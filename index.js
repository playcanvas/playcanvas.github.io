var e={exports:{}},t={},n=Object.getOwnPropertySymbols,a=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;function s(e){if(null==e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}var r=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var t={},n=0;n<10;n++)t["_"+String.fromCharCode(n)]=n;var a=Object.getOwnPropertyNames(t).map((function(e){return t[e]}));if("0123456789"!==a.join(""))return!1;var i={};return"abcdefghijklmnopqrst".split("").forEach((function(e){i[e]=e})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},i)).join("")}catch(e){return!1}}()?Object.assign:function(e,t){for(var r,o,l=s(e),c=1;c<arguments.length;c++){for(var h in r=Object(arguments[c]))a.call(r,h)&&(l[h]=r[h]);if(n){o=n(r);for(var d=0;d<o.length;d++)i.call(r,o[d])&&(l[o[d]]=r[o[d]])}}return l},o=r,l=60103,c=60106;
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */t.Fragment=60107,t.StrictMode=60108,t.Profiler=60114;var h=60109,d=60110,p=60112;t.Suspense=60113;var u=60115,m=60116;if("function"==typeof Symbol&&Symbol.for){var f=Symbol.for;l=f("react.element"),c=f("react.portal"),t.Fragment=f("react.fragment"),t.StrictMode=f("react.strict_mode"),t.Profiler=f("react.profiler"),h=f("react.provider"),d=f("react.context"),p=f("react.forward_ref"),t.Suspense=f("react.suspense"),u=f("react.memo"),m=f("react.lazy")}var g="function"==typeof Symbol&&Symbol.iterator;function y(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var b={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},v={};function _(e,t,n){this.props=e,this.context=t,this.refs=v,this.updater=n||b}function w(){}function x(e,t,n){this.props=e,this.context=t,this.refs=v,this.updater=n||b}_.prototype.isReactComponent={},_.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error(y(85));this.updater.enqueueSetState(this,e,t,"setState")},_.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},w.prototype=_.prototype;var C=x.prototype=new w;C.constructor=x,o(C,_.prototype),C.isPureReactComponent=!0;var T={current:null},E=Object.prototype.hasOwnProperty,S={key:!0,ref:!0,__self:!0,__source:!0};function A(e,t,n){var a,i={},s=null,r=null;if(null!=t)for(a in void 0!==t.ref&&(r=t.ref),void 0!==t.key&&(s=""+t.key),t)E.call(t,a)&&!S.hasOwnProperty(a)&&(i[a]=t[a]);var o=arguments.length-2;if(1===o)i.children=n;else if(1<o){for(var c=Array(o),h=0;h<o;h++)c[h]=arguments[h+2];i.children=c}if(e&&e.defaultProps)for(a in o=e.defaultProps)void 0===i[a]&&(i[a]=o[a]);return{$$typeof:l,type:e,key:s,ref:r,props:i,_owner:T.current}}function M(e){return"object"==typeof e&&null!==e&&e.$$typeof===l}var L=/\/+/g;function R(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function I(e,t,n,a,i){var s=typeof e;"undefined"!==s&&"boolean"!==s||(e=null);var r=!1;if(null===e)r=!0;else switch(s){case"string":case"number":r=!0;break;case"object":switch(e.$$typeof){case l:case c:r=!0}}if(r)return i=i(r=e),e=""===a?"."+R(r,0):a,Array.isArray(i)?(n="",null!=e&&(n=e.replace(L,"$&/")+"/"),I(i,t,n,"",(function(e){return e}))):null!=i&&(M(i)&&(i=function(e,t){return{$$typeof:l,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(i,n+(!i.key||r&&r.key===i.key?"":(""+i.key).replace(L,"$&/")+"/")+e)),t.push(i)),1;if(r=0,a=""===a?".":a+":",Array.isArray(e))for(var o=0;o<e.length;o++){var h=a+R(s=e[o],o);r+=I(s,t,n,h,i)}else if(h=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=g&&e[g]||e["@@iterator"])?e:null}(e),"function"==typeof h)for(e=h.call(e),o=0;!(s=e.next()).done;)r+=I(s=s.value,t,n,h=a+R(s,o++),i);else if("object"===s)throw t=""+e,Error(y(31,"[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t));return r}function P(e,t,n){if(null==e)return e;var a=[],i=0;return I(e,a,"","",(function(e){return t.call(n,e,i++)})),a}function k(e){if(-1===e._status){var t=e._result;t=t(),e._status=0,e._result=t,t.then((function(t){0===e._status&&(t=t.default,e._status=1,e._result=t)}),(function(t){0===e._status&&(e._status=2,e._result=t)}))}if(1===e._status)return e._result;throw e._result}var D={current:null};function O(){var e=D.current;if(null===e)throw Error(y(321));return e}var F={ReactCurrentDispatcher:D,ReactCurrentBatchConfig:{transition:0},ReactCurrentOwner:T,IsSomeRendererActing:{current:!1},assign:o};t.Children={map:P,forEach:function(e,t,n){P(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return P(e,(function(){t++})),t},toArray:function(e){return P(e,(function(e){return e}))||[]},only:function(e){if(!M(e))throw Error(y(143));return e}},t.Component=_,t.PureComponent=x,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=F,t.cloneElement=function(e,t,n){if(null==e)throw Error(y(267,e));var a=o({},e.props),i=e.key,s=e.ref,r=e._owner;if(null!=t){if(void 0!==t.ref&&(s=t.ref,r=T.current),void 0!==t.key&&(i=""+t.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(h in t)E.call(t,h)&&!S.hasOwnProperty(h)&&(a[h]=void 0===t[h]&&void 0!==c?c[h]:t[h])}var h=arguments.length-2;if(1===h)a.children=n;else if(1<h){c=Array(h);for(var d=0;d<h;d++)c[d]=arguments[d+2];a.children=c}return{$$typeof:l,type:e.type,key:i,ref:s,props:a,_owner:r}},t.createContext=function(e,t){return void 0===t&&(t=null),(e={$$typeof:d,_calculateChangedBits:t,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider={$$typeof:h,_context:e},e.Consumer=e},t.createElement=A,t.createFactory=function(e){var t=A.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:p,render:e}},t.isValidElement=M,t.lazy=function(e){return{$$typeof:m,_payload:{_status:-1,_result:e},_init:k}},t.memo=function(e,t){return{$$typeof:u,type:e,compare:void 0===t?null:t}},t.useCallback=function(e,t){return O().useCallback(e,t)},t.useContext=function(e,t){return O().useContext(e,t)},t.useDebugValue=function(){},t.useEffect=function(e,t){return O().useEffect(e,t)},t.useImperativeHandle=function(e,t,n){return O().useImperativeHandle(e,t,n)},t.useLayoutEffect=function(e,t){return O().useLayoutEffect(e,t)},t.useMemo=function(e,t){return O().useMemo(e,t)},t.useReducer=function(e,t,n){return O().useReducer(e,t,n)},t.useRef=function(e){return O().useRef(e)},t.useState=function(e){return O().useState(e)},t.version="17.0.2",e.exports=t;var N=e.exports,V={exports:{}},B={},U={exports:{}},z={};
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
!function(e){var t,n,a,i;if("object"==typeof performance&&"function"==typeof performance.now){var s=performance;e.unstable_now=function(){return s.now()}}else{var r=Date,o=r.now();e.unstable_now=function(){return r.now()-o}}if("undefined"==typeof window||"function"!=typeof MessageChannel){var l=null,c=null,h=function(){if(null!==l)try{var t=e.unstable_now();l(!0,t),l=null}catch(e){throw setTimeout(h,0),e}};t=function(e){null!==l?setTimeout(t,0,e):(l=e,setTimeout(h,0))},n=function(e,t){c=setTimeout(e,t)},a=function(){clearTimeout(c)},e.unstable_shouldYield=function(){return!1},i=e.unstable_forceFrameRate=function(){}}else{var d=window.setTimeout,p=window.clearTimeout;if("undefined"!=typeof console){var u=window.cancelAnimationFrame;"function"!=typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"),"function"!=typeof u&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")}var m=!1,f=null,g=-1,y=5,b=0;e.unstable_shouldYield=function(){return e.unstable_now()>=b},i=function(){},e.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):y=0<e?Math.floor(1e3/e):5};var v=new MessageChannel,_=v.port2;v.port1.onmessage=function(){if(null!==f){var t=e.unstable_now();b=t+y;try{f(!0,t)?_.postMessage(null):(m=!1,f=null)}catch(e){throw _.postMessage(null),e}}else m=!1},t=function(e){f=e,m||(m=!0,_.postMessage(null))},n=function(t,n){g=d((function(){t(e.unstable_now())}),n)},a=function(){p(g),g=-1}}function w(e,t){var n=e.length;e.push(t);e:for(;;){var a=n-1>>>1,i=e[a];if(!(void 0!==i&&0<T(i,t)))break e;e[a]=t,e[n]=i,n=a}}function x(e){return void 0===(e=e[0])?null:e}function C(e){var t=e[0];if(void 0!==t){var n=e.pop();if(n!==t){e[0]=n;e:for(var a=0,i=e.length;a<i;){var s=2*(a+1)-1,r=e[s],o=s+1,l=e[o];if(void 0!==r&&0>T(r,n))void 0!==l&&0>T(l,r)?(e[a]=l,e[o]=n,a=o):(e[a]=r,e[s]=n,a=s);else{if(!(void 0!==l&&0>T(l,n)))break e;e[a]=l,e[o]=n,a=o}}}return t}return null}function T(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}var E=[],S=[],A=1,M=null,L=3,R=!1,I=!1,P=!1;function k(e){for(var t=x(S);null!==t;){if(null===t.callback)C(S);else{if(!(t.startTime<=e))break;C(S),t.sortIndex=t.expirationTime,w(E,t)}t=x(S)}}function D(e){if(P=!1,k(e),!I)if(null!==x(E))I=!0,t(O);else{var a=x(S);null!==a&&n(D,a.startTime-e)}}function O(t,i){I=!1,P&&(P=!1,a()),R=!0;var s=L;try{for(k(i),M=x(E);null!==M&&(!(M.expirationTime>i)||t&&!e.unstable_shouldYield());){var r=M.callback;if("function"==typeof r){M.callback=null,L=M.priorityLevel;var o=r(M.expirationTime<=i);i=e.unstable_now(),"function"==typeof o?M.callback=o:M===x(E)&&C(E),k(i)}else C(E);M=x(E)}if(null!==M)var l=!0;else{var c=x(S);null!==c&&n(D,c.startTime-i),l=!1}return l}finally{M=null,L=s,R=!1}}var F=i;e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(e){e.callback=null},e.unstable_continueExecution=function(){I||R||(I=!0,t(O))},e.unstable_getCurrentPriorityLevel=function(){return L},e.unstable_getFirstCallbackNode=function(){return x(E)},e.unstable_next=function(e){switch(L){case 1:case 2:case 3:var t=3;break;default:t=L}var n=L;L=t;try{return e()}finally{L=n}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=F,e.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=L;L=e;try{return t()}finally{L=n}},e.unstable_scheduleCallback=function(i,s,r){var o=e.unstable_now();switch("object"==typeof r&&null!==r?r="number"==typeof(r=r.delay)&&0<r?o+r:o:r=o,i){case 1:var l=-1;break;case 2:l=250;break;case 5:l=1073741823;break;case 4:l=1e4;break;default:l=5e3}return i={id:A++,callback:s,priorityLevel:i,startTime:r,expirationTime:l=r+l,sortIndex:-1},r>o?(i.sortIndex=r,w(S,i),null===x(E)&&i===x(S)&&(P?a():P=!0,n(D,r-o))):(i.sortIndex=l,w(E,i),I||R||(I=!0,t(O))),i},e.unstable_wrapCallback=function(e){var t=L;return function(){var n=L;L=t;try{return e.apply(this,arguments)}finally{L=n}}}}(z),U.exports=z;
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var G=e.exports,H=r,W=U.exports;function j(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!G)throw Error(j(227));var X=new Set,Y={};function q(e,t){K(e,t),K(e+"Capture",t)}function K(e,t){for(Y[e]=t,e=0;e<t.length;e++)X.add(t[e])}var Z=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement),$=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Q=Object.prototype.hasOwnProperty,J={},ee={};function te(e,t,n,a,i,s,r){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=a,this.attributeNamespace=i,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=s,this.removeEmptyString=r}var ne={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){ne[e]=new te(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];ne[t]=new te(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){ne[e]=new te(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){ne[e]=new te(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){ne[e]=new te(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){ne[e]=new te(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){ne[e]=new te(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){ne[e]=new te(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){ne[e]=new te(e,5,!1,e.toLowerCase(),null,!1,!1)}));var ae=/[\-:]([a-z])/g;function ie(e){return e[1].toUpperCase()}function se(e,t,n,a){var i=ne.hasOwnProperty(t)?ne[t]:null;(null!==i?0===i.type:!a&&(2<t.length&&("o"===t[0]||"O"===t[0])&&("n"===t[1]||"N"===t[1])))||(function(e,t,n,a){if(null==t||function(e,t,n,a){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!a&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,a))return!0;if(a)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,i,a)&&(n=null),a||null===i?function(e){return!!Q.call(ee,e)||!Q.call(J,e)&&($.test(e)?ee[e]=!0:(J[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):i.mustUseProperty?e[i.propertyName]=null===n?3!==i.type&&"":n:(t=i.attributeName,a=i.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(i=i.type)||4===i&&!0===n?"":""+n,a?e.setAttributeNS(a,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(ae,ie);ne[t]=new te(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(ae,ie);ne[t]=new te(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(ae,ie);ne[t]=new te(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){ne[e]=new te(e,1,!1,e.toLowerCase(),null,!1,!1)})),ne.xlinkHref=new te("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){ne[e]=new te(e,1,!1,e.toLowerCase(),null,!0,!0)}));var re=G.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,oe=60103,le=60106,ce=60107,he=60108,de=60114,pe=60109,ue=60110,me=60112,fe=60113,ge=60120,ye=60115,be=60116,ve=60121,_e=60128,we=60129,xe=60130,Ce=60131;if("function"==typeof Symbol&&Symbol.for){var Te=Symbol.for;oe=Te("react.element"),le=Te("react.portal"),ce=Te("react.fragment"),he=Te("react.strict_mode"),de=Te("react.profiler"),pe=Te("react.provider"),ue=Te("react.context"),me=Te("react.forward_ref"),fe=Te("react.suspense"),ge=Te("react.suspense_list"),ye=Te("react.memo"),be=Te("react.lazy"),ve=Te("react.block"),Te("react.scope"),_e=Te("react.opaque.id"),we=Te("react.debug_trace_mode"),xe=Te("react.offscreen"),Ce=Te("react.legacy_hidden")}var Ee,Se="function"==typeof Symbol&&Symbol.iterator;function Ae(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=Se&&e[Se]||e["@@iterator"])?e:null}function Me(e){if(void 0===Ee)try{throw Error()}catch(e){var t=e.stack.trim().match(/\n( *(at )?)/);Ee=t&&t[1]||""}return"\n"+Ee+e}var Le=!1;function Re(e,t){if(!e||Le)return"";Le=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"==typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(e){var a=e}Reflect.construct(e,[],t)}else{try{t.call()}catch(e){a=e}e.call(t.prototype)}else{try{throw Error()}catch(e){a=e}e()}}catch(e){if(e&&a&&"string"==typeof e.stack){for(var i=e.stack.split("\n"),s=a.stack.split("\n"),r=i.length-1,o=s.length-1;1<=r&&0<=o&&i[r]!==s[o];)o--;for(;1<=r&&0<=o;r--,o--)if(i[r]!==s[o]){if(1!==r||1!==o)do{if(r--,0>--o||i[r]!==s[o])return"\n"+i[r].replace(" at new "," at ")}while(1<=r&&0<=o);break}}}finally{Le=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?Me(e):""}function Ie(e){switch(e.tag){case 5:return Me(e.type);case 16:return Me("Lazy");case 13:return Me("Suspense");case 19:return Me("SuspenseList");case 0:case 2:case 15:return e=Re(e.type,!1);case 11:return e=Re(e.type.render,!1);case 22:return e=Re(e.type._render,!1);case 1:return e=Re(e.type,!0);default:return""}}function Pe(e){if(null==e)return null;if("function"==typeof e)return e.displayName||e.name||null;if("string"==typeof e)return e;switch(e){case ce:return"Fragment";case le:return"Portal";case de:return"Profiler";case he:return"StrictMode";case fe:return"Suspense";case ge:return"SuspenseList"}if("object"==typeof e)switch(e.$$typeof){case ue:return(e.displayName||"Context")+".Consumer";case pe:return(e._context.displayName||"Context")+".Provider";case me:var t=e.render;return t=t.displayName||t.name||"",e.displayName||(""!==t?"ForwardRef("+t+")":"ForwardRef");case ye:return Pe(e.type);case ve:return Pe(e._render);case be:t=e._payload,e=e._init;try{return Pe(e(t))}catch(e){}}return null}function ke(e){switch(typeof e){case"boolean":case"number":case"object":case"string":case"undefined":return e;default:return""}}function De(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function Oe(e){e._valueTracker||(e._valueTracker=function(e){var t=De(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),a=""+e[t];if(!e.hasOwnProperty(t)&&void 0!==n&&"function"==typeof n.get&&"function"==typeof n.set){var i=n.get,s=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return i.call(this)},set:function(e){a=""+e,s.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return a},setValue:function(e){a=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function Fe(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),a="";return e&&(a=De(e)?e.checked?"true":"false":e.value),(e=a)!==n&&(t.setValue(e),!0)}function Ne(e){if(void 0===(e=e||("undefined"!=typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function Ve(e,t){var n=t.checked;return H({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Be(e,t){var n=null==t.defaultValue?"":t.defaultValue,a=null!=t.checked?t.checked:t.defaultChecked;n=ke(null!=t.value?t.value:n),e._wrapperState={initialChecked:a,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function Ue(e,t){null!=(t=t.checked)&&se(e,"checked",t,!1)}function ze(e,t){Ue(e,t);var n=ke(t.value),a=t.type;if(null!=n)"number"===a?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===a||"reset"===a)return void e.removeAttribute("value");t.hasOwnProperty("value")?He(e,t.type,n):t.hasOwnProperty("defaultValue")&&He(e,t.type,ke(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function Ge(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var a=t.type;if(!("submit"!==a&&"reset"!==a||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function He(e,t,n){"number"===t&&Ne(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}function We(e,t){return e=H({children:void 0},t),(t=function(e){var t="";return G.Children.forEach(e,(function(e){null!=e&&(t+=e)})),t}(t.children))&&(e.children=t),e}function je(e,t,n,a){if(e=e.options,t){t={};for(var i=0;i<n.length;i++)t["$"+n[i]]=!0;for(n=0;n<e.length;n++)i=t.hasOwnProperty("$"+e[n].value),e[n].selected!==i&&(e[n].selected=i),i&&a&&(e[n].defaultSelected=!0)}else{for(n=""+ke(n),t=null,i=0;i<e.length;i++){if(e[i].value===n)return e[i].selected=!0,void(a&&(e[i].defaultSelected=!0));null!==t||e[i].disabled||(t=e[i])}null!==t&&(t.selected=!0)}}function Xe(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(j(91));return H({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function Ye(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(j(92));if(Array.isArray(n)){if(!(1>=n.length))throw Error(j(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:ke(n)}}function qe(e,t){var n=ke(t.value),a=ke(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=a&&(e.defaultValue=""+a)}function Ke(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}var Ze="http://www.w3.org/1999/xhtml",$e="http://www.w3.org/2000/svg";function Qe(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Je(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?Qe(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var et,tt,nt=(tt=function(e,t){if(e.namespaceURI!==$e||"innerHTML"in e)e.innerHTML=t;else{for((et=et||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=et.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!=typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,a){MSApp.execUnsafeLocalFunction((function(){return tt(e,t)}))}:tt);function at(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var it={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},st=["Webkit","ms","Moz","O"];function rt(e,t,n){return null==t||"boolean"==typeof t||""===t?"":n||"number"!=typeof t||0===t||it.hasOwnProperty(e)&&it[e]?(""+t).trim():t+"px"}function ot(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var a=0===n.indexOf("--"),i=rt(n,t[n],a);"float"===n&&(n="cssFloat"),a?e.setProperty(n,i):e[n]=i}}Object.keys(it).forEach((function(e){st.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),it[t]=it[e]}))}));var lt=H({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ct(e,t){if(t){if(lt[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(j(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(j(60));if("object"!=typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(j(61))}if(null!=t.style&&"object"!=typeof t.style)throw Error(j(62))}}function ht(e,t){if(-1===e.indexOf("-"))return"string"==typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}function dt(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var pt=null,ut=null,mt=null;function ft(e){if(e=Gi(e)){if("function"!=typeof pt)throw Error(j(280));var t=e.stateNode;t&&(t=Wi(t),pt(e.stateNode,e.type,t))}}function gt(e){ut?mt?mt.push(e):mt=[e]:ut=e}function yt(){if(ut){var e=ut,t=mt;if(mt=ut=null,ft(e),t)for(e=0;e<t.length;e++)ft(t[e])}}function bt(e,t){return e(t)}function vt(e,t,n,a,i){return e(t,n,a,i)}function _t(){}var wt=bt,xt=!1,Ct=!1;function Tt(){null===ut&&null===mt||(_t(),yt())}function Et(e,t){var n=e.stateNode;if(null===n)return null;var a=Wi(n);if(null===a)return null;n=a[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(a=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!a;break e;default:e=!1}if(e)return null;if(n&&"function"!=typeof n)throw Error(j(231,t,typeof n));return n}var St=!1;if(Z)try{var At={};Object.defineProperty(At,"passive",{get:function(){St=!0}}),window.addEventListener("test",At,At),window.removeEventListener("test",At,At)}catch(tt){St=!1}function Mt(e,t,n,a,i,s,r,o,l){var c=Array.prototype.slice.call(arguments,3);try{t.apply(n,c)}catch(e){this.onError(e)}}var Lt=!1,Rt=null,It=!1,Pt=null,kt={onError:function(e){Lt=!0,Rt=e}};function Dt(e,t,n,a,i,s,r,o,l){Lt=!1,Rt=null,Mt.apply(kt,arguments)}function Ot(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!=(1026&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ft(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function Nt(e){if(Ot(e)!==e)throw Error(j(188))}function Vt(e){if(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ot(e)))throw Error(j(188));return t!==e?null:e}for(var n=e,a=t;;){var i=n.return;if(null===i)break;var s=i.alternate;if(null===s){if(null!==(a=i.return)){n=a;continue}break}if(i.child===s.child){for(s=i.child;s;){if(s===n)return Nt(i),e;if(s===a)return Nt(i),t;s=s.sibling}throw Error(j(188))}if(n.return!==a.return)n=i,a=s;else{for(var r=!1,o=i.child;o;){if(o===n){r=!0,n=i,a=s;break}if(o===a){r=!0,a=i,n=s;break}o=o.sibling}if(!r){for(o=s.child;o;){if(o===n){r=!0,n=s,a=i;break}if(o===a){r=!0,a=s,n=i;break}o=o.sibling}if(!r)throw Error(j(189))}}if(n.alternate!==a)throw Error(j(190))}if(3!==n.tag)throw Error(j(188));return n.stateNode.current===n?e:t}(e),!e)return null;for(var t=e;;){if(5===t.tag||6===t.tag)return t;if(t.child)t.child.return=t,t=t.child;else{if(t===e)break;for(;!t.sibling;){if(!t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}}return null}function Bt(e,t){for(var n=e.alternate;null!==t;){if(t===e||t===n)return!0;t=t.return}return!1}var Ut,zt,Gt,Ht,Wt=!1,jt=[],Xt=null,Yt=null,qt=null,Kt=new Map,Zt=new Map,$t=[],Qt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Jt(e,t,n,a,i){return{blockedOn:e,domEventName:t,eventSystemFlags:16|n,nativeEvent:i,targetContainers:[a]}}function en(e,t){switch(e){case"focusin":case"focusout":Xt=null;break;case"dragenter":case"dragleave":Yt=null;break;case"mouseover":case"mouseout":qt=null;break;case"pointerover":case"pointerout":Kt.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Zt.delete(t.pointerId)}}function tn(e,t,n,a,i,s){return null===e||e.nativeEvent!==s?(e=Jt(t,n,a,i,s),null!==t&&(null!==(t=Gi(t))&&zt(t)),e):(e.eventSystemFlags|=a,t=e.targetContainers,null!==i&&-1===t.indexOf(i)&&t.push(i),e)}function nn(e){var t=zi(e.target);if(null!==t){var n=Ot(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ft(n)))return e.blockedOn=t,void Ht(e.lanePriority,(function(){W.unstable_runWithPriority(e.priority,(function(){Gt(n)}))}))}else if(3===t&&n.stateNode.hydrate)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function an(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Bn(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=Gi(n))&&zt(t),e.blockedOn=n,!1;t.shift()}return!0}function sn(e,t,n){an(e)&&n.delete(t)}function rn(){for(Wt=!1;0<jt.length;){var e=jt[0];if(null!==e.blockedOn){null!==(e=Gi(e.blockedOn))&&Ut(e);break}for(var t=e.targetContainers;0<t.length;){var n=Bn(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n){e.blockedOn=n;break}t.shift()}null===e.blockedOn&&jt.shift()}null!==Xt&&an(Xt)&&(Xt=null),null!==Yt&&an(Yt)&&(Yt=null),null!==qt&&an(qt)&&(qt=null),Kt.forEach(sn),Zt.forEach(sn)}function on(e,t){e.blockedOn===t&&(e.blockedOn=null,Wt||(Wt=!0,W.unstable_scheduleCallback(W.unstable_NormalPriority,rn)))}function ln(e){function t(t){return on(t,e)}if(0<jt.length){on(jt[0],e);for(var n=1;n<jt.length;n++){var a=jt[n];a.blockedOn===e&&(a.blockedOn=null)}}for(null!==Xt&&on(Xt,e),null!==Yt&&on(Yt,e),null!==qt&&on(qt,e),Kt.forEach(t),Zt.forEach(t),n=0;n<$t.length;n++)(a=$t[n]).blockedOn===e&&(a.blockedOn=null);for(;0<$t.length&&null===(n=$t[0]).blockedOn;)nn(n),null===n.blockedOn&&$t.shift()}function cn(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var hn={animationend:cn("Animation","AnimationEnd"),animationiteration:cn("Animation","AnimationIteration"),animationstart:cn("Animation","AnimationStart"),transitionend:cn("Transition","TransitionEnd")},dn={},pn={};function un(e){if(dn[e])return dn[e];if(!hn[e])return e;var t,n=hn[e];for(t in n)if(n.hasOwnProperty(t)&&t in pn)return dn[e]=n[t];return e}Z&&(pn=document.createElement("div").style,"AnimationEvent"in window||(delete hn.animationend.animation,delete hn.animationiteration.animation,delete hn.animationstart.animation),"TransitionEvent"in window||delete hn.transitionend.transition);var mn=un("animationend"),fn=un("animationiteration"),gn=un("animationstart"),yn=un("transitionend"),bn=new Map,vn=new Map,_n=["abort","abort",mn,"animationEnd",fn,"animationIteration",gn,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",yn,"transitionEnd","waiting","waiting"];function wn(e,t){for(var n=0;n<e.length;n+=2){var a=e[n],i=e[n+1];i="on"+(i[0].toUpperCase()+i.slice(1)),vn.set(a,t),bn.set(a,i),q(i,[a])}}(0,W.unstable_now)();var xn=8;function Cn(e){if(0!=(1&e))return xn=15,1;if(0!=(2&e))return xn=14,2;if(0!=(4&e))return xn=13,4;var t=24&e;return 0!==t?(xn=12,t):0!=(32&e)?(xn=11,32):0!==(t=192&e)?(xn=10,t):0!=(256&e)?(xn=9,256):0!==(t=3584&e)?(xn=8,t):0!=(4096&e)?(xn=7,4096):0!==(t=4186112&e)?(xn=6,t):0!==(t=62914560&e)?(xn=5,t):67108864&e?(xn=4,67108864):0!=(134217728&e)?(xn=3,134217728):0!==(t=805306368&e)?(xn=2,t):0!=(1073741824&e)?(xn=1,1073741824):(xn=8,e)}function Tn(e,t){var n=e.pendingLanes;if(0===n)return xn=0;var a=0,i=0,s=e.expiredLanes,r=e.suspendedLanes,o=e.pingedLanes;if(0!==s)a=s,i=xn=15;else if(0!==(s=134217727&n)){var l=s&~r;0!==l?(a=Cn(l),i=xn):0!==(o&=s)&&(a=Cn(o),i=xn)}else 0!==(s=n&~r)?(a=Cn(s),i=xn):0!==o&&(a=Cn(o),i=xn);if(0===a)return 0;if(a=n&((0>(a=31-Rn(a))?0:1<<a)<<1)-1,0!==t&&t!==a&&0==(t&r)){if(Cn(t),i<=xn)return t;xn=i}if(0!==(t=e.entangledLanes))for(e=e.entanglements,t&=a;0<t;)i=1<<(n=31-Rn(t)),a|=e[n],t&=~i;return a}function En(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function Sn(e,t){switch(e){case 15:return 1;case 14:return 2;case 12:return 0===(e=An(24&~t))?Sn(10,t):e;case 10:return 0===(e=An(192&~t))?Sn(8,t):e;case 8:return 0===(e=An(3584&~t))&&(0===(e=An(4186112&~t))&&(e=512)),e;case 2:return 0===(t=An(805306368&~t))&&(t=268435456),t}throw Error(j(358,e))}function An(e){return e&-e}function Mn(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function Ln(e,t,n){e.pendingLanes|=t;var a=t-1;e.suspendedLanes&=a,e.pingedLanes&=a,(e=e.eventTimes)[t=31-Rn(t)]=n}var Rn=Math.clz32?Math.clz32:function(e){return 0===e?32:31-(In(e)/Pn|0)|0},In=Math.log,Pn=Math.LN2;var kn=W.unstable_UserBlockingPriority,Dn=W.unstable_runWithPriority,On=!0;function Fn(e,t,n,a){xt||_t();var i=Vn,s=xt;xt=!0;try{vt(i,e,t,n,a)}finally{(xt=s)||Tt()}}function Nn(e,t,n,a){Dn(kn,Vn.bind(null,e,t,n,a))}function Vn(e,t,n,a){var i;if(On)if((i=0==(4&t))&&0<jt.length&&-1<Qt.indexOf(e))e=Jt(null,e,t,n,a),jt.push(e);else{var s=Bn(e,t,n,a);if(null===s)i&&en(e,a);else{if(i){if(-1<Qt.indexOf(e))return e=Jt(s,e,t,n,a),void jt.push(e);if(function(e,t,n,a,i){switch(t){case"focusin":return Xt=tn(Xt,e,t,n,a,i),!0;case"dragenter":return Yt=tn(Yt,e,t,n,a,i),!0;case"mouseover":return qt=tn(qt,e,t,n,a,i),!0;case"pointerover":var s=i.pointerId;return Kt.set(s,tn(Kt.get(s)||null,e,t,n,a,i)),!0;case"gotpointercapture":return s=i.pointerId,Zt.set(s,tn(Zt.get(s)||null,e,t,n,a,i)),!0}return!1}(s,e,t,n,a))return;en(e,a)}_i(e,t,a,null,n)}}}function Bn(e,t,n,a){var i=dt(a);if(null!==(i=zi(i))){var s=Ot(i);if(null===s)i=null;else{var r=s.tag;if(13===r){if(null!==(i=Ft(s)))return i;i=null}else if(3===r){if(s.stateNode.hydrate)return 3===s.tag?s.stateNode.containerInfo:null;i=null}else s!==i&&(i=null)}}return _i(e,t,a,i,n),null}var Un=null,zn=null,Gn=null;function Hn(){if(Gn)return Gn;var e,t,n=zn,a=n.length,i="value"in Un?Un.value:Un.textContent,s=i.length;for(e=0;e<a&&n[e]===i[e];e++);var r=a-e;for(t=1;t<=r&&n[a-t]===i[s-t];t++);return Gn=i.slice(e,1<t?1-t:void 0)}function Wn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function jn(){return!0}function Xn(){return!1}function Yn(e){function t(t,n,a,i,s){for(var r in this._reactName=t,this._targetInst=a,this.type=n,this.nativeEvent=i,this.target=s,this.currentTarget=null,e)e.hasOwnProperty(r)&&(t=e[r],this[r]=t?t(i):i[r]);return this.isDefaultPrevented=(null!=i.defaultPrevented?i.defaultPrevented:!1===i.returnValue)?jn:Xn,this.isPropagationStopped=Xn,this}return H(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!=typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=jn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!=typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=jn)},persist:function(){},isPersistent:jn}),t}var qn,Kn,Zn,$n={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Qn=Yn($n),Jn=H({},$n,{view:0,detail:0}),ea=Yn(Jn),ta=H({},Jn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:ua,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==Zn&&(Zn&&"mousemove"===e.type?(qn=e.screenX-Zn.screenX,Kn=e.screenY-Zn.screenY):Kn=qn=0,Zn=e),qn)},movementY:function(e){return"movementY"in e?e.movementY:Kn}}),na=Yn(ta),aa=Yn(H({},ta,{dataTransfer:0})),ia=Yn(H({},Jn,{relatedTarget:0})),sa=Yn(H({},$n,{animationName:0,elapsedTime:0,pseudoElement:0})),ra=H({},$n,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),oa=Yn(ra),la=Yn(H({},$n,{data:0})),ca={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},ha={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},da={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function pa(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=da[e])&&!!t[e]}function ua(){return pa}var ma=H({},Jn,{key:function(e){if(e.key){var t=ca[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=Wn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?ha[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:ua,charCode:function(e){return"keypress"===e.type?Wn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?Wn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),fa=Yn(ma),ga=Yn(H({},ta,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),ya=Yn(H({},Jn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:ua})),ba=Yn(H({},$n,{propertyName:0,elapsedTime:0,pseudoElement:0})),va=H({},ta,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),_a=Yn(va),wa=[9,13,27,32],xa=Z&&"CompositionEvent"in window,Ca=null;Z&&"documentMode"in document&&(Ca=document.documentMode);var Ta=Z&&"TextEvent"in window&&!Ca,Ea=Z&&(!xa||Ca&&8<Ca&&11>=Ca),Sa=String.fromCharCode(32),Aa=!1;function Ma(e,t){switch(e){case"keyup":return-1!==wa.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function La(e){return"object"==typeof(e=e.detail)&&"data"in e?e.data:null}var Ra=!1;var Ia={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Pa(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Ia[e.type]:"textarea"===t}function ka(e,t,n,a){gt(a),0<(t=xi(t,"onChange")).length&&(n=new Qn("onChange","change",null,n,a),e.push({event:n,listeners:t}))}var Da=null,Oa=null;function Fa(e){mi(e,0)}function Na(e){if(Fe(Hi(e)))return e}function Va(e,t){if("change"===e)return t}var Ba=!1;if(Z){var Ua;if(Z){var za="oninput"in document;if(!za){var Ga=document.createElement("div");Ga.setAttribute("oninput","return;"),za="function"==typeof Ga.oninput}Ua=za}else Ua=!1;Ba=Ua&&(!document.documentMode||9<document.documentMode)}function Ha(){Da&&(Da.detachEvent("onpropertychange",Wa),Oa=Da=null)}function Wa(e){if("value"===e.propertyName&&Na(Oa)){var t=[];if(ka(t,Oa,e,dt(e)),e=Fa,xt)e(t);else{xt=!0;try{bt(e,t)}finally{xt=!1,Tt()}}}}function ja(e,t,n){"focusin"===e?(Ha(),Oa=n,(Da=t).attachEvent("onpropertychange",Wa)):"focusout"===e&&Ha()}function Xa(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Na(Oa)}function Ya(e,t){if("click"===e)return Na(t)}function qa(e,t){if("input"===e||"change"===e)return Na(t)}var Ka="function"==typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e==1/t)||e!=e&&t!=t},Za=Object.prototype.hasOwnProperty;function $a(e,t){if(Ka(e,t))return!0;if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;var n=Object.keys(e),a=Object.keys(t);if(n.length!==a.length)return!1;for(a=0;a<n.length;a++)if(!Za.call(t,n[a])||!Ka(e[n[a]],t[n[a]]))return!1;return!0}function Qa(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function Ja(e,t){var n,a=Qa(e);for(e=0;a;){if(3===a.nodeType){if(n=e+a.textContent.length,e<=t&&n>=t)return{node:a,offset:t-e};e=n}e:{for(;a;){if(a.nextSibling){a=a.nextSibling;break e}a=a.parentNode}a=void 0}a=Qa(a)}}function ei(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?ei(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function ti(){for(var e=window,t=Ne();t instanceof e.HTMLIFrameElement;){try{var n="string"==typeof t.contentWindow.location.href}catch(e){n=!1}if(!n)break;t=Ne((e=t.contentWindow).document)}return t}function ni(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}var ai=Z&&"documentMode"in document&&11>=document.documentMode,ii=null,si=null,ri=null,oi=!1;function li(e,t,n){var a=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;oi||null==ii||ii!==Ne(a)||("selectionStart"in(a=ii)&&ni(a)?a={start:a.selectionStart,end:a.selectionEnd}:a={anchorNode:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset},ri&&$a(ri,a)||(ri=a,0<(a=xi(si,"onSelect")).length&&(t=new Qn("onSelect","select",null,t,n),e.push({event:t,listeners:a}),t.target=ii)))}wn("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0),wn("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1),wn(_n,2);for(var ci="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),hi=0;hi<ci.length;hi++)vn.set(ci[hi],0);K("onMouseEnter",["mouseout","mouseover"]),K("onMouseLeave",["mouseout","mouseover"]),K("onPointerEnter",["pointerout","pointerover"]),K("onPointerLeave",["pointerout","pointerover"]),q("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),q("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),q("onBeforeInput",["compositionend","keypress","textInput","paste"]),q("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),q("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),q("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var di="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),pi=new Set("cancel close invalid load scroll toggle".split(" ").concat(di));function ui(e,t,n){var a=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,a,i,s,r,o,l){if(Dt.apply(this,arguments),Lt){if(!Lt)throw Error(j(198));var c=Rt;Lt=!1,Rt=null,It||(It=!0,Pt=c)}}(a,t,void 0,e),e.currentTarget=null}function mi(e,t){t=0!=(4&t);for(var n=0;n<e.length;n++){var a=e[n],i=a.event;a=a.listeners;e:{var s=void 0;if(t)for(var r=a.length-1;0<=r;r--){var o=a[r],l=o.instance,c=o.currentTarget;if(o=o.listener,l!==s&&i.isPropagationStopped())break e;ui(i,o,c),s=l}else for(r=0;r<a.length;r++){if(l=(o=a[r]).instance,c=o.currentTarget,o=o.listener,l!==s&&i.isPropagationStopped())break e;ui(i,o,c),s=l}}}if(It)throw e=Pt,It=!1,Pt=null,e}function fi(e,t){var n=ji(t),a=e+"__bubble";n.has(a)||(vi(t,e,2,!1),n.add(a))}var gi="_reactListening"+Math.random().toString(36).slice(2);function yi(e){e[gi]||(e[gi]=!0,X.forEach((function(t){pi.has(t)||bi(t,!1,e,null),bi(t,!0,e,null)})))}function bi(e,t,n,a){var i=4<arguments.length&&void 0!==arguments[4]?arguments[4]:0,s=n;if("selectionchange"===e&&9!==n.nodeType&&(s=n.ownerDocument),null!==a&&!t&&pi.has(e)){if("scroll"!==e)return;i|=2,s=a}var r=ji(s),o=e+"__"+(t?"capture":"bubble");r.has(o)||(t&&(i|=4),vi(s,e,i,t),r.add(o))}function vi(e,t,n,a){var i=vn.get(t);switch(void 0===i?2:i){case 0:i=Fn;break;case 1:i=Nn;break;default:i=Vn}n=i.bind(null,t,n,e),i=void 0,!St||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(i=!0),a?void 0!==i?e.addEventListener(t,n,{capture:!0,passive:i}):e.addEventListener(t,n,!0):void 0!==i?e.addEventListener(t,n,{passive:i}):e.addEventListener(t,n,!1)}function _i(e,t,n,a,i){var s=a;if(0==(1&t)&&0==(2&t)&&null!==a)e:for(;;){if(null===a)return;var r=a.tag;if(3===r||4===r){var o=a.stateNode.containerInfo;if(o===i||8===o.nodeType&&o.parentNode===i)break;if(4===r)for(r=a.return;null!==r;){var l=r.tag;if((3===l||4===l)&&((l=r.stateNode.containerInfo)===i||8===l.nodeType&&l.parentNode===i))return;r=r.return}for(;null!==o;){if(null===(r=zi(o)))return;if(5===(l=r.tag)||6===l){a=s=r;continue e}o=o.parentNode}}a=a.return}!function(e,t,n){if(Ct)return e(t,n);Ct=!0;try{wt(e,t,n)}finally{Ct=!1,Tt()}}((function(){var a=s,i=dt(n),r=[];e:{var o=bn.get(e);if(void 0!==o){var l=Qn,c=e;switch(e){case"keypress":if(0===Wn(n))break e;case"keydown":case"keyup":l=fa;break;case"focusin":c="focus",l=ia;break;case"focusout":c="blur",l=ia;break;case"beforeblur":case"afterblur":l=ia;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=na;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=aa;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=ya;break;case mn:case fn:case gn:l=sa;break;case yn:l=ba;break;case"scroll":l=ea;break;case"wheel":l=_a;break;case"copy":case"cut":case"paste":l=oa;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=ga}var h=0!=(4&t),d=!h&&"scroll"===e,p=h?null!==o?o+"Capture":null:o;h=[];for(var u,m=a;null!==m;){var f=(u=m).stateNode;if(5===u.tag&&null!==f&&(u=f,null!==p&&(null!=(f=Et(m,p))&&h.push(wi(m,f,u)))),d)break;m=m.return}0<h.length&&(o=new l(o,c,null,n,i),r.push({event:o,listeners:h}))}}if(0==(7&t)){if(l="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||0!=(16&t)||!(c=n.relatedTarget||n.fromElement)||!zi(c)&&!c[Bi])&&(l||o)&&(o=i.window===i?i:(o=i.ownerDocument)?o.defaultView||o.parentWindow:window,l?(l=a,null!==(c=(c=n.relatedTarget||n.toElement)?zi(c):null)&&(c!==(d=Ot(c))||5!==c.tag&&6!==c.tag)&&(c=null)):(l=null,c=a),l!==c)){if(h=na,f="onMouseLeave",p="onMouseEnter",m="mouse","pointerout"!==e&&"pointerover"!==e||(h=ga,f="onPointerLeave",p="onPointerEnter",m="pointer"),d=null==l?o:Hi(l),u=null==c?o:Hi(c),(o=new h(f,m+"leave",l,n,i)).target=d,o.relatedTarget=u,f=null,zi(i)===a&&((h=new h(p,m+"enter",c,n,i)).target=u,h.relatedTarget=d,f=h),d=f,l&&c)e:{for(p=c,m=0,u=h=l;u;u=Ci(u))m++;for(u=0,f=p;f;f=Ci(f))u++;for(;0<m-u;)h=Ci(h),m--;for(;0<u-m;)p=Ci(p),u--;for(;m--;){if(h===p||null!==p&&h===p.alternate)break e;h=Ci(h),p=Ci(p)}h=null}else h=null;null!==l&&Ti(r,o,l,h,!1),null!==c&&null!==d&&Ti(r,d,c,h,!0)}if("select"===(l=(o=a?Hi(a):window).nodeName&&o.nodeName.toLowerCase())||"input"===l&&"file"===o.type)var g=Va;else if(Pa(o))if(Ba)g=qa;else{g=Xa;var y=ja}else(l=o.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===o.type||"radio"===o.type)&&(g=Ya);switch(g&&(g=g(e,a))?ka(r,g,n,i):(y&&y(e,o,a),"focusout"===e&&(y=o._wrapperState)&&y.controlled&&"number"===o.type&&He(o,"number",o.value)),y=a?Hi(a):window,e){case"focusin":(Pa(y)||"true"===y.contentEditable)&&(ii=y,si=a,ri=null);break;case"focusout":ri=si=ii=null;break;case"mousedown":oi=!0;break;case"contextmenu":case"mouseup":case"dragend":oi=!1,li(r,n,i);break;case"selectionchange":if(ai)break;case"keydown":case"keyup":li(r,n,i)}var b;if(xa)e:{switch(e){case"compositionstart":var v="onCompositionStart";break e;case"compositionend":v="onCompositionEnd";break e;case"compositionupdate":v="onCompositionUpdate";break e}v=void 0}else Ra?Ma(e,n)&&(v="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(v="onCompositionStart");v&&(Ea&&"ko"!==n.locale&&(Ra||"onCompositionStart"!==v?"onCompositionEnd"===v&&Ra&&(b=Hn()):(zn="value"in(Un=i)?Un.value:Un.textContent,Ra=!0)),0<(y=xi(a,v)).length&&(v=new la(v,e,null,n,i),r.push({event:v,listeners:y}),b?v.data=b:null!==(b=La(n))&&(v.data=b))),(b=Ta?function(e,t){switch(e){case"compositionend":return La(t);case"keypress":return 32!==t.which?null:(Aa=!0,Sa);case"textInput":return(e=t.data)===Sa&&Aa?null:e;default:return null}}(e,n):function(e,t){if(Ra)return"compositionend"===e||!xa&&Ma(e,t)?(e=Hn(),Gn=zn=Un=null,Ra=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Ea&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(a=xi(a,"onBeforeInput")).length&&(i=new la("onBeforeInput","beforeinput",null,n,i),r.push({event:i,listeners:a}),i.data=b))}mi(r,t)}))}function wi(e,t,n){return{instance:e,listener:t,currentTarget:n}}function xi(e,t){for(var n=t+"Capture",a=[];null!==e;){var i=e,s=i.stateNode;5===i.tag&&null!==s&&(i=s,null!=(s=Et(e,n))&&a.unshift(wi(e,s,i)),null!=(s=Et(e,t))&&a.push(wi(e,s,i))),e=e.return}return a}function Ci(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Ti(e,t,n,a,i){for(var s=t._reactName,r=[];null!==n&&n!==a;){var o=n,l=o.alternate,c=o.stateNode;if(null!==l&&l===a)break;5===o.tag&&null!==c&&(o=c,i?null!=(l=Et(n,s))&&r.unshift(wi(n,l,o)):i||null!=(l=Et(n,s))&&r.push(wi(n,l,o))),n=n.return}0!==r.length&&e.push({event:t,listeners:r})}function Ei(){}var Si=null,Ai=null;function Mi(e,t){switch(e){case"button":case"input":case"select":case"textarea":return!!t.autoFocus}return!1}function Li(e,t){return"textarea"===e||"option"===e||"noscript"===e||"string"==typeof t.children||"number"==typeof t.children||"object"==typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var Ri="function"==typeof setTimeout?setTimeout:void 0,Ii="function"==typeof clearTimeout?clearTimeout:void 0;function Pi(e){1===e.nodeType?e.textContent="":9===e.nodeType&&(null!=(e=e.body)&&(e.textContent=""))}function ki(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break}return e}function Di(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var Oi=0;var Fi=Math.random().toString(36).slice(2),Ni="__reactFiber$"+Fi,Vi="__reactProps$"+Fi,Bi="__reactContainer$"+Fi,Ui="__reactEvents$"+Fi;function zi(e){var t=e[Ni];if(t)return t;for(var n=e.parentNode;n;){if(t=n[Bi]||n[Ni]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=Di(e);null!==e;){if(n=e[Ni])return n;e=Di(e)}return t}n=(e=n).parentNode}return null}function Gi(e){return!(e=e[Ni]||e[Bi])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function Hi(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(j(33))}function Wi(e){return e[Vi]||null}function ji(e){var t=e[Ui];return void 0===t&&(t=e[Ui]=new Set),t}var Xi=[],Yi=-1;function qi(e){return{current:e}}function Ki(e){0>Yi||(e.current=Xi[Yi],Xi[Yi]=null,Yi--)}function Zi(e,t){Yi++,Xi[Yi]=e.current,e.current=t}var $i={},Qi=qi($i),Ji=qi(!1),es=$i;function ts(e,t){var n=e.type.contextTypes;if(!n)return $i;var a=e.stateNode;if(a&&a.__reactInternalMemoizedUnmaskedChildContext===t)return a.__reactInternalMemoizedMaskedChildContext;var i,s={};for(i in n)s[i]=t[i];return a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=s),s}function ns(e){return null!=(e=e.childContextTypes)}function as(){Ki(Ji),Ki(Qi)}function is(e,t,n){if(Qi.current!==$i)throw Error(j(168));Zi(Qi,t),Zi(Ji,n)}function ss(e,t,n){var a=e.stateNode;if(e=t.childContextTypes,"function"!=typeof a.getChildContext)return n;for(var i in a=a.getChildContext())if(!(i in e))throw Error(j(108,Pe(t)||"Unknown",i));return H({},n,a)}function rs(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||$i,es=Qi.current,Zi(Qi,e),Zi(Ji,Ji.current),!0}function os(e,t,n){var a=e.stateNode;if(!a)throw Error(j(169));n?(e=ss(e,t,es),a.__reactInternalMemoizedMergedChildContext=e,Ki(Ji),Ki(Qi),Zi(Qi,e)):Ki(Ji),Zi(Ji,n)}var ls=null,cs=null,hs=W.unstable_runWithPriority,ds=W.unstable_scheduleCallback,ps=W.unstable_cancelCallback,us=W.unstable_shouldYield,ms=W.unstable_requestPaint,fs=W.unstable_now,gs=W.unstable_getCurrentPriorityLevel,ys=W.unstable_ImmediatePriority,bs=W.unstable_UserBlockingPriority,vs=W.unstable_NormalPriority,_s=W.unstable_LowPriority,ws=W.unstable_IdlePriority,xs={},Cs=void 0!==ms?ms:function(){},Ts=null,Es=null,Ss=!1,As=fs(),Ms=1e4>As?fs:function(){return fs()-As};function Ls(){switch(gs()){case ys:return 99;case bs:return 98;case vs:return 97;case _s:return 96;case ws:return 95;default:throw Error(j(332))}}function Rs(e){switch(e){case 99:return ys;case 98:return bs;case 97:return vs;case 96:return _s;case 95:return ws;default:throw Error(j(332))}}function Is(e,t){return e=Rs(e),hs(e,t)}function Ps(e,t,n){return e=Rs(e),ds(e,t,n)}function ks(){if(null!==Es){var e=Es;Es=null,ps(e)}Ds()}function Ds(){if(!Ss&&null!==Ts){Ss=!0;var e=0;try{var t=Ts;Is(99,(function(){for(;e<t.length;e++){var n=t[e];do{n=n(!0)}while(null!==n)}})),Ts=null}catch(t){throw null!==Ts&&(Ts=Ts.slice(e+1)),ds(ys,ks),t}finally{Ss=!1}}}var Os=re.ReactCurrentBatchConfig;function Fs(e,t){if(e&&e.defaultProps){for(var n in t=H({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}var Ns=qi(null),Vs=null,Bs=null,Us=null;function zs(){Us=Bs=Vs=null}function Gs(e){var t=Ns.current;Ki(Ns),e.type._context._currentValue=t}function Hs(e,t){for(;null!==e;){var n=e.alternate;if((e.childLanes&t)===t){if(null===n||(n.childLanes&t)===t)break;n.childLanes|=t}else e.childLanes|=t,null!==n&&(n.childLanes|=t);e=e.return}}function Ws(e,t){Vs=e,Us=Bs=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!=(e.lanes&t)&&(xo=!0),e.firstContext=null)}function js(e,t){if(Us!==e&&!1!==t&&0!==t)if("number"==typeof t&&1073741823!==t||(Us=e,t=1073741823),t={context:e,observedBits:t,next:null},null===Bs){if(null===Vs)throw Error(j(308));Bs=t,Vs.dependencies={lanes:0,firstContext:t,responders:null}}else Bs=Bs.next=t;return e._currentValue}var Xs=!1;function Ys(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}function qs(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Ks(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function Zs(e,t){if(null!==(e=e.updateQueue)){var n=(e=e.shared).pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}}function $s(e,t){var n=e.updateQueue,a=e.alternate;if(null!==a&&n===(a=a.updateQueue)){var i=null,s=null;if(null!==(n=n.firstBaseUpdate)){do{var r={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===s?i=s=r:s=s.next=r,n=n.next}while(null!==n);null===s?i=s=t:s=s.next=t}else i=s=t;return n={baseState:a.baseState,firstBaseUpdate:i,lastBaseUpdate:s,shared:a.shared,effects:a.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Qs(e,t,n,a){var i=e.updateQueue;Xs=!1;var s=i.firstBaseUpdate,r=i.lastBaseUpdate,o=i.shared.pending;if(null!==o){i.shared.pending=null;var l=o,c=l.next;l.next=null,null===r?s=c:r.next=c,r=l;var h=e.alternate;if(null!==h){var d=(h=h.updateQueue).lastBaseUpdate;d!==r&&(null===d?h.firstBaseUpdate=c:d.next=c,h.lastBaseUpdate=l)}}if(null!==s){for(d=i.baseState,r=0,h=c=l=null;;){o=s.lane;var p=s.eventTime;if((a&o)===o){null!==h&&(h=h.next={eventTime:p,lane:0,tag:s.tag,payload:s.payload,callback:s.callback,next:null});e:{var u=e,m=s;switch(o=t,p=n,m.tag){case 1:if("function"==typeof(u=m.payload)){d=u.call(p,d,o);break e}d=u;break e;case 3:u.flags=-4097&u.flags|64;case 0:if(null==(o="function"==typeof(u=m.payload)?u.call(p,d,o):u))break e;d=H({},d,o);break e;case 2:Xs=!0}}null!==s.callback&&(e.flags|=32,null===(o=i.effects)?i.effects=[s]:o.push(s))}else p={eventTime:p,lane:o,tag:s.tag,payload:s.payload,callback:s.callback,next:null},null===h?(c=h=p,l=d):h=h.next=p,r|=o;if(null===(s=s.next)){if(null===(o=i.shared.pending))break;s=o.next,o.next=null,i.lastBaseUpdate=o,i.shared.pending=null}}null===h&&(l=d),i.baseState=l,i.firstBaseUpdate=c,i.lastBaseUpdate=h,Sl|=r,e.lanes=r,e.memoizedState=d}}function Js(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var a=e[t],i=a.callback;if(null!==i){if(a.callback=null,a=n,"function"!=typeof i)throw Error(j(191,i));i.call(a)}}}var er=(new G.Component).refs;function tr(e,t,n,a){n=null==(n=n(a,t=e.memoizedState))?t:H({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var nr={isMounted:function(e){return!!(e=e._reactInternals)&&Ot(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var a=$l(),i=Ql(e),s=Ks(a,i);s.payload=t,null!=n&&(s.callback=n),Zs(e,s),Jl(e,i,a)},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var a=$l(),i=Ql(e),s=Ks(a,i);s.tag=1,s.payload=t,null!=n&&(s.callback=n),Zs(e,s),Jl(e,i,a)},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=$l(),a=Ql(e),i=Ks(n,a);i.tag=2,null!=t&&(i.callback=t),Zs(e,i),Jl(e,a,n)}};function ar(e,t,n,a,i,s,r){return"function"==typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(a,s,r):!t.prototype||!t.prototype.isPureReactComponent||(!$a(n,a)||!$a(i,s))}function ir(e,t,n){var a=!1,i=$i,s=t.contextType;return"object"==typeof s&&null!==s?s=js(s):(i=ns(t)?es:Qi.current,s=(a=null!=(a=t.contextTypes))?ts(e,i):$i),t=new t(n,s),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=nr,e.stateNode=t,t._reactInternals=e,a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=i,e.__reactInternalMemoizedMaskedChildContext=s),t}function sr(e,t,n,a){e=t.state,"function"==typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,a),"function"==typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,a),t.state!==e&&nr.enqueueReplaceState(t,t.state,null)}function rr(e,t,n,a){var i=e.stateNode;i.props=n,i.state=e.memoizedState,i.refs=er,Ys(e);var s=t.contextType;"object"==typeof s&&null!==s?i.context=js(s):(s=ns(t)?es:Qi.current,i.context=ts(e,s)),Qs(e,n,i,a),i.state=e.memoizedState,"function"==typeof(s=t.getDerivedStateFromProps)&&(tr(e,t,s,n),i.state=e.memoizedState),"function"==typeof t.getDerivedStateFromProps||"function"==typeof i.getSnapshotBeforeUpdate||"function"!=typeof i.UNSAFE_componentWillMount&&"function"!=typeof i.componentWillMount||(t=i.state,"function"==typeof i.componentWillMount&&i.componentWillMount(),"function"==typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount(),t!==i.state&&nr.enqueueReplaceState(i,i.state,null),Qs(e,n,i,a),i.state=e.memoizedState),"function"==typeof i.componentDidMount&&(e.flags|=4)}var or=Array.isArray;function lr(e,t,n){if(null!==(e=n.ref)&&"function"!=typeof e&&"object"!=typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(j(309));var a=n.stateNode}if(!a)throw Error(j(147,e));var i=""+e;return null!==t&&null!==t.ref&&"function"==typeof t.ref&&t.ref._stringRef===i?t.ref:(t=function(e){var t=a.refs;t===er&&(t=a.refs={}),null===e?delete t[i]:t[i]=e},t._stringRef=i,t)}if("string"!=typeof e)throw Error(j(284));if(!n._owner)throw Error(j(290,e))}return e}function cr(e,t){if("textarea"!==e.type)throw Error(j(31,"[object Object]"===Object.prototype.toString.call(t)?"object with keys {"+Object.keys(t).join(", ")+"}":t))}function hr(e){function t(t,n){if(e){var a=t.lastEffect;null!==a?(a.nextEffect=n,t.lastEffect=n):t.firstEffect=t.lastEffect=n,n.nextEffect=null,n.flags=8}}function n(n,a){if(!e)return null;for(;null!==a;)t(n,a),a=a.sibling;return null}function a(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function i(e,t){return(e=Pc(e,t)).index=0,e.sibling=null,e}function s(t,n,a){return t.index=a,e?null!==(a=t.alternate)?(a=a.index)<n?(t.flags=2,n):a:(t.flags=2,n):n}function r(t){return e&&null===t.alternate&&(t.flags=2),t}function o(e,t,n,a){return null===t||6!==t.tag?((t=Fc(n,e.mode,a)).return=e,t):((t=i(t,n)).return=e,t)}function l(e,t,n,a){return null!==t&&t.elementType===n.type?((a=i(t,n.props)).ref=lr(e,t,n),a.return=e,a):((a=kc(n.type,n.key,n.props,null,e.mode,a)).ref=lr(e,t,n),a.return=e,a)}function c(e,t,n,a){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Nc(n,e.mode,a)).return=e,t):((t=i(t,n.children||[])).return=e,t)}function h(e,t,n,a,s){return null===t||7!==t.tag?((t=Dc(n,e.mode,a,s)).return=e,t):((t=i(t,n)).return=e,t)}function d(e,t,n){if("string"==typeof t||"number"==typeof t)return(t=Fc(""+t,e.mode,n)).return=e,t;if("object"==typeof t&&null!==t){switch(t.$$typeof){case oe:return(n=kc(t.type,t.key,t.props,null,e.mode,n)).ref=lr(e,null,t),n.return=e,n;case le:return(t=Nc(t,e.mode,n)).return=e,t}if(or(t)||Ae(t))return(t=Dc(t,e.mode,n,null)).return=e,t;cr(e,t)}return null}function p(e,t,n,a){var i=null!==t?t.key:null;if("string"==typeof n||"number"==typeof n)return null!==i?null:o(e,t,""+n,a);if("object"==typeof n&&null!==n){switch(n.$$typeof){case oe:return n.key===i?n.type===ce?h(e,t,n.props.children,a,i):l(e,t,n,a):null;case le:return n.key===i?c(e,t,n,a):null}if(or(n)||Ae(n))return null!==i?null:h(e,t,n,a,null);cr(e,n)}return null}function u(e,t,n,a,i){if("string"==typeof a||"number"==typeof a)return o(t,e=e.get(n)||null,""+a,i);if("object"==typeof a&&null!==a){switch(a.$$typeof){case oe:return e=e.get(null===a.key?n:a.key)||null,a.type===ce?h(t,e,a.props.children,i,a.key):l(t,e,a,i);case le:return c(t,e=e.get(null===a.key?n:a.key)||null,a,i)}if(or(a)||Ae(a))return h(t,e=e.get(n)||null,a,i,null);cr(t,a)}return null}function m(i,r,o,l){for(var c=null,h=null,m=r,f=r=0,g=null;null!==m&&f<o.length;f++){m.index>f?(g=m,m=null):g=m.sibling;var y=p(i,m,o[f],l);if(null===y){null===m&&(m=g);break}e&&m&&null===y.alternate&&t(i,m),r=s(y,r,f),null===h?c=y:h.sibling=y,h=y,m=g}if(f===o.length)return n(i,m),c;if(null===m){for(;f<o.length;f++)null!==(m=d(i,o[f],l))&&(r=s(m,r,f),null===h?c=m:h.sibling=m,h=m);return c}for(m=a(i,m);f<o.length;f++)null!==(g=u(m,i,f,o[f],l))&&(e&&null!==g.alternate&&m.delete(null===g.key?f:g.key),r=s(g,r,f),null===h?c=g:h.sibling=g,h=g);return e&&m.forEach((function(e){return t(i,e)})),c}function f(i,r,o,l){var c=Ae(o);if("function"!=typeof c)throw Error(j(150));if(null==(o=c.call(o)))throw Error(j(151));for(var h=c=null,m=r,f=r=0,g=null,y=o.next();null!==m&&!y.done;f++,y=o.next()){m.index>f?(g=m,m=null):g=m.sibling;var b=p(i,m,y.value,l);if(null===b){null===m&&(m=g);break}e&&m&&null===b.alternate&&t(i,m),r=s(b,r,f),null===h?c=b:h.sibling=b,h=b,m=g}if(y.done)return n(i,m),c;if(null===m){for(;!y.done;f++,y=o.next())null!==(y=d(i,y.value,l))&&(r=s(y,r,f),null===h?c=y:h.sibling=y,h=y);return c}for(m=a(i,m);!y.done;f++,y=o.next())null!==(y=u(m,i,f,y.value,l))&&(e&&null!==y.alternate&&m.delete(null===y.key?f:y.key),r=s(y,r,f),null===h?c=y:h.sibling=y,h=y);return e&&m.forEach((function(e){return t(i,e)})),c}return function(e,a,s,o){var l="object"==typeof s&&null!==s&&s.type===ce&&null===s.key;l&&(s=s.props.children);var c="object"==typeof s&&null!==s;if(c)switch(s.$$typeof){case oe:e:{for(c=s.key,l=a;null!==l;){if(l.key===c){if(7===l.tag){if(s.type===ce){n(e,l.sibling),(a=i(l,s.props.children)).return=e,e=a;break e}}else if(l.elementType===s.type){n(e,l.sibling),(a=i(l,s.props)).ref=lr(e,l,s),a.return=e,e=a;break e}n(e,l);break}t(e,l),l=l.sibling}s.type===ce?((a=Dc(s.props.children,e.mode,o,s.key)).return=e,e=a):((o=kc(s.type,s.key,s.props,null,e.mode,o)).ref=lr(e,a,s),o.return=e,e=o)}return r(e);case le:e:{for(l=s.key;null!==a;){if(a.key===l){if(4===a.tag&&a.stateNode.containerInfo===s.containerInfo&&a.stateNode.implementation===s.implementation){n(e,a.sibling),(a=i(a,s.children||[])).return=e,e=a;break e}n(e,a);break}t(e,a),a=a.sibling}(a=Nc(s,e.mode,o)).return=e,e=a}return r(e)}if("string"==typeof s||"number"==typeof s)return s=""+s,null!==a&&6===a.tag?(n(e,a.sibling),(a=i(a,s)).return=e,e=a):(n(e,a),(a=Fc(s,e.mode,o)).return=e,e=a),r(e);if(or(s))return m(e,a,s,o);if(Ae(s))return f(e,a,s,o);if(c&&cr(e,s),void 0===s&&!l)switch(e.tag){case 1:case 22:case 0:case 11:case 15:throw Error(j(152,Pe(e.type)||"Component"))}return n(e,a)}}var dr=hr(!0),pr=hr(!1),ur={},mr=qi(ur),fr=qi(ur),gr=qi(ur);function yr(e){if(e===ur)throw Error(j(174));return e}function br(e,t){switch(Zi(gr,t),Zi(fr,e),Zi(mr,ur),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:Je(null,"");break;default:t=Je(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Ki(mr),Zi(mr,t)}function vr(){Ki(mr),Ki(fr),Ki(gr)}function _r(e){yr(gr.current);var t=yr(mr.current),n=Je(t,e.type);t!==n&&(Zi(fr,e),Zi(mr,n))}function wr(e){fr.current===e&&(Ki(mr),Ki(fr))}var xr=qi(0);function Cr(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!=(64&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var Tr=null,Er=null,Sr=!1;function Ar(e,t){var n=Rc(5,null,null,0);n.elementType="DELETED",n.type="DELETED",n.stateNode=t,n.return=e,n.flags=8,null!==e.lastEffect?(e.lastEffect.nextEffect=n,e.lastEffect=n):e.firstEffect=e.lastEffect=n}function Mr(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,!0);default:return!1}}function Lr(e){if(Sr){var t=Er;if(t){var n=t;if(!Mr(e,t)){if(!(t=ki(n.nextSibling))||!Mr(e,t))return e.flags=-1025&e.flags|2,Sr=!1,void(Tr=e);Ar(Tr,n)}Tr=e,Er=ki(t.firstChild)}else e.flags=-1025&e.flags|2,Sr=!1,Tr=e}}function Rr(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;Tr=e}function Ir(e){if(e!==Tr)return!1;if(!Sr)return Rr(e),Sr=!0,!1;var t=e.type;if(5!==e.tag||"head"!==t&&"body"!==t&&!Li(t,e.memoizedProps))for(t=Er;t;)Ar(e,t),t=ki(t.nextSibling);if(Rr(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(j(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){Er=ki(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}Er=null}}else Er=Tr?ki(e.stateNode.nextSibling):null;return!0}function Pr(){Er=Tr=null,Sr=!1}var kr=[];function Dr(){for(var e=0;e<kr.length;e++)kr[e]._workInProgressVersionPrimary=null;kr.length=0}var Or=re.ReactCurrentDispatcher,Fr=re.ReactCurrentBatchConfig,Nr=0,Vr=null,Br=null,Ur=null,zr=!1,Gr=!1;function Hr(){throw Error(j(321))}function Wr(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Ka(e[n],t[n]))return!1;return!0}function jr(e,t,n,a,i,s){if(Nr=s,Vr=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,Or.current=null===e||null===e.memoizedState?bo:vo,e=n(a,i),Gr){s=0;do{if(Gr=!1,!(25>s))throw Error(j(301));s+=1,Ur=Br=null,t.updateQueue=null,Or.current=_o,e=n(a,i)}while(Gr)}if(Or.current=yo,t=null!==Br&&null!==Br.next,Nr=0,Ur=Br=Vr=null,zr=!1,t)throw Error(j(300));return e}function Xr(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===Ur?Vr.memoizedState=Ur=e:Ur=Ur.next=e,Ur}function Yr(){if(null===Br){var e=Vr.alternate;e=null!==e?e.memoizedState:null}else e=Br.next;var t=null===Ur?Vr.memoizedState:Ur.next;if(null!==t)Ur=t,Br=e;else{if(null===e)throw Error(j(310));e={memoizedState:(Br=e).memoizedState,baseState:Br.baseState,baseQueue:Br.baseQueue,queue:Br.queue,next:null},null===Ur?Vr.memoizedState=Ur=e:Ur=Ur.next=e}return Ur}function qr(e,t){return"function"==typeof t?t(e):t}function Kr(e){var t=Yr(),n=t.queue;if(null===n)throw Error(j(311));n.lastRenderedReducer=e;var a=Br,i=a.baseQueue,s=n.pending;if(null!==s){if(null!==i){var r=i.next;i.next=s.next,s.next=r}a.baseQueue=i=s,n.pending=null}if(null!==i){i=i.next,a=a.baseState;var o=r=s=null,l=i;do{var c=l.lane;if((Nr&c)===c)null!==o&&(o=o.next={lane:0,action:l.action,eagerReducer:l.eagerReducer,eagerState:l.eagerState,next:null}),a=l.eagerReducer===e?l.eagerState:e(a,l.action);else{var h={lane:c,action:l.action,eagerReducer:l.eagerReducer,eagerState:l.eagerState,next:null};null===o?(r=o=h,s=a):o=o.next=h,Vr.lanes|=c,Sl|=c}l=l.next}while(null!==l&&l!==i);null===o?s=a:o.next=r,Ka(a,t.memoizedState)||(xo=!0),t.memoizedState=a,t.baseState=s,t.baseQueue=o,n.lastRenderedState=a}return[t.memoizedState,n.dispatch]}function Zr(e){var t=Yr(),n=t.queue;if(null===n)throw Error(j(311));n.lastRenderedReducer=e;var a=n.dispatch,i=n.pending,s=t.memoizedState;if(null!==i){n.pending=null;var r=i=i.next;do{s=e(s,r.action),r=r.next}while(r!==i);Ka(s,t.memoizedState)||(xo=!0),t.memoizedState=s,null===t.baseQueue&&(t.baseState=s),n.lastRenderedState=s}return[s,a]}function $r(e,t,n){var a=t._getVersion;a=a(t._source);var i=t._workInProgressVersionPrimary;if(null!==i?e=i===a:(e=e.mutableReadLanes,(e=(Nr&e)===e)&&(t._workInProgressVersionPrimary=a,kr.push(t))),e)return n(t._source);throw kr.push(t),Error(j(350))}function Qr(e,t,n,a){var i=bl;if(null===i)throw Error(j(349));var s=t._getVersion,r=s(t._source),o=Or.current,l=o.useState((function(){return $r(i,t,n)})),c=l[1],h=l[0];l=Ur;var d=e.memoizedState,p=d.refs,u=p.getSnapshot,m=d.source;d=d.subscribe;var f=Vr;return e.memoizedState={refs:p,source:t,subscribe:a},o.useEffect((function(){p.getSnapshot=n,p.setSnapshot=c;var e=s(t._source);if(!Ka(r,e)){e=n(t._source),Ka(h,e)||(c(e),e=Ql(f),i.mutableReadLanes|=e&i.pendingLanes),e=i.mutableReadLanes,i.entangledLanes|=e;for(var a=i.entanglements,o=e;0<o;){var l=31-Rn(o),d=1<<l;a[l]|=e,o&=~d}}}),[n,t,a]),o.useEffect((function(){return a(t._source,(function(){var e=p.getSnapshot,n=p.setSnapshot;try{n(e(t._source));var a=Ql(f);i.mutableReadLanes|=a&i.pendingLanes}catch(e){n((function(){throw e}))}}))}),[t,a]),Ka(u,n)&&Ka(m,t)&&Ka(d,a)||((e={pending:null,dispatch:null,lastRenderedReducer:qr,lastRenderedState:h}).dispatch=c=go.bind(null,Vr,e),l.queue=e,l.baseQueue=null,h=$r(i,t,n),l.memoizedState=l.baseState=h),h}function Jr(e,t,n){return Qr(Yr(),e,t,n)}function eo(e){var t=Xr();return"function"==typeof e&&(e=e()),t.memoizedState=t.baseState=e,e=(e=t.queue={pending:null,dispatch:null,lastRenderedReducer:qr,lastRenderedState:e}).dispatch=go.bind(null,Vr,e),[t.memoizedState,e]}function to(e,t,n,a){return e={tag:e,create:t,destroy:n,deps:a,next:null},null===(t=Vr.updateQueue)?(t={lastEffect:null},Vr.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(a=n.next,n.next=e,e.next=a,t.lastEffect=e),e}function no(e){return e={current:e},Xr().memoizedState=e}function ao(){return Yr().memoizedState}function io(e,t,n,a){var i=Xr();Vr.flags|=e,i.memoizedState=to(1|t,n,void 0,void 0===a?null:a)}function so(e,t,n,a){var i=Yr();a=void 0===a?null:a;var s=void 0;if(null!==Br){var r=Br.memoizedState;if(s=r.destroy,null!==a&&Wr(a,r.deps))return void to(t,n,s,a)}Vr.flags|=e,i.memoizedState=to(1|t,n,s,a)}function ro(e,t){return io(516,4,e,t)}function oo(e,t){return so(516,4,e,t)}function lo(e,t){return so(4,2,e,t)}function co(e,t){return"function"==typeof t?(e=e(),t(e),function(){t(null)}):null!=t?(e=e(),t.current=e,function(){t.current=null}):void 0}function ho(e,t,n){return n=null!=n?n.concat([e]):null,so(4,2,co.bind(null,t,e),n)}function po(){}function uo(e,t){var n=Yr();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&Wr(t,a[1])?a[0]:(n.memoizedState=[e,t],e)}function mo(e,t){var n=Yr();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&Wr(t,a[1])?a[0]:(e=e(),n.memoizedState=[e,t],e)}function fo(e,t){var n=Ls();Is(98>n?98:n,(function(){e(!0)})),Is(97<n?97:n,(function(){var n=Fr.transition;Fr.transition=1;try{e(!1),t()}finally{Fr.transition=n}}))}function go(e,t,n){var a=$l(),i=Ql(e),s={lane:i,action:n,eagerReducer:null,eagerState:null,next:null},r=t.pending;if(null===r?s.next=s:(s.next=r.next,r.next=s),t.pending=s,r=e.alternate,e===Vr||null!==r&&r===Vr)Gr=zr=!0;else{if(0===e.lanes&&(null===r||0===r.lanes)&&null!==(r=t.lastRenderedReducer))try{var o=t.lastRenderedState,l=r(o,n);if(s.eagerReducer=r,s.eagerState=l,Ka(l,o))return}catch(e){}Jl(e,i,a)}}var yo={readContext:js,useCallback:Hr,useContext:Hr,useEffect:Hr,useImperativeHandle:Hr,useLayoutEffect:Hr,useMemo:Hr,useReducer:Hr,useRef:Hr,useState:Hr,useDebugValue:Hr,useDeferredValue:Hr,useTransition:Hr,useMutableSource:Hr,useOpaqueIdentifier:Hr,unstable_isNewReconciler:!1},bo={readContext:js,useCallback:function(e,t){return Xr().memoizedState=[e,void 0===t?null:t],e},useContext:js,useEffect:ro,useImperativeHandle:function(e,t,n){return n=null!=n?n.concat([e]):null,io(4,2,co.bind(null,t,e),n)},useLayoutEffect:function(e,t){return io(4,2,e,t)},useMemo:function(e,t){var n=Xr();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var a=Xr();return t=void 0!==n?n(t):t,a.memoizedState=a.baseState=t,e=(e=a.queue={pending:null,dispatch:null,lastRenderedReducer:e,lastRenderedState:t}).dispatch=go.bind(null,Vr,e),[a.memoizedState,e]},useRef:no,useState:eo,useDebugValue:po,useDeferredValue:function(e){var t=eo(e),n=t[0],a=t[1];return ro((function(){var t=Fr.transition;Fr.transition=1;try{a(e)}finally{Fr.transition=t}}),[e]),n},useTransition:function(){var e=eo(!1),t=e[0];return no(e=fo.bind(null,e[1])),[e,t]},useMutableSource:function(e,t,n){var a=Xr();return a.memoizedState={refs:{getSnapshot:t,setSnapshot:null},source:e,subscribe:n},Qr(a,e,t,n)},useOpaqueIdentifier:function(){if(Sr){var e=!1,t=function(e){return{$$typeof:_e,toString:e,valueOf:e}}((function(){throw e||(e=!0,n("r:"+(Oi++).toString(36))),Error(j(355))})),n=eo(t)[1];return 0==(2&Vr.mode)&&(Vr.flags|=516,to(5,(function(){n("r:"+(Oi++).toString(36))}),void 0,null)),t}return eo(t="r:"+(Oi++).toString(36)),t},unstable_isNewReconciler:!1},vo={readContext:js,useCallback:uo,useContext:js,useEffect:oo,useImperativeHandle:ho,useLayoutEffect:lo,useMemo:mo,useReducer:Kr,useRef:ao,useState:function(){return Kr(qr)},useDebugValue:po,useDeferredValue:function(e){var t=Kr(qr),n=t[0],a=t[1];return oo((function(){var t=Fr.transition;Fr.transition=1;try{a(e)}finally{Fr.transition=t}}),[e]),n},useTransition:function(){var e=Kr(qr)[0];return[ao().current,e]},useMutableSource:Jr,useOpaqueIdentifier:function(){return Kr(qr)[0]},unstable_isNewReconciler:!1},_o={readContext:js,useCallback:uo,useContext:js,useEffect:oo,useImperativeHandle:ho,useLayoutEffect:lo,useMemo:mo,useReducer:Zr,useRef:ao,useState:function(){return Zr(qr)},useDebugValue:po,useDeferredValue:function(e){var t=Zr(qr),n=t[0],a=t[1];return oo((function(){var t=Fr.transition;Fr.transition=1;try{a(e)}finally{Fr.transition=t}}),[e]),n},useTransition:function(){var e=Zr(qr)[0];return[ao().current,e]},useMutableSource:Jr,useOpaqueIdentifier:function(){return Zr(qr)[0]},unstable_isNewReconciler:!1},wo=re.ReactCurrentOwner,xo=!1;function Co(e,t,n,a){t.child=null===e?pr(t,null,n,a):dr(t,e.child,n,a)}function To(e,t,n,a,i){n=n.render;var s=t.ref;return Ws(t,i),a=jr(e,t,n,a,s,i),null===e||xo?(t.flags|=1,Co(e,t,a,i),t.child):(t.updateQueue=e.updateQueue,t.flags&=-517,e.lanes&=~i,Wo(e,t,i))}function Eo(e,t,n,a,i,s){if(null===e){var r=n.type;return"function"!=typeof r||Ic(r)||void 0!==r.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=kc(n.type,null,a,t,t.mode,s)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=r,So(e,t,r,a,i,s))}return r=e.child,0==(i&s)&&(i=r.memoizedProps,(n=null!==(n=n.compare)?n:$a)(i,a)&&e.ref===t.ref)?Wo(e,t,s):(t.flags|=1,(e=Pc(r,a)).ref=t.ref,e.return=t,t.child=e)}function So(e,t,n,a,i,s){if(null!==e&&$a(e.memoizedProps,a)&&e.ref===t.ref){if(xo=!1,0==(s&i))return t.lanes=e.lanes,Wo(e,t,s);0!=(16384&e.flags)&&(xo=!0)}return Lo(e,t,n,a,s)}function Ao(e,t,n){var a=t.pendingProps,i=a.children,s=null!==e?e.memoizedState:null;if("hidden"===a.mode||"unstable-defer-without-hiding"===a.mode)if(0==(4&t.mode))t.memoizedState={baseLanes:0},oc(t,n);else{if(0==(1073741824&n))return e=null!==s?s.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e},oc(t,e),null;t.memoizedState={baseLanes:0},oc(t,null!==s?s.baseLanes:n)}else null!==s?(a=s.baseLanes|n,t.memoizedState=null):a=n,oc(t,a);return Co(e,t,i,n),t.child}function Mo(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=128)}function Lo(e,t,n,a,i){var s=ns(n)?es:Qi.current;return s=ts(t,s),Ws(t,i),n=jr(e,t,n,a,s,i),null===e||xo?(t.flags|=1,Co(e,t,n,i),t.child):(t.updateQueue=e.updateQueue,t.flags&=-517,e.lanes&=~i,Wo(e,t,i))}function Ro(e,t,n,a,i){if(ns(n)){var s=!0;rs(t)}else s=!1;if(Ws(t,i),null===t.stateNode)null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),ir(t,n,a),rr(t,n,a,i),a=!0;else if(null===e){var r=t.stateNode,o=t.memoizedProps;r.props=o;var l=r.context,c=n.contextType;"object"==typeof c&&null!==c?c=js(c):c=ts(t,c=ns(n)?es:Qi.current);var h=n.getDerivedStateFromProps,d="function"==typeof h||"function"==typeof r.getSnapshotBeforeUpdate;d||"function"!=typeof r.UNSAFE_componentWillReceiveProps&&"function"!=typeof r.componentWillReceiveProps||(o!==a||l!==c)&&sr(t,r,a,c),Xs=!1;var p=t.memoizedState;r.state=p,Qs(t,a,r,i),l=t.memoizedState,o!==a||p!==l||Ji.current||Xs?("function"==typeof h&&(tr(t,n,h,a),l=t.memoizedState),(o=Xs||ar(t,n,o,a,p,l,c))?(d||"function"!=typeof r.UNSAFE_componentWillMount&&"function"!=typeof r.componentWillMount||("function"==typeof r.componentWillMount&&r.componentWillMount(),"function"==typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount()),"function"==typeof r.componentDidMount&&(t.flags|=4)):("function"==typeof r.componentDidMount&&(t.flags|=4),t.memoizedProps=a,t.memoizedState=l),r.props=a,r.state=l,r.context=c,a=o):("function"==typeof r.componentDidMount&&(t.flags|=4),a=!1)}else{r=t.stateNode,qs(e,t),o=t.memoizedProps,c=t.type===t.elementType?o:Fs(t.type,o),r.props=c,d=t.pendingProps,p=r.context,"object"==typeof(l=n.contextType)&&null!==l?l=js(l):l=ts(t,l=ns(n)?es:Qi.current);var u=n.getDerivedStateFromProps;(h="function"==typeof u||"function"==typeof r.getSnapshotBeforeUpdate)||"function"!=typeof r.UNSAFE_componentWillReceiveProps&&"function"!=typeof r.componentWillReceiveProps||(o!==d||p!==l)&&sr(t,r,a,l),Xs=!1,p=t.memoizedState,r.state=p,Qs(t,a,r,i);var m=t.memoizedState;o!==d||p!==m||Ji.current||Xs?("function"==typeof u&&(tr(t,n,u,a),m=t.memoizedState),(c=Xs||ar(t,n,c,a,p,m,l))?(h||"function"!=typeof r.UNSAFE_componentWillUpdate&&"function"!=typeof r.componentWillUpdate||("function"==typeof r.componentWillUpdate&&r.componentWillUpdate(a,m,l),"function"==typeof r.UNSAFE_componentWillUpdate&&r.UNSAFE_componentWillUpdate(a,m,l)),"function"==typeof r.componentDidUpdate&&(t.flags|=4),"function"==typeof r.getSnapshotBeforeUpdate&&(t.flags|=256)):("function"!=typeof r.componentDidUpdate||o===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),"function"!=typeof r.getSnapshotBeforeUpdate||o===e.memoizedProps&&p===e.memoizedState||(t.flags|=256),t.memoizedProps=a,t.memoizedState=m),r.props=a,r.state=m,r.context=l,a=c):("function"!=typeof r.componentDidUpdate||o===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),"function"!=typeof r.getSnapshotBeforeUpdate||o===e.memoizedProps&&p===e.memoizedState||(t.flags|=256),a=!1)}return Io(e,t,n,a,s,i)}function Io(e,t,n,a,i,s){Mo(e,t);var r=0!=(64&t.flags);if(!a&&!r)return i&&os(t,n,!1),Wo(e,t,s);a=t.stateNode,wo.current=t;var o=r&&"function"!=typeof n.getDerivedStateFromError?null:a.render();return t.flags|=1,null!==e&&r?(t.child=dr(t,e.child,null,s),t.child=dr(t,null,o,s)):Co(e,t,o,s),t.memoizedState=a.state,i&&os(t,n,!0),t.child}function Po(e){var t=e.stateNode;t.pendingContext?is(0,t.pendingContext,t.pendingContext!==t.context):t.context&&is(0,t.context,!1),br(e,t.containerInfo)}var ko,Do,Oo,Fo={dehydrated:null,retryLane:0};function No(e,t,n){var a,i=t.pendingProps,s=xr.current,r=!1;return(a=0!=(64&t.flags))||(a=(null===e||null!==e.memoizedState)&&0!=(2&s)),a?(r=!0,t.flags&=-65):null!==e&&null===e.memoizedState||void 0===i.fallback||!0===i.unstable_avoidThisFallback||(s|=1),Zi(xr,1&s),null===e?(void 0!==i.fallback&&Lr(t),e=i.children,s=i.fallback,r?(e=Vo(t,e,s,n),t.child.memoizedState={baseLanes:n},t.memoizedState=Fo,e):"number"==typeof i.unstable_expectedLoadTime?(e=Vo(t,e,s,n),t.child.memoizedState={baseLanes:n},t.memoizedState=Fo,t.lanes=33554432,e):((n=Oc({mode:"visible",children:e},t.mode,n,null)).return=t,t.child=n)):(e.memoizedState,r?(i=Uo(e,t,i.children,i.fallback,n),r=t.child,s=e.child.memoizedState,r.memoizedState=null===s?{baseLanes:n}:{baseLanes:s.baseLanes|n},r.childLanes=e.childLanes&~n,t.memoizedState=Fo,i):(n=Bo(e,t,i.children,n),t.memoizedState=null,n))}function Vo(e,t,n,a){var i=e.mode,s=e.child;return t={mode:"hidden",children:t},0==(2&i)&&null!==s?(s.childLanes=0,s.pendingProps=t):s=Oc(t,i,0,null),n=Dc(n,i,a,null),s.return=e,n.return=e,s.sibling=n,e.child=s,n}function Bo(e,t,n,a){var i=e.child;return e=i.sibling,n=Pc(i,{mode:"visible",children:n}),0==(2&t.mode)&&(n.lanes=a),n.return=t,n.sibling=null,null!==e&&(e.nextEffect=null,e.flags=8,t.firstEffect=t.lastEffect=e),t.child=n}function Uo(e,t,n,a,i){var s=t.mode,r=e.child;e=r.sibling;var o={mode:"hidden",children:n};return 0==(2&s)&&t.child!==r?((n=t.child).childLanes=0,n.pendingProps=o,null!==(r=n.lastEffect)?(t.firstEffect=n.firstEffect,t.lastEffect=r,r.nextEffect=null):t.firstEffect=t.lastEffect=null):n=Pc(r,o),null!==e?a=Pc(e,a):(a=Dc(a,s,i,null)).flags|=2,a.return=t,n.return=t,n.sibling=a,t.child=n,a}function zo(e,t){e.lanes|=t;var n=e.alternate;null!==n&&(n.lanes|=t),Hs(e.return,t)}function Go(e,t,n,a,i,s){var r=e.memoizedState;null===r?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:a,tail:n,tailMode:i,lastEffect:s}:(r.isBackwards=t,r.rendering=null,r.renderingStartTime=0,r.last=a,r.tail=n,r.tailMode=i,r.lastEffect=s)}function Ho(e,t,n){var a=t.pendingProps,i=a.revealOrder,s=a.tail;if(Co(e,t,a.children,n),0!=(2&(a=xr.current)))a=1&a|2,t.flags|=64;else{if(null!==e&&0!=(64&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&zo(e,n);else if(19===e.tag)zo(e,n);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}a&=1}if(Zi(xr,a),0==(2&t.mode))t.memoizedState=null;else switch(i){case"forwards":for(n=t.child,i=null;null!==n;)null!==(e=n.alternate)&&null===Cr(e)&&(i=n),n=n.sibling;null===(n=i)?(i=t.child,t.child=null):(i=n.sibling,n.sibling=null),Go(t,!1,i,n,s,t.lastEffect);break;case"backwards":for(n=null,i=t.child,t.child=null;null!==i;){if(null!==(e=i.alternate)&&null===Cr(e)){t.child=i;break}e=i.sibling,i.sibling=n,n=i,i=e}Go(t,!0,n,null,s,t.lastEffect);break;case"together":Go(t,!1,null,null,void 0,t.lastEffect);break;default:t.memoizedState=null}return t.child}function Wo(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Sl|=t.lanes,0!=(n&t.childLanes)){if(null!==e&&t.child!==e.child)throw Error(j(153));if(null!==t.child){for(n=Pc(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Pc(e,e.pendingProps)).return=t;n.sibling=null}return t.child}return null}function jo(e,t){if(!Sr)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var a=null;null!==n;)null!==n.alternate&&(a=n),n=n.sibling;null===a?t||null===e.tail?e.tail=null:e.tail.sibling=null:a.sibling=null}}function Xo(e,t,n){var a=t.pendingProps;switch(t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:case 17:return ns(t.type)&&as(),null;case 3:return vr(),Ki(Ji),Ki(Qi),Dr(),(a=t.stateNode).pendingContext&&(a.context=a.pendingContext,a.pendingContext=null),null!==e&&null!==e.child||(Ir(t)?t.flags|=4:a.hydrate||(t.flags|=256)),null;case 5:wr(t);var i=yr(gr.current);if(n=t.type,null!==e&&null!=t.stateNode)Do(e,t,n,a),e.ref!==t.ref&&(t.flags|=128);else{if(!a){if(null===t.stateNode)throw Error(j(166));return null}if(e=yr(mr.current),Ir(t)){a=t.stateNode,n=t.type;var s=t.memoizedProps;switch(a[Ni]=t,a[Vi]=s,n){case"dialog":fi("cancel",a),fi("close",a);break;case"iframe":case"object":case"embed":fi("load",a);break;case"video":case"audio":for(e=0;e<di.length;e++)fi(di[e],a);break;case"source":fi("error",a);break;case"img":case"image":case"link":fi("error",a),fi("load",a);break;case"details":fi("toggle",a);break;case"input":Be(a,s),fi("invalid",a);break;case"select":a._wrapperState={wasMultiple:!!s.multiple},fi("invalid",a);break;case"textarea":Ye(a,s),fi("invalid",a)}for(var r in ct(n,s),e=null,s)s.hasOwnProperty(r)&&(i=s[r],"children"===r?"string"==typeof i?a.textContent!==i&&(e=["children",i]):"number"==typeof i&&a.textContent!==""+i&&(e=["children",""+i]):Y.hasOwnProperty(r)&&null!=i&&"onScroll"===r&&fi("scroll",a));switch(n){case"input":Oe(a),Ge(a,s,!0);break;case"textarea":Oe(a),Ke(a);break;case"select":case"option":break;default:"function"==typeof s.onClick&&(a.onclick=Ei)}a=e,t.updateQueue=a,null!==a&&(t.flags|=4)}else{switch(r=9===i.nodeType?i:i.ownerDocument,e===Ze&&(e=Qe(n)),e===Ze?"script"===n?((e=r.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"==typeof a.is?e=r.createElement(n,{is:a.is}):(e=r.createElement(n),"select"===n&&(r=e,a.multiple?r.multiple=!0:a.size&&(r.size=a.size))):e=r.createElementNS(e,n),e[Ni]=t,e[Vi]=a,ko(e,t),t.stateNode=e,r=ht(n,a),n){case"dialog":fi("cancel",e),fi("close",e),i=a;break;case"iframe":case"object":case"embed":fi("load",e),i=a;break;case"video":case"audio":for(i=0;i<di.length;i++)fi(di[i],e);i=a;break;case"source":fi("error",e),i=a;break;case"img":case"image":case"link":fi("error",e),fi("load",e),i=a;break;case"details":fi("toggle",e),i=a;break;case"input":Be(e,a),i=Ve(e,a),fi("invalid",e);break;case"option":i=We(e,a);break;case"select":e._wrapperState={wasMultiple:!!a.multiple},i=H({},a,{value:void 0}),fi("invalid",e);break;case"textarea":Ye(e,a),i=Xe(e,a),fi("invalid",e);break;default:i=a}ct(n,i);var o=i;for(s in o)if(o.hasOwnProperty(s)){var l=o[s];"style"===s?ot(e,l):"dangerouslySetInnerHTML"===s?null!=(l=l?l.__html:void 0)&&nt(e,l):"children"===s?"string"==typeof l?("textarea"!==n||""!==l)&&at(e,l):"number"==typeof l&&at(e,""+l):"suppressContentEditableWarning"!==s&&"suppressHydrationWarning"!==s&&"autoFocus"!==s&&(Y.hasOwnProperty(s)?null!=l&&"onScroll"===s&&fi("scroll",e):null!=l&&se(e,s,l,r))}switch(n){case"input":Oe(e),Ge(e,a,!1);break;case"textarea":Oe(e),Ke(e);break;case"option":null!=a.value&&e.setAttribute("value",""+ke(a.value));break;case"select":e.multiple=!!a.multiple,null!=(s=a.value)?je(e,!!a.multiple,s,!1):null!=a.defaultValue&&je(e,!!a.multiple,a.defaultValue,!0);break;default:"function"==typeof i.onClick&&(e.onclick=Ei)}Mi(n,a)&&(t.flags|=4)}null!==t.ref&&(t.flags|=128)}return null;case 6:if(e&&null!=t.stateNode)Oo(0,t,e.memoizedProps,a);else{if("string"!=typeof a&&null===t.stateNode)throw Error(j(166));n=yr(gr.current),yr(mr.current),Ir(t)?(a=t.stateNode,n=t.memoizedProps,a[Ni]=t,a.nodeValue!==n&&(t.flags|=4)):((a=(9===n.nodeType?n:n.ownerDocument).createTextNode(a))[Ni]=t,t.stateNode=a)}return null;case 13:return Ki(xr),a=t.memoizedState,0!=(64&t.flags)?(t.lanes=n,t):(a=null!==a,n=!1,null===e?void 0!==t.memoizedProps.fallback&&Ir(t):n=null!==e.memoizedState,a&&!n&&0!=(2&t.mode)&&(null===e&&!0!==t.memoizedProps.unstable_avoidThisFallback||0!=(1&xr.current)?0===Cl&&(Cl=3):(0!==Cl&&3!==Cl||(Cl=4),null===bl||0==(134217727&Sl)&&0==(134217727&Al)||ac(bl,_l))),(a||n)&&(t.flags|=4),null);case 4:return vr(),null===e&&yi(t.stateNode.containerInfo),null;case 10:return Gs(t),null;case 19:if(Ki(xr),null===(a=t.memoizedState))return null;if(s=0!=(64&t.flags),null===(r=a.rendering))if(s)jo(a,!1);else{if(0!==Cl||null!==e&&0!=(64&e.flags))for(e=t.child;null!==e;){if(null!==(r=Cr(e))){for(t.flags|=64,jo(a,!1),null!==(s=r.updateQueue)&&(t.updateQueue=s,t.flags|=4),null===a.lastEffect&&(t.firstEffect=null),t.lastEffect=a.lastEffect,a=n,n=t.child;null!==n;)e=a,(s=n).flags&=2,s.nextEffect=null,s.firstEffect=null,s.lastEffect=null,null===(r=s.alternate)?(s.childLanes=0,s.lanes=e,s.child=null,s.memoizedProps=null,s.memoizedState=null,s.updateQueue=null,s.dependencies=null,s.stateNode=null):(s.childLanes=r.childLanes,s.lanes=r.lanes,s.child=r.child,s.memoizedProps=r.memoizedProps,s.memoizedState=r.memoizedState,s.updateQueue=r.updateQueue,s.type=r.type,e=r.dependencies,s.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Zi(xr,1&xr.current|2),t.child}e=e.sibling}null!==a.tail&&Ms()>Il&&(t.flags|=64,s=!0,jo(a,!1),t.lanes=33554432)}else{if(!s)if(null!==(e=Cr(r))){if(t.flags|=64,s=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),jo(a,!0),null===a.tail&&"hidden"===a.tailMode&&!r.alternate&&!Sr)return null!==(t=t.lastEffect=a.lastEffect)&&(t.nextEffect=null),null}else 2*Ms()-a.renderingStartTime>Il&&1073741824!==n&&(t.flags|=64,s=!0,jo(a,!1),t.lanes=33554432);a.isBackwards?(r.sibling=t.child,t.child=r):(null!==(n=a.last)?n.sibling=r:t.child=r,a.last=r)}return null!==a.tail?(n=a.tail,a.rendering=n,a.tail=n.sibling,a.lastEffect=t.lastEffect,a.renderingStartTime=Ms(),n.sibling=null,t=xr.current,Zi(xr,s?1&t|2:1&t),n):null;case 23:case 24:return lc(),null!==e&&null!==e.memoizedState!=(null!==t.memoizedState)&&"unstable-defer-without-hiding"!==a.mode&&(t.flags|=4),null}throw Error(j(156,t.tag))}function Yo(e){switch(e.tag){case 1:ns(e.type)&&as();var t=e.flags;return 4096&t?(e.flags=-4097&t|64,e):null;case 3:if(vr(),Ki(Ji),Ki(Qi),Dr(),0!=(64&(t=e.flags)))throw Error(j(285));return e.flags=-4097&t|64,e;case 5:return wr(e),null;case 13:return Ki(xr),4096&(t=e.flags)?(e.flags=-4097&t|64,e):null;case 19:return Ki(xr),null;case 4:return vr(),null;case 10:return Gs(e),null;case 23:case 24:return lc(),null;default:return null}}function qo(e,t){try{var n="",a=t;do{n+=Ie(a),a=a.return}while(a);var i=n}catch(e){i="\nError generating stack: "+e.message+"\n"+e.stack}return{value:e,source:t,stack:i}}function Ko(e,t){try{console.error(t.value)}catch(e){setTimeout((function(){throw e}))}}ko=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Do=function(e,t,n,a){var i=e.memoizedProps;if(i!==a){e=t.stateNode,yr(mr.current);var s,r=null;switch(n){case"input":i=Ve(e,i),a=Ve(e,a),r=[];break;case"option":i=We(e,i),a=We(e,a),r=[];break;case"select":i=H({},i,{value:void 0}),a=H({},a,{value:void 0}),r=[];break;case"textarea":i=Xe(e,i),a=Xe(e,a),r=[];break;default:"function"!=typeof i.onClick&&"function"==typeof a.onClick&&(e.onclick=Ei)}for(c in ct(n,a),n=null,i)if(!a.hasOwnProperty(c)&&i.hasOwnProperty(c)&&null!=i[c])if("style"===c){var o=i[c];for(s in o)o.hasOwnProperty(s)&&(n||(n={}),n[s]="")}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(Y.hasOwnProperty(c)?r||(r=[]):(r=r||[]).push(c,null));for(c in a){var l=a[c];if(o=null!=i?i[c]:void 0,a.hasOwnProperty(c)&&l!==o&&(null!=l||null!=o))if("style"===c)if(o){for(s in o)!o.hasOwnProperty(s)||l&&l.hasOwnProperty(s)||(n||(n={}),n[s]="");for(s in l)l.hasOwnProperty(s)&&o[s]!==l[s]&&(n||(n={}),n[s]=l[s])}else n||(r||(r=[]),r.push(c,n)),n=l;else"dangerouslySetInnerHTML"===c?(l=l?l.__html:void 0,o=o?o.__html:void 0,null!=l&&o!==l&&(r=r||[]).push(c,l)):"children"===c?"string"!=typeof l&&"number"!=typeof l||(r=r||[]).push(c,""+l):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(Y.hasOwnProperty(c)?(null!=l&&"onScroll"===c&&fi("scroll",e),r||o===l||(r=[])):"object"==typeof l&&null!==l&&l.$$typeof===_e?l.toString():(r=r||[]).push(c,l))}n&&(r=r||[]).push("style",n);var c=r;(t.updateQueue=c)&&(t.flags|=4)}},Oo=function(e,t,n,a){n!==a&&(t.flags|=4)};var Zo="function"==typeof WeakMap?WeakMap:Map;function $o(e,t,n){(n=Ks(-1,n)).tag=3,n.payload={element:null};var a=t.value;return n.callback=function(){Ol||(Ol=!0,Fl=a),Ko(0,t)},n}function Qo(e,t,n){(n=Ks(-1,n)).tag=3;var a=e.type.getDerivedStateFromError;if("function"==typeof a){var i=t.value;n.payload=function(){return Ko(0,t),a(i)}}var s=e.stateNode;return null!==s&&"function"==typeof s.componentDidCatch&&(n.callback=function(){"function"!=typeof a&&(null===Nl?Nl=new Set([this]):Nl.add(this),Ko(0,t));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}var Jo="function"==typeof WeakSet?WeakSet:Set;function el(e){var t=e.ref;if(null!==t)if("function"==typeof t)try{t(null)}catch(t){Sc(e,t)}else t.current=null}function tl(e,t){switch(t.tag){case 0:case 11:case 15:case 22:case 5:case 6:case 4:case 17:return;case 1:if(256&t.flags&&null!==e){var n=e.memoizedProps,a=e.memoizedState;t=(e=t.stateNode).getSnapshotBeforeUpdate(t.elementType===t.type?n:Fs(t.type,n),a),e.__reactInternalSnapshotBeforeUpdate=t}return;case 3:return void(256&t.flags&&Pi(t.stateNode.containerInfo))}throw Error(j(163))}function nl(e,t,n){switch(n.tag){case 0:case 11:case 15:case 22:if(null!==(t=null!==(t=n.updateQueue)?t.lastEffect:null)){e=t=t.next;do{if(3==(3&e.tag)){var a=e.create;e.destroy=a()}e=e.next}while(e!==t)}if(null!==(t=null!==(t=n.updateQueue)?t.lastEffect:null)){e=t=t.next;do{var i=e;a=i.next,0!=(4&(i=i.tag))&&0!=(1&i)&&(Cc(n,e),xc(n,e)),e=a}while(e!==t)}return;case 1:return e=n.stateNode,4&n.flags&&(null===t?e.componentDidMount():(a=n.elementType===n.type?t.memoizedProps:Fs(n.type,t.memoizedProps),e.componentDidUpdate(a,t.memoizedState,e.__reactInternalSnapshotBeforeUpdate))),void(null!==(t=n.updateQueue)&&Js(n,t,e));case 3:if(null!==(t=n.updateQueue)){if(e=null,null!==n.child)switch(n.child.tag){case 5:case 1:e=n.child.stateNode}Js(n,t,e)}return;case 5:return e=n.stateNode,void(null===t&&4&n.flags&&Mi(n.type,n.memoizedProps)&&e.focus());case 6:case 4:case 12:case 19:case 17:case 20:case 21:case 23:case 24:return;case 13:return void(null===n.memoizedState&&(n=n.alternate,null!==n&&(n=n.memoizedState,null!==n&&(n=n.dehydrated,null!==n&&ln(n)))))}throw Error(j(163))}function al(e,t){for(var n=e;;){if(5===n.tag){var a=n.stateNode;if(t)"function"==typeof(a=a.style).setProperty?a.setProperty("display","none","important"):a.display="none";else{a=n.stateNode;var i=n.memoizedProps.style;i=null!=i&&i.hasOwnProperty("display")?i.display:null,a.style.display=rt("display",i)}}else if(6===n.tag)n.stateNode.nodeValue=t?"":n.memoizedProps;else if((23!==n.tag&&24!==n.tag||null===n.memoizedState||n===e)&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break;for(;null===n.sibling;){if(null===n.return||n.return===e)return;n=n.return}n.sibling.return=n.return,n=n.sibling}}function il(e,t){if(cs&&"function"==typeof cs.onCommitFiberUnmount)try{cs.onCommitFiberUnmount(ls,t)}catch(e){}switch(t.tag){case 0:case 11:case 14:case 15:case 22:if(null!==(e=t.updateQueue)&&null!==(e=e.lastEffect)){var n=e=e.next;do{var a=n,i=a.destroy;if(a=a.tag,void 0!==i)if(0!=(4&a))Cc(t,n);else{a=t;try{i()}catch(e){Sc(a,e)}}n=n.next}while(n!==e)}break;case 1:if(el(t),"function"==typeof(e=t.stateNode).componentWillUnmount)try{e.props=t.memoizedProps,e.state=t.memoizedState,e.componentWillUnmount()}catch(e){Sc(t,e)}break;case 5:el(t);break;case 4:hl(e,t)}}function sl(e){e.alternate=null,e.child=null,e.dependencies=null,e.firstEffect=null,e.lastEffect=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.return=null,e.updateQueue=null}function rl(e){return 5===e.tag||3===e.tag||4===e.tag}function ol(e){e:{for(var t=e.return;null!==t;){if(rl(t))break e;t=t.return}throw Error(j(160))}var n=t;switch(t=n.stateNode,n.tag){case 5:var a=!1;break;case 3:case 4:t=t.containerInfo,a=!0;break;default:throw Error(j(161))}16&n.flags&&(at(t,""),n.flags&=-17);e:t:for(n=e;;){for(;null===n.sibling;){if(null===n.return||rl(n.return)){n=null;break e}n=n.return}for(n.sibling.return=n.return,n=n.sibling;5!==n.tag&&6!==n.tag&&18!==n.tag;){if(2&n.flags)continue t;if(null===n.child||4===n.tag)continue t;n.child.return=n,n=n.child}if(!(2&n.flags)){n=n.stateNode;break e}}a?ll(e,n,t):cl(e,n,t)}function ll(e,t,n){var a=e.tag,i=5===a||6===a;if(i)e=i?e.stateNode:e.stateNode.instance,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!=(n=n._reactRootContainer)||null!==t.onclick||(t.onclick=Ei));else if(4!==a&&null!==(e=e.child))for(ll(e,t,n),e=e.sibling;null!==e;)ll(e,t,n),e=e.sibling}function cl(e,t,n){var a=e.tag,i=5===a||6===a;if(i)e=i?e.stateNode:e.stateNode.instance,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==a&&null!==(e=e.child))for(cl(e,t,n),e=e.sibling;null!==e;)cl(e,t,n),e=e.sibling}function hl(e,t){for(var n,a,i=t,s=!1;;){if(!s){s=i.return;e:for(;;){if(null===s)throw Error(j(160));switch(n=s.stateNode,s.tag){case 5:a=!1;break e;case 3:case 4:n=n.containerInfo,a=!0;break e}s=s.return}s=!0}if(5===i.tag||6===i.tag){e:for(var r=e,o=i,l=o;;)if(il(r,l),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===o)break e;for(;null===l.sibling;){if(null===l.return||l.return===o)break e;l=l.return}l.sibling.return=l.return,l=l.sibling}a?(r=n,o=i.stateNode,8===r.nodeType?r.parentNode.removeChild(o):r.removeChild(o)):n.removeChild(i.stateNode)}else if(4===i.tag){if(null!==i.child){n=i.stateNode.containerInfo,a=!0,i.child.return=i,i=i.child;continue}}else if(il(e,i),null!==i.child){i.child.return=i,i=i.child;continue}if(i===t)break;for(;null===i.sibling;){if(null===i.return||i.return===t)return;4===(i=i.return).tag&&(s=!1)}i.sibling.return=i.return,i=i.sibling}}function dl(e,t){switch(t.tag){case 0:case 11:case 14:case 15:case 22:var n=t.updateQueue;if(null!==(n=null!==n?n.lastEffect:null)){var a=n=n.next;do{3==(3&a.tag)&&(e=a.destroy,a.destroy=void 0,void 0!==e&&e()),a=a.next}while(a!==n)}return;case 1:case 12:case 17:return;case 5:if(null!=(n=t.stateNode)){a=t.memoizedProps;var i=null!==e?e.memoizedProps:a;e=t.type;var s=t.updateQueue;if(t.updateQueue=null,null!==s){for(n[Vi]=a,"input"===e&&"radio"===a.type&&null!=a.name&&Ue(n,a),ht(e,i),t=ht(e,a),i=0;i<s.length;i+=2){var r=s[i],o=s[i+1];"style"===r?ot(n,o):"dangerouslySetInnerHTML"===r?nt(n,o):"children"===r?at(n,o):se(n,r,o,t)}switch(e){case"input":ze(n,a);break;case"textarea":qe(n,a);break;case"select":e=n._wrapperState.wasMultiple,n._wrapperState.wasMultiple=!!a.multiple,null!=(s=a.value)?je(n,!!a.multiple,s,!1):e!==!!a.multiple&&(null!=a.defaultValue?je(n,!!a.multiple,a.defaultValue,!0):je(n,!!a.multiple,a.multiple?[]:"",!1))}}}return;case 6:if(null===t.stateNode)throw Error(j(162));return void(t.stateNode.nodeValue=t.memoizedProps);case 3:return void((n=t.stateNode).hydrate&&(n.hydrate=!1,ln(n.containerInfo)));case 13:return null!==t.memoizedState&&(Rl=Ms(),al(t.child,!0)),void pl(t);case 19:return void pl(t);case 23:case 24:return void al(t,null!==t.memoizedState)}throw Error(j(163))}function pl(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Jo),t.forEach((function(t){var a=Mc.bind(null,e,t);n.has(t)||(n.add(t),t.then(a,a))}))}}function ul(e,t){return null!==e&&(null===(e=e.memoizedState)||null!==e.dehydrated)&&(null!==(t=t.memoizedState)&&null===t.dehydrated)}var ml=Math.ceil,fl=re.ReactCurrentDispatcher,gl=re.ReactCurrentOwner,yl=0,bl=null,vl=null,_l=0,wl=0,xl=qi(0),Cl=0,Tl=null,El=0,Sl=0,Al=0,Ml=0,Ll=null,Rl=0,Il=1/0;function Pl(){Il=Ms()+500}var kl,Dl=null,Ol=!1,Fl=null,Nl=null,Vl=!1,Bl=null,Ul=90,zl=[],Gl=[],Hl=null,Wl=0,jl=null,Xl=-1,Yl=0,ql=0,Kl=null,Zl=!1;function $l(){return 0!=(48&yl)?Ms():-1!==Xl?Xl:Xl=Ms()}function Ql(e){if(0==(2&(e=e.mode)))return 1;if(0==(4&e))return 99===Ls()?1:2;if(0===Yl&&(Yl=El),0!==Os.transition){0!==ql&&(ql=null!==Ll?Ll.pendingLanes:0),e=Yl;var t=4186112&~ql;return 0===(t&=-t)&&(0===(t=(e=4186112&~e)&-e)&&(t=8192)),t}return e=Ls(),0!=(4&yl)&&98===e?e=Sn(12,Yl):e=Sn(e=function(e){switch(e){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}(e),Yl),e}function Jl(e,t,n){if(50<Wl)throw Wl=0,jl=null,Error(j(185));if(null===(e=ec(e,t)))return null;Ln(e,t,n),e===bl&&(Al|=t,4===Cl&&ac(e,_l));var a=Ls();1===t?0!=(8&yl)&&0==(48&yl)?ic(e):(tc(e,n),0===yl&&(Pl(),ks())):(0==(4&yl)||98!==a&&99!==a||(null===Hl?Hl=new Set([e]):Hl.add(e)),tc(e,n)),Ll=e}function ec(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}function tc(e,t){for(var n=e.callbackNode,a=e.suspendedLanes,i=e.pingedLanes,s=e.expirationTimes,r=e.pendingLanes;0<r;){var o=31-Rn(r),l=1<<o,c=s[o];if(-1===c){if(0==(l&a)||0!=(l&i)){c=t,Cn(l);var h=xn;s[o]=10<=h?c+250:6<=h?c+5e3:-1}}else c<=t&&(e.expiredLanes|=l);r&=~l}if(a=Tn(e,e===bl?_l:0),t=xn,0===a)null!==n&&(n!==xs&&ps(n),e.callbackNode=null,e.callbackPriority=0);else{if(null!==n){if(e.callbackPriority===t)return;n!==xs&&ps(n)}15===t?(n=ic.bind(null,e),null===Ts?(Ts=[n],Es=ds(ys,Ds)):Ts.push(n),n=xs):14===t?n=Ps(99,ic.bind(null,e)):(n=function(e){switch(e){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(j(358,e))}}(t),n=Ps(n,nc.bind(null,e))),e.callbackPriority=t,e.callbackNode=n}}function nc(e){if(Xl=-1,ql=Yl=0,0!=(48&yl))throw Error(j(327));var t=e.callbackNode;if(wc()&&e.callbackNode!==t)return null;var n=Tn(e,e===bl?_l:0);if(0===n)return null;var a=n,i=yl;yl|=16;var s=dc();for(bl===e&&_l===a||(Pl(),cc(e,a));;)try{fc();break}catch(t){hc(e,t)}if(zs(),fl.current=s,yl=i,null!==vl?a=0:(bl=null,_l=0,a=Cl),0!=(El&Al))cc(e,0);else if(0!==a){if(2===a&&(yl|=64,e.hydrate&&(e.hydrate=!1,Pi(e.containerInfo)),0!==(n=En(e))&&(a=uc(e,n))),1===a)throw t=Tl,cc(e,0),ac(e,n),tc(e,Ms()),t;switch(e.finishedWork=e.current.alternate,e.finishedLanes=n,a){case 0:case 1:throw Error(j(345));case 2:case 5:bc(e);break;case 3:if(ac(e,n),(62914560&n)===n&&10<(a=Rl+500-Ms())){if(0!==Tn(e,0))break;if(((i=e.suspendedLanes)&n)!==n){$l(),e.pingedLanes|=e.suspendedLanes&i;break}e.timeoutHandle=Ri(bc.bind(null,e),a);break}bc(e);break;case 4:if(ac(e,n),(4186112&n)===n)break;for(a=e.eventTimes,i=-1;0<n;){var r=31-Rn(n);s=1<<r,(r=a[r])>i&&(i=r),n&=~s}if(n=i,10<(n=(120>(n=Ms()-n)?120:480>n?480:1080>n?1080:1920>n?1920:3e3>n?3e3:4320>n?4320:1960*ml(n/1960))-n)){e.timeoutHandle=Ri(bc.bind(null,e),n);break}bc(e);break;default:throw Error(j(329))}}return tc(e,Ms()),e.callbackNode===t?nc.bind(null,e):null}function ac(e,t){for(t&=~Ml,t&=~Al,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-Rn(t),a=1<<n;e[n]=-1,t&=~a}}function ic(e){if(0!=(48&yl))throw Error(j(327));if(wc(),e===bl&&0!=(e.expiredLanes&_l)){var t=_l,n=uc(e,t);0!=(El&Al)&&(n=uc(e,t=Tn(e,t)))}else n=uc(e,t=Tn(e,0));if(0!==e.tag&&2===n&&(yl|=64,e.hydrate&&(e.hydrate=!1,Pi(e.containerInfo)),0!==(t=En(e))&&(n=uc(e,t))),1===n)throw n=Tl,cc(e,0),ac(e,t),tc(e,Ms()),n;return e.finishedWork=e.current.alternate,e.finishedLanes=t,bc(e),tc(e,Ms()),null}function sc(e,t){var n=yl;yl|=1;try{return e(t)}finally{0===(yl=n)&&(Pl(),ks())}}function rc(e,t){var n=yl;yl&=-2,yl|=8;try{return e(t)}finally{0===(yl=n)&&(Pl(),ks())}}function oc(e,t){Zi(xl,wl),wl|=t,El|=t}function lc(){wl=xl.current,Ki(xl)}function cc(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,Ii(n)),null!==vl)for(n=vl.return;null!==n;){var a=n;switch(a.tag){case 1:null!=(a=a.type.childContextTypes)&&as();break;case 3:vr(),Ki(Ji),Ki(Qi),Dr();break;case 5:wr(a);break;case 4:vr();break;case 13:case 19:Ki(xr);break;case 10:Gs(a);break;case 23:case 24:lc()}n=n.return}bl=e,vl=Pc(e.current,null),_l=wl=El=t,Cl=0,Tl=null,Ml=Al=Sl=0}function hc(e,t){for(;;){var n=vl;try{if(zs(),Or.current=yo,zr){for(var a=Vr.memoizedState;null!==a;){var i=a.queue;null!==i&&(i.pending=null),a=a.next}zr=!1}if(Nr=0,Ur=Br=Vr=null,Gr=!1,gl.current=null,null===n||null===n.return){Cl=1,Tl=t,vl=null;break}e:{var s=e,r=n.return,o=n,l=t;if(t=_l,o.flags|=2048,o.firstEffect=o.lastEffect=null,null!==l&&"object"==typeof l&&"function"==typeof l.then){var c=l;if(0==(2&o.mode)){var h=o.alternate;h?(o.updateQueue=h.updateQueue,o.memoizedState=h.memoizedState,o.lanes=h.lanes):(o.updateQueue=null,o.memoizedState=null)}var d=0!=(1&xr.current),p=r;do{var u;if(u=13===p.tag){var m=p.memoizedState;if(null!==m)u=null!==m.dehydrated;else{var f=p.memoizedProps;u=void 0!==f.fallback&&(!0!==f.unstable_avoidThisFallback||!d)}}if(u){var g=p.updateQueue;if(null===g){var y=new Set;y.add(c),p.updateQueue=y}else g.add(c);if(0==(2&p.mode)){if(p.flags|=64,o.flags|=16384,o.flags&=-2981,1===o.tag)if(null===o.alternate)o.tag=17;else{var b=Ks(-1,1);b.tag=2,Zs(o,b)}o.lanes|=1;break e}l=void 0,o=t;var v=s.pingCache;if(null===v?(v=s.pingCache=new Zo,l=new Set,v.set(c,l)):void 0===(l=v.get(c))&&(l=new Set,v.set(c,l)),!l.has(o)){l.add(o);var _=Ac.bind(null,s,c,o);c.then(_,_)}p.flags|=4096,p.lanes=t;break e}p=p.return}while(null!==p);l=Error((Pe(o.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")}5!==Cl&&(Cl=2),l=qo(l,o),p=r;do{switch(p.tag){case 3:s=l,p.flags|=4096,t&=-t,p.lanes|=t,$s(p,$o(0,s,t));break e;case 1:s=l;var w=p.type,x=p.stateNode;if(0==(64&p.flags)&&("function"==typeof w.getDerivedStateFromError||null!==x&&"function"==typeof x.componentDidCatch&&(null===Nl||!Nl.has(x)))){p.flags|=4096,t&=-t,p.lanes|=t,$s(p,Qo(p,s,t));break e}}p=p.return}while(null!==p)}yc(n)}catch(e){t=e,vl===n&&null!==n&&(vl=n=n.return);continue}break}}function dc(){var e=fl.current;return fl.current=yo,null===e?yo:e}function uc(e,t){var n=yl;yl|=16;var a=dc();for(bl===e&&_l===t||cc(e,t);;)try{mc();break}catch(t){hc(e,t)}if(zs(),yl=n,fl.current=a,null!==vl)throw Error(j(261));return bl=null,_l=0,Cl}function mc(){for(;null!==vl;)gc(vl)}function fc(){for(;null!==vl&&!us();)gc(vl)}function gc(e){var t=kl(e.alternate,e,wl);e.memoizedProps=e.pendingProps,null===t?yc(e):vl=t,gl.current=null}function yc(e){var t=e;do{var n=t.alternate;if(e=t.return,0==(2048&t.flags)){if(null!==(n=Xo(n,t,wl)))return void(vl=n);if(24!==(n=t).tag&&23!==n.tag||null===n.memoizedState||0!=(1073741824&wl)||0==(4&n.mode)){for(var a=0,i=n.child;null!==i;)a|=i.lanes|i.childLanes,i=i.sibling;n.childLanes=a}null!==e&&0==(2048&e.flags)&&(null===e.firstEffect&&(e.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==e.lastEffect&&(e.lastEffect.nextEffect=t.firstEffect),e.lastEffect=t.lastEffect),1<t.flags&&(null!==e.lastEffect?e.lastEffect.nextEffect=t:e.firstEffect=t,e.lastEffect=t))}else{if(null!==(n=Yo(t)))return n.flags&=2047,void(vl=n);null!==e&&(e.firstEffect=e.lastEffect=null,e.flags|=2048)}if(null!==(t=t.sibling))return void(vl=t);vl=t=e}while(null!==t);0===Cl&&(Cl=5)}function bc(e){var t=Ls();return Is(99,vc.bind(null,e,t)),null}function vc(e,t){do{wc()}while(null!==Bl);if(0!=(48&yl))throw Error(j(327));var n=e.finishedWork;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(j(177));e.callbackNode=null;var a=n.lanes|n.childLanes,i=a,s=e.pendingLanes&~i;e.pendingLanes=i,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=i,e.mutableReadLanes&=i,e.entangledLanes&=i,i=e.entanglements;for(var r=e.eventTimes,o=e.expirationTimes;0<s;){var l=31-Rn(s),c=1<<l;i[l]=0,r[l]=-1,o[l]=-1,s&=~c}if(null!==Hl&&0==(24&a)&&Hl.has(e)&&Hl.delete(e),e===bl&&(vl=bl=null,_l=0),1<n.flags?null!==n.lastEffect?(n.lastEffect.nextEffect=n,a=n.firstEffect):a=n:a=n.firstEffect,null!==a){if(i=yl,yl|=32,gl.current=null,Si=On,ni(r=ti())){if("selectionStart"in r)o={start:r.selectionStart,end:r.selectionEnd};else e:if(o=(o=r.ownerDocument)&&o.defaultView||window,(c=o.getSelection&&o.getSelection())&&0!==c.rangeCount){o=c.anchorNode,s=c.anchorOffset,l=c.focusNode,c=c.focusOffset;try{o.nodeType,l.nodeType}catch(e){o=null;break e}var h=0,d=-1,p=-1,u=0,m=0,f=r,g=null;t:for(;;){for(var y;f!==o||0!==s&&3!==f.nodeType||(d=h+s),f!==l||0!==c&&3!==f.nodeType||(p=h+c),3===f.nodeType&&(h+=f.nodeValue.length),null!==(y=f.firstChild);)g=f,f=y;for(;;){if(f===r)break t;if(g===o&&++u===s&&(d=h),g===l&&++m===c&&(p=h),null!==(y=f.nextSibling))break;g=(f=g).parentNode}f=y}o=-1===d||-1===p?null:{start:d,end:p}}else o=null;o=o||{start:0,end:0}}else o=null;Ai={focusedElem:r,selectionRange:o},On=!1,Kl=null,Zl=!1,Dl=a;do{try{_c()}catch(e){if(null===Dl)throw Error(j(330));Sc(Dl,e),Dl=Dl.nextEffect}}while(null!==Dl);Kl=null,Dl=a;do{try{for(r=e;null!==Dl;){var b=Dl.flags;if(16&b&&at(Dl.stateNode,""),128&b){var v=Dl.alternate;if(null!==v){var _=v.ref;null!==_&&("function"==typeof _?_(null):_.current=null)}}switch(1038&b){case 2:ol(Dl),Dl.flags&=-3;break;case 6:ol(Dl),Dl.flags&=-3,dl(Dl.alternate,Dl);break;case 1024:Dl.flags&=-1025;break;case 1028:Dl.flags&=-1025,dl(Dl.alternate,Dl);break;case 4:dl(Dl.alternate,Dl);break;case 8:hl(r,o=Dl);var w=o.alternate;sl(o),null!==w&&sl(w)}Dl=Dl.nextEffect}}catch(e){if(null===Dl)throw Error(j(330));Sc(Dl,e),Dl=Dl.nextEffect}}while(null!==Dl);if(_=Ai,v=ti(),b=_.focusedElem,r=_.selectionRange,v!==b&&b&&b.ownerDocument&&ei(b.ownerDocument.documentElement,b)){null!==r&&ni(b)&&(v=r.start,void 0===(_=r.end)&&(_=v),"selectionStart"in b?(b.selectionStart=v,b.selectionEnd=Math.min(_,b.value.length)):(_=(v=b.ownerDocument||document)&&v.defaultView||window).getSelection&&(_=_.getSelection(),o=b.textContent.length,w=Math.min(r.start,o),r=void 0===r.end?w:Math.min(r.end,o),!_.extend&&w>r&&(o=r,r=w,w=o),o=Ja(b,w),s=Ja(b,r),o&&s&&(1!==_.rangeCount||_.anchorNode!==o.node||_.anchorOffset!==o.offset||_.focusNode!==s.node||_.focusOffset!==s.offset)&&((v=v.createRange()).setStart(o.node,o.offset),_.removeAllRanges(),w>r?(_.addRange(v),_.extend(s.node,s.offset)):(v.setEnd(s.node,s.offset),_.addRange(v))))),v=[];for(_=b;_=_.parentNode;)1===_.nodeType&&v.push({element:_,left:_.scrollLeft,top:_.scrollTop});for("function"==typeof b.focus&&b.focus(),b=0;b<v.length;b++)(_=v[b]).element.scrollLeft=_.left,_.element.scrollTop=_.top}On=!!Si,Ai=Si=null,e.current=n,Dl=a;do{try{for(b=e;null!==Dl;){var x=Dl.flags;if(36&x&&nl(b,Dl.alternate,Dl),128&x){v=void 0;var C=Dl.ref;if(null!==C){var T=Dl.stateNode;Dl.tag,v=T,"function"==typeof C?C(v):C.current=v}}Dl=Dl.nextEffect}}catch(e){if(null===Dl)throw Error(j(330));Sc(Dl,e),Dl=Dl.nextEffect}}while(null!==Dl);Dl=null,Cs(),yl=i}else e.current=n;if(Vl)Vl=!1,Bl=e,Ul=t;else for(Dl=a;null!==Dl;)t=Dl.nextEffect,Dl.nextEffect=null,8&Dl.flags&&((x=Dl).sibling=null,x.stateNode=null),Dl=t;if(0===(a=e.pendingLanes)&&(Nl=null),1===a?e===jl?Wl++:(Wl=0,jl=e):Wl=0,n=n.stateNode,cs&&"function"==typeof cs.onCommitFiberRoot)try{cs.onCommitFiberRoot(ls,n,void 0,64==(64&n.current.flags))}catch(e){}if(tc(e,Ms()),Ol)throw Ol=!1,e=Fl,Fl=null,e;return 0!=(8&yl)||ks(),null}function _c(){for(;null!==Dl;){var e=Dl.alternate;Zl||null===Kl||(0!=(8&Dl.flags)?Bt(Dl,Kl)&&(Zl=!0):13===Dl.tag&&ul(e,Dl)&&Bt(Dl,Kl)&&(Zl=!0));var t=Dl.flags;0!=(256&t)&&tl(e,Dl),0==(512&t)||Vl||(Vl=!0,Ps(97,(function(){return wc(),null}))),Dl=Dl.nextEffect}}function wc(){if(90!==Ul){var e=97<Ul?97:Ul;return Ul=90,Is(e,Tc)}return!1}function xc(e,t){zl.push(t,e),Vl||(Vl=!0,Ps(97,(function(){return wc(),null})))}function Cc(e,t){Gl.push(t,e),Vl||(Vl=!0,Ps(97,(function(){return wc(),null})))}function Tc(){if(null===Bl)return!1;var e=Bl;if(Bl=null,0!=(48&yl))throw Error(j(331));var t=yl;yl|=32;var n=Gl;Gl=[];for(var a=0;a<n.length;a+=2){var i=n[a],s=n[a+1],r=i.destroy;if(i.destroy=void 0,"function"==typeof r)try{r()}catch(e){if(null===s)throw Error(j(330));Sc(s,e)}}for(n=zl,zl=[],a=0;a<n.length;a+=2){i=n[a],s=n[a+1];try{var o=i.create;i.destroy=o()}catch(e){if(null===s)throw Error(j(330));Sc(s,e)}}for(o=e.current.firstEffect;null!==o;)e=o.nextEffect,o.nextEffect=null,8&o.flags&&(o.sibling=null,o.stateNode=null),o=e;return yl=t,ks(),!0}function Ec(e,t,n){Zs(e,t=$o(0,t=qo(n,t),1)),t=$l(),null!==(e=ec(e,1))&&(Ln(e,1,t),tc(e,t))}function Sc(e,t){if(3===e.tag)Ec(e,e,t);else for(var n=e.return;null!==n;){if(3===n.tag){Ec(n,e,t);break}if(1===n.tag){var a=n.stateNode;if("function"==typeof n.type.getDerivedStateFromError||"function"==typeof a.componentDidCatch&&(null===Nl||!Nl.has(a))){var i=Qo(n,e=qo(t,e),1);if(Zs(n,i),i=$l(),null!==(n=ec(n,1)))Ln(n,1,i),tc(n,i);else if("function"==typeof a.componentDidCatch&&(null===Nl||!Nl.has(a)))try{a.componentDidCatch(t,e)}catch(e){}break}}n=n.return}}function Ac(e,t,n){var a=e.pingCache;null!==a&&a.delete(t),t=$l(),e.pingedLanes|=e.suspendedLanes&n,bl===e&&(_l&n)===n&&(4===Cl||3===Cl&&(62914560&_l)===_l&&500>Ms()-Rl?cc(e,0):Ml|=n),tc(e,t)}function Mc(e,t){var n=e.stateNode;null!==n&&n.delete(t),0===(t=0)&&(0==(2&(t=e.mode))?t=1:0==(4&t)?t=99===Ls()?1:2:(0===Yl&&(Yl=El),0===(t=An(62914560&~Yl))&&(t=4194304))),n=$l(),null!==(e=ec(e,t))&&(Ln(e,t,n),tc(e,n))}function Lc(e,t,n,a){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.flags=0,this.lastEffect=this.firstEffect=this.nextEffect=null,this.childLanes=this.lanes=0,this.alternate=null}function Rc(e,t,n,a){return new Lc(e,t,n,a)}function Ic(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Pc(e,t){var n=e.alternate;return null===n?((n=Rc(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.nextEffect=null,n.firstEffect=null,n.lastEffect=null),n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function kc(e,t,n,a,i,s){var r=2;if(a=e,"function"==typeof e)Ic(e)&&(r=1);else if("string"==typeof e)r=5;else e:switch(e){case ce:return Dc(n.children,i,s,t);case we:r=8,i|=16;break;case he:r=8,i|=1;break;case de:return(e=Rc(12,n,t,8|i)).elementType=de,e.type=de,e.lanes=s,e;case fe:return(e=Rc(13,n,t,i)).type=fe,e.elementType=fe,e.lanes=s,e;case ge:return(e=Rc(19,n,t,i)).elementType=ge,e.lanes=s,e;case xe:return Oc(n,i,s,t);case Ce:return(e=Rc(24,n,t,i)).elementType=Ce,e.lanes=s,e;default:if("object"==typeof e&&null!==e)switch(e.$$typeof){case pe:r=10;break e;case ue:r=9;break e;case me:r=11;break e;case ye:r=14;break e;case be:r=16,a=null;break e;case ve:r=22;break e}throw Error(j(130,null==e?e:typeof e,""))}return(t=Rc(r,n,t,i)).elementType=e,t.type=a,t.lanes=s,t}function Dc(e,t,n,a){return(e=Rc(7,e,a,t)).lanes=n,e}function Oc(e,t,n,a){return(e=Rc(23,e,a,t)).elementType=xe,e.lanes=n,e}function Fc(e,t,n){return(e=Rc(6,e,null,t)).lanes=n,e}function Nc(e,t,n){return(t=Rc(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function Vc(e,t,n){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.pendingContext=this.context=null,this.hydrate=n,this.callbackNode=null,this.callbackPriority=0,this.eventTimes=Mn(0),this.expirationTimes=Mn(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Mn(0),this.mutableSourceEagerHydrationData=null}function Bc(e,t,n){var a=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:le,key:null==a?null:""+a,children:e,containerInfo:t,implementation:n}}function Uc(e,t,n,a){var i=t.current,s=$l(),r=Ql(i);e:if(n){t:{if(Ot(n=n._reactInternals)!==n||1!==n.tag)throw Error(j(170));var o=n;do{switch(o.tag){case 3:o=o.stateNode.context;break t;case 1:if(ns(o.type)){o=o.stateNode.__reactInternalMemoizedMergedChildContext;break t}}o=o.return}while(null!==o);throw Error(j(171))}if(1===n.tag){var l=n.type;if(ns(l)){n=ss(n,l,o);break e}}n=o}else n=$i;return null===t.context?t.context=n:t.pendingContext=n,(t=Ks(s,r)).payload={element:e},null!==(a=void 0===a?null:a)&&(t.callback=a),Zs(i,t),Jl(i,r,s),r}function zc(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Gc(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Hc(e,t){Gc(e,t),(e=e.alternate)&&Gc(e,t)}function Wc(e,t,n){var a=null!=n&&null!=n.hydrationOptions&&n.hydrationOptions.mutableSources||null;if(n=new Vc(e,t,null!=n&&!0===n.hydrate),t=Rc(3,null,null,2===t?7:1===t?3:0),n.current=t,t.stateNode=n,Ys(t),e[Bi]=n.current,yi(8===e.nodeType?e.parentNode:e),a)for(e=0;e<a.length;e++){var i=(t=a[e])._getVersion;i=i(t._source),null==n.mutableSourceEagerHydrationData?n.mutableSourceEagerHydrationData=[t,i]:n.mutableSourceEagerHydrationData.push(t,i)}this._internalRoot=n}function jc(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Xc(e,t,n,a,i){var s=n._reactRootContainer;if(s){var r=s._internalRoot;if("function"==typeof i){var o=i;i=function(){var e=zc(r);o.call(e)}}Uc(t,r,e,i)}else{if(s=n._reactRootContainer=function(e,t){if(t||(t=!(!(t=e?9===e.nodeType?e.documentElement:e.firstChild:null)||1!==t.nodeType||!t.hasAttribute("data-reactroot"))),!t)for(var n;n=e.lastChild;)e.removeChild(n);return new Wc(e,0,t?{hydrate:!0}:void 0)}(n,a),r=s._internalRoot,"function"==typeof i){var l=i;i=function(){var e=zc(r);l.call(e)}}rc((function(){Uc(t,r,e,i)}))}return zc(r)}function Yc(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!jc(t))throw Error(j(200));return Bc(e,t,null,n)}kl=function(e,t,n){var a=t.lanes;if(null!==e)if(e.memoizedProps!==t.pendingProps||Ji.current)xo=!0;else{if(0==(n&a)){switch(xo=!1,t.tag){case 3:Po(t),Pr();break;case 5:_r(t);break;case 1:ns(t.type)&&rs(t);break;case 4:br(t,t.stateNode.containerInfo);break;case 10:a=t.memoizedProps.value;var i=t.type._context;Zi(Ns,i._currentValue),i._currentValue=a;break;case 13:if(null!==t.memoizedState)return 0!=(n&t.child.childLanes)?No(e,t,n):(Zi(xr,1&xr.current),null!==(t=Wo(e,t,n))?t.sibling:null);Zi(xr,1&xr.current);break;case 19:if(a=0!=(n&t.childLanes),0!=(64&e.flags)){if(a)return Ho(e,t,n);t.flags|=64}if(null!==(i=t.memoizedState)&&(i.rendering=null,i.tail=null,i.lastEffect=null),Zi(xr,xr.current),a)break;return null;case 23:case 24:return t.lanes=0,Ao(e,t,n)}return Wo(e,t,n)}xo=0!=(16384&e.flags)}else xo=!1;switch(t.lanes=0,t.tag){case 2:if(a=t.type,null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),e=t.pendingProps,i=ts(t,Qi.current),Ws(t,n),i=jr(null,t,a,e,i,n),t.flags|=1,"object"==typeof i&&null!==i&&"function"==typeof i.render&&void 0===i.$$typeof){if(t.tag=1,t.memoizedState=null,t.updateQueue=null,ns(a)){var s=!0;rs(t)}else s=!1;t.memoizedState=null!==i.state&&void 0!==i.state?i.state:null,Ys(t);var r=a.getDerivedStateFromProps;"function"==typeof r&&tr(t,a,r,e),i.updater=nr,t.stateNode=i,i._reactInternals=t,rr(t,a,e,n),t=Io(null,t,a,!0,s,n)}else t.tag=0,Co(null,t,i,n),t=t.child;return t;case 16:i=t.elementType;e:{switch(null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),e=t.pendingProps,i=(s=i._init)(i._payload),t.type=i,s=t.tag=function(e){if("function"==typeof e)return Ic(e)?1:0;if(null!=e){if((e=e.$$typeof)===me)return 11;if(e===ye)return 14}return 2}(i),e=Fs(i,e),s){case 0:t=Lo(null,t,i,e,n);break e;case 1:t=Ro(null,t,i,e,n);break e;case 11:t=To(null,t,i,e,n);break e;case 14:t=Eo(null,t,i,Fs(i.type,e),a,n);break e}throw Error(j(306,i,""))}return t;case 0:return a=t.type,i=t.pendingProps,Lo(e,t,a,i=t.elementType===a?i:Fs(a,i),n);case 1:return a=t.type,i=t.pendingProps,Ro(e,t,a,i=t.elementType===a?i:Fs(a,i),n);case 3:if(Po(t),a=t.updateQueue,null===e||null===a)throw Error(j(282));if(a=t.pendingProps,i=null!==(i=t.memoizedState)?i.element:null,qs(e,t),Qs(t,a,null,n),(a=t.memoizedState.element)===i)Pr(),t=Wo(e,t,n);else{if((s=(i=t.stateNode).hydrate)&&(Er=ki(t.stateNode.containerInfo.firstChild),Tr=t,s=Sr=!0),s){if(null!=(e=i.mutableSourceEagerHydrationData))for(i=0;i<e.length;i+=2)(s=e[i])._workInProgressVersionPrimary=e[i+1],kr.push(s);for(n=pr(t,null,a,n),t.child=n;n;)n.flags=-3&n.flags|1024,n=n.sibling}else Co(e,t,a,n),Pr();t=t.child}return t;case 5:return _r(t),null===e&&Lr(t),a=t.type,i=t.pendingProps,s=null!==e?e.memoizedProps:null,r=i.children,Li(a,i)?r=null:null!==s&&Li(a,s)&&(t.flags|=16),Mo(e,t),Co(e,t,r,n),t.child;case 6:return null===e&&Lr(t),null;case 13:return No(e,t,n);case 4:return br(t,t.stateNode.containerInfo),a=t.pendingProps,null===e?t.child=dr(t,null,a,n):Co(e,t,a,n),t.child;case 11:return a=t.type,i=t.pendingProps,To(e,t,a,i=t.elementType===a?i:Fs(a,i),n);case 7:return Co(e,t,t.pendingProps,n),t.child;case 8:case 12:return Co(e,t,t.pendingProps.children,n),t.child;case 10:e:{a=t.type._context,i=t.pendingProps,r=t.memoizedProps,s=i.value;var o=t.type._context;if(Zi(Ns,o._currentValue),o._currentValue=s,null!==r)if(o=r.value,0===(s=Ka(o,s)?0:0|("function"==typeof a._calculateChangedBits?a._calculateChangedBits(o,s):1073741823))){if(r.children===i.children&&!Ji.current){t=Wo(e,t,n);break e}}else for(null!==(o=t.child)&&(o.return=t);null!==o;){var l=o.dependencies;if(null!==l){r=o.child;for(var c=l.firstContext;null!==c;){if(c.context===a&&0!=(c.observedBits&s)){1===o.tag&&((c=Ks(-1,n&-n)).tag=2,Zs(o,c)),o.lanes|=n,null!==(c=o.alternate)&&(c.lanes|=n),Hs(o.return,n),l.lanes|=n;break}c=c.next}}else r=10===o.tag&&o.type===t.type?null:o.child;if(null!==r)r.return=o;else for(r=o;null!==r;){if(r===t){r=null;break}if(null!==(o=r.sibling)){o.return=r.return,r=o;break}r=r.return}o=r}Co(e,t,i.children,n),t=t.child}return t;case 9:return i=t.type,a=(s=t.pendingProps).children,Ws(t,n),a=a(i=js(i,s.unstable_observedBits)),t.flags|=1,Co(e,t,a,n),t.child;case 14:return s=Fs(i=t.type,t.pendingProps),Eo(e,t,i,s=Fs(i.type,s),a,n);case 15:return So(e,t,t.type,t.pendingProps,a,n);case 17:return a=t.type,i=t.pendingProps,i=t.elementType===a?i:Fs(a,i),null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),t.tag=1,ns(a)?(e=!0,rs(t)):e=!1,Ws(t,n),ir(t,a,i),rr(t,a,i,n),Io(null,t,a,!0,e,n);case 19:return Ho(e,t,n);case 23:case 24:return Ao(e,t,n)}throw Error(j(156,t.tag))},Wc.prototype.render=function(e){Uc(e,this._internalRoot,null,null)},Wc.prototype.unmount=function(){var e=this._internalRoot,t=e.containerInfo;Uc(null,e,null,(function(){t[Bi]=null}))},Ut=function(e){13===e.tag&&(Jl(e,4,$l()),Hc(e,4))},zt=function(e){13===e.tag&&(Jl(e,67108864,$l()),Hc(e,67108864))},Gt=function(e){if(13===e.tag){var t=$l(),n=Ql(e);Jl(e,n,t),Hc(e,n)}},Ht=function(e,t){return t()},pt=function(e,t,n){switch(t){case"input":if(ze(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var a=n[t];if(a!==e&&a.form===e.form){var i=Wi(a);if(!i)throw Error(j(90));Fe(a),ze(a,i)}}}break;case"textarea":qe(e,n);break;case"select":null!=(t=n.value)&&je(e,!!n.multiple,t,!1)}},bt=sc,vt=function(e,t,n,a,i){var s=yl;yl|=4;try{return Is(98,e.bind(null,t,n,a,i))}finally{0===(yl=s)&&(Pl(),ks())}},_t=function(){0==(49&yl)&&(function(){if(null!==Hl){var e=Hl;Hl=null,e.forEach((function(e){e.expiredLanes|=24&e.pendingLanes,tc(e,Ms())}))}ks()}(),wc())},wt=function(e,t){var n=yl;yl|=2;try{return e(t)}finally{0===(yl=n)&&(Pl(),ks())}};var qc={Events:[Gi,Hi,Wi,gt,yt,wc,{current:!1}]},Kc={findFiberByHostInstance:zi,bundleType:0,version:"17.0.2",rendererPackageName:"react-dom"},Zc={bundleType:Kc.bundleType,version:Kc.version,rendererPackageName:Kc.rendererPackageName,rendererConfig:Kc.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:re.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Vt(e))?null:e.stateNode},findFiberByHostInstance:Kc.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var $c=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!$c.isDisabled&&$c.supportsFiber)try{ls=$c.inject(Zc),cs=$c}catch(tt){}}B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=qc,B.createPortal=Yc,B.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"==typeof e.render)throw Error(j(188));throw Error(j(268,Object.keys(e)))}return e=null===(e=Vt(t))?null:e.stateNode},B.flushSync=function(e,t){var n=yl;if(0!=(48&n))return e(t);yl|=1;try{if(e)return Is(99,e.bind(null,t))}finally{yl=n,ks()}},B.hydrate=function(e,t,n){if(!jc(t))throw Error(j(200));return Xc(null,e,t,!0,n)},B.render=function(e,t,n){if(!jc(t))throw Error(j(200));return Xc(null,e,t,!1,n)},B.unmountComponentAtNode=function(e){if(!jc(e))throw Error(j(40));return!!e._reactRootContainer&&(rc((function(){Xc(null,null,e,!1,(function(){e._reactRootContainer=null,e[Bi]=null}))})),!0)},B.unstable_batchedUpdates=sc,B.unstable_createPortal=function(e,t){return Yc(e,t,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)},B.unstable_renderSubtreeIntoContainer=function(e,t,n,a){if(!jc(n))throw Error(j(200));if(null==e||void 0===e._reactInternals)throw Error(j(38));return Xc(e,t,n,!1,a)},B.version="17.0.2";var Qc={},Jc=0;
/** @license React v0.20.2
 * scheduler-tracing.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */Qc.__interactionsRef=null,Qc.__subscriberRef=null,Qc.unstable_clear=function(e){return e()},Qc.unstable_getCurrent=function(){return null},Qc.unstable_getThreadID=function(){return++Jc},Qc.unstable_subscribe=function(){},Qc.unstable_trace=function(e,t,n){return n()},Qc.unstable_unsubscribe=function(){},Qc.unstable_wrap=function(e){return e},function e(){if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(e){console.error(e)}}(),V.exports=B;var eh=V.exports;function th(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function nh(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?th(Object(n),!0).forEach((function(t){rh(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):th(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function ah(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function ih(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function sh(e,t,n){return t&&ih(e.prototype,t),n&&ih(e,n),e}function rh(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function oh(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&ch(e,t)}function lh(e){return lh=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},lh(e)}function ch(e,t){return ch=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},ch(e,t)}function hh(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function dh(e,t){if(t&&("object"==typeof t||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return hh(e)}function ph(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,a=lh(e);if(t){var i=lh(this).constructor;n=Reflect.construct(a,arguments,i)}else n=a.apply(this,arguments);return dh(this,n)}}function uh(e,t,n){return uh="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var a=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=lh(e)););return e}(e,t);if(a){var i=Object.getOwnPropertyDescriptor(a,t);return i.get?i.get.call(n):i.value}},uh(e,t,n||e)}var mh="pcui-resizable",fh="pcui-focus",gh="pcui-multiple-values";class yh{constructor(e,t,n){this.owner=e,this.name=t,this.fn=n}unbind(){this.owner&&(this.owner.unbind(this.name,this.fn),this.owner=null,this.name=null,this.fn=null)}call(){this.fn&&this.fn.call(this.owner,arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7])}on(e,t){return this.owner.on(e,t)}}class bh{constructor(){Object.defineProperty(this,"_events",{enumerable:!1,configurable:!1,writable:!0,value:{}}),this._suspendEvents=!1,this._additionalEmitters=[]}get suspendEvents(){return this._suspendEvents}set suspendEvents(e){this._suspendEvents=!!e}on(e,t){const n=this._events[e];return void 0===n?this._events[e]=[t]:-1===n.indexOf(t)&&n.push(t),new yh(this,e,t)}once(e,t){const n=this.on(e,((e,a,i,s,r,o,l,c)=>{t.call(this,e,a,i,s,r,o,l,c),n.unbind()}));return n}emit(e,t,n,a,i,s,r,o,l){if(this._suspendEvents)return;let c=this._events[e];if(c&&c.length){c=c.slice(0);for(let h=0;h<c.length;h++)if(c[h])try{c[h].call(this,t,n,a,i,s,r,o,l)}catch(t){console.info("%c%s %c(event error)","color: #06f",e,"color: #f00"),console.log(t.stack)}}if(this._additionalEmitters.length){this._additionalEmitters.slice().forEach((c=>{c.emit(e,t,n,a,i,s,r,o,l)}))}return this}unbind(e,t){if(e){const n=this._events[e];if(!n)return this;if(t){const a=n.indexOf(t);-1!==a&&(1===n.length?delete this._events[e]:n.splice(a,1))}else delete this._events[e]}else this._events={};return this}addEmitter(e){this._additionalEmitters.includes(e)||this._additionalEmitters.push(e)}removeEmitter(e){const t=this._additionalEmitters.indexOf(e);-1!==t&&this._additionalEmitters.splice(t,1)}}class vh extends bh{constructor(e,t={}){if(super(),this._destroyed=!1,this._path="",this._keys=[],this._data={},this._pathsWithDuplicates=null,t.pathsWithDuplicates){this._pathsWithDuplicates={};for(let e=0;e<t.pathsWithDuplicates.length;e++)this._pathsWithDuplicates[t.pathsWithDuplicates[e]]=!0}this.patch(e),this._parent=t.parent||null,this._parentPath=t.parentPath||"",this._parentField=t.parentField||null,this._parentKey=t.parentKey||null,this._latestFn=t.latestFn||null,this._silent=!1;const n=function(e){return function(t,n,a,i){if(!this._parent)return;let s,r=this._parentKey;!r&&this._parentField instanceof Array&&(r=this._parentField.indexOf(this),-1===r)||(t=this._parentPath+"."+r+"."+t,this._silent&&(s=this._parent.silence()),this._parent.emit(t+":"+e,n,a,i),this._parent.emit("*:"+e,t,n,a,i),this._silent&&this._parent.silenceRestore(s))}};this.on("*:set",n("set")),this.on("*:unset",n("unset")),this.on("*:insert",n("insert")),this.on("*:remove",n("remove")),this.on("*:move",n("move"))}static _splitPath(e){const t=vh._splitPathsCache;let n=t[e];return n?n=n.slice():(n=e.split("."),t[e]=n),n}silence(){this._silent=!0;const e=this.history&&this.history.enabled;e&&(this.history.enabled=!1);const t=this.sync&&this.sync.enabled;return t&&(this.sync.enabled=!1),[e,t]}silenceRestore(e){this._silent=!1,e[0]&&(this.history.enabled=!0),e[1]&&(this.sync.enabled=!0)}_prepare(e,t,n,a,i){let s,r;const o=(e._path?e._path+".":"")+t,l=typeof n;if(e._keys.push(t),"object"===l&&n instanceof Array){for(e._data[t]=n.slice(0),s=0;s<e._data[t].length;s++)"object"==typeof e._data[t][s]&&null!==e._data[t][s]?e._data[t][s]instanceof Array?e._data[t][s].slice(0):e._data[t][s]=new vh(e._data[t][s],{parent:this,parentPath:o,parentField:e._data[t],parentKey:null}):(r=this.silence(),this.emit(o+"."+s+":set",e._data[t][s],null,i),this.emit("*:set",o+"."+s,e._data[t][s],null,i),this.silenceRestore(r));a&&(r=this.silence()),this.emit(o+":set",e._data[t],null,i),this.emit("*:set",o,e._data[t],null,i),a&&this.silenceRestore(r)}else if("object"===l&&n instanceof Object){for(s in"object"!=typeof e._data[t]&&(e._data[t]={_path:o,_keys:[],_data:{}}),n)"object"==typeof n[s]?this._prepare(e._data[t],s,n[s],!0,i):(r=this.silence(),e._data[t]._data[s]=n[s],e._data[t]._keys.push(s),this.emit(o+"."+s+":set",n[s],null,i),this.emit("*:set",o+"."+s,n[s],null,i),this.silenceRestore(r));a&&(r=this.silence()),this.emit(o+":set",n,void 0,i),this.emit("*:set",o,n,void 0,i),a&&this.silenceRestore(r)}else a&&(r=this.silence()),e._data[t]=n,this.emit(o+":set",n,void 0,i),this.emit("*:set",o,n,void 0,i),a&&this.silenceRestore(r);return!0}set(e,t,n,a,i){let s,r,o=vh._splitPath(e);const l=o.length,c=o[l-1];let h,d,p=this,u="",m=this;for(s=0;s<l-1;s++)p instanceof Array?(p=p[o[s]],p instanceof vh&&(e=o.slice(s+1).join("."),m=p)):(s<l&&"object"!=typeof p._data[o[s]]&&(p._data[o[s]]&&m.unset((p.__path?p.__path+".":"")+o[s]),p._data[o[s]]={_path:e,_keys:[],_data:{}},p._keys.push(o[s])),s===l-1&&p.__path&&(u=p.__path+"."+o[s]),p=p._data[o[s]]);if(p instanceof Array){const s=parseInt(c,10);if(p[s]===t&&!i)return;return r=p[s],r=r instanceof vh?r.json():m.json(r),p[s]=t,t instanceof vh&&(t._parent=m,t._parentPath=u,t._parentField=p,t._parentKey=null),n&&(h=m.silence()),m.emit(e+":set",t,r,a),m.emit("*:set",e,t,r,a),n&&m.silenceRestore(h),!0}if(p._data&&!p._data.hasOwnProperty(c))return"object"==typeof t?m._prepare(p,c,t,!1,a):(p._data[c]=t,p._keys.push(c),n&&(h=m.silence()),m.emit(e+":set",t,null,a),m.emit("*:set",e,t,null,a),n&&m.silenceRestore(h),!0);if("object"==typeof t&&t instanceof Array){if(t.equals(p._data[c])&&!i)return!1;if(r=p._data[c],r instanceof vh||(r=m.json(r)),p._data[c]&&p._data[c].length===t.length){for(h=m.silence(),0===t.length&&(p._data[c]=t),s=0;s<p._data[c].length;s++)p._data[c][s]instanceof vh?p._data[c][s].patch(t[s],!0):p._data[c][s]!==t[s]&&(p._data[c][s]=t[s],m.emit(e+"."+s+":set",p._data[c][s],r&&r[s]||null,a),m.emit("*:set",e+"."+s,p._data[c][s],r&&r[s]||null,a));m.silenceRestore(h)}else{for(p._data[c]=[],t.forEach((e=>{this._doInsert(p,c,e,void 0,!0)})),h=m.silence(),s=0;s<p._data[c].length;s++)m.emit(e+"."+s+":set",p._data[c][s],r&&r[s]||null,a),m.emit("*:set",e+"."+s,p._data[c][s],r&&r[s]||null,a);m.silenceRestore(h)}return n&&(h=m.silence()),m.emit(e+":set",t,r,a),m.emit("*:set",e,t,r,a),n&&m.silenceRestore(h),!0}if("object"==typeof t&&t instanceof Object){let i,l=!1;r=p._data[c],r instanceof vh||(r=m.json(r)),o=Object.keys(t),p._data[c]&&p._data[c]._data||(p._data[c]?m.unset((p.__path?p.__path+".":"")+c):l=!0,p._data[c]={_path:e,_keys:[],_data:{}});for(const n in p._data[c]._data)t.hasOwnProperty(n)?p._data[c]._data.hasOwnProperty(n)?m._equals(p._data[c]._data[n],t[n])||(i=m.set(e+"."+n,t[n],!0),i&&(l=!0)):(i=m._prepare(p._data[c],n,t[n],!0,a),i&&(l=!0)):(i=m.unset(e+"."+n,!0),i&&(l=!0));for(s=0;s<o.length;s++)void 0===t[o[s]]&&p._data[c]._data.hasOwnProperty(o[s])?(i=m.unset(e+"."+o[s],!0),i&&(l=!0)):"object"==typeof t[o[s]]?p._data[c]._data.hasOwnProperty(o[s])?(i=m.set(e+"."+o[s],t[o[s]],!0),i&&(l=!0)):(i=m._prepare(p._data[c],o[s],t[o[s]],!0,a),i&&(l=!0)):m._equals(p._data[c]._data[o[s]],t[o[s]])||("object"==typeof t[o[s]]?(i=m.set(p._data[c]._path+"."+o[s],t[o[s]],!0),i&&(l=!0)):p._data[c]._data[o[s]]!==t[o[s]]&&(l=!0,-1===p._data[c]._keys.indexOf(o[s])&&p._data[c]._keys.push(o[s]),p._data[c]._data[o[s]]=t[o[s]],h=m.silence(),m.emit(p._data[c]._path+"."+o[s]+":set",p._data[c]._data[o[s]],null,a),m.emit("*:set",p._data[c]._path+"."+o[s],p._data[c]._data[o[s]],null,a),m.silenceRestore(h)));if(l){n&&(h=m.silence());const e=m.json(p._data[c]);return m.emit(p._data[c]._path+":set",e,r,a),m.emit("*:set",p._data[c]._path,e,r,a),n&&m.silenceRestore(h),!0}return!1}return d=!p.hasOwnProperty("_data")&&p.hasOwnProperty(c)?p:p._data,!(d[c]===t&&!i)&&(n&&(h=m.silence()),r=d[c],r instanceof vh||(r=m.json(r)),d[c]=t,m.emit(e+":set",t,r,a),m.emit("*:set",e,t,r,a),n&&m.silenceRestore(h),!0)}has(e){const t=vh._splitPath(e);let n=this;for(let e=0,a=t.length;e<a;e++){if(null==n)return;n=n._data?n._data[t[e]]:n[t[e]]}return void 0!==n}get(e,t){const n=vh._splitPath(e);let a=this;for(let e=0;e<n.length;e++){if(null==a)return;a=a._data?a._data[n[e]]:a[n[e]]}return t?a:null==a?null:this.json(a)}getRaw(e){return this.get(e,!0)}_equals(e,t){return e===t||!!(e instanceof Array&&t instanceof Array&&e.equals(t))}unset(e,t,n){let a;const i=vh._splitPath(e),s=i[i.length-1];let r=this,o=this;for(a=0;a<i.length-1;a++)r instanceof Array?(r=r[i[a]],r instanceof vh&&(e=i.slice(a+1).join("."),o=r)):r=r._data[i[a]];if(!r._data||!r._data.hasOwnProperty(s))return!1;let l,c=r._data[s];if(c instanceof vh||(c=o.json(c)),r._data[s]&&r._data[s]._data)for(a=r._data[s]._keys.length-1;a>=0;a--)o.unset(e+"."+r._data[s]._keys[a],!0);return r._keys.splice(r._keys.indexOf(s),1),delete r._data[s],t&&(l=o.silence()),o.emit(e+":unset",c,n),o.emit("*:unset",e,c,n),t&&o.silenceRestore(l),!0}remove(e,t,n,a){const i=vh._splitPath(e),s=i[i.length-1];let r=this,o=this;for(let t=0;t<i.length-1;t++)if(r instanceof Array)r=r[parseInt(i[t],10)],r instanceof vh&&(e=i.slice(t+1).join("."),o=r);else{if(!r._data||!r._data.hasOwnProperty(i[t]))return;r=r._data[i[t]]}if(!(r._data&&r._data.hasOwnProperty(s)&&r._data[s]instanceof Array))return;const l=r._data[s];if(l.length<t)return;let c,h=l[t];return h instanceof vh?h._parent=null:h=o.json(h),l.splice(t,1),n&&(c=o.silence()),o.emit(e+":remove",h,t,a),o.emit("*:remove",e,h,t,a),n&&o.silenceRestore(c),!0}removeValue(e,t,n,a){const i=vh._splitPath(e),s=i[i.length-1];let r=this,o=this;for(let t=0;t<i.length-1;t++)if(r instanceof Array)r=r[parseInt(i[t],10)],r instanceof vh&&(e=i.slice(t+1).join("."),o=r);else{if(!r._data||!r._data.hasOwnProperty(i[t]))return;r=r._data[i[t]]}if(!(r._data&&r._data.hasOwnProperty(s)&&r._data[s]instanceof Array))return;const l=r._data[s],c=l.indexOf(t);if(-1===c)return;if(l.length<c)return;let h;return(t=l[c])instanceof vh?t._parent=null:t=o.json(t),l.splice(c,1),n&&(h=o.silence()),o.emit(e+":remove",t,c,a),o.emit("*:remove",e,t,c,a),n&&o.silenceRestore(h),!0}insert(e,t,n,a,i){const s=vh._splitPath(e),r=s[s.length-1];let o=this,l=this;for(let t=0;t<s.length-1;t++)if(o instanceof Array)o=o[parseInt(s[t],10)],o instanceof vh&&(e=s.slice(t+1).join("."),l=o);else{if(!o._data||!o._data.hasOwnProperty(s[t]))return;o=o._data[s[t]]}if(!(o._data&&o._data.hasOwnProperty(r)&&o._data[r]instanceof Array))return;const c=o._data[r];let h;return t=l._doInsert(o,r,t,n),void 0===n&&(n=c.length-1),a&&(h=l.silence()),l.emit(e+":insert",t,n,i),l.emit("*:insert",e,t,n,i),a&&l.silenceRestore(h),!0}_doInsert(e,t,n,a,i){const s=e._data[t];"object"!=typeof n||n instanceof vh||null===n||(n=n instanceof Array?n.slice(0):new vh(n));const r=e._path?`${e._path}.${t}`:t;if(null===n||i||this._pathsWithDuplicates&&this._pathsWithDuplicates[r]||-1===s.indexOf(n))return void 0===a?s.push(n):s.splice(a,0,n),n instanceof vh?(n._parent=this,n._parentPath=r,n._parentField=s,n._parentKey=null):n=this.json(n),n}move(e,t,n,a,i){const s=vh._splitPath(e),r=s[s.length-1];let o=this,l=this;for(let t=0;t<s.length-1;t++)if(o instanceof Array)o=o[parseInt(s[t],10)],o instanceof vh&&(e=s.slice(t+1).join("."),l=o);else{if(!o._data||!o._data.hasOwnProperty(s[t]))return;o=o._data[s[t]]}if(!(o._data&&o._data.hasOwnProperty(r)&&o._data[r]instanceof Array))return;const c=o._data[r];if(c.length<t||c.length<n||t===n)return;let h,d=c[t];return c.splice(t,1),-1===n&&(n=c.length),c.splice(n,0,d),d instanceof vh||(d=l.json(d)),a&&(h=l.silence()),l.emit(e+":move",d,n,t,i),l.emit("*:move",e,d,n,t,i),a&&l.silenceRestore(h),!0}patch(e,t){if("object"==typeof e){for(const t in e)"object"!=typeof e[t]||this._data.hasOwnProperty(t)?this._data[t]!==e[t]&&this.set(t,e[t]):this._prepare(this,t,e[t]);if(t)for(const t in this._data)e.hasOwnProperty(t)||this.unset(t)}}json(e){let t,n,a={};const i=void 0===e?this:e;let s,r;if(i instanceof Object&&i._keys){s=i._keys.length;for(let e=0;e<s;e++){t=i._keys[e];const s=i._data[t],o=typeof s;if("object"===o&&s instanceof Array)for(a[t]=s.slice(0),r=a[t].length,n=0;n<r;n++)"object"==typeof a[t][n]&&(a[t][n]=this.json(a[t][n]));else a[t]="object"===o&&s instanceof Object?this.json(s):s}}else{if(null===i)return null;if("object"==typeof i&&i instanceof Array)for(a=i.slice(0),s=a.length,n=0;n<s;n++)a[n]=this.json(a[n]);else if("object"==typeof i)for(t in i)i.hasOwnProperty(t)&&(a[t]=i[t]);else a=i}return a}forEach(e,t,n=""){const a=t||this;for(let t=0;t<a._keys.length;t++){const i=a._keys[t],s=a._data[i],r=this.schema&&this.schema.has(n+i)&&this.schema.get(n+i).type.name.toLowerCase()||typeof s;"object"===r&&s instanceof Array?e(n+i,"array",s,i):"object"===r&&s instanceof Object?(e(n+i,"object",s,i),this.forEach(e,s,n+i+".")):e(n+i,r,s,i)}}latest(){return this._latestFn?this._latestFn():this}destroy(){this._destroyed||(this._destroyed=!0,this.emit("destroy"),this.unbind())}get latestFn(){return this._latestFn}set latestFn(e){this._latestFn=e}}vh._splitPathsCache={},function(e){if(!e||!window)return;const t=document.createElement("style");t.setAttribute("type","text/css"),t.innerHTML=e,document.head.appendChild(t)}('@font-face {\n  font-family: "pc-icon";\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot");\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix") format("embedded-opentype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2") format("woff2"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff") format("woff"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf") format("truetype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg") format("svg");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular, .pcui-element {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon {\n  font-family: "pc-icon";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, "Ubuntu Mono", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n@-webkit-keyframes pcui-flash-animation {\n  from {\n    outline-color: #f60;\n  }\n  to {\n    outline-color: rgba(255, 102, 0, 0);\n  }\n}\n@keyframes pcui-flash-animation {\n  from {\n    outline-color: #f60;\n  }\n  to {\n    outline-color: rgba(255, 102, 0, 0);\n  }\n}\n.noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-element {\n  border: 0 solid #232e30;\n}\n.pcui-element.flash {\n  outline: 1px solid #f60;\n  -webkit-animation: pcui-flash-animation 200ms ease-in-out forwards;\n  animation: pcui-flash-animation 200ms ease-in-out forwards;\n}\n.pcui-element:focus {\n  outline: none;\n}\n.pcui-element::-moz-focus-inner {\n  border: 0;\n}\n\n.pcui-element.pcui-hidden {\n  display: none;\n}');const _h=["flexDirection","flexGrow","flexBasis","flexShrink","flexWrap","alignItems","alignSelf","justifyContent","justifySelf"],wh={};class xh extends bh{constructor(e,t){if(super(),t||(t={}),this._destroyed=!1,this._parent=null,this._domEventClick=this._onClick.bind(this),this._domEventMouseOver=this._onMouseOver.bind(this),this._domEventMouseOut=this._onMouseOut.bind(this),this._eventsParent=[],this._dom=e||t.dom||document.createElement("div"),void 0!==t.id&&(this._dom.id=t.id),this._dom.ui=this,this._dom.addEventListener("click",this._domEventClick),this._dom.addEventListener("mouseover",this._domEventMouseOver),this._dom.addEventListener("mouseout",this._domEventMouseOut),this._dom.classList.add("pcui-element"),this._dom.classList.add("font-regular"),t.class)if(Array.isArray(t.class))for(let e=0;e<t.class.length;e++)this._dom.classList.add(t.class[e]);else this._dom.classList.add(t.class);this.enabled=void 0===t.enabled||t.enabled,this._hiddenParents=!t.isRoot,this.hidden=t.hidden||!1,this.readOnly=t.readOnly||!1,this.ignoreParent=t.ignoreParent||!1,void 0!==t.width&&(this.width=t.width),void 0!==t.height&&(this.height=t.height),void 0!==t.tabIndex&&(this.tabIndex=t.tabIndex);for(const e in t)void 0!==t[e]&&-1!==_h.indexOf(e)&&(this[e]=t[e]);t.binding&&(this.binding=t.binding),this._flashTimeout=null}link(e,t){this._binding&&this._binding.link(e,t)}unlink(){this._binding&&this._binding.unlink()}flash(){this._flashTimeout||(this.classAdd("flash"),this._flashTimeout=setTimeout(function(){this._flashTimeout=null,this.classRemove("flash")}.bind(this),200))}_onClick(e){this.enabled&&this.emit("click",e)}_onMouseOver(e){this.emit("hover",e)}_onMouseOut(e){this.emit("hoverend",e)}_onHiddenToRootChange(e){e?this.emit("hideToRoot"):this.emit("showToRoot")}_onEnabledChange(e){e?this.classRemove("pcui-disabled"):this.classAdd("pcui-disabled"),this.emit(e?"enable":"disable")}_onParentDestroy(){this.destroy()}_onParentDisable(){this._ignoreParent||this._enabled&&this._onEnabledChange(!1)}_onParentEnable(){this._ignoreParent||this._enabled&&this._onEnabledChange(!0)}_onParentShowToRoot(){const e=this.hiddenToRoot;this._hiddenParents=!1,e!==this.hiddenToRoot&&this._onHiddenToRootChange(this.hiddenToRoot)}_onParentHideToRoot(){const e=this.hiddenToRoot;this._hiddenParents=!0,e!==this.hiddenToRoot&&this._onHiddenToRootChange(this.hiddenToRoot)}_onReadOnlyChange(e){e?this.classAdd("pcui-readonly"):this.classRemove("pcui-readonly"),this.emit("readOnly",e)}_onParentReadOnlyChange(e){this._ignoreParent||(e?this._readOnly||this._onReadOnlyChange(!0):this._readOnly||this._onReadOnlyChange(!1))}classAdd(e){var t=this._dom.classList;t.contains(e)||t.add(e)}classRemove(e){var t=this._dom.classList;t.contains(e)&&t.remove(e)}destroy(){if(this._destroyed)return;if(this._destroyed=!0,this.binding?this.binding=null:this.unlink(),this.parent){const e=this.parent;for(let e=0;e<this._eventsParent.length;e++)this._eventsParent[e].unbind();this._eventsParent.length=0,e.remove&&!e._destroyed&&e.remove(this),this._parent=null,!e._destroyed&&this._dom&&this._dom.parentElement&&this._dom.parentElement.removeChild(this._dom)}const e=this._dom;e&&(e.removeEventListener("click",this._domEventClick),e.removeEventListener("mouseover",this._domEventMouseOver),e.removeEventListener("mouseout",this._domEventMouseOut),delete e.ui,this._dom=null),this._domEventClick=null,this._domEventMouseOver=null,this._domEventMouseOut=null,this._flashTimeout&&clearTimeout(this._flashTimeout),this.emit("destroy",e,this),this.unbind()}static register(e,t,n){wh[e]={cls:t,defaultArguments:n}}static unregister(e){delete wh[e]}static create(e,t){const n=wh[e];if(!n)return void console.error("Invalid type passed to pcui.Element#create",e);const a=n.cls,i={};return n.defaultArguments&&Object.assign(i,n.defaultArguments),t&&Object.assign(i,t),new a(i)}get enabled(){return this._ignoreParent?this._enabled:this._enabled&&(!this._parent||this._parent.enabled)}set enabled(e){if(this._enabled===e)return;const t=this.enabled;this._enabled=e,t!==e&&this._onEnabledChange(e)}get ignoreParent(){return this._ignoreParent}set ignoreParent(e){this._ignoreParent=e,this._onEnabledChange(this.enabled),this._onReadOnlyChange(this.readOnly)}get dom(){return this._dom}get parent(){return this._parent}set parent(e){if(e===this._parent)return;const t=this.enabled,n=this.readOnly,a=this.hiddenToRoot;if(this._parent){for(let e=0;e<this._eventsParent.length;e++)this._eventsParent[e].unbind();this._eventsParent.length=0}this._parent=e,this._parent?(this._eventsParent.push(this._parent.once("destroy",this._onParentDestroy.bind(this))),this._eventsParent.push(this._parent.on("disable",this._onParentDisable.bind(this))),this._eventsParent.push(this._parent.on("enable",this._onParentEnable.bind(this))),this._eventsParent.push(this._parent.on("readOnly",this._onParentReadOnlyChange.bind(this))),this._eventsParent.push(this._parent.on("showToRoot",this._onParentShowToRoot.bind(this))),this._eventsParent.push(this._parent.on("hideToRoot",this._onParentHideToRoot.bind(this))),this._hiddenParents=this._parent.hiddenToRoot):this._hiddenParents=!0,this.emit("parent",this._parent);const i=this.enabled;i!==t&&this._onEnabledChange(i);const s=this.readOnly;s!==n&&this._onReadOnlyChange(s);const r=this.hiddenToRoot;r!==a&&this._onHiddenToRootChange(r)}get hidden(){return this._hidden}set hidden(e){if(e===this._hidden)return;const t=this.hiddenToRoot;this._hidden=e,e?this.classAdd("pcui-hidden"):this.classRemove("pcui-hidden"),this.emit(e?"hide":"show"),this.hiddenToRoot!==t&&this._onHiddenToRootChange(this.hiddenToRoot)}get hiddenToRoot(){return this._hidden||this._hiddenParents}get readOnly(){return this._ignoreParent?this._readOnly:this._readOnly||!(!this._parent||!this._parent.readOnly)}set readOnly(e){this._readOnly!==e&&(this._readOnly=e,this._onReadOnlyChange(e))}get error(){return this._hasError}set error(e){this._hasError!==e&&(this._hasError=e,e?this.classAdd("pcui-error"):this.classRemove("pcui-error"))}get style(){return this._dom.style}get class(){return this._dom.classList}get width(){return this._dom.clientWidth}set width(e){"number"==typeof e&&(e+="px"),this.style.width=e}get height(){return this._dom.clientHeight}set height(e){"number"==typeof e&&(e+="px"),this.style.height=e}get tabIndex(){return this._dom.tabIndex}set tabIndex(e){this._dom.tabIndex=e}get binding(){return this._binding}set binding(e){if(this._binding===e)return;let t,n;this._binding&&(t=this._binding.observers,n=this._binding.paths,this.unlink(),this._binding.element=null,this._binding=null),this._binding=e,this._binding&&(this._binding.element=this,t&&n&&this.link(t,n))}get destroyed(){return this._destroyed}get disabled(){return!this.enabled}set disabled(e){this.enabled=!e}get element(){return this.dom}set element(e){this.dom=e}get innerElement(){return this.domContent}set innerElement(e){this.domContent=e}}_h.forEach((function(e){Object.defineProperty(xh.prototype,e,{get:function(){return this.style[e]},set:function(t){this.style[e]=t}})})),function(e){if(!e||!window)return;const t=document.createElement("style");t.setAttribute("type","text/css"),t.innerHTML=e,document.head.appendChild(t)}(".pcui-container {\n  position: relative;\n  min-width: 0;\n  min-height: 0;\n}\n\n.pcui-container.pcui-resizable > .pcui-resizable-handle {\n  position: absolute;\n  z-index: 1;\n  opacity: 0;\n  background-color: transparent;\n}\n.pcui-container.pcui-resizable > .pcui-resizable-handle:hover {\n  opacity: 1;\n}\n.pcui-container.pcui-resizable.pcui-resizable-resizing > .pcui-resizable-handle {\n  opacity: 1;\n}\n.pcui-container.pcui-resizable.pcui-resizable-left > .pcui-resizable-handle, .pcui-container.pcui-resizable.pcui-resizable-right > .pcui-resizable-handle {\n  top: 0;\n  bottom: 0;\n  width: 1px;\n  height: auto;\n  cursor: ew-resize;\n}\n.pcui-container.pcui-resizable.pcui-resizable-left > .pcui-resizable-handle {\n  left: 0;\n  border-left: 3px solid #20292b;\n}\n.pcui-container.pcui-resizable.pcui-resizable-right > .pcui-resizable-handle {\n  right: 0;\n  border-right: 3px solid #20292b;\n}\n.pcui-container.pcui-resizable.pcui-resizable-top > .pcui-resizable-handle, .pcui-container.pcui-resizable.pcui-resizable-bottom > .pcui-resizable-handle {\n  left: 0;\n  right: 0;\n  width: auto;\n  height: 1px;\n  cursor: ns-resize;\n}\n.pcui-container.pcui-resizable.pcui-resizable-top > .pcui-resizable-handle {\n  top: 0;\n  border-top: 3px solid #20292b;\n}\n.pcui-container.pcui-resizable.pcui-resizable-bottom > .pcui-resizable-handle {\n  bottom: 0;\n  border-bottom: 3px solid #20292b;\n}\n\n.pcui-container-dragged {\n  outline: 2px solid #ffffff;\n  box-sizing: border-box;\n  opacity: 0.7;\n  z-index: 1;\n}\n\n.pcui-container-dragged-child {\n  outline: 1px dotted #f60;\n  box-sizing: border-box;\n}");const Ch=[null,"top","right","bottom","left"],Th="pcui-container-dragged";class Eh extends xh{constructor(e){e||(e={});super(e.dom||document.createElement("div"),e),this.class.add("pcui-container"),this._domEventScroll=this._onScroll.bind(this),this.domContent=this._dom,this._scrollable=!1,e.scrollable&&(this.scrollable=!0),this._flex=!1,this.flex=!!e.flex,this._grid=!1;let t=!!e.grid;t&&this.flex&&(console.error('Invalid pcui.Container arguments: "grid" and "flex" cannot both be true.'),t=!1),this.grid=t,this._domResizeHandle=null,this._domEventResizeStart=this._onResizeStart.bind(this),this._domEventResizeMove=this._onResizeMove.bind(this),this._domEventResizeEnd=this._onResizeEnd.bind(this),this._domEventResizeTouchStart=this._onResizeTouchStart.bind(this),this._domEventResizeTouchMove=this._onResizeTouchMove.bind(this),this._domEventResizeTouchEnd=this._onResizeTouchEnd.bind(this),this._resizeTouchId=null,this._resizeData=null,this._resizeHorizontally=!0,this.resizable=e.resizable||null,this._resizeMin=100,this._resizeMax=300,void 0!==e.resizeMin&&(this.resizeMin=e.resizeMin),void 0!==e.resizeMax&&(this.resizeMax=e.resizeMax),this._draggedStartIndex=-1}append(e){const t=this._getDomFromElement(e);this._domContent.appendChild(t),this._onAppendChild(e)}appendBefore(e,t){const n=this._getDomFromElement(e);this._domContent.appendChild(n);const a=t&&this._getDomFromElement(t);this._domContent.insertBefore(n,a),this._onAppendChild(e)}appendAfter(e,t){const n=this._getDomFromElement(e),a=t&&this._getDomFromElement(t),i=a?a.nextSibling:null;i?this._domContent.insertBefore(n,i):this._domContent.appendChild(n),this._onAppendChild(e)}prepend(e){const t=this._getDomFromElement(e),n=this._domContent.firstChild;n?this._domContent.insertBefore(t,n):this._domContent.appendChild(t),this._onAppendChild(e)}remove(e){if(e.parent!==this)return;const t=this._getDomFromElement(e);this._domContent.removeChild(t),this._onRemoveChild(e)}move(e,t){let n=-1;for(let t=0;t<this.dom.childNodes.length;t++)if(this.dom.childNodes[t].ui===e){n=t;break}-1===n?this.appendBefore(e,this.dom.childNodes[t]):t!==n&&(this.remove(e),t<n?this.appendBefore(e,this.dom.childNodes[t]):this.appendAfter(e,this.dom.childNodes[t-1]))}clear(){let e=this._domContent.childNodes.length;for(;e--;){const t=this._domContent.childNodes[e];t.ui&&t.ui!==this&&t.ui.destroy()}this._domResizeHandle&&(this._domResizeHandle.removeEventListener("mousedown",this._domEventResizeStart),this._domResizeHandle.removeEventListener("touchstart",this._domEventResizeTouchStart,{passive:!1}),this._domResizeHandle=null),this._domContent.innerHTML="",this.resizable&&(this._createResizeHandle(),this._dom.appendChild(this._domResizeHandle))}_getDomFromElement(e){return e.dom?e.dom:e.element?e.element:e}_onAppendChild(e){e.parent=this,this.emit("append",e)}_onRemoveChild(e){e.parent=null,this.emit("remove",e)}_onScroll(e){this.emit("scroll",e)}_createResizeHandle(){const e=document.createElement("div");e.classList.add("pcui-resizable-handle"),e.ui=this,e.addEventListener("mousedown",this._domEventResizeStart),e.addEventListener("touchstart",this._domEventResizeTouchStart,{passive:!1}),this._domResizeHandle=e}_onResizeStart(e){e.preventDefault(),e.stopPropagation(),window.addEventListener("mousemove",this._domEventResizeMove),window.addEventListener("mouseup",this._domEventResizeEnd),this._resizeStart()}_onResizeMove(e){e.preventDefault(),e.stopPropagation(),this._resizeMove(e.clientX,e.clientY)}_onResizeEnd(e){e.preventDefault(),e.stopPropagation(),window.removeEventListener("mousemove",this._domEventResizeMove),window.removeEventListener("mouseup",this._domEventResizeEnd),this._resizeEnd()}_onResizeTouchStart(e){e.preventDefault(),e.stopPropagation();for(let t=0;t<e.changedTouches.length;t++){const n=e.changedTouches[t];n.target===this._domResizeHandle&&(this._resizeTouchId=n.identifier)}window.addEventListener("touchmove",this._domEventResizeTouchMove),window.addEventListener("touchend",this._domEventResizeTouchEnd),this._resizeStart()}_onResizeTouchMove(e){for(let t=0;t<e.changedTouches.length;t++){const n=e.changedTouches[t];if(n.identifier===this._resizeTouchId){e.stopPropagation(),e.preventDefault(),this._resizeMove(n.clientX,n.clientY);break}}}_onResizeTouchEnd(e){for(let t=0;t<e.changedTouches.length;t++){if(e.changedTouches[t].identifier!==this._resizeTouchId){this._resizeTouchId=null,e.preventDefault(),e.stopPropagation(),window.removeEventListener("touchmove",this._domEventResizeTouchMove),window.removeEventListener("touchend",this._domEventResizeTouchEnd),this._resizeEnd();break}}}_resizeStart(){this.class.add("pcui-resizable-resizing")}_resizeMove(e,t){if(this._resizeData){if(this._resizeHorizontally){let t=this._resizeData.x-e;"right"===this._resizable&&(t=-t),this.width=4+Math.max(this._resizeMin,Math.min(this._resizeMax,this._resizeData.width+t))}else{let e=this._resizeData.y-t;"bottom"===this._resizable&&(e=-e),this.height=Math.max(this._resizeMin,Math.min(this._resizeMax,this._resizeData.height+e))}this.emit("resize")}else this._resizeData={x:e,y:t,width:this.dom.clientWidth,height:this.dom.clientHeight}}_resizeEnd(){this._resizeData=null,this.class.remove("pcui-resizable-resizing")}resize(e,t){e=e||0,t=t||0,this._resizeStart(),this._resizeMove(0,0),this._resizeMove(4-e,-t),this._resizeEnd()}_getDraggedChildIndex(e){for(let t=0;t<this.dom.childNodes.length;t++)if(this.dom.childNodes[t].ui===e)return t;return-1}_onChildDragStart(e,t){this.class.add("pcui-container-dragged-child"),this._draggedStartIndex=this._getDraggedChildIndex(t),t.class.add(Th),this._draggedHeight=t.height,this.emit("child:dragstart",t,this._draggedStartIndex)}_onChildDragMove(e,t){const n=this.dom.getBoundingClientRect(),a=e.clientX<n.left||e.clientX>n.right||e.clientY<n.top||e.clientY>n.bottom,i=this._getDraggedChildIndex(t);if(a)return t.class.remove(Th),void(this._draggedStartIndex!==i&&(this.remove(t),this._draggedStartIndex<i?this.appendBefore(t,this.dom.childNodes[this._draggedStartIndex]):this.appendAfter(t,this.dom.childNodes[this._draggedStartIndex-1])));t.class.add(Th);const s=e.clientY-n.top;let r=null;for(let e=0;e<this.dom.childNodes.length;e++){const n=this.dom.childNodes[e].ui,a=n.dom.offsetTop;if(e<i){if(s<=a+n.header.height){r=e;break}}else if(e>i&&s+t.height>=a+n.height){r=e;break}}null!==r&&i!==r&&(this.remove(t),r<i?this.appendBefore(t,this.dom.childNodes[r]):this.appendAfter(t,this.dom.childNodes[r-1]))}_onChildDragEnd(e,t){this.class.remove("pcui-container-dragged-child"),t.class.remove(Th);const n=this._getDraggedChildIndex(t);this.emit("child:dragend",t,n,this._draggedStartIndex),this._draggedStartIndex=-1}forEachChild(e){for(let t=0;t<this.dom.childNodes.length;t++){const n=this.dom.childNodes[t].ui;if(n){if(!1===e(n,t))break}}}_buildDomNode(e){const t=Object.keys(e);let n;return t.includes("root")?(n=this._buildDomNode(e.root),e.children.forEach((e=>{const t=this._buildDomNode(e);null!==t&&n.append(t)}))):(n=e[t[0]],this[`_${t[0]}`]=n),n}buildDom(e){e.forEach((e=>{const t=this._buildDomNode(e);this.append(t)}))}destroy(){this._destroyed||(this.domContent=null,this._domResizeHandle&&(this._domResizeHandle.removeEventListener("mousedown",this._domEventResizeStart),window.removeEventListener("mousemove",this._domEventResizeMove),window.removeEventListener("mouseup",this._domEventResizeEnd),this._domResizeHandle.removeEventListener("touchstart",this._domEventResizeTouchStart),window.removeEventListener("touchmove",this._domEventResizeTouchMove),window.removeEventListener("touchend",this._domEventResizeTouchEnd)),this._domResizeHandle=null,this._domEventResizeStart=null,this._domEventResizeMove=null,this._domEventResizeEnd=null,this._domEventResizeTouchStart=null,this._domEventResizeTouchMove=null,this._domEventResizeTouchEnd=null,this._domEventScroll=null,super.destroy())}get flex(){return this._flex}set flex(e){e!==this._flex&&(this._flex=e,e?this.classAdd("pcui-flex"):this.classRemove("pcui-flex"))}get grid(){return this._grid}set grid(e){e!==this._grid&&(this._grid=e,e?this.classAdd("pcui-grid"):this.classRemove("pcui-grid"))}get scrollable(){return this._scrollable}set scrollable(e){this._scrollable!==e&&(this._scrollable=e,e?this.classAdd("pcui-scrollable"):this.classRemove("pcui-scrollable"))}get resizable(){return this._resizable}set resizable(e){e!==this._resizable&&(-1!==Ch.indexOf(e)?(this._resizable&&this.classRemove(`${mh}-${this._resizable}`),this._resizable=e,this._resizeHorizontally="right"===e||"left"===e,e?(this.classAdd(mh),this.classAdd(`${mh}-${e}`),this._domResizeHandle||this._createResizeHandle(),this._dom.appendChild(this._domResizeHandle)):(this.classRemove(mh),this._domResizeHandle&&this._dom.removeChild(this._domResizeHandle))):console.error("Invalid resizable value: must be one of "+Ch.join(",")))}get resizeMin(){return this._resizeMin}set resizeMin(e){this._resizeMin=Math.max(0,Math.min(e,this._resizeMax))}get resizeMax(){return this._resizeMax}set resizeMax(e){this._resizeMax=Math.max(this._resizeMin,e)}get domContent(){return this._domContent}set domContent(e){this._domContent!==e&&(this._domContent&&this._domContent.removeEventListener("scroll",this._domEventScroll),this._domContent=e,this._domContent&&this._domContent.addEventListener("scroll",this._domEventScroll))}}xh.register("container",Eh);var Sh=function(e){oh(n,N.Component);var t=ph(n);function n(e){var a;return ah(this,n),rh(hh(a=t.call(this,e)),"attachElement",(function(e,t){e&&(a.element=new a.elementClass(nh(nh({},a.props),{},{dom:e,container:t,parent:void 0})),a.onClick&&a.element.on("click",a.onClick),a.onChange&&a.element.on("change",a.onChange),a.props.parent&&(a.element.parent=a.props.parent))})),rh(hh(a),"getPropertyDescriptor",(function(e,t){var n;do{n=Object.getOwnPropertyDescriptor(e,t)}while(!n&&(e=Object.getPrototypeOf(e)));return n})),e.onClick&&(a.onClick=e.onClick),e.onChange&&(a.onChange=e.onChange),e.link&&(a.link=e.link),a}return sh(n,[{key:"componentDidMount",value:function(){this.link&&this.element.link(this.link.observer,this.link.path)}},{key:"componentDidUpdate",value:function(e){var t=this;Object.keys(this.props).forEach((function(e){var n=t.getPropertyDescriptor(t.element,e);n&&n.set&&(t.element[e]=t.props[e])})),e.link!==this.props.link&&this.element.link(this.props.link.observer,this.props.link.path)}},{key:"render",value:function(){return N.createElement("div",{ref:this.attachElement})}}]),n}(),Ah=function(e){oh(n,Sh);var t=ph(n);function n(e){var a;return ah(this,n),rh(hh(a=t.call(this,e)),"getParent",(function(){return console.log(hh(a)),hh(a)})),a.elementClass=Eh,a}return sh(n,[{key:"componentDidMount",value:function(){this.props.onResize&&this.element.on("resize",this.props.onResize)}},{key:"render",value:function(){var e=this,t=N.Children.toArray(this.props.children);return 1===t.length?t=N.cloneElement(t[0],{parent:this.element}):t.length>0&&(t=t.map((function(t){return N.cloneElement(t,{parent:e.element})}))),N.createElement("div",{ref:this.attachElement},t)}}]),n}();function Mh(e,t){return Mh=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},Mh(e,t)}function Lh(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,Mh(e,t)}Ah.propTypes={},Ah.ctor=Eh,Ah.defaultProps={};var Rh={exports:{}},Ih={exports:{}},Ph={},kh="function"==typeof Symbol&&Symbol.for,Dh=kh?Symbol.for("react.element"):60103,Oh=kh?Symbol.for("react.portal"):60106,Fh=kh?Symbol.for("react.fragment"):60107,Nh=kh?Symbol.for("react.strict_mode"):60108,Vh=kh?Symbol.for("react.profiler"):60114,Bh=kh?Symbol.for("react.provider"):60109,Uh=kh?Symbol.for("react.context"):60110,zh=kh?Symbol.for("react.async_mode"):60111,Gh=kh?Symbol.for("react.concurrent_mode"):60111,Hh=kh?Symbol.for("react.forward_ref"):60112,Wh=kh?Symbol.for("react.suspense"):60113,jh=kh?Symbol.for("react.suspense_list"):60120,Xh=kh?Symbol.for("react.memo"):60115,Yh=kh?Symbol.for("react.lazy"):60116,qh=kh?Symbol.for("react.block"):60121,Kh=kh?Symbol.for("react.fundamental"):60117,Zh=kh?Symbol.for("react.responder"):60118,$h=kh?Symbol.for("react.scope"):60119;function Qh(e){if("object"==typeof e&&null!==e){var t=e.$$typeof;switch(t){case Dh:switch(e=e.type){case zh:case Gh:case Fh:case Vh:case Nh:case Wh:return e;default:switch(e=e&&e.$$typeof){case Uh:case Hh:case Yh:case Xh:case Bh:return e;default:return t}}case Oh:return t}}}function Jh(e){return Qh(e)===Gh}Ph.AsyncMode=zh,Ph.ConcurrentMode=Gh,Ph.ContextConsumer=Uh,Ph.ContextProvider=Bh,Ph.Element=Dh,Ph.ForwardRef=Hh,Ph.Fragment=Fh,Ph.Lazy=Yh,Ph.Memo=Xh,Ph.Portal=Oh,Ph.Profiler=Vh,Ph.StrictMode=Nh,Ph.Suspense=Wh,Ph.isAsyncMode=function(e){return Jh(e)||Qh(e)===zh},Ph.isConcurrentMode=Jh,Ph.isContextConsumer=function(e){return Qh(e)===Uh},Ph.isContextProvider=function(e){return Qh(e)===Bh},Ph.isElement=function(e){return"object"==typeof e&&null!==e&&e.$$typeof===Dh},Ph.isForwardRef=function(e){return Qh(e)===Hh},Ph.isFragment=function(e){return Qh(e)===Fh},Ph.isLazy=function(e){return Qh(e)===Yh},Ph.isMemo=function(e){return Qh(e)===Xh},Ph.isPortal=function(e){return Qh(e)===Oh},Ph.isProfiler=function(e){return Qh(e)===Vh},Ph.isStrictMode=function(e){return Qh(e)===Nh},Ph.isSuspense=function(e){return Qh(e)===Wh},Ph.isValidElementType=function(e){return"string"==typeof e||"function"==typeof e||e===Fh||e===Gh||e===Vh||e===Nh||e===Wh||e===jh||"object"==typeof e&&null!==e&&(e.$$typeof===Yh||e.$$typeof===Xh||e.$$typeof===Bh||e.$$typeof===Uh||e.$$typeof===Hh||e.$$typeof===Kh||e.$$typeof===Zh||e.$$typeof===$h||e.$$typeof===qh)},Ph.typeOf=Qh,Ih.exports=Ph;function ed(){}function td(){}td.resetWarningCache=ed;Rh.exports=function(){function e(e,t,n,a,i,s){if("SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"!==s){var r=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw r.name="Invariant Violation",r}}function t(){return e}e.isRequired=e;var n={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,elementType:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t,checkPropTypes:td,resetWarningCache:ed};return n.PropTypes=n,n}();var nd=Rh.exports;function ad(){return ad=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},ad.apply(this,arguments)}function id(e){return"/"===e.charAt(0)}function sd(e,t){for(var n=t,a=n+1,i=e.length;a<i;n+=1,a+=1)e[n]=e[a];e.pop()}function rd(e){return e.valueOf?e.valueOf():Object.prototype.valueOf.call(e)}function od(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(Array.isArray(e))return Array.isArray(t)&&e.length===t.length&&e.every((function(e,n){return od(e,t[n])}));if("object"==typeof e||"object"==typeof t){var n=rd(e),a=rd(t);return n!==e||a!==t?od(n,a):Object.keys(Object.assign({},e,t)).every((function(n){return od(e[n],t[n])}))}return!1}var ld="Invariant failed";function cd(e,t){if(!e)throw new Error(ld)}function hd(e){return"/"===e.charAt(0)?e:"/"+e}function dd(e){return"/"===e.charAt(0)?e.substr(1):e}function pd(e,t){return function(e,t){return 0===e.toLowerCase().indexOf(t.toLowerCase())&&-1!=="/?#".indexOf(e.charAt(t.length))}(e,t)?e.substr(t.length):e}function ud(e){return"/"===e.charAt(e.length-1)?e.slice(0,-1):e}function md(e){var t=e.pathname,n=e.search,a=e.hash,i=t||"/";return n&&"?"!==n&&(i+="?"===n.charAt(0)?n:"?"+n),a&&"#"!==a&&(i+="#"===a.charAt(0)?a:"#"+a),i}function fd(e,t,n,a){var i;"string"==typeof e?(i=function(e){var t=e||"/",n="",a="",i=t.indexOf("#");-1!==i&&(a=t.substr(i),t=t.substr(0,i));var s=t.indexOf("?");return-1!==s&&(n=t.substr(s),t=t.substr(0,s)),{pathname:t,search:"?"===n?"":n,hash:"#"===a?"":a}}(e),i.state=t):(void 0===(i=ad({},e)).pathname&&(i.pathname=""),i.search?"?"!==i.search.charAt(0)&&(i.search="?"+i.search):i.search="",i.hash?"#"!==i.hash.charAt(0)&&(i.hash="#"+i.hash):i.hash="",void 0!==t&&void 0===i.state&&(i.state=t));try{i.pathname=decodeURI(i.pathname)}catch(e){throw e instanceof URIError?new URIError('Pathname "'+i.pathname+'" could not be decoded. This is likely caused by an invalid percent-encoding.'):e}return n&&(i.key=n),a?i.pathname?"/"!==i.pathname.charAt(0)&&(i.pathname=function(e,t){void 0===t&&(t="");var n,a=e&&e.split("/")||[],i=t&&t.split("/")||[],s=e&&id(e),r=t&&id(t),o=s||r;if(e&&id(e)?i=a:a.length&&(i.pop(),i=i.concat(a)),!i.length)return"/";if(i.length){var l=i[i.length-1];n="."===l||".."===l||""===l}else n=!1;for(var c=0,h=i.length;h>=0;h--){var d=i[h];"."===d?sd(i,h):".."===d?(sd(i,h),c++):c&&(sd(i,h),c--)}if(!o)for(;c--;c)i.unshift("..");!o||""===i[0]||i[0]&&id(i[0])||i.unshift("");var p=i.join("/");return n&&"/"!==p.substr(-1)&&(p+="/"),p}(i.pathname,a.pathname)):i.pathname=a.pathname:i.pathname||(i.pathname="/"),i}function gd(e,t){return e.pathname===t.pathname&&e.search===t.search&&e.hash===t.hash&&e.key===t.key&&od(e.state,t.state)}function yd(){var e=null;var t=[];return{setPrompt:function(t){return e=t,function(){e===t&&(e=null)}},confirmTransitionTo:function(t,n,a,i){if(null!=e){var s="function"==typeof e?e(t,n):e;"string"==typeof s?"function"==typeof a?a(s,i):i(!0):i(!1!==s)}else i(!0)},appendListener:function(e){var n=!0;function a(){n&&e.apply(void 0,arguments)}return t.push(a),function(){n=!1,t=t.filter((function(e){return e!==a}))}},notifyListeners:function(){for(var e=arguments.length,n=new Array(e),a=0;a<e;a++)n[a]=arguments[a];t.forEach((function(e){return e.apply(void 0,n)}))}}}var bd=!("undefined"==typeof window||!window.document||!window.document.createElement);function vd(e,t){t(window.confirm(e))}var _d={hashbang:{encodePath:function(e){return"!"===e.charAt(0)?e:"!/"+dd(e)},decodePath:function(e){return"!"===e.charAt(0)?e.substr(1):e}},noslash:{encodePath:dd,decodePath:hd},slash:{encodePath:hd,decodePath:hd}};function wd(e){var t=e.indexOf("#");return-1===t?e:e.slice(0,t)}function xd(){var e=window.location.href,t=e.indexOf("#");return-1===t?"":e.substring(t+1)}function Cd(e){window.location.replace(wd(window.location.href)+"#"+e)}function Td(e){void 0===e&&(e={}),bd||cd(!1);var t=window.history;window.navigator.userAgent.indexOf("Firefox");var n=e,a=n.getUserConfirmation,i=void 0===a?vd:a,s=n.hashType,r=void 0===s?"slash":s,o=e.basename?ud(hd(e.basename)):"",l=_d[r],c=l.encodePath,h=l.decodePath;function d(){var e=h(xd());return o&&(e=pd(e,o)),fd(e)}var p=yd();function u(e){ad(E,e),E.length=t.length,p.notifyListeners(E.location,E.action)}var m=!1,f=null;function g(){var e=xd(),t=c(e);if(e!==t)Cd(t);else{var n=d(),a=E.location;if(!m&&function(e,t){return e.pathname===t.pathname&&e.search===t.search&&e.hash===t.hash}(a,n))return;if(f===md(n))return;f=null,function(e){if(m)m=!1,u();else{var t="POP";p.confirmTransitionTo(e,t,i,(function(n){n?u({action:t,location:e}):function(e){var t=E.location,n=_.lastIndexOf(md(t));-1===n&&(n=0);var a=_.lastIndexOf(md(e));-1===a&&(a=0);var i=n-a;i&&(m=!0,w(i))}(e)}))}}(n)}}var y=xd(),b=c(y);y!==b&&Cd(b);var v=d(),_=[md(v)];function w(e){t.go(e)}var x=0;function C(e){1===(x+=e)&&1===e?window.addEventListener("hashchange",g):0===x&&window.removeEventListener("hashchange",g)}var T=!1;var E={length:t.length,action:"POP",location:v,createHref:function(e){var t=document.querySelector("base"),n="";return t&&t.getAttribute("href")&&(n=wd(window.location.href)),n+"#"+c(o+md(e))},push:function(e,t){var n="PUSH",a=fd(e,void 0,void 0,E.location);p.confirmTransitionTo(a,n,i,(function(e){if(e){var t=md(a),i=c(o+t);if(xd()!==i){f=t,function(e){window.location.hash=e}(i);var s=_.lastIndexOf(md(E.location)),r=_.slice(0,s+1);r.push(t),_=r,u({action:n,location:a})}else u()}}))},replace:function(e,t){var n="REPLACE",a=fd(e,void 0,void 0,E.location);p.confirmTransitionTo(a,n,i,(function(e){if(e){var t=md(a),i=c(o+t);xd()!==i&&(f=t,Cd(i));var s=_.indexOf(md(E.location));-1!==s&&(_[s]=t),u({action:n,location:a})}}))},go:w,goBack:function(){w(-1)},goForward:function(){w(1)},block:function(e){void 0===e&&(e=!1);var t=p.setPrompt(e);return T||(C(1),T=!0),function(){return T&&(T=!1,C(-1)),t()}},listen:function(e){var t=p.appendListener(e);return C(1),function(){C(-1),t()}}};return E}var Ed="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{};function Sd(e){var t=[];return{on:function(e){t.push(e)},off:function(e){t=t.filter((function(t){return t!==e}))},get:function(){return e},set:function(n,a){e=n,t.forEach((function(t){return t(e,a)}))}}}var Ad=N.createContext||function(t,n){var a,i,s,r="__create-react-context-"+((Ed[s="__global_unique_id__"]=(Ed[s]||0)+1)+"__"),o=function(e){function t(){var t;return(t=e.apply(this,arguments)||this).emitter=Sd(t.props.value),t}Lh(t,e);var a=t.prototype;return a.getChildContext=function(){var e;return(e={})[r]=this.emitter,e},a.componentWillReceiveProps=function(e){if(this.props.value!==e.value){var t,a=this.props.value,i=e.value;!function(e,t){return e===t?0!==e||1/e==1/t:e!=e&&t!=t}(a,i)?(t="function"==typeof n?n(a,i):1073741823,0!==(t|=0)&&this.emitter.set(e.value,t)):t=0}},a.render=function(){return this.props.children},t}(e.exports.Component);o.childContextTypes=((a={})[r]=nd.object.isRequired,a);var l=function(e){function n(){var t;return(t=e.apply(this,arguments)||this).state={value:t.getValue()},t.onUpdate=function(e,n){0!=((0|t.observedBits)&n)&&t.setState({value:t.getValue()})},t}Lh(n,e);var a=n.prototype;return a.componentWillReceiveProps=function(e){var t=e.observedBits;this.observedBits=null==t?1073741823:t},a.componentDidMount=function(){this.context[r]&&this.context[r].on(this.onUpdate);var e=this.props.observedBits;this.observedBits=null==e?1073741823:e},a.componentWillUnmount=function(){this.context[r]&&this.context[r].off(this.onUpdate)},a.getValue=function(){return this.context[r]?this.context[r].get():t},a.render=function(){return(e=this.props.children,Array.isArray(e)?e[0]:e)(this.state.value);var e},n}(e.exports.Component);return l.contextTypes=((i={})[r]=nd.object,i),{Provider:o,Consumer:l}},Md={exports:{}},Ld=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},Rd=Ld;Md.exports=Ud,Md.exports.parse=Pd,Md.exports.compile=function(e,t){return Dd(Pd(e,t),t)},Md.exports.tokensToFunction=Dd,Md.exports.tokensToRegExp=Bd;var Id=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Pd(e,t){for(var n,a=[],i=0,s=0,r="",o=t&&t.delimiter||"/";null!=(n=Id.exec(e));){var l=n[0],c=n[1],h=n.index;if(r+=e.slice(s,h),s=h+l.length,c)r+=c[1];else{var d=e[s],p=n[2],u=n[3],m=n[4],f=n[5],g=n[6],y=n[7];r&&(a.push(r),r="");var b=null!=p&&null!=d&&d!==p,v="+"===g||"*"===g,_="?"===g||"*"===g,w=n[2]||o,x=m||f;a.push({name:u||i++,prefix:p||"",delimiter:w,optional:_,repeat:v,partial:b,asterisk:!!y,pattern:x?Fd(x):y?".*":"[^"+Od(w)+"]+?"})}}return s<e.length&&(r+=e.substr(s)),r&&a.push(r),a}function kd(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function Dd(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",Vd(t)));return function(t,a){for(var i="",s=t||{},r=(a||{}).pretty?kd:encodeURIComponent,o=0;o<e.length;o++){var l=e[o];if("string"!=typeof l){var c,h=s[l.name];if(null==h){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(Rd(h)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(h)+"`");if(0===h.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<h.length;d++){if(c=r(h[d]),!n[o].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(h).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()})):r(h),!n[o].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');i+=l.prefix+c}}else i+=l}return i}}function Od(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Fd(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function Nd(e,t){return e.keys=t,e}function Vd(e){return e&&e.sensitive?"":"i"}function Bd(e,t,n){Rd(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,i=!1!==n.end,s="",r=0;r<e.length;r++){var o=e[r];if("string"==typeof o)s+=Od(o);else{var l=Od(o.prefix),c="(?:"+o.pattern+")";t.push(o),o.repeat&&(c+="(?:"+l+c+")*"),s+=c=o.optional?o.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var h=Od(n.delimiter||"/"),d=s.slice(-h.length)===h;return a||(s=(d?s.slice(0,-h.length):s)+"(?:"+h+"(?=$))?"),s+=i?"$":a&&d?"":"(?="+h+"|$)",Nd(new RegExp("^"+s,Vd(n)),t)}function Ud(e,t,n){return Rd(t)||(n=t||n,t=[]),n=n||{},e instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Nd(e,t)}(e,t):Rd(e)?function(e,t,n){for(var a=[],i=0;i<e.length;i++)a.push(Ud(e[i],t,n).source);return Nd(new RegExp("(?:"+a.join("|")+")",Vd(n)),t)}(e,t,n):function(e,t,n){return Bd(Pd(e,n),t,n)}(e,t,n)}var zd=Md.exports;function Gd(e,t){if(null==e)return{};var n,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}var Hd=Ih.exports,Wd={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},jd={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},Xd={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},Yd={};function qd(e){return Hd.isMemo(e)?Xd:Yd[e.$$typeof]||Wd}Yd[Hd.ForwardRef]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},Yd[Hd.Memo]=Xd;var Kd=Object.defineProperty,Zd=Object.getOwnPropertyNames,$d=Object.getOwnPropertySymbols,Qd=Object.getOwnPropertyDescriptor,Jd=Object.getPrototypeOf,ep=Object.prototype;var tp=function e(t,n,a){if("string"!=typeof n){if(ep){var i=Jd(n);i&&i!==ep&&e(t,i,a)}var s=Zd(n);$d&&(s=s.concat($d(n)));for(var r=qd(t),o=qd(n),l=0;l<s.length;++l){var c=s[l];if(!(jd[c]||a&&a[c]||o&&o[c]||r&&r[c])){var h=Qd(n,c);try{Kd(t,c,h)}catch(e){}}}}return t},np=tp,ap=function(e){var t=Ad();return t.displayName=e,t},ip=ap("Router-History"),sp=ap("Router"),rp=function(e){function t(t){var n;return(n=e.call(this,t)||this).state={location:t.history.location},n._isMounted=!1,n._pendingLocation=null,t.staticContext||(n.unlisten=t.history.listen((function(e){n._isMounted?n.setState({location:e}):n._pendingLocation=e}))),n}Lh(t,e),t.computeRootMatch=function(e){return{path:"/",url:"/",params:{},isExact:"/"===e}};var n=t.prototype;return n.componentDidMount=function(){this._isMounted=!0,this._pendingLocation&&this.setState({location:this._pendingLocation})},n.componentWillUnmount=function(){this.unlisten&&(this.unlisten(),this._isMounted=!1,this._pendingLocation=null)},n.render=function(){return N.createElement(sp.Provider,{value:{history:this.props.history,location:this.state.location,match:t.computeRootMatch(this.state.location.pathname),staticContext:this.props.staticContext}},N.createElement(ip.Provider,{children:this.props.children||null,value:this.props.history}))},t}(N.Component);N.Component;var op=function(e){function t(){return e.apply(this,arguments)||this}Lh(t,e);var n=t.prototype;return n.componentDidMount=function(){this.props.onMount&&this.props.onMount.call(this,this)},n.componentDidUpdate=function(e){this.props.onUpdate&&this.props.onUpdate.call(this,this,e)},n.componentWillUnmount=function(){this.props.onUnmount&&this.props.onUnmount.call(this,this)},n.render=function(){return null},t}(N.Component),lp={},cp=0;function hp(e,t){return void 0===e&&(e="/"),void 0===t&&(t={}),"/"===e?e:function(e){if(lp[e])return lp[e];var t=zd.compile(e);return cp<1e4&&(lp[e]=t,cp++),t}(e)(t,{pretty:!0})}function dp(e){var t=e.computedMatch,n=e.to,a=e.push,i=void 0!==a&&a;return N.createElement(sp.Consumer,null,(function(e){e||cd(!1);var a=e.history,s=e.staticContext,r=i?a.push:a.replace,o=fd(t?"string"==typeof n?hp(n,t.params):ad({},n,{pathname:hp(n.pathname,t.params)}):n);return s?(r(o),null):N.createElement(op,{onMount:function(){r(o)},onUpdate:function(e,t){var n=fd(t.to);gd(n,ad({},o,{key:n.key}))||r(o)},to:n})}))}var pp={},up=0;function mp(e,t){void 0===t&&(t={}),("string"==typeof t||Array.isArray(t))&&(t={path:t});var n=t,a=n.path,i=n.exact,s=void 0!==i&&i,r=n.strict,o=void 0!==r&&r,l=n.sensitive,c=void 0!==l&&l;return[].concat(a).reduce((function(t,n){if(!n&&""!==n)return null;if(t)return t;var a=function(e,t){var n=""+t.end+t.strict+t.sensitive,a=pp[n]||(pp[n]={});if(a[e])return a[e];var i=[],s={regexp:zd(e,i,t),keys:i};return up<1e4&&(a[e]=s,up++),s}(n,{end:s,strict:o,sensitive:c}),i=a.regexp,r=a.keys,l=i.exec(e);if(!l)return null;var h=l[0],d=l.slice(1),p=e===h;return s&&!p?null:{path:n,url:"/"===n&&""===h?"/":h,isExact:p,params:r.reduce((function(e,t,n){return e[t.name]=d[n],e}),{})}}),null)}var fp=function(e){function t(){return e.apply(this,arguments)||this}return Lh(t,e),t.prototype.render=function(){var e=this;return N.createElement(sp.Consumer,null,(function(t){t||cd(!1);var n=e.props.location||t.location,a=ad({},t,{location:n,match:e.props.computedMatch?e.props.computedMatch:e.props.path?mp(n.pathname,e.props):t.match}),i=e.props,s=i.children,r=i.component,o=i.render;return Array.isArray(s)&&function(e){return 0===N.Children.count(e)}(s)&&(s=null),N.createElement(sp.Provider,{value:a},a.match?s?"function"==typeof s?s(a):s:r?N.createElement(r,a):o?o(a):null:"function"==typeof s?s(a):null)}))},t}(N.Component);N.Component;var gp=function(e){function t(){return e.apply(this,arguments)||this}return Lh(t,e),t.prototype.render=function(){var e=this;return N.createElement(sp.Consumer,null,(function(t){t||cd(!1);var n,a,i=e.props.location||t.location;return N.Children.forEach(e.props.children,(function(e){if(null==a&&N.isValidElement(e)){n=e;var s=e.props.path||e.props.from;a=s?mp(i.pathname,ad({},e.props,{path:s})):t.match}})),a?N.cloneElement(n,{location:i,computedMatch:a}):null}))},t}(N.Component);N.useContext,N.Component;var yp=function(e){function t(){for(var t,n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];return(t=e.call.apply(e,[this].concat(a))||this).history=Td(t.props),t}return Lh(t,e),t.prototype.render=function(){return N.createElement(rp,{history:this.history,children:this.props.children})},t}(N.Component),bp=function(e,t){return"function"==typeof e?e(t):e},vp=function(e,t){return"string"==typeof e?fd(e,null,null,t):e},_p=function(e){return e},wp=N.forwardRef;void 0===wp&&(wp=_p);var xp=wp((function(e,t){var n=e.innerRef,a=e.navigate,i=e.onClick,s=Gd(e,["innerRef","navigate","onClick"]),r=s.target,o=ad({},s,{onClick:function(e){try{i&&i(e)}catch(t){throw e.preventDefault(),t}e.defaultPrevented||0!==e.button||r&&"_self"!==r||function(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}(e)||(e.preventDefault(),a())}});return o.ref=_p!==wp&&t||n,N.createElement("a",o)})),Cp=wp((function(e,t){var n=e.component,a=void 0===n?xp:n,i=e.replace,s=e.to,r=e.innerRef,o=Gd(e,["component","replace","to","innerRef"]);return N.createElement(sp.Consumer,null,(function(e){e||cd(!1);var n=e.history,l=vp(bp(s,e.location),e.location),c=l?n.createHref(l):"",h=ad({},o,{href:c,navigate:function(){var t=bp(s,e.location),a=md(e.location)===md(vp(t));(i||a?n.replace:n.push)(t)}});return _p!==wp?h.ref=t||r:h.innerRef=r,N.createElement(a,h)}))})),Tp=function(e){return e},Ep=N.forwardRef;void 0===Ep&&(Ep=Tp),Ep((function(e,t){var n=e["aria-current"],a=void 0===n?"page":n,i=e.activeClassName,s=void 0===i?"active":i,r=e.activeStyle,o=e.className,l=e.exact,c=e.isActive,h=e.location,d=e.sensitive,p=e.strict,u=e.style,m=e.to,f=e.innerRef,g=Gd(e,["aria-current","activeClassName","activeStyle","className","exact","isActive","location","sensitive","strict","style","to","innerRef"]);return N.createElement(sp.Consumer,null,(function(e){e||cd(!1);var n=h||e.location,i=vp(bp(m,n),n),y=i.pathname,b=y&&y.replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1"),v=b?mp(n.pathname,{path:b,exact:l,sensitive:d,strict:p}):null,_=!!(c?c(v,n):v),w="function"==typeof o?o(_):o,x="function"==typeof u?u(_):u;_&&(w=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.filter((function(e){return e})).join(" ")}(w,s),x=ad({},x,r));var C=ad({"aria-current":_&&a||null,className:w,style:x,to:i},g);return Tp!==Ep?C.ref=t||f:C.innerRef=f,N.createElement(Cp,C)}))})),function(e){if(!e||!window)return;const t=document.createElement("style");t.setAttribute("type","text/css"),t.innerHTML=e,document.head.appendChild(t)}('@font-face {\n  font-family: "pc-icon";\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot");\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix") format("embedded-opentype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2") format("woff2"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff") format("woff"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf") format("truetype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg") format("svg");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon {\n  font-family: "pc-icon";\n}\n\n.fixedFont, .pcui-label.pcui-multiple-values:before {\n  font-family: inconsolatamedium, Monaco, Menlo, "Ubuntu Mono", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect, .pcui-label.pcui-selectable:hover {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-label {\n  display: inline-block;\n  box-sizing: border-box;\n  margin: 6px;\n  vertical-align: middle;\n  transition: opacity 100ms;\n  color: #b1b8ba;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  user-select: none;\n}\n\n.pcui-label.pcui-default-mousedown {\n  user-select: initial;\n}\n\n.pcui-label.pcui-multiple-values {\n  position: relative;\n  color: transparent;\n}\n.pcui-label.pcui-multiple-values:before {\n  content: "...";\n  color: #b1b8ba;\n  white-space: nowrap;\n  font-size: 12px;\n}\n\n.pcui-label.pcui-error {\n  color: #d34141;\n}\n\n.pcui-label.pcui-selectable:hover {\n  color: #f60;\n  text-decoration: underline;\n}\n\n.pcui-label[placeholder] {\n  position: relative;\n}\n.pcui-label[placeholder]:after {\n  content: attr(placeholder);\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 0 8px;\n  color: #999;\n  pointer-events: none;\n}');class Sp extends xh{constructor(e){e||(e={}),super(e.dom?e.dom:document.createElement("span"),e),this.class.add("pcui-label"),this._unsafe=e.unsafe||!1,this.text=e.text||e.value||"",e.allowTextSelection&&this.class.add("pcui-default-mousedown"),e.nativeTooltip&&(this.dom.title=this.text),this.placeholder=e.placeholder||null,this.renderChanges=e.renderChanges||!1,this.on("change",(()=>{this.renderChanges&&this.flash()}))}_updateText(e){return this.class.remove(gh),this._text!==e&&(this._text=e,this._unsafe?this._dom.innerHTML=e:this._dom.textContent=e,this.emit("change",e),!0)}get text(){return this._text}set text(e){null==e&&(e="");this._updateText(e)&&this._binding&&this._binding.setValue(e)}get value(){return this.text}set value(e){this.text=e}set values(e){let t=!1;const n=e[0];for(let a=1;a<e.length;a++)if(e[a]!==n){t=!0;break}t?(this._updateText(""),this.class.add(gh)):this._updateText(e[0])}get placeholder(){return this.dom.getAttribute("placeholder")}set placeholder(e){e?this.dom.setAttribute("placeholder",e):this.dom.removeAttribute("placeholder")}}xh.register("label",Sp),function(e){if(!e||!window)return;const t=document.createElement("style");t.setAttribute("type","text/css"),t.innerHTML=e,document.head.appendChild(t)}('@font-face {\n  font-family: "pc-icon";\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot");\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix") format("embedded-opentype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2") format("woff2"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff") format("woff"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf") format("truetype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg") format("svg");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon, .pcui-button[data-icon]:before {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon, .pcui-button[data-icon]:before {\n  font-family: "pc-icon";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, "Ubuntu Mono", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect, .pcui-button {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-button {\n  font-family: inherit;\n  display: inline-block;\n  border: 1px solid #20292b;\n  border-radius: 2px;\n  box-sizing: border-box;\n  background-color: #2c393c;\n  color: #b1b8ba;\n  padding: 0 8px;\n  margin: 6px;\n  height: 28px;\n  line-height: 28px;\n  max-height: 100%;\n  vertical-align: middle;\n  font-size: 12px;\n  font-weight: 600;\n  text-align: center;\n  white-space: nowrap;\n  cursor: pointer;\n  transition: color 100ms, opacity 100ms, box-shadow 100ms;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.pcui-button[data-icon]:before {\n  content: attr(data-icon);\n  font-weight: 100;\n  font-size: inherit;\n  margin-right: 6px;\n  vertical-align: middle;\n}\n.pcui-button[data-icon]:empty:before {\n  margin-right: 0;\n}\n\n.pcui-button:not(.pcui-disabled):not(.pcui-readonly):hover, .pcui-button:not(.pcui-disabled):not(.pcui-readonly):focus {\n  color: #ffffff;\n  background-color: #2c393c;\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-button:not(.pcui-disabled):not(.pcui-readonly):active {\n  background-color: #20292b;\n  box-shadow: none;\n}\n\n.pcui-button.pcui-readonly {\n  opacity: 0.7;\n  cursor: default;\n}\n\n.pcui-button.pcui-disabled {\n  opacity: 0.4;\n  cursor: default;\n}\n\n.pcui-button.pcui-small {\n  height: 24px;\n  line-height: 24px;\n  font-size: 10px;\n}');class Ap extends xh{constructor(e){e||(e={}),super(e.dom?e.dom:document.createElement("button"),e),this.class.add("pcui-button"),this._unsafe=e.unsafe||!1,this.text=e.text||"",this.size=e.size||null,this.icon=e.icon||"",this._domEventKeyDown=this._onKeyDown.bind(this),this.dom.addEventListener("keydown",this._onKeyDown.bind(this))}_onKeyDown(e){27===e.keyCode?this.blur():13===e.keyCode&&this._onClick(e)}_onClick(e){this.blur(),this.readOnly||super._onClick(e)}focus(){this.dom.focus()}blur(){this.dom.blur()}destroy(){this._destroyed||(this.dom.removeEventListener("keydown",this._domEventKeyDown),super.destroy())}get text(){return this._text}set text(e){this._text!==e&&(this._text=e,this._unsafe?this.dom.innerHTML=e:this.dom.textContent=e)}get icon(){return this._icon}set icon(e){this._icon===e|!e.match(/^E[0-9]{0,4}$/)||(this._icon=e,e?this.dom.setAttribute("data-icon",String.fromCodePoint(parseInt(e,16))):this.dom.removeAttribute("data-icon"))}get size(){return this._size}set size(e){this._size!==e&&(this._size&&(this.class.remove("pcui-"+this._size),this._size=null),this._size=e,this._size&&this.class.add("pcui-"+this._size))}}xh.register("button",Ap),function(e){if(!e||!window)return;const t=document.createElement("style");t.setAttribute("type","text/css"),t.innerHTML=e,document.head.appendChild(t)}('@font-face {\n  font-family: "pc-icon";\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot");\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix") format("embedded-opentype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2") format("woff2"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff") format("woff"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf") format("truetype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg") format("svg");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .pcui-panel-header-title, .pcui-panel-header, .font-icon, .pcui-panel.pcui-collapsible > .pcui-panel-header:before {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon, .pcui-panel.pcui-collapsible > .pcui-panel-header:before {\n  font-family: "pc-icon";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, "Ubuntu Mono", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex, .pcui-panel-header > .pcui-panel-sortable-icon {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden), .pcui-panel-header > .pcui-panel-sortable-icon:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-panel {\n  background-color: #364346;\n}\n\n.pcui-panel-header {\n  background-color: #293538;\n  color: #ffffff;\n  font-size: 12px;\n  white-space: nowrap;\n  padding-left: 10px;\n  flex-shrink: 0;\n  align-items: center;\n}\n\n.pcui-panel-header-title {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  flex: 1;\n  color: inherit;\n  font-size: inherit;\n  white-space: inherit;\n  margin: 0 auto 0 0;\n}\n\n.pcui-panel-content {\n  flex: 1;\n}\n\n.pcui-panel.pcui-collapsible {\n  transition: height 100ms, width 100ms;\n}\n.pcui-panel.pcui-collapsible > .pcui-panel-header {\n  cursor: pointer;\n}\n.pcui-panel.pcui-collapsible > .pcui-panel-header:before {\n  left: 0;\n  content: "\\e179";\n  font-size: 14px;\n  margin-right: 10px;\n  text-align: center;\n  color: #f60;\n}\n.pcui-panel.pcui-collapsible > .pcui-panel-header:hover {\n  color: #ffffff;\n}\n.pcui-panel.pcui-collapsible > .pcui-panel-header:hover:before {\n  color: #ffffff;\n}\n.pcui-panel.pcui-collapsible.pcui-panel-normal > .pcui-panel-header:before {\n  content: "\\e183";\n  font-weight: 200;\n}\n.pcui-panel.pcui-collapsible > .pcui-panel-content {\n  transition: visibility 100ms;\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed {\n  overflow: hidden;\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed > .pcui-panel-content {\n  visibility: hidden;\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed > .pcui-panel-header:before {\n  content: "\\e180";\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed.pcui-panel-normal > .pcui-panel-header:before {\n  content: "\\e184";\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed.pcui-panel-horizontal > .pcui-panel-header {\n  width: 2048px;\n  -webkit-transform: rotate(90deg);\n  -moz-transform: rotate(90deg);\n  -ms-transform: rotate(90deg);\n  -o-transform: rotate(90deg);\n  transform: rotate(90deg);\n  -webkit-transform-origin: 0% 100%;\n  -moz-transform-origin: 0% 100%;\n  -ms-transform-origin: 0% 100%;\n  -o-transform-origin: 0% 100%;\n  transform-origin: 0% 100%;\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed.pcui-panel-horizontal > .pcui-panel-header:before {\n  content: "\\e177";\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed.pcui-panel-horizontal.pcui-panel-normal > .pcui-panel-header:before {\n  content: "\\e181";\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed.pcui-panel-horizontal > .pcui-panel-content {\n  transition: none;\n}\n\n.pcui-panel.pcui-resizable.pcui-collapsible.pcui-collapsed > .pcui-resizable-handle {\n  display: none;\n}\n.pcui-panel.pcui-resizable.pcui-resizable-resizing {\n  transition: none;\n}\n.pcui-panel.pcui-resizable.pcui-resizable-resizing > .pcui-panel-content {\n  transition: none;\n}\n\n.pcui-panel-header > .pcui-panel-sortable-icon {\n  color: #5b7073;\n  transition: color 100ms;\n  flex-direction: row;\n  align-items: center;\n  margin: 0 10px 0 0;\n  height: 100%;\n}\n.pcui-panel-header > .pcui-panel-sortable-icon:before {\n  content: " ";\n  border-left: 1px solid #364346;\n  margin-right: 10px;\n  height: calc(100% - 14px);\n  flex-shrink: 0;\n}\n.pcui-panel-header > .pcui-panel-sortable-icon:after {\n  content: ".. .. ..";\n  white-space: normal;\n  width: 12px;\n  line-height: 5px;\n  overflow: hidden;\n  height: 24px;\n  font-size: 22px;\n  letter-spacing: 1px;\n  flex-shrink: 0;\n}\n\n.pcui-panel:not(.pcui-disabled):not(.pcui-readonly) > .pcui-panel-header > .pcui-panel-sortable-icon:hover {\n  color: #ffffff;\n  cursor: move;\n}\n\n.pcui-panel:not(.pcui-collapsible) > .pcui-panel-header > .pcui-panel-sortable-icon:before {\n  display: none;\n}\n\n.pcui-panel-remove {\n  align-self: flex-end;\n  order: 100;\n}\n.pcui-panel-remove:before {\n  line-height: 30px;\n}\n\n.pcui-panel.pcui-readonly .pcui-panel-remove {\n  display: none;\n}\n\n.pcui-panel-header > .pcui-button {\n  flex-shrink: 0;\n  margin: 1px;\n  background-color: transparent;\n  border: 0;\n}\n\n.pcui-panel.pcui-disabled > .pcui-panel-header {\n  background-color: #303d40;\n  color: #999;\n}\n\n.pcui-subpanel {\n  box-sizing: border-box;\n  margin: 6px;\n  border: 1px solid #293538;\n  border-radius: 2px;\n  background-color: #2c393c;\n  color: #b1b8ba;\n  font-size: 12px;\n}\n.pcui-subpanel .pcui-button {\n  background-color: #364346;\n  border-color: #293538;\n}\n.pcui-subpanel .pcui-button:not(.pcui-disabled):not(.pcui-readonly):hover, .pcui-subpanel .pcui-button:not(.pcui-disabled):not(.pcui-readonly):focus {\n  background-color: #364346;\n}\n.pcui-subpanel .pcui-button:not(.pcui-disabled):not(.pcui-readonly):active {\n  background-color: #2c393c;\n}');class Mp extends Eh{constructor(e){e||(e={});const t=Object.assign({},e);t.flex=!0,delete t.grid,delete t.flexDirection,delete t.scrollable,super(t),this.class.add("pcui-panel"),e.panelType&&this.class.add("pcui-panel-"+e.panelType),this._suspendReflow=!0,this._initializeHeader(e),this._initializeContent(e),this.headerSize=void 0!==e.headerSize?e.headerSize:32,this._domEvtDragStart=this._onDragStart.bind(this),this._domEvtDragMove=this._onDragMove.bind(this),this._domEvtDragEnd=this._onDragEnd.bind(this),this._reflowTimeout=null,this._widthBeforeCollapse=null,this._heightBeforeCollapse=null,this.collapsible=e.collapsible||!1,this.collapsed=e.collapsed||!1,this.collapseHorizontally=e.collapseHorizontally||!1,this._iconSort=null,this.sortable=e.sortable||!1,this._btnRemove=null,this.removable=e.removable||!1,this.domContent=this._containerContent.dom,this._suspendReflow=!1,this._reflow()}_initializeHeader(e){this._containerHeader=new Eh({flex:!0,flexDirection:"row",class:["pcui-panel-header","font-bold"]}),this._labelTitle=new Sp({text:e.headerText,class:["pcui-panel-header-title","font-bold"]}),this._containerHeader.append(this._labelTitle),this._containerHeader.dom.addEventListener("click",this._onHeaderClick.bind(this)),this.append(this._containerHeader)}_onHeaderClick(e){this._collapsible&&(e.target!==this.header.dom&&e.target!==this._labelTitle.dom||(this.collapsed=!this.collapsed))}_onClickRemove(e){e.preventDefault(),e.stopPropagation(),this.emit("click:remove")}_initializeContent(e){this._containerContent=new Eh({class:"pcui-panel-content",grid:e.grid,flex:e.flex,flexDirection:e.flexDirection,scrollable:e.scrollable,dom:e.container}),this.append(this._containerContent)}_reflow(){this._suspendReflow||(this._reflowTimeout&&(cancelAnimationFrame(this._reflowTimeout),this._reflowTimeout=null),!this.hidden&&this.collapsible&&(this.collapsed&&this.collapseHorizontally?this._containerHeader.style.top=-this.headerSize+"px":this._containerHeader.style.top="",this._reflowTimeout=requestAnimationFrame((()=>{this._reflowTimeout=null,this.collapsed?(this._widthBeforeCollapse||(this._widthBeforeCollapse=this.style.width),this._heightBeforeCollapse||(this._heightBeforeCollapse=this.style.height),this._collapseHorizontally?(this.height="",this.width=this.headerSize):this.height=this.headerSize,this.class.add("pcui-collapsed")):(this.class.remove("pcui-collapsed"),this._collapseHorizontally?(this.height="",null!==this._widthBeforeCollapse&&(this.width=this._widthBeforeCollapse)):null!==this._heightBeforeCollapse&&(this.height=this._heightBeforeCollapse),this._widthBeforeCollapse=null,this._heightBeforeCollapse=null)}))))}_onDragStart(e){this.disabled||this.readOnly||(e.stopPropagation(),e.preventDefault(),window.addEventListener("mouseup",this._domEvtDragEnd),window.addEventListener("mouseleave",this._domEvtDragEnd),window.addEventListener("mousemove",this._domEvtDragMove),this.emit("dragstart"),this.parent&&this.parent._onChildDragStart&&this.parent._onChildDragStart(e,this))}_onDragMove(e){this.emit("dragmove"),this.parent&&this.parent._onChildDragStart&&this.parent._onChildDragMove(e,this)}_onDragEnd(e){window.removeEventListener("mouseup",this._domEvtDragEnd),window.removeEventListener("mouseleave",this._domEvtDragEnd),window.removeEventListener("mousemove",this._domEvtDragMove),this._draggedChild===this&&(this._draggedChild=null),this.emit("dragend"),this.parent&&this.parent._onChildDragStart&&this.parent._onChildDragEnd(e,this)}destroy(){this._destroyed||(this._reflowTimeout&&(cancelAnimationFrame(this._reflowTimeout),this._reflowTimeout=null),window.removeEventListener("mouseup",this._domEvtDragEnd),window.removeEventListener("mouseleave",this._domEvtDragEnd),window.removeEventListener("mousemove",this._domEvtDragMove),super.destroy())}get collapsible(){return this._collapsible}set collapsible(e){e!==this._collapsible&&(this._collapsible=e,e?this.classAdd("pcui-collapsible"):this.classRemove("pcui-collapsible"),this._reflow(),this.collapsed&&this.emit(e?"collapse":"expand"))}get collapsed(){return this._collapsed}set collapsed(e){this._collapsed!==e&&(this._collapsed=e,this._reflow(),this.collapsible&&this.emit(e?"collapse":"expand"))}get sortable(){return this._sortable}set sortable(e){this._sortable!==e&&(this._sortable=e,e?(this._iconSort=new Sp({class:"pcui-panel-sortable-icon"}),this._iconSort.dom.addEventListener("mousedown",this._domEvtDragStart),this.header.prepend(this._iconSort)):this._iconSort&&(this._iconSort.destroy(),this._iconSort=null))}get removable(){return!!this._btnRemove}set removable(e){this.removable!==e&&(e?(this._btnRemove=new Ap({icon:"E289",class:"pcui-panel-remove"}),this._btnRemove.on("click",this._onClickRemove.bind(this)),this.header.append(this._btnRemove)):(this._btnRemove.destroy(),this._btnRemove=null))}get collapseHorizontally(){return this._collapseHorizontally}set collapseHorizontally(e){this._collapseHorizontally!==e&&(this._collapseHorizontally=e,e?this.classAdd("pcui-panel-horizontal"):this.classRemove("pcui-panel-horizontal"),this._reflow())}get content(){return this._containerContent}get header(){return this._containerHeader}get headerText(){return this._labelTitle.text}set headerText(e){this._labelTitle.text=e}get headerSize(){return this._headerSize}set headerSize(e){this._headerSize=e;const t=this._containerHeader.dom.style;t.height=Math.max(0,e)+"px",t.lineHeight=t.height,this._reflow()}}xh.register("panel",Mp);var Lp=function(e){oh(n,Sh);var t=ph(n);function n(e){var a;return ah(this,n),(a=t.call(this,e)).elementClass=Mp,a}return sh(n,[{key:"componentDidMount",value:function(){this.attachElement(this.nodeElement,this.containerElement)}},{key:"render",value:function(){var e=this,t=N.Children.toArray(this.props.children);return 1===t.length?t=N.cloneElement(t[0],{parent:this.element}):t.length>0&&(t=t.map((function(t){return N.cloneElement(t,{parent:e.element})}))),N.createElement("div",{ref:function(t){return e.nodeElement=t}},N.createElement("div",{ref:function(t){return e.containerElement=t}},t))}}]),n}();Lp.propTypes={},Lp.ctor=Mp,Lp.defaultProps={},function(e){if(!e||!window)return;const t=document.createElement("style");t.setAttribute("type","text/css"),t.innerHTML=e,document.head.appendChild(t)}('@font-face {\n  font-family: "pc-icon";\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot");\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix") format("embedded-opentype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2") format("woff2"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff") format("woff"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf") format("truetype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg") format("svg");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon {\n  font-family: "pc-icon";\n}\n\n.fixedFont, .pcui-text-input.pcui-multiple-values:before, .pcui-text-input > input {\n  font-family: inconsolatamedium, Monaco, Menlo, "Ubuntu Mono", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-text-input {\n  display: inline-block;\n  border: 1px solid #293538;\n  border-radius: 2px;\n  box-sizing: border-box;\n  margin: 6px;\n  min-height: 24px;\n  height: 24px;\n  background-color: #2c393c;\n  vertical-align: top;\n  transition: color 100ms, background-color 100ms, box-shadow 100ms;\n  position: relative;\n  color: #b1b8ba;\n}\n.pcui-text-input > input {\n  height: 100%;\n  width: calc(100% - 16px);\n  padding: 0 6px;\n  line-height: 1;\n  color: inherit;\n  background: transparent;\n  border: none;\n  outline: none;\n  box-shadow: none;\n}\n.pcui-text-input:before {\n  color: inherit;\n}\n\n.pcui-text-input.pcui-multiple-values:before {\n  position: absolute;\n  padding: 0 8px;\n  content: "...";\n  white-space: nowrap;\n  top: 5px;\n  font-size: 12px;\n}\n\n.pcui-text-input:not(.pcui-disabled):not(.pcui-readonly):hover {\n  background-color: #293538;\n  color: #ffffff;\n}\n.pcui-text-input:not(.pcui-disabled):not(.pcui-readonly):not(.pcui-error):hover {\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-text-input:not(.pcui-disabled):not(.pcui-readonly).pcui-focus {\n  background-color: #20292b;\n  box-shadow: 0 0 0 1px rgba(255, 102, 0, 0.3);\n}\n\n.pcui-text-input.pcui-focus:after, .pcui-text-input.pcui-focus:before, .pcui-text-input:hover:after, .pcui-text-input:hover:before {\n  display: none;\n}\n\n.pcui-text-input.pcui-readonly {\n  background-color: rgba(44, 57, 60, 0.7);\n  border-color: transparent;\n}\n\n.pcui-text-input.pcui-disabled {\n  color: #5b7073;\n}\n\n.pcui-text-input.pcui-error {\n  color: #b1b8ba;\n  box-shadow: 0 0 0 1px #d34141;\n}\n\n.pcui-text-input[placeholder] {\n  position: relative;\n}\n.pcui-text-input[placeholder]:after {\n  content: attr(placeholder);\n  background-color: #2c393c;\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 0 8px;\n  line-height: 22px;\n  font-size: 10px;\n  font-weight: 600;\n  white-space: nowrap;\n  color: #829193;\n  pointer-events: none;\n}');class Rp extends xh{constructor(e){e||(e={}),super(e.dom?e.dom:document.createElement("div"),e),this.class.add("pcui-text-input");let t=e.input;t||(t=document.createElement("input"),t.ui=this,t.type="text",t.tabIndex=0),this._domInput=t,this._domEvtChange=this._onInputChange.bind(this),this._domEvtFocus=this._onInputFocus.bind(this),this._domEvtBlur=this._onInputBlur.bind(this),this._domEvtKeyDown=this._onInputKeyDown.bind(this),this._domEvtKeyUp=this._onInputKeyUp.bind(this),this._domEvtCtxMenu=this._onInputCtxMenu.bind(this),this._domInput.addEventListener("change",this._domEvtChange),this._domInput.addEventListener("focus",this._domEvtFocus),this._domInput.addEventListener("blur",this._domEvtBlur),this._domInput.addEventListener("keydown",this._domEvtKeyDown),this._domInput.addEventListener("contextmenu",this._domEvtCtxMenu,!1),this.dom.appendChild(this._domInput),this._suspendInputChangeEvt=!1,void 0!==e.value&&(this.value=e.value),this.placeholder=e.placeholder||null,this.renderChanges=e.renderChanges||!1,this.blurOnEnter=void 0===e.blurOnEnter||e.blurOnEnter,this.blurOnEscape=void 0===e.blurOnEscape||e.blurOnEscape,this.keyChange=e.keyChange||!1,this._prevValue=null,e.onValidate&&(this.onValidate=e.onValidate),this.on("change",(()=>{this.renderChanges&&this.flash()})),this.on("disable",this._updateInputReadOnly.bind(this)),this.on("enable",this._updateInputReadOnly.bind(this)),this.on("readOnly",this._updateInputReadOnly.bind(this)),this._updateInputReadOnly()}_onInputChange(e){if(!this._suspendInputChangeEvt){if(this._onValidate){const e=!this._onValidate(this.value);if(this.error=e,e)return}else this.error=!1;this.emit("change",this.value),this._binding&&this._binding.setValue(this.value)}}_onInputFocus(e){this.class.add(fh),this.emit("focus",e),this._prevValue=this.value}_onInputBlur(e){this.class.remove(fh),this.emit("blur",e)}_onInputKeyDown(e){27===e.keyCode&&this.blurOnEscape?(this._suspendInputChangeEvt=!0,this._domInput.value=this._prevValue,this._suspendInputChangeEvt=!1,this._domInput.blur()):13===e.keyCode&&this.blurOnEnter&&this._domInput.blur(),this.emit("keydown",e)}_onInputKeyUp(e){this._onInputChange(e),this.emit("keyup",e)}_onInputCtxMenu(e){this._domInput.select()}_updateInputReadOnly(){!this.enabled||this.readOnly?this._domInput.setAttribute("readonly",!0):this._domInput.removeAttribute("readonly")}_updateValue(e){if(this.class.remove(gh),e&&"object"==typeof e)if(Array.isArray(e)){let t=!1;for(let n=0;n<e.length;n++)if(e[n]&&"object"==typeof e[n]){t=!0;break}e=t?"[Not available]":e.map((e=>null===e?"null":e)).join(",")}else e="[Not available]";return e!==this.value&&(this._suspendInputChangeEvt=!0,this._domInput.value=null==e?"":e,this._suspendInputChangeEvt=!1,this.emit("change",e),!0)}focus(e){this._domInput.focus(),e&&this._domInput.select()}blur(){this._domInput.blur()}destroy(){this._destroyed||(this._domInput.removeEventListener("change",this._domEvtChange),this._domInput.removeEventListener("focus",this._domEvtFocus),this._domInput.removeEventListener("blur",this._domEvtBlur),this._domInput.removeEventListener("keydown",this._domEvtKeyDown),this._domInput.removeEventListener("keyup",this._domEvtKeyUp),this._domInput.removeEventListener("contextmenu",this._domEvtCtxMenu),this._domInput=null,super.destroy())}get value(){return this._domInput.value}set value(e){const t=this._updateValue(e);t&&(this.error=!1),t&&this._binding&&this._binding.setValue(e)}set values(e){let t=!1;const n=e[0];for(let a=1;a<e.length;a++)if(e[a]!==n){t=!0;break}t?(this._updateValue(null),this.class.add(gh)):this._updateValue(e[0])}get placeholder(){return this.dom.getAttribute("placeholder")}set placeholder(e){e?this.dom.setAttribute("placeholder",e):this.dom.removeAttribute("placeholder")}get keyChange(){return this._keyChange}set keyChange(e){this._keyChange!==e&&(this._keyChange=e,e?this._domInput.addEventListener("keyup",this._domEvtKeyUp):this._domInput.removeEventListener("keyup",this._domEvtKeyUp))}get input(){return this._domInput}get onValidate(){return this._onValidate}set onValidate(e){this._onValidate=e}}xh.register("string",Rp,{renderChanges:!0});var Ip=function(e){oh(n,Sh);var t=ph(n);function n(e){var a;return ah(this,n),(a=t.call(this,e)).elementClass=Rp,a}return sh(n,[{key:"render",value:function(){return uh(lh(n.prototype),"render",this).call(this)}}]),n}();Ip.propTypes={},Ip.ctor=Rp,Ip.defaultProps={};var Pp=function(e){oh(n,Sh);var t=ph(n);function n(e){var a;return ah(this,n),(a=t.call(this,e)).elementClass=Sp,a}return sh(n,[{key:"render",value:function(){return N.createElement("span",{ref:this.attachElement})}}]),n}();Pp.propTypes={},Pp.ctor=Sp,Pp.defaultProps={text:""},function(e){if(!e||!window)return;const t=document.createElement("style");t.setAttribute("type","text/css"),t.innerHTML=e,document.head.appendChild(t)}(".noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex, .pcui-label-group {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden), .pcui-label-group:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-label-group {\n  align-items: center;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  margin: 6px;\n}\n.pcui-label-group > .pcui-label:first-child {\n  width: 100px;\n  flex-shrink: 0;\n  margin: 0;\n}\n.pcui-label-group > .pcui-element:not(:first-child) {\n  margin: 0 0 0 6px;\n}\n.pcui-label-group > .pcui-element:nth-child(2):not(.pcui-not-flexible) {\n  flex: 1;\n}\n.pcui-label-group > .pcui-vector-input > .pcui-numeric-input {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.pcui-label-group-align-top > .pcui-label:first-child {\n  align-self: flex-start;\n  margin-top: 4px;\n}\n\n.pcui-label-group.pcui-disabled > .pcui-label:first-child {\n  opacity: 0.4;\n}");class kp extends Eh{constructor(e){e||(e={}),super(e),this.class.add("pcui-label-group"),this._label=new Sp({text:e.text||"Label",nativeTooltip:e.nativeTooltip}),this.append(this._label),this._field=e.field,this._field&&this.append(this._field),this.labelAlignTop=e.labelAlignTop||!1}get label(){return this._label}get field(){return this._field}get text(){return this._label.text}set text(e){this._label.text=e}get labelAlignTop(){return this.class.contains("pcui-label-group-align-top")}set labelAlignTop(e){e?this.class.add("pcui-label-group-align-top"):this.class.remove("pcui-label-group-align-top")}}xh.register("labelgroup",kp);var Dp=function(e){oh(n,Sh);var t=ph(n);function n(e){var a;ah(this,n),a=t.call(this,e);var i=e.children;return a.childElement=new i.type.ctor(i.props),a.element=new kp(nh(nh({},e),{},{field:a.childElement})),i.props.link&&(a.childLink=i.props.link),a}return sh(n,[{key:"componentDidMount",value:function(){this.childLink&&this.childElement.link(this.childLink.observer,this.childLink.path)}},{key:"render",value:function(){var e=this;return N.createElement("div",{ref:function(t){t&&t.appendChild(e.element.dom)}})}}]),n}();Dp.propTypes={},Dp.ctor=kp,Dp.defaultProps={},function(e){if(!e||!window)return;const t=document.createElement("style");t.setAttribute("type","text/css"),t.innerHTML=e,document.head.appendChild(t)}('@charset "UTF-8";\n@font-face {\n  font-family: "pc-icon";\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot");\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix") format("embedded-opentype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2") format("woff2"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff") format("woff"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf") format("truetype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg") format("svg");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon, .pcui-boolean-input.pcui-boolean-input-ticked:after {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon, .pcui-boolean-input.pcui-boolean-input-ticked:after {\n  font-family: "pc-icon";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, "Ubuntu Mono", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.pcui-boolean-input {\n  display: inline-block;\n  position: relative;\n  box-sizing: border-box;\n  background-color: #2c393c;\n  color: #fff;\n  width: 14px;\n  height: 14px;\n  line-height: 1;\n  overflow: hidden;\n  margin: 6px;\n  transition: opacity 100ms, background-color 100ms, box-shadow 100ms;\n}\n.pcui-boolean-input:focus {\n  outline: none;\n}\n\n.pcui-boolean-input.pcui-boolean-input-ticked {\n  background-color: #b1b8ba;\n}\n.pcui-boolean-input.pcui-boolean-input-ticked:after {\n  content: "\\e372";\n  color: #20292b;\n  background-color: inherit;\n  font-size: 19px;\n  display: block;\n  margin-top: -2px;\n  margin-left: -2px;\n}\n\n.pcui-boolean-input:not(.pcui-disabled):not(.pcui-readonly):hover, .pcui-boolean-input:not(.pcui-disabled):not(.pcui-readonly):focus {\n  cursor: pointer;\n  background-color: #293538;\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-boolean-input:not(.pcui-disabled):not(.pcui-readonly).pcui-boolean-input-ticked:hover, .pcui-boolean-input:not(.pcui-disabled):not(.pcui-readonly).pcui-boolean-input-ticked:focus {\n  background-color: #b1b8ba;\n}\n\n.pcui-boolean-input.pcui-disabled {\n  opacity: 0.4;\n}\n\n.pcui-boolean-input.pcui-multiple-values:after {\n  position: absolute;\n  font-size: 17px;\n  font-weight: bold;\n  color: #b1b8ba;\n  left: 4px;\n  top: -3px;\n  content: "-";\n}\n\n.pcui-boolean-input-toggle {\n  display: inline-block;\n  position: relative;\n  width: 30px;\n  height: 16px;\n  border-radius: 8px;\n  flex-shrink: 0;\n  border: 1px solid #293538;\n  box-sizing: border-box;\n  background-color: #364346;\n  color: #fff;\n  line-height: 1;\n  overflow: hidden;\n  margin: 6px;\n  transition: opacity 100ms, background-color 100ms, box-shadow 100ms;\n}\n.pcui-boolean-input-toggle:focus {\n  outline: none;\n}\n.pcui-boolean-input-toggle:after {\n  content: " ";\n  position: absolute;\n  top: 1px;\n  left: 1px;\n  width: 12px;\n  height: 12px;\n  border-radius: 6px;\n  background-color: #5b7073;\n  transition: left 100ms ease, background-color 100ms ease;\n}\n\n.pcui-boolean-input-toggle.pcui-boolean-input-ticked {\n  border-color: #293538;\n}\n.pcui-boolean-input-toggle.pcui-boolean-input-ticked:after {\n  left: 15px;\n  background-color: #69b875;\n}\n\n.pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly):hover, .pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly):focus {\n  cursor: pointer;\n  border-color: #20292b;\n  background-color: #20292b;\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly):hover:after, .pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly):focus:after {\n  background-color: #d34141;\n}\n.pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly).pcui-boolean-input-ticked:hover, .pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly).pcui-boolean-input-ticked:focus {\n  border-color: #20292b;\n  background-color: #20292b;\n}\n.pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly).pcui-boolean-input-ticked:after {\n  background-color: #7f7;\n}\n\n.pcui-boolean-input-toggle.pcui-readonly {\n  opacity: 0.7;\n}\n\n.pcui-boolean-input-toggle.pcui-disabled {\n  opacity: 0.4;\n}\n\n.pcui-boolean-input-toggle.pcui-multiple-values:after {\n  left: 8px;\n  background-color: rgba(155, 161, 163, 0.25);\n}');class Op extends xh{constructor(e){super((e=Object.assign({tabIndex:0},e)).dom?e.dom:document.createElement("div"),e),"toggle"===e.type?this.class.add("pcui-boolean-input-toggle"):this.class.add("pcui-boolean-input"),this.class.add("pcui-not-flexible"),this._domEventKeyDown=this._onKeyDown.bind(this),this._domEventFocus=this._onFocus.bind(this),this._domEventBlur=this._onBlur.bind(this),this.dom.addEventListener("keydown",this._domEventKeyDown),this.dom.addEventListener("focus",this._domEventFocus),this.dom.addEventListener("blur",this._domEventBlur),this._value=null,void 0!==e.value&&(this.value=e.value),this.renderChanges=e.renderChanges}_onClick(e){return this.enabled&&this.focus(),this.enabled&&!this.readOnly&&(this.value=!this.value),super._onClick(e)}_onKeyDown(e){27!==e.keyCode?this.enabled&&!this.readOnly&&32===e.keyCode&&(e.stopPropagation(),e.preventDefault(),this.value=!this.value):this.blur()}_onFocus(){this.emit("focus")}_onBlur(){this.emit("blur")}_updateValue(e){return this.class.remove(gh),e!==this.value&&(this._value=e,e?this.class.add("pcui-boolean-input-ticked"):this.class.remove("pcui-boolean-input-ticked"),this.renderChanges&&this.flash(),this.emit("change",e),!0)}focus(){this.dom.focus()}blur(){this.dom.blur()}destroy(){this._destroyed||(this.dom.removeEventListener("keydown",this._domEventKeyDown),this.dom.removeEventListener("focus",this._domEventFocus),this.dom.removeEventListener("blur",this._domEventBlur),super.destroy())}get value(){return this._value}set value(e){this._updateValue(e)&&this._binding&&this._binding.setValue(e)}set values(e){let t=!1;const n=e[0];for(let a=1;a<e.length;a++)if(e[a]!==n){t=!0;break}t?(this._updateValue(null),this.class.add(gh)):this._updateValue(e[0])}}xh.register("boolean",Op,{renderChanges:!0});var Fp=function(e){oh(n,Sh);var t=ph(n);function n(e){var a;return ah(this,n),(a=t.call(this,e)).elementClass=Op,a}return sh(n,[{key:"render",value:function(){return uh(lh(n.prototype),"render",this).call(this)}}]),n}();Fp.ctor=Op;class Np extends bh{constructor(e){super(),e||(e={}),this._observers=null,this._paths=null,this._applyingChange=!1,this._element=e.element||null,this._history=e.history||null,this._historyPrefix=e.historyPrefix||null,this._historyPostfix=e.historyPostfix||null,this._historyName=e.historyName||null,this._historyCombine=e.historyCombine||!1,this._linked=!1}_pathAt(e,t){return e[t]||e[0]}link(e,t){this._observers&&this.unlink(),this._observers=Array.isArray(e)?e:[e],this._paths=Array.isArray(t)?t:[t],this._linked=!0}unlink(){this._observers=null,this._paths=null,this._linked=!1}clone(){throw new Error("pcui.BindingBase#clone: Not implemented")}setValue(e){}setValues(e){}addValue(e){}addValues(e){}removeValue(e){}removeValues(e){}get element(){return this._element}set element(e){this._element=e}get applyingChange(){return this._applyingChange}set applyingChange(e){this._applyingChange!==e&&(this._applyingChange=e,this.emit("applyingChange",e))}get linked(){return this._linked}get historyCombine(){return this._historyCombine}set historyCombine(e){this._historyCombine=e}get historyName(){return this._historyName}set historyName(e){this._historyName=e}get historyPrefix(){return this._historyPrefix}set historyPrefix(e){this._historyPrefix=e}get historyPostfix(){return this._historyPostfix}set historyPostfix(e){this._historyPostfix=e}get historyEnabled(){return this._history&&this._history.enabled}set historyEnabled(e){this._history&&(this._history.enabled=e)}get observers(){return this._observers}get paths(){return this._paths}}class Vp extends Np{clone(){return new Vp({history:this._history,historyPrefix:this._historyPrefix,historyPostfix:this._historyPostfix,historyName:this._historyName,historyCombine:this._historyCombine})}_getHistoryActionName(e){return`${this._historyPrefix||""}${this._historyName||e[0]}${this._historyPostfix||""}`}_setValue(e,t){if(this.applyingChange)return;if(!this._observers)return;this.applyingChange=!0;const n=this._observers.slice(),a=this._paths.slice(),i={observers:n,paths:a},s=()=>{this._setValueToObservers(n,a,e,t),this.emit("history:redo",i)};if(this._history){let e=[];e=1===n.length&&a.length>1?a.map((e=>n[0].has(e)?n[0].get(e):void 0)):n.map(((e,t)=>{const n=this._pathAt(a,t);return e.has(n)?e.get(n):void 0})),this.emit("history:init",i),this._history.add({name:this._getHistoryActionName(a),redo:s,combine:this._historyCombine,undo:()=>{this._setValueToObservers(n,a,e,!0),this.emit("history:undo",i)}})}s(),this.applyingChange=!1}_setValueToObservers(e,t,n,a){if(1===e.length&&t.length>1)for(let a=0;a<t.length;a++){const i=e[0].latest();if(!i)continue;let s=!1;i.history&&(s=i.history.enabled,i.history.enabled=!1);const r=t[a],o=n[a];void 0!==n?this._observerSet(i,r,o):i.unset(r),s&&(i.history.enabled=!0)}else for(let i=0;i<e.length;i++){const s=e[i].latest();if(!s)continue;let r=!1;s.history&&(r=s.history.enabled,s.history.enabled=!1);const o=this._pathAt(t,i),l=a?n[i]:n;void 0!==n?this._observerSet(s,o,l):s.unset(o),r&&(s.history.enabled=!0)}}_observerSet(e,t,n){const a=t.lastIndexOf(".");if(a>0&&!e.has(t.substring(0,a)))return;const i=Array.isArray(n);e.set(t,i&&n?n.slice():n)}_addValues(e){if(this.applyingChange)return;if(!this._observers)return;this.applyingChange=!0;const t=this._observers.slice(),n=this._paths.slice(),a=[];for(let i=0;i<t.length;i++){const s=this._pathAt(n,i),r=t[i];e.forEach((e=>{-1===r.get(s).indexOf(e)&&a.push({observer:r,path:s,value:e})}))}const i=()=>{for(let e=0;e<a.length;e++){const t=a[e].observer.latest();if(!t)continue;const n=a[e].path;let i=!1;t.history&&(i=t.history.enabled,t.history.enabled=!1),t.insert(n,a[e].value),i&&(t.history.enabled=!0)}};this._history&&a.length&&this._history.add({name:this._getHistoryActionName(n),redo:i,combine:this._historyCombine,undo:()=>{for(let e=0;e<a.length;e++){const t=a[e].observer.latest();if(!t)continue;const n=a[e].path;let i=!1;t.history&&(i=t.history.enabled,t.history.enabled=!1),t.removeValue(n,a[e].value),i&&(t.history.enabled=!0)}}}),i(),this.applyingChange=!1}_removeValues(e){if(this.applyingChange)return;if(!this._observers)return;this.applyingChange=!0;const t=this._observers.slice(),n=this._paths.slice(),a=[];for(let i=0;i<t.length;i++){const s=this._pathAt(n,i),r=t[i];e.forEach((e=>{const t=r.get(s).indexOf(e);-1!==t&&a.push({observer:r,path:s,value:e,index:t})}))}const i=()=>{for(let e=0;e<a.length;e++){const t=a[e].observer.latest();if(!t)continue;const n=a[e].path;let i=!1;t.history&&(i=t.history.enabled,t.history.enabled=!1),t.removeValue(n,a[e].value),i&&(t.history.enabled=!0)}};this._history&&a.length&&this._history.add({name:this._getHistoryActionName(n),redo:i,combine:this._historyCombine,undo:()=>{for(let e=0;e<a.length;e++){const t=a[e].observer.latest();if(!t)continue;const n=a[e].path;let i=!1;t.history&&(i=t.history.enabled,t.history.enabled=!1),-1===t.get(n).indexOf(a[e].value)&&t.insert(n,a[e].value,a[e].index),i&&(t.history.enabled=!0)}}}),i(),this.applyingChange=!1}setValue(e){this._setValue(e,!1)}setValues(e){e=e.slice().map((e=>Array.isArray(e)?e.slice():e)),this._setValue(e,!0)}addValue(e){this._addValues([e])}addValues(e){this._addValues(e)}removeValue(e){this._removeValues([e])}removeValues(e){this._removeValues(e)}}class Bp extends Np{constructor({customUpdate:e,...t}={}){super(t),this._customUpdate=e,this._events=[],this._updateElementHandler=this._updateElement.bind(this),this._updateTimeout=null}_linkObserver(e,t){this._events.push(e.on(t+":set",this._deferUpdateElement.bind(this))),this._events.push(e.on(t+":unset",this._deferUpdateElement.bind(this))),this._events.push(e.on(t+":insert",this._deferUpdateElement.bind(this))),this._events.push(e.on(t+":remove",this._deferUpdateElement.bind(this)))}_deferUpdateElement(){this.applyingChange||(this.applyingChange=!0,this._updateTimeout=setTimeout(this._updateElementHandler))}_updateElement(){this._updateTimeout&&(clearTimeout(this._updateTimeout),this._updateTimeout=null),this._updateTimeout=null,this.applyingChange=!0,"function"==typeof this._customUpdate?this._customUpdate(this._element,this._observers,this._paths):1===this._observers.length?this._paths.length>1?this._element.value=this._paths.map((e=>this._observers[0].has(e)?this._observers[0].get(e):void 0)):this._element.value=this._observers[0].has(this._paths[0])?this._observers[0].get(this._paths[0]):void 0:this._element.values=this._observers.map(((e,t)=>{const n=this._pathAt(this._paths,t);return e.has(n)?e.get(n):void 0})),this.applyingChange=!1}link(e,t){super.link(e,t);const n=this._element.renderChanges;if(n&&(this._element.renderChanges=!1),this._updateElement(),n&&(this._element.renderChanges=n),1===this._observers.length&&this._paths.length>1)for(let e=0;e<this._paths.length;e++)this._linkObserver(this._observers[0],this._paths[e]);else for(let e=0;e<this._observers.length;e++)this._linkObserver(this._observers[e],this._pathAt(this._paths,e))}unlink(){for(let e=0;e<this._events.length;e++)this._events[e].unbind();this._events.length=0,this._updateTimeout&&(clearTimeout(this._updateTimeout),this._updateTimeout=null),super.unlink()}clone(){return new Bp({customUpdate:this._customUpdate})}}class Up extends Np{constructor(e){e||(e={}),super(e),this._bindingElementToObservers=e.bindingElementToObservers||new Vp(e),this._bindingObserversToElement=e.bindingObserversToElement||new Bp(e),this._applyingChange=!1,this._bindingElementToObservers.on("applyingChange",(e=>{this.applyingChange=e})),this._bindingElementToObservers.on("history:init",(e=>{this.emit("history:init",e)})),this._bindingElementToObservers.on("history:undo",(e=>{this.emit("history:undo",e)})),this._bindingElementToObservers.on("history:redo",(e=>{this.emit("history:redo",e)})),this._bindingObserversToElement.on("applyingChange",(e=>{this.applyingChange=e}))}link(e,t){super.link(e,t),this._bindingElementToObservers.link(e,t),this._bindingObserversToElement.link(e,t)}unlink(){this._bindingElementToObservers.unlink(),this._bindingObserversToElement.unlink(),super.unlink()}clone(){return new Up({bindingElementToObservers:this._bindingElementToObservers.clone(),bindingObserversToElement:this._bindingObserversToElement.clone()})}setValue(e){this._bindingElementToObservers.setValue(e)}setValues(e){this._bindingElementToObservers.setValues(e)}addValue(e){this._bindingElementToObservers.addValue(e)}addValues(e){this._bindingElementToObservers.addValues(e)}removeValue(e){this._bindingElementToObservers.removeValue(e)}removeValues(e){this._bindingElementToObservers.removeValues(e)}get element(){return this._element}set element(e){this._element=e,this._bindingElementToObservers.element=e,this._bindingObserversToElement.element=e}get applyingChange(){return super.applyingChange}set applyingChange(e){super.applyingChange!==e&&(this._bindingElementToObservers.applyingChange=e,this._bindingObserversToElement.applyingChange=e,super.applyingChange=e)}get historyCombine(){return this._bindingElementToObservers.historyCombine}set historyCombine(e){this._bindingElementToObservers.historyCombine=e}get historyPrefix(){return this._bindingElementToObservers.historyPrefix}set historyPrefix(e){this._bindingElementToObservers.historyPrefix=e}get historyPostfix(){return this._bindingElementToObservers.historyPostfix}set historyPostfix(e){this._bindingElementToObservers.historyPostfix=e}get historyEnabled(){return this._bindingElementToObservers.historyEnabled}set historyEnabled(e){this._bindingElementToObservers.historyEnabled=e}}var zp={animation:{"blend-trees-1d":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any, data: any): void {\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n\n    // setup skydome\n    app.scene.exposure = 2;\n    app.scene.skyboxMip = 2;\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n    cameraEntity.translate(0, 0.75, 3);\n\n    // add bloom postprocessing (this is ignored by the picker)\n    cameraEntity.addComponent("script");\n    cameraEntity.script.create("bloom", {\n        attributes: {\n            bloomIntensity: 1,\n            bloomThreshold: 0.7,\n            blurAmount: 4\n        }\n    });\n    app.root.addChild(cameraEntity);\n\n    // Create an entity with a light component\n    const lightEntity = new pc.Entity();\n    lightEntity.addComponent("light", {\n        castShadows: true,\n        intensity: 1.5,\n        normalOffsetBias: 0.02,\n        shadowType: pc.SHADOW_PCF5,\n        shadowDistance: 6,\n        shadowResolution: 2048,\n        shadowBias: 0.02\n    });\n    app.root.addChild(lightEntity);\n    lightEntity.setLocalEulerAngles(45, 30, 0);\n\n    // create an entity from the loaded model using the render component\n    const modelEntity = assets.model.resource.instantiateRenderEntity({\n        castShadows: true\n    });\n\n    // add an anim component to the entity\n    modelEntity.addComponent(\'anim\', {\n        activate: true\n    });\n\n    // create an anim state graph\n    const animStateGraphData = {\n        "layers": [\n            {\n                "name": "characterState",\n                "states": [\n                    {\n                        "name": "START"\n                    },\n                    {\n                        "name": "Movement",\n                        "speed": 1.0,\n                        "loop": true,\n                        "blendTree": {\n                            "type": "1D",\n                            "parameter": "blend",\n                            "children": [\n                                {\n                                    "name": "Idle",\n                                    "point": 0.0\n                                },\n                                {\n                                    "name": "Dance",\n                                    "point": 1.0,\n                                    "speed": 0.85\n                                }\n                            ]\n                        }\n                    }\n                ],\n                "transitions": [\n                    {\n                        "from": "START",\n                        "to": "Movement"\n                    }\n                ]\n            }\n        ],\n        "parameters": {\n            "blend": {\n                "name": "blend",\n                "type": "FLOAT",\n                "value": 0\n            }\n        }\n    };\n\n    // load the state graph into the anim component\n    modelEntity.anim.loadStateGraph(animStateGraphData);\n\n    // load the state graph asset resource into the anim component\n    const characterStateLayer = modelEntity.anim.baseLayer;\n    characterStateLayer.assignAnimation(\'Movement.Idle\', assets.idleAnim.resource.animations[0].resource);\n    characterStateLayer.assignAnimation(\'Movement.Dance\', assets.danceAnim.resource.animations[0].resource);\n\n    app.root.addChild(modelEntity);\n\n    app.start();\n\n    data.on(\'blend:set\', (blend: number) => {\n        modelEntity.anim.setFloat(\'blend\', blend);\n    });\n}',javaScriptFunction:'function example(canvas, assets, data) {\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    // setup skydome\n    app.scene.exposure = 2;\n    app.scene.skyboxMip = 2;\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    cameraEntity.translate(0, 0.75, 3);\n\n    // add bloom postprocessing (this is ignored by the picker)\n    cameraEntity.addComponent("script");\n    cameraEntity.script.create("bloom", {\n        attributes: {\n            bloomIntensity: 1,\n            bloomThreshold: 0.7,\n            blurAmount: 4,\n        },\n    });\n\n    app.root.addChild(cameraEntity);\n\n    // Create an entity with a light component\n    const lightEntity = new pc.Entity();\n    lightEntity.addComponent("light", {\n        castShadows: true,\n        intensity: 1.5,\n        normalOffsetBias: 0.02,\n        shadowType: pc.SHADOW_PCF5,\n        shadowDistance: 6,\n        shadowResolution: 2048,\n        shadowBias: 0.02,\n    });\n\n    app.root.addChild(lightEntity);\n    lightEntity.setLocalEulerAngles(45, 30, 0);\n\n    // create an entity from the loaded model using the render component\n    const modelEntity = assets.model.resource.instantiateRenderEntity({\n        castShadows: true,\n    });\n\n    // add an anim component to the entity\n    modelEntity.addComponent("anim", {\n        activate: true,\n    });\n\n    // create an anim state graph\n    const animStateGraphData = {\n        layers: [\n            {\n                name: "characterState",\n                states: [\n                    {\n                        name: "START",\n                    },\n\n                    {\n                        name: "Movement",\n                        speed: 1.0,\n                        loop: true,\n                        blendTree: {\n                            type: "1D",\n                            parameter: "blend",\n                            children: [\n                                {\n                                    name: "Idle",\n                                    point: 0.0,\n                                },\n\n                                {\n                                    name: "Dance",\n                                    point: 1.0,\n                                    speed: 0.85,\n                                },\n                            ],\n                        },\n                    },\n                ],\n\n                transitions: [\n                    {\n                        from: "START",\n                        to: "Movement",\n                    },\n                ],\n            },\n        ],\n\n        parameters: {\n            blend: {\n                name: "blend",\n                type: "FLOAT",\n                value: 0,\n            },\n        },\n    };\n\n    // load the state graph into the anim component\n    modelEntity.anim.loadStateGraph(animStateGraphData);\n\n    // load the state graph asset resource into the anim component\n    const characterStateLayer = modelEntity.anim.baseLayer;\n    characterStateLayer.assignAnimation(\n        "Movement.Idle",\n        assets.idleAnim.resource.animations[0].resource\n    );\n    characterStateLayer.assignAnimation(\n        "Movement.Dance",\n        assets.danceAnim.resource.animations[0].resource\n    );\n\n    app.root.addChild(modelEntity);\n\n    app.start();\n\n    data.on("blend:set", (blend) => {\n        modelEntity.anim.setFloat("blend", blend);\n    });\n}\n',nameSlug:"blend-trees-1d",categorySlug:"animation"},"blend-trees-2d-cartesian":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any): void {\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n\n    // setup skydome\n    app.scene.exposure = 2;\n    app.scene.skyboxMip = 2;\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n    cameraEntity.translate(0, 0.75, 3);\n    // add bloom postprocessing (this is ignored by the picker)\n    cameraEntity.addComponent("script");\n    cameraEntity.script.create("bloom", {\n        attributes: {\n            bloomIntensity: 1,\n            bloomThreshold: 0.7,\n            blurAmount: 4\n        }\n    });\n    app.root.addChild(cameraEntity);\n\n    // Create an entity with a light component\n    const lightEntity = new pc.Entity();\n    lightEntity.addComponent("light", {\n        castShadows: true,\n        intensity: 1.5,\n        normalOffsetBias: 0.02,\n        shadowType: pc.SHADOW_PCF5,\n        shadowDistance: 6,\n        shadowResolution: 2048,\n        shadowBias: 0.02\n    });\n    app.root.addChild(lightEntity);\n    lightEntity.setLocalEulerAngles(45, 30, 0);\n\n    // create an entity from the loaded model using the render component\n    const modelEntity = assets.model.resource.instantiateRenderEntity({\n        castShadows: true\n    });\n    modelEntity.name = \'model\';\n\n    // add an anim component to the entity\n    modelEntity.addComponent(\'anim\', {\n        activate: true\n    });\n\n    // create an anim state graph\n    const animStateGraphData = {\n        "layers": [\n            {\n                "name": "base",\n                "states": [\n                    {\n                        "name": "START"\n                    },\n                    {\n                        "name": "Emote",\n                        "speed": 1.0,\n                        "loop": true,\n                        "blendTree": {\n                            "type": pc.ANIM_BLEND_2D_CARTESIAN,\n                            "parameters": ["posX", "posY"],\n                            "children": [\n                                {\n                                    "name": "Idle",\n                                    "point": [-0.5, 0.5]\n                                },\n                                {\n                                    "name": "Eager",\n                                    "point": [0.5, 0.5]\n                                },\n                                {\n                                    "name": "Walk",\n                                    "point": [0.5, -0.5]\n                                },\n                                {\n                                    "name": "Dance",\n                                    "point": [-0.5, -0.5]\n                                }\n                            ]\n                        }\n                    }\n                ],\n                "transitions": [\n                    {\n                        "from": "START",\n                        "to": "Emote"\n                    }\n                ]\n            }\n        ],\n        "parameters": {\n            "posX": {\n                "name": "posX",\n                "type": "FLOAT",\n                "value": -0.5\n            },\n            "posY": {\n                "name": "posY",\n                "type": "FLOAT",\n                "value": 0.5\n            }\n        }\n    };\n\n    // load the state graph into the anim component\n    modelEntity.anim.loadStateGraph(animStateGraphData);\n\n    // load the state graph asset resource into the anim component\n    const characterStateLayer = modelEntity.anim.baseLayer;\n    characterStateLayer.assignAnimation(\'Emote.Idle\', assets.idleAnim.resource.animations[0].resource);\n    characterStateLayer.assignAnimation(\'Emote.Eager\', assets.eagerAnim.resource.animations[0].resource);\n    characterStateLayer.assignAnimation(\'Emote.Dance\', assets.danceAnim.resource.animations[0].resource);\n    characterStateLayer.assignAnimation(\'Emote.Walk\', assets.walkAnim.resource.animations[0].resource);\n\n    app.root.addChild(modelEntity);\n\n    app.start();\n}',javaScriptFunction:'function example(canvas, assets) {\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    // setup skydome\n    app.scene.exposure = 2;\n    app.scene.skyboxMip = 2;\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    cameraEntity.translate(0, 0.75, 3);\n    // add bloom postprocessing (this is ignored by the picker)\n    cameraEntity.addComponent("script");\n    cameraEntity.script.create("bloom", {\n        attributes: {\n            bloomIntensity: 1,\n            bloomThreshold: 0.7,\n            blurAmount: 4,\n        },\n    });\n\n    app.root.addChild(cameraEntity);\n\n    // Create an entity with a light component\n    const lightEntity = new pc.Entity();\n    lightEntity.addComponent("light", {\n        castShadows: true,\n        intensity: 1.5,\n        normalOffsetBias: 0.02,\n        shadowType: pc.SHADOW_PCF5,\n        shadowDistance: 6,\n        shadowResolution: 2048,\n        shadowBias: 0.02,\n    });\n\n    app.root.addChild(lightEntity);\n    lightEntity.setLocalEulerAngles(45, 30, 0);\n\n    // create an entity from the loaded model using the render component\n    const modelEntity = assets.model.resource.instantiateRenderEntity({\n        castShadows: true,\n    });\n\n    modelEntity.name = "model";\n\n    // add an anim component to the entity\n    modelEntity.addComponent("anim", {\n        activate: true,\n    });\n\n    // create an anim state graph\n    const animStateGraphData = {\n        layers: [\n            {\n                name: "base",\n                states: [\n                    {\n                        name: "START",\n                    },\n\n                    {\n                        name: "Emote",\n                        speed: 1.0,\n                        loop: true,\n                        blendTree: {\n                            type: pc.ANIM_BLEND_2D_CARTESIAN,\n                            parameters: ["posX", "posY"],\n                            children: [\n                                {\n                                    name: "Idle",\n                                    point: [-0.5, 0.5],\n                                },\n\n                                {\n                                    name: "Eager",\n                                    point: [0.5, 0.5],\n                                },\n\n                                {\n                                    name: "Walk",\n                                    point: [0.5, -0.5],\n                                },\n\n                                {\n                                    name: "Dance",\n                                    point: [-0.5, -0.5],\n                                },\n                            ],\n                        },\n                    },\n                ],\n\n                transitions: [\n                    {\n                        from: "START",\n                        to: "Emote",\n                    },\n                ],\n            },\n        ],\n\n        parameters: {\n            posX: {\n                name: "posX",\n                type: "FLOAT",\n                value: -0.5,\n            },\n\n            posY: {\n                name: "posY",\n                type: "FLOAT",\n                value: 0.5,\n            },\n        },\n    };\n\n    // load the state graph into the anim component\n    modelEntity.anim.loadStateGraph(animStateGraphData);\n\n    // load the state graph asset resource into the anim component\n    const characterStateLayer = modelEntity.anim.baseLayer;\n    characterStateLayer.assignAnimation(\n        "Emote.Idle",\n        assets.idleAnim.resource.animations[0].resource\n    );\n    characterStateLayer.assignAnimation(\n        "Emote.Eager",\n        assets.eagerAnim.resource.animations[0].resource\n    );\n    characterStateLayer.assignAnimation(\n        "Emote.Dance",\n        assets.danceAnim.resource.animations[0].resource\n    );\n    characterStateLayer.assignAnimation(\n        "Emote.Walk",\n        assets.walkAnim.resource.animations[0].resource\n    );\n\n    app.root.addChild(modelEntity);\n\n    app.start();\n}\n',nameSlug:"blend-trees-2d-cartesian",categorySlug:"animation"},"blend-trees-2d-directional":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any, data: any): void {\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n\n    // setup skydome\n    app.scene.exposure = 2;\n    app.scene.skyboxMip = 2;\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n    cameraEntity.translate(0, 0.75, 3);\n    // add bloom postprocessing (this is ignored by the picker)\n    cameraEntity.addComponent("script");\n    cameraEntity.script.create("bloom", {\n        attributes: {\n            bloomIntensity: 1,\n            bloomThreshold: 0.7,\n            blurAmount: 4\n        }\n    });\n    app.root.addChild(cameraEntity);\n\n    // Create an entity with a light component\n    const lightEntity = new pc.Entity();\n    lightEntity.addComponent("light", {\n        castShadows: true,\n        intensity: 1.5,\n        normalOffsetBias: 0.02,\n        shadowType: pc.SHADOW_PCF5,\n        shadowDistance: 6,\n        shadowResolution: 2048,\n        shadowBias: 0.02\n    });\n    app.root.addChild(lightEntity);\n    lightEntity.setLocalEulerAngles(45, 30, 0);\n\n    // create an entity from the loaded model using the render component\n    const modelEntity = assets.model.resource.instantiateRenderEntity({\n        castShadows: true\n    });\n    modelEntity.name = \'model\';\n\n    // add an anim component to the entity\n    modelEntity.addComponent(\'anim\', {\n        activate: true\n    });\n\n    // create an anim state graph\n    const animStateGraphData = {\n        "layers": [\n            {\n                "name": "locomotion",\n                "states": [\n                    {\n                        "name": "START"\n                    },\n                    {\n                        "name": "Travel",\n                        "speed": 1.0,\n                        "loop": true,\n                        "blendTree": {\n                            "type": pc.ANIM_BLEND_2D_DIRECTIONAL,\n                            "syncDurations": true,\n                            "parameters": ["posX", "posY"],\n                            "children": [\n                                {\n                                    "name": "Idle",\n                                    "point": [0.0, 0.0]\n                                },\n                                {\n                                    "speed": -1,\n                                    "name": "WalkBackwards",\n                                    "point": [0.0, -0.5]\n                                },\n                                {\n                                    "speed": 1,\n                                    "name": "Walk",\n                                    "point": [0.0, 0.5]\n                                },\n                                {\n                                    "speed": 1,\n                                    "name": "Jog",\n                                    "point": [0.0, 1.0]\n                                }\n                            ]\n                        }\n                    }\n                ],\n                "transitions": [\n                    {\n                        "from": "START",\n                        "to": "Travel"\n                    }\n                ]\n            }\n        ],\n        "parameters": {\n            "posX": {\n                "name": "posX",\n                "type": "FLOAT",\n                "value": 0\n            },\n            "posY": {\n                "name": "posY",\n                "type": "FLOAT",\n                "value": 0\n            }\n        }\n    };\n\n    // load the state graph into the anim component\n    modelEntity.anim.loadStateGraph(animStateGraphData);\n\n    // load the state graph asset resource into the anim component\n    const locomotionLayer = modelEntity.anim.baseLayer;\n    locomotionLayer.assignAnimation(\'Travel.Idle\', assets.idleAnim.resource.animations[0].resource);\n    locomotionLayer.assignAnimation(\'Travel.Walk\', assets.walkAnim.resource.animations[0].resource);\n    locomotionLayer.assignAnimation(\'Travel.WalkBackwards\', assets.walkAnim.resource.animations[0].resource);\n    locomotionLayer.assignAnimation(\'Travel.Jog\', assets.jogAnim.resource.animations[0].resource);\n\n    app.root.addChild(modelEntity);\n\n    app.start();\n}',javaScriptFunction:'function example(canvas, assets, data) {\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    // setup skydome\n    app.scene.exposure = 2;\n    app.scene.skyboxMip = 2;\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    cameraEntity.translate(0, 0.75, 3);\n    // add bloom postprocessing (this is ignored by the picker)\n    cameraEntity.addComponent("script");\n    cameraEntity.script.create("bloom", {\n        attributes: {\n            bloomIntensity: 1,\n            bloomThreshold: 0.7,\n            blurAmount: 4,\n        },\n    });\n\n    app.root.addChild(cameraEntity);\n\n    // Create an entity with a light component\n    const lightEntity = new pc.Entity();\n    lightEntity.addComponent("light", {\n        castShadows: true,\n        intensity: 1.5,\n        normalOffsetBias: 0.02,\n        shadowType: pc.SHADOW_PCF5,\n        shadowDistance: 6,\n        shadowResolution: 2048,\n        shadowBias: 0.02,\n    });\n\n    app.root.addChild(lightEntity);\n    lightEntity.setLocalEulerAngles(45, 30, 0);\n\n    // create an entity from the loaded model using the render component\n    const modelEntity = assets.model.resource.instantiateRenderEntity({\n        castShadows: true,\n    });\n\n    modelEntity.name = "model";\n\n    // add an anim component to the entity\n    modelEntity.addComponent("anim", {\n        activate: true,\n    });\n\n    // create an anim state graph\n    const animStateGraphData = {\n        layers: [\n            {\n                name: "locomotion",\n                states: [\n                    {\n                        name: "START",\n                    },\n\n                    {\n                        name: "Travel",\n                        speed: 1.0,\n                        loop: true,\n                        blendTree: {\n                            type: pc.ANIM_BLEND_2D_DIRECTIONAL,\n                            syncDurations: true,\n                            parameters: ["posX", "posY"],\n                            children: [\n                                {\n                                    name: "Idle",\n                                    point: [0.0, 0.0],\n                                },\n\n                                {\n                                    speed: -1,\n                                    name: "WalkBackwards",\n                                    point: [0.0, -0.5],\n                                },\n\n                                {\n                                    speed: 1,\n                                    name: "Walk",\n                                    point: [0.0, 0.5],\n                                },\n\n                                {\n                                    speed: 1,\n                                    name: "Jog",\n                                    point: [0.0, 1.0],\n                                },\n                            ],\n                        },\n                    },\n                ],\n\n                transitions: [\n                    {\n                        from: "START",\n                        to: "Travel",\n                    },\n                ],\n            },\n        ],\n\n        parameters: {\n            posX: {\n                name: "posX",\n                type: "FLOAT",\n                value: 0,\n            },\n\n            posY: {\n                name: "posY",\n                type: "FLOAT",\n                value: 0,\n            },\n        },\n    };\n\n    // load the state graph into the anim component\n    modelEntity.anim.loadStateGraph(animStateGraphData);\n\n    // load the state graph asset resource into the anim component\n    const locomotionLayer = modelEntity.anim.baseLayer;\n    locomotionLayer.assignAnimation(\n        "Travel.Idle",\n        assets.idleAnim.resource.animations[0].resource\n    );\n    locomotionLayer.assignAnimation(\n        "Travel.Walk",\n        assets.walkAnim.resource.animations[0].resource\n    );\n    locomotionLayer.assignAnimation(\n        "Travel.WalkBackwards",\n        assets.walkAnim.resource.animations[0].resource\n    );\n    locomotionLayer.assignAnimation(\n        "Travel.Jog",\n        assets.jogAnim.resource.animations[0].resource\n    );\n\n    app.root.addChild(modelEntity);\n\n    app.start();\n}\n',nameSlug:"blend-trees-2d-directional",categorySlug:"animation"},"component-properties":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { playcanvasGreyTexture: pc.Asset }, data: any): void {\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n\n    // create the animation data for two static spot lights\n    const animClipStaticLightData = {\n        "name": "staticLight",\n        "duration": 1.0,\n        // curve keyframe inputs\n        "inputs": [\n            [\n                0.0\n            ]\n        ],\n        // curve keyframe outputs\n        "outputs": [\n            // a single RGBA color keyframe value of a green light\n            {\n                "components": 4,\n                "data": [\n                    0.0, 1.0, 0.0, 1.0\n                ]\n            },\n            // a single quaternion keyframe value with no rotation\n            {\n                "components": 4,\n                "data": [\n                    0.0, 0.0, 0.0, 0.0\n                ]\n            }\n        ],\n        // the curves contained in the clip, each with the path to the property they animation, the index of\n        // their input and output keyframes and the method of interpolation to be used\n        "curves": [\n            {\n                "path": { entityPath: ["lights", "spotLight1"], component: "light", propertyPath: ["color"] },\n                "inputIndex": 0,\n                "outputIndex": 0,\n                "interpolation": 1\n            },\n            {\n                "path": { entityPath: ["lights", "spotLight2"], component: "light", propertyPath: ["color"] },\n                "inputIndex": 0,\n                "outputIndex": 0,\n                "interpolation": 1\n            },\n            {\n                "path": { entityPath: ["lights", "spotLight1"], component: "entity", propertyPath: ["localEulerAngles"] },\n                "inputIndex": 0,\n                "outputIndex": 1,\n                "interpolation": 1\n            },\n            {\n                "path": { entityPath: ["lights", "spotLight2"], component: "entity", propertyPath: ["localEulerAngles"] },\n                "inputIndex": 0,\n                "outputIndex": 1,\n                "interpolation": 1\n            }\n        ]\n    };\n\n    // create the animation data for two flashing spot lights\n    const animClipFlashingLightData = {\n        "name": "flashingLight",\n        "duration": 2.0,\n        // curve keyframe inputs\n        "inputs": [\n            [\n                0.0, 0.5, 1.0, 1.5, 2.0\n            ],\n            [\n                0, 1, 2\n            ]\n        ],\n        // curve keyframe outputs\n        "outputs": [\n            //  keyframe outputs for a flashing red RGBA color\n            {\n                "components": 4,\n                "data": [\n                    1.0, 0.0, 0.0, 1.0,\n                    0.4, 0.0, 0.0, 1.0,\n                    1.0, 0.0, 0.0, 1.0,\n                    0.4, 0.0, 0.0, 1.0,\n                    1.0, 0.0, 0.0, 1.0\n                ]\n            },\n            //  keyframe outputs for a quaternion rotation\n            {\n                "components": 4,\n                "data": [\n                    4.0, 0.0, 0.0, 0.0,\n                    4.0, 180.0, 0.0, 0.0,\n                    4.0, 0.0, 0.0, 0.0\n                ]\n            },\n            //  keyframe outputs for a quaternion rotation\n            {\n                "components": 4,\n                "data": [\n                    -4.0, 0.0, 0.0, 0.0,\n                    -4.0, 180.0, 0.0, 0.0,\n                    -4.0, 0.0, 0.0, 0.0\n                ]\n            }\n        ],\n        // the curves contained in the clip, each with the path to the property they animation, the index of\n        // their input and output keyframes and the method of interpolation to be used\n        "curves": [\n            {\n                "path": { entityPath: ["lights", "spotLight1"], component: "light", propertyPath: ["color"] },\n                "inputIndex": 0,\n                "outputIndex": 0,\n                "interpolation": 1\n            },\n            {\n                "path": { entityPath: ["lights", "spotLight2"], component: "light", propertyPath: ["color"] },\n                "inputIndex": 0,\n                "outputIndex": 0,\n                "interpolation": 1\n            },\n            {\n                "path": { entityPath: ["lights", "spotLight1"], component: "entity", propertyPath: ["localEulerAngles"] },\n                "inputIndex": 1,\n                "outputIndex": 1,\n                "interpolation": 1\n            },\n            {\n                "path": { entityPath: ["lights", "spotLight2"], component: "entity", propertyPath: ["localEulerAngles"] },\n                "inputIndex": 1,\n                "outputIndex": 2,\n                "interpolation": 1\n            }\n        ]\n    };\n\n    const animClipHandler = new pc.AnimClipHandler();\n    const animClipStaticLight = animClipHandler.open(undefined, animClipStaticLightData);\n    const animClipFlashingLight = animClipHandler.open(undefined, animClipFlashingLightData);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.name = \'camera\';\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0, 0, 0.0)\n    });\n    cameraEntity.translateLocal(7, 10, 7);\n    cameraEntity.lookAt(0, 0, 0);\n\n    const boxEntity = new pc.Entity();\n    boxEntity.addComponent("render", {\n        type: \'box\'\n    });\n    boxEntity.name = \'model\';\n    boxEntity.setPosition(0, 0.25, 0);\n    boxEntity.setLocalScale(0.5, 0.5, 0.5);\n    const material = new pc.StandardMaterial();\n    material.diffuseMap = assets.playcanvasGreyTexture.resource;\n    material.update();\n    boxEntity.render.meshInstances[0].material = material;\n\n    const planeEntity = new pc.Entity();\n    planeEntity.name = \'plane\';\n    planeEntity.addComponent("render", {\n        type: "plane"\n    });\n    planeEntity.setLocalScale(15, 1, 15);\n    planeEntity.setPosition(0, 0, 0);\n\n    // Create the animatible lights\n    const lightsEntity = new pc.Entity();\n    lightsEntity.name = \'lights\';\n\n    const light1 = new pc.Entity();\n    light1.name = \'spotLight1\';\n    light1.addComponent("light", {\n        type: "spot",\n        color: new pc.Color(0.0, 0.0, 0.0, 1.0),\n        intensity: 1,\n        range: 15,\n        innerConeAngle: 5,\n        outerConeAngle: 10\n    });\n    light1.setPosition(0, 10, 0);\n\n    const light2 = new pc.Entity();\n    light2.name = \'spotLight2\';\n    light2.addComponent("light", {\n        type: "spot",\n        color: new pc.Color(0.0, 0.0, 0.0, 1.0),\n        intensity: 1,\n        range: 15,\n        innerConeAngle: 5,\n        outerConeAngle: 10\n    });\n    light2.setPosition(0, 10, 0);\n\n    // Add Entities into the scene hierarchy\n    app.root.addChild(cameraEntity);\n    lightsEntity.addChild(light1);\n    lightsEntity.addChild(light2);\n    app.root.addChild(lightsEntity);\n    app.root.addChild(boxEntity);\n    app.root.addChild(planeEntity);\n\n    // add the anim component to the lights entity\n    lightsEntity.addComponent("anim", {\n        speed: 1.0,\n        activate: true\n    });\n\n    // assign animation clip asset resources to the appropriate states\n    lightsEntity.anim.assignAnimation(\'Static\', animClipStaticLight);\n    lightsEntity.anim.assignAnimation(\'Flash\', animClipFlashingLight);\n\n    app.start();\n\n    data.on(\'flash:set\', () => {\n        if (lightsEntity.anim.baseLayer.activeState === \'Static\') {\n            lightsEntity.anim.baseLayer.transition(\'Flash\', 0.5);\n        } else {\n            lightsEntity.anim.baseLayer.transition(\'Static\', 0.5);\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets, data) {\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    // create the animation data for two static spot lights\n    const animClipStaticLightData = {\n        name: "staticLight",\n        duration: 1.0,\n        // curve keyframe inputs\n        inputs: [[0.0]],\n\n        // curve keyframe outputs\n        outputs: [\n            // a single RGBA color keyframe value of a green light\n            {\n                components: 4,\n                data: [0.0, 1.0, 0.0, 1.0],\n            },\n\n            // a single quaternion keyframe value with no rotation\n            {\n                components: 4,\n                data: [0.0, 0.0, 0.0, 0.0],\n            },\n        ],\n\n        // the curves contained in the clip, each with the path to the property they animation, the index of\n        // their input and output keyframes and the method of interpolation to be used\n        curves: [\n            {\n                path: {\n                    entityPath: ["lights", "spotLight1"],\n                    component: "light",\n                    propertyPath: ["color"],\n                },\n                inputIndex: 0,\n                outputIndex: 0,\n                interpolation: 1,\n            },\n\n            {\n                path: {\n                    entityPath: ["lights", "spotLight2"],\n                    component: "light",\n                    propertyPath: ["color"],\n                },\n                inputIndex: 0,\n                outputIndex: 0,\n                interpolation: 1,\n            },\n\n            {\n                path: {\n                    entityPath: ["lights", "spotLight1"],\n                    component: "entity",\n                    propertyPath: ["localEulerAngles"],\n                },\n                inputIndex: 0,\n                outputIndex: 1,\n                interpolation: 1,\n            },\n\n            {\n                path: {\n                    entityPath: ["lights", "spotLight2"],\n                    component: "entity",\n                    propertyPath: ["localEulerAngles"],\n                },\n                inputIndex: 0,\n                outputIndex: 1,\n                interpolation: 1,\n            },\n        ],\n    };\n\n    // create the animation data for two flashing spot lights\n    const animClipFlashingLightData = {\n        name: "flashingLight",\n        duration: 2.0,\n        // curve keyframe inputs\n        inputs: [\n            [0.0, 0.5, 1.0, 1.5, 2.0],\n\n            [0, 1, 2],\n        ],\n\n        // curve keyframe outputs\n        outputs: [\n            //  keyframe outputs for a flashing red RGBA color\n            {\n                components: 4,\n                data: [\n                    1.0, 0.0, 0.0, 1.0, 0.4, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0,\n                    0.4, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0,\n                ],\n            },\n\n            //  keyframe outputs for a quaternion rotation\n            {\n                components: 4,\n                data: [\n                    4.0, 0.0, 0.0, 0.0, 4.0, 180.0, 0.0, 0.0, 4.0, 0.0, 0.0,\n                    0.0,\n                ],\n            },\n\n            //  keyframe outputs for a quaternion rotation\n            {\n                components: 4,\n                data: [\n                    -4.0, 0.0, 0.0, 0.0, -4.0, 180.0, 0.0, 0.0, -4.0, 0.0, 0.0,\n                    0.0,\n                ],\n            },\n        ],\n\n        // the curves contained in the clip, each with the path to the property they animation, the index of\n        // their input and output keyframes and the method of interpolation to be used\n        curves: [\n            {\n                path: {\n                    entityPath: ["lights", "spotLight1"],\n                    component: "light",\n                    propertyPath: ["color"],\n                },\n                inputIndex: 0,\n                outputIndex: 0,\n                interpolation: 1,\n            },\n\n            {\n                path: {\n                    entityPath: ["lights", "spotLight2"],\n                    component: "light",\n                    propertyPath: ["color"],\n                },\n                inputIndex: 0,\n                outputIndex: 0,\n                interpolation: 1,\n            },\n\n            {\n                path: {\n                    entityPath: ["lights", "spotLight1"],\n                    component: "entity",\n                    propertyPath: ["localEulerAngles"],\n                },\n                inputIndex: 1,\n                outputIndex: 1,\n                interpolation: 1,\n            },\n\n            {\n                path: {\n                    entityPath: ["lights", "spotLight2"],\n                    component: "entity",\n                    propertyPath: ["localEulerAngles"],\n                },\n                inputIndex: 1,\n                outputIndex: 2,\n                interpolation: 1,\n            },\n        ],\n    };\n\n    const animClipHandler = new pc.AnimClipHandler();\n    const animClipStaticLight = animClipHandler.open(\n        undefined,\n        animClipStaticLightData\n    );\n    const animClipFlashingLight = animClipHandler.open(\n        undefined,\n        animClipFlashingLightData\n    );\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.name = "camera";\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0, 0, 0.0),\n    });\n\n    cameraEntity.translateLocal(7, 10, 7);\n    cameraEntity.lookAt(0, 0, 0);\n\n    const boxEntity = new pc.Entity();\n    boxEntity.addComponent("render", {\n        type: "box",\n    });\n\n    boxEntity.name = "model";\n    boxEntity.setPosition(0, 0.25, 0);\n    boxEntity.setLocalScale(0.5, 0.5, 0.5);\n    const material = new pc.StandardMaterial();\n    material.diffuseMap = assets.playcanvasGreyTexture.resource;\n    material.update();\n    boxEntity.render.meshInstances[0].material = material;\n\n    const planeEntity = new pc.Entity();\n    planeEntity.name = "plane";\n    planeEntity.addComponent("render", {\n        type: "plane",\n    });\n\n    planeEntity.setLocalScale(15, 1, 15);\n    planeEntity.setPosition(0, 0, 0);\n\n    // Create the animatible lights\n    const lightsEntity = new pc.Entity();\n    lightsEntity.name = "lights";\n\n    const light1 = new pc.Entity();\n    light1.name = "spotLight1";\n    light1.addComponent("light", {\n        type: "spot",\n        color: new pc.Color(0.0, 0.0, 0.0, 1.0),\n        intensity: 1,\n        range: 15,\n        innerConeAngle: 5,\n        outerConeAngle: 10,\n    });\n\n    light1.setPosition(0, 10, 0);\n\n    const light2 = new pc.Entity();\n    light2.name = "spotLight2";\n    light2.addComponent("light", {\n        type: "spot",\n        color: new pc.Color(0.0, 0.0, 0.0, 1.0),\n        intensity: 1,\n        range: 15,\n        innerConeAngle: 5,\n        outerConeAngle: 10,\n    });\n\n    light2.setPosition(0, 10, 0);\n\n    // Add Entities into the scene hierarchy\n    app.root.addChild(cameraEntity);\n    lightsEntity.addChild(light1);\n    lightsEntity.addChild(light2);\n    app.root.addChild(lightsEntity);\n    app.root.addChild(boxEntity);\n    app.root.addChild(planeEntity);\n\n    // add the anim component to the lights entity\n    lightsEntity.addComponent("anim", {\n        speed: 1.0,\n        activate: true,\n    });\n\n    // assign animation clip asset resources to the appropriate states\n    lightsEntity.anim.assignAnimation("Static", animClipStaticLight);\n    lightsEntity.anim.assignAnimation("Flash", animClipFlashingLight);\n\n    app.start();\n\n    data.on("flash:set", () => {\n        if (lightsEntity.anim.baseLayer.activeState === "Static") {\n            lightsEntity.anim.baseLayer.transition("Flash", 0.5);\n        } else {\n            lightsEntity.anim.baseLayer.transition("Static", 0.5);\n        }\n    });\n}\n',nameSlug:"component-properties",categorySlug:"animation"},events:{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: { orbitScript: pc.Asset, bloom: pc.Asset, model: pc.Asset, walkAnim: pc.Asset, 'helipad.dds': pc.Asset }): void {\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body)\n    });\n    app.scene.exposure = 2;\n    app.start();\n\n    // setup skydome\n    app.scene.skyboxMip = 2;\n    app.scene.setSkybox(assets['helipad.dds'].resources);\n    app.scene.skyboxIntensity = 0.4;    // make it darker\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n    cameraEntity.translate(0, 1, 0);\n\n    // add bloom postprocessing (this is ignored by the picker)\n    cameraEntity.addComponent(\"script\");\n    cameraEntity.script.create(\"bloom\", {\n        attributes: {\n            bloomIntensity: 1,\n            bloomThreshold: 0.7,\n            blurAmount: 4\n        }\n    });\n    app.root.addChild(cameraEntity);\n\n    const boxes: any = {};\n    const highlightedBoxes: pc.Entity[] = [];\n\n    // create a floor made up of box models\n    for (let i = -5; i <= 5; i++) {\n        for (let j = -5; j <= 5; j++) {\n            const box = new pc.Entity();\n            boxes[`${i}${j}`] = box;\n            box.addComponent('model', { type: 'box' });\n            box.setPosition(i, -0.5, j);\n            box.setLocalScale(0.95, 1, 0.95);\n            const material = new pc.StandardMaterial();\n            material.diffuse = new pc.Color(0.7, 0.7, 0.7);\n            material.shininess = 30;\n            material.metalness = 0.2;\n            material.useMetalness = true;\n            box.model.material = material;\n            material.update();\n            app.root.addChild(box);\n\n        }\n    }\n\n    // light up a box at the given position with a random color using the emissive material property\n    const highlightBox = (pos: pc.Vec3) => {\n        const i = Math.floor(pos.x + 0.5);\n        const j = Math.floor(pos.z + 0.5);\n        const colorVec = new pc.Vec3(Math.random(), Math.random(), Math.random());\n        colorVec.mulScalar(1 / colorVec.length());\n        boxes[`${i}${j}`].model.material.emissive = new pc.Color(colorVec.x, colorVec.y, colorVec.z);\n        highlightedBoxes.push(boxes[`${i}${j}`]);\n    };\n\n    // create an entity from the loaded model using the render component\n    const modelEntity = assets.model.resource.instantiateRenderEntity({\n        castShadows: true\n    });\n\n    // add an anim component to the entity\n    modelEntity.addComponent('anim', {\n        activate: true\n    });\n    modelEntity.setLocalPosition(-3, 0, 0);\n\n    const modelEntityParent = new pc.Entity();\n    modelEntityParent.addChild(modelEntity);\n\n    app.root.addChild(modelEntityParent);\n\n    // rotate the model in a circle around the center of the scene\n    app.on('update', (dt: number) => {\n        modelEntityParent.rotate(0, 13.8 * dt, 0);\n    });\n\n    const walkTrack = assets.walkAnim.resource.animations[0].resource;\n\n    // Add two anim events to the walk animation, one for each foot step. These events should occur just as each foot touches the ground\n    walkTrack.events = new pc.AnimEvents([\n        {\n            time: walkTrack.duration * 0.1,\n            name: 'foot_step',\n            bone: 'R_foot0002_bind_JNT'\n        },\n        {\n            time: walkTrack.duration * 0.6,\n            name: 'foot_step',\n            bone: 'L_foot0002_bind_JNT'\n        }\n    ]);\n\n    // add the animation track to the anim component, with a defined speed\n    modelEntity.anim.assignAnimation('Walk', walkTrack, undefined, 0.62);\n\n    modelEntity.anim.on('foot_step', (event: any) => {\n        // highlight the box that is under the foot's bone position\n        highlightBox(modelEntity.findByName(event.bone).getPosition());\n    });\n\n    app.on('update', (dt: number) => {\n        // on update, iterate over any currently highlighted boxes and reduce their emissive property\n        highlightedBoxes.forEach((box: pc.Entity) => {\n            const material = box.model.material as pc.StandardMaterial;\n            const emissive = material.emissive;\n            emissive.lerp(emissive, pc.Color.BLACK, 0.08);\n            material.update();\n        });\n        // remove old highlighted boxes from the update loop\n        while (highlightedBoxes.length > 5) {\n            highlightedBoxes.shift();\n        }\n\n        // set the camera to follow the model\n        const modelPosition = modelEntity.getPosition().clone();\n        modelPosition.y = 0.5;\n        cameraEntity.lookAt(modelPosition);\n    });\n}",javaScriptFunction:'function example(canvas, assets) {\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n    });\n\n    app.scene.exposure = 2;\n    app.start();\n\n    // setup skydome\n    app.scene.skyboxMip = 2;\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n    app.scene.skyboxIntensity = 0.4; // make it darker\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    cameraEntity.translate(0, 1, 0);\n\n    // add bloom postprocessing (this is ignored by the picker)\n    cameraEntity.addComponent("script");\n    cameraEntity.script.create("bloom", {\n        attributes: {\n            bloomIntensity: 1,\n            bloomThreshold: 0.7,\n            blurAmount: 4,\n        },\n    });\n\n    app.root.addChild(cameraEntity);\n\n    const boxes = {};\n    const highlightedBoxes = [];\n\n    // create a floor made up of box models\n    for (let i = -5; i <= 5; i++) {\n        for (let j = -5; j <= 5; j++) {\n            const box = new pc.Entity();\n            boxes[`${i}${j}`] = box;\n            box.addComponent("model", { type: "box" });\n            box.setPosition(i, -0.5, j);\n            box.setLocalScale(0.95, 1, 0.95);\n            const material = new pc.StandardMaterial();\n            material.diffuse = new pc.Color(0.7, 0.7, 0.7);\n            material.shininess = 30;\n            material.metalness = 0.2;\n            material.useMetalness = true;\n            box.model.material = material;\n            material.update();\n            app.root.addChild(box);\n        }\n    }\n\n    // light up a box at the given position with a random color using the emissive material property\n    const highlightBox = (pos) => {\n        const i = Math.floor(pos.x + 0.5);\n        const j = Math.floor(pos.z + 0.5);\n        const colorVec = new pc.Vec3(\n            Math.random(),\n            Math.random(),\n            Math.random()\n        );\n        colorVec.mulScalar(1 / colorVec.length());\n        boxes[`${i}${j}`].model.material.emissive = new pc.Color(\n            colorVec.x,\n            colorVec.y,\n            colorVec.z\n        );\n        highlightedBoxes.push(boxes[`${i}${j}`]);\n    };\n\n    // create an entity from the loaded model using the render component\n    const modelEntity = assets.model.resource.instantiateRenderEntity({\n        castShadows: true,\n    });\n\n    // add an anim component to the entity\n    modelEntity.addComponent("anim", {\n        activate: true,\n    });\n\n    modelEntity.setLocalPosition(-3, 0, 0);\n\n    const modelEntityParent = new pc.Entity();\n    modelEntityParent.addChild(modelEntity);\n\n    app.root.addChild(modelEntityParent);\n\n    // rotate the model in a circle around the center of the scene\n    app.on("update", (dt) => {\n        modelEntityParent.rotate(0, 13.8 * dt, 0);\n    });\n\n    const walkTrack = assets.walkAnim.resource.animations[0].resource;\n\n    // Add two anim events to the walk animation, one for each foot step. These events should occur just as each foot touches the ground\n    walkTrack.events = new pc.AnimEvents([\n        {\n            time: walkTrack.duration * 0.1,\n            name: "foot_step",\n            bone: "R_foot0002_bind_JNT",\n        },\n\n        {\n            time: walkTrack.duration * 0.6,\n            name: "foot_step",\n            bone: "L_foot0002_bind_JNT",\n        },\n    ]);\n\n    // add the animation track to the anim component, with a defined speed\n    modelEntity.anim.assignAnimation("Walk", walkTrack, undefined, 0.62);\n\n    modelEntity.anim.on("foot_step", (event) => {\n        // highlight the box that is under the foot\'s bone position\n        highlightBox(modelEntity.findByName(event.bone).getPosition());\n    });\n\n    app.on("update", (dt) => {\n        // on update, iterate over any currently highlighted boxes and reduce their emissive property\n        highlightedBoxes.forEach((box) => {\n            const material = box.model.material;\n            const emissive = material.emissive;\n            emissive.lerp(emissive, pc.Color.BLACK, 0.08);\n            material.update();\n        });\n        // remove old highlighted boxes from the update loop\n        while (highlightedBoxes.length > 5) {\n            highlightedBoxes.shift();\n        }\n\n        // set the camera to follow the model\n        const modelPosition = modelEntity.getPosition().clone();\n        modelPosition.y = 0.5;\n        cameraEntity.lookAt(modelPosition);\n    });\n}\n',nameSlug:"events",categorySlug:"animation"},"layer-masks":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: any, data: any): void {\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body)\n    });\n    app.start();\n\n    // setup data\n    data.set('fullBodyLayer', {\n        state: 'Idle',\n        blendType: pc.ANIM_LAYER_OVERWRITE\n    });\n    data.set('upperBodyLayer', {\n        state: 'Eager',\n        blendType: pc.ANIM_LAYER_ADDITIVE,\n        useMask: true\n    });\n    data.set('options', {\n        blend: 0.5,\n        skeleton: true\n    });\n\n    // setup skydome\n    app.scene.exposure = 2;\n    app.scene.skyboxMip = 2;\n    app.scene.setSkybox(assets['helipad.dds'].resources);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n    cameraEntity.translate(0, 0.75, 3);\n\n    // add bloom postprocessing (this is ignored by the picker)\n    cameraEntity.addComponent(\"script\");\n    cameraEntity.script.create(\"bloom\", {\n        attributes: {\n            bloomIntensity: 1,\n            bloomThreshold: 0.7,\n            blurAmount: 4\n        }\n    });\n    app.root.addChild(cameraEntity);\n\n    // Create an entity with a light component\n    const lightEntity = new pc.Entity();\n    lightEntity.addComponent(\"light\", {\n        castShadows: true,\n        intensity: 1.5,\n        normalOffsetBias: 0.02,\n        shadowType: pc.SHADOW_PCF5,\n        shadowDistance: 6,\n        shadowResolution: 2048,\n        shadowBias: 0.02\n    });\n    app.root.addChild(lightEntity);\n    lightEntity.setLocalEulerAngles(45, 30, 0);\n\n    // create an entity from the loaded model using the render component\n    const modelEntity = assets.model.resource.instantiateRenderEntity({\n        castShadows: true\n    });\n    modelEntity.addComponent('anim', {\n        activate: true\n    });\n    app.root.addChild(modelEntity);\n\n    // retrieve the animation assets\n    const idleTrack = assets.idleAnim.resource.animations[0].resource;\n    const walkTrack = assets.walkAnim.resource.animations[0].resource;\n    const danceTrack = assets.danceAnim.resource.animations[0].resource;\n    const idleEagerTrack = assets.idleEagerAnim.resource.animations[0].resource;\n\n    // create the full body layer by assigning full body animations to the anim component\n    modelEntity.anim.assignAnimation('Idle', idleTrack);\n    modelEntity.anim.assignAnimation('Walk', walkTrack);\n\n    // set the default weight for the base layer\n    modelEntity.anim.baseLayer.weight = 1.0 - data.get('options.blend');\n\n    // create a mask for the upper body layer\n    const upperBodyMask = {\n        // set a path with the children property as true to include that path and all of its children in the mask\n        'RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT': {\n            children: true\n        },\n        // set a path to true in the mask to include only that specific path\n        'RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT/C_Head': true\n    };\n\n    // create a new layer for the upper body, with additive layer blending\n    const upperBodyLayer = modelEntity.anim.addLayer('UpperBody', data.get('options.blend'), upperBodyMask, data.get('upperBodyLayer.blendType'));\n    upperBodyLayer.assignAnimation('Eager', idleEagerTrack);\n    upperBodyLayer.assignAnimation('Idle', idleTrack);\n    upperBodyLayer.assignAnimation('Dance', danceTrack);\n\n    // respond to changes in the data object made by the control panel\n    data.on('*:set', (path: string, value: any) => {\n        if (path === 'fullBodyLayer.state') {\n            modelEntity.anim.baseLayer.transition(value, 0.4);\n        }\n        if (path === 'upperBodyLayer.state') {\n            upperBodyLayer.transition(value, 0.4);\n        }\n        if (path === 'fullBodyLayer.blendType') {\n            modelEntity.anim.baseLayer.blendType = value;\n        }\n        if (path === 'upperBodyLayer.blendType') {\n            upperBodyLayer.blendType = value;\n        }\n        if (path === 'upperBodyLayer.useMask') {\n            upperBodyLayer.mask = value ? {\n                'RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT': {\n                    children: true\n                }\n            } : null;\n        }\n        if (path === 'options.blend') {\n            modelEntity.anim.baseLayer.weight = 1.0 - value;\n            upperBodyLayer.weight = value;\n        }\n    });\n\n    const drawSkeleton = (entity: pc.Entity, color: pc.Color) => {\n        entity.children.forEach((c: pc.Entity) => {\n            const target = modelEntity.anim._targets[entity.path + '/graph/localPosition'];\n            if (target) {\n                app.drawLine(entity.getPosition(), c.getPosition(), new pc.Color(target.getWeight(0), 0, target.getWeight(1), 1), false);\n            }\n            drawSkeleton(c, color);\n        });\n    };\n\n    app.on('update', () => {\n        if (data.get('options.skeleton')) {\n            drawSkeleton(modelEntity, new pc.Color(1, 0, 0, modelEntity.anim.baseLayer.weight * 0.5));\n        }\n    });\n\n}",javaScriptFunction:'function example(canvas, assets, data) {\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n    });\n\n    app.start();\n\n    // setup data\n    data.set("fullBodyLayer", {\n        state: "Idle",\n        blendType: pc.ANIM_LAYER_OVERWRITE,\n    });\n\n    data.set("upperBodyLayer", {\n        state: "Eager",\n        blendType: pc.ANIM_LAYER_ADDITIVE,\n        useMask: true,\n    });\n\n    data.set("options", {\n        blend: 0.5,\n        skeleton: true,\n    });\n\n    // setup skydome\n    app.scene.exposure = 2;\n    app.scene.skyboxMip = 2;\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    cameraEntity.translate(0, 0.75, 3);\n\n    // add bloom postprocessing (this is ignored by the picker)\n    cameraEntity.addComponent("script");\n    cameraEntity.script.create("bloom", {\n        attributes: {\n            bloomIntensity: 1,\n            bloomThreshold: 0.7,\n            blurAmount: 4,\n        },\n    });\n\n    app.root.addChild(cameraEntity);\n\n    // Create an entity with a light component\n    const lightEntity = new pc.Entity();\n    lightEntity.addComponent("light", {\n        castShadows: true,\n        intensity: 1.5,\n        normalOffsetBias: 0.02,\n        shadowType: pc.SHADOW_PCF5,\n        shadowDistance: 6,\n        shadowResolution: 2048,\n        shadowBias: 0.02,\n    });\n\n    app.root.addChild(lightEntity);\n    lightEntity.setLocalEulerAngles(45, 30, 0);\n\n    // create an entity from the loaded model using the render component\n    const modelEntity = assets.model.resource.instantiateRenderEntity({\n        castShadows: true,\n    });\n\n    modelEntity.addComponent("anim", {\n        activate: true,\n    });\n\n    app.root.addChild(modelEntity);\n\n    // retrieve the animation assets\n    const idleTrack = assets.idleAnim.resource.animations[0].resource;\n    const walkTrack = assets.walkAnim.resource.animations[0].resource;\n    const danceTrack = assets.danceAnim.resource.animations[0].resource;\n    const idleEagerTrack = assets.idleEagerAnim.resource.animations[0].resource;\n\n    // create the full body layer by assigning full body animations to the anim component\n    modelEntity.anim.assignAnimation("Idle", idleTrack);\n    modelEntity.anim.assignAnimation("Walk", walkTrack);\n\n    // set the default weight for the base layer\n    modelEntity.anim.baseLayer.weight = 1.0 - data.get("options.blend");\n\n    // create a mask for the upper body layer\n    const upperBodyMask = {\n        // set a path with the children property as true to include that path and all of its children in the mask\n        "RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT": {\n            children: true,\n        },\n\n        // set a path to true in the mask to include only that specific path\n        "RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT/C_Head": true,\n    };\n\n    // create a new layer for the upper body, with additive layer blending\n    const upperBodyLayer = modelEntity.anim.addLayer(\n        "UpperBody",\n        data.get("options.blend"),\n        upperBodyMask,\n        data.get("upperBodyLayer.blendType")\n    );\n    upperBodyLayer.assignAnimation("Eager", idleEagerTrack);\n    upperBodyLayer.assignAnimation("Idle", idleTrack);\n    upperBodyLayer.assignAnimation("Dance", danceTrack);\n\n    // respond to changes in the data object made by the control panel\n    data.on("*:set", (path, value) => {\n        if (path === "fullBodyLayer.state") {\n            modelEntity.anim.baseLayer.transition(value, 0.4);\n        }\n        if (path === "upperBodyLayer.state") {\n            upperBodyLayer.transition(value, 0.4);\n        }\n        if (path === "fullBodyLayer.blendType") {\n            modelEntity.anim.baseLayer.blendType = value;\n        }\n        if (path === "upperBodyLayer.blendType") {\n            upperBodyLayer.blendType = value;\n        }\n        if (path === "upperBodyLayer.useMask") {\n            upperBodyLayer.mask = value\n                ? {\n                      "RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT":\n                          {\n                              children: true,\n                          },\n                  }\n                : null;\n        }\n        if (path === "options.blend") {\n            modelEntity.anim.baseLayer.weight = 1.0 - value;\n            upperBodyLayer.weight = value;\n        }\n    });\n\n    const drawSkeleton = (entity, color) => {\n        entity.children.forEach((c) => {\n            const target =\n                modelEntity.anim._targets[entity.path + "/graph/localPosition"];\n            if (target) {\n                app.drawLine(\n                    entity.getPosition(),\n                    c.getPosition(),\n                    new pc.Color(\n                        target.getWeight(0),\n                        0,\n                        target.getWeight(1),\n                        1\n                    ),\n                    false\n                );\n            }\n            drawSkeleton(c, color);\n        });\n    };\n\n    app.on("update", () => {\n        if (data.get("options.skeleton")) {\n            drawSkeleton(\n                modelEntity,\n                new pc.Color(1, 0, 0, modelEntity.anim.baseLayer.weight * 0.5)\n            );\n        }\n    });\n}\n',nameSlug:"layer-masks",categorySlug:"animation"},locomotion:{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any, data: any, wasmSupported: any, loadWasmModuleAsync: any): void {\n\n    if (wasmSupported()) {\n        loadWasmModuleAsync(\'Ammo\', \'/static/lib/ammo/ammo.wasm.js\', \'/static/lib/ammo/ammo.wasm.wasm\', run);\n    } else {\n        loadWasmModuleAsync(\'Ammo\', \'/static/lib/ammo/ammo.js\', \'\', run);\n    }\n\n    function run() {\n\n        // Create the application and start the update loop\n        const app = new pc.Application(canvas, {});\n\n        // setup skydome\n        app.scene.skyboxMip = 2;\n        app.scene.skyboxIntensity = 0.7;\n        app.scene.setSkybox(assets.cubemap.resources);\n        app.scene.toneMapping = pc.TONEMAP_ACES;\n\n        // Create an Entity with a camera component\n        const cameraEntity = new pc.Entity();\n        cameraEntity.name = "Camera";\n        cameraEntity.addComponent("camera", {\n            clearColor: new pc.Color(0.1, 0.15, 0.2)\n        });\n\n        cameraEntity.translateLocal(0.5, 3, 8);\n        cameraEntity.rotateLocal(-30, 0, 0);\n        app.root.addChild(cameraEntity);\n\n        // Create an entity with a light component\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            type: "directional",\n            color: new pc.Color(1, 1, 1),\n            castShadows: true,\n            intensity: 2,\n            shadowBias: 0.2,\n            shadowDistance: 16,\n            normalOffsetBias: 0.05,\n            shadowResolution: 2048\n        });\n        light.setLocalEulerAngles(60, 30, 0);\n        app.root.addChild(light);\n\n        app.start();\n\n        const characterEntity = new pc.Entity();\n\n        // create an entity from the loaded model using the render component\n        const renderEntity = assets.model.resource.instantiateRenderEntity({\n            castShadows: true\n        });\n\n        // assign the renderEntity as the child of character entity. All transforms of the\n        // renderEntity and its children are driven by the anim component.\n        // The characterEntity transform will be controlled by the Locomotion script.\n        characterEntity.addChild(renderEntity);\n\n        // add an anim component to the entity\n        characterEntity.addComponent(\'anim\', {\n            activate: true\n        });\n\n        // create an anim state graph\n        const animStateGraphData = {\n            "layers": [\n                {\n                    "name": "locomotion",\n                    "states": [\n                        {\n                            "name": "START"\n                        },\n                        {\n                            "name": "Idle",\n                            "speed": 1.0\n                        },\n                        {\n                            "name": "Walk",\n                            "speed": 1.0\n                        },\n                        {\n                            "name": "Jump",\n                            "speed": 1\n                        },\n                        {\n                            "name": "Jog",\n                            "speed": 1.0\n                        },\n                        {\n                            "name": "END"\n                        }\n                    ],\n                    "transitions": [\n                        {\n                            "from": "START",\n                            "to": "Idle",\n                            "time": 0,\n                            "priority": 0\n                        },\n                        {\n                            "from": "Idle",\n                            "to": "Walk",\n                            "time": 0.1,\n                            "priority": 0,\n                            "conditions": [\n                                {\n                                    "parameterName": "speed",\n                                    "predicate": pc.ANIM_GREATER_THAN,\n                                    "value": 0\n                                }\n                            ]\n                        },\n                        {\n                            "from": "ANY",\n                            "to": "Jump",\n                            "time": 0.1,\n                            "priority": 0,\n                            "conditions": [\n                                {\n                                    "parameterName": "jump",\n                                    "predicate": pc.ANIM_EQUAL_TO,\n                                    "value": true\n                                }\n                            ]\n                        },\n                        {\n                            "from": "Jump",\n                            "to": "Idle",\n                            "time": 0.2,\n                            "priority": 0,\n                            "exitTime": 0.8\n                        },\n                        {\n                            "from": "Jump",\n                            "to": "Walk",\n                            "time": 0.2,\n                            "priority": 0,\n                            "exitTime": 0.8\n                        },\n                        {\n                            "from": "Walk",\n                            "to": "Idle",\n                            "time": 0.1,\n                            "priority": 0,\n                            "conditions": [\n                                {\n                                    "parameterName": "speed",\n                                    "predicate": pc.ANIM_LESS_THAN_EQUAL_TO,\n                                    "value": 0\n                                }\n                            ]\n                        },\n                        {\n                            "from": "Walk",\n                            "to": "Jog",\n                            "time": 0.1,\n                            "priority": 0,\n                            "conditions": [\n                                {\n                                    "parameterName": "speed",\n                                    "predicate": pc.ANIM_GREATER_THAN,\n                                    "value": 1\n                                }\n                            ]\n                        },\n                        {\n                            "from": "Jog",\n                            "to": "Walk",\n                            "time": 0.1,\n                            "priority": 0,\n                            "conditions": [\n                                {\n                                    "parameterName": "speed",\n                                    "predicate": pc.ANIM_LESS_THAN,\n                                    "value": 2\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ],\n            "parameters": {\n                "speed": {\n                    "name": "speed",\n                    "type": pc.ANIM_PARAMETER_INTEGER,\n                    "value": 0\n                },\n                "jump": {\n                    "name": "jump",\n                    "type": pc.ANIM_PARAMETER_TRIGGER,\n                    "value": false\n                }\n            }\n        };\n\n        // load the state graph into the anim component\n        characterEntity.anim.loadStateGraph(animStateGraphData);\n\n        // assign the loaded animation assets to each of the states present in the state graph\n        const locomotionLayer = characterEntity.anim.baseLayer;\n        locomotionLayer.assignAnimation(\'Idle\', assets.idleAnim.resource.animations[0].resource);\n        locomotionLayer.assignAnimation(\'Walk\', assets.walkAnim.resource.animations[0].resource);\n        locomotionLayer.assignAnimation(\'Jog\', assets.jogAnim.resource.animations[0].resource);\n        locomotionLayer.assignAnimation(\'Jump\', assets.jumpAnim.resource.animations[0].resource);\n\n        app.root.addChild(characterEntity);\n\n        const planeEntity = new pc.Entity();\n        planeEntity.name = \'Plane\';\n        planeEntity.addComponent("render", {\n            type: "plane"\n        });\n        planeEntity.addComponent("collision", {\n            type: \'box\',\n            halfExtents: new pc.Vec3(7.5, 0, 7.5)\n        });\n        planeEntity.addComponent("rigidbody", {\n            type: \'static\'\n        });\n        planeEntity.setLocalScale(15, 1, 15);\n        planeEntity.setPosition(0, 0, 0);\n        const material = new pc.StandardMaterial();\n        material.diffuseMap = assets.playcanvasGreyTexture.resource;\n        material.update();\n        planeEntity.render.meshInstances[0].material = material;\n        app.root.addChild(planeEntity);\n\n        data.on(\'jump\', function () {\n            const isJumping = characterEntity.anim.baseLayer.activeState === \'Jump\';\n            if (!isJumping) {\n                characterEntity.anim.setTrigger(\'jump\');\n            }\n        });\n\n        // create a Locomotion script and initialize some variables\n        const Locomotion = pc.createScript(\'Locomotion\');\n\n        let characterDirection;\n        let targetPosition: pc.Vec3;\n\n        // initialize code called once per entity\n        Locomotion.prototype.initialize = function () {\n            characterDirection = new pc.Vec3(1, 0, 0);\n            targetPosition = new pc.Vec3(2, 0, 2);\n            document.addEventListener("mousedown", this.onMouseDown);\n        };\n\n        // @ts-ignore engine-tsd\n        Locomotion.prototype.onMouseDown = function (event: any) {\n            if (event.button !== 0) return;\n            // Set the character target position to a position on the plane that the user has clicked\n            const cameraEntity = app.root.findByName(\'Camera\') as pc.Entity;\n            const near = cameraEntity.camera.screenToWorld(event.x, event.y, cameraEntity.camera.nearClip);\n            const far = cameraEntity.camera.screenToWorld(event.x, event.y, cameraEntity.camera.farClip);\n            const result = app.systems.rigidbody.raycastFirst(far, near);\n            if (result) {\n                targetPosition = new pc.Vec3(result.point.x, 0, result.point.z);\n                characterEntity.anim.setInteger(\'speed\', data.get(\'jogToggle\') ? 2 : 1);\n            }\n        };\n\n        // defines how many units the character should move per second given its current animation state\n        function speedForState(state: any) {\n            switch (state) {\n                case \'Walk\':\n                    return 1.0;\n                case \'Jog\':\n                    return 4.0;\n                case \'Jump\':\n                case \'Idle\':\n                default:\n                    return 0.0;\n            }\n        }\n\n        const currentPosition = new pc.Vec3(0, 0, 0);\n\n        // update code called every frame\n        Locomotion.prototype.update = function (dt) {\n            if (characterEntity.anim.getInteger(\'speed\')) {\n                // Update position if target position is not the same as entity position. Base the movement speed on the current state\n                // Move the character along X & Z axis based on click target position & make character face click direction\n                let moveSpeed = speedForState(characterEntity.anim.baseLayer.activeState);\n                if (characterEntity.anim.baseLayer.transitioning) {\n                    const prevMoveSpeed = speedForState(characterEntity.anim.baseLayer.previousState);\n                    const progress = characterEntity.anim.baseLayer.transitionProgress;\n                    moveSpeed = (prevMoveSpeed * (1.0 - progress)) + (moveSpeed * progress);\n                }\n                const distance = targetPosition.clone().sub(currentPosition);\n                const direction = distance.clone().normalize();\n                characterDirection = new pc.Vec3().sub(direction);\n                const movement = direction.clone().mulScalar(dt * moveSpeed);\n                if (movement.length() < distance.length()) {\n                    currentPosition.add(movement);\n                    characterEntity.setPosition(currentPosition);\n                    characterEntity.lookAt(characterEntity.getPosition().clone().add(characterDirection));\n                } else {\n                    currentPosition.copy(targetPosition);\n                    characterEntity.setPosition(currentPosition);\n                    characterEntity.anim.setInteger(\'speed\', 0);\n                }\n            }\n\n        };\n\n        characterEntity.addComponent("script");\n        characterEntity.script.create(\'Locomotion\', {});\n    }\n}',javaScriptFunction:'function example(canvas, assets, data, wasmSupported, loadWasmModuleAsync) {\n    if (wasmSupported()) {\n        loadWasmModuleAsync(\n            "Ammo",\n            "/static/lib/ammo/ammo.wasm.js",\n            "/static/lib/ammo/ammo.wasm.wasm",\n            run\n        );\n    } else {\n        loadWasmModuleAsync("Ammo", "/static/lib/ammo/ammo.js", "", run);\n    }\n\n    function run() {\n        // Create the application and start the update loop\n        const app = new pc.Application(canvas, {});\n\n        // setup skydome\n        app.scene.skyboxMip = 2;\n        app.scene.skyboxIntensity = 0.7;\n        app.scene.setSkybox(assets.cubemap.resources);\n        app.scene.toneMapping = pc.TONEMAP_ACES;\n\n        // Create an Entity with a camera component\n        const cameraEntity = new pc.Entity();\n        cameraEntity.name = "Camera";\n        cameraEntity.addComponent("camera", {\n            clearColor: new pc.Color(0.1, 0.15, 0.2),\n        });\n\n        cameraEntity.translateLocal(0.5, 3, 8);\n        cameraEntity.rotateLocal(-30, 0, 0);\n        app.root.addChild(cameraEntity);\n\n        // Create an entity with a light component\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            type: "directional",\n            color: new pc.Color(1, 1, 1),\n            castShadows: true,\n            intensity: 2,\n            shadowBias: 0.2,\n            shadowDistance: 16,\n            normalOffsetBias: 0.05,\n            shadowResolution: 2048,\n        });\n\n        light.setLocalEulerAngles(60, 30, 0);\n        app.root.addChild(light);\n\n        app.start();\n\n        const characterEntity = new pc.Entity();\n\n        // create an entity from the loaded model using the render component\n        const renderEntity = assets.model.resource.instantiateRenderEntity({\n            castShadows: true,\n        });\n\n        // assign the renderEntity as the child of character entity. All transforms of the\n        // renderEntity and its children are driven by the anim component.\n        // The characterEntity transform will be controlled by the Locomotion script.\n        characterEntity.addChild(renderEntity);\n\n        // add an anim component to the entity\n        characterEntity.addComponent("anim", {\n            activate: true,\n        });\n\n        // create an anim state graph\n        const animStateGraphData = {\n            layers: [\n                {\n                    name: "locomotion",\n                    states: [\n                        {\n                            name: "START",\n                        },\n\n                        {\n                            name: "Idle",\n                            speed: 1.0,\n                        },\n\n                        {\n                            name: "Walk",\n                            speed: 1.0,\n                        },\n\n                        {\n                            name: "Jump",\n                            speed: 1,\n                        },\n\n                        {\n                            name: "Jog",\n                            speed: 1.0,\n                        },\n\n                        {\n                            name: "END",\n                        },\n                    ],\n\n                    transitions: [\n                        {\n                            from: "START",\n                            to: "Idle",\n                            time: 0,\n                            priority: 0,\n                        },\n\n                        {\n                            from: "Idle",\n                            to: "Walk",\n                            time: 0.1,\n                            priority: 0,\n                            conditions: [\n                                {\n                                    parameterName: "speed",\n                                    predicate: pc.ANIM_GREATER_THAN,\n                                    value: 0,\n                                },\n                            ],\n                        },\n\n                        {\n                            from: "ANY",\n                            to: "Jump",\n                            time: 0.1,\n                            priority: 0,\n                            conditions: [\n                                {\n                                    parameterName: "jump",\n                                    predicate: pc.ANIM_EQUAL_TO,\n                                    value: true,\n                                },\n                            ],\n                        },\n\n                        {\n                            from: "Jump",\n                            to: "Idle",\n                            time: 0.2,\n                            priority: 0,\n                            exitTime: 0.8,\n                        },\n\n                        {\n                            from: "Jump",\n                            to: "Walk",\n                            time: 0.2,\n                            priority: 0,\n                            exitTime: 0.8,\n                        },\n\n                        {\n                            from: "Walk",\n                            to: "Idle",\n                            time: 0.1,\n                            priority: 0,\n                            conditions: [\n                                {\n                                    parameterName: "speed",\n                                    predicate: pc.ANIM_LESS_THAN_EQUAL_TO,\n                                    value: 0,\n                                },\n                            ],\n                        },\n\n                        {\n                            from: "Walk",\n                            to: "Jog",\n                            time: 0.1,\n                            priority: 0,\n                            conditions: [\n                                {\n                                    parameterName: "speed",\n                                    predicate: pc.ANIM_GREATER_THAN,\n                                    value: 1,\n                                },\n                            ],\n                        },\n\n                        {\n                            from: "Jog",\n                            to: "Walk",\n                            time: 0.1,\n                            priority: 0,\n                            conditions: [\n                                {\n                                    parameterName: "speed",\n                                    predicate: pc.ANIM_LESS_THAN,\n                                    value: 2,\n                                },\n                            ],\n                        },\n                    ],\n                },\n            ],\n\n            parameters: {\n                speed: {\n                    name: "speed",\n                    type: pc.ANIM_PARAMETER_INTEGER,\n                    value: 0,\n                },\n\n                jump: {\n                    name: "jump",\n                    type: pc.ANIM_PARAMETER_TRIGGER,\n                    value: false,\n                },\n            },\n        };\n\n        // load the state graph into the anim component\n        characterEntity.anim.loadStateGraph(animStateGraphData);\n\n        // assign the loaded animation assets to each of the states present in the state graph\n        const locomotionLayer = characterEntity.anim.baseLayer;\n        locomotionLayer.assignAnimation(\n            "Idle",\n            assets.idleAnim.resource.animations[0].resource\n        );\n        locomotionLayer.assignAnimation(\n            "Walk",\n            assets.walkAnim.resource.animations[0].resource\n        );\n        locomotionLayer.assignAnimation(\n            "Jog",\n            assets.jogAnim.resource.animations[0].resource\n        );\n        locomotionLayer.assignAnimation(\n            "Jump",\n            assets.jumpAnim.resource.animations[0].resource\n        );\n\n        app.root.addChild(characterEntity);\n\n        const planeEntity = new pc.Entity();\n        planeEntity.name = "Plane";\n        planeEntity.addComponent("render", {\n            type: "plane",\n        });\n\n        planeEntity.addComponent("collision", {\n            type: "box",\n            halfExtents: new pc.Vec3(7.5, 0, 7.5),\n        });\n\n        planeEntity.addComponent("rigidbody", {\n            type: "static",\n        });\n\n        planeEntity.setLocalScale(15, 1, 15);\n        planeEntity.setPosition(0, 0, 0);\n        const material = new pc.StandardMaterial();\n        material.diffuseMap = assets.playcanvasGreyTexture.resource;\n        material.update();\n        planeEntity.render.meshInstances[0].material = material;\n        app.root.addChild(planeEntity);\n\n        data.on("jump", function () {\n            const isJumping =\n                characterEntity.anim.baseLayer.activeState === "Jump";\n            if (!isJumping) {\n                characterEntity.anim.setTrigger("jump");\n            }\n        });\n\n        // create a Locomotion script and initialize some variables\n        const Locomotion = pc.createScript("Locomotion");\n\n        let characterDirection;\n        let targetPosition;\n\n        // initialize code called once per entity\n        Locomotion.prototype.initialize = function () {\n            characterDirection = new pc.Vec3(1, 0, 0);\n            targetPosition = new pc.Vec3(2, 0, 2);\n            document.addEventListener("mousedown", this.onMouseDown);\n        };\n\n        // @ts-ignore engine-tsd\n        Locomotion.prototype.onMouseDown = function (event) {\n            if (event.button !== 0) return;\n            // Set the character target position to a position on the plane that the user has clicked\n            const cameraEntity = app.root.findByName("Camera");\n            const near = cameraEntity.camera.screenToWorld(\n                event.x,\n                event.y,\n                cameraEntity.camera.nearClip\n            );\n            const far = cameraEntity.camera.screenToWorld(\n                event.x,\n                event.y,\n                cameraEntity.camera.farClip\n            );\n            const result = app.systems.rigidbody.raycastFirst(far, near);\n            if (result) {\n                targetPosition = new pc.Vec3(result.point.x, 0, result.point.z);\n                characterEntity.anim.setInteger(\n                    "speed",\n                    data.get("jogToggle") ? 2 : 1\n                );\n            }\n        };\n\n        // defines how many units the character should move per second given its current animation state\n        function speedForState(state) {\n            switch (state) {\n                case "Walk":\n                    return 1.0;\n                case "Jog":\n                    return 4.0;\n                case "Jump":\n                case "Idle":\n                default:\n                    return 0.0;\n            }\n        }\n\n        const currentPosition = new pc.Vec3(0, 0, 0);\n\n        // update code called every frame\n        Locomotion.prototype.update = function (dt) {\n            if (characterEntity.anim.getInteger("speed")) {\n                // Update position if target position is not the same as entity position. Base the movement speed on the current state\n                // Move the character along X & Z axis based on click target position & make character face click direction\n                let moveSpeed = speedForState(\n                    characterEntity.anim.baseLayer.activeState\n                );\n                if (characterEntity.anim.baseLayer.transitioning) {\n                    const prevMoveSpeed = speedForState(\n                        characterEntity.anim.baseLayer.previousState\n                    );\n                    const progress =\n                        characterEntity.anim.baseLayer.transitionProgress;\n                    moveSpeed =\n                        prevMoveSpeed * (1.0 - progress) + moveSpeed * progress;\n                }\n                const distance = targetPosition.clone().sub(currentPosition);\n                const direction = distance.clone().normalize();\n                characterDirection = new pc.Vec3().sub(direction);\n                const movement = direction.clone().mulScalar(dt * moveSpeed);\n                if (movement.length() < distance.length()) {\n                    currentPosition.add(movement);\n                    characterEntity.setPosition(currentPosition);\n                    characterEntity.lookAt(\n                        characterEntity\n                            .getPosition()\n                            .clone()\n                            .add(characterDirection)\n                    );\n                } else {\n                    currentPosition.copy(targetPosition);\n                    characterEntity.setPosition(currentPosition);\n                    characterEntity.anim.setInteger("speed", 0);\n                }\n            }\n        };\n\n        characterEntity.addComponent("script");\n        characterEntity.script.create("Locomotion", {});\n    }\n}\n',nameSlug:"locomotion",categorySlug:"animation"},tween:{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: { font: pc.Asset, script: pc.Asset }): void {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Utility function to create a text element-based entity\n    const createText = function (fontAsset: pc.Asset, message: string, x: number, y: number, z: number, rot: number) {\n        const text = new pc.Entity();\n        text.addComponent(\"element\", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            fontAsset: fontAsset,\n            fontSize: 0.5,\n            pivot: [1, 0.5],\n            text: message,\n            type: pc.ELEMENTTYPE_TEXT\n        });\n        text.setLocalPosition(x, y, z);\n        text.setLocalEulerAngles(0, 0, rot);\n        app.root.addChild(text);\n    };\n\n    const easingFunctions = [\n        'Linear',\n        'Quadratic',\n        'Cubic',\n        'Quartic',\n        'Quintic',\n        'Sinusoidal',\n        'Exponential',\n        'Circular',\n        'Elastic',\n        'Back',\n        'Bounce'\n    ];\n    const points: Array<pc.Vec3> = [];\n    const colors: Array<pc.Color> = [];\n\n    for (let i = 0; i < easingFunctions.length; i++) {\n        // Create an entity with a sphere render component\n        const sphere = new pc.Entity();\n\n        sphere.addComponent(\"render\", {\n            type: \"sphere\"\n        });\n        const material = sphere.render.material as pc.StandardMaterial;\n        material.diffuse.set(1, 0, 0);\n        material.specular.set(0.6, 0.6, 0.6);\n        material.shininess = 20;\n\n        sphere.addComponent(\"script\");\n        sphere.script.create(\"tween\", {\n            attributes: {\n                tweens: [{\n                    autoPlay: true, // Start this tween immediately\n                    delay: 0, // No delay on start\n                    duration: 1500, // 2 seconds\n                    easingFunction: i,\n                    easingType: 2, // InOut type\n                    end: new pc.Vec4(4, -i, 0, 0),\n                    path: 'localPosition', // Update the entity's local position\n                    repeat: -1, // Repeat infinitely\n                    repeatDelay: 0, // No delay between repeats\n                    start: new pc.Vec4(0, -i, 0, 0),\n                    yoyo: true // Ping pong between start and end values\n                }]\n            }\n        });\n\n        sphere.setLocalScale(0.8, 0.8, 0.8);\n        app.root.addChild(sphere);\n\n        // Add a line for the path of the sphere\n        points.push(new pc.Vec3(0, -i, 0), new pc.Vec3(4, -i, 0));\n        colors.push(pc.Color.WHITE, pc.Color.WHITE);\n\n        // Create a text label for the sphere\n        createText(assets.font, easingFunctions[i], -0.5, -i, 0, 0);\n    }\n\n    // Create an entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent(\"light\", {\n        type: \"directional\"\n    });\n    light.setLocalEulerAngles(70, 30, 0);\n    app.root.addChild(light);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.translate(0.65, -5.5, 20);\n    app.root.addChild(camera);\n\n    app.on('update', function () {\n        app.drawLines(points, colors);\n    });\n}",javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Utility function to create a text element-based entity\n    const createText = function (fontAsset, message, x, y, z, rot) {\n        const text = new pc.Entity();\n        text.addComponent("element", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            fontAsset: fontAsset,\n            fontSize: 0.5,\n            pivot: [1, 0.5],\n            text: message,\n            type: pc.ELEMENTTYPE_TEXT,\n        });\n\n        text.setLocalPosition(x, y, z);\n        text.setLocalEulerAngles(0, 0, rot);\n        app.root.addChild(text);\n    };\n\n    const easingFunctions = [\n        "Linear",\n        "Quadratic",\n        "Cubic",\n        "Quartic",\n        "Quintic",\n        "Sinusoidal",\n        "Exponential",\n        "Circular",\n        "Elastic",\n        "Back",\n        "Bounce",\n    ];\n\n    const points = [];\n    const colors = [];\n\n    for (let i = 0; i < easingFunctions.length; i++) {\n        // Create an entity with a sphere render component\n        const sphere = new pc.Entity();\n\n        sphere.addComponent("render", {\n            type: "sphere",\n        });\n\n        const material = sphere.render.material;\n        material.diffuse.set(1, 0, 0);\n        material.specular.set(0.6, 0.6, 0.6);\n        material.shininess = 20;\n\n        sphere.addComponent("script");\n        sphere.script.create("tween", {\n            attributes: {\n                tweens: [\n                    {\n                        autoPlay: true, // Start this tween immediately\n                        delay: 0, // No delay on start\n                        duration: 1500, // 2 seconds\n                        easingFunction: i,\n                        easingType: 2, // InOut type\n                        end: new pc.Vec4(4, -i, 0, 0),\n                        path: "localPosition", // Update the entity\'s local position\n                        repeat: -1, // Repeat infinitely\n                        repeatDelay: 0, // No delay between repeats\n                        start: new pc.Vec4(0, -i, 0, 0),\n                        yoyo: true, // Ping pong between start and end values\n                    },\n                ],\n            },\n        });\n\n        sphere.setLocalScale(0.8, 0.8, 0.8);\n        app.root.addChild(sphere);\n\n        // Add a line for the path of the sphere\n        points.push(new pc.Vec3(0, -i, 0), new pc.Vec3(4, -i, 0));\n        colors.push(pc.Color.WHITE, pc.Color.WHITE);\n\n        // Create a text label for the sphere\n        createText(assets.font, easingFunctions[i], -0.5, -i, 0, 0);\n    }\n\n    // Create an entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n    });\n\n    light.setLocalEulerAngles(70, 30, 0);\n    app.root.addChild(light);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.translate(0.65, -5.5, 20);\n    app.root.addChild(camera);\n\n    app.on("update", function () {\n        app.drawLines(points, colors);\n    });\n}\n',nameSlug:"tween",categorySlug:"animation"}},camera:{"first-person":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { statue: pc.Asset, script: pc.Asset }, wasmSupported: any, loadWasmModuleAsync: any): void {\n\n    if (wasmSupported()) {\n        loadWasmModuleAsync(\'Ammo\', \'/static/lib/ammo/ammo.wasm.js\', \'/static/lib/ammo/ammo.wasm.wasm\', run);\n    } else {\n        loadWasmModuleAsync(\'Ammo\', \'/static/lib/ammo/ammo.js\', \'\', run);\n    }\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        gamepads: new pc.GamePads(),\n        keyboard: new pc.Keyboard(window)\n    });\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n    function run() {\n        app.start();\n\n        // Create a physical floor\n        const floor = new pc.Entity();\n        floor.addComponent("collision", {\n            type: "box",\n            halfExtents: new pc.Vec3(100, 0.5, 100)\n        });\n        floor.addComponent("rigidbody", {\n            type: "static",\n            restitution: 0.5\n        });\n        floor.setLocalPosition(0, -0.5, 0);\n        app.root.addChild(floor);\n\n        const floorModel = new pc.Entity();\n        floorModel.addComponent("model", {\n            type: "plane"\n        });\n        floorModel.setLocalPosition(0, 0.5, 0);\n        floorModel.setLocalScale(200, 1, 200);\n        floor.addChild(floorModel);\n\n        // Create a model entity and assign the statue model\n        const model = assets.statue.resource.instantiateRenderEntity({\n            castShadows: true\n        });\n        model.addComponent("collision", {\n            type: "mesh",\n            asset: assets.statue.resource.model\n        });\n        model.addComponent("rigidbody", {\n            type: "static",\n            restitution: 0.5\n        });\n        app.root.addChild(model);\n\n        // Create a camera that will be driven by the character controller\n        const camera = new pc.Entity();\n        camera.addComponent("camera", {\n            clearColor: new pc.Color(0.4, 0.45, 0.5),\n            farClip: 100,\n            fov: 65,\n            nearClip: 0.1\n        });\n        camera.setLocalPosition(0, 1, 0);\n\n        // Create a physical character controller\n        const characterController = new pc.Entity();\n        characterController.addComponent("collision", {\n            axis: 0,\n            height: 2,\n            radius: 0.5,\n            type: "capsule"\n        });\n        characterController.addComponent("rigidbody", {\n            angularDamping: 0,\n            angularFactor: pc.Vec3.ZERO,\n            friction: 0.3,\n            linearDamping: 0,\n            linearFactor: pc.Vec3.ONE,\n            mass: 80,\n            restitution: 0,\n            type: "dynamic"\n        });\n        characterController.addComponent("script");\n        characterController.script.create("characterController");\n        characterController.script.create("firstPersonCamera", {\n            attributes: {\n                camera: camera\n            }\n        });\n        characterController.script.create("gamePadInput");\n        characterController.script.create("keyboardInput");\n        characterController.script.create("mouseInput");\n        characterController.script.create("touchInput");\n        characterController.setLocalPosition(0, 1, 10);\n\n        // Add the character controller and camera to the hierarchy\n        app.root.addChild(characterController);\n        characterController.addChild(camera);\n\n        // Create a directional light\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            castShadows: true,\n            color: new pc.Color(1, 1, 1),\n            normalOffsetBias: 0.05,\n            shadowBias: 0.2,\n            shadowDistance: 40,\n            type: "directional",\n            shadowResolution: 2048\n        });\n        app.root.addChild(light);\n        light.setLocalEulerAngles(45, 30, 0);\n    }\n}',javaScriptFunction:'function example(canvas, assets, wasmSupported, loadWasmModuleAsync) {\n    if (wasmSupported()) {\n        loadWasmModuleAsync(\n            "Ammo",\n            "/static/lib/ammo/ammo.wasm.js",\n            "/static/lib/ammo/ammo.wasm.wasm",\n            run\n        );\n    } else {\n        loadWasmModuleAsync("Ammo", "/static/lib/ammo/ammo.js", "", run);\n    }\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        gamepads: new pc.GamePads(),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n    function run() {\n        app.start();\n\n        // Create a physical floor\n        const floor = new pc.Entity();\n        floor.addComponent("collision", {\n            type: "box",\n            halfExtents: new pc.Vec3(100, 0.5, 100),\n        });\n\n        floor.addComponent("rigidbody", {\n            type: "static",\n            restitution: 0.5,\n        });\n\n        floor.setLocalPosition(0, -0.5, 0);\n        app.root.addChild(floor);\n\n        const floorModel = new pc.Entity();\n        floorModel.addComponent("model", {\n            type: "plane",\n        });\n\n        floorModel.setLocalPosition(0, 0.5, 0);\n        floorModel.setLocalScale(200, 1, 200);\n        floor.addChild(floorModel);\n\n        // Create a model entity and assign the statue model\n        const model = assets.statue.resource.instantiateRenderEntity({\n            castShadows: true,\n        });\n\n        model.addComponent("collision", {\n            type: "mesh",\n            asset: assets.statue.resource.model,\n        });\n\n        model.addComponent("rigidbody", {\n            type: "static",\n            restitution: 0.5,\n        });\n\n        app.root.addChild(model);\n\n        // Create a camera that will be driven by the character controller\n        const camera = new pc.Entity();\n        camera.addComponent("camera", {\n            clearColor: new pc.Color(0.4, 0.45, 0.5),\n            farClip: 100,\n            fov: 65,\n            nearClip: 0.1,\n        });\n\n        camera.setLocalPosition(0, 1, 0);\n\n        // Create a physical character controller\n        const characterController = new pc.Entity();\n        characterController.addComponent("collision", {\n            axis: 0,\n            height: 2,\n            radius: 0.5,\n            type: "capsule",\n        });\n\n        characterController.addComponent("rigidbody", {\n            angularDamping: 0,\n            angularFactor: pc.Vec3.ZERO,\n            friction: 0.3,\n            linearDamping: 0,\n            linearFactor: pc.Vec3.ONE,\n            mass: 80,\n            restitution: 0,\n            type: "dynamic",\n        });\n\n        characterController.addComponent("script");\n        characterController.script.create("characterController");\n        characterController.script.create("firstPersonCamera", {\n            attributes: {\n                camera: camera,\n            },\n        });\n\n        characterController.script.create("gamePadInput");\n        characterController.script.create("keyboardInput");\n        characterController.script.create("mouseInput");\n        characterController.script.create("touchInput");\n        characterController.setLocalPosition(0, 1, 10);\n\n        // Add the character controller and camera to the hierarchy\n        app.root.addChild(characterController);\n        characterController.addChild(camera);\n\n        // Create a directional light\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            castShadows: true,\n            color: new pc.Color(1, 1, 1),\n            normalOffsetBias: 0.05,\n            shadowBias: 0.2,\n            shadowDistance: 40,\n            type: "directional",\n            shadowResolution: 2048,\n        });\n\n        app.root.addChild(light);\n        light.setLocalEulerAngles(45, 30, 0);\n    }\n}\n',nameSlug:"first-person",categorySlug:"camera"},fly:{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        keyboard: new pc.Keyboard(window)\n    });\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    app.start();\n\n    // ***********    Helper functions    *******************\n\n    function createMaterial(color: pc.Color) {\n        const material = new pc.StandardMaterial();\n        material.diffuse = color;\n        // we need to call material.update when we change its properties\n        material.update();\n        return material;\n    }\n\n    function createBox(position: pc.Vec3, size: pc.Vec3, material: pc.Material) {\n        // create an entity and add a model component of type \'box\'\n        const box = new pc.Entity();\n        box.addComponent("render", {\n            type: "box",\n            material: material\n        });\n\n        // move the box\n        box.setLocalPosition(position);\n        box.setLocalScale(size);\n\n        // add the box to the hierarchy\n        app.root.addChild(box);\n    }\n\n    // ***********    Create Boxes    *******************\n\n    // create a few boxes in our scene\n    const red = createMaterial(pc.Color.RED);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 2; j++) {\n            createBox(new pc.Vec3(i * 2, 0, j * 4), pc.Vec3.ONE, red);\n        }\n    }\n\n    // create a floor\n    const white = createMaterial(pc.Color.WHITE);\n    createBox(new pc.Vec3(0, -0.5, 0), new pc.Vec3(10, 0.1, 10), white);\n\n    // ***********    Create lights   *******************\n\n    // make our scene prettier by adding a directional light\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100\n    });\n    light.setLocalPosition(0, 0, 2);\n\n    // add the light to the hierarchy\n    app.root.addChild(light);\n\n    // ***********    Create camera    *******************\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.5, 0.5, 0.8),\n        nearClip: 0.3,\n        farClip: 30\n    });\n\n    // add the fly camera script to the camera\n    camera.addComponent("script");\n    camera.script.create("flyCamera");\n\n    // add the camera to the hierarchy\n    app.root.addChild(camera);\n\n    // Move the camera a little further away\n    camera.translate(2, 0.8, 9);\n}',javaScriptFunction:'function example(canvas) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    app.start();\n\n    // ***********    Helper functions    *******************\n\n    function createMaterial(color) {\n        const material = new pc.StandardMaterial();\n        material.diffuse = color;\n        // we need to call material.update when we change its properties\n        material.update();\n        return material;\n    }\n\n    function createBox(position, size, material) {\n        // create an entity and add a model component of type \'box\'\n        const box = new pc.Entity();\n        box.addComponent("render", {\n            type: "box",\n            material: material,\n        });\n\n        // move the box\n        box.setLocalPosition(position);\n        box.setLocalScale(size);\n\n        // add the box to the hierarchy\n        app.root.addChild(box);\n    }\n\n    // ***********    Create Boxes    *******************\n\n    // create a few boxes in our scene\n    const red = createMaterial(pc.Color.RED);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 2; j++) {\n            createBox(new pc.Vec3(i * 2, 0, j * 4), pc.Vec3.ONE, red);\n        }\n    }\n\n    // create a floor\n    const white = createMaterial(pc.Color.WHITE);\n    createBox(new pc.Vec3(0, -0.5, 0), new pc.Vec3(10, 0.1, 10), white);\n\n    // ***********    Create lights   *******************\n\n    // make our scene prettier by adding a directional light\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100,\n    });\n\n    light.setLocalPosition(0, 0, 2);\n\n    // add the light to the hierarchy\n    app.root.addChild(light);\n\n    // ***********    Create camera    *******************\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.5, 0.5, 0.8),\n        nearClip: 0.3,\n        farClip: 30,\n    });\n\n    // add the fly camera script to the camera\n    camera.addComponent("script");\n    camera.script.create("flyCamera");\n\n    // add the camera to the hierarchy\n    app.root.addChild(camera);\n\n    // Move the camera a little further away\n    camera.translate(2, 0.8, 9);\n}\n',nameSlug:"fly",categorySlug:"camera"},orbit:{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { statue: pc.Asset, script: pc.Asset }): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body)\n    });\n\n    // Create an entity hierarchy representing the statue\n    const statueEntity = assets.statue.resource.instantiateRenderEntity();\n    statueEntity.setLocalScale(0.07, 0.07, 0.07);\n    statueEntity.setLocalPosition(0, -0.5, 0);\n    app.root.addChild(statueEntity);\n\n    // Create a camera with an orbit camera script\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2 // Override default of 0 (no inertia)\n        }\n    });\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // Create a directional light\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional"\n    });\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 30, 0);\n\n    app.start();\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n    });\n\n    // Create an entity hierarchy representing the statue\n    const statueEntity = assets.statue.resource.instantiateRenderEntity();\n    statueEntity.setLocalScale(0.07, 0.07, 0.07);\n    statueEntity.setLocalPosition(0, -0.5, 0);\n    app.root.addChild(statueEntity);\n\n    // Create a camera with an orbit camera script\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2, // Override default of 0 (no inertia)\n        },\n    });\n\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // Create a directional light\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n    });\n\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 30, 0);\n\n    app.start();\n}\n',nameSlug:"orbit",categorySlug:"camera"}},graphics:{"area-lights":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // helper function to create a primitive with shape type, position, scale, color\n    function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3, color: pc.Color, assetManifest: any) {\n\n        // create material of specified color\n        const material = new pc.StandardMaterial();\n        material.diffuse = color;\n        material.shininess = 80;\n        material.useMetalness = true;\n\n        if (assetManifest) {\n            material.diffuseMap = assetManifest.color.resource;\n            material.normalMap = assetManifest.normal.resource;\n            material.glossMap = assetManifest.gloss.resource;\n            material.metalness = 0.7;\n\n            material.diffuseMapTiling.set(7, 7);\n            material.normalMapTiling.set(7, 7);\n            material.glossMapTiling.set(7, 7);\n        }\n\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent(\'render\', {\n            type: primitiveType,\n            material: material\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // helper function to create area light including its visual representation in the world\n    function createAreaLight(type: string, shape: number, position: pc.Vec3, scale: number, color: pc.Color, intensity: number, shadows: boolean, range: number) {\n        const lightParent = new pc.Entity();\n        lightParent.translate(position);\n        app.root.addChild(lightParent);\n\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            type: type,\n            shape: shape,\n            color: color,\n            intensity: intensity,\n            falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED,\n            range: range,\n            castShadows: shadows,\n            innerConeAngle: 80,\n            outerConeAngle: 85,\n            shadowBias: 0.1,\n            normalOffsetBias: 0.1,\n            shadowResolution: 2048\n        });\n\n        light.setLocalScale(scale, scale, scale);\n        lightParent.addChild(light);\n\n        // emissive material that is the light source color\n        const brightMaterial = new pc.StandardMaterial();\n        brightMaterial.emissive = color;\n        brightMaterial.useLighting = false;\n        brightMaterial.cull = (shape === pc.LIGHTSHAPE_RECT) ? pc.CULLFACE_NONE : pc.CULLFACE_BACK;\n        brightMaterial.update();\n\n        const brightShape = new pc.Entity();\n        // primitive shape that matches light source shape\n        brightShape.addComponent("render", {\n            type: (shape === pc.LIGHTSHAPE_SPHERE) ? "sphere" : (shape === pc.LIGHTSHAPE_DISK) ? "cone" : "plane",\n            material: brightMaterial,\n            castShadows: type !== "directional"\n        });\n        brightShape.setLocalScale(((type === "directional") ? scale * range : scale), (shape === pc.LIGHTSHAPE_DISK) ? 0.001 : ((type === "directional") ? scale * range : scale), ((type === "directional") ? scale * range : scale));\n        lightParent.addChild(brightShape);\n\n        // add black primitive shape if not omni-directional or global directional\n        if (type === "spot") {\n            // black material\n            const blackMaterial = new pc.StandardMaterial();\n            blackMaterial.diffuse = new pc.Color(0, 0, 0);\n            blackMaterial.useLighting = false;\n            blackMaterial.cull = (shape === pc.LIGHTSHAPE_RECT) ? pc.CULLFACE_NONE : pc.CULLFACE_BACK;\n            blackMaterial.update();\n\n            const blackShape = new pc.Entity();\n            blackShape.addComponent("render", {\n                type: (shape === pc.LIGHTSHAPE_SPHERE) ? "sphere" : (shape === pc.LIGHTSHAPE_DISK) ? "cone" : "plane",\n                material: blackMaterial\n            });\n            blackShape.setLocalPosition(0, 0.01 / scale, 0);\n            blackShape.setLocalEulerAngles(-180, 0, 0);\n            brightShape.addChild(blackShape);\n        }\n\n        return lightParent;\n    }\n\n    const far = 5000.0;\n\n    app.start();\n\n    // set the loaded area light LUT data\n    app.setAreaLightLuts(assets.luts);\n\n    // set up some general scene rendering properties\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // setup skydome\n    app.scene.skyboxMip = 1;            // use top mipmap level of cubemap (full resolution)\n    app.scene.skyboxIntensity = 0.4;    // make it darker\n\n    // set skybox - this DDS file was \'prefiltered\' in the PlayCanvas Editor and then downloaded.\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n\n    // create ground plane\n    createPrimitive("plane", new pc.Vec3(0, 0, 0), new pc.Vec3(20, 20, 20), new pc.Color(0.3, 0.3, 0.3), assets);\n\n    // get the instance of the statue and set up with render component\n    const statue = assets.statue.resource.instantiateRenderEntity();\n    statue.setLocalScale(0.4, 0.4, 0.4);\n    app.root.addChild(statue);\n\n    // Create the camera, which renders entities\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2),\n        fov: 60,\n        farClip: 100000\n    });\n    app.root.addChild(camera);\n    camera.setLocalPosition(0, 2.5, 12);\n    camera.lookAt(0, 0, 0);\n\n    // Create lights with light source shape\n    const light1 = createAreaLight("spot", pc.LIGHTSHAPE_RECT, new pc.Vec3(-3, 4, 0), 4, new pc.Color(1, 1, 1), 2, true, 10);\n    const light2 = createAreaLight("omni", pc.LIGHTSHAPE_SPHERE, new pc.Vec3(5, 2, -2), 2, new pc.Color(1, 1, 0), 2, false, 10);\n    const light3 = createAreaLight("directional", pc.LIGHTSHAPE_DISK, new pc.Vec3(0, 0, 0), 0.2, new pc.Color(0.7, 0.7, 1), 10, true, far);\n\n    // update things each frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        const factor1 = (Math.sin(time) + 1) * 0.5;\n        const factor2 = (Math.sin(time * 0.6) + 1) * 0.5;\n        const factor3 = (Math.sin(time * 0.4) + 1) * 0.5;\n\n        if (light1) {\n            light1.setLocalEulerAngles(pc.math.lerp(-90, 110, factor1), 0, 90);\n            light1.setLocalPosition(-4, pc.math.lerp(2, 4, factor3), pc.math.lerp(-2, 2, factor2));\n        }\n\n        if (light2) {\n            light2.setLocalPosition(5, pc.math.lerp(1, 3, factor1), pc.math.lerp(-2, 2, factor2));\n        }\n\n        if (light3) {\n            light3.setLocalEulerAngles(pc.math.lerp(230, 310, factor2), pc.math.lerp(-30, 0, factor3), 90);\n\n            const dir = light3.getWorldTransform().getY();\n            const campos = camera.getPosition();\n\n            light3.setPosition(campos.x + dir.x * far, campos.y + dir.y * far, campos.z + dir.z * far);\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // helper function to create a primitive with shape type, position, scale, color\n    function createPrimitive(\n        primitiveType,\n        position,\n        scale,\n        color,\n        assetManifest\n    ) {\n        // create material of specified color\n        const material = new pc.StandardMaterial();\n        material.diffuse = color;\n        material.shininess = 80;\n        material.useMetalness = true;\n\n        if (assetManifest) {\n            material.diffuseMap = assetManifest.color.resource;\n            material.normalMap = assetManifest.normal.resource;\n            material.glossMap = assetManifest.gloss.resource;\n            material.metalness = 0.7;\n\n            material.diffuseMapTiling.set(7, 7);\n            material.normalMapTiling.set(7, 7);\n            material.glossMapTiling.set(7, 7);\n        }\n\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent("render", {\n            type: primitiveType,\n            material: material,\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // helper function to create area light including its visual representation in the world\n    function createAreaLight(\n        type,\n        shape,\n        position,\n        scale,\n        color,\n        intensity,\n        shadows,\n        range\n    ) {\n        const lightParent = new pc.Entity();\n        lightParent.translate(position);\n        app.root.addChild(lightParent);\n\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            type: type,\n            shape: shape,\n            color: color,\n            intensity: intensity,\n            falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED,\n            range: range,\n            castShadows: shadows,\n            innerConeAngle: 80,\n            outerConeAngle: 85,\n            shadowBias: 0.1,\n            normalOffsetBias: 0.1,\n            shadowResolution: 2048,\n        });\n\n        light.setLocalScale(scale, scale, scale);\n        lightParent.addChild(light);\n\n        // emissive material that is the light source color\n        const brightMaterial = new pc.StandardMaterial();\n        brightMaterial.emissive = color;\n        brightMaterial.useLighting = false;\n        brightMaterial.cull =\n            shape === pc.LIGHTSHAPE_RECT ? pc.CULLFACE_NONE : pc.CULLFACE_BACK;\n        brightMaterial.update();\n\n        const brightShape = new pc.Entity();\n        // primitive shape that matches light source shape\n        brightShape.addComponent("render", {\n            type:\n                shape === pc.LIGHTSHAPE_SPHERE\n                    ? "sphere"\n                    : shape === pc.LIGHTSHAPE_DISK\n                    ? "cone"\n                    : "plane",\n            material: brightMaterial,\n            castShadows: type !== "directional",\n        });\n\n        brightShape.setLocalScale(\n            type === "directional" ? scale * range : scale,\n            shape === pc.LIGHTSHAPE_DISK\n                ? 0.001\n                : type === "directional"\n                ? scale * range\n                : scale,\n            type === "directional" ? scale * range : scale\n        );\n        lightParent.addChild(brightShape);\n\n        // add black primitive shape if not omni-directional or global directional\n        if (type === "spot") {\n            // black material\n            const blackMaterial = new pc.StandardMaterial();\n            blackMaterial.diffuse = new pc.Color(0, 0, 0);\n            blackMaterial.useLighting = false;\n            blackMaterial.cull =\n                shape === pc.LIGHTSHAPE_RECT\n                    ? pc.CULLFACE_NONE\n                    : pc.CULLFACE_BACK;\n            blackMaterial.update();\n\n            const blackShape = new pc.Entity();\n            blackShape.addComponent("render", {\n                type:\n                    shape === pc.LIGHTSHAPE_SPHERE\n                        ? "sphere"\n                        : shape === pc.LIGHTSHAPE_DISK\n                        ? "cone"\n                        : "plane",\n                material: blackMaterial,\n            });\n\n            blackShape.setLocalPosition(0, 0.01 / scale, 0);\n            blackShape.setLocalEulerAngles(-180, 0, 0);\n            brightShape.addChild(blackShape);\n        }\n\n        return lightParent;\n    }\n\n    const far = 5000.0;\n\n    app.start();\n\n    // set the loaded area light LUT data\n    app.setAreaLightLuts(assets.luts);\n\n    // set up some general scene rendering properties\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // setup skydome\n    app.scene.skyboxMip = 1; // use top mipmap level of cubemap (full resolution)\n    app.scene.skyboxIntensity = 0.4; // make it darker\n\n    // set skybox - this DDS file was \'prefiltered\' in the PlayCanvas Editor and then downloaded.\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    // create ground plane\n    createPrimitive(\n        "plane",\n        new pc.Vec3(0, 0, 0),\n        new pc.Vec3(20, 20, 20),\n        new pc.Color(0.3, 0.3, 0.3),\n        assets\n    );\n\n    // get the instance of the statue and set up with render component\n    const statue = assets.statue.resource.instantiateRenderEntity();\n    statue.setLocalScale(0.4, 0.4, 0.4);\n    app.root.addChild(statue);\n\n    // Create the camera, which renders entities\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2),\n        fov: 60,\n        farClip: 100000,\n    });\n\n    app.root.addChild(camera);\n    camera.setLocalPosition(0, 2.5, 12);\n    camera.lookAt(0, 0, 0);\n\n    // Create lights with light source shape\n    const light1 = createAreaLight(\n        "spot",\n        pc.LIGHTSHAPE_RECT,\n        new pc.Vec3(-3, 4, 0),\n        4,\n        new pc.Color(1, 1, 1),\n        2,\n        true,\n        10\n    );\n    const light2 = createAreaLight(\n        "omni",\n        pc.LIGHTSHAPE_SPHERE,\n        new pc.Vec3(5, 2, -2),\n        2,\n        new pc.Color(1, 1, 0),\n        2,\n        false,\n        10\n    );\n    const light3 = createAreaLight(\n        "directional",\n        pc.LIGHTSHAPE_DISK,\n        new pc.Vec3(0, 0, 0),\n        0.2,\n        new pc.Color(0.7, 0.7, 1),\n        10,\n        true,\n        far\n    );\n\n    // update things each frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        const factor1 = (Math.sin(time) + 1) * 0.5;\n        const factor2 = (Math.sin(time * 0.6) + 1) * 0.5;\n        const factor3 = (Math.sin(time * 0.4) + 1) * 0.5;\n\n        if (light1) {\n            light1.setLocalEulerAngles(pc.math.lerp(-90, 110, factor1), 0, 90);\n            light1.setLocalPosition(\n                -4,\n                pc.math.lerp(2, 4, factor3),\n                pc.math.lerp(-2, 2, factor2)\n            );\n        }\n\n        if (light2) {\n            light2.setLocalPosition(\n                5,\n                pc.math.lerp(1, 3, factor1),\n                pc.math.lerp(-2, 2, factor2)\n            );\n        }\n\n        if (light3) {\n            light3.setLocalEulerAngles(\n                pc.math.lerp(230, 310, factor2),\n                pc.math.lerp(-30, 0, factor3),\n                90\n            );\n\n            const dir = light3.getWorldTransform().getY();\n            const campos = camera.getPosition();\n\n            light3.setPosition(\n                campos.x + dir.x * far,\n                campos.y + dir.y * far,\n                campos.z + dir.z * far\n            );\n        }\n    });\n}\n',nameSlug:"area-lights",categorySlug:"graphics"},"area-picker":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { bloom : pc.Asset, \'helipad.dds\': pc.Asset}): void {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // setup skydome\n    app.scene.skyboxMip = 2;\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n    app.scene.skyboxIntensity = 0.1;\n\n    // use a quarter resolution for picker render target (faster but less precise - can miss small objects)\n    const pickerScale = 0.25;\n    let mouseX = 0, mouseY = 0;\n\n    // generate a box area with specified size of random primitives\n    const size = 30;\n    const halfSize = size * 0.5;\n    for (let i = 0; i < 300; i++) {\n        const shape = Math.random() < 0.5 ? "cylinder" : "sphere";\n        const position = new pc.Vec3(Math.random() * size - halfSize, Math.random() * size - halfSize, Math.random() * size - halfSize);\n        const scale = 1 + Math.random();\n        const entity = createPrimitive(shape, position, new pc.Vec3(scale, scale, scale));\n        app.root.addChild(entity);\n    }\n\n    // handle mouse move event and store current mouse position to use as a position to pick from the scene\n    new pc.Mouse(document.body).on(pc.EVENT_MOUSEMOVE, function (event) {\n        mouseX = event.x;\n        mouseY = event.y;\n    }, this);\n\n    // Create an instance of the picker class\n    // Lets use quarter of the resolution to improve performance - this will miss very small objects, but it\'s ok in our case\n    const picker = new pc.Picker(app, canvas.clientWidth * pickerScale, canvas.clientHeight * pickerScale);\n\n    // helper function to create a primitive with shape type, position, scale\n    function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3) {\n        // create material of random color\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(Math.random(), Math.random(), Math.random());\n        material.shininess = 60;\n        material.metalness = 0.4;\n        material.useMetalness = true;\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent(\'render\', {\n            type: primitiveType,\n            material: material\n        });\n\n        // set position and scale\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n\n        return primitive;\n    }\n\n    // Create main camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n\n    // add bloom postprocessing (this is ignored by the picker)\n    camera.addComponent("script");\n    camera.script.create("bloom", {\n        attributes: {\n            bloomIntensity: 1,\n            bloomThreshold: 0.7,\n            blurAmount: 4\n        }\n    });\n    app.root.addChild(camera);\n\n    // function to draw a 2D rectangle in the screen space coordinates\n    function drawRectangle(x: number, y: number, w: number, h: number) {\n\n        const pink = new pc.Color(1, 0.02, 0.58);\n\n        // transform 4 2D screen points into world space\n        const pt0 = camera.camera.screenToWorld(x, y, 1);\n        const pt1 = camera.camera.screenToWorld(x + w, y, 1);\n        const pt2 = camera.camera.screenToWorld(x + w, y + h, 1);\n        const pt3 = camera.camera.screenToWorld(x, y + h, 1);\n\n        // and connect them using white lines\n        const points = [pt0, pt1,  pt1, pt2,  pt2, pt3,  pt3, pt0];\n        const colors = [pink, pink, pink, pink, pink, pink, pink, pink];\n        app.drawLines(points, colors);\n    }\n\n    // sets material emissive color to specified color\n    function highlightMaterial(material: pc.StandardMaterial, color: pc.Color) {\n        material.emissive = color;\n        material.update();\n    }\n\n    // array of highlighted materials\n    const highlights: pc.StandardMaterial[] = [];\n\n    // update each frame\n    let time = 0;\n    app.on("update", function (dt) {\n\n        time += dt * 0.1;\n\n        // orbit the camera around\n        if (!camera) {\n            return;\n        }\n\n        camera.setLocalPosition(40 * Math.sin(time), 0, 40 * Math.cos(time));\n        camera.lookAt(pc.Vec3.ZERO);\n\n        // turn all previously highlighted meshes to black at the start of the frame\n        for (let h = 0; h < highlights.length; h++) {\n            highlightMaterial(highlights[h], pc.Color.BLACK);\n        }\n        highlights.length = 0;\n\n        // Make sure the picker is the right size, and prepare it, which renders meshes into its render target\n        if (picker) {\n            picker.resize(canvas.clientWidth * pickerScale, canvas.clientHeight * pickerScale);\n            picker.prepare(camera.camera, app.scene);\n        }\n\n        // areas we want to sample - two larger rectangles, one small square, and one pixel at a mouse position\n        // assign them different highlight colors as well\n        const areas = [\n            {\n                pos: new pc.Vec2(canvas.clientWidth * 0.3, canvas.clientHeight * 0.3),\n                size: new pc.Vec2(100, 200),\n                color: pc.Color.YELLOW\n            },\n            {\n                pos: new pc.Vec2(canvas.clientWidth * 0.6, canvas.clientHeight * 0.7),\n                size: new pc.Vec2(200, 20),\n                color: pc.Color.CYAN\n            },\n            {\n                pos: new pc.Vec2(canvas.clientWidth * 0.8, canvas.clientHeight * 0.3),\n                size: new pc.Vec2(5, 5),\n                color: pc.Color.MAGENTA\n            },\n            {\n                // area based on mouse position\n                pos: new pc.Vec2(mouseX, mouseY),\n                size: new pc.Vec2(1, 1),\n                color: pc.Color.RED\n            }\n        ];\n\n        // process all areas\n        for (let a = 0; a < areas.length; a++) {\n            const areaPos = areas[a].pos;\n            const areaSize = areas[a].size;\n            const color = areas[a].color;\n\n            // display 2D rectangle around it\n            drawRectangle(areaPos.x, areaPos.y, areaSize.x, areaSize.y);\n\n            // get list of meshInstances inside the area from the picker\n            // this scans the pixels inside the render target and maps the id value stored there into meshInstances\n            const selection = picker.getSelection(areaPos.x * pickerScale, areaPos.y * pickerScale, areaSize.x * pickerScale, areaSize.y * pickerScale);\n\n            // process all meshInstances it found - highlight them to appropriate color for the area\n            for (let s = 0; s < selection.length; s++) {\n                if (selection[s]) {\n                    const material = selection[s].material as pc.StandardMaterial;\n                    highlightMaterial(material, color);\n                    highlights.push(material);\n                }\n            }\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // setup skydome\n    app.scene.skyboxMip = 2;\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n    app.scene.skyboxIntensity = 0.1;\n\n    // use a quarter resolution for picker render target (faster but less precise - can miss small objects)\n    const pickerScale = 0.25;\n    let mouseX = 0,\n        mouseY = 0;\n\n    // generate a box area with specified size of random primitives\n    const size = 30;\n    const halfSize = size * 0.5;\n    for (let i = 0; i < 300; i++) {\n        const shape = Math.random() < 0.5 ? "cylinder" : "sphere";\n        const position = new pc.Vec3(\n            Math.random() * size - halfSize,\n            Math.random() * size - halfSize,\n            Math.random() * size - halfSize\n        );\n        const scale = 1 + Math.random();\n        const entity = createPrimitive(\n            shape,\n            position,\n            new pc.Vec3(scale, scale, scale)\n        );\n        app.root.addChild(entity);\n    }\n\n    // handle mouse move event and store current mouse position to use as a position to pick from the scene\n    new pc.Mouse(document.body).on(\n        pc.EVENT_MOUSEMOVE,\n        function (event) {\n            mouseX = event.x;\n            mouseY = event.y;\n        },\n        this\n    );\n\n    // Create an instance of the picker class\n    // Lets use quarter of the resolution to improve performance - this will miss very small objects, but it\'s ok in our case\n    const picker = new pc.Picker(\n        app,\n        canvas.clientWidth * pickerScale,\n        canvas.clientHeight * pickerScale\n    );\n\n    // helper function to create a primitive with shape type, position, scale\n    function createPrimitive(primitiveType, position, scale) {\n        // create material of random color\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(\n            Math.random(),\n            Math.random(),\n            Math.random()\n        );\n        material.shininess = 60;\n        material.metalness = 0.4;\n        material.useMetalness = true;\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent("render", {\n            type: primitiveType,\n            material: material,\n        });\n\n        // set position and scale\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n\n        return primitive;\n    }\n\n    // Create main camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    // add bloom postprocessing (this is ignored by the picker)\n    camera.addComponent("script");\n    camera.script.create("bloom", {\n        attributes: {\n            bloomIntensity: 1,\n            bloomThreshold: 0.7,\n            blurAmount: 4,\n        },\n    });\n\n    app.root.addChild(camera);\n\n    // function to draw a 2D rectangle in the screen space coordinates\n    function drawRectangle(x, y, w, h) {\n        const pink = new pc.Color(1, 0.02, 0.58);\n\n        // transform 4 2D screen points into world space\n        const pt0 = camera.camera.screenToWorld(x, y, 1);\n        const pt1 = camera.camera.screenToWorld(x + w, y, 1);\n        const pt2 = camera.camera.screenToWorld(x + w, y + h, 1);\n        const pt3 = camera.camera.screenToWorld(x, y + h, 1);\n\n        // and connect them using white lines\n        const points = [pt0, pt1, pt1, pt2, pt2, pt3, pt3, pt0];\n        const colors = [pink, pink, pink, pink, pink, pink, pink, pink];\n        app.drawLines(points, colors);\n    }\n\n    // sets material emissive color to specified color\n    function highlightMaterial(material, color) {\n        material.emissive = color;\n        material.update();\n    }\n\n    // array of highlighted materials\n    const highlights = [];\n\n    // update each frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt * 0.1;\n\n        // orbit the camera around\n        if (!camera) {\n            return;\n        }\n\n        camera.setLocalPosition(40 * Math.sin(time), 0, 40 * Math.cos(time));\n        camera.lookAt(pc.Vec3.ZERO);\n\n        // turn all previously highlighted meshes to black at the start of the frame\n        for (let h = 0; h < highlights.length; h++) {\n            highlightMaterial(highlights[h], pc.Color.BLACK);\n        }\n        highlights.length = 0;\n\n        // Make sure the picker is the right size, and prepare it, which renders meshes into its render target\n        if (picker) {\n            picker.resize(\n                canvas.clientWidth * pickerScale,\n                canvas.clientHeight * pickerScale\n            );\n            picker.prepare(camera.camera, app.scene);\n        }\n\n        // areas we want to sample - two larger rectangles, one small square, and one pixel at a mouse position\n        // assign them different highlight colors as well\n        const areas = [\n            {\n                pos: new pc.Vec2(\n                    canvas.clientWidth * 0.3,\n                    canvas.clientHeight * 0.3\n                ),\n                size: new pc.Vec2(100, 200),\n                color: pc.Color.YELLOW,\n            },\n\n            {\n                pos: new pc.Vec2(\n                    canvas.clientWidth * 0.6,\n                    canvas.clientHeight * 0.7\n                ),\n                size: new pc.Vec2(200, 20),\n                color: pc.Color.CYAN,\n            },\n\n            {\n                pos: new pc.Vec2(\n                    canvas.clientWidth * 0.8,\n                    canvas.clientHeight * 0.3\n                ),\n                size: new pc.Vec2(5, 5),\n                color: pc.Color.MAGENTA,\n            },\n\n            {\n                // area based on mouse position\n                pos: new pc.Vec2(mouseX, mouseY),\n                size: new pc.Vec2(1, 1),\n                color: pc.Color.RED,\n            },\n        ];\n\n        // process all areas\n        for (let a = 0; a < areas.length; a++) {\n            const areaPos = areas[a].pos;\n            const areaSize = areas[a].size;\n            const color = areas[a].color;\n\n            // display 2D rectangle around it\n            drawRectangle(areaPos.x, areaPos.y, areaSize.x, areaSize.y);\n\n            // get list of meshInstances inside the area from the picker\n            // this scans the pixels inside the render target and maps the id value stored there into meshInstances\n            const selection = picker.getSelection(\n                areaPos.x * pickerScale,\n                areaPos.y * pickerScale,\n                areaSize.x * pickerScale,\n                areaSize.y * pickerScale\n            );\n\n            // process all meshInstances it found - highlight them to appropriate color for the area\n            for (let s = 0; s < selection.length; s++) {\n                if (selection[s]) {\n                    const material = selection[s].material;\n                    highlightMaterial(material, color);\n                    highlights.push(material);\n                }\n            }\n        }\n    });\n}\n',nameSlug:"area-picker",categorySlug:"graphics"},"batching-dynamic":{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // create two material\n    const material1 = new pc.StandardMaterial();\n    material1.diffuse = new pc.Color(1, 1, 0);\n    material1.shininess = 40;\n    material1.metalness = 0.5;\n    material1.useMetalness = true;\n    material1.update();\n\n    const material2 = new pc.StandardMaterial();\n    material2.diffuse = new pc.Color(0, 1, 1);\n    material2.shininess = 40;\n    material2.metalness = 0.5;\n    material2.useMetalness = true;\n    material2.update();\n\n    // create a single BatchGroup. Make it dynamic to allow batched meshes to be freely moved every frame.\n    const batchGroup = app.batcher.addGroup("Meshes", true, 100);\n\n    // create various primitive instances using one of the two materials\n    const numInstances = 500;\n    const shapes = ["box", "cone", "cylinder", "sphere", "capsule"];\n    const entities: any = [];\n    for (let i = 0; i < numInstances; i++) {\n\n        // random shape\n        const shapeName = shapes[Math.floor(Math.random() * shapes.length)];\n\n        const entity = new pc.Entity();\n\n        // create render component\n        entity.addComponent("render", {\n            type: shapeName,\n            material: Math.random() < 0.5 ? material1 : material2,\n            castShadows: true,\n\n            // add it to the batchGroup - this instructs engine to try and render these meshes in a small number of draw calls.\n            // there will be at least 2 draw calls, one for each material\n            batchGroupId: batchGroup.id\n        });\n\n        // add entity for rendering\n        app.root.addChild(entity);\n\n        // keep in the list to adjust positions each frame\n        entities.push(entity);\n    }\n\n    // Create an Entity for the ground\n    const ground = new pc.Entity();\n    ground.addComponent("render", {\n        type: "box",\n        material: material2\n    });\n    ground.setLocalScale(150, 1, 150);\n    ground.setLocalPosition(0, -26, 0);\n    app.root.addChild(ground);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2)\n    });\n    app.root.addChild(camera);\n\n    // Create an entity with a directional light component\n    // Add it as a child of a camera to rotate with the camera\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        castShadows: true,\n        shadowBias: 0.2,\n        normalOffsetBias: 0.06,\n        shadowDistance: 150\n    });\n    camera.addChild(light);\n    light.setLocalEulerAngles(15, 30, 0);\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // move all entities along orbits\n        for (let i = 0; i < entities.length; i++) {\n            const radius = 5 + 20.0 * i / numInstances;\n            const speed = i / numInstances;\n            entities[i].setLocalPosition(radius * Math.sin(i + time * speed), radius * Math.cos(i + time * speed), radius * Math.cos(i + 2 * time * speed));\n            entities[i].lookAt(pc.Vec3.ZERO);\n        }\n\n        // orbit camera around\n        camera.setLocalPosition(70 * Math.sin(time), 0, 70 * Math.cos(time));\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}',javaScriptFunction:'function example(canvas) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // create two material\n    const material1 = new pc.StandardMaterial();\n    material1.diffuse = new pc.Color(1, 1, 0);\n    material1.shininess = 40;\n    material1.metalness = 0.5;\n    material1.useMetalness = true;\n    material1.update();\n\n    const material2 = new pc.StandardMaterial();\n    material2.diffuse = new pc.Color(0, 1, 1);\n    material2.shininess = 40;\n    material2.metalness = 0.5;\n    material2.useMetalness = true;\n    material2.update();\n\n    // create a single BatchGroup. Make it dynamic to allow batched meshes to be freely moved every frame.\n    const batchGroup = app.batcher.addGroup("Meshes", true, 100);\n\n    // create various primitive instances using one of the two materials\n    const numInstances = 500;\n    const shapes = ["box", "cone", "cylinder", "sphere", "capsule"];\n    const entities = [];\n    for (let i = 0; i < numInstances; i++) {\n        // random shape\n        const shapeName = shapes[Math.floor(Math.random() * shapes.length)];\n\n        const entity = new pc.Entity();\n\n        // create render component\n        entity.addComponent("render", {\n            type: shapeName,\n            material: Math.random() < 0.5 ? material1 : material2,\n            castShadows: true,\n\n            // add it to the batchGroup - this instructs engine to try and render these meshes in a small number of draw calls.\n            // there will be at least 2 draw calls, one for each material\n            batchGroupId: batchGroup.id,\n        });\n\n        // add entity for rendering\n        app.root.addChild(entity);\n\n        // keep in the list to adjust positions each frame\n        entities.push(entity);\n    }\n\n    // Create an Entity for the ground\n    const ground = new pc.Entity();\n    ground.addComponent("render", {\n        type: "box",\n        material: material2,\n    });\n\n    ground.setLocalScale(150, 1, 150);\n    ground.setLocalPosition(0, -26, 0);\n    app.root.addChild(ground);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2),\n    });\n\n    app.root.addChild(camera);\n\n    // Create an entity with a directional light component\n    // Add it as a child of a camera to rotate with the camera\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        castShadows: true,\n        shadowBias: 0.2,\n        normalOffsetBias: 0.06,\n        shadowDistance: 150,\n    });\n\n    camera.addChild(light);\n    light.setLocalEulerAngles(15, 30, 0);\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // move all entities along orbits\n        for (let i = 0; i < entities.length; i++) {\n            const radius = 5 + (20.0 * i) / numInstances;\n            const speed = i / numInstances;\n            entities[i].setLocalPosition(\n                radius * Math.sin(i + time * speed),\n                radius * Math.cos(i + time * speed),\n                radius * Math.cos(i + 2 * time * speed)\n            );\n            entities[i].lookAt(pc.Vec3.ZERO);\n        }\n\n        // orbit camera around\n        camera.setLocalPosition(70 * Math.sin(time), 0, 70 * Math.cos(time));\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}\n',nameSlug:"batching-dynamic",categorySlug:"graphics"},"box-reflection":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any, data: any): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    data.set(\'settings\', {\n        updateFrequency: 10,\n        shininess: 90,\n        metalness: 0.7,\n        bumpiness: 0.2\n    });\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // create a layer for object that do not render into reflection cubemap\n    const excludedLayer = new pc.Layer({ name: "Excluded" });\n    app.scene.layers.push(excludedLayer);\n\n    // get world layer\n    const worldLayer = app.scene.layers.getLayerByName("World");\n\n    // create an envAtlas texture, which will hold a prefiltering lighting generated from the cubemap.\n    // This represents a reflection prefiltered for different levels of roughness\n    const envAtlas = new pc.Texture(app.graphicsDevice, {\n        width: 512,\n        height: 512,\n        format: pc.PIXELFORMAT_R8_G8_B8_A8,\n        type: pc.TEXTURETYPE_RGBM,\n        projection: pc.TEXTUREPROJECTION_EQUIRECT,\n        addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n        addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n        mipmaps: false\n    });\n\n    // material for the walls\n    const roomMaterial = new pc.StandardMaterial();\n    roomMaterial.useMetalness = true;\n    roomMaterial.diffuse = pc.Color.WHITE;\n    roomMaterial.normalMap = assets.normal.resource;\n    roomMaterial.normalMapTiling.set(5, 5);\n    roomMaterial.bumpiness = 0.1;\n    roomMaterial.shininess = 90;\n    // @ts-ignore\n    roomMaterial.envAtlas = envAtlas; // use reflection from env atlas\n    roomMaterial.metalness = 0.5;\n\n    // the material uses box projected cubemap for reflections. Set its bounding box the the size of the room\n    // so that the reflections line up\n    roomMaterial.cubeMapProjection = pc.CUBEPROJ_BOX;\n    roomMaterial.cubeMapProjectionBox = new pc.BoundingBox(new pc.Vec3(0, 200, 0), new pc.Vec3(400, 200, 400));\n    roomMaterial.update();\n\n    // material for the magenta emissive beams\n    const emissiveMaterial = new pc.StandardMaterial();\n    emissiveMaterial.emissive = pc.Color.MAGENTA;\n    emissiveMaterial.diffuse = pc.Color.BLACK;\n    emissiveMaterial.update();\n\n    // material for the white sphere representing an omni light\n    const lightMaterial = new pc.StandardMaterial();\n    lightMaterial.emissive = pc.Color.WHITE;\n    lightMaterial.diffuse = pc.Color.BLACK;\n    lightMaterial.update();\n\n    // material for the reflective sphere in the center\n    const sphereMaterial = new pc.StandardMaterial();\n    sphereMaterial.useMetalness = true;\n    sphereMaterial.diffuse = pc.Color.WHITE;\n    sphereMaterial.normalMap = assets.normal.resource;\n    sphereMaterial.normalMapTiling.set(5, 5);\n    sphereMaterial.bumpiness = 0.7;\n    sphereMaterial.shininess = 90;\n    sphereMaterial.metalness = 0.6;\n    // @ts-ignore\n    sphereMaterial.envAtlas = envAtlas; // use reflection from env atlas\n    sphereMaterial.update();\n\n    // set up video playback into a texture\n    const videoTexture = new pc.Texture(app.graphicsDevice, {\n        format: pc.PIXELFORMAT_R5_G6_B5,\n        mipmaps: false,\n        minFilter: pc.FILTER_LINEAR,\n        magFilter: pc.FILTER_LINEAR,\n        addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n        addressV: pc.ADDRESS_CLAMP_TO_EDGE\n    });\n\n    // create a HTML element with the video\n    const video: HTMLVideoElement = document.createElement(\'video\');\n    video.id = \'vid\';\n    video.loop = true;\n    video.muted = true;\n    video.autoplay = true;\n    video.playsInline = true;\n    video.crossOrigin = "anonymous";\n    video.setAttribute(\'style\', \'display: block; width: 1px; height: 1px; position: absolute; opacity: 0; z-index: -1000; top: 0px; pointer-events: none\');\n    video.src = \'/static/assets/video/SampleVideo_1280x720_1mb.mp4\';\n    document.body.append(video);\n    video.addEventListener(\'canplaythrough\', function () {\n        videoTexture.setSource(video);\n    });\n\n    // materials used on the TV screen to display the video texture\n    const screenMaterial = new pc.StandardMaterial();\n    screenMaterial.useLighting = false;\n    screenMaterial.emissiveMap = videoTexture;\n    screenMaterial.update();\n\n    // helper function to create a 3d primitive including its material\n    function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3, material: pc.Material) {\n\n        // create the primitive using the material\n        const primitive = new pc.Entity();\n        primitive.addComponent(\'render\', {\n            type: primitiveType,\n            material: material,\n            layers: [worldLayer.id, excludedLayer.id]\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n    }\n\n    // create the ground plane from the boxes\n    createPrimitive("box", new pc.Vec3(0, 0, 0), new pc.Vec3(800, 2, 800), roomMaterial);\n    createPrimitive("box", new pc.Vec3(0, 400, 0), new pc.Vec3(800, 2, 800), roomMaterial);\n\n    // walls\n    createPrimitive("box", new pc.Vec3(400, 200, 0), new pc.Vec3(2, 400, 800), roomMaterial);\n    createPrimitive("box", new pc.Vec3(-400, 200, 0), new pc.Vec3(2, 400, 800), roomMaterial);\n    createPrimitive("box", new pc.Vec3(0, 200, -400), new pc.Vec3(800, 400, 0), roomMaterial);\n    createPrimitive("box", new pc.Vec3(0, 200, 400), new pc.Vec3(800, 400, 0), roomMaterial);\n\n    // emissive pillars\n    createPrimitive("box", new pc.Vec3(400, 200, -50), new pc.Vec3(20, 400, 20), emissiveMaterial);\n    createPrimitive("box", new pc.Vec3(400, 200, 50), new pc.Vec3(20, 400, 20), emissiveMaterial);\n    createPrimitive("box", new pc.Vec3(-400, 200, 50), new pc.Vec3(20, 400, 20), emissiveMaterial);\n    createPrimitive("box", new pc.Vec3(-400, 200, -50), new pc.Vec3(20, 400, 20), emissiveMaterial);\n    createPrimitive("box", new pc.Vec3(0, 400, 50), new pc.Vec3(800, 20, 20), emissiveMaterial);\n    createPrimitive("box", new pc.Vec3(0, 400, -50), new pc.Vec3(800, 20, 20), emissiveMaterial);\n\n    // screen\n    createPrimitive("box", new pc.Vec3(0, 200, 400), new pc.Vec3(500, 250, 5), screenMaterial);\n\n    // sphere\n    createPrimitive("sphere", new pc.Vec3(0, 150, 0), new pc.Vec3(150, 150, 150), sphereMaterial);\n\n    // create an omni light white orbits the room to avoid it being completely dark\n    const lightOmni = new pc.Entity();\n    lightOmni.addComponent("light", {\n        type: "omni",\n        layers: [excludedLayer.id], // add it to excluded layer, we don\'t want the light captured in the reflection\n        castShadows: false,\n        color: pc.Color.WHITE,\n        intensity: 0.2,\n        range: 1000\n    });\n\n    // add a white sphere to light so that we can see where it is. This sphere is excluded from the reflections.\n    lightOmni.addComponent("render", {\n        type: "sphere",\n        layers: [excludedLayer.id],\n        material: lightMaterial\n    });\n    lightOmni.setLocalScale(20, 20, 20);\n    app.root.addChild(lightOmni);\n\n    // create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        fov: 100,\n        layers: [worldLayer.id, excludedLayer.id],\n        farClip: 1500\n    });\n    camera.setLocalPosition(270, 90, -260);\n\n    // add orbit camera script with a mouse and a touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            distanceMax: 390,\n            frameOnStart: false\n        }\n    });\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // create a probe object with cubemapRenderer script which takes care of rendering dynamic cubemap\n    const probe = new pc.Entity();\n    probe.addComponent(\'script\');\n\n    // add camera component to the probe - this defines camera properties for cubemap rendering\n    probe.addComponent(\'camera\', {\n\n        // optimization - no need to clear as all pixels get overwritten\n        clearColorBuffer: false,\n\n        // priority - render before world camera\n        priority: -1,\n\n        // only render meshes on the worldLayer (and not excluded layer)\n        layers: [worldLayer.id],\n\n        // disable as this is not a camera that renders cube map but only a container for properties for cube map rendering\n        enabled: false,\n\n        nearClip: 1,\n        farClip: 500\n    });\n\n    // Add a cubemap renderer script, which renders to a cubemap of size 128 with mipmaps, which is directly useable\n    // as a lighting source for envAtlas generation\n    // Position it in the center of the room.\n    probe.script.create(\'cubemapRenderer\', {\n        attributes: {\n            resolution: 128,\n            mipmaps: true,\n            depth: true\n        }\n    });\n    probe.setPosition(0, 200, 0);\n    app.root.addChild(probe);\n\n    // handle onCubemapPostRender event fired by the cubemapRenderer when all faces of the cubemap are done rendering\n    probe.on(\'onCubemapPostRender\', () => {\n\n        // prefilter just rendered cubemap into envAtlas, so that it can be used for reflection during the rest of the frame\n        // @ts-ignore\n        pc.EnvLighting.generateAtlas(probe.script.cubemapRenderer.cubeMap, {\n            target: envAtlas\n        });\n    });\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    let updateProbeCount = 1;\n    let updateVideo = true;\n    app.on("update", function (dt: number) {\n        time += dt * 0.3;\n\n        // Update the video data to the texture every other frame\n        if (updateVideo) {\n            videoTexture.upload();\n        }\n        updateVideo = !updateVideo;\n\n        // move the light around\n        lightOmni.setLocalPosition(300 * Math.sin(time), 300, 300 * Math.cos(time));\n\n        // update the reflection probe as needed\n        const updateFrequency = data.get(\'settings.updateFrequency\');\n        updateProbeCount--;\n        if (updateFrequency === 0)\n            updateProbeCount = 1;\n\n        if (updateProbeCount <= 0) {\n            // enable probe rendering\n            probe.enabled = true;\n            updateProbeCount = updateFrequency;\n        } else {\n            probe.enabled = false;\n        }\n\n        // update material properties based on settings\n        const shininess = data.get(\'settings.shininess\');\n        const metalness = data.get(\'settings.metalness\');\n        const bumpiness = data.get(\'settings.bumpiness\');\n\n        roomMaterial.shininess = shininess;\n        roomMaterial.metalness = metalness;\n        roomMaterial.bumpiness = bumpiness;\n        roomMaterial.update();\n\n        sphereMaterial.shininess = shininess;\n        sphereMaterial.metalness = metalness;\n        sphereMaterial.bumpiness = bumpiness;\n        sphereMaterial.update();\n    });\n}',javaScriptFunction:'function example(canvas, assets, data) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    data.set("settings", {\n        updateFrequency: 10,\n        shininess: 90,\n        metalness: 0.7,\n        bumpiness: 0.2,\n    });\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // create a layer for object that do not render into reflection cubemap\n    const excludedLayer = new pc.Layer({ name: "Excluded" });\n    app.scene.layers.push(excludedLayer);\n\n    // get world layer\n    const worldLayer = app.scene.layers.getLayerByName("World");\n\n    // create an envAtlas texture, which will hold a prefiltering lighting generated from the cubemap.\n    // This represents a reflection prefiltered for different levels of roughness\n    const envAtlas = new pc.Texture(app.graphicsDevice, {\n        width: 512,\n        height: 512,\n        format: pc.PIXELFORMAT_R8_G8_B8_A8,\n        type: pc.TEXTURETYPE_RGBM,\n        projection: pc.TEXTUREPROJECTION_EQUIRECT,\n        addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n        addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n        mipmaps: false,\n    });\n\n    // material for the walls\n    const roomMaterial = new pc.StandardMaterial();\n    roomMaterial.useMetalness = true;\n    roomMaterial.diffuse = pc.Color.WHITE;\n    roomMaterial.normalMap = assets.normal.resource;\n    roomMaterial.normalMapTiling.set(5, 5);\n    roomMaterial.bumpiness = 0.1;\n    roomMaterial.shininess = 90;\n    // @ts-ignore\n    roomMaterial.envAtlas = envAtlas; // use reflection from env atlas\n    roomMaterial.metalness = 0.5;\n\n    // the material uses box projected cubemap for reflections. Set its bounding box the the size of the room\n    // so that the reflections line up\n    roomMaterial.cubeMapProjection = pc.CUBEPROJ_BOX;\n    roomMaterial.cubeMapProjectionBox = new pc.BoundingBox(\n        new pc.Vec3(0, 200, 0),\n        new pc.Vec3(400, 200, 400)\n    );\n    roomMaterial.update();\n\n    // material for the magenta emissive beams\n    const emissiveMaterial = new pc.StandardMaterial();\n    emissiveMaterial.emissive = pc.Color.MAGENTA;\n    emissiveMaterial.diffuse = pc.Color.BLACK;\n    emissiveMaterial.update();\n\n    // material for the white sphere representing an omni light\n    const lightMaterial = new pc.StandardMaterial();\n    lightMaterial.emissive = pc.Color.WHITE;\n    lightMaterial.diffuse = pc.Color.BLACK;\n    lightMaterial.update();\n\n    // material for the reflective sphere in the center\n    const sphereMaterial = new pc.StandardMaterial();\n    sphereMaterial.useMetalness = true;\n    sphereMaterial.diffuse = pc.Color.WHITE;\n    sphereMaterial.normalMap = assets.normal.resource;\n    sphereMaterial.normalMapTiling.set(5, 5);\n    sphereMaterial.bumpiness = 0.7;\n    sphereMaterial.shininess = 90;\n    sphereMaterial.metalness = 0.6;\n    // @ts-ignore\n    sphereMaterial.envAtlas = envAtlas; // use reflection from env atlas\n    sphereMaterial.update();\n\n    // set up video playback into a texture\n    const videoTexture = new pc.Texture(app.graphicsDevice, {\n        format: pc.PIXELFORMAT_R5_G6_B5,\n        mipmaps: false,\n        minFilter: pc.FILTER_LINEAR,\n        magFilter: pc.FILTER_LINEAR,\n        addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n        addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n    });\n\n    // create a HTML element with the video\n    const video = document.createElement("video");\n    video.id = "vid";\n    video.loop = true;\n    video.muted = true;\n    video.autoplay = true;\n    video.playsInline = true;\n    video.crossOrigin = "anonymous";\n    video.setAttribute(\n        "style",\n        "display: block; width: 1px; height: 1px; position: absolute; opacity: 0; z-index: -1000; top: 0px; pointer-events: none"\n    );\n    video.src = "/static/assets/video/SampleVideo_1280x720_1mb.mp4";\n    document.body.append(video);\n    video.addEventListener("canplaythrough", function () {\n        videoTexture.setSource(video);\n    });\n\n    // materials used on the TV screen to display the video texture\n    const screenMaterial = new pc.StandardMaterial();\n    screenMaterial.useLighting = false;\n    screenMaterial.emissiveMap = videoTexture;\n    screenMaterial.update();\n\n    // helper function to create a 3d primitive including its material\n    function createPrimitive(primitiveType, position, scale, material) {\n        // create the primitive using the material\n        const primitive = new pc.Entity();\n        primitive.addComponent("render", {\n            type: primitiveType,\n            material: material,\n            layers: [worldLayer.id, excludedLayer.id],\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n    }\n\n    // create the ground plane from the boxes\n    createPrimitive(\n        "box",\n        new pc.Vec3(0, 0, 0),\n        new pc.Vec3(800, 2, 800),\n        roomMaterial\n    );\n    createPrimitive(\n        "box",\n        new pc.Vec3(0, 400, 0),\n        new pc.Vec3(800, 2, 800),\n        roomMaterial\n    );\n\n    // walls\n    createPrimitive(\n        "box",\n        new pc.Vec3(400, 200, 0),\n        new pc.Vec3(2, 400, 800),\n        roomMaterial\n    );\n    createPrimitive(\n        "box",\n        new pc.Vec3(-400, 200, 0),\n        new pc.Vec3(2, 400, 800),\n        roomMaterial\n    );\n    createPrimitive(\n        "box",\n        new pc.Vec3(0, 200, -400),\n        new pc.Vec3(800, 400, 0),\n        roomMaterial\n    );\n    createPrimitive(\n        "box",\n        new pc.Vec3(0, 200, 400),\n        new pc.Vec3(800, 400, 0),\n        roomMaterial\n    );\n\n    // emissive pillars\n    createPrimitive(\n        "box",\n        new pc.Vec3(400, 200, -50),\n        new pc.Vec3(20, 400, 20),\n        emissiveMaterial\n    );\n    createPrimitive(\n        "box",\n        new pc.Vec3(400, 200, 50),\n        new pc.Vec3(20, 400, 20),\n        emissiveMaterial\n    );\n    createPrimitive(\n        "box",\n        new pc.Vec3(-400, 200, 50),\n        new pc.Vec3(20, 400, 20),\n        emissiveMaterial\n    );\n    createPrimitive(\n        "box",\n        new pc.Vec3(-400, 200, -50),\n        new pc.Vec3(20, 400, 20),\n        emissiveMaterial\n    );\n    createPrimitive(\n        "box",\n        new pc.Vec3(0, 400, 50),\n        new pc.Vec3(800, 20, 20),\n        emissiveMaterial\n    );\n    createPrimitive(\n        "box",\n        new pc.Vec3(0, 400, -50),\n        new pc.Vec3(800, 20, 20),\n        emissiveMaterial\n    );\n\n    // screen\n    createPrimitive(\n        "box",\n        new pc.Vec3(0, 200, 400),\n        new pc.Vec3(500, 250, 5),\n        screenMaterial\n    );\n\n    // sphere\n    createPrimitive(\n        "sphere",\n        new pc.Vec3(0, 150, 0),\n        new pc.Vec3(150, 150, 150),\n        sphereMaterial\n    );\n\n    // create an omni light white orbits the room to avoid it being completely dark\n    const lightOmni = new pc.Entity();\n    lightOmni.addComponent("light", {\n        type: "omni",\n        layers: [excludedLayer.id], // add it to excluded layer, we don\'t want the light captured in the reflection\n        castShadows: false,\n        color: pc.Color.WHITE,\n        intensity: 0.2,\n        range: 1000,\n    });\n\n    // add a white sphere to light so that we can see where it is. This sphere is excluded from the reflections.\n    lightOmni.addComponent("render", {\n        type: "sphere",\n        layers: [excludedLayer.id],\n        material: lightMaterial,\n    });\n\n    lightOmni.setLocalScale(20, 20, 20);\n    app.root.addChild(lightOmni);\n\n    // create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        fov: 100,\n        layers: [worldLayer.id, excludedLayer.id],\n        farClip: 1500,\n    });\n\n    camera.setLocalPosition(270, 90, -260);\n\n    // add orbit camera script with a mouse and a touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            distanceMax: 390,\n            frameOnStart: false,\n        },\n    });\n\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // create a probe object with cubemapRenderer script which takes care of rendering dynamic cubemap\n    const probe = new pc.Entity();\n    probe.addComponent("script");\n\n    // add camera component to the probe - this defines camera properties for cubemap rendering\n    probe.addComponent("camera", {\n        // optimization - no need to clear as all pixels get overwritten\n        clearColorBuffer: false,\n\n        // priority - render before world camera\n        priority: -1,\n\n        // only render meshes on the worldLayer (and not excluded layer)\n        layers: [worldLayer.id],\n\n        // disable as this is not a camera that renders cube map but only a container for properties for cube map rendering\n        enabled: false,\n\n        nearClip: 1,\n        farClip: 500,\n    });\n\n    // Add a cubemap renderer script, which renders to a cubemap of size 128 with mipmaps, which is directly useable\n    // as a lighting source for envAtlas generation\n    // Position it in the center of the room.\n    probe.script.create("cubemapRenderer", {\n        attributes: {\n            resolution: 128,\n            mipmaps: true,\n            depth: true,\n        },\n    });\n\n    probe.setPosition(0, 200, 0);\n    app.root.addChild(probe);\n\n    // handle onCubemapPostRender event fired by the cubemapRenderer when all faces of the cubemap are done rendering\n    probe.on("onCubemapPostRender", () => {\n        // prefilter just rendered cubemap into envAtlas, so that it can be used for reflection during the rest of the frame\n        // @ts-ignore\n        pc.EnvLighting.generateAtlas(probe.script.cubemapRenderer.cubeMap, {\n            target: envAtlas,\n        });\n    });\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    let updateProbeCount = 1;\n    let updateVideo = true;\n    app.on("update", function (dt) {\n        time += dt * 0.3;\n\n        // Update the video data to the texture every other frame\n        if (updateVideo) {\n            videoTexture.upload();\n        }\n        updateVideo = !updateVideo;\n\n        // move the light around\n        lightOmni.setLocalPosition(\n            300 * Math.sin(time),\n            300,\n            300 * Math.cos(time)\n        );\n\n        // update the reflection probe as needed\n        const updateFrequency = data.get("settings.updateFrequency");\n        updateProbeCount--;\n        if (updateFrequency === 0) updateProbeCount = 1;\n\n        if (updateProbeCount <= 0) {\n            // enable probe rendering\n            probe.enabled = true;\n            updateProbeCount = updateFrequency;\n        } else {\n            probe.enabled = false;\n        }\n\n        // update material properties based on settings\n        const shininess = data.get("settings.shininess");\n        const metalness = data.get("settings.metalness");\n        const bumpiness = data.get("settings.bumpiness");\n\n        roomMaterial.shininess = shininess;\n        roomMaterial.metalness = metalness;\n        roomMaterial.bumpiness = bumpiness;\n        roomMaterial.update();\n\n        sphereMaterial.shininess = shininess;\n        sphereMaterial.metalness = metalness;\n        sphereMaterial.bumpiness = bumpiness;\n        sphereMaterial.update();\n    });\n}\n',nameSlug:"box-reflection",categorySlug:"graphics"},"clustered-area-lights":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any, data:any): void {\n\n    data.set(\'settings\', {\n        material: {\n            shininess: 80,\n            metalness: 0.7\n        }\n    });\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body)\n    });\n\n    // set up some general scene rendering properties\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // enabled clustered lighting. This is a temporary API and will change in the future\n    // @ts-ignore engine-tsd\n    app.scene.clusteredLightingEnabled = true;\n\n    // adjust default clustered lighting parameters to handle many lights:\n    // @ts-ignore\n    const lighting = app.scene.lighting;\n\n    // 1) subdivide space with lights into this many cells:\n    // @ts-ignore engine-tsd\n    lighting.cells = new pc.Vec3(30, 2, 30);\n\n    // 2) and allow this many lights per cell:\n    // @ts-ignore engine-tsd\n    lighting.maxLightsPerCell = 20;\n\n    // @ts-ignore engine-tsd\n    lighting.areaLightsEnabled = true;\n\n    // @ts-ignore engine-tsd\n    lighting.shadowsEnabled = false;\n\n\n    // pure black material - used on back side of light objects\n    const blackMaterial = new pc.StandardMaterial();\n    blackMaterial.diffuse = new pc.Color(0, 0, 0);\n    blackMaterial.useLighting = false;\n    blackMaterial.update();\n\n    // ground material\n    const groundMaterial = new pc.StandardMaterial();\n    groundMaterial.diffuse = pc.Color.GRAY;\n    groundMaterial.shininess = 80;\n    groundMaterial.metalness = 0.7;\n    groundMaterial.useMetalness = true;\n\n    // helper function to create a primitive with shape type, position, scale, color\n    function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3, assetManifest: any) {\n\n        if (assetManifest) {\n            groundMaterial.diffuseMap = assetManifest.color.resource;\n            groundMaterial.normalMap = assetManifest.normal.resource;\n            groundMaterial.glossMap = assetManifest.gloss.resource;\n\n            groundMaterial.diffuseMapTiling.set(17, 17);\n            groundMaterial.normalMapTiling.set(17, 17);\n            groundMaterial.glossMapTiling.set(17, 17);\n        }\n\n        groundMaterial.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent(\'render\', {\n            type: primitiveType,\n            material: groundMaterial\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // helper function to create area light including its visual representation in the world\n    function createAreaLight(type: string, shape: number, position: pc.Vec3, scale: pc.Vec3, color: pc.Color, intensity: number, range: number) {\n\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            type: type,\n            shape: shape,\n            color: color,\n            intensity: intensity,\n            falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED,\n            range: range,\n            innerConeAngle: 88,\n            outerConeAngle: 89\n        });\n\n        light.setLocalScale(scale);\n        light.setLocalPosition(position);\n        if (type === "spot") {\n            light.rotate(-90, 0, 0);\n        }\n        app.root.addChild(light);\n\n        // emissive material that is the light source color\n        const brightMaterial = new pc.StandardMaterial();\n        brightMaterial.emissive = new pc.Color(color.r * 0.8, color.g * 0.8, color.b * 0.8);\n        brightMaterial.useLighting = false;\n        brightMaterial.update();\n\n        // primitive shape that matches light source shape\n        const lightPrimitive = (shape === pc.LIGHTSHAPE_SPHERE) ? "sphere" : (shape === pc.LIGHTSHAPE_DISK) ? "cylinder" : "box";\n\n        // primitive scale - flatten it to disk / rectangle\n        const primitiveScale = new pc.Vec3(1, shape !== pc.LIGHTSHAPE_SPHERE ? 0.001 : 1, 1);\n\n        // bright primitive representing the area light source\n        const brightShape = new pc.Entity();\n        brightShape.addComponent("render", {\n            type: lightPrimitive,\n            material: brightMaterial\n        });\n        brightShape.setLocalScale(primitiveScale);\n        light.addChild(brightShape);\n\n        // black primitive representing the back of the light source which is not emitting light\n        if (type === "spot") {\n\n            const blackShape = new pc.Entity();\n            blackShape.addComponent("render", {\n                type: lightPrimitive,\n                material: blackMaterial\n            });\n            blackShape.setLocalPosition(0, 0.004, 0);\n            blackShape.setLocalEulerAngles(-180, 0, 0);\n            blackShape.setLocalScale(primitiveScale);\n            light.addChild(blackShape);\n        }\n\n        return light;\n    }\n\n    app.start();\n\n    // set the loaded area light LUT data\n    app.setAreaLightLuts(assets.luts);\n\n    // set up some general scene rendering properties\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // create ground plane\n    const ground = createPrimitive("plane", new pc.Vec3(0, 0, 0), new pc.Vec3(45, 1, 45), assets);\n\n    // Create the camera, which renders entities\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n        fov: 60,\n        farClip: 1000\n    });\n    camera.setLocalPosition(3, 3, 12);\n\n    // add orbit camera script with a mouse and a touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            focusEntity: ground,\n            distanceMax: 60,\n            frameOnStart: false\n        }\n    });\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // add bloom postprocessing\n    camera.script.create("bloom", {\n        attributes: {\n            bloomIntensity: 1.5,\n            bloomThreshold: 0.6,\n            blurAmount: 6\n        }\n    });\n\n    // generate a grid of area lights of sphere, disk and rect shapes\n    for (let x = -20; x <= 20; x += 5) {\n        for (let y = -20; y <= 20; y += 5) {\n            const pos = new pc.Vec3(x, 0.6, y);\n            const color = new pc.Color(0.3 + Math.random() * 0.7, 0.3 + Math.random() * 0.7, 0.3 + Math.random() * 0.7);\n            const rand = Math.random();\n            if (rand < 0.3) {\n                createAreaLight("omni", pc.LIGHTSHAPE_SPHERE, pos, new pc.Vec3(1.5, 1.5, 1.5), color, 2, 6);\n            } else if (rand < 0.6) {\n                createAreaLight("spot", pc.LIGHTSHAPE_DISK, pos, new pc.Vec3(1.5, 1.5, 1.5), color, 2.5, 5);\n            } else {\n                createAreaLight("spot", pc.LIGHTSHAPE_RECT, pos, new pc.Vec3(2, 1, 1), color, 2.5, 5);\n            }\n        }\n    }\n\n    // handle HUD changes - update properties on the material\n    data.on(\'*:set\', (path: string, value: any) => {\n        const pathArray = path.split(\'.\');\n        if (pathArray[2] === "shininess") groundMaterial.shininess = value;\n        if (pathArray[2] === "metalness") groundMaterial.metalness = value;\n        groundMaterial.update();\n    });\n}',javaScriptFunction:'function example(canvas, assets, data) {\n    data.set("settings", {\n        material: {\n            shininess: 80,\n            metalness: 0.7,\n        },\n    });\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n    });\n\n    // set up some general scene rendering properties\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // enabled clustered lighting. This is a temporary API and will change in the future\n    // @ts-ignore engine-tsd\n    app.scene.clusteredLightingEnabled = true;\n\n    // adjust default clustered lighting parameters to handle many lights:\n    // @ts-ignore\n    const lighting = app.scene.lighting;\n\n    // 1) subdivide space with lights into this many cells:\n    // @ts-ignore engine-tsd\n    lighting.cells = new pc.Vec3(30, 2, 30);\n\n    // 2) and allow this many lights per cell:\n    // @ts-ignore engine-tsd\n    lighting.maxLightsPerCell = 20;\n\n    // @ts-ignore engine-tsd\n    lighting.areaLightsEnabled = true;\n\n    // @ts-ignore engine-tsd\n    lighting.shadowsEnabled = false;\n\n    // pure black material - used on back side of light objects\n    const blackMaterial = new pc.StandardMaterial();\n    blackMaterial.diffuse = new pc.Color(0, 0, 0);\n    blackMaterial.useLighting = false;\n    blackMaterial.update();\n\n    // ground material\n    const groundMaterial = new pc.StandardMaterial();\n    groundMaterial.diffuse = pc.Color.GRAY;\n    groundMaterial.shininess = 80;\n    groundMaterial.metalness = 0.7;\n    groundMaterial.useMetalness = true;\n\n    // helper function to create a primitive with shape type, position, scale, color\n    function createPrimitive(primitiveType, position, scale, assetManifest) {\n        if (assetManifest) {\n            groundMaterial.diffuseMap = assetManifest.color.resource;\n            groundMaterial.normalMap = assetManifest.normal.resource;\n            groundMaterial.glossMap = assetManifest.gloss.resource;\n\n            groundMaterial.diffuseMapTiling.set(17, 17);\n            groundMaterial.normalMapTiling.set(17, 17);\n            groundMaterial.glossMapTiling.set(17, 17);\n        }\n\n        groundMaterial.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent("render", {\n            type: primitiveType,\n            material: groundMaterial,\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // helper function to create area light including its visual representation in the world\n    function createAreaLight(\n        type,\n        shape,\n        position,\n        scale,\n        color,\n        intensity,\n        range\n    ) {\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            type: type,\n            shape: shape,\n            color: color,\n            intensity: intensity,\n            falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED,\n            range: range,\n            innerConeAngle: 88,\n            outerConeAngle: 89,\n        });\n\n        light.setLocalScale(scale);\n        light.setLocalPosition(position);\n        if (type === "spot") {\n            light.rotate(-90, 0, 0);\n        }\n        app.root.addChild(light);\n\n        // emissive material that is the light source color\n        const brightMaterial = new pc.StandardMaterial();\n        brightMaterial.emissive = new pc.Color(\n            color.r * 0.8,\n            color.g * 0.8,\n            color.b * 0.8\n        );\n        brightMaterial.useLighting = false;\n        brightMaterial.update();\n\n        // primitive shape that matches light source shape\n        const lightPrimitive =\n            shape === pc.LIGHTSHAPE_SPHERE\n                ? "sphere"\n                : shape === pc.LIGHTSHAPE_DISK\n                ? "cylinder"\n                : "box";\n\n        // primitive scale - flatten it to disk / rectangle\n        const primitiveScale = new pc.Vec3(\n            1,\n            shape !== pc.LIGHTSHAPE_SPHERE ? 0.001 : 1,\n            1\n        );\n\n        // bright primitive representing the area light source\n        const brightShape = new pc.Entity();\n        brightShape.addComponent("render", {\n            type: lightPrimitive,\n            material: brightMaterial,\n        });\n\n        brightShape.setLocalScale(primitiveScale);\n        light.addChild(brightShape);\n\n        // black primitive representing the back of the light source which is not emitting light\n        if (type === "spot") {\n            const blackShape = new pc.Entity();\n            blackShape.addComponent("render", {\n                type: lightPrimitive,\n                material: blackMaterial,\n            });\n\n            blackShape.setLocalPosition(0, 0.004, 0);\n            blackShape.setLocalEulerAngles(-180, 0, 0);\n            blackShape.setLocalScale(primitiveScale);\n            light.addChild(blackShape);\n        }\n\n        return light;\n    }\n\n    app.start();\n\n    // set the loaded area light LUT data\n    app.setAreaLightLuts(assets.luts);\n\n    // set up some general scene rendering properties\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // create ground plane\n    const ground = createPrimitive(\n        "plane",\n        new pc.Vec3(0, 0, 0),\n        new pc.Vec3(45, 1, 45),\n        assets\n    );\n\n    // Create the camera, which renders entities\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n        fov: 60,\n        farClip: 1000,\n    });\n\n    camera.setLocalPosition(3, 3, 12);\n\n    // add orbit camera script with a mouse and a touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            focusEntity: ground,\n            distanceMax: 60,\n            frameOnStart: false,\n        },\n    });\n\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // add bloom postprocessing\n    camera.script.create("bloom", {\n        attributes: {\n            bloomIntensity: 1.5,\n            bloomThreshold: 0.6,\n            blurAmount: 6,\n        },\n    });\n\n    // generate a grid of area lights of sphere, disk and rect shapes\n    for (let x = -20; x <= 20; x += 5) {\n        for (let y = -20; y <= 20; y += 5) {\n            const pos = new pc.Vec3(x, 0.6, y);\n            const color = new pc.Color(\n                0.3 + Math.random() * 0.7,\n                0.3 + Math.random() * 0.7,\n                0.3 + Math.random() * 0.7\n            );\n            const rand = Math.random();\n            if (rand < 0.3) {\n                createAreaLight(\n                    "omni",\n                    pc.LIGHTSHAPE_SPHERE,\n                    pos,\n                    new pc.Vec3(1.5, 1.5, 1.5),\n                    color,\n                    2,\n                    6\n                );\n            } else if (rand < 0.6) {\n                createAreaLight(\n                    "spot",\n                    pc.LIGHTSHAPE_DISK,\n                    pos,\n                    new pc.Vec3(1.5, 1.5, 1.5),\n                    color,\n                    2.5,\n                    5\n                );\n            } else {\n                createAreaLight(\n                    "spot",\n                    pc.LIGHTSHAPE_RECT,\n                    pos,\n                    new pc.Vec3(2, 1, 1),\n                    color,\n                    2.5,\n                    5\n                );\n            }\n        }\n    }\n\n    // handle HUD changes - update properties on the material\n    data.on("*:set", (path, value) => {\n        const pathArray = path.split(".");\n        if (pathArray[2] === "shininess") groundMaterial.shininess = value;\n        if (pathArray[2] === "metalness") groundMaterial.metalness = value;\n        groundMaterial.update();\n    });\n}\n',nameSlug:"clustered-area-lights",categorySlug:"graphics"},"clustered-lighting":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { normal: pc.Asset }): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const pointLightList: Array<pc.Entity> = [];\n    const spotLightList: Array<pc.Entity> = [];\n    let dirLight: pc.Entity = null;\n\n    app.start();\n\n    // enabled clustered lighting. This is a temporary API and will change in the future\n    // @ts-ignore engine-tsd\n    app.scene.clusteredLightingEnabled = true;\n\n    // @ts-ignore adjust default clustered lighting parameters to handle many lights:\n    const lighting = app.scene.lighting;\n\n    // 1) subdivide space with lights into this many cells:\n    // @ts-ignore engine-tsd\n    lighting.cells = new pc.Vec3(12, 16, 12);\n\n    // 2) and allow this many lights per cell:\n    // @ts-ignore engine-tsd\n    lighting.maxLightsPerCell = 48;\n\n    // @ts-ignore engine-tsd\n    lighting.shadowsEnabled = false;\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // material with tiled normal map\n    let material = new pc.StandardMaterial();\n    material.normalMap = assets.normal.resource;\n    material.normalMapTiling.set(5, 5);\n    material.bumpiness = 1;\n\n    // enable specular\n    material.shininess = 50;\n    material.metalness = 0.3;\n    material.useMetalness = true;\n\n    material.update();\n\n    // ground plane\n    const ground = new pc.Entity();\n    ground.addComponent(\'render\', {\n        type: "plane",\n        material: material\n    });\n    ground.setLocalScale(150, 150, 150);\n    app.root.addChild(ground);\n\n    // high polycount cylinder\n    const cylinderMesh = pc.createCylinder(app.graphicsDevice, { capSegments: 200 });\n    const cylinder = new pc.Entity();\n    cylinder.addComponent(\'render\', {\n        material: material,\n        meshInstances: [new pc.MeshInstance(cylinderMesh, material)],\n        castShadows: true\n    });\n    app.root.addChild(cylinder);\n    cylinder.setLocalPosition(0, 50, 0);\n    cylinder.setLocalScale(50, 100, 50);\n\n    // create many omni lights that do not cast shadows\n    let count = 30;\n    for (let i = 0; i < count; i++) {\n        const color = new pc.Color(Math.random(), Math.random(), Math.random(), 1);\n        const lightPoint = new pc.Entity();\n        lightPoint.addComponent("light", {\n            type: "omni",\n            color: color,\n            range: 12,\n            castShadows: false,\n            falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED\n        });\n\n        // attach a render component with a small sphere to each light\n        const material = new pc.StandardMaterial();\n        material.emissive = color;\n        material.update();\n\n        lightPoint.addComponent(\'render\', {\n            type: "sphere",\n            material: material,\n            castShadows: true\n        });\n        lightPoint.setLocalScale(5, 5, 5);\n\n        // add it to the scene and also keep it in an array\n        app.root.addChild(lightPoint);\n        pointLightList.push(lightPoint);\n    }\n\n    // create many spot lights\n    count = 16;\n    for (let i = 0; i < count; i++) {\n        const color = new pc.Color(Math.random(), Math.random(), Math.random(), 1);\n        const lightSpot = new pc.Entity();\n        lightSpot.addComponent("light", {\n            type: "spot",\n            color: color,\n            innerConeAngle: 5,\n            outerConeAngle: 6 + Math.random() * 40,\n            range: 25,\n            castShadows: false\n        });\n\n        // attach a render component with a small cone to each light\n        material = new pc.StandardMaterial();\n        material.emissive = color;\n        material.update();\n\n        lightSpot.addComponent(\'render\', {\n            type: "cone",\n            material: material\n        });\n        lightSpot.setLocalScale(5, 5, 5);\n\n        lightSpot.setLocalPosition(100, 50, 70);\n        lightSpot.lookAt(new pc.Vec3(100, 60, 70));\n        app.root.addChild(lightSpot);\n        spotLightList.push(lightSpot);\n    }\n\n    // Create a single directional light which casts shadows\n    dirLight = new pc.Entity();\n    dirLight.addComponent("light", {\n        type: "directional",\n        color: pc.Color.WHITE,\n        intensity: 0.15,\n        range: 300,\n        shadowDistance: 600,\n        castShadows: true,\n        shadowBias: 0.2,\n        normalOffsetBias: 0.05\n    });\n    app.root.addChild(dirLight);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.05, 0.05, 0.05),\n        farClip: 500,\n        nearClip: 0.1\n    });\n    camera.setLocalPosition(140, 140, 140);\n    camera.lookAt(new pc.Vec3(0, 40, 0));\n\n    // add orbit camera script with mouse and touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            focusEntity: app.root,\n            distanceMax: 400,\n            frameOnStart: false\n        }\n    });\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    app.on("update", function (dt: number) {\n        time += dt;\n\n        // move lights along sin based waves around the cylinder\n        pointLightList.forEach(function (light, i) {\n            const angle = (i / pointLightList.length) * Math.PI * 2;\n            const y = Math.sin(time * 0.5 + 7 * angle) * 30 + 70;\n            light.setLocalPosition(30 * Math.sin(angle), y, 30 * Math.cos(angle));\n        });\n\n        // rotate spot lights around\n        spotLightList.forEach(function (spotlight, i) {\n            const angle = (i / spotLightList.length) * Math.PI * 2;\n            spotlight.setLocalPosition(40 * Math.sin(time + angle), 5, 40 * Math.cos(time + angle));\n            spotlight.lookAt(pc.Vec3.ZERO);\n            spotlight.rotateLocal(90, 0, 0);\n        });\n\n        // rotate directional light\n        if (dirLight) {\n            dirLight.setLocalEulerAngles(25, -30 * time, 0);\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const pointLightList = [];\n    const spotLightList = [];\n    let dirLight = null;\n\n    app.start();\n\n    // enabled clustered lighting. This is a temporary API and will change in the future\n    // @ts-ignore engine-tsd\n    app.scene.clusteredLightingEnabled = true;\n\n    // @ts-ignore adjust default clustered lighting parameters to handle many lights:\n    const lighting = app.scene.lighting;\n\n    // 1) subdivide space with lights into this many cells:\n    // @ts-ignore engine-tsd\n    lighting.cells = new pc.Vec3(12, 16, 12);\n\n    // 2) and allow this many lights per cell:\n    // @ts-ignore engine-tsd\n    lighting.maxLightsPerCell = 48;\n\n    // @ts-ignore engine-tsd\n    lighting.shadowsEnabled = false;\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // material with tiled normal map\n    let material = new pc.StandardMaterial();\n    material.normalMap = assets.normal.resource;\n    material.normalMapTiling.set(5, 5);\n    material.bumpiness = 1;\n\n    // enable specular\n    material.shininess = 50;\n    material.metalness = 0.3;\n    material.useMetalness = true;\n\n    material.update();\n\n    // ground plane\n    const ground = new pc.Entity();\n    ground.addComponent("render", {\n        type: "plane",\n        material: material,\n    });\n\n    ground.setLocalScale(150, 150, 150);\n    app.root.addChild(ground);\n\n    // high polycount cylinder\n    const cylinderMesh = pc.createCylinder(app.graphicsDevice, {\n        capSegments: 200,\n    });\n    const cylinder = new pc.Entity();\n    cylinder.addComponent("render", {\n        material: material,\n        meshInstances: [new pc.MeshInstance(cylinderMesh, material)],\n        castShadows: true,\n    });\n\n    app.root.addChild(cylinder);\n    cylinder.setLocalPosition(0, 50, 0);\n    cylinder.setLocalScale(50, 100, 50);\n\n    // create many omni lights that do not cast shadows\n    let count = 30;\n    for (let i = 0; i < count; i++) {\n        const color = new pc.Color(\n            Math.random(),\n            Math.random(),\n            Math.random(),\n            1\n        );\n        const lightPoint = new pc.Entity();\n        lightPoint.addComponent("light", {\n            type: "omni",\n            color: color,\n            range: 12,\n            castShadows: false,\n            falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED,\n        });\n\n        // attach a render component with a small sphere to each light\n        const material = new pc.StandardMaterial();\n        material.emissive = color;\n        material.update();\n\n        lightPoint.addComponent("render", {\n            type: "sphere",\n            material: material,\n            castShadows: true,\n        });\n\n        lightPoint.setLocalScale(5, 5, 5);\n\n        // add it to the scene and also keep it in an array\n        app.root.addChild(lightPoint);\n        pointLightList.push(lightPoint);\n    }\n\n    // create many spot lights\n    count = 16;\n    for (let i = 0; i < count; i++) {\n        const color = new pc.Color(\n            Math.random(),\n            Math.random(),\n            Math.random(),\n            1\n        );\n        const lightSpot = new pc.Entity();\n        lightSpot.addComponent("light", {\n            type: "spot",\n            color: color,\n            innerConeAngle: 5,\n            outerConeAngle: 6 + Math.random() * 40,\n            range: 25,\n            castShadows: false,\n        });\n\n        // attach a render component with a small cone to each light\n        material = new pc.StandardMaterial();\n        material.emissive = color;\n        material.update();\n\n        lightSpot.addComponent("render", {\n            type: "cone",\n            material: material,\n        });\n\n        lightSpot.setLocalScale(5, 5, 5);\n\n        lightSpot.setLocalPosition(100, 50, 70);\n        lightSpot.lookAt(new pc.Vec3(100, 60, 70));\n        app.root.addChild(lightSpot);\n        spotLightList.push(lightSpot);\n    }\n\n    // Create a single directional light which casts shadows\n    dirLight = new pc.Entity();\n    dirLight.addComponent("light", {\n        type: "directional",\n        color: pc.Color.WHITE,\n        intensity: 0.15,\n        range: 300,\n        shadowDistance: 600,\n        castShadows: true,\n        shadowBias: 0.2,\n        normalOffsetBias: 0.05,\n    });\n\n    app.root.addChild(dirLight);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.05, 0.05, 0.05),\n        farClip: 500,\n        nearClip: 0.1,\n    });\n\n    camera.setLocalPosition(140, 140, 140);\n    camera.lookAt(new pc.Vec3(0, 40, 0));\n\n    // add orbit camera script with mouse and touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            focusEntity: app.root,\n            distanceMax: 400,\n            frameOnStart: false,\n        },\n    });\n\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // move lights along sin based waves around the cylinder\n        pointLightList.forEach(function (light, i) {\n            const angle = (i / pointLightList.length) * Math.PI * 2;\n            const y = Math.sin(time * 0.5 + 7 * angle) * 30 + 70;\n            light.setLocalPosition(\n                30 * Math.sin(angle),\n                y,\n                30 * Math.cos(angle)\n            );\n        });\n\n        // rotate spot lights around\n        spotLightList.forEach(function (spotlight, i) {\n            const angle = (i / spotLightList.length) * Math.PI * 2;\n            spotlight.setLocalPosition(\n                40 * Math.sin(time + angle),\n                5,\n                40 * Math.cos(time + angle)\n            );\n            spotlight.lookAt(pc.Vec3.ZERO);\n            spotlight.rotateLocal(90, 0, 0);\n        });\n\n        // rotate directional light\n        if (dirLight) {\n            dirLight.setLocalEulerAngles(25, -30 * time, 0);\n        }\n    });\n}\n',nameSlug:"clustered-lighting",categorySlug:"graphics"},"clustered-omni-shadows":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any, data: any): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // set up some general scene rendering properties\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    data.set(\'settings\', {\n        shadowAtlasResolution: 1300,     // shadow map resolution storing all shadows\n        shadowType: pc.SHADOW_PCF3,      // shadow filter type\n        shadowsEnabled: true,\n        cookiesEnabled: true\n    });\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // enabled clustered lighting. This is a temporary API and will change in the future\n    // @ts-ignore engine-tsd\n    app.scene.clusteredLightingEnabled = true;\n\n    // adjust default clustered lighting parameters to handle many lights:\n    // @ts-ignore\n    const lighting = app.scene.lighting;\n\n    // 1) subdivide space with lights into this many cells:\n    // @ts-ignore engine-tsd\n    lighting.cells = new pc.Vec3(16, 12, 16);\n\n    // 2) and allow this many lights per cell:\n    // @ts-ignore engine-tsd\n    lighting.maxLightsPerCell = 12;\n\n    // enable clustered shadows (it\'s enabled by default as well)\n    // @ts-ignore engine-tsd\n    lighting.shadowsEnabled = true;\n\n    // enable clustered cookies\n    // @ts-ignore engine-tsd\n    lighting.cookiesEnabled = true;\n\n    // resolution of the shadow and cookie atlas\n    lighting.shadowAtlasResolution = data.get(\'settings.shadowAtlasResolution\');\n    lighting.cookieAtlasResolution = 2048;\n\n    // helper function to create a 3d primitive including its material\n    function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3) {\n\n        // create a material\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(0.7, 0.7, 0.7);\n\n        // normal map\n        material.normalMap = assets.normal.resource;\n        material.normalMapTiling.set(5, 5);\n        material.bumpiness = 0.7;\n\n        // enable specular\n        material.shininess = 40;\n        material.metalness = 0.3;\n        material.useMetalness = true;\n\n        material.update();\n\n        // create the primitive using the material\n        const primitive = new pc.Entity();\n        primitive.addComponent(\'render\', {\n            type: primitiveType,\n            material: material\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create the ground plane from the boxes\n    createPrimitive("box", new pc.Vec3(0, 0, 0), new pc.Vec3(800, 2, 800));\n    createPrimitive("box", new pc.Vec3(0, 400, 0), new pc.Vec3(800, 2, 800));\n\n    // walls\n    createPrimitive("box", new pc.Vec3(400, 200, 0), new pc.Vec3(2, 400, 800));\n    createPrimitive("box", new pc.Vec3(-400, 200, 0), new pc.Vec3(2, 400, 800));\n    createPrimitive("box", new pc.Vec3(0, 200, 400), new pc.Vec3(800, 400, 0));\n    createPrimitive("box", new pc.Vec3(0, 200, -400), new pc.Vec3(800, 400, 0));\n\n    const numTowers = 7;\n    for (let i = 0; i < numTowers; i++) {\n        let scale = 25;\n        const fraction = i / numTowers * Math.PI * 2;\n        const radius = (i % 2) ? 340 : 210;\n        for (let y = 0; y <= 7; y++) {\n            const prim = createPrimitive("box", new pc.Vec3(radius * Math.sin(fraction), 2 + y * 25, radius * Math.cos(fraction)), new pc.Vec3(scale, scale, scale));\n            prim.setLocalEulerAngles(Math.random() * 360, Math.random() * 360, Math.random() * 360);\n        }\n        scale -= 1.5;\n    }\n\n    // construct the cubemap asset for the omni light cookie texture\n    // Note: the textures array could contain 6 texture asset names to load instead as well\n    const cubemapAsset = new pc.Asset(\'xmas_cubemap\', \'cubemap\', null, {\n        textures: [\n            assets.xmas_posx.id, assets.xmas_negx.id,\n            assets.xmas_posy.id, assets.xmas_negy.id,\n            assets.xmas_posz.id, assets.xmas_negz.id\n        ]\n    });\n    // @ts-ignore engine-tsd\n    cubemapAsset.loadFaces = true;\n    app.assets.add(cubemapAsset);\n\n    const omniLights: Array<pc.Entity> = [];\n    const numLights = 10;\n    for (let i = 0; i < numLights; i++) {\n        const lightOmni = new pc.Entity("Omni");\n        lightOmni.addComponent("light", {\n            type: "omni",\n            color: pc.Color.WHITE,\n            intensity: 10 / numLights,\n            range: 350,\n            castShadows: true,\n            shadowBias: 0.2,\n            normalOffsetBias: 0.2,\n\n            // cookie texture\n            cookieAsset: cubemapAsset,\n            cookieChannel: "rgb"\n        });\n\n        // attach a render component with a small sphere to it\n        const material = new pc.StandardMaterial();\n        material.emissive = pc.Color.WHITE;\n        material.update();\n\n        lightOmni.addComponent(\'render\', {\n            type: "sphere",\n            material: material,\n            castShadows: false\n        });\n        lightOmni.setPosition(0, 120, 0);\n        lightOmni.setLocalScale(5, 5, 5);\n        app.root.addChild(lightOmni);\n\n        omniLights.push(lightOmni);\n    }\n\n    // create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        fov: 80,\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n        farClip: 1500\n    });\n\n    // and position it in the world\n    camera.setLocalPosition(300, 120, 25);\n\n    // add orbit camera script with a mouse and a touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            focusEntity: app.root,\n            distanceMax: 1200,\n            frameOnStart: false\n        }\n    });\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // handle HUD changes - update properties on the scene\n    data.on(\'*:set\', (path: string, value: any) => {\n        const pathArray = path.split(\'.\');\n        // @ts-ignore\n        lighting[pathArray[1]] = value;\n    });\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    app.on("update", function (dt: number) {\n        time += dt * 0.3;\n        const radius = 250;\n        for (let i = 0; i < omniLights.length; i++) {\n            const fraction = i / omniLights.length * Math.PI * 2;\n            omniLights[i].setPosition(radius * Math.sin(time + fraction), 190 + Math.sin(time + fraction) * 150, radius * Math.cos(time + fraction));\n        }\n\n        // display shadow texture (debug feature, only works when depth is stored as color, which is webgl1)\n        // app.drawTexture(-0.7, 0.7, 0.4, 0.4, app.renderer.lightTextureAtlas.shadowMap.texture);\n\n        // display cookie texture (debug feature)\n        // app.drawTexture(-0.7, 0.2, 0.4, 0.4, app.renderer.lightTextureAtlas.cookieAtlas);\n    });\n}',javaScriptFunction:'function example(canvas, assets, data) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // set up some general scene rendering properties\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    data.set("settings", {\n        shadowAtlasResolution: 1300, // shadow map resolution storing all shadows\n        shadowType: pc.SHADOW_PCF3, // shadow filter type\n        shadowsEnabled: true,\n        cookiesEnabled: true,\n    });\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // enabled clustered lighting. This is a temporary API and will change in the future\n    // @ts-ignore engine-tsd\n    app.scene.clusteredLightingEnabled = true;\n\n    // adjust default clustered lighting parameters to handle many lights:\n    // @ts-ignore\n    const lighting = app.scene.lighting;\n\n    // 1) subdivide space with lights into this many cells:\n    // @ts-ignore engine-tsd\n    lighting.cells = new pc.Vec3(16, 12, 16);\n\n    // 2) and allow this many lights per cell:\n    // @ts-ignore engine-tsd\n    lighting.maxLightsPerCell = 12;\n\n    // enable clustered shadows (it\'s enabled by default as well)\n    // @ts-ignore engine-tsd\n    lighting.shadowsEnabled = true;\n\n    // enable clustered cookies\n    // @ts-ignore engine-tsd\n    lighting.cookiesEnabled = true;\n\n    // resolution of the shadow and cookie atlas\n    lighting.shadowAtlasResolution = data.get("settings.shadowAtlasResolution");\n    lighting.cookieAtlasResolution = 2048;\n\n    // helper function to create a 3d primitive including its material\n    function createPrimitive(primitiveType, position, scale) {\n        // create a material\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(0.7, 0.7, 0.7);\n\n        // normal map\n        material.normalMap = assets.normal.resource;\n        material.normalMapTiling.set(5, 5);\n        material.bumpiness = 0.7;\n\n        // enable specular\n        material.shininess = 40;\n        material.metalness = 0.3;\n        material.useMetalness = true;\n\n        material.update();\n\n        // create the primitive using the material\n        const primitive = new pc.Entity();\n        primitive.addComponent("render", {\n            type: primitiveType,\n            material: material,\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create the ground plane from the boxes\n    createPrimitive("box", new pc.Vec3(0, 0, 0), new pc.Vec3(800, 2, 800));\n    createPrimitive("box", new pc.Vec3(0, 400, 0), new pc.Vec3(800, 2, 800));\n\n    // walls\n    createPrimitive("box", new pc.Vec3(400, 200, 0), new pc.Vec3(2, 400, 800));\n    createPrimitive("box", new pc.Vec3(-400, 200, 0), new pc.Vec3(2, 400, 800));\n    createPrimitive("box", new pc.Vec3(0, 200, 400), new pc.Vec3(800, 400, 0));\n    createPrimitive("box", new pc.Vec3(0, 200, -400), new pc.Vec3(800, 400, 0));\n\n    const numTowers = 7;\n    for (let i = 0; i < numTowers; i++) {\n        let scale = 25;\n        const fraction = (i / numTowers) * Math.PI * 2;\n        const radius = i % 2 ? 340 : 210;\n        for (let y = 0; y <= 7; y++) {\n            const prim = createPrimitive(\n                "box",\n                new pc.Vec3(\n                    radius * Math.sin(fraction),\n                    2 + y * 25,\n                    radius * Math.cos(fraction)\n                ),\n                new pc.Vec3(scale, scale, scale)\n            );\n            prim.setLocalEulerAngles(\n                Math.random() * 360,\n                Math.random() * 360,\n                Math.random() * 360\n            );\n        }\n        scale -= 1.5;\n    }\n\n    // construct the cubemap asset for the omni light cookie texture\n    // Note: the textures array could contain 6 texture asset names to load instead as well\n    const cubemapAsset = new pc.Asset("xmas_cubemap", "cubemap", null, {\n        textures: [\n            assets.xmas_posx.id,\n            assets.xmas_negx.id,\n            assets.xmas_posy.id,\n            assets.xmas_negy.id,\n            assets.xmas_posz.id,\n            assets.xmas_negz.id,\n        ],\n    });\n\n    // @ts-ignore engine-tsd\n    cubemapAsset.loadFaces = true;\n    app.assets.add(cubemapAsset);\n\n    const omniLights = [];\n    const numLights = 10;\n    for (let i = 0; i < numLights; i++) {\n        const lightOmni = new pc.Entity("Omni");\n        lightOmni.addComponent("light", {\n            type: "omni",\n            color: pc.Color.WHITE,\n            intensity: 10 / numLights,\n            range: 350,\n            castShadows: true,\n            shadowBias: 0.2,\n            normalOffsetBias: 0.2,\n\n            // cookie texture\n            cookieAsset: cubemapAsset,\n            cookieChannel: "rgb",\n        });\n\n        // attach a render component with a small sphere to it\n        const material = new pc.StandardMaterial();\n        material.emissive = pc.Color.WHITE;\n        material.update();\n\n        lightOmni.addComponent("render", {\n            type: "sphere",\n            material: material,\n            castShadows: false,\n        });\n\n        lightOmni.setPosition(0, 120, 0);\n        lightOmni.setLocalScale(5, 5, 5);\n        app.root.addChild(lightOmni);\n\n        omniLights.push(lightOmni);\n    }\n\n    // create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        fov: 80,\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n        farClip: 1500,\n    });\n\n    // and position it in the world\n    camera.setLocalPosition(300, 120, 25);\n\n    // add orbit camera script with a mouse and a touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            focusEntity: app.root,\n            distanceMax: 1200,\n            frameOnStart: false,\n        },\n    });\n\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // handle HUD changes - update properties on the scene\n    data.on("*:set", (path, value) => {\n        const pathArray = path.split(".");\n        // @ts-ignore\n        lighting[pathArray[1]] = value;\n    });\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt * 0.3;\n        const radius = 250;\n        for (let i = 0; i < omniLights.length; i++) {\n            const fraction = (i / omniLights.length) * Math.PI * 2;\n            omniLights[i].setPosition(\n                radius * Math.sin(time + fraction),\n                190 + Math.sin(time + fraction) * 150,\n                radius * Math.cos(time + fraction)\n            );\n        }\n\n        // display shadow texture (debug feature, only works when depth is stored as color, which is webgl1)\n        // app.drawTexture(-0.7, 0.7, 0.4, 0.4, app.renderer.lightTextureAtlas.shadowMap.texture);\n\n        // display cookie texture (debug feature)\n        // app.drawTexture(-0.7, 0.2, 0.4, 0.4, app.renderer.lightTextureAtlas.cookieAtlas);\n    });\n}\n',nameSlug:"clustered-omni-shadows",categorySlug:"graphics"},"clustered-spot-shadows":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any, data: any): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    data.set(\'settings\', {\n        shadowAtlasResolution: 1024,     // shadow map resolution storing all shadows\n        shadowType: pc.SHADOW_PCF3,      // shadow filter type\n        shadowsEnabled: true,\n        cookiesEnabled: true,\n        numLights: 0,\n        debug: false,\n        debugAtlas: false,\n        splitOptions: 0,\n        static: false\n    });\n\n    // setup skydome as ambient light\n    app.scene.skyboxMip = 3;\n    app.scene.skyboxIntensity = 0.1;\n    app.scene.setSkybox(assets.cubemap.resources);\n\n    // enabled clustered lighting. This is a temporary API and will change in the future\n    // @ts-ignore engine-tsd\n    app.scene.clusteredLightingEnabled = true;\n\n    // adjust default clustered lighting parameters to handle many lights:\n    // @ts-ignore\n    const lighting = app.scene.lighting;\n\n    // 1) subdivide space with lights into this many cells:\n    // @ts-ignore engine-tsd\n    lighting.cells = new pc.Vec3(12, 4, 12);\n\n    // 2) and allow this many lights per cell:\n    // @ts-ignore engine-tsd\n    const maxLights = 24;\n    lighting.maxLightsPerCell = maxLights;\n\n    // enable clustered shadows (it\'s enabled by default as well)\n    // @ts-ignore engine-tsd\n    lighting.shadowsEnabled = true;\n\n    // enable clustered cookies\n    // @ts-ignore engine-tsd\n    lighting.cookiesEnabled = true;\n\n    // resolution of the shadow and cookie atlas\n    lighting.shadowAtlasResolution = data.get(\'settings.shadowAtlasResolution\');\n    lighting.cookieAtlasResolution = 1500;\n\n    const splitOptions = [\n        null,               // automatic - split atlas each frame to give all required lights an equal size\n        [2, 1, 1, 2, 1],    // 7 shadows: split atlas to 2x2 (first number), and split created quarters to 1x1, 1x1, 2x2, 1x1\n        [3, 2],             // 12 shadows: split atlas to 3x3 (first number), and split one of the created parts to 2x2\n        [4]                 // 16 shadows: split atlas to 4x4\n    ];\n\n    // lights are static (not moving and so do not need to update shadows) or dynamic\n    let lightsStatic = false;\n\n    // debug rendering is enabled\n    let debugAtlas = false;\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // ground material\n    const groundMaterial = new pc.StandardMaterial();\n    groundMaterial.shininess = 25;\n    groundMaterial.metalness = 0.4;\n    groundMaterial.useMetalness = true;\n\n    // normal map\n    groundMaterial.normalMap = assets.normal.resource;\n    groundMaterial.normalMapTiling.set(10, 10);\n    groundMaterial.bumpiness = 0.5;\n\n    groundMaterial.update();\n\n    // helper function to create a 3d primitive including its material\n    function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3) {\n\n        // create the primitive using the material\n        const primitive = new pc.Entity();\n        primitive.addComponent(\'render\', {\n            type: primitiveType,\n            castShadows: true,\n            material: groundMaterial\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create some visible geometry\n    const ground = createPrimitive("box", new pc.Vec3(0, 0, 0), new pc.Vec3(500, 0, 500));\n\n    const numTowers = 8;\n    for (let i = 0; i < numTowers; i++) {\n        let scale = 12;\n        const fraction = i / numTowers * Math.PI * 2;\n        const radius = 200;\n        const numCubes = 12;\n        for (let y = 0; y <= 10; y++) {\n            const elevationRadius = radius * (1 - (y / numCubes));\n            const pos = new pc.Vec3(elevationRadius * Math.sin(fraction), y * 6, elevationRadius * Math.cos(fraction));\n            const prim = createPrimitive("box", pos, new pc.Vec3(scale, scale, scale));\n            prim.setLocalEulerAngles(Math.random() * 360, Math.random() * 360, Math.random() * 360);\n        }\n        scale -= 1.5;\n    }\n\n    const spotLightList: Array<pc.Entity> = [];\n    const cookieChannels = ["r", "g", "b", "a", "rgb"];\n\n    // helper function to create a light\n    function createLight(index: number) {\n        const intensity = 1.5;\n        const color = new pc.Color(intensity * Math.random(), intensity * Math.random(), intensity * Math.random(), 1);\n        const lightSpot = new pc.Entity(`Spot-${index}`);\n        const heartTexture = Math.random() < 0.5;\n        const cookieTexture = heartTexture ? assets.heart : assets.channels;\n        const cookieChannel = heartTexture ? "a" : cookieChannels[Math.floor(Math.random() * cookieChannels.length)];\n\n        lightSpot.addComponent("light", {\n            type: "spot",\n            color: color,\n            intensity: 3,\n            innerConeAngle: 30,\n            outerConeAngle: 35,\n            range: 150,\n            castShadows: true,\n            shadowBias: 0.4,\n            normalOffsetBias: 0.1,\n            shadowResolution: 512,      // only used when clustering is off\n\n            // when lights are static, only render shadows one time (or as needed when they use different atlas slot)\n            shadowUpdateMode: lightsStatic ? pc.SHADOWUPDATE_THISFRAME : pc.SHADOWUPDATE_REALTIME,\n\n            // cookie texture\n            cookie: cookieTexture.resource,\n            cookieChannel: cookieChannel,\n            cookieIntensity: 0.5\n        });\n\n        // attach a render component with a small cone to each light\n        const material = new pc.StandardMaterial();\n        material.emissive = color;\n        material.update();\n\n        lightSpot.addComponent(\'render\', {\n            type: "cone",\n            material: material,\n            castShadows: false\n        });\n        lightSpot.setLocalScale(5, 5, 5);\n        app.root.addChild(lightSpot);\n        spotLightList.push(lightSpot);\n    }\n\n    // create many spot lights\n    const count = 10;\n    for (let i = 0; i < count; i++) {\n        createLight(i);\n    }\n    updateLightCount();\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2),\n        farClip: 2000,\n        nearClip: 1\n    });\n    app.root.addChild(camera);\n    camera.setLocalPosition(300 * Math.sin(0), 150, 300 * Math.cos(0));\n\n    // add orbit camera script with mouse and touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            focusEntity: ground,\n            distanceMax: 1200,\n            frameOnStart: false\n        }\n    });\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n\n    // handle HUD changes - update properties on the scene\n    data.on(\'*:set\', (path: string, value: any) => {\n        const pathArray = path.split(\'.\');\n        if (pathArray[1] === \'static\') {\n\n            lightsStatic = value;\n            updateLightCount();\n\n        } else if (pathArray[1] === \'atlasSplit\') {\n\n            // assign atlas split option\n            lighting.atlasSplit = splitOptions[value];\n\n        } else if (pathArray[1] === \'debug\') {\n\n            // debug rendering of lighting clusters on world layer\n            lighting.debugLayer = value ? app.scene.layers.getLayerByName("World").id : undefined;\n\n        } else if (pathArray[1] === \'debugAtlas\') {\n\n            // show debug atlas\n            debugAtlas = value;\n\n        } else {\n            // @ts-ignore\n            lighting[pathArray[1]] = value;\n        }\n    });\n\n    function updateLightCount() {\n\n        // update the number on HUD\n        data.set(\'settings.numLights\', spotLightList.length);\n\n        // shadow update mode (need to force render shadow when we add / remove light, as they all move)\n        spotLightList.forEach((spot) => {\n            spot.light.shadowUpdateMode = lightsStatic ? pc.SHADOWUPDATE_THISFRAME : pc.SHADOWUPDATE_REALTIME;\n        });\n    }\n\n    // add light button handler\n    data.on(\'add\', function () {\n        if (spotLightList.length < maxLights) {\n            createLight(spotLightList.length);\n            updateLightCount();\n        }\n    });\n\n    // remove light button handler\n    data.on(\'remove\', function () {\n        if (spotLightList.length) {\n            const light = spotLightList.pop();\n            app.root.removeChild(light);\n            light.destroy();\n            updateLightCount();\n        }\n    });\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    app.on("update", function (dt: number) {\n\n        // don\'t move lights around when they\'re static\n        if (!lightsStatic) {\n            time += dt * 0.15;\n        }\n\n        // rotate spot lights around\n        const lightPos = new pc.Vec3();\n        spotLightList.forEach(function (spotlight, i) {\n            const angle = (i / spotLightList.length) * Math.PI * 2;\n            const x = 130 * Math.sin(angle + time);\n            const z = 130 * Math.cos(angle + time);\n            lightPos.set(x, 100, z);\n            spotlight.setLocalPosition(lightPos);\n\n            lightPos.y = 0;\n            spotlight.lookAt(lightPos, pc.Vec3.RIGHT);\n\n            spotlight.rotateLocal(90, 0, 0);\n        });\n\n        // display shadow texture (debug feature, only works when depth is stored as color, which is webgl1)\n        // app.drawTexture(-0.7, 0.7, 0.4, 0.4, app.renderer.lightTextureAtlas.shadowAtlas.texture);\n\n        // display cookie texture (debug feature)\n        if (debugAtlas) {\n            // @ts-ignore engine-tsd\n            app.drawTexture(-0.7, 0.2, 0.4, 0.4, app.renderer.lightTextureAtlas.cookieAtlas);\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets, data) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    data.set("settings", {\n        shadowAtlasResolution: 1024, // shadow map resolution storing all shadows\n        shadowType: pc.SHADOW_PCF3, // shadow filter type\n        shadowsEnabled: true,\n        cookiesEnabled: true,\n        numLights: 0,\n        debug: false,\n        debugAtlas: false,\n        splitOptions: 0,\n        static: false,\n    });\n\n    // setup skydome as ambient light\n    app.scene.skyboxMip = 3;\n    app.scene.skyboxIntensity = 0.1;\n    app.scene.setSkybox(assets.cubemap.resources);\n\n    // enabled clustered lighting. This is a temporary API and will change in the future\n    // @ts-ignore engine-tsd\n    app.scene.clusteredLightingEnabled = true;\n\n    // adjust default clustered lighting parameters to handle many lights:\n    // @ts-ignore\n    const lighting = app.scene.lighting;\n\n    // 1) subdivide space with lights into this many cells:\n    // @ts-ignore engine-tsd\n    lighting.cells = new pc.Vec3(12, 4, 12);\n\n    // 2) and allow this many lights per cell:\n    // @ts-ignore engine-tsd\n    const maxLights = 24;\n    lighting.maxLightsPerCell = maxLights;\n\n    // enable clustered shadows (it\'s enabled by default as well)\n    // @ts-ignore engine-tsd\n    lighting.shadowsEnabled = true;\n\n    // enable clustered cookies\n    // @ts-ignore engine-tsd\n    lighting.cookiesEnabled = true;\n\n    // resolution of the shadow and cookie atlas\n    lighting.shadowAtlasResolution = data.get("settings.shadowAtlasResolution");\n    lighting.cookieAtlasResolution = 1500;\n\n    const splitOptions = [\n        null, // automatic - split atlas each frame to give all required lights an equal size\n        [2, 1, 1, 2, 1], // 7 shadows: split atlas to 2x2 (first number), and split created quarters to 1x1, 1x1, 2x2, 1x1\n        [3, 2], // 12 shadows: split atlas to 3x3 (first number), and split one of the created parts to 2x2\n        [4], // 16 shadows: split atlas to 4x4\n    ];\n\n    // lights are static (not moving and so do not need to update shadows) or dynamic\n    let lightsStatic = false;\n\n    // debug rendering is enabled\n    let debugAtlas = false;\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // ground material\n    const groundMaterial = new pc.StandardMaterial();\n    groundMaterial.shininess = 25;\n    groundMaterial.metalness = 0.4;\n    groundMaterial.useMetalness = true;\n\n    // normal map\n    groundMaterial.normalMap = assets.normal.resource;\n    groundMaterial.normalMapTiling.set(10, 10);\n    groundMaterial.bumpiness = 0.5;\n\n    groundMaterial.update();\n\n    // helper function to create a 3d primitive including its material\n    function createPrimitive(primitiveType, position, scale) {\n        // create the primitive using the material\n        const primitive = new pc.Entity();\n        primitive.addComponent("render", {\n            type: primitiveType,\n            castShadows: true,\n            material: groundMaterial,\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create some visible geometry\n    const ground = createPrimitive(\n        "box",\n        new pc.Vec3(0, 0, 0),\n        new pc.Vec3(500, 0, 500)\n    );\n\n    const numTowers = 8;\n    for (let i = 0; i < numTowers; i++) {\n        let scale = 12;\n        const fraction = (i / numTowers) * Math.PI * 2;\n        const radius = 200;\n        const numCubes = 12;\n        for (let y = 0; y <= 10; y++) {\n            const elevationRadius = radius * (1 - y / numCubes);\n            const pos = new pc.Vec3(\n                elevationRadius * Math.sin(fraction),\n                y * 6,\n                elevationRadius * Math.cos(fraction)\n            );\n            const prim = createPrimitive(\n                "box",\n                pos,\n                new pc.Vec3(scale, scale, scale)\n            );\n            prim.setLocalEulerAngles(\n                Math.random() * 360,\n                Math.random() * 360,\n                Math.random() * 360\n            );\n        }\n        scale -= 1.5;\n    }\n\n    const spotLightList = [];\n    const cookieChannels = ["r", "g", "b", "a", "rgb"];\n\n    // helper function to create a light\n    function createLight(index) {\n        const intensity = 1.5;\n        const color = new pc.Color(\n            intensity * Math.random(),\n            intensity * Math.random(),\n            intensity * Math.random(),\n            1\n        );\n        const lightSpot = new pc.Entity(`Spot-${index}`);\n        const heartTexture = Math.random() < 0.5;\n        const cookieTexture = heartTexture ? assets.heart : assets.channels;\n        const cookieChannel = heartTexture\n            ? "a"\n            : cookieChannels[Math.floor(Math.random() * cookieChannels.length)];\n\n        lightSpot.addComponent("light", {\n            type: "spot",\n            color: color,\n            intensity: 3,\n            innerConeAngle: 30,\n            outerConeAngle: 35,\n            range: 150,\n            castShadows: true,\n            shadowBias: 0.4,\n            normalOffsetBias: 0.1,\n            shadowResolution: 512, // only used when clustering is off\n\n            // when lights are static, only render shadows one time (or as needed when they use different atlas slot)\n            shadowUpdateMode: lightsStatic\n                ? pc.SHADOWUPDATE_THISFRAME\n                : pc.SHADOWUPDATE_REALTIME,\n\n            // cookie texture\n            cookie: cookieTexture.resource,\n            cookieChannel: cookieChannel,\n            cookieIntensity: 0.5,\n        });\n\n        // attach a render component with a small cone to each light\n        const material = new pc.StandardMaterial();\n        material.emissive = color;\n        material.update();\n\n        lightSpot.addComponent("render", {\n            type: "cone",\n            material: material,\n            castShadows: false,\n        });\n\n        lightSpot.setLocalScale(5, 5, 5);\n        app.root.addChild(lightSpot);\n        spotLightList.push(lightSpot);\n    }\n\n    // create many spot lights\n    const count = 10;\n    for (let i = 0; i < count; i++) {\n        createLight(i);\n    }\n    updateLightCount();\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2),\n        farClip: 2000,\n        nearClip: 1,\n    });\n\n    app.root.addChild(camera);\n    camera.setLocalPosition(300 * Math.sin(0), 150, 300 * Math.cos(0));\n\n    // add orbit camera script with mouse and touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            focusEntity: ground,\n            distanceMax: 1200,\n            frameOnStart: false,\n        },\n    });\n\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n\n    // handle HUD changes - update properties on the scene\n    data.on("*:set", (path, value) => {\n        const pathArray = path.split(".");\n        if (pathArray[1] === "static") {\n            lightsStatic = value;\n            updateLightCount();\n        } else if (pathArray[1] === "atlasSplit") {\n            // assign atlas split option\n            lighting.atlasSplit = splitOptions[value];\n        } else if (pathArray[1] === "debug") {\n            // debug rendering of lighting clusters on world layer\n            lighting.debugLayer = value\n                ? app.scene.layers.getLayerByName("World").id\n                : undefined;\n        } else if (pathArray[1] === "debugAtlas") {\n            // show debug atlas\n            debugAtlas = value;\n        } else {\n            // @ts-ignore\n            lighting[pathArray[1]] = value;\n        }\n    });\n\n    function updateLightCount() {\n        // update the number on HUD\n        data.set("settings.numLights", spotLightList.length);\n\n        // shadow update mode (need to force render shadow when we add / remove light, as they all move)\n        spotLightList.forEach((spot) => {\n            spot.light.shadowUpdateMode = lightsStatic\n                ? pc.SHADOWUPDATE_THISFRAME\n                : pc.SHADOWUPDATE_REALTIME;\n        });\n    }\n\n    // add light button handler\n    data.on("add", function () {\n        if (spotLightList.length < maxLights) {\n            createLight(spotLightList.length);\n            updateLightCount();\n        }\n    });\n\n    // remove light button handler\n    data.on("remove", function () {\n        if (spotLightList.length) {\n            const light = spotLightList.pop();\n            app.root.removeChild(light);\n            light.destroy();\n            updateLightCount();\n        }\n    });\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    app.on("update", function (dt) {\n        // don\'t move lights around when they\'re static\n        if (!lightsStatic) {\n            time += dt * 0.15;\n        }\n\n        // rotate spot lights around\n        const lightPos = new pc.Vec3();\n        spotLightList.forEach(function (spotlight, i) {\n            const angle = (i / spotLightList.length) * Math.PI * 2;\n            const x = 130 * Math.sin(angle + time);\n            const z = 130 * Math.cos(angle + time);\n            lightPos.set(x, 100, z);\n            spotlight.setLocalPosition(lightPos);\n\n            lightPos.y = 0;\n            spotlight.lookAt(lightPos, pc.Vec3.RIGHT);\n\n            spotlight.rotateLocal(90, 0, 0);\n        });\n\n        // display shadow texture (debug feature, only works when depth is stored as color, which is webgl1)\n        // app.drawTexture(-0.7, 0.7, 0.4, 0.4, app.renderer.lightTextureAtlas.shadowAtlas.texture);\n\n        // display cookie texture (debug feature)\n        if (debugAtlas) {\n            // @ts-ignore engine-tsd\n            app.drawTexture(\n                -0.7,\n                0.2,\n                0.4,\n                0.4,\n                app.renderer.lightTextureAtlas.cookieAtlas\n            );\n        }\n    });\n}\n',nameSlug:"clustered-spot-shadows",categorySlug:"graphics"},"grab-pass":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // setup skydome\n    app.scene.skyboxMip = 0;\n    app.scene.exposure = 2;\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // Render meshes to immediate layer, which renders after skybox - to include skybox in the refraction.\n    // Set up front to back sorting for those meshes - so when we get to render the glass,\n    // object behind it would be rendered already\n    const immediateLayer = app.scene.layers.getLayerByName("Immediate");\n    immediateLayer.opaqueSortMode = pc.SORTMODE_BACK2FRONT;\n\n    // helper function to create a primitive with shape type, position, scale, color\n    function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3, color: pc.Color) {\n        // create material of specified color\n        const material = new pc.StandardMaterial();\n        material.diffuse = color;\n        material.shininess = 60;\n        material.metalness = 0.4;\n        material.useMetalness = true;\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent(\'render\', {\n            type: primitiveType,\n            material: material,\n            layers: [immediateLayer.id]\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create few primitives, keep their references to rotate them later\n    const primitives: any = [];\n    const count = 7;\n    const shapes = ["box", "cone", "cylinder", "sphere", "capsule"];\n    for (let i = 0; i < count; i++) {\n        const shapeName = shapes[Math.floor(Math.random() * shapes.length)];\n        const color = new pc.Color(Math.random(), Math.random(), Math.random());\n        const angle = 2 * Math.PI * i / count;\n        const pos = new pc.Vec3(12 * Math.sin(angle), 0, 12 * Math.cos(angle));\n        primitives.push(createPrimitive(shapeName, pos, new pc.Vec3(4, 8, 4), color));\n    }\n\n    // Create the camera, which renders entities\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2)\n    });\n    app.root.addChild(camera);\n    camera.setLocalPosition(0, 10, 20);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // create a primitive which uses refraction shader to distort the view behind it\n    const glass = createPrimitive("box", new pc.Vec3(1, 3, 0), new pc.Vec3(10, 10, 10), new pc.Color(1, 1, 1));\n    glass.render.castShadows = false;\n    glass.render.receiveShadows = false;\n\n    // @ts-ignore create shader using vertex and fragment shaders\n    const webgl2def = (app.graphicsDevice.webgl2) ? "#define GL2\\n" : "";\n    const shaderDefinition = {\n        attributes: {\n            aPosition: pc.SEMANTIC_POSITION,\n            aUv: pc.SEMANTIC_TEXCOORD0\n        },\n        vshader: assets[\'shader.vert\'].data,\n        fshader: webgl2def + assets[\'shader.frag\'].data\n    };\n\n    // reflection material using the shader\n    const refractionMaterial = new pc.Material();\n    refractionMaterial.shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n    glass.render.material = refractionMaterial;\n\n    // set an offset map on the material\n    refractionMaterial.setParameter(\'uOffsetMap\', assets.normal.resource);\n\n    // set roughness map\n    refractionMaterial.setParameter(\'uRoughnessMap\', assets.roughness.resource);\n\n    refractionMaterial.update();\n    app.start();\n\n    // update things each frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // rotate the primitives\n        primitives.forEach((prim: pc.Entity) => {\n            prim.rotate(0.3, 0.2, 0.1);\n        });\n\n        glass.rotate(-0.1, 0.1, -0.15);\n\n        // orbit the camera\n        camera.setLocalPosition(20 * Math.sin(time * 0.2), 7, 20 * Math.cos(time * 0.2));\n        camera.lookAt(new pc.Vec3(0, 2, 0));\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // setup skydome\n    app.scene.skyboxMip = 0;\n    app.scene.exposure = 2;\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // Render meshes to immediate layer, which renders after skybox - to include skybox in the refraction.\n    // Set up front to back sorting for those meshes - so when we get to render the glass,\n    // object behind it would be rendered already\n    const immediateLayer = app.scene.layers.getLayerByName("Immediate");\n    immediateLayer.opaqueSortMode = pc.SORTMODE_BACK2FRONT;\n\n    // helper function to create a primitive with shape type, position, scale, color\n    function createPrimitive(primitiveType, position, scale, color) {\n        // create material of specified color\n        const material = new pc.StandardMaterial();\n        material.diffuse = color;\n        material.shininess = 60;\n        material.metalness = 0.4;\n        material.useMetalness = true;\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent("render", {\n            type: primitiveType,\n            material: material,\n            layers: [immediateLayer.id],\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create few primitives, keep their references to rotate them later\n    const primitives = [];\n    const count = 7;\n    const shapes = ["box", "cone", "cylinder", "sphere", "capsule"];\n    for (let i = 0; i < count; i++) {\n        const shapeName = shapes[Math.floor(Math.random() * shapes.length)];\n        const color = new pc.Color(Math.random(), Math.random(), Math.random());\n        const angle = (2 * Math.PI * i) / count;\n        const pos = new pc.Vec3(12 * Math.sin(angle), 0, 12 * Math.cos(angle));\n        primitives.push(\n            createPrimitive(shapeName, pos, new pc.Vec3(4, 8, 4), color)\n        );\n    }\n\n    // Create the camera, which renders entities\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2),\n    });\n\n    app.root.addChild(camera);\n    camera.setLocalPosition(0, 10, 20);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // create a primitive which uses refraction shader to distort the view behind it\n    const glass = createPrimitive(\n        "box",\n        new pc.Vec3(1, 3, 0),\n        new pc.Vec3(10, 10, 10),\n        new pc.Color(1, 1, 1)\n    );\n    glass.render.castShadows = false;\n    glass.render.receiveShadows = false;\n\n    // @ts-ignore create shader using vertex and fragment shaders\n    const webgl2def = app.graphicsDevice.webgl2 ? "#define GL2\\n" : "";\n    const shaderDefinition = {\n        attributes: {\n            aPosition: pc.SEMANTIC_POSITION,\n            aUv: pc.SEMANTIC_TEXCOORD0,\n        },\n\n        vshader: assets["shader.vert"].data,\n        fshader: webgl2def + assets["shader.frag"].data,\n    };\n\n    // reflection material using the shader\n    const refractionMaterial = new pc.Material();\n    refractionMaterial.shader = new pc.Shader(\n        app.graphicsDevice,\n        shaderDefinition\n    );\n    glass.render.material = refractionMaterial;\n\n    // set an offset map on the material\n    refractionMaterial.setParameter("uOffsetMap", assets.normal.resource);\n\n    // set roughness map\n    refractionMaterial.setParameter("uRoughnessMap", assets.roughness.resource);\n\n    refractionMaterial.update();\n    app.start();\n\n    // update things each frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // rotate the primitives\n        primitives.forEach((prim) => {\n            prim.rotate(0.3, 0.2, 0.1);\n        });\n\n        glass.rotate(-0.1, 0.1, -0.15);\n\n        // orbit the camera\n        camera.setLocalPosition(\n            20 * Math.sin(time * 0.2),\n            7,\n            20 * Math.cos(time * 0.2)\n        );\n        camera.lookAt(new pc.Vec3(0, 2, 0));\n    });\n}\n',nameSlug:"grab-pass",categorySlug:"graphics"},"hardware-instancing":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: {\'helipad.dds\': pc.Asset}): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // setup skydome\n    app.scene.skyboxMip = 2;\n    app.scene.exposure = 0.3;\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n\n    // set up some general scene rendering properties\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n    });\n    app.root.addChild(camera);\n\n    // Move the camera back to see the cubes\n    camera.translate(0, 0, 10);\n\n    // create standard material and enable instancing on it\n    const material = new pc.StandardMaterial();\n    material.onUpdateShader = function (options) {\n        options.useInstancing = true;\n        return options;\n    };\n    material.shininess = 60;\n    material.metalness = 0.7;\n    material.useMetalness = true;\n    material.update();\n\n    // Create a Entity with a cylinder render component and the instancing material\n    const box = new pc.Entity();\n    box.addComponent("render", {\n        material: material,\n        type: "cylinder"\n    });\n\n    // add the box entity to the hierarchy\n    app.root.addChild(box);\n\n    if (app.graphicsDevice.supportsInstancing) {\n        // number of instances to render\n        const instanceCount = 1000;\n\n        // store matrices for individual instances into array\n        const matrices = new Float32Array(instanceCount * 16);\n        let matrixIndex = 0;\n\n        const radius = 5;\n        const pos = new pc.Vec3();\n        const rot = new pc.Quat();\n        const scl = new pc.Vec3();\n        const matrix = new pc.Mat4();\n\n        for (let i = 0; i < instanceCount; i++) {\n            // generate random positions / scales and rotations\n            pos.set(Math.random() * radius - radius * 0.5, Math.random() * radius - radius * 0.5, Math.random() * radius - radius * 0.5);\n            scl.set(0.1 + Math.random() * 0.1, 0.1 + Math.random() * 0.3, 0.1 + Math.random() * 0.1);\n            rot.setFromEulerAngles(i * 30, i * 50, i * 70);\n            matrix.setTRS(pos, rot, scl);\n\n            // copy matrix elements into array of floats\n            for (let m = 0; m < 16; m++)\n                matrices[matrixIndex++] = matrix.data[m];\n        }\n\n        // create static vertex buffer containing the matrices\n        const vertexBuffer = new pc.VertexBuffer(app.graphicsDevice, pc.VertexFormat.defaultInstancingFormat, instanceCount, pc.BUFFER_STATIC, matrices);\n\n        // initialize instancing using the vertex buffer on meshInstance of the created box\n        const boxMeshInst = box.render.meshInstances[0];\n        boxMeshInst.setInstancing(vertexBuffer);\n    }\n\n    // Set an update function on the app\'s update event\n    let angle = 0;\n    app.on("update", function (dt) {\n        // orbit camera around\n        angle += dt * 0.2;\n        camera.setLocalPosition(8 * Math.sin(angle), 0, 8 * Math.cos(angle));\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // setup skydome\n    app.scene.skyboxMip = 2;\n    app.scene.exposure = 0.3;\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    // set up some general scene rendering properties\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {});\n\n    app.root.addChild(camera);\n\n    // Move the camera back to see the cubes\n    camera.translate(0, 0, 10);\n\n    // create standard material and enable instancing on it\n    const material = new pc.StandardMaterial();\n    material.onUpdateShader = function (options) {\n        options.useInstancing = true;\n        return options;\n    };\n    material.shininess = 60;\n    material.metalness = 0.7;\n    material.useMetalness = true;\n    material.update();\n\n    // Create a Entity with a cylinder render component and the instancing material\n    const box = new pc.Entity();\n    box.addComponent("render", {\n        material: material,\n        type: "cylinder",\n    });\n\n    // add the box entity to the hierarchy\n    app.root.addChild(box);\n\n    if (app.graphicsDevice.supportsInstancing) {\n        // number of instances to render\n        const instanceCount = 1000;\n\n        // store matrices for individual instances into array\n        const matrices = new Float32Array(instanceCount * 16);\n        let matrixIndex = 0;\n\n        const radius = 5;\n        const pos = new pc.Vec3();\n        const rot = new pc.Quat();\n        const scl = new pc.Vec3();\n        const matrix = new pc.Mat4();\n\n        for (let i = 0; i < instanceCount; i++) {\n            // generate random positions / scales and rotations\n            pos.set(\n                Math.random() * radius - radius * 0.5,\n                Math.random() * radius - radius * 0.5,\n                Math.random() * radius - radius * 0.5\n            );\n            scl.set(\n                0.1 + Math.random() * 0.1,\n                0.1 + Math.random() * 0.3,\n                0.1 + Math.random() * 0.1\n            );\n            rot.setFromEulerAngles(i * 30, i * 50, i * 70);\n            matrix.setTRS(pos, rot, scl);\n\n            // copy matrix elements into array of floats\n            for (let m = 0; m < 16; m++)\n                matrices[matrixIndex++] = matrix.data[m];\n        }\n\n        // create static vertex buffer containing the matrices\n        const vertexBuffer = new pc.VertexBuffer(\n            app.graphicsDevice,\n            pc.VertexFormat.defaultInstancingFormat,\n            instanceCount,\n            pc.BUFFER_STATIC,\n            matrices\n        );\n\n        // initialize instancing using the vertex buffer on meshInstance of the created box\n        const boxMeshInst = box.render.meshInstances[0];\n        boxMeshInst.setInstancing(vertexBuffer);\n    }\n\n    // Set an update function on the app\'s update event\n    let angle = 0;\n    app.on("update", function (dt) {\n        // orbit camera around\n        angle += dt * 0.2;\n        camera.setLocalPosition(8 * Math.sin(angle), 0, 8 * Math.cos(angle));\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}\n',nameSlug:"hardware-instancing",categorySlug:"graphics"},hierarchy:{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // helper function to create a primitive with shape type, position, scale\n    function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3) {\n        // create material of random color\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(Math.random(), Math.random(), Math.random());\n        material.update();\n\n        // create primitive with a render component\n        const primitive = new pc.Entity();\n        primitive.addComponent(\'render\', {\n            type: primitiveType,\n            material: material\n        });\n\n        // set position and scale\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n\n        return primitive;\n    }\n\n    // list of all created entities\n    const entities: Array<pc.Entity> = [];\n\n    // helper recursive function to create a next layer of entities for a specified parent\n    function createChildren(parent: pc.Entity, gridSize: number, scale: number, scaleDelta: number, spacing: number, levels: number) {\n        if (levels >= 0) {\n            const offset = spacing * (gridSize - 1) * 0.5;\n            for (let x = 0; x < gridSize; x++) {\n                for (let y = 0; y < gridSize; y++) {\n                    const shape = Math.random() < 0.5 ? "box" : "sphere";\n                    const position = new pc.Vec3(x * spacing - offset, spacing, y * spacing - offset);\n                    const entity = createPrimitive(shape, position, new pc.Vec3(scale, scale, scale));\n\n                    parent.addChild(entity);\n                    entities.push(entity);\n\n                    createChildren(entity, gridSize, scale - scaleDelta, scaleDelta, spacing * 0.7, levels - 1);\n                }\n            }\n        }\n    }\n\n    // dummy root entity\n    const root = new pc.Entity();\n    app.root.addChild(root);\n\n    // generate hierarchy of children entities\n    const levels = 5;\n    const gridSize = 2;\n    const scale = 1.7;\n    const scaleDelta = 0.25;\n    const spacing = 7;\n    createChildren(root, gridSize, scale, scaleDelta, spacing, levels);\n    console.log("number of created entities: " + entities.length);\n\n    // Create main camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n    camera.setLocalPosition(90 * Math.sin(0), 40, 90 * Math.cos(0));\n    camera.lookAt(new pc.Vec3(0, 5, 0));\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 150\n    });\n    light.translate(40, 60, 50);\n    app.root.addChild(light);\n\n    // update each frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // rotation quaternion changing with time\n        const rot = new pc.Quat();\n        rot.setFromEulerAngles(time * 5, time * 13, time * 6);\n\n        // apply it to all entities\n        for (let e = 0; e < entities.length; e++) {\n            entities[e].setLocalRotation(rot);\n        }\n    });\n}',javaScriptFunction:'function example(canvas) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // helper function to create a primitive with shape type, position, scale\n    function createPrimitive(primitiveType, position, scale) {\n        // create material of random color\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(\n            Math.random(),\n            Math.random(),\n            Math.random()\n        );\n        material.update();\n\n        // create primitive with a render component\n        const primitive = new pc.Entity();\n        primitive.addComponent("render", {\n            type: primitiveType,\n            material: material,\n        });\n\n        // set position and scale\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n\n        return primitive;\n    }\n\n    // list of all created entities\n    const entities = [];\n\n    // helper recursive function to create a next layer of entities for a specified parent\n    function createChildren(\n        parent,\n        gridSize,\n        scale,\n        scaleDelta,\n        spacing,\n        levels\n    ) {\n        if (levels >= 0) {\n            const offset = spacing * (gridSize - 1) * 0.5;\n            for (let x = 0; x < gridSize; x++) {\n                for (let y = 0; y < gridSize; y++) {\n                    const shape = Math.random() < 0.5 ? "box" : "sphere";\n                    const position = new pc.Vec3(\n                        x * spacing - offset,\n                        spacing,\n                        y * spacing - offset\n                    );\n                    const entity = createPrimitive(\n                        shape,\n                        position,\n                        new pc.Vec3(scale, scale, scale)\n                    );\n\n                    parent.addChild(entity);\n                    entities.push(entity);\n\n                    createChildren(\n                        entity,\n                        gridSize,\n                        scale - scaleDelta,\n                        scaleDelta,\n                        spacing * 0.7,\n                        levels - 1\n                    );\n                }\n            }\n        }\n    }\n\n    // dummy root entity\n    const root = new pc.Entity();\n    app.root.addChild(root);\n\n    // generate hierarchy of children entities\n    const levels = 5;\n    const gridSize = 2;\n    const scale = 1.7;\n    const scaleDelta = 0.25;\n    const spacing = 7;\n    createChildren(root, gridSize, scale, scaleDelta, spacing, levels);\n    console.log("number of created entities: " + entities.length);\n\n    // Create main camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    camera.setLocalPosition(90 * Math.sin(0), 40, 90 * Math.cos(0));\n    camera.lookAt(new pc.Vec3(0, 5, 0));\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 150,\n    });\n\n    light.translate(40, 60, 50);\n    app.root.addChild(light);\n\n    // update each frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // rotation quaternion changing with time\n        const rot = new pc.Quat();\n        rot.setFromEulerAngles(time * 5, time * 13, time * 6);\n\n        // apply it to all entities\n        for (let e = 0; e < entities.length; e++) {\n            entities[e].setLocalRotation(rot);\n        }\n    });\n}\n',nameSlug:"hierarchy",categorySlug:"graphics"},layers:{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create a new layer to put in front of everything\n    const layer = new pc.Layer({\n        name: "Front Layer"\n    });\n\n    // get the world layer index\n    const worldLayer = app.scene.layers.getLayerByName("World");\n    const idx = app.scene.layers.getTransparentIndex(worldLayer);\n\n    // insert the new layer after the world layer\n    app.scene.layers.insert(layer, idx + 1);\n\n    // Create an Entity with a camera component\n    // Make sure it renders both World and Front Layer\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n        layers: [worldLayer.id, layer.id]\n    });\n    camera.translate(0, 0, 24);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component\n    // Make sure it lights both World and Front Layer\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100,\n        layers: [worldLayer.id, layer.id]\n    });\n    light.translate(5, 0, 15);\n    app.root.addChild(light);\n\n    // red material is semi-transparent\n    const red = new pc.StandardMaterial();\n    red.diffuse.set(1, 0, 0);\n    red.blendType = pc.BLEND_NORMAL;\n    red.opacity = 0.5;\n    red.update();\n\n    // blue material does not test the existing depth buffer\n    const blue = new pc.StandardMaterial();\n    blue.diffuse.set(0, 0, 1);\n    blue.depthTest = false;\n    blue.update();\n\n    // red box is rendered first in World layer\n    const redBox = new pc.Entity();\n    redBox.addComponent(\'model\', {\n        type: \'box\'\n    });\n    redBox.model.material = red;\n    redBox.setLocalScale(5, 5, 5);\n    app.root.addChild(redBox);\n\n    // blue box is rendered in the Front Layer which is after World\n    // because it does not test for depth\n    // and is in a later layer\n    // it is visible even though it should be inside the red box\n    const blueBox = new pc.Entity();\n    blueBox.addComponent(\'model\', {\n        type: \'box\',\n        layers: [layer.id] // try removing this line, the blue box will appear inside the red one\n    });\n    blueBox.model.material = blue;\n    blueBox.setLocalScale(2.5, 2.5, 2.5);\n    app.root.addChild(blueBox);\n\n    app.on("update", function (dt) {\n        if (redBox) {\n            redBox.rotate(0, 10 * dt, 0);\n        }\n        if (blueBox) {\n            blueBox.rotate(0, -10 * dt, 0);\n        }\n\n        blueBox.model.meshInstances[0].layer = 10;\n    });\n}',javaScriptFunction:'function example(canvas) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create a new layer to put in front of everything\n    const layer = new pc.Layer({\n        name: "Front Layer",\n    });\n\n    // get the world layer index\n    const worldLayer = app.scene.layers.getLayerByName("World");\n    const idx = app.scene.layers.getTransparentIndex(worldLayer);\n\n    // insert the new layer after the world layer\n    app.scene.layers.insert(layer, idx + 1);\n\n    // Create an Entity with a camera component\n    // Make sure it renders both World and Front Layer\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n        layers: [worldLayer.id, layer.id],\n    });\n\n    camera.translate(0, 0, 24);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component\n    // Make sure it lights both World and Front Layer\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100,\n        layers: [worldLayer.id, layer.id],\n    });\n\n    light.translate(5, 0, 15);\n    app.root.addChild(light);\n\n    // red material is semi-transparent\n    const red = new pc.StandardMaterial();\n    red.diffuse.set(1, 0, 0);\n    red.blendType = pc.BLEND_NORMAL;\n    red.opacity = 0.5;\n    red.update();\n\n    // blue material does not test the existing depth buffer\n    const blue = new pc.StandardMaterial();\n    blue.diffuse.set(0, 0, 1);\n    blue.depthTest = false;\n    blue.update();\n\n    // red box is rendered first in World layer\n    const redBox = new pc.Entity();\n    redBox.addComponent("model", {\n        type: "box",\n    });\n\n    redBox.model.material = red;\n    redBox.setLocalScale(5, 5, 5);\n    app.root.addChild(redBox);\n\n    // blue box is rendered in the Front Layer which is after World\n    // because it does not test for depth\n    // and is in a later layer\n    // it is visible even though it should be inside the red box\n    const blueBox = new pc.Entity();\n    blueBox.addComponent("model", {\n        type: "box",\n        layers: [layer.id], // try removing this line, the blue box will appear inside the red one\n    });\n    blueBox.model.material = blue;\n    blueBox.setLocalScale(2.5, 2.5, 2.5);\n    app.root.addChild(blueBox);\n\n    app.on("update", function (dt) {\n        if (redBox) {\n            redBox.rotate(0, 10 * dt, 0);\n        }\n        if (blueBox) {\n            blueBox.rotate(0, -10 * dt, 0);\n        }\n\n        blueBox.model.meshInstances[0].layer = 10;\n    });\n}\n',nameSlug:"layers",categorySlug:"graphics"},"lights-baked-a-o":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any, data: any): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body)\n    });\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // setup skydome - this is the main source of ambient light\n    app.scene.skyboxMip = 3;\n    app.scene.skyboxIntensity = 0.6;\n    app.scene.setSkybox(assets.cubemap.resources);\n\n    // if skydome cubemap is disabled using HUD, a constant ambient color is used instead\n    app.scene.ambientLight = new pc.Color(0.1, 0.3, 0.4);\n\n    // instantiate the house model, which has unwrapped texture coordinates for lightmap in UV1\n    const house = assets.house.resource.instantiateRenderEntity();\n    house.setLocalScale(100, 100, 100);\n    app.root.addChild(house);\n\n    // change its materials to lightmapping\n    const renders: Array<pc.RenderComponent> = house.findComponents("render");\n    renders.forEach((render) => {\n        render.castShadows = true;\n        render.castShadowsLightmap = true;\n        render.lightmapped = true;\n    });\n\n    // directional light\n    const lightDirectional = new pc.Entity("Directional");\n    lightDirectional.addComponent("light", {\n        type: "directional",\n        affectDynamic: true,\n        affectLightmapped: true,\n        castShadows: true,\n        normalOffsetBias: 0.05,\n        shadowBias: 0.2,\n        shadowDistance: 100,\n        shadowResolution: 2048,\n        shadowType: pc.SHADOW_PCF3,\n        color: new pc.Color(0.7, 0.7, 0.5),\n        intensity: 1.6\n    });\n    app.root.addChild(lightDirectional);\n    lightDirectional.setLocalEulerAngles(-55, 0, -30);\n\n    // Create an entity with a omni light component that is configured as a baked light\n    const lightOmni = new pc.Entity("Omni");\n    lightOmni.addComponent("light", {\n        type: "omni",\n        affectDynamic: false,\n        affectLightmapped: true,\n        bake: true,\n        castShadows: true,\n        normalOffsetBias: 0.05,\n        shadowBias: 0.2,\n        shadowDistance: 25,\n        shadowResolution: 512,\n        shadowType: pc.SHADOW_PCF3,\n        color: pc.Color.YELLOW,\n        range: 25,\n        intensity: 0.9\n    });\n    lightOmni.setLocalPosition(-4, 10, 5);\n    app.root.addChild(lightOmni);\n\n    // Create an entity with a spot light component that is configured as a baked light\n    const lightSpot = new pc.Entity("Spot");\n    lightSpot.addComponent("light", {\n        type: "spot",\n        affectDynamic: false,\n        affectLightmapped: true,\n        bake: true,\n        castShadows: true,\n        normalOffsetBias: 0.05,\n        shadowBias: 0.2,\n        shadowDistance: 50,\n        shadowResolution: 512,\n        shadowType: pc.SHADOW_PCF3,\n        color: pc.Color.RED,\n        range: 10,\n        intensity: 2.5\n    });\n    lightSpot.setLocalPosition(-5, 10, -7.5);\n    app.root.addChild(lightSpot);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n        farClip: 100,\n        nearClip: 1\n    });\n    camera.setLocalPosition(40, 20, 40);\n\n    // add orbit camera script with a mouse and a touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            focusEntity: house,\n            distanceMax: 60\n        }\n    });\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // lightmap baking properties\n    const bakeType = pc.BAKE_COLOR;\n    app.scene.lightmapMode = bakeType;\n    app.scene.lightmapMaxResolution = 1024;\n\n    // multiplier for lightmap resolution\n    app.scene.lightmapSizeMultiplier = 512;\n\n    // bake when settings are changed only\n    let needBake = false;\n\n    // handle data changes from HUD to modify baking properties\n    data.on(\'*:set\', (path: string, value: any) => {\n        let bakeSettingChanged = true;\n        const pathArray = path.split(\'.\');\n\n        // ambient light\n        if (pathArray[1] === \'ambient\') {\n            if (pathArray[2] === \'cubemap\') {\n                // enable / disable cubemap\n                app.scene.setSkybox(value ? assets.cubemap.resources : null);\n            } else if (pathArray[2] === \'hemisphere\') {\n                // switch between smaller upper hemisphere and full sphere\n                app.scene.ambientBakeSpherePart = value ? 0.4 : 1;\n            } else {\n                // all other values are set directly on the scene\n                // @ts-ignore engine-tsd\n                app.scene[pathArray[2]] = value;\n            }\n        } else if (pathArray[1] === \'directional\') {\n            // @ts-ignore engine-tsd\n            lightDirectional.light[pathArray[2]] = value;\n        } else if (pathArray[1] === \'settings\') {\n            // @ts-ignore engine-tsd\n            app.scene[pathArray[2]] = value;\n        } else if (pathArray[1] === \'other\') {\n            // @ts-ignore engine-tsd\n            lightOmni.light[pathArray[2]] = value;\n            // @ts-ignore engine-tsd\n            lightSpot.light[pathArray[2]] = value;\n        } else {\n            // don\'t rebake if stats change\n            bakeSettingChanged = false;\n        }\n\n        // trigger bake on the next frame if relevant settings were changes\n        needBake ||= bakeSettingChanged;\n    });\n\n    // bake properties connected to the HUD\n    data.set(\'data\', {\n        settings: {\n            lightmapFilterEnabled: true,\n            lightmapFilterRange: 10,\n            lightmapFilterSmoothness: 0.2\n        },\n        ambient: {\n            ambientBake: true,\n            cubemap: true,\n            hemisphere: true,\n            ambientBakeNumSamples: 20,\n            ambientBakeOcclusionContrast: -0.6,\n            ambientBakeOcclusionBrightness: -0.5\n        },\n        directional: {\n            enabled: true,\n            bake: true,\n            bakeNumSamples: 15,\n            bakeArea: 10\n        },\n        other: {\n            enabled: true\n        },\n        stats: {\n            duration: \'\'\n        }\n    });\n\n    // Set an update function on the app\'s update event\n    app.on("update", function (dt) {\n\n        // bake lightmaps when HUD properties change\n        if (needBake) {\n            needBake = false;\n            app.lightmapper.bake(null, bakeType);\n\n            // update stats with the bake duration\n            // @ts-ignore engine-tsd\n            data.set(\'data.stats.duration\', app.lightmapper.stats.totalRenderTime.toFixed(1) + \'ms\');\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets, data) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n    });\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // setup skydome - this is the main source of ambient light\n    app.scene.skyboxMip = 3;\n    app.scene.skyboxIntensity = 0.6;\n    app.scene.setSkybox(assets.cubemap.resources);\n\n    // if skydome cubemap is disabled using HUD, a constant ambient color is used instead\n    app.scene.ambientLight = new pc.Color(0.1, 0.3, 0.4);\n\n    // instantiate the house model, which has unwrapped texture coordinates for lightmap in UV1\n    const house = assets.house.resource.instantiateRenderEntity();\n    house.setLocalScale(100, 100, 100);\n    app.root.addChild(house);\n\n    // change its materials to lightmapping\n    const renders = house.findComponents("render");\n    renders.forEach((render) => {\n        render.castShadows = true;\n        render.castShadowsLightmap = true;\n        render.lightmapped = true;\n    });\n\n    // directional light\n    const lightDirectional = new pc.Entity("Directional");\n    lightDirectional.addComponent("light", {\n        type: "directional",\n        affectDynamic: true,\n        affectLightmapped: true,\n        castShadows: true,\n        normalOffsetBias: 0.05,\n        shadowBias: 0.2,\n        shadowDistance: 100,\n        shadowResolution: 2048,\n        shadowType: pc.SHADOW_PCF3,\n        color: new pc.Color(0.7, 0.7, 0.5),\n        intensity: 1.6,\n    });\n\n    app.root.addChild(lightDirectional);\n    lightDirectional.setLocalEulerAngles(-55, 0, -30);\n\n    // Create an entity with a omni light component that is configured as a baked light\n    const lightOmni = new pc.Entity("Omni");\n    lightOmni.addComponent("light", {\n        type: "omni",\n        affectDynamic: false,\n        affectLightmapped: true,\n        bake: true,\n        castShadows: true,\n        normalOffsetBias: 0.05,\n        shadowBias: 0.2,\n        shadowDistance: 25,\n        shadowResolution: 512,\n        shadowType: pc.SHADOW_PCF3,\n        color: pc.Color.YELLOW,\n        range: 25,\n        intensity: 0.9,\n    });\n\n    lightOmni.setLocalPosition(-4, 10, 5);\n    app.root.addChild(lightOmni);\n\n    // Create an entity with a spot light component that is configured as a baked light\n    const lightSpot = new pc.Entity("Spot");\n    lightSpot.addComponent("light", {\n        type: "spot",\n        affectDynamic: false,\n        affectLightmapped: true,\n        bake: true,\n        castShadows: true,\n        normalOffsetBias: 0.05,\n        shadowBias: 0.2,\n        shadowDistance: 50,\n        shadowResolution: 512,\n        shadowType: pc.SHADOW_PCF3,\n        color: pc.Color.RED,\n        range: 10,\n        intensity: 2.5,\n    });\n\n    lightSpot.setLocalPosition(-5, 10, -7.5);\n    app.root.addChild(lightSpot);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n        farClip: 100,\n        nearClip: 1,\n    });\n\n    camera.setLocalPosition(40, 20, 40);\n\n    // add orbit camera script with a mouse and a touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            focusEntity: house,\n            distanceMax: 60,\n        },\n    });\n\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // lightmap baking properties\n    const bakeType = pc.BAKE_COLOR;\n    app.scene.lightmapMode = bakeType;\n    app.scene.lightmapMaxResolution = 1024;\n\n    // multiplier for lightmap resolution\n    app.scene.lightmapSizeMultiplier = 512;\n\n    // bake when settings are changed only\n    let needBake = false;\n\n    // handle data changes from HUD to modify baking properties\n    data.on("*:set", (path, value) => {\n        let bakeSettingChanged = true;\n        const pathArray = path.split(".");\n\n        // ambient light\n        if (pathArray[1] === "ambient") {\n            if (pathArray[2] === "cubemap") {\n                // enable / disable cubemap\n                app.scene.setSkybox(value ? assets.cubemap.resources : null);\n            } else if (pathArray[2] === "hemisphere") {\n                // switch between smaller upper hemisphere and full sphere\n                app.scene.ambientBakeSpherePart = value ? 0.4 : 1;\n            } else {\n                // all other values are set directly on the scene\n                // @ts-ignore engine-tsd\n                app.scene[pathArray[2]] = value;\n            }\n        } else if (pathArray[1] === "directional") {\n            // @ts-ignore engine-tsd\n            lightDirectional.light[pathArray[2]] = value;\n        } else if (pathArray[1] === "settings") {\n            // @ts-ignore engine-tsd\n            app.scene[pathArray[2]] = value;\n        } else if (pathArray[1] === "other") {\n            // @ts-ignore engine-tsd\n            lightOmni.light[pathArray[2]] = value;\n            // @ts-ignore engine-tsd\n            lightSpot.light[pathArray[2]] = value;\n        } else {\n            // don\'t rebake if stats change\n            bakeSettingChanged = false;\n        }\n\n        // trigger bake on the next frame if relevant settings were changes\n        needBake ||= bakeSettingChanged;\n    });\n\n    // bake properties connected to the HUD\n    data.set("data", {\n        settings: {\n            lightmapFilterEnabled: true,\n            lightmapFilterRange: 10,\n            lightmapFilterSmoothness: 0.2,\n        },\n\n        ambient: {\n            ambientBake: true,\n            cubemap: true,\n            hemisphere: true,\n            ambientBakeNumSamples: 20,\n            ambientBakeOcclusionContrast: -0.6,\n            ambientBakeOcclusionBrightness: -0.5,\n        },\n\n        directional: {\n            enabled: true,\n            bake: true,\n            bakeNumSamples: 15,\n            bakeArea: 10,\n        },\n\n        other: {\n            enabled: true,\n        },\n\n        stats: {\n            duration: "",\n        },\n    });\n\n    // Set an update function on the app\'s update event\n    app.on("update", function (dt) {\n        // bake lightmaps when HUD properties change\n        if (needBake) {\n            needBake = false;\n            app.lightmapper.bake(null, bakeType);\n\n            // update stats with the bake duration\n            // @ts-ignore engine-tsd\n            data.set(\n                "data.stats.duration",\n                app.lightmapper.stats.totalRenderTime.toFixed(1) + "ms"\n            );\n        }\n    });\n}\n',nameSlug:"lights-baked-a-o",categorySlug:"graphics"},"lights-baked":{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // All render component primitive shape types\n    const shapes = ["box", "cone", "cylinder", "sphere", "capsule"];\n\n    for (let i = 0; i < 40; i++) {\n        const shape = shapes[Math.floor(Math.random() * shapes.length)];\n\n        // Create an entity with a render component that is set up to be lightmapped with baked direct lighting\n        const entity = new pc.Entity();\n        entity.addComponent(\'render\', {\n            castShadows: false,\n            castShadowsLightmap: true,\n            lightmapped: true,\n            type: shape\n        });\n        app.root.addChild(entity);\n\n        // random orientation\n        entity.setLocalPosition(Math.random() * 10 - 5, Math.random() * 5, Math.random() * 10 - 5);\n    }\n\n    const ground = new pc.Entity();\n    ground.addComponent(\'render\', {\n        castShadows: false,\n        castShadowsLightmap: false,\n        lightmapped: true,\n        type: "plane"\n    });\n    app.root.addChild(ground);\n    ground.setLocalPosition(0, -1, 0);\n    ground.setLocalScale(40, 40, 40);\n\n    // Create an entity with a directional light component that is configured as a baked light\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        affectDynamic: false,\n        affectLightmapped: true,\n        bake: true,\n        castShadows: true,\n        normalOffsetBias: 0.05,\n        shadowBias: 0.2,\n        shadowDistance: 50,\n        shadowResolution: 2048,\n        shadowType: pc.SHADOW_PCF3,\n        color: pc.Color.GREEN,\n        type: "directional"\n    });\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 30, 0);\n\n    // Create an entity with an omni light component that is configured as a baked light\n    const lightPoint = new pc.Entity();\n    lightPoint.addComponent("light", {\n        affectDynamic: false,\n        affectLightmapped: true,\n        bake: true,\n        castShadows: true,\n        normalOffsetBias: 0.05,\n        shadowBias: 0.2,\n        shadowDistance: 50,\n        shadowResolution: 512,\n        shadowType: pc.SHADOW_PCF3,\n        color: pc.Color.RED,\n        range: 100,\n        type: "point"\n    });\n    lightPoint.setLocalPosition(0, 2, 0);\n    app.root.addChild(lightPoint);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n        farClip: 100,\n        nearClip: 0.05\n    });\n    app.root.addChild(camera);\n\n    // lightmap baking properties\n    app.scene.lightmapMode = pc.BAKE_COLOR;\n    app.scene.lightmapMaxResolution = 2048;\n\n    // For baked lights, this property perhaps has the biggest impact on lightmap resolution:\n    app.scene.lightmapSizeMultiplier = 32;\n\n    // bake lightmaps\n    app.lightmapper.bake(null, pc.BAKE_COLOR);\n\n    // Set an update function on the app\'s update event\n    let time = 4;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // orbit camera\n        camera.setLocalPosition(20 * Math.sin(time * 0.4), 3, 6);\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}',javaScriptFunction:'function example(canvas) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // All render component primitive shape types\n    const shapes = ["box", "cone", "cylinder", "sphere", "capsule"];\n\n    for (let i = 0; i < 40; i++) {\n        const shape = shapes[Math.floor(Math.random() * shapes.length)];\n\n        // Create an entity with a render component that is set up to be lightmapped with baked direct lighting\n        const entity = new pc.Entity();\n        entity.addComponent("render", {\n            castShadows: false,\n            castShadowsLightmap: true,\n            lightmapped: true,\n            type: shape,\n        });\n\n        app.root.addChild(entity);\n\n        // random orientation\n        entity.setLocalPosition(\n            Math.random() * 10 - 5,\n            Math.random() * 5,\n            Math.random() * 10 - 5\n        );\n    }\n\n    const ground = new pc.Entity();\n    ground.addComponent("render", {\n        castShadows: false,\n        castShadowsLightmap: false,\n        lightmapped: true,\n        type: "plane",\n    });\n\n    app.root.addChild(ground);\n    ground.setLocalPosition(0, -1, 0);\n    ground.setLocalScale(40, 40, 40);\n\n    // Create an entity with a directional light component that is configured as a baked light\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        affectDynamic: false,\n        affectLightmapped: true,\n        bake: true,\n        castShadows: true,\n        normalOffsetBias: 0.05,\n        shadowBias: 0.2,\n        shadowDistance: 50,\n        shadowResolution: 2048,\n        shadowType: pc.SHADOW_PCF3,\n        color: pc.Color.GREEN,\n        type: "directional",\n    });\n\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 30, 0);\n\n    // Create an entity with an omni light component that is configured as a baked light\n    const lightPoint = new pc.Entity();\n    lightPoint.addComponent("light", {\n        affectDynamic: false,\n        affectLightmapped: true,\n        bake: true,\n        castShadows: true,\n        normalOffsetBias: 0.05,\n        shadowBias: 0.2,\n        shadowDistance: 50,\n        shadowResolution: 512,\n        shadowType: pc.SHADOW_PCF3,\n        color: pc.Color.RED,\n        range: 100,\n        type: "point",\n    });\n\n    lightPoint.setLocalPosition(0, 2, 0);\n    app.root.addChild(lightPoint);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n        farClip: 100,\n        nearClip: 0.05,\n    });\n\n    app.root.addChild(camera);\n\n    // lightmap baking properties\n    app.scene.lightmapMode = pc.BAKE_COLOR;\n    app.scene.lightmapMaxResolution = 2048;\n\n    // For baked lights, this property perhaps has the biggest impact on lightmap resolution:\n    app.scene.lightmapSizeMultiplier = 32;\n\n    // bake lightmaps\n    app.lightmapper.bake(null, pc.BAKE_COLOR);\n\n    // Set an update function on the app\'s update event\n    let time = 4;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // orbit camera\n        camera.setLocalPosition(20 * Math.sin(time * 0.4), 3, 6);\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}\n',nameSlug:"lights-baked",categorySlug:"graphics"},lights:{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any, data:any): void {\n    function createMaterial(colors: any) {\n        const material: any = new pc.StandardMaterial();\n        for (const param in colors) {\n            material[param] = colors[param];\n        }\n        material.update();\n        return material;\n    }\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        keyboard: new pc.Keyboard(window)\n    });\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // create an entity with the statue\n    const entity = assets.statue.resource.instantiateRenderEntity();\n\n    app.root.addChild(entity);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.translate(0, 15, 35);\n    camera.rotate(-14, 0, 0);\n    app.root.addChild(camera);\n\n    // ground material\n    const material = createMaterial({\n        ambient: pc.Color.GRAY,\n        diffuse: pc.Color.GRAY\n    });\n\n    // Create an Entity for the ground\n    const ground = new pc.Entity();\n    ground.addComponent("render", {\n        type: "box",\n        material: material\n    });\n    ground.setLocalScale(70, 1, 70);\n    ground.setLocalPosition(0, -0.5, 0);\n    app.root.addChild(ground);\n\n    // setup light data\n    data.set(\'lights\', {\n        spot: {\n            enabled: true,\n            intensity: 0.8,\n            cookieIntensity: 1\n        },\n        omni: {\n            enabled: true,\n            intensity: 0.8,\n            cookieIntensity: 1\n        },\n        directional: {\n            enabled: true,\n            intensity: 0.8\n        }\n    });\n\n    const lights: {[key: string]: pc.Entity } = {};\n\n    // Create an spot light\n    lights.spot = new pc.Entity();\n    lights.spot.addComponent("light", {\n        ...{\n            type: "spot",\n            color: pc.Color.WHITE,\n            innerConeAngle: 30,\n            outerConeAngle: 31,\n            range: 100,\n            castShadows: true,\n            shadowBias: 0.05,\n            normalOffsetBias: 0.03,\n            shadowResolution: 2048,\n            // heart texture\'s alpha channel as a cookie texture\n            cookie: assets.heart.resource,\n            cookieChannel: "a"\n        },\n        ...data.get(\'lights.spot\')\n    });\n\n    const cone = new pc.Entity();\n    cone.addComponent("render", {\n        type: "cone",\n        castShadows: false,\n        material: createMaterial({ emissive: pc.Color.WHITE })\n    });\n    lights.spot.addChild(cone);\n    app.root.addChild(lights.spot);\n\n    // construct the cubemap asset for the omni light cookie texture\n    // Note: the textures array could contain 6 texture asset names to load instead as well\n    const cubemapAsset = new pc.Asset(\'xmas_cubemap\', \'cubemap\', null, {\n        textures: [\n            assets.xmas_posx.id, assets.xmas_negx.id,\n            assets.xmas_posy.id, assets.xmas_negy.id,\n            assets.xmas_posz.id, assets.xmas_negz.id\n        ]\n    });\n    // @ts-ignore engine-tsd\n    cubemapAsset.loadFaces = true;\n    app.assets.add(cubemapAsset);\n\n    // Create a omni light\n    lights.omni = new pc.Entity();\n    lights.omni.addComponent("light", {\n        ...{\n            type: "omni",\n            color: pc.Color.YELLOW,\n            castShadows: true,\n            range: 111,\n            cookieAsset: cubemapAsset,\n            cookieChannel: "rgb"\n        },\n        ...data.get(\'lights.omni\')\n    });\n    lights.omni.addComponent("render", {\n        type: "sphere",\n        castShadows: false,\n        material: createMaterial({ diffuse: pc.Color.BLACK, emissive: pc.Color.YELLOW })\n    });\n    app.root.addChild(lights.omni);\n\n    // Create a directional light\n    lights.directional = new pc.Entity();\n    lights.directional.addComponent("light", {\n        ...{\n            type: "directional",\n            color: pc.Color.CYAN,\n            range: 100,\n            shadowDistance: 50,\n            castShadows: true,\n            shadowBias: 0.1,\n            normalOffsetBias: 0.2\n        },\n        ...data.get(\'lights.directional\')\n    });\n    app.root.addChild(lights.directional);\n\n    // Allow user to toggle individual lights\n    app.keyboard.on("keydown", function (e) {\n        // if the user is editing an input field, ignore key presses\n        if (e.element.constructor.name === \'HTMLInputElement\') return;\n        switch (e.key) {\n            case pc.KEY_1:\n                data.set(\'lights.omni.enabled\', !data.get(\'lights.omni.enabled\'));\n                break;\n            case pc.KEY_2:\n                data.set(\'lights.spot.enabled\', !data.get(\'lights.spot.enabled\'));\n                break;\n            case pc.KEY_3:\n                data.set(\'lights.directional.enabled\', !data.get(\'lights.directional.enabled\'));\n                break;\n        }\n    }, this);\n\n    // Simple update loop to rotate the light\n    let angleRad = 1;\n    app.on("update", function (dt) {\n        angleRad += 0.3 * dt;\n        if (entity) {\n\n            lights.spot.lookAt(new pc.Vec3(0, -5, 0));\n            lights.spot.rotateLocal(90, 0, 0);\n            lights.spot.setLocalPosition(15 * Math.sin(angleRad), 25, 15 * Math.cos(angleRad));\n\n            lights.omni.setLocalPosition(5 * Math.sin(-2 * angleRad), 10, 5 * Math.cos(-2 * angleRad));\n            lights.omni.rotate(0, 50 * dt, 0);\n\n            lights.directional.setLocalEulerAngles(45, -60 * angleRad, 0);\n        }\n    });\n\n    data.on(\'*:set\', (path: string, value: any) => {\n        const pathArray = path.split(\'.\');\n        if (pathArray[2] === \'enabled\') {\n            lights[pathArray[1]].enabled = value;\n        } else {\n            // @ts-ignore\n            lights[pathArray[1]].light[pathArray[2]] = value;\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets, data) {\n    function createMaterial(colors) {\n        const material = new pc.StandardMaterial();\n        for (const param in colors) {\n            material[param] = colors[param];\n        }\n        material.update();\n        return material;\n    }\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        keyboard: new pc.Keyboard(window),\n    });\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // create an entity with the statue\n    const entity = assets.statue.resource.instantiateRenderEntity();\n\n    app.root.addChild(entity);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.translate(0, 15, 35);\n    camera.rotate(-14, 0, 0);\n    app.root.addChild(camera);\n\n    // ground material\n    const material = createMaterial({\n        ambient: pc.Color.GRAY,\n        diffuse: pc.Color.GRAY,\n    });\n\n    // Create an Entity for the ground\n    const ground = new pc.Entity();\n    ground.addComponent("render", {\n        type: "box",\n        material: material,\n    });\n\n    ground.setLocalScale(70, 1, 70);\n    ground.setLocalPosition(0, -0.5, 0);\n    app.root.addChild(ground);\n\n    // setup light data\n    data.set("lights", {\n        spot: {\n            enabled: true,\n            intensity: 0.8,\n            cookieIntensity: 1,\n        },\n\n        omni: {\n            enabled: true,\n            intensity: 0.8,\n            cookieIntensity: 1,\n        },\n\n        directional: {\n            enabled: true,\n            intensity: 0.8,\n        },\n    });\n\n    const lights = {};\n\n    // Create an spot light\n    lights.spot = new pc.Entity();\n    lights.spot.addComponent("light", {\n        ...{\n            type: "spot",\n            color: pc.Color.WHITE,\n            innerConeAngle: 30,\n            outerConeAngle: 31,\n            range: 100,\n            castShadows: true,\n            shadowBias: 0.05,\n            normalOffsetBias: 0.03,\n            shadowResolution: 2048,\n            // heart texture\'s alpha channel as a cookie texture\n            cookie: assets.heart.resource,\n            cookieChannel: "a",\n        },\n\n        ...data.get("lights.spot"),\n    });\n\n    const cone = new pc.Entity();\n    cone.addComponent("render", {\n        type: "cone",\n        castShadows: false,\n        material: createMaterial({ emissive: pc.Color.WHITE }),\n    });\n\n    lights.spot.addChild(cone);\n    app.root.addChild(lights.spot);\n\n    // construct the cubemap asset for the omni light cookie texture\n    // Note: the textures array could contain 6 texture asset names to load instead as well\n    const cubemapAsset = new pc.Asset("xmas_cubemap", "cubemap", null, {\n        textures: [\n            assets.xmas_posx.id,\n            assets.xmas_negx.id,\n            assets.xmas_posy.id,\n            assets.xmas_negy.id,\n            assets.xmas_posz.id,\n            assets.xmas_negz.id,\n        ],\n    });\n\n    // @ts-ignore engine-tsd\n    cubemapAsset.loadFaces = true;\n    app.assets.add(cubemapAsset);\n\n    // Create a omni light\n    lights.omni = new pc.Entity();\n    lights.omni.addComponent("light", {\n        ...{\n            type: "omni",\n            color: pc.Color.YELLOW,\n            castShadows: true,\n            range: 111,\n            cookieAsset: cubemapAsset,\n            cookieChannel: "rgb",\n        },\n\n        ...data.get("lights.omni"),\n    });\n\n    lights.omni.addComponent("render", {\n        type: "sphere",\n        castShadows: false,\n        material: createMaterial({\n            diffuse: pc.Color.BLACK,\n            emissive: pc.Color.YELLOW,\n        }),\n    });\n\n    app.root.addChild(lights.omni);\n\n    // Create a directional light\n    lights.directional = new pc.Entity();\n    lights.directional.addComponent("light", {\n        ...{\n            type: "directional",\n            color: pc.Color.CYAN,\n            range: 100,\n            shadowDistance: 50,\n            castShadows: true,\n            shadowBias: 0.1,\n            normalOffsetBias: 0.2,\n        },\n\n        ...data.get("lights.directional"),\n    });\n\n    app.root.addChild(lights.directional);\n\n    // Allow user to toggle individual lights\n    app.keyboard.on(\n        "keydown",\n        function (e) {\n            // if the user is editing an input field, ignore key presses\n            if (e.element.constructor.name === "HTMLInputElement") return;\n            switch (e.key) {\n                case pc.KEY_1:\n                    data.set(\n                        "lights.omni.enabled",\n                        !data.get("lights.omni.enabled")\n                    );\n                    break;\n                case pc.KEY_2:\n                    data.set(\n                        "lights.spot.enabled",\n                        !data.get("lights.spot.enabled")\n                    );\n                    break;\n                case pc.KEY_3:\n                    data.set(\n                        "lights.directional.enabled",\n                        !data.get("lights.directional.enabled")\n                    );\n                    break;\n            }\n        },\n        this\n    );\n\n    // Simple update loop to rotate the light\n    let angleRad = 1;\n    app.on("update", function (dt) {\n        angleRad += 0.3 * dt;\n        if (entity) {\n            lights.spot.lookAt(new pc.Vec3(0, -5, 0));\n            lights.spot.rotateLocal(90, 0, 0);\n            lights.spot.setLocalPosition(\n                15 * Math.sin(angleRad),\n                25,\n                15 * Math.cos(angleRad)\n            );\n\n            lights.omni.setLocalPosition(\n                5 * Math.sin(-2 * angleRad),\n                10,\n                5 * Math.cos(-2 * angleRad)\n            );\n            lights.omni.rotate(0, 50 * dt, 0);\n\n            lights.directional.setLocalEulerAngles(45, -60 * angleRad, 0);\n        }\n    });\n\n    data.on("*:set", (path, value) => {\n        const pathArray = path.split(".");\n        if (pathArray[2] === "enabled") {\n            lights[pathArray[1]].enabled = value;\n        } else {\n            // @ts-ignore\n            lights[pathArray[1]].light[pathArray[2]] = value;\n        }\n    });\n}\n',nameSlug:"lights",categorySlug:"graphics"},lines:{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: {\'helipad.dds\': pc.Asset}): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // setup skydome\n    app.scene.skyboxMip = 2;\n    app.scene.exposure = 0.2;\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n    app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(0, 30, 0);\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n    camera.setLocalPosition(80, 40, 80);\n    camera.lookAt(new pc.Vec3(0, -35, 0));\n    app.root.addChild(camera);\n\n    // Create a directional light\n    const directionallight = new pc.Entity();\n    directionallight.addComponent("light", {\n        type: "directional",\n        color: pc.Color.WHITE,\n        castShadows: false\n    });\n    app.root.addChild(directionallight);\n\n    // create a circle of meshes\n    const meshes: Array<pc.Entity> = [];\n    const numMeshes = 10;\n    for (let i = 0; i < numMeshes; i++) {\n        const entity = new pc.Entity();\n        entity.setLocalScale(4, 4, 4);\n\n        // use material with random color\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(Math.random(), Math.random(), Math.random());\n        material.update();\n\n        // create render component\n        entity.addComponent("render", {\n            type: (i % 2 ? "sphere" : "cylinder"),\n            material: material\n        });\n\n        if (!(i % 2)) {\n            entity.setLocalScale(3, 5, 3);\n        }\n\n        // add entity for rendering\n        app.root.addChild(entity);\n        meshes.push(entity);\n    }\n\n    // helper function to generate elevation of a point with [x, y] coordinates\n    function groundElevation(time: number, x: number, z: number) {\n        return Math.sin(time + 0.2 * x) * 2 + Math.cos(time * 0.2 + 0.5 * z + 0.2 * x);\n    }\n\n    // helper function to generate a color for 3d point by lerping between green and red color\n    // based on its y coordinate\n    function groundColor(color: pc.Color, point: pc.Vec3) {\n        color.lerp(pc.Color.GREEN, pc.Color.RED, pc.math.clamp((point.y + 3) * 0.25, 0, 1));\n    }\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // generate grid of lines - store positions and colors as an arrays of numbers instead of\n        // Vec3s and Colors to improve performance\n        const positions = [];\n        const colors = [];\n\n        // temporary instances for calculations\n        const pt1 = new pc.Vec3();\n        const pt2 = new pc.Vec3();\n        const pt3 = new pc.Vec3();\n        const c1 = new pc.Color();\n        const c2 = new pc.Color();\n        const c3 = new pc.Color();\n\n        for (let x = 1; x < 60; x++) {\n            for (let z = 1; z < 60; z++) {\n\n                // generate 3 points: one start point, one along x and one along z axis\n                pt1.set(x, groundElevation(time, x, z), z);\n                pt2.set(x - 1, groundElevation(time, x - 1, z), z);\n                pt3.set(x, groundElevation(time, x, z - 1), z - 1);\n\n                // generate colors for the 3 points\n                groundColor(c1, pt1);\n                groundColor(c2, pt2);\n                groundColor(c3, pt3);\n\n                // add line connecting points along z axis\n                if (x > 1) {\n                    positions.push(pt1.x, pt1.y, pt1.z, pt2.x, pt2.y, pt2.z);\n                    colors.push(c1.r, c1.g, c1.b, c1.a, c2.r, c2.g, c2.b, c2.a);\n                }\n\n                // add line connecting points along x axis\n                if (z > 1) {\n                    positions.push(pt1.x, pt1.y, pt1.z, pt3.x, pt3.y, pt3.z);\n                    colors.push(c1.r, c1.g, c1.b, c1.a, c3.r, c3.g, c3.b, c3.a);\n                }\n            }\n        }\n\n        // submit the generated arrays of lines and colors for rendering\n        app.drawLineArrays(positions, colors);\n\n        // array of Vec3 and Color classes for different way to render lines\n        const grayLinePositions = [];\n        const grayLineColors = [];\n\n        // handle the array of meshes\n        for (let i = 0; i < numMeshes; i++) {\n\n            // move them equally spaced out around in the circle\n            const offset = i * Math.PI * 2 / numMeshes;\n            const entity = meshes[i];\n            entity.setLocalPosition(\n                30 + 20 * Math.sin(time * 0.2 + offset),\n                5 + 2 * Math.sin(time + 3 * i / numMeshes),\n                30 + 20 * Math.cos(time * 0.2 + offset)\n            );\n\n            // rotate the meshes\n            entity.rotate((i + 1) * dt, 4 * (i + 1) * dt, 6 * (i + 1) * dt);\n\n            // draw a single magenta line from this mesh to the next mesh\n            const nextEntity = meshes[(i + 1) % meshes.length];\n            app.drawLine(entity.getPosition(), nextEntity.getPosition(), pc.Color.MAGENTA);\n\n            // store positions and colors of lines connecting objects to a center point\n            grayLinePositions.push(entity.getPosition(), new pc.Vec3(0, 10, 0));\n            grayLineColors.push(pc.Color.GRAY, pc.Color.GRAY);\n        }\n\n        // render all gray lines\n        app.drawLines(grayLinePositions, grayLineColors);\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // setup skydome\n    app.scene.skyboxMip = 2;\n    app.scene.exposure = 0.2;\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n    app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(0, 30, 0);\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    camera.setLocalPosition(80, 40, 80);\n    camera.lookAt(new pc.Vec3(0, -35, 0));\n    app.root.addChild(camera);\n\n    // Create a directional light\n    const directionallight = new pc.Entity();\n    directionallight.addComponent("light", {\n        type: "directional",\n        color: pc.Color.WHITE,\n        castShadows: false,\n    });\n\n    app.root.addChild(directionallight);\n\n    // create a circle of meshes\n    const meshes = [];\n    const numMeshes = 10;\n    for (let i = 0; i < numMeshes; i++) {\n        const entity = new pc.Entity();\n        entity.setLocalScale(4, 4, 4);\n\n        // use material with random color\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(\n            Math.random(),\n            Math.random(),\n            Math.random()\n        );\n        material.update();\n\n        // create render component\n        entity.addComponent("render", {\n            type: i % 2 ? "sphere" : "cylinder",\n            material: material,\n        });\n\n        if (!(i % 2)) {\n            entity.setLocalScale(3, 5, 3);\n        }\n\n        // add entity for rendering\n        app.root.addChild(entity);\n        meshes.push(entity);\n    }\n\n    // helper function to generate elevation of a point with [x, y] coordinates\n    function groundElevation(time, x, z) {\n        return (\n            Math.sin(time + 0.2 * x) * 2 +\n            Math.cos(time * 0.2 + 0.5 * z + 0.2 * x)\n        );\n    }\n\n    // helper function to generate a color for 3d point by lerping between green and red color\n    // based on its y coordinate\n    function groundColor(color, point) {\n        color.lerp(\n            pc.Color.GREEN,\n            pc.Color.RED,\n            pc.math.clamp((point.y + 3) * 0.25, 0, 1)\n        );\n    }\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // generate grid of lines - store positions and colors as an arrays of numbers instead of\n        // Vec3s and Colors to improve performance\n        const positions = [];\n        const colors = [];\n\n        // temporary instances for calculations\n        const pt1 = new pc.Vec3();\n        const pt2 = new pc.Vec3();\n        const pt3 = new pc.Vec3();\n        const c1 = new pc.Color();\n        const c2 = new pc.Color();\n        const c3 = new pc.Color();\n\n        for (let x = 1; x < 60; x++) {\n            for (let z = 1; z < 60; z++) {\n                // generate 3 points: one start point, one along x and one along z axis\n                pt1.set(x, groundElevation(time, x, z), z);\n                pt2.set(x - 1, groundElevation(time, x - 1, z), z);\n                pt3.set(x, groundElevation(time, x, z - 1), z - 1);\n\n                // generate colors for the 3 points\n                groundColor(c1, pt1);\n                groundColor(c2, pt2);\n                groundColor(c3, pt3);\n\n                // add line connecting points along z axis\n                if (x > 1) {\n                    positions.push(pt1.x, pt1.y, pt1.z, pt2.x, pt2.y, pt2.z);\n                    colors.push(c1.r, c1.g, c1.b, c1.a, c2.r, c2.g, c2.b, c2.a);\n                }\n\n                // add line connecting points along x axis\n                if (z > 1) {\n                    positions.push(pt1.x, pt1.y, pt1.z, pt3.x, pt3.y, pt3.z);\n                    colors.push(c1.r, c1.g, c1.b, c1.a, c3.r, c3.g, c3.b, c3.a);\n                }\n            }\n        }\n\n        // submit the generated arrays of lines and colors for rendering\n        app.drawLineArrays(positions, colors);\n\n        // array of Vec3 and Color classes for different way to render lines\n        const grayLinePositions = [];\n        const grayLineColors = [];\n\n        // handle the array of meshes\n        for (let i = 0; i < numMeshes; i++) {\n            // move them equally spaced out around in the circle\n            const offset = (i * Math.PI * 2) / numMeshes;\n            const entity = meshes[i];\n            entity.setLocalPosition(\n                30 + 20 * Math.sin(time * 0.2 + offset),\n                5 + 2 * Math.sin(time + (3 * i) / numMeshes),\n                30 + 20 * Math.cos(time * 0.2 + offset)\n            );\n\n            // rotate the meshes\n            entity.rotate((i + 1) * dt, 4 * (i + 1) * dt, 6 * (i + 1) * dt);\n\n            // draw a single magenta line from this mesh to the next mesh\n            const nextEntity = meshes[(i + 1) % meshes.length];\n            app.drawLine(\n                entity.getPosition(),\n                nextEntity.getPosition(),\n                pc.Color.MAGENTA\n            );\n\n            // store positions and colors of lines connecting objects to a center point\n            grayLinePositions.push(entity.getPosition(), new pc.Vec3(0, 10, 0));\n            grayLineColors.push(pc.Color.GRAY, pc.Color.GRAY);\n        }\n\n        // render all gray lines\n        app.drawLines(grayLinePositions, grayLineColors);\n    });\n}\n',nameSlug:"lines",categorySlug:"graphics"},"material-anisotropic":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { \'helipad.dds\': pc.Asset, font: pc.Asset }): void {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    // Set the skybox to the 128x128 cubemap mipmap level\n    app.scene.skyboxMip = 1;\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera");\n    camera.translate(0, 6, 6);\n    camera.rotate(-48, 0, 0);\n    app.root.addChild(camera);\n\n    // Create an entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional"\n    });\n    app.root.addChild(light);\n    const e = light.getLocalEulerAngles();\n    light.setLocalEulerAngles(e.x + 90, e.y - 75, e.z);\n\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n\n    const NUM_SPHERES_X = 11;\n    const NUM_SPHERES_Z = 6;\n\n    const createSphere = function (x: number, y: number, z: number) {\n        const material = new pc.StandardMaterial();\n        material.metalness = 1.0;\n        material.shininess = (z) / (NUM_SPHERES_Z - 1) * 100;\n        material.useMetalness = true;\n        material.anisotropy = ((2 * x / (NUM_SPHERES_X - 1)) - 1.0) * -1.0;\n        material.enableGGXSpecular = true;\n        material.update();\n\n        const sphere = new pc.Entity();\n\n        sphere.addComponent("render", {\n            material: material,\n            type: "sphere"\n        });\n        sphere.setLocalPosition(x - (NUM_SPHERES_X - 1) * 0.5, y, z - (NUM_SPHERES_Z - 1) * 0.5);\n        sphere.setLocalScale(0.7, 0.7, 0.7);\n        app.root.addChild(sphere);\n    };\n\n    const createText = function (fontAsset: pc.Asset, message: string, x: number, y: number, z: number, rotx: number, roty: number) {\n        // Create a text element-based entity\n        const text = new pc.Entity();\n        text.addComponent("element", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            fontAsset: fontAsset,\n            fontSize: 0.5,\n            pivot: [0.5, 0.5],\n            text: message,\n            type: pc.ELEMENTTYPE_TEXT\n        });\n        text.setLocalPosition(x, y, z);\n        text.setLocalEulerAngles(rotx, roty, 0);\n        app.root.addChild(text);\n    };\n\n    for (let i = 0; i < NUM_SPHERES_Z; i++) {\n        for (let j = 0; j < NUM_SPHERES_X; j++) {\n            createSphere(j, 0, i);\n        }\n    }\n\n    createText(assets.font, \'Anisotropy\', 0, 0, ((NUM_SPHERES_Z + 1) * 0.5), -90, 0);\n    createText(assets.font, \'Roughness\', -(NUM_SPHERES_X + 1) * 0.5, 0, 0, -90, 90);\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    // Set the skybox to the 128x128 cubemap mipmap level\n    app.scene.skyboxMip = 1;\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera");\n    camera.translate(0, 6, 6);\n    camera.rotate(-48, 0, 0);\n    app.root.addChild(camera);\n\n    // Create an entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n    });\n\n    app.root.addChild(light);\n    const e = light.getLocalEulerAngles();\n    light.setLocalEulerAngles(e.x + 90, e.y - 75, e.z);\n\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    const NUM_SPHERES_X = 11;\n    const NUM_SPHERES_Z = 6;\n\n    const createSphere = function (x, y, z) {\n        const material = new pc.StandardMaterial();\n        material.metalness = 1.0;\n        material.shininess = (z / (NUM_SPHERES_Z - 1)) * 100;\n        material.useMetalness = true;\n        material.anisotropy = ((2 * x) / (NUM_SPHERES_X - 1) - 1.0) * -1.0;\n        material.enableGGXSpecular = true;\n        material.update();\n\n        const sphere = new pc.Entity();\n\n        sphere.addComponent("render", {\n            material: material,\n            type: "sphere",\n        });\n\n        sphere.setLocalPosition(\n            x - (NUM_SPHERES_X - 1) * 0.5,\n            y,\n            z - (NUM_SPHERES_Z - 1) * 0.5\n        );\n        sphere.setLocalScale(0.7, 0.7, 0.7);\n        app.root.addChild(sphere);\n    };\n\n    const createText = function (fontAsset, message, x, y, z, rotx, roty) {\n        // Create a text element-based entity\n        const text = new pc.Entity();\n        text.addComponent("element", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            fontAsset: fontAsset,\n            fontSize: 0.5,\n            pivot: [0.5, 0.5],\n            text: message,\n            type: pc.ELEMENTTYPE_TEXT,\n        });\n\n        text.setLocalPosition(x, y, z);\n        text.setLocalEulerAngles(rotx, roty, 0);\n        app.root.addChild(text);\n    };\n\n    for (let i = 0; i < NUM_SPHERES_Z; i++) {\n        for (let j = 0; j < NUM_SPHERES_X; j++) {\n            createSphere(j, 0, i);\n        }\n    }\n\n    createText(\n        assets.font,\n        "Anisotropy",\n        0,\n        0,\n        (NUM_SPHERES_Z + 1) * 0.5,\n        -90,\n        0\n    );\n    createText(\n        assets.font,\n        "Roughness",\n        -(NUM_SPHERES_X + 1) * 0.5,\n        0,\n        0,\n        -90,\n        90\n    );\n}\n',nameSlug:"material-anisotropic",categorySlug:"graphics"},"material-clear-coat":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: { 'helipad.dds': pc.Asset, normal: pc.Asset, diffuse: pc.Asset, other: pc.Asset }): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    // Set the skybox to the 128x128 cubemap mipmap level\n    app.scene.skyboxMip = 1;\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\");\n    camera.translate(0, 0, 3);\n    app.root.addChild(camera);\n\n    // Create an entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent(\"light\", {\n        type: \"directional\",\n        color: new pc.Color(1, 0.8, 0.25)\n    });\n    app.root.addChild(light);\n    light.setLocalEulerAngles(85, -100, 0);\n\n    app.scene.setSkybox(assets['helipad.dds'].resources);\n\n    // function to create sphere\n    const createSphere = function (x: number, y: number, z: number, material: pc.Material) {\n        const sphere = new pc.Entity();\n\n        sphere.addComponent(\"render\", {\n            material: material,\n            type: \"sphere\"\n        });\n        sphere.setLocalPosition(x, y, z);\n        sphere.setLocalScale(0.7, 0.7, 0.7);\n        app.root.addChild(sphere);\n    };\n\n    const material = new pc.StandardMaterial();\n    material.diffuseMap = assets.diffuse.resource;\n    material.metalnessMap = assets.other.resource;\n    material.metalnessMapChannel = 'r';\n    material.glossMap = assets.other.resource;\n    material.glossMapChannel = 'g';\n    material.normalMap = assets.normal.resource;\n    material.diffuse = new pc.Color(0.6, 0.6, 0.9);\n    material.diffuseTint = true;\n    material.metalness = 1.0;\n    material.shininess = 90.0;\n    material.bumpiness = 0.7;\n    material.useMetalness = true;\n    material.update();\n\n    createSphere(-0.5, 0, 0, material);\n\n    const clearCoatMaterial = new pc.StandardMaterial();\n    clearCoatMaterial.diffuseMap = assets.diffuse.resource;\n    clearCoatMaterial.metalnessMap = assets.other.resource;\n    clearCoatMaterial.metalnessMapChannel = 'r';\n    clearCoatMaterial.glossMap = assets.other.resource;\n    clearCoatMaterial.glossMapChannel = 'g';\n    clearCoatMaterial.normalMap = assets.normal.resource;\n    clearCoatMaterial.diffuse = new pc.Color(0.6, 0.6, 0.9);\n    clearCoatMaterial.diffuseTint = true;\n    clearCoatMaterial.metalness = 1.0;\n    clearCoatMaterial.shininess = 90;\n    clearCoatMaterial.bumpiness = 0.7;\n    clearCoatMaterial.useMetalness = true;\n    clearCoatMaterial.clearCoat = 0.25;\n    clearCoatMaterial.clearCoatGlossiness = 0.9;\n    clearCoatMaterial.update();\n\n    createSphere(0.5, 0, 0, clearCoatMaterial);\n\n    app.start();\n\n    // update things each frame\n    let time = 0;\n    app.on(\"update\", function (dt) {\n        // rotate camera around the objects\n        time += dt;\n        camera.setLocalPosition(3 * Math.sin(time * 0.5), 0, 3 * Math.cos(time * 0.5));\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}",javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    // Set the skybox to the 128x128 cubemap mipmap level\n    app.scene.skyboxMip = 1;\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera");\n    camera.translate(0, 0, 3);\n    app.root.addChild(camera);\n\n    // Create an entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 0.8, 0.25),\n    });\n\n    app.root.addChild(light);\n    light.setLocalEulerAngles(85, -100, 0);\n\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    // function to create sphere\n    const createSphere = function (x, y, z, material) {\n        const sphere = new pc.Entity();\n\n        sphere.addComponent("render", {\n            material: material,\n            type: "sphere",\n        });\n\n        sphere.setLocalPosition(x, y, z);\n        sphere.setLocalScale(0.7, 0.7, 0.7);\n        app.root.addChild(sphere);\n    };\n\n    const material = new pc.StandardMaterial();\n    material.diffuseMap = assets.diffuse.resource;\n    material.metalnessMap = assets.other.resource;\n    material.metalnessMapChannel = "r";\n    material.glossMap = assets.other.resource;\n    material.glossMapChannel = "g";\n    material.normalMap = assets.normal.resource;\n    material.diffuse = new pc.Color(0.6, 0.6, 0.9);\n    material.diffuseTint = true;\n    material.metalness = 1.0;\n    material.shininess = 90.0;\n    material.bumpiness = 0.7;\n    material.useMetalness = true;\n    material.update();\n\n    createSphere(-0.5, 0, 0, material);\n\n    const clearCoatMaterial = new pc.StandardMaterial();\n    clearCoatMaterial.diffuseMap = assets.diffuse.resource;\n    clearCoatMaterial.metalnessMap = assets.other.resource;\n    clearCoatMaterial.metalnessMapChannel = "r";\n    clearCoatMaterial.glossMap = assets.other.resource;\n    clearCoatMaterial.glossMapChannel = "g";\n    clearCoatMaterial.normalMap = assets.normal.resource;\n    clearCoatMaterial.diffuse = new pc.Color(0.6, 0.6, 0.9);\n    clearCoatMaterial.diffuseTint = true;\n    clearCoatMaterial.metalness = 1.0;\n    clearCoatMaterial.shininess = 90;\n    clearCoatMaterial.bumpiness = 0.7;\n    clearCoatMaterial.useMetalness = true;\n    clearCoatMaterial.clearCoat = 0.25;\n    clearCoatMaterial.clearCoatGlossiness = 0.9;\n    clearCoatMaterial.update();\n\n    createSphere(0.5, 0, 0, clearCoatMaterial);\n\n    app.start();\n\n    // update things each frame\n    let time = 0;\n    app.on("update", function (dt) {\n        // rotate camera around the objects\n        time += dt;\n        camera.setLocalPosition(\n            3 * Math.sin(time * 0.5),\n            0,\n            3 * Math.cos(time * 0.5)\n        );\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}\n',nameSlug:"material-clear-coat",categorySlug:"graphics"},"material-physical":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: { 'helipad.dds': pc.Asset, font: pc.Asset }): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    // Set the skybox to the 128x128 cubemap mipmap level\n    app.scene.skyboxMip = 1;\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\");\n    camera.translate(0, 0, 9);\n    app.root.addChild(camera);\n\n    app.scene.setSkybox(assets['helipad.dds'].resources);\n\n    const NUM_SPHERES = 5;\n\n    const createSphere = function (x: number, y: number, z: number) {\n        const material = new pc.StandardMaterial();\n        material.metalness = y / (NUM_SPHERES - 1);\n        material.shininess = x / (NUM_SPHERES - 1) * 100;\n        material.useMetalness = true;\n        material.update();\n\n        const sphere = new pc.Entity();\n        sphere.addComponent(\"render\", {\n            material: material,\n            type: \"sphere\"\n        });\n        sphere.setLocalPosition(x - (NUM_SPHERES - 1) * 0.5, y - (NUM_SPHERES - 1) * 0.5, z);\n        sphere.setLocalScale(0.9, 0.9, 0.9);\n        app.root.addChild(sphere);\n    };\n\n    const createText = function (fontAsset: pc.Asset, message: string, x: number, y: number, z: number, rot: number) {\n        // Create a text element-based entity\n        const text = new pc.Entity();\n        text.addComponent(\"element\", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            fontAsset: fontAsset,\n            fontSize: 0.5,\n            pivot: [0.5, 0.5],\n            text: message,\n            type: pc.ELEMENTTYPE_TEXT\n        });\n        text.setLocalPosition(x, y, z);\n        text.setLocalEulerAngles(0, 0, rot);\n        app.root.addChild(text);\n    };\n\n    for (let i = 0; i < NUM_SPHERES; i++) {\n        for (let j = 0; j < NUM_SPHERES; j++) {\n            createSphere(j, i, 0);\n        }\n    }\n\n    createText(assets.font, 'Glossiness', 0, -(NUM_SPHERES + 1) * 0.5, 0, 0);\n    createText(assets.font, 'Metalness', -(NUM_SPHERES + 1) * 0.5, 0, 0, 90);\n\n    // rotate the skybox using mouse input\n    const mouse = new pc.Mouse(document.body);\n\n    let x = 0;\n    let y = 0;\n    const rot = new pc.Quat();\n\n    mouse.on('mousemove', function (event) {\n        if (event.buttons[pc.MOUSEBUTTON_LEFT]) {\n            x += event.dx;\n            y += event.dy;\n\n            rot.setFromEulerAngles(0.2 * y, 0.2 * x, 0);\n            app.scene.skyboxRotation = rot;\n        }\n    });\n}",javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    // Set the skybox to the 128x128 cubemap mipmap level\n    app.scene.skyboxMip = 1;\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera");\n    camera.translate(0, 0, 9);\n    app.root.addChild(camera);\n\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    const NUM_SPHERES = 5;\n\n    const createSphere = function (x, y, z) {\n        const material = new pc.StandardMaterial();\n        material.metalness = y / (NUM_SPHERES - 1);\n        material.shininess = (x / (NUM_SPHERES - 1)) * 100;\n        material.useMetalness = true;\n        material.update();\n\n        const sphere = new pc.Entity();\n        sphere.addComponent("render", {\n            material: material,\n            type: "sphere",\n        });\n\n        sphere.setLocalPosition(\n            x - (NUM_SPHERES - 1) * 0.5,\n            y - (NUM_SPHERES - 1) * 0.5,\n            z\n        );\n        sphere.setLocalScale(0.9, 0.9, 0.9);\n        app.root.addChild(sphere);\n    };\n\n    const createText = function (fontAsset, message, x, y, z, rot) {\n        // Create a text element-based entity\n        const text = new pc.Entity();\n        text.addComponent("element", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            fontAsset: fontAsset,\n            fontSize: 0.5,\n            pivot: [0.5, 0.5],\n            text: message,\n            type: pc.ELEMENTTYPE_TEXT,\n        });\n\n        text.setLocalPosition(x, y, z);\n        text.setLocalEulerAngles(0, 0, rot);\n        app.root.addChild(text);\n    };\n\n    for (let i = 0; i < NUM_SPHERES; i++) {\n        for (let j = 0; j < NUM_SPHERES; j++) {\n            createSphere(j, i, 0);\n        }\n    }\n\n    createText(assets.font, "Glossiness", 0, -(NUM_SPHERES + 1) * 0.5, 0, 0);\n    createText(assets.font, "Metalness", -(NUM_SPHERES + 1) * 0.5, 0, 0, 90);\n\n    // rotate the skybox using mouse input\n    const mouse = new pc.Mouse(document.body);\n\n    let x = 0;\n    let y = 0;\n    const rot = new pc.Quat();\n\n    mouse.on("mousemove", function (event) {\n        if (event.buttons[pc.MOUSEBUTTON_LEFT]) {\n            x += event.dx;\n            y += event.dy;\n\n            rot.setFromEulerAngles(0.2 * y, 0.2 * x, 0);\n            app.scene.skyboxRotation = rot;\n        }\n    });\n}\n',nameSlug:"material-physical",categorySlug:"graphics"},"material-translucent-specular":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { \'helipad.dds\': pc.Asset, font: pc.Asset }): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    // Set the skybox to the 128x128 cubemap mipmap level\n    app.scene.skyboxMip = 1;\n    app.scene.skyboxIntensity = 1;\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera");\n    camera.translate(0, 0, 8);\n    camera.rotate(0, 0, 0);\n    app.root.addChild(camera);\n\n     // Create an entities with a directional light components\n    for (let i = 0; i < 3; i++) {\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            type: "directional"\n        });\n        app.root.addChild(light);\n        light.rotateLocal(60 + 10 * i, 30 + 90 * i, 0);\n    }\n\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n\n    const NUM_SPHERES_X = 10;\n    const NUM_SPHERES_Z = 5;\n\n    const createSphere = function (x: number, y: number, z: number) {\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(0.7, 0.7, 0.7);\n        material.metalness = 0.0;\n        material.shininess = ((z) / (NUM_SPHERES_Z - 1) * 50) + 50;\n        material.useMetalness = true;\n        material.blendType = pc.BLEND_NORMAL;\n        material.opacity = (x >= 5) ? ((x - 5) / 5 + 0.2) * ((x - 5) / 5 + 0.2) : (x / 5 + 0.2) * (x / 5 + 0.2);\n        material.opacityFadesSpecular = !(x >= 5);\n        material.alphaWrite = false;\n\n        material.update();\n\n        const sphere = new pc.Entity();\n\n        sphere.addComponent("render", {\n            material: material,\n            type: "sphere"\n        });\n        sphere.setLocalPosition(x - (NUM_SPHERES_X - 1) * 0.5, z - (NUM_SPHERES_Z - 1) * 0.5, 0);\n        sphere.setLocalScale(0.7, 0.7, 0.7);\n        app.root.addChild(sphere);\n    };\n\n    const createText = function (fontAsset: pc.Asset, message: string, x: number, y: number, z: number, rotx: number, roty: number) {\n        // Create a text element-based entity\n        const text = new pc.Entity();\n        text.addComponent("element", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            fontAsset: fontAsset,\n            fontSize: 0.5,\n            pivot: [0.5, 0.5],\n            text: message,\n            type: pc.ELEMENTTYPE_TEXT\n        });\n        text.setLocalPosition(x, y, z);\n        text.setLocalEulerAngles(rotx, roty, 0);\n        app.root.addChild(text);\n    };\n\n    for (let i = 0; i < NUM_SPHERES_Z; i++) {\n        for (let j = 0; j < NUM_SPHERES_X; j++) {\n            createSphere(j, 0, i);\n        }\n    }\n\n    createText(assets.font, \'Spec Fade On\', -NUM_SPHERES_X * 0.25, ((NUM_SPHERES_Z + 1) * -0.5), 0, -0, 0);\n    createText(assets.font, \'Spec Fade Off\', NUM_SPHERES_X * 0.25, ((NUM_SPHERES_Z + 1) * -0.5), 0, -0, 0);\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    // Set the skybox to the 128x128 cubemap mipmap level\n    app.scene.skyboxMip = 1;\n    app.scene.skyboxIntensity = 1;\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera");\n    camera.translate(0, 0, 8);\n    camera.rotate(0, 0, 0);\n    app.root.addChild(camera);\n\n    // Create an entities with a directional light components\n    for (let i = 0; i < 3; i++) {\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            type: "directional",\n        });\n\n        app.root.addChild(light);\n        light.rotateLocal(60 + 10 * i, 30 + 90 * i, 0);\n    }\n\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    const NUM_SPHERES_X = 10;\n    const NUM_SPHERES_Z = 5;\n\n    const createSphere = function (x, y, z) {\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(0.7, 0.7, 0.7);\n        material.metalness = 0.0;\n        material.shininess = (z / (NUM_SPHERES_Z - 1)) * 50 + 50;\n        material.useMetalness = true;\n        material.blendType = pc.BLEND_NORMAL;\n        material.opacity =\n            x >= 5\n                ? ((x - 5) / 5 + 0.2) * ((x - 5) / 5 + 0.2)\n                : (x / 5 + 0.2) * (x / 5 + 0.2);\n        material.opacityFadesSpecular = !(x >= 5);\n        material.alphaWrite = false;\n\n        material.update();\n\n        const sphere = new pc.Entity();\n\n        sphere.addComponent("render", {\n            material: material,\n            type: "sphere",\n        });\n\n        sphere.setLocalPosition(\n            x - (NUM_SPHERES_X - 1) * 0.5,\n            z - (NUM_SPHERES_Z - 1) * 0.5,\n            0\n        );\n        sphere.setLocalScale(0.7, 0.7, 0.7);\n        app.root.addChild(sphere);\n    };\n\n    const createText = function (fontAsset, message, x, y, z, rotx, roty) {\n        // Create a text element-based entity\n        const text = new pc.Entity();\n        text.addComponent("element", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            fontAsset: fontAsset,\n            fontSize: 0.5,\n            pivot: [0.5, 0.5],\n            text: message,\n            type: pc.ELEMENTTYPE_TEXT,\n        });\n\n        text.setLocalPosition(x, y, z);\n        text.setLocalEulerAngles(rotx, roty, 0);\n        app.root.addChild(text);\n    };\n\n    for (let i = 0; i < NUM_SPHERES_Z; i++) {\n        for (let j = 0; j < NUM_SPHERES_X; j++) {\n            createSphere(j, 0, i);\n        }\n    }\n\n    createText(\n        assets.font,\n        "Spec Fade On",\n        -NUM_SPHERES_X * 0.25,\n        (NUM_SPHERES_Z + 1) * -0.5,\n        0,\n        -0,\n        0\n    );\n    createText(\n        assets.font,\n        "Spec Fade Off",\n        NUM_SPHERES_X * 0.25,\n        (NUM_SPHERES_Z + 1) * -0.5,\n        0,\n        -0,\n        0\n    );\n}\n',nameSlug:"material-translucent-specular",categorySlug:"graphics"},"mesh-decals":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { spark: pc.Asset }): void {\n\n    // Create the application\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // create material for the plane\n    const planeMaterial = new pc.StandardMaterial();\n    planeMaterial.shininess = 60;\n    planeMaterial.metalness = 0.3;\n    planeMaterial.useMetalness = true;\n    planeMaterial.update();\n\n    // create plane primitive\n    const primitive = new pc.Entity();\n    primitive.addComponent(\'render\', {\n        type: "plane",\n        material: planeMaterial\n    });\n\n    // set position and scale and add it to scene\n    primitive.setLocalScale(new pc.Vec3(20, 20, 20));\n    primitive.setLocalPosition(new pc.Vec3(0, -0.01, 0));\n    app.root.addChild(primitive);\n\n    // Create an Entity with a omni light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(0.2, 0.2, 0.2),\n        range: 30,\n        castShadows: true,\n        shadowBias: 0.1,\n        normalOffsetBias: 0.2\n    });\n    light.translate(0, 8, 0);\n    app.root.addChild(light);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2)\n    });\n\n    // Add the camera to the hierarchy\n    app.root.addChild(camera);\n\n    // Position the camera\n    camera.translate(0, 10, 20);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // Create bouncing ball model and add it to hierarchy\n    const ball = new pc.Entity();\n    ball.addComponent("render", {\n        type: "sphere"\n    });\n    app.root.addChild(ball);\n\n    // Allocate space for decals. Each decal is a quad with 4 vertices\n    const numDecals = 500;\n    const numDecalVertices = 4 * numDecals;\n\n    // Allocate storage for vertex positions, vertex stores x, y and z\n    const positions = new Float32Array(3 * numDecalVertices);\n\n    // Allocate storage for colors, each vertex stores r, g, b and a\n    const colors = new Uint8ClampedArray(4 * numDecalVertices);\n\n    // Allocate storage for uvs, each vertex stores u and v. And fill them up to display whole texture\n    const uvs: any = [];\n    for (let i = 0; i < numDecals; i++)\n        uvs.push(0, 0, 0, 1, 1, 1, 1, 0);\n\n    // Allocate and generate indices. Each quad is representing using 2 triangles, and uses 4 vertices\n    const quadTriangles = [\n        0, 1, 2,\n        2, 3, 0\n    ];\n    const indices = new Uint16Array(6 * numDecals);\n    for (let i = 0; i < numDecals; i++) {\n        indices[6 * i + 0] = 4 * i + quadTriangles[0];\n        indices[6 * i + 1] = 4 * i + quadTriangles[1];\n        indices[6 * i + 2] = 4 * i + quadTriangles[2];\n        indices[6 * i + 3] = 4 * i + quadTriangles[3];\n        indices[6 * i + 4] = 4 * i + quadTriangles[4];\n        indices[6 * i + 5] = 4 * i + quadTriangles[5];\n    }\n\n    // Helper function to generate a decal with index i at position pos. It fills up information for all 4 vertices of a quad\n    function createDecal(i: number, pos: pc.Vec3) {\n\n        // random size and rotation angle\n        const size = 0.5 + Math.random();\n        let angle = Math.random() * Math.PI;\n\n        // random color\n        const r = Math.random() * 255;\n        const g = Math.random() * 255;\n        const b = Math.random() * 255;\n\n        for (let j = 0; j < 4; j++) {\n            colors[i * 16 + j * 4 + 0] = r;\n            colors[i * 16 + j * 4 + 1] = g;\n            colors[i * 16 + j * 4 + 2] = b;\n            colors[i * 16 + j * 4 + 3] = 0;    // alpha is not used by shader\n        }\n\n        // vertex positions to form a square quad with random rotation and size\n        positions[12 * i + 0] = pos.x + size * Math.sin(angle);\n        positions[12 * i + 1] = 0;\n        positions[12 * i + 2] = pos.z + size * Math.cos(angle); angle += Math.PI * 0.5;\n\n        positions[12 * i + 3] = pos.x + size * Math.sin(angle);\n        positions[12 * i + 4] = 0;\n        positions[12 * i + 5] = pos.z + size * Math.cos(angle); angle += Math.PI * 0.5;\n\n        positions[12 * i + 6] = pos.x + size * Math.sin(angle);\n        positions[12 * i + 7] = 0;\n        positions[12 * i + 8] = pos.z + size * Math.cos(angle); angle += Math.PI * 0.5;\n\n        positions[12 * i + 9] = pos.x + size * Math.sin(angle);\n        positions[12 * i + 10] = 0;\n        positions[12 * i + 11] = pos.z + size * Math.cos(angle); angle += Math.PI * 0.5;\n    }\n\n    // helper function to update required vertex streams\n    function updateMesh(mesh: pc.Mesh, updatePositions: any, updateColors: any, initAll?: boolean) {\n\n        // update positions when needed\n        if (updatePositions)\n            mesh.setPositions(positions);\n\n        // update colors when needed\n        if (updateColors)\n            mesh.setColors32(colors);\n\n        // update indices and uvs only one time, as they never change\n        if (initAll) {\n            mesh.setIndices(indices);\n            mesh.setUvs(0, uvs);\n        }\n\n        mesh.update(pc.PRIMITIVE_TRIANGLES);\n    }\n\n    // Create a mesh with dynamic vertex buffer and static index buffer\n    const mesh = new pc.Mesh(app.graphicsDevice);\n    mesh.clear(true, false);\n    updateMesh(mesh, true, true, true);\n\n    // create material\n    const material = new pc.StandardMaterial();\n    material.useLighting = false;      // turn off lighting - we use emissive texture only. Also, lighting needs normal maps which we don\'t generate\n    material.diffuse = new pc.Color(0, 0, 0);\n    material.emissiveVertexColor = true;\n    material.blendType = pc.BLEND_ADDITIVE;     // additive alpha blend\n    material.depthWrite = false;        // optimization - no need to write to depth buffer, as decals are part of the ground plane\n    material.emissiveMap = assets.spark.resource;\n    material.update();\n\n    // Create the mesh instance\n    const meshInstance = new pc.MeshInstance(mesh, material);\n\n    // Create Entity with a render component to render the mesh instance\n    const entity = new pc.Entity();\n    entity.addComponent("render", {\n        type: \'asset\',\n        meshInstances: [meshInstance],\n        castShadows: false\n    });\n    app.root.addChild(entity);\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    let decalIndex = 0;\n    app.on("update", (dt) => {\n\n        const previousTime = time;\n        time += dt;\n\n        // Bounce the ball around in a circle with changing radius\n        const radius = Math.abs(Math.sin(time * 0.55) * 9);\n        const previousElevation = 2 * Math.cos(previousTime * 7);\n        const elevation = 2 * Math.cos(time * 7);\n        ball.setLocalPosition(new pc.Vec3(radius * Math.sin(time), 0.5 + Math.abs(elevation), radius * Math.cos(time)));\n\n        // When ball crossed the ground plane\n        let positionsUpdated = false;\n        let colorsUpdated = false;\n        if ((previousElevation < 0 && elevation >= 0) || (elevation < 0 && previousElevation >= 0)) {\n\n            // create new decal at next index, and roll the index around if out of range\n            createDecal(decalIndex, ball.getLocalPosition());\n            decalIndex++;\n            if (decalIndex >= numDecals)\n                decalIndex = 0;\n\n            // both position and color streams were updated\n            positionsUpdated = true;\n            colorsUpdated = true;\n        }\n\n        // fade out all vertex colors once a second\n        if (Math.round(time) != Math.round(previousTime)) {\n            for (let i = 0; i < colors.length; i++)\n                colors[i] -= 2;\n\n            // colors were updated\n            colorsUpdated = true;\n        }\n\n        // update mesh with the streams that were updated\n        updateMesh(mesh, positionsUpdated, colorsUpdated);\n    });\n\n    // start app here when all is ready\n    app.start();\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // create material for the plane\n    const planeMaterial = new pc.StandardMaterial();\n    planeMaterial.shininess = 60;\n    planeMaterial.metalness = 0.3;\n    planeMaterial.useMetalness = true;\n    planeMaterial.update();\n\n    // create plane primitive\n    const primitive = new pc.Entity();\n    primitive.addComponent("render", {\n        type: "plane",\n        material: planeMaterial,\n    });\n\n    // set position and scale and add it to scene\n    primitive.setLocalScale(new pc.Vec3(20, 20, 20));\n    primitive.setLocalPosition(new pc.Vec3(0, -0.01, 0));\n    app.root.addChild(primitive);\n\n    // Create an Entity with a omni light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(0.2, 0.2, 0.2),\n        range: 30,\n        castShadows: true,\n        shadowBias: 0.1,\n        normalOffsetBias: 0.2,\n    });\n\n    light.translate(0, 8, 0);\n    app.root.addChild(light);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2),\n    });\n\n    // Add the camera to the hierarchy\n    app.root.addChild(camera);\n\n    // Position the camera\n    camera.translate(0, 10, 20);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // Create bouncing ball model and add it to hierarchy\n    const ball = new pc.Entity();\n    ball.addComponent("render", {\n        type: "sphere",\n    });\n\n    app.root.addChild(ball);\n\n    // Allocate space for decals. Each decal is a quad with 4 vertices\n    const numDecals = 500;\n    const numDecalVertices = 4 * numDecals;\n\n    // Allocate storage for vertex positions, vertex stores x, y and z\n    const positions = new Float32Array(3 * numDecalVertices);\n\n    // Allocate storage for colors, each vertex stores r, g, b and a\n    const colors = new Uint8ClampedArray(4 * numDecalVertices);\n\n    // Allocate storage for uvs, each vertex stores u and v. And fill them up to display whole texture\n    const uvs = [];\n    for (let i = 0; i < numDecals; i++) uvs.push(0, 0, 0, 1, 1, 1, 1, 0);\n\n    // Allocate and generate indices. Each quad is representing using 2 triangles, and uses 4 vertices\n    const quadTriangles = [0, 1, 2, 2, 3, 0];\n\n    const indices = new Uint16Array(6 * numDecals);\n    for (let i = 0; i < numDecals; i++) {\n        indices[6 * i + 0] = 4 * i + quadTriangles[0];\n        indices[6 * i + 1] = 4 * i + quadTriangles[1];\n        indices[6 * i + 2] = 4 * i + quadTriangles[2];\n        indices[6 * i + 3] = 4 * i + quadTriangles[3];\n        indices[6 * i + 4] = 4 * i + quadTriangles[4];\n        indices[6 * i + 5] = 4 * i + quadTriangles[5];\n    }\n\n    // Helper function to generate a decal with index i at position pos. It fills up information for all 4 vertices of a quad\n    function createDecal(i, pos) {\n        // random size and rotation angle\n        const size = 0.5 + Math.random();\n        let angle = Math.random() * Math.PI;\n\n        // random color\n        const r = Math.random() * 255;\n        const g = Math.random() * 255;\n        const b = Math.random() * 255;\n\n        for (let j = 0; j < 4; j++) {\n            colors[i * 16 + j * 4 + 0] = r;\n            colors[i * 16 + j * 4 + 1] = g;\n            colors[i * 16 + j * 4 + 2] = b;\n            colors[i * 16 + j * 4 + 3] = 0; // alpha is not used by shader\n        }\n\n        // vertex positions to form a square quad with random rotation and size\n        positions[12 * i + 0] = pos.x + size * Math.sin(angle);\n        positions[12 * i + 1] = 0;\n        positions[12 * i + 2] = pos.z + size * Math.cos(angle);\n        angle += Math.PI * 0.5;\n\n        positions[12 * i + 3] = pos.x + size * Math.sin(angle);\n        positions[12 * i + 4] = 0;\n        positions[12 * i + 5] = pos.z + size * Math.cos(angle);\n        angle += Math.PI * 0.5;\n\n        positions[12 * i + 6] = pos.x + size * Math.sin(angle);\n        positions[12 * i + 7] = 0;\n        positions[12 * i + 8] = pos.z + size * Math.cos(angle);\n        angle += Math.PI * 0.5;\n\n        positions[12 * i + 9] = pos.x + size * Math.sin(angle);\n        positions[12 * i + 10] = 0;\n        positions[12 * i + 11] = pos.z + size * Math.cos(angle);\n        angle += Math.PI * 0.5;\n    }\n\n    // helper function to update required vertex streams\n    function updateMesh(mesh, updatePositions, updateColors, initAll) {\n        // update positions when needed\n        if (updatePositions) mesh.setPositions(positions);\n\n        // update colors when needed\n        if (updateColors) mesh.setColors32(colors);\n\n        // update indices and uvs only one time, as they never change\n        if (initAll) {\n            mesh.setIndices(indices);\n            mesh.setUvs(0, uvs);\n        }\n\n        mesh.update(pc.PRIMITIVE_TRIANGLES);\n    }\n\n    // Create a mesh with dynamic vertex buffer and static index buffer\n    const mesh = new pc.Mesh(app.graphicsDevice);\n    mesh.clear(true, false);\n    updateMesh(mesh, true, true, true);\n\n    // create material\n    const material = new pc.StandardMaterial();\n    material.useLighting = false; // turn off lighting - we use emissive texture only. Also, lighting needs normal maps which we don\'t generate\n    material.diffuse = new pc.Color(0, 0, 0);\n    material.emissiveVertexColor = true;\n    material.blendType = pc.BLEND_ADDITIVE; // additive alpha blend\n    material.depthWrite = false; // optimization - no need to write to depth buffer, as decals are part of the ground plane\n    material.emissiveMap = assets.spark.resource;\n    material.update();\n\n    // Create the mesh instance\n    const meshInstance = new pc.MeshInstance(mesh, material);\n\n    // Create Entity with a render component to render the mesh instance\n    const entity = new pc.Entity();\n    entity.addComponent("render", {\n        type: "asset",\n        meshInstances: [meshInstance],\n        castShadows: false,\n    });\n\n    app.root.addChild(entity);\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    let decalIndex = 0;\n    app.on("update", (dt) => {\n        const previousTime = time;\n        time += dt;\n\n        // Bounce the ball around in a circle with changing radius\n        const radius = Math.abs(Math.sin(time * 0.55) * 9);\n        const previousElevation = 2 * Math.cos(previousTime * 7);\n        const elevation = 2 * Math.cos(time * 7);\n        ball.setLocalPosition(\n            new pc.Vec3(\n                radius * Math.sin(time),\n                0.5 + Math.abs(elevation),\n                radius * Math.cos(time)\n            )\n        );\n\n        // When ball crossed the ground plane\n        let positionsUpdated = false;\n        let colorsUpdated = false;\n        if (\n            (previousElevation < 0 && elevation >= 0) ||\n            (elevation < 0 && previousElevation >= 0)\n        ) {\n            // create new decal at next index, and roll the index around if out of range\n            createDecal(decalIndex, ball.getLocalPosition());\n            decalIndex++;\n            if (decalIndex >= numDecals) decalIndex = 0;\n\n            // both position and color streams were updated\n            positionsUpdated = true;\n            colorsUpdated = true;\n        }\n\n        // fade out all vertex colors once a second\n        if (Math.round(time) != Math.round(previousTime)) {\n            for (let i = 0; i < colors.length; i++) colors[i] -= 2;\n\n            // colors were updated\n            colorsUpdated = true;\n        }\n\n        // update mesh with the streams that were updated\n        updateMesh(mesh, positionsUpdated, colorsUpdated);\n    });\n\n    // start app here when all is ready\n    app.start();\n}\n',nameSlug:"mesh-decals",categorySlug:"graphics"},"mesh-deformation":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { statue: pc.Asset, \'helipad.dds\': pc.Asset }): void {\n\n    // Create the app\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // setup skydome\n    app.scene.skyboxMip = 2;\n    app.scene.exposure = 1;\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.translate(0, 7, 24);\n    app.root.addChild(camera);\n\n    // create a hierarchy of entities with render components, representing the statue model\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    // collect positions from all mesh instances to work on\n    const allMeshes: any = [];\n    const renders: Array<pc.RenderComponent> = entity.findComponents("render");\n    renders.forEach((render) => {\n\n        // collect positions from all mesh instances on this render component\n        const meshInstances = render.meshInstances;\n        for (let i = 0; i < meshInstances.length; i++) {\n            const meshInstance = meshInstances[i];\n\n            // get positions from the mesh\n            const mesh = meshInstance.mesh;\n            const srcPositions: any = [];\n            mesh.getPositions(srcPositions);\n\n            // store it\n            allMeshes.push({\n                mesh: mesh,\n                srcPositions: srcPositions\n            });\n        }\n    });\n\n    // start the application when all is set up\n    app.start();\n\n    // temporary work array of positions to avoid per frame allocations\n    const tempPositions: any = [];\n\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        if (entity) {\n\n            // orbit the camera\n            camera.setLocalPosition(25 * Math.sin(time * 0.2), 15, 25 * Math.cos(time * 0.2));\n            camera.lookAt(new pc.Vec3(0, 7, 0));\n\n            const strength = 50;\n\n            // modify mesh positions on each frame\n            for (let i = 0; i < allMeshes.length; i++) {\n                tempPositions.length = 0;\n                const srcPositions = allMeshes[i].srcPositions;\n\n                // loop over all positions, and fill up tempPositions array with waved version of positions from srcPositions array\n                // modify .x and .z components based on sin function, which uses .y component\n                for (let k = 0; k < srcPositions.length; k += 3) {\n                    tempPositions[k] = srcPositions[k] + strength * Math.sin(time + srcPositions[k + 1] * 0.01);\n                    tempPositions[k + 1] = srcPositions[k + 1];\n                    tempPositions[k + 2] = srcPositions[k + 2] + strength * Math.sin(time + srcPositions[k + 1] * 0.01);\n                }\n\n                // set new positions on the mesh\n                const mesh = allMeshes[i].mesh;\n                mesh.setPositions(tempPositions);\n                mesh.update();\n            }\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the app\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // setup skydome\n    app.scene.skyboxMip = 2;\n    app.scene.exposure = 1;\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.translate(0, 7, 24);\n    app.root.addChild(camera);\n\n    // create a hierarchy of entities with render components, representing the statue model\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    // collect positions from all mesh instances to work on\n    const allMeshes = [];\n    const renders = entity.findComponents("render");\n    renders.forEach((render) => {\n        // collect positions from all mesh instances on this render component\n        const meshInstances = render.meshInstances;\n        for (let i = 0; i < meshInstances.length; i++) {\n            const meshInstance = meshInstances[i];\n\n            // get positions from the mesh\n            const mesh = meshInstance.mesh;\n            const srcPositions = [];\n            mesh.getPositions(srcPositions);\n\n            // store it\n            allMeshes.push({\n                mesh: mesh,\n                srcPositions: srcPositions,\n            });\n        }\n    });\n\n    // start the application when all is set up\n    app.start();\n\n    // temporary work array of positions to avoid per frame allocations\n    const tempPositions = [];\n\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        if (entity) {\n            // orbit the camera\n            camera.setLocalPosition(\n                25 * Math.sin(time * 0.2),\n                15,\n                25 * Math.cos(time * 0.2)\n            );\n            camera.lookAt(new pc.Vec3(0, 7, 0));\n\n            const strength = 50;\n\n            // modify mesh positions on each frame\n            for (let i = 0; i < allMeshes.length; i++) {\n                tempPositions.length = 0;\n                const srcPositions = allMeshes[i].srcPositions;\n\n                // loop over all positions, and fill up tempPositions array with waved version of positions from srcPositions array\n                // modify .x and .z components based on sin function, which uses .y component\n                for (let k = 0; k < srcPositions.length; k += 3) {\n                    tempPositions[k] =\n                        srcPositions[k] +\n                        strength * Math.sin(time + srcPositions[k + 1] * 0.01);\n                    tempPositions[k + 1] = srcPositions[k + 1];\n                    tempPositions[k + 2] =\n                        srcPositions[k + 2] +\n                        strength * Math.sin(time + srcPositions[k + 1] * 0.01);\n                }\n\n                // set new positions on the mesh\n                const mesh = allMeshes[i].mesh;\n                mesh.setPositions(tempPositions);\n                mesh.update();\n            }\n        }\n    });\n}\n',nameSlug:"mesh-deformation",categorySlug:"graphics"},"mesh-generation":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { playcanvasGrey: pc.Asset }): void {\n\n    // Create the application\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);\n\n    // helper function to create a light\n    function createLight(color: pc.Color, scale: number) {\n\n        // Create an Entity with a omni light component, which is casting shadows (using rendering to cubemap)\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            type: "omni",\n            color: color,\n            radius: 10,\n            castShadows: false\n        });\n\n        // create material of specified color\n        const material = new pc.StandardMaterial();\n        material.emissive = color;\n        material.update();\n\n        // add sphere at the position of light\n        light.addComponent("render", {\n            type: "sphere",\n            material: material\n        });\n\n        // Scale the sphere\n        light.setLocalScale(scale, scale, scale);\n\n        app.root.addChild(light);\n        return light;\n    }\n\n    // create 4 lights that will move in the scene and deform the mesh as well\n    const lights = [\n        { radius: 7, speed: 1.0, scale: 2.5, light: createLight(new pc.Color(0.3, 0.9, 0.6), 1.0) },\n        { radius: 3, speed: 1.2, scale: 3.0, light: createLight(new pc.Color(0.7, 0.2, 0.3), 1.3) },\n        { radius: 5, speed: -0.8, scale: 4.0, light: createLight(new pc.Color(0.2, 0.2, 0.9), 1.5) },\n        { radius: 4, speed: -0.3, scale: 5.5, light: createLight(new pc.Color(0.8, 0.9, 0.4), 1.7) }\n    ];\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2)\n    });\n\n    // Add the new Entity to the hierarchy\n    app.root.addChild(camera);\n\n    // Position the camera\n    camera.translate(0, 5, 20);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // Generate a 3D grid plane with world size of 20, and resolution of 60\n    const resolution = 60;\n    const extent = 20;\n    const scale = extent / resolution;\n\n    // Generate positions and uv coordinates for vertices, store them in Float32Arrays\n    const positions = new Float32Array(3 * resolution * resolution);\n    const uvs =  new Float32Array(2 * resolution * resolution);\n    let index = 0;\n    for (let x = 0; x < resolution; x++) {\n        for (let z = 0; z < resolution; z++) {\n            positions[3 * index] = scale * (x - resolution * 0.5);\n            positions[3 * index + 1] = 0;  // no elevation, flat grid\n            positions[3 * index + 2] = scale * (z - resolution * 0.5);\n            uvs[2 * index] = x / resolution;\n            uvs[2 * index + 1] = 1 - z / resolution;\n            index++;\n        }\n    }\n\n    // Generate array of indices to form triangle list - two triangles per grid square\n    const indexArray: any = [];\n    for (let x = 0; x < resolution - 1; x++) {\n        for (let y = 0; y < resolution - 1; y++) {\n            indexArray.push(x * resolution + y + 1, (x + 1) * resolution + y, x * resolution + y,\n                            (x + 1) * resolution + y, x * resolution + y + 1, (x + 1) * resolution + y + 1);\n        }\n    }\n\n    // helper function to update required vertex / index streams\n    function updateMesh(mesh: pc.Mesh, initAll?: boolean) {\n\n        // Set updated positions and normal each frame\n        mesh.setPositions(positions);\n        // @ts-ignore engine-tsd\n        mesh.setNormals(pc.calculateNormals(positions, indexArray));\n\n        // update mesh Uvs and Indices only one time, as they do not change each frame\n        if (initAll) {\n            mesh.setUvs(0, uvs);\n            mesh.setIndices(indexArray);\n        }\n\n        // Let mesh update Vertex and Index buffer as needed\n        mesh.update(pc.PRIMITIVE_TRIANGLES);\n    }\n\n    // Create a mesh with dynamic vertex buffer and static index buffer\n    const mesh = new pc.Mesh(app.graphicsDevice);\n    mesh.clear(true, false);\n    updateMesh(mesh, true);\n\n    // create material\n    const material = new pc.StandardMaterial();\n    material.diffuseMap = assets.playcanvasGrey.resource;\n    material.shininess = 50;\n    material.metalness = 0.3;\n    material.useMetalness = true;\n    material.update();\n\n    // Create the mesh instance\n    const meshInstance = new pc.MeshInstance(mesh, material);\n\n    // Create the entity with render component using meshInstances\n    const entity = new pc.Entity();\n    entity.addComponent("render", {\n        meshInstances: [meshInstance]\n    });\n    app.root.addChild(entity);\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // Move the lights along circles, also keep separate list of their position for faster update in next block of code\n        const lightPositions = [];\n        for (let l = 0; l < lights.length; l++) {\n            const element = lights[l];\n            const lightPos = new pc.Vec2(element.radius * Math.sin(time * element.speed), element.radius * Math.cos(time * element.speed));\n            lightPositions.push(lightPos);\n            element.light.setLocalPosition(lightPos.x, 3, lightPos.y);\n        }\n\n        // animate .y coordinate of grid vertices by moving them up when lights are close\n        let index = 0;\n        for (let x = 0; x < resolution; x++) {\n            for (let z = 0; z < resolution; z++) {\n\n                let elevation = 0;\n\n                // Evaluate distance of grid vertex to each light position, and increase elevation if light is within the range\n                for (let l = 0; l < lightPositions.length; l++) {\n                    const dx = positions[index] - lightPositions[l].x;\n                    const dz = positions[index + 2] - lightPositions[l].y;\n                    let dist = Math.sqrt(dx * dx + dz * dz);\n                    dist = pc.math.clamp(dist, 0, lights[l].scale);\n                    dist = pc.math.smoothstep(0, lights[l].scale, dist);\n                    elevation += (1 - dist);\n                }\n\n                // Store elevation in .y element\n                positions[index + 1] = elevation;\n                index += 3;\n            }\n        }\n\n        // update the mesh\n        updateMesh(mesh);\n    });\n\n    // start application update loop when texture is loaded\n    app.start();\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);\n\n    // helper function to create a light\n    function createLight(color, scale) {\n        // Create an Entity with a omni light component, which is casting shadows (using rendering to cubemap)\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            type: "omni",\n            color: color,\n            radius: 10,\n            castShadows: false,\n        });\n\n        // create material of specified color\n        const material = new pc.StandardMaterial();\n        material.emissive = color;\n        material.update();\n\n        // add sphere at the position of light\n        light.addComponent("render", {\n            type: "sphere",\n            material: material,\n        });\n\n        // Scale the sphere\n        light.setLocalScale(scale, scale, scale);\n\n        app.root.addChild(light);\n        return light;\n    }\n\n    // create 4 lights that will move in the scene and deform the mesh as well\n    const lights = [\n        {\n            radius: 7,\n            speed: 1.0,\n            scale: 2.5,\n            light: createLight(new pc.Color(0.3, 0.9, 0.6), 1.0),\n        },\n        {\n            radius: 3,\n            speed: 1.2,\n            scale: 3.0,\n            light: createLight(new pc.Color(0.7, 0.2, 0.3), 1.3),\n        },\n        {\n            radius: 5,\n            speed: -0.8,\n            scale: 4.0,\n            light: createLight(new pc.Color(0.2, 0.2, 0.9), 1.5),\n        },\n        {\n            radius: 4,\n            speed: -0.3,\n            scale: 5.5,\n            light: createLight(new pc.Color(0.8, 0.9, 0.4), 1.7),\n        },\n    ];\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2),\n    });\n\n    // Add the new Entity to the hierarchy\n    app.root.addChild(camera);\n\n    // Position the camera\n    camera.translate(0, 5, 20);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // Generate a 3D grid plane with world size of 20, and resolution of 60\n    const resolution = 60;\n    const extent = 20;\n    const scale = extent / resolution;\n\n    // Generate positions and uv coordinates for vertices, store them in Float32Arrays\n    const positions = new Float32Array(3 * resolution * resolution);\n    const uvs = new Float32Array(2 * resolution * resolution);\n    let index = 0;\n    for (let x = 0; x < resolution; x++) {\n        for (let z = 0; z < resolution; z++) {\n            positions[3 * index] = scale * (x - resolution * 0.5);\n            positions[3 * index + 1] = 0; // no elevation, flat grid\n            positions[3 * index + 2] = scale * (z - resolution * 0.5);\n            uvs[2 * index] = x / resolution;\n            uvs[2 * index + 1] = 1 - z / resolution;\n            index++;\n        }\n    }\n\n    // Generate array of indices to form triangle list - two triangles per grid square\n    const indexArray = [];\n    for (let x = 0; x < resolution - 1; x++) {\n        for (let y = 0; y < resolution - 1; y++) {\n            indexArray.push(\n                x * resolution + y + 1,\n                (x + 1) * resolution + y,\n                x * resolution + y,\n                (x + 1) * resolution + y,\n                x * resolution + y + 1,\n                (x + 1) * resolution + y + 1\n            );\n        }\n    }\n\n    // helper function to update required vertex / index streams\n    function updateMesh(mesh, initAll) {\n        // Set updated positions and normal each frame\n        mesh.setPositions(positions);\n        // @ts-ignore engine-tsd\n        mesh.setNormals(pc.calculateNormals(positions, indexArray));\n\n        // update mesh Uvs and Indices only one time, as they do not change each frame\n        if (initAll) {\n            mesh.setUvs(0, uvs);\n            mesh.setIndices(indexArray);\n        }\n\n        // Let mesh update Vertex and Index buffer as needed\n        mesh.update(pc.PRIMITIVE_TRIANGLES);\n    }\n\n    // Create a mesh with dynamic vertex buffer and static index buffer\n    const mesh = new pc.Mesh(app.graphicsDevice);\n    mesh.clear(true, false);\n    updateMesh(mesh, true);\n\n    // create material\n    const material = new pc.StandardMaterial();\n    material.diffuseMap = assets.playcanvasGrey.resource;\n    material.shininess = 50;\n    material.metalness = 0.3;\n    material.useMetalness = true;\n    material.update();\n\n    // Create the mesh instance\n    const meshInstance = new pc.MeshInstance(mesh, material);\n\n    // Create the entity with render component using meshInstances\n    const entity = new pc.Entity();\n    entity.addComponent("render", {\n        meshInstances: [meshInstance],\n    });\n\n    app.root.addChild(entity);\n\n    // Set an update function on the app\'s update event\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // Move the lights along circles, also keep separate list of their position for faster update in next block of code\n        const lightPositions = [];\n        for (let l = 0; l < lights.length; l++) {\n            const element = lights[l];\n            const lightPos = new pc.Vec2(\n                element.radius * Math.sin(time * element.speed),\n                element.radius * Math.cos(time * element.speed)\n            );\n            lightPositions.push(lightPos);\n            element.light.setLocalPosition(lightPos.x, 3, lightPos.y);\n        }\n\n        // animate .y coordinate of grid vertices by moving them up when lights are close\n        let index = 0;\n        for (let x = 0; x < resolution; x++) {\n            for (let z = 0; z < resolution; z++) {\n                let elevation = 0;\n\n                // Evaluate distance of grid vertex to each light position, and increase elevation if light is within the range\n                for (let l = 0; l < lightPositions.length; l++) {\n                    const dx = positions[index] - lightPositions[l].x;\n                    const dz = positions[index + 2] - lightPositions[l].y;\n                    let dist = Math.sqrt(dx * dx + dz * dz);\n                    dist = pc.math.clamp(dist, 0, lights[l].scale);\n                    dist = pc.math.smoothstep(0, lights[l].scale, dist);\n                    elevation += 1 - dist;\n                }\n\n                // Store elevation in .y element\n                positions[index + 1] = elevation;\n                index += 3;\n            }\n        }\n\n        // update the mesh\n        updateMesh(mesh);\n    });\n\n    // start application update loop when texture is loaded\n    app.start();\n}\n',nameSlug:"mesh-generation",categorySlug:"graphics"},"mesh-morph-many":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { \'helipad.dds\': pc.Asset}): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // setup skydome\n    app.scene.skyboxMip = 2;\n    app.scene.exposure = 0.6;\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        castShadows: true,\n        shadowBias: 0.5,\n        shadowDistance: 25,\n        color: new pc.Color(0.5, 0.5, 0.5)\n    });\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 45, 0);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n    app.root.addChild(camera);\n\n    // position the camera\n    camera.setLocalPosition(0, 4, 14);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // helper function to return the shortest distance from point [x, y, z] to a plane defined by [a, b, c] normal and constant d\n    const shortestDistance = function (x: number, y: number, z: number, a: number, b: number, c: number, d: number) {\n        d = Math.abs((a * x + b * y + c * z + d));\n        const e = Math.sqrt(a * a + b * b + c * c);\n        return d / e;\n    };\n\n    // helper function that creates a morph target from original positions, normals and indices, and a plane normal [nx, ny, nz]\n    const createMorphTarget = function (positions: string | any[], normals: any[], indices: any[], offset: number, nx: number, ny: number, nz: number) {\n\n        // modify vertices to separate array\n        const modifiedPositions = new Float32Array(positions.length);\n        let dist: number;\n        let i: number;\n        let displacement: number;\n        const limit = 0.2 + Math.random() * 0.5;\n        const range = 1 + 2 * Math.random();\n        for (i = 0; i < positions.length; i += 3) {\n            // distance of the point to the specified plane\n            dist = shortestDistance(positions[i], positions[i + 1], positions[i + 2], nx, ny, nz, offset);\n\n            // modify distance to displacement amount - displace nearby points more than distant points\n            displacement = pc.math.smoothstep(0, limit, dist);\n            displacement = 1 - displacement;\n            displacement *= range;\n\n            // generate new position by extruding vertex along normal by displacement\n            modifiedPositions[i] = positions[i] + normals[i] * displacement;\n            modifiedPositions[i + 1] = positions[i + 1] + normals[i + 1] * displacement;\n            modifiedPositions[i + 2] = positions[i + 2] + normals[i + 2] * displacement;\n        }\n\n        // generate normals based on modified positions and indices\n        // @ts-ignore engine-tsd\n        const modifiedNormals = new Float32Array(pc.calculateNormals(modifiedPositions, indices));\n\n        // generate delta positions and normals - as morph targets store delta between base position / normal and modified position / normal\n        for (i = 0; i < modifiedNormals.length; i++) {\n            modifiedPositions[i] -= positions[i];\n            modifiedNormals[i] -= normals[i];\n        }\n\n        // create a morph target\n        // @ts-ignore engine-tsd\n        return new pc.MorphTarget({\n            deltaPositions: modifiedPositions,\n            deltaNormals: modifiedNormals\n        });\n    };\n\n    // create the base mesh - a sphere, with higher amount of vertices / triangles\n    const mesh = pc.createCylinder(app.graphicsDevice, { height: 10, heightSegments: 200, capSegments: 100 });\n\n    // obtain base mesh vertex / index data\n    const srcPositions: Float32Array | number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array = [], srcNormals: Float32Array | number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array = [], indices: number[] | Uint8Array | Uint16Array | Uint32Array = [];\n    mesh.getPositions(srcPositions);\n    mesh.getNormals(srcNormals);\n    mesh.getIndices(indices);\n\n    // build morph targets by expanding a part of cylinder by the normal\n    const targets = [];\n    let startOffset = -4.5;\n    const endOffset = 4.5;\n    const count = 12;\n    const deltaOffset = (endOffset - startOffset) / (count - 1);\n    for (let o = 0; o < count; o++) {\n        targets.push(createMorphTarget(srcPositions, srcNormals, indices, startOffset, 0, 1, 0));\n        startOffset += deltaOffset;\n    }\n\n    // create a morph using these targets\n    mesh.morph = new pc.Morph(targets, app.graphicsDevice);\n\n    // material\n    const material = new pc.StandardMaterial();\n    material.shininess = 50;\n    material.metalness = 0.3;\n    material.useMetalness = true;\n    material.update();\n\n    // Create the mesh instance\n    const meshInstance = new pc.MeshInstance(mesh, material);\n\n    // add morph instance - this is where currently set weights are stored\n    const morphInstance = new pc.MorphInstance(mesh.morph);\n    meshInstance.morphInstance = morphInstance;\n\n    // Create Entity and add it to the scene\n    const entity = new pc.Entity();\n    entity.addComponent("render", {\n        material: material,\n        meshInstances: [meshInstance]\n    });\n    entity.setLocalPosition(0, 0, 0);\n    app.root.addChild(entity);\n\n    // update function called once per frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // modify weights of all morph targets along sin curve with different frequency\n        for (let i = 0; i < targets.length; i++) {\n            morphInstance.setWeight(i, Math.abs(Math.sin(time * 2 * (i + 5) / targets.length)));\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // setup skydome\n    app.scene.skyboxMip = 2;\n    app.scene.exposure = 0.6;\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        castShadows: true,\n        shadowBias: 0.5,\n        shadowDistance: 25,\n        color: new pc.Color(0.5, 0.5, 0.5),\n    });\n\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 45, 0);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    app.root.addChild(camera);\n\n    // position the camera\n    camera.setLocalPosition(0, 4, 14);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // helper function to return the shortest distance from point [x, y, z] to a plane defined by [a, b, c] normal and constant d\n    const shortestDistance = function (x, y, z, a, b, c, d) {\n        d = Math.abs(a * x + b * y + c * z + d);\n        const e = Math.sqrt(a * a + b * b + c * c);\n        return d / e;\n    };\n\n    // helper function that creates a morph target from original positions, normals and indices, and a plane normal [nx, ny, nz]\n    const createMorphTarget = function (\n        positions,\n        normals,\n        indices,\n        offset,\n        nx,\n        ny,\n        nz\n    ) {\n        // modify vertices to separate array\n        const modifiedPositions = new Float32Array(positions.length);\n        let dist;\n        let i;\n        let displacement;\n        const limit = 0.2 + Math.random() * 0.5;\n        const range = 1 + 2 * Math.random();\n        for (i = 0; i < positions.length; i += 3) {\n            // distance of the point to the specified plane\n            dist = shortestDistance(\n                positions[i],\n                positions[i + 1],\n                positions[i + 2],\n                nx,\n                ny,\n                nz,\n                offset\n            );\n\n            // modify distance to displacement amount - displace nearby points more than distant points\n            displacement = pc.math.smoothstep(0, limit, dist);\n            displacement = 1 - displacement;\n            displacement *= range;\n\n            // generate new position by extruding vertex along normal by displacement\n            modifiedPositions[i] = positions[i] + normals[i] * displacement;\n            modifiedPositions[i + 1] =\n                positions[i + 1] + normals[i + 1] * displacement;\n            modifiedPositions[i + 2] =\n                positions[i + 2] + normals[i + 2] * displacement;\n        }\n\n        // generate normals based on modified positions and indices\n        // @ts-ignore engine-tsd\n        const modifiedNormals = new Float32Array(\n            pc.calculateNormals(modifiedPositions, indices)\n        );\n\n        // generate delta positions and normals - as morph targets store delta between base position / normal and modified position / normal\n        for (i = 0; i < modifiedNormals.length; i++) {\n            modifiedPositions[i] -= positions[i];\n            modifiedNormals[i] -= normals[i];\n        }\n\n        // create a morph target\n        // @ts-ignore engine-tsd\n        return new pc.MorphTarget({\n            deltaPositions: modifiedPositions,\n            deltaNormals: modifiedNormals,\n        });\n    };\n\n    // create the base mesh - a sphere, with higher amount of vertices / triangles\n    const mesh = pc.createCylinder(app.graphicsDevice, {\n        height: 10,\n        heightSegments: 200,\n        capSegments: 100,\n    });\n\n    // obtain base mesh vertex / index data\n    const srcPositions = [],\n        srcNormals = [],\n        indices = [];\n    mesh.getPositions(srcPositions);\n    mesh.getNormals(srcNormals);\n    mesh.getIndices(indices);\n\n    // build morph targets by expanding a part of cylinder by the normal\n    const targets = [];\n    let startOffset = -4.5;\n    const endOffset = 4.5;\n    const count = 12;\n    const deltaOffset = (endOffset - startOffset) / (count - 1);\n    for (let o = 0; o < count; o++) {\n        targets.push(\n            createMorphTarget(\n                srcPositions,\n                srcNormals,\n                indices,\n                startOffset,\n                0,\n                1,\n                0\n            )\n        );\n        startOffset += deltaOffset;\n    }\n\n    // create a morph using these targets\n    mesh.morph = new pc.Morph(targets, app.graphicsDevice);\n\n    // material\n    const material = new pc.StandardMaterial();\n    material.shininess = 50;\n    material.metalness = 0.3;\n    material.useMetalness = true;\n    material.update();\n\n    // Create the mesh instance\n    const meshInstance = new pc.MeshInstance(mesh, material);\n\n    // add morph instance - this is where currently set weights are stored\n    const morphInstance = new pc.MorphInstance(mesh.morph);\n    meshInstance.morphInstance = morphInstance;\n\n    // Create Entity and add it to the scene\n    const entity = new pc.Entity();\n    entity.addComponent("render", {\n        material: material,\n        meshInstances: [meshInstance],\n    });\n\n    entity.setLocalPosition(0, 0, 0);\n    app.root.addChild(entity);\n\n    // update function called once per frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // modify weights of all morph targets along sin curve with different frequency\n        for (let i = 0; i < targets.length; i++) {\n            morphInstance.setWeight(\n                i,\n                Math.abs(Math.sin((time * 2 * (i + 5)) / targets.length))\n            );\n        }\n    });\n}\n',nameSlug:"mesh-morph-many",categorySlug:"graphics"},"mesh-morph":{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional"\n    });\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 30, 0);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n    app.root.addChild(camera);\n\n    // helper function to return the shortest distance from point [x, y, z] to a plane defined by [a, b, c] normal\n    const shortestDistance = function (x: number, y: number, z: number, a: number, b: number, c: number) {\n        const d = Math.abs(a * x + b * y + c * z);\n        const e = Math.sqrt(a * a + b * b + c * c);\n        return d / e;\n    };\n\n    // helper function that creates a morph target from original positions, normals and indices, and a plane normal [nx, ny, nz]\n    const createMorphTarget = function (positions: string | any[], normals: any[], indices: any[], nx: number, ny: number, nz: number) {\n\n        // modify vertices to separate array\n        const modifiedPositions = new Float32Array(positions.length);\n        let dist: number, i: number, displacement: number;\n        const limit = 0.2;\n        for (i = 0; i < positions.length; i += 3) {\n            // distance of the point to the specified plane\n            dist = shortestDistance(positions[i], positions[i + 1], positions[i + 2], nx, ny, nz);\n\n            // modify distance to displacement amount - displace nearby points more than distant points\n            displacement = pc.math.smoothstep(0, limit, dist);\n            displacement = 1 - displacement;\n\n            // generate new position by extruding vertex along normal by displacement\n            modifiedPositions[i] = positions[i] + normals[i] * displacement;\n            modifiedPositions[i + 1] = positions[i + 1] + normals[i + 1] * displacement;\n            modifiedPositions[i + 2] = positions[i + 2] + normals[i + 2] * displacement;\n        }\n\n        // generate normals based on modified positions and indices\n        // @ts-ignore engine-tsd\n        const modifiedNormals = new Float32Array(pc.calculateNormals(modifiedPositions, indices));\n\n        // generate delta positions and normals - as morph targets store delta between base position / normal and modified position / normal\n        for (i = 0; i < modifiedNormals.length; i++) {\n            modifiedPositions[i] -= positions[i];\n            modifiedNormals[i] -= normals[i];\n        }\n\n        // create a morph target\n        // @ts-ignore engine-tsd\n        return new pc.MorphTarget({\n            deltaPositions: modifiedPositions,\n            deltaNormals: modifiedNormals\n        });\n    };\n\n    const createMorphInstance = function (x: number | pc.Vec3, y: number, z: number) {\n        // create the base mesh - a sphere, with higher amount of vertices / triangles\n        const mesh = pc.createSphere(app.graphicsDevice, { latitudeBands: 200, longitudeBands: 200 });\n\n        // obtain base mesh vertex / index data\n        const srcPositions: Float32Array | number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array = [], srcNormals: Float32Array | number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array = [], indices: number[] | Uint8Array | Uint16Array | Uint32Array = [];\n        mesh.getPositions(srcPositions);\n        mesh.getNormals(srcNormals);\n        mesh.getIndices(indices);\n\n        // build 3 targets by expanding a part of sphere along 3 planes, specified by the normal\n        const targets = [];\n        targets.push(createMorphTarget(srcPositions, srcNormals, indices, 1, 0, 0));\n        targets.push(createMorphTarget(srcPositions, srcNormals, indices, 0, 1, 0));\n        targets.push(createMorphTarget(srcPositions, srcNormals, indices, 0, 0, 1));\n\n        // create a morph using these 3 targets\n        mesh.morph = new pc.Morph(targets, app.graphicsDevice);\n\n        // Create the mesh instance\n        const material = new pc.StandardMaterial();\n        const meshInstance = new pc.MeshInstance(mesh, material);\n\n        // add morph instance - this is where currently set weights are stored\n        const morphInstance = new pc.MorphInstance(mesh.morph);\n        meshInstance.morphInstance = morphInstance;\n\n        // Create Entity and add it to the scene\n        const entity = new pc.Entity();\n        entity.setLocalPosition(x, y, z);\n        app.root.addChild(entity);\n\n        // Add a render component with meshInstance\n        entity.addComponent(\'render\', {\n            material: material,\n            meshInstances: [meshInstance]\n        });\n\n        return morphInstance;\n    };\n\n    // create 3 morph instances\n    const morphInstances: { setWeight: (arg0: number, arg1: number) => void; }[] = [];\n    for (let k = 0; k < 3; k++) {\n        morphInstances.push(createMorphInstance(Math.random() * 6 - 3, Math.random() * 6 - 3, Math.random() * 6 - 3));\n    }\n\n    // update function called once per frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        for (let m = 0; m < morphInstances.length; m++) {\n            // modify weights of all 3 morph targets along some sin curve with different frequency\n            morphInstances[m].setWeight(0, Math.abs(Math.sin(time + m)));\n            morphInstances[m].setWeight(1, Math.abs(Math.sin(time * 0.3 + m)));\n            morphInstances[m].setWeight(2, Math.abs(Math.sin(time * 0.7 + m)));\n        }\n\n        // orbit camera around\n        camera.setLocalPosition(16 * Math.sin(time * 0.2), 4, 16 * Math.cos(time * 0.2));\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}',javaScriptFunction:'function example(canvas) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n    });\n\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 30, 0);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    app.root.addChild(camera);\n\n    // helper function to return the shortest distance from point [x, y, z] to a plane defined by [a, b, c] normal\n    const shortestDistance = function (x, y, z, a, b, c) {\n        const d = Math.abs(a * x + b * y + c * z);\n        const e = Math.sqrt(a * a + b * b + c * c);\n        return d / e;\n    };\n\n    // helper function that creates a morph target from original positions, normals and indices, and a plane normal [nx, ny, nz]\n    const createMorphTarget = function (\n        positions,\n        normals,\n        indices,\n        nx,\n        ny,\n        nz\n    ) {\n        // modify vertices to separate array\n        const modifiedPositions = new Float32Array(positions.length);\n        let dist, i, displacement;\n        const limit = 0.2;\n        for (i = 0; i < positions.length; i += 3) {\n            // distance of the point to the specified plane\n            dist = shortestDistance(\n                positions[i],\n                positions[i + 1],\n                positions[i + 2],\n                nx,\n                ny,\n                nz\n            );\n\n            // modify distance to displacement amount - displace nearby points more than distant points\n            displacement = pc.math.smoothstep(0, limit, dist);\n            displacement = 1 - displacement;\n\n            // generate new position by extruding vertex along normal by displacement\n            modifiedPositions[i] = positions[i] + normals[i] * displacement;\n            modifiedPositions[i + 1] =\n                positions[i + 1] + normals[i + 1] * displacement;\n            modifiedPositions[i + 2] =\n                positions[i + 2] + normals[i + 2] * displacement;\n        }\n\n        // generate normals based on modified positions and indices\n        // @ts-ignore engine-tsd\n        const modifiedNormals = new Float32Array(\n            pc.calculateNormals(modifiedPositions, indices)\n        );\n\n        // generate delta positions and normals - as morph targets store delta between base position / normal and modified position / normal\n        for (i = 0; i < modifiedNormals.length; i++) {\n            modifiedPositions[i] -= positions[i];\n            modifiedNormals[i] -= normals[i];\n        }\n\n        // create a morph target\n        // @ts-ignore engine-tsd\n        return new pc.MorphTarget({\n            deltaPositions: modifiedPositions,\n            deltaNormals: modifiedNormals,\n        });\n    };\n\n    const createMorphInstance = function (x, y, z) {\n        // create the base mesh - a sphere, with higher amount of vertices / triangles\n        const mesh = pc.createSphere(app.graphicsDevice, {\n            latitudeBands: 200,\n            longitudeBands: 200,\n        });\n\n        // obtain base mesh vertex / index data\n        const srcPositions = [],\n            srcNormals = [],\n            indices = [];\n        mesh.getPositions(srcPositions);\n        mesh.getNormals(srcNormals);\n        mesh.getIndices(indices);\n\n        // build 3 targets by expanding a part of sphere along 3 planes, specified by the normal\n        const targets = [];\n        targets.push(\n            createMorphTarget(srcPositions, srcNormals, indices, 1, 0, 0)\n        );\n        targets.push(\n            createMorphTarget(srcPositions, srcNormals, indices, 0, 1, 0)\n        );\n        targets.push(\n            createMorphTarget(srcPositions, srcNormals, indices, 0, 0, 1)\n        );\n\n        // create a morph using these 3 targets\n        mesh.morph = new pc.Morph(targets, app.graphicsDevice);\n\n        // Create the mesh instance\n        const material = new pc.StandardMaterial();\n        const meshInstance = new pc.MeshInstance(mesh, material);\n\n        // add morph instance - this is where currently set weights are stored\n        const morphInstance = new pc.MorphInstance(mesh.morph);\n        meshInstance.morphInstance = morphInstance;\n\n        // Create Entity and add it to the scene\n        const entity = new pc.Entity();\n        entity.setLocalPosition(x, y, z);\n        app.root.addChild(entity);\n\n        // Add a render component with meshInstance\n        entity.addComponent("render", {\n            material: material,\n            meshInstances: [meshInstance],\n        });\n\n        return morphInstance;\n    };\n\n    // create 3 morph instances\n    const morphInstances = [];\n    for (let k = 0; k < 3; k++) {\n        morphInstances.push(\n            createMorphInstance(\n                Math.random() * 6 - 3,\n                Math.random() * 6 - 3,\n                Math.random() * 6 - 3\n            )\n        );\n    }\n\n    // update function called once per frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        for (let m = 0; m < morphInstances.length; m++) {\n            // modify weights of all 3 morph targets along some sin curve with different frequency\n            morphInstances[m].setWeight(0, Math.abs(Math.sin(time + m)));\n            morphInstances[m].setWeight(1, Math.abs(Math.sin(time * 0.3 + m)));\n            morphInstances[m].setWeight(2, Math.abs(Math.sin(time * 0.7 + m)));\n        }\n\n        // orbit camera around\n        camera.setLocalPosition(\n            16 * Math.sin(time * 0.2),\n            4,\n            16 * Math.cos(time * 0.2)\n        );\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}\n',nameSlug:"mesh-morph",categorySlug:"graphics"},"model-asset":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { statue: pc.Asset }): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    app.start();\n\n    // create an entity with render assets\n    const entity = assets.statue.resource.instantiateModelEntity({\n        castShadows: true\n    });\n\n    app.root.addChild(entity);\n\n    // clone a small version of the entity\n    const clone = entity.clone();\n    clone.setLocalScale(0.2, 0.2, 0.2);\n    clone.setLocalPosition(-4, 12, 0);\n    app.root.addChild(clone);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.translate(0, 7, 24);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100,\n        castShadows: true\n    });\n    light.translate(5, 0, 15);\n    app.root.addChild(light);\n\n    app.on("update", function (dt) {\n        if (entity) {\n            entity.rotate(0, 10 * dt, 0);\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    app.start();\n\n    // create an entity with render assets\n    const entity = assets.statue.resource.instantiateModelEntity({\n        castShadows: true,\n    });\n\n    app.root.addChild(entity);\n\n    // clone a small version of the entity\n    const clone = entity.clone();\n    clone.setLocalScale(0.2, 0.2, 0.2);\n    clone.setLocalPosition(-4, 12, 0);\n    app.root.addChild(clone);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.translate(0, 7, 24);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100,\n        castShadows: true,\n    });\n\n    light.translate(5, 0, 15);\n    app.root.addChild(light);\n\n    app.on("update", function (dt) {\n        if (entity) {\n            entity.rotate(0, 10 * dt, 0);\n        }\n    });\n}\n',nameSlug:"model-asset",categorySlug:"graphics"},"model-outline":{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // helper function to create a primitive with shape type, position, scale, color and layer\n    function createPrimitive(primitiveType: string, position: number | pc.Vec3, scale: number | pc.Vec3, color: pc.Color, layer: number[]) {\n        // create material of specified color\n        const material = new pc.StandardMaterial();\n        material.diffuse = color;\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent(\'render\', {\n            type: primitiveType,\n            layers: layer,\n            material: material\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create texture and render target for rendering into, including depth buffer\n    let texture = new pc.Texture(app.graphicsDevice, {\n        width: app.graphicsDevice.width,\n        height: app.graphicsDevice.height,\n        format: pc.PIXELFORMAT_R8_G8_B8_A8,\n        mipmaps: true,\n        minFilter: pc.FILTER_LINEAR,\n        magFilter: pc.FILTER_LINEAR\n    });\n    let renderTarget = new pc.RenderTarget({\n        colorBuffer: texture,\n        depth: true\n    });\n\n    // create a layer for rendering to texture, and add it to the beginning of layers to render into it first\n    const outlineLayer = new pc.Layer({ name: "OutlineLayer" });\n    app.scene.layers.insert(outlineLayer, 0);\n\n    // set up layer to render to the render target\n    outlineLayer.renderTarget = renderTarget;\n\n    // get world layer\n    const worldLayer = app.scene.layers.getLayerByName("World");\n\n    // create ground plane and 3 primitives, visible in both layers\n    createPrimitive("plane", new pc.Vec3(0, 0, 0), new pc.Vec3(20, 20, 20), new pc.Color(0.3, 0.5, 0.3), [worldLayer.id]);\n    createPrimitive("sphere", new pc.Vec3(-2, 1, 0), new pc.Vec3(2, 2, 2), new pc.Color(1, 0, 0), [worldLayer.id]);\n    createPrimitive("box", new pc.Vec3(2, 1, 0), new pc.Vec3(2, 2, 2), new pc.Color(1, 1, 0), [worldLayer.id, outlineLayer.id]);\n    createPrimitive("cone", new pc.Vec3(0, 1, -2), new pc.Vec3(2, 2, 2), new pc.Color(0, 1, 1), [worldLayer.id]);\n\n    // Create main camera, which renders entities in world layer\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.4),\n        layers: [worldLayer.id]\n    });\n    camera.translate(0, 20, 25);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // Create outline camera, which renders entities in outline layer\n    const outlineCamera = new pc.Entity();\n    outlineCamera.addComponent("camera", {\n        clearColor: new pc.Color(0.0, 0.0, 0.0, 0.0),\n        layers: [outlineLayer.id]\n    });\n    app.root.addChild(outlineCamera);\n\n    // @ts-ignore engine-tsd\n    const outline = new OutlineEffect(app.graphicsDevice, 3);\n    outline.color = new pc.Color(0, 0.5, 1, 1);\n    outline.texture = texture;\n    camera.camera.postEffects.addEffect(outline);\n\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component and add it to both layers\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 200,\n        castShadows: true,\n        layers: [worldLayer.id]\n    });\n    light.translate(0, 2, 5);\n    app.root.addChild(light);\n\n    // handle canvas resize\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n\n        camera.camera.postEffects.removeEffect(outline);\n\n        app.scene.layers.remove(outlineLayer);\n\n        texture.destroy();\n        texture = new pc.Texture(app.graphicsDevice, {\n            width: app.graphicsDevice.width,\n            height: app.graphicsDevice.height,\n            format: pc.PIXELFORMAT_R8_G8_B8_A8,\n            mipmaps: true,\n            minFilter: pc.FILTER_LINEAR,\n            magFilter: pc.FILTER_LINEAR\n        });\n        renderTarget.destroy();\n        renderTarget = new pc.RenderTarget({\n            colorBuffer: texture,\n            depth: true\n        });\n        outlineLayer.renderTarget = renderTarget;\n\n        app.scene.layers.insert(outlineLayer, 0);\n\n        outline.texture = texture;\n        camera.camera.postEffects.addEffect(outline);\n    });\n\n    // update things each frame\n    let time = 0;\n    // let switchTime = 0;\n    app.on("update", function (dt) {\n        // rotate cameras around the objects\n        time += dt;\n        camera.setLocalPosition(12 * Math.sin(time), 5, 12 * Math.cos(time));\n        camera.lookAt(pc.Vec3.ZERO);\n        outlineCamera.setLocalPosition(12 * Math.sin(time), 5, 12 * Math.cos(time));\n        outlineCamera.lookAt(pc.Vec3.ZERO);\n    });\n}',javaScriptFunction:'function example(canvas) {\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // helper function to create a primitive with shape type, position, scale, color and layer\n    function createPrimitive(primitiveType, position, scale, color, layer) {\n        // create material of specified color\n        const material = new pc.StandardMaterial();\n        material.diffuse = color;\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent("render", {\n            type: primitiveType,\n            layers: layer,\n            material: material,\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create texture and render target for rendering into, including depth buffer\n    let texture = new pc.Texture(app.graphicsDevice, {\n        width: app.graphicsDevice.width,\n        height: app.graphicsDevice.height,\n        format: pc.PIXELFORMAT_R8_G8_B8_A8,\n        mipmaps: true,\n        minFilter: pc.FILTER_LINEAR,\n        magFilter: pc.FILTER_LINEAR,\n    });\n\n    let renderTarget = new pc.RenderTarget({\n        colorBuffer: texture,\n        depth: true,\n    });\n\n    // create a layer for rendering to texture, and add it to the beginning of layers to render into it first\n    const outlineLayer = new pc.Layer({ name: "OutlineLayer" });\n    app.scene.layers.insert(outlineLayer, 0);\n\n    // set up layer to render to the render target\n    outlineLayer.renderTarget = renderTarget;\n\n    // get world layer\n    const worldLayer = app.scene.layers.getLayerByName("World");\n\n    // create ground plane and 3 primitives, visible in both layers\n    createPrimitive(\n        "plane",\n        new pc.Vec3(0, 0, 0),\n        new pc.Vec3(20, 20, 20),\n        new pc.Color(0.3, 0.5, 0.3),\n        [worldLayer.id]\n    );\n    createPrimitive(\n        "sphere",\n        new pc.Vec3(-2, 1, 0),\n        new pc.Vec3(2, 2, 2),\n        new pc.Color(1, 0, 0),\n        [worldLayer.id]\n    );\n    createPrimitive(\n        "box",\n        new pc.Vec3(2, 1, 0),\n        new pc.Vec3(2, 2, 2),\n        new pc.Color(1, 1, 0),\n        [worldLayer.id, outlineLayer.id]\n    );\n    createPrimitive(\n        "cone",\n        new pc.Vec3(0, 1, -2),\n        new pc.Vec3(2, 2, 2),\n        new pc.Color(0, 1, 1),\n        [worldLayer.id]\n    );\n\n    // Create main camera, which renders entities in world layer\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.4),\n        layers: [worldLayer.id],\n    });\n\n    camera.translate(0, 20, 25);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // Create outline camera, which renders entities in outline layer\n    const outlineCamera = new pc.Entity();\n    outlineCamera.addComponent("camera", {\n        clearColor: new pc.Color(0.0, 0.0, 0.0, 0.0),\n        layers: [outlineLayer.id],\n    });\n\n    app.root.addChild(outlineCamera);\n\n    // @ts-ignore engine-tsd\n    const outline = new OutlineEffect(app.graphicsDevice, 3);\n    outline.color = new pc.Color(0, 0.5, 1, 1);\n    outline.texture = texture;\n    camera.camera.postEffects.addEffect(outline);\n\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component and add it to both layers\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 200,\n        castShadows: true,\n        layers: [worldLayer.id],\n    });\n\n    light.translate(0, 2, 5);\n    app.root.addChild(light);\n\n    // handle canvas resize\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n\n        camera.camera.postEffects.removeEffect(outline);\n\n        app.scene.layers.remove(outlineLayer);\n\n        texture.destroy();\n        texture = new pc.Texture(app.graphicsDevice, {\n            width: app.graphicsDevice.width,\n            height: app.graphicsDevice.height,\n            format: pc.PIXELFORMAT_R8_G8_B8_A8,\n            mipmaps: true,\n            minFilter: pc.FILTER_LINEAR,\n            magFilter: pc.FILTER_LINEAR,\n        });\n\n        renderTarget.destroy();\n        renderTarget = new pc.RenderTarget({\n            colorBuffer: texture,\n            depth: true,\n        });\n\n        outlineLayer.renderTarget = renderTarget;\n\n        app.scene.layers.insert(outlineLayer, 0);\n\n        outline.texture = texture;\n        camera.camera.postEffects.addEffect(outline);\n    });\n\n    // update things each frame\n    let time = 0;\n    // let switchTime = 0;\n    app.on("update", function (dt) {\n        // rotate cameras around the objects\n        time += dt;\n        camera.setLocalPosition(12 * Math.sin(time), 5, 12 * Math.cos(time));\n        camera.lookAt(pc.Vec3.ZERO);\n        outlineCamera.setLocalPosition(\n            12 * Math.sin(time),\n            5,\n            12 * Math.cos(time)\n        );\n        outlineCamera.lookAt(pc.Vec3.ZERO);\n    });\n}\n',nameSlug:"model-outline",categorySlug:"graphics"},"model-textured-box":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { clouds: pc.Asset }): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create a Entity with a Box model component\n    const box = new pc.Entity();\n    box.addComponent("model", {\n        type: "box"\n    });\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 0, 0),\n        radius: 10\n    });\n    light.addComponent("model", {\n        type: "sphere"\n    });\n    // Scale the sphere down to 0.1m\n    light.setLocalScale(0.1, 0.1, 0.1);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n\n    // Add the new Entities to the hierarchy\n    app.root.addChild(box);\n    app.root.addChild(light);\n    app.root.addChild(camera);\n\n    // Move the camera 10m along the z-axis\n    camera.translate(0, 0, 10);\n\n    // Set an update function on the app\'s update event\n    let angle = 0;\n    app.on("update", function (dt) {\n        angle += dt;\n        if (angle > 360) {\n            angle = 0;\n        }\n\n        // Move the light in a circle\n        light.setLocalPosition(3 * Math.sin(angle), 0, 3 * Math.cos(angle));\n\n        // Rotate the box\n        box.setEulerAngles(angle * 2, angle * 4, angle * 8);\n    });\n\n    const material = new pc.StandardMaterial();\n    material.diffuseMap = assets.clouds.resource;\n    material.update();\n\n    box.model.material = material;\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create a Entity with a Box model component\n    const box = new pc.Entity();\n    box.addComponent("model", {\n        type: "box",\n    });\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 0, 0),\n        radius: 10,\n    });\n\n    light.addComponent("model", {\n        type: "sphere",\n    });\n\n    // Scale the sphere down to 0.1m\n    light.setLocalScale(0.1, 0.1, 0.1);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    // Add the new Entities to the hierarchy\n    app.root.addChild(box);\n    app.root.addChild(light);\n    app.root.addChild(camera);\n\n    // Move the camera 10m along the z-axis\n    camera.translate(0, 0, 10);\n\n    // Set an update function on the app\'s update event\n    let angle = 0;\n    app.on("update", function (dt) {\n        angle += dt;\n        if (angle > 360) {\n            angle = 0;\n        }\n\n        // Move the light in a circle\n        light.setLocalPosition(3 * Math.sin(angle), 0, 3 * Math.cos(angle));\n\n        // Rotate the box\n        box.setEulerAngles(angle * 2, angle * 4, angle * 8);\n    });\n\n    const material = new pc.StandardMaterial();\n    material.diffuseMap = assets.clouds.resource;\n    material.update();\n\n    box.model.material = material;\n}\n',nameSlug:"model-textured-box",categorySlug:"graphics"},painter:{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // helper function to create a primitive with shape type, position, scale, color and layer\n    function createPrimitive(primitiveType: string, position: number | pc.Vec3, scale: number | pc.Vec3, layer: number[], material: pc.StandardMaterial) {\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent(\'render\', {\n            type: primitiveType,\n            layers: layer,\n            material: material,\n            castShadows: false,\n            receiveShadows: false\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create texture and render target for rendering into\n    const texture = new pc.Texture(app.graphicsDevice, {\n        width: 1024,\n        height: 1024,\n        format: pc.PIXELFORMAT_R8_G8_B8,\n        mipmaps: false,\n        minFilter: pc.FILTER_LINEAR,\n        magFilter: pc.FILTER_LINEAR\n    });\n    const renderTarget = new pc.RenderTarget({\n        colorBuffer: texture,\n        depth: false\n    });\n\n    // create a layer for rendering to texture, and add it to the beginning of layers to render into it first\n    const paintLayer = new pc.Layer({ name: "paintLayer" });\n    app.scene.layers.insert(paintLayer, 0);\n\n    // create a material we use for the paint brush - it uses emissive color to control its color, which is assigned later\n    const brushMaterial = new pc.StandardMaterial();\n    brushMaterial.emissiveTint = true;\n    brushMaterial.useLighting = false;\n    brushMaterial.update();\n\n    // we render multiple brush imprints each frame to make smooth lines, and set up pool to reuse them each frame\n    const brushes: any[] = [];\n    function getBrush() {\n        let brush: pc.Entity;\n        if (brushes.length === 0) {\n            // create new brush - use sphere primitive, but could use plane with a texture as well\n            // Note: plane would need to be rotated by -90 degrees along x-axis to face camera and be visible\n            brush = createPrimitive("sphere", new pc.Vec3(2, 1, 0), new pc.Vec3(1, 1, 1), [paintLayer.id], brushMaterial);\n        } else {\n            // reuse already allocated brush\n            brush = brushes.pop();\n            brush.enabled = true;\n        }\n        return brush;\n    }\n\n    // Create orthographic camera, which renders brushes in paintLayer, and renders before the main camera\n    const paintCamera = new pc.Entity();\n    paintCamera.addComponent("camera", {\n        clearColorBuffer: false,\n        projection: pc.PROJECTION_ORTHOGRAPHIC,\n        layers: [paintLayer.id],\n        renderTarget: renderTarget,\n        priority: -1\n    });\n\n    // make it look at the center of the render target, some distance away\n    paintCamera.setLocalPosition(0, 0, -10);\n    paintCamera.lookAt(pc.Vec3.ZERO);\n    app.root.addChild(paintCamera);\n\n    // Create main camera, which renders entities in world layer - this is where we show the render target on the box\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2)\n    });\n    camera.translate(0, 0, 30);\n    camera.lookAt(pc.Vec3.ZERO);\n    app.root.addChild(camera);\n\n    // material used to add render target into the world\n    const material = new pc.StandardMaterial();\n    material.emissiveMap = texture;\n    material.useLighting = false;\n    material.update();\n\n    // create a box which we use to display rendered texture in the world layer\n    const worldLayer = app.scene.layers.getLayerByName("World");\n    const box = createPrimitive("box", new pc.Vec3(0, 0, 0), new pc.Vec3(15, 15, 15), [worldLayer.id], material);\n\n    let progress = 1;\n    let scale: number;\n    let startPos: pc.Vec3, endPos: pc.Vec3;\n    const pos = new pc.Vec3();\n    const usedBrushes: any[] = [];\n\n    // update things each frame\n    app.on("update", function (dt) {\n\n        // if the last brush stroke is finished, generate new random one\n        if (progress >= 1) {\n            progress = 0;\n\n            // generate start and end position for the stroke\n            startPos = new pc.Vec3(Math.random() * 20 - 10, Math.random() * 20 - 10, 0);\n            endPos = new pc.Vec3(Math.random() * 20 - 10, Math.random() * 20 - 10, 0);\n\n            // random width (scale)\n            scale = 0.1 + Math.random();\n\n            // assign random color to the brush\n            brushMaterial.emissive = new pc.Color(Math.random(), Math.random(), Math.random());\n            brushMaterial.update();\n        }\n\n        // disable brushes from the previous frame and return them to the free pool\n        while (usedBrushes.length > 0) {\n            const brush = usedBrushes.pop();\n            brush.enabled = false;\n            brushes.push(brush);\n        }\n\n        // step along the brush line multiple times each frame to make the line smooth\n        const stepCount = 30;\n        const stepProgress = 0.005;\n\n        // in each step\n        for (let i = 0; i < stepCount; i++) {\n\n            // move position little bit\n            pos.lerp(startPos, endPos, progress);\n\n            // setup brush to be rendered this frame\n            const activeBrush = getBrush();\n            activeBrush.setLocalPosition(pos);\n            activeBrush.setLocalScale(scale, scale, scale);\n            usedBrushes.push(activeBrush);\n\n            // progress for the next step\n            progress += stepProgress;\n        }\n\n        // rotate the box in the world\n        box.rotate(5 * dt, 10 * dt, 15 * dt);\n    });\n}',javaScriptFunction:'function example(canvas) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // helper function to create a primitive with shape type, position, scale, color and layer\n    function createPrimitive(primitiveType, position, scale, layer, material) {\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent("render", {\n            type: primitiveType,\n            layers: layer,\n            material: material,\n            castShadows: false,\n            receiveShadows: false,\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create texture and render target for rendering into\n    const texture = new pc.Texture(app.graphicsDevice, {\n        width: 1024,\n        height: 1024,\n        format: pc.PIXELFORMAT_R8_G8_B8,\n        mipmaps: false,\n        minFilter: pc.FILTER_LINEAR,\n        magFilter: pc.FILTER_LINEAR,\n    });\n\n    const renderTarget = new pc.RenderTarget({\n        colorBuffer: texture,\n        depth: false,\n    });\n\n    // create a layer for rendering to texture, and add it to the beginning of layers to render into it first\n    const paintLayer = new pc.Layer({ name: "paintLayer" });\n    app.scene.layers.insert(paintLayer, 0);\n\n    // create a material we use for the paint brush - it uses emissive color to control its color, which is assigned later\n    const brushMaterial = new pc.StandardMaterial();\n    brushMaterial.emissiveTint = true;\n    brushMaterial.useLighting = false;\n    brushMaterial.update();\n\n    // we render multiple brush imprints each frame to make smooth lines, and set up pool to reuse them each frame\n    const brushes = [];\n    function getBrush() {\n        let brush;\n        if (brushes.length === 0) {\n            // create new brush - use sphere primitive, but could use plane with a texture as well\n            // Note: plane would need to be rotated by -90 degrees along x-axis to face camera and be visible\n            brush = createPrimitive(\n                "sphere",\n                new pc.Vec3(2, 1, 0),\n                new pc.Vec3(1, 1, 1),\n                [paintLayer.id],\n                brushMaterial\n            );\n        } else {\n            // reuse already allocated brush\n            brush = brushes.pop();\n            brush.enabled = true;\n        }\n        return brush;\n    }\n\n    // Create orthographic camera, which renders brushes in paintLayer, and renders before the main camera\n    const paintCamera = new pc.Entity();\n    paintCamera.addComponent("camera", {\n        clearColorBuffer: false,\n        projection: pc.PROJECTION_ORTHOGRAPHIC,\n        layers: [paintLayer.id],\n        renderTarget: renderTarget,\n        priority: -1,\n    });\n\n    // make it look at the center of the render target, some distance away\n    paintCamera.setLocalPosition(0, 0, -10);\n    paintCamera.lookAt(pc.Vec3.ZERO);\n    app.root.addChild(paintCamera);\n\n    // Create main camera, which renders entities in world layer - this is where we show the render target on the box\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.2, 0.2),\n    });\n\n    camera.translate(0, 0, 30);\n    camera.lookAt(pc.Vec3.ZERO);\n    app.root.addChild(camera);\n\n    // material used to add render target into the world\n    const material = new pc.StandardMaterial();\n    material.emissiveMap = texture;\n    material.useLighting = false;\n    material.update();\n\n    // create a box which we use to display rendered texture in the world layer\n    const worldLayer = app.scene.layers.getLayerByName("World");\n    const box = createPrimitive(\n        "box",\n        new pc.Vec3(0, 0, 0),\n        new pc.Vec3(15, 15, 15),\n        [worldLayer.id],\n        material\n    );\n\n    let progress = 1;\n    let scale;\n    let startPos, endPos;\n    const pos = new pc.Vec3();\n    const usedBrushes = [];\n\n    // update things each frame\n    app.on("update", function (dt) {\n        // if the last brush stroke is finished, generate new random one\n        if (progress >= 1) {\n            progress = 0;\n\n            // generate start and end position for the stroke\n            startPos = new pc.Vec3(\n                Math.random() * 20 - 10,\n                Math.random() * 20 - 10,\n                0\n            );\n            endPos = new pc.Vec3(\n                Math.random() * 20 - 10,\n                Math.random() * 20 - 10,\n                0\n            );\n\n            // random width (scale)\n            scale = 0.1 + Math.random();\n\n            // assign random color to the brush\n            brushMaterial.emissive = new pc.Color(\n                Math.random(),\n                Math.random(),\n                Math.random()\n            );\n            brushMaterial.update();\n        }\n\n        // disable brushes from the previous frame and return them to the free pool\n        while (usedBrushes.length > 0) {\n            const brush = usedBrushes.pop();\n            brush.enabled = false;\n            brushes.push(brush);\n        }\n\n        // step along the brush line multiple times each frame to make the line smooth\n        const stepCount = 30;\n        const stepProgress = 0.005;\n\n        // in each step\n        for (let i = 0; i < stepCount; i++) {\n            // move position little bit\n            pos.lerp(startPos, endPos, progress);\n\n            // setup brush to be rendered this frame\n            const activeBrush = getBrush();\n            activeBrush.setLocalPosition(pos);\n            activeBrush.setLocalScale(scale, scale, scale);\n            usedBrushes.push(activeBrush);\n\n            // progress for the next step\n            progress += stepProgress;\n        }\n\n        // rotate the box in the world\n        box.rotate(5 * dt, 10 * dt, 15 * dt);\n    });\n}\n',nameSlug:"painter",categorySlug:"graphics"},"particles-anim-index":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { particlesNumbers: pc.Asset }): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0.75, 0.75, 0.75)\n    });\n    cameraEntity.rotateLocal(0, 0, 0);\n    cameraEntity.translateLocal(0, 0, 20);\n\n    // Create a directional light\n    const lightDirEntity = new pc.Entity();\n    lightDirEntity.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        intensity: 1\n    });\n    lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n    // Create a screen to display the particle texture\n    const screenEntity = new pc.Entity();\n    screenEntity.addComponent("screen", { resolution: new pc.Vec2(640, 480), screenSpace: true });\n    screenEntity.screen.scaleMode = "blend";\n    screenEntity.screen.referenceResolution = new pc.Vec2(1280, 720);\n\n    // Create a panel to display the full particle texture\n    const panel = new pc.Entity();\n    screenEntity.addChild(panel);\n\n    // Add Entities into the scene hierarchy\n    app.root.addChild(cameraEntity);\n    app.root.addChild(lightDirEntity);\n    app.root.addChild(screenEntity);\n\n    // Create entity for first particle system\n    const particleEntity1 = new pc.Entity();\n    app.root.addChild(particleEntity1);\n    particleEntity1.setLocalPosition(-3, 3, 0);\n\n    // Create entity for second particle system\n    const particleEntity2 = new pc.Entity();\n    app.root.addChild(particleEntity2);\n    particleEntity2.setLocalPosition(3, 3, 0);\n\n    // Create entity for third particle system\n    const particleEntity3 = new pc.Entity();\n    app.root.addChild(particleEntity3);\n    particleEntity3.setLocalPosition(-3, -3, 0);\n\n    // Create entity for fourth particle system\n    const particleEntity4 = new pc.Entity();\n    app.root.addChild(particleEntity4);\n    particleEntity4.setLocalPosition(3, -3, 0);\n\n    // when the texture is loaded add particlesystem components to particle entities\n\n    // gradually make sparks bigger\n    const scaleCurve = new pc.Curve(\n        [0, 0, 1, 1]\n    );\n\n    const particleSystemConfiguration = {\n        numParticles: 8,\n        lifetime: 4,\n        rate: 0.5,\n        colorMap: assets.particlesNumbers.resource,\n        initialVelocity: 0.25,\n        emitterShape: pc.EMITTERSHAPE_SPHERE,\n        emitterRadius: 0.1,\n        animLoop: true,\n        animTilesX: 4,\n        animTilesY: 4,\n        animSpeed: 1,\n        autoPlay: true,\n        scaleGraph: scaleCurve\n    };\n\n    let options;\n\n    options = Object.assign(particleSystemConfiguration, {\n        // states that each animation in the sprite sheet has 4 frames\n        animNumFrames: 4,\n        // set the animation index of the first particle system to 0\n        animIndex: 0\n    });\n    particleEntity1.addComponent("particlesystem", options);\n\n    options = Object.assign(particleSystemConfiguration, {\n        // states that each animation in the sprite sheet has 4 frames\n        animNumFrames: 4,\n        // set the animation index of the second particle system to 1\n        animIndex: 1\n    });\n    particleEntity2.addComponent("particlesystem", options);\n\n    options = Object.assign(particleSystemConfiguration, {\n        // states that each animation in the sprite sheet has 4 frames\n        animNumFrames: 4,\n        // set the animation index of the third particle system to 2\n        animIndex: 2\n    });\n    particleEntity3.addComponent("particlesystem", options);\n\n    options = Object.assign(particleSystemConfiguration, {\n        // states that each animation in the sprite sheet has 4 frames\n        animNumFrames: 4,\n        // set the animation index of the fourth particle system to 3\n        animIndex: 3\n    });\n    particleEntity4.addComponent("particlesystem", options);\n\n    // add the full particle texture to the panel\n    panel.addComponent(\'element\', {\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        pivot: new pc.Vec2(0.5, 0.5),\n        width: 100,\n        height: 100,\n        type: "image",\n        textureAsset: assets.particlesNumbers\n    });\n\n    app.start();\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0.75, 0.75, 0.75),\n    });\n\n    cameraEntity.rotateLocal(0, 0, 0);\n    cameraEntity.translateLocal(0, 0, 20);\n\n    // Create a directional light\n    const lightDirEntity = new pc.Entity();\n    lightDirEntity.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        intensity: 1,\n    });\n\n    lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n    // Create a screen to display the particle texture\n    const screenEntity = new pc.Entity();\n    screenEntity.addComponent("screen", {\n        resolution: new pc.Vec2(640, 480),\n        screenSpace: true,\n    });\n    screenEntity.screen.scaleMode = "blend";\n    screenEntity.screen.referenceResolution = new pc.Vec2(1280, 720);\n\n    // Create a panel to display the full particle texture\n    const panel = new pc.Entity();\n    screenEntity.addChild(panel);\n\n    // Add Entities into the scene hierarchy\n    app.root.addChild(cameraEntity);\n    app.root.addChild(lightDirEntity);\n    app.root.addChild(screenEntity);\n\n    // Create entity for first particle system\n    const particleEntity1 = new pc.Entity();\n    app.root.addChild(particleEntity1);\n    particleEntity1.setLocalPosition(-3, 3, 0);\n\n    // Create entity for second particle system\n    const particleEntity2 = new pc.Entity();\n    app.root.addChild(particleEntity2);\n    particleEntity2.setLocalPosition(3, 3, 0);\n\n    // Create entity for third particle system\n    const particleEntity3 = new pc.Entity();\n    app.root.addChild(particleEntity3);\n    particleEntity3.setLocalPosition(-3, -3, 0);\n\n    // Create entity for fourth particle system\n    const particleEntity4 = new pc.Entity();\n    app.root.addChild(particleEntity4);\n    particleEntity4.setLocalPosition(3, -3, 0);\n\n    // when the texture is loaded add particlesystem components to particle entities\n\n    // gradually make sparks bigger\n    const scaleCurve = new pc.Curve([0, 0, 1, 1]);\n\n    const particleSystemConfiguration = {\n        numParticles: 8,\n        lifetime: 4,\n        rate: 0.5,\n        colorMap: assets.particlesNumbers.resource,\n        initialVelocity: 0.25,\n        emitterShape: pc.EMITTERSHAPE_SPHERE,\n        emitterRadius: 0.1,\n        animLoop: true,\n        animTilesX: 4,\n        animTilesY: 4,\n        animSpeed: 1,\n        autoPlay: true,\n        scaleGraph: scaleCurve,\n    };\n\n    let options;\n\n    options = Object.assign(particleSystemConfiguration, {\n        // states that each animation in the sprite sheet has 4 frames\n        animNumFrames: 4,\n        // set the animation index of the first particle system to 0\n        animIndex: 0,\n    });\n\n    particleEntity1.addComponent("particlesystem", options);\n\n    options = Object.assign(particleSystemConfiguration, {\n        // states that each animation in the sprite sheet has 4 frames\n        animNumFrames: 4,\n        // set the animation index of the second particle system to 1\n        animIndex: 1,\n    });\n\n    particleEntity2.addComponent("particlesystem", options);\n\n    options = Object.assign(particleSystemConfiguration, {\n        // states that each animation in the sprite sheet has 4 frames\n        animNumFrames: 4,\n        // set the animation index of the third particle system to 2\n        animIndex: 2,\n    });\n\n    particleEntity3.addComponent("particlesystem", options);\n\n    options = Object.assign(particleSystemConfiguration, {\n        // states that each animation in the sprite sheet has 4 frames\n        animNumFrames: 4,\n        // set the animation index of the fourth particle system to 3\n        animIndex: 3,\n    });\n\n    particleEntity4.addComponent("particlesystem", options);\n\n    // add the full particle texture to the panel\n    panel.addComponent("element", {\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        pivot: new pc.Vec2(0.5, 0.5),\n        width: 100,\n        height: 100,\n        type: "image",\n        textureAsset: assets.particlesNumbers,\n    });\n\n    app.start();\n}\n',nameSlug:"particles-anim-index",categorySlug:"graphics"},"particles-random-sprites":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { particlesCoinsTexture: pc.Asset, particlesBonusTexture: pc.Asset }): void {\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0.23, 0.5, 0.75)\n    });\n    cameraEntity.rotateLocal(0, 0, 0);\n    cameraEntity.translateLocal(0, 0, 20);\n\n    // Create a directional light\n    const lightDirEntity = new pc.Entity();\n    lightDirEntity.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        intensity: 1\n    });\n    lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n    // Create a screen to display the particle systems textures\n    const screenEntity = new pc.Entity();\n    screenEntity.addComponent("screen", { resolution: new pc.Vec2(640, 480), screenSpace: true });\n    screenEntity.screen.scaleMode = "blend";\n    screenEntity.screen.referenceResolution = new pc.Vec2(1280, 720);\n\n    // Create a panel to display the full particle textures\n    const panel = new pc.Entity();\n    screenEntity.addChild(panel);\n    const panel2 = new pc.Entity();\n    screenEntity.addChild(panel2);\n\n    // Add Entities into the scene hierarchy\n    app.root.addChild(cameraEntity);\n    app.root.addChild(lightDirEntity);\n    app.root.addChild(screenEntity);\n\n    // Create entity for first particle system\n    const particleEntity1 = new pc.Entity();\n    app.root.addChild(particleEntity1);\n    particleEntity1.setLocalPosition(-3, 3, 0);\n\n    // Create entity for second particle system\n    const particleEntity2 = new pc.Entity();\n    app.root.addChild(particleEntity2);\n    particleEntity2.setLocalPosition(3, 3, 0);\n\n    // gradually make particles bigger\n    const scaleCurve = new pc.Curve(\n        [0, 0.1, 1, 0.5]\n    );\n\n    // make particles fade in and out\n    const alphaCurve = new pc.Curve(\n        [0, 0, 0.5, 1, 1, 0]\n    );\n\n    const particleSystemConfiguration = function (asset: any, animTilesX: any, animTilesY: any) {\n        return {\n            numParticles: 32,\n            lifetime: 2,\n            rate: 0.2,\n            colorMap: asset.resource,\n            initialVelocity: 0.125,\n            emitterShape: pc.EMITTERSHAPE_SPHERE,\n            emitterRadius: 2.0,\n            animLoop: true,\n            animTilesX: animTilesX,\n            animTilesY: animTilesY,\n            animSpeed: 4,\n            autoPlay: true,\n            alphaGraph: alphaCurve,\n            scaleGraph: scaleCurve\n        };\n    };\n\n    // add particlesystem component to particle entity\n    particleEntity1.addComponent("particlesystem", Object.assign(particleSystemConfiguration(assets.particlesCoinsTexture, 4, 6), {\n        // set the number of animations in the sprite sheet to 4\n        animNumAnimations: 4,\n        // set the number of frames in each animation to 6\n        animNumFrames: 6,\n        // set the particle system to randomly select a different animation for each particle\n        randomizeAnimIndex: true\n    }));\n\n    // display the full coin texture to the left of the panel\n    panel.addComponent(\'element\', {\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        pivot: new pc.Vec2(1.75, 1.0),\n        width: 150,\n        height: 225,\n        type: "image",\n        textureAsset: assets.particlesCoinsTexture\n    });\n\n    // add particlesystem component to particle entity\n    particleEntity2.addComponent("particlesystem", Object.assign(particleSystemConfiguration(assets.particlesBonusTexture, 4, 2), {\n        // set the number of animations in the sprite sheet to 7\n        animNumAnimations: 7,\n        // set the number of frames in each animation to 1\n        animNumFrames: 1,\n        // set the particle system to randomly select a different animation for each particle\n        randomizeAnimIndex: true\n    }));\n\n    // display the full bonus item texture to the left of the panel\n    panel2.addComponent(\'element\', {\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        pivot: new pc.Vec2(-0.5, 1.0),\n        width: 200,\n        height: 100,\n        type: "image",\n        textureAsset: assets.particlesBonusTexture\n    });\n\n    app.start();\n}',javaScriptFunction:'function example(canvas, assets) {\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0.23, 0.5, 0.75),\n    });\n\n    cameraEntity.rotateLocal(0, 0, 0);\n    cameraEntity.translateLocal(0, 0, 20);\n\n    // Create a directional light\n    const lightDirEntity = new pc.Entity();\n    lightDirEntity.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        intensity: 1,\n    });\n\n    lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n    // Create a screen to display the particle systems textures\n    const screenEntity = new pc.Entity();\n    screenEntity.addComponent("screen", {\n        resolution: new pc.Vec2(640, 480),\n        screenSpace: true,\n    });\n    screenEntity.screen.scaleMode = "blend";\n    screenEntity.screen.referenceResolution = new pc.Vec2(1280, 720);\n\n    // Create a panel to display the full particle textures\n    const panel = new pc.Entity();\n    screenEntity.addChild(panel);\n    const panel2 = new pc.Entity();\n    screenEntity.addChild(panel2);\n\n    // Add Entities into the scene hierarchy\n    app.root.addChild(cameraEntity);\n    app.root.addChild(lightDirEntity);\n    app.root.addChild(screenEntity);\n\n    // Create entity for first particle system\n    const particleEntity1 = new pc.Entity();\n    app.root.addChild(particleEntity1);\n    particleEntity1.setLocalPosition(-3, 3, 0);\n\n    // Create entity for second particle system\n    const particleEntity2 = new pc.Entity();\n    app.root.addChild(particleEntity2);\n    particleEntity2.setLocalPosition(3, 3, 0);\n\n    // gradually make particles bigger\n    const scaleCurve = new pc.Curve([0, 0.1, 1, 0.5]);\n\n    // make particles fade in and out\n    const alphaCurve = new pc.Curve([0, 0, 0.5, 1, 1, 0]);\n\n    const particleSystemConfiguration = function (\n        asset,\n        animTilesX,\n        animTilesY\n    ) {\n        return {\n            numParticles: 32,\n            lifetime: 2,\n            rate: 0.2,\n            colorMap: asset.resource,\n            initialVelocity: 0.125,\n            emitterShape: pc.EMITTERSHAPE_SPHERE,\n            emitterRadius: 2.0,\n            animLoop: true,\n            animTilesX: animTilesX,\n            animTilesY: animTilesY,\n            animSpeed: 4,\n            autoPlay: true,\n            alphaGraph: alphaCurve,\n            scaleGraph: scaleCurve,\n        };\n    };\n\n    // add particlesystem component to particle entity\n    particleEntity1.addComponent(\n        "particlesystem",\n        Object.assign(\n            particleSystemConfiguration(assets.particlesCoinsTexture, 4, 6),\n            {\n                // set the number of animations in the sprite sheet to 4\n                animNumAnimations: 4,\n                // set the number of frames in each animation to 6\n                animNumFrames: 6,\n                // set the particle system to randomly select a different animation for each particle\n                randomizeAnimIndex: true,\n            }\n        )\n    );\n\n    // display the full coin texture to the left of the panel\n    panel.addComponent("element", {\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        pivot: new pc.Vec2(1.75, 1.0),\n        width: 150,\n        height: 225,\n        type: "image",\n        textureAsset: assets.particlesCoinsTexture,\n    });\n\n    // add particlesystem component to particle entity\n    particleEntity2.addComponent(\n        "particlesystem",\n        Object.assign(\n            particleSystemConfiguration(assets.particlesBonusTexture, 4, 2),\n            {\n                // set the number of animations in the sprite sheet to 7\n                animNumAnimations: 7,\n                // set the number of frames in each animation to 1\n                animNumFrames: 1,\n                // set the particle system to randomly select a different animation for each particle\n                randomizeAnimIndex: true,\n            }\n        )\n    );\n\n    // display the full bonus item texture to the left of the panel\n    panel2.addComponent("element", {\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        pivot: new pc.Vec2(-0.5, 1.0),\n        width: 200,\n        height: 100,\n        type: "image",\n        textureAsset: assets.particlesBonusTexture,\n    });\n\n    app.start();\n}\n',nameSlug:"particles-random-sprites",categorySlug:"graphics"},"particles-snow":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { snowflake: pc.Asset }): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0, 0, 0)\n    });\n    cameraEntity.rotateLocal(0, 0, 0);\n    cameraEntity.translateLocal(0, 0, 10);\n\n    // Create a directional light\n    const lightDirEntity = new pc.Entity();\n    lightDirEntity.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        intensity: 1\n    });\n    lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n    // Add Entities into the scene hierarchy\n    app.root.addChild(cameraEntity);\n    app.root.addChild(lightDirEntity);\n\n\n    // set up random downwards velocity from -0.4 to -0.7\n    const velocityCurve = new pc.CurveSet([\n        [0, 0],     // x\n        [0, -0.7],  // y\n        [0, 0]      // z\n    ]);\n    const velocityCurve2 = new pc.CurveSet([\n        [0, 0],   // x\n        [0, -0.4], // y\n        [0, 0]    // z\n    ]);\n\n    // set up random rotation speed from -100 to 100 degrees per second\n    const rotCurve = new pc.Curve([0, 100]);\n    const rotCurve2 = new pc.Curve([0, -100]);\n\n    // scale is constant at 0.1\n    const scaleCurve = new pc.Curve([0, 0.1]);\n\n    // Create entity for particle system\n    const entity = new pc.Entity();\n    app.root.addChild(entity);\n    entity.setLocalPosition(0, 3, 0);\n\n    // load snowflake texture\n    app.assets.loadFromUrl(\'/static/assets/textures/snowflake.png\', \'texture\', function (err, asset) {\n        // when texture is loaded add particlesystem component to entity\n        entity.addComponent("particlesystem", {\n            numParticles: 100,\n            lifetime: 10,\n            rate: 0.1,\n            startAngle: 360,\n            startAngle2: -360,\n            emitterExtents: new pc.Vec3(5, 0, 0),\n            velocityGraph: velocityCurve,\n            velocityGraph2: velocityCurve2,\n            scaleGraph: scaleCurve,\n            rotationSpeedGraph: rotCurve,\n            rotationSpeedGraph2: rotCurve2,\n            colorMap: assets.snowflake.resource\n        });\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0, 0, 0),\n    });\n\n    cameraEntity.rotateLocal(0, 0, 0);\n    cameraEntity.translateLocal(0, 0, 10);\n\n    // Create a directional light\n    const lightDirEntity = new pc.Entity();\n    lightDirEntity.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        intensity: 1,\n    });\n\n    lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n    // Add Entities into the scene hierarchy\n    app.root.addChild(cameraEntity);\n    app.root.addChild(lightDirEntity);\n\n    // set up random downwards velocity from -0.4 to -0.7\n    const velocityCurve = new pc.CurveSet([\n        [0, 0], // x\n        [0, -0.7], // y\n        [0, 0], // z\n    ]);\n    const velocityCurve2 = new pc.CurveSet([\n        [0, 0], // x\n        [0, -0.4], // y\n        [0, 0], // z\n    ]);\n\n    // set up random rotation speed from -100 to 100 degrees per second\n    const rotCurve = new pc.Curve([0, 100]);\n    const rotCurve2 = new pc.Curve([0, -100]);\n\n    // scale is constant at 0.1\n    const scaleCurve = new pc.Curve([0, 0.1]);\n\n    // Create entity for particle system\n    const entity = new pc.Entity();\n    app.root.addChild(entity);\n    entity.setLocalPosition(0, 3, 0);\n\n    // load snowflake texture\n    app.assets.loadFromUrl(\n        "/static/assets/textures/snowflake.png",\n        "texture",\n        function (err, asset) {\n            // when texture is loaded add particlesystem component to entity\n            entity.addComponent("particlesystem", {\n                numParticles: 100,\n                lifetime: 10,\n                rate: 0.1,\n                startAngle: 360,\n                startAngle2: -360,\n                emitterExtents: new pc.Vec3(5, 0, 0),\n                velocityGraph: velocityCurve,\n                velocityGraph2: velocityCurve2,\n                scaleGraph: scaleCurve,\n                rotationSpeedGraph: rotCurve,\n                rotationSpeedGraph2: rotCurve2,\n                colorMap: assets.snowflake.resource,\n            });\n        }\n    );\n}\n',nameSlug:"particles-snow",categorySlug:"graphics"},"particles-spark":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { spark: pc.Asset }): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0, 0, 0.05)\n    });\n    cameraEntity.rotateLocal(0, 0, 0);\n    cameraEntity.translateLocal(0, 0, 10);\n\n    // Create a directional light\n    const lightDirEntity = new pc.Entity();\n    lightDirEntity.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        intensity: 1\n    });\n    lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n    // Add Entities into the scene hierarchy\n    app.root.addChild(cameraEntity);\n    app.root.addChild(lightDirEntity);\n\n\n    // Offset position\n    const localPosCurve = new pc.CurveSet([\n        [0, 0, 1, 4],\n        [0, 0, 1, 3],\n        [0, 0, 1, 0]\n    ]);\n    localPosCurve.type = pc.CURVE_LINEAR;\n\n    // make particles move in different directions\n    const localVelocityCurve = new pc.CurveSet([\n        [0, 0, 1, 8],\n        [0, 0, 1, 6],\n        [0, 0, 1, 0]\n    ]);\n    const localVelocityCurve2 = new pc.CurveSet([\n        [0, 0, 1, -8],\n        [0, 0, 1, -6],\n        [0, 0, 1, 0]\n    ]);\n\n    // increasing gravity\n    const worldVelocityCurve = new pc.CurveSet([\n        [0, 0],\n        [0, 0, 0.2, 6, 1, -48],\n        [0, 0]\n    ]);\n\n    // gradually make sparks bigger\n    const scaleCurve = new pc.Curve(\n        [0, 0, 0.5, 0.3, 0.8, 0.2, 1, 0.1]\n    );\n\n    // rotate sparks 360 degrees per second\n    const angleCurve = new pc.Curve(\n        [0, 360]\n    );\n\n    // color changes throughout lifetime\n    const colorCurve = new pc.CurveSet([\n        [0, 1, 0.25, 1, 0.375, 0.5, 0.5, 0],\n        [0, 0, 0.125, 0.25, 0.25, 0.5, 0.375, 0.75, 0.5, 1],\n        [0, 0, 1, 0]\n    ]);\n\n    // Create entity for particle system\n    const entity = new pc.Entity();\n    app.root.addChild(entity);\n    entity.setLocalPosition(0, 0, 0);\n\n    // when texture is loaded add particlesystem component to entity\n    entity.addComponent("particlesystem", {\n        numParticles: 200,\n        lifetime: 2,\n        rate: 0.01,\n        scaleGraph: scaleCurve,\n        rotationSpeedGraph: angleCurve,\n        colorGraph: colorCurve,\n        colorMap: assets.spark.resource,\n        velocityGraph: worldVelocityCurve,\n        localVelocityGraph: localVelocityCurve,\n        localVelocityGraph2: localVelocityCurve2\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const cameraEntity = new pc.Entity();\n    cameraEntity.addComponent("camera", {\n        clearColor: new pc.Color(0, 0, 0.05),\n    });\n\n    cameraEntity.rotateLocal(0, 0, 0);\n    cameraEntity.translateLocal(0, 0, 10);\n\n    // Create a directional light\n    const lightDirEntity = new pc.Entity();\n    lightDirEntity.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        intensity: 1,\n    });\n\n    lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n    // Add Entities into the scene hierarchy\n    app.root.addChild(cameraEntity);\n    app.root.addChild(lightDirEntity);\n\n    // Offset position\n    const localPosCurve = new pc.CurveSet([\n        [0, 0, 1, 4],\n        [0, 0, 1, 3],\n        [0, 0, 1, 0],\n    ]);\n\n    localPosCurve.type = pc.CURVE_LINEAR;\n\n    // make particles move in different directions\n    const localVelocityCurve = new pc.CurveSet([\n        [0, 0, 1, 8],\n        [0, 0, 1, 6],\n        [0, 0, 1, 0],\n    ]);\n\n    const localVelocityCurve2 = new pc.CurveSet([\n        [0, 0, 1, -8],\n        [0, 0, 1, -6],\n        [0, 0, 1, 0],\n    ]);\n\n    // increasing gravity\n    const worldVelocityCurve = new pc.CurveSet([\n        [0, 0],\n        [0, 0, 0.2, 6, 1, -48],\n        [0, 0],\n    ]);\n\n    // gradually make sparks bigger\n    const scaleCurve = new pc.Curve([0, 0, 0.5, 0.3, 0.8, 0.2, 1, 0.1]);\n\n    // rotate sparks 360 degrees per second\n    const angleCurve = new pc.Curve([0, 360]);\n\n    // color changes throughout lifetime\n    const colorCurve = new pc.CurveSet([\n        [0, 1, 0.25, 1, 0.375, 0.5, 0.5, 0],\n        [0, 0, 0.125, 0.25, 0.25, 0.5, 0.375, 0.75, 0.5, 1],\n        [0, 0, 1, 0],\n    ]);\n\n    // Create entity for particle system\n    const entity = new pc.Entity();\n    app.root.addChild(entity);\n    entity.setLocalPosition(0, 0, 0);\n\n    // when texture is loaded add particlesystem component to entity\n    entity.addComponent("particlesystem", {\n        numParticles: 200,\n        lifetime: 2,\n        rate: 0.01,\n        scaleGraph: scaleCurve,\n        rotationSpeedGraph: angleCurve,\n        colorGraph: colorCurve,\n        colorMap: assets.spark.resource,\n        velocityGraph: worldVelocityCurve,\n        localVelocityGraph: localVelocityCurve,\n        localVelocityGraph2: localVelocityCurve2,\n    });\n}\n',nameSlug:"particles-spark",categorySlug:"graphics"},"point-cloud-simulation":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: any): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0, 0, 0)\n    });\n\n    // Add entity into scene hierarchy\n    app.root.addChild(camera);\n\n    // allocate two buffers to store positions of particles\n    const maxNumPoints = 100000;\n    let visiblePoints = 10000;\n    const positions = new Float32Array(3 * maxNumPoints);\n    const oldPositions = new Float32Array(3 * maxNumPoints);\n\n    // generate random positions and old positions within small cube (delta between them represents velocity)\n    for (let i = 0; i < 3 * maxNumPoints; i++) {\n        positions[i] = Math.random() * 2 - 1;\n        oldPositions[i] = positions[i] + Math.random() * 0.04 - 0.01;\n    }\n\n    // helper function to update vertex of the mesh\n    function updateMesh(mesh: pc.Mesh) {\n\n        // Set current positions on mesh - this reallocates vertex buffer if more space is needed to test it.\n        // For best performance, we could preallocate enough space using mesh.Clear.\n        // Also turn off bounding box generation, as we set up large box manually\n        mesh.setPositions(positions, 3, visiblePoints);\n        mesh.update(pc.PRIMITIVE_POINTS, false);\n    }\n\n    // Create a mesh with dynamic vertex buffer (index buffer is not needed)\n    const mesh = new pc.Mesh(app.graphicsDevice);\n    mesh.clear(true);\n    updateMesh(mesh);\n\n    // set large bounding box so we don't need to update it each frame\n    mesh.aabb = new pc.BoundingBox(new pc.Vec3(0, 0, 0), new pc.Vec3(15, 15, 15));\n\n    // Create the shader from the vertex and fragment shaders\n    const shader = new pc.Shader(app.graphicsDevice, {\n        attributes: { aPosition: pc.SEMANTIC_POSITION },\n        vshader: assets['shader.vert'].data,\n        fshader: assets['shader.frag'].data\n    });\n\n    // Create a new material with the new shader and additive alpha blending\n    const material = new pc.Material();\n    material.shader = shader;\n    material.blendType = pc.BLEND_ADDITIVEALPHA;\n    material.depthWrite = false;\n\n    // Create the mesh instance\n    const meshInstance = new pc.MeshInstance(mesh, material);\n\n    // Create Entity to render the mesh instances using a render component\n    const entity = new pc.Entity();\n    entity.addComponent(\"render\", {\n        type: 'asset',\n        meshInstances: [meshInstance],\n        material: material,\n        castShadows: false\n    });\n    app.root.addChild(entity);\n\n    // Set an update function on the app's update event\n    let time = 0, previousTime;\n    app.on(\"update\", function (dt) {\n        previousTime = time;\n        time += dt;\n\n        // update particle positions using simple Verlet integration, and keep them inside a sphere boundary\n        let dist;\n        const pos = new pc.Vec3();\n        const old = new pc.Vec3();\n        const delta = new pc.Vec3();\n        const next = new pc.Vec3();\n        for (let i = 0; i < maxNumPoints; i++) {\n\n            // read positions from buffers\n            old.set(oldPositions[i * 3], oldPositions[i * 3 + 1], oldPositions[i * 3 + 2]);\n            pos.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);\n\n            // verlet integration to move them\n            delta.sub2(pos, old);\n            next.add2(pos, delta);\n\n            // boundary collision to keep them inside a sphere. If outside, simply move them in opposite direction\n            dist = next.length();\n            if (dist > 15)\n                next.copy(old);\n\n            // write out changed positions\n            positions[i * 3] = next.x;\n            positions[i * 3 + 1] = next.y;\n            positions[i * 3 + 2] = next.z;\n\n            oldPositions[i * 3] = pos.x;\n            oldPositions[i * 3 + 1] = pos.y;\n            oldPositions[i * 3 + 2] = pos.z;\n        }\n\n        // once a second change how many points are visible\n        if (Math.round(time) !== Math.round(previousTime))\n            visiblePoints = Math.floor(50000 + Math.random() * maxNumPoints - 50000);\n\n        // update mesh vertices\n        updateMesh(mesh);\n\n        // Rotate the camera around\n        const cameraTime = time * 0.2;\n        const cameraPos = new pc.Vec3(20 * Math.sin(cameraTime), 10, 20 * Math.cos(cameraTime));\n        camera.setLocalPosition(cameraPos);\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}",javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0, 0, 0),\n    });\n\n    // Add entity into scene hierarchy\n    app.root.addChild(camera);\n\n    // allocate two buffers to store positions of particles\n    const maxNumPoints = 100000;\n    let visiblePoints = 10000;\n    const positions = new Float32Array(3 * maxNumPoints);\n    const oldPositions = new Float32Array(3 * maxNumPoints);\n\n    // generate random positions and old positions within small cube (delta between them represents velocity)\n    for (let i = 0; i < 3 * maxNumPoints; i++) {\n        positions[i] = Math.random() * 2 - 1;\n        oldPositions[i] = positions[i] + Math.random() * 0.04 - 0.01;\n    }\n\n    // helper function to update vertex of the mesh\n    function updateMesh(mesh) {\n        // Set current positions on mesh - this reallocates vertex buffer if more space is needed to test it.\n        // For best performance, we could preallocate enough space using mesh.Clear.\n        // Also turn off bounding box generation, as we set up large box manually\n        mesh.setPositions(positions, 3, visiblePoints);\n        mesh.update(pc.PRIMITIVE_POINTS, false);\n    }\n\n    // Create a mesh with dynamic vertex buffer (index buffer is not needed)\n    const mesh = new pc.Mesh(app.graphicsDevice);\n    mesh.clear(true);\n    updateMesh(mesh);\n\n    // set large bounding box so we don\'t need to update it each frame\n    mesh.aabb = new pc.BoundingBox(\n        new pc.Vec3(0, 0, 0),\n        new pc.Vec3(15, 15, 15)\n    );\n\n    // Create the shader from the vertex and fragment shaders\n    const shader = new pc.Shader(app.graphicsDevice, {\n        attributes: { aPosition: pc.SEMANTIC_POSITION },\n        vshader: assets["shader.vert"].data,\n        fshader: assets["shader.frag"].data,\n    });\n\n    // Create a new material with the new shader and additive alpha blending\n    const material = new pc.Material();\n    material.shader = shader;\n    material.blendType = pc.BLEND_ADDITIVEALPHA;\n    material.depthWrite = false;\n\n    // Create the mesh instance\n    const meshInstance = new pc.MeshInstance(mesh, material);\n\n    // Create Entity to render the mesh instances using a render component\n    const entity = new pc.Entity();\n    entity.addComponent("render", {\n        type: "asset",\n        meshInstances: [meshInstance],\n        material: material,\n        castShadows: false,\n    });\n\n    app.root.addChild(entity);\n\n    // Set an update function on the app\'s update event\n    let time = 0,\n        previousTime;\n    app.on("update", function (dt) {\n        previousTime = time;\n        time += dt;\n\n        // update particle positions using simple Verlet integration, and keep them inside a sphere boundary\n        let dist;\n        const pos = new pc.Vec3();\n        const old = new pc.Vec3();\n        const delta = new pc.Vec3();\n        const next = new pc.Vec3();\n        for (let i = 0; i < maxNumPoints; i++) {\n            // read positions from buffers\n            old.set(\n                oldPositions[i * 3],\n                oldPositions[i * 3 + 1],\n                oldPositions[i * 3 + 2]\n            );\n            pos.set(\n                positions[i * 3],\n                positions[i * 3 + 1],\n                positions[i * 3 + 2]\n            );\n\n            // verlet integration to move them\n            delta.sub2(pos, old);\n            next.add2(pos, delta);\n\n            // boundary collision to keep them inside a sphere. If outside, simply move them in opposite direction\n            dist = next.length();\n            if (dist > 15) next.copy(old);\n\n            // write out changed positions\n            positions[i * 3] = next.x;\n            positions[i * 3 + 1] = next.y;\n            positions[i * 3 + 2] = next.z;\n\n            oldPositions[i * 3] = pos.x;\n            oldPositions[i * 3 + 1] = pos.y;\n            oldPositions[i * 3 + 2] = pos.z;\n        }\n\n        // once a second change how many points are visible\n        if (Math.round(time) !== Math.round(previousTime))\n            visiblePoints = Math.floor(\n                50000 + Math.random() * maxNumPoints - 50000\n            );\n\n        // update mesh vertices\n        updateMesh(mesh);\n\n        // Rotate the camera around\n        const cameraTime = time * 0.2;\n        const cameraPos = new pc.Vec3(\n            20 * Math.sin(cameraTime),\n            10,\n            20 * Math.cos(cameraTime)\n        );\n        camera.setLocalPosition(cameraPos);\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}\n',nameSlug:"point-cloud-simulation",categorySlug:"graphics"},"point-cloud":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: any): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n    camera.translate(0, 7, 24);\n\n    // Add entity into scene hierarchy\n    app.root.addChild(camera);\n    app.start();\n\n    // Create a new Entity\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    // Create the shader definition and shader from the vertex and fragment shaders\n    const shaderDefinition = {\n        attributes: {\n            aPosition: pc.SEMANTIC_POSITION\n        },\n        vshader: assets['shader.vert'].data,\n        fshader: assets['shader.frag'].data\n    };\n    const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n    // Create a new material with the new shader\n    const material = new pc.Material();\n    material.shader = shader;\n\n    // find all render components\n    const renderComponents = entity.findComponents('render');\n\n    // for all render components\n    renderComponents.forEach(function (render: any) {\n\n        // For all meshes in the render component, assign new material\n        render.meshInstances.forEach(function (meshInstance: pc.MeshInstance) {\n            meshInstance.material = material;\n        });\n\n        // set it to render as points\n        render.renderStyle = pc.RENDERSTYLE_POINTS;\n    });\n\n    let currentTime = 0;\n    app.on(\"update\", function (dt) {\n\n        // Update the time and pass it to shader\n        currentTime += dt;\n        material.setParameter('uTime', currentTime);\n\n        // Rotate the model\n        entity.rotate(0, 15 * dt, 0);\n    });\n}",javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    camera.translate(0, 7, 24);\n\n    // Add entity into scene hierarchy\n    app.root.addChild(camera);\n    app.start();\n\n    // Create a new Entity\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    // Create the shader definition and shader from the vertex and fragment shaders\n    const shaderDefinition = {\n        attributes: {\n            aPosition: pc.SEMANTIC_POSITION,\n        },\n\n        vshader: assets["shader.vert"].data,\n        fshader: assets["shader.frag"].data,\n    };\n\n    const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n    // Create a new material with the new shader\n    const material = new pc.Material();\n    material.shader = shader;\n\n    // find all render components\n    const renderComponents = entity.findComponents("render");\n\n    // for all render components\n    renderComponents.forEach(function (render) {\n        // For all meshes in the render component, assign new material\n        render.meshInstances.forEach(function (meshInstance) {\n            meshInstance.material = material;\n        });\n\n        // set it to render as points\n        render.renderStyle = pc.RENDERSTYLE_POINTS;\n    });\n\n    let currentTime = 0;\n    app.on("update", function (dt) {\n        // Update the time and pass it to shader\n        currentTime += dt;\n        material.setParameter("uTime", currentTime);\n\n        // Rotate the model\n        entity.rotate(0, 15 * dt, 0);\n    });\n}\n',nameSlug:"point-cloud",categorySlug:"graphics"},portal:{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: any): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        keyboard: new pc.Keyboard(window)\n    });\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.start();\n\n    // set skybox - this DDS file was 'prefiltered' in the PlayCanvas Editor and then downloaded.\n    app.scene.setSkybox(assets[\"helipad.dds\"].resources);\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    app.scene.skyboxMip = 1;\n    app.scene.skyboxIntensity = 0.7;\n\n    ////////////////////////////////\n    // Script to rotate the scene //\n    ////////////////////////////////\n    const Rotator = pc.createScript('rotator');\n\n    let t = 0;\n\n    Rotator.prototype.update = function (dt: number) {\n        t += dt;\n        this.entity.setEulerAngles(0, Math.sin(t) * 40, 0);\n    };\n\n    //////////////////////////////////////////////////\n    // Script to set up rendering the portal itself //\n    //////////////////////////////////////////////////\n    const Portal = pc.createScript('portal');\n\n    // initialize code called once per entity\n    Portal.prototype.initialize = function () {\n\n        // increment value in stencil (from 0 to 1) for stencil geometry\n        const stencil = new pc.StencilParameters({\n            zpass: pc.STENCILOP_INCREMENT\n        });\n\n        // set the stencil and other parameters on all materials\n        const renders: Array<pc.RenderComponent> = this.entity.findComponents(\"render\");\n        renders.forEach((render) => {\n            for (const meshInstance of render.meshInstances) {\n                const mat = meshInstance.material;\n                mat.stencilBack = mat.stencilFront = stencil;\n\n                // We only want to write to the stencil buffer\n                mat.depthWrite = false;\n                mat.redWrite = mat.greenWrite = mat.blueWrite = mat.alphaWrite = false;\n                mat.update();\n            }\n        });\n    };\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Script to set stencil options for entities inside or outside the portal //\n    /////////////////////////////////////////////////////////////////////////////\n\n    const PortalGeometry = pc.createScript('portalGeometry');\n\n    PortalGeometry.attributes.add('inside', {\n        type: 'boolean',\n        default: true,\n        title: 'True indicating the geometry is inside the portal, false for outside',\n    });\n\n    PortalGeometry.prototype.initialize = function () {\n\n        // based on value in the stencil buffer (0 outside, 1 inside), either render\n        // the geometry when the value is equal, or not equal to zero.\n        const stencil = new pc.StencilParameters({\n            func: this.inside ? pc.FUNC_NOTEQUAL : pc.FUNC_EQUAL,\n            ref: 0\n        });\n\n        // set the stencil parameters on all materials\n        const renders: Array<pc.RenderComponent> = this.entity.findComponents(\"render\");\n        renders.forEach((render) => {\n            for (const meshInstance of render.meshInstances) {\n                meshInstance.material.stencilBack = meshInstance.material.stencilFront = stencil;\n            }\n        });\n    };\n\n    /////////////////////////////////////////////////////////////////////////////\n\n    // find world layer - majority of objects render to this layer\n    const worldLayer = app.scene.layers.getLayerByName(\"World\");\n\n    // find skybox layer - to enable it for the camera\n    const skyboxLayer = app.scene.layers.getLayerByName(\"Skybox\");\n\n    // portal layer - this is where the portal geometry is written to the stencil\n    // buffer, and this needs to render first, so insert it before the world layer\n    const portalLayer = new pc.Layer({ name: \"Portal\" });\n    app.scene.layers.insert(portalLayer, 0);\n\n    // Create an Entity with a camera component\n    // this camera renders both world and portal layers\n    const camera = new pc.Entity();\n    camera.addComponent('camera', {\n        layers: [worldLayer.id, portalLayer.id, skyboxLayer.id]\n    });\n    camera.setLocalPosition(7, 5.5, 7.1);\n    camera.setLocalEulerAngles(-27, 45, 0);\n    app.root.addChild(camera);\n\n    // Create an Entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent('light', {\n        type: 'directional',\n        color: new pc.Color(1, 1, 1)\n    });\n    light.setEulerAngles(45, 35, 0);\n    app.root.addChild(light);\n\n    // Create a root for the graphical scene\n    const group = new pc.Entity();\n    group.addComponent('script');\n    group.script.create('rotator');\n    app.root.addChild(group);\n\n    // Create the portal entity - this plane is written to stencil buffer,\n    // which is then used to test for inside / outside. This needs to render\n    // before all elements requiring stencil buffer, so add to to a portalLayer.\n    // This is the plane that fills the inside of the portal geometry.\n    const portal = new pc.Entity(\"Portal\");\n    portal.addComponent('render', {\n        type: 'plane',\n        material: new pc.StandardMaterial(),\n        layers: [portalLayer.id]\n    });\n    portal.addComponent('script');\n    portal.script.create('portal'); // comment out this line to see the geometry\n    portal.setLocalPosition(0, 0.4, -0.3);\n    portal.setLocalEulerAngles(90, 0, 0);\n    portal.setLocalScale(3.7, 1, 6.7);\n    group.addChild(portal);\n\n    // Create the portal visual geometry\n    const portalEntity = assets.portal.resource.instantiateRenderEntity();\n    portalEntity.setLocalPosition(0, -3, 0);\n    portalEntity.setLocalScale(0.02, 0.02, 0.02);\n    group.addChild(portalEntity);\n\n    // Create a statue entity, whic is visible inside the portal only\n    const statue = assets.statue.resource.instantiateRenderEntity();\n    statue.addComponent('script');\n    statue.script.create('portalGeometry', {\n        attributes: {\n            inside: true\n        }\n    });\n    statue.setLocalPosition(0, -1, -2);\n    statue.setLocalScale(0.25, 0.25, 0.25);\n    group.addChild(statue);\n\n    // Create a bitmoji entity, whic is visible outside the portal only\n    const bitmoji = assets.bitmoji.resource.instantiateRenderEntity();\n    bitmoji.addComponent('script');\n    bitmoji.script.create('portalGeometry', {\n        attributes: {\n            inside: false\n        }\n    });\n    bitmoji.setLocalPosition(0, -1, -2);\n    bitmoji.setLocalScale(2.5, 2.5, 2.5);\n    group.addChild(bitmoji);\n}",javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        keyboard: new pc.Keyboard(window),\n    });\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.start();\n\n    // set skybox - this DDS file was \'prefiltered\' in the PlayCanvas Editor and then downloaded.\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    app.scene.skyboxMip = 1;\n    app.scene.skyboxIntensity = 0.7;\n\n    ////////////////////////////////\n    // Script to rotate the scene //\n    ////////////////////////////////\n    const Rotator = pc.createScript("rotator");\n\n    let t = 0;\n\n    Rotator.prototype.update = function (dt) {\n        t += dt;\n        this.entity.setEulerAngles(0, Math.sin(t) * 40, 0);\n    };\n\n    //////////////////////////////////////////////////\n    // Script to set up rendering the portal itself //\n    //////////////////////////////////////////////////\n    const Portal = pc.createScript("portal");\n\n    // initialize code called once per entity\n    Portal.prototype.initialize = function () {\n        // increment value in stencil (from 0 to 1) for stencil geometry\n        const stencil = new pc.StencilParameters({\n            zpass: pc.STENCILOP_INCREMENT,\n        });\n\n        // set the stencil and other parameters on all materials\n        const renders = this.entity.findComponents("render");\n        renders.forEach((render) => {\n            for (const meshInstance of render.meshInstances) {\n                const mat = meshInstance.material;\n                mat.stencilBack = mat.stencilFront = stencil;\n\n                // We only want to write to the stencil buffer\n                mat.depthWrite = false;\n                mat.redWrite =\n                    mat.greenWrite =\n                    mat.blueWrite =\n                    mat.alphaWrite =\n                        false;\n                mat.update();\n            }\n        });\n    };\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Script to set stencil options for entities inside or outside the portal //\n    /////////////////////////////////////////////////////////////////////////////\n\n    const PortalGeometry = pc.createScript("portalGeometry");\n\n    PortalGeometry.attributes.add("inside", {\n        type: "boolean",\n        default: true,\n        title: "True indicating the geometry is inside the portal, false for outside",\n    });\n\n    PortalGeometry.prototype.initialize = function () {\n        // based on value in the stencil buffer (0 outside, 1 inside), either render\n        // the geometry when the value is equal, or not equal to zero.\n        const stencil = new pc.StencilParameters({\n            func: this.inside ? pc.FUNC_NOTEQUAL : pc.FUNC_EQUAL,\n            ref: 0,\n        });\n\n        // set the stencil parameters on all materials\n        const renders = this.entity.findComponents("render");\n        renders.forEach((render) => {\n            for (const meshInstance of render.meshInstances) {\n                meshInstance.material.stencilBack =\n                    meshInstance.material.stencilFront = stencil;\n            }\n        });\n    };\n\n    /////////////////////////////////////////////////////////////////////////////\n\n    // find world layer - majority of objects render to this layer\n    const worldLayer = app.scene.layers.getLayerByName("World");\n\n    // find skybox layer - to enable it for the camera\n    const skyboxLayer = app.scene.layers.getLayerByName("Skybox");\n\n    // portal layer - this is where the portal geometry is written to the stencil\n    // buffer, and this needs to render first, so insert it before the world layer\n    const portalLayer = new pc.Layer({ name: "Portal" });\n    app.scene.layers.insert(portalLayer, 0);\n\n    // Create an Entity with a camera component\n    // this camera renders both world and portal layers\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        layers: [worldLayer.id, portalLayer.id, skyboxLayer.id],\n    });\n\n    camera.setLocalPosition(7, 5.5, 7.1);\n    camera.setLocalEulerAngles(-27, 45, 0);\n    app.root.addChild(camera);\n\n    // Create an Entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n    });\n\n    light.setEulerAngles(45, 35, 0);\n    app.root.addChild(light);\n\n    // Create a root for the graphical scene\n    const group = new pc.Entity();\n    group.addComponent("script");\n    group.script.create("rotator");\n    app.root.addChild(group);\n\n    // Create the portal entity - this plane is written to stencil buffer,\n    // which is then used to test for inside / outside. This needs to render\n    // before all elements requiring stencil buffer, so add to to a portalLayer.\n    // This is the plane that fills the inside of the portal geometry.\n    const portal = new pc.Entity("Portal");\n    portal.addComponent("render", {\n        type: "plane",\n        material: new pc.StandardMaterial(),\n        layers: [portalLayer.id],\n    });\n\n    portal.addComponent("script");\n    portal.script.create("portal"); // comment out this line to see the geometry\n    portal.setLocalPosition(0, 0.4, -0.3);\n    portal.setLocalEulerAngles(90, 0, 0);\n    portal.setLocalScale(3.7, 1, 6.7);\n    group.addChild(portal);\n\n    // Create the portal visual geometry\n    const portalEntity = assets.portal.resource.instantiateRenderEntity();\n    portalEntity.setLocalPosition(0, -3, 0);\n    portalEntity.setLocalScale(0.02, 0.02, 0.02);\n    group.addChild(portalEntity);\n\n    // Create a statue entity, whic is visible inside the portal only\n    const statue = assets.statue.resource.instantiateRenderEntity();\n    statue.addComponent("script");\n    statue.script.create("portalGeometry", {\n        attributes: {\n            inside: true,\n        },\n    });\n\n    statue.setLocalPosition(0, -1, -2);\n    statue.setLocalScale(0.25, 0.25, 0.25);\n    group.addChild(statue);\n\n    // Create a bitmoji entity, whic is visible outside the portal only\n    const bitmoji = assets.bitmoji.resource.instantiateRenderEntity();\n    bitmoji.addComponent("script");\n    bitmoji.script.create("portalGeometry", {\n        attributes: {\n            inside: false,\n        },\n    });\n\n    bitmoji.setLocalPosition(0, -1, -2);\n    bitmoji.setLocalScale(2.5, 2.5, 2.5);\n    group.addChild(bitmoji);\n}\n',nameSlug:"portal",categorySlug:"graphics"},"post-effects":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: any, data: any): void {\n    const app = new pc.Application(canvas, {\n        keyboard: new pc.Keyboard(window)\n    });\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // setup skydome\n    app.scene.setSkybox(assets['helipad.dds'].resources);\n    app.scene.skyboxMip = 3;\n    app.scene.exposure = 1;\n\n    // helper function to create a 3d primitive including its material\n    function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3, brightness: number, allowEmissive = true) {\n\n        // create a material\n        const material = new pc.StandardMaterial();\n        material.shininess = 40;\n        material.metalness = 0.6;\n        material.useMetalness = true;\n\n        // random diffuse and emissive color\n        material.diffuse = new pc.Color(brightness, brightness, brightness);\n        if (allowEmissive && Math.random() < 0.15) {\n            material.emissive = new pc.Color(Math.random(), Math.random(), Math.random());\n        }\n        material.update();\n\n        // create the primitive using the material\n        const primitive = new pc.Entity();\n        primitive.addComponent('render', {\n            type: primitiveType,\n            material: material\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create the ground plane from the boxes\n    for (let x = -2; x <= 2; x += 0.5) {\n        for (let z = 0; z <= 10; z += 0.5) {\n            createPrimitive(\"box\", new pc.Vec3(x * 40, -5, z * 40), new pc.Vec3(18, 2, 18), Math.random());\n        }\n    }\n\n    // create the towers from the boxes\n    let scale = 16;\n    for (let y = 0; y <= 7; y++) {\n        for (let x = -1; x <= 1; x += 2) {\n            for (let z = 0; z <= 10; z += 2) {\n                const prim = createPrimitive(\"box\", new pc.Vec3(x * 40, 2 + y * 10, z * 40), new pc.Vec3(scale, scale, scale), Math.random());\n                prim.setLocalEulerAngles(Math.random() * 360, Math.random() * 360, Math.random() * 360);\n            }\n        }\n        scale -= 1.5;\n    }\n\n    // create a sphere which represents the point of focus for the bokeh filter\n    const focusPrimitive = createPrimitive(\"sphere\", pc.Vec3.ZERO, new pc.Vec3(10, 10, 10), 1.5, false);\n\n    // add an omni light as a child of this sphere\n    const light = new pc.Entity();\n    light.addComponent(\"light\", {\n        type: \"omni\",\n        color: pc.Color.WHITE,\n        intensity: 4,\n        range: 100,\n        castShadows: false\n    });\n    focusPrimitive.addChild(light);\n\n    // Create an Entity with a camera component, and attach postprocessing effects scripts on it\n    const camera: any = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n        farClip: 500\n    });\n    camera.addComponent(\"script\");\n    data.set('scripts', {\n        ssao: {\n            enabled: true,\n            radius: 5,\n            samples: 16,\n            brightness: 0\n        },\n        bloom: {\n            enabled: true,\n            bloomIntensity: 0.8,\n            bloomThreshold: 0.8,\n            blurAmount: 15\n        },\n        sepia: {\n            enabled: true,\n            amount: 0.4\n        },\n        vignette: {\n            enabled: true,\n            darkness: 1,\n            offset: 1.2\n        },\n        bokeh: {\n            enabled: true,\n            aperture: 0.1,\n            maxBlur: 0.01\n        }\n    });\n\n    Object.keys(data.get('scripts')).forEach((key) => {\n        camera.script.create(key, {\n            attributes: data.get(`scripts.${key}`)\n        });\n    });\n\n    // position the camera in the world\n    camera.setLocalPosition(0, 30, -60);\n    camera.lookAt(0, 0, 100);\n    app.root.addChild(camera);\n\n    // Allow user to toggle individual post effects\n    app.keyboard.on(\"keydown\", function (e) {\n        // if the user is editing an input field, ignore key presses\n        if (e.element.constructor.name === 'HTMLInputElement') return;\n        switch (e.key) {\n            case pc.KEY_1:\n                data.set('scripts.bloom.enabled', !data.get('scripts.bloom.enabled'));\n                break;\n            case pc.KEY_2:\n                data.set('scripts.sepia.enabled', !data.get('scripts.sepia.enabled'));\n                break;\n            case pc.KEY_3:\n                data.set('scripts.vignette.enabled', !data.get('scripts.vignette.enabled'));\n                break;\n            case pc.KEY_4:\n                data.set('scripts.bokeh.enabled', !data.get('scripts.bokeh.enabled'));\n                break;\n            case pc.KEY_5:\n                data.set('scripts.ssao.enabled', !data.get('scripts.ssao.enabled'));\n                break;\n            case pc.KEY_6:\n                data.set('data.postProcessUI.enabled', !data.get('data.postProcessUI.enabled'));\n                break;\n        }\n    }, this);\n\n    // Create a 2D screen to place UI on\n    const screen = new pc.Entity();\n    screen.addComponent(\"screen\", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true\n    });\n    app.root.addChild(screen);\n\n    // create a text element to show which effects are enabled\n    const text = new pc.Entity();\n    text.addComponent(\"element\", {\n        anchor: new pc.Vec4(0.1, 0.1, 0.5, 0.5),\n        fontAsset: assets.font,\n        fontSize: 28,\n        pivot: new pc.Vec2(0.5, 0.1),\n        type: pc.ELEMENTTYPE_TEXT,\n        alignment: pc.Vec2.ZERO\n    });\n    screen.addChild(text);\n\n    // Display some UI text which the post processing can be tested against\n    text.element.text = 'Test UI Text';\n\n    // update things every frame\n    let angle = 0;\n    app.on(\"update\", function (dt) {\n        angle += dt;\n\n        // rotate the skydome\n        app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(0, angle * 20, 0);\n\n        // move the focus sphere in the world closer and further away\n        const focusPosition = new pc.Vec3(0, 10, Math.abs(Math.sin(angle * 0.1)) * 400);\n        focusPrimitive.setPosition(focusPosition);\n\n        // set the focus distance to the bokeh effect\n        // - it's a negative distance between the camera and the focus sphere\n        camera.script.bokeh.focus = -focusPosition.sub(camera.getPosition()).length();\n\n        // display the depth texture if bokeh is enabled\n        if (camera.script.bokeh.enabled) {\n            // @ts-ignore engine-tsd\n            app.drawDepthTexture(0.7, -0.7, 0.5, 0.5);\n        }\n    });\n\n    data.on('*:set', (path: string, value: any) => {\n        const pathArray = path.split('.');\n        if (pathArray[0] === 'scripts') {\n            camera.script[pathArray[1]][pathArray[2]] = value;\n        } else {\n            camera.camera.disablePostEffectsLayer = camera.camera.disablePostEffectsLayer === pc.LAYERID_UI ? undefined : pc.LAYERID_UI;\n        }\n    });\n}",javaScriptFunction:'function example(canvas, assets, data) {\n    const app = new pc.Application(canvas, {\n        keyboard: new pc.Keyboard(window),\n    });\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // setup skydome\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n    app.scene.skyboxMip = 3;\n    app.scene.exposure = 1;\n\n    // helper function to create a 3d primitive including its material\n    function createPrimitive(\n        primitiveType,\n        position,\n        scale,\n        brightness,\n        allowEmissive = true\n    ) {\n        // create a material\n        const material = new pc.StandardMaterial();\n        material.shininess = 40;\n        material.metalness = 0.6;\n        material.useMetalness = true;\n\n        // random diffuse and emissive color\n        material.diffuse = new pc.Color(brightness, brightness, brightness);\n        if (allowEmissive && Math.random() < 0.15) {\n            material.emissive = new pc.Color(\n                Math.random(),\n                Math.random(),\n                Math.random()\n            );\n        }\n        material.update();\n\n        // create the primitive using the material\n        const primitive = new pc.Entity();\n        primitive.addComponent("render", {\n            type: primitiveType,\n            material: material,\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create the ground plane from the boxes\n    for (let x = -2; x <= 2; x += 0.5) {\n        for (let z = 0; z <= 10; z += 0.5) {\n            createPrimitive(\n                "box",\n                new pc.Vec3(x * 40, -5, z * 40),\n                new pc.Vec3(18, 2, 18),\n                Math.random()\n            );\n        }\n    }\n\n    // create the towers from the boxes\n    let scale = 16;\n    for (let y = 0; y <= 7; y++) {\n        for (let x = -1; x <= 1; x += 2) {\n            for (let z = 0; z <= 10; z += 2) {\n                const prim = createPrimitive(\n                    "box",\n                    new pc.Vec3(x * 40, 2 + y * 10, z * 40),\n                    new pc.Vec3(scale, scale, scale),\n                    Math.random()\n                );\n                prim.setLocalEulerAngles(\n                    Math.random() * 360,\n                    Math.random() * 360,\n                    Math.random() * 360\n                );\n            }\n        }\n        scale -= 1.5;\n    }\n\n    // create a sphere which represents the point of focus for the bokeh filter\n    const focusPrimitive = createPrimitive(\n        "sphere",\n        pc.Vec3.ZERO,\n        new pc.Vec3(10, 10, 10),\n        1.5,\n        false\n    );\n\n    // add an omni light as a child of this sphere\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: pc.Color.WHITE,\n        intensity: 4,\n        range: 100,\n        castShadows: false,\n    });\n\n    focusPrimitive.addChild(light);\n\n    // Create an Entity with a camera component, and attach postprocessing effects scripts on it\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n        farClip: 500,\n    });\n\n    camera.addComponent("script");\n    data.set("scripts", {\n        ssao: {\n            enabled: true,\n            radius: 5,\n            samples: 16,\n            brightness: 0,\n        },\n\n        bloom: {\n            enabled: true,\n            bloomIntensity: 0.8,\n            bloomThreshold: 0.8,\n            blurAmount: 15,\n        },\n\n        sepia: {\n            enabled: true,\n            amount: 0.4,\n        },\n\n        vignette: {\n            enabled: true,\n            darkness: 1,\n            offset: 1.2,\n        },\n\n        bokeh: {\n            enabled: true,\n            aperture: 0.1,\n            maxBlur: 0.01,\n        },\n    });\n\n    Object.keys(data.get("scripts")).forEach((key) => {\n        camera.script.create(key, {\n            attributes: data.get(`scripts.${key}`),\n        });\n    });\n\n    // position the camera in the world\n    camera.setLocalPosition(0, 30, -60);\n    camera.lookAt(0, 0, 100);\n    app.root.addChild(camera);\n\n    // Allow user to toggle individual post effects\n    app.keyboard.on(\n        "keydown",\n        function (e) {\n            // if the user is editing an input field, ignore key presses\n            if (e.element.constructor.name === "HTMLInputElement") return;\n            switch (e.key) {\n                case pc.KEY_1:\n                    data.set(\n                        "scripts.bloom.enabled",\n                        !data.get("scripts.bloom.enabled")\n                    );\n                    break;\n                case pc.KEY_2:\n                    data.set(\n                        "scripts.sepia.enabled",\n                        !data.get("scripts.sepia.enabled")\n                    );\n                    break;\n                case pc.KEY_3:\n                    data.set(\n                        "scripts.vignette.enabled",\n                        !data.get("scripts.vignette.enabled")\n                    );\n                    break;\n                case pc.KEY_4:\n                    data.set(\n                        "scripts.bokeh.enabled",\n                        !data.get("scripts.bokeh.enabled")\n                    );\n                    break;\n                case pc.KEY_5:\n                    data.set(\n                        "scripts.ssao.enabled",\n                        !data.get("scripts.ssao.enabled")\n                    );\n                    break;\n                case pc.KEY_6:\n                    data.set(\n                        "data.postProcessUI.enabled",\n                        !data.get("data.postProcessUI.enabled")\n                    );\n                    break;\n            }\n        },\n        this\n    );\n\n    // Create a 2D screen to place UI on\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true,\n    });\n\n    app.root.addChild(screen);\n\n    // create a text element to show which effects are enabled\n    const text = new pc.Entity();\n    text.addComponent("element", {\n        anchor: new pc.Vec4(0.1, 0.1, 0.5, 0.5),\n        fontAsset: assets.font,\n        fontSize: 28,\n        pivot: new pc.Vec2(0.5, 0.1),\n        type: pc.ELEMENTTYPE_TEXT,\n        alignment: pc.Vec2.ZERO,\n    });\n\n    screen.addChild(text);\n\n    // Display some UI text which the post processing can be tested against\n    text.element.text = "Test UI Text";\n\n    // update things every frame\n    let angle = 0;\n    app.on("update", function (dt) {\n        angle += dt;\n\n        // rotate the skydome\n        app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(\n            0,\n            angle * 20,\n            0\n        );\n\n        // move the focus sphere in the world closer and further away\n        const focusPosition = new pc.Vec3(\n            0,\n            10,\n            Math.abs(Math.sin(angle * 0.1)) * 400\n        );\n        focusPrimitive.setPosition(focusPosition);\n\n        // set the focus distance to the bokeh effect\n        // - it\'s a negative distance between the camera and the focus sphere\n        camera.script.bokeh.focus = -focusPosition\n            .sub(camera.getPosition())\n            .length();\n\n        // display the depth texture if bokeh is enabled\n        if (camera.script.bokeh.enabled) {\n            // @ts-ignore engine-tsd\n            app.drawDepthTexture(0.7, -0.7, 0.5, 0.5);\n        }\n    });\n\n    data.on("*:set", (path, value) => {\n        const pathArray = path.split(".");\n        if (pathArray[0] === "scripts") {\n            camera.script[pathArray[1]][pathArray[2]] = value;\n        } else {\n            camera.camera.disablePostEffectsLayer =\n                camera.camera.disablePostEffectsLayer === pc.LAYERID_UI\n                    ? undefined\n                    : pc.LAYERID_UI;\n        }\n    });\n}\n',nameSlug:"post-effects",categorySlug:"graphics"},"render-asset":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { \'helipad.dds\': pc.Asset, statue: pc.Asset, cube: pc.Asset }): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    const cubeEntities: pc.Entity[] = [];\n\n    app.start();\n\n    // get the instance of the cube it set up with render component and add it to scene\n    cubeEntities[0] = assets.cube.resource.instantiateRenderEntity();\n    cubeEntities[0].setLocalPosition(7, 12, 0);\n    cubeEntities[0].setLocalScale(3, 3, 3);\n    app.root.addChild(cubeEntities[0]);\n\n    // clone another copy of it and add it to scene\n    cubeEntities[1] = cubeEntities[0].clone() as pc.Entity;\n    cubeEntities[1].setLocalPosition(-7, 12, 0);\n    cubeEntities[1].setLocalScale(3, 3, 3);\n    app.root.addChild(cubeEntities[1]);\n\n    // get the instance of the statue and set up with render component\n    const statueEntity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(statueEntity);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.1, 0.1),\n        farClip: 100\n    });\n    camera.translate(-20, 15, 20);\n    camera.lookAt(0, 7, 0);\n    app.root.addChild(camera);\n\n    // set skybox - this DDS file was \'prefiltered\' in the PlayCanvas Editor and then downloaded.\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    app.scene.skyboxMip = 1;\n\n    // spin the meshes\n    app.on("update", function (dt) {\n\n        if (cubeEntities[0]) {\n            cubeEntities[0].rotate(3 * dt, 10 * dt, 6 * dt);\n        }\n\n        if (cubeEntities[1]) {\n            cubeEntities[1].rotate(-7 * dt, 5 * dt, -2 * dt);\n        }\n\n        if (statueEntity) {\n            statueEntity.rotate(0, -12 * dt, 0);\n        }\n\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    const cubeEntities = [];\n\n    app.start();\n\n    // get the instance of the cube it set up with render component and add it to scene\n    cubeEntities[0] = assets.cube.resource.instantiateRenderEntity();\n    cubeEntities[0].setLocalPosition(7, 12, 0);\n    cubeEntities[0].setLocalScale(3, 3, 3);\n    app.root.addChild(cubeEntities[0]);\n\n    // clone another copy of it and add it to scene\n    cubeEntities[1] = cubeEntities[0].clone();\n    cubeEntities[1].setLocalPosition(-7, 12, 0);\n    cubeEntities[1].setLocalScale(3, 3, 3);\n    app.root.addChild(cubeEntities[1]);\n\n    // get the instance of the statue and set up with render component\n    const statueEntity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(statueEntity);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.2, 0.1, 0.1),\n        farClip: 100,\n    });\n\n    camera.translate(-20, 15, 20);\n    camera.lookAt(0, 7, 0);\n    app.root.addChild(camera);\n\n    // set skybox - this DDS file was \'prefiltered\' in the PlayCanvas Editor and then downloaded.\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    app.scene.skyboxMip = 1;\n\n    // spin the meshes\n    app.on("update", function (dt) {\n        if (cubeEntities[0]) {\n            cubeEntities[0].rotate(3 * dt, 10 * dt, 6 * dt);\n        }\n\n        if (cubeEntities[1]) {\n            cubeEntities[1].rotate(-7 * dt, 5 * dt, -2 * dt);\n        }\n\n        if (statueEntity) {\n            statueEntity.rotate(0, -12 * dt, 0);\n        }\n    });\n}\n',nameSlug:"render-asset",categorySlug:"graphics"},"render-cubemap":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { \'helipad.dds\': pc.Asset, script: pc.Asset }): void {\n\n    // Create the app\n    const app = new pc.Application(canvas, {});\n\n    // start the update loop\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // set up some general scene rendering properties\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // setup skydome\n    app.scene.skyboxMip = 0;        // use top mipmap level of cubemap (full resolution)\n    app.scene.skyboxIntensity = 2;  // make it brighter\n\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n\n    // helper function to create high polygon version of a sphere and sets up an entity to allow it to be added to the scene\n    const createHighQualitySphere = function (material: pc.Material, layer: number[]) {\n\n        // Create Entity and add it to the scene\n        const entity = new pc.Entity("ShinyBall");\n        app.root.addChild(entity);\n\n        // create hight resolution sphere\n        const mesh = pc.createSphere(app.graphicsDevice, { latitudeBands: 200, longitudeBands: 200 });\n\n        // Add a render component with the mesh\n        entity.addComponent(\'render\', {\n            type: \'asset\',\n            layers: layer,\n            meshInstances: [new pc.MeshInstance(mesh, material)]\n        });\n\n        return entity;\n    };\n\n    // helper function to create a primitive with shape type, position, scale, color and layer\n    function createPrimitive(primitiveType: string, position: number | pc.Vec3, scale: number | pc.Vec3, color: pc.Color, layer: number[]) {\n        // create material of specified color\n        const material = new pc.StandardMaterial();\n        material.diffuse = color;\n        material.shininess = 60;\n        material.metalness = 0.7;\n        material.useMetalness = true;\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent(\'render\', {\n            type: primitiveType,\n            layers: layer,\n            material: material\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create a layer for object that do not render into texture\n    const excludedLayer = new pc.Layer({ name: "Excluded" });\n    app.scene.layers.push(excludedLayer);\n\n    // create material for the shiny ball\n    const shinyMat = new pc.StandardMaterial();\n\n    // create shiny ball mesh - this is on excluded layer as it does not render to cubemap\n    const shinyBall = createHighQualitySphere(shinyMat, [excludedLayer.id]);\n    shinyBall.setLocalPosition(0, 0, 0);\n    shinyBall.setLocalScale(10, 10, 10);\n\n    // get world and skybox layers\n    const worldLayer = app.scene.layers.getLayerByName("World");\n    const skyboxLayer = app.scene.layers.getLayerByName("Skybox");\n    const immediateLayer = app.scene.layers.getLayerByName("Immediate");\n\n    // add camera component to shiny ball - this defines camera properties for cubemap rendering\n    shinyBall.addComponent(\'camera\', {\n\n        // optimization - no need to clear as all pixels get overwritten\n        clearColorBuffer: false,\n\n        // cubemap camera will render objects on world layer and also skybox\n        layers: [worldLayer.id, skyboxLayer.id],\n\n        // priority - render before world camera\n        priority: -1,\n\n        // disable as this is not a camera that renders cube map but only a container for properties for cube map rendering\n        enabled: false\n    });\n\n    // add cubemapRenderer script component which takes care of rendering dynamic cubemap\n    shinyBall.addComponent(\'script\');\n    shinyBall.script.create(\'cubemapRenderer\', {\n        attributes: {\n            resolution: 256,\n            mipmaps: true,\n            depth: true\n        }\n    });\n\n    // finish set up of shiny material - make reflection a bit darker\n    shinyMat.diffuse = new pc.Color(0.6, 0.6, 0.6);\n\n    // use cubemap which is generated by cubemapRenderer instead of global skybox cubemap\n    shinyMat.useSkybox = false;\n    // @ts-ignore engine-tsd\n    shinyMat.cubeMap = shinyBall.script.cubemapRenderer.cubeMap;\n\n    // make it shiny without diffuse component\n    shinyMat.metalness = 1;\n    shinyMat.useMetalness = true;\n    shinyMat.update();\n\n    // create few random primitives in the world layer\n    const entities: pc.Entity[] = [];\n    const shapes = ["box", "cone", "cylinder", "sphere", "capsule"];\n    for (let i = 0; i < 6; i++) {\n        const shapeName = shapes[Math.floor(Math.random() * shapes.length)];\n        const color = new pc.Color(Math.random(), Math.random(), Math.random());\n        entities.push(createPrimitive(shapeName, pc.Vec3.ZERO, new pc.Vec3(3, 3, 3), color, [worldLayer.id]));\n    }\n\n    // create green plane as a base to cast shadows on\n    createPrimitive("plane", new pc.Vec3(0, -8, 0), new pc.Vec3(20, 20, 20), new pc.Color(0.3, 0.5, 0.3), [worldLayer.id]);\n\n    // Create main camera, which renders entities in world, excluded and skybox layers\n    const camera = new pc.Entity("MainCamera");\n    camera.addComponent("camera", {\n        fov: 60,\n        layers: [worldLayer.id, excludedLayer.id, skyboxLayer.id, immediateLayer.id]\n    });\n    app.root.addChild(camera);\n\n    // Create an Entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        color: pc.Color.YELLOW,\n        range: 40,\n        castShadows: true,\n        layers: [worldLayer.id],\n        shadowBias: 0.2,\n        shadowResolution: 1024,\n        normalOffsetBias: 0.05,\n        shadowDistance: 40\n    });\n    app.root.addChild(light);\n\n    // helper function to create a texture that can be used to project cubemap to\n    function createReprojectionTexture(projection: string, size: number) {\n        return new pc.Texture(app.graphicsDevice, {\n            width: size,\n            height: size,\n            format: pc.PIXELFORMAT_R8_G8_B8,\n            mipmaps: false,\n            minFilter: pc.FILTER_LINEAR,\n            magFilter: pc.FILTER_LINEAR,\n            addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n            addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n            projection: projection\n        });\n    }\n\n    // create 2 uqirect and 2 octahedral textures\n    const textureEqui = createReprojectionTexture(pc.TEXTUREPROJECTION_EQUIRECT, 256);\n    const textureEqui2 = createReprojectionTexture(pc.TEXTUREPROJECTION_EQUIRECT, 256);\n    const textureOcta = createReprojectionTexture(pc.TEXTUREPROJECTION_OCTAHEDRAL, 64);\n    const textureOcta2 = createReprojectionTexture(pc.TEXTUREPROJECTION_OCTAHEDRAL, 32);\n\n    // update things each frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // rotate primitives around their center and also orbit them around the shiny sphere\n        for (let e = 0; e < entities.length; e++) {\n            const scale = (e + 1) / entities.length;\n            const offset = time + e * 200;\n            entities[e].setLocalPosition(7 * Math.sin(offset), 2 * (e - 3), 7 * Math.cos(offset));\n            entities[e].rotate(1 * scale, 2 * scale, 3 * scale);\n        }\n\n        // slowly orbit camera around\n        camera.setLocalPosition(20 * Math.cos(time * 0.2), 2, 20 * Math.sin(time * 0.2));\n        camera.lookAt(pc.Vec3.ZERO);\n\n        // project textures, and display them on the screen\n        // @ts-ignore engine-tsd\n        const srcCube = shinyBall.script.cubemapRenderer.cubeMap;\n\n        // cube -> equi1\n        pc.reprojectTexture(srcCube, textureEqui, {\n            numSamples: 1\n        });\n        // @ts-ignore engine-tsd\n        app.drawTexture(-0.6, 0.7, 0.6, 0.3, textureEqui);\n\n        // cube -> octa1\n        pc.reprojectTexture(srcCube, textureOcta, {\n            numSamples: 1\n        });\n        // @ts-ignore engine-tsd\n        app.drawTexture(0.7, 0.7, 0.4, 0.4, textureOcta);\n\n        // equi1 -> octa2\n        pc.reprojectTexture(textureEqui, textureOcta2, {\n            specularPower: 32,\n            numSamples: 1024\n        });\n        // @ts-ignore engine-tsd\n        app.drawTexture(-0.7, -0.7, 0.4, 0.4, textureOcta2);\n\n        // octa1 -> equi2\n        pc.reprojectTexture(textureOcta, textureEqui2, {\n            specularPower: 16,\n            numSamples: 512\n        });\n        // @ts-ignore engine-tsd\n        app.drawTexture(0.6, -0.7, 0.6, 0.3, textureEqui2);\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the app\n    const app = new pc.Application(canvas, {});\n\n    // start the update loop\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // set up some general scene rendering properties\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // setup skydome\n    app.scene.skyboxMip = 0; // use top mipmap level of cubemap (full resolution)\n    app.scene.skyboxIntensity = 2; // make it brighter\n\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    // helper function to create high polygon version of a sphere and sets up an entity to allow it to be added to the scene\n    const createHighQualitySphere = function (material, layer) {\n        // Create Entity and add it to the scene\n        const entity = new pc.Entity("ShinyBall");\n        app.root.addChild(entity);\n\n        // create hight resolution sphere\n        const mesh = pc.createSphere(app.graphicsDevice, {\n            latitudeBands: 200,\n            longitudeBands: 200,\n        });\n\n        // Add a render component with the mesh\n        entity.addComponent("render", {\n            type: "asset",\n            layers: layer,\n            meshInstances: [new pc.MeshInstance(mesh, material)],\n        });\n\n        return entity;\n    };\n\n    // helper function to create a primitive with shape type, position, scale, color and layer\n    function createPrimitive(primitiveType, position, scale, color, layer) {\n        // create material of specified color\n        const material = new pc.StandardMaterial();\n        material.diffuse = color;\n        material.shininess = 60;\n        material.metalness = 0.7;\n        material.useMetalness = true;\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent("render", {\n            type: primitiveType,\n            layers: layer,\n            material: material,\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create a layer for object that do not render into texture\n    const excludedLayer = new pc.Layer({ name: "Excluded" });\n    app.scene.layers.push(excludedLayer);\n\n    // create material for the shiny ball\n    const shinyMat = new pc.StandardMaterial();\n\n    // create shiny ball mesh - this is on excluded layer as it does not render to cubemap\n    const shinyBall = createHighQualitySphere(shinyMat, [excludedLayer.id]);\n    shinyBall.setLocalPosition(0, 0, 0);\n    shinyBall.setLocalScale(10, 10, 10);\n\n    // get world and skybox layers\n    const worldLayer = app.scene.layers.getLayerByName("World");\n    const skyboxLayer = app.scene.layers.getLayerByName("Skybox");\n    const immediateLayer = app.scene.layers.getLayerByName("Immediate");\n\n    // add camera component to shiny ball - this defines camera properties for cubemap rendering\n    shinyBall.addComponent("camera", {\n        // optimization - no need to clear as all pixels get overwritten\n        clearColorBuffer: false,\n\n        // cubemap camera will render objects on world layer and also skybox\n        layers: [worldLayer.id, skyboxLayer.id],\n\n        // priority - render before world camera\n        priority: -1,\n\n        // disable as this is not a camera that renders cube map but only a container for properties for cube map rendering\n        enabled: false,\n    });\n\n    // add cubemapRenderer script component which takes care of rendering dynamic cubemap\n    shinyBall.addComponent("script");\n    shinyBall.script.create("cubemapRenderer", {\n        attributes: {\n            resolution: 256,\n            mipmaps: true,\n            depth: true,\n        },\n    });\n\n    // finish set up of shiny material - make reflection a bit darker\n    shinyMat.diffuse = new pc.Color(0.6, 0.6, 0.6);\n\n    // use cubemap which is generated by cubemapRenderer instead of global skybox cubemap\n    shinyMat.useSkybox = false;\n    // @ts-ignore engine-tsd\n    shinyMat.cubeMap = shinyBall.script.cubemapRenderer.cubeMap;\n\n    // make it shiny without diffuse component\n    shinyMat.metalness = 1;\n    shinyMat.useMetalness = true;\n    shinyMat.update();\n\n    // create few random primitives in the world layer\n    const entities = [];\n    const shapes = ["box", "cone", "cylinder", "sphere", "capsule"];\n    for (let i = 0; i < 6; i++) {\n        const shapeName = shapes[Math.floor(Math.random() * shapes.length)];\n        const color = new pc.Color(Math.random(), Math.random(), Math.random());\n        entities.push(\n            createPrimitive(\n                shapeName,\n                pc.Vec3.ZERO,\n                new pc.Vec3(3, 3, 3),\n                color,\n                [worldLayer.id]\n            )\n        );\n    }\n\n    // create green plane as a base to cast shadows on\n    createPrimitive(\n        "plane",\n        new pc.Vec3(0, -8, 0),\n        new pc.Vec3(20, 20, 20),\n        new pc.Color(0.3, 0.5, 0.3),\n        [worldLayer.id]\n    );\n\n    // Create main camera, which renders entities in world, excluded and skybox layers\n    const camera = new pc.Entity("MainCamera");\n    camera.addComponent("camera", {\n        fov: 60,\n        layers: [\n            worldLayer.id,\n            excludedLayer.id,\n            skyboxLayer.id,\n            immediateLayer.id,\n        ],\n    });\n\n    app.root.addChild(camera);\n\n    // Create an Entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        color: pc.Color.YELLOW,\n        range: 40,\n        castShadows: true,\n        layers: [worldLayer.id],\n        shadowBias: 0.2,\n        shadowResolution: 1024,\n        normalOffsetBias: 0.05,\n        shadowDistance: 40,\n    });\n\n    app.root.addChild(light);\n\n    // helper function to create a texture that can be used to project cubemap to\n    function createReprojectionTexture(projection, size) {\n        return new pc.Texture(app.graphicsDevice, {\n            width: size,\n            height: size,\n            format: pc.PIXELFORMAT_R8_G8_B8,\n            mipmaps: false,\n            minFilter: pc.FILTER_LINEAR,\n            magFilter: pc.FILTER_LINEAR,\n            addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n            addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n            projection: projection,\n        });\n    }\n\n    // create 2 uqirect and 2 octahedral textures\n    const textureEqui = createReprojectionTexture(\n        pc.TEXTUREPROJECTION_EQUIRECT,\n        256\n    );\n    const textureEqui2 = createReprojectionTexture(\n        pc.TEXTUREPROJECTION_EQUIRECT,\n        256\n    );\n    const textureOcta = createReprojectionTexture(\n        pc.TEXTUREPROJECTION_OCTAHEDRAL,\n        64\n    );\n    const textureOcta2 = createReprojectionTexture(\n        pc.TEXTUREPROJECTION_OCTAHEDRAL,\n        32\n    );\n\n    // update things each frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // rotate primitives around their center and also orbit them around the shiny sphere\n        for (let e = 0; e < entities.length; e++) {\n            const scale = (e + 1) / entities.length;\n            const offset = time + e * 200;\n            entities[e].setLocalPosition(\n                7 * Math.sin(offset),\n                2 * (e - 3),\n                7 * Math.cos(offset)\n            );\n            entities[e].rotate(1 * scale, 2 * scale, 3 * scale);\n        }\n\n        // slowly orbit camera around\n        camera.setLocalPosition(\n            20 * Math.cos(time * 0.2),\n            2,\n            20 * Math.sin(time * 0.2)\n        );\n        camera.lookAt(pc.Vec3.ZERO);\n\n        // project textures, and display them on the screen\n        // @ts-ignore engine-tsd\n        const srcCube = shinyBall.script.cubemapRenderer.cubeMap;\n\n        // cube -> equi1\n        pc.reprojectTexture(srcCube, textureEqui, {\n            numSamples: 1,\n        });\n\n        // @ts-ignore engine-tsd\n        app.drawTexture(-0.6, 0.7, 0.6, 0.3, textureEqui);\n\n        // cube -> octa1\n        pc.reprojectTexture(srcCube, textureOcta, {\n            numSamples: 1,\n        });\n\n        // @ts-ignore engine-tsd\n        app.drawTexture(0.7, 0.7, 0.4, 0.4, textureOcta);\n\n        // equi1 -> octa2\n        pc.reprojectTexture(textureEqui, textureOcta2, {\n            specularPower: 32,\n            numSamples: 1024,\n        });\n\n        // @ts-ignore engine-tsd\n        app.drawTexture(-0.7, -0.7, 0.4, 0.4, textureOcta2);\n\n        // octa1 -> equi2\n        pc.reprojectTexture(textureOcta, textureEqui2, {\n            specularPower: 16,\n            numSamples: 512,\n        });\n\n        // @ts-ignore engine-tsd\n        app.drawTexture(0.6, -0.7, 0.6, 0.3, textureEqui2);\n    });\n}\n',nameSlug:"render-cubemap",categorySlug:"graphics"},"render-to-texture":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { \'helipad.dds\': pc.Asset }): void {\n\n    // Overview:\n    // There are 3 layers used:\n    // - worldLayer - it contains objects that render into main camera and also into texture\n    // - excludedLayer - it contains objects that are excluded from rendering into texture and so render only into main camera\n    // - skyboxLayer - it contains skybox and renders into both main and texture camera\n    // There are two cameras:\n    // - textureCamera - this camera renders into texture, objects from World and also Skybox layers\n    // - camera - this camera renders into main framebuffer, objects from World, Excluded and also Skybox layers\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // helper function to create a primitive with shape type, position, scale, color and layer\n    function createPrimitive(primitiveType: string, position: number | pc.Vec3, scale: number | pc.Vec3, color: pc.Color, layer: number[]) {\n        // create material of specified color\n        const material = new pc.StandardMaterial();\n        material.diffuse = color;\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent(\'render\', {\n            type: primitiveType,\n            layers: layer,\n            material: material\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create texture and render target for rendering into, including depth buffer\n    const texture = new pc.Texture(app.graphicsDevice, {\n        width: 512,\n        height: 256,\n        format: pc.PIXELFORMAT_R8_G8_B8,\n        mipmaps: true,\n        minFilter: pc.FILTER_LINEAR,\n        magFilter: pc.FILTER_LINEAR,\n        addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n        addressV: pc.ADDRESS_CLAMP_TO_EDGE\n    });\n    const renderTarget = new pc.RenderTarget({\n        colorBuffer: texture,\n        depth: true,\n        flipY: true,\n        samples: 2\n    });\n\n    // create a layer for object that do not render into texture\n    const excludedLayer = new pc.Layer({ name: "Excluded" });\n    app.scene.layers.push(excludedLayer);\n\n    // get world and skybox layers\n    const worldLayer = app.scene.layers.getLayerByName("World");\n    const skyboxLayer = app.scene.layers.getLayerByName("Skybox");\n\n    // create ground plane and 3 primitives, visible in world layer\n    createPrimitive("plane", new pc.Vec3(0, 0, 0), new pc.Vec3(20, 20, 20), new pc.Color(0.2, 0.4, 0.2), [worldLayer.id]);\n    createPrimitive("sphere", new pc.Vec3(-2, 1, 0), new pc.Vec3(2, 2, 2), pc.Color.RED, [worldLayer.id]);\n    createPrimitive("box", new pc.Vec3(2, 1, 0), new pc.Vec3(2, 2, 2), pc.Color.YELLOW, [worldLayer.id]);\n    createPrimitive("cone", new pc.Vec3(0, 1, -2), new pc.Vec3(2, 2, 2), pc.Color.CYAN, [worldLayer.id]);\n\n    // Create main camera, which renders entities in world, excluded and skybox layers\n    const camera = new pc.Entity("Camera");\n    camera.addComponent("camera", {\n        fov: 100,\n        layers: [worldLayer.id, excludedLayer.id, skyboxLayer.id]\n    });\n    camera.translate(0, 9, 15);\n    camera.lookAt(1, 4, 0);\n    app.root.addChild(camera);\n\n    // Create texture camera, which renders entities in world and skybox layers into the texture\n    const textureCamera = new pc.Entity("TextureCamera");\n    textureCamera.addComponent("camera", {\n        layers: [worldLayer.id, skyboxLayer.id],\n\n        // set the priority of textureCamera to lower number than the priority of the main camera (which is at default 0)\n        // to make it rendered first each frame\n        priority: -1,\n\n        // this camera renders into texture target\n        renderTarget: renderTarget\n    });\n\n    // add sphere at the position of this camera to see it in the world\n    textureCamera.addComponent("render", {\n        type: "sphere"\n    });\n    app.root.addChild(textureCamera);\n\n    // Create an Entity with a omni light component and add it to world layer (and so used by both cameras)\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: pc.Color.WHITE,\n        range: 200,\n        castShadows: true,\n        layers: [worldLayer.id]\n    });\n    light.translate(0, 2, 5);\n    app.root.addChild(light);\n\n    // create a plane called tv which we use to display rendered texture\n    // this is only added to excluded Layer, so it does not render into texture\n    const tv = createPrimitive("plane", new pc.Vec3(6, 8, -5), new pc.Vec3(20, 10, 10), pc.Color.BLACK, [excludedLayer.id]);\n    tv.setLocalEulerAngles(90, 0, 0);\n    tv.render.castShadows = false;\n    tv.render.receiveShadows = false;\n    const material = tv.render.material as pc.StandardMaterial;\n    material.emissiveMap = texture;     // assign the rendered texture as an emissive texture\n    material.update();\n\n    // setup skydome, use top mipmap level of cubemap (full resolution)\n    app.scene.skyboxMip = 0;\n    app.scene.setSkybox(assets[\'helipad.dds\'].resources);\n\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // update things each frame\n    let time = 0;\n    let switchTime = 0;\n    app.on("update", function (dt) {\n        // rotate texture camera around the objects\n        time += dt;\n        textureCamera.setLocalPosition(12 * Math.sin(time), 3, 12 * Math.cos(time));\n        textureCamera.lookAt(pc.Vec3.ZERO);\n\n        // every 5 seconds switch texture camera between perspective and orthographic projection\n        switchTime += dt;\n        if (switchTime > 5) {\n            switchTime = 0;\n            if (textureCamera.camera.projection === pc.PROJECTION_ORTHOGRAPHIC) {\n                textureCamera.camera.projection = pc.PROJECTION_PERSPECTIVE;\n            } else {\n                textureCamera.camera.projection = pc.PROJECTION_ORTHOGRAPHIC;\n                textureCamera.camera.orthoHeight = 5;\n            }\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Overview:\n    // There are 3 layers used:\n    // - worldLayer - it contains objects that render into main camera and also into texture\n    // - excludedLayer - it contains objects that are excluded from rendering into texture and so render only into main camera\n    // - skyboxLayer - it contains skybox and renders into both main and texture camera\n    // There are two cameras:\n    // - textureCamera - this camera renders into texture, objects from World and also Skybox layers\n    // - camera - this camera renders into main framebuffer, objects from World, Excluded and also Skybox layers\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // helper function to create a primitive with shape type, position, scale, color and layer\n    function createPrimitive(primitiveType, position, scale, color, layer) {\n        // create material of specified color\n        const material = new pc.StandardMaterial();\n        material.diffuse = color;\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent("render", {\n            type: primitiveType,\n            layers: layer,\n            material: material,\n        });\n\n        // set position and scale and add it to scene\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n        app.root.addChild(primitive);\n\n        return primitive;\n    }\n\n    // create texture and render target for rendering into, including depth buffer\n    const texture = new pc.Texture(app.graphicsDevice, {\n        width: 512,\n        height: 256,\n        format: pc.PIXELFORMAT_R8_G8_B8,\n        mipmaps: true,\n        minFilter: pc.FILTER_LINEAR,\n        magFilter: pc.FILTER_LINEAR,\n        addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n        addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n    });\n\n    const renderTarget = new pc.RenderTarget({\n        colorBuffer: texture,\n        depth: true,\n        flipY: true,\n        samples: 2,\n    });\n\n    // create a layer for object that do not render into texture\n    const excludedLayer = new pc.Layer({ name: "Excluded" });\n    app.scene.layers.push(excludedLayer);\n\n    // get world and skybox layers\n    const worldLayer = app.scene.layers.getLayerByName("World");\n    const skyboxLayer = app.scene.layers.getLayerByName("Skybox");\n\n    // create ground plane and 3 primitives, visible in world layer\n    createPrimitive(\n        "plane",\n        new pc.Vec3(0, 0, 0),\n        new pc.Vec3(20, 20, 20),\n        new pc.Color(0.2, 0.4, 0.2),\n        [worldLayer.id]\n    );\n    createPrimitive(\n        "sphere",\n        new pc.Vec3(-2, 1, 0),\n        new pc.Vec3(2, 2, 2),\n        pc.Color.RED,\n        [worldLayer.id]\n    );\n    createPrimitive(\n        "box",\n        new pc.Vec3(2, 1, 0),\n        new pc.Vec3(2, 2, 2),\n        pc.Color.YELLOW,\n        [worldLayer.id]\n    );\n    createPrimitive(\n        "cone",\n        new pc.Vec3(0, 1, -2),\n        new pc.Vec3(2, 2, 2),\n        pc.Color.CYAN,\n        [worldLayer.id]\n    );\n\n    // Create main camera, which renders entities in world, excluded and skybox layers\n    const camera = new pc.Entity("Camera");\n    camera.addComponent("camera", {\n        fov: 100,\n        layers: [worldLayer.id, excludedLayer.id, skyboxLayer.id],\n    });\n\n    camera.translate(0, 9, 15);\n    camera.lookAt(1, 4, 0);\n    app.root.addChild(camera);\n\n    // Create texture camera, which renders entities in world and skybox layers into the texture\n    const textureCamera = new pc.Entity("TextureCamera");\n    textureCamera.addComponent("camera", {\n        layers: [worldLayer.id, skyboxLayer.id],\n\n        // set the priority of textureCamera to lower number than the priority of the main camera (which is at default 0)\n        // to make it rendered first each frame\n        priority: -1,\n\n        // this camera renders into texture target\n        renderTarget: renderTarget,\n    });\n\n    // add sphere at the position of this camera to see it in the world\n    textureCamera.addComponent("render", {\n        type: "sphere",\n    });\n\n    app.root.addChild(textureCamera);\n\n    // Create an Entity with a omni light component and add it to world layer (and so used by both cameras)\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: pc.Color.WHITE,\n        range: 200,\n        castShadows: true,\n        layers: [worldLayer.id],\n    });\n\n    light.translate(0, 2, 5);\n    app.root.addChild(light);\n\n    // create a plane called tv which we use to display rendered texture\n    // this is only added to excluded Layer, so it does not render into texture\n    const tv = createPrimitive(\n        "plane",\n        new pc.Vec3(6, 8, -5),\n        new pc.Vec3(20, 10, 10),\n        pc.Color.BLACK,\n        [excludedLayer.id]\n    );\n    tv.setLocalEulerAngles(90, 0, 0);\n    tv.render.castShadows = false;\n    tv.render.receiveShadows = false;\n    const material = tv.render.material;\n    material.emissiveMap = texture; // assign the rendered texture as an emissive texture\n    material.update();\n\n    // setup skydome, use top mipmap level of cubemap (full resolution)\n    app.scene.skyboxMip = 0;\n    app.scene.setSkybox(assets["helipad.dds"].resources);\n\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // update things each frame\n    let time = 0;\n    let switchTime = 0;\n    app.on("update", function (dt) {\n        // rotate texture camera around the objects\n        time += dt;\n        textureCamera.setLocalPosition(\n            12 * Math.sin(time),\n            3,\n            12 * Math.cos(time)\n        );\n        textureCamera.lookAt(pc.Vec3.ZERO);\n\n        // every 5 seconds switch texture camera between perspective and orthographic projection\n        switchTime += dt;\n        if (switchTime > 5) {\n            switchTime = 0;\n            if (\n                textureCamera.camera.projection === pc.PROJECTION_ORTHOGRAPHIC\n            ) {\n                textureCamera.camera.projection = pc.PROJECTION_PERSPECTIVE;\n            } else {\n                textureCamera.camera.projection = pc.PROJECTION_ORTHOGRAPHIC;\n                textureCamera.camera.orthoHeight = 5;\n            }\n        }\n    });\n}\n',nameSlug:"render-to-texture",categorySlug:"graphics"},"shader-burn":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: any): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.translate(0, 7, 24);\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent(\"light\", {\n        type: \"omni\",\n        color: new pc.Color(1, 1, 1),\n        radius: 10\n    });\n    light.translate(0, 1, 0);\n\n    // Add entities into scene hierarchy\n    app.root.addChild(camera);\n    app.root.addChild(light);\n\n    app.start();\n\n    // Create the shader definition and shader from the vertex and fragment shaders\n    const shaderDefinition = {\n        attributes: {\n            aPosition: pc.SEMANTIC_POSITION,\n            aUv0: pc.SEMANTIC_TEXCOORD0\n        },\n        vshader: assets['shader.vert'].data,\n        fshader: assets['shader.frag'].data\n    };\n    const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n    // Create a new material with the new shader\n    const material = new pc.Material();\n    material.shader = shader;\n    material.setParameter('uHeightMap', assets.clouds.resource);\n\n    // create a hierarchy of entities with render components, representing the statue model\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    // Set the new material on all meshes in the model, and use original texture from the model on the new material\n    let originalTexture:pc.Texture = null;\n    const renders: Array<pc.RenderComponent> = entity.findComponents(\"render\");\n    renders.forEach((render) => {\n        const meshInstances = render.meshInstances;\n        for (let i = 0; i < meshInstances.length; i++) {\n            const meshInstance = meshInstances[i];\n            if (!originalTexture) {\n                const originalMaterial = meshInstance.material as pc.StandardMaterial;\n                originalTexture = originalMaterial.diffuseMap;\n            }\n            meshInstance.material = material;\n        }\n    });\n\n    // material is set up, update it\n    material.setParameter('uDiffuseMap', originalTexture);\n    material.update();\n\n    let time = 0;\n    app.on(\"update\", function (dt) {\n        time += 0.2 * dt;\n\n        // reverse time\n        let t = time % 2;\n        if (t > 1) {\n            t = 1 - (t - 1);\n        }\n\n        // set time parameter for the shader\n        material.setParameter('uTime', t);\n        material.update();\n    });\n}",javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.translate(0, 7, 24);\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        radius: 10,\n    });\n\n    light.translate(0, 1, 0);\n\n    // Add entities into scene hierarchy\n    app.root.addChild(camera);\n    app.root.addChild(light);\n\n    app.start();\n\n    // Create the shader definition and shader from the vertex and fragment shaders\n    const shaderDefinition = {\n        attributes: {\n            aPosition: pc.SEMANTIC_POSITION,\n            aUv0: pc.SEMANTIC_TEXCOORD0,\n        },\n\n        vshader: assets["shader.vert"].data,\n        fshader: assets["shader.frag"].data,\n    };\n\n    const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n    // Create a new material with the new shader\n    const material = new pc.Material();\n    material.shader = shader;\n    material.setParameter("uHeightMap", assets.clouds.resource);\n\n    // create a hierarchy of entities with render components, representing the statue model\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    // Set the new material on all meshes in the model, and use original texture from the model on the new material\n    let originalTexture = null;\n    const renders = entity.findComponents("render");\n    renders.forEach((render) => {\n        const meshInstances = render.meshInstances;\n        for (let i = 0; i < meshInstances.length; i++) {\n            const meshInstance = meshInstances[i];\n            if (!originalTexture) {\n                const originalMaterial = meshInstance.material;\n                originalTexture = originalMaterial.diffuseMap;\n            }\n            meshInstance.material = material;\n        }\n    });\n\n    // material is set up, update it\n    material.setParameter("uDiffuseMap", originalTexture);\n    material.update();\n\n    let time = 0;\n    app.on("update", function (dt) {\n        time += 0.2 * dt;\n\n        // reverse time\n        let t = time % 2;\n        if (t > 1) {\n            t = 1 - (t - 1);\n        }\n\n        // set time parameter for the shader\n        material.setParameter("uTime", t);\n        material.update();\n    });\n}\n',nameSlug:"shader-burn",categorySlug:"graphics"},"shader-toon":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.translate(0, 7, 24);\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        radius: 10\n    });\n    light.translate(0, 1, 0);\n\n    // Add entities into scene hierarchy\n    app.root.addChild(camera);\n    app.root.addChild(light);\n\n    app.start();\n\n    // Create the shader definition and shader from the vertex and fragment shaders\n    const shaderDefinition = {\n        attributes: {\n            aPosition: pc.SEMANTIC_POSITION,\n            aNormal: pc.SEMANTIC_NORMAL,\n            aUv: pc.SEMANTIC_TEXCOORD0\n        },\n        vshader: assets[\'shader.vert\'].data,\n        fshader: assets[\'shader.frag\'].data\n    };\n    const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n    // Create a new material with the new shader\n    const material = new pc.Material();\n    material.shader = shader;\n\n    // create a hierarchy of entities with render components, representing the statue model\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    // Set the new material on all meshes in the model, and use original texture from the model on the new material\n    let originalTexture:pc.Texture = null;\n    const renders: Array<pc.RenderComponent> = entity.findComponents("render");\n    renders.forEach((render) => {\n        const meshInstances = render.meshInstances;\n        for (let i = 0; i < meshInstances.length; i++) {\n            const meshInstance = meshInstances[i];\n            if (!originalTexture) {\n                const originalMaterial = meshInstance.material as pc.StandardMaterial;\n                originalTexture = originalMaterial.diffuseMap;\n            }\n            meshInstance.material = material;\n        }\n    });\n\n    // material parameters\n    const lightPosArray = [light.getPosition().x, light.getPosition().y, light.getPosition().z];\n    material.setParameter(\'uLightPos\', lightPosArray);\n    material.setParameter(\'uTexture\', originalTexture);\n    material.update();\n\n    // rotate the statue\n    app.on("update", function (dt) {\n        entity.rotate(0, 60 * dt, 0);\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.translate(0, 7, 24);\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        radius: 10,\n    });\n\n    light.translate(0, 1, 0);\n\n    // Add entities into scene hierarchy\n    app.root.addChild(camera);\n    app.root.addChild(light);\n\n    app.start();\n\n    // Create the shader definition and shader from the vertex and fragment shaders\n    const shaderDefinition = {\n        attributes: {\n            aPosition: pc.SEMANTIC_POSITION,\n            aNormal: pc.SEMANTIC_NORMAL,\n            aUv: pc.SEMANTIC_TEXCOORD0,\n        },\n\n        vshader: assets["shader.vert"].data,\n        fshader: assets["shader.frag"].data,\n    };\n\n    const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n    // Create a new material with the new shader\n    const material = new pc.Material();\n    material.shader = shader;\n\n    // create a hierarchy of entities with render components, representing the statue model\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    // Set the new material on all meshes in the model, and use original texture from the model on the new material\n    let originalTexture = null;\n    const renders = entity.findComponents("render");\n    renders.forEach((render) => {\n        const meshInstances = render.meshInstances;\n        for (let i = 0; i < meshInstances.length; i++) {\n            const meshInstance = meshInstances[i];\n            if (!originalTexture) {\n                const originalMaterial = meshInstance.material;\n                originalTexture = originalMaterial.diffuseMap;\n            }\n            meshInstance.material = material;\n        }\n    });\n\n    // material parameters\n    const lightPosArray = [\n        light.getPosition().x,\n        light.getPosition().y,\n        light.getPosition().z,\n    ];\n    material.setParameter("uLightPos", lightPosArray);\n    material.setParameter("uTexture", originalTexture);\n    material.update();\n\n    // rotate the statue\n    app.on("update", function (dt) {\n        entity.rotate(0, 60 * dt, 0);\n    });\n}\n',nameSlug:"shader-toon",categorySlug:"graphics"},"shader-wobble":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any): void {\n    let time = 0;\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.translate(0, 7, 25);\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        radius: 10\n    });\n    light.translate(0, 1, 0);\n\n    // Add entities into scene hierarchy\n    app.root.addChild(camera);\n    app.root.addChild(light);\n\n    // Create the shader definition and shader from the vertex and fragment shaders\n    const shaderDefinition = {\n        attributes: {\n            aPosition: pc.SEMANTIC_POSITION,\n            aUv0: pc.SEMANTIC_TEXCOORD0\n        },\n        vshader: assets[\'shader.vert\'].data,\n        fshader: assets[\'shader.frag\'].data\n    };\n\n    const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n    // Create a new material with the new shader\n    const material = new pc.Material();\n    material.shader = shader;\n\n    // create a hierarchy of entities with render components, representing the statue model\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    // Set the new material on all meshes in the model, and use original texture from the model on the new material\n    let originalTexture: pc.Texture = null;\n    const renders: Array<pc.RenderComponent> = entity.findComponents("render");\n    renders.forEach((render) => {\n        const meshInstances = render.meshInstances;\n        for (let i = 0; i < meshInstances.length; i++) {\n            const meshInstance = meshInstances[i];\n            if (!originalTexture) {\n                const originalMaterial = meshInstance.material as pc.StandardMaterial;\n                originalTexture = originalMaterial.diffuseMap;\n            }\n            meshInstance.material = material;\n        }\n    });\n\n    // material is set up, update it\n    material.setParameter(\'uDiffuseMap\', originalTexture);\n    material.update();\n\n    app.on("update", function (dt) {\n        time += dt;\n\n        // set time parameter for the shader\n        material.setParameter(\'uTime\', time);\n        material.update();\n    });\n\n    app.start();\n}',javaScriptFunction:'function example(canvas, assets) {\n    let time = 0;\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.translate(0, 7, 25);\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        radius: 10,\n    });\n\n    light.translate(0, 1, 0);\n\n    // Add entities into scene hierarchy\n    app.root.addChild(camera);\n    app.root.addChild(light);\n\n    // Create the shader definition and shader from the vertex and fragment shaders\n    const shaderDefinition = {\n        attributes: {\n            aPosition: pc.SEMANTIC_POSITION,\n            aUv0: pc.SEMANTIC_TEXCOORD0,\n        },\n\n        vshader: assets["shader.vert"].data,\n        fshader: assets["shader.frag"].data,\n    };\n\n    const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n    // Create a new material with the new shader\n    const material = new pc.Material();\n    material.shader = shader;\n\n    // create a hierarchy of entities with render components, representing the statue model\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    // Set the new material on all meshes in the model, and use original texture from the model on the new material\n    let originalTexture = null;\n    const renders = entity.findComponents("render");\n    renders.forEach((render) => {\n        const meshInstances = render.meshInstances;\n        for (let i = 0; i < meshInstances.length; i++) {\n            const meshInstance = meshInstances[i];\n            if (!originalTexture) {\n                const originalMaterial = meshInstance.material;\n                originalTexture = originalMaterial.diffuseMap;\n            }\n            meshInstance.material = material;\n        }\n    });\n\n    // material is set up, update it\n    material.setParameter("uDiffuseMap", originalTexture);\n    material.update();\n\n    app.on("update", function (dt) {\n        time += dt;\n\n        // set time parameter for the shader\n        material.setParameter("uTime", time);\n        material.update();\n    });\n\n    app.start();\n}\n',nameSlug:"shader-wobble",categorySlug:"graphics"},"shadow-cascades":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any, data: any): void {\n\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    data.set(\'settings\', {\n        light: {\n            numCascades: 4,             // number of cascades\n            shadowResolution: 2048,     // shadow map resolution storing 4 cascades\n            cascadeDistribution: 0.5,   // distribution of cascade distances to prefer sharpness closer to the camera\n            shadowType: pc.SHADOW_PCF3, // shadow filter type\n            vsmBlurSize: 11             // shader filter blur size for VSM shadows\n        }\n    });\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // setup skydome\n    app.scene.skyboxMip = 3;\n    app.scene.setSkybox(assets.helipad.resources);\n    app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(0, -70, 0);\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // instantiate the terrain\n    const terrain = assets.terrain.resource.instantiateRenderEntity();\n    terrain.setLocalScale(30, 30, 30);\n    app.root.addChild(terrain);\n\n    // find a tree in the middle to use as a focus point\n    const tree = terrain.findOne("name", "Arbol 2.002");\n\n    // create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.9, 0.9, 0.9),\n        farClip: 1000\n    });\n\n    // and position it in the world\n    camera.setLocalPosition(300, 60, 25);\n\n    // add orbit camera script with a mouse and a touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            focusEntity: tree,\n            distanceMax: 600\n        }\n    });\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // Create a directional light casting cascaded shadows\n    const dirLight = new pc.Entity();\n    dirLight.addComponent("light", {\n        ...{\n            type: "directional",\n            color: pc.Color.WHITE,\n            shadowBias: 0.3,\n            normalOffsetBias: 0.2,\n            intensity: 1.0,\n\n            // enable shadow casting\n            castShadows: true,\n            shadowDistance: 1000\n        },\n        ...data.get(\'settings.light\')\n    });\n    app.root.addChild(dirLight);\n    dirLight.setLocalEulerAngles(45, 350, 20);\n\n    // handle HUD changes - update properties on the light\n    data.on(\'*:set\', (path: string, value: any) => {\n        const pathArray = path.split(\'.\');\n        // @ts-ignore\n        dirLight.light[pathArray[2]] = value;\n    });\n\n    // on the first frame, when camera is updated, move it further away from the focus tree\n    let firstFrame = true;\n    app.on("update", function (dt) {\n        if (firstFrame) {\n            firstFrame = false;\n            // @ts-ignore engine-tsd\n            camera.script.orbitCamera.distance = 320;\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets, data) {\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    data.set("settings", {\n        light: {\n            numCascades: 4, // number of cascades\n            shadowResolution: 2048, // shadow map resolution storing 4 cascades\n            cascadeDistribution: 0.5, // distribution of cascade distances to prefer sharpness closer to the camera\n            shadowType: pc.SHADOW_PCF3, // shadow filter type\n            vsmBlurSize: 11, // shader filter blur size for VSM shadows\n        },\n    });\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // setup skydome\n    app.scene.skyboxMip = 3;\n    app.scene.setSkybox(assets.helipad.resources);\n    app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(0, -70, 0);\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n\n    // instantiate the terrain\n    const terrain = assets.terrain.resource.instantiateRenderEntity();\n    terrain.setLocalScale(30, 30, 30);\n    app.root.addChild(terrain);\n\n    // find a tree in the middle to use as a focus point\n    const tree = terrain.findOne("name", "Arbol 2.002");\n\n    // create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.9, 0.9, 0.9),\n        farClip: 1000,\n    });\n\n    // and position it in the world\n    camera.setLocalPosition(300, 60, 25);\n\n    // add orbit camera script with a mouse and a touch support\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2,\n            focusEntity: tree,\n            distanceMax: 600,\n        },\n    });\n\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // Create a directional light casting cascaded shadows\n    const dirLight = new pc.Entity();\n    dirLight.addComponent("light", {\n        ...{\n            type: "directional",\n            color: pc.Color.WHITE,\n            shadowBias: 0.3,\n            normalOffsetBias: 0.2,\n            intensity: 1.0,\n\n            // enable shadow casting\n            castShadows: true,\n            shadowDistance: 1000,\n        },\n\n        ...data.get("settings.light"),\n    });\n\n    app.root.addChild(dirLight);\n    dirLight.setLocalEulerAngles(45, 350, 20);\n\n    // handle HUD changes - update properties on the light\n    data.on("*:set", (path, value) => {\n        const pathArray = path.split(".");\n        // @ts-ignore\n        dirLight.light[pathArray[2]] = value;\n    });\n\n    // on the first frame, when camera is updated, move it further away from the focus tree\n    let firstFrame = true;\n    app.on("update", function (dt) {\n        if (firstFrame) {\n            firstFrame = false;\n            // @ts-ignore engine-tsd\n            camera.script.orbitCamera.distance = 320;\n        }\n    });\n}\n',nameSlug:"shadow-cascades",categorySlug:"graphics"},shapes:{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // All render component primitive shape types\n    const shapes = ["box", "plane", "cone", "cylinder", "sphere", "capsule"];\n    let x = -1, y = -1;\n\n    shapes.forEach(function (shape) {\n        // Create an entity with a render component\n        const entity = new pc.Entity();\n        entity.addComponent("render", {\n            type: shape\n        });\n        app.root.addChild(entity);\n\n        // Lay out the 6 primitives in two rows, 3 per row\n        entity.setLocalPosition(x * 1.2, y, 0);\n        if (x++ === 1) {\n            x = -1;\n            y = 1;\n        }\n    });\n\n    // Create an entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional"\n    });\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 30, 0);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    app.root.addChild(camera);\n    camera.setLocalPosition(0, 0, 5);\n}',javaScriptFunction:'function example(canvas) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // All render component primitive shape types\n    const shapes = ["box", "plane", "cone", "cylinder", "sphere", "capsule"];\n    let x = -1,\n        y = -1;\n\n    shapes.forEach(function (shape) {\n        // Create an entity with a render component\n        const entity = new pc.Entity();\n        entity.addComponent("render", {\n            type: shape,\n        });\n\n        app.root.addChild(entity);\n\n        // Lay out the 6 primitives in two rows, 3 per row\n        entity.setLocalPosition(x * 1.2, y, 0);\n        if (x++ === 1) {\n            x = -1;\n            y = 1;\n        }\n    });\n\n    // Create an entity with a directional light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n    });\n\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 30, 0);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    app.root.addChild(camera);\n    camera.setLocalPosition(0, 0, 5);\n}\n',nameSlug:"shapes",categorySlug:"graphics"},"texture-basis":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: { color: pc.Asset, gloss: pc.Asset, normal: pc.Asset, helipad: pc.Asset }): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    pc.basisInitialize({\n        glueUrl: '/static/lib/basis/basis.wasm.js',\n        wasmUrl: '/static/lib/basis/basis.wasm.wasm',\n        fallbackUrl: '/static/lib/basis/basis.js'\n    });\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Set skybox\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    app.scene.skyboxMip = 1;\n    app.scene.skyboxIntensity = 0.7;\n    app.scene.setSkybox(assets.helipad.resources);\n\n    // Create directional light\n    const light = new pc.Entity();\n    light.addComponent('light', {\n        type: 'directional'\n    });\n    light.setLocalEulerAngles(45, 0, 45);\n\n    // Construct material\n    const material = new pc.StandardMaterial();\n    material.useMetalness = true;\n    material.diffuse = new pc.Color(0.3, 0.3, 0.3);\n    material.shininess = 80;\n    material.metalness = 0.7;\n    material.diffuseMap = assets.color.resource;\n    material.normalMap = assets.normal.resource;\n    material.glossMap = assets.gloss.resource;\n    material.diffuseMapTiling.set(7, 7);\n    material.normalMapTiling.set(7, 7);\n    material.glossMapTiling.set(7, 7);\n    material.update();\n\n    // Create a torus shape\n    const torus = pc.createTorus(app.graphicsDevice, {\n        tubeRadius: 0.2,\n        ringRadius: 0.3,\n        segments: 50,\n        sides: 40\n    });\n    const shape = new pc.Entity();\n    shape.addComponent('render', {\n        material: material,\n        meshInstances: [new pc.MeshInstance(torus, material)]\n    });\n    shape.setPosition(0, 0, 0);\n    shape.setLocalScale(2, 2, 2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n\n    // Adjust the camera position\n    camera.translate(0, 0, 4);\n\n    // Add the new Entities to the hierarchy\n    app.root.addChild(light);\n    app.root.addChild(shape);\n    app.root.addChild(camera);\n\n    // Set an update function on the app's update event\n    let angle = 0;\n    app.on(\"update\", function (dt) {\n        angle = (angle + dt * 10) % 360;\n\n        // Rotate the boxes\n        shape.setEulerAngles(angle, angle * 2, angle * 4);\n    });\n}",javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    pc.basisInitialize({\n        glueUrl: "/static/lib/basis/basis.wasm.js",\n        wasmUrl: "/static/lib/basis/basis.wasm.wasm",\n        fallbackUrl: "/static/lib/basis/basis.js",\n    });\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Set skybox\n    app.scene.toneMapping = pc.TONEMAP_ACES;\n    app.scene.skyboxMip = 1;\n    app.scene.skyboxIntensity = 0.7;\n    app.scene.setSkybox(assets.helipad.resources);\n\n    // Create directional light\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n    });\n\n    light.setLocalEulerAngles(45, 0, 45);\n\n    // Construct material\n    const material = new pc.StandardMaterial();\n    material.useMetalness = true;\n    material.diffuse = new pc.Color(0.3, 0.3, 0.3);\n    material.shininess = 80;\n    material.metalness = 0.7;\n    material.diffuseMap = assets.color.resource;\n    material.normalMap = assets.normal.resource;\n    material.glossMap = assets.gloss.resource;\n    material.diffuseMapTiling.set(7, 7);\n    material.normalMapTiling.set(7, 7);\n    material.glossMapTiling.set(7, 7);\n    material.update();\n\n    // Create a torus shape\n    const torus = pc.createTorus(app.graphicsDevice, {\n        tubeRadius: 0.2,\n        ringRadius: 0.3,\n        segments: 50,\n        sides: 40,\n    });\n\n    const shape = new pc.Entity();\n    shape.addComponent("render", {\n        material: material,\n        meshInstances: [new pc.MeshInstance(torus, material)],\n    });\n\n    shape.setPosition(0, 0, 0);\n    shape.setLocalScale(2, 2, 2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    // Adjust the camera position\n    camera.translate(0, 0, 4);\n\n    // Add the new Entities to the hierarchy\n    app.root.addChild(light);\n    app.root.addChild(shape);\n    app.root.addChild(camera);\n\n    // Set an update function on the app\'s update event\n    let angle = 0;\n    app.on("update", function (dt) {\n        angle = (angle + dt * 10) % 360;\n\n        // Rotate the boxes\n        shape.setEulerAngles(angle, angle * 2, angle * 4);\n    });\n}\n',nameSlug:"texture-basis",categorySlug:"graphics"},"transform-feedback":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // create small 2D texture representing movement direction (wind)\n    const textureResolution = 10;\n    const textureData = new Uint8ClampedArray(textureResolution * textureResolution * 4);\n\n    for (let i = 0; i < textureResolution * textureResolution; i++) {\n\n        // rgb store biased movement direction\n        textureData[i * 4] = 127 + Math.random() * 50 - 25;\n        textureData[i * 4 + 1] = 127 + Math.random() * 50 - 25;\n        textureData[i * 4 + 2] = 127 + Math.random() * 50 - 25;\n\n        // set alpha to 255 for debugging purposes\n        textureData[i * 4 + 3] = 255;\n    }\n\n    // create texture\n    const texture = new pc.Texture(app.graphicsDevice, {\n        width: textureResolution,\n        height: textureResolution,\n        format: pc.PIXELFORMAT_R8_G8_B8_A8,\n        cubemap: false,\n        mipmaps: false,\n        minFilter: pc.FILTER_LINEAR,\n        magFilter: pc.FILTER_LINEAR,\n        addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n        addressV: pc.ADDRESS_CLAMP_TO_EDGE\n    });\n\n    // initialize it with data\n    const pixels = texture.lock();\n    pixels.set(textureData);\n    texture.unlock();\n\n    // Create main camera, which renders the world\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n    app.root.addChild(camera);\n\n    // set up texture transform part, on webgl2 devices only\n    let tf: any;\n    let shader: any;\n    const areaSize = 30;\n\n    // resolve parameters to simulation shader parameters\n    const areaSizeUniform = app.graphicsDevice.scope.resolve("areaSize");\n    const deltaTimeUniform = app.graphicsDevice.scope.resolve("deltaTime");\n    const directionSampler = app.graphicsDevice.scope.resolve("directionSampler");\n\n    // @ts-ignore engine-tsd\n    if (app.graphicsDevice.webgl2) {\n\n        // simulated particles\n        const maxNumPoints = 200000;\n        const positions = new Float32Array(4 * maxNumPoints);\n\n        // generate random data, these are used as seeds to generate particles in vertex shader\n        for (let i = 0; i < maxNumPoints; i++) {\n            positions[i * 4] = Math.random();\n            positions[i * 4 + 1] = Math.random();\n            positions[i * 4 + 2] = Math.random();\n\n            // set life time to 0 which triggers particle restart in shader\n            positions[i * 4 + 3] = 0;\n        }\n\n        // store these in a vertex buffer of a mesh\n        const mesh = new pc.Mesh(app.graphicsDevice);\n        mesh.setPositions(positions, 4);\n        mesh.update(pc.PRIMITIVE_POINTS, false);\n\n        // set large bounding box so we don\'t need to update it each frame\n        mesh.aabb = new pc.BoundingBox(new pc.Vec3(0, 0, 0), new pc.Vec3(100, 100, 100));\n\n        // Create the shader from the vertex and fragment shaders which is used to render point sprites\n        shader = new pc.Shader(app.graphicsDevice, {\n            attributes: { aPosition: pc.SEMANTIC_POSITION },\n            vshader: assets.vshaderCloud.data,\n            fshader: assets.fshaderCloud.data\n        });\n\n        // Create a new material with the new shader and additive alpha blending\n        const material = new pc.Material();\n        material.shader = shader;\n        material.blendType = pc.BLEND_ADDITIVEALPHA;\n        material.depthWrite = false;\n\n        // Create the mesh instance\n        const node = new pc.GraphNode();\n        const meshInstance = new pc.MeshInstance(mesh, material, node);\n\n        // create an entity used to render the mesh instance using a render component\n        const entity = new pc.Entity();\n        entity.addComponent("render", {\n            type: \'asset\',\n            meshInstances: [meshInstance]\n        });\n        app.root.addChild(entity);\n\n        // set up transform feedback. This creates a clone of the vertex buffer, and sets up rendering to ping pong between them\n        tf = new pc.TransformFeedback(mesh.vertexBuffer);\n        shader = pc.TransformFeedback.createShader(app.graphicsDevice, assets.vshaderFeedback.data, "transformShaderExample");\n    }\n\n    // update things each frame\n    let time = 0;\n    app.on("update", function (dt) {\n\n        // rotate camera around\n        time += dt;\n        camera.setLocalPosition(9 * Math.sin(time * 0.2), 6, 25 * Math.cos(time * 0.2));\n        camera.lookAt(new pc.Vec3(0, 3, 0));\n\n        // if transform feedback was initialized\n        if (tf) {\n\n            // set up simulation parameters\n            areaSizeUniform.setValue(areaSize);\n            deltaTimeUniform.setValue(dt);\n            directionSampler.setValue(texture);\n\n            // execute simulation\n            tf.process(shader);\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // create small 2D texture representing movement direction (wind)\n    const textureResolution = 10;\n    const textureData = new Uint8ClampedArray(\n        textureResolution * textureResolution * 4\n    );\n\n    for (let i = 0; i < textureResolution * textureResolution; i++) {\n        // rgb store biased movement direction\n        textureData[i * 4] = 127 + Math.random() * 50 - 25;\n        textureData[i * 4 + 1] = 127 + Math.random() * 50 - 25;\n        textureData[i * 4 + 2] = 127 + Math.random() * 50 - 25;\n\n        // set alpha to 255 for debugging purposes\n        textureData[i * 4 + 3] = 255;\n    }\n\n    // create texture\n    const texture = new pc.Texture(app.graphicsDevice, {\n        width: textureResolution,\n        height: textureResolution,\n        format: pc.PIXELFORMAT_R8_G8_B8_A8,\n        cubemap: false,\n        mipmaps: false,\n        minFilter: pc.FILTER_LINEAR,\n        magFilter: pc.FILTER_LINEAR,\n        addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n        addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n    });\n\n    // initialize it with data\n    const pixels = texture.lock();\n    pixels.set(textureData);\n    texture.unlock();\n\n    // Create main camera, which renders the world\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    app.root.addChild(camera);\n\n    // set up texture transform part, on webgl2 devices only\n    let tf;\n    let shader;\n    const areaSize = 30;\n\n    // resolve parameters to simulation shader parameters\n    const areaSizeUniform = app.graphicsDevice.scope.resolve("areaSize");\n    const deltaTimeUniform = app.graphicsDevice.scope.resolve("deltaTime");\n    const directionSampler =\n        app.graphicsDevice.scope.resolve("directionSampler");\n\n    // @ts-ignore engine-tsd\n    if (app.graphicsDevice.webgl2) {\n        // simulated particles\n        const maxNumPoints = 200000;\n        const positions = new Float32Array(4 * maxNumPoints);\n\n        // generate random data, these are used as seeds to generate particles in vertex shader\n        for (let i = 0; i < maxNumPoints; i++) {\n            positions[i * 4] = Math.random();\n            positions[i * 4 + 1] = Math.random();\n            positions[i * 4 + 2] = Math.random();\n\n            // set life time to 0 which triggers particle restart in shader\n            positions[i * 4 + 3] = 0;\n        }\n\n        // store these in a vertex buffer of a mesh\n        const mesh = new pc.Mesh(app.graphicsDevice);\n        mesh.setPositions(positions, 4);\n        mesh.update(pc.PRIMITIVE_POINTS, false);\n\n        // set large bounding box so we don\'t need to update it each frame\n        mesh.aabb = new pc.BoundingBox(\n            new pc.Vec3(0, 0, 0),\n            new pc.Vec3(100, 100, 100)\n        );\n\n        // Create the shader from the vertex and fragment shaders which is used to render point sprites\n        shader = new pc.Shader(app.graphicsDevice, {\n            attributes: { aPosition: pc.SEMANTIC_POSITION },\n            vshader: assets.vshaderCloud.data,\n            fshader: assets.fshaderCloud.data,\n        });\n\n        // Create a new material with the new shader and additive alpha blending\n        const material = new pc.Material();\n        material.shader = shader;\n        material.blendType = pc.BLEND_ADDITIVEALPHA;\n        material.depthWrite = false;\n\n        // Create the mesh instance\n        const node = new pc.GraphNode();\n        const meshInstance = new pc.MeshInstance(mesh, material, node);\n\n        // create an entity used to render the mesh instance using a render component\n        const entity = new pc.Entity();\n        entity.addComponent("render", {\n            type: "asset",\n            meshInstances: [meshInstance],\n        });\n\n        app.root.addChild(entity);\n\n        // set up transform feedback. This creates a clone of the vertex buffer, and sets up rendering to ping pong between them\n        tf = new pc.TransformFeedback(mesh.vertexBuffer);\n        shader = pc.TransformFeedback.createShader(\n            app.graphicsDevice,\n            assets.vshaderFeedback.data,\n            "transformShaderExample"\n        );\n    }\n\n    // update things each frame\n    let time = 0;\n    app.on("update", function (dt) {\n        // rotate camera around\n        time += dt;\n        camera.setLocalPosition(\n            9 * Math.sin(time * 0.2),\n            6,\n            25 * Math.cos(time * 0.2)\n        );\n        camera.lookAt(new pc.Vec3(0, 3, 0));\n\n        // if transform feedback was initialized\n        if (tf) {\n            // set up simulation parameters\n            areaSizeUniform.setValue(areaSize);\n            deltaTimeUniform.setValue(dt);\n            directionSampler.setValue(texture);\n\n            // execute simulation\n            tf.process(shader);\n        }\n    });\n}\n',nameSlug:"transform-feedback",categorySlug:"graphics"},"video-texture":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: { tv: pc.Asset }): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.translate(0, 0, 15);\n\n    // Create an Entity with a omni light\n    const light = new pc.Entity();\n    light.addComponent(\"light\", {\n        type: \"omni\",\n        color: new pc.Color(1, 1, 1),\n        range: 30\n    });\n    light.translate(5, 5, 10);\n\n    app.root.addChild(camera);\n    app.root.addChild(light);\n\n    // Create a texture to hold the video frame data\n    const videoTexture = new pc.Texture(app.graphicsDevice, {\n        format: pc.PIXELFORMAT_R5_G6_B5,\n        mipmaps: false,\n        minFilter: pc.FILTER_LINEAR,\n        magFilter: pc.FILTER_LINEAR,\n        addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n        addressV: pc.ADDRESS_CLAMP_TO_EDGE\n    });\n\n    // Create our HTML element with the video\n    const video: HTMLVideoElement = document.createElement('video');\n    video.id = 'vid';\n    video.loop = true;\n\n    // Muted so that we can autoplay\n    video.muted = true;\n    video.autoplay = true;\n\n    // Inline needed for iOS otherwise it plays at fullscreen\n    video.playsInline = true;\n\n    video.crossOrigin = \"anonymous\";\n\n    // Make sure that the video is in view on the page otherwise it doesn't\n    // load on some browsers, especially mobile\n    video.setAttribute('style', 'display: block; width: 1px; height: 1px; position: absolute; opacity: 0; z-index: -1000; top: 0px; pointer-events: none');\n\n    video.src = '/static/assets/video/SampleVideo_1280x720_1mb.mp4';\n    document.body.append(video);\n\n    video.addEventListener('canplaythrough', function () {\n        videoTexture.setSource(video);\n    });\n\n    // create an entity to render the tv mesh\n    const entity = assets.tv.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    // Create a material that will use our video texture\n    const material = new pc.StandardMaterial();\n    material.useLighting = false;\n    material.emissiveMap = videoTexture;\n    material.update();\n\n    // set the material on the screen mesh\n    entity.render.meshInstances[1].material = material;\n\n    video.load();\n\n    const mouse = new pc.Mouse(document.body);\n    mouse.on('mousedown', function (event) {\n        if (entity && event.buttons[pc.MOUSEBUTTON_LEFT]) {\n            video.muted = !video.muted;\n        }\n    });\n\n    let upload = false;\n    let time = 0;\n    app.on('update', function (dt) {\n        time += dt;\n\n        // rotate the tv object\n        entity.setLocalEulerAngles(100 + Math.sin(time) * 50, 0, -90);\n\n        // Upload the video data to the texture every other frame\n        upload = !upload;\n        if (upload) {\n            videoTexture.upload();\n        }\n    });\n}",javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.translate(0, 0, 15);\n\n    // Create an Entity with a omni light\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 30,\n    });\n\n    light.translate(5, 5, 10);\n\n    app.root.addChild(camera);\n    app.root.addChild(light);\n\n    // Create a texture to hold the video frame data\n    const videoTexture = new pc.Texture(app.graphicsDevice, {\n        format: pc.PIXELFORMAT_R5_G6_B5,\n        mipmaps: false,\n        minFilter: pc.FILTER_LINEAR,\n        magFilter: pc.FILTER_LINEAR,\n        addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n        addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n    });\n\n    // Create our HTML element with the video\n    const video = document.createElement("video");\n    video.id = "vid";\n    video.loop = true;\n\n    // Muted so that we can autoplay\n    video.muted = true;\n    video.autoplay = true;\n\n    // Inline needed for iOS otherwise it plays at fullscreen\n    video.playsInline = true;\n\n    video.crossOrigin = "anonymous";\n\n    // Make sure that the video is in view on the page otherwise it doesn\'t\n    // load on some browsers, especially mobile\n    video.setAttribute(\n        "style",\n        "display: block; width: 1px; height: 1px; position: absolute; opacity: 0; z-index: -1000; top: 0px; pointer-events: none"\n    );\n\n    video.src = "/static/assets/video/SampleVideo_1280x720_1mb.mp4";\n    document.body.append(video);\n\n    video.addEventListener("canplaythrough", function () {\n        videoTexture.setSource(video);\n    });\n\n    // create an entity to render the tv mesh\n    const entity = assets.tv.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    // Create a material that will use our video texture\n    const material = new pc.StandardMaterial();\n    material.useLighting = false;\n    material.emissiveMap = videoTexture;\n    material.update();\n\n    // set the material on the screen mesh\n    entity.render.meshInstances[1].material = material;\n\n    video.load();\n\n    const mouse = new pc.Mouse(document.body);\n    mouse.on("mousedown", function (event) {\n        if (entity && event.buttons[pc.MOUSEBUTTON_LEFT]) {\n            video.muted = !video.muted;\n        }\n    });\n\n    let upload = false;\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // rotate the tv object\n        entity.setLocalEulerAngles(100 + Math.sin(time) * 50, 0, -90);\n\n        // Upload the video data to the texture every other frame\n        upload = !upload;\n        if (upload) {\n            videoTexture.upload();\n        }\n    });\n}\n',nameSlug:"video-texture",categorySlug:"graphics"}},input:{gamepad:{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { statue: pc.Asset }): void {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.translate(0, 7, 25);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100\n    });\n    light.translate(5, 5, 10);\n    app.root.addChild(light);\n\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    const gamepads = new pc.GamePads();\n    app.on("update", function () {\n        gamepads.update();\n        if (gamepads.isPressed(pc.PAD_1, pc.PAD_LEFT)) {\n            entity.rotate(0, -1, 0);\n        }\n        if (gamepads.isPressed(pc.PAD_1, pc.PAD_RIGHT)) {\n            entity.rotate(0, 1, 0);\n        }\n        if (gamepads.wasPressed(pc.PAD_1, pc.PAD_UP)) {\n            entity.rotate(-1, 0, 0);\n        }\n        if (gamepads.wasPressed(pc.PAD_1, pc.PAD_DOWN)) {\n            entity.rotate(1, 0, 0);\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.translate(0, 7, 25);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100,\n    });\n\n    light.translate(5, 5, 10);\n    app.root.addChild(light);\n\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    const gamepads = new pc.GamePads();\n    app.on("update", function () {\n        gamepads.update();\n        if (gamepads.isPressed(pc.PAD_1, pc.PAD_LEFT)) {\n            entity.rotate(0, -1, 0);\n        }\n        if (gamepads.isPressed(pc.PAD_1, pc.PAD_RIGHT)) {\n            entity.rotate(0, 1, 0);\n        }\n        if (gamepads.wasPressed(pc.PAD_1, pc.PAD_UP)) {\n            entity.rotate(-1, 0, 0);\n        }\n        if (gamepads.wasPressed(pc.PAD_1, pc.PAD_DOWN)) {\n            entity.rotate(1, 0, 0);\n        }\n    });\n}\n',nameSlug:"gamepad",categorySlug:"input"},keyboard:{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { statue: pc.Asset }): void {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.translate(0, 7, 25);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100\n    });\n    light.translate(5, 5, 10);\n    app.root.addChild(light);\n\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    const keyboard = new pc.Keyboard(document.body);\n    app.on("update", function () {\n        if (keyboard.isPressed(pc.KEY_LEFT)) {\n            entity.rotate(0, -1, 0);\n        }\n        if (keyboard.isPressed(pc.KEY_RIGHT)) {\n            entity.rotate(0, 1, 0);\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.translate(0, 7, 25);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100,\n    });\n\n    light.translate(5, 5, 10);\n    app.root.addChild(light);\n\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    const keyboard = new pc.Keyboard(document.body);\n    app.on("update", function () {\n        if (keyboard.isPressed(pc.KEY_LEFT)) {\n            entity.rotate(0, -1, 0);\n        }\n        if (keyboard.isPressed(pc.KEY_RIGHT)) {\n            entity.rotate(0, 1, 0);\n        }\n    });\n}\n',nameSlug:"keyboard",categorySlug:"input"},mouse:{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { statue: pc.Asset }): void {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.translate(0, 7, 25);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100\n    });\n    light.translate(5, 5, 10);\n    app.root.addChild(light);\n\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    const mouse = new pc.Mouse(document.body);\n\n    let x = 0;\n    const y = 0;\n\n    mouse.on(\'mousemove\', function (event) {\n        if (event.buttons[pc.MOUSEBUTTON_LEFT]) {\n            x += event.dx;\n\n            entity.setLocalEulerAngles(0.2 * y, 0.2 * x, 0);\n        }\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.translate(0, 7, 25);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component and a sphere model component.\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100,\n    });\n\n    light.translate(5, 5, 10);\n    app.root.addChild(light);\n\n    const entity = assets.statue.resource.instantiateRenderEntity();\n    app.root.addChild(entity);\n\n    const mouse = new pc.Mouse(document.body);\n\n    let x = 0;\n    const y = 0;\n\n    mouse.on("mousemove", function (event) {\n        if (event.buttons[pc.MOUSEBUTTON_LEFT]) {\n            x += event.dx;\n\n            entity.setLocalEulerAngles(0.2 * y, 0.2 * x, 0);\n        }\n    });\n}\n',nameSlug:"mouse",categorySlug:"input"}},loaders:{"draco-glb":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: any, wasmSupported: any, loadWasmModuleAsync: any): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // load the draco decoder\n    if (wasmSupported()) {\n        loadWasmModuleAsync('DracoDecoderModule', '/static/lib/draco/draco.wasm.js', '/static/lib/draco/draco.wasm.wasm', demo);\n    } else {\n        loadWasmModuleAsync('DracoDecoderModule', '/static/lib/draco/draco.js', '', demo);\n    }\n\n    function demo() {\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        // Load a glb file as a container\n        const url = \"/static/assets/models/heart_draco.glb\";\n        app.assets.loadFromUrl(url, \"container\", function (err, asset) {\n            app.start();\n\n            // create an instance using render component\n            const entity = asset.resource.instantiateRenderEntity({\n                castShadows: true\n            });\n            app.root.addChild(entity);\n            entity.setLocalScale(20, 20, 20);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.2, 0.2)\n            });\n            camera.translate(0, 0.5, 4);\n            app.root.addChild(camera);\n\n            // Create an entity with a omni light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                intensity: 3\n            });\n            light.setLocalPosition(1, 1, 5);\n            app.root.addChild(light);\n\n            app.on(\"update\", function (dt) {\n                if (entity) {\n                    entity.rotate(4 * dt, -20 * dt, 0);\n                }\n            });\n        });\n    }\n}",javaScriptFunction:'function example(canvas, assets, wasmSupported, loadWasmModuleAsync) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // load the draco decoder\n    if (wasmSupported()) {\n        loadWasmModuleAsync(\n            "DracoDecoderModule",\n            "/static/lib/draco/draco.wasm.js",\n            "/static/lib/draco/draco.wasm.wasm",\n            demo\n        );\n    } else {\n        loadWasmModuleAsync(\n            "DracoDecoderModule",\n            "/static/lib/draco/draco.js",\n            "",\n            demo\n        );\n    }\n\n    function demo() {\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        // Load a glb file as a container\n        const url = "/static/assets/models/heart_draco.glb";\n        app.assets.loadFromUrl(url, "container", function (err, asset) {\n            app.start();\n\n            // create an instance using render component\n            const entity = asset.resource.instantiateRenderEntity({\n                castShadows: true,\n            });\n\n            app.root.addChild(entity);\n            entity.setLocalScale(20, 20, 20);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent("camera", {\n                clearColor: new pc.Color(0.2, 0.2, 0.2),\n            });\n\n            camera.translate(0, 0.5, 4);\n            app.root.addChild(camera);\n\n            // Create an entity with a omni light component\n            const light = new pc.Entity();\n            light.addComponent("light", {\n                type: "omni",\n                intensity: 3,\n            });\n\n            light.setLocalPosition(1, 1, 5);\n            app.root.addChild(light);\n\n            app.on("update", function (dt) {\n                if (entity) {\n                    entity.rotate(4 * dt, -20 * dt, 0);\n                }\n            });\n        });\n    }\n}\n',nameSlug:"draco-glb",categorySlug:"loaders"},glb:{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n\n    // The example demonstrates loading of glb file, which contains meshes,\n    // lights and cameras, and switches between the cameras every 2 seconds.\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // the array will store loaded cameras\n    let camerasComponents: Array<pc.CameraComponent> = null;\n\n    // Load a glb file as a container\n    const url = "/static/assets/models/geometry-camera-light.glb";\n    app.assets.loadFromUrl(url, "container", function (err, asset) {\n        app.start();\n\n        // create an instance using render component\n        const entity = asset.resource.instantiateRenderEntity();\n        app.root.addChild(entity);\n\n        // find all cameras - by default they are disabled\n        // set their aspect ratio to automatic to work with any window size\n        camerasComponents = entity.findComponents("camera");\n        camerasComponents.forEach((component) => {\n            component.aspectRatioMode = pc.ASPECT_AUTO;\n        });\n\n        // enable all lights from the glb\n        const lightComponents: Array<pc.LightComponent> = entity.findComponents("light");\n        lightComponents.forEach((component) => {\n            component.enabled = true;\n        });\n\n        let time = 0;\n        let activeCamera = 0;\n        app.on("update", function (dt) {\n            time -= dt;\n\n            // change the camera every few seconds\n            if (time <= 0) {\n                time = 2;\n\n                // disable current camera\n                camerasComponents[activeCamera].enabled = false;\n\n                // activate next camera\n                activeCamera = (activeCamera + 1) % camerasComponents.length;\n                camerasComponents[activeCamera].enabled = true;\n            }\n        });\n    });\n}',javaScriptFunction:'function example(canvas) {\n    // The example demonstrates loading of glb file, which contains meshes,\n    // lights and cameras, and switches between the cameras every 2 seconds.\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // the array will store loaded cameras\n    let camerasComponents = null;\n\n    // Load a glb file as a container\n    const url = "/static/assets/models/geometry-camera-light.glb";\n    app.assets.loadFromUrl(url, "container", function (err, asset) {\n        app.start();\n\n        // create an instance using render component\n        const entity = asset.resource.instantiateRenderEntity();\n        app.root.addChild(entity);\n\n        // find all cameras - by default they are disabled\n        // set their aspect ratio to automatic to work with any window size\n        camerasComponents = entity.findComponents("camera");\n        camerasComponents.forEach((component) => {\n            component.aspectRatioMode = pc.ASPECT_AUTO;\n        });\n\n        // enable all lights from the glb\n        const lightComponents = entity.findComponents("light");\n        lightComponents.forEach((component) => {\n            component.enabled = true;\n        });\n\n        let time = 0;\n        let activeCamera = 0;\n        app.on("update", function (dt) {\n            time -= dt;\n\n            // change the camera every few seconds\n            if (time <= 0) {\n                time = 2;\n\n                // disable current camera\n                camerasComponents[activeCamera].enabled = false;\n\n                // activate next camera\n                activeCamera = (activeCamera + 1) % camerasComponents.length;\n                camerasComponents[activeCamera].enabled = true;\n            }\n        });\n    });\n}\n',nameSlug:"glb",categorySlug:"loaders"},"loaders-gl":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: any): void {\n    // This example uses draco point cloud loader library from https://loaders.gl/\n    // Note that many additional formats are supported by the library and can be used.\n\n    // Create the app\n    const app = new pc.Application(canvas, {});\n\n    async function loadModel(url:string) {\n\n        // load the url using the draco format loader\n        // @ts-ignore: cannot find CORE and DRACO\n        const modelData = await CORE.load(url, DRACO.DracoLoader);\n\n        // loaded colors only contain RGB, convert it to an array of RGBA with alpha of 255\n        const srcColors = modelData.attributes.COLOR_0.value;\n        const numVertices = srcColors.length / modelData.attributes.COLOR_0.size;\n        const colors32 = new Uint8Array(numVertices * 4);\n        for (let i = 0; i < numVertices; i++) {\n            colors32[i * 4 + 0] = srcColors[i * 3 + 0];\n            colors32[i * 4 + 1] = srcColors[i * 3 + 1];\n            colors32[i * 4 + 2] = srcColors[i * 3 + 2];\n            colors32[i * 4 + 3] = 255;\n        }\n\n        // based on the loaded data, create the mesh with position and color vertex data\n        const mesh = new pc.Mesh(app.graphicsDevice);\n        mesh.clear(true, false);\n        mesh.setPositions(modelData.attributes.POSITION.value, modelData.attributes.POSITION.size);\n        mesh.setColors32(colors32);\n        mesh.update(pc.PRIMITIVE_POINTS);\n\n        // Create shader to render mesh as circular points with color\n        const shaderDefinition = {\n            attributes: {\n                aPosition: pc.SEMANTIC_POSITION,\n                aColor: pc.SEMANTIC_COLOR\n            },\n            vshader: assets['shader.vert'].data,\n            fshader: assets['shader.frag'].data\n        };\n        const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n        // create material using the shader\n        const material = new pc.Material();\n        material.shader = shader;\n        material.blendType = pc.BLENDMODE_ONE_MINUS_DST_ALPHA;\n        material.cull = pc.CULLFACE_NONE;\n\n        // Add an entity with a render component to render the mesh\n        const entity = new pc.Entity();\n        entity.addComponent('render', {\n            material: material,\n            meshInstances: [new pc.MeshInstance(mesh, material)]\n        });\n\n        app.root.addChild(entity);\n    }\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n        farClip: 100\n    });\n    camera.translate(-20, 15, 20);\n    camera.lookAt(0, 7, 0);\n    app.root.addChild(camera);\n\n    // load the draco model, and then start the application\n    loadModel(\"/static/assets/models/park_points.drc\").then(() => {\n        app.start();\n    });\n\n    // update things each frame\n    let time = 0;\n    app.on(\"update\", function (dt) {\n        time += dt;\n\n        // orbit the camera\n        if (camera) {\n            camera.setLocalPosition(40 * Math.sin(time * 0.5), 10, 20 * Math.cos(time * 0.5));\n            camera.lookAt(pc.Vec3.ZERO);\n        }\n    });\n}",javaScriptFunction:'function example(canvas, assets) {\n    // This example uses draco point cloud loader library from https://loaders.gl/\n    // Note that many additional formats are supported by the library and can be used.\n\n    // Create the app\n    const app = new pc.Application(canvas, {});\n\n    async function loadModel(url) {\n        // load the url using the draco format loader\n        // @ts-ignore: cannot find CORE and DRACO\n        const modelData = await CORE.load(url, DRACO.DracoLoader);\n\n        // loaded colors only contain RGB, convert it to an array of RGBA with alpha of 255\n        const srcColors = modelData.attributes.COLOR_0.value;\n        const numVertices =\n            srcColors.length / modelData.attributes.COLOR_0.size;\n        const colors32 = new Uint8Array(numVertices * 4);\n        for (let i = 0; i < numVertices; i++) {\n            colors32[i * 4 + 0] = srcColors[i * 3 + 0];\n            colors32[i * 4 + 1] = srcColors[i * 3 + 1];\n            colors32[i * 4 + 2] = srcColors[i * 3 + 2];\n            colors32[i * 4 + 3] = 255;\n        }\n\n        // based on the loaded data, create the mesh with position and color vertex data\n        const mesh = new pc.Mesh(app.graphicsDevice);\n        mesh.clear(true, false);\n        mesh.setPositions(\n            modelData.attributes.POSITION.value,\n            modelData.attributes.POSITION.size\n        );\n        mesh.setColors32(colors32);\n        mesh.update(pc.PRIMITIVE_POINTS);\n\n        // Create shader to render mesh as circular points with color\n        const shaderDefinition = {\n            attributes: {\n                aPosition: pc.SEMANTIC_POSITION,\n                aColor: pc.SEMANTIC_COLOR,\n            },\n\n            vshader: assets["shader.vert"].data,\n            fshader: assets["shader.frag"].data,\n        };\n\n        const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n        // create material using the shader\n        const material = new pc.Material();\n        material.shader = shader;\n        material.blendType = pc.BLENDMODE_ONE_MINUS_DST_ALPHA;\n        material.cull = pc.CULLFACE_NONE;\n\n        // Add an entity with a render component to render the mesh\n        const entity = new pc.Entity();\n        entity.addComponent("render", {\n            material: material,\n            meshInstances: [new pc.MeshInstance(mesh, material)],\n        });\n\n        app.root.addChild(entity);\n    }\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n        farClip: 100,\n    });\n\n    camera.translate(-20, 15, 20);\n    camera.lookAt(0, 7, 0);\n    app.root.addChild(camera);\n\n    // load the draco model, and then start the application\n    loadModel("/static/assets/models/park_points.drc").then(() => {\n        app.start();\n    });\n\n    // update things each frame\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt;\n\n        // orbit the camera\n        if (camera) {\n            camera.setLocalPosition(\n                40 * Math.sin(time * 0.5),\n                10,\n                20 * Math.cos(time * 0.5)\n            );\n            camera.lookAt(pc.Vec3.ZERO);\n        }\n    });\n}\n',nameSlug:"loaders-gl",categorySlug:"loaders"},obj:{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    const objurl = "/static/assets/models/monkey.obj";\n    const scripturl = "/static/scripts/parsers/obj-model.js";\n\n    let entity: pc.Entity;\n    app.assets.loadFromUrl(scripturl, "script", function () {\n\n        // OBJ Parser is not enabled by default in engine. Add the parser to the model resource handler\n        // set up obj parser\n        // @ts-ignore globally loaded ObjModelParser\n        app.loader.getHandler("model").addParser(new ObjModelParser(app.graphicsDevice), function (url) {\n            return (pc.path.getExtension(url) === \'.obj\');\n        });\n\n        app.assets.loadFromUrl(objurl, "model", function (err, asset) {\n\n            app.start();\n\n            entity = new pc.Entity();\n            entity.addComponent("model");\n            entity.model.model = asset.resource;\n            app.root.addChild(entity);\n\n            // add a randomly generated material to all mesh instances\n            const mis = entity.model.meshInstances;\n            for (let i = 0; i < mis.length; i++) {\n                const material = new pc.StandardMaterial();\n                material.diffuse = new pc.Color(pc.math.random(0, 1), pc.math.random(0, 1), pc.math.random(0, 1));\n                material.update();\n                mis[i].material = material;\n            }\n        });\n    });\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.translate(0, 0, 5);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100\n    });\n    light.translate(5, 0, 15);\n    app.root.addChild(light);\n\n    app.on("update", function (dt) {\n        if (entity) {\n            entity.rotate(0, 100 * dt, 0);\n        }\n    });\n}',javaScriptFunction:'function example(canvas) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    const objurl = "/static/assets/models/monkey.obj";\n    const scripturl = "/static/scripts/parsers/obj-model.js";\n\n    let entity;\n    app.assets.loadFromUrl(scripturl, "script", function () {\n        // OBJ Parser is not enabled by default in engine. Add the parser to the model resource handler\n        // set up obj parser\n        // @ts-ignore globally loaded ObjModelParser\n        app.loader\n            .getHandler("model")\n            .addParser(new ObjModelParser(app.graphicsDevice), function (url) {\n                return pc.path.getExtension(url) === ".obj";\n            });\n\n        app.assets.loadFromUrl(objurl, "model", function (err, asset) {\n            app.start();\n\n            entity = new pc.Entity();\n            entity.addComponent("model");\n            entity.model.model = asset.resource;\n            app.root.addChild(entity);\n\n            // add a randomly generated material to all mesh instances\n            const mis = entity.model.meshInstances;\n            for (let i = 0; i < mis.length; i++) {\n                const material = new pc.StandardMaterial();\n                material.diffuse = new pc.Color(\n                    pc.math.random(0, 1),\n                    pc.math.random(0, 1),\n                    pc.math.random(0, 1)\n                );\n                material.update();\n                mis[i].material = material;\n            }\n        });\n    });\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.translate(0, 0, 5);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "omni",\n        color: new pc.Color(1, 1, 1),\n        range: 100,\n    });\n\n    light.translate(5, 0, 15);\n    app.root.addChild(light);\n\n    app.on("update", function (dt) {\n        if (entity) {\n            entity.rotate(0, 100 * dt, 0);\n        }\n    });\n}\n',nameSlug:"obj",categorySlug:"loaders"}},misc:{"hello-world":{typeScriptFunction:"function example(canvas: HTMLCanvasElement): void {\n\n    const app = new pc.Application(canvas, {});\n\n    // create box entity\n    const box = new pc.Entity('cube');\n    box.addComponent('render', {\n        type: 'box'\n    });\n    app.root.addChild(box);\n\n    // create camera entity\n    const camera = new pc.Entity('camera');\n    camera.addComponent('camera', {\n        clearColor: new pc.Color(0.5, 0.6, 0.9)\n    });\n    app.root.addChild(camera);\n    camera.setPosition(0, 0, 3);\n\n    // create directional light entity\n    const light = new pc.Entity('light');\n    light.addComponent('light');\n    app.root.addChild(light);\n    light.setEulerAngles(45, 0, 0);\n\n    // rotate the box according to the delta time since the last frame\n    app.on('update', (dt: number) => box.rotate(10 * dt, 20 * dt, 30 * dt));\n\n    app.start();\n}",javaScriptFunction:'function example(canvas) {\n    const app = new pc.Application(canvas, {});\n\n    // create box entity\n    const box = new pc.Entity("cube");\n    box.addComponent("render", {\n        type: "box",\n    });\n\n    app.root.addChild(box);\n\n    // create camera entity\n    const camera = new pc.Entity("camera");\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.5, 0.6, 0.9),\n    });\n\n    app.root.addChild(camera);\n    camera.setPosition(0, 0, 3);\n\n    // create directional light entity\n    const light = new pc.Entity("light");\n    light.addComponent("light");\n    app.root.addChild(light);\n    light.setEulerAngles(45, 0, 0);\n\n    // rotate the box according to the delta time since the last frame\n    app.on("update", (dt) => box.rotate(10 * dt, 20 * dt, 30 * dt));\n\n    app.start();\n}\n',nameSlug:"hello-world",categorySlug:"misc"},"mini-stats":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, pcx: any): void {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // set up options for mini-stats, start with the default options\n    const options = pcx.MiniStats.getDefaultOptions();\n\n    // configure sizes\n    options.sizes = [\n        { width: 128, height: 16, spacing: 0, graphs: false },\n        { width: 256, height: 32, spacing: 2, graphs: true },\n        { width: 500, height: 64, spacing: 2, graphs: true }\n    ];\n\n    // when the application starts, use the largest size\n    options.startSizeIndex = 2;\n\n    // display additional counters\n    // Note: for most of these to report values, either debug or profiling engine build needs to be used.\n    options.stats = [\n\n        // frame update time in ms\n        {\n            name: "Update",\n            stats: ["frame.updateTime"],\n            decimalPlaces: 1,\n            unitsName: "ms",\n            watermark: 33\n        },\n\n        // total number of draw calls\n        {\n            name: "DrawCalls",\n            stats: ["drawCalls.total"],\n            watermark: 2000\n        },\n\n        // total number of triangles, in 1000s\n        {\n            name: "triCount",\n            stats: ["frame.triangles"],\n            decimalPlaces: 1,\n            multiplier: 1 / 1000,\n            unitsName: "k",\n            watermark: 500\n        },\n\n        // number of materials used in a frame\n        {\n            name: "materials",\n            stats: ["frame.materials"],\n            watermark: 2000\n        },\n\n        // frame time it took to do frustum culling\n        {\n            name: "cull",\n            stats: ["frame.cullTime"],\n            decimalPlaces: 1,\n            watermark: 1,\n            unitsName: "ms"\n        },\n\n        // used VRAM, displayed using 2 colors - red for textures, green for geometry\n        {\n            name: "VRAM",\n            stats: ["vram.tex", "vram.geom"],\n            decimalPlaces: 1,\n            multiplier: 1 / (1024 * 1024),\n            unitsName: "MB",\n            watermark: 100\n        },\n\n        // frames per second\n        {\n            name: "FPS",\n            stats: ["frame.fps"],\n            watermark: 60\n        },\n\n        // delta time\n        {\n            name: "Frame",\n            stats: ["frame.ms"],\n            decimalPlaces: 1,\n            unitsName: "ms",\n            watermark: 33\n        }\n    ];\n\n    // create mini-stats system\n    const miniStats = new pcx.MiniStats(app, options);\n\n    // add directional lights to the scene\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional"\n    });\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 30, 0);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n    app.root.addChild(camera);\n    camera.setLocalPosition(20, 10, 10);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // helper function to create a primitive with shape type, position, scale\n    function createPrimitive(primitiveType: string, position: number | pc.Vec3, scale: number | pc.Vec3) {\n        // create material of random color\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(Math.random(), Math.random(), Math.random());\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent(\'model\', {\n            type: primitiveType\n        });\n        primitive.model.material = material;\n\n        // set position and scale\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n\n        return primitive;\n    }\n\n    // list of all created engine resources\n    const entities: any[] = [];\n    const vertexBuffers: any[] = [];\n    const textures: any[] = [];\n\n    // update function called every frame\n    let adding = true;\n    const step = 10, max = 2000;\n    let entity: pc.GraphNode, vertexBuffer: pc.VertexBuffer, texture: { destroy: () => void; };\n    app.on("update", function (dt: any) {\n\n        // execute some tasks multiple times per frame\n        for (let i = 0; i < step; i++) {\n\n            // allocating resources\n            if (adding) {\n\n                // add entity (they used shared geometry internally, and we create individual material for each)\n                const shape = Math.random() < 0.5 ? "box" : "sphere";\n                const position = new pc.Vec3(Math.random() * 10, Math.random() * 10, Math.random() * 10);\n                const scale = 0.5 + Math.random();\n                entity = createPrimitive(shape, position, new pc.Vec3(scale, scale, scale));\n                entities.push(entity);\n                app.root.addChild(entity);\n\n                // if allocation reached the max limit, switch to removing mode\n                if (entities.length >= max) {\n                    adding = false;\n                }\n\n                // add vertex buffer\n                const vertexCount = 500;\n                const data = new Float32Array(vertexCount * 16);\n                vertexBuffer = new pc.VertexBuffer(app.graphicsDevice, pc.VertexFormat.defaultInstancingFormat, vertexCount, pc.BUFFER_STATIC, data);\n                vertexBuffers.push(vertexBuffer);\n\n                // allocate texture\n                const texture = new pc.Texture(app.graphicsDevice, {\n                    width: 64,\n                    height: 64,\n                    format: pc.PIXELFORMAT_R8_G8_B8,\n                    mipmaps: false\n                });\n                textures.push(texture);\n\n                // ensure texture is uploaded (actual VRAM is allocated)\n                texture.lock();\n                texture.unlock();\n                // @ts-ignore engine-tsd\n                app.graphicsDevice.setTexture(texture, 0);\n\n            } else {    // de-allocating resources\n\n                if (entities.length > 0) {\n\n                    // destroy entities\n                    entity = entities[entities.length - 1];\n                    // @ts-ignore engine-tsd\n                    entity.destroy();\n                    entities.length--;\n\n                    // destroy vertex buffer\n                    vertexBuffer = vertexBuffers[vertexBuffers.length - 1];\n                    vertexBuffer.destroy();\n                    vertexBuffers.length--;\n\n                    // destroy texture\n                    texture = textures[textures.length - 1];\n                    texture.destroy();\n                    textures.length--;\n                } else {\n                    adding = true;\n                }\n            }\n        }\n    });\n}',javaScriptFunction:'function example(canvas, pcx) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // set up options for mini-stats, start with the default options\n    const options = pcx.MiniStats.getDefaultOptions();\n\n    // configure sizes\n    options.sizes = [\n        { width: 128, height: 16, spacing: 0, graphs: false },\n        { width: 256, height: 32, spacing: 2, graphs: true },\n        { width: 500, height: 64, spacing: 2, graphs: true },\n    ];\n\n    // when the application starts, use the largest size\n    options.startSizeIndex = 2;\n\n    // display additional counters\n    // Note: for most of these to report values, either debug or profiling engine build needs to be used.\n    options.stats = [\n        // frame update time in ms\n        {\n            name: "Update",\n            stats: ["frame.updateTime"],\n            decimalPlaces: 1,\n            unitsName: "ms",\n            watermark: 33,\n        },\n\n        // total number of draw calls\n        {\n            name: "DrawCalls",\n            stats: ["drawCalls.total"],\n            watermark: 2000,\n        },\n\n        // total number of triangles, in 1000s\n        {\n            name: "triCount",\n            stats: ["frame.triangles"],\n            decimalPlaces: 1,\n            multiplier: 1 / 1000,\n            unitsName: "k",\n            watermark: 500,\n        },\n\n        // number of materials used in a frame\n        {\n            name: "materials",\n            stats: ["frame.materials"],\n            watermark: 2000,\n        },\n\n        // frame time it took to do frustum culling\n        {\n            name: "cull",\n            stats: ["frame.cullTime"],\n            decimalPlaces: 1,\n            watermark: 1,\n            unitsName: "ms",\n        },\n\n        // used VRAM, displayed using 2 colors - red for textures, green for geometry\n        {\n            name: "VRAM",\n            stats: ["vram.tex", "vram.geom"],\n            decimalPlaces: 1,\n            multiplier: 1 / (1024 * 1024),\n            unitsName: "MB",\n            watermark: 100,\n        },\n\n        // frames per second\n        {\n            name: "FPS",\n            stats: ["frame.fps"],\n            watermark: 60,\n        },\n\n        // delta time\n        {\n            name: "Frame",\n            stats: ["frame.ms"],\n            decimalPlaces: 1,\n            unitsName: "ms",\n            watermark: 33,\n        },\n    ];\n\n    // create mini-stats system\n    const miniStats = new pcx.MiniStats(app, options);\n\n    // add directional lights to the scene\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n    });\n\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 30, 0);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    app.root.addChild(camera);\n    camera.setLocalPosition(20, 10, 10);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // helper function to create a primitive with shape type, position, scale\n    function createPrimitive(primitiveType, position, scale) {\n        // create material of random color\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(\n            Math.random(),\n            Math.random(),\n            Math.random()\n        );\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent("model", {\n            type: primitiveType,\n        });\n\n        primitive.model.material = material;\n\n        // set position and scale\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n\n        return primitive;\n    }\n\n    // list of all created engine resources\n    const entities = [];\n    const vertexBuffers = [];\n    const textures = [];\n\n    // update function called every frame\n    let adding = true;\n    const step = 10,\n        max = 2000;\n    let entity, vertexBuffer, texture;\n    app.on("update", function (dt) {\n        // execute some tasks multiple times per frame\n        for (let i = 0; i < step; i++) {\n            // allocating resources\n            if (adding) {\n                // add entity (they used shared geometry internally, and we create individual material for each)\n                const shape = Math.random() < 0.5 ? "box" : "sphere";\n                const position = new pc.Vec3(\n                    Math.random() * 10,\n                    Math.random() * 10,\n                    Math.random() * 10\n                );\n                const scale = 0.5 + Math.random();\n                entity = createPrimitive(\n                    shape,\n                    position,\n                    new pc.Vec3(scale, scale, scale)\n                );\n                entities.push(entity);\n                app.root.addChild(entity);\n\n                // if allocation reached the max limit, switch to removing mode\n                if (entities.length >= max) {\n                    adding = false;\n                }\n\n                // add vertex buffer\n                const vertexCount = 500;\n                const data = new Float32Array(vertexCount * 16);\n                vertexBuffer = new pc.VertexBuffer(\n                    app.graphicsDevice,\n                    pc.VertexFormat.defaultInstancingFormat,\n                    vertexCount,\n                    pc.BUFFER_STATIC,\n                    data\n                );\n                vertexBuffers.push(vertexBuffer);\n\n                // allocate texture\n                const texture = new pc.Texture(app.graphicsDevice, {\n                    width: 64,\n                    height: 64,\n                    format: pc.PIXELFORMAT_R8_G8_B8,\n                    mipmaps: false,\n                });\n\n                textures.push(texture);\n\n                // ensure texture is uploaded (actual VRAM is allocated)\n                texture.lock();\n                texture.unlock();\n                // @ts-ignore engine-tsd\n                app.graphicsDevice.setTexture(texture, 0);\n            } else {\n                // de-allocating resources\n\n                if (entities.length > 0) {\n                    // destroy entities\n                    entity = entities[entities.length - 1];\n                    // @ts-ignore engine-tsd\n                    entity.destroy();\n                    entities.length--;\n\n                    // destroy vertex buffer\n                    vertexBuffer = vertexBuffers[vertexBuffers.length - 1];\n                    vertexBuffer.destroy();\n                    vertexBuffers.length--;\n\n                    // destroy texture\n                    texture = textures[textures.length - 1];\n                    texture.destroy();\n                    textures.length--;\n                } else {\n                    adding = true;\n                }\n            }\n        }\n    });\n}\n',nameSlug:"mini-stats",categorySlug:"misc"},spineboy:{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: any): void {\n\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // create camera entity\n    const camera = new pc.Entity('camera');\n    camera.addComponent('camera', {\n        clearColor: new pc.Color(0.5, 0.6, 0.9)\n    });\n    app.root.addChild(camera);\n    camera.translateLocal(0, 7, 20);\n\n    const createSpineInstance = (position: pc.Vec3, scale: pc.Vec3, timeScale: number) => {\n\n        const spineEntity = new pc.Entity();\n        spineEntity.addComponent(\"spine\", {\n            atlasAsset: assets.atlas.id,\n            skeletonAsset: assets.skeleton.id,\n            textureAssets: [assets.texture.id]\n        });\n        spineEntity.setLocalPosition(position);\n        spineEntity.setLocalScale(scale);\n        app.root.addChild(spineEntity);\n\n        // play spine animation\n        // @ts-ignore\n        spineEntity.spine.state.setAnimation(0, \"portal\", true);\n\n        // @ts-ignore\n        spineEntity.spine.state.timeScale = timeScale;\n    };\n\n    // create spine entity 1\n    createSpineInstance(new pc.Vec3(2, 2, 0), new pc.Vec3(1, 1, 1), 1);\n\n    // create spine entity 2\n    createSpineInstance(new pc.Vec3(2, 10, 0), new pc.Vec3(-0.5, 0.5, 0.5), 0.5);\n}",javaScriptFunction:'function example(canvas, assets) {\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // create camera entity\n    const camera = new pc.Entity("camera");\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(0.5, 0.6, 0.9),\n    });\n\n    app.root.addChild(camera);\n    camera.translateLocal(0, 7, 20);\n\n    const createSpineInstance = (position, scale, timeScale) => {\n        const spineEntity = new pc.Entity();\n        spineEntity.addComponent("spine", {\n            atlasAsset: assets.atlas.id,\n            skeletonAsset: assets.skeleton.id,\n            textureAssets: [assets.texture.id],\n        });\n\n        spineEntity.setLocalPosition(position);\n        spineEntity.setLocalScale(scale);\n        app.root.addChild(spineEntity);\n\n        // play spine animation\n        // @ts-ignore\n        spineEntity.spine.state.setAnimation(0, "portal", true);\n\n        // @ts-ignore\n        spineEntity.spine.state.timeScale = timeScale;\n    };\n\n    // create spine entity 1\n    createSpineInstance(new pc.Vec3(2, 2, 0), new pc.Vec3(1, 1, 1), 1);\n\n    // create spine entity 2\n    createSpineInstance(\n        new pc.Vec3(2, 10, 0),\n        new pc.Vec3(-0.5, 0.5, 0.5),\n        0.5\n    );\n}\n',nameSlug:"spineboy",categorySlug:"misc"}},physics:{"compound-collision":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, wasmSupported: any, loadWasmModuleAsync: any): void {\n    if (wasmSupported()) {\n        loadWasmModuleAsync('Ammo', '/static/lib/ammo/ammo.wasm.js', '/static/lib/ammo/ammo.wasm.wasm', demo);\n    } else {\n        loadWasmModuleAsync('Ammo', '/static/lib/ammo/ammo.js', '', demo);\n    }\n\n    function demo() {\n        // Create the application and start the update loop\n        const app = new pc.Application(canvas, {});\n        app.start();\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        function createMaterial(color: pc.Color) {\n            const material = new pc.StandardMaterial();\n            material.diffuse = color;\n            material.update();\n\n            return material;\n        }\n\n        // Create a couple of materials for our objects\n        const red = createMaterial(new pc.Color(0.7, 0.3, 0.3));\n        const gray = createMaterial(new pc.Color(0.7, 0.7, 0.7));\n\n        // Define a scene hierarchy in JSON format. This is loaded/parsed in\n        // the parseScene function below\n        const scene = [\n            {\n                // The Chair entity has a collision component of type 'compound' and a\n                // rigidbody component. This means that any descendent entity with a\n                // collision component is added to a compound collision shape on the\n                // Chair entity. You can use compound collision shapes to define\n                // complex, rigid shapes.\n                name: 'Chair',\n                pos: [0, 1, 0],\n                components: [\n                    {\n                        type: 'collision',\n                        options: {\n                            type: 'compound'\n                        }\n                    }, {\n                        type: 'rigidbody',\n                        options: {\n                            type: 'dynamic',\n                            friction: 0.5,\n                            mass: 10,\n                            restitution: 0.5\n                        }\n                    }\n                ],\n                children: [\n                    {\n                        name: 'Seat',\n                        components: [\n                            {\n                                type: 'collision',\n                                options: {\n                                    type: 'box',\n                                    halfExtents: [0.25, 0.025, 0.25]\n                                }\n                            }\n                        ],\n                        children: [\n                            {\n                                name: 'Seat Model',\n                                scl: [0.5, 0.05, 0.5],\n                                components: [\n                                    {\n                                        type: 'render',\n                                        options: {\n                                            type: 'box',\n                                            material: gray\n                                        }\n                                    }\n                                ]\n                            }\n                        ]\n                    }, {\n                        name: 'Seat Back',\n                        pos: [0, 0.3, -0.2],\n                        components: [\n                            {\n                                type: 'collision',\n                                options: {\n                                    type: 'box',\n                                    halfExtents: [0.25, 0.2, 0.025]\n                                }\n                            }\n                        ],\n                        children: [\n                            {\n                                name: 'Seat Back Model',\n                                scl: [0.5, 0.4, 0.05],\n                                components: [\n                                    {\n                                        type: 'render',\n                                        options: {\n                                            type: 'box',\n                                            material: gray\n                                        }\n                                    }\n                                ]\n                            }\n                        ]\n                    }, {\n                        name: 'Leg 1',\n                        pos: [0.2, -0.25, 0.2],\n                        components: [\n                            {\n                                type: 'collision',\n                                options: {\n                                    type: 'cylinder',\n                                    height: 0.5,\n                                    radius: 0.025\n                                }\n                            }\n                        ],\n                        children: [\n                            {\n                                name: 'Leg 1 Model',\n                                scl: [0.05, 0.5, 0.05],\n                                components: [\n                                    {\n                                        type: 'render',\n                                        options: {\n                                            type: 'cylinder',\n                                            material: gray\n                                        }\n                                    }\n                                ]\n                            }\n                        ]\n                    }, {\n                        name: 'Leg 2',\n                        pos: [-0.2, -0.25, 0.2],\n                        components: [\n                            {\n                                type: 'collision',\n                                options: {\n                                    type: 'cylinder',\n                                    height: 0.5,\n                                    radius: 0.025\n                                }\n                            }\n                        ],\n                        children: [\n                            {\n                                name: 'Leg 2 Model',\n                                scl: [0.05, 0.5, 0.05],\n                                components: [\n                                    {\n                                        type: 'render',\n                                        options: {\n                                            type: 'cylinder',\n                                            material: gray\n                                        }\n                                    }\n                                ]\n                            }\n                        ]\n                    }, {\n                        name: 'Leg 3',\n                        pos: [0.2, 0, -0.2],\n                        components: [\n                            {\n                                type: 'collision',\n                                options: {\n                                    type: 'cylinder',\n                                    height: 1,\n                                    radius: 0.025\n                                }\n                            }\n                        ],\n                        children: [\n                            {\n                                name: 'Leg 3 Model',\n                                scl: [0.05, 1, 0.05],\n                                components: [\n                                    {\n                                        type: 'render',\n                                        options: {\n                                            type: 'cylinder',\n                                            material: gray\n                                        }\n                                    }\n                                ]\n                            }\n                        ]\n                    }, {\n                        name: 'Leg 4',\n                        pos: [-0.2, 0, -0.2],\n                        components: [\n                            {\n                                type: 'collision',\n                                options: {\n                                    type: 'cylinder',\n                                    height: 1,\n                                    radius: 0.025\n                                }\n                            }\n                        ],\n                        children: [\n                            {\n                                name: 'Leg 4 Model',\n                                scl: [0.05, 1, 0.05],\n                                components: [\n                                    {\n                                        type: 'render',\n                                        options: {\n                                            type: 'cylinder',\n                                            material: gray\n                                        }\n                                    }\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            }, {\n                name: 'Ground',\n                pos: [0, -0.5, 0],\n                components: [\n                    {\n                        type: 'collision',\n                        options: {\n                            type: 'box',\n                            halfExtents: [5, 0.5, 5]\n                        }\n                    }, {\n                        type: 'rigidbody',\n                        options: {\n                            type: 'static',\n                            restitution: 0.5\n                        }\n                    }\n                ],\n                children: [\n                    {\n                        name: 'Ground Model',\n                        scl: [10, 1, 10],\n                        components: [\n                            {\n                                type: 'render',\n                                options: {\n                                    type: 'box',\n                                    material: gray\n                                }\n                            }\n                        ]\n                    }\n                ]\n            }, {\n                name: 'Directional Light',\n                rot: [45, 130, 0],\n                components: [\n                    {\n                        type: 'light',\n                        options: {\n                            type: 'directional',\n                            castShadows: true,\n                            shadowDistance: 8,\n                            shadowBias: 0.1,\n                            intensity: 1,\n                            normalOffsetBias: 0.05\n                        }\n                    }\n                ]\n            }, {\n                name: 'Camera',\n                pos: [0, 4, 7],\n                rot: [-30, 0, 0],\n                components: [\n                    {\n                        type: 'camera',\n                        options: {\n                            color: [0.5, 0.5, 0.5]\n                        }\n                    }\n                ]\n            }\n        ];\n\n        // Convert an entity definition in the structure above to a pc.Entity object\n        function parseEntity(e: any) {\n            const entity = new pc.Entity(e.name);\n\n            if (e.pos) {\n                entity.setLocalPosition(e.pos[0], e.pos[1], e.pos[2]);\n            }\n            if (e.rot) {\n                entity.setLocalEulerAngles(e.rot[0], e.rot[1], e.rot[2]);\n            }\n            if (e.scl) {\n                entity.setLocalScale(e.scl[0], e.scl[1], e.scl[2]);\n            }\n\n            if (e.components) {\n                e.components.forEach(function (c: any) {\n                    entity.addComponent(c.type, c.options);\n                });\n            }\n\n            if (e.children) {\n                e.children.forEach(function (child: pc.Entity) {\n                    entity.addChild(parseEntity(child));\n                });\n            }\n\n            return entity;\n        }\n\n        // Parse the scene data above into entities and add them to the scene's root entity\n        function parseScene(s: any) {\n            s.forEach(function (e: any) {\n                app.root.addChild(parseEntity(e));\n            });\n        }\n\n        parseScene(scene);\n\n        let numChairs = 0;\n\n        // Clone the chair entity hierarchy and add it to the scene root\n        function spawnChair() {\n            const chair: pc.Entity = app.root.findByName('Chair') as pc.Entity;\n            const clone = chair.clone();\n            clone.setLocalPosition(Math.random() * 5 - 2.5, Math.random() * 2 + 1, Math.random() * 5 - 2.5);\n            app.root.addChild(clone);\n            numChairs++;\n        }\n\n        // Set an update function on the application's update event\n        let time = 0;\n        app.on(\"update\", function (dt) {\n            // Add a new chair every 250 ms\n            time += dt;\n            if (time > 0.25 && numChairs < 100) {\n                spawnChair();\n                time = 0;\n            }\n\n            // Show active bodies in red and frozen bodies in gray\n            app.root.findComponents('rigidbody').forEach(function (body: pc.RigidBodyComponent) {\n                body.entity.findComponents('render').forEach(function (render: pc.RenderComponent) {\n                    render.material = body.isActive() ? red : gray;\n                });\n            });\n        });\n    }\n}",javaScriptFunction:'function example(canvas, wasmSupported, loadWasmModuleAsync) {\n    if (wasmSupported()) {\n        loadWasmModuleAsync(\n            "Ammo",\n            "/static/lib/ammo/ammo.wasm.js",\n            "/static/lib/ammo/ammo.wasm.wasm",\n            demo\n        );\n    } else {\n        loadWasmModuleAsync("Ammo", "/static/lib/ammo/ammo.js", "", demo);\n    }\n\n    function demo() {\n        // Create the application and start the update loop\n        const app = new pc.Application(canvas, {});\n        app.start();\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        function createMaterial(color) {\n            const material = new pc.StandardMaterial();\n            material.diffuse = color;\n            material.update();\n\n            return material;\n        }\n\n        // Create a couple of materials for our objects\n        const red = createMaterial(new pc.Color(0.7, 0.3, 0.3));\n        const gray = createMaterial(new pc.Color(0.7, 0.7, 0.7));\n\n        // Define a scene hierarchy in JSON format. This is loaded/parsed in\n        // the parseScene function below\n        const scene = [\n            {\n                // The Chair entity has a collision component of type \'compound\' and a\n                // rigidbody component. This means that any descendent entity with a\n                // collision component is added to a compound collision shape on the\n                // Chair entity. You can use compound collision shapes to define\n                // complex, rigid shapes.\n                name: "Chair",\n                pos: [0, 1, 0],\n                components: [\n                    {\n                        type: "collision",\n                        options: {\n                            type: "compound",\n                        },\n                    },\n\n                    {\n                        type: "rigidbody",\n                        options: {\n                            type: "dynamic",\n                            friction: 0.5,\n                            mass: 10,\n                            restitution: 0.5,\n                        },\n                    },\n                ],\n\n                children: [\n                    {\n                        name: "Seat",\n                        components: [\n                            {\n                                type: "collision",\n                                options: {\n                                    type: "box",\n                                    halfExtents: [0.25, 0.025, 0.25],\n                                },\n                            },\n                        ],\n\n                        children: [\n                            {\n                                name: "Seat Model",\n                                scl: [0.5, 0.05, 0.5],\n                                components: [\n                                    {\n                                        type: "render",\n                                        options: {\n                                            type: "box",\n                                            material: gray,\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n\n                    {\n                        name: "Seat Back",\n                        pos: [0, 0.3, -0.2],\n                        components: [\n                            {\n                                type: "collision",\n                                options: {\n                                    type: "box",\n                                    halfExtents: [0.25, 0.2, 0.025],\n                                },\n                            },\n                        ],\n\n                        children: [\n                            {\n                                name: "Seat Back Model",\n                                scl: [0.5, 0.4, 0.05],\n                                components: [\n                                    {\n                                        type: "render",\n                                        options: {\n                                            type: "box",\n                                            material: gray,\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n\n                    {\n                        name: "Leg 1",\n                        pos: [0.2, -0.25, 0.2],\n                        components: [\n                            {\n                                type: "collision",\n                                options: {\n                                    type: "cylinder",\n                                    height: 0.5,\n                                    radius: 0.025,\n                                },\n                            },\n                        ],\n\n                        children: [\n                            {\n                                name: "Leg 1 Model",\n                                scl: [0.05, 0.5, 0.05],\n                                components: [\n                                    {\n                                        type: "render",\n                                        options: {\n                                            type: "cylinder",\n                                            material: gray,\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n\n                    {\n                        name: "Leg 2",\n                        pos: [-0.2, -0.25, 0.2],\n                        components: [\n                            {\n                                type: "collision",\n                                options: {\n                                    type: "cylinder",\n                                    height: 0.5,\n                                    radius: 0.025,\n                                },\n                            },\n                        ],\n\n                        children: [\n                            {\n                                name: "Leg 2 Model",\n                                scl: [0.05, 0.5, 0.05],\n                                components: [\n                                    {\n                                        type: "render",\n                                        options: {\n                                            type: "cylinder",\n                                            material: gray,\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n\n                    {\n                        name: "Leg 3",\n                        pos: [0.2, 0, -0.2],\n                        components: [\n                            {\n                                type: "collision",\n                                options: {\n                                    type: "cylinder",\n                                    height: 1,\n                                    radius: 0.025,\n                                },\n                            },\n                        ],\n\n                        children: [\n                            {\n                                name: "Leg 3 Model",\n                                scl: [0.05, 1, 0.05],\n                                components: [\n                                    {\n                                        type: "render",\n                                        options: {\n                                            type: "cylinder",\n                                            material: gray,\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n\n                    {\n                        name: "Leg 4",\n                        pos: [-0.2, 0, -0.2],\n                        components: [\n                            {\n                                type: "collision",\n                                options: {\n                                    type: "cylinder",\n                                    height: 1,\n                                    radius: 0.025,\n                                },\n                            },\n                        ],\n\n                        children: [\n                            {\n                                name: "Leg 4 Model",\n                                scl: [0.05, 1, 0.05],\n                                components: [\n                                    {\n                                        type: "render",\n                                        options: {\n                                            type: "cylinder",\n                                            material: gray,\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n                ],\n            },\n\n            {\n                name: "Ground",\n                pos: [0, -0.5, 0],\n                components: [\n                    {\n                        type: "collision",\n                        options: {\n                            type: "box",\n                            halfExtents: [5, 0.5, 5],\n                        },\n                    },\n\n                    {\n                        type: "rigidbody",\n                        options: {\n                            type: "static",\n                            restitution: 0.5,\n                        },\n                    },\n                ],\n\n                children: [\n                    {\n                        name: "Ground Model",\n                        scl: [10, 1, 10],\n                        components: [\n                            {\n                                type: "render",\n                                options: {\n                                    type: "box",\n                                    material: gray,\n                                },\n                            },\n                        ],\n                    },\n                ],\n            },\n\n            {\n                name: "Directional Light",\n                rot: [45, 130, 0],\n                components: [\n                    {\n                        type: "light",\n                        options: {\n                            type: "directional",\n                            castShadows: true,\n                            shadowDistance: 8,\n                            shadowBias: 0.1,\n                            intensity: 1,\n                            normalOffsetBias: 0.05,\n                        },\n                    },\n                ],\n            },\n\n            {\n                name: "Camera",\n                pos: [0, 4, 7],\n                rot: [-30, 0, 0],\n                components: [\n                    {\n                        type: "camera",\n                        options: {\n                            color: [0.5, 0.5, 0.5],\n                        },\n                    },\n                ],\n            },\n        ];\n\n        // Convert an entity definition in the structure above to a pc.Entity object\n        function parseEntity(e) {\n            const entity = new pc.Entity(e.name);\n\n            if (e.pos) {\n                entity.setLocalPosition(e.pos[0], e.pos[1], e.pos[2]);\n            }\n            if (e.rot) {\n                entity.setLocalEulerAngles(e.rot[0], e.rot[1], e.rot[2]);\n            }\n            if (e.scl) {\n                entity.setLocalScale(e.scl[0], e.scl[1], e.scl[2]);\n            }\n\n            if (e.components) {\n                e.components.forEach(function (c) {\n                    entity.addComponent(c.type, c.options);\n                });\n            }\n\n            if (e.children) {\n                e.children.forEach(function (child) {\n                    entity.addChild(parseEntity(child));\n                });\n            }\n\n            return entity;\n        }\n\n        // Parse the scene data above into entities and add them to the scene\'s root entity\n        function parseScene(s) {\n            s.forEach(function (e) {\n                app.root.addChild(parseEntity(e));\n            });\n        }\n\n        parseScene(scene);\n\n        let numChairs = 0;\n\n        // Clone the chair entity hierarchy and add it to the scene root\n        function spawnChair() {\n            const chair = app.root.findByName("Chair");\n            const clone = chair.clone();\n            clone.setLocalPosition(\n                Math.random() * 5 - 2.5,\n                Math.random() * 2 + 1,\n                Math.random() * 5 - 2.5\n            );\n            app.root.addChild(clone);\n            numChairs++;\n        }\n\n        // Set an update function on the application\'s update event\n        let time = 0;\n        app.on("update", function (dt) {\n            // Add a new chair every 250 ms\n            time += dt;\n            if (time > 0.25 && numChairs < 100) {\n                spawnChair();\n                time = 0;\n            }\n\n            // Show active bodies in red and frozen bodies in gray\n            app.root.findComponents("rigidbody").forEach(function (body) {\n                body.entity.findComponents("render").forEach(function (render) {\n                    render.material = body.isActive() ? red : gray;\n                });\n            });\n        });\n    }\n}\n',nameSlug:"compound-collision",categorySlug:"physics"},"falling-shapes":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { torus: pc.Asset }, wasmSupported: any, loadWasmModuleAsync: any): void {\n\n        // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    if (wasmSupported()) {\n        loadWasmModuleAsync(\'Ammo\', \'/static/lib/ammo/ammo.wasm.js\', \'/static/lib/ammo/ammo.wasm.wasm\', demo);\n    } else {\n        loadWasmModuleAsync(\'Ammo\', \'/static/lib/ammo/ammo.js\', \'\', demo);\n    }\n\n    function demo() {\n        app.start();\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        // Set the gravity for our rigid bodies\n        app.systems.rigidbody.gravity.set(0, -9.81, 0);\n\n        function createMaterial(color: pc.Color) {\n            const material = new pc.StandardMaterial();\n            material.diffuse = color;\n            // we need to call material.update when we change its properties\n            material.update();\n            return material;\n        }\n\n        // create a few materials for our objects\n        const red = createMaterial(new pc.Color(1, 0.3, 0.3));\n        const gray = createMaterial(new pc.Color(0.7, 0.7, 0.7));\n\n        // ***********    Create our floor   *******************\n\n        const floor = new pc.Entity();\n        floor.addComponent("render", {\n            type: "box",\n            material: gray\n        });\n\n        // scale it\n        floor.setLocalScale(10, 1, 10);\n\n        // add a rigidbody component so that other objects collide with it\n        floor.addComponent("rigidbody", {\n            type: "static",\n            restitution: 0.5\n        });\n\n        // add a collision component\n        floor.addComponent("collision", {\n            type: "box",\n            halfExtents: new pc.Vec3(5, 0.5, 5)\n        });\n\n        // add the floor to the hierarchy\n        app.root.addChild(floor);\n\n        // ***********    Create lights   *******************\n\n        // make our scene prettier by adding a directional light\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            type: "directional",\n            color: new pc.Color(1, 1, 1),\n            castShadows: true,\n            shadowBias: 0.2,\n            shadowDistance: 25,\n            normalOffsetBias: 0.05,\n            shadowResolution: 2048\n        });\n\n        // set the direction for our light\n        light.setLocalEulerAngles(45, 30, 0);\n\n        // Add the light to the hierarchy\n        app.root.addChild(light);\n\n        // ***********    Create camera    *******************\n\n        // Create an Entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent("camera", {\n            clearColor: new pc.Color(0.5, 0.5, 0.8),\n            farClip: 50\n        });\n\n        // add the camera to the hierarchy\n        app.root.addChild(camera);\n\n        // Move the camera a little further away\n        camera.translate(0, 10, 15);\n        camera.lookAt(0, 2, 0);\n\n        // helper function which creates a template for a collider\n        const createTemplate = function (type: any, collisionOptions: any, template?: any) {\n\n            // add a render component (visible mesh)\n            if (!template) {\n                template = new pc.Entity();\n                template.addComponent("render", {\n                    type: type\n                });\n            }\n\n            // ...a rigidbody component of type \'dynamic\' so that it is simulated by the physics engine...\n            template.addComponent("rigidbody", {\n                type: "dynamic",\n                mass: 50,\n                restitution: 0.5\n            });\n\n            // ... and a collision component\n            template.addComponent("collision", collisionOptions);\n\n            return template;\n        };\n\n        // ***********    Create templates    *******************\n\n        // Create a template for a falling box\n        const boxTemplate = createTemplate("box", {\n            type: "box",\n            halfExtents: new pc.Vec3(0.5, 0.5, 0.5)\n        });\n\n        // A sphere...\n        const sphereTemplate = createTemplate("sphere", {\n            type: "sphere",\n            radius: 0.5\n        });\n\n        // A capsule...\n        const capsuleTemplate = createTemplate("capsule", {\n            type: "capsule",\n            radius: 0.5,\n            height: 2\n        });\n\n        // A cylinder...\n        const cylinderTemplate = createTemplate("cylinder", {\n            type: "cylinder",\n            radius: 0.5,\n            height: 1\n        });\n\n        // A torus mesh...\n        const container = assets.torus.resource;\n        const meshTemplate = container.instantiateRenderEntity();\n\n        createTemplate(null, {\n            type: \'mesh\',\n            renderAsset: container.renders[0]\n        }, meshTemplate);\n\n        // add all the templates to an array so that\n        // we can randomly spawn them\n        const templates = [boxTemplate, sphereTemplate, capsuleTemplate, cylinderTemplate, meshTemplate];\n\n        // disable the templates because we don\'t want them to be visible\n        // we\'ll just use them to clone other Entities\n        templates.forEach(function (template) {\n            template.enabled = false;\n        });\n\n        // ***********    Update Function   *******************\n\n        // initialize variables for our update function\n        let timer = 0;\n        let count = 40;\n\n        // Set an update function on the application\'s update event\n        app.on("update", function (dt) {\n            // create a falling box every 0.2 seconds\n            if (count > 0) {\n                timer -= dt;\n                if (timer <= 0) {\n                    count--;\n                    timer = 0.2;\n\n                    // Clone a random template and position it above the floor\n                    const template = templates[Math.floor(Math.random() * templates.length)];\n                    const clone = template.clone();\n                    // enable the clone because the template is disabled\n                    clone.enabled = true;\n\n                    app.root.addChild(clone);\n\n                    clone.rigidbody.teleport(pc.math.random(-1, 1), 10, pc.math.random(-1, 1));\n                    clone.rigidbody.angularVelocity = new pc.Vec3(Math.random() * 10 - 5, Math.random() * 10 - 5, Math.random() * 10 - 5);\n                }\n            }\n\n            // Show active bodies in red and frozen bodies in gray\n            app.root.findComponents(\'rigidbody\').forEach(function (body: pc.RigidBodyComponent) {\n                body.entity.render.meshInstances[0].material = body.isActive() ? red : gray;\n            });\n        });\n    }\n}',javaScriptFunction:'function example(canvas, assets, wasmSupported, loadWasmModuleAsync) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    if (wasmSupported()) {\n        loadWasmModuleAsync(\n            "Ammo",\n            "/static/lib/ammo/ammo.wasm.js",\n            "/static/lib/ammo/ammo.wasm.wasm",\n            demo\n        );\n    } else {\n        loadWasmModuleAsync("Ammo", "/static/lib/ammo/ammo.js", "", demo);\n    }\n\n    function demo() {\n        app.start();\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        // Set the gravity for our rigid bodies\n        app.systems.rigidbody.gravity.set(0, -9.81, 0);\n\n        function createMaterial(color) {\n            const material = new pc.StandardMaterial();\n            material.diffuse = color;\n            // we need to call material.update when we change its properties\n            material.update();\n            return material;\n        }\n\n        // create a few materials for our objects\n        const red = createMaterial(new pc.Color(1, 0.3, 0.3));\n        const gray = createMaterial(new pc.Color(0.7, 0.7, 0.7));\n\n        // ***********    Create our floor   *******************\n\n        const floor = new pc.Entity();\n        floor.addComponent("render", {\n            type: "box",\n            material: gray,\n        });\n\n        // scale it\n        floor.setLocalScale(10, 1, 10);\n\n        // add a rigidbody component so that other objects collide with it\n        floor.addComponent("rigidbody", {\n            type: "static",\n            restitution: 0.5,\n        });\n\n        // add a collision component\n        floor.addComponent("collision", {\n            type: "box",\n            halfExtents: new pc.Vec3(5, 0.5, 5),\n        });\n\n        // add the floor to the hierarchy\n        app.root.addChild(floor);\n\n        // ***********    Create lights   *******************\n\n        // make our scene prettier by adding a directional light\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            type: "directional",\n            color: new pc.Color(1, 1, 1),\n            castShadows: true,\n            shadowBias: 0.2,\n            shadowDistance: 25,\n            normalOffsetBias: 0.05,\n            shadowResolution: 2048,\n        });\n\n        // set the direction for our light\n        light.setLocalEulerAngles(45, 30, 0);\n\n        // Add the light to the hierarchy\n        app.root.addChild(light);\n\n        // ***********    Create camera    *******************\n\n        // Create an Entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent("camera", {\n            clearColor: new pc.Color(0.5, 0.5, 0.8),\n            farClip: 50,\n        });\n\n        // add the camera to the hierarchy\n        app.root.addChild(camera);\n\n        // Move the camera a little further away\n        camera.translate(0, 10, 15);\n        camera.lookAt(0, 2, 0);\n\n        // helper function which creates a template for a collider\n        const createTemplate = function (type, collisionOptions, template) {\n            // add a render component (visible mesh)\n            if (!template) {\n                template = new pc.Entity();\n                template.addComponent("render", {\n                    type: type,\n                });\n            }\n\n            // ...a rigidbody component of type \'dynamic\' so that it is simulated by the physics engine...\n            template.addComponent("rigidbody", {\n                type: "dynamic",\n                mass: 50,\n                restitution: 0.5,\n            });\n\n            // ... and a collision component\n            template.addComponent("collision", collisionOptions);\n\n            return template;\n        };\n\n        // ***********    Create templates    *******************\n\n        // Create a template for a falling box\n        const boxTemplate = createTemplate("box", {\n            type: "box",\n            halfExtents: new pc.Vec3(0.5, 0.5, 0.5),\n        });\n\n        // A sphere...\n        const sphereTemplate = createTemplate("sphere", {\n            type: "sphere",\n            radius: 0.5,\n        });\n\n        // A capsule...\n        const capsuleTemplate = createTemplate("capsule", {\n            type: "capsule",\n            radius: 0.5,\n            height: 2,\n        });\n\n        // A cylinder...\n        const cylinderTemplate = createTemplate("cylinder", {\n            type: "cylinder",\n            radius: 0.5,\n            height: 1,\n        });\n\n        // A torus mesh...\n        const container = assets.torus.resource;\n        const meshTemplate = container.instantiateRenderEntity();\n\n        createTemplate(\n            null,\n            {\n                type: "mesh",\n                renderAsset: container.renders[0],\n            },\n            meshTemplate\n        );\n\n        // add all the templates to an array so that\n        // we can randomly spawn them\n        const templates = [\n            boxTemplate,\n            sphereTemplate,\n            capsuleTemplate,\n            cylinderTemplate,\n            meshTemplate,\n        ];\n\n        // disable the templates because we don\'t want them to be visible\n        // we\'ll just use them to clone other Entities\n        templates.forEach(function (template) {\n            template.enabled = false;\n        });\n\n        // ***********    Update Function   *******************\n\n        // initialize variables for our update function\n        let timer = 0;\n        let count = 40;\n\n        // Set an update function on the application\'s update event\n        app.on("update", function (dt) {\n            // create a falling box every 0.2 seconds\n            if (count > 0) {\n                timer -= dt;\n                if (timer <= 0) {\n                    count--;\n                    timer = 0.2;\n\n                    // Clone a random template and position it above the floor\n                    const template =\n                        templates[Math.floor(Math.random() * templates.length)];\n                    const clone = template.clone();\n                    // enable the clone because the template is disabled\n                    clone.enabled = true;\n\n                    app.root.addChild(clone);\n\n                    clone.rigidbody.teleport(\n                        pc.math.random(-1, 1),\n                        10,\n                        pc.math.random(-1, 1)\n                    );\n                    clone.rigidbody.angularVelocity = new pc.Vec3(\n                        Math.random() * 10 - 5,\n                        Math.random() * 10 - 5,\n                        Math.random() * 10 - 5\n                    );\n                }\n            }\n\n            // Show active bodies in red and frozen bodies in gray\n            app.root.findComponents("rigidbody").forEach(function (body) {\n                body.entity.render.meshInstances[0].material = body.isActive()\n                    ? red\n                    : gray;\n            });\n        });\n    }\n}\n',nameSlug:"falling-shapes",categorySlug:"physics"},raycast:{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: { font: pc.Asset }, wasmSupported: any, loadWasmModuleAsync: any): void {\n\n    if (wasmSupported()) {\n        loadWasmModuleAsync('Ammo', '/static/lib/ammo/ammo.wasm.js', '/static/lib/ammo/ammo.wasm.wasm', demo);\n    } else {\n        loadWasmModuleAsync('Ammo', '/static/lib/ammo/ammo.js', '', demo);\n    }\n\n    function demo() {\n        // Create the application and start the update loop\n        const app = new pc.Application(canvas, {});\n        app.start();\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        function createMaterial(color: pc.Color) {\n            const material = new pc.StandardMaterial();\n            material.diffuse = color;\n            material.update();\n\n            return material;\n        }\n\n        // Create a couple of materials\n        const red = createMaterial(new pc.Color(1, 0, 0));\n        const green = createMaterial(new pc.Color(0, 1, 0));\n\n        // Create light\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\"\n        });\n\n        app.root.addChild(light);\n        light.setEulerAngles(45, 30, 0);\n\n        // Create camera\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.5, 0.5, 0.8)\n        });\n\n        app.root.addChild(camera);\n        camera.setPosition(5, 0, 15);\n\n        function createPhysicalShape(type: string, material: pc.Material, x: number, y: number, z: number) {\n            const e = new pc.Entity();\n\n            // Have to set the position of the entity before adding the static rigidbody\n            // component because static bodies cannot be moved after creation\n            app.root.addChild(e);\n            e.setPosition(x, y, z);\n\n            e.addComponent(\"render\", {\n                type: type,\n                material: material\n            });\n            e.addComponent(\"rigidbody\", {\n                type: \"static\"\n            });\n            e.addComponent(\"collision\", {\n                type: type,\n                height: type === 'capsule' ? 2 : 1\n            });\n\n            return e;\n        }\n\n        // Create two rows of physical geometric shapes\n        const types = ['box', 'capsule', 'cone', 'cylinder', 'sphere'];\n        types.forEach(function (type, idx) {\n            createPhysicalShape(type, green, idx * 2 + 1, 2, 0);\n        });\n        types.forEach(function (type, idx) {\n            createPhysicalShape(type, green, idx * 2 + 1, -2, 0);\n        });\n\n        // Allocate some colors\n        const white = new pc.Color(1, 1, 1);\n        const blue = new pc.Color(0, 0, 1);\n\n        // Allocate some vectors\n        const start = new pc.Vec3();\n        const end = new pc.Vec3();\n        const temp = new pc.Vec3();\n\n        // Set an update function on the application's update event\n        let time = 0;\n        let y = 0;\n        app.on(\"update\", function (dt) {\n            time += dt;\n\n            // Reset all shapes to green\n            app.root.findComponents('render').forEach(function (render: pc.RenderComponent) {\n                render.material = green;\n            });\n\n            y = 2 + 1.2 * Math.sin(time);\n            start.set(0, y, 0);\n            end.set(10, y, 0);\n\n            // Render the ray used in the raycast\n            app.drawLine(start, end, white);\n\n            const result = app.systems.rigidbody.raycastFirst(start, end);\n            if (result) {\n                result.entity.render.material = red;\n\n                // Render the normal on the surface from the hit point\n                temp.copy(result.normal).mulScalar(0.3).add(result.point);\n                app.drawLine(result.point, temp, blue);\n            }\n\n            y = -2 + 1.2 * Math.sin(time);\n            start.set(0, y, 0);\n            end.set(10, y, 0);\n\n            // Render the ray used in the raycast\n            app.drawLine(start, end, white);\n\n            const results = app.systems.rigidbody.raycastAll(start, end);\n            results.forEach(function (result: pc.RaycastResult) {\n                result.entity.render.material = red;\n\n                // Render the normal on the surface from the hit point\n                temp.copy(result.normal).mulScalar(0.3).add(result.point);\n                app.drawLine(result.point, temp, blue);\n            }, this);\n        });\n\n        const createText = function (fontAsset: pc.Asset, message: string, x: number, y: number, z: number, rot: number) {\n            // Create a text element-based entity\n            const text = new pc.Entity();\n            text.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                fontAsset: fontAsset,\n                fontSize: 0.5,\n                pivot: [0, 0.5],\n                text: message,\n                type: pc.ELEMENTTYPE_TEXT\n            });\n            text.setLocalPosition(x, y, z);\n            text.setLocalEulerAngles(0, 0, rot);\n            app.root.addChild(text);\n        };\n\n        createText(assets.font, 'raycastFirst', 0.5, 3.75, 0, 0);\n        createText(assets.font, 'raycastAll', 0.5, -0.25, 0, 0);\n    }\n}",javaScriptFunction:'function example(canvas, assets, wasmSupported, loadWasmModuleAsync) {\n    if (wasmSupported()) {\n        loadWasmModuleAsync(\n            "Ammo",\n            "/static/lib/ammo/ammo.wasm.js",\n            "/static/lib/ammo/ammo.wasm.wasm",\n            demo\n        );\n    } else {\n        loadWasmModuleAsync("Ammo", "/static/lib/ammo/ammo.js", "", demo);\n    }\n\n    function demo() {\n        // Create the application and start the update loop\n        const app = new pc.Application(canvas, {});\n        app.start();\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        function createMaterial(color) {\n            const material = new pc.StandardMaterial();\n            material.diffuse = color;\n            material.update();\n\n            return material;\n        }\n\n        // Create a couple of materials\n        const red = createMaterial(new pc.Color(1, 0, 0));\n        const green = createMaterial(new pc.Color(0, 1, 0));\n\n        // Create light\n        const light = new pc.Entity();\n        light.addComponent("light", {\n            type: "directional",\n        });\n\n        app.root.addChild(light);\n        light.setEulerAngles(45, 30, 0);\n\n        // Create camera\n        const camera = new pc.Entity();\n        camera.addComponent("camera", {\n            clearColor: new pc.Color(0.5, 0.5, 0.8),\n        });\n\n        app.root.addChild(camera);\n        camera.setPosition(5, 0, 15);\n\n        function createPhysicalShape(type, material, x, y, z) {\n            const e = new pc.Entity();\n\n            // Have to set the position of the entity before adding the static rigidbody\n            // component because static bodies cannot be moved after creation\n            app.root.addChild(e);\n            e.setPosition(x, y, z);\n\n            e.addComponent("render", {\n                type: type,\n                material: material,\n            });\n\n            e.addComponent("rigidbody", {\n                type: "static",\n            });\n\n            e.addComponent("collision", {\n                type: type,\n                height: type === "capsule" ? 2 : 1,\n            });\n\n            return e;\n        }\n\n        // Create two rows of physical geometric shapes\n        const types = ["box", "capsule", "cone", "cylinder", "sphere"];\n        types.forEach(function (type, idx) {\n            createPhysicalShape(type, green, idx * 2 + 1, 2, 0);\n        });\n        types.forEach(function (type, idx) {\n            createPhysicalShape(type, green, idx * 2 + 1, -2, 0);\n        });\n\n        // Allocate some colors\n        const white = new pc.Color(1, 1, 1);\n        const blue = new pc.Color(0, 0, 1);\n\n        // Allocate some vectors\n        const start = new pc.Vec3();\n        const end = new pc.Vec3();\n        const temp = new pc.Vec3();\n\n        // Set an update function on the application\'s update event\n        let time = 0;\n        let y = 0;\n        app.on("update", function (dt) {\n            time += dt;\n\n            // Reset all shapes to green\n            app.root.findComponents("render").forEach(function (render) {\n                render.material = green;\n            });\n\n            y = 2 + 1.2 * Math.sin(time);\n            start.set(0, y, 0);\n            end.set(10, y, 0);\n\n            // Render the ray used in the raycast\n            app.drawLine(start, end, white);\n\n            const result = app.systems.rigidbody.raycastFirst(start, end);\n            if (result) {\n                result.entity.render.material = red;\n\n                // Render the normal on the surface from the hit point\n                temp.copy(result.normal).mulScalar(0.3).add(result.point);\n                app.drawLine(result.point, temp, blue);\n            }\n\n            y = -2 + 1.2 * Math.sin(time);\n            start.set(0, y, 0);\n            end.set(10, y, 0);\n\n            // Render the ray used in the raycast\n            app.drawLine(start, end, white);\n\n            const results = app.systems.rigidbody.raycastAll(start, end);\n            results.forEach(function (result) {\n                result.entity.render.material = red;\n\n                // Render the normal on the surface from the hit point\n                temp.copy(result.normal).mulScalar(0.3).add(result.point);\n                app.drawLine(result.point, temp, blue);\n            }, this);\n        });\n\n        const createText = function (fontAsset, message, x, y, z, rot) {\n            // Create a text element-based entity\n            const text = new pc.Entity();\n            text.addComponent("element", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                fontAsset: fontAsset,\n                fontSize: 0.5,\n                pivot: [0, 0.5],\n                text: message,\n                type: pc.ELEMENTTYPE_TEXT,\n            });\n\n            text.setLocalPosition(x, y, z);\n            text.setLocalEulerAngles(0, 0, rot);\n            app.root.addChild(text);\n        };\n\n        createText(assets.font, "raycastFirst", 0.5, 3.75, 0, 0);\n        createText(assets.font, "raycastAll", 0.5, -0.25, 0, 0);\n    }\n}\n',nameSlug:"raycast",categorySlug:"physics"},vehicle:{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: { script1: pc.Asset, script2: pc.Asset, script3: pc.Asset, script4: pc.Asset }, wasmSupported: any, loadWasmModuleAsync: any): void {\n\n    if (wasmSupported()) {\n        loadWasmModuleAsync('Ammo', '/static/lib/ammo/ammo.wasm.js', '/static/lib/ammo/ammo.wasm.wasm', demo);\n    } else {\n        loadWasmModuleAsync('Ammo', '/static/lib/ammo/ammo.js', '', demo);\n    }\n\n    function demo() {\n        // Create the application and start the update loop\n        const app = new pc.Application(canvas, {\n            keyboard: new pc.Keyboard(window)\n        });\n        app.start();\n\n        // Create a static ground shape for our car to drive on\n        const ground = new pc.Entity('Ground');\n        ground.addComponent('rigidbody', {\n            type: 'static'\n        });\n        ground.addComponent('collision', {\n            type: 'box',\n            halfExtents: new pc.Vec3(50, 0.5, 50)\n        });\n        ground.setLocalPosition(0, -0.5, 0);\n        app.root.addChild(ground);\n\n        // Create 4 wheels for our vehicle\n        const wheels: any = [];\n        [\n            { name: 'Front Left Wheel', pos: new pc.Vec3(0.8, 0.4, 1.2), front: true },\n            { name: 'Front Right Wheel', pos: new pc.Vec3(-0.8, 0.4, 1.2), front: true },\n            { name: 'Back Left Wheel', pos: new pc.Vec3(0.8, 0.4, -1.2), front: false },\n            { name: 'Back Right Wheel', pos: new pc.Vec3(-0.8, 0.4, -1.2), front: false }\n        ].forEach(function (wheelDef) {\n            // Create a wheel\n            const wheel = new pc.Entity(wheelDef.name);\n            wheel.addComponent('script');\n            wheel.script.create('vehicleWheel', {\n                attributes: {\n                    debugRender: true,\n                    isFront: wheelDef.front\n                }\n            });\n            wheel.setLocalPosition(wheelDef.pos);\n            wheels.push(wheel);\n        });\n\n        // Create a physical vehicle\n        const vehicle = new pc.Entity('Vehicle');\n        vehicle.addComponent('rigidbody', {\n            mass: 800,\n            type: 'dynamic'\n        });\n        vehicle.addComponent('collision', {\n            type: 'compound'\n        });\n        vehicle.addComponent('script');\n        vehicle.script.create('vehicle', {\n            attributes: {\n                wheels: wheels\n            }\n        });\n        vehicle.script.create('vehicleControls');\n        vehicle.script.create('actionPhysicsReset', {\n            attributes: {\n                event: 'reset'\n            }\n        });\n        vehicle.setLocalPosition(0, 2, 0);\n\n        // Create the car chassis, offset upwards in Y from the compound body\n        const chassis = new pc.Entity('Chassis');\n        chassis.addComponent('collision', {\n            type: 'box',\n            halfExtents: [0.6, 0.35, 1.65]\n        });\n        chassis.setLocalPosition(0, 0.65, 0);\n\n        // Create the car chassis, offset upwards in Y from the compound body\n        const cab = new pc.Entity('Cab');\n        cab.addComponent('collision', {\n            type: 'box',\n            halfExtents: [0.5, 0.2, 1]\n        });\n        cab.setLocalPosition(0, 1.2, -0.25);\n\n        // Add the vehicle to the hierarchy\n        wheels.forEach(function (wheel: pc.Entity) {\n            vehicle.addChild(wheel);\n        });\n        vehicle.addChild(chassis);\n        vehicle.addChild(cab);\n        app.root.addChild(vehicle);\n\n        // Build a wall of blocks for the car to smash through\n        for (let i = 0; i < 10; i++) {\n            for (let j = 0; j < 5; j++) {\n                const block = new pc.Entity('Block');\n                block.addComponent('rigidbody', {\n                    type: 'dynamic'\n                });\n                block.addComponent('collision', {\n                    type: 'box'\n                });\n                block.addComponent('script');\n                block.script.create('actionPhysicsReset', {\n                    attributes: {\n                        event: 'reset'\n                    }\n                });\n                block.setLocalPosition(i - 4.5, j + 0.5, -10);\n                app.root.addChild(block);\n            }\n        }\n\n        // Create a directional light source\n        const light = new pc.Entity('Directional Light');\n        light.addComponent(\"light\", {\n            type: \"directional\",\n            color: new pc.Color(1, 1, 1),\n            castShadows: true,\n            shadowBias: 0.2,\n            shadowDistance: 40,\n            normalOffsetBias: 0.05,\n            shadowResolution: 2048\n        });\n        light.setLocalEulerAngles(45, 30, 0);\n        app.root.addChild(light);\n\n        // Create a camera to render the scene\n        const camera = new pc.Entity('Camera');\n        camera.addComponent(\"camera\");\n        camera.addComponent('script');\n        camera.script.create('trackingCamera', {\n            attributes: {\n                target: vehicle\n            }\n        });\n        camera.translate(0, 10, 15);\n        camera.lookAt(0, 0, 0);\n        app.root.addChild(camera);\n\n        // Enable rendering and resetting of all rigid bodies in the scene\n        app.root.addComponent('script');\n        app.root.script.create('renderPhysics', {\n            attributes: {\n                drawShapes: true,\n                opacity: 1\n            }\n        });\n\n        app.keyboard.on(pc.EVENT_KEYDOWN, function (e) {\n            if (e.key === pc.KEY_R) {\n                app.fire('reset');\n            }\n        });\n    }\n}",javaScriptFunction:'function example(canvas, assets, wasmSupported, loadWasmModuleAsync) {\n    if (wasmSupported()) {\n        loadWasmModuleAsync(\n            "Ammo",\n            "/static/lib/ammo/ammo.wasm.js",\n            "/static/lib/ammo/ammo.wasm.wasm",\n            demo\n        );\n    } else {\n        loadWasmModuleAsync("Ammo", "/static/lib/ammo/ammo.js", "", demo);\n    }\n\n    function demo() {\n        // Create the application and start the update loop\n        const app = new pc.Application(canvas, {\n            keyboard: new pc.Keyboard(window),\n        });\n\n        app.start();\n\n        // Create a static ground shape for our car to drive on\n        const ground = new pc.Entity("Ground");\n        ground.addComponent("rigidbody", {\n            type: "static",\n        });\n\n        ground.addComponent("collision", {\n            type: "box",\n            halfExtents: new pc.Vec3(50, 0.5, 50),\n        });\n\n        ground.setLocalPosition(0, -0.5, 0);\n        app.root.addChild(ground);\n\n        // Create 4 wheels for our vehicle\n        const wheels = [];\n        [\n            {\n                name: "Front Left Wheel",\n                pos: new pc.Vec3(0.8, 0.4, 1.2),\n                front: true,\n            },\n            {\n                name: "Front Right Wheel",\n                pos: new pc.Vec3(-0.8, 0.4, 1.2),\n                front: true,\n            },\n            {\n                name: "Back Left Wheel",\n                pos: new pc.Vec3(0.8, 0.4, -1.2),\n                front: false,\n            },\n            {\n                name: "Back Right Wheel",\n                pos: new pc.Vec3(-0.8, 0.4, -1.2),\n                front: false,\n            },\n        ].forEach(function (wheelDef) {\n            // Create a wheel\n            const wheel = new pc.Entity(wheelDef.name);\n            wheel.addComponent("script");\n            wheel.script.create("vehicleWheel", {\n                attributes: {\n                    debugRender: true,\n                    isFront: wheelDef.front,\n                },\n            });\n\n            wheel.setLocalPosition(wheelDef.pos);\n            wheels.push(wheel);\n        });\n\n        // Create a physical vehicle\n        const vehicle = new pc.Entity("Vehicle");\n        vehicle.addComponent("rigidbody", {\n            mass: 800,\n            type: "dynamic",\n        });\n\n        vehicle.addComponent("collision", {\n            type: "compound",\n        });\n\n        vehicle.addComponent("script");\n        vehicle.script.create("vehicle", {\n            attributes: {\n                wheels: wheels,\n            },\n        });\n\n        vehicle.script.create("vehicleControls");\n        vehicle.script.create("actionPhysicsReset", {\n            attributes: {\n                event: "reset",\n            },\n        });\n\n        vehicle.setLocalPosition(0, 2, 0);\n\n        // Create the car chassis, offset upwards in Y from the compound body\n        const chassis = new pc.Entity("Chassis");\n        chassis.addComponent("collision", {\n            type: "box",\n            halfExtents: [0.6, 0.35, 1.65],\n        });\n\n        chassis.setLocalPosition(0, 0.65, 0);\n\n        // Create the car chassis, offset upwards in Y from the compound body\n        const cab = new pc.Entity("Cab");\n        cab.addComponent("collision", {\n            type: "box",\n            halfExtents: [0.5, 0.2, 1],\n        });\n\n        cab.setLocalPosition(0, 1.2, -0.25);\n\n        // Add the vehicle to the hierarchy\n        wheels.forEach(function (wheel) {\n            vehicle.addChild(wheel);\n        });\n        vehicle.addChild(chassis);\n        vehicle.addChild(cab);\n        app.root.addChild(vehicle);\n\n        // Build a wall of blocks for the car to smash through\n        for (let i = 0; i < 10; i++) {\n            for (let j = 0; j < 5; j++) {\n                const block = new pc.Entity("Block");\n                block.addComponent("rigidbody", {\n                    type: "dynamic",\n                });\n\n                block.addComponent("collision", {\n                    type: "box",\n                });\n\n                block.addComponent("script");\n                block.script.create("actionPhysicsReset", {\n                    attributes: {\n                        event: "reset",\n                    },\n                });\n\n                block.setLocalPosition(i - 4.5, j + 0.5, -10);\n                app.root.addChild(block);\n            }\n        }\n\n        // Create a directional light source\n        const light = new pc.Entity("Directional Light");\n        light.addComponent("light", {\n            type: "directional",\n            color: new pc.Color(1, 1, 1),\n            castShadows: true,\n            shadowBias: 0.2,\n            shadowDistance: 40,\n            normalOffsetBias: 0.05,\n            shadowResolution: 2048,\n        });\n\n        light.setLocalEulerAngles(45, 30, 0);\n        app.root.addChild(light);\n\n        // Create a camera to render the scene\n        const camera = new pc.Entity("Camera");\n        camera.addComponent("camera");\n        camera.addComponent("script");\n        camera.script.create("trackingCamera", {\n            attributes: {\n                target: vehicle,\n            },\n        });\n\n        camera.translate(0, 10, 15);\n        camera.lookAt(0, 0, 0);\n        app.root.addChild(camera);\n\n        // Enable rendering and resetting of all rigid bodies in the scene\n        app.root.addComponent("script");\n        app.root.script.create("renderPhysics", {\n            attributes: {\n                drawShapes: true,\n                opacity: 1,\n            },\n        });\n\n        app.keyboard.on(pc.EVENT_KEYDOWN, function (e) {\n            if (e.key === pc.KEY_R) {\n                app.fire("reset");\n            }\n        });\n    }\n}\n',nameSlug:"vehicle",categorySlug:"physics"}},sound:{positional:{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { model: pc.Asset, runAnim: pc.Asset, gravel: pc.Asset }): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(1, 0, 0)\n    });\n    camera.addComponent("audiolistener");\n    camera.rotateLocal(-30, 0, 0);\n    camera.translateLocal(0, 0, 5);\n    app.root.addChild(camera);\n\n    // Create an Entity for the ground\n    const material = new pc.StandardMaterial();\n    material.diffuse = pc.Color.GRAY;\n    material.update();\n\n    const ground = new pc.Entity();\n    ground.addComponent("render", {\n        type: "box",\n        material: material\n    });\n    ground.setLocalScale(50, 1, 50);\n    ground.setLocalPosition(0, -0.5, 0);\n    app.root.addChild(ground);\n\n    // Create an entity with a light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        castShadows: true,\n        intensity: 2,\n        shadowBias: 0.2,\n        shadowDistance: 16,\n        normalOffsetBias: 0.05,\n        shadowResolution: 2048\n    });\n    light.setLocalEulerAngles(45, 30, 0);\n    app.root.addChild(light);\n\n    app.start();\n\n    // Create walking dude\n    const entity = new pc.Entity();\n\n    // add sound component\n    entity.addComponent(\'sound\');\n\n    // add footsteps slot\n    entity.sound.addSlot(\'footsteps\', {\n        asset: assets.gravel.id,\n        pitch: 1.7,\n        loop: true,\n        autoPlay: true\n    });\n\n    // add model\n    entity.addComponent("model", {\n        type: "asset",\n        asset: assets.model,\n        castShadows: true\n    });\n\n    // add animation\n    entity.addComponent("animation", {\n        assets: [assets.runAnim],\n        speed: 0.8\n    });\n\n    // add entity in the hierarchy\n    app.root.addChild(entity);\n\n    let angle = 135;\n    const radius = 3;\n    const height = 0;// 1.1;\n    app.on("update", function (dt) {\n        angle += 30 * dt;\n        if (angle > 360) {\n            angle -= 360;\n        }\n        entity.setLocalPosition(radius * Math.sin(angle * pc.math.DEG_TO_RAD), height, radius * Math.cos(angle * pc.math.DEG_TO_RAD));\n        entity.setLocalEulerAngles(0, angle + 90, 0);\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(1, 0, 0),\n    });\n\n    camera.addComponent("audiolistener");\n    camera.rotateLocal(-30, 0, 0);\n    camera.translateLocal(0, 0, 5);\n    app.root.addChild(camera);\n\n    // Create an Entity for the ground\n    const material = new pc.StandardMaterial();\n    material.diffuse = pc.Color.GRAY;\n    material.update();\n\n    const ground = new pc.Entity();\n    ground.addComponent("render", {\n        type: "box",\n        material: material,\n    });\n\n    ground.setLocalScale(50, 1, 50);\n    ground.setLocalPosition(0, -0.5, 0);\n    app.root.addChild(ground);\n\n    // Create an entity with a light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        castShadows: true,\n        intensity: 2,\n        shadowBias: 0.2,\n        shadowDistance: 16,\n        normalOffsetBias: 0.05,\n        shadowResolution: 2048,\n    });\n\n    light.setLocalEulerAngles(45, 30, 0);\n    app.root.addChild(light);\n\n    app.start();\n\n    // Create walking dude\n    const entity = new pc.Entity();\n\n    // add sound component\n    entity.addComponent("sound");\n\n    // add footsteps slot\n    entity.sound.addSlot("footsteps", {\n        asset: assets.gravel.id,\n        pitch: 1.7,\n        loop: true,\n        autoPlay: true,\n    });\n\n    // add model\n    entity.addComponent("model", {\n        type: "asset",\n        asset: assets.model,\n        castShadows: true,\n    });\n\n    // add animation\n    entity.addComponent("animation", {\n        assets: [assets.runAnim],\n        speed: 0.8,\n    });\n\n    // add entity in the hierarchy\n    app.root.addChild(entity);\n\n    let angle = 135;\n    const radius = 3;\n    const height = 0; // 1.1;\n    app.on("update", function (dt) {\n        angle += 30 * dt;\n        if (angle > 360) {\n            angle -= 360;\n        }\n        entity.setLocalPosition(\n            radius * Math.sin(angle * pc.math.DEG_TO_RAD),\n            height,\n            radius * Math.cos(angle * pc.math.DEG_TO_RAD)\n        );\n        entity.setLocalEulerAngles(0, angle + 90, 0);\n    });\n}\n',nameSlug:"positional",categorySlug:"sound"}},"user-interface":{"button-basic":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { font: pc.Asset, red_button_atlas: pc.Asset }): void {\n\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n    });\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true\n    });\n    app.root.addChild(screen);\n\n    // Button\n    const button = new pc.Entity();\n    button.addComponent("button", {\n        imageEntity: button\n    });\n    button.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        height: 40,\n        pivot: [0.5, 0.5],\n        type: pc.ELEMENTTYPE_IMAGE,\n        width: 175,\n        useInput: true\n    });\n    screen.addChild(button);\n\n    // Create a label for the button\n    const label = new pc.Entity();\n    label.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        color: new pc.Color(0, 0, 0),\n        fontAsset: assets.font.id,\n        fontSize: 32,\n        height: 64,\n        pivot: [0.5, 0.5],\n        text: "CLICK ME",\n        type: pc.ELEMENTTYPE_TEXT,\n        width: 128,\n        wrapLines: true\n    });\n    button.addChild(label);\n\n    // Change the background color every time the button is clicked\n    button.button.on(\'click\', function (e) {\n        camera.camera.clearColor = new pc.Color(Math.random(), Math.random(), Math.random());\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n    });\n\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true,\n    });\n\n    app.root.addChild(screen);\n\n    // Button\n    const button = new pc.Entity();\n    button.addComponent("button", {\n        imageEntity: button,\n    });\n\n    button.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        height: 40,\n        pivot: [0.5, 0.5],\n        type: pc.ELEMENTTYPE_IMAGE,\n        width: 175,\n        useInput: true,\n    });\n\n    screen.addChild(button);\n\n    // Create a label for the button\n    const label = new pc.Entity();\n    label.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        color: new pc.Color(0, 0, 0),\n        fontAsset: assets.font.id,\n        fontSize: 32,\n        height: 64,\n        pivot: [0.5, 0.5],\n        text: "CLICK ME",\n        type: pc.ELEMENTTYPE_TEXT,\n        width: 128,\n        wrapLines: true,\n    });\n\n    button.addChild(label);\n\n    // Change the background color every time the button is clicked\n    button.button.on("click", function (e) {\n        camera.camera.clearColor = new pc.Color(\n            Math.random(),\n            Math.random(),\n            Math.random()\n        );\n    });\n}\n',nameSlug:"button-basic",categorySlug:"user-interface"},"button-sprite":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: { font: pc.Asset, red_button_atlas: pc.Asset }): void {\n\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n    app.start();\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n    });\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent(\"screen\", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true\n    });\n    app.root.addChild(screen);\n\n    // Create a simple button\n    const button = new pc.Entity();\n    button.addComponent(\"button\", {\n        active: true,\n        imageEntity: button,\n        transitionMode: pc.BUTTON_TRANSITION_MODE_SPRITE_CHANGE\n    });\n    button.addComponent(\"element\", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        height: 64,\n        pivot: [0.5, 0.5],\n        type: pc.ELEMENTTYPE_IMAGE,\n        width: 175,\n        useInput: true\n    });\n    screen.addChild(button);\n\n    // Create a label for the button\n    const label = new pc.Entity();\n    label.addComponent(\"element\", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        color: new pc.Color(1, 1, 1),\n        fontAsset: assets.font.id,\n        fontSize: 32,\n        height: 64,\n        opacity: 0.5,\n        pivot: [0.5, 0.5],\n        text: \"CLICK ME\",\n        type: pc.ELEMENTTYPE_TEXT,\n        width: 128,\n        wrapLines: true\n    });\n    button.addChild(label);\n\n    // Change the background color every time the button is clicked\n    button.button.on('click', function () {\n        const r = Math.random();\n        camera.camera.clearColor = new pc.Color(r, r, r);\n    });\n\n    // Move the button's label with the animation of the sprite\n    button.button.on('pressedstart', function () {\n        label.translateLocal(0, -4, 0);\n    });\n    button.button.on('pressedend', function () {\n        label.translateLocal(0, 4, 0);\n    });\n\n    // Apply the font to the text element\n    const texture = assets.red_button_atlas.resource;\n    texture.addressU = pc.ADDRESS_CLAMP_TO_EDGE;\n    texture.addressV = pc.ADDRESS_CLAMP_TO_EDGE;\n    texture.minFilter = pc.FILTER_NEAREST;\n    texture.magFilter = pc.FILTER_NEAREST;\n\n    const atlas = new pc.TextureAtlas();\n    atlas.frames = {\n        \"0\": {\n            rect: new pc.Vec4(0, 147, 190, 49),\n            pivot: new pc.Vec2(0.5, 0.5),\n            border: new pc.Vec4(7, 11, 7, 7)\n        },\n        \"1\": {\n            rect: new pc.Vec4(0, 98, 190, 49),\n            pivot: new pc.Vec2(0.5, 0.5),\n            border: new pc.Vec4(7, 11, 7, 7)\n        },\n        \"2\": {\n            rect: new pc.Vec4(0, 49, 190, 49),\n            pivot: new pc.Vec2(0.5, 0.5),\n            border: new pc.Vec4(7, 11, 7, 7)\n        },\n        \"3\": {\n            rect: new pc.Vec4(0, 0, 190, 49),\n            pivot: new pc.Vec2(0.5, 0.5),\n            border: new pc.Vec4(7, 11, 7, 7)\n        }\n    };\n    atlas.texture = texture;\n\n    const createSpriteAsset = function (frame: string) {\n        const sprite = new pc.Sprite(app.graphicsDevice, {\n            atlas: atlas,\n            frameKeys: [frame],\n            pixelsPerUnit: 1,\n            renderMode: pc.SPRITE_RENDERMODE_SIMPLE\n        });\n\n        const spriteAsset = new pc.Asset('sprite', 'sprite', { url: '' });\n        spriteAsset.resource = sprite;\n        spriteAsset.loaded = true;\n        app.assets.add(spriteAsset);\n        return spriteAsset;\n    };\n\n    button.element.spriteAsset = createSpriteAsset('0').id;\n    button.button.hoverSpriteAsset = createSpriteAsset('1');\n    button.button.pressedSpriteAsset = createSpriteAsset('2');\n    button.button.inactiveSpriteAsset = createSpriteAsset('3');\n}",javaScriptFunction:'function example(canvas, assets) {\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    app.start();\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n    });\n\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true,\n    });\n\n    app.root.addChild(screen);\n\n    // Create a simple button\n    const button = new pc.Entity();\n    button.addComponent("button", {\n        active: true,\n        imageEntity: button,\n        transitionMode: pc.BUTTON_TRANSITION_MODE_SPRITE_CHANGE,\n    });\n\n    button.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        height: 64,\n        pivot: [0.5, 0.5],\n        type: pc.ELEMENTTYPE_IMAGE,\n        width: 175,\n        useInput: true,\n    });\n\n    screen.addChild(button);\n\n    // Create a label for the button\n    const label = new pc.Entity();\n    label.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        color: new pc.Color(1, 1, 1),\n        fontAsset: assets.font.id,\n        fontSize: 32,\n        height: 64,\n        opacity: 0.5,\n        pivot: [0.5, 0.5],\n        text: "CLICK ME",\n        type: pc.ELEMENTTYPE_TEXT,\n        width: 128,\n        wrapLines: true,\n    });\n\n    button.addChild(label);\n\n    // Change the background color every time the button is clicked\n    button.button.on("click", function () {\n        const r = Math.random();\n        camera.camera.clearColor = new pc.Color(r, r, r);\n    });\n\n    // Move the button\'s label with the animation of the sprite\n    button.button.on("pressedstart", function () {\n        label.translateLocal(0, -4, 0);\n    });\n    button.button.on("pressedend", function () {\n        label.translateLocal(0, 4, 0);\n    });\n\n    // Apply the font to the text element\n    const texture = assets.red_button_atlas.resource;\n    texture.addressU = pc.ADDRESS_CLAMP_TO_EDGE;\n    texture.addressV = pc.ADDRESS_CLAMP_TO_EDGE;\n    texture.minFilter = pc.FILTER_NEAREST;\n    texture.magFilter = pc.FILTER_NEAREST;\n\n    const atlas = new pc.TextureAtlas();\n    atlas.frames = {\n        "0": {\n            rect: new pc.Vec4(0, 147, 190, 49),\n            pivot: new pc.Vec2(0.5, 0.5),\n            border: new pc.Vec4(7, 11, 7, 7),\n        },\n\n        "1": {\n            rect: new pc.Vec4(0, 98, 190, 49),\n            pivot: new pc.Vec2(0.5, 0.5),\n            border: new pc.Vec4(7, 11, 7, 7),\n        },\n\n        "2": {\n            rect: new pc.Vec4(0, 49, 190, 49),\n            pivot: new pc.Vec2(0.5, 0.5),\n            border: new pc.Vec4(7, 11, 7, 7),\n        },\n\n        "3": {\n            rect: new pc.Vec4(0, 0, 190, 49),\n            pivot: new pc.Vec2(0.5, 0.5),\n            border: new pc.Vec4(7, 11, 7, 7),\n        },\n    };\n\n    atlas.texture = texture;\n\n    const createSpriteAsset = function (frame) {\n        const sprite = new pc.Sprite(app.graphicsDevice, {\n            atlas: atlas,\n            frameKeys: [frame],\n            pixelsPerUnit: 1,\n            renderMode: pc.SPRITE_RENDERMODE_SIMPLE,\n        });\n\n        const spriteAsset = new pc.Asset("sprite", "sprite", { url: "" });\n        spriteAsset.resource = sprite;\n        spriteAsset.loaded = true;\n        app.assets.add(spriteAsset);\n        return spriteAsset;\n    };\n\n    button.element.spriteAsset = createSpriteAsset("0").id;\n    button.button.hoverSpriteAsset = createSpriteAsset("1");\n    button.button.pressedSpriteAsset = createSpriteAsset("2");\n    button.button.inactiveSpriteAsset = createSpriteAsset("3");\n}\n',nameSlug:"button-sprite",categorySlug:"user-interface"},"custom-shader":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: any): void {\n\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n    });\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true\n    });\n    app.root.addChild(screen);\n\n    // Dynamically set the precision depending on device\n    const fragmentShader = "precision " + app.graphicsDevice.precision + " float;\\n" + assets[\'shader.frag\'].data;\n\n    // Create the shader from the vertex and fragment shaders\n    const shader = new pc.Shader(app.graphicsDevice, {\n        attributes: {\n            vertex_position: pc.SEMANTIC_POSITION,\n            vertex_texCoord0: pc.SEMANTIC_TEXCOORD0\n        },\n        vshader: assets[\'shader.vert\'].data,\n        fshader: fragmentShader\n    });\n    // Create a new material with the new shader and additive alpha blending\n    const material = new pc.Material();\n    material.shader = shader;\n    material.blendType = pc.BLEND_ADDITIVEALPHA;\n    material.depthWrite = true;\n    material.setParameter("uDiffuseMap", assets.playcanvas.resource);\n    material.update();\n\n    // Create the UI image element with the custom material\n    const entity = new pc.Entity();\n    entity.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        width: 350,\n        height: 350,\n        type: pc.ELEMENTTYPE_IMAGE\n    });\n    entity.element.material = material;\n    screen.addChild(entity);\n\n    // update the material\'s \'amount\' parameter to animate the inverse effect\n    let time = 0;\n    app.on(\'update\', (dt) => {\n        time += dt;\n        // animate the amount as a sine wave varying from 0 to 1\n        material.setParameter("amount", (Math.sin(time * 4) + 1) * 0.5);\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n    });\n\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true,\n    });\n\n    app.root.addChild(screen);\n\n    // Dynamically set the precision depending on device\n    const fragmentShader =\n        "precision " +\n        app.graphicsDevice.precision +\n        " float;\\n" +\n        assets["shader.frag"].data;\n\n    // Create the shader from the vertex and fragment shaders\n    const shader = new pc.Shader(app.graphicsDevice, {\n        attributes: {\n            vertex_position: pc.SEMANTIC_POSITION,\n            vertex_texCoord0: pc.SEMANTIC_TEXCOORD0,\n        },\n\n        vshader: assets["shader.vert"].data,\n        fshader: fragmentShader,\n    });\n\n    // Create a new material with the new shader and additive alpha blending\n    const material = new pc.Material();\n    material.shader = shader;\n    material.blendType = pc.BLEND_ADDITIVEALPHA;\n    material.depthWrite = true;\n    material.setParameter("uDiffuseMap", assets.playcanvas.resource);\n    material.update();\n\n    // Create the UI image element with the custom material\n    const entity = new pc.Entity();\n    entity.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        width: 350,\n        height: 350,\n        type: pc.ELEMENTTYPE_IMAGE,\n    });\n\n    entity.element.material = material;\n    screen.addChild(entity);\n\n    // update the material\'s \'amount\' parameter to animate the inverse effect\n    let time = 0;\n    app.on("update", (dt) => {\n        time += dt;\n        // animate the amount as a sine wave varying from 0 to 1\n        material.setParameter("amount", (Math.sin(time * 4) + 1) * 0.5);\n    });\n}\n',nameSlug:"custom-shader",categorySlug:"user-interface"},"layout-group":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { font: pc.Asset }): void {\n\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n    });\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true\n    });\n    app.root.addChild(screen);\n\n    // Create Layout Group Entity\n    const group = new pc.Entity();\n    group.addComponent("element", {\n        // a Layout Group needs a \'group\' element component\n        type: pc.ELEMENTTYPE_GROUP,\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        pivot: [0.5, 0.5],\n        // the element\'s width and height dictate the group\'s bounds\n        width: 350,\n        height: 150\n    });\n    group.addComponent("layoutgroup", {\n        orientation: pc.ORIENTATION_HORIZONTAL,\n        spacing: new pc.Vec2(10, 10),\n        // fit_both for width and height, making all child elements take the entire space\n        widthFitting: pc.FITTING_BOTH,\n        heightFitting: pc.FITTING_BOTH,\n        // wrap children\n        wrap: true\n    });\n    screen.addChild(group);\n\n    // create 15 children to show off the layout group\n    for (let i = 0; i < 15; ++i) {\n        // create a random-colored panel\n        const child = new pc.Entity();\n        child.addComponent("element", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            pivot: [0.5, 0.5],\n            color: new pc.Color(Math.random(), Math.random(), Math.random()),\n            type: pc.ELEMENTTYPE_IMAGE\n        });\n        child.addComponent("layoutchild", {\n            excludeFromLayout: false\n        });\n        group.addChild(child);\n\n        // add a text label\n        const childLabel = new pc.Entity();\n        childLabel.addComponent("element", {\n            // center-position and attach to the borders of parent\n            // meaning this text element will scale along with parent\n            anchor: [0, 0, 1, 1],\n            margin: [0, 0, 0, 0],\n            pivot: [0.5, 0.5],\n            color: new pc.Color(1, 1, 1),\n            fontAsset: assets.font.id,\n            text: `${i + 1}`,\n            type: pc.ELEMENTTYPE_TEXT,\n            // auto font size\n            autoWidth: false,\n            autoHeight: false,\n            autoFitWidth: true,\n            autoFitHeight: true\n        });\n        child.addChild(childLabel);\n    }\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n    });\n\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true,\n    });\n\n    app.root.addChild(screen);\n\n    // Create Layout Group Entity\n    const group = new pc.Entity();\n    group.addComponent("element", {\n        // a Layout Group needs a \'group\' element component\n        type: pc.ELEMENTTYPE_GROUP,\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        pivot: [0.5, 0.5],\n        // the element\'s width and height dictate the group\'s bounds\n        width: 350,\n        height: 150,\n    });\n\n    group.addComponent("layoutgroup", {\n        orientation: pc.ORIENTATION_HORIZONTAL,\n        spacing: new pc.Vec2(10, 10),\n        // fit_both for width and height, making all child elements take the entire space\n        widthFitting: pc.FITTING_BOTH,\n        heightFitting: pc.FITTING_BOTH,\n        // wrap children\n        wrap: true,\n    });\n\n    screen.addChild(group);\n\n    // create 15 children to show off the layout group\n    for (let i = 0; i < 15; ++i) {\n        // create a random-colored panel\n        const child = new pc.Entity();\n        child.addComponent("element", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            pivot: [0.5, 0.5],\n            color: new pc.Color(Math.random(), Math.random(), Math.random()),\n            type: pc.ELEMENTTYPE_IMAGE,\n        });\n\n        child.addComponent("layoutchild", {\n            excludeFromLayout: false,\n        });\n\n        group.addChild(child);\n\n        // add a text label\n        const childLabel = new pc.Entity();\n        childLabel.addComponent("element", {\n            // center-position and attach to the borders of parent\n            // meaning this text element will scale along with parent\n            anchor: [0, 0, 1, 1],\n            margin: [0, 0, 0, 0],\n            pivot: [0.5, 0.5],\n            color: new pc.Color(1, 1, 1),\n            fontAsset: assets.font.id,\n            text: `${i + 1}`,\n            type: pc.ELEMENTTYPE_TEXT,\n            // auto font size\n            autoWidth: false,\n            autoHeight: false,\n            autoFitWidth: true,\n            autoFitHeight: true,\n        });\n\n        child.addChild(childLabel);\n    }\n}\n',nameSlug:"layout-group",categorySlug:"user-interface"},"particle-system":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { font: pc.Asset, spark: pc.Asset }): void {\n\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n    });\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true\n    });\n    app.root.addChild(screen);\n\n    // Create a simple panel\n    const panel = new pc.Entity();\n    panel.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        color: new pc.Color(0.4, 0.4, 0.4),\n        height: 40,\n        pivot: [0.5, 0.5],\n        type: pc.ELEMENTTYPE_IMAGE,\n        width: 175,\n        useInput: true\n    });\n    screen.addChild(panel);\n\n    // Create a label for the panel\n    const label = new pc.Entity();\n    label.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        color: new pc.Color(1, 1, 0),\n        fontAsset: assets.font.id,\n        fontSize: 36,\n        height: 64,\n        pivot: [0.5, 0.5],\n        text: "LABEL",\n        type: pc.ELEMENTTYPE_TEXT,\n        width: 128,\n        wrapLines: true\n    });\n    panel.addChild(label);\n\n    // Create entity for particle system\n    const particles = new pc.Entity();\n\n    // insert sparks as a child of the panel, but before Label - that is the order for rendering\n    panel.insertChild(particles, 0);\n\n    // particles will render in UI layer\n    const UILayer = app.scene.layers.getLayerByName("UI");\n\n    // particle size\n    const scaleCurve = new pc.Curve(\n        [0, 0.03]\n    );\n\n    // color changes throughout lifetime\n    const colorCurve = new pc.CurveSet([\n        [0, 1, 0.25, 1, 0.375, 0.5, 0.5, 0],\n        [0, 0, 0.125, 0.25, 0.25, 0.5, 0.375, 0.75, 0.5, 1],\n        [0, 0, 1, 0]\n    ]);\n\n    // increasing gravity to get them to move\n    const worldVelocityCurve = new pc.CurveSet([\n        [0, 0],\n        [0, 0, 0.1, 0.1, 0.1, -0.1],\n        [0, 0]\n    ]);\n\n    // rotate sparks 360 degrees per second\n    const angleCurve = new pc.Curve(\n        [0, 360]\n    );\n\n    // when texture is loaded add particlesystem component to entity\n    particles.addComponent("particlesystem", {\n        numParticles: 100,\n        lifetime: 1,\n        rate: 0.01,\n\n        // make them follow the buttn in screen-space\n        localSpace: true,\n        screenSpace: true,\n\n        emitterShape: pc.EMITTERSHAPE_SPHERE,\n        emitterRadius: 100,\n\n        scaleGraph: scaleCurve,\n        rotationSpeedGraph: angleCurve,\n        colorGraph: colorCurve,\n        velocityGraph: worldVelocityCurve,\n\n        colorMap: assets.spark.resource,\n        layers: [UILayer.id]\n    });\n\n    // sort all screen elements\n    screen.screen.syncDrawOrder();\n\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt * 0.3;\n\n        // move buttons along the circular path\n        panel.setLocalPosition(300 * Math.sin(time), 300 * Math.cos(time), 0);\n    });\n\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n    });\n\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true,\n    });\n\n    app.root.addChild(screen);\n\n    // Create a simple panel\n    const panel = new pc.Entity();\n    panel.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        color: new pc.Color(0.4, 0.4, 0.4),\n        height: 40,\n        pivot: [0.5, 0.5],\n        type: pc.ELEMENTTYPE_IMAGE,\n        width: 175,\n        useInput: true,\n    });\n\n    screen.addChild(panel);\n\n    // Create a label for the panel\n    const label = new pc.Entity();\n    label.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        color: new pc.Color(1, 1, 0),\n        fontAsset: assets.font.id,\n        fontSize: 36,\n        height: 64,\n        pivot: [0.5, 0.5],\n        text: "LABEL",\n        type: pc.ELEMENTTYPE_TEXT,\n        width: 128,\n        wrapLines: true,\n    });\n\n    panel.addChild(label);\n\n    // Create entity for particle system\n    const particles = new pc.Entity();\n\n    // insert sparks as a child of the panel, but before Label - that is the order for rendering\n    panel.insertChild(particles, 0);\n\n    // particles will render in UI layer\n    const UILayer = app.scene.layers.getLayerByName("UI");\n\n    // particle size\n    const scaleCurve = new pc.Curve([0, 0.03]);\n\n    // color changes throughout lifetime\n    const colorCurve = new pc.CurveSet([\n        [0, 1, 0.25, 1, 0.375, 0.5, 0.5, 0],\n        [0, 0, 0.125, 0.25, 0.25, 0.5, 0.375, 0.75, 0.5, 1],\n        [0, 0, 1, 0],\n    ]);\n\n    // increasing gravity to get them to move\n    const worldVelocityCurve = new pc.CurveSet([\n        [0, 0],\n        [0, 0, 0.1, 0.1, 0.1, -0.1],\n        [0, 0],\n    ]);\n\n    // rotate sparks 360 degrees per second\n    const angleCurve = new pc.Curve([0, 360]);\n\n    // when texture is loaded add particlesystem component to entity\n    particles.addComponent("particlesystem", {\n        numParticles: 100,\n        lifetime: 1,\n        rate: 0.01,\n\n        // make them follow the buttn in screen-space\n        localSpace: true,\n        screenSpace: true,\n\n        emitterShape: pc.EMITTERSHAPE_SPHERE,\n        emitterRadius: 100,\n\n        scaleGraph: scaleCurve,\n        rotationSpeedGraph: angleCurve,\n        colorGraph: colorCurve,\n        velocityGraph: worldVelocityCurve,\n\n        colorMap: assets.spark.resource,\n        layers: [UILayer.id],\n    });\n\n    // sort all screen elements\n    screen.screen.syncDrawOrder();\n\n    let time = 0;\n    app.on("update", function (dt) {\n        time += dt * 0.3;\n\n        // move buttons along the circular path\n        panel.setLocalPosition(300 * Math.sin(time), 300 * Math.cos(time), 0);\n    });\n}\n',nameSlug:"particle-system",categorySlug:"user-interface"},"scroll-view":{typeScriptFunction:"function example(canvas: HTMLCanvasElement, assets: { font: pc.Asset }): void {\r\n\r\n    // Create the application with input and start the update loop\r\n    const app = new pc.Application(canvas, {\r\n        mouse: new pc.Mouse(document.body),\r\n        touch: new pc.TouchDevice(document.body),\r\n        elementInput: new pc.ElementInput(canvas)\r\n    });\r\n    app.start();\r\n\r\n    // Create a camera\r\n    const camera = new pc.Entity();\r\n    app.root.addChild(camera);\r\n\r\n    camera.addComponent(\"camera\", {\r\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\r\n    });\r\n\r\n    // Create a 2D screen\r\n    const screen = new pc.Entity();\r\n    app.root.addChild(screen);\r\n\r\n    screen.addComponent(\"screen\", {\r\n        screenSpace: true,\r\n        referenceResolution: new pc.Vec2(1280, 720),\r\n        scaleMode: pc.SCALEMODE_BLEND,\r\n        scaleBlend: 0.5\r\n    });\r\n\r\n    function createScrollbar(horizontal: boolean) {\r\n        const handle = new pc.Entity('Handle');\r\n        const handleOptions = {\r\n            type: pc.ELEMENTTYPE_IMAGE,\r\n            color: new pc.Color(1, 1, 1),\r\n            opacity: 1,\r\n            margin: new pc.Vec4(0, 0, 0, 0),\r\n            rect: new pc.Vec4(0, 0, 1, 1),\r\n            mask: false,\r\n            useInput: true\r\n        };\r\n        if (horizontal) {\r\n            // @ts-ignore engine-tsd\r\n            handleOptions.anchor = new pc.Vec4(0, 0, 0, 1);  // Split in Y\r\n            // @ts-ignore engine-tsd\r\n            handleOptions.pivot = new pc.Vec2(0, 0);         // Bottom left\r\n        } else {\r\n            // @ts-ignore engine-tsd\r\n            handleOptions.anchor = new pc.Vec4(0, 1, 1, 1);  // Split in X\r\n            // @ts-ignore engine-tsd\r\n            handleOptions.pivot = new pc.Vec2(1, 1);         // Top right\r\n        }\r\n        handle.addComponent('element', handleOptions);\r\n        handle.addComponent('button', {\r\n            active: true,\r\n            imageEntity: handle,\r\n            hitPadding: new pc.Vec4(0, 0, 0, 0),\r\n            transitionMode: pc.BUTTON_TRANSITION_MODE_TINT,\r\n            hoverTint: new pc.Color(1, 1, 1),\r\n            pressedTint: new pc.Color(1, 1, 1),\r\n            inactiveTint: new pc.Color(1, 1, 1),\r\n            fadeDuration: 0\r\n        });\r\n\r\n        const scrollbar = new pc.Entity(horizontal ? 'HorizontalScrollbar' : 'VerticalScrollbar');\r\n\r\n        scrollbar.addChild(handle);\r\n\r\n        const scrollbarOptions = {\r\n            type: pc.ELEMENTTYPE_IMAGE,\r\n            color: new pc.Color(0.5, 0.5, 0.5),\r\n            opacity: 1,\r\n            rect: new pc.Vec4(0, 0, 1, 1),\r\n            mask: false,\r\n            useInput: false\r\n        };\r\n\r\n        const scrollbarSize = 20;\r\n\r\n        if (horizontal) {\r\n            // @ts-ignore engine-tsd\r\n            scrollbarOptions.anchor = new pc.Vec4(0, 0, 1, 0);\r\n            // @ts-ignore engine-tsd\r\n            scrollbarOptions.pivot = new pc.Vec2(0, 0);\r\n            // @ts-ignore engine-tsd\r\n            scrollbarOptions.margin = new pc.Vec4(0, 0, scrollbarSize, -scrollbarSize);\r\n        } else {\r\n            // @ts-ignore engine-tsd\r\n            scrollbarOptions.anchor = new pc.Vec4(1, 0, 1, 1);\r\n            // @ts-ignore engine-tsd\r\n            scrollbarOptions.pivot = new pc.Vec2(1, 1);\r\n            // @ts-ignore engine-tsd\r\n            scrollbarOptions.margin = new pc.Vec4(-scrollbarSize, scrollbarSize, 0, 0);\r\n        }\r\n        scrollbar.addComponent('element', scrollbarOptions);\r\n        scrollbar.addComponent('scrollbar', {\r\n            orientation: horizontal ? pc.ORIENTATION_HORIZONTAL : pc.ORIENTATION_VERTICAL,\r\n            value: 0,\r\n            handleSize: 0.5,\r\n            handleEntity: handle\r\n        });\r\n\r\n        return scrollbar;\r\n    }\r\n\r\n    // Create some text content\r\n    const text = new pc.Entity(\"Text\");\r\n    text.addComponent(\"element\", {\r\n        alignment: new pc.Vec2(0, 0),\r\n        anchor: new pc.Vec4(0, 1, 0, 1),\r\n        autoHeight: true,\r\n        autoWidth: false,\r\n        fontAsset: assets.font.id,\r\n        fontSize: 32,\r\n        lineHeight: 36,\r\n        pivot: new pc.Vec2(0, 1),\r\n        text: \"This is a scroll view control. You can scroll the content by dragging the vertical \" +\r\n                \"or horizontal scroll bars, by dragging the content itself, by using the mouse wheel, or \" +\r\n                \"by using a trackpad. Notice the elastic bounce if you drag the content beyond the \" +\r\n                \"limits of the scroll view.\",\r\n        type: pc.ELEMENTTYPE_TEXT,\r\n        width: 600,\r\n        wrapLines: true\r\n    });\r\n\r\n    // Group to hold the content inside the scroll view's viewport\r\n    const content = new pc.Entity('Content');\r\n    content.addChild(text);\r\n\r\n    content.addComponent('element', {\r\n        anchor: new pc.Vec4(0, 1, 0, 1),\r\n        height: 400,\r\n        pivot: new pc.Vec2(0, 1),\r\n        type: pc.ELEMENTTYPE_GROUP,\r\n        useInput: true,\r\n        width: 600\r\n    });\r\n\r\n    // Scroll view viewport\r\n    const viewport = new pc.Entity('Viewport');\r\n    viewport.addChild(content);\r\n\r\n    viewport.addComponent('element', {\r\n        anchor: new pc.Vec4(0, 0, 1, 1),\r\n        color: new pc.Color(0.2, 0.2, 0.2),\r\n        margin: new pc.Vec4(0, 20, 20, 0),\r\n        mask: true,\r\n        opacity: 1,\r\n        pivot: new pc.Vec2(0, 1),\r\n        rect: new pc.Vec4(0, 0, 1, 1),\r\n        type: pc.ELEMENTTYPE_IMAGE,\r\n        useInput: false\r\n    });\r\n\r\n    const horizontalScrollbar = createScrollbar(true);\r\n    const verticalScrollbar = createScrollbar(false);\r\n\r\n    // Create a scroll view\r\n    const scrollview = new pc.Entity('ScrollView');\r\n    scrollview.addChild(viewport);\r\n    scrollview.addChild(horizontalScrollbar);\r\n    scrollview.addChild(verticalScrollbar);\r\n\r\n    // You must add the scrollview entity to the hierarchy BEFORE adding the scrollview component\r\n    screen.addChild(scrollview);\r\n\r\n    scrollview.addComponent('element', {\r\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\r\n        height: 200,\r\n        pivot: new pc.Vec2(0.5, 0.5),\r\n        type: pc.ELEMENTTYPE_GROUP,\r\n        useInput: false,\r\n        width: 400\r\n    });\r\n\r\n    scrollview.addComponent('scrollview', {\r\n        bounceAmount: 0.1,\r\n        contentEntity: content,\r\n        friction: 0.05,\r\n        useMouseWheel: true,\r\n        mouseWheelSensitivity: pc.Vec2.ONE,\r\n        horizontal: true,\r\n        horizontalScrollbarEntity: horizontalScrollbar,\r\n        horizontalScrollbarVisibility: pc.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED,\r\n        scrollMode: pc.SCROLL_MODE_BOUNCE,\r\n        vertical: true,\r\n        verticalScrollbarEntity: verticalScrollbar,\r\n        verticalScrollbarVisibility: pc.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED,\r\n        viewportEntity: viewport\r\n    });\r\n}",javaScriptFunction:'function example(canvas, assets) {\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    app.start();\n\n    // Create a camera\n    const camera = new pc.Entity();\n    app.root.addChild(camera);\n\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n    });\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    app.root.addChild(screen);\n\n    screen.addComponent("screen", {\n        screenSpace: true,\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleMode: pc.SCALEMODE_BLEND,\n        scaleBlend: 0.5,\n    });\n\n    function createScrollbar(horizontal) {\n        const handle = new pc.Entity("Handle");\n        const handleOptions = {\n            type: pc.ELEMENTTYPE_IMAGE,\n            color: new pc.Color(1, 1, 1),\n            opacity: 1,\n            margin: new pc.Vec4(0, 0, 0, 0),\n            rect: new pc.Vec4(0, 0, 1, 1),\n            mask: false,\n            useInput: true,\n        };\n\n        if (horizontal) {\n            // @ts-ignore engine-tsd\n            handleOptions.anchor = new pc.Vec4(0, 0, 0, 1); // Split in Y\n            // @ts-ignore engine-tsd\n            handleOptions.pivot = new pc.Vec2(0, 0); // Bottom left\n        } else {\n            // @ts-ignore engine-tsd\n            handleOptions.anchor = new pc.Vec4(0, 1, 1, 1); // Split in X\n            // @ts-ignore engine-tsd\n            handleOptions.pivot = new pc.Vec2(1, 1); // Top right\n        }\n        handle.addComponent("element", handleOptions);\n        handle.addComponent("button", {\n            active: true,\n            imageEntity: handle,\n            hitPadding: new pc.Vec4(0, 0, 0, 0),\n            transitionMode: pc.BUTTON_TRANSITION_MODE_TINT,\n            hoverTint: new pc.Color(1, 1, 1),\n            pressedTint: new pc.Color(1, 1, 1),\n            inactiveTint: new pc.Color(1, 1, 1),\n            fadeDuration: 0,\n        });\n\n        const scrollbar = new pc.Entity(\n            horizontal ? "HorizontalScrollbar" : "VerticalScrollbar"\n        );\n\n        scrollbar.addChild(handle);\n\n        const scrollbarOptions = {\n            type: pc.ELEMENTTYPE_IMAGE,\n            color: new pc.Color(0.5, 0.5, 0.5),\n            opacity: 1,\n            rect: new pc.Vec4(0, 0, 1, 1),\n            mask: false,\n            useInput: false,\n        };\n\n        const scrollbarSize = 20;\n\n        if (horizontal) {\n            // @ts-ignore engine-tsd\n            scrollbarOptions.anchor = new pc.Vec4(0, 0, 1, 0);\n            // @ts-ignore engine-tsd\n            scrollbarOptions.pivot = new pc.Vec2(0, 0);\n            // @ts-ignore engine-tsd\n            scrollbarOptions.margin = new pc.Vec4(\n                0,\n                0,\n                scrollbarSize,\n                -scrollbarSize\n            );\n        } else {\n            // @ts-ignore engine-tsd\n            scrollbarOptions.anchor = new pc.Vec4(1, 0, 1, 1);\n            // @ts-ignore engine-tsd\n            scrollbarOptions.pivot = new pc.Vec2(1, 1);\n            // @ts-ignore engine-tsd\n            scrollbarOptions.margin = new pc.Vec4(\n                -scrollbarSize,\n                scrollbarSize,\n                0,\n                0\n            );\n        }\n        scrollbar.addComponent("element", scrollbarOptions);\n        scrollbar.addComponent("scrollbar", {\n            orientation: horizontal\n                ? pc.ORIENTATION_HORIZONTAL\n                : pc.ORIENTATION_VERTICAL,\n            value: 0,\n            handleSize: 0.5,\n            handleEntity: handle,\n        });\n\n        return scrollbar;\n    }\n\n    // Create some text content\n    const text = new pc.Entity("Text");\n    text.addComponent("element", {\n        alignment: new pc.Vec2(0, 0),\n        anchor: new pc.Vec4(0, 1, 0, 1),\n        autoHeight: true,\n        autoWidth: false,\n        fontAsset: assets.font.id,\n        fontSize: 32,\n        lineHeight: 36,\n        pivot: new pc.Vec2(0, 1),\n        text:\n            "This is a scroll view control. You can scroll the content by dragging the vertical " +\n            "or horizontal scroll bars, by dragging the content itself, by using the mouse wheel, or " +\n            "by using a trackpad. Notice the elastic bounce if you drag the content beyond the " +\n            "limits of the scroll view.",\n        type: pc.ELEMENTTYPE_TEXT,\n        width: 600,\n        wrapLines: true,\n    });\n\n    // Group to hold the content inside the scroll view\'s viewport\n    const content = new pc.Entity("Content");\n    content.addChild(text);\n\n    content.addComponent("element", {\n        anchor: new pc.Vec4(0, 1, 0, 1),\n        height: 400,\n        pivot: new pc.Vec2(0, 1),\n        type: pc.ELEMENTTYPE_GROUP,\n        useInput: true,\n        width: 600,\n    });\n\n    // Scroll view viewport\n    const viewport = new pc.Entity("Viewport");\n    viewport.addChild(content);\n\n    viewport.addComponent("element", {\n        anchor: new pc.Vec4(0, 0, 1, 1),\n        color: new pc.Color(0.2, 0.2, 0.2),\n        margin: new pc.Vec4(0, 20, 20, 0),\n        mask: true,\n        opacity: 1,\n        pivot: new pc.Vec2(0, 1),\n        rect: new pc.Vec4(0, 0, 1, 1),\n        type: pc.ELEMENTTYPE_IMAGE,\n        useInput: false,\n    });\n\n    const horizontalScrollbar = createScrollbar(true);\n    const verticalScrollbar = createScrollbar(false);\n\n    // Create a scroll view\n    const scrollview = new pc.Entity("ScrollView");\n    scrollview.addChild(viewport);\n    scrollview.addChild(horizontalScrollbar);\n    scrollview.addChild(verticalScrollbar);\n\n    // You must add the scrollview entity to the hierarchy BEFORE adding the scrollview component\n    screen.addChild(scrollview);\n\n    scrollview.addComponent("element", {\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        height: 200,\n        pivot: new pc.Vec2(0.5, 0.5),\n        type: pc.ELEMENTTYPE_GROUP,\n        useInput: false,\n        width: 400,\n    });\n\n    scrollview.addComponent("scrollview", {\n        bounceAmount: 0.1,\n        contentEntity: content,\n        friction: 0.05,\n        useMouseWheel: true,\n        mouseWheelSensitivity: pc.Vec2.ONE,\n        horizontal: true,\n        horizontalScrollbarEntity: horizontalScrollbar,\n        horizontalScrollbarVisibility:\n            pc.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED,\n        scrollMode: pc.SCROLL_MODE_BOUNCE,\n        vertical: true,\n        verticalScrollbarEntity: verticalScrollbar,\n        verticalScrollbarVisibility: pc.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED,\n        viewportEntity: viewport,\n    });\n}\n',nameSlug:"scroll-view",categorySlug:"user-interface"},"text-auto-font-size":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { font: pc.Asset }): void {\n\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n    });\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true\n    });\n    app.root.addChild(screen);\n\n    // Create a container entity with an image component\n    const autoFontSizeContainer = new pc.Entity();\n    autoFontSizeContainer.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        width: 220,\n        height: 50,\n        color: new pc.Color(60 / 255, 60 / 255, 60 / 255),\n        type: pc.ELEMENTTYPE_IMAGE\n    });\n    // Create a text element with auto font size, and place it inside the container\n    const autoFontSizeText = new pc.Entity();\n    autoFontSizeText.addComponent("element", {\n        // place the text taking the entire parent space\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0, 0, 1, 1),\n        margin: new pc.Vec4(0, 0, 0, 0),\n        fontAsset: assets.font.id,\n        autoWidth: false,\n        autoHeight: false,\n        autoFitWidth: true,\n        autoFitHeight: true,\n        minFontSize: 10,\n        maxFontSize: 100,\n        text: "Auto font size!",\n        type: pc.ELEMENTTYPE_TEXT\n    });\n    screen.addChild(autoFontSizeContainer);\n    autoFontSizeContainer.addChild(autoFontSizeText);\n\n    // update the container\'s size to showcase the auto-sizing feature\n    let time = 0;\n    app.on(\'update\', (dt) => {\n        time += dt;\n        autoFontSizeContainer.element.width = 280 + (Math.sin(time) * 80);\n        autoFontSizeContainer.element.height = 60 + (Math.sin(time * 0.5) * 50);\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n    });\n\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true,\n    });\n\n    app.root.addChild(screen);\n\n    // Create a container entity with an image component\n    const autoFontSizeContainer = new pc.Entity();\n    autoFontSizeContainer.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        width: 220,\n        height: 50,\n        color: new pc.Color(60 / 255, 60 / 255, 60 / 255),\n        type: pc.ELEMENTTYPE_IMAGE,\n    });\n\n    // Create a text element with auto font size, and place it inside the container\n    const autoFontSizeText = new pc.Entity();\n    autoFontSizeText.addComponent("element", {\n        // place the text taking the entire parent space\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0, 0, 1, 1),\n        margin: new pc.Vec4(0, 0, 0, 0),\n        fontAsset: assets.font.id,\n        autoWidth: false,\n        autoHeight: false,\n        autoFitWidth: true,\n        autoFitHeight: true,\n        minFontSize: 10,\n        maxFontSize: 100,\n        text: "Auto font size!",\n        type: pc.ELEMENTTYPE_TEXT,\n    });\n\n    screen.addChild(autoFontSizeContainer);\n    autoFontSizeContainer.addChild(autoFontSizeText);\n\n    // update the container\'s size to showcase the auto-sizing feature\n    let time = 0;\n    app.on("update", (dt) => {\n        time += dt;\n        autoFontSizeContainer.element.width = 280 + Math.sin(time) * 80;\n        autoFontSizeContainer.element.height = 60 + Math.sin(time * 0.5) * 50;\n    });\n}\n',nameSlug:"text-auto-font-size",categorySlug:"user-interface"},"text-emojis":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { font: pc.Asset }): void {\n\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n    });\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true\n    });\n    app.root.addChild(screen);\n\n    // some sample text\n    const firstLineText = "PlayCanvas supports Emojis via CanvasFont!";\n    const flagsText = "Flags: 🇺🇸🇩🇪🇮🇪🇮🇹🏴‍☠️🇨🇦";\n    const complexText = "Complex emoji: 👨🏿3️⃣👁️‍🗨️";\n\n    // Create a canvas font asset\n    const size = 64;\n    const elSize = 32;\n\n    // @ts-ignore engine-tsd\n    const canvasFont = new pc.CanvasFont(app, {\n        color: new pc.Color(1, 1, 1), // white\n        fontName: "Arial",\n        fontSize: size,\n        width: 256,\n        height: 256\n    });\n\n    // The first texture update needs to be `createTextures()`. Follow-up calls need to be `updateTextures()`.\n    canvasFont.createTextures(firstLineText);\n    canvasFont.updateTextures(flagsText);\n    canvasFont.updateTextures(complexText);\n\n    // Create the text entities\n    function createText(y: number, text: string) {\n        const canvasElementEntity = new pc.Entity();\n        canvasElementEntity.setLocalPosition(0, y, 0);\n        canvasElementEntity.addComponent("element", {\n            pivot: new pc.Vec2(0.5, 0.5),\n            anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n            fontSize: elSize,\n            text: text,\n            type: pc.ELEMENTTYPE_TEXT\n        });\n        canvasElementEntity.element.font = canvasFont;\n        screen.addChild(canvasElementEntity);\n    }\n    createText(225, firstLineText);\n    createText(150, flagsText);\n    createText(100, complexText);\n\n\n    // Canvas Fonts Debug - you shouldn\'t do this in your actual project\n    const debugText = new pc.Entity();\n    debugText.setLocalPosition(0, -50, 0);\n    debugText.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        fontAsset: assets.font.id,\n        fontSize: elSize,\n        text: "The following are the CanvasFont\'s Texture Atlases,\\ncontaining all the rendered characters:",\n        type: pc.ELEMENTTYPE_TEXT\n    });\n    screen.addChild(debugText);\n\n    // Create Layout Group Entity\n    const group = new pc.Entity();\n    group.setLocalPosition(0, -150, 0);\n    group.addComponent("element", {\n        // a Layout Group needs a \'group\' element component\n        type: pc.ELEMENTTYPE_GROUP,\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        pivot: [0.5, 0.5],\n        // the element\'s width and height dictate the group\'s bounds\n        width: 300,\n        height: 100\n    });\n    group.addComponent("layoutgroup", {\n        orientation: pc.ORIENTATION_HORIZONTAL,\n        // fit_both for width and height, making all child elements take the entire space\n        widthFitting: pc.FITTING_BOTH,\n        heightFitting: pc.FITTING_BOTH,\n        // wrap children\n        wrap: true\n    });\n    screen.addChild(group);\n\n    // create 1 child per texture\n    for (let i = 0; i < canvasFont.textures.length; i++) {\n        const texture = canvasFont.textures[i];\n\n        // create a random-colored panel\n        const child = new pc.Entity();\n        child.addComponent("element", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            pivot: [0.5, 0.5],\n            texture: texture,\n            type: pc.ELEMENTTYPE_IMAGE\n        });\n        child.addComponent("layoutchild", {\n            excludeFromLayout: false\n        });\n        group.addChild(child);\n    }\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n    });\n\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true,\n    });\n\n    app.root.addChild(screen);\n\n    // some sample text\n    const firstLineText = "PlayCanvas supports Emojis via CanvasFont!";\n    const flagsText = "Flags: 🇺🇸🇩🇪🇮🇪🇮🇹🏴‍☠️🇨🇦";\n    const complexText = "Complex emoji: 👨🏿3️⃣👁️‍🗨️";\n\n    // Create a canvas font asset\n    const size = 64;\n    const elSize = 32;\n\n    // @ts-ignore engine-tsd\n    const canvasFont = new pc.CanvasFont(app, {\n        color: new pc.Color(1, 1, 1), // white\n        fontName: "Arial",\n        fontSize: size,\n        width: 256,\n        height: 256,\n    });\n\n    // The first texture update needs to be `createTextures()`. Follow-up calls need to be `updateTextures()`.\n    canvasFont.createTextures(firstLineText);\n    canvasFont.updateTextures(flagsText);\n    canvasFont.updateTextures(complexText);\n\n    // Create the text entities\n    function createText(y, text) {\n        const canvasElementEntity = new pc.Entity();\n        canvasElementEntity.setLocalPosition(0, y, 0);\n        canvasElementEntity.addComponent("element", {\n            pivot: new pc.Vec2(0.5, 0.5),\n            anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n            fontSize: elSize,\n            text: text,\n            type: pc.ELEMENTTYPE_TEXT,\n        });\n\n        canvasElementEntity.element.font = canvasFont;\n        screen.addChild(canvasElementEntity);\n    }\n    createText(225, firstLineText);\n    createText(150, flagsText);\n    createText(100, complexText);\n\n    // Canvas Fonts Debug - you shouldn\'t do this in your actual project\n    const debugText = new pc.Entity();\n    debugText.setLocalPosition(0, -50, 0);\n    debugText.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        fontAsset: assets.font.id,\n        fontSize: elSize,\n        text: "The following are the CanvasFont\'s Texture Atlases,\\ncontaining all the rendered characters:",\n        type: pc.ELEMENTTYPE_TEXT,\n    });\n\n    screen.addChild(debugText);\n\n    // Create Layout Group Entity\n    const group = new pc.Entity();\n    group.setLocalPosition(0, -150, 0);\n    group.addComponent("element", {\n        // a Layout Group needs a \'group\' element component\n        type: pc.ELEMENTTYPE_GROUP,\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        pivot: [0.5, 0.5],\n        // the element\'s width and height dictate the group\'s bounds\n        width: 300,\n        height: 100,\n    });\n\n    group.addComponent("layoutgroup", {\n        orientation: pc.ORIENTATION_HORIZONTAL,\n        // fit_both for width and height, making all child elements take the entire space\n        widthFitting: pc.FITTING_BOTH,\n        heightFitting: pc.FITTING_BOTH,\n        // wrap children\n        wrap: true,\n    });\n\n    screen.addChild(group);\n\n    // create 1 child per texture\n    for (let i = 0; i < canvasFont.textures.length; i++) {\n        const texture = canvasFont.textures[i];\n\n        // create a random-colored panel\n        const child = new pc.Entity();\n        child.addComponent("element", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            pivot: [0.5, 0.5],\n            texture: texture,\n            type: pc.ELEMENTTYPE_IMAGE,\n        });\n\n        child.addComponent("layoutchild", {\n            excludeFromLayout: false,\n        });\n\n        group.addChild(child);\n    }\n}\n',nameSlug:"text-emojis",categorySlug:"user-interface"},"text-localization":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { font: pc.Asset }): void {\r\n\r\n    // Create the application with input and start the update loop\r\n    const app = new pc.Application(canvas, {\r\n        mouse: new pc.Mouse(document.body),\r\n        touch: new pc.TouchDevice(document.body),\r\n        elementInput: new pc.ElementInput(canvas)\r\n    });\r\n    app.start();\r\n\r\n    app.i18n.addData({\r\n        header: {\r\n            version: 1\r\n        },\r\n        data: [{\r\n            info: {\r\n                locale: \'en-US\'\r\n            },\r\n            messages: {\r\n                "HELLO": "Hi"\r\n            }\r\n        }, {\r\n            info: {\r\n                locale: \'fr-FR\'\r\n            },\r\n            messages: {\r\n                "HELLO": "Salut"\r\n            }\r\n        }, {\r\n            info: {\r\n                locale: \'es-ES\'\r\n            },\r\n            messages: {\r\n                "HELLO": "Hola"\r\n            }\r\n        }, {\r\n            info: {\r\n                locale: \'pt-BR\'\r\n            },\r\n            messages: {\r\n                "HELLO": "Oi!"\r\n            }\r\n        }]\r\n    });\r\n\r\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\r\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\r\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\r\n\r\n    window.addEventListener("resize", function () {\r\n        app.resizeCanvas(canvas.width, canvas.height);\r\n    });\r\n\r\n    // Create a camera\r\n    const camera = new pc.Entity();\r\n    camera.addComponent("camera", {\r\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\r\n    });\r\n    app.root.addChild(camera);\r\n\r\n    // Create a 2D screen\r\n    const screen = new pc.Entity();\r\n    screen.addComponent("screen", {\r\n        referenceResolution: new pc.Vec2(1280, 720),\r\n        scaleBlend: 0.5,\r\n        scaleMode: pc.SCALEMODE_BLEND,\r\n        screenSpace: true\r\n    });\r\n    app.root.addChild(screen);\r\n\r\n    // Create a basic text element\r\n    const text = new pc.Entity();\r\n    text.addComponent("element", {\r\n        anchor: [0.5, 0.5, 0.5, 0.5],\r\n        autoWidth: false,\r\n        fontAsset: assets.font.id,\r\n        fontSize: 128,\r\n        pivot: [0.5, 0.5],\r\n        key: "HELLO",\r\n        type: pc.ELEMENTTYPE_TEXT,\r\n        width: 640\r\n    });\r\n    screen.addChild(text);\r\n\r\n    function createButton(labelText: string, x: number, y: number) {\r\n        // Create a simple button\r\n        const button = new pc.Entity();\r\n        button.addComponent("button", {\r\n            imageEntity: button\r\n        });\r\n        button.addComponent("element", {\r\n            anchor: [0.5, 0.5, 0.5, 0.5],\r\n            height: 40,\r\n            pivot: [0.5, 0.5],\r\n            type: pc.ELEMENTTYPE_IMAGE,\r\n            width: 128,\r\n            useInput: true\r\n        });\r\n\r\n        // Create a label for the button\r\n        const label = new pc.Entity();\r\n        label.addComponent("element", {\r\n            anchor: [0.5, 0.5, 0.5, 0.5],\r\n            color: new pc.Color(0, 0, 0),\r\n            fontAsset: assets.font.id,\r\n            fontSize: 32,\r\n            height: 64,\r\n            pivot: [0.5, 0.5],\r\n            text: labelText,\r\n            type: pc.ELEMENTTYPE_TEXT,\r\n            width: 128,\r\n            wrapLines: true\r\n        });\r\n        button.addChild(label);\r\n\r\n        // Change the locale to the button text\r\n        button.button.on(\'click\', function (e) {\r\n            app.i18n.locale = labelText;\r\n        });\r\n\r\n        button.setLocalPosition(x, y, 0);\r\n\r\n        return button;\r\n    }\r\n\r\n    screen.addChild(createButton("en-US", -225, -100));\r\n    screen.addChild(createButton("fr-FR", -75, -100));\r\n    screen.addChild(createButton("es-ES", 75, -100));\r\n    screen.addChild(createButton("pt-BR", 225, -100));\r\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    app.start();\n\n    app.i18n.addData({\n        header: {\n            version: 1,\n        },\n\n        data: [\n            {\n                info: {\n                    locale: "en-US",\n                },\n\n                messages: {\n                    HELLO: "Hi",\n                },\n            },\n\n            {\n                info: {\n                    locale: "fr-FR",\n                },\n\n                messages: {\n                    HELLO: "Salut",\n                },\n            },\n\n            {\n                info: {\n                    locale: "es-ES",\n                },\n\n                messages: {\n                    HELLO: "Hola",\n                },\n            },\n\n            {\n                info: {\n                    locale: "pt-BR",\n                },\n\n                messages: {\n                    HELLO: "Oi!",\n                },\n            },\n        ],\n    });\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n    });\n\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true,\n    });\n\n    app.root.addChild(screen);\n\n    // Create a basic text element\n    const text = new pc.Entity();\n    text.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        autoWidth: false,\n        fontAsset: assets.font.id,\n        fontSize: 128,\n        pivot: [0.5, 0.5],\n        key: "HELLO",\n        type: pc.ELEMENTTYPE_TEXT,\n        width: 640,\n    });\n\n    screen.addChild(text);\n\n    function createButton(labelText, x, y) {\n        // Create a simple button\n        const button = new pc.Entity();\n        button.addComponent("button", {\n            imageEntity: button,\n        });\n\n        button.addComponent("element", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            height: 40,\n            pivot: [0.5, 0.5],\n            type: pc.ELEMENTTYPE_IMAGE,\n            width: 128,\n            useInput: true,\n        });\n\n        // Create a label for the button\n        const label = new pc.Entity();\n        label.addComponent("element", {\n            anchor: [0.5, 0.5, 0.5, 0.5],\n            color: new pc.Color(0, 0, 0),\n            fontAsset: assets.font.id,\n            fontSize: 32,\n            height: 64,\n            pivot: [0.5, 0.5],\n            text: labelText,\n            type: pc.ELEMENTTYPE_TEXT,\n            width: 128,\n            wrapLines: true,\n        });\n\n        button.addChild(label);\n\n        // Change the locale to the button text\n        button.button.on("click", function (e) {\n            app.i18n.locale = labelText;\n        });\n\n        button.setLocalPosition(x, y, 0);\n\n        return button;\n    }\n\n    screen.addChild(createButton("en-US", -225, -100));\n    screen.addChild(createButton("fr-FR", -75, -100));\n    screen.addChild(createButton("es-ES", 75, -100));\n    screen.addChild(createButton("pt-BR", 225, -100));\n}\n',nameSlug:"text-localization",categorySlug:"user-interface"},"text-typewriter":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { font: pc.Asset }): void {\r\n\r\n    // Create the application with input and start the update loop\r\n    const app = new pc.Application(canvas, {\r\n        mouse: new pc.Mouse(document.body),\r\n        touch: new pc.TouchDevice(document.body),\r\n        elementInput: new pc.ElementInput(canvas)\r\n    });\r\n    app.start();\r\n\r\n    // Create a camera\r\n    const camera = new pc.Entity();\r\n    camera.addComponent("camera", {\r\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\r\n    });\r\n    app.root.addChild(camera);\r\n\r\n    // Create a 2D screen\r\n    const screen = new pc.Entity();\r\n    screen.addComponent("screen", {\r\n        referenceResolution: new pc.Vec2(1280, 720),\r\n        scaleBlend: 0.5,\r\n        scaleMode: pc.SCALEMODE_BLEND,\r\n        screenSpace: true\r\n    });\r\n    app.root.addChild(screen);\r\n\r\n    // Create a text element that wraps text over several lines\r\n    const loremIpsum = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.";\r\n    const text = new pc.Entity();\r\n    text.addComponent("element", {\r\n        anchor: [0.5, 0.5, 0.5, 0.5],\r\n        autoWidth: false,\r\n        fontAsset: assets.font.id,\r\n        fontSize: 32,\r\n        pivot: [0.5, 0.5],\r\n        text: loremIpsum,\r\n        type: pc.ELEMENTTYPE_TEXT,\r\n        width: 512,\r\n        wrapLines: true\r\n    });\r\n    screen.addChild(text);\r\n\r\n    // Start with no text printed\r\n    text.element.rangeStart = 0;\r\n    text.element.rangeEnd = 0;\r\n\r\n    // Render a new character every 75ms\r\n    setInterval(function () {\r\n        text.element.rangeEnd += 1;\r\n        if (text.element.rangeEnd >= loremIpsum.length) {\r\n            text.element.rangeEnd = 0;\r\n        }\r\n    }, 75);\r\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    app.start();\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n    });\n\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true,\n    });\n\n    app.root.addChild(screen);\n\n    // Create a text element that wraps text over several lines\n    const loremIpsum =\n        "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.";\n    const text = new pc.Entity();\n    text.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        autoWidth: false,\n        fontAsset: assets.font.id,\n        fontSize: 32,\n        pivot: [0.5, 0.5],\n        text: loremIpsum,\n        type: pc.ELEMENTTYPE_TEXT,\n        width: 512,\n        wrapLines: true,\n    });\n\n    screen.addChild(text);\n\n    // Start with no text printed\n    text.element.rangeStart = 0;\n    text.element.rangeEnd = 0;\n\n    // Render a new character every 75ms\n    setInterval(function () {\n        text.element.rangeEnd += 1;\n        if (text.element.rangeEnd >= loremIpsum.length) {\n            text.element.rangeEnd = 0;\n        }\n    }, 75);\n}\n',nameSlug:"text-typewriter",categorySlug:"user-interface"},text:{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { font: pc.Asset }): void {\n\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n    });\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true\n    });\n    app.root.addChild(screen);\n\n    // Basic Text\n    const textBasic = new pc.Entity();\n    textBasic.setLocalPosition(0, 200, 0);\n    textBasic.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        fontAsset: assets.font.id,\n        fontSize: 42,\n        text: "Basic Text",\n        type: pc.ELEMENTTYPE_TEXT\n    });\n    screen.addChild(textBasic);\n\n    // Markup Text with wrap\n    const textMarkup = new pc.Entity();\n    textMarkup.setLocalPosition(0, 50, 0);\n    textMarkup.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        fontAsset: assets.font.id,\n        fontSize: 32,\n        text: \'There are seven colors in the rainbow: [color="#ff0000"]red[/color], [color="#ffa500"]orange[/color], [color="#ffff00"]yellow[/color], [color="#00ff00"]green[/color], [color="#0000ff"]blue[/color], [color="#4b0082"]indigo[/color] and [color="#7f00ff"]violet[/color].\',\n        width: 500,\n        height: 100,\n        autoWidth: false,\n        autoHeight: false,\n        wrapLines: true,\n        enableMarkup: true,\n        type: pc.ELEMENTTYPE_TEXT\n    });\n    screen.addChild(textMarkup);\n\n    // Text with outline\n    const textOutline = new pc.Entity();\n    textOutline.setLocalPosition(0, -100, 0);\n    textOutline.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        fontAsset: assets.font.id,\n        fontSize: 62,\n        text: "Outline",\n        color: new pc.Color(0, 0, 0),\n        outlineColor: new pc.Color(1, 1, 1),\n        outlineThickness: 0.75,\n        type: pc.ELEMENTTYPE_TEXT\n    });\n    screen.addChild(textOutline);\n\n    // Text with drop shadow\n    const textDropShadow = new pc.Entity();\n    textDropShadow.setLocalPosition(0, -200, 0);\n    textDropShadow.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        fontAsset: assets.font.id,\n        fontSize: 62,\n        text: "Drop Shadow",\n        shadowColor: new pc.Color(1, 0, 0),\n        shadowOffset: new pc.Vec2(0.25, -0.25),\n        type: pc.ELEMENTTYPE_TEXT\n    });\n    screen.addChild(textDropShadow);\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // Create a camera\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n    });\n\n    app.root.addChild(camera);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        scaleBlend: 0.5,\n        scaleMode: pc.SCALEMODE_BLEND,\n        screenSpace: true,\n    });\n\n    app.root.addChild(screen);\n\n    // Basic Text\n    const textBasic = new pc.Entity();\n    textBasic.setLocalPosition(0, 200, 0);\n    textBasic.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        fontAsset: assets.font.id,\n        fontSize: 42,\n        text: "Basic Text",\n        type: pc.ELEMENTTYPE_TEXT,\n    });\n\n    screen.addChild(textBasic);\n\n    // Markup Text with wrap\n    const textMarkup = new pc.Entity();\n    textMarkup.setLocalPosition(0, 50, 0);\n    textMarkup.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        fontAsset: assets.font.id,\n        fontSize: 32,\n        text: \'There are seven colors in the rainbow: [color="#ff0000"]red[/color], [color="#ffa500"]orange[/color], [color="#ffff00"]yellow[/color], [color="#00ff00"]green[/color], [color="#0000ff"]blue[/color], [color="#4b0082"]indigo[/color] and [color="#7f00ff"]violet[/color].\',\n        width: 500,\n        height: 100,\n        autoWidth: false,\n        autoHeight: false,\n        wrapLines: true,\n        enableMarkup: true,\n        type: pc.ELEMENTTYPE_TEXT,\n    });\n\n    screen.addChild(textMarkup);\n\n    // Text with outline\n    const textOutline = new pc.Entity();\n    textOutline.setLocalPosition(0, -100, 0);\n    textOutline.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        fontAsset: assets.font.id,\n        fontSize: 62,\n        text: "Outline",\n        color: new pc.Color(0, 0, 0),\n        outlineColor: new pc.Color(1, 1, 1),\n        outlineThickness: 0.75,\n        type: pc.ELEMENTTYPE_TEXT,\n    });\n\n    screen.addChild(textOutline);\n\n    // Text with drop shadow\n    const textDropShadow = new pc.Entity();\n    textDropShadow.setLocalPosition(0, -200, 0);\n    textDropShadow.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        fontAsset: assets.font.id,\n        fontSize: 62,\n        text: "Drop Shadow",\n        shadowColor: new pc.Color(1, 0, 0),\n        shadowOffset: new pc.Vec2(0.25, -0.25),\n        type: pc.ELEMENTTYPE_TEXT,\n    });\n\n    screen.addChild(textDropShadow);\n}\n',nameSlug:"text",categorySlug:"user-interface"},"world-to-screen":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { checkboard: pc.Asset, font: pc.Asset }): void {\n\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n    app.start();\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n    });\n    camera.rotateLocal(-30, 0, 0);\n    camera.translateLocal(0, 0, 7);\n    app.root.addChild(camera);\n\n    // Create an Entity for the ground\n    const material = new pc.StandardMaterial();\n    material.diffuse = pc.Color.WHITE;\n    material.diffuseMap = assets.checkboard.resource;\n    material.diffuseMapTiling = new pc.Vec2(50, 50);\n    material.update();\n\n    const ground = new pc.Entity();\n    ground.addComponent("render", {\n        type: "box",\n        material: material\n    });\n    ground.setLocalScale(50, 1, 50);\n    ground.setLocalPosition(0, -0.5, 0);\n    app.root.addChild(ground);\n\n    // Create an entity with a light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        castShadows: true,\n        intensity: 1,\n        shadowBias: 0.2,\n        shadowDistance: 16,\n        normalOffsetBias: 0.05,\n        shadowResolution: 2048\n    });\n    light.setLocalEulerAngles(45, 30, 0);\n    app.root.addChild(light);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.setLocalScale(0.01, 0.01, 0.01);\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        screenSpace: true\n    });\n    app.root.addChild(screen);\n\n    /**\n     * Converts a coordinate in world space into a screen\'s space.\n     *\n     * @param {pc.Vec3} worldPosition - the Vec3 representing the world-space coordinate.\n     * @param {pc.CameraComponent} camera - the Camera.\n     * @param {pc.ScreenComponent} screen - the Screen\n     * @returns {pc.Vec3} a Vec3 of the input worldPosition relative to the camera and screen. The Z coordinate represents the depth,\n     * and negative numbers signal that the worldPosition is behind the camera.\n     */\n    function worldToScreenSpace(worldPosition: pc.Vec3, camera: pc.CameraComponent, screen: pc.ScreenComponent): pc.Vec3 {\n        const screenPos = camera.worldToScreen(worldPosition);\n\n        // take pixel ratio into account\n        const pixelRatio = app.graphicsDevice.maxPixelRatio;\n        screenPos.x *= pixelRatio;\n        screenPos.y *= pixelRatio;\n\n        // account for screen scaling\n        // @ts-ignore engine-tsd\n        const scale = screen.scale;\n\n        // invert the y position\n        screenPos.y = screen.resolution.y - screenPos.y;\n\n        // put that into a Vec3\n        return new pc.Vec3(screenPos.x / scale, screenPos.y / scale, screenPos.z / scale);\n    }\n\n    function createPlayer(id: number, startingAngle: number, speed: number, radius: number) {\n        // Create a capsule entity to represent a player in the 3d world\n        const entity = new pc.Entity();\n        entity.setLocalScale(new pc.Vec3(0.5, 0.5, 0.5));\n        entity.addComponent("render", {\n            type: "capsule"\n        });\n        app.root.addChild(entity);\n\n        // update the player position every frame with some mock logic\n        // normally, this would be taking inputs, running physics simulation, etc\n        let angle = startingAngle;\n        const height = 0.5;\n        app.on("update", function (dt) {\n            angle += dt * speed;\n            if (angle > 360) {\n                angle -= 360;\n            }\n            entity.setLocalPosition(radius * Math.sin(angle * pc.math.DEG_TO_RAD), height, radius * Math.cos(angle * pc.math.DEG_TO_RAD));\n            entity.setLocalEulerAngles(0, angle + 90, 0);\n        });\n\n        // Create a text element that will hover the player\'s head\n        const playerInfo = new pc.Entity();\n        playerInfo.addComponent("element", {\n            pivot: new pc.Vec2(0.5, 0),\n            anchor: new pc.Vec4(0, 0, 0, 0),\n            width: 150,\n            height: 50,\n            opacity: 0.05,\n            type: pc.ELEMENTTYPE_IMAGE\n        });\n        screen.addChild(playerInfo);\n\n        const name = new pc.Entity();\n        name.addComponent("element", {\n            pivot: new pc.Vec2(0.5, 0.5),\n            anchor: new pc.Vec4(0, 0.4, 1, 1),\n            margin: new pc.Vec4(0, 0, 0, 0),\n            fontAsset: assets.font.id,\n            fontSize: 20,\n            text: `Player ${id}`,\n            useInput: true,\n            type: pc.ELEMENTTYPE_TEXT\n        });\n        name.addComponent("button", {\n            imageEntity: name\n        });\n        name.button.on(\'click\', function (e) {\n            const color = new pc.Color(Math.random(), Math.random(), Math.random());\n            name.element.color = color;\n            entity.render.material.setParameter("material_diffuse", [color.r, color.g, color.b]);\n        });\n        playerInfo.addChild(name);\n\n        const healthBar = new pc.Entity();\n        healthBar.addComponent("element", {\n            pivot: new pc.Vec2(0.5, 0),\n            anchor: new pc.Vec4(0, 0, 1, 0.4),\n            margin: new pc.Vec4(0, 0, 0, 0),\n            color: new pc.Color(0.2, 0.6, 0.2, 1),\n            opacity: 1,\n            type: pc.ELEMENTTYPE_IMAGE\n        });\n        playerInfo.addChild(healthBar);\n\n        // update the player text\'s position to always hover the player\n        app.on("update", function () {\n            // get the desired world position\n            const worldPosition = entity.getPosition();\n            worldPosition.y += 0.6; // slightly above the player\'s head\n\n            // convert to screen position\n            const screenPosition = worldToScreenSpace(worldPosition, camera.camera, screen.screen);\n\n            if (screenPosition.z > 0) {\n                // if world position is in front of the camera, show it\n                playerInfo.enabled = true;\n\n                // set the UI position\n                playerInfo.setLocalPosition(screenPosition);\n            } else {\n                // if world position is actually *behind* the camera, hide the UI\n                playerInfo.enabled = false;\n            }\n        });\n    }\n\n    createPlayer(1, 135, 30, 1.5);\n    createPlayer(2, 65, -18, 1);\n    createPlayer(3, 0, 15, 2.5);\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    app.start();\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n    });\n\n    camera.rotateLocal(-30, 0, 0);\n    camera.translateLocal(0, 0, 7);\n    app.root.addChild(camera);\n\n    // Create an Entity for the ground\n    const material = new pc.StandardMaterial();\n    material.diffuse = pc.Color.WHITE;\n    material.diffuseMap = assets.checkboard.resource;\n    material.diffuseMapTiling = new pc.Vec2(50, 50);\n    material.update();\n\n    const ground = new pc.Entity();\n    ground.addComponent("render", {\n        type: "box",\n        material: material,\n    });\n\n    ground.setLocalScale(50, 1, 50);\n    ground.setLocalPosition(0, -0.5, 0);\n    app.root.addChild(ground);\n\n    // Create an entity with a light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        castShadows: true,\n        intensity: 1,\n        shadowBias: 0.2,\n        shadowDistance: 16,\n        normalOffsetBias: 0.05,\n        shadowResolution: 2048,\n    });\n\n    light.setLocalEulerAngles(45, 30, 0);\n    app.root.addChild(light);\n\n    // Create a 2D screen\n    const screen = new pc.Entity();\n    screen.setLocalScale(0.01, 0.01, 0.01);\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        screenSpace: true,\n    });\n\n    app.root.addChild(screen);\n\n    /**\n     * Converts a coordinate in world space into a screen\'s space.\n     *\n     * @param {pc.Vec3} worldPosition - the Vec3 representing the world-space coordinate.\n     * @param {pc.CameraComponent} camera - the Camera.\n     * @param {pc.ScreenComponent} screen - the Screen\n     * @returns {pc.Vec3} a Vec3 of the input worldPosition relative to the camera and screen. The Z coordinate represents the depth,\n     * and negative numbers signal that the worldPosition is behind the camera.\n     */\n    function worldToScreenSpace(worldPosition, camera, screen) {\n        const screenPos = camera.worldToScreen(worldPosition);\n\n        // take pixel ratio into account\n        const pixelRatio = app.graphicsDevice.maxPixelRatio;\n        screenPos.x *= pixelRatio;\n        screenPos.y *= pixelRatio;\n\n        // account for screen scaling\n        // @ts-ignore engine-tsd\n        const scale = screen.scale;\n\n        // invert the y position\n        screenPos.y = screen.resolution.y - screenPos.y;\n\n        // put that into a Vec3\n        return new pc.Vec3(\n            screenPos.x / scale,\n            screenPos.y / scale,\n            screenPos.z / scale\n        );\n    }\n\n    function createPlayer(id, startingAngle, speed, radius) {\n        // Create a capsule entity to represent a player in the 3d world\n        const entity = new pc.Entity();\n        entity.setLocalScale(new pc.Vec3(0.5, 0.5, 0.5));\n        entity.addComponent("render", {\n            type: "capsule",\n        });\n\n        app.root.addChild(entity);\n\n        // update the player position every frame with some mock logic\n        // normally, this would be taking inputs, running physics simulation, etc\n        let angle = startingAngle;\n        const height = 0.5;\n        app.on("update", function (dt) {\n            angle += dt * speed;\n            if (angle > 360) {\n                angle -= 360;\n            }\n            entity.setLocalPosition(\n                radius * Math.sin(angle * pc.math.DEG_TO_RAD),\n                height,\n                radius * Math.cos(angle * pc.math.DEG_TO_RAD)\n            );\n            entity.setLocalEulerAngles(0, angle + 90, 0);\n        });\n\n        // Create a text element that will hover the player\'s head\n        const playerInfo = new pc.Entity();\n        playerInfo.addComponent("element", {\n            pivot: new pc.Vec2(0.5, 0),\n            anchor: new pc.Vec4(0, 0, 0, 0),\n            width: 150,\n            height: 50,\n            opacity: 0.05,\n            type: pc.ELEMENTTYPE_IMAGE,\n        });\n\n        screen.addChild(playerInfo);\n\n        const name = new pc.Entity();\n        name.addComponent("element", {\n            pivot: new pc.Vec2(0.5, 0.5),\n            anchor: new pc.Vec4(0, 0.4, 1, 1),\n            margin: new pc.Vec4(0, 0, 0, 0),\n            fontAsset: assets.font.id,\n            fontSize: 20,\n            text: `Player ${id}`,\n            useInput: true,\n            type: pc.ELEMENTTYPE_TEXT,\n        });\n\n        name.addComponent("button", {\n            imageEntity: name,\n        });\n\n        name.button.on("click", function (e) {\n            const color = new pc.Color(\n                Math.random(),\n                Math.random(),\n                Math.random()\n            );\n            name.element.color = color;\n            entity.render.material.setParameter("material_diffuse", [\n                color.r,\n                color.g,\n                color.b,\n            ]);\n        });\n        playerInfo.addChild(name);\n\n        const healthBar = new pc.Entity();\n        healthBar.addComponent("element", {\n            pivot: new pc.Vec2(0.5, 0),\n            anchor: new pc.Vec4(0, 0, 1, 0.4),\n            margin: new pc.Vec4(0, 0, 0, 0),\n            color: new pc.Color(0.2, 0.6, 0.2, 1),\n            opacity: 1,\n            type: pc.ELEMENTTYPE_IMAGE,\n        });\n\n        playerInfo.addChild(healthBar);\n\n        // update the player text\'s position to always hover the player\n        app.on("update", function () {\n            // get the desired world position\n            const worldPosition = entity.getPosition();\n            worldPosition.y += 0.6; // slightly above the player\'s head\n\n            // convert to screen position\n            const screenPosition = worldToScreenSpace(\n                worldPosition,\n                camera.camera,\n                screen.screen\n            );\n\n            if (screenPosition.z > 0) {\n                // if world position is in front of the camera, show it\n                playerInfo.enabled = true;\n\n                // set the UI position\n                playerInfo.setLocalPosition(screenPosition);\n            } else {\n                // if world position is actually *behind* the camera, hide the UI\n                playerInfo.enabled = false;\n            }\n        });\n    }\n\n    createPlayer(1, 135, 30, 1.5);\n    createPlayer(2, 65, -18, 1);\n    createPlayer(3, 0, 15, 2.5);\n}\n',nameSlug:"world-to-screen",categorySlug:"user-interface"},"world-ui":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { checkboard: pc.Asset, font: pc.Asset, script: pc.Asset }): void {\n\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n    app.start();\n\n    // Create an Entity with a camera component and simple orbiter script\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n    });\n    camera.rotateLocal(-30, 0, 0);\n    camera.translateLocal(0, 0, 7);\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2 // Override default of 0 (no inertia)\n        }\n    });\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // Create an Entity for the ground\n    const material = new pc.StandardMaterial();\n    material.diffuse = pc.Color.WHITE;\n    material.diffuseMap = assets.checkboard.resource;\n    material.diffuseMapTiling = new pc.Vec2(50, 50);\n    material.update();\n\n    const ground = new pc.Entity();\n    ground.addComponent("render", {\n        type: "box",\n        material: material\n    });\n    ground.setLocalScale(50, 1, 50);\n    ground.setLocalPosition(0, -0.5, 0);\n    app.root.addChild(ground);\n\n    // Create an entity with a light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        castShadows: true,\n        intensity: 1,\n        shadowBias: 0.2,\n        shadowDistance: 16,\n        normalOffsetBias: 0.05,\n        shadowResolution: 2048\n    });\n    light.setLocalEulerAngles(45, 30, 0);\n    app.root.addChild(light);\n\n    // Create a 3D world screen, which is basically a `screen` with `screenSpace` set to false\n    const screen = new pc.Entity();\n    screen.setLocalScale(0.01, 0.01, 0.01);\n    screen.setPosition(0, 0.01, 0); // place UI slightly above the ground\n    screen.setLocalRotation(new pc.Quat().setFromEulerAngles(-90, 0, 0));\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        screenSpace: false\n    });\n    app.root.addChild(screen);\n\n    // Text\n    const text = new pc.Entity();\n    text.setLocalPosition(0, 25, 0);\n    text.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        fontAsset: assets.font.id,\n        fontSize: 18,\n        text: "this is a UI screen placed in the 3D world",\n        width: 200,\n        height: 100,\n        autoWidth: false,\n        autoHeight: false,\n        wrapLines: true,\n        enableMarkup: true,\n        type: pc.ELEMENTTYPE_TEXT\n    });\n    screen.addChild(text);\n\n    // Button\n    const button = new pc.Entity();\n    button.setLocalPosition(0, -25, 0);\n    button.addComponent("button", {\n        imageEntity: button\n    });\n    button.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        width: 100,\n        height: 25,\n        pivot: [0.5, 0.5],\n        type: pc.ELEMENTTYPE_IMAGE,\n        useInput: true\n    });\n    screen.addChild(button);\n\n    // Create a label for the button\n    const buttonText = new pc.Entity();\n    buttonText.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0, 0, 1, 1),\n        margin: new pc.Vec4(0, 0, 0, 0),\n        color: new pc.Color(0, 0, 0),\n        fontAsset: assets.font.id,\n        fontSize: 12,\n        text: "and this is a button",\n        type: pc.ELEMENTTYPE_TEXT,\n        wrapLines: true\n    });\n    button.addChild(buttonText);\n\n    // Change the background color every time the button is clicked\n    button.button.on(\'click\', function (e) {\n        camera.camera.clearColor = new pc.Color(Math.random(), Math.random(), Math.random());\n    });\n}',javaScriptFunction:'function example(canvas, assets) {\n    // Create the application with input and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    app.start();\n\n    // Create an Entity with a camera component and simple orbiter script\n    const camera = new pc.Entity();\n    camera.addComponent("camera", {\n        clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n    });\n\n    camera.rotateLocal(-30, 0, 0);\n    camera.translateLocal(0, 0, 7);\n    camera.addComponent("script");\n    camera.script.create("orbitCamera", {\n        attributes: {\n            inertiaFactor: 0.2, // Override default of 0 (no inertia)\n        },\n    });\n\n    camera.script.create("orbitCameraInputMouse");\n    camera.script.create("orbitCameraInputTouch");\n    app.root.addChild(camera);\n\n    // Create an Entity for the ground\n    const material = new pc.StandardMaterial();\n    material.diffuse = pc.Color.WHITE;\n    material.diffuseMap = assets.checkboard.resource;\n    material.diffuseMapTiling = new pc.Vec2(50, 50);\n    material.update();\n\n    const ground = new pc.Entity();\n    ground.addComponent("render", {\n        type: "box",\n        material: material,\n    });\n\n    ground.setLocalScale(50, 1, 50);\n    ground.setLocalPosition(0, -0.5, 0);\n    app.root.addChild(ground);\n\n    // Create an entity with a light component\n    const light = new pc.Entity();\n    light.addComponent("light", {\n        type: "directional",\n        color: new pc.Color(1, 1, 1),\n        castShadows: true,\n        intensity: 1,\n        shadowBias: 0.2,\n        shadowDistance: 16,\n        normalOffsetBias: 0.05,\n        shadowResolution: 2048,\n    });\n\n    light.setLocalEulerAngles(45, 30, 0);\n    app.root.addChild(light);\n\n    // Create a 3D world screen, which is basically a `screen` with `screenSpace` set to false\n    const screen = new pc.Entity();\n    screen.setLocalScale(0.01, 0.01, 0.01);\n    screen.setPosition(0, 0.01, 0); // place UI slightly above the ground\n    screen.setLocalRotation(new pc.Quat().setFromEulerAngles(-90, 0, 0));\n    screen.addComponent("screen", {\n        referenceResolution: new pc.Vec2(1280, 720),\n        screenSpace: false,\n    });\n\n    app.root.addChild(screen);\n\n    // Text\n    const text = new pc.Entity();\n    text.setLocalPosition(0, 25, 0);\n    text.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n        fontAsset: assets.font.id,\n        fontSize: 18,\n        text: "this is a UI screen placed in the 3D world",\n        width: 200,\n        height: 100,\n        autoWidth: false,\n        autoHeight: false,\n        wrapLines: true,\n        enableMarkup: true,\n        type: pc.ELEMENTTYPE_TEXT,\n    });\n\n    screen.addChild(text);\n\n    // Button\n    const button = new pc.Entity();\n    button.setLocalPosition(0, -25, 0);\n    button.addComponent("button", {\n        imageEntity: button,\n    });\n\n    button.addComponent("element", {\n        anchor: [0.5, 0.5, 0.5, 0.5],\n        width: 100,\n        height: 25,\n        pivot: [0.5, 0.5],\n        type: pc.ELEMENTTYPE_IMAGE,\n        useInput: true,\n    });\n\n    screen.addChild(button);\n\n    // Create a label for the button\n    const buttonText = new pc.Entity();\n    buttonText.addComponent("element", {\n        pivot: new pc.Vec2(0.5, 0.5),\n        anchor: new pc.Vec4(0, 0, 1, 1),\n        margin: new pc.Vec4(0, 0, 0, 0),\n        color: new pc.Color(0, 0, 0),\n        fontAsset: assets.font.id,\n        fontSize: 12,\n        text: "and this is a button",\n        type: pc.ELEMENTTYPE_TEXT,\n        wrapLines: true,\n    });\n\n    button.addChild(buttonText);\n\n    // Change the background color every time the button is clicked\n    button.button.on("click", function (e) {\n        camera.camera.clearColor = new pc.Color(\n            Math.random(),\n            Math.random(),\n            Math.random()\n        );\n    });\n}\n',nameSlug:"world-ui",categorySlug:"user-interface"}},xr:{"ar-basic":{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector(\'.message\');\n        if (!el) {\n            el = document.createElement(\'div\');\n            el.classList.add(\'message\');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n        graphicsDeviceOptions: { alpha: true }\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent(\'camera\', {\n        clearColor: new pc.Color(0, 0, 0, 0),\n        farClip: 10000\n    });\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent("light", {\n        type: "spot",\n        range: 30\n    });\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n\n    const createCube = function (x: number, y: number, z: number) {\n        const cube = new pc.Entity();\n        cube.addComponent("model", {\n            type: "box"\n        });\n        cube.setLocalScale(0.5, 0.5, 0.5);\n        cube.translate(x * 0.5, y, z * 0.5);\n        app.root.addChild(cube);\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x < SIZE; x++) {\n        for (let y = 0; y < SIZE; y++) {\n            createCube(2 * x - SIZE, 0.25, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_AR)) {\n                c.camera.startXr(pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR, {\n                    callback: function (err) {\n                        if (err) message("WebXR Immersive AR failed to start: " + err.message);\n                    }\n                });\n            } else {\n                message("Immersive AR is not available");\n            }\n        };\n\n        app.mouse.on("mousedown", function () {\n            if (!app.xr.active)\n                activate();\n        });\n\n        if (app.touch) {\n            app.touch.on("touchend", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on(\'keydown\', function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        app.xr.on(\'start\', function () {\n            message("Immersive AR session has started");\n        });\n        app.xr.on(\'end\', function () {\n            message("Immersive AR session has ended");\n        });\n        app.xr.on(\'available:\' + pc.XRTYPE_AR, function (available) {\n            message("Immersive AR is " + (available ? \'available\' : \'unavailable\'));\n        });\n\n        if (!app.xr.isAvailable(pc.XRTYPE_AR)) {\n            message("Immersive AR is not available");\n        }\n    } else {\n        message("WebXR is not supported");\n    }\n}',javaScriptFunction:'function example(canvas) {\n    const message = function (msg) {\n        let el = document.querySelector(".message");\n        if (!el) {\n            el = document.createElement("div");\n            el.classList.add("message");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n        graphicsDeviceOptions: { alpha: true },\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent("camera", {\n        clearColor: new pc.Color(0, 0, 0, 0),\n        farClip: 10000,\n    });\n\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent("light", {\n        type: "spot",\n        range: 30,\n    });\n\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x, y, z) {\n        const cube = new pc.Entity();\n        cube.addComponent("model", {\n            type: "box",\n        });\n\n        cube.setLocalScale(0.5, 0.5, 0.5);\n        cube.translate(x * 0.5, y, z * 0.5);\n        app.root.addChild(cube);\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x < SIZE; x++) {\n        for (let y = 0; y < SIZE; y++) {\n            createCube(2 * x - SIZE, 0.25, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_AR)) {\n                c.camera.startXr(pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR, {\n                    callback: function (err) {\n                        if (err)\n                            message(\n                                "WebXR Immersive AR failed to start: " +\n                                    err.message\n                            );\n                    },\n                });\n            } else {\n                message("Immersive AR is not available");\n            }\n        };\n\n        app.mouse.on("mousedown", function () {\n            if (!app.xr.active) activate();\n        });\n\n        if (app.touch) {\n            app.touch.on("touchend", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on("keydown", function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        app.xr.on("start", function () {\n            message("Immersive AR session has started");\n        });\n        app.xr.on("end", function () {\n            message("Immersive AR session has ended");\n        });\n        app.xr.on("available:" + pc.XRTYPE_AR, function (available) {\n            message(\n                "Immersive AR is " + (available ? "available" : "unavailable")\n            );\n        });\n\n        if (!app.xr.isAvailable(pc.XRTYPE_AR)) {\n            message("Immersive AR is not available");\n        }\n    } else {\n        message("WebXR is not supported");\n    }\n}\n',nameSlug:"ar-basic",categorySlug:"xr"},"ar-hit-test":{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector(\'.message\');\n        if (!el) {\n            el = document.createElement(\'div\');\n            el.classList.add(\'message\');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n        graphicsDeviceOptions: { alpha: true }\n    });\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent(\'camera\', {\n        clearColor: new pc.Color(0, 0, 0, 0),\n        farClip: 10000\n    });\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent("light", {\n        type: "spot",\n        range: 30\n    });\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const target = new pc.Entity();\n    target.addComponent("model", {\n        type: "cylinder"\n    });\n    target.setLocalScale(0.5, 0.01, 0.5);\n    app.root.addChild(target);\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_AR)) {\n                c.camera.startXr(pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR, {\n                    callback: function (err) {\n                        if (err) message("WebXR Immersive AR failed to start: " + err.message);\n                    }\n                });\n            } else {\n                message("Immersive AR is not available");\n            }\n        };\n\n        app.mouse.on("mousedown", function () {\n            if (!app.xr.active)\n                activate();\n        });\n\n        if (app.touch) {\n            app.touch.on("touchend", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on(\'keydown\', function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        app.xr.on(\'start\', function () {\n            message("Immersive AR session has started");\n\n            if (!app.xr.hitTest.supported)\n                return;\n\n            app.xr.hitTest.start({\n                entityTypes: [pc.XRTRACKABLE_POINT, pc.XRTRACKABLE_PLANE],\n                callback: function (err, hitTestSource) {\n                    if (err) {\n                        message("Failed to start AR hit test");\n                        return;\n                    }\n\n                    hitTestSource.on(\'result\', function (position, rotation) {\n                        target.setPosition(position);\n                        target.setRotation(rotation);\n                    });\n                }\n            });\n        });\n        app.xr.on(\'end\', function () {\n            message("Immersive AR session has ended");\n        });\n        app.xr.on(\'available:\' + pc.XRTYPE_AR, function (available) {\n            if (available) {\n                if (app.xr.hitTest.supported) {\n                    message("Touch screen to start AR session and look at the floor or walls");\n                } else {\n                    message("AR Hit Test is not supported");\n                }\n            } else {\n                message("Immersive AR is unavailable");\n            }\n        });\n\n        if (!app.xr.isAvailable(pc.XRTYPE_AR)) {\n            message("Immersive AR is not available");\n        } else if (!app.xr.hitTest.supported) {\n            message("AR Hit Test is not supported");\n        } else {\n            message("Touch screen to start AR session and look at the floor or walls");\n        }\n    } else {\n        message("WebXR is not supported");\n    }\n}',javaScriptFunction:'function example(canvas) {\n    const message = function (msg) {\n        let el = document.querySelector(".message");\n        if (!el) {\n            el = document.createElement("div");\n            el.classList.add("message");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n        graphicsDeviceOptions: { alpha: true },\n    });\n\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent("camera", {\n        clearColor: new pc.Color(0, 0, 0, 0),\n        farClip: 10000,\n    });\n\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent("light", {\n        type: "spot",\n        range: 30,\n    });\n\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const target = new pc.Entity();\n    target.addComponent("model", {\n        type: "cylinder",\n    });\n\n    target.setLocalScale(0.5, 0.01, 0.5);\n    app.root.addChild(target);\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_AR)) {\n                c.camera.startXr(pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR, {\n                    callback: function (err) {\n                        if (err)\n                            message(\n                                "WebXR Immersive AR failed to start: " +\n                                    err.message\n                            );\n                    },\n                });\n            } else {\n                message("Immersive AR is not available");\n            }\n        };\n\n        app.mouse.on("mousedown", function () {\n            if (!app.xr.active) activate();\n        });\n\n        if (app.touch) {\n            app.touch.on("touchend", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on("keydown", function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        app.xr.on("start", function () {\n            message("Immersive AR session has started");\n\n            if (!app.xr.hitTest.supported) return;\n\n            app.xr.hitTest.start({\n                entityTypes: [pc.XRTRACKABLE_POINT, pc.XRTRACKABLE_PLANE],\n                callback: function (err, hitTestSource) {\n                    if (err) {\n                        message("Failed to start AR hit test");\n                        return;\n                    }\n\n                    hitTestSource.on("result", function (position, rotation) {\n                        target.setPosition(position);\n                        target.setRotation(rotation);\n                    });\n                },\n            });\n        });\n        app.xr.on("end", function () {\n            message("Immersive AR session has ended");\n        });\n        app.xr.on("available:" + pc.XRTYPE_AR, function (available) {\n            if (available) {\n                if (app.xr.hitTest.supported) {\n                    message(\n                        "Touch screen to start AR session and look at the floor or walls"\n                    );\n                } else {\n                    message("AR Hit Test is not supported");\n                }\n            } else {\n                message("Immersive AR is unavailable");\n            }\n        });\n\n        if (!app.xr.isAvailable(pc.XRTYPE_AR)) {\n            message("Immersive AR is not available");\n        } else if (!app.xr.hitTest.supported) {\n            message("AR Hit Test is not supported");\n        } else {\n            message(\n                "Touch screen to start AR session and look at the floor or walls"\n            );\n        }\n    } else {\n        message("WebXR is not supported");\n    }\n}\n',nameSlug:"ar-hit-test",categorySlug:"xr"},"vr-basic":{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector(\'.message\');\n        if (!el) {\n            el = document.createElement(\'div\');\n            el.classList.add(\'message\');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window)\n    });\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent(\'camera\', {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n        farClip: 10000\n    });\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent("light", {\n        type: "spot",\n        range: 30\n    });\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n\n    const createCube = function (x: number, y: number, z: number) {\n        const cube = new pc.Entity();\n        cube.addComponent("render", {\n            type: "box"\n        });\n        cube.setLocalScale(1, 1, 1);\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    // create a grid of cubes\n    const SIZE = 16;\n    for (let x = 0; x < SIZE; x++) {\n        for (let y = 0; y < SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err) message("WebXR Immersive VR failed to start: " + err.message);\n                    }\n                });\n            } else {\n                message("Immersive VR is not available");\n            }\n        };\n\n        app.mouse.on("mousedown", function () {\n            if (!app.xr.active)\n                activate();\n        });\n\n        if (app.touch) {\n            app.touch.on("touchend", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on(\'keydown\', function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        app.xr.on(\'start\', function () {\n            message("Immersive VR session has started");\n        });\n        app.xr.on(\'end\', function () {\n            message("Immersive VR session has ended");\n        });\n        app.xr.on(\'available:\' + pc.XRTYPE_VR, function (available) {\n            message("Immersive VR is " + (available ? \'available\' : \'unavailable\'));\n        });\n\n        if (!app.xr.isAvailable(pc.XRTYPE_VR)) {\n            message("Immersive VR is not available");\n        }\n    } else {\n        message("WebXR is not supported");\n    }\n}',javaScriptFunction:'function example(canvas) {\n    const message = function (msg) {\n        let el = document.querySelector(".message");\n        if (!el) {\n            el = document.createElement("div");\n            el.classList.add("message");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent("camera", {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n        farClip: 10000,\n    });\n\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent("light", {\n        type: "spot",\n        range: 30,\n    });\n\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x, y, z) {\n        const cube = new pc.Entity();\n        cube.addComponent("render", {\n            type: "box",\n        });\n\n        cube.setLocalScale(1, 1, 1);\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    // create a grid of cubes\n    const SIZE = 16;\n    for (let x = 0; x < SIZE; x++) {\n        for (let y = 0; y < SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err)\n                            message(\n                                "WebXR Immersive VR failed to start: " +\n                                    err.message\n                            );\n                    },\n                });\n            } else {\n                message("Immersive VR is not available");\n            }\n        };\n\n        app.mouse.on("mousedown", function () {\n            if (!app.xr.active) activate();\n        });\n\n        if (app.touch) {\n            app.touch.on("touchend", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on("keydown", function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        app.xr.on("start", function () {\n            message("Immersive VR session has started");\n        });\n        app.xr.on("end", function () {\n            message("Immersive VR session has ended");\n        });\n        app.xr.on("available:" + pc.XRTYPE_VR, function (available) {\n            message(\n                "Immersive VR is " + (available ? "available" : "unavailable")\n            );\n        });\n\n        if (!app.xr.isAvailable(pc.XRTYPE_VR)) {\n            message("Immersive VR is not available");\n        }\n    } else {\n        message("WebXR is not supported");\n    }\n}\n',nameSlug:"vr-basic",categorySlug:"xr"},"vr-controllers":{typeScriptFunction:'function example(canvas: HTMLCanvasElement, assets: { glb: pc.Asset }): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector(\'.message\');\n        if (!el) {\n            el = document.createElement(\'div\');\n            el.classList.add(\'message\');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window)\n    });\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent(\'camera\', {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255)\n    });\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent("light", {\n        type: "directional",\n        castShadows: true,\n        shadowBias: 0.05,\n        normalOffsetBias: 0.05,\n        shadowDistance: 5\n    });\n    l.setEulerAngles(45, 135, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x: number, y: number, z: number) {\n        const cube = new pc.Entity();\n        cube.addComponent("model", {\n            type: "box",\n            material: new pc.StandardMaterial()\n        });\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    const controllers: any = [];\n    // create controller model\n    const createController = function (inputSource: any) {\n        const entity = new pc.Entity();\n        entity.addComponent(\'model\', {\n            type: \'asset\',\n            asset: assets.glb.resource.model,\n            castShadows: true\n        });\n        app.root.addChild(entity);\n        // @ts-ignore engine-tsd\n        entity.inputSource = inputSource;\n        controllers.push(entity);\n\n        // destroy input source related entity\n        // when input source is removed\n        inputSource.on(\'remove\', function () {\n            controllers.splice(controllers.indexOf(entity), 1);\n            entity.destroy();\n        });\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err) message("Immersive VR failed to start: " + err.message);\n                    }\n                });\n            } else {\n                message("Immersive VR is not available");\n            }\n        };\n\n        app.mouse.on("mousedown", function () {\n            if (!app.xr.active)\n                activate();\n        });\n\n        if (app.touch) {\n            app.touch.on("touchend", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on(\'keydown\', function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        // when new input source added\n        app.xr.input.on(\'add\', function (inputSource) {\n            message("Controller Added");\n            createController(inputSource);\n        });\n\n        message("Tap on screen to enter VR, and see controllers");\n\n        // update position and rotation for each controller\n        app.on(\'update\', function () {\n            for (let i = 0; i < controllers.length; i++) {\n                const inputSource = controllers[i].inputSource;\n                if (inputSource.grip) {\n                    // some controllers can be gripped\n                    controllers[i].enabled = true;\n                    controllers[i].setLocalPosition(inputSource.getLocalPosition());\n                    controllers[i].setLocalRotation(inputSource.getLocalRotation());\n                } else {\n                    // some controllers cannot be gripped\n                    controllers[i].enabled = false;\n                }\n            }\n        });\n    } else {\n        message("WebXR is not supported");\n    }\n}',javaScriptFunction:'function example(canvas, assets) {\n    const message = function (msg) {\n        let el = document.querySelector(".message");\n        if (!el) {\n            el = document.createElement("div");\n            el.classList.add("message");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent("camera", {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n    });\n\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent("light", {\n        type: "directional",\n        castShadows: true,\n        shadowBias: 0.05,\n        normalOffsetBias: 0.05,\n        shadowDistance: 5,\n    });\n\n    l.setEulerAngles(45, 135, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x, y, z) {\n        const cube = new pc.Entity();\n        cube.addComponent("model", {\n            type: "box",\n            material: new pc.StandardMaterial(),\n        });\n\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    const controllers = [];\n    // create controller model\n    const createController = function (inputSource) {\n        const entity = new pc.Entity();\n        entity.addComponent("model", {\n            type: "asset",\n            asset: assets.glb.resource.model,\n            castShadows: true,\n        });\n\n        app.root.addChild(entity);\n        // @ts-ignore engine-tsd\n        entity.inputSource = inputSource;\n        controllers.push(entity);\n\n        // destroy input source related entity\n        // when input source is removed\n        inputSource.on("remove", function () {\n            controllers.splice(controllers.indexOf(entity), 1);\n            entity.destroy();\n        });\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err)\n                            message(\n                                "Immersive VR failed to start: " + err.message\n                            );\n                    },\n                });\n            } else {\n                message("Immersive VR is not available");\n            }\n        };\n\n        app.mouse.on("mousedown", function () {\n            if (!app.xr.active) activate();\n        });\n\n        if (app.touch) {\n            app.touch.on("touchend", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on("keydown", function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        // when new input source added\n        app.xr.input.on("add", function (inputSource) {\n            message("Controller Added");\n            createController(inputSource);\n        });\n\n        message("Tap on screen to enter VR, and see controllers");\n\n        // update position and rotation for each controller\n        app.on("update", function () {\n            for (let i = 0; i < controllers.length; i++) {\n                const inputSource = controllers[i].inputSource;\n                if (inputSource.grip) {\n                    // some controllers can be gripped\n                    controllers[i].enabled = true;\n                    controllers[i].setLocalPosition(\n                        inputSource.getLocalPosition()\n                    );\n                    controllers[i].setLocalRotation(\n                        inputSource.getLocalRotation()\n                    );\n                } else {\n                    // some controllers cannot be gripped\n                    controllers[i].enabled = false;\n                }\n            }\n        });\n    } else {\n        message("WebXR is not supported");\n    }\n}\n',nameSlug:"vr-controllers",categorySlug:"xr"},"vr-hands":{typeScriptFunction:"function example(canvas: HTMLCanvasElement): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector('.message');\n        if (!el) {\n            el = document.createElement('div');\n            el.classList.add('message');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window)\n    });\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent('camera', {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255)\n    });\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent(\"light\", {\n        type: \"directional\"\n    });\n    l.setEulerAngles(45, 135, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x: number, y: number, z: number) {\n        const cube = new pc.Entity();\n        cube.addComponent(\"model\", {\n            type: \"box\",\n            material: new pc.StandardMaterial()\n        });\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    const controllers: any = [];\n\n    // create controller model\n    const createController = function (inputSource: any) {\n        const entity = new pc.Entity();\n\n        if (inputSource.hand) {\n            // hand input\n            // @ts-ignore engine-tsd\n            entity.joints = [];\n\n            const material = new pc.StandardMaterial();\n\n            // create box for each hand joint\n            for (let i = 0; i < inputSource.hand.joints.length; i++) {\n                const joint = inputSource.hand.joints[i];\n                const jointEntity = new pc.Entity();\n                jointEntity.addComponent('model', {\n                    type: 'box',\n                    material: material\n                });\n                // @ts-ignore engine-tsd\n                jointEntity.joint = joint;\n                // @ts-ignore engine-tsd\n                entity.joints.push(jointEntity);\n                entity.addChild(jointEntity);\n            }\n            // when tracking lost, paint joints to red\n            inputSource.hand.on('trackinglost', function () {\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.diffuse.set(1, 0, 0);\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.update();\n            });\n            // when tracking recovered, paint joints to white\n            inputSource.hand.on('tracking', function () {\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.diffuse.set(1, 1, 1);\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.update();\n            });\n        } else {\n            // other inputs\n            entity.addComponent('model', {\n                type: 'box',\n                castShadows: true\n            });\n            entity.setLocalScale(0.05, 0.05, 0.05);\n        }\n\n        app.root.addChild(entity);\n        // @ts-ignore engine-tsd\n        entity.inputSource = inputSource;\n        controllers.push(entity);\n\n        // destroy input source related entity\n        // when input source is removed\n        inputSource.on('remove', function () {\n            controllers.splice(controllers.indexOf(entity), 1);\n            entity.destroy();\n        });\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err) message(\"Immersive VR failed to start: \" + err.message);\n                    }\n                });\n            } else {\n                message(\"Immersive VR is not available\");\n            }\n        };\n\n        app.mouse.on(\"mousedown\", function () {\n            if (!app.xr.active)\n                activate();\n        });\n\n        if (app.touch) {\n            app.touch.on(\"touchend\", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on('keydown', function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        // when new input source added\n        app.xr.input.on('add', function (inputSource) {\n            message(\"Controller Added\");\n            createController(inputSource);\n        });\n\n        if ((window as any).XRHand) {\n            message(\"Tap on screen to enter VR, and switch to hand input\");\n        } else {\n            message(\"WebXR Hands Input is not supported by your platform\");\n        }\n\n        // update position and rotation for each controller\n        app.on('update', function () {\n            for (let i = 0; i < controllers.length; i++) {\n                const inputSource = controllers[i].inputSource;\n\n                if (inputSource.hand) {\n                    // hand input source\n                    controllers[i].enabled = true;\n                    // update each hand joint\n                    for (let j = 0; j < controllers[i].joints.length; j++) {\n                        const joint = controllers[i].joints[j].joint;\n                        const r = joint.radius * 2;\n                        controllers[i].joints[j].setLocalScale(r, r, r);\n                        controllers[i].joints[j].setPosition(joint.getPosition());\n                        controllers[i].joints[j].setRotation(joint.getRotation());\n                    }\n                } else if (inputSource.grip) {\n                    // grippable input source\n                    controllers[i].enabled = true;\n                    controllers[i].setLocalPosition(inputSource.getLocalPosition());\n                    controllers[i].setLocalRotation(inputSource.getLocalRotation());\n                } else {\n                    // some controllers cannot be gripped\n                    controllers[i].enabled = false;\n                }\n            }\n        });\n    } else {\n        message(\"WebXR is not supported\");\n    }\n}",javaScriptFunction:'function example(canvas) {\n    const message = function (msg) {\n        let el = document.querySelector(".message");\n        if (!el) {\n            el = document.createElement("div");\n            el.classList.add("message");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent("camera", {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n    });\n\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent("light", {\n        type: "directional",\n    });\n\n    l.setEulerAngles(45, 135, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x, y, z) {\n        const cube = new pc.Entity();\n        cube.addComponent("model", {\n            type: "box",\n            material: new pc.StandardMaterial(),\n        });\n\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    const controllers = [];\n\n    // create controller model\n    const createController = function (inputSource) {\n        const entity = new pc.Entity();\n\n        if (inputSource.hand) {\n            // hand input\n            // @ts-ignore engine-tsd\n            entity.joints = [];\n\n            const material = new pc.StandardMaterial();\n\n            // create box for each hand joint\n            for (let i = 0; i < inputSource.hand.joints.length; i++) {\n                const joint = inputSource.hand.joints[i];\n                const jointEntity = new pc.Entity();\n                jointEntity.addComponent("model", {\n                    type: "box",\n                    material: material,\n                });\n\n                // @ts-ignore engine-tsd\n                jointEntity.joint = joint;\n                // @ts-ignore engine-tsd\n                entity.joints.push(jointEntity);\n                entity.addChild(jointEntity);\n            }\n            // when tracking lost, paint joints to red\n            inputSource.hand.on("trackinglost", function () {\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.diffuse.set(1, 0, 0);\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.update();\n            });\n            // when tracking recovered, paint joints to white\n            inputSource.hand.on("tracking", function () {\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.diffuse.set(1, 1, 1);\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.update();\n            });\n        } else {\n            // other inputs\n            entity.addComponent("model", {\n                type: "box",\n                castShadows: true,\n            });\n\n            entity.setLocalScale(0.05, 0.05, 0.05);\n        }\n\n        app.root.addChild(entity);\n        // @ts-ignore engine-tsd\n        entity.inputSource = inputSource;\n        controllers.push(entity);\n\n        // destroy input source related entity\n        // when input source is removed\n        inputSource.on("remove", function () {\n            controllers.splice(controllers.indexOf(entity), 1);\n            entity.destroy();\n        });\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err)\n                            message(\n                                "Immersive VR failed to start: " + err.message\n                            );\n                    },\n                });\n            } else {\n                message("Immersive VR is not available");\n            }\n        };\n\n        app.mouse.on("mousedown", function () {\n            if (!app.xr.active) activate();\n        });\n\n        if (app.touch) {\n            app.touch.on("touchend", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on("keydown", function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        // when new input source added\n        app.xr.input.on("add", function (inputSource) {\n            message("Controller Added");\n            createController(inputSource);\n        });\n\n        if (window.XRHand) {\n            message("Tap on screen to enter VR, and switch to hand input");\n        } else {\n            message("WebXR Hands Input is not supported by your platform");\n        }\n\n        // update position and rotation for each controller\n        app.on("update", function () {\n            for (let i = 0; i < controllers.length; i++) {\n                const inputSource = controllers[i].inputSource;\n\n                if (inputSource.hand) {\n                    // hand input source\n                    controllers[i].enabled = true;\n                    // update each hand joint\n                    for (let j = 0; j < controllers[i].joints.length; j++) {\n                        const joint = controllers[i].joints[j].joint;\n                        const r = joint.radius * 2;\n                        controllers[i].joints[j].setLocalScale(r, r, r);\n                        controllers[i].joints[j].setPosition(\n                            joint.getPosition()\n                        );\n                        controllers[i].joints[j].setRotation(\n                            joint.getRotation()\n                        );\n                    }\n                } else if (inputSource.grip) {\n                    // grippable input source\n                    controllers[i].enabled = true;\n                    controllers[i].setLocalPosition(\n                        inputSource.getLocalPosition()\n                    );\n                    controllers[i].setLocalRotation(\n                        inputSource.getLocalRotation()\n                    );\n                } else {\n                    // some controllers cannot be gripped\n                    controllers[i].enabled = false;\n                }\n            }\n        });\n    } else {\n        message("WebXR is not supported");\n    }\n}\n',nameSlug:"vr-hands",categorySlug:"xr"},"vr-movement":{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector(\'.message\');\n        if (!el) {\n            el = document.createElement(\'div\');\n            el.classList.add(\'message\');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window)\n    });\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera parent\n    const cameraParent = new pc.Entity();\n    app.root.addChild(cameraParent);\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent(\'camera\', {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n        farClip: 10000\n    });\n    cameraParent.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent("light", {\n        type: "spot",\n        range: 30\n    });\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x: number, y: number, z: number) {\n        const cube = new pc.Entity();\n        cube.addComponent("model", {\n            type: "box",\n            material: new pc.StandardMaterial()\n        });\n        cube.setLocalScale(1, 1, 1);\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    const controllers: any = [];\n    // create controller box\n    const createController = function (inputSource: any) {\n        const entity = new pc.Entity();\n        entity.addComponent(\'model\', {\n            type: \'box\'\n        });\n        entity.setLocalScale(0.05, 0.05, 0.05);\n        cameraParent.addChild(entity);\n        // @ts-ignore engine-tsd\n        entity.inputSource = inputSource;\n        controllers.push(entity);\n\n        // destroy input source related entity\n        // when input source is removed\n        inputSource.on(\'remove\', function () {\n            controllers.splice(controllers.indexOf(entity), 1);\n            entity.destroy();\n        });\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err) message("Immersive VR failed to start: " + err.message);\n                    }\n                });\n            } else {\n                message("Immersive VR is not available");\n            }\n        };\n\n        app.mouse.on("mousedown", function () {\n            if (!app.xr.active)\n                activate();\n        });\n\n        if (app.touch) {\n            app.touch.on("touchend", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on(\'keydown\', function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        // when new input source added\n        app.xr.input.on(\'add\', function (inputSource) {\n            createController(inputSource);\n        });\n\n        message("Tap on screen to enter VR, use left thumbstick to move and right thumbstick to rotate");\n\n        const movementSpeed = 1.5; // 1.5 m/s\n        const rotateSpeed = 45;\n        const rotateThreshold = 0.5;\n        const rotateResetThreshold = 0.25;\n        let lastRotateValue = 0;\n\n        const tmpVec2A = new pc.Vec2();\n        const tmpVec2B = new pc.Vec2();\n        const tmpVec3A = new pc.Vec3();\n        const tmpVec3B = new pc.Vec3();\n        const lineColor = new pc.Color(1, 1, 1);\n\n        // update position and rotation for each controller\n        app.on(\'update\', function (dt) {\n            let i, inputSource;\n\n            // first we update movement\n            for (i = 0; i < controllers.length; i++) {\n                inputSource = controllers[i].inputSource;\n\n                // should have gamepad\n                if (!inputSource.gamepad)\n                    continue;\n\n                // left controller - for movement\n                if (inputSource.handedness === pc.XRHAND_LEFT) {\n                    // set vector based on gamepad thumbstick axes values\n                    tmpVec2A.set(inputSource.gamepad.axes[2], inputSource.gamepad.axes[3]);\n\n                    // if there is input\n                    if (tmpVec2A.length()) {\n                        tmpVec2A.normalize();\n\n                        // we need to take in account camera facing\n                        // so we figure out Yaw of camera\n                        tmpVec2B.x = c.forward.x;\n                        tmpVec2B.y = c.forward.z;\n                        tmpVec2B.normalize();\n\n                        const rad = Math.atan2(tmpVec2B.x, tmpVec2B.y) - (Math.PI / 2);\n                        // and rotate our movement vector based on camera yaw\n                        const t =      tmpVec2A.x * Math.sin(rad) - tmpVec2A.y * Math.cos(rad);\n                        tmpVec2A.y = tmpVec2A.y * Math.sin(rad) + tmpVec2A.x * Math.cos(rad);\n                        tmpVec2A.x = t;\n\n                        // set movement speed\n                        tmpVec2A.mulScalar(movementSpeed * dt);\n                        // move camera parent based on calculated movement vector\n                        cameraParent.translate(tmpVec2A.x, 0, tmpVec2A.y);\n                    }\n\n                // right controller - for rotation\n                } else if (inputSource.handedness === pc.XRHAND_RIGHT) {\n                    // get rotation from thumbsitck\n                    const rotate = -inputSource.gamepad.axes[2];\n\n                    // each rotate should be done by moving thumbstick to the side enough\n                    // then thumbstick should be moved back close to neutral position\n                    // before it can be used again to rotate\n                    if (lastRotateValue > 0 && rotate < rotateResetThreshold) {\n                        lastRotateValue = 0;\n                    } else if (lastRotateValue < 0 && rotate > -rotateResetThreshold) {\n                        lastRotateValue = 0;\n                    }\n\n                    // if thumbstick is reset and moved enough to the side\n                    if (lastRotateValue === 0 && Math.abs(rotate) > rotateThreshold) {\n                        lastRotateValue = Math.sign(rotate);\n\n                        // we want to rotate relative to camera position\n                        tmpVec3A.copy(c.getLocalPosition());\n                        cameraParent.translateLocal(tmpVec3A);\n                        cameraParent.rotateLocal(0, Math.sign(rotate) * rotateSpeed, 0);\n                        cameraParent.translateLocal(tmpVec3A.mulScalar(-1));\n                    }\n                }\n            }\n\n            // after movement and rotation is done\n            // we update/render controllers\n            for (i = 0; i < controllers.length; i++) {\n                inputSource = controllers[i].inputSource;\n\n                // render controller ray\n                tmpVec3A.copy(inputSource.getOrigin());\n                tmpVec3B.copy(inputSource.getDirection());\n                tmpVec3B.mulScalar(100).add(tmpVec3A);\n                app.drawLine(tmpVec3A, tmpVec3B, lineColor);\n\n                // render controller\n                if (inputSource.grip) {\n                    // some controllers can be gripped\n                    controllers[i].model.enabled = true;\n                    controllers[i].setLocalPosition(inputSource.getLocalPosition);\n                    controllers[i].setLocalRotation(inputSource.getLocalRotation);\n                } else {\n                    // some controllers cannot be gripped\n                    controllers[i].model.enabled = false;\n                }\n            }\n        });\n    } else {\n        message("WebXR is not supported");\n    }\n}',javaScriptFunction:'function example(canvas) {\n    const message = function (msg) {\n        let el = document.querySelector(".message");\n        if (!el) {\n            el = document.createElement("div");\n            el.classList.add("message");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera parent\n    const cameraParent = new pc.Entity();\n    app.root.addChild(cameraParent);\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent("camera", {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n        farClip: 10000,\n    });\n\n    cameraParent.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent("light", {\n        type: "spot",\n        range: 30,\n    });\n\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x, y, z) {\n        const cube = new pc.Entity();\n        cube.addComponent("model", {\n            type: "box",\n            material: new pc.StandardMaterial(),\n        });\n\n        cube.setLocalScale(1, 1, 1);\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    const controllers = [];\n    // create controller box\n    const createController = function (inputSource) {\n        const entity = new pc.Entity();\n        entity.addComponent("model", {\n            type: "box",\n        });\n\n        entity.setLocalScale(0.05, 0.05, 0.05);\n        cameraParent.addChild(entity);\n        // @ts-ignore engine-tsd\n        entity.inputSource = inputSource;\n        controllers.push(entity);\n\n        // destroy input source related entity\n        // when input source is removed\n        inputSource.on("remove", function () {\n            controllers.splice(controllers.indexOf(entity), 1);\n            entity.destroy();\n        });\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err)\n                            message(\n                                "Immersive VR failed to start: " + err.message\n                            );\n                    },\n                });\n            } else {\n                message("Immersive VR is not available");\n            }\n        };\n\n        app.mouse.on("mousedown", function () {\n            if (!app.xr.active) activate();\n        });\n\n        if (app.touch) {\n            app.touch.on("touchend", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on("keydown", function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        // when new input source added\n        app.xr.input.on("add", function (inputSource) {\n            createController(inputSource);\n        });\n\n        message(\n            "Tap on screen to enter VR, use left thumbstick to move and right thumbstick to rotate"\n        );\n\n        const movementSpeed = 1.5; // 1.5 m/s\n        const rotateSpeed = 45;\n        const rotateThreshold = 0.5;\n        const rotateResetThreshold = 0.25;\n        let lastRotateValue = 0;\n\n        const tmpVec2A = new pc.Vec2();\n        const tmpVec2B = new pc.Vec2();\n        const tmpVec3A = new pc.Vec3();\n        const tmpVec3B = new pc.Vec3();\n        const lineColor = new pc.Color(1, 1, 1);\n\n        // update position and rotation for each controller\n        app.on("update", function (dt) {\n            let i, inputSource;\n\n            // first we update movement\n            for (i = 0; i < controllers.length; i++) {\n                inputSource = controllers[i].inputSource;\n\n                // should have gamepad\n                if (!inputSource.gamepad) continue;\n\n                // left controller - for movement\n                if (inputSource.handedness === pc.XRHAND_LEFT) {\n                    // set vector based on gamepad thumbstick axes values\n                    tmpVec2A.set(\n                        inputSource.gamepad.axes[2],\n                        inputSource.gamepad.axes[3]\n                    );\n\n                    // if there is input\n                    if (tmpVec2A.length()) {\n                        tmpVec2A.normalize();\n\n                        // we need to take in account camera facing\n                        // so we figure out Yaw of camera\n                        tmpVec2B.x = c.forward.x;\n                        tmpVec2B.y = c.forward.z;\n                        tmpVec2B.normalize();\n\n                        const rad =\n                            Math.atan2(tmpVec2B.x, tmpVec2B.y) - Math.PI / 2;\n                        // and rotate our movement vector based on camera yaw\n                        const t =\n                            tmpVec2A.x * Math.sin(rad) -\n                            tmpVec2A.y * Math.cos(rad);\n                        tmpVec2A.y =\n                            tmpVec2A.y * Math.sin(rad) +\n                            tmpVec2A.x * Math.cos(rad);\n                        tmpVec2A.x = t;\n\n                        // set movement speed\n                        tmpVec2A.mulScalar(movementSpeed * dt);\n                        // move camera parent based on calculated movement vector\n                        cameraParent.translate(tmpVec2A.x, 0, tmpVec2A.y);\n                    }\n\n                    // right controller - for rotation\n                } else if (inputSource.handedness === pc.XRHAND_RIGHT) {\n                    // get rotation from thumbsitck\n                    const rotate = -inputSource.gamepad.axes[2];\n\n                    // each rotate should be done by moving thumbstick to the side enough\n                    // then thumbstick should be moved back close to neutral position\n                    // before it can be used again to rotate\n                    if (lastRotateValue > 0 && rotate < rotateResetThreshold) {\n                        lastRotateValue = 0;\n                    } else if (\n                        lastRotateValue < 0 &&\n                        rotate > -rotateResetThreshold\n                    ) {\n                        lastRotateValue = 0;\n                    }\n\n                    // if thumbstick is reset and moved enough to the side\n                    if (\n                        lastRotateValue === 0 &&\n                        Math.abs(rotate) > rotateThreshold\n                    ) {\n                        lastRotateValue = Math.sign(rotate);\n\n                        // we want to rotate relative to camera position\n                        tmpVec3A.copy(c.getLocalPosition());\n                        cameraParent.translateLocal(tmpVec3A);\n                        cameraParent.rotateLocal(\n                            0,\n                            Math.sign(rotate) * rotateSpeed,\n                            0\n                        );\n                        cameraParent.translateLocal(tmpVec3A.mulScalar(-1));\n                    }\n                }\n            }\n\n            // after movement and rotation is done\n            // we update/render controllers\n            for (i = 0; i < controllers.length; i++) {\n                inputSource = controllers[i].inputSource;\n\n                // render controller ray\n                tmpVec3A.copy(inputSource.getOrigin());\n                tmpVec3B.copy(inputSource.getDirection());\n                tmpVec3B.mulScalar(100).add(tmpVec3A);\n                app.drawLine(tmpVec3A, tmpVec3B, lineColor);\n\n                // render controller\n                if (inputSource.grip) {\n                    // some controllers can be gripped\n                    controllers[i].model.enabled = true;\n                    controllers[i].setLocalPosition(\n                        inputSource.getLocalPosition\n                    );\n                    controllers[i].setLocalRotation(\n                        inputSource.getLocalRotation\n                    );\n                } else {\n                    // some controllers cannot be gripped\n                    controllers[i].model.enabled = false;\n                }\n            }\n        });\n    } else {\n        message("WebXR is not supported");\n    }\n}\n',nameSlug:"vr-movement",categorySlug:"xr"},"xr-picking":{typeScriptFunction:'function example(canvas: HTMLCanvasElement): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector(\'.message\');\n        if (!el) {\n            el = document.createElement(\'div\');\n            el.classList.add(\'message\');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window)\n    });\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent(\'camera\', {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n        farClip: 10000\n    });\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent("light", {\n        type: "spot",\n        range: 30\n    });\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const cubes: any = [];\n\n    const createCube = function (x: number, y: number, z: number) {\n        const cube = new pc.Entity();\n        cube.addComponent("model", {\n            type: "box",\n            material: new pc.StandardMaterial()\n        });\n        cube.setLocalScale(1, 1, 1);\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n        cubes.push(cube);\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err) message("Immersive VR failed to start: " + err.message);\n                    }\n                });\n            } else {\n                message("Immersive VR is not available");\n            }\n        };\n\n        app.mouse.on("mousedown", function () {\n            if (!app.xr.active)\n                activate();\n        });\n\n        if (app.touch) {\n            app.touch.on("touchend", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on(\'keydown\', function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        message("Tap on screen to enter VR, and then pick objects");\n\n        // when input source is triggers select\n        // pick closest box and change its color\n        const ray = new pc.Ray();\n        app.xr.input.on(\'select\', function (inputSource) {\n            let candidate = null;\n            let candidateDist = Infinity;\n\n            for (let i = 0; i < cubes.length; i++) {\n                const mesh = cubes[i].model.meshInstances[0];\n\n                // check if mesh bounding box intersects with input source ray\n                ray.set(inputSource.getOrigin(), inputSource.getDirection());\n                if (mesh.aabb.intersectsRay(ray)) {\n                    // check distance to camera\n                    const dist = mesh.aabb.center.distance(c.getPosition());\n\n                    // if it is closer than previous distance\n                    if (dist < candidateDist) {\n\n                        // set new candidate\n                        candidate = mesh;\n                        candidateDist = dist;\n                    }\n                }\n            }\n\n            // if we have picked candidate\n            if (candidate) {\n                // randomize its color\n                candidate.material.diffuse.set(Math.random(), Math.random(), Math.random());\n                candidate.material.update();\n            }\n        });\n\n        const tmpVec = new pc.Vec3();\n        const lineColor = new pc.Color(1, 1, 1);\n\n        // on each app update\n        // render input source rays as a line\n        app.on(\'update\', function () {\n            for (let i = 0; i < app.xr.input.inputSources.length; i++) {\n                const inputSource = app.xr.input.inputSources[i];\n                const direction = inputSource.getDirection();\n                const origin = inputSource.getOrigin();\n\n                tmpVec.copy(direction).mulScalar(100).add(origin);\n\n                app.drawLine(inputSource.getOrigin(), tmpVec, lineColor);\n            }\n        });\n    } else {\n        message("WebXR is not supported");\n    }\n}',javaScriptFunction:'function example(canvas) {\n    const message = function (msg) {\n        let el = document.querySelector(".message");\n        if (!el) {\n            el = document.createElement("div");\n            el.classList.add("message");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener("resize", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent("camera", {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n        farClip: 10000,\n    });\n\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent("light", {\n        type: "spot",\n        range: 30,\n    });\n\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const cubes = [];\n\n    const createCube = function (x, y, z) {\n        const cube = new pc.Entity();\n        cube.addComponent("model", {\n            type: "box",\n            material: new pc.StandardMaterial(),\n        });\n\n        cube.setLocalScale(1, 1, 1);\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n        cubes.push(cube);\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err)\n                            message(\n                                "Immersive VR failed to start: " + err.message\n                            );\n                    },\n                });\n            } else {\n                message("Immersive VR is not available");\n            }\n        };\n\n        app.mouse.on("mousedown", function () {\n            if (!app.xr.active) activate();\n        });\n\n        if (app.touch) {\n            app.touch.on("touchend", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on("keydown", function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        message("Tap on screen to enter VR, and then pick objects");\n\n        // when input source is triggers select\n        // pick closest box and change its color\n        const ray = new pc.Ray();\n        app.xr.input.on("select", function (inputSource) {\n            let candidate = null;\n            let candidateDist = Infinity;\n\n            for (let i = 0; i < cubes.length; i++) {\n                const mesh = cubes[i].model.meshInstances[0];\n\n                // check if mesh bounding box intersects with input source ray\n                ray.set(inputSource.getOrigin(), inputSource.getDirection());\n                if (mesh.aabb.intersectsRay(ray)) {\n                    // check distance to camera\n                    const dist = mesh.aabb.center.distance(c.getPosition());\n\n                    // if it is closer than previous distance\n                    if (dist < candidateDist) {\n                        // set new candidate\n                        candidate = mesh;\n                        candidateDist = dist;\n                    }\n                }\n            }\n\n            // if we have picked candidate\n            if (candidate) {\n                // randomize its color\n                candidate.material.diffuse.set(\n                    Math.random(),\n                    Math.random(),\n                    Math.random()\n                );\n                candidate.material.update();\n            }\n        });\n\n        const tmpVec = new pc.Vec3();\n        const lineColor = new pc.Color(1, 1, 1);\n\n        // on each app update\n        // render input source rays as a line\n        app.on("update", function () {\n            for (let i = 0; i < app.xr.input.inputSources.length; i++) {\n                const inputSource = app.xr.input.inputSources[i];\n                const direction = inputSource.getDirection();\n                const origin = inputSource.getOrigin();\n\n                tmpVec.copy(direction).mulScalar(100).add(origin);\n\n                app.drawLine(inputSource.getOrigin(), tmpVec, lineColor);\n            }\n        });\n    } else {\n        message("WebXR is not supported");\n    }\n}\n',nameSlug:"xr-picking",categorySlug:"xr"}}};
/**
 * @license
 * PlayCanvas Engine v1.53.4 revision 7d36fcd91
 * Copyright 2011-2022 PlayCanvas Ltd. All rights reserved.
 */function Gp(e,t,n){e.prototype[t]||Object.defineProperty(e.prototype,t,{value:n,configurable:!0,enumerable:!1,writable:!0})}Gp(Array,"fill",(function(e){if(null==this)throw new TypeError("this is null or not defined");for(var t=Object(this),n=t.length>>>0,a=arguments[1],i=a>>0,s=i<0?Math.max(n+i,0):Math.min(i,n),r=arguments[2],o=void 0===r?n:r>>0,l=o<0?Math.max(n+o,0):Math.min(o,n);s<l;)t[s]=e,s++;return t})),Gp(Array,"find",(function(e){if(null==this)throw TypeError('"this" is null or not defined');var t=Object(this),n=t.length>>>0;if("function"!=typeof e)throw TypeError("predicate must be a function");for(var a=arguments[1],i=0;i<n;){var s=t[i];if(e.call(a,s,i,t))return s;i++}})),Gp(Array,"findIndex",(function(e){if(null==this)throw new TypeError('"this" is null or not defined');var t=Object(this),n=t.length>>>0;if("function"!=typeof e)throw new TypeError("predicate must be a function");for(var a=arguments[1],i=0;i<n;){var s=t[i];if(e.call(a,s,i,t))return i;i++}return-1})),Math.log2=Math.log2||function(e){return Math.log(e)*Math.LOG2E},Math.sign||(Math.sign=function(e){return(e>0)-(e<0)||+e}),void 0===Number.isFinite&&(Number.isFinite=function(e){return"number"==typeof e&&isFinite(e)}),"function"!=typeof Object.assign&&Object.defineProperty(Object,"assign",{value:function(e,t){if(null==e)throw new TypeError("Cannot convert undefined or null to object");for(var n=Object(e),a=1;a<arguments.length;a++){var i=arguments[a];if(null!=i)for(var s in i)Object.prototype.hasOwnProperty.call(i,s)&&(n[s]=i[s])}return n},writable:!0,configurable:!0}),function(){if("undefined"!=typeof navigator&&"undefined"!=typeof document){navigator.pointer=navigator.pointer||navigator.webkitPointer||navigator.mozPointer;var e=function(){var e=document.createEvent("CustomEvent");e.initCustomEvent("pointerlockchange",!0,!1,null),document.dispatchEvent(e)},t=function(){var e=document.createEvent("CustomEvent");e.initCustomEvent("pointerlockerror",!0,!1,null),document.dispatchEvent(e)};document.addEventListener("webkitpointerlockchange",e,!1),document.addEventListener("webkitpointerlocklost",e,!1),document.addEventListener("mozpointerlockchange",e,!1),document.addEventListener("mozpointerlocklost",e,!1),document.addEventListener("webkitpointerlockerror",t,!1),document.addEventListener("mozpointerlockerror",t,!1),Element.prototype.mozRequestPointerLock?Element.prototype.requestPointerLock=function(){this.mozRequestPointerLock()}:Element.prototype.requestPointerLock=Element.prototype.requestPointerLock||Element.prototype.webkitRequestPointerLock||Element.prototype.mozRequestPointerLock,!Element.prototype.requestPointerLock&&navigator.pointer&&(Element.prototype.requestPointerLock=function(){document.pointerLockElement=this,navigator.pointer.lock(this,e,t)}),document.exitPointerLock=document.exitPointerLock||document.webkitExitPointerLock||document.mozExitPointerLock,document.exitPointerLock||(document.exitPointerLock=function(){navigator.pointer&&(document.pointerLockElement=null,navigator.pointer.unlock())})}}(),function(){if("undefined"!=typeof window){for(var e=0,t=["ms","moz","webkit","o"],n=0;n<t.length&&!window.requestAnimationFrame;++n)window.requestAnimationFrame=window[t[n]+"RequestAnimationFrame"],window.cancelAnimationFrame=window[t[n]+"CancelAnimationFrame"]||window[t[n]+"CancelRequestAnimationFrame"];window.requestAnimationFrame||(window.requestAnimationFrame=function(t,n){var a=(new Date).getTime(),i=Math.max(0,16-(a-e)),s=window.setTimeout((function(){t(a+i)}),i);return e=a+i,s}),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(e){clearTimeout(e)})}}(),Gp(String,"endsWith",(function(e,t){return(void 0===t||t>this.length)&&(t=this.length),this.substring(t-e.length,t)===e})),Gp(String,"includes",(function(e,t){return"number"!=typeof t&&(t=0),!(t+e.length>this.length)&&-1!==this.indexOf(e,t)})),Gp(String,"startsWith",(function(e,t){return this.substr(!t||t<0?0:+t,e.length)===e}));const Hp=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array];for(const e of Hp)Gp(e,"fill",Array.prototype.fill),Gp(e,"join",Array.prototype.join);var Wp={};function jp(e,t){var n;Wp[e]=!0,void 0!==t&&(n=t,window.console&&window.console.error&&window.console.error(n))}var Xp=function e(t){var n=t.gl;this.ext=t,this.isAlive=!0,this.hasBeenBound=!1,this.elementArrayBuffer=null,this.attribs=new Array(t.maxVertexAttribs);for(var a=0;a<this.attribs.length;a++){var i=new e.VertexAttrib(n);this.attribs[a]=i}this.maxAttrib=0};(Xp.VertexAttrib=function(e){this.enabled=!1,this.buffer=null,this.size=4,this.type=e.FLOAT,this.normalized=!1,this.stride=16,this.offset=0,this.cached="",this.recache()}).prototype.recache=function(){this.cached=[this.size,this.type,this.normalized,this.stride,this.offset].join(":")};var Yp=function(e){var t=this;this.gl=e,function(e){var t=e.getError;e.getError=function(){do{(n=t.apply(e))!=e.NO_ERROR&&(Wp[n]=!0)}while(n!=e.NO_ERROR);for(var n in Wp)if(Wp[n])return delete Wp[n],parseInt(n);return e.NO_ERROR}}(e);var n=this.original={getParameter:e.getParameter,enableVertexAttribArray:e.enableVertexAttribArray,disableVertexAttribArray:e.disableVertexAttribArray,bindBuffer:e.bindBuffer,getVertexAttrib:e.getVertexAttrib,vertexAttribPointer:e.vertexAttribPointer};e.getParameter=function(e){return e==t.VERTEX_ARRAY_BINDING_OES?t.currentVertexArrayObject==t.defaultVertexArrayObject?null:t.currentVertexArrayObject:n.getParameter.apply(this,arguments)},e.enableVertexAttribArray=function(e){var a=t.currentVertexArrayObject;a.maxAttrib=Math.max(a.maxAttrib,e);var i=a.attribs[e];return i.enabled=!0,n.enableVertexAttribArray.apply(this,arguments)},e.disableVertexAttribArray=function(e){var a=t.currentVertexArrayObject;a.maxAttrib=Math.max(a.maxAttrib,e);var i=a.attribs[e];return i.enabled=!1,n.disableVertexAttribArray.apply(this,arguments)},e.bindBuffer=function(a,i){switch(a){case e.ARRAY_BUFFER:t.currentArrayBuffer=i;break;case e.ELEMENT_ARRAY_BUFFER:t.currentVertexArrayObject.elementArrayBuffer=i}return n.bindBuffer.apply(this,arguments)},e.getVertexAttrib=function(a,i){var s=t.currentVertexArrayObject,r=s.attribs[a];switch(i){case e.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:return r.buffer;case e.VERTEX_ATTRIB_ARRAY_ENABLED:return r.enabled;case e.VERTEX_ATTRIB_ARRAY_SIZE:return r.size;case e.VERTEX_ATTRIB_ARRAY_STRIDE:return r.stride;case e.VERTEX_ATTRIB_ARRAY_TYPE:return r.type;case e.VERTEX_ATTRIB_ARRAY_NORMALIZED:return r.normalized;default:return n.getVertexAttrib.apply(this,arguments)}},e.vertexAttribPointer=function(e,a,i,s,r,o){var l=t.currentVertexArrayObject;l.maxAttrib=Math.max(l.maxAttrib,e);var c=l.attribs[e];return c.buffer=t.currentArrayBuffer,c.size=a,c.type=i,c.normalized=s,c.stride=r,c.offset=o,c.recache(),n.vertexAttribPointer.apply(this,arguments)},e.instrumentExtension&&e.instrumentExtension(this,"OES_vertex_array_object"),e.canvas.addEventListener("webglcontextrestored",(function(){var e;e="OESVertexArrayObject emulation library context restored",window.console&&window.console.log&&window.console.log(e),t.reset_()}),!0),this.reset_()};Yp.prototype.VERTEX_ARRAY_BINDING_OES=34229,Yp.prototype.reset_=function(){if(void 0!==this.vertexArrayObjects)for(var e=0;e<this.vertexArrayObjects.length;++e)this.vertexArrayObjects.isAlive=!1;var t=this.gl;this.maxVertexAttribs=t.getParameter(t.MAX_VERTEX_ATTRIBS),this.defaultVertexArrayObject=new Xp(this),this.currentVertexArrayObject=null,this.currentArrayBuffer=null,this.vertexArrayObjects=[this.defaultVertexArrayObject],this.bindVertexArrayOES(null)},Yp.prototype.createVertexArrayOES=function(){var e=new Xp(this);return this.vertexArrayObjects.push(e),e},Yp.prototype.deleteVertexArrayOES=function(e){e.isAlive=!1,this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(e),1),this.currentVertexArrayObject==e&&this.bindVertexArrayOES(null)},Yp.prototype.isVertexArrayOES=function(e){return!!(e&&e instanceof Xp&&e.hasBeenBound&&e.ext==this)},Yp.prototype.bindVertexArrayOES=function(e){var t=this.gl;if(!e||e.isAlive){var n=this.original,a=this.currentVertexArrayObject;this.currentVertexArrayObject=e||this.defaultVertexArrayObject,this.currentVertexArrayObject.hasBeenBound=!0;var i=this.currentVertexArrayObject;if(a!=i){a&&i.elementArrayBuffer==a.elementArrayBuffer||n.bindBuffer.call(t,t.ELEMENT_ARRAY_BUFFER,i.elementArrayBuffer);for(var s=this.currentArrayBuffer,r=Math.max(a?a.maxAttrib:0,i.maxAttrib),o=0;o<=r;o++){var l=i.attribs[o],c=a?a.attribs[o]:null;if(a&&l.enabled==c.enabled||(l.enabled?n.enableVertexAttribArray.call(t,o):n.disableVertexAttribArray.call(t,o)),l.enabled){var h=!1;a&&l.buffer==c.buffer||(s!=l.buffer&&(n.bindBuffer.call(t,t.ARRAY_BUFFER,l.buffer),s=l.buffer),h=!0),(h||l.cached!=c.cached)&&n.vertexAttribPointer.call(t,o,l.size,l.type,l.normalized,l.stride,l.offset)}}this.currentArrayBuffer!=s&&n.bindBuffer.call(t,t.ARRAY_BUFFER,this.currentArrayBuffer)}}else jp(t.INVALID_OPERATION,"bindVertexArrayOES: attempt to bind deleted arrayObject")};const qp=function(){const e={},t=["Array","Object","Function","Date","RegExp","Float32Array"];for(let n=0;n<t.length;n++)e["[object "+t[n]+"]"]=t[n].toLowerCase();return e}();function Kp(e){if(null===e)return"null";const t=typeof e;return"undefined"===t||"number"===t||"string"===t||"boolean"===t?t:qp[Object.prototype.toString.call(e)]}function Zp(e,t){for(const n in t){const a=t[n];"object"===Kp(a)?e[n]=Zp({},a):"array"===Kp(a)?e[n]=Zp([],a):e[n]=a}return e}function $p(e){return undefined!==e}class Qp{constructor(){this._callbacks={},this._callbackActive={}}initEventHandler(){this._callbacks={},this._callbackActive={}}_addCallback(e,t,n,a=!1){e&&"string"==typeof e&&t&&(this._callbacks[e]||(this._callbacks[e]=[]),this._callbackActive[e]&&this._callbackActive[e]===this._callbacks[e]&&(this._callbackActive[e]=this._callbackActive[e].slice()),this._callbacks[e].push({callback:t,scope:n||this,once:a}))}on(e,t,n){return this._addCallback(e,t,n,!1),this}off(e,t,n){if(e)this._callbackActive[e]&&this._callbackActive[e]===this._callbacks[e]&&(this._callbackActive[e]=this._callbackActive[e].slice());else for(const e in this._callbackActive)this._callbacks[e]&&this._callbacks[e]===this._callbackActive[e]&&(this._callbackActive[e]=this._callbackActive[e].slice());if(e)if(t){const a=this._callbacks[e];if(!a)return this;let i=a.length;for(let e=0;e<i;e++)a[e].callback===t&&(n&&a[e].scope!==n||(a[e--]=a[--i]));a.length=i}else this._callbacks[e]&&(this._callbacks[e]=[]);else this._callbacks={};return this}fire(e,t,n,a,i,s,r,o,l){if(!e||!this._callbacks[e])return this;let c;this._callbackActive[e]?(this._callbackActive[e]===this._callbacks[e]&&(this._callbackActive[e]=this._callbackActive[e].slice()),c=this._callbacks[e].slice()):this._callbackActive[e]=this._callbacks[e];for(let h=0;(c||this._callbackActive[e])&&h<(c||this._callbackActive[e]).length;h++){const d=(c||this._callbackActive[e])[h];if(d.callback.call(d.scope,t,n,a,i,s,r,o,l),d.once){const t=this._callbacks[e],n=t?t.indexOf(d):-1;-1!==n&&(this._callbackActive[e]===t&&(this._callbackActive[e]=this._callbackActive[e].slice()),this._callbacks[e].splice(n,1))}}return c||(this._callbackActive[e]=null),this}once(e,t,n){return this._addCallback(e,t,n,!0),this}hasEvent(e){return this._callbacks[e]&&0!==this._callbacks[e].length||!1}}const Jp={attach:function(e){const t=Jp;return e._addCallback=t._addCallback,e.on=t.on,e.off=t.off,e.fire=t.fire,e.once=t.once,e.hasEvent=t.hasEvent,e._callbacks={},e._callbackActive={},e},_addCallback:Qp.prototype._addCallback,on:Qp.prototype.on,off:Qp.prototype.off,fire:Qp.prototype.fire,once:Qp.prototype.once,hasEvent:Qp.prototype.hasEvent},eu=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(function(e){const t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)}))},tu={delimiter:"/",join:function(){const e=arguments.length;let t=arguments[0];for(let n=0;n<e-1;++n){const e=arguments[n],a=arguments[n+1];if(!$p(e)||!$p(a))throw new Error("undefined argument to pc.path.join");a[0]!==tu.delimiter?e&&a&&e[e.length-1]!==tu.delimiter&&a[0]!==tu.delimiter?t+=tu.delimiter+a:t+=a:t=a}return t},normalize:function(e){const t=e.startsWith(tu.delimiter),n=e.endsWith(tu.delimiter),a=e.split("/");let i="",s=[];for(let e=0;e<a.length;e++)""!==a[e]&&"."!==a[e]&&(".."===a[e]&&s.length>0?s=s.slice(0,s.length-2):(e>0&&s.push(tu.delimiter),s.push(a[e])));return i=s.join(""),t||i[0]!==tu.delimiter||(i=i.slice(1)),n&&i[i.length-1]!==tu.delimiter&&(i+=tu.delimiter),i},split:function(e){const t=e.split(tu.delimiter),n=t.slice(t.length-1)[0];return[t.slice(0,t.length-1).join(tu.delimiter),n]},getBasename:function(e){return tu.split(e)[1]},getDirectory:function(e){const t=e.split(tu.delimiter);return t.slice(0,t.length-1).join(tu.delimiter)},getExtension:function(e){const t=e.split("?")[0].split(".").pop();return t!==e?"."+t:""},isRelativePath:function(e){return"/"!==e.charAt(0)&&null===e.match(/:\/\//)},extractPath:function(e){let t="";const n=e.split("/");let a=0;if(n.length>1)if(tu.isRelativePath(e))if("."===n[0])for(a=0;a<n.length-1;++a)t+=0===a?n[a]:"/"+n[a];else if(".."===n[0])for(a=0;a<n.length-1;++a)t+=0===a?n[a]:"/"+n[a];else for(t=".",a=0;a<n.length-1;++a)t+="/"+n[a];else for(a=0;a<n.length-1;++a)t+=0===a?n[a]:"/"+n[a];return t}};let nu=!1,au=!1,iu=!1,su=!1,ru=!1,ou=!1,lu=!1,cu=!1,hu=!1,du=!1;if("undefined"!=typeof navigator){const e=navigator.userAgent;/(windows|mac os|linux|cros)/i.test(e)&&(nu=!0),/xbox/i.test(e)&&(su=!0),/(windows phone|iemobile|wpdesktop)/i.test(e)?(nu=!1,au=!0,iu=!0):/android/i.test(e)?(nu=!1,au=!0,ru=!0):/ip([ao]d|hone)/i.test(e)&&(nu=!1,au=!0,ou=!0),"undefined"!=typeof window&&(lu="ontouchstart"in window||"maxTouchPoints"in navigator&&navigator.maxTouchPoints>0),cu="getGamepads"in navigator,hu="undefined"!=typeof Worker;try{const e=Object.defineProperty({},"passive",{get:function(){return du=!0,!1}});window.addEventListener("testpassive",null,e),window.removeEventListener("testpassive",null,e)}catch(Fh){}}const pu="undefined"!=typeof window?"browser":"node",uu={environment:pu,global:"browser"===pu?window:global,browser:"browser"===pu,desktop:nu,mobile:au,ios:ou,android:ru,windows:iu,xbox:su,gamepads:cu,touch:lu,workers:hu,passiveEvents:du};function mu(e,t=0){const n=e.length;if(t<0||t>=n)return null;const a=e.charCodeAt(t);if(n>1&&a>=55296&&a<=56319){const n=e.charCodeAt(t+1);if(n>=56320&&n<=57343)return{code:1024*(a-55296)+n-56320+65536,long:!0}}return{code:a,long:!1}}function fu(e,t,n){if(!e)return!1;const a=mu(e);if(a){const e=a.code;return e>=t&&e<=n}return!1}function gu(e,t){if(t===e.length-1)return 1;if(fu(e[t],55296,56319)){const n=e.substring(t,t+2),a=e.substring(t+2,t+4);return fu(a,127995,127999)||fu(n,127462,127487)&&fu(a,127462,127487)?4:fu(a,65024,65039)?3:2}return fu(e[t+1],65024,65039)?2:1}const yu={ASCII_LOWERCASE:"abcdefghijklmnopqrstuvwxyz",ASCII_UPPERCASE:"ABCDEFGHIJKLMNOPQRSTUVWXYZ",ASCII_LETTERS:"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",format:function(e){for(let t=1;t<arguments.length;t++)e=e.replace("{"+(t-1)+"}",arguments[t]);return e},toBool:function(e,t=!1){if("true"===e)return!0;if(t){if("false"===e)return!1;throw new TypeError("Not a boolean string")}return!1},getCodePoint:function(e,t){const n=mu(e,t);return n&&n.code},getCodePoints:function(e){if("string"!=typeof e)throw new TypeError("Not a string");let t=0;const n=[];let a;for(;a=mu(e,t);)n.push(a.code),t+=a.long?2:1;return n},getSymbols:function(e){if("string"!=typeof e)throw new TypeError("Not a string");let t=0;const n=e.length,a=[];let i,s=0;for(;t<n;){if(s+=gu(e,t+s),i=e[t+s],fu(i,8400,8447)&&(i=e[t+s++]),fu(i,65024,65039)&&(i=e[t+s++]),i&&8205===i.charCodeAt(0)){i=e[t+s++];continue}const n=e.substring(t,t+s);a.push(n),t+=s,s=0}return a},fromCodePoint:function(){const e=[];let t,n,a;for(let i=0;i<arguments.length;++i)t=Number(arguments[i]),n=t-65536,a=t>65535?[55296+(n>>10),n%1024+56320]:[t],e.push(String.fromCharCode.apply(null,a));return e.join("")}};class bu{constructor(){this._list=[],this._index={}}push(e,t){if(this._index[e])throw Error("Key already in index "+e);const n=this._list.push(t)-1;this._index[e]=n}has(e){return void 0!==this._index[e]}get(e){const t=this._index[e];return void 0!==t?this._list[t]:null}remove(e){const t=this._index[e];if(void 0!==t){for(e in this._list.splice(t,1),delete this._index[e],this._index){const n=this._index[e];n>t&&(this._index[e]=n-1)}return!0}return!1}list(){return this._list}clear(){this._list.length=0;for(const e in this._index)delete this._index[e]}}class vu{constructor(e){this.arraybuffer=e,this.dataView=new DataView(e),this.offset=0,this.stack=[]}get remainingBytes(){return this.dataView.byteLength-this.offset}reset(e=0){this.offset=e}skip(e){this.offset+=e}align(e){this.offset=this.offset+e-1&~(e-1)}_inc(e){return this.offset+=e,this.offset-e}readChar(){return String.fromCharCode(this.dataView.getUint8(this.offset++))}readChars(e){let t="";for(let n=0;n<e;++n)t+=this.readChar();return t}readU8(){return this.dataView.getUint8(this.offset++)}readU16(){return this.dataView.getUint16(this._inc(2),!0)}readU32(){return this.dataView.getUint32(this._inc(4),!0)}readU64(){return this.readU32()+2**32*this.readU32()}readU32be(){return this.dataView.getUint32(this._inc(4),!1)}readArray(e){for(let t=0;t<e.length;++t)e[t]=this.readU8()}readLine(){const e=this.dataView;let t="";for(;!(this.offset>=e.byteLength);){const e=String.fromCharCode(this.readU8());if("\n"===e)break;t+=e}return t}}class _u{constructor(e){this.items=[],this.length=0,this.loopIndex=-1,this._sortBy=e.sortBy,this._sortHandler=this._doSort.bind(this)}_binarySearch(e){let t=0,n=this.items.length-1;const a=e[this._sortBy];let i,s;for(;t<=n;)i=Math.floor((t+n)/2),s=this.items[i][this._sortBy],s<=a?t=i+1:s>a&&(n=i-1);return t}_doSort(e,t){const n=this._sortBy;return e[n]-t[n]}insert(e){const t=this._binarySearch(e);this.items.splice(t,0,e),this.length++,this.loopIndex>=t&&this.loopIndex++}append(e){this.items.push(e),this.length++}remove(e){const t=this.items.indexOf(e);t<0||(this.items.splice(t,1),this.length--,this.loopIndex>=t&&this.loopIndex--)}sort(){const e=this.loopIndex>=0?this.items[this.loopIndex]:null;this.items.sort(this._sortHandler),null!==e&&(this.loopIndex=this.items.indexOf(e))}}class wu extends Qp{constructor(e){super(),this._index={},this._list=[],this._parent=e}add(){let e=!1;const t=this._processArguments(arguments,!0);if(!t.length)return e;for(let n=0;n<t.length;n++)this._index[t[n]]||(e=!0,this._index[t[n]]=!0,this._list.push(t[n]),this.fire("add",t[n],this._parent));return e&&this.fire("change",this._parent),e}remove(){let e=!1;if(!this._list.length)return e;const t=this._processArguments(arguments,!0);if(!t.length)return e;for(let n=0;n<t.length;n++)this._index[t[n]]&&(e=!0,delete this._index[t[n]],this._list.splice(this._list.indexOf(t[n]),1),this.fire("remove",t[n],this._parent));return e&&this.fire("change",this._parent),e}clear(){if(!this._list.length)return;const e=this._list.slice(0);this._list=[],this._index={};for(let t=0;t<e.length;t++)this.fire("remove",e[t],this._parent);this.fire("change",this._parent)}has(){return!!this._list.length&&this._has(this._processArguments(arguments))}_has(e){if(!this._list.length||!e.length)return!1;for(let t=0;t<e.length;t++)if(1===e[t].length){if(this._index[e[t][0]])return!0}else{let n=!0;for(let a=0;a<e[t].length;a++)if(!this._index[e[t][a]]){n=!1;break}if(n)return!0}return!1}list(){return this._list.slice(0)}_processArguments(e,t){const n=[];let a=[];if(!e||!e.length)return n;for(let i=0;i<e.length;i++)if(e[i]instanceof Array){t||(a=[]);for(let s=0;s<e[i].length;s++)"string"==typeof e[i][s]&&(t?n.push(e[i][s]):a.push(e[i][s]));!t&&a.length&&n.push(a)}else"string"==typeof e[i]&&(t?n.push(e[i]):n.push([e[i]]));return n}get size(){return this._list.length}}const xu="undefined"!=typeof window&&window.performance&&window.performance.now&&window.performance.timing?function(){return window.performance.now()}:Date.now,Cu=/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;class Tu{constructor(e){const t=e.match(Cu);this.scheme=t[2],this.authority=t[4],this.path=t[5],this.query=t[7],this.fragment=t[9]}toString(){let e="";return this.scheme&&(e+=this.scheme+":"),this.authority&&(e+="//"+this.authority),e+=this.path,this.query&&(e+="?"+this.query),this.fragment&&(e+="#"+this.fragment),e}getQuery(){const e={};if(this.query){const t=decodeURIComponent(this.query).split("&");for(const n of t){const t=n.split("=");e[t[0]]=t[1]}}return e}setQuery(e){let t="";for(const n in e)e.hasOwnProperty(n)&&(""!==t&&(t+="&"),t+=encodeURIComponent(n)+"="+encodeURIComponent(e[n]));this.query=t}}const Eu={DEG_TO_RAD:Math.PI/180,RAD_TO_DEG:180/Math.PI,clamp:function(e,t,n){return e>=n?n:e<=t?t:e},intToBytes24:function(e){return[e>>16&255,e>>8&255,255&e]},intToBytes32:function(e){return[e>>24&255,e>>16&255,e>>8&255,255&e]},bytesToInt24:function(e,t,n){return e.length&&(n=e[2],t=e[1],e=e[0]),e<<16|t<<8|n},bytesToInt32:function(e,t,n,a){return e.length&&(a=e[3],n=e[2],t=e[1],e=e[0]),(e<<24|t<<16|n<<8|a)>>>0},lerp:function(e,t,n){return e+(t-e)*Eu.clamp(n,0,1)},lerpAngle:function(e,t,n){return t-e>180&&(t-=360),t-e<-180&&(t+=360),Eu.lerp(e,t,Eu.clamp(n,0,1))},powerOfTwo:function(e){return 0!==e&&!(e&e-1)},nextPowerOfTwo:function(e){return e--,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,e|=e>>16,++e},random:function(e,t){const n=t-e;return Math.random()*n+e},smoothstep:function(e,t,n){return n<=e?0:n>=t?1:(n=(n-e)/(t-e))*n*(3-2*n)},smootherstep:function(e,t,n){return n<=e?0:n>=t?1:(n=(n-e)/(t-e))*n*n*(n*(6*n-15)+10)},roundUp:function(e,t){return 0===t?e:Math.ceil(e/t)*t},between:function(e,t,n,a){const i=Math.min(t,n),s=Math.max(t,n);return a?e>=i&&e<=s:e>i&&e<s}};class Su{get(e,t,n){return"function"==typeof t&&(n=t,t={}),this.request("GET",e,t,n)}post(e,t,n,a){return"function"==typeof n&&(a=n,n={}),n.postdata=t,this.request("POST",e,n,a)}put(e,t,n,a){return"function"==typeof n&&(a=n,n={}),n.postdata=t,this.request("PUT",e,n,a)}del(e,t,n){return"function"==typeof t&&(n=t,t={}),this.request("DELETE",e,t,n)}request(e,t,n,a){let i,s,r,o=!1;if("function"==typeof n&&(a=n,n={}),n.retry&&(n=Object.assign({retries:0,maxRetries:5},n)),n.callback=a,null==n.async&&(n.async=!0),null==n.headers&&(n.headers={}),null!=n.postdata)if(n.postdata instanceof Document)r=n.postdata;else if(n.postdata instanceof FormData)r=n.postdata;else if(n.postdata instanceof Object){let e=n.headers["Content-Type"];switch(void 0===e&&(n.headers["Content-Type"]=Su.ContentType.FORM_URLENCODED,e=n.headers["Content-Type"]),e){case Su.ContentType.FORM_URLENCODED:{r="";let e=!0;for(const t in n.postdata)if(n.postdata.hasOwnProperty(t)){e?e=!1:r+="&";r+=`${encodeURIComponent(t)}=${encodeURIComponent(n.postdata[t])}`}break}default:case Su.ContentType.JSON:null==e&&(n.headers["Content-Type"]=Su.ContentType.JSON),r=JSON.stringify(n.postdata)}}else r=n.postdata;if(!1===n.cache){const e=xu();i=new Tu(t),i.query?i.query=i.query+"&ts="+e:i.query="ts="+e,t=i.toString()}n.query&&(i=new Tu(t),s=Zp(i.getQuery(),n.query),i.setQuery(s),t=i.toString());const l=new XMLHttpRequest;l.open(e,t,n.async),l.withCredentials=void 0!==n.withCredentials&&n.withCredentials,l.responseType=n.responseType||this._guessResponseType(t);for(const e in n.headers)n.headers.hasOwnProperty(e)&&l.setRequestHeader(e,n.headers[e]);l.onreadystatechange=()=>{this._onReadyStateChange(e,t,n,l)},l.onerror=()=>{this._onError(e,t,n,l),o=!0};try{l.send(r)}catch(e){o||n.error(l.status,l,e)}return l}_guessResponseType(e){const t=new Tu(e),n=tu.getExtension(t.path);return Su.binaryExtensions.indexOf(n)>=0?Su.ResponseType.ARRAY_BUFFER:".xml"===n?Su.ResponseType.DOCUMENT:Su.ResponseType.TEXT}_isBinaryContentType(e){return[Su.ContentType.MP4,Su.ContentType.WAV,Su.ContentType.OGG,Su.ContentType.MP3,Su.ContentType.BIN,Su.ContentType.DDS,Su.ContentType.BASIS,Su.ContentType.GLB].indexOf(e)>=0}_onReadyStateChange(e,t,n,a){if(4===a.readyState)switch(a.status){case 0:a.responseURL&&a.responseURL.startsWith("file:///")?this._onSuccess(e,t,n,a):this._onError(e,t,n,a);break;case 200:case 201:case 206:case 304:this._onSuccess(e,t,n,a);break;default:this._onError(e,t,n,a)}}_onSuccess(e,t,n,a){let i,s;const r=a.getResponseHeader("Content-Type");if(r){s=r.split(";")[0].trim()}try{i=s===Su.ContentType.JSON||t.split("?")[0].endsWith(".json")?JSON.parse(a.responseText):this._isBinaryContentType(s)||a.responseType===Su.ResponseType.ARRAY_BUFFER||a.responseType===Su.ResponseType.BLOB||a.responseType===Su.ResponseType.JSON?a.response:a.responseType===Su.ResponseType.DOCUMENT||s===Su.ContentType.XML?a.responseXML:a.responseText,n.callback(null,i)}catch(e){n.callback(e)}}_onError(e,t,n,a){if(!n.retrying)if(n.retry&&n.retries<n.maxRetries){n.retries++,n.retrying=!0;const i=Eu.clamp(Math.pow(2,n.retries)*Su.retryDelay,0,n.maxRetryDelay||5e3);console.log(`${e}: ${t} - Error ${a.status}. Retrying in ${i} ms`),setTimeout((()=>{n.retrying=!1,this.request(e,t,n,n.callback)}),i)}else n.callback(0===a.status?"Network error":a.status,null)}}Su.ContentType={FORM_URLENCODED:"application/x-www-form-urlencoded",GIF:"image/gif",JPEG:"image/jpeg",DDS:"image/dds",JSON:"application/json",PNG:"image/png",TEXT:"text/plain",XML:"application/xml",WAV:"audio/x-wav",OGG:"audio/ogg",MP3:"audio/mpeg",MP4:"audio/mp4",AAC:"audio/aac",BIN:"application/octet-stream",BASIS:"image/basis",GLB:"model/gltf-binary"},Su.ResponseType={TEXT:"text",ARRAY_BUFFER:"arraybuffer",BLOB:"blob",DOCUMENT:"document",JSON:"json"},Su.binaryExtensions=[".model",".wav",".ogg",".mp3",".mp4",".m4a",".aac",".dds",".basis",".glb"],Su.retryDelay=100;const Au=new Su;class Mu{constructor(e=0,t=0,n=0,a=1){const i=e.length;3===i||4===i?(this.r=e[0],this.g=e[1],this.b=e[2],this.a=void 0!==e[3]?e[3]:1):(this.r=e,this.g=t,this.b=n,this.a=a)}clone(){return new Mu(this.r,this.g,this.b,this.a)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a,this}equals(e){return this.r===e.r&&this.g===e.g&&this.b===e.b&&this.a===e.a}set(e,t,n,a=1){return this.r=e,this.g=t,this.b=n,this.a=a,this}lerp(e,t,n){return this.r=e.r+n*(t.r-e.r),this.g=e.g+n*(t.g-e.g),this.b=e.b+n*(t.b-e.b),this.a=e.a+n*(t.a-e.a),this}fromString(e){const t=parseInt(e.replace("#","0x"),16);let n;return e.length>7?n=Eu.intToBytes32(t):(n=Eu.intToBytes24(t),n[3]=255),this.set(n[0]/255,n[1]/255,n[2]/255,n[3]/255),this}toString(e){let t="#"+((1<<24)+(Math.round(255*this.r)<<16)+(Math.round(255*this.g)<<8)+Math.round(255*this.b)).toString(16).slice(1);if(!0===e){const e=Math.round(255*this.a).toString(16);this.a<16/255?t+="0"+e:t+=e}return t}}Mu.BLACK=Object.freeze(new Mu(0,0,0,1)),Mu.BLUE=Object.freeze(new Mu(0,0,1,1)),Mu.CYAN=Object.freeze(new Mu(0,1,1,1)),Mu.GRAY=Object.freeze(new Mu(.5,.5,.5,1)),Mu.GREEN=Object.freeze(new Mu(0,1,0,1)),Mu.MAGENTA=Object.freeze(new Mu(1,0,1,1)),Mu.RED=Object.freeze(new Mu(1,0,0,1)),Mu.WHITE=Object.freeze(new Mu(1,1,1,1)),Mu.YELLOW=Object.freeze(new Mu(1,1,0,1));class Lu{constructor(e,t=0){this._curve=e,this._left=-1/0,this._right=1/0,this._recip=0,this._p0=0,this._p1=0,this._m0=0,this._m1=0,this._reset(t)}evaluate(e,t=!1){let n;(t||e<this._left||e>=this._right)&&this._reset(e);const a=this._curve.type;if(5===a)n=this._p0;else{const t=0===this._recip?0:(e-this._left)*this._recip;n=0===a?Eu.lerp(this._p0,this._p1,t):1===a?Eu.lerp(this._p0,this._p1,t*t*(3-2*t)):this._evaluateHermite(this._p0,this._p1,this._m0,this._m1,t)}return n}_reset(e){const t=this._curve.keys,n=t.length;if(n)if(e<t[0][0])this._left=-1/0,this._right=t[0][0],this._recip=0,this._p0=this._p1=t[0][1],this._m0=this._m1=0;else if(e>=t[n-1][0])this._left=t[n-1][0],this._right=1/0,this._recip=0,this._p0=this._p1=t[n-1][1],this._m0=this._m1=0;else{let n=0;for(;e>=t[n+1][0];)n++;this._left=t[n][0],this._right=t[n+1][0];const a=1/(this._right-this._left);this._recip=isFinite(a)?a:0,this._p0=t[n][1],this._p1=t[n+1][1],this._isHermite()&&this._calcTangents(t,n)}else this._left=-1/0,this._right=1/0,this._recip=0,this._p0=this._p1=this._m0=this._m1=0}_isHermite(){return 2===this._curve.type||3===this._curve.type||4===this._curve.type}_calcTangents(e,t){let n;const a=e[t],i=e[t+1];let s;if(n=0===t?[e[0][0]+(e[0][0]-e[1][0]),e[0][1]+(e[0][1]-e[1][1])]:e[t-1],s=t===e.length-2?[e[t+1][0]+(e[t+1][0]-e[t][0]),e[t+1][1]+(e[t+1][1]-e[t][1])]:e[t+2],4===this._curve.type){const e=2*(i[0]-a[0])/(i[0]-n[0]),t=2*(i[0]-a[0])/(s[0]-a[0]);this._m0=this._curve.tension*(isFinite(e)?e:0)*(i[1]-n[1]),this._m1=this._curve.tension*(isFinite(t)?t:0)*(s[1]-a[1])}else{const e=(i[0]-a[0])/(a[0]-n[0]),t=(i[0]-a[0])/(s[0]-i[0]),r=a[1]+(n[1]-a[1])*(isFinite(e)?e:0),o=i[1]+(s[1]-i[1])*(isFinite(t)?t:0),l=2===this._curve.type?.5:this._curve.tension;this._m0=l*(i[1]-r),this._m1=l*(o-a[1])}}_evaluateHermite(e,t,n,a,i){const s=i*i,r=i+i,o=1-i,l=o*o;return e*((1+r)*l)+n*(i*l)+t*(s*(3-r))+a*(s*(i-1))}}class Ru{constructor(e){if(this.keys=[],this.type=1,this.tension=.5,this._eval=new Lu(this),e)for(let t=0;t<e.length-1;t+=2)this.keys.push([e[t],e[t+1]]);this.sort()}get length(){return this.keys.length}add(e,t){const n=this.keys,a=n.length;let i=0;for(;i<a&&!(n[i][0]>e);i++);const s=[e,t];return this.keys.splice(i,0,s),s}get(e){return this.keys[e]}sort(){this.keys.sort((function(e,t){return e[0]-t[0]}))}value(e){return this._eval.evaluate(e,!0)}closest(e){const t=this.keys,n=t.length;let a=2,i=null;for(let s=0;s<n;s++){const n=Math.abs(e-t[s][0]);if(!(a>=n))break;a=n,i=t[s]}return i}clone(){const e=new Ru;return e.keys=Zp(e.keys,this.keys),e.type=this.type,e.tension=this.tension,e}quantize(e){e=Math.max(e,2);const t=new Float32Array(e),n=1/(e-1);t[0]=this._eval.evaluate(0,!0);for(let a=1;a<e;a++)t[a]=this._eval.evaluate(n*a);return t}quantizeClamped(e,t,n){const a=this.quantize(e);for(let e=0;e<a.length;++e)a[e]=Math.min(n,Math.max(t,a[e]));return a}}class Iu{constructor(){if(this.curves=[],this._type=1,arguments.length>1)for(let e=0;e<arguments.length;e++)this.curves.push(new Ru(arguments[e]));else if(0===arguments.length)this.curves.push(new Ru);else{const e=arguments[0];if("number"==typeof e)for(let t=0;t<e;t++)this.curves.push(new Ru);else for(let t=0;t<e.length;t++)this.curves.push(new Ru(e[t]))}}get length(){return this.curves.length}set type(e){this._type=e;for(let t=0;t<this.curves.length;t++)this.curves[t].type=e}get type(){return this._type}get(e){return this.curves[e]}value(e,t=[]){const n=this.curves.length;t.length=n;for(let a=0;a<n;a++)t[a]=this.curves[a].value(e);return t}clone(){const e=new Iu;e.curves=[];for(let t=0;t<this.curves.length;t++)e.curves.push(this.curves[t].clone());return e._type=this._type,e}quantize(e){e=Math.max(e,2);const t=this.curves.length,n=new Float32Array(e*t),a=1/(e-1);for(let i=0;i<t;i++){const s=new Lu(this.curves[i]);for(let r=0;r<e;r++)n[r*t+i]=s.evaluate(a*r)}return n}quantizeClamped(e,t,n){const a=this.quantize(e);for(let e=0;e<a.length;++e)a[e]=Math.min(n,Math.max(t,a[e]));return a}}class Pu{constructor(e=0,t=0,n=0){3===e.length?(this.x=e[0],this.y=e[1],this.z=e[2]):(this.x=e,this.y=t,this.z=n)}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}add2(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}clone(){return new Pu(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}cross(e,t){const n=e.x,a=e.y,i=e.z,s=t.x,r=t.y,o=t.z;return this.x=a*o-r*i,this.y=i*s-o*n,this.z=n*r-s*a,this}distance(e){const t=this.x-e.x,n=this.y-e.y,a=this.z-e.z;return Math.sqrt(t*t+n*n+a*a)}div(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}div2(e,t){return this.x=e.x/t.x,this.y=e.y/t.y,this.z=e.z/t.z,this}divScalar(e){return this.x/=e,this.y/=e,this.z/=e,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}equals(e){return this.x===e.x&&this.y===e.y&&this.z===e.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}lerp(e,t,n){return this.x=e.x+n*(t.x-e.x),this.y=e.y+n*(t.y-e.y),this.z=e.z+n*(t.z-e.z),this}mul(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}mul2(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}mulScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}normalize(){const e=this.x*this.x+this.y*this.y+this.z*this.z;if(e>0){const t=1/Math.sqrt(e);this.x*=t,this.y*=t,this.z*=t}return this}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}min(e){return e.x<this.x&&(this.x=e.x),e.y<this.y&&(this.y=e.y),e.z<this.z&&(this.z=e.z),this}max(e){return e.x>this.x&&(this.x=e.x),e.y>this.y&&(this.y=e.y),e.z>this.z&&(this.z=e.z),this}project(e){const t=(this.x*e.x+this.y*e.y+this.z*e.z)/(e.x*e.x+e.y*e.y+e.z*e.z);return this.x=e.x*t,this.y=e.y*t,this.z=e.z*t,this}set(e,t,n){return this.x=e,this.y=t,this.z=n,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}sub2(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}toString(){return`[${this.x}, ${this.y}, ${this.z}]`}}Pu.ZERO=Object.freeze(new Pu(0,0,0)),Pu.ONE=Object.freeze(new Pu(1,1,1)),Pu.UP=Object.freeze(new Pu(0,1,0)),Pu.DOWN=Object.freeze(new Pu(0,-1,0)),Pu.RIGHT=Object.freeze(new Pu(1,0,0)),Pu.LEFT=Object.freeze(new Pu(-1,0,0)),Pu.FORWARD=Object.freeze(new Pu(0,0,-1)),Pu.BACK=Object.freeze(new Pu(0,0,1));class ku{constructor(){const e=new Float32Array(9);e[0]=e[4]=e[8]=1,this.data=e}clone(){return(new ku).copy(this)}copy(e){const t=e.data,n=this.data;return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],this}set(e){const t=this.data;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],this}equals(e){const t=this.data,n=e.data;return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]}isIdentity(){const e=this.data;return 1===e[0]&&0===e[1]&&0===e[2]&&0===e[3]&&1===e[4]&&0===e[5]&&0===e[6]&&0===e[7]&&1===e[8]}setIdentity(){const e=this.data;return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,this}toString(){return"["+this.data.join(", ")+"]"}transpose(){const e=this.data;let t;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}setFromMat4(e){const t=e.data,n=this.data;return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[4],n[4]=t[5],n[5]=t[6],n[6]=t[8],n[7]=t[9],n[8]=t[10],this}transformVector(e,t=new Pu){const n=this.data,a=e.x,i=e.y,s=e.z;return t.x=a*n[0]+i*n[3]+s*n[6],t.y=a*n[1]+i*n[4]+s*n[7],t.z=a*n[2]+i*n[5]+s*n[8],t}}ku.IDENTITY=Object.freeze(new ku),ku.ZERO=Object.freeze((new ku).set([0,0,0,0,0,0,0,0,0]));class Du{constructor(e=0,t=0){2===e.length?(this.x=e[0],this.y=e[1]):(this.x=e,this.y=t)}add(e){return this.x+=e.x,this.y+=e.y,this}add2(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScalar(e){return this.x+=e,this.y+=e,this}clone(){return new Du(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}cross(e){return this.x*e.y-this.y*e.x}distance(e){const t=this.x-e.x,n=this.y-e.y;return Math.sqrt(t*t+n*n)}div(e){return this.x/=e.x,this.y/=e.y,this}div2(e,t){return this.x=e.x/t.x,this.y=e.y/t.y,this}divScalar(e){return this.x/=e,this.y/=e,this}dot(e){return this.x*e.x+this.y*e.y}equals(e){return this.x===e.x&&this.y===e.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSq(){return this.x*this.x+this.y*this.y}lerp(e,t,n){return this.x=e.x+n*(t.x-e.x),this.y=e.y+n*(t.y-e.y),this}mul(e){return this.x*=e.x,this.y*=e.y,this}mul2(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this}mulScalar(e){return this.x*=e,this.y*=e,this}normalize(){const e=this.x*this.x+this.y*this.y;if(e>0){const t=1/Math.sqrt(e);this.x*=t,this.y*=t}return this}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}min(e){return e.x<this.x&&(this.x=e.x),e.y<this.y&&(this.y=e.y),this}max(e){return e.x>this.x&&(this.x=e.x),e.y>this.y&&(this.y=e.y),this}set(e,t){return this.x=e,this.y=t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}sub2(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}subScalar(e){return this.x-=e,this.y-=e,this}toString(){return`[${this.x}, ${this.y}]`}static angleRad(e,t){return Math.atan2(e.x*t.y-e.y*t.x,e.x*t.x+e.y*t.y)}}Du.ZERO=Object.freeze(new Du(0,0)),Du.ONE=Object.freeze(new Du(1,1)),Du.UP=Object.freeze(new Du(0,1)),Du.DOWN=Object.freeze(new Du(0,-1)),Du.RIGHT=Object.freeze(new Du(1,0)),Du.LEFT=Object.freeze(new Du(-1,0));class Ou{constructor(e=0,t=0,n=0,a=0){4===e.length?(this.x=e[0],this.y=e[1],this.z=e[2],this.w=e[3]):(this.x=e,this.y=t,this.z=n,this.w=a)}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}add2(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}clone(){return new Ou(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}div(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this}div2(e,t){return this.x=e.x/t.x,this.y=e.y/t.y,this.z=e.z/t.z,this.w=e.w/t.w,this}divScalar(e){return this.x/=e,this.y/=e,this.z/=e,this.w/=e,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}equals(e){return this.x===e.x&&this.y===e.y&&this.z===e.z&&this.w===e.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}lerp(e,t,n){return this.x=e.x+n*(t.x-e.x),this.y=e.y+n*(t.y-e.y),this.z=e.z+n*(t.z-e.z),this.w=e.w+n*(t.w-e.w),this}mul(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}mul2(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this.w=e.w*t.w,this}mulScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}normalize(){const e=this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;if(e>0){const t=1/Math.sqrt(e);this.x*=t,this.y*=t,this.z*=t,this.w*=t}return this}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}min(e){return e.x<this.x&&(this.x=e.x),e.y<this.y&&(this.y=e.y),e.z<this.z&&(this.z=e.z),e.w<this.w&&(this.w=e.w),this}max(e){return e.x>this.x&&(this.x=e.x),e.y>this.y&&(this.y=e.y),e.z>this.z&&(this.z=e.z),e.w>this.w&&(this.w=e.w),this}set(e,t,n,a){return this.x=e,this.y=t,this.z=n,this.w=a,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}sub2(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}toString(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`}}Ou.ZERO=Object.freeze(new Ou(0,0,0,0)),Ou.ONE=Object.freeze(new Ou(1,1,1,1));const Fu=new Du,Nu=new Pu,Vu=new Pu,Bu=new Pu,Uu=new Pu;class zu{constructor(){const e=new Float32Array(16);e[0]=e[5]=e[10]=e[15]=1,this.data=e}static _getPerspectiveHalfSize(e,t,n,a,i){i?(e.x=a*Math.tan(t*Math.PI/360),e.y=e.x/n):(e.y=a*Math.tan(t*Math.PI/360),e.x=e.y*n)}add2(e,t){const n=e.data,a=t.data,i=this.data;return i[0]=n[0]+a[0],i[1]=n[1]+a[1],i[2]=n[2]+a[2],i[3]=n[3]+a[3],i[4]=n[4]+a[4],i[5]=n[5]+a[5],i[6]=n[6]+a[6],i[7]=n[7]+a[7],i[8]=n[8]+a[8],i[9]=n[9]+a[9],i[10]=n[10]+a[10],i[11]=n[11]+a[11],i[12]=n[12]+a[12],i[13]=n[13]+a[13],i[14]=n[14]+a[14],i[15]=n[15]+a[15],this}add(e){return this.add2(this,e)}clone(){return(new zu).copy(this)}copy(e){const t=e.data,n=this.data;return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],this}equals(e){const t=this.data,n=e.data;return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]&&t[9]===n[9]&&t[10]===n[10]&&t[11]===n[11]&&t[12]===n[12]&&t[13]===n[13]&&t[14]===n[14]&&t[15]===n[15]}isIdentity(){const e=this.data;return 1===e[0]&&0===e[1]&&0===e[2]&&0===e[3]&&0===e[4]&&1===e[5]&&0===e[6]&&0===e[7]&&0===e[8]&&0===e[9]&&1===e[10]&&0===e[11]&&0===e[12]&&0===e[13]&&0===e[14]&&1===e[15]}mul2(e,t){const n=e.data,a=t.data,i=this.data,s=n[0],r=n[1],o=n[2],l=n[3],c=n[4],h=n[5],d=n[6],p=n[7],u=n[8],m=n[9],f=n[10],g=n[11],y=n[12],b=n[13],v=n[14],_=n[15];let w,x,C,T;return w=a[0],x=a[1],C=a[2],T=a[3],i[0]=s*w+c*x+u*C+y*T,i[1]=r*w+h*x+m*C+b*T,i[2]=o*w+d*x+f*C+v*T,i[3]=l*w+p*x+g*C+_*T,w=a[4],x=a[5],C=a[6],T=a[7],i[4]=s*w+c*x+u*C+y*T,i[5]=r*w+h*x+m*C+b*T,i[6]=o*w+d*x+f*C+v*T,i[7]=l*w+p*x+g*C+_*T,w=a[8],x=a[9],C=a[10],T=a[11],i[8]=s*w+c*x+u*C+y*T,i[9]=r*w+h*x+m*C+b*T,i[10]=o*w+d*x+f*C+v*T,i[11]=l*w+p*x+g*C+_*T,w=a[12],x=a[13],C=a[14],T=a[15],i[12]=s*w+c*x+u*C+y*T,i[13]=r*w+h*x+m*C+b*T,i[14]=o*w+d*x+f*C+v*T,i[15]=l*w+p*x+g*C+_*T,this}mulAffine2(e,t){const n=e.data,a=t.data,i=this.data,s=n[0],r=n[1],o=n[2],l=n[4],c=n[5],h=n[6],d=n[8],p=n[9],u=n[10],m=n[12],f=n[13],g=n[14];let y,b,v;return y=a[0],b=a[1],v=a[2],i[0]=s*y+l*b+d*v,i[1]=r*y+c*b+p*v,i[2]=o*y+h*b+u*v,i[3]=0,y=a[4],b=a[5],v=a[6],i[4]=s*y+l*b+d*v,i[5]=r*y+c*b+p*v,i[6]=o*y+h*b+u*v,i[7]=0,y=a[8],b=a[9],v=a[10],i[8]=s*y+l*b+d*v,i[9]=r*y+c*b+p*v,i[10]=o*y+h*b+u*v,i[11]=0,y=a[12],b=a[13],v=a[14],i[12]=s*y+l*b+d*v+m,i[13]=r*y+c*b+p*v+f,i[14]=o*y+h*b+u*v+g,i[15]=1,this}mul(e){return this.mul2(this,e)}transformPoint(e,t=new Pu){const n=this.data,a=e.x,i=e.y,s=e.z;return t.x=a*n[0]+i*n[4]+s*n[8]+n[12],t.y=a*n[1]+i*n[5]+s*n[9]+n[13],t.z=a*n[2]+i*n[6]+s*n[10]+n[14],t}transformVector(e,t=new Pu){const n=this.data,a=e.x,i=e.y,s=e.z;return t.x=a*n[0]+i*n[4]+s*n[8],t.y=a*n[1]+i*n[5]+s*n[9],t.z=a*n[2]+i*n[6]+s*n[10],t}transformVec4(e,t=new Ou){const n=this.data,a=e.x,i=e.y,s=e.z,r=e.w;return t.x=a*n[0]+i*n[4]+s*n[8]+r*n[12],t.y=a*n[1]+i*n[5]+s*n[9]+r*n[13],t.z=a*n[2]+i*n[6]+s*n[10]+r*n[14],t.w=a*n[3]+i*n[7]+s*n[11]+r*n[15],t}setLookAt(e,t,n){Bu.sub2(e,t).normalize(),Vu.copy(n).normalize(),Nu.cross(Vu,Bu).normalize(),Vu.cross(Bu,Nu);const a=this.data;return a[0]=Nu.x,a[1]=Nu.y,a[2]=Nu.z,a[3]=0,a[4]=Vu.x,a[5]=Vu.y,a[6]=Vu.z,a[7]=0,a[8]=Bu.x,a[9]=Bu.y,a[10]=Bu.z,a[11]=0,a[12]=e.x,a[13]=e.y,a[14]=e.z,a[15]=1,this}setFrustum(e,t,n,a,i,s){const r=2*i,o=t-e,l=a-n,c=s-i,h=this.data;return h[0]=r/o,h[1]=0,h[2]=0,h[3]=0,h[4]=0,h[5]=r/l,h[6]=0,h[7]=0,h[8]=(t+e)/o,h[9]=(a+n)/l,h[10]=(-s-i)/c,h[11]=-1,h[12]=0,h[13]=0,h[14]=-r*s/c,h[15]=0,this}setPerspective(e,t,n,a,i){return zu._getPerspectiveHalfSize(Fu,e,t,n,i),this.setFrustum(-Fu.x,Fu.x,-Fu.y,Fu.y,n,a)}setOrtho(e,t,n,a,i,s){const r=this.data;return r[0]=2/(t-e),r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=2/(a-n),r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=-2/(s-i),r[11]=0,r[12]=-(t+e)/(t-e),r[13]=-(a+n)/(a-n),r[14]=-(s+i)/(s-i),r[15]=1,this}setFromAxisAngle(e,t){t*=Eu.DEG_TO_RAD;const n=e.x,a=e.y,i=e.z,s=Math.cos(t),r=Math.sin(t),o=1-s,l=o*n,c=o*a,h=this.data;return h[0]=l*n+s,h[1]=l*a+r*i,h[2]=l*i-r*a,h[3]=0,h[4]=l*a-r*i,h[5]=c*a+s,h[6]=c*i+r*n,h[7]=0,h[8]=l*i+r*a,h[9]=c*i-n*r,h[10]=o*i*i+s,h[11]=0,h[12]=0,h[13]=0,h[14]=0,h[15]=1,this}setTranslate(e,t,n){const a=this.data;return a[0]=1,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=1,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=1,a[11]=0,a[12]=e,a[13]=t,a[14]=n,a[15]=1,this}setScale(e,t,n){const a=this.data;return a[0]=e,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=t,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=n,a[11]=0,a[12]=0,a[13]=0,a[14]=0,a[15]=1,this}setViewport(e,t,n,a){const i=this.data;return i[0]=.5*n,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=.5*a,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=.5,i[11]=0,i[12]=e+.5*n,i[13]=t+.5*a,i[14]=.5,i[15]=1,this}invert(){const e=this.data,t=e[0],n=e[1],a=e[2],i=e[3],s=e[4],r=e[5],o=e[6],l=e[7],c=e[8],h=e[9],d=e[10],p=e[11],u=e[12],m=e[13],f=e[14],g=e[15],y=t*r-n*s,b=t*o-a*s,v=t*l-i*s,_=n*o-a*r,w=n*l-i*r,x=a*l-i*o,C=c*m-h*u,T=c*f-d*u,E=c*g-p*u,S=h*f-d*m,A=h*g-p*m,M=d*g-p*f,L=y*M-b*A+v*S+_*E-w*T+x*C;if(0===L)this.setIdentity();else{const R=1/L;e[0]=(r*M-o*A+l*S)*R,e[1]=(-n*M+a*A-i*S)*R,e[2]=(m*x-f*w+g*_)*R,e[3]=(-h*x+d*w-p*_)*R,e[4]=(-s*M+o*E-l*T)*R,e[5]=(t*M-a*E+i*T)*R,e[6]=(-u*x+f*v-g*b)*R,e[7]=(c*x-d*v+p*b)*R,e[8]=(s*A-r*E+l*C)*R,e[9]=(-t*A+n*E-i*C)*R,e[10]=(u*w-m*v+g*y)*R,e[11]=(-c*w+h*v-p*y)*R,e[12]=(-s*S+r*T-o*C)*R,e[13]=(t*S-n*T+a*C)*R,e[14]=(-u*_+m*b-f*y)*R,e[15]=(c*_-h*b+d*y)*R}return this}set(e){const t=this.data;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],this}setIdentity(){const e=this.data;return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}setTRS(e,t,n){const a=t.x,i=t.y,s=t.z,r=t.w,o=n.x,l=n.y,c=n.z,h=a+a,d=i+i,p=s+s,u=a*h,m=a*d,f=a*p,g=i*d,y=i*p,b=s*p,v=r*h,_=r*d,w=r*p,x=this.data;return x[0]=(1-(g+b))*o,x[1]=(m+w)*o,x[2]=(f-_)*o,x[3]=0,x[4]=(m-w)*l,x[5]=(1-(u+b))*l,x[6]=(y+v)*l,x[7]=0,x[8]=(f+_)*c,x[9]=(y-v)*c,x[10]=(1-(u+g))*c,x[11]=0,x[12]=e.x,x[13]=e.y,x[14]=e.z,x[15]=1,this}transpose(){let e;const t=this.data;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}invertTo3x3(e){const t=this.data,n=e.data,a=t[0],i=t[1],s=t[2],r=t[4],o=t[5],l=t[6],c=t[8],h=t[9],d=t[10],p=d*o-l*h,u=-d*i+s*h,m=l*i-s*o,f=-d*r+l*c,g=d*a-s*c,y=-l*a+s*r,b=h*r-o*c,v=-h*a+i*c,_=o*a-i*r,w=a*p+i*f+s*b;if(0===w)return this;const x=1/w;return n[0]=x*p,n[1]=x*u,n[2]=x*m,n[3]=x*f,n[4]=x*g,n[5]=x*y,n[6]=x*b,n[7]=x*v,n[8]=x*_,this}getTranslation(e=new Pu){return e.set(this.data[12],this.data[13],this.data[14])}getX(e=new Pu){return e.set(this.data[0],this.data[1],this.data[2])}getY(e=new Pu){return e.set(this.data[4],this.data[5],this.data[6])}getZ(e=new Pu){return e.set(this.data[8],this.data[9],this.data[10])}getScale(e=new Pu){return this.getX(Nu),this.getY(Vu),this.getZ(Bu),e.set(Nu.length(),Vu.length(),Bu.length()),e}setFromEulerAngles(e,t,n){e*=Eu.DEG_TO_RAD,t*=Eu.DEG_TO_RAD,n*=Eu.DEG_TO_RAD;const a=Math.sin(-e),i=Math.cos(-e),s=Math.sin(-t),r=Math.cos(-t),o=Math.sin(-n),l=Math.cos(-n),c=this.data;return c[0]=r*l,c[1]=-r*o,c[2]=s,c[3]=0,c[4]=i*o+l*a*s,c[5]=i*l-a*s*o,c[6]=-r*a,c[7]=0,c[8]=a*o-i*l*s,c[9]=l*a+i*s*o,c[10]=i*r,c[11]=0,c[12]=0,c[13]=0,c[14]=0,c[15]=1,this}getEulerAngles(e=new Pu){this.getScale(Uu);const t=Uu.x,n=Uu.y,a=Uu.z;if(0===t||0===n||0===a)return e.set(0,0,0);const i=this.data,s=Math.asin(-i[2]/t),r=.5*Math.PI;let o,l;return s<r?s>-r?(o=Math.atan2(i[6]/n,i[10]/a),l=Math.atan2(i[1]/t,i[0]/t)):(l=0,o=-Math.atan2(i[4]/n,i[5]/n)):(l=0,o=Math.atan2(i[4]/n,i[5]/n)),e.set(o,s,l).mulScalar(Eu.RAD_TO_DEG)}toString(){return"["+this.data.join(", ")+"]"}}zu.IDENTITY=Object.freeze(new zu),zu.ZERO=Object.freeze((new zu).set([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]));class Gu{constructor(e=0,t=0,n=0,a=1){4===e.length?(this.x=e[0],this.y=e[1],this.z=e[2],this.w=e[3]):(this.x=e,this.y=t,this.z=n,this.w=a)}clone(){return new Gu(this.x,this.y,this.z,this.w)}conjugate(){return this.x*=-1,this.y*=-1,this.z*=-1,this}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}equals(e){return this.x===e.x&&this.y===e.y&&this.z===e.z&&this.w===e.w}getAxisAngle(e){let t=2*Math.acos(this.w);const n=Math.sin(t/2);return 0!==n?(e.x=this.x/n,e.y=this.y/n,e.z=this.z/n,(e.x<0||e.y<0||e.z<0)&&(e.x*=-1,e.y*=-1,e.z*=-1,t*=-1)):(e.x=1,e.y=0,e.z=0),t*Eu.RAD_TO_DEG}getEulerAngles(e=new Pu){let t,n,a;const i=this.x,s=this.y,r=this.z,o=this.w,l=2*(o*s-i*r);return l<=-.99999?(t=2*Math.atan2(i,o),n=-Math.PI/2,a=0):l>=.99999?(t=2*Math.atan2(i,o),n=Math.PI/2,a=0):(t=Math.atan2(2*(o*i+s*r),1-2*(i*i+s*s)),n=Math.asin(l),a=Math.atan2(2*(o*r+i*s),1-2*(s*s+r*r))),e.set(t,n,a).mulScalar(Eu.RAD_TO_DEG)}invert(){return this.conjugate().normalize()}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}mul(e){const t=this.x,n=this.y,a=this.z,i=this.w,s=e.x,r=e.y,o=e.z,l=e.w;return this.x=i*s+t*l+n*o-a*r,this.y=i*r+n*l+a*s-t*o,this.z=i*o+a*l+t*r-n*s,this.w=i*l-t*s-n*r-a*o,this}mul2(e,t){const n=e.x,a=e.y,i=e.z,s=e.w,r=t.x,o=t.y,l=t.z,c=t.w;return this.x=s*r+n*c+a*l-i*o,this.y=s*o+a*c+i*r-n*l,this.z=s*l+i*c+n*o-a*r,this.w=s*c-n*r-a*o-i*l,this}normalize(){let e=this.length();return 0===e?(this.x=this.y=this.z=0,this.w=1):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}set(e,t,n,a){return this.x=e,this.y=t,this.z=n,this.w=a,this}setFromAxisAngle(e,t){t*=.5*Eu.DEG_TO_RAD;const n=Math.sin(t),a=Math.cos(t);return this.x=n*e.x,this.y=n*e.y,this.z=n*e.z,this.w=a,this}setFromEulerAngles(e,t,n){if(e instanceof Pu){const a=e;e=a.x,t=a.y,n=a.z}const a=.5*Eu.DEG_TO_RAD;e*=a,t*=a,n*=a;const i=Math.sin(e),s=Math.cos(e),r=Math.sin(t),o=Math.cos(t),l=Math.sin(n),c=Math.cos(n);return this.x=i*o*c-s*r*l,this.y=s*r*c+i*o*l,this.z=s*o*l-i*r*c,this.w=s*o*c+i*r*l,this}setFromMat4(e){let t,n,a,i,s,r,o,l,c,h,d,p,u,m;if(t=(e=e.data)[0],n=e[1],a=e[2],i=e[4],s=e[5],r=e[6],o=e[8],l=e[9],c=e[10],p=t*t+n*n+a*a,0===p)return this;if(p=1/Math.sqrt(p),u=i*i+s*s+r*r,0===u)return this;if(u=1/Math.sqrt(u),m=o*o+l*l+c*c,0===m)return this;m=1/Math.sqrt(m),t*=p,n*=p,a*=p,i*=u,s*=u,r*=u,o*=m,l*=m,c*=m;const f=t+s+c;return f>=0?(h=Math.sqrt(f+1),this.w=.5*h,h=.5/h,this.x=(r-l)*h,this.y=(o-a)*h,this.z=(n-i)*h):t>s?t>c?(d=t-(s+c)+1,d=Math.sqrt(d),this.x=.5*d,d=.5/d,this.w=(r-l)*d,this.y=(n+i)*d,this.z=(a+o)*d):(d=c-(t+s)+1,d=Math.sqrt(d),this.z=.5*d,d=.5/d,this.w=(n-i)*d,this.x=(o+a)*d,this.y=(l+r)*d):s>c?(d=s-(c+t)+1,d=Math.sqrt(d),this.y=.5*d,d=.5/d,this.w=(o-a)*d,this.z=(r+l)*d,this.x=(i+n)*d):(d=c-(t+s)+1,d=Math.sqrt(d),this.z=.5*d,d=.5/d,this.w=(n-i)*d,this.x=(o+a)*d,this.y=(l+r)*d),this}slerp(e,t,n){const a=e.x,i=e.y,s=e.z,r=e.w;let o=t.x,l=t.y,c=t.z,h=t.w,d=r*h+a*o+i*l+s*c;if(d<0&&(h=-h,o=-o,l=-l,c=-c,d=-d),Math.abs(d)>=1)return this.w=r,this.x=a,this.y=i,this.z=s,this;const p=Math.acos(d),u=Math.sqrt(1-d*d);if(Math.abs(u)<.001)return this.w=.5*r+.5*h,this.x=.5*a+.5*o,this.y=.5*i+.5*l,this.z=.5*s+.5*c,this;const m=Math.sin((1-n)*p)/u,f=Math.sin(n*p)/u;return this.w=r*m+h*f,this.x=a*m+o*f,this.y=i*m+l*f,this.z=s*m+c*f,this}transformVector(e,t=new Pu){const n=e.x,a=e.y,i=e.z,s=this.x,r=this.y,o=this.z,l=this.w,c=l*n+r*i-o*a,h=l*a+o*n-s*i,d=l*i+s*a-r*n,p=-s*n-r*a-o*i;return t.x=c*l+p*-s+h*-o-d*-r,t.y=h*l+p*-r+d*-s-c*-o,t.z=d*l+p*-o+c*-r-h*-s,t}toString(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`}}Gu.IDENTITY=Object.freeze(new Gu(0,0,0,1)),Gu.ZERO=Object.freeze(new Gu(0,0,0,0));const Hu=new Pu,Wu=new Pu,ju=new Pu,Xu=new Pu,Yu=new Pu;class qu{constructor(e=new Pu,t=new Pu(.5,.5,.5)){this.center=e,this.halfExtents=t,this._min=new Pu,this._max=new Pu}add(e){const t=this.center,n=t.x,a=t.y,i=t.z,s=this.halfExtents,r=s.x,o=s.y,l=s.z;let c=n-r,h=n+r,d=a-o,p=a+o,u=i-l,m=i+l;const f=e.center,g=f.x,y=f.y,b=f.z,v=e.halfExtents,_=v.x,w=v.y,x=v.z,C=g-_,T=g+_,E=y-w,S=y+w,A=b-x,M=b+x;C<c&&(c=C),T>h&&(h=T),E<d&&(d=E),S>p&&(p=S),A<u&&(u=A),M>m&&(m=M),t.x=.5*(c+h),t.y=.5*(d+p),t.z=.5*(u+m),s.x=.5*(h-c),s.y=.5*(p-d),s.z=.5*(m-u)}copy(e){this.center.copy(e.center),this.halfExtents.copy(e.halfExtents)}clone(){return new qu(this.center.clone(),this.halfExtents.clone())}intersects(e){const t=this.getMax(),n=this.getMin(),a=e.getMax(),i=e.getMin();return n.x<=a.x&&t.x>=i.x&&n.y<=a.y&&t.y>=i.y&&n.z<=a.z&&t.z>=i.z}_intersectsRay(e,t){const n=Hu.copy(this.getMin()).sub(e.origin),a=Wu.copy(this.getMax()).sub(e.origin),i=e.direction;0===i.x?(n.x=n.x<0?-Number.MAX_VALUE:Number.MAX_VALUE,a.x=a.x<0?-Number.MAX_VALUE:Number.MAX_VALUE):(n.x/=i.x,a.x/=i.x),0===i.y?(n.y=n.y<0?-Number.MAX_VALUE:Number.MAX_VALUE,a.y=a.y<0?-Number.MAX_VALUE:Number.MAX_VALUE):(n.y/=i.y,a.y/=i.y),0===i.z?(n.z=n.z<0?-Number.MAX_VALUE:Number.MAX_VALUE,a.z=a.z<0?-Number.MAX_VALUE:Number.MAX_VALUE):(n.z/=i.z,a.z/=i.z);const s=ju.set(Math.min(n.x,a.x),Math.min(n.y,a.y),Math.min(n.z,a.z)),r=Xu.set(Math.max(n.x,a.x),Math.max(n.y,a.y),Math.max(n.z,a.z)),o=Math.min(Math.min(r.x,r.y),r.z),l=Math.max(Math.max(s.x,s.y),s.z),c=o>=l&&l>=0;return c&&t.copy(e.direction).mulScalar(l).add(e.origin),c}_fastIntersectsRay(e){const t=Hu,n=Wu,a=ju,i=Xu,s=Yu,r=e.direction;return t.sub2(e.origin,this.center),i.set(Math.abs(t.x),Math.abs(t.y),Math.abs(t.z)),a.mul2(t,r),!(i.x>this.halfExtents.x&&a.x>=0)&&(!(i.y>this.halfExtents.y&&a.y>=0)&&(!(i.z>this.halfExtents.z&&a.z>=0)&&(s.set(Math.abs(r.x),Math.abs(r.y),Math.abs(r.z)),n.cross(r,t),n.set(Math.abs(n.x),Math.abs(n.y),Math.abs(n.z)),!(n.x>this.halfExtents.y*s.z+this.halfExtents.z*s.y)&&(!(n.y>this.halfExtents.x*s.z+this.halfExtents.z*s.x)&&!(n.z>this.halfExtents.x*s.y+this.halfExtents.y*s.x)))))}intersectsRay(e,t){return t?this._intersectsRay(e,t):this._fastIntersectsRay(e)}setMinMax(e,t){this.center.add2(t,e).mulScalar(.5),this.halfExtents.sub2(t,e).mulScalar(.5)}getMin(){return this._min.copy(this.center).sub(this.halfExtents)}getMax(){return this._max.copy(this.center).add(this.halfExtents)}containsPoint(e){const t=this.getMin(),n=this.getMax();return!(e.x<t.x||e.x>n.x||e.y<t.y||e.y>n.y||e.z<t.z||e.z>n.z)}setFromTransformedAabb(e,t,n=!1){const a=e.center,i=e.halfExtents,s=t.data;let r=s[0],o=s[4],l=s[8],c=s[1],h=s[5],d=s[9],p=s[2],u=s[6],m=s[10];if(n){let e=r*r+o*o+l*l;if(e>0){const t=1/Math.sqrt(e);r*=t,o*=t,l*=t}if(e=c*c+h*h+d*d,e>0){const t=1/Math.sqrt(e);c*=t,h*=t,d*=t}if(e=p*p+u*u+m*m,e>0){const t=1/Math.sqrt(e);p*=t,u*=t,m*=t}}this.center.set(s[12]+r*a.x+o*a.y+l*a.z,s[13]+c*a.x+h*a.y+d*a.z,s[14]+p*a.x+u*a.y+m*a.z),this.halfExtents.set(Math.abs(r)*i.x+Math.abs(o)*i.y+Math.abs(l)*i.z,Math.abs(c)*i.x+Math.abs(h)*i.y+Math.abs(d)*i.z,Math.abs(p)*i.x+Math.abs(u)*i.y+Math.abs(m)*i.z)}compute(e,t){if((t=void 0===t?e.length/3:t)>0){const n=Hu.set(e[0],e[1],e[2]),a=Wu.set(e[0],e[1],e[2]);for(let i=1;i<t;i++){const t=e[3*i+0],s=e[3*i+1],r=e[3*i+2];t<n.x&&(n.x=t),s<n.y&&(n.y=s),r<n.z&&(n.z=r),t>a.x&&(a.x=t),s>a.y&&(a.y=s),r>a.z&&(a.z=r)}this.setMinMax(n,a)}}intersectsBoundingSphere(e){return this._distanceToBoundingSphereSq(e)<=e.radius*e.radius}_distanceToBoundingSphereSq(e){const t=this.getMin(),n=this.getMax();let a=0;const i=["x","y","z"];for(let s=0;s<3;++s){let r=0;const o=e.center[i[s]],l=t[i[s]],c=n[i[s]];let h=0;o<l&&(h=l-o,r+=h*h),o>c&&(h=o-c,r+=h*h),a+=r}return a}_expand(e,t){Hu.add2(this.getMin(),e),Wu.add2(this.getMax(),t),this.setMinMax(Hu,Wu)}}const Ku=new Pu,Zu=new Pu;class $u{constructor(e=new Pu,t=.5){this.center=e,this.radius=t}containsPoint(e){const t=Ku.sub2(e,this.center).lengthSq(),n=this.radius;return t<n*n}intersectsRay(e,t){const n=Ku.copy(e.origin).sub(this.center),a=n.dot(Zu.copy(e.direction).normalize()),i=n.dot(n)-this.radius*this.radius;if(i>0&&a>0)return!1;const s=a*a-i;if(s<0)return!1;const r=Math.abs(-a-Math.sqrt(s));return t&&t.copy(e.direction).mulScalar(r).add(e.origin),!0}intersectsBoundingSphere(e){Ku.sub2(e.center,this.center);const t=e.radius+this.radius;return Ku.lengthSq()<=t*t}}const Qu={0:"PCF3",1:"VSM8",2:"VSM16",3:"VSM32",4:"PCF5",5:"PCF1"},Ju=[new Pu,new Pu,new Pu,new Pu,new Pu,new Pu,new Pu,new Pu];class em{constructor(){this.planes=[];for(let e=0;e<6;e++)this.planes[e]=[]}setFromMat4(e){const t=e.data;let n;const a=this.planes;n=a[0],n[0]=t[3]-t[0],n[1]=t[7]-t[4],n[2]=t[11]-t[8],n[3]=t[15]-t[12];let i=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=i,n[1]/=i,n[2]/=i,n[3]/=i,n=a[1],n[0]=t[3]+t[0],n[1]=t[7]+t[4],n[2]=t[11]+t[8],n[3]=t[15]+t[12],i=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]),n[0]/=i,n[1]/=i,n[2]/=i,n[3]/=i,n=a[2],n[0]=t[3]+t[1],n[1]=t[7]+t[5],n[2]=t[11]+t[9],n[3]=t[15]+t[13],i=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]),n[0]/=i,n[1]/=i,n[2]/=i,n[3]/=i,n=a[3],n[0]=t[3]-t[1],n[1]=t[7]-t[5],n[2]=t[11]-t[9],n[3]=t[15]-t[13],i=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]),n[0]/=i,n[1]/=i,n[2]/=i,n[3]/=i,n=a[4],n[0]=t[3]-t[2],n[1]=t[7]-t[6],n[2]=t[11]-t[10],n[3]=t[15]-t[14],i=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]),n[0]/=i,n[1]/=i,n[2]/=i,n[3]/=i,n=a[5],n[0]=t[3]+t[2],n[1]=t[7]+t[6],n[2]=t[11]+t[10],n[3]=t[15]+t[14],i=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]),n[0]/=i,n[1]/=i,n[2]/=i,n[3]/=i}containsPoint(e){let t,n;for(t=0;t<6;t++)if(n=this.planes[t],n[0]*e.x+n[1]*e.y+n[2]*e.z+n[3]<=0)return!1;return!0}containsSphere(e){let t,n,a=0;const i=e.radius,s=e.center,r=s.x,o=s.y,l=s.z,c=this.planes;let h;for(n=0;n<6;n++){if(h=c[n],t=h[0]*r+h[1]*o+h[2]*l+h[3],t<=-i)return 0;t>i&&a++}return 6===a?2:1}static getPoints(e,t,n){t=t||e._nearClip,n=n||e._farClip;const a=e._fov*Math.PI/180;let i=0===e._projection?Math.tan(a/2)*t:e._orthoHeight,s=i*e._aspectRatio;const r=Ju;return r[0].x=s,r[0].y=-i,r[0].z=-t,r[1].x=s,r[1].y=i,r[1].z=-t,r[2].x=-s,r[2].y=i,r[2].z=-t,r[3].x=-s,r[3].y=-i,r[3].z=-t,0===e._projection&&(i=Math.tan(a/2)*n,s=i*e._aspectRatio),r[4].x=s,r[4].y=-i,r[4].z=-n,r[5].x=s,r[5].y=i,r[5].z=-n,r[6].x=-s,r[6].y=i,r[6].z=-n,r[7].x=-s,r[7].y=-i,r[7].z=-n,r}}class tm{constructor(e=new Pu,t=new Pu(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}}new tm,new Pu,new $u,new zu,new Pu;const nm=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array],am=[1,1,2,2,4,4,4],im=[Uint8Array,Uint16Array,Uint32Array],sm=[1,2,4],rm={POSITION:0,NORMAL:1,BLENDWEIGHT:2,BLENDINDICES:3,COLOR:4,TEXCOORD0:5,TEXCOORD1:6,TEXCOORD2:7,TEXCOORD3:8,TEXCOORD4:9,TEXCOORD5:10,TEXCOORD6:11,TEXCOORD7:12,TANGENT:13,ATTR0:0,ATTR1:1,ATTR2:2,ATTR3:3,ATTR4:4,ATTR5:5,ATTR6:6,ATTR7:7,ATTR8:8,ATTR9:9,ATTR10:10,ATTR11:11,ATTR12:12,ATTR13:13,ATTR14:14,ATTR15:15};let om=0;class lm{constructor(e,t,n,a=0,i){this.device=e,this.format=t,this.numVertices=n,this.usage=a,this.id=om++,this.impl=e.createVertexBufferImpl(this,t),this.instancing=!1,this.numBytes=t.verticesByteSize?t.verticesByteSize:t.size*n,e._vram.vb+=this.numBytes,i?this.setData(i):this.storage=new ArrayBuffer(this.numBytes),this.device.buffers.push(this)}destroy(){const e=this.device,t=e.buffers.indexOf(this);-1!==t&&e.buffers.splice(t,1),this.impl.destroy(e),e._vram.vb-=this.storage.byteLength}loseContext(){this.impl.loseContext()}getFormat(){return this.format}getUsage(){return this.usage}getNumVertices(){return this.numVertices}lock(){return this.storage}unlock(){this.impl.unlock(this)}setData(e){return e.byteLength===this.numBytes&&(this.storage=e,this.unlock(),!0)}}function cm(e){let t=0;for(let n=0,a=e.length;n<a;n++)t=(t<<5)-t+e.charCodeAt(n),t|=0;return t}class hm{constructor(e,t,n){this._elements=[],this.hasUv0=!1,this.hasUv1=!1,this.hasColor=!1,this.hasTangents=!1,this.verticesByteSize=0,this.vertexCount=n,this.interleaved=void 0===n,this.size=t.reduce(((e,t)=>e+4*Math.ceil(t.components*am[t.type]/4)),0);let a,i=0;for(let e=0,s=t.length;e<s;e++){const s=t[e];a=s.components*am[s.type],n&&(i=Eu.roundUp(i,a));const r={name:s.semantic,offset:n?i:s.hasOwnProperty("offset")?s.offset:i,stride:n?a:s.hasOwnProperty("stride")?s.stride:this.size,dataType:s.type,numComponents:s.components,normalize:void 0!==s.normalize&&s.normalize,size:a};this._elements.push(r),i+=n?a*n:4*Math.ceil(a/4),"TEXCOORD0"===s.semantic?this.hasUv0=!0:"TEXCOORD1"===s.semantic?this.hasUv1=!0:"COLOR"===s.semantic?this.hasColor=!0:"TANGENT"===s.semantic&&(this.hasTangents=!0)}n&&(this.verticesByteSize=i),this._evaluateHash()}get elements(){return this._elements}static get defaultInstancingFormat(){return hm._defaultInstancingFormat||(hm._defaultInstancingFormat=new hm(null,[{semantic:"ATTR12",components:4,type:6},{semantic:"ATTR13",components:4,type:6},{semantic:"ATTR14",components:4,type:6},{semantic:"ATTR15",components:4,type:6}])),hm._defaultInstancingFormat}_evaluateHash(){let e;const t=[];let n;const a=[],i=this._elements.length;for(let s=0;s<i;s++){const i=this._elements[s];e=i.name,e+=i.dataType,e+=i.numComponents,e+=i.normalize,t.push(e),n=e,n+=i.offset,n+=i.stride,n+=i.size,a.push(n)}t.sort(),this.batchingHash=cm(t.join()),this.renderingingHash=cm(a.join())}}hm._defaultInstancingFormat=null;class dm{constructor(){this._cache=new Map}get(e,t){return this._cache.has(e)||(this._cache.set(e,t()),e.on("destroy",(()=>{this.remove(e)}))),this._cache.get(e)}remove(e){var t;null==(t=this._cache.get(e))||t.destroy(),this._cache.delete(e)}}const pm={type:5,base:0,count:4,indexed:!1},um=new dm;function mm(e,t,n,a,i,s=!1){const r=e.renderTarget;let o,l,c,h,d,p,u,m;e.setRenderTarget(t),e.updateBegin(),a?(o=a.x,l=a.y,c=a.z,h=a.w):(c=t?t.width:e.width,h=t?t.height:e.height,o=0,l=0),i?(d=i.x,p=i.y,u=i.z,m=i.w):(d=o,p=l,u=c,m=h);const f=e.vx,g=e.vy,y=e.vw,b=e.vh;e.setViewport(o,l,c,h);const v=e.sx,_=e.sy,w=e.sw,x=e.sh;e.setScissor(d,p,u,m);const C=e.getDepthTest(),T=e.getDepthWrite(),E=e.getCullMode(),S=e.writeRed,A=e.writeGreen,M=e.writeBlue,L=e.writeAlpha;e.setDepthTest(!1),e.setDepthWrite(!1),e.setCullMode(0),e.setColorWrite(!0,!0,!0,!0),s||e.setBlending(!1),e.setVertexBuffer(function(e){return um.get(e,(()=>{const t=new hm(e,[{semantic:"POSITION",components:2,type:6}]),n=new Float32Array(8);return n.set([-1,-1,1,-1,-1,1,1,1]),new lm(e,t,4,0,n)}))}(e),0),e.setShader(n),e.draw(pm),e.setDepthTest(C),e.setDepthWrite(T),e.setCullMode(E),e.setColorWrite(S,A,M,L),e.updateEnd(),e.setRenderTarget(r),e.updateBegin(),e.setViewport(f,g,y,b),e.setScissor(v,_,w,x)}class fm{constructor(e,t){this.device=e,this.definition=t,this.init(),this.impl=e.createShaderImpl(this)}init(){this.ready=!1,this.failed=!1}destroy(){this.impl.destroy(this)}loseContext(){this.init()}restoreContext(){this.impl.restoreContext(this.device,this)}}const gm={alphaTestPS:"uniform float alpha_ref;\nvoid alphaTest(float a) {\n\tif (a < alpha_ref) discard;\n}\n",ambientConstantPS:"void addAmbient() {\n\tdDiffuseLight += light_globalAmbient;\n}\n",ambientEnvPS:"#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nvoid addAmbient() {\n\tvec3 dir = normalize(cubeMapRotate(dNormalW) * vec3(-1.0, 1.0, 1.0));\n\tvec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n\tvec4 raw = texture2D(texture_envAtlas, uv);\n\tvec3 linear = $DECODE(raw);\n\tdDiffuseLight += processEnvironment(linear);\n}\n",ambientSHPS:"uniform vec3 ambientSH[9];\nvoid addAmbient() {\n\tvec3 n = cubeMapRotate(dNormalW);\n\tvec3 color =\n\t\tambientSH[0] +\n\t\tambientSH[1] * n.x +\n\t\tambientSH[2] * n.y +\n\t\tambientSH[3] * n.z +\n\t\tambientSH[4] * n.x * n.z +\n\t\tambientSH[5] * n.z * n.y +\n\t\tambientSH[6] * n.y * n.x +\n\t\tambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n\t\tambientSH[8] * (n.x * n.x - n.y * n.y);\n\tdDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n",aoPS:"#ifdef MAPTEXTURE\nuniform sampler2D texture_aoMap;\n#endif\nvoid getAO() {\n\tdAo = 1.0;\n\t#ifdef MAPTEXTURE\n\tdAo *= texture2D(texture_aoMap, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAo *= saturate(vVertexColor.$VC);\n\t#endif\n}\n",aoDiffuseOccPS:"void occludeDiffuse() {\n\tdDiffuseLight *= dAo;\n}\n",aoSpecOccPS:"uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\tspecOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n",aoSpecOccConstPS:"void occludeSpecular() {\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n",aoSpecOccConstSimplePS:"void occludeSpecular() {\n\tdSpecularLight *= dAo;\n\tdReflection *= dAo;\n}\n",aoSpecOccSimplePS:"uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n\tfloat specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n",bakeDirLmEndPS:"\tvec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n\tif (bakeDir > 0.5) {\n\t\tif (dAtten > 0.00001) {\n\t\t\tdirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n\t\t\tdAtten = saturate(dAtten);\n\t\t\tgl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n\t\t\tgl_FragColor.a = dirLm.w + dAtten;\n\t\t\tgl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n\t\t} else {\n\t\t\tgl_FragColor = dirLm;\n\t\t}\n\t} else {\n\t\tgl_FragColor.rgb = dirLm.xyz;\n\t\tgl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n\t}\n",bakeLmEndPS:"\tgl_FragColor.rgb = dDiffuseLight;\n\tgl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n\tgl_FragColor.rgb /= 8.0;\n\tgl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n\tgl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n\tgl_FragColor.rgb /= gl_FragColor.a;\n",basePS:"uniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n\treturn x*x;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n\treturn clamp(x, vec3(0.0), vec3(1.0));\n}\n",baseVS:"attribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\n",baseNineSlicedPS:"#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n",baseNineSlicedVS:"#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n",baseNineSlicedTiledPS:"#define NINESLICED\n#define NINESLICETILED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n",biasConstPS:"#define SHADOWBIAS\nfloat getShadowBias(float resolution, float maxBias) {\n\treturn maxBias;\n}\n",blurVSMPS:"varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\n#endif\nvoid main(void) {\n\tvec3 moments = vec3(0.0);\n\tvec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n\tfor (int i=0; i<SAMPLES; i++) {\n\t\tvec4 c = texture2D(source, uv + pixelOffset * float(i));\n\t\t#ifdef PACKED\n\t\tc.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n\t\t#endif\n\t\t#ifdef GAUSS\n\t\tmoments += c.xyz * weight[i];\n\t\t#else\n\t\tmoments += c.xyz;\n\t\t#endif\n\t}\n\t#ifndef GAUSS\n\tmoments /= float(SAMPLES);\n\t#endif\n\t#ifdef PACKED\n\tgl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n\t#else\n\tgl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n\t#endif\n}\n",clearCoatPS:"#ifdef MAPFLOAT\nuniform float material_clearCoat;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatMap;\n#endif\nvoid getClearCoat() {\n\tccSpecularity = 1.0;\n\t#ifdef MAPFLOAT\n\tccSpecularity *= material_clearCoat;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccSpecularity *= texture2D(texture_clearCoatMap, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n",clearCoatGlossPS:"#ifdef MAPFLOAT\nuniform float material_clearCoatGlossiness;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatGlossMap;\n#endif\nvoid getClearCoatGlossiness() {\n\tccGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tccGlossiness *= material_clearCoatGlossiness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\tccGlossiness += 0.0000001;\n}\n",clearCoatNormalPS:"#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatNormalMap;\nuniform float material_clearCoatBumpiness;\n#endif\nvoid getClearCoatNormal() {\n\t#ifdef MAPTEXTURE\n\tvec3 normalMap = unpackNormal(texture2D(texture_clearCoatNormalMap, $UV, textureBias));\n\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness));\n\tccNormalW = dTBN * normalMap;\n\t#else\n\tccNormalW = normalize(dVertexNormalW);\n\t#endif\n\tccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\n}\n",clusteredLightCookiesPS:"vec3 _getCookieClustered(sampler2D tex, vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 pixel = mix(vec4(1.0), texture2D(tex, uv), intensity);\n\treturn isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));\n}\nvec3 getCookie2DClustered(sampler2D tex, mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 projPos = transform * vec4(worldPosition, 1.0);\n\treturn _getCookieClustered(tex, projPos.xy / projPos.w, intensity, isRgb, cookieChannel);\n}\nvec3 getCookieCubeClustered(sampler2D tex, vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {\n\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\treturn _getCookieClustered(tex, uv, intensity, isRgb, cookieChannel);\n}\n",clusteredLightShadowsPS:"#ifdef GL2\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowOmniClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\treturn texture(shadowMap, vec3(uv, shadowZ));\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowOmniClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\tdShadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(shadowMap, shadowParams.xyz);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowOmniClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\tdShadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF5x5(shadowMap, shadowParams.xyz);\n\t}\n\t#endif\n#else\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat depth = unpackFloat(texture2D(shadowMap, uv));\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\treturn depth > shadowZ ? 1.0 : 0.0;\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3) || defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\tdShadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(shadowMap, shadowParams.xyz);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\treturn getShadowOmniClusteredPCF3(shadowMap, shadowParams, omniAtlasViewport, shadowEdgePixels, dir);\n\t}\n\t#endif\n#endif\n#ifdef GL2\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowSpotClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams) {\n\t\treturn texture(shadowMap, dShadowCoord);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowSpotClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(shadowMap, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowSpotClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams) {\n\t\treturn getShadowPCF5x5(shadowMap, shadowParams.xyz);\n\t}\n\t#endif\n#else\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowSpotClusteredPCF1(sampler2D shadowMap, vec4 shadowParams) {\n\t\tfloat depth = unpackFloat(texture2D(shadowMap, dShadowCoord.xy));\n\t\treturn depth > dShadowCoord.z ? 1.0 : 0.0;\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3) || defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowSpotClusteredPCF3(sampler2D shadowMap, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(shadowMap, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowSpotClusteredPCF5(sampler2D shadowMap, vec4 shadowParams) {\n\t\treturn getShadowSpotClusteredPCF3(shadowMap, shadowParams);\n\t}\n\t#endif\n#endif\n",clusteredLightUtilsPS:"vec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\n{\n\tvec3 vAbs = abs(dir);\n\tfloat ma;\n\tvec2 uv;\n\tif (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {\n\t\tfaceIndex = dir.z < 0.0 ? 5.0 : 4.0;\n\t\tma = 0.5 / vAbs.z;\n\t\tuv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\n\t\ttileOffset.x = 2.0;\n\t\ttileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\n\t} else if(vAbs.y >= vAbs.x) {\n\t\tfaceIndex = dir.y < 0.0 ? 3.0 : 2.0;\n\t\tma = 0.5 / vAbs.y;\n\t\tuv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\n\t\ttileOffset.x = 1.0;\n\t\ttileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\n\t} else {\n\t\tfaceIndex = dir.x < 0.0 ? 1.0 : 0.0;\n\t\tma = 0.5 / vAbs.x;\n\t\tuv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\n\t\ttileOffset.x = 0.0;\n\t\ttileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\n\t}\n\treturn uv * ma + 0.5;\n}\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\n\tfloat faceIndex;\n\tvec2 tileOffset;\n\tvec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\n\tfloat atlasFaceSize = omniAtlasViewport.z;\n\tfloat tileSize = shadowTextureResolution * atlasFaceSize;\n\tfloat offset = shadowEdgePixels / tileSize;\n\tuv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\n\tuv *= atlasFaceSize;\n\tuv += tileOffset * atlasFaceSize;\n\tuv += omniAtlasViewport.xy;\n\treturn uv;\n}\n",clusteredLightPS:"uniform sampler2D clusterWorldTexture;\nuniform sampler2D lightsTexture8;\nuniform highp sampler2D lightsTextureFloat;\n#ifdef CLUSTER_SHADOWS\n\t#ifdef GL2\n\t\tuniform sampler2DShadow shadowAtlasTexture;\n\t#else\n\t\tuniform sampler2D shadowAtlasTexture;\n\t#endif\n#endif\n#ifdef CLUSTER_COOKIES\n\tuniform sampler2D cookieAtlasTexture;\n#endif\nuniform float clusterPixelsPerCell;\nuniform vec3 clusterCellsCountByBoundsSize;\nuniform vec4 lightsTextureInvSize;\nuniform vec3 clusterTextureSize;\nuniform vec3 clusterBoundsMin;\nuniform vec3 clusterBoundsDelta;\nuniform vec3 clusterCellsDot;\nuniform vec3 clusterCellsMax;\nuniform vec2 clusterCompressionLimit0;\nuniform vec2 shadowAtlasParams;\nfloat LTCLightValuesEvaluated = 0.0;\nstruct ClusterLightData {\n\tfloat lightV;\n\tfloat type;\n\tfloat shape;\n\tvec3 halfWidth;\n\tvec3 halfHeight;\n\tfloat falloffMode;\n\tfloat castShadows;\n\tfloat shadowBias;\n\tfloat shadowNormalBias;\n\tvec3 position;\n\tvec3 direction;\n\tfloat range;\n\tfloat innerConeAngleCos;\n\tfloat outerConeAngleCos;\n\tvec3 color;\n\tvec3 omniAtlasViewport;\n\tfloat cookie;\n\tfloat cookieRgb;\n\tfloat cookieIntensity;\n\tvec4 cookieChannelMask;\n\tfloat mask;\n};\nmat4 lightProjectionMatrix;\n#define isClusteredLightCastShadow(light) ( light.castShadows > 0.5 )\n#define isClusteredLightCookie(light) (light.cookie > 0.5 )\n#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )\n#define isClusteredLightSpot(light) ( light.type > 0.5 )\n#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )\n#define isClusteredLightArea(light) ( light.shape > 0.1 )\n#define isClusteredLightRect(light) ( light.shape < 0.3 )\n#define isClusteredLightDisk(light) ( light.shape < 0.6 )\n#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS\n\t#define acceptLightMask(light) ( light.mask < 0.75)\n#else\n\t#define acceptLightMask(light) ( light.mask > 0.25)\n#endif\nvec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {\n\treturn vec4(\n\t\tbytes2floatRange4(d0, -2.0, 2.0),\n\t\tbytes2floatRange4(d1, -2.0, 2.0),\n\t\tbytes2floatRange4(d2, -2.0, 2.0),\n\t\tbytes2floatRange4(d3, -2.0, 2.0)\n\t);\n}\n#ifdef SUPPORTS_TEXLOD\n\t#define textureData(texture, uv) texture2DLodEXT(texture, uv, 0.0)\n#else\n\t#define textureData(texture, uv) texture2D(texture, uv)\n#endif\nvec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {\n\treturn textureData(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV));\n}\nvec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {\n\treturn textureData(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV));\n}\nvoid decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {\n\tclusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;\n\tvec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);\n\tclusterLightData.type = lightInfo.x;\n\tclusterLightData.shape = lightInfo.y;\n\tclusterLightData.falloffMode = lightInfo.z;\n\tclusterLightData.castShadows = lightInfo.w;\n\tvec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);\n\tvec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);\n\tclusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;\n\tclusterLightData.cookie = colorB.z;\n\tclusterLightData.mask = colorB.w;\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tvec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);\n\t\tclusterLightData.position = lightPosRange.xyz;\n\t\tclusterLightData.range = lightPosRange.w;\n\t\tvec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);\n\t\tclusterLightData.direction = lightDir_Unused.xyz;\n\t#else\n\t\tvec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);\n\t\tvec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);\n\t\tvec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);\n\t\tclusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;\n\t\tvec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);\n\t\tclusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;\n\t\tvec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);\n\t\tvec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);\n\t\tvec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);\n\t\tclusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;\n\t#endif\n}\nvoid decodeClusterLightSpot(inout ClusterLightData clusterLightData) {\n\tvec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);\n\tclusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;\n\tclusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;\n}\nvoid decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tclusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;\n\t#else\n\t\tvec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);\n\t\tvec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);\n\t\tclusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));\n\t#endif\n}\nvoid decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tclusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;\n\t\tclusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;\n\t#else\n\t\tvec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);\n\t\tvec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);\n\t\tvec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);\n\t\tclusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));\n\t\tvec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);\n\t\tvec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);\n\t\tvec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);\n\t\tclusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));\n\t#endif\n}\nvoid decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tvec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);\n\t\tvec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);\n\t\tvec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);\n\t\tvec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);\n\t#else\n\t\tvec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);\n\t\tvec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);\n\t\tvec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);\n\t\tvec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);\n\t\tvec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);\n\t\tvec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);\n\t\tvec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);\n\t\tvec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);\n\t\tvec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);\n\t\tvec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);\n\t\tvec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);\n\t\tvec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);\n\t\tvec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);\n\t\tvec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);\n\t\tvec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);\n\t\tvec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);\n\t\tvec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);\n\t\tvec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);\n\t\tvec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);\n\t\tvec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));\n\t#endif\n\tlightProjectionMatrix = mat4(m0, m1, m2, m3);\n}\nvoid decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {\n\tvec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);\n\tclusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),\n\tclusterLightData.shadowNormalBias = bytes2float2(biases.zw);\n}\nvoid decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {\n\tvec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);\n\tclusterLightData.cookieIntensity = cookieA.x;\n\tclusterLightData.cookieRgb = cookieA.y;\n\tclusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);\n}\nvoid evaluateLight(ClusterLightData light) {\n\tdAtten3 = vec3(1.0);\n\tgetLightDirPoint(light.position);\n\t#ifdef CLUSTER_AREALIGHTS\n\tif (isClusteredLightArea(light)) {\n\t\tdecodeClusterLightAreaData(light);\n\t\tif (LTCLightValuesEvaluated < 0.5) {\n\t\t\tLTCLightValuesEvaluated = 1.0;\n\t\t\tcalcLTCLightValues();\n\t\t}\n\t\tif (isClusteredLightRect(light)) {\n\t\t\tcalcRectLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\tcalcDiskLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else {\n\t\t\tcalcSphereLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t}\n\t\tdAtten = getFalloffWindow(light.range);\n\t} else\n\t#endif\n\t{\n\t\tif (isClusteredLightFalloffLinear(light))\n\t\t\tdAtten = getFalloffLinear(light.range);\n\t\telse\n\t\t\tdAtten = getFalloffInvSquared(light.range);\n\t}\n\tif (dAtten > 0.00001) {\n\t\t#ifdef CLUSTER_AREALIGHTS\n\t\tif (isClusteredLightArea(light)) {\n\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\tdAttenD = getRectLightDiffuse() * 16.0;\n\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\tdAttenD = getDiskLightDiffuse() * 16.0;\n\t\t\t} else {\n\t\t\t\tdAttenD = getSphereLightDiffuse() * 16.0;\n\t\t\t}\n\t\t} else\n\t\t#endif\n\t\t{\n\t\t\tdAtten *= getLightDiffuse();\n\t\t}\n\t\tif (isClusteredLightSpot(light)) {\n\t\t\tdecodeClusterLightSpot(light);\n\t\t\tdAtten *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos);\n\t\t}\n\t\t#if defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)\n\t\tif (dAtten > 0.00001) {\n\t\t\tif (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {\n\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\tdecodeClusterLightProjectionMatrixData(light);\n\t\t\t\t} else {\n\t\t\t\t\tdecodeClusterLightOmniAtlasViewport(light);\n\t\t\t\t}\n\t\t\t\tfloat shadowTextureResolution = shadowAtlasParams.x;\n\t\t\t\tfloat shadowEdgePixels = shadowAtlasParams.y;\n\t\t\t\t#ifdef CLUSTER_COOKIES\n\t\t\t\tif (isClusteredLightCookie(light)) {\n\t\t\t\t\tdecodeClusterLightCookieData(light);\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\t\tdAtten3 = getCookie2DClustered(cookieAtlasTexture, lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdAtten3 = getCookieCubeClustered(cookieAtlasTexture, dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t\t#ifdef CLUSTER_SHADOWS\n\t\t\t\tif (isClusteredLightCastShadow(light)) {\n\t\t\t\t\tdecodeClusterLightShadowData(light);\n\t\t\t\t\tvec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\t\tgetShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams);\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tdAtten *= getShadowSpotClusteredPCF1(shadowAtlasTexture, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tdAtten *= getShadowSpotClusteredPCF3(shadowAtlasTexture, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tdAtten *= getShadowSpotClusteredPCF5(shadowAtlasTexture, shadowParams);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnormalOffsetPointShadow(shadowParams);\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tdAtten *= getShadowOmniClusteredPCF1(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tdAtten *= getShadowOmniClusteredPCF3(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tdAtten *= getShadowOmniClusteredPCF5(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\t\t}\n\t\t#endif\n\t\t#ifdef CLUSTER_AREALIGHTS\n\t\tif (isClusteredLightArea(light)) {\n\t\t\t{\n\t\t\t\tvec3 areaDiffuse = (dAttenD * dAtten) * light.color * dAtten3;\n\t\t\t\t#if defined(CLUSTER_SPECULAR) && defined(CLUSTER_CONSERVE_ENERGY)\n\t\t\t\t\tareaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);\n\t\t\t\t#endif\n\t\t\t\tdDiffuseLight += areaDiffuse;\n\t\t\t}\n\t\t\t#ifdef CLUSTER_SPECULAR\n\t\t\t\tfloat areaLightSpecular;\n\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\tareaLightSpecular = getRectLightSpecular();\n\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\tareaLightSpecular = getDiskLightSpecular();\n\t\t\t\t} else {\n\t\t\t\t\tareaLightSpecular = getSphereLightSpecular();\n\t\t\t\t}\n\t\t\t\tdSpecularLight += dLTCSpecFres * areaLightSpecular * dAtten * light.color * dAtten3;\n\t\t\t\t#ifdef CLUSTER_CLEAR_COAT\n\t\t\t\t\tfloat areaLightSpecularCC;\n\t\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getRectLightSpecularCC();\n\t\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getDiskLightSpecularCC();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tareaLightSpecularCC = getSphereLightSpecularCC();\n\t\t\t\t\t}\n\t\t\t\t\tccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * dAtten * light.color\t* dAtten3;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t} else\n\t\t#endif\n\t\t{\n\t\t\t{\n\t\t\t\tvec3 punctualDiffuse = dAtten * light.color * dAtten3;\n\t\t\t\t#if defined(CLUSTER_AREALIGHTS) && defined(CLUSTER_SPECULAR) && defined(CLUSTER_CONSERVE_ENERGY)\n\t\t\t\t\tpunctualDiffuse = mix(punctualDiffuse, vec3(0), dSpecularity);\n\t\t\t\t#endif\n\t\t\t\tdDiffuseLight += punctualDiffuse;\n\t\t\t}\n\t\t\t#ifdef CLUSTER_SPECULAR\n\t\t\t\t{\n\t\t\t\t\tvec3 punctualSpecular = getLightSpecular() * dAtten * light.color * dAtten3;\n\t\t\t\t\t#if defined(CLUSTER_AREALIGHTS)\n\t\t\t\t\t\tpunctualSpecular *= dSpecularity;\n\t\t\t\t\t#endif\n\t\t\t\t\tdSpecularLight += punctualSpecular;\n\t\t\t\t}\n\t\t\t\t#ifdef CLUSTER_CLEAR_COAT\n\t\t\t\t\tvec3 punctualCC = getLightSpecularCC() * dAtten * light.color * dAtten3;\n\t\t\t\t\t#if defined(CLUSTER_AREALIGHTS)\n\t\t\t\t\t\tpunctualCC *= ccSpecularity;\n\t\t\t\t\t#endif\n\t\t\t\t\tccSpecularLight += punctualCC;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t}\n\t}\n}\nvoid evaluateClusterLight(float lightIndex) {\n\tClusterLightData clusterLightData;\n\tdecodeClusterLightCore(clusterLightData, lightIndex);\n\tif (acceptLightMask(clusterLightData))\n\t\tevaluateLight(clusterLightData);\n}\nvoid addClusteredLights() {\n\tvec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);\n\tif (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {\n\t\tfloat cellIndex = dot(clusterCellsDot, cellCoords);\n\t\tfloat clusterV = floor(cellIndex * clusterTextureSize.y);\n\t\tfloat clusterU = cellIndex - (clusterV * clusterTextureSize.x);\n\t\tclusterV = (clusterV + 0.5) * clusterTextureSize.z;\n\t\tconst float maxLightCells = 256.0 / 4.0;\n\t\tfor (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {\n\t\t\tvec4 lightIndices = textureData(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV));\n\t\t\tvec4 indices = lightIndices * 255.0;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (indices.x <= 0.0)\n\t\t\t\t\treturn;\n\t\t\t\tevaluateClusterLight(indices.x);\n\t\t\t\tindices = indices.yzwx;\n\t\t\t}\n\t\t\tif (lightCellIndex > clusterPixelsPerCell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n",combineClearCoatPS:"vec3 combineColorCC() {\n\treturn combineColor()+(ccSpecularLight*ccSpecularity+ccReflection.rgb*ccSpecularity*ccReflection.a);\n}\n",combineDiffusePS:"vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight;\n}\n",combineDiffuseSpecularPS:"vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight, dSpecularLight + dReflection.rgb * dReflection.a, dSpecularity);\n}\n",combineDiffuseSpecularNoConservePS:"vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + (dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity;\n}\n",combineDiffuseSpecularNoReflPS:"vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity;\n}\n",combineDiffuseSpecularNoReflSeparateAmbientPS:"uniform vec3 material_ambient;\nvec3 combineColor() {\n\treturn (dDiffuseLight - light_globalAmbient) * dAlbedo + dSpecularLight * dSpecularity + material_ambient * light_globalAmbient;\n}\n",combineDiffuseSpecularOldPS:"vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity, dReflection.rgb, dReflection.a);\n}\n",cookiePS:"vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n\treturn mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n",cubeMapProjectBoxPS:"uniform vec3 envBoxMin, envBoxMax;\nvec3 cubeMapProject(vec3 nrdir) {\n\tnrdir = cubeMapRotate(nrdir);\n\tvec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n\tvec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n\tvec3 rbminmax;\n\trbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n\trbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n\trbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n\tfloat fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\tvec3 posonbox = vPositionW + nrdir * fa;\n\tvec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n\treturn normalize(posonbox - envBoxPos);\n}\n",cubeMapProjectNonePS:"vec3 cubeMapProject(vec3 dir) {\n\treturn cubeMapRotate(dir);\n}\n",cubeMapRotatePS:"#ifdef CUBEMAP_ROTATION\nuniform mat3 cubeMapRotationMatrix;\n#endif\nvec3 cubeMapRotate(vec3 refDir) {\n#ifdef CUBEMAP_ROTATION\n\treturn refDir * cubeMapRotationMatrix;\n#else\n\treturn refDir;\n#endif\n}\n",detailModesPS:"vec3 detailMode_mul(vec3 c1, vec3 c2) {\n\treturn c1 * c2;\n}\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n\treturn c1 + c2;\n}\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n\treturn 1.0 - (1.0 - c1)*(1.0 - c2);\n}\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n\treturn mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n\treturn min(c1, c2);\n}\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n\treturn max(c1, c2);\n}\n",diffusePS:"#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseMap;\n#endif\nvoid getAlbedo() {\n\tdAlbedo = vec3(1.0);\n\t#ifdef MAPCOLOR\n\tdAlbedo *= material_diffuse.rgb;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlbedo *= gammaCorrectInput(addAlbedoDetail(texture2D(texture_diffuseMap, $UV, textureBias).$CH));\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n}\n",diffuseDetailMapPS:"#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseDetailMap;\n#endif\nvec3 addAlbedoDetail(vec3 albedo) {\n\t#ifdef MAPTEXTURE\n\tvec3 albedoDetail = vec3(texture2D(texture_diffuseDetailMap, $UV, textureBias).$CH);\n\treturn detailMode_$DETAILMODE(albedo, albedoDetail);\n\t#else\n\treturn albedo;\n\t#endif\n}\n",dilatePS:"#define SHADER_NAME Dilate\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nvoid main(void) {\n\tvec4 c = texture2D(source, vUv0);\n\tc = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\n\tgl_FragColor = c;\n}\n",bilateralDeNoisePS:"#define SHADER_NAME BilateralDeNoise\nfloat normpdf3(in vec3 v, in float sigma) {\n\treturn 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\n}\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec3 color) {\n\tvec4 encoded;\n\tencoded.rgb = pow(color.rgb, vec3(0.5));\n\tencoded.rgb *= 1.0 / 8.0;\n\tencoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n\tencoded.a = ceil(encoded.a * 255.0) / 255.0;\n\tencoded.rgb /= encoded.a;\n\treturn encoded;\n}\n#define MSIZE 15\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nuniform vec2 sigmas;\nuniform float bZnorm;\nuniform float kernel[MSIZE];\nvoid main(void) {\n\tvec4 pixelRgbm = texture2D(source, vUv0);\n\tif (pixelRgbm.a <= 0.0) {\n\t\tgl_FragColor = pixelRgbm;\n\t\treturn ;\n\t}\n\tfloat sigma = sigmas.x;\n\tfloat bSigma = sigmas.y;\n\tvec3 pixelHdr = decodeRGBM(pixelRgbm);\n\tvec3 accumulatedHdr = vec3(0.0);\n\tfloat accumulatedFactor = 0.0;\n\tconst int kSize = (MSIZE-1)/2;\n\tfor (int i = -kSize; i <= kSize; ++i) {\n\t\tfor (int j = -kSize; j <= kSize; ++j) {\n\t\t\tvec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\n\t\t\tvec4 rgbm = texture2D(source, coord);\n\t\t\tif (rgbm.a > 0.0) {\n\t\t\t\tvec3 hdr = decodeRGBM(rgbm);\n\t\t\t\tfloat factor = kernel[kSize + j] * kernel[kSize + i];\n\t\t\t\tfactor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\n\t\t\t\taccumulatedHdr += factor * hdr;\n\t\t\t\taccumulatedFactor += factor;\n\t\t\t}\n\t\t}\n\t}\n\tgl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);\n}\n",decodePS:"vec3 decodeLinear(vec4 raw) {\n\treturn raw.rgb;\n}\nvec3 decodeGamma(vec4 raw) {\n\treturn pow(raw.xyz, vec3(2.2));\n}\nvec3 decodeRGBM(vec4 raw) {\n\tvec3 color = (8.0 * raw.a) * raw.rgb;\n\treturn color * color;\n}\nvec3 decodeRGBE(vec4 raw) {\n\tif (raw.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);\n\t}\n}\nconst float PI = 3.141592653589793;\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec2 toSphericalUv(vec3 dir) {\n\tvec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;\n\treturn vec2(uv.x, 1.0 - uv.y);\n}\nconst float atlasSize = 512.0;\nconst float seamSize = 1.0 / atlasSize;\nvec2 mapUv(vec2 uv, vec4 rect) {\n\treturn vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\n\t\t\t\tmix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\n}\nvec2 mapRoughnessUv(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));\n}\nvec2 mapMip(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));\n}\n",emissivePS:"#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_emissiveMap;\n#endif\nvec3 getEmission() {\n\tvec3 emission = vec3(1.0);\n\t#ifdef MAPFLOAT\n\temission *= material_emissiveIntensity;\n\t#endif\n\t#ifdef MAPCOLOR\n\temission *= material_emissive;\n\t#endif\n\t#ifdef MAPTEXTURE\n\temission *= $texture2DSAMPLE(texture_emissiveMap, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\temission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n\treturn emission;\n}\n",endPS:"\t#ifdef CLEARCOAT\n\tgl_FragColor.rgb = combineColorCC();\n\t#else\n\tgl_FragColor.rgb = combineColor();\n\t#endif\n\tgl_FragColor.rgb += getEmission();\n\tgl_FragColor.rgb = addFog(gl_FragColor.rgb);\n\t#ifndef HDR\n\tgl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n\tgl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n\t#endif\n",endVS:"\n",envConstPS:"vec3 processEnvironment(vec3 color) {\n\treturn color;\n}\n",envMultiplyPS:"uniform float skyboxIntensity;\nvec3 processEnvironment(vec3 color) {\n\treturn color * skyboxIntensity;\n}\n",extensionPS:"\n",extensionVS:"\n",falloffInvSquaredPS:"float getFalloffWindow(float lightRadius) {\n\tfloat sqrDist = dot(dLightDirW, dLightDirW);\n\tfloat invRadius = 1.0 / lightRadius;\n\treturn square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n}\nfloat getFalloffInvSquared(float lightRadius) {\n\tfloat sqrDist = dot(dLightDirW, dLightDirW);\n\tfloat falloff = 1.0 / (sqrDist + 1.0);\n\tfloat invRadius = 1.0 / lightRadius;\n\tfalloff *= 16.0;\n\tfalloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n\treturn falloff;\n}\n",falloffLinearPS:"float getFalloffLinear(float lightRadius) {\n\tfloat d = length(dLightDirW);\n\treturn max(((lightRadius - d) / lightRadius), 0.0);\n}\n",fixCubemapSeamsNonePS:"vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\treturn vec;\n}\nvec3 calcSeam(vec3 vec) {\n\treturn vec3(0);\n}\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n\treturn vec;\n}\n",fixCubemapSeamsStretchPS:"vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\tvec3 avec = abs(vec);\n\tfloat scale = 1.0 - exp2(mipmapIndex) / 128.0;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\tvec3 avec = abs(vec);\n\tfloat scale = 1.0 - 1.0 / 128.0;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\tvec3 avec = abs(vec);\n\tfloat scale = invRecMipSize;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 calcSeam(vec3 vec) {\n\tvec3 avec = abs(vec);\n\tfloat M = max(avec.x, max(avec.y, avec.z));\n\treturn vec3(avec.x != M ? 1.0 : 0.0,\n\t\t\t\tavec.y != M ? 1.0 : 0.0,\n\t\t\t\tavec.z != M ? 1.0 : 0.0);\n}\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n\treturn vec * (seam * -scale + vec3(1.0));\n}\n",floatUnpackingPS:"float bytes2float2(vec2 data) {\n\treturn dot(data, vec2(1.0, 1.0 / 255.0));\n}\nfloat bytes2float3(vec3 data) {\n\treturn dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));\n}\nfloat bytes2float4(vec4 data) {\n\treturn dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n}\nfloat bytes2floatRange2(vec2 data, float min, float max) {\n\treturn mix(min, max, bytes2float2(data));\n}\nfloat bytes2floatRange3(vec3 data, float min, float max) {\n\treturn mix(min, max, bytes2float3(data));\n}\nfloat bytes2floatRange4(vec4 data, float min, float max) {\n\treturn mix(min, max, bytes2float4(data));\n}\nfloat mantissaExponent2Float(vec4 pack)\n{\n\tfloat value = bytes2floatRange3(pack.xyz, -1.0, 1.0);\n\tfloat exponent = floor(pack.w * 255.0 - 127.0);\n\treturn value * exp2(exponent);\n}\n",fogExpPS:"uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n",fogExp2PS:"uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * depth * fog_density * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n",fogLinearPS:"uniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = (fog_end - depth) / (fog_end - fog_start);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\tfogFactor = gammaCorrectInput(fogFactor);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n",fogNonePS:"float dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\treturn color;\n}\n",fresnelSchlickPS:"uniform float material_fresnelFactor;\nvoid getFresnel() {\n\tfloat fresnel = 1.0 - max(dot(dNormalW, dViewDirW), 0.0);\n\tfloat fresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= dGlossiness * dGlossiness;\n\tdSpecularity = dSpecularity + (1.0 - dSpecularity) * fresnel;\n\t#ifdef CLEARCOAT\n\tfresnel = 1.0 - max(dot(ccNormalW, dViewDirW), 0.0);\n\tfresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= ccGlossiness * ccGlossiness;\n\tccSpecularity = ccSpecularity + (1.0 - ccSpecularity) * fresnel;\n\t#endif\n}\n",fullscreenQuadPS:"varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n",fullscreenQuadVS:"attribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tvUv0 = vertex_position.xy*0.5+0.5;\n}\n",gamma1_0PS:"vec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\treturn texture2D(tex, uv);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\treturn texture2D(tex, uv, bias);\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\treturn textureCube(tex, uvw);\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\treturn color;\n}\nvec3 gammaCorrectInput(vec3 color) {\n\treturn color;\n}\nfloat gammaCorrectInput(float color) {\n\treturn color;\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn color;\n}\n",gamma2_2PS:"vec3 gammaCorrectInput(vec3 color) {\n\treturn pow(color, vec3(2.2));\n}\nfloat gammaCorrectInput(float color) {\n\treturn pow(color, 2.2);\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn vec4(pow(color.rgb, vec3(2.2)), color.a);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\tvec4 rgba = texture2D(tex, uv);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\tvec4 rgba = texture2D(tex, uv, bias);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\tvec4 rgba = textureCube(tex, uvw);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\t#ifdef HDR\n\treturn color;\n\t#else\n\tcolor += vec3(0.0000001);\n\treturn pow(color, vec3(0.45));\n\t#endif\n}\n",gles3PS:"#define varying in\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define GL2\n#define SUPPORTS_TEXLOD\n",gles3VS:"#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n",glossPS:"#ifdef MAPFLOAT\nuniform float material_shininess;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_glossMap;\n#endif\nvoid getGlossiness() {\n\tdGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tdGlossiness *= material_shininess;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdGlossiness *= texture2D(texture_glossMap, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\tdGlossiness += 0.0000001;\n}\n",instancingVS:"attribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n",lightDiffuseLambertPS:"float getLightDiffuse() {\n\treturn max(dot(dNormalW, -dLightDirNormW), 0.0);\n}\n",lightDirPointPS:"void getLightDirPoint(vec3 lightPosW) {\n\tdLightDirW = vPositionW - lightPosW;\n\tdLightDirNormW = normalize(dLightDirW);\n\tdLightPosW = lightPosW;\n}\n",lightmapDirPS:"uniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\nvoid addLightMap() {\n\tvec3 color = $texture2DSAMPLE(texture_lightMap, $UV, textureBias).$CH;\n\tvec3 dir = texture2D(texture_dirLightMap, $UV, textureBias).xyz;\n\tif (dot(dir, vec3(1.0)) < 0.00001) {\n\t\tdDiffuseLight += color;\n\t} else {\n\t\tdLightDirNormW = normalize(dir * 2.0 - vec3(1.0));\n\t\tfloat vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\n\t\tfloat flight = saturate(dot(dLightDirNormW, -dNormalW));\n\t\tfloat nlight = (flight / max(vlight, 0.01)) * 0.5;\n\t\tdDiffuseLight += color * nlight * 2.0;\n\t}\n\tdSpecularLight += color * getLightSpecular();\n}\n",lightmapSinglePS:"#ifdef MAPTEXTURE\nuniform sampler2D texture_lightMap;\n#endif\nvoid addLightMap() {\n\tvec3 lm = vec3(1.0);\n\t#ifdef MAPTEXTURE\n\tlm *= $texture2DSAMPLE(texture_lightMap, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tlm *= saturate(vVertexColor.$VC);\n\t#endif\n\tdDiffuseLight += lm;\n}\n",lightmapSingleVertPS:"void addLightMap() {\n\tdDiffuseLight += saturate(vVertexColor.$CH);\n}\n",lightSpecularAnisoGGXPS:"float calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tfloat PI = 3.141592653589793;\n\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n\tfloat anisotropy = material_anisotropy * roughness;\n\tfloat at = max((roughness + anisotropy), roughness / 4.0);\n\tfloat ab = max((roughness - anisotropy), roughness / 4.0);\n\tvec3 h = normalize(normalize(-dLightDirNormW) + normalize(dViewDirW));\n\tfloat NoH = dot(tNormalW, h);\n\tfloat ToH = dot(dTBN[0], h);\n\tfloat BoH = dot(dTBN[1], h);\n\tfloat a2 = at * ab;\n\tvec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n\tfloat v2 = dot(v, v);\n\tfloat w2 = a2 / v2;\n\tfloat D = a2 * w2 * w2 * (1.0 / PI);\n\tfloat ToV = dot(dTBN[0], dViewDirW);\n\tfloat BoV = dot(dTBN[1], dViewDirW);\n\tfloat ToL = dot(dTBN[0], -dLightDirNormW);\n\tfloat BoL = dot(dTBN[1], -dLightDirNormW);\n\tfloat NoV = dot(tNormalW, dViewDirW);\n\tfloat NoL = dot(tNormalW, -dLightDirNormW);\n\tfloat lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n\tfloat lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n\tfloat G = 0.5 / (lambdaV + lambdaL);\n\treturn D * G;\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n",lightSpecularBlinnPS:"float calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tvec3 h = normalize( -dLightDirNormW + dViewDirW );\n\tfloat nh = max( dot( h, tNormalW ), 0.0 );\n\tfloat specPow = exp2(tGlossiness * 11.0);\n\tspecPow = antiAliasGlossiness(specPow);\n\tspecPow = max(specPow, 0.0001);\n\treturn pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n",lightSpecularPhongPS:"float calcLightSpecular(float tGlossiness, vec3 tReflDirW) {\n\tfloat specPow = tGlossiness;\n\tspecPow = antiAliasGlossiness(specPow);\n\treturn pow(max(dot(tReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dReflDirW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccReflDirW);\n}\n",ltc:"mat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nstruct Coords {\n\tvec3 coord0;\n\tvec3 coord1;\n\tvec3 coord2;\n\tvec3 coord3;\n};\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\n\tvec3 v1 = rectCoords.coord1 - rectCoords.coord0;\n\tvec3 v2 = rectCoords.coord3 - rectCoords.coord0;\n\tvec3 lightNormal = cross( v1, v2 );\n\tfloat factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 =\tfactor * cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords.coord0 - P );\n\tcoords[ 1 ] = mat * ( rectCoords.coord1 - P );\n\tcoords[ 2 ] = mat * ( rectCoords.coord2 - P );\n\tcoords[ 3 ] = mat * ( rectCoords.coord3 - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn result;\n}\nCoords dLTCCoords;\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\tCoords coords;\n\tcoords.coord0 = lightPos + halfWidth - halfHeight;\n\tcoords.coord1 = lightPos - halfWidth - halfHeight;\n\tcoords.coord2 = lightPos - halfWidth + halfHeight;\n\tcoords.coord3 = lightPos + halfWidth + halfHeight;\n\treturn coords;\n}\nfloat dSphereRadius;\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\tdSphereRadius = max(length(halfWidth), length(halfHeight));\n\tvec3 f = reflect(normalize(lightPos - view_position), vNormalW);\n\tvec3 w = normalize(cross(f, halfHeight));\n\tvec3 h = normalize(cross(f, w));\n\treturn getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\n}\nvec2 dLTCUV;\n#ifdef CLEARCOAT\nvec2 ccLTCUV;\n#endif\nvec2 getLTCLightUV(float tGlossiness, vec3 tNormalW)\n{\n\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n\treturn LTC_Uv( tNormalW, dViewDirW, roughness );\n}\nvec3 dLTCSpecFres;\n#ifdef CLEARCOAT\nvec3 ccLTCSpecFres;\n#endif\nvec3 getLTCLightSpecFres(vec2 uv, vec3 tSpecularity)\n{\n\tvec4 t2 = texture2D( areaLightsLutTex2, uv );\n\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\tt2 *= vec4(0.693103,1,1,1);\n\tt2 += vec4(0.306897,0,0,0);\n\t#endif\n\treturn tSpecularity * t2.x + ( vec3( 1.0 ) - tSpecularity) * t2.y;\n}\nvoid calcLTCLightValues()\n{\n\tdLTCUV = getLTCLightUV(dGlossiness, dNormalW);\n\tdLTCSpecFres = getLTCLightSpecFres(dLTCUV, dSpecularityNoFres);\n#ifdef CLEARCOAT\n\tccLTCUV = getLTCLightUV(ccGlossiness, ccNormalW);\n\tccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(ccSpecularityNoFres));\n#endif\n}\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\n}\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tcalcRectLightValues(lightPos, halfWidth, halfHeight);\n}\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\n}\nvec3 SolveCubic(vec4 Coefficient)\n{\n\tfloat pi = 3.14159;\n\tCoefficient.xyz /= Coefficient.w;\n\tCoefficient.yz /= 3.0;\n\tfloat A = Coefficient.w;\n\tfloat B = Coefficient.z;\n\tfloat C = Coefficient.y;\n\tfloat D = Coefficient.x;\n\tvec3 Delta = vec3(\n\t\t-Coefficient.z * Coefficient.z + Coefficient.y,\n\t\t-Coefficient.y * Coefficient.z + Coefficient.x,\n\t\tdot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\n\t);\n\tfloat Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\n\tvec3 RootsA, RootsD;\n\tvec2 xlc, xsc;\n\t{\n\t\tfloat A_a = 1.0;\n\t\tfloat C_a = Delta.x;\n\t\tfloat D_a = -2.0 * B * Delta.x + Delta.y;\n\t\tfloat Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\n\t\tfloat x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\n\t\tfloat x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\n\t\tfloat xl;\n\t\tif ((x_1a + x_3a) > 2.0 * B)\n\t\t\txl = x_1a;\n\t\telse\n\t\t\txl = x_3a;\n\t\txlc = vec2(xl - B, A);\n\t}\n\t{\n\t\tfloat A_d = D;\n\t\tfloat C_d = Delta.z;\n\t\tfloat D_d = -D * Delta.y + 2.0 * C * Delta.z;\n\t\tfloat Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\n\t\tfloat x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\n\t\tfloat x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\n\t\tfloat xs;\n\t\tif (x_1d + x_3d < 2.0 * C)\n\t\t\txs = x_1d;\n\t\telse\n\t\t\txs = x_3d;\n\t\txsc = vec2(-D, xs + C);\n\t}\n\tfloat E =\txlc.y * xsc.y;\n\tfloat F = -xlc.x * xsc.y - xlc.y * xsc.x;\n\tfloat G =\txlc.x * xsc.x;\n\tvec2 xmc = vec2(C * F - B * G, -B * F + C * E);\n\tvec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\n\tif (Root.x < Root.y && Root.x < Root.z)\n\t\tRoot.xyz = Root.yxz;\n\telse if (Root.z < Root.x && Root.z < Root.y)\n\t\tRoot.xyz = Root.xzy;\n\treturn Root;\n}\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\n{\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot(V, N));\n\tT2 = cross(N, T1);\n\tmat3 R = transposeMat3( mat3( T1, T2, N ) );\n\tvec3 L_[ 3 ];\n\tL_[ 0 ] = R * ( points.coord0 - P );\n\tL_[ 1 ] = R * ( points.coord1 - P );\n\tL_[ 2 ] = R * ( points.coord2 - P );\n\tvec3 Lo_i = vec3(0);\n\tvec3 C\t= 0.5 * (L_[0] + L_[2]);\n\tvec3 V1 = 0.5 * (L_[1] - L_[2]);\n\tvec3 V2 = 0.5 * (L_[1] - L_[0]);\n\tC\t= Minv * C;\n\tV1 = Minv * V1;\n\tV2 = Minv * V2;\n\tfloat a, b;\n\tfloat d11 = dot(V1, V1);\n\tfloat d22 = dot(V2, V2);\n\tfloat d12 = dot(V1, V2);\n\tif (abs(d12) / sqrt(d11 * d22) > 0.0001)\n\t{\n\t\tfloat tr = d11 + d22;\n\t\tfloat det = -d12 * d12 + d11 * d22;\n\t\tdet = sqrt(det);\n\t\tfloat u = 0.5 * sqrt(tr - 2.0 * det);\n\t\tfloat v = 0.5 * sqrt(tr + 2.0 * det);\n\t\tfloat e_max = (u + v) * (u + v);\n\t\tfloat e_min = (u - v) * (u - v);\n\t\tvec3 V1_, V2_;\n\t\tif (d11 > d22)\n\t\t{\n\t\t\tV1_ = d12 * V1 + (e_max - d11) * V2;\n\t\t\tV2_ = d12 * V1 + (e_min - d11) * V2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV1_ = d12*V2 + (e_max - d22)*V1;\n\t\t\tV2_ = d12*V2 + (e_min - d22)*V1;\n\t\t}\n\t\ta = 1.0 / e_max;\n\t\tb = 1.0 / e_min;\n\t\tV1 = normalize(V1_);\n\t\tV2 = normalize(V2_);\n\t}\n\telse\n\t{\n\t\ta = 1.0 / dot(V1, V1);\n\t\tb = 1.0 / dot(V2, V2);\n\t\tV1 *= sqrt(a);\n\t\tV2 *= sqrt(b);\n\t}\n\tvec3 V3 = cross(V1, V2);\n\tif (dot(C, V3) < 0.0)\n\t\tV3 *= -1.0;\n\tfloat L\t= dot(V3, C);\n\tfloat x0 = dot(V1, C) / L;\n\tfloat y0 = dot(V2, C) / L;\n\tfloat E1 = inversesqrt(a);\n\tfloat E2 = inversesqrt(b);\n\ta *= L * L;\n\tb *= L * L;\n\tfloat c0 = a * b;\n\tfloat c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\n\tfloat c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\n\tfloat c3 = 1.0;\n\tvec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\n\tfloat e1 = roots.x;\n\tfloat e2 = roots.y;\n\tfloat e3 = roots.z;\n\tvec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\n\tmat3 rotate = mat3(V1, V2, V3);\n\tavgDir = rotate * avgDir;\n\tavgDir = normalize(avgDir);\n\tfloat L1 = sqrt(-e2 / e3);\n\tfloat L2 = sqrt(-e2 / e1);\n\tfloat formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tvec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\n\tuv = uv*LUT_SCALE + LUT_BIAS;\n\tfloat scale = texture2D( areaLightsLutTex2, uv ).w;\n\treturn formFactor*scale;\n}\nfloat getRectLightDiffuse() {\n\treturn LTC_EvaluateRect( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getDiskLightDiffuse() {\n\treturn LTC_EvaluateDisk( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getSphereLightDiffuse() {\n\tfloat falloff = dSphereRadius / (dot(dLightDirW, dLightDirW) + dSphereRadius);\n\treturn getLightDiffuse()*falloff;\n}\nmat3 getLTCLightInvMat(vec2 uv)\n{\n\tvec4 t1 = texture2D( areaLightsLutTex1, uv );\n\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\tt1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);\n\tt1 += vec4(0.0, -0.2976, -0.01381, 0.0);\n\t#endif\n\treturn mat3(\n\t\tvec3( t1.x, 0, t1.y ),\n\t\tvec3(\t0, 1,\t0 ),\n\t\tvec3( t1.z, 0, t1.w )\n\t);\n}\nfloat calcRectLightSpecular(vec3 tNormalW, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateRect( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\n}\nfloat getRectLightSpecular() {\n\treturn calcRectLightSpecular(dNormalW, dLTCUV);\n}\n#ifdef CLEARCOAT\nfloat getRectLightSpecularCC() {\n\treturn calcRectLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\nfloat calcDiskLightSpecular(vec3 tNormalW, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateDisk( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\n}\nfloat getDiskLightSpecular() {\n\treturn calcDiskLightSpecular(dNormalW, dLTCUV);\n}\n#ifdef CLEARCOAT\nfloat getDiskLightSpecularCC() {\n\treturn calcDiskLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\nfloat getSphereLightSpecular() {\n\treturn calcDiskLightSpecular(dNormalW, dLTCUV);\n}\n#ifdef CLEARCOAT\nfloat getSphereLightSpecularCC() {\n\treturn calcDiskLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\n",metalnessPS:"void processMetalness(float metalness) {\n\tconst float dielectricF0 = 0.04;\n\tdSpecularity = mix(vec3(dielectricF0), dAlbedo, metalness);\n\tdAlbedo *= 1.0 - metalness;\n}\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_metalnessMap;\n#endif\nvoid getSpecularity() {\n\tfloat metalness = 1.0;\n\t#ifdef MAPFLOAT\n\tmetalness *= material_metalness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tmetalness *= texture2D(texture_metalnessMap, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tmetalness *= saturate(vVertexColor.$VC);\n\t#endif\n\tprocessMetalness(metalness);\n}\n",msdfPS:"uniform sampler2D texture_msdfMap;\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n#ifdef GL2\n#define USE_FWIDTH\n#endif\nfloat median(float r, float g, float b) {\n\treturn max(min(r, g), min(max(r, g), b));\n}\nfloat map (float min, float max, float v) {\n\treturn (v - min) / (max - min);\n}\nuniform float font_sdfIntensity;\nuniform float font_pxrange;\nuniform float font_textureWidth;\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\nvec4 applyMsdf(vec4 color) {\n\tvec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n\tvec2 uvShdw = vUv0 - shadow_offset;\n\tvec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n\tfloat sigDist = median(tsample.r, tsample.g, tsample.b);\n\tfloat sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\tfloat smoothingMax = 0.2;\n\t#ifdef USE_FWIDTH\n\tvec2 w = fwidth(vUv0);\n\tfloat smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\n\t#else\n\tfloat font_size = 16.0;\n\tfloat smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);\n\t#endif\n\tfloat mapMin = 0.05;\n\tfloat mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\tfloat sigDistInner = map(mapMin, mapMax, sigDist);\n\tfloat sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n\tsigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\tfloat center = 0.5;\n\tfloat inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n\tfloat outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n\tfloat shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\tvec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n\ttcolor = mix(tcolor, color, inside);\n\tvec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n\ttcolor = mix(scolor, tcolor, outline);\n\treturn tcolor;\n}\n",normalVS:"#ifdef MORPHING_TEXTURE_BASED_NORMAL\nuniform highp sampler2D morphNormalTex;\n#endif\nvec3 getNormal() {\n\t#ifdef SKIN\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\t#elif defined(INSTANCING)\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\t#else\n\tdNormalMatrix = matrix_normal;\n\t#endif\n\tvec3 tempNormal = vertex_normal;\n\t#ifdef MORPHING\n\t#ifdef MORPHING_NRM03\n\ttempNormal += morph_weights_a[0] * morph_nrm0;\n\ttempNormal += morph_weights_a[1] * morph_nrm1;\n\ttempNormal += morph_weights_a[2] * morph_nrm2;\n\ttempNormal += morph_weights_a[3] * morph_nrm3;\n\t#endif\n\t#ifdef MORPHING_NRM47\n\ttempNormal += morph_weights_b[0] * morph_nrm4;\n\ttempNormal += morph_weights_b[1] * morph_nrm5;\n\ttempNormal += morph_weights_b[2] * morph_nrm6;\n\ttempNormal += morph_weights_b[3] * morph_nrm7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_NORMAL\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;\n\ttempNormal += morphNormal;\n\t#endif\n\treturn normalize(dNormalMatrix * tempNormal);\n}\n",normalDetailMapPS:"#ifdef MAPTEXTURE\nuniform sampler2D texture_normalDetailMap;\nuniform float material_normalDetailMapBumpiness;\nvec3 blendNormals(vec3 n1, vec3 n2) {\n\tn1 += vec3(0, 0, 1);\n\tn2 *= vec3(-1, -1, 1);\n\treturn normalize(n1*dot(n1, n2)/n1.z - n2);\n}\n#endif\nvec3 addNormalDetail(vec3 normalMap) {\n\t#ifdef MAPTEXTURE\n\tvec3 normalDetailMap = unpackNormal(texture2D(texture_normalDetailMap, $UV, textureBias));\n\tnormalDetailMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness));\n\treturn blendNormals(normalMap, normalDetailMap);\n\t#else\n\treturn normalMap;\n\t#endif\n}\n",normalInstancedVS:"vec3 getNormal() {\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n",normalMapPS:"uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV, textureBias));\n\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n}\n",normalMapFastPS:"uniform sampler2D texture_normalMap;\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV, textureBias));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n}\n",normalSkinnedVS:"vec3 getNormal() {\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n",normalVertexPS:"void getNormal() {\n\tdNormalW = normalize(dVertexNormalW);\n}\n",normalXYPS:"vec3 unpackNormal(vec4 nmap) {\n\tvec3 normal;\n\tnormal.xy = nmap.wy * 2.0 - 1.0;\n\tnormal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\treturn normal;\n}\n",normalXYZPS:"vec3 unpackNormal(vec4 nmap) {\n\treturn nmap.xyz * 2.0 - 1.0;\n}\n",opacityPS:"#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_opacityMap;\n#endif\nvoid getOpacity() {\n\tdAlpha = 1.0;\n\t#ifdef MAPFLOAT\n\tdAlpha *= material_opacity;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlpha *= texture2D(texture_opacityMap, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n\t#endif\n}\n",outputAlphaPS:"gl_FragColor.a = dAlpha;\n",outputAlphaOpaquePS:"gl_FragColor.a = 1.0;\n",outputAlphaPremulPS:"gl_FragColor.rgb *= dAlpha;\ngl_FragColor.a = dAlpha;\n",outputTex2DPS:"varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n",packDepthPS:"vec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask\t= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n",parallaxPS:"uniform sampler2D texture_heightMap;\nuniform float material_heightMapFactor;\nvoid getParallax() {\n\tfloat parallaxScale = material_heightMapFactor;\n\tfloat height = texture2D(texture_heightMap, $UV, textureBias).$CH;\n\theight = height * parallaxScale - parallaxScale*0.5;\n\tvec3 viewDirT = dViewDirW * dTBN;\n\tviewDirT.z += 0.42;\n\tdUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n",particlePS:"varying vec4 texCoordsAlphaLife;\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nuniform float softening;\nuniform float colorMult;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\tfloat depth = dot(rgbaDepth, bitShift);\n\treturn depth;\n}\n#endif\nvoid main(void) {\n\tvec4 tex\t= texture2DSRGB(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y));\n\tvec4 ramp = texture2DSRGB(colorParam, vec2(texCoordsAlphaLife.w, 0.0));\n\tramp.rgb *= colorMult;\n\tramp.a += texCoordsAlphaLife.z;\n\tvec3 rgb = tex.rgb * ramp.rgb;\n\tfloat a\t= tex.a * ramp.a;\n",particleVS:"vec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {\n\treturn mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex,tc);\n\tvec4 b = texture2D(tex,tc + graphSampleSize);\n\tfloat c = fract(tc.x*graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a, b, c);\n}\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n\t#ifdef SCREEN_SPACE\n\t\tvec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n\t#else\n\t\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\t#endif\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvec2 safeNormalize(vec2 v) {\n\tfloat l = length(v);\n\treturn (l > 1e-06) ? v / l : v;\n}\nvoid main(void) {\n\tvec3 meshLocalPos = particle_vertexData.xyz;\n\tfloat id = floor(particle_vertexData.w);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\tfloat uv = id / numParticlesPot;\n\treadInput(uv);\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);\n\tfloat particleLifetime = lifetime;\n\tif (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n\tvec2 quadXY = meshLocalPos.xy;\n\tfloat nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\tvec3 paramDiv;\n\tvec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat scale = params.y;\n\tfloat scaleDiv = paramDiv.x;\n\tfloat alphaDiv = paramDiv.z;\n\tscale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n#ifndef USE_MESH\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n\ttexCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n\tvec3 particlePos = inPos;\n\tvec3 particlePosMoved = vec3(0.0);\n\tmat2 rotMatrix;\n",particleAnimFrameClampVS:"\tfloat animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n",particleAnimFrameLoopVS:"\tfloat animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n",particleAnimTexVS:"\tfloat animationIndex;\n\tif (animTexIndexParams.y == 1.0) {\n\t\tanimationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n\t} else {\n\t\tanimationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n\t}\n\tfloat atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n\tfloat atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n\tatlasX = fract(atlasX);\n\ttexCoordsAlphaLife.xy *= animTexTilesParams.xy;\n\ttexCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n",particleInputFloatPS:"void readInput(float uv) {\n\tvec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n\tinPos = tex.xyz;\n\tinVel = tex2.xyz;\n\tinAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n\tinShow = tex.w >= 0.0;\n\tinLife = tex2.w;\n}\n",particleInputRgba8PS:"#define PI2 6.283185307179586\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\nuniform float maxVel;\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat decodeFloatRGBA( vec4 rgba ) {\n\treturn dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\nvoid readInput(float uv) {\n\tvec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n\tvec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n\tvec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n\tinPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n\tinPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n\tinVel = tex2.xyz;\n\tinVel = (inVel - vec3(0.5)) * maxVel;\n\tinAngle = decodeFloatRG(tex1.ba) * PI2;\n\tinShow = tex2.a > 0.5;\n\tinLife = decodeFloatRGBA(tex3);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\tinLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n",particleOutputFloatPS:"void writeOutput() {\n\tif (gl_FragCoord.y<1.0) {\n\t\tgl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n\t} else {\n\t\tgl_FragColor = vec4(outVel, outLife);\n\t}\n}\n",particleOutputRgba8PS:"uniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\nvec4 encodeFloatRGBA( float v ) {\n\tvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n\treturn enc;\n}\nvoid writeOutput() {\n\toutPos = outPos * outBoundsMul + outBoundsAdd;\n\toutAngle = fract(outAngle / PI2);\n\toutVel = (outVel / maxVel) + vec3(0.5);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\toutLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\tif (gl_FragCoord.y < 1.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n\t} else if (gl_FragCoord.y < 2.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n\t} else if (gl_FragCoord.y < 3.0) {\n\t\tgl_FragColor = vec4(outVel, visMode*0.5+0.5);\n\t} else {\n\t\tgl_FragColor = encodeFloatRGBA(outLife);\n\t}\n}\n",particleUpdaterAABBPS:"uniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tvec3 pos = inBounds - vec3(0.5);\n\tvec3 posAbs = abs(pos);\n\tvec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n\tvec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n\tpos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n\tpos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n\tpos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n#ifndef LOCAL_SPACE\n\treturn emitterPos + spawnBounds * pos;\n#else\n\treturn spawnBounds * pos;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity -= vec3(0, 0, initialVelocity);\n}\n",particleUpdaterEndPS:"\twriteOutput();\n}\n",particleUpdaterInitPS:"varying vec2 vUv0;\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\nuniform mat3 emitterMatrix, emitterMatrixInv;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;\nuniform float startAngle, startAngle2;\nuniform float initialVelocity;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n",particleUpdaterNoRespawnPS:"\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = -1.0;\n\t}\n",particleUpdaterOnStopPS:"\tvisMode = outLife < 0.0? -1.0: visMode;\n",particleUpdaterRespawnPS:"\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = 1.0;\n\t}\n\tvisMode = outLife < 0.0? 1.0: visMode;\n",particleUpdaterSpherePS:"uniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tfloat rnd4 = fract(rndFactor * 1000.0);\n\tvec3 norm = normalize(inBounds.xyz - vec3(0.5));\n\tfloat r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n\treturn emitterPos + norm * r * spawnBoundsSphere;\n#else\n\treturn norm * r * spawnBoundsSphere;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n",particleUpdaterStartPS:"float saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nvec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex, tc);\n\tvec4 b = texture2D(tex, tc + graphSampleSize);\n\tfloat c = fract(tc.x * graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a.xyz, b.xyz, c);\n}\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\nvoid main(void) {\n\tif (gl_FragCoord.x > numParticles) discard;\n\treadInput(vUv0.x);\n\tvisMode = inShow? 1.0 : -1.0;\n\tvec4 rndFactor = hash41(gl_FragCoord.x + seed);\n\tfloat particleRate = rate + rateDiv * rndFactor.x;\n\toutLife = inLife + delta;\n\tfloat nlife = clamp(outLife / lifetime, 0.0, 1.0);\n\tvec3 localVelocityDiv;\n\tvec3 velocityDiv;\n\tvec3 paramDiv;\n\tvec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\n\tvec3 velocity =\t\ttex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\n\tvec3 params =\t\ttex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat rotSpeed = params.x;\n\tfloat rotSpeedDiv = paramDiv.y;\n\tvec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);\n\tfloat radialSpeed = radialParams.x;\n\tfloat radialSpeedDiv = radialParams.y;\n\tbool respawn = inLife <= 0.0 || outLife >= lifetime;\n\tinPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n\tinAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n#ifndef LOCAL_SPACE\n\tvec3 radialVel = inPos - emitterPos;\n#else\n\tvec3 radialVel = inPos;\n#endif\n\tradialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n\tradialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n\tlocalVelocity +=\t(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n\tvelocity +=\t\t (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n\trotSpeed +=\t\t (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n\taddInitialVelocity(localVelocity, rndFactor.xyz);\n#ifndef LOCAL_SPACE\n\toutVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n\toutVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n\toutPos = inPos + outVel * delta;\n\toutAngle = inAngle + rotSpeed * delta;\n",particle_billboardVS:"\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = billboard(particlePos, quadXY);\n",particle_blendAddPS:"\tdBlendModeFogFactor = 0.0;\n\trgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n\tif ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n",particle_blendMultiplyPS:"\trgb = mix(vec3(1.0), rgb, vec3(a));\n\tif (rgb.r + rgb.g + rgb.b > 2.99) discard;\n",particle_blendNormalPS:"\tif (a < 0.01) discard;\n",particle_cpuVS:"attribute vec4 particle_vertexData;\nattribute vec4 particle_vertexData2;\nattribute vec4 particle_vertexData3;\nattribute float particle_vertexData4;\n#ifndef USE_MESH\n#define VDATA5TYPE vec2\n#else\n#define VDATA5TYPE vec4\n#endif\nattribute VDATA5TYPE particle_vertexData5;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds, emitterScale, faceTangent, faceBinorm;\nuniform sampler2D texLifeAndSourcePosOUT;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform vec3 emitterPos;\nvarying vec4 texCoordsAlphaLife;\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvoid main(void)\n{\n\tvec3 particlePos = particle_vertexData.xyz;\n\tvec3 inPos = particlePos;\n\tvec3 vertPos = particle_vertexData3.xyz;\n\tvec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n\tfloat id = floor(particle_vertexData4);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);\n\tvec2 quadXY = vertPos.xy;\n#ifdef USE_MESH\n\ttexCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#else\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#endif\n\tmat2 rotMatrix;\n\tfloat inAngle = particle_vertexData2.x;\n\tvec3 particlePosMoved = vec3(0.0);\n\tvec3 meshLocalPos = particle_vertexData3.xyz;\n",particle_cpu_endVS:"\tlocalPos *= particle_vertexData2.y * emitterScale;\n\tlocalPos += particlePos;\n\tgl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n",particle_customFaceVS:"\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = customFace(particlePos, quadXY);\n",particle_endPS:"\trgb = addFog(rgb);\n\trgb = toneMap(rgb);\n\trgb = gammaCorrectOutput(rgb);\n\tgl_FragColor = vec4(rgb, a);\n}\n",particle_endVS:"\tlocalPos *= scale * emitterScale;\n\tlocalPos += particlePos;\n\t#ifdef SCREEN_SPACE\n\tgl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n\t#else\n\tgl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n\t#endif\n",particle_halflambertPS:"\tvec3 negNormal = normal*0.5+0.5;\n\tvec3 posNormal = -normal*0.5+0.5;\n\tnegNormal *= negNormal;\n\tposNormal *= posNormal;\n",particle_initVS:"attribute vec4 particle_vertexData;\n#ifdef USE_MESH\nattribute vec2 particle_uv;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform float numParticles, numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\nuniform sampler2D particleTexOUT, particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nvarying vec4 texCoordsAlphaLife;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n",particle_lambertPS:"\tvec3 negNormal = max(normal, vec3(0.0));\n\tvec3 posNormal = max(-normal, vec3(0.0));\n",particle_lightingPS:"\tvec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n\t\t\t\t\t\tnegNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n\t\t\t\t\t\tnegNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n\trgb *= light;\n",particle_localShiftVS:"\tparticlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n",particle_meshVS:"\tvec3 localPos = meshLocalPos;\n\tlocalPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n\tlocalPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n\tbillboard(particlePos, quadXY);\n",particle_normalVS:"\tNormal = normalize(localPos + matrix_viewInverse[2].xyz);\n",particle_normalMapPS:"\tvec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\n\tvec3 normal = ParticleMat * normalMap;\n",particle_pointAlongVS:"\tinAngle = atan(velocityV.x, velocityV.y);\n",particle_softPS:"\tfloat depth = getLinearScreenDepth();\n\tfloat particleDepth = vDepth;\n\tfloat depthDiff = saturate(abs(particleDepth - depth) * softening);\n\ta *= depthDiff;\n",particle_softVS:"\tvDepth = getLinearDepth(localPos);\n",particle_stretchVS:"\tvec3 moveDir = inVel * stretch;\n\tvec3 posPrev = particlePos - moveDir;\n\tposPrev += particlePosMoved;\n\tvec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n\tfloat interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n\tparticlePos = mix(particlePos, posPrev, interpolation);\n",particle_TBNVS:"\tmat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n\tParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n",particle_wrapVS:"\tvec3 origParticlePos = particlePos;\n\tparticlePos -= matrix_model[3].xyz;\n\tparticlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n\tparticlePos += matrix_model[3].xyz;\n\tparticlePosMoved = particlePos - origParticlePos;\n",precisionTestPS:"void main(void) {\n\tgl_FragColor = vec4(2147483648.0);\n}\n",precisionTest2PS:"uniform sampler2D source;\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask\t= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main(void) {\n\tfloat c = texture2D(source, vec2(0.0)).r;\n\tfloat diff = abs(c - 2147483648.0) / 2147483648.0;\n\tgl_FragColor = packFloat(diff);\n}\n",reflDirPS:"void getReflDir() {\n\tdReflDirW = normalize(-reflect(dViewDirW, dNormalW));\n}\n",reflDirAnisoPS:"void getReflDir() {\n\tfloat roughness = sqrt(1.0 - min(dGlossiness, 1.0));\n\tfloat anisotropy = material_anisotropy * roughness;\n\tvec3 anisotropicDirection = anisotropy >= 0.0 ? dTBN[1] : dTBN[0];\n\tvec3 anisotropicTangent = cross(anisotropicDirection, dViewDirW);\n\tvec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n\tvec3 bentNormal = normalize(mix(normalize(dNormalW), normalize(anisotropicNormal), anisotropy));\n\tdReflDirW = reflect(-dViewDirW, bentNormal);\n}\n",reflectionCCPS:"#ifdef CLEARCOAT\nuniform float material_clearCoatReflectivity;\nvoid addReflectionCC() {\n\tccReflection += vec4(calcReflection(ccReflDirW, ccGlossiness), material_clearCoatReflectivity);\n}\n#endif\n",reflectionCubePS:"uniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 lookupVec = fixSeams(cubeMapProject(tReflDirW));\n\tlookupVec.x *= -1.0;\n\treturn $DECODE(textureCube(texture_cubeMap, lookupVec));\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",reflectionEnvPS:"#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform float material_reflectivity;\nfloat shinyMipLevel(vec2 uv) {\n\tvec2 dx = dFdx(uv);\n\tvec2 dy = dFdy(uv);\n\tvec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\n\tvec2 dx2 = dFdx(uv2);\n\tvec2 dy2 = dFdy(uv2);\n\tfloat maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\n\treturn clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);\n}\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 dir = cubeMapProject(tReflDirW) * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(dir);\n\tfloat level = saturate(1.0 - tGlossiness) * 5.0;\n\tfloat ilevel = floor(level);\n\tfloat level2 = shinyMipLevel(uv * atlasSize);\n\tfloat ilevel2 = floor(level2);\n\tvec2 uv0, uv1;\n\tfloat weight;\n\tif (ilevel == 0.0) {\n\t\tuv0 = mapMip(uv, ilevel2);\n\t\tuv1 = mapMip(uv, ilevel2 + 1.0);\n\t\tweight = level2 - ilevel2;\n\t} else {\n\t\tuv0 = uv1 = mapRoughnessUv(uv, ilevel);\n\t\tweight = 0.0;\n\t}\n\tvec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));\n\tvec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));\n\tvec3 linear0 = mix(linearA, linearB, weight);\n\tvec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\treturn processEnvironment(mix(linear0, linear1, level - ilevel));\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",reflectionSpherePS:"#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = (mat3(matrix_view) * tReflDirW).xyz;\n\tfloat m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n\tvec2 sphereMapUv = reflDirV.xy / m + 0.5;\n\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",reflectionSphereLowPS:"uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = vNormalV;\n\tvec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\n\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n",refractionPS:"uniform float material_refraction, material_refractionIndex;\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n\tfloat vn = dot(viewVec, Normal);\n\tfloat k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n\tvec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n\treturn refrVec;\n}\nvoid addRefraction() {\n\tvec3 tmp = dReflDirW;\n\tvec4 tmp2 = dReflection;\n\tdReflection = vec4(0.0);\n\tdReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\n\taddReflection();\n\tdDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, material_refraction);\n\tdReflDirW = tmp;\n\tdReflection = tmp2;\n}\n",reprojectPS:"varying vec2 vUv0;\nuniform sampler2D sourceTex;\nuniform samplerCube sourceCube;\nuniform sampler2D samplesTex;\nuniform vec2 samplesTexInverseSize;\nuniform vec4 params;\nuniform vec2 params2;\nfloat targetFace() { return params.x; }\nfloat specularPower() { return params.y; }\nfloat sourceCubeSeamScale() { return params.z; }\nfloat targetCubeSeamScale() { return params.w; }\nfloat targetTotalPixels() { return params2.x; }\nfloat sourceTotalPixels() { return params2.y; }\nfloat PI = 3.141592653589793;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 decodeLinear(vec4 source) {\n\treturn source.rgb;\n}\nvec4 encodeLinear(vec3 source) {\n\treturn vec4(source, 1.0);\n}\nvec3 decodeGamma(vec4 source) {\n\treturn pow(source.xyz, vec3(2.2));\n}\nvec4 encodeGamma(vec3 source) {\n\treturn vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nvec4 encodeRGBM(vec3 source) {\n\tvec4 result;\n\tresult.rgb = pow(source.rgb, vec3(0.5));\n\tresult.rgb *= 1.0 / 8.0;\n\tresult.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n\tresult.a = ceil(result.a * 255.0) / 255.0;\n\tresult.rgb /= result.a;\n\treturn result;\n}\nvec3 decodeRGBE(vec4 source) {\n\tif (source.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn source.xyz * pow(2.0, source.w * 255.0 - 128.0);\n\t}\n}\nvec4 encodeRGBE(vec3 source) {\n\tfloat maxVal = max(source.x, max(source.y, source.z));\n\tif (maxVal < 1e-32) {\n\t\treturn vec4(0, 0, 0, 0);\n\t} else {\n\t\tfloat e = ceil(log2(maxVal));\n\t\treturn vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n\t}\n}\nvec3 modifySeams(vec3 dir, float scale) {\n\tvec3 adir = abs(dir);\n\tfloat M = max(max(adir.x, adir.y), adir.z);\n\treturn dir / M * vec3(\n\t\tadir.x == M ? 1.0 : scale,\n\t\tadir.y == M ? 1.0 : scale,\n\t\tadir.z == M ? 1.0 : scale\n\t);\n}\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec3 fromSpherical(vec2 uv) {\n\treturn vec3(cos(uv.y) * sin(uv.x),\n\t\t\t\tsin(uv.y),\n\t\t\t\tcos(uv.y) * cos(uv.x));\n}\nvec3 getDirectionEquirect() {\n\treturn fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\nvec4 sampleEquirect(vec2 sph) {\n\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n}\nvec4 sampleEquirect(vec3 dir) {\n\treturn sampleEquirect(toSpherical(dir));\n}\nvec4 sampleCubemap(vec3 dir) {\n\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));\n}\nvec4 sampleCubemap(vec2 sph) {\n\treturn sampleCubemap(fromSpherical(sph));\n}\nvec4 sampleEquirect(vec2 sph, float mipLevel) {\n\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n#ifdef SUPPORTS_TEXLOD\n\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n#else\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n#endif\n}\nvec4 sampleEquirect(vec3 dir, float mipLevel) {\n\treturn sampleEquirect(toSpherical(dir), mipLevel);\n}\nvec4 sampleCubemap(vec3 dir, float mipLevel) {\n#ifdef SUPPORTS_TEXLOD\n\treturn textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);\n#else\n\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()));\n#endif\n}\nvec4 sampleCubemap(vec2 sph, float mipLevel) {\n\treturn sampleCubemap(fromSpherical(sph), mipLevel);\n}\nfloat signNotZero(float k){\n\treturn(k >= 0.0) ? 1.0 : -1.0;\n}\nvec2 signNotZero(vec2 v) {\n\treturn vec2(signNotZero(v.x), signNotZero(v.y));\n}\nvec3 octDecode(vec2 o) {\n\tvec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\n\tif (v.y < 0.0) {\n\t\tv.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);\n\t}\n\treturn normalize(v);\n}\nvec3 getDirectionOctahedral() {\n\treturn octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);\n}\nvec2 octEncode(in vec3 v) {\n\tfloat l1norm = abs(v.x) + abs(v.y) + abs(v.z);\n\tvec2 result = v.xz * (1.0 / l1norm);\n\tif (v.y < 0.0) {\n\t\tresult = (1.0 - abs(result.yx)) * signNotZero(result.xy);\n\t}\n\treturn result;\n}\nvec4 sampleOctahedral(vec3 dir) {\n\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n}\nvec4 sampleOctahedral(vec2 sph) {\n\treturn sampleOctahedral(fromSpherical(sph));\n}\nvec4 sampleOctahedral(vec3 dir, float mipLevel) {\n\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n#ifdef SUPPORTS_TEXLOD\n\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n#else\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n#endif\n}\nvec4 sampleOctahedral(vec2 sph, float mipLevel) {\n\treturn sampleOctahedral(fromSpherical(sph), mipLevel);\n}\nvec3 getDirectionCubemap() {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = targetFace();\n\tvec3 vec;\n\tif (face == 0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face == 1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face == 2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face == 3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face == 4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\treturn normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));\n}\nmat3 matrixFromVector(vec3 n) {\n\tfloat a = 1.0 / (1.0 + n.z);\n\tfloat b = -n.x * n.y * a;\n\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\treturn mat3(b1, b2, n);\n}\nmat3 matrixFromVectorSlow(vec3 n) {\n\tvec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);\n\tvec3 x = normalize(cross(up, n));\n\tvec3 y = cross(n, x);\n\treturn mat3(x, y, n);\n}\nvec4 reproject() {\n\tif (NUM_SAMPLES <= 1) {\n\t\treturn ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\n\t} else {\n\t\tvec2 sph = toSpherical(TARGET_FUNC());\n\t\tvec2 sphu = dFdx(sph);\n\t\tvec2 sphv = dFdy(sph);\n\t\tconst float NUM_SAMPLES_SQRT = sqrt(float(NUM_SAMPLES));\n\t\tvec3 result = vec3(0.0);\n\t\tfor (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {\n\t\t\tfor (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {\n\t\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(sph +\n\t\t\t\t\t\t\t\t\t\t\t\t\tsphu * (u / NUM_SAMPLES_SQRT - 0.5) +\n\t\t\t\t\t\t\t\t\t\t\t\t\tsphv * (v / NUM_SAMPLES_SQRT - 0.5)));\n\t\t\t}\n\t\t}\n\t\treturn ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));\n\t}\n}\nvec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\nvoid unpackSample(int i, out vec3 L, out float mipLevel) {\n\tfloat u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;\n\tfloat v = (floor(u) + 0.5) * samplesTexInverseSize.y;\n\tvec4 raw;\n\traw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\traw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\traw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\traw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);\n\tL.xyz = raw.xyz * 2.0 - 1.0;\n\tmipLevel = raw.w * 8.0;\n}\nvec4 prefilterSamples() {\n\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\tvec3 L;\n\tfloat mipLevel;\n\tvec3 result = vec3(0.0);\n\tfloat totalWeight = 0.0;\n\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\tunpackSample(i, L, mipLevel);\n\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;\n\t\ttotalWeight += L.z;\n\t}\n\treturn ENCODE_FUNC(result / totalWeight);\n}\nvec4 prefilterSamplesUnweighted() {\n\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\tvec3 L;\n\tfloat mipLevel;\n\tvec3 result = vec3(0.0);\n\tfloat totalWeight = 0.0;\n\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\tunpackSample(i, L, mipLevel);\n\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));\n\t}\n\treturn ENCODE_FUNC(result / float(NUM_SAMPLES));\n}\nvoid main(void) {\n\tgl_FragColor = PROCESS_FUNC();\n}\n",rgbmPS:"vec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n\treturn decodeRGBM(texture2D(tex, uv));\n}\nvec3 texture2DRGBM(sampler2D tex, vec2 uv, float bias) {\n\treturn decodeRGBM(texture2D(tex, uv, bias));\n}\nvec3 textureCubeRGBM(samplerCube tex, vec3 uvw) {\n\treturn decodeRGBM(textureCube(tex, uvw));\n}\n",screenDepthPS:"uniform highp sampler2D uDepthMap;\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n#ifdef GL2\nfloat linearizeDepth(float z) {\n\tz = z * 2.0 - 1.0;\n\treturn 1.0 / (camera_params.z * z + camera_params.w);\n}\n#else\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#endif\nfloat getLinearScreenDepth(vec2 uv) {\n\t#ifdef GL2\n\treturn linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y;\n\t#else\n\treturn unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y;\n\t#endif\n}\n#ifndef VERTEXSHADER\nfloat getLinearScreenDepth() {\n\tvec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n\treturn getLinearScreenDepth(uv);\n}\n#endif\nfloat getLinearDepth(vec3 pos) {\n\treturn -(matrix_view * vec4(pos, 1.0)).z;\n}\n",shadowCascadesPS:"const float maxCascades = 4.0;\nmat4 cascadeShadowMat;\nvoid getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {\n\tfloat depth = 1.0 / gl_FragCoord.w;\n\tfloat cascadeIndex = 0.0;\n\tfor (float i = 0.0; i < maxCascades; i++) {\n\t\tif (depth < shadowCascadeDistances[int(i)]) {\n\t\t\tcascadeIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);\n\t#ifdef GL2\n\t\tcascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];\n\t#else\n\t\tif (cascadeIndex == 0.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[0];\n\t\t}\n\t\telse if (cascadeIndex == 1.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[1];\n\t\t}\n\t\telse if (cascadeIndex == 2.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[2];\n\t\t}\n\t\telse {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[3];\n\t\t}\n\t#endif\n}\nvoid fadeShadow(float shadowCascadeDistances[4]) {\n\tfloat depth = 1.0 / gl_FragCoord.w;\n\tif (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {\n\t\tdShadowCoord.z = -9999999.0;\n\t}\n}\n",shadowCommonPS:"void normalOffsetPointShadow(vec4 shadowParams) {\n\tfloat distScale = length(dLightDirW);\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\tvec3 dir = wPos - dLightPosW;\n\tdLightDirW = dir;\n}\n",shadowCoordPS:"void _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n\tdShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\n\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xy /= projPos.w;\n\tdShadowCoord.xy = projPos.xy;\n\tdShadowCoord.z = length(dLightDirW) * shadowParams.w;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0);\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n",shadowCoordPerspZbufferPS:"void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xyz /= projPos.w;\n\tdShadowCoord = projPos.xyz;\n}\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\n}\n",shadowEVSMPS:"float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec3 moments = texture2D(tex, texCoords).xyz;\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n",shadowEVSMnPS:"float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tfloat pixelSize = 1.0 / resolution;\n\ttexCoords -= vec2(pixelSize);\n\tvec3 s00 = texture2D(tex, texCoords).xyz;\n\tvec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n\tvec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n\tvec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n\tvec2 fr = fract(texCoords * resolution);\n\tvec3 h0 = mix(s00, s10, fr.x);\n\tvec3 h1 = mix(s01, s11, fr.x);\n\tvec3 moments = mix(h0, h1, fr.y);\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n",shadowStandardPS:"vec3 lessThan2(vec3 a, vec3 b) {\n\treturn clamp((b - a)*1000.0, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#ifdef GL2\nfloat _getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat sum = 0.0;\n\tfloat uw0 = (3.0 - 2.0 * s);\n\tfloat uw1 = (1.0 + 2.0 * s);\n\tfloat u0 = (2.0 - s) / uw0 - 1.0;\n\tfloat u1 = s / uw1 + 1.0;\n\tfloat vw0 = (3.0 - 2.0 * t);\n\tfloat vw1 = (1.0 + 2.0 * t);\n\tfloat v0 = (2.0 - t) / vw0 - 1.0;\n\tfloat v1 = t / vw1 + 1.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\tsum *= 1.0f / 16.0;\n\treturn sum;\n}\nfloat getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF3x3(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#else\nfloat _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\n\tmat3 shadowKernel;\n\tvec3 shadowCoord = dShadowCoord;\n\tvec3 shadowZ = vec3(shadowCoord.z);\n\tshadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n\tvec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\tvec3 shadowCoord = dShadowCoord;\n\tfloat xoffset = 1.0 / shadowParams.x;\n\tfloat dx0 = -xoffset;\n\tfloat dx1 = xoffset;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n\tdepthKernel[0][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n\tdepthKernel[0][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n\tdepthKernel[1][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n\tdepthKernel[1][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy));\n\tdepthKernel[1][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n\tdepthKernel[2][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n\tdepthKernel[2][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n\tdepthKernel[2][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n\treturn _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\n}\nfloat getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#endif\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n\tvec3 tc = normalize(dir);\n\tvec3 tcAbs = abs(tc);\n\tvec4 dirX = vec4(1,0,0, tc.x);\n\tvec4 dirY = vec4(0,1,0, tc.y);\n\tfloat majorAxisLength = tc.z;\n\tif ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n\t\tdirX = vec4(0,0,1, tc.z);\n\t\tdirY = vec4(0,1,0, tc.y);\n\t\tmajorAxisLength = tc.x;\n\t} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n\t\tdirX = vec4(1,0,0, tc.x);\n\t\tdirY = vec4(0,0,1, tc.z);\n\t\tmajorAxisLength = tc.y;\n\t}\n\tfloat shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n\tvec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n\tvec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n\tvec3 dx0 = -xoffset;\n\tvec3 dy0 = -yoffset;\n\tvec3 dx1 = xoffset;\n\tvec3 dy1 = yoffset;\n\tmat3 shadowKernel;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n\tdepthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n\tdepthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n\tdepthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n\tdepthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n\tdepthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n\tdepthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n\tdepthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n\tdepthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n\tvec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n\tshadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n\tvec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n\tvec2 fractionalCoord = fract( uv * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\n\treturn _getShadowPoint(shadowMap, shadowParams, dLightDirW);\n}\n",shadowStandardGL2PS:"float _getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat uw0 = (4.0 - 3.0 * s);\n\tfloat uw1 = 7.0;\n\tfloat uw2 = (1.0 + 3.0 * s);\n\tfloat u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n\tfloat u1 = (3.0 + s) / uw1;\n\tfloat u2 = s / uw2 + 2.0;\n\tfloat vw0 = (4.0 - 3.0 * t);\n\tfloat vw1 = 7.0;\n\tfloat vw2 = (1.0 + 3.0 * t);\n\tfloat v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n\tfloat v1 = (3.0 + t) / vw1;\n\tfloat v2 = t / vw2 + 2.0;\n\tfloat sum = 0.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tu2 = u2 * shadowMapSizeInv + base_uv.x;\n\tv2 = v2 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw2 * vw0 * texture(shadowMap, vec3(u2, v0, z));\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\tsum += uw2 * vw1 * texture(shadowMap, vec3(u2, v1, z));\n\tsum += uw0 * vw2 * texture(shadowMap, vec3(u0, v2, z));\n\tsum += uw1 * vw2 * texture(shadowMap, vec3(u1, v2, z));\n\tsum += uw2 * vw2 * texture(shadowMap, vec3(u2, v2, z));\n\tsum *= 1.0f / 144.0;\n\tsum = gammaCorrectInput(sum);\n\tsum = saturate(sum);\n\treturn sum;\n}\nfloat getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF5x5(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams.xyz);\n}\n",shadowVSM8PS:"float calculateVSM8(vec3 moments, float Z, float vsmBias) {\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * Z;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec4 c = texture2D(tex, texCoords);\n\tvec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n\treturn calculateVSM8(moments, Z, vsmBias);\n}\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\n}\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n",shadowVSM_commonPS:"float linstep(float a, float b, float v) {\n\treturn saturate((v - a) / (b - a));\n}\nfloat reduceLightBleeding(float pMax, float amount) {\n\t return linstep(amount, 1.0, pMax);\n}\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n\tfloat variance = moments.y - (moments.x * moments.x);\n\tvariance = max(variance, minVariance);\n\tfloat d = mean - moments.x;\n\tfloat pMax = variance / (variance + (d * d));\n\tpMax = reduceLightBleeding(pMax, lightBleedingReduction);\n\treturn (mean <= moments.x ? 1.0 : pMax);\n}\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n\tZ = 2.0 * Z - 1.0;\n\tfloat warpedDepth = exp(exponent * Z);\n\tmoments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * exponent * warpedDepth;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n",skinBatchConstVS:"attribute float vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nmat4 getBoneMatrix(const in float i) {\n\tvec4 v1 = matrix_pose[int(3.0 * i)];\n\tvec4 v2 = matrix_pose[int(3.0 * i + 1.0)];\n\tvec4 v3 = matrix_pose[int(3.0 * i + 2.0)];\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n",skinBatchTexVS:"attribute float vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tvec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tvec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tvec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n",skinConstVS:"attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tv1 = matrix_pose[int(3.0 * i)];\n\tv2 = matrix_pose[int(3.0 * i + 1.0)];\n\tv3 = matrix_pose[int(3.0 * i + 2.0)];\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n",skinTexVS:"attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tv1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tv2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tv3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n",skyboxEnvPS:"varying vec3 vViewDir;\nuniform sampler2D texture_envAtlas;\nuniform float mipLevel;\nvoid main(void) {\n\tvec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(normalize(dir));\n\tvec3 linear = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\n\tgl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n}\n",skyboxHDRPS:"varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvoid main(void) {\n\tvec3 dir=vViewDir;\n\tdir.x *= -1.0;\n\tvec3 color = processEnvironment($textureCubeSAMPLE(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)).rgb);\n\tcolor = toneMap(color);\n\tcolor = gammaCorrectOutput(color);\n\tgl_FragColor = vec4(color, 1.0);\n}\n",skyboxVS:"attribute vec3 aPosition;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat4 matrix_projectionSkybox;\nuniform mat3 cubeMapRotationMatrix;\nvarying vec3 vViewDir;\nvoid main(void) {\n\tmat4 view = matrix_view;\n\tview[3][0] = view[3][1] = view[3][2] = 0.0;\n\tgl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\n\tgl_Position.z = gl_Position.w - 0.00001;\n\tvViewDir = aPosition * cubeMapRotationMatrix;\n}\n",specularPS:"#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularMap;\n#endif\nvoid getSpecularity() {\n\tdSpecularity = vec3(1.0);\n\t#ifdef MAPCOLOR\n\tdSpecularity *= material_specular;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdSpecularity *= texture2D(texture_specularMap, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n",specularAaNonePS:"float antiAliasGlossiness(float power) {\n\treturn power;\n}\n",specularAaToksvigPS:"float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * mix(1.0, toksvig, material_bumpiness);\n}\n",specularAaToksvigFastPS:"float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * toksvig;\n}\n",spotPS:"float getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\n\tfloat cosAngle = dot(dLightDirNormW, lightSpotDirW);\n\treturn smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n",startPS:"void main(void) {\n\tdDiffuseLight = vec3(0);\n\tdSpecularLight = vec3(0);\n\tdReflection = vec4(0);\n\tdSpecularity = vec3(0);\n\t#ifdef CLEARCOAT\n\tccSpecularLight = vec3(0);\n\tccReflection = vec4(0);\n\t#endif\n",startVS:"void main(void) {\n\tgl_Position = getPosition();\n",startNineSlicedPS:"\tnineSlicedUv = vUv0;\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n",startNineSlicedTiledPS:"\tvec2 tileMask = step(vMask, vec2(0.99999));\n\tvec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);\n\tvec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);\n\tvec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));\n\tclampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n\tnineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n",storeEVSMPS:"float exponent = VSM_EXPONENT;\ndepth = 2.0 * depth - 1.0;\ndepth =\texp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n",tangentBinormalVS:"vec3 getTangent() {\n\treturn normalize(dNormalMatrix * vertex_tangent.xyz);\n}\nvec3 getBinormal() {\n\treturn cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\nvec3 getObjectSpaceUp() {\n\treturn normalize(dNormalMatrix * vec3(0, 1, 0));\n}\n",TBNPS:"void getTBN() {\n\tdTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\n}\n",TBNderivativePS:"uniform float tbnBasis;\nvoid getTBN() {\n\tvec2 uv = $UV;\n\tvec3 dp1 = dFdx( vPositionW );\n\tvec3 dp2 = dFdy( vPositionW );\n\tvec2 duv1 = dFdx( uv );\n\tvec2 duv2 = dFdy( uv );\n\tvec3 dp2perp = cross( dp2, dVertexNormalW );\n\tvec3 dp1perp = cross( dVertexNormalW, dp1 );\n\tvec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n\tvec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\tfloat denom = max( dot(T,T), dot(B,B) );\n\tfloat invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );\n\tdTBN = mat3(T * invmax, -B * invmax, dVertexNormalW );\n}\n",TBNfastPS:"void getTBN() {\n\tdTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\n}\n",TBNObjectSpacePS:"void getTBN() {\n\tvec3 B = cross(dVertexNormalW, vObjectSpaceUpW);\n\tvec3 T = cross(dVertexNormalW, B);\n\tif (dot(B,B)==0.0)\n\t{\n\t\tfloat major=max(max(dVertexNormalW.x, dVertexNormalW.y),dVertexNormalW.z);\n\t\tif (dVertexNormalW.x==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,1,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.y==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,0,1));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.z==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(1,0,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t}\n\tdTBN = mat3(normalize(T), normalize(B), normalize(dVertexNormalW));\n}\n",tonemappingAcesPS:"uniform float exposure;\nvec3 toneMap(vec3 color) {\n\tfloat tA = 2.51;\n\tfloat tB = 0.03;\n\tfloat tC = 2.43;\n\tfloat tD = 0.59;\n\tfloat tE = 0.14;\n\tvec3 x = color * exposure;\n\treturn (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n",tonemappingAces2PS:"uniform float exposure;\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.35458, 0.04823,\n\t0.07600, 0.90834, 0.01566,\n\t0.02840, 0.13383, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.53108, -0.07367,\n\t-0.10208,\t1.10813, -0.00605,\n\t-0.00327, -0.07276,\t1.07602\n);\nvec3 RRTAndODTFit(vec3 v) {\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tcolor = color * ACESInputMat;\n\tcolor = RRTAndODTFit(color);\n\tcolor = color * ACESOutputMat;\n\tcolor = clamp(color, 0.0, 1.0);\n\treturn color;\n}\n",tonemappingFilmicPS:"const float A =\t0.15;\nconst float B =\t0.50;\nconst float C =\t0.10;\nconst float D =\t0.20;\nconst float E =\t0.02;\nconst float F =\t0.30;\nconst float W =\t11.2;\nuniform float exposure;\nvec3 uncharted2Tonemap(vec3 x) {\n\t return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMap(vec3 color) {\n\tcolor = uncharted2Tonemap(color * exposure);\n\tvec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n\tcolor = color * whiteScale;\n\treturn color;\n}\n",tonemappingHejlPS:"uniform float exposure;\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tconst float\tA = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n\tconst float Scl = 1.25;\n\tvec3 h = max( vec3(0.0), color - vec3(0.004) );\n\treturn (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n",tonemappingLinearPS:"uniform float exposure;\nvec3 toneMap(vec3 color) {\n\treturn color * exposure;\n}\n",tonemappingNonePS:"vec3 toneMap(vec3 color) {\n\treturn color;\n}\n",transformVS:"#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n#ifdef MORPHING\nuniform vec4 morph_weights_a;\nuniform vec4 morph_weights_b;\n#endif\n#ifdef MORPHING_TEXTURE_BASED\nuniform vec4 morph_tex_params;\nvec2 getTextureMorphCoords() {\n\tfloat vertexId = morph_vertex_id;\n\tvec2 textureSize = morph_tex_params.xy;\n\tvec2 invTextureSize = morph_tex_params.zw;\n\tfloat morphGridV = floor(vertexId * invTextureSize.x);\n\tfloat morphGridU = vertexId - (morphGridV * textureSize.x);\n\treturn (vec2(morphGridU, morphGridV) * invTextureSize) + (0.5 * invTextureSize);\n}\n#endif\n#ifdef MORPHING_TEXTURE_BASED_POSITION\nuniform highp sampler2D morphPositionTex;\n#endif\nmat4 getModelMatrix() {\n\t#ifdef DYNAMICBATCH\n\treturn getBoneMatrix(vertex_boneIndices);\n\t#elif defined(SKIN)\n\treturn matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n\t#elif defined(INSTANCING)\n\treturn mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n\t#else\n\treturn matrix_model;\n\t#endif\n}\nvec4 getPosition() {\n\tdModelMatrix = getModelMatrix();\n\tvec3 localPos = vertex_position;\n\t#ifdef NINESLICED\n\tlocalPos.xz *= outerScale;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tlocalPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tvTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;\n\tlocalPos.xz *= -0.5;\n\tlocalPos = localPos.xzy;\n\t#endif\n\t#ifdef MORPHING\n\t#ifdef MORPHING_POS03\n\tlocalPos.xyz += morph_weights_a[0] * morph_pos0;\n\tlocalPos.xyz += morph_weights_a[1] * morph_pos1;\n\tlocalPos.xyz += morph_weights_a[2] * morph_pos2;\n\tlocalPos.xyz += morph_weights_a[3] * morph_pos3;\n\t#endif\n\t#ifdef MORPHING_POS47\n\tlocalPos.xyz += morph_weights_b[0] * morph_pos4;\n\tlocalPos.xyz += morph_weights_b[1] * morph_pos5;\n\tlocalPos.xyz += morph_weights_b[2] * morph_pos6;\n\tlocalPos.xyz += morph_weights_b[3] * morph_pos7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_POSITION\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\n\tlocalPos += morphPos;\n\t#endif\n\tvec4 posW = dModelMatrix * vec4(localPos, 1.0);\n\t#ifdef SCREENSPACE\n\tposW.zw = vec2(0.0, 1.0);\n\t#endif\n\tdPositionW = posW.xyz;\n\tvec4 screenPos;\n\t#ifdef UV1LAYOUT\n\tscreenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n\t#else\n\t#ifdef SCREENSPACE\n\tscreenPos = posW;\n\t#else\n\tscreenPos = matrix_viewProjection * posW;\n\t#endif\n\t#ifdef PIXELSNAP\n\tscreenPos.xy = (screenPos.xy * 0.5) + 0.5;\n\tscreenPos.xy *= uScreenSize.xy;\n\tscreenPos.xy = floor(screenPos.xy);\n\tscreenPos.xy *= uScreenSize.zw;\n\tscreenPos.xy = (screenPos.xy * 2.0) - 1.0;\n\t#endif\n\t#endif\n\treturn screenPos;\n}\nvec3 getWorldPosition() {\n\treturn dPositionW;\n}\n",transformDeclVS:"attribute vec3 vertex_position;\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\nvec3 dPositionW;\nmat4 dModelMatrix;\n",uv0VS:"#ifdef NINESLICED\nvec2 getUv0() {\n\tvec2 uv = vertex_position.xz;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tuv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tuv = uv * -0.5 + 0.5;\n\tuv = uv * atlasRect.zw + atlasRect.xy;\n\tvMask = vertex_texCoord0.xy;\n\treturn uv;\n}\n#else\nvec2 getUv0() {\n\treturn vertex_texCoord0;\n}\n#endif\n",uv1VS:"vec2 getUv1() {\n\treturn vertex_texCoord1;\n}\n",viewDirPS:"void getViewDir() {\n\tdViewDirW = normalize(view_position - vPositionW);\n}\n",viewNormalVS:"#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nvec3 getViewNormal() {\n\treturn mat3(matrix_view) * vNormalW;\n}\n"};function ym(e,t){return t||(t=gm),1===e||2===e?t.gamma2_2PS?t.gamma2_2PS:gm.gamma2_2PS:3===e?"#define HDR\n"+(t.gamma2_2PS?t.gamma2_2PS:gm.gamma2_2PS):t.gamma1_0PS?t.gamma1_0PS:gm.gamma1_0PS}function bm(e,t){return t||(t=gm),1===e?t.tonemappingFilmicPS?t.tonemappingFilmicPS:gm.tonemappingFilmicPS:0===e?t.tonemappingLinearPS?t.tonemappingLinearPS:gm.tonemappingLinearPS:2===e?t.tonemappingHejlPS?t.tonemappingHejlPS:gm.tonemappingHejlPS:3===e?t.tonemappingAcesPS?t.tonemappingAcesPS:gm.tonemappingAcesPS:4===e?t.tonemappingAces2PS?t.tonemappingAces2PS:gm.tonemappingAces2PS:t.tonemapingNonePS?t.tonemapingNonePS:gm.tonemappingNonePS}function vm(e,t){return t||(t=gm),"linear"===e?t.fogLinearPS?t.fogLinearPS:gm.fogLinearPS:"exp"===e?t.fogExpPS?t.fogExpPS:gm.fogExpPS:"exp2"===e?t.fogExp2PS?t.fogExp2PS:gm.fogExp2PS:t.fogNonePS?t.fogNonePS:gm.fogNonePS}function _m(e,t){return t||(t=gm),e.supportsBoneTextures?t.skinTexVS:"#define BONE_LIMIT "+e.getBoneLimit()+"\n"+t.skinConstVS}function wm(e){let t="precision "+e.precision+" float;\n";return e.webgl2&&(t+="#ifdef GL2\nprecision "+e.precision+" sampler2DShadow;\n#endif\n"),t}function xm(e){return e.webgl2?"#version 300 es\n":""}function Cm(){return"void main(void) {gl_FragColor = vec4(0.0);}"}function Tm(){return"void main(void)\n{\n"}function Em(){return"}\n"}const Sm={vertex_position:"POSITION",vertex_normal:"NORMAL",vertex_tangent:"TANGENT",vertex_texCoord0:"TEXCOORD0",vertex_texCoord1:"TEXCOORD1",vertex_texCoord2:"TEXCOORD2",vertex_texCoord3:"TEXCOORD3",vertex_texCoord4:"TEXCOORD4",vertex_texCoord5:"TEXCOORD5",vertex_texCoord6:"TEXCOORD6",vertex_texCoord7:"TEXCOORD7",vertex_color:"COLOR",vertex_boneIndices:"BLENDINDICES",vertex_boneWeights:"BLENDWEIGHT"};function Am(e){const t={};let n=0,a=e.indexOf("attribute");for(;a>=0&&!(a>0&&"/"===e[a-1]);){const i=e.indexOf(";",a),s=e.lastIndexOf(" ",i),r=e.substr(s+1,i-(s+1)),o=Sm[r];void 0!==o?t[r]=o:(t[r]="ATTR"+n,n++),a=e.indexOf("attribute",a+1)}return t}function Mm(e,t,n,a,i=!1,s=""){const r=e.programLib._cache,o=r[a];if(void 0!==o)return o;n=wm(e)+"\n"+(n||"void main(void) {gl_FragColor = vec4(0.0);}");const l=Am(t);return e.webgl2&&(t=xm(e)+gm.gles3VS+t,n=xm(e)+gm.gles3PS+n),r[a]=new fm(e,{attributes:l,vshader:t,fshader:s+n,useTransformFeedback:i}),r[a]}gm.collectAttribs=Am,gm.createShader=function(e,t,n,a=!1){let i=gm[t],s=wm(e)+"\n"+gm[n];const r=Am(i);return e.webgl2&&(i=xm(e)+gm.gles3VS+i,s=xm(e)+gm.gles3PS+s),new fm(e,{attributes:r,vshader:i,fshader:s,useTransformFeedback:a})},gm.createShaderFromCode=Mm;class Lm{constructor(){this.globalId=0,this.revision=0}equals(e){return this.globalId===e.globalId&&this.revision===e.revision}copy(e){this.globalId=e.globalId,this.revision=e.revision}reset(){this.globalId=0,this.revision=0}}let Rm=0;class Im{constructor(){Rm++,this.version=new Lm,this.version.globalId=Rm}increment(){this.version.revision++}}class Pm{constructor(e){this.name=e,this.value=null,this.versionObject=new Im}setValue(e){this.value=e,this.versionObject.increment()}getValue(){return this.value}}class km{constructor(e){this.name=e,this.variables=new Map}resolve(e){return this.variables.has(e)||this.variables.set(e,new Pm(e)),this.variables.get(e)}removeValue(e){for(const t in this.variables){const n=this.variables[t];n.value===e&&(n.value=null)}}}const Dm={generateKey:function(e){let t="basic";return e.fog&&(t+="_fog"),e.alphaTest&&(t+="_atst"),e.vertexColors&&(t+="_vcol"),e.diffuseMap&&(t+="_diff"),e.skin&&(t+="_skin"),e.screenSpace&&(t+="_ss"),e.useInstancing&&(t+="_inst"),e.useMorphPosition&&(t+="_morphp"),e.useMorphNormal&&(t+="_morphn"),e.useMorphTextureBased&&(t+="_morpht"),t+="_"+e.pass,t},createShaderDefinition:function(e,t){const n={vertex_position:"POSITION"};t.skin&&(n.vertex_boneWeights="BLENDWEIGHT",n.vertex_boneIndices="BLENDINDICES"),t.vertexColors&&(n.vertex_color="COLOR"),t.diffuseMap&&(n.vertex_texCoord0="TEXCOORD0");let a="";a+=gm.transformDeclVS,t.skin?(a+=_m(e),a+=gm.transformSkinnedVS):a+=gm.transformVS,t.vertexColors&&(a+="attribute vec4 vertex_color;\n",a+="varying vec4 vColor;\n"),t.diffuseMap&&(a+="attribute vec2 vertex_texCoord0;\n",a+="varying vec2 vUv0;\n"),2===t.pass&&(a+="varying float vDepth;\n",a+="#ifndef VIEWMATRIX\n",a+="#define VIEWMATRIX\n",a+="uniform mat4 matrix_view;\n",a+="#endif\n",a+="#ifndef CAMERAPLANES\n",a+="#define CAMERAPLANES\n",a+="uniform vec4 camera_params;\n\n",a+="#endif\n"),a+="void main(void)\n{\n",a+="\t gl_Position = getPosition();\n",2===t.pass&&(a+="\t\tvDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\n"),t.vertexColors&&(a+="\t\tvColor = vertex_color;\n"),t.diffuseMap&&(a+="\t\tvUv0 = vertex_texCoord0;\n"),a+="}\n";const i=a;a=wm(e),t.vertexColors?a+="varying vec4 vColor;\n":a+="uniform vec4 uColor;\n",t.diffuseMap&&(a+="varying vec2 vUv0;\n",a+="uniform sampler2D texture_diffuseMap;\n"),t.fog&&(a+=vm(t.fog)),t.alphatest&&(a+=gm.alphaTestPS),2===t.pass&&(a+="varying float vDepth;\n",a+=gm.packDepthPS),a+="void main(void)\n{\n",t.vertexColors?a+="\t\tgl_FragColor = vColor;\n":a+="\t\tgl_FragColor = uColor;\n",t.diffuseMap&&(a+="\t\tgl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n"),t.alphatest&&(a+="\t alphaTest(gl_FragColor.a);\n"),18!==t.pass&&(2===t.pass?a+="\t\tgl_FragColor = packFloat(vDepth);\n":t.fog&&(a+="\t glFragColor.rgb = addFog(gl_FragColor.rgb);\n")),a+="}\n";return{attributes:n,vshader:i,fshader:a}}},Om={generateKey:function(e){let t="particle";for(const n in e)e.hasOwnProperty(n)&&(t+=e[n]);return t},_animTex:function(e){let t="";return t+=e.animTexLoop?gm.particleAnimFrameLoopVS:gm.particleAnimFrameClampVS,t+=gm.particleAnimTexVS,t},createShaderDefinition:function(e,t){let n="",a=wm(e)+"\n";a+="#define PARTICLE\n",e.webgl2&&(n+="#define GL2\n",a+="#define GL2\n"),n+="#define VERTEXSHADER\n",t.mesh&&(n+="#define USE_MESH\n"),t.localSpace&&(n+="#define LOCAL_SPACE\n"),t.screenSpace&&(n+="#define SCREEN_SPACE\n"),t.animTex&&(n+="\nuniform vec2 animTexTilesParams;\n"),t.animTex&&(n+="\nuniform vec4 animTexParams;\n"),t.animTex&&(n+="\nuniform vec2 animTexIndexParams;\n"),2===t.normal&&(n+="\nvarying mat3 ParticleMat;\n"),1===t.normal&&(n+="\nvarying vec3 Normal;\n"),t.soft&&(n+="\nvarying float vDepth;\n");const i=t.customFace?gm.particle_customFaceVS:gm.particle_billboardVS;t.useCpu?(t.soft>0&&(n+=gm.screenDepthPS),n+=gm.particle_cpuVS,t.localSpace&&(n+=gm.particle_localShiftVS),t.animTex&&(n+=this._animTex(t)),t.alignToMotion&&(n+=gm.particle_pointAlongVS),n+=t.mesh?gm.particle_meshVS:i,1===t.normal&&(n+=gm.particle_normalVS),2===t.normal&&(n+=gm.particle_TBNVS),t.stretch>0&&(n+=gm.particle_stretchVS),n+=gm.particle_cpu_endVS,t.soft>0&&(n+=gm.particle_softVS)):(n+=gm.particle_initVS,n+=t.pack8?gm.particleInputRgba8PS:gm.particleInputFloatPS,t.soft>0&&(n+=gm.screenDepthPS),n+=gm.particleVS,t.localSpace&&(n+=gm.particle_localShiftVS),t.animTex&&(n+=this._animTex(t)),t.wrap&&(n+=gm.particle_wrapVS),t.alignToMotion&&(n+=gm.particle_pointAlongVS),n+=t.mesh?gm.particle_meshVS:i,1===t.normal&&(n+=gm.particle_normalVS),2===t.normal&&(n+=gm.particle_TBNVS),t.stretch>0&&(n+=gm.particle_stretchVS),n+=gm.particle_endVS,t.soft>0&&(n+=gm.particle_softVS)),n+="}\n",t.normal>0&&(1===t.normal?a+="\nvarying vec3 Normal;\n":2===t.normal&&(a+="\nvarying mat3 ParticleMat;\n"),a+="\nuniform vec3 lightCube[6];\n"),t.soft&&(a+="\nvarying float vDepth;\n"),0===t.normal&&"none"===t.fog&&(t.srgb=!1),a+=ym(t.gamma),a+=bm(t.toneMap),"linear"===t.fog?a+=gm.fogLinearPS:"exp"===t.fog?a+=gm.fogExpPS:"exp2"===t.fog?a+=gm.fogExp2PS:a+=gm.fogNonePS,2===t.normal&&(a+="\nuniform sampler2D normalMap;\n"),t.soft>0&&(a+=gm.screenDepthPS),a+=gm.particlePS,t.soft>0&&(a+=gm.particle_softPS),1===t.normal&&(a+="\nvec3 normal = Normal;\n"),2===t.normal&&(a+=gm.particle_normalMapPS),t.normal>0&&(a+=t.halflambert?gm.particle_halflambertPS:gm.particle_lambertPS),t.normal>0&&(a+=gm.particle_lightingPS),2===t.blend?a+=gm.particle_blendNormalPS:1===t.blend?a+=gm.particle_blendAddPS:5===t.blend&&(a+=gm.particle_blendMultiplyPS),a+=gm.particle_endPS;return{attributes:Am(n),vshader:n,fshader:a}}},Fm={generateKey:function(e){return"cubemap"===e.type?`skybox-${e.type}-${e.rgbm}-${e.hdr}-${e.fixSeams}-${e.toneMapping}-${e.gamma}-${e.useIntensity}-${e.mip}`:`skybox-${e.type}-${e.encoding}-${e.useIntensity}-${e.gamma}-${e.toneMapping}`},createShaderDefinition:function(e,t){let n;if("cubemap"===t.type){const a=[128,64,16,8,4,2];n=wm(e),n+=t.mip?gm.fixCubemapSeamsStretchPS:gm.fixCubemapSeamsNonePS,n+=t.useIntensity?gm.envMultiplyPS:gm.envConstPS,n+=ym(t.gamma),n+=bm(t.toneMapping),n+=gm.decodePS,n+=gm.rgbmPS,n+=gm.skyboxHDRPS.replace(/\$textureCubeSAMPLE/g,t.rgbm?"textureCubeRGBM":t.hdr?"textureCube":"textureCubeSRGB").replace(/\$FIXCONST/g,1-1/a[t.mip]+"")}else{const a={rgbm:"decodeRGBM",rgbe:"decodeRGBE",linear:"decodeLinear"};n=wm(e),n+=t.useIntensity?gm.envMultiplyPS:gm.envConstPS,n+=ym(t.gamma),n+=bm(t.toneMapping),n+=gm.decodePS,n+=gm.skyboxEnvPS.replace(/\$DECODE/g,a[t.encoding]||"decodeGamma")}return{attributes:{aPosition:"POSITION"},vshader:gm.skyboxVS,fshader:n}}},Nm=new Float32Array(1),Vm=new Int32Array(Nm.buffer);class Bm{static float2Half(e){Nm[0]=e;const t=Vm[0];let n=t>>16&32768,a=t>>12&2047;const i=t>>23&255;return i<103?n:i>142?(n|=31744,n|=(255===i?0:1)&&8388607&t,n):i<113?(a|=2048,n|=(a>>114-i)+(a>>113-i&1),n):(n|=i-112<<10|a>>1,n+=1&a,n)}static float2Bytes(e,t,n,a){const i=255*e%1;if(t[n+0]=Math.round(255*(e%1-.00392156862745098*i)),a>1){const s=65025*e%1;if(t[n+1]=Math.round(255*(i-.00392156862745098*s)),a>2){const i=16581375*e%1;t[n+2]=Math.round(255*(s-.00392156862745098*i)),a>3&&(t[n+3]=Math.round(255*i))}}}static float2BytesRange(e,t,n,a,i,s){e=Eu.clamp((e-a)/(i-a),0,1),Bm.float2Bytes(e,t,n,s)}static float2MantissaExponent(e,t,n,a){const i=Math.floor(Math.log2(Math.abs(e)))+1;e/=Math.pow(2,i),Bm.float2BytesRange(e,t,n,-1,1,a-1),t[n+a-1]=Math.round(i+127)}}let Um=null,zm=null;class Gm{constructor(e,t){this.device=e,this.name=null,this._width=4,this._height=4,this._depth=1,this._format=7,this.type="default",this.projection="none",this._cubemap=!1,this._volume=!1,this.fixCubemapSeams=!1,this._flipY=!1,this._premultiplyAlpha=!1,this._isRenderTarget=!1,this._mipmaps=!0,this._minFilter=5,this._magFilter=1,this._anisotropy=1,this._addressU=0,this._addressV=0,this._addressW=0,this._compareOnRead=!1,this._compareFunc=1,void 0!==t&&(void 0!==t.name&&(this.name=t.name),this._width=void 0!==t.width?t.width:this._width,this._height=void 0!==t.height?t.height:this._height,this._format=void 0!==t.format?t.format:this._format,t.hasOwnProperty("type")?this.type=t.type:t.hasOwnProperty("rgbm")?this.type=t.rgbm?"rgbm":"default":t.hasOwnProperty("swizzleGGGR")&&(this.type=t.swizzleGGGR?"swizzleGGGR":"default"),void 0!==t.mipmaps?this._mipmaps=t.mipmaps:this._mipmaps=void 0!==t.autoMipmap?t.autoMipmap:this._mipmaps,this._levels=t.levels,this._cubemap=void 0!==t.cubemap?t.cubemap:this._cubemap,this.fixCubemapSeams=void 0!==t.fixCubemapSeams?t.fixCubemapSeams:this.fixCubemapSeams,this._cubemap?this.projection="cube":t.projection&&"cube"!==t.projection&&(this.projection=t.projection),this._minFilter=void 0!==t.minFilter?t.minFilter:this._minFilter,this._magFilter=void 0!==t.magFilter?t.magFilter:this._magFilter,this._anisotropy=void 0!==t.anisotropy?t.anisotropy:this._anisotropy,this._addressU=void 0!==t.addressU?t.addressU:this._addressU,this._addressV=void 0!==t.addressV?t.addressV:this._addressV,this._compareOnRead=void 0!==t.compareOnRead?t.compareOnRead:this._compareOnRead,this._compareFunc=void 0!==t._compareFunc?t._compareFunc:this._compareFunc,this._flipY=void 0!==t.flipY?t.flipY:this._flipY,this._premultiplyAlpha=void 0!==t.premultiplyAlpha?t.premultiplyAlpha:this._premultiplyAlpha,e.webgl2&&(this._depth=void 0!==t.depth?t.depth:this._depth,this._volume=void 0!==t.volume?t.volume:this._volume,this._addressW=void 0!==t.addressW?t.addressW:this._addressW)),this._compressed=8===this._format||9===this._format||10===this._format||this._format>=21,this._invalid=!1,this._lockedLevel=-1,this._levels||(this._levels=this._cubemap?[[null,null,null,null,null,null]]:[null]),this.dirtyAll(),this._gpuSize=0,this.impl=e.createTextureImpl(),e.textures.push(this)}destroy(){if(this.device){const e=this.device,t=e.textures.indexOf(this);-1!==t&&e.textures.splice(t,1),e.scope.removeValue(this),this.impl.destroy(e),this.adjustVramSizeTracking(e._vram,-this._gpuSize),this._levels=null,this.device=null}}loseContext(){this.impl.loseContext(),this.dirtyAll()}adjustVramSizeTracking(e,t){e.tex+=t}set minFilter(e){this._minFilter!==e&&(this._minFilter=e,this._parameterFlags|=1)}get minFilter(){return this._minFilter}set magFilter(e){this._magFilter!==e&&(this._magFilter=e,this._parameterFlags|=2)}get magFilter(){return this._magFilter}set addressU(e){this._addressU!==e&&(this._addressU=e,this._parameterFlags|=4)}get addressU(){return this._addressU}set addressV(e){this._addressV!==e&&(this._addressV=e,this._parameterFlags|=8)}get addressV(){return this._addressV}set addressW(e){this.device.webgl2&&this._volume&&e!==this._addressW&&(this._addressW=e,this._parameterFlags|=16)}get addressW(){return this._addressW}set compareOnRead(e){this._compareOnRead!==e&&(this._compareOnRead=e,this._parameterFlags|=32)}get compareOnRead(){return this._compareOnRead}set compareFunc(e){this._compareFunc!==e&&(this._compareFunc=e,this._parameterFlags|=64)}get compareFunc(){return this._compareFunc}set anisotropy(e){this._anisotropy!==e&&(this._anisotropy=e,this._parameterFlags|=128)}get anisotropy(){return this._anisotropy}set autoMipmap(e){this._mipmaps=e}get autoMipmap(){return this._mipmaps}set mipmaps(e){this._mipmaps!==e&&(this._mipmaps=e,e&&(this._needsMipmapsUpload=!0))}get mipmaps(){return this._mipmaps}get width(){return this._width}get height(){return this._height}get depth(){return this._depth}get format(){return this._format}get cubemap(){return this._cubemap}get gpuSize(){const e=this.pot&&this._mipmaps&&!(this._compressed&&1===this._levels.length);return Gm.calcGpuSize(this._width,this._height,this._depth,this._format,e,this._cubemap)}get volume(){return this._volume}set flipY(e){this._flipY!==e&&(this._flipY=e,this._needsUpload=!0)}get flipY(){return this._flipY}set premultiplyAlpha(e){this._premultiplyAlpha!==e&&(this._premultiplyAlpha=e,this._needsUpload=!0)}get premultiplyAlpha(){return this._premultiplyAlpha}get pot(){return Eu.powerOfTwo(this._width)&&Eu.powerOfTwo(this._height)}get encoding(){return"rgbm"===this.type?"rgbm":"rgbe"===this.type?"rgbe":12===this.format||14===this.format?"linear":"srgb"}static calcGpuSize(e,t,n,a,i,s){Um||(Um=[],Um[0]=1,Um[1]=1,Um[2]=2,Um[3]=2,Um[4]=2,Um[5]=2,Um[6]=4,Um[7]=4,Um[11]=8,Um[12]=8,Um[13]=16,Um[14]=16,Um[15]=4,Um[16]=4,Um[17]=4,Um[18]=4,Um[19]=4,Um[20]=4),zm||(zm=[],zm[21]=8,zm[22]=8,zm[24]=8,zm[25]=8,zm[26]=8,zm[27]=8,zm[8]=8,zm[29]=8,zm[23]=16,zm[9]=16,zm[10]=16,zm[28]=16,zm[30]=16);const r=Um.hasOwnProperty(a)?Um[a]:0,o=zm.hasOwnProperty(a)?zm[a]:0;let l=0;for(;;){if(r>0)l+=e*t*n*r;else{let i=Math.floor((e+3)/4);const s=Math.floor((t+3)/4),r=Math.floor((n+3)/4);24!==a&&25!==a||(i=Math.max(Math.floor(i/2),1)),l+=i*s*r*o}if(!i||1===e&&1===t&&1===n)break;e=Math.max(Math.floor(e/2),1),t=Math.max(Math.floor(t/2),1),n=Math.max(Math.floor(n/2),1)}return l*(s?6:1)}dirtyAll(){this._levelsUpdated=this._cubemap?[[!0,!0,!0,!0,!0,!0]]:[!0],this._needsUpload=!0,this._needsMipmapsUpload=this._mipmaps,this._mipmapsUploaded=!1,this._parameterFlags=255}lock(e={}){if(void 0===e.level&&(e.level=0),void 0===e.face&&(e.face=0),void 0===e.mode&&(e.mode=2),this._lockedLevel=e.level,null===this._levels[e.level])switch(this._format){case 0:case 1:this._levels[e.level]=new Uint8Array(this._width*this._height*this._depth);break;case 2:this._levels[e.level]=new Uint8Array(this._width*this._height*this._depth*2);break;case 3:case 4:case 5:this._levels[e.level]=new Uint16Array(this._width*this._height*this._depth);break;case 6:this._levels[e.level]=new Uint8Array(this._width*this._height*this._depth*3);break;case 7:this._levels[e.level]=new Uint8Array(this._width*this._height*this._depth*4);break;case 8:this._levels[e.level]=new Uint8Array(Math.floor((this._width+3)/4)*Math.floor((this._height+3)/4)*8*this._depth);break;case 9:case 10:this._levels[e.level]=new Uint8Array(Math.floor((this._width+3)/4)*Math.floor((this._height+3)/4)*16*this._depth);break;case 11:this._levels[e.level]=new Uint16Array(this._width*this._height*this._depth*3);break;case 13:this._levels[e.level]=new Float32Array(this._width*this._height*this._depth*3);break;case 12:this._levels[e.level]=new Uint16Array(this._width*this._height*this._depth*4);break;case 14:this._levels[e.level]=new Float32Array(this._width*this._height*this._depth*4)}return this._levels[e.level]}setSource(e,t=0){let n,a,i=!1;if(this._cubemap){if(e[0]){n=e[0].width||0,a=e[0].height||0;for(let t=0;t<6;t++){const s=e[t];if(!s||s.width!==n||s.height!==a||!this.device._isBrowserInterface(s)){i=!0;break}}}else i=!0;if(!i)for(let n=0;n<6;n++)this._levels[t][n]!==e[n]&&(this._levelsUpdated[t][n]=!0)}else this.device._isBrowserInterface(e)||(i=!0),i||(e!==this._levels[t]&&(this._levelsUpdated[t]=!0),n=e.width,a=e.height);if(i)if(this._width=4,this._height=4,this._cubemap)for(let e=0;e<6;e++)this._levels[t][e]=null,this._levelsUpdated[t][e]=!0;else this._levels[t]=null,this._levelsUpdated[t]=!0;else 0===t&&(this._width=n,this._height=a),this._levels[t]=e;this._invalid===i&&i||(this._invalid=i,this.upload())}getSource(e=0){return this._levels[e]}unlock(){this._lockedLevel,this.upload(),this._lockedLevel=-1}upload(){this._needsUpload=!0,this._needsMipmapsUpload=this._mipmaps}getDds(){let e=128,t=0;for(;this._levels[t];){if(this.cubemap)for(let n=0;n<6;n++){if(!this._levels[t][n])return;const a=this._levels[t][n].length;if(!a)return;e+=a}else{const n=this._levels[t].length;if(!n)return;e+=n}e+=this._levels[t].length,t++}const n=new ArrayBuffer(e),a=new Uint32Array(n,0,32);let i=528391;this._levels.length>1&&(i|=131072);let s=4096;this._levels.length>1&&(s|=4194304),(this._levels.length>1||this.cubemap)&&(s|=8);const r=this.cubemap?65024:0;a[0]=542327876,a[1]=124,a[2]=i,a[3]=this.height,a[4]=this.width,a[5]=this.width*this.height*4,a[6]=0,a[7]=this._levels.length;for(let e=0;e<11;e++)a[8+e]=0;a[19]=32,a[20]=65,a[21]=0,a[22]=32,a[23]=16711680,a[24]=65280,a[25]=255,a[26]=4278190080,a[27]=s,a[28]=r,a[29]=0,a[30]=0,a[31]=0;let o=128;if(this.cubemap)for(let e=0;e<6;e++)for(let t=0;t<this._levels.length;t++){const a=this._levels[t][e],i=new Uint8Array(n,o,a.length);for(let e=0;e<a.length;e++)i[e]=a[e];o+=a.length}else for(let e=0;e<this._levels.length;e++){const t=this._levels[e],a=new Uint8Array(n,o,t.length);for(let e=0;e<t.length;e++)a[e]=t[e];o+=t.length}return n}}const Hm=new Pu,Wm=new Pu,jm=new Pu,Xm=new zu;class Ym{constructor(){this._aspectRatio=16/9,this._aspectRatioMode=0,this._calculateProjection=null,this._calculateTransform=null,this._clearColor=new Mu(.75,.75,.75,1),this._clearColorBuffer=!0,this._clearDepth=1,this._clearDepthBuffer=!0,this._clearStencil=0,this._clearStencilBuffer=!0,this._cullingMask=4294967295,this._cullFaces=!0,this._farClip=1e3,this._flipFaces=!1,this._fov=45,this._frustumCulling=!0,this._horizontalFov=!1,this._layers=[0,1,2,4,3],this._nearClip=.1,this._node=null,this._orthoHeight=10,this._projection=0,this._rect=new Ou(0,0,1,1),this._renderTarget=null,this._scissorRect=new Ou(0,0,1,1),this._scissorRectClear=!1,this._vrDisplay=null,this._projMat=new zu,this._projMatDirty=!0,this._projMatSkybox=new zu,this._viewMat=new zu,this._viewMatDirty=!0,this._viewProjMat=new zu,this._viewProjMatDirty=!0,this.frustum=new em}set aspectRatio(e){this._aspectRatio!==e&&(this._aspectRatio=e,this._projMatDirty=!0)}get aspectRatio(){return this._aspectRatio}set aspectRatioMode(e){this._aspectRatioMode!==e&&(this._aspectRatioMode=e,this._projMatDirty=!0)}get aspectRatioMode(){return this._aspectRatioMode}set calculateProjection(e){this._calculateProjection=e,this._projMatDirty=!0}get calculateProjection(){return this._calculateProjection}set calculateTransform(e){this._calculateTransform=e}get calculateTransform(){return this._calculateTransform}set clearColor(e){this._clearColor.copy(e)}get clearColor(){return this._clearColor}set clearColorBuffer(e){this._clearColorBuffer=e}get clearColorBuffer(){return this._clearColorBuffer}set clearDepth(e){this._clearDepth=e}get clearDepth(){return this._clearDepth}set clearDepthBuffer(e){this._clearDepthBuffer=e}get clearDepthBuffer(){return this._clearDepthBuffer}set clearStencil(e){this._clearStencil=e}get clearStencil(){return this._clearStencil}set clearStencilBuffer(e){this._clearStencilBuffer=e}get clearStencilBuffer(){return this._clearStencilBuffer}set cullingMask(e){this._cullingMask=e}get cullingMask(){return this._cullingMask}set cullFaces(e){this._cullFaces=e}get cullFaces(){return this._cullFaces}set farClip(e){this._farClip!==e&&(this._farClip=e,this._projMatDirty=!0)}get farClip(){return this._farClip}set flipFaces(e){this._flipFaces=e}get flipFaces(){return this._flipFaces}set fov(e){this._fov!==e&&(this._fov=e,this._projMatDirty=!0)}get fov(){return this._fov}set frustumCulling(e){this._frustumCulling=e}get frustumCulling(){return this._frustumCulling}set horizontalFov(e){this._horizontalFov!==e&&(this._horizontalFov=e,this._projMatDirty=!0)}get horizontalFov(){return this._horizontalFov}set layers(e){this._layers=e.slice(0)}get layers(){return this._layers}set nearClip(e){this._nearClip!==e&&(this._nearClip=e,this._projMatDirty=!0)}get nearClip(){return this._nearClip}set node(e){this._node=e}get node(){return this._node}set orthoHeight(e){this._orthoHeight!==e&&(this._orthoHeight=e,this._projMatDirty=!0)}get orthoHeight(){return this._orthoHeight}set projection(e){this._projection!==e&&(this._projection=e,this._projMatDirty=!0)}get projection(){return this._projection}get projectionMatrix(){return this._evaluateProjectionMatrix(),this._projMat}set rect(e){this._rect.copy(e)}get rect(){return this._rect}set renderTarget(e){this._renderTarget=e}get renderTarget(){return this._renderTarget}set scissorRect(e){this._scissorRect.copy(e)}get scissorRect(){return this._scissorRect}get viewMatrix(){if(this._viewMatDirty){const e=this._node.getWorldTransform();this._viewMat.copy(e).invert(),this._viewMatDirty=!1}return this._viewMat}set vrDisplay(e){this._vrDisplay=e,e&&(e._camera=this)}get vrDisplay(){return this._vrDisplay}clone(){return(new Ym).copy(this)}copy(e){return this.aspectRatio=e.aspectRatio,this.aspectRatioMode=e.aspectRatioMode,this.calculateProjection=e.calculateProjection,this.calculateTransform=e.calculateTransform,this.clearColor=e.clearColor,this.clearColorBuffer=e.clearColorBuffer,this.clearDepth=e.clearDepth,this.clearDepthBuffer=e.clearDepthBuffer,this.clearStencil=e.clearStencil,this.clearStencilBuffer=e.clearStencilBuffer,this.cullFaces=e.cullFaces,this.cullingMask=e.cullingMask,this.farClip=e.farClip,this.flipFaces=e.flipFaces,this.fov=e.fov,this.frustumCulling=e.frustumCulling,this.horizontalFov=e.horizontalFov,this.layers=e.layers,this.nearClip=e.nearClip,this.orthoHeight=e.orthoHeight,this.projection=e.projection,this.rect=e.rect,this.renderTarget=e.renderTarget,this.scissorRect=e.scissorRect,this.vrDisplay=e.vrDisplay,this}_updateViewProjMat(){(this._projMatDirty||this._viewMatDirty||this._viewProjMatDirty)&&(this._viewProjMat.mul2(this.projectionMatrix,this.viewMatrix),this._viewProjMatDirty=!1)}worldToScreen(e,t,n,a=new Pu){this._updateViewProjMat(),this._viewProjMat.transformPoint(e,a);const i=this._viewProjMat.data,s=e.x*i[3]+e.y*i[7]+e.z*i[11]+1*i[15];return a.x=.5*(a.x/s+1)*t,a.y=.5*(1-a.y/s)*n,a}screenToWorld(e,t,n,a,i,s=new Pu){const r=this._farClip-this._nearClip;if(Hm.set(e/a,(i-t)/i,n/r),Hm.mulScalar(2),Hm.sub(Pu.ONE),0===this._projection){zu._getPerspectiveHalfSize(Wm,this._fov,this._aspectRatio,this._nearClip,this._horizontalFov),Wm.x*=Hm.x,Wm.y*=Hm.y;const e=this._node.getWorldTransform();Wm.z=-this._nearClip,e.transformPoint(Wm,jm);const t=this._node.getPosition();s.sub2(jm,t),s.normalize(),s.mulScalar(n),s.add(t)}else this._updateViewProjMat(),Xm.copy(this._viewProjMat).invert(),Xm.transformPoint(Hm,s);return s}_evaluateProjectionMatrix(){if(this._projMatDirty){if(0===this._projection)this._projMat.setPerspective(this._fov,this._aspectRatio,this._nearClip,this._farClip,this._horizontalFov),this._projMatSkybox.copy(this._projMat);else{const e=this._orthoHeight,t=e*this._aspectRatio;this._projMat.setOrtho(-t,t,-e,e,this._nearClip,this._farClip),this._projMatSkybox.setPerspective(this._fov,this._aspectRatio,this._nearClip,this._farClip)}this._projMatDirty=!1}}getProjectionMatrixSkybox(){return this._evaluateProjectionMatrix(),this._projMatSkybox}getScreenSize(e){if(0===this._projection){const t=this._node.getPosition().distance(e.center);if(t<e.radius)return 1;const n=Math.asin(e.radius/t),a=Math.tan(n),i=Math.tan(this._fov/2*Eu.DEG_TO_RAD);return Math.min(a/i,1)}return Eu.clamp(e.radius/this._orthoHeight,0,1)}}const qm=new zu,Km=new Pu,Zm=new Gu,$m=new Gu,Qm=new Pu,Jm=new Pu,ef=new zu,tf=new Gu,nf=new Pu,af=new zu,sf=new Gu,rf=new Gu,of=new zu,lf=new Pu,cf=new Pu;class hf extends Qp{constructor(e="Untitled"){super(),this.name=e,this.tags=new wu(this),this._labels={},this.localPosition=new Pu,this.localRotation=new Gu,this.localScale=new Pu(1,1,1),this.localEulerAngles=new Pu,this.position=new Pu,this.rotation=new Gu,this.eulerAngles=new Pu,this._scale=null,this.localTransform=new zu,this._dirtyLocal=!1,this._aabbVer=0,this._frozen=!1,this.worldTransform=new zu,this._dirtyWorld=!1,this.normalMatrix=new ku,this._dirtyNormal=!0,this._right=null,this._up=null,this._forward=null,this._parent=null,this._children=[],this._graphDepth=0,this._enabled=!0,this._enabledInHierarchy=!1,this.scaleCompensation=!1}get right(){return this._right||(this._right=new Pu),this.getWorldTransform().getX(this._right).normalize()}get up(){return this._up||(this._up=new Pu),this.getWorldTransform().getY(this._up).normalize()}get forward(){return this._forward||(this._forward=new Pu),this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1)}set enabled(e){var t;this._enabled!==e&&(this._enabled=e,(e&&null!=(t=this._parent)&&t.enabled||!e)&&this._notifyHierarchyStateChanged(this,e))}get enabled(){return this._enabled&&this._enabledInHierarchy}get parent(){return this._parent}get path(){let e=this._parent;if(!e)return"";let t=this.name;for(;e&&e._parent;)t=`${e.name}/${t}`,e=e._parent;return t}get root(){let e=this;for(;e._parent;)e=e._parent;return e}get children(){return this._children}get graphDepth(){return this._graphDepth}_notifyHierarchyStateChanged(e,t){e._onHierarchyStateChanged(t);const n=e._children;for(let e=0,a=n.length;e<a;e++)n[e]._enabled&&this._notifyHierarchyStateChanged(n[e],t)}_onHierarchyStateChanged(e){this._enabledInHierarchy=e,e&&!this._frozen&&this._unfreezeParentToRoot()}_cloneInternal(e){e.name=this.name;const t=this.tags._list;e.tags.clear();for(let n=0;n<t.length;n++)e.tags.add(t[n]);e._labels=Object.assign({},this._labels),e.localPosition.copy(this.localPosition),e.localRotation.copy(this.localRotation),e.localScale.copy(this.localScale),e.localEulerAngles.copy(this.localEulerAngles),e.position.copy(this.position),e.rotation.copy(this.rotation),e.eulerAngles.copy(this.eulerAngles),e.localTransform.copy(this.localTransform),e._dirtyLocal=this._dirtyLocal,e.worldTransform.copy(this.worldTransform),e._dirtyWorld=this._dirtyWorld,e._dirtyNormal=this._dirtyNormal,e._aabbVer=this._aabbVer+1,e._enabled=this._enabled,e.scaleCompensation=this.scaleCompensation,e._enabledInHierarchy=!1}clone(){const e=new hf;return this._cloneInternal(e),e}copy(e){return e._cloneInternal(this),this}find(e,t){let n,a=[];const i=this._children.length;if(e instanceof Function){const t=e;n=t(this),n&&a.push(this);for(let e=0;e<i;e++){const n=this._children[e].find(t);n.length&&(a=a.concat(n))}}else{let n;this[e]&&(n=this[e]instanceof Function?this[e]():this[e],n===t&&a.push(this));for(let n=0;n<i;++n){const i=this._children[n].find(e,t);i.length&&(a=a.concat(i))}}return a}findOne(e,t){const n=this._children.length;let a=null;if(e instanceof Function){const t=e;if(a=t(this),a)return this;for(let e=0;e<n;e++)if(a=this._children[e].findOne(t),a)return a}else{let i;if(this[e]&&(i=this[e]instanceof Function?this[e]():this[e],i===t))return this;for(let i=0;i<n;i++)if(a=this._children[i].findOne(e,t),null!==a)return a}return null}findByTag(){const e=arguments,t=[],n=(a,i)=>{i&&a.tags.has(...e)&&t.push(a);for(let e=0;e<a._children.length;e++)n(a._children[e],!0)};return n(this,!1),t}findByName(e){if(this.name===e)return this;for(let t=0;t<this._children.length;t++){const n=this._children[t].findByName(e);if(null!==n)return n}return null}findByPath(e){const t=Array.isArray(e)?e:e.split("/");let n=this;for(let e=0,a=t.length;e<a;++e)if(n=n.children.find((n=>n.name===t[e])),!n)return null;return n}forEach(e,t){e.call(t,this);const n=this._children;for(let a=0;a<n.length;a++)n[a].forEach(e,t)}isDescendantOf(e){let t=this._parent;for(;t;){if(t===e)return!0;t=t._parent}return!1}isAncestorOf(e){return e.isDescendantOf(this)}getEulerAngles(){return this.getWorldTransform().getEulerAngles(this.eulerAngles),this.eulerAngles}getLocalEulerAngles(){return this.localRotation.getEulerAngles(this.localEulerAngles),this.localEulerAngles}getLocalPosition(){return this.localPosition}getLocalRotation(){return this.localRotation}getLocalScale(){return this.localScale}getLocalTransform(){return this._dirtyLocal&&(this.localTransform.setTRS(this.localPosition,this.localRotation,this.localScale),this._dirtyLocal=!1),this.localTransform}getPosition(){return this.getWorldTransform().getTranslation(this.position),this.position}getRotation(){return this.rotation.setFromMat4(this.getWorldTransform()),this.rotation}getScale(){return this._scale||(this._scale=new Pu),this.getWorldTransform().getScale(this._scale)}getWorldTransform(){return this._dirtyLocal||this._dirtyWorld?(this._parent&&this._parent.getWorldTransform(),this._sync(),this.worldTransform):this.worldTransform}reparent(e,t){const n=this._parent;n&&n.removeChild(this),e&&(t>=0?e.insertChild(this,t):e.addChild(this))}setLocalEulerAngles(e,t,n){this.localRotation.setFromEulerAngles(e,t,n),this._dirtyLocal||this._dirtifyLocal()}setLocalPosition(e,t,n){e instanceof Pu?this.localPosition.copy(e):this.localPosition.set(e,t,n),this._dirtyLocal||this._dirtifyLocal()}setLocalRotation(e,t,n,a){e instanceof Gu?this.localRotation.copy(e):this.localRotation.set(e,t,n,a),this._dirtyLocal||this._dirtifyLocal()}setLocalScale(e,t,n){e instanceof Pu?this.localScale.copy(e):this.localScale.set(e,t,n),this._dirtyLocal||this._dirtifyLocal()}_dirtifyLocal(){this._dirtyLocal||(this._dirtyLocal=!0,this._dirtyWorld||this._dirtifyWorld())}_unfreezeParentToRoot(){let e=this._parent;for(;e;)e._frozen=!1,e=e._parent}_dirtifyWorld(){this._dirtyWorld||this._unfreezeParentToRoot(),this._dirtifyWorldInternal()}_dirtifyWorldInternal(){if(!this._dirtyWorld){this._frozen=!1,this._dirtyWorld=!0;for(let e=0;e<this._children.length;e++)this._children[e]._dirtyWorld||this._children[e]._dirtifyWorldInternal()}this._dirtyNormal=!0,this._aabbVer++}setPosition(e,t,n){e instanceof Pu?nf.copy(e):nf.set(e,t,n),null===this._parent?this.localPosition.copy(nf):(af.copy(this._parent.getWorldTransform()).invert(),af.transformPoint(nf,this.localPosition)),this._dirtyLocal||this._dirtifyLocal()}setRotation(e,t,n,a){if(e instanceof Gu?sf.copy(e):sf.set(e,t,n,a),null===this._parent)this.localRotation.copy(sf);else{const e=this._parent.getRotation();rf.copy(e).invert(),this.localRotation.copy(rf).mul(sf)}this._dirtyLocal||this._dirtifyLocal()}setEulerAngles(e,t,n){if(this.localRotation.setFromEulerAngles(e,t,n),null!==this._parent){const e=this._parent.getRotation();rf.copy(e).invert(),this.localRotation.mul2(rf,this.localRotation)}this._dirtyLocal||this._dirtifyLocal()}addChild(e){if(null!==e._parent)throw new Error("GraphNode is already parented");this._children.push(e),this._onInsertChild(e)}addChildAndSaveTransform(e){const t=e.getPosition(),n=e.getRotation(),a=e._parent;a&&a.removeChild(e),e.setPosition(ef.copy(this.worldTransform).invert().transformPoint(t)),e.setRotation(tf.copy(this.getRotation()).invert().mul(n)),this._children.push(e),this._onInsertChild(e)}insertChild(e,t){if(null!==e._parent)throw new Error("GraphNode is already parented");this._children.splice(t,0,e),this._onInsertChild(e)}_fireOnHierarchy(e,t,n){this.fire(e,n);for(let e=0;e<this._children.length;e++)this._children[e]._fireOnHierarchy(t,t,n)}_onInsertChild(e){e._parent=this;const t=e._enabled&&this.enabled;e._enabledInHierarchy!==t&&(e._enabledInHierarchy=t,e._notifyHierarchyStateChanged(e,t)),e._updateGraphDepth(),e._dirtifyWorld(),this._frozen&&e._unfreezeParentToRoot(),e._fireOnHierarchy("insert","inserthierarchy",this),this.fire&&this.fire("childinsert",e)}_updateGraphDepth(){this._graphDepth=this._parent?this._parent._graphDepth+1:0;for(let e=0,t=this._children.length;e<t;e++)this._children[e]._updateGraphDepth()}removeChild(e){const t=this._children.indexOf(e);-1!==t&&(this._children.splice(t,1),e._parent=null,e._fireOnHierarchy("remove","removehierarchy",this),this.fire("childremove",e))}_sync(){if(this._dirtyLocal&&(this.localTransform.setTRS(this.localPosition,this.localRotation,this.localScale),this._dirtyLocal=!1),this._dirtyWorld){if(null===this._parent)this.worldTransform.copy(this.localTransform);else if(this.scaleCompensation){let e;const t=this._parent;let n=this.localScale,a=t;if(a){for(;a&&a.scaleCompensation;)a=a._parent;a&&(a=a._parent,a&&(e=a.worldTransform.getScale(),Qm.mul2(e,this.localScale),n=Qm))}$m.setFromMat4(t.worldTransform),Zm.mul2($m,this.localRotation);let i=t.worldTransform;t.scaleCompensation&&(Jm.mul2(e,t.getLocalScale()),qm.setTRS(t.worldTransform.getTranslation(Km),$m,Jm),i=qm),i.transformPoint(this.localPosition,Km),this.worldTransform.setTRS(Km,Zm,n)}else this.worldTransform.mulAffine2(this._parent.worldTransform,this.localTransform);this._dirtyWorld=!1}}syncHierarchy(){if(!this._enabled)return;if(this._frozen)return;this._frozen=!0,(this._dirtyLocal||this._dirtyWorld)&&this._sync();const e=this._children;for(let t=0,n=e.length;t<n;t++)e[t].syncHierarchy()}lookAt(e,t,n,a=0,i=1,s=0){if(e instanceof Pu)lf.copy(e),t instanceof Pu?cf.copy(t):cf.copy(Pu.UP);else{if(void 0===n)return;lf.set(e,t,n),cf.set(a,i,s)}of.setLookAt(this.getPosition(),lf,cf),sf.setFromMat4(of),this.setRotation(sf)}translate(e,t,n){e instanceof Pu?nf.copy(e):nf.set(e,t,n),nf.add(this.getPosition()),this.setPosition(nf)}translateLocal(e,t,n){e instanceof Pu?nf.copy(e):nf.set(e,t,n),this.localRotation.transformVector(nf,nf),this.localPosition.add(nf),this._dirtyLocal||this._dirtifyLocal()}rotate(e,t,n){if(sf.setFromEulerAngles(e,t,n),null===this._parent)this.localRotation.mul2(sf,this.localRotation);else{const e=this.getRotation(),t=this._parent.getRotation();rf.copy(t).invert(),sf.mul2(rf,sf),this.localRotation.mul2(sf,e)}this._dirtyLocal||this._dirtifyLocal()}rotateLocal(e,t,n){sf.setFromEulerAngles(e,t,n),this.localRotation.mul(sf),this._dirtyLocal||this._dirtifyLocal()}}const df=new zu,pf=new zu,uf=new zu;class mf{static create(e,t,n){const a=new Ym;switch(a.node=new hf(e),a.aspectRatio=1,a.aspectRatioMode=1,a._scissorRectClear=!0,t){case 1:a.node.setRotation(mf.pointLightRotations[n]),a.fov=90,a.projection=0;break;case 2:a.projection=0;break;case 0:a.projection=1}return a}static evalSpotCookieMatrix(e){let t=mf._spotCookieCamera;t||(t=mf.create("SpotCookieCamera",2),mf._spotCookieCamera=t),t.fov=2*e._outerConeAngle;const n=t._node;n.setPosition(e._node.getPosition()),n.setRotation(e._node.getRotation()),n.rotateLocal(-90,0,0),df.setTRS(n.getPosition(),n.getRotation(),Pu.ONE).invert(),pf.mul2(t.projectionMatrix,df);const a=e.cookieMatrix,i=e.atlasViewport;return uf.setViewport(i.x,i.y,i.z,i.w),a.mul2(uf,pf),a}}mf.pointLightRotations=[(new Gu).setFromEulerAngles(0,90,180),(new Gu).setFromEulerAngles(0,-90,180),(new Gu).setFromEulerAngles(90,0,0),(new Gu).setFromEulerAngles(-90,0,0),(new Gu).setFromEulerAngles(0,180,180),(new Gu).setFromEulerAngles(0,0,180)],mf._spotCookieCamera=null;const ff=new Pu,gf=new Float32Array(6),yf=new Pu(-.5,0,0),bf=new Pu(0,0,.5),vf={FLAGS:0,COLOR_A:1,COLOR_B:2,SPOT_ANGLES:3,SHADOW_BIAS:4,COOKIE_A:5,COOKIE_B:6,COUNT_ALWAYS:7,POSITION_X:7,POSITION_Y:8,POSITION_Z:9,RANGE:10,SPOT_DIRECTION_X:11,SPOT_DIRECTION_Y:12,SPOT_DIRECTION_Z:13,PROJ_MAT_00:14,ATLAS_VIEWPORT_A:14,PROJ_MAT_01:15,ATLAS_VIEWPORT_B:15,PROJ_MAT_02:16,PROJ_MAT_03:17,PROJ_MAT_10:18,PROJ_MAT_11:19,PROJ_MAT_12:20,PROJ_MAT_13:21,PROJ_MAT_20:22,PROJ_MAT_21:23,PROJ_MAT_22:24,PROJ_MAT_23:25,PROJ_MAT_30:26,PROJ_MAT_31:27,PROJ_MAT_32:28,PROJ_MAT_33:29,AREA_DATA_WIDTH_X:30,AREA_DATA_WIDTH_Y:31,AREA_DATA_WIDTH_Z:32,AREA_DATA_HEIGHT_X:33,AREA_DATA_HEIGHT_Y:34,AREA_DATA_HEIGHT_Z:35,COUNT:36},_f={POSITION_RANGE:0,SPOT_DIRECTION:1,PROJ_MAT_0:2,ATLAS_VIEWPORT:2,PROJ_MAT_1:3,PROJ_MAT_2:4,PROJ_MAT_3:5,AREA_DATA_WIDTH:6,AREA_DATA_HEIGHT:7,COUNT:8};class wf{static initShaderDefines(){const e=wf.lightTextureFormat===wf.FORMAT_FLOAT?"FLOAT":"8BIT";wf.shaderDefines=`\n\t\t\t\t\t\t\n#define CLUSTER_TEXTURE_${e}\n\t\t\t\t\t\t${wf.buildShaderDefines(vf,"CLUSTER_TEXTURE_8_")}\n\t\t\t\t\t\t${wf.buildShaderDefines(_f,"CLUSTER_TEXTURE_F_")}\n\t\t\t\t`}static buildShaderDefines(e,t){let n="";return Object.keys(e).forEach((a=>{n+=`\n#define ${t}${a} ${e[a]}.5`})),n}static init(e){wf.lightTextureFormat=e.extTextureFloat&&e.maxTextures>8?wf.FORMAT_FLOAT:wf.FORMAT_8BIT,wf.initShaderDefines()}static createTexture(e,t,n,a,i){return new Gm(e,{name:i,width:t,height:n,mipmaps:!1,format:a,addressU:1,addressV:1,type:"default",magFilter:0,minFilter:0,anisotropy:1})}constructor(e){this.device=e,this.cookiesEnabled=!1,this.shadowsEnabled=!1,this.areaLightsEnabled=!1,this.maxLights=255;let t=vf.COUNT_ALWAYS,n=0;wf.lightTextureFormat===wf.FORMAT_FLOAT?n=_f.COUNT:t=vf.COUNT,this.lights8=new Uint8ClampedArray(4*t*this.maxLights),this.lightsTexture8=wf.createTexture(this.device,t,this.maxLights,7,"LightsTexture8"),this._lightsTexture8Id=this.device.scope.resolve("lightsTexture8"),n?(this.lightsFloat=new Float32Array(4*n*this.maxLights),this.lightsTextureFloat=wf.createTexture(this.device,n,this.maxLights,14,"LightsTextureFloat"),this._lightsTextureFloatId=this.device.scope.resolve("lightsTextureFloat")):(this.lightsFloat=null,this.lightsTextureFloat=null,this._lightsTextureFloatId=void 0),this._lightsTextureInvSizeId=this.device.scope.resolve("lightsTextureInvSize"),this._lightsTextureInvSizeData=new Float32Array(4),this._lightsTextureInvSizeData[0]=n?1/this.lightsTextureFloat.width:0,this._lightsTextureInvSizeData[1]=n?1/this.lightsTextureFloat.height:0,this._lightsTextureInvSizeData[2]=1/this.lightsTexture8.width,this._lightsTextureInvSizeData[3]=1/this.lightsTexture8.height,this.invMaxColorValue=0,this.invMaxAttenuation=0,this.boundsMin=new Pu,this.boundsDelta=new Pu}destroy(){this.lightsTexture8&&(this.lightsTexture8.destroy(),this.lightsTexture8=null),this.lightsTextureFloat&&(this.lightsTextureFloat.destroy(),this.lightsTextureFloat=null)}setCompressionRanges(e,t){this.invMaxColorValue=1/t,this.invMaxAttenuation=1/e}setBounds(e,t){this.boundsMin.copy(e),this.boundsDelta.copy(t)}uploadTextures(){this.lightsTextureFloat&&(this.lightsTextureFloat.lock().set(this.lightsFloat),this.lightsTextureFloat.unlock()),this.lightsTexture8.lock().set(this.lights8),this.lightsTexture8.unlock()}updateUniforms(){this._lightsTexture8Id.setValue(this.lightsTexture8),wf.lightTextureFormat===wf.FORMAT_FLOAT&&this._lightsTextureFloatId.setValue(this.lightsTextureFloat),this._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData)}getSpotDirection(e,t){t._node.getWorldTransform().getY(e).mulScalar(-1),e.normalize()}getLightAreaSizes(e){const t=e._node.getWorldTransform();return t.transformVector(yf,ff),gf[0]=ff.x,gf[1]=ff.y,gf[2]=ff.z,t.transformVector(bf,ff),gf[3]=ff.x,gf[4]=ff.y,gf[5]=ff.z,gf}addLightDataFlags(e,t,n,a,i){e[t+0]=a?255:0,e[t+1]=64*n._shape,e[t+2]=255*n._falloffMode,e[t+3]=i?255:0}addLightDataColor(e,t,n,a,i){const s=this.invMaxColorValue,r=a?n._linearFinalColor:n._finalColor;Bm.float2Bytes(r[0]*s,e,t+0,2),Bm.float2Bytes(r[1]*s,e,t+2,2),Bm.float2Bytes(r[2]*s,e,t+4,2),e[t+6]=i?255:0;const o=!!(1&n.mask),l=!!(2&n.mask);e[t+7]=o&&l?127:l?255:0}addLightDataSpotAngles(e,t,n){Bm.float2Bytes(.499999*n._innerConeAngleCos+.5,e,t+0,2),Bm.float2Bytes(.499999*n._outerConeAngleCos+.5,e,t+2,2)}addLightDataShadowBias(e,t,n){const a=n.getRenderData(null,0),i=n._getUniformBiasValues(a);Bm.float2BytesRange(i.bias,e,t,-1,20,2),Bm.float2Bytes(i.normalBias,e,t+2,2)}addLightDataPositionRange(e,t,n,a){const i=ff.sub2(a,this.boundsMin).div(this.boundsDelta);Bm.float2Bytes(i.x,e,t+0,4),Bm.float2Bytes(i.y,e,t+4,4),Bm.float2Bytes(i.z,e,t+8,4),Bm.float2Bytes(n.attenuationEnd*this.invMaxAttenuation,e,t+12,4)}addLightDataSpotDirection(e,t,n){this.getSpotDirection(ff,n),Bm.float2Bytes(.499999*ff.x+.5,e,t+0,4),Bm.float2Bytes(.499999*ff.y+.5,e,t+4,4),Bm.float2Bytes(.499999*ff.z+.5,e,t+8,4)}addLightDataLightProjMatrix(e,t,n){const a=n.data;for(let n=0;n<12;n++)Bm.float2BytesRange(a[n],e,t+4*n,-2,2,4);for(let n=12;n<16;n++)Bm.float2MantissaExponent(a[n],e,t+4*n,4)}addLightDataCookies(e,t,n){const a="rgb"===n._cookieChannel;if(e[t+0]=Math.floor(255*n.cookieIntensity),e[t+1]=a?255:0,!a){const a=n._cookieChannel;e[t+4]="rrr"===a?255:0,e[t+5]="ggg"===a?255:0,e[t+6]="bbb"===a?255:0,e[t+7]="aaa"===a?255:0}}addLightAtlasViewport(e,t,n){Bm.float2Bytes(n.x,e,t+0,2),Bm.float2Bytes(n.y,e,t+2,2),Bm.float2Bytes(n.z/3,e,t+4,2)}addLightAreaSizes(e,t,n){const a=this.getLightAreaSizes(n);for(let n=0;n<6;n++)Bm.float2MantissaExponent(a[n],e,t+4*n,4)}addLightData(e,t,n){const a=2===e._type,i=e.atlasViewportAllocated,s=this.cookiesEnabled&&!!e._cookie&&i,r=this.areaLightsEnabled&&0!==e.shape,o=this.shadowsEnabled&&e.castShadows&&i,l=e._node.getPosition();let c=null,h=null;if(a)if(o){c=e.getRenderData(null,0).shadowMatrix}else s&&(c=mf.evalSpotCookieMatrix(e));else(o||s)&&(h=e.atlasViewport);const d=this.lights8,p=t*this.lightsTexture8.width*4;if(this.addLightDataFlags(d,p+4*vf.FLAGS,e,a,o),this.addLightDataColor(d,p+4*vf.COLOR_A,e,n,s),a&&this.addLightDataSpotAngles(d,p+4*vf.SPOT_ANGLES,e),e.castShadows&&this.addLightDataShadowBias(d,p+4*vf.SHADOW_BIAS,e),s&&this.addLightDataCookies(d,p+4*vf.COOKIE_A,e),wf.lightTextureFormat===wf.FORMAT_FLOAT){const n=this.lightsFloat,i=t*this.lightsTextureFloat.width*4;if(n[i+4*_f.POSITION_RANGE+0]=l.x,n[i+4*_f.POSITION_RANGE+1]=l.y,n[i+4*_f.POSITION_RANGE+2]=l.z,n[i+4*_f.POSITION_RANGE+3]=e.attenuationEnd,a&&(this.getSpotDirection(ff,e),n[i+4*_f.SPOT_DIRECTION+0]=ff.x,n[i+4*_f.SPOT_DIRECTION+1]=ff.y,n[i+4*_f.SPOT_DIRECTION+2]=ff.z),c){const e=c.data;for(let t=0;t<16;t++)n[i+4*_f.PROJ_MAT_0+t]=e[t]}if(h&&(n[i+4*_f.ATLAS_VIEWPORT+0]=h.x,n[i+4*_f.ATLAS_VIEWPORT+1]=h.y,n[i+4*_f.ATLAS_VIEWPORT+2]=h.z/3),r){const t=this.getLightAreaSizes(e);n[i+4*_f.AREA_DATA_WIDTH+0]=t[0],n[i+4*_f.AREA_DATA_WIDTH+1]=t[1],n[i+4*_f.AREA_DATA_WIDTH+2]=t[2],n[i+4*_f.AREA_DATA_HEIGHT+0]=t[3],n[i+4*_f.AREA_DATA_HEIGHT+1]=t[4],n[i+4*_f.AREA_DATA_HEIGHT+2]=t[5]}}else this.addLightDataPositionRange(d,p+4*vf.POSITION_X,e,l),a&&this.addLightDataSpotDirection(d,p+4*vf.SPOT_DIRECTION_X,e),c&&this.addLightDataLightProjMatrix(d,p+4*vf.PROJ_MAT_00,c),h&&this.addLightAtlasViewport(d,p+4*vf.ATLAS_VIEWPORT_A,h),r&&this.addLightAreaSizes(d,p+4*vf.AREA_DATA_WIDTH_X,e)}}wf.FORMAT_FLOAT=0,wf.FORMAT_8BIT=1,wf.lightTextureFormat=wf.FORMAT_8BIT,wf.shaderDefines="";const xf=[],Cf={rgbm:"decodeRGBM",rgbe:"decodeRGBE",linear:"decodeLinear"},Tf={optionsContext:{},optionsContextMin:{},generateKey:function(e){const t=function(e){const t=[];for(const n in e)e.hasOwnProperty(n)&&"chunks"!==n&&"lights"!==n&&t.push(n);return t.sort()};let n;e===this.optionsContextMin?(this.propsMin||(this.propsMin=t(e)),n=this.propsMin):e===this.optionsContext?(this.props||(this.props=t(e)),n=this.props):n=t(e);let a="standard";for(let t=0;t<n.length;t++)e[n[t]]&&(a+=n[t]+e[n[t]]);if(e.chunks){const t=[];for(const n in e.chunks)e.chunks.hasOwnProperty(n)&&t.push(n+e.chunks[n]);t.sort(),a+=t}if(e.lights){const t=e.clusteredLightingEnabled;for(let n=0;n<e.lights.length;n++){const i=e.lights[n];t&&0!==i._type||(a+=i.key)}}return cm(a)},_correctChannel:function(e,t){if(xf[e]>0){if(xf[e]<t.length)return t.substring(0,xf[e]);if(xf[e]>t.length){let n=t;const a=n.charAt(n.length-1),i=xf[e]-n.length;for(let e=0;e<i;e++)n+=a;return n}return t}},_setMapTransform:function(e,t,n,a){const i=`texture_${t}MapTransform`,s=n+100*a;return e[0]+=`uniform vec3 ${i}0;\n`,e[0]+=`uniform vec3 ${i}1;\n`,e[3][s]||(e[1]+=`varying vec2 vUV${a}_${n};\n`,e[2]+=`\t vUV${a}_${n} = vec2(dot(vec3(uv${a}, 1), ${i}0), dot(vec3(uv${a}, 1), ${i}1));\n`,e[3][s]=!0),e},_getUvSourceExpression:function(e,t,n){const a=n[e],i=n[t],s=0===n.pass||1===n.pass;let r;return s&&1===n.nineSlicedMode||s&&2===n.nineSlicedMode?r="nineSlicedUv":(r=0===a?"vUv"+i:"vUV"+i+"_"+a,n.heightMap&&"heightMapTransform"!==e&&(r+=" + dUvOffset")),r},_addMapDef:function(e,t){let n="\n#undef "+e+"\n";return t&&(n+=" #define "+e+"\n"),n},_addMapDefs:function(e,t,n,a){let i="";return i+=this._addMapDef("MAPFLOAT",e),i+=this._addMapDef("MAPCOLOR",t),i+=this._addMapDef("MAPVERTEX",n),i+=this._addMapDef("MAPTEXTURE",a),i},_addMap:function(e,t,n,a,i){const s=e+"Map",r=s+"Uv",o=s+"Transform",l=s+"Channel",c=e+"VertexColorChannel",h=e+"VertexColor",d=e+"Mode",p=n[e+"Tint"],u=n[h],m=n[s],f=n[d];let g=a[t];if(m){const e=this._getUvSourceExpression(o,r,n);if(g=g.replace(/\$UV/g,e).replace(/\$CH/g,n[l]),void 0!==i){const e=0===i?"texture2DSRGB":1===i?"texture2DRGBM":"texture2D";g=g.replace(/\$texture2DSAMPLE/g,e)}}u&&(g=g.replace(/\$VC/g,n[c])),f&&(g=g.replace(/\$DETAILMODE/g,f));const y=!!(1&p),b=!!(2&p);return g=this._addMapDefs(y,b,u,m)+g,g.replace(/\$/g,"")},_directionalShadowMapProjection:function(e,t,n,a,i){let s="";return e.numCascades>1&&(s+=`getShadowCascadeMatrix(light${a}_shadowMatrixPalette, light${a}_shadowCascadeDistances, light${a}_shadowCascadeCount);\n`,t=`(cascadeShadowMat, ${n});\n`),s+=i+t,s+=`fadeShadow(light${a}_shadowCascadeDistances);\n`,s},_nonPointShadowMapProjection:function(e,t,n,a,i){const s=`(${n}, ${a});\n`;return!t._normalOffsetBias||t._isVsm?2===t._type?t._isPcf&&(e.webgl2||e.extStandardDerivatives)?"\t\t\t getShadowCoordPerspZbuffer"+s:"\t\t\t getShadowCoordPersp"+s:this._directionalShadowMapProjection(t,s,a,i,"getShadowCoordOrtho"):2===t._type?t._isPcf&&(e.webgl2||e.extStandardDerivatives)?"\t\t\t getShadowCoordPerspZbufferNormalOffset"+s:"\t\t\t getShadowCoordPerspNormalOffset"+s:this._directionalShadowMapProjection(t,s,a,i,"getShadowCoordOrthoNormalOffset")},_addVaryingIfNeeded:function(e,t,n){return e.indexOf(n)>=0?"varying "+t+" "+n+";\n":""},_getLightSourceShapeString:function(e){switch(e){case 1:return"Rect";case 2:return"Disk";case 3:return"Sphere";default:return""}},_getPassDefineString:function(e){return 18===e?"#define PICK_PASS\n":2===e?"#define DEPTH_PASS\n":e>=3&&e<=17?"#define SHADOW_PASS\n":""},_vsAddTransformCode:function(e,t,n,a){return e+=n.transformVS},_vsAddBaseCode:function(e,t,n,a){return e+=n.baseVS,1!==a.nineSlicedMode&&2!==a.nineSlicedMode||(e+=n.baseNineSlicedVS),e},_fsAddBaseCode:function(e,t,n,a){return e+=n.basePS,1===a.nineSlicedMode?e+=n.baseNineSlicedPS:2===a.nineSlicedMode&&(e+=n.baseNineSlicedTiledPS),2===a.nineSlicedMode?e+="const float textureBias = -1000.0;\n":e+="uniform float textureBias;\n",e},_decodeFunc:function(e){return Cf[e]||"decodeGamma"},_fsAddStartCode:function(e,t,n,a){return e+=n.startPS,1===a.nineSlicedMode?e+=n.startNineSlicedPS:2===a.nineSlicedMode&&(e+=n.startNineSlicedTiledPS),e},_buildShadowPassFragmentCode:function(e,t,n,a,i){const s=a.pass-3,r=Math.floor(s/6),o=s-6*r;t.extStandardDerivatives&&!t.webgl2&&(e+="uniform vec2 polygonOffset;\n"),3===o?t.textureFloatHighPrecision?e+="#define VSM_EXPONENT 15.0\n\n":e+="#define VSM_EXPONENT 5.54\n\n":2===o&&(e+="#define VSM_EXPONENT 5.54\n\n"),0!==r&&(e+="uniform vec3 view_position;\n",e+="uniform float light_radius;\n"),e+=i,a.alphaTest&&(e+="uniform float textureBias;",e+="float dAlpha;\n",e+=this._addMap("opacity","opacityPS",a,n),e+=n.alphaTestPS),0!==o||t.webgl2&&1!==r?1===o&&(e+="vec2 encodeFloatRG( float v ) {\n",e+="\t\tvec2 enc = vec2(1.0, 255.0) * v;\n",e+="\t\tenc = fract(enc);\n",e+="\t\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n",e+="\t\treturn enc;\n",e+="}\n\n"):e+=n.packDepthPS,e+="void main(void)\n{\n",a.alphaTest&&(e+="\t getOpacity();\n",e+="\t alphaTest(dAlpha);\n");return e+=1===r||(1===o||2===o||3===o)&&0!==r?"\t float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n":"\t float depth = gl_FragCoord.z;\n",0!==o||t.webgl2&&(1!==r||a.clusteredLightingEnabled)?0===o||4===o?(e+="\t gl_FragColor = vec4(1.0);\n",a.clusteredLightingEnabled&&1===r&&t.webgl2&&(e+="\t gl_FragDepth = depth;\n")):e+=1===o?"\t gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n":n.storeEVSMPS:t.extStandardDerivatives&&!t.webgl2?(e+="\t float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n",e+="\t depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n",e+="\t gl_FragColor = packFloat(depth);\n"):e+="\t gl_FragColor = packFloat(depth);\n",e+="}\n"},createShaderDefinition:function(e,t){let n=t.lights.length>0;t.dirLightMap&&(n=!0),t.clusteredLightingEnabled&&(n=!0),0===t.shadingModel?(t.fresnelModel=0,t.specularAntialias=!1,t.ambientSH=!1):t.fresnelModel=0===t.fresnelModel?2:t.fresnelModel;const a=!!t.reflectionSource;t.useSpecular||(t.specularMap=t.glossMap=null);const i=t.pass>=3&&t.pass<=17,s=n||a||t.ambientSH||t.heightMap||t.enableGGXSpecular||t.clusteredLightingEnabled&&!i||t.clearCoatNormalMap;this.options=t;let r,o,l="",c="",h="",d=gm;const p={vertex_position:"POSITION"};if(t.chunks){const e={};for(const n in d)d.hasOwnProperty(n)&&(t.chunks[n]?(o=t.chunks[n],o.indexOf("vertex_normal")>=0&&(p.vertex_normal="NORMAL"),o.indexOf("vertex_tangent")>=0&&(p.vertex_tangent="TANGENT"),o.indexOf("vertex_texCoord0")>=0&&(p.vertex_texCoord0="TEXCOORD0"),o.indexOf("vertex_texCoord1")>=0&&(p.vertex_texCoord1="TEXCOORD1"),o.indexOf("vertex_color")>=0&&(p.vertex_color="COLOR"),o.indexOf("vertex_boneWeights")>=0&&(p.vertex_boneWeights="BLENDWEIGHT"),o.indexOf("vertex_boneIndices")>=0&&(p.vertex_boneIndices="BLENDINDICES"),e[n]=o):e[n]=d[n]);d=e}l+=this._getPassDefineString(t.pass),l=this._vsAddBaseCode(l,e,d,t),c+="\t vPositionW\t\t= getWorldPosition();\n",2===t.pass&&(l+="varying float vDepth;\n",l+="#ifndef VIEWMATRIX\n",l+="#define VIEWMATRIX\n",l+="uniform mat4 matrix_view;\n",l+="#endif\n",l+="#ifndef CAMERAPLANES\n",l+="#define CAMERAPLANES\n",l+="uniform vec4 camera_params;\n\n",l+="#endif\n",c+="\t\tvDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n"),t.useInstancing&&(p.instance_line1="ATTR12",p.instance_line2="ATTR13",p.instance_line3="ATTR14",p.instance_line4="ATTR15",l+=d.instancingVS),s&&(p.vertex_normal="NORMAL",c+="\t vNormalW = getNormal();\n","sphereMap"===t.reflectionSource&&e.fragmentUniformsCount<=16&&(l+=d.viewNormalVS,c+="\t vNormalV\t\t= getViewNormal();\n"),(t.heightMap||t.normalMap||t.enableGGXSpecular)&&t.hasTangents?(p.vertex_tangent="TANGENT",l+=d.tangentBinormalVS,c+="\t vTangentW\t = getTangent();\n",c+="\t vBinormalW\t= getBinormal();\n"):t.enableGGXSpecular&&(l+=d.tangentBinormalVS,c+="\t vObjectSpaceUpW\t= getObjectSpaceUp();\n"));const u=[],m=[];for(const e in xf){const n=e+"Map";if(t[e+"VertexColor"]){const n=e+"VertexColorChannel";t[n]=this._correctChannel(e,t[n])}if(t[n]){const a=n+"Channel",i=n+"Transform",s=n+"Uv";t[s]=Math.min(t[s],1),t[a]=this._correctChannel(e,t[a]);const r=t[s];u[r]=!0,m[r]=m[r]||t[n]&&!t[i]}}t.forceUv1&&(u[1]=!0,m[1]=void 0===m[1]||m[1]);for(let e=0;e<2;e++)u[e]&&(p["vertex_texCoord"+e]="TEXCOORD"+e,l+=d["uv"+e+"VS"],c+="\t vec2 uv"+e+" = getUv"+e+"();\n"),m[e]&&(c+="\t vUv"+e+" = uv"+e+";\n");const f=[l,h,c,[]];for(const e in xf){const n=e+"Map";if(t[n]){const a=n+"Transform";if(t[a]){const i=n+"Uv";this._setMapTransform(f,e,t[a],t[i])}}}l=f[0],h=f[1],c=f[2],t.vertexColors&&(p.vertex_color="COLOR",c+="\t vVertexColor = vertex_color;\n"),(t.useMorphPosition||t.useMorphNormal)&&(t.useMorphTextureBased?(l+="#define MORPHING_TEXTURE_BASED\n",t.useMorphPosition&&(l+="#define MORPHING_TEXTURE_BASED_POSITION\n"),t.useMorphNormal&&(l+="#define MORPHING_TEXTURE_BASED_NORMAL\n"),p.morph_vertex_id="ATTR15",l+="attribute float morph_vertex_id;\n"):(l+="#define MORPHING\n",t.useMorphPosition?(p.morph_pos0="ATTR8",p.morph_pos1="ATTR9",p.morph_pos2="ATTR10",p.morph_pos3="ATTR11",l+="#define MORPHING_POS03\n",l+="attribute vec3 morph_pos0;\n",l+="attribute vec3 morph_pos1;\n",l+="attribute vec3 morph_pos2;\n",l+="attribute vec3 morph_pos3;\n"):t.useMorphNormal&&(p.morph_nrm0="ATTR8",p.morph_nrm1="ATTR9",p.morph_nrm2="ATTR10",p.morph_nrm3="ATTR11",l+="#define MORPHING_NRM03\n",l+="attribute vec3 morph_nrm0;\n",l+="attribute vec3 morph_nrm1;\n",l+="attribute vec3 morph_nrm2;\n",l+="attribute vec3 morph_nrm3;\n"),t.useMorphNormal?(p.morph_nrm4="ATTR12",p.morph_nrm5="ATTR13",p.morph_nrm6="ATTR14",p.morph_nrm7="ATTR15",l+="#define MORPHING_NRM47\n",l+="attribute vec3 morph_nrm4;\n",l+="attribute vec3 morph_nrm5;\n",l+="attribute vec3 morph_nrm6;\n",l+="attribute vec3 morph_nrm7;\n"):(p.morph_pos4="ATTR12",p.morph_pos5="ATTR13",p.morph_pos6="ATTR14",p.morph_pos7="ATTR15",l+="#define MORPHING_POS47\n",l+="attribute vec3 morph_pos4;\n",l+="attribute vec3 morph_pos5;\n",l+="attribute vec3 morph_pos6;\n",l+="attribute vec3 morph_pos7;\n"))),t.skin?(p.vertex_boneWeights="BLENDWEIGHT",p.vertex_boneIndices="BLENDINDICES",l+=_m(e,d),l+="#define SKIN\n"):t.useInstancing&&(l+="#define INSTANCING\n"),t.screenSpace&&(l+="#define SCREENSPACE\n"),t.pixelSnap&&(l+="#define PIXELSNAP\n"),l=this._vsAddTransformCode(l,e,d,t),s&&(l+=d.normalVS),l+="\n",l+=d.startVS,l+=c,l+=d.endVS,l+="}";let g=l;const y=h;h="",h+=this._addVaryingIfNeeded(l,"vec4","vVertexColor"),h+=this._addVaryingIfNeeded(l,"vec3","vPositionW"),h+=this._addVaryingIfNeeded(l,"vec3","vNormalV"),h+=this._addVaryingIfNeeded(l,"vec3","vNormalW"),h+=this._addVaryingIfNeeded(l,"vec3","vTangentW"),h+=this._addVaryingIfNeeded(l,"vec3","vBinormalW"),h+=this._addVaryingIfNeeded(l,"vec3","vObjectSpaceUpW"),h+=this._addVaryingIfNeeded(l,"vec2","vUv0"),h+=this._addVaryingIfNeeded(l,"vec2","vUv1"),h+=y,g=h+g;let b,v="";if(e.webgl2?(v=xm(e),d.extensionVS&&(v+=d.extensionVS+"\n"),g=v+d.gles3VS+g):(d.extensionVS&&(v=d.extensionVS+"\n"),g=v+g),t.forceFragmentPrecision&&"highp"!==t.forceFragmentPrecision&&"mediump"!==t.forceFragmentPrecision&&"lowp"!==t.forceFragmentPrecision&&(t.forceFragmentPrecision=null),t.forceFragmentPrecision&&("highp"===t.forceFragmentPrecision&&"highp"!==e.maxPrecision&&(t.forceFragmentPrecision="mediump"),"mediump"===t.forceFragmentPrecision&&"lowp"===e.maxPrecision&&(t.forceFragmentPrecision="lowp")),l="",e.webgl2&&(l+=xm(e)),e.webgl2||(e.extStandardDerivatives&&(l+="#extension GL_OES_standard_derivatives : enable\n"),e.extTextureLod&&(l+="#extension GL_EXT_shader_texture_lod : enable\n",l+="#define SUPPORTS_TEXLOD\n")),d.extensionPS&&(l+=d.extensionPS+"\n"),e.webgl2&&(l+=d.gles3PS),l+=t.forceFragmentPrecision?"precision "+t.forceFragmentPrecision+" float;\n\n":wm(e),l+=this._getPassDefineString(t.pass),18===t.pass)return l+="uniform vec4 uColor;\n",l+=h,t.alphaTest&&(l+="uniform float textureBias;",l+="float dAlpha;\n",l+=this._addMap("opacity","opacityPS",t,d),l+=d.alphaTestPS),l+="void main(void)\n{\n",t.alphaTest&&(l+="\t getOpacity();\n",l+="\t alphaTest(dAlpha);\n"),l+="\t\tgl_FragColor = uColor;\n",l+="}\n",{attributes:p,vshader:g,fshader:l};if(2===t.pass)return l+="varying float vDepth;\n",l+=h,l+=d.packDepthPS,t.alphaTest&&(l+="uniform float textureBias;",l+="float dAlpha;\n",l+=this._addMap("opacity","opacityPS",t,d),l+=d.alphaTestPS),l+="void main(void)\n{\n",t.alphaTest&&(l+="\t getOpacity();\n",l+="\t alphaTest(dAlpha);\n"),l+="\t\tgl_FragColor = packFloat(vDepth);\n",l+="}\n",{attributes:p,vshader:g,fshader:l};if(i)return{attributes:p,vshader:g,fshader:this._buildShadowPassFragmentCode(l,e,d,t,h)};if(t.customFragmentShader)return b=l+t.customFragmentShader,{attributes:p,vshader:g,fshader:b,tag:1};l+=h,l=this._fsAddBaseCode(l,e,d,t),t.detailModes&&(l+=d.detailModesPS);const _=l;l="",t.clearCoat>0&&(l+="#define CLEARCOAT\n",l+="#define CLUSTER_CLEAR_COAT\n"),!1===t.opacityFadesSpecular&&(l+="uniform float material_alphaFade;\n");let w=0;const x=[];let C,T=!1,E=!1,S=!1,A=t.lights.some((function(e){return e._shape&&0!==e._shape}));t.clusteredLightingEnabled&&t.clusteredLightingAreaLightsEnabled&&(A=!0),7===e.areaLightLutFormat?(l+="#define AREA_R8_G8_B8_A8_LUTS\n",l+="#define AREA_LUTS_PRECISION lowp\n"):l+="#define AREA_LUTS_PRECISION highp\n",(A||t.clusteredLightingEnabled)&&(l+="#define AREA_LIGHTS\n",l+="uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex1;\n",l+="uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex2;\n");for(let n=0;n<t.lights.length;n++){const a=t.lights[n],i=a._type;if(t.clusteredLightingEnabled&&0!==i)continue;l+="uniform vec3 light"+n+"_color;\n",0===i?l+="uniform vec3 light"+n+"_direction;\n":(l+="uniform vec3 light"+n+"_position;\n",l+="uniform float light"+n+"_radius;\n",2===i&&(l+="uniform vec3 light"+n+"_direction;\n",l+="uniform float light"+n+"_innerConeAngle;\n",l+="uniform float light"+n+"_outerConeAngle;\n")),0!==(A&&a._shape?a._shape:0)&&(0===i&&(l+="uniform vec3 light"+n+"_position;\n"),l+="uniform vec3 light"+n+"_halfWidth;\n",l+="uniform vec3 light"+n+"_halfHeight;\n"),a.castShadows&&!t.noShadow&&(l+="uniform mat4 light"+n+"_shadowMatrix;\n",0===i&&(l+="uniform mat4 light"+n+"_shadowMatrixPalette[4];\n",l+="uniform float light"+n+"_shadowCascadeDistances[4];\n",l+="uniform float light"+n+"_shadowCascadeCount;\n"),0!==i?l+="uniform vec4 light"+n+"_shadowParams;\n":(T=!0,l+="uniform vec3 light"+n+"_shadowParams;\n"),1===i?l+="uniform samplerCube light"+n+"_shadowMap;\n":a._isPcf&&e.webgl2?l+="uniform sampler2DShadow light"+n+"_shadowMap;\n":l+="uniform sampler2D light"+n+"_shadowMap;\n",w++,x[a._shadowType]=!0,a._isVsm&&(E=!0),a._isPcf&&(e.webgl2||e.extStandardDerivatives)&&2===i&&(S=!0)),a._cookie&&(a._cookie._cubemap?1===i&&(l+="uniform samplerCube light"+n+"_cookie;\n",l+="uniform float light"+n+"_cookieIntensity;\n",a.castShadows&&!t.noShadow||(l+="uniform mat4 light"+n+"_shadowMatrix;\n")):2===i&&(l+="uniform sampler2D light"+n+"_cookie;\n",l+="uniform float light"+n+"_cookieIntensity;\n",a.castShadows&&!t.noShadow||(l+="uniform mat4 light"+n+"_shadowMatrix;\n"),a._cookieTransform&&(l+="uniform vec4 light"+n+"_cookieMatrix;\n",l+="uniform vec2 light"+n+"_cookieOffset;\n")))}if(l+="\n",C=!t.hasTangents&&e.extStandardDerivatives?d.TBNderivativePS:t.fastTbn?d.TBNfastPS:d.TBNPS,s)if(t.normalMap||t.clearCoatNormalMap){if(l+=t.packedNormal?d.normalXYPS:d.normalXYZPS,!t.hasTangents){const e=t.normalMap?"normalMap":"clearCoatNormalMap",n=this._getUvSourceExpression(`${e}Transform`,`${e}Uv`,t);C=C.replace(/\$UV/g,n)}l+=C}else t.enableGGXSpecular&&!t.heightMap&&(l+=d.normalVertexPS,l+=d.TBNObjectSpacePS);if(s)if(t.normalMap){t.normalDetail&&(l+=this._addMap("normalDetail","normalDetailMapPS",t,d));const e=this._getUvSourceExpression("normalMapTransform","normalMapUv",t);t.normalizeNormalMap?l+=d.normalMapPS.replace(/\$UV/g,e):l+=d.normalMapFastPS.replace(/\$UV/g,e)}else t.enableGGXSpecular&&!t.heightMap||(l+=d.normalVertexPS);if(l+=ym(t.gamma,d),l+=bm(t.toneMap,d),l+=vm(t.fog,d),l+=d.decodePS,t.useRgbm&&(l+=d.rgbmPS),t.useCubeMapRotation&&(l+="#define CUBEMAP_ROTATION\n"),s&&(l+=d.cubeMapRotatePS,l+=t.cubeMapProjection>0?d.cubeMapProjectBoxPS:d.cubeMapProjectNonePS,l+=t.skyboxIntensity?d.envMultiplyPS:d.envConstPS),t.diffuseDetail&&(l+=this._addMap("diffuseDetail","diffuseDetailMapPS",t,d)),l+=this._addMap("diffuse","diffusePS",t,d),(3!==t.blendType||t.alphaTest||t.alphaToCoverage)&&(l+=this._addMap("opacity","opacityPS",t,d)),l+=this._addMap("emissive","emissivePS",t,d,t.emissiveFormat),n&&t.useSpecular||a){t.specularAntialias&&t.normalMap?t.normalizeNormalMap&&s?l+=d.specularAaToksvigPS:l+=d.specularAaToksvigFastPS:l+=d.specularAaNonePS;const e=t.useMetalness?"metalness":"specular";l+=this._addMap(e,e+"PS",t,d),l+=this._addMap("gloss","glossPS",t,d),2===t.fresnelModel&&(l+=d.fresnelSchlickPS)}if(t.clearCoat>0&&(l+=this._addMap("clearCoat","clearCoatPS",t,d),l+=this._addMap("clearCoatGloss","clearCoatGlossPS",t,d),l+=this._addMap("clearCoatNormal","clearCoatNormalPS",t,d)),t.heightMap){if(!t.normalMap){const e=this._getUvSourceExpression("heightMapTransform","heightMapUv",t);t.hasTangents||(C=C.replace(/\$UV/g,e)),l+=C}l+=this._addMap("height","parallaxPS",t,d)}const M=t.aoMap||t.aoVertexColor;if(M&&(l+=this._addMap("ao","aoPS",t,d),l+=d.aoDiffuseOccPS,t.occludeSpecular&&(1===t.occludeSpecular?l+=t.occludeSpecularFloat?d.aoSpecOccSimplePS:d.aoSpecOccConstSimplePS:l+=t.occludeSpecularFloat?d.aoSpecOccPS:d.aoSpecOccConstPS)),"envAtlas"===t.reflectionSource)l+=d.reflectionEnvPS.replace(/\$DECODE/g,this._decodeFunc(t.reflectionEncoding));else if("cubeMap"===t.reflectionSource)l+=t.fixSeams?d.fixCubemapSeamsStretchPS:d.fixCubemapSeamsNonePS,l+=d.reflectionCubePS.replace(/\$DECODE/g,this._decodeFunc(t.reflectionEncoding));else if("sphereMap"===t.reflectionSource){l+=(e.fragmentUniformsCount>16?d.reflectionSpherePS:d.reflectionSphereLowPS).replace(/\$DECODE/g,this._decodeFunc(t.reflectionEncoding))}a&&(t.clearCoat>0&&(l+=d.reflectionCCPS),t.refraction&&(l+=d.refractionPS)),t.clusteredLightingEnabled&&(l+=d.clusteredLightUtilsPS,l+=d.clusteredLightCookiesPS,x[0]=!0,x[4]=!0,S=!0),(w>0||t.clusteredLightingEnabled)&&(T&&(l+=d.shadowCascadesPS),x[0]&&(l+=d.shadowStandardPS),x[4]&&e.webgl2&&(l+=d.shadowStandardGL2PS),E&&(l+=d.shadowVSM_commonPS,x[1]&&(l+=d.shadowVSM8PS),x[2]&&(l+=e.extTextureHalfFloatLinear?d.shadowEVSMPS.replace(/\$/g,"16"):d.shadowEVSMnPS.replace(/\$/g,"16")),x[3]&&(l+=e.extTextureFloatLinear?d.shadowEVSMPS.replace(/\$/g,"32"):d.shadowEVSMnPS.replace(/\$/g,"32"))),e.webgl2||e.extStandardDerivatives||(l+=d.biasConstPS),l+=d.shadowCoordPS+d.shadowCommonPS,S&&(l+=d.shadowCoordPerspZbufferPS)),t.enableGGXSpecular&&(l+="uniform float material_anisotropy;\n"),n&&(l+=d.lightDiffuseLambertPS,(A||t.clusteredLightingEnabled)&&(l+=d.ltc)),l+="\n";let L=!1;t.useSpecular?(l+="#define CLUSTER_SPECULAR\n",t.conserveEnergy&&(l+="#define CLUSTER_CONSERVE_ENERGY\n"),n&&(l+=0===t.shadingModel?d.lightSpecularPhongPS:t.enableGGXSpecular?d.lightSpecularAnisoGGXPS:d.lightSpecularBlinnPS),t.fresnelModel>0?t.conserveEnergy&&!A?l+=d.combineDiffuseSpecularPS:l+=d.combineDiffuseSpecularNoConservePS:a?l+=d.combineDiffuseSpecularOldPS:t.diffuseMap?l+=d.combineDiffuseSpecularNoReflPS:(l+=d.combineDiffuseSpecularNoReflSeparateAmbientPS,L=!0)):l+=d.combineDiffusePS,t.clearCoat>0&&(l+=d.combineClearCoatPS);let R=!0;if(t.lightMap||t.lightVertexColor){const e=t.dirLightMap&&t.useSpecular?"lightmapDirPS":"lightmapSinglePS";l+=this._addMap("light",e,t,d,t.lightMapFormat),R=t.lightMapWithoutAmbient}R&&("ambientSH"===t.ambientSource?l+=d.ambientSHPS:"envAtlas"===t.ambientSource?l+=d.ambientEnvPS.replace(/\$DECODE/g,this._decodeFunc(t.ambientEncoding)):l+=d.ambientConstantPS),t.ambientTint&&!L&&(l+="uniform vec3 material_ambient;\n"),t.alphaTest&&(l+=d.alphaTestPS),t.msdf&&(l+=d.msdfPS),s&&(l+=d.viewDirPS,t.useSpecular&&(l+=t.enableGGXSpecular?d.reflDirAnisoPS:d.reflDirPS));let I,P=!1,k=!1,D=!1,O=!1,F=!1;t.clusteredLightingEnabled&&n&&(O=!0,P=!0,k=!0,F=!0,l+=d.floatUnpackingPS,t.lightMaskDynamic&&(l+="\n#define CLUSTER_MESH_DYNAMIC_LIGHTS"),t.clusteredLightingCookiesEnabled&&(l+="\n#define CLUSTER_COOKIES"),t.clusteredLightingShadowsEnabled&&!t.noShadow&&(l+="\n#define CLUSTER_SHADOWS",l+="\n#define CLUSTER_SHADOW_TYPE_"+Qu[t.clusteredLightingShadowType]),t.clusteredLightingAreaLightsEnabled&&(l+="\n#define CLUSTER_AREALIGHTS"),l+=wf.shaderDefines,l+=d.clusteredLightShadowsPS,l+=d.clusteredLightPS),t.twoSidedLighting&&(l+="uniform float twoSidedLightingNegScaleFactor;\n"),l=this._fsAddStartCode(l,e,d,t),s&&(t.hasTangents||!e.extStandardDerivatives||t.fastTbn?t.twoSidedLighting?l+="\t dVertexNormalW = gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor;\n":l+="\t dVertexNormalW = vNormalW;\n":t.twoSidedLighting?l+="\t dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);\n":l+="\t dVertexNormalW = normalize(vNormalW);\n",(t.heightMap||t.normalMap)&&t.hasTangents&&(t.twoSidedLighting?(l+="\t dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;\n",l+="\t dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;\n"):(l+="\t dTangentW = vTangentW;\n",l+="\t dBinormalW = vBinormalW;\n")));let N=!1;3!==t.blendType||t.alphaTest||t.alphaToCoverage?t.heightMap&&t.opacityMap?N=!0:(l+="\t getOpacity();\n",t.alphaTest&&(l+="\t alphaTest(dAlpha);\n")):l+="\t dAlpha = 1.0;\n";let V=!1;if(s&&(l+="\t getViewDir();\n",(t.heightMap||t.normalMap||t.clearCoatNormalMap||t.enableGGXSpecular)&&(l+="\t getTBN();\n"),t.heightMap&&(l+="\t getParallax();\n"),N&&(l+="\t getOpacity();\n",t.alphaTest&&(l+="\t alphaTest(dAlpha);\n")),l+="\t getNormal();\n",t.useSpecular&&(n&&t.enableGGXSpecular&&(l+="\t getGlossiness();\n",V=!0),l+="\t getReflDir();\n")),l+="\t getAlbedo();\n",t.clearCoat>0&&(l+="\t getClearCoat();\n",l+="\t getClearCoatGlossiness();\n",l+="\t getClearCoatNormal();\n"),(n&&t.useSpecular||a)&&(l+="\t getSpecularity();\n",V||(l+="\t getGlossiness();\n"),A&&(l+="\t #ifdef AREA_LIGHTS\n",l+="\t dSpecularityNoFres = dSpecularity;\n",l+="\t #ifdef CLEARCOAT\n",l+="\t ccSpecularityNoFres = ccSpecularity;\n",l+="\t #endif\n",l+="\t #endif\n"),t.fresnelModel>0&&(l+="\t getFresnel();\n")),M&&(l+="\tgetAO();\n"),R&&(l+="\t addAmbient();\n",t.separateAmbient&&(l+="\n\t\t\t\t\t\t\t\t\t\tvec3 dAmbientLight = dDiffuseLight;\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = vec3(0);\n\t\t\t\t\t\t\t\t")),t.ambientTint&&!L&&(l+="\t dDiffuseLight *= material_ambient;\n"),M&&!t.occludeDirect&&(l+="\t\toccludeDiffuse();\n"),(t.lightMap||t.lightVertexColor)&&(l+="\t addLightMap();\n"),n||a){a&&(t.clearCoat>0&&(l+="\t addReflectionCC();\n"),l+="\t addReflection();\n"),A&&(l+="\t ccReflection.rgb *= ccSpecularity;\n",l+="\t dReflection.rgb *= dSpecularity;\n",l+="\t dSpecularLight *= dSpecularity;\n",l+="\t float roughness = max((1.0 - dGlossiness) * (1.0 - dGlossiness), 0.001);\n",l+="\t calcLTCLightValues();\n");for(let n=0;n<t.lights.length;n++){const a=t.lights[n],i=a._type;if(t.clusteredLightingEnabled&&0!==i)continue;I=!1;const s=A&&a._shape?a.shape:0,o=A&&a._shape?this._getLightSourceShapeString(s):"";if(0!==s&&(l+="\t calc"+o+"LightValues(light"+n+"_position, light"+n+"_halfWidth, light"+n+"_halfHeight);\n"),0===i?(l+="\t dLightDirNormW = light"+n+"_direction;\n",l+="\t dAtten = 1.0;\n"):(a._cookie&&(2!==i||a._cookie._cubemap?1===i&&a._cookie._cubemap&&(F=!0,I=!0):(F=!0,I=!0)),l+="\t getLightDirPoint(light"+n+"_position);\n",P=!0,I&&(l+=2===i?"\t dAtten3 = getCookie2D"+(a._cookieFalloff?"":"Clip")+(a._cookieTransform?"Xform":"")+"(light"+n+"_cookie, light"+n+"_shadowMatrix, light"+n+"_cookieIntensity"+(a._cookieTransform?", light"+n+"_cookieMatrix, light"+n+"_cookieOffset":"")+")."+a._cookieChannel+";\n":"\t dAtten3 = getCookieCube(light"+n+"_cookie, light"+n+"_shadowMatrix, light"+n+"_cookieIntensity)."+a._cookieChannel+";\n"),0===s?0===a._falloffMode?(l+="\t dAtten = getFalloffLinear(light"+n+"_radius);\n",k=!0):(l+="\t dAtten = getFalloffInvSquared(light"+n+"_radius);\n",D=!0):(l+="\t dAtten = getFalloffWindow(light"+n+"_radius);\n",D=!0),l+="\t if (dAtten > 0.00001) {\n",2===i&&(I&&!a._cookieFalloff||(l+="\t\t\t dAtten *= getSpotEffect(light"+n+"_direction, light"+n+"_innerConeAngle, light"+n+"_outerConeAngle);\n",O=!0))),l+=0!==s?0===i?"\t\t\t dAttenD = getLightDiffuse();\n":"\t\t\t dAttenD = get"+o+"LightDiffuse() * 16.0;\n":"\t\t\t dAtten *= getLightDiffuse();\n",a.castShadows&&!t.noShadow){let s,o=null;if(1===a._shadowType?(o="VSM8",s="0.0"):2===a._shadowType?(o="VSM16",s="5.54"):3===a._shadowType?(o="VSM32",s=e.textureFloatHighPrecision?"15.0":"5.54"):o=4===a._shadowType?"PCF5x5":"PCF3x3",null!==o)if(1===i)r="(light"+n+"_shadowMap, light"+n+"_shadowParams);\n",a._normalOffsetBias&&(l+="\t\t\t normalOffsetPointShadow(light"+n+"_shadowParams);\n"),l+="\t\t\t dAtten *= getShadowPoint"+o+r;else{const r=`light${n}_shadowMatrix`,c=`light${n}_shadowParams`;l+=this._nonPointShadowMapProjection(e,t.lights[n],r,c,n),2===i&&(o="Spot"+o),l+="\t\t\t dAtten *= getShadow"+o+"(light"+n+"_shadowMap, light"+n+"_shadowParams"+(a._isVsm?", "+s:"")+");\n"}}0!==s?t.conserveEnergy&&t.useSpecular?l+="\t\t\t dDiffuseLight += mix((dAttenD * dAtten) * light"+n+"_color"+(I?" * dAtten3":"")+", vec3(0), dLTCSpecFres);\n":l+="\t\t\t dDiffuseLight += (dAttenD * dAtten) * light"+n+"_color"+(I?" * dAtten3":"")+";\n":A&&t.conserveEnergy&&t.useSpecular?l+="\t\t\t dDiffuseLight += mix(dAtten * light"+n+"_color"+(I?" * dAtten3":"")+", vec3(0), dSpecularity);\n":l+="\t\t\t dDiffuseLight += dAtten * light"+n+"_color"+(I?" * dAtten3":"")+";\n",0!==s?(t.clearCoat>0&&(l+="\t\t\t ccSpecularLight += ccLTCSpecFres * get"+o+"LightSpecularCC() * dAtten * light"+n+"_color"+(I?" * dAtten3":"")+";\n"),t.useSpecular&&(l+="\t\t\t dSpecularLight += dLTCSpecFres * get"+o+"LightSpecular() * dAtten * light"+n+"_color"+(I?" * dAtten3":"")+";\n")):A?(t.clearCoat>0&&(l+="\t\t\t ccSpecularLight += ccSpecularity * getLightSpecularCC() * dAtten * light"+n+"_color"+(I?" * dAtten3":"")+";\n"),t.useSpecular&&(l+="\t\t\t dSpecularLight += dSpecularity * getLightSpecular() * dAtten * light"+n+"_color"+(I?" * dAtten3":"")+";\n")):(t.clearCoat>0&&(l+="\t\t\t ccSpecularLight += getLightSpecularCC() * dAtten * light"+n+"_color"+(I?" * dAtten3":"")+";\n"),t.useSpecular&&(l+="\t\t\t dSpecularLight += getLightSpecular() * dAtten * light"+n+"_color"+(I?" * dAtten3":"")+";\n")),0!==i&&(l+="\t }\n"),l+="\n"}t.clusteredLightingEnabled&&n&&(k=!0,D=!0,P=!0,l+="\t addClusteredLights();\n"),A&&(t.clearCoat>0&&(l+="\t ccSpecularity = 1.0;\n"),t.useSpecular&&(l+="\t dSpecularity = vec3(1);\n")),a&&t.refraction&&(l+="\t addRefraction();\n")}l+="\n",M&&(t.occludeDirect&&(l+="\t\toccludeDiffuse();\n"),t.occludeSpecular&&(l+="\t\toccludeSpecular();\n")),!1===t.opacityFadesSpecular&&(2!==t.blendType&&4!==t.blendType||(l+="float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\n",l+="#ifdef CLEARCOAT\n specLum += dot(ccSpecularLight * ccSpecularity + ccReflection.rgb * ccReflection.a * ccSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif\n",l+="dAlpha = clamp(dAlpha + gammaCorrectInput(specLum), 0.0, 1.0);\n"),l+="dAlpha *= material_alphaFade;\n"),l+=d.endPS,2===t.blendType||6===t.blendType||t.alphaToCoverage?l+=d.outputAlphaPS:4===t.blendType?l+=d.outputAlphaPremulPS:l+=d.outputAlphaOpaquePS,t.msdf&&(l+="\t gl_FragColor = applyMsdf(gl_FragColor);\n"),l+="\n",l+="}\n",P&&(l=d.lightDirPointPS+l),k&&(l=d.falloffLinearPS+l),D&&(l=d.falloffInvSquaredPS+l),O&&(l=d.spotPS+l),F&&(l=d.cookiePS+l);let B="";return l.includes("dReflection")&&(B+="vec4 dReflection;\n"),l.includes("dTBN")&&(B+="mat3 dTBN;\n"),l.includes("dAlbedo")&&(B+="vec3 dAlbedo;\n"),l.includes("dEmission")&&(B+="vec3 dEmission;\n"),l.includes("dNormalW")&&(B+="vec3 dNormalW;\n"),l.includes("dVertexNormalW")&&(B+="vec3 dVertexNormalW;\n"),l.includes("dTangentW")&&(B+="vec3 dTangentW;\n"),l.includes("dBinormalW")&&(B+="vec3 dBinormalW;\n"),l.includes("dViewDirW")&&(B+="vec3 dViewDirW;\n"),l.includes("dReflDirW")&&(B+="vec3 dReflDirW;\n"),l.includes("dDiffuseLight")&&(B+="vec3 dDiffuseLight;\n"),l.includes("dSpecularLight")&&(B+="vec3 dSpecularLight;\n"),l.includes("dLightDirNormW")&&(B+="vec3 dLightDirNormW;\n"),l.includes("dLightDirW")&&(B+="vec3 dLightDirW;\n"),l.includes("dLightPosW")&&(B+="vec3 dLightPosW;\n"),l.includes("dShadowCoord")&&(B+="vec3 dShadowCoord;\n"),l.includes("dNormalMap")&&(B+="vec3 dNormalMap;\n"),l.includes("dSpecularity")&&(B+="vec3 dSpecularity;\n"),l.includes("dSpecularityNoFres")&&(B+="vec3 dSpecularityNoFres;\n"),l.includes("dUvOffset")&&(B+="vec2 dUvOffset;\n"),l.includes("dGlossiness")&&(B+="float dGlossiness;\n"),l.includes("dAlpha")&&(B+="float dAlpha;\n"),l.includes("dAtten")&&(B+="float dAtten;\n"),l.includes("dAttenD")&&(B+="float dAttenD;\n"),l.includes("dAtten3")&&(B+="vec3 dAtten3;\n"),l.includes("dAo")&&(B+="float dAo;\n"),l.includes("dMsdf")&&(B+="vec4 dMsdf;\n"),l.includes("ccReflection")&&(B+="vec4 ccReflection;\n"),l.includes("ccNormalW")&&(B+="vec3 ccNormalW;\n"),l.includes("ccReflDirW")&&(B+="vec3 ccReflDirW;\n"),l.includes("ccSpecularLight")&&(B+="vec3 ccSpecularLight;\n"),l.includes("ccSpecularity")&&(B+="float ccSpecularity;\n"),l.includes("ccSpecularityNoFres")&&(B+="float ccSpecularityNoFres;\n"),l.includes("ccGlossiness")&&(B+="float ccGlossiness;\n"),l=_+B+l,b=l,{attributes:p,vshader:g,fshader:b,tag:1}}},Ef={begin:Tm,dummyFragmentCode:Cm,end:Em,fogCode:vm,gammaCode:ym,precisionCode:wm,skinCode:_m,tonemapCode:bm,versionCode:xm,basic:Dm,particle:Om,skybox:Fm,standard:Tf},Sf=function(e,t,n){const a=2.399963229728653*t,i=Math.sqrt(t)/Math.sqrt(n);e.x=i*Math.cos(a),e.y=i*Math.sin(a)},Af=function(e,t,n,a=0,i=1){a=1-2*a,i=1-2*i;const s=Eu.lerp(a,i,t/n),r=Math.sqrt(1-s*s),o=2.399963229728653*t;e.x=Math.cos(o)*r,e.y=s,e.z=Math.sin(o)*r},Mf=function(e){let t=(e<<16|e>>>16)>>>0;return t=((1431655765&t)<<1|(2863311530&t)>>>1)>>>0,t=((858993459&t)<<2|(3435973836&t)>>>2)>>>0,t=((252645135&t)<<4|(4042322160&t)>>>4)>>>0,t=((16711935&t)<<8|(4278255360&t)>>>8)>>>0,2.3283064365386963e-10*t},Lf=e=>{switch(e.type){case"rgbm":return"RGBM";case"rgbe":return"RGBE";default:switch(e.format){case 11:case 13:case 12:case 14:return"Linear";default:return"Gamma"}}},Rf=e=>{switch("none"===e&&(e="equirect"),e){case"cube":return"Cubemap";case"equirect":return"Equirect";case"octahedral":return"Octahedral"}},If=(e,t,n)=>{if(e<=0)t[n+0]=0,t[n+1]=0,t[n+2]=0,t[n+3]=0;else if(e>=1)t[n+0]=255,t[n+1]=0,t[n+2]=0,t[n+3]=0;else{let a=1*e%1,i=255*e%1,s=65025*e%1;const r=16581375*e%1;a-=i/255,i-=s/255,s-=r/255,t[n+0]=Math.min(255,Math.floor(256*a)),t[n+1]=Math.min(255,Math.floor(256*i)),t[n+2]=Math.min(255,Math.floor(256*s)),t[n+3]=Math.min(255,Math.floor(256*r))}},Pf=(e,t,n,a)=>{const i=2*n*Math.PI,s=Math.pow(1-t,1/(a+1)),r=Math.sqrt(1-s*s);e.set(Math.cos(i)*r,Math.sin(i)*r,s).normalize()},kf=(e,t,n)=>{const a=2*n*Math.PI,i=Math.sqrt(1-t),s=Math.sqrt(t);e.set(Math.cos(a)*s,Math.sin(a)*s,i).normalize()},Df=(e,t,n,a)=>{const i=2*n*Math.PI,s=Math.sqrt((1-t)/(1+(a*a-1)*t)),r=Math.sqrt(1-s*s);e.set(Math.cos(i)*r,Math.sin(i)*r,s).normalize()},Of=(e,t)=>{const n=e*t,a=t/(1-e*e+n*n);return a*a*(1/Math.PI)},Ff={16:{2:26,8:20,32:17,128:16,512:16},32:{2:53,8:40,32:34,128:32,512:32},128:{2:214,8:163,32:139,128:130,512:128},1024:{2:1722,8:1310,32:1114,128:1041,512:1025}},Nf=(e,t,n)=>{const a=n/e,i=1-Math.log2(t)/11,s=i*i,r=new Pu,o=new Pu,l=new Pu(0,0,1),c=[],h=((e,t)=>{const n=Ff[e];return n&&n[t]||e})(e,t);for(let e=0;e<h;++e){Df(r,e/h,Mf(e),s);const t=r.z;if(o.set(r.x,r.y,r.z).mulScalar(2*t).sub(l),o.z>0){const e=Of(Math.min(1,t),s)/4+.001,n=.5*Math.log2(a/e);c.push(o.x,o.y,o.z,n)}}for(;c.length<4*e;)c.push(0,0,0,0);return c},Vf=(e,t,n)=>{const a=(e=>{const t=e.length,n=Math.min(t,512),a=Math.ceil(t/n),i=new Uint8Array(n*a*4);let s=0;for(let n=0;n<t;++n)If(.5*e[4*n+0]+.5,i,s+0),If(.5*e[4*n+1]+.5,i,s+4),If(.5*e[4*n+2]+.5,i,s+8),If(e[4*n+3]/8,i,s+12),s+=16;return{width:n,height:a,data:i}})(n);return new Gm(e,{name:t,width:a.width,height:a.height,mipmaps:!1,minFilter:0,magFilter:0,levels:[a.data]})};class Bf{constructor(e=!0){this.map=new Map,this.destroyContent=e}destroy(){this.destroyContent&&this.map.forEach(((e,t)=>{e.destroy()}))}get(e,t){if(!this.map.has(e)){const n=t();return this.map.set(e,n),n}return this.map.get(e)}}const Uf=new Bf(!1),zf=new dm,Gf=(e,t,n)=>zf.get(e,(()=>new Bf)).get(t,(()=>Vf(e,t,Uf.get(t,n)))),Hf=(e,t,n)=>Gf(e,`lambert-samples-${t}-${n}`,(()=>((e,t)=>{const n=t/e,a=new Pu,i=[];for(let t=0;t<e;++t){kf(a,t/e,Mf(t));const s=a.z/Math.PI,r=.5*Math.log2(n/s);i.push(a.x,a.y,a.z,r)}return i})(t,n))),Wf=(e,t,n)=>Gf(e,`phong-samples-${t}-${n}`,(()=>((e,t)=>{const n=new Pu,a=[];for(let i=0;i<e;++i)Pf(n,i/e,Mf(i),t),a.push(n.x,n.y,n.z,0);return a})(t,n))),jf=(e,t,n,a)=>Gf(e,`ggx-samples-${t}-${n}-${a}`,(()=>Nf(t,n,a))),Xf="\nattribute vec2 vertex_position;\n\nuniform vec4 uvMod;\n\nvarying vec2 vUv0;\n\nvoid main(void) {\n\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\tvUv0 = (vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw;\n}\n";function Yf(e,t,n={}){var a;e instanceof wg&&(e=arguments[1],t=arguments[2],n={},void 0!==arguments[3]&&(n.specularPower=arguments[3]),void 0!==arguments[4]&&(n.numSamples=arguments[4]));const i={none:"reproject",lambert:"prefilterSamplesUnweighted",phong:"prefilterSamplesUnweighted",ggx:"prefilterSamples"},s=n.hasOwnProperty("specularPower")?n.specularPower:1,r=n.hasOwnProperty("face")?n.face:null,o=n.hasOwnProperty("distribution")?n.distribution:1===s?"none":"phong",l=i[o]||"reproject",c=`decode${Lf(e)}`,h=`encode${Lf(t)}`,d=`sample${Rf(e.projection)}`,p=`getDirection${Rf(t.projection)}`,u=n.hasOwnProperty("numSamples")?n.numSamples:1024,m=`${l}_${c}_${h}_${d}_${p}_${u}`,f=e.device;let g=f.programLib._cache[m];if(!g){const e=`#define PROCESS_FUNC ${l}\n#define DECODE_FUNC ${c}\n#define ENCODE_FUNC ${h}\n#define SOURCE_FUNC ${d}\n#define TARGET_FUNC ${p}\n#define NUM_SAMPLES ${u}\n`+(f.extTextureLod?"#define SUPPORTS_TEXLOD\n":"");let t="";f.webgl2||(t="#extension GL_OES_standard_derivatives: enable\n",f.extTextureLod&&(t+="#extension GL_EXT_shader_texture_lod: enable\n\n")),g=Mm(f,Xf,`${e}\n${gm.reprojectPS}`,m,!1,t)}const y=f.scope.resolve(e.cubemap?"sourceCube":"sourceTex");y.setValue(e);const b=f.scope.resolve("params"),v=f.scope.resolve("params2"),_=f.scope.resolve("uvMod");if(null!=(a=n)&&a.seamPixels){const e=n.seamPixels,a=(n.rect?n.rect.z:t.width)-2*e,i=(n.rect?n.rect.w:t.height)-2*e;_.setValue([(a+2*e)/a,(i+2*e)/i,-e/a,-e/i])}else _.setValue([1,1,0,0]);const w=[0,s,e.fixCubemapSeams?1/e.width:0,t.fixCubemapSeams?1/t.width:0],x=[t.width*t.height*(t.cubemap?6:1),e.width*e.height*(e.cubemap?6:1)];if(l.startsWith("prefilterSamples")){const t=e.width*e.height*(e.cubemap?6:1),n="ggx"===o?jf(f,u,s,t):"lambert"===o?Hf(f,u,t):Wf(f,u,s);f.scope.resolve("samplesTex").setValue(n),f.scope.resolve("samplesTexInverseSize").setValue([1/n.width,1/n.height])}for(let e=0;e<(t.cubemap?6:1);e++)if(null===r||e===r){var C;const a=new Cg({colorBuffer:t,face:e,depth:!1});w[0]=e,b.setValue(w),v.setValue(x),mm(f,a,g,null==(C=n)?void 0:C.rect),a.destroy()}}const qf=(e,t=0)=>1+Math.floor(Math.log2(Math.max(e,t)));class Kf{static generateSkyboxCubemap(e,t){const n=((e,t,n,a)=>new Gm(e,{name:`lighting-${t}`,cubemap:!0,width:t,height:t,format:n,type:7===n?"rgbm":"default",addressU:1,addressV:1,fixCubemapSeams:!0,mipmaps:!!a}))(e.device,t||(e.cubemap?e.width:e.width/4),7,!1);return Yf(e,n,{numSamples:1024}),n}static generateLightingSource(e,t=null){const n=e.device,a=(e=>(e=>e.extTextureHalfFloat&&e.textureHalfFloatRenderable)(e)?12:(e=>e.extTextureFloat&&e.textureFloatRenderable)(e)?14:7)(n),i=(null==t?void 0:t.target)||new Gm(n,{name:"lighting-source",cubemap:!0,width:(null==t?void 0:t.size)||128,height:(null==t?void 0:t.size)||128,format:a,type:7===a?"rgbm":"default",addressU:1,addressV:1,fixCubemapSeams:!1,mipmaps:!0});return Yf(e,i,{numSamples:e.mipmaps?1:1024}),i}static generateAtlas(e,t=null){const n=e.device,a=(null==t?void 0:t.target)||new Gm(n,{width:(null==t?void 0:t.size)||512,height:(null==t?void 0:t.size)||512,format:7,type:"rgbm",projection:"equirect",addressU:1,addressV:1,mipmaps:!1}),i=a.width/512,s=new Ou(0,0,512*i,256*i),r=qf(256)-qf(4);for(let t=0;t<r;++t)Yf(e,a,{numSamples:1,rect:s,seamPixels:i}),s.x+=s.w,s.y+=s.w,s.z=Math.max(1,Math.floor(.5*s.z)),s.w=Math.max(1,Math.floor(.5*s.w));s.set(0,256*i,256*i,128*i);for(let n=1;n<7;++n)Yf(e,a,{numSamples:(null==t?void 0:t.numReflectionSamples)||1024,distribution:(null==t?void 0:t.distribution)||"ggx",specularPower:Math.max(1,2048>>2*n),rect:s,seamPixels:i}),s.y+=s.w,s.z=Math.max(1,Math.floor(.5*s.z)),s.w=Math.max(1,Math.floor(.5*s.w));return s.set(128*i,384*i,64*i,32*i),Yf(e,a,{numSamples:(null==t?void 0:t.numAmbientSamples)||2048,distribution:"lambert",rect:s,seamPixels:i}),a}static generatePrefilteredAtlas(e,t=null){const n=e[0].device,a=(null==t?void 0:t.target)||new Gm(n,{width:(null==t?void 0:t.size)||512,height:(null==t?void 0:t.size)||512,format:7,type:"rgbm",projection:"equirect",addressU:1,addressV:1,mipmaps:!1}),i=a.width/512,s=new Ou(0,0,512*i,256*i),r=qf(512);for(let t=0;t<r;++t)Yf(e[0],a,{numSamples:1,rect:s,seamPixels:i}),s.x+=s.w,s.y+=s.w,s.z=Math.max(1,Math.floor(.5*s.z)),s.w=Math.max(1,Math.floor(.5*s.w));s.set(0,256*i,256*i,128*i);for(let t=1;t<e.length;++t)Yf(e[t],a,{numSamples:1,rect:s,seamPixels:i}),s.y+=s.w,s.z=Math.max(1,Math.floor(.5*s.z)),s.w=Math.max(1,Math.floor(.5*s.w));return s.set(128*i,384*i,64*i,32*i),null!=t&&t.legacyAmbient?Yf(e[5],a,{numSamples:1,rect:s,seamPixels:i}):Yf(e[0],a,{numSamples:(null==t?void 0:t.numSamples)||2048,distribution:"lambert",rect:s,seamPixels:i}),a}}const Zf=new dm;function $f(e){return Zf.get(e)}let Qf=0;class Jf{constructor(){this.name="Untitled",this.id=Qf++,this._shader=null,this.variants={},this.parameters={},this.alphaTest=0,this.alphaToCoverage=!1,this.blend=!1,this.blendSrc=1,this.blendDst=0,this.blendEquation=0,this.separateAlphaBlend=!1,this.blendSrcAlpha=1,this.blendDstAlpha=0,this.blendAlphaEquation=0,this.cull=1,this.depthTest=!0,this.depthFunc=3,this.depthWrite=!0,this.stencilFront=null,this.stencilBack=null,this.depthBias=0,this.slopeDepthBias=0,this.redWrite=!0,this.greenWrite=!0,this.blueWrite=!0,this.alphaWrite=!0,this.meshInstances=[],this._shaderVersion=0,this._scene=null,this._dirtyBlend=!1,this.dirty=!0}set shader(e){this._shader=e}get shader(){return this._shader}get transparent(){return this.blend||1!==this.blendSrc||0!==this.blendDst||0!==this.blendEquation}set blendType(e){const t=this.blend;switch(e){case 3:this.blend=!1,this.blendSrc=1,this.blendDst=0,this.blendEquation=0;break;case 2:this.blend=!0,this.blendSrc=6,this.blendDst=8,this.blendEquation=0;break;case 4:this.blend=!0,this.blendSrc=1,this.blendDst=8,this.blendEquation=0;break;case 1:this.blend=!0,this.blendSrc=1,this.blendDst=1,this.blendEquation=0;break;case 6:this.blend=!0,this.blendSrc=6,this.blendDst=1,this.blendEquation=0;break;case 7:this.blend=!0,this.blendSrc=4,this.blendDst=2,this.blendEquation=0;break;case 8:this.blend=!0,this.blendSrc=5,this.blendDst=1,this.blendEquation=0;break;case 5:this.blend=!0,this.blendSrc=4,this.blendDst=0,this.blendEquation=0;break;case 9:this.blend=!0,this.blendSrc=1,this.blendDst=1,this.blendEquation=3;break;case 10:this.blend=!0,this.blendSrc=1,this.blendDst=1,this.blendEquation=4}t!==this.blend&&(this._scene?this._scene.layers._dirtyBlend=!0:this._dirtyBlend=!0),this._updateMeshInstanceKeys()}get blendType(){return this.transparent?this.blend&&6===this.blendSrc&&8===this.blendDst&&0===this.blendEquation?2:this.blend&&1===this.blendSrc&&1===this.blendDst&&0===this.blendEquation?1:this.blend&&6===this.blendSrc&&1===this.blendDst&&0===this.blendEquation?6:this.blend&&4===this.blendSrc&&2===this.blendDst&&0===this.blendEquation?7:this.blend&&5===this.blendSrc&&1===this.blendDst&&0===this.blendEquation?8:this.blend&&1===this.blendSrc&&1===this.blendDst&&3===this.blendEquation?9:this.blend&&1===this.blendSrc&&1===this.blendDst&&4===this.blendEquation?10:this.blend&&4===this.blendSrc&&0===this.blendDst&&0===this.blendEquation?5:this.blend&&1===this.blendSrc&&8===this.blendDst&&0===this.blendEquation?4:2:3}copy(e){return this.name=e.name,this.shader=e.shader,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.blend=e.blend,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.separateAlphaBlend=e.separateAlphaBlend,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendAlphaEquation=e.blendAlphaEquation,this.cull=e.cull,this.depthTest=e.depthTest,this.depthFunc=e.depthFunc,this.depthWrite=e.depthWrite,this.depthBias=e.depthBias,this.slopeDepthBias=e.slopeDepthBias,e.stencilFront&&(this.stencilFront=e.stencilFront.clone()),e.stencilBack&&(e.stencilFront===e.stencilBack?this.stencilBack=this.stencilFront:this.stencilBack=e.stencilBack.clone()),this.redWrite=e.redWrite,this.greenWrite=e.greenWrite,this.blueWrite=e.blueWrite,this.alphaWrite=e.alphaWrite,this}clone(){return(new this.constructor).copy(this)}_updateMeshInstanceKeys(){const e=this.meshInstances;for(let t=0;t<e.length;t++)e[t].updateKey()}updateUniforms(e,t){}updateShader(e,t,n,a,i,s){}update(){this.dirty=!0,this._shader&&(this._shader.failed=!1)}clearParameters(){this.parameters={}}getParameters(){return this.parameters}clearVariants(){this.variants={};for(let e=0;e<this.meshInstances.length;e++){const t=this.meshInstances[e];for(let e=0;e<t._shader.length;e++)t._shader[e]=null}}getParameter(e){return this.parameters[e]}setParameter(e,t){if(void 0===t&&"object"==typeof e){const n=e;if(n.length){for(let e=0;e<n.length;e++)this.setParameter(n[e]);return}e=n.name,t=n.value}const n=this.parameters[e];n?n.data=t:this.parameters[e]={scopeId:null,data:t}}deleteParameter(e){this.parameters[e]&&delete this.parameters[e]}setParameters(e,t){const n=this.parameters;void 0===t&&(t=n);for(const a in t){const t=n[a];t&&(t.scopeId||(t.scopeId=e.scope.resolve(a)),t.scopeId.setValue(t.data))}}destroy(){this.variants={},this.shader=null;for(let e=0;e<this.meshInstances.length;e++){const t=this.meshInstances[e];for(let e=0;e<t._shader.length;e++)t._shader[e]=null;if(t._material=null,t.mesh){const e=$f(t.mesh.device);this!==e&&(t.material=e)}}}addMeshInstanceRef(e){this.meshInstances.push(e)}removeMeshInstanceRef(e){const t=this.meshInstances,n=t.indexOf(e);-1!==n&&t.splice(n,1)}}const eg=(e,t)=>{if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0},tg=e=>1!==e.r||1!==e.g||1!==e.b;class ng{constructor(){this._mapXForms=null}updateMinRef(e,t,n,a,i,s,r,o){this._updateSharedOptions(e,n,a,i,r),this._updateMinOptions(e,a),this._updateUVOptions(e,a,i,!0)}updateRef(e,t,n,a,i,s,r,o){this._updateSharedOptions(e,n,a,i,r),this._updateEnvOptions(e,t,a,n),this._updateMaterialOptions(e,a),1===r&&(e.gamma&&(e.gamma=3),e.toneMap=0),e.hasTangents=i&&a.normalMap&&0!=(512&i),this._updateLightOptions(e,a,i,o,s),this._updateUVOptions(e,a,i,!1)}_updateSharedOptions(e,t,n,a,i){e.pass=i,e.alphaTest=n.alphaTest>0,e.forceFragmentPrecision=n.forceFragmentPrecision||"",e.chunks=n.chunks||"",e.blendType=n.blendType,e.forceUv1=n.forceUv1,e.separateAmbient=!1,e.screenSpace=a&&0!=(256&a),e.skin=a&&0!=(2&a),e.useInstancing=a&&0!=(32&a),e.useMorphPosition=a&&0!=(1024&a),e.useMorphNormal=a&&0!=(2048&a),e.useMorphTextureBased=a&&0!=(4096&a),e.nineSlicedMode=n.nineSlicedMode||0,t.clusteredLightingEnabled&&(e.clusteredLightingEnabled=!0,e.clusteredLightingCookiesEnabled=t.lighting.cookiesEnabled,e.clusteredLightingShadowsEnabled=t.lighting.shadowsEnabled,e.clusteredLightingShadowType=t.lighting.shadowType,e.clusteredLightingAreaLightsEnabled=t.lighting.areaLightsEnabled)}_updateUVOptions(e,t,n,a){let i=!1,s=!1,r=!1;n&&(i=0!=(4&n),s=0!=(8&n),r=0!=(16&n)),e.vertexColors=!1,this._mapXForms=[];for(const n in xf)this._updateTexOptions(e,t,n,i,s,r,a);this._mapXForms=null}_updateMinOptions(e,t){e.opacityTint=1!==t.opacity&&3!==t.blendType,e.lights=[]}_updateMaterialOptions(e,t){const n=(t.diffuseTint||!t.diffuseMap&&!t.diffuseVertexColor)&&tg(t.diffuse),a=!!(t.useMetalness||t.specularMap||t.sphereMap||t.cubeMap||(i=t.specular,0!==i.r||0!==i.g||0!==i.b)||t.enableGGXSpecular||t.clearCoat>0);var i;const s=a&&!t.useMetalness&&(t.specularTint||!t.specularMap&&!t.specularVertexColor)&&tg(t.specular),r=!t.emissiveMap||tg(t.emissive)&&t.emissiveTint,o=1!==t.emissiveIntensity,l=!!t.normalMap&&(10===t.normalMap.format||"swizzleGGGR"===t.normalMap.type);e.opacityTint=1!==t.opacity&&3!==t.blendType?1:0,e.blendMapsWithColors=!0,e.ambientTint=t.ambientTint,e.diffuseTint=n?2:0,e.specularTint=s?2:0,e.metalnessTint=t.useMetalness&&t.metalness<1?1:0,e.glossTint=1,e.emissiveTint=(r?2:0)+(o?1:0),e.alphaToCoverage=t.alphaToCoverage,e.normalizeNormalMap=t.normalizeNormalMap,e.ambientSH=!!t.ambientSH,e.useSpecular=a,e.emissiveFormat=t.emissiveMap?"rgbm"===t.emissiveMap.type?1:14===t.emissiveMap.format?2:0:null,e.lightMapFormat=t.lightMap?"rgbm"===t.lightMap.type?1:14===t.lightMap.format?2:0:null,e.specularAntialias=t.specularAntialias&&!!t.normalMap&&!!t.normalMap.mipmaps&&!l,e.conserveEnergy=t.conserveEnergy,e.opacityFadesSpecular=t.opacityFadesSpecular,e.alphaFade=t.alphaFade,e.occludeSpecular=t.occludeSpecular,e.occludeSpecularFloat=1!==t.occludeSpecularIntensity,e.occludeDirect=t.occludeDirect,e.shadingModel=t.shadingModel,e.fresnelModel=t.fresnelModel,e.packedNormal=l,e.fastTbn=t.fastTbn,e.cubeMapProjection=t.cubeMapProjection,e.customFragmentShader=t.customFragmentShader,e.refraction=!!t.refraction,e.useMetalness=t.useMetalness,e.enableGGXSpecular=t.enableGGXSpecular,e.msdf=!!t.msdfMap,e.twoSidedLighting=t.twoSidedLighting,e.pixelSnap=t.pixelSnap,e.aoMapUv=t.aoUvSet,e.diffuseDetail=!!t.diffuseMap,e.normalDetail=!!t.normalMap,e.diffuseDetailMode=t.diffuseDetailMode,e.detailModes=!!e.diffuseDetail,e.clearCoat=!!t.clearCoat,e.clearCoatTint=1!==t.clearCoat?1:0,e.clearCoatGlossiness=!!t.clearCoatGlossiness,e.clearCoatGlossTint=1!==t.clearCoatGlossiness?1:0}_updateEnvOptions(e,t,n,a){e.fog=n.useFog?a.fog:"none",e.gamma=n.useGammaTonemap?a.gammaCorrection:0,e.toneMap=n.useGammaTonemap?a.toneMapping:-1,e.useRgbm=n.emissiveMap&&"rgbm"===n.emissiveMap.type||n.lightMap&&"rgbm"===n.lightMap.type,e.fixSeams=!!n.cubeMap&&n.cubeMap.fixCubemapSeams;const i=0===n.shadingModel;let s=!1;if(n.envAtlas&&!i?(e.reflectionSource="envAtlas",e.reflectionEncoding=n.envAtlas.encoding):n.cubeMap?(e.reflectionSource="cubeMap",e.reflectionEncoding=n.cubeMap.encoding):n.sphereMap?(e.reflectionSource="sphereMap",e.reflectionEncoding=n.sphereMap.encoding):n.useSkybox&&a.envAtlas&&!i?(e.reflectionSource="envAtlas",e.reflectionEncoding=a.envAtlas.encoding,s=!0):(e.reflectionSource=null,e.reflectionEncoding=null),n.ambientSH&&!i)e.ambientSource="ambientSH",e.ambientEncoding=null;else{const t=n.envAtlas||(n.useSkybox&&a.envAtlas?a.envAtlas:null);t&&!i?(e.ambientSource="envAtlas",e.ambientEncoding=t.encoding):(e.ambientSource="constant",e.ambientEncoding=null)}e.skyboxIntensity=s&&1!==a.skyboxIntensity,e.useCubeMapRotation=s&&a.skyboxRotation&&!a.skyboxRotation.equals(Gu.IDENTITY)}_updateLightOptions(e,t,n,a,i){if(e.lightMap=!1,e.lightMapChannel="",e.lightMapUv=0,e.lightMapTransform=0,e.lightMapWithoutAmbient=!1,e.dirLightMap=!1,n&&(e.noShadow=0!=(1&n),0!=(64&n)&&(e.lightMapFormat=1,e.lightMap=!0,e.lightMapChannel="rgb",e.lightMapUv=1,e.lightMapTransform=0,e.lightMapWithoutAmbient=!t.lightMap,e.useRgbm=!0,0!=(128&n)&&(e.dirLightMap=!0),0!=(8192&n)&&(e.lightMapWithoutAmbient=!1))),t.useLighting){const t=[],s=n?n>>16:1;e.lightMaskDynamic=!!(1&s),a&&(this._collectLights(0,a[0],t,s),this._collectLights(1,a[1],t,s,i),this._collectLights(2,a[2],t,s,i)),e.lights=t}else e.lights=[];0===e.lights.length&&(e.noShadow=!0)}_updateTexOptions(e,t,n,a,i,s,r){const o=n+"Map",l=n+"VertexColor",c=n+"VertexColorChannel",h=o+"Channel",d=o+"Transform",p=o+"Uv";"light"!==n&&(e[o]=!1,e[h]="",e[d]=0,e[p]=0),e[l]=!1,e[c]="";const u="opacity"===n;if(u&&3===t.blendType&&0===t.alphaTest&&!t.alphaToCoverage)return e;if((!r||u)&&("height"!==n&&t[l]&&s&&(e[l]=t[l],e[c]=t[c],e.vertexColors=!0),t[o])){let n=!0;0!==t[p]||a||(n=!1),1!==t[p]||i||(n=!1),n&&(e[o]=!!t[o],e[d]=this._getMapTransformID(t.getUniform(d),t[p]),e[h]=t[h],e[p]=t[p])}}_collectLights(e,t,n,a,i){for(let i=0;i<t.length;i++){const s=t[i];if(s.enabled&&s.mask&a){if(0!==e&&s.isStatic)continue;n.push(s)}}if(i)for(let t=0;t<i.length;t++){const a=i[t];a._type===e&&n.push(a)}}_getMapTransformID(e,t){if(!e)return 0;let n=this._mapXForms[t];n||(n=[],this._mapXForms[t]=n);for(let t=0;t<n.length;t++)if(eg(n[t][0].value,e[0].value)&&eg(n[t][1].value,e[1].value))return t+1;return n.push(e)}}const ag={name:"string",chunks:"chunks",mappingFormat:"string",_engine:"boolean",ambient:"rgb",ambientTint:"boolean",aoVertexColor:"boolean",aoVertexColorChannel:"string",aoMap:"texture",aoMapChannel:"string",aoMapUv:"number",aoMapTiling:"vec2",aoMapOffset:"vec2",aoMapRotation:"number",diffuse:"rgb",diffuseTint:"boolean",diffuseVertexColor:"boolean",diffuseVertexColorChannel:"string",diffuseMap:"texture",diffuseMapChannel:"string",diffuseMapUv:"number",diffuseMapTiling:"vec2",diffuseMapOffset:"vec2",diffuseMapRotation:"number",diffuseDetailMap:"texture",diffuseDetailMapChannel:"string",diffuseDetailMapUv:"number",diffuseDetailMapTiling:"vec2",diffuseDetailMapOffset:"vec2",diffuseDetailMapRotation:"number",diffuseDetailMode:"string",specular:"rgb",specularTint:"boolean",specularVertexColor:"boolean",specularVertexColorChannel:"string",specularMap:"texture",specularMapChannel:"string",specularMapUv:"number",specularMapTiling:"vec2",specularMapOffset:"vec2",specularMapRotation:"number",specularAntialias:"boolean",occludeSpecular:"enum:occludeSpecular",useMetalness:"boolean",metalness:"number",enableGGXSpecular:"boolean",anisotropy:"number",metalnessTint:"boolean",metalnessVertexColor:"boolean",metalnessVertexColorChannel:"string",metalnessMap:"texture",metalnessMapChannel:"string",metalnessMapUv:"number",metalnessMapTiling:"vec2",metalnessMapOffset:"vec2",netalnessMapRotation:"number",conserveEnergy:"boolean",shininess:"number",glossVertexColor:"boolean",glossVertexColorChannel:"string",glossMap:"texture",glossMapChannel:"string",glossMapUv:"number",glossMapTiling:"vec2",glossMapOffset:"vec2",glossMapRotation:"number",clearCoat:"number",clearCoatVertexColor:"boolean",clearCoatVertexColorChannel:"string",clearCoatMap:"texture",clearCoatMapChannel:"string",clearCoatMapUv:"number",clearCoatMapTiling:"vec2",clearCoatMapOffset:"vec2",clearCoatMapRotation:"number",clearCoatGlossiness:"number",clearCoatGlossVertexColor:"boolean",clearCoatGlossVertexColorChannel:"string",clearCoatGlossMap:"texture",clearCoatGlossMapChannel:"string",clearCoatGlossMapUv:"number",clearCoatGlossMapTiling:"vec2",clearCoatGlossMapOffset:"vec2",clearCoatGlossMapRotation:"number",clearCoatBumpiness:"number",clearCoatNormalMap:"texture",clearCoatNormalMapUv:"number",clearCoatNormalMapTiling:"vec2",clearCoatNormalMapOffset:"vec2",clearCoatNormalMapRotation:"number",fresnelModel:"number",emissive:"rgb",emissiveTint:"boolean",emissiveVertexColor:"boolean",emissiveVertexColorChannel:"string",emissiveMap:"texture",emissiveMapChannel:"string",emissiveMapUv:"number",emissiveMapTiling:"vec2",emissiveMapOffset:"vec2",emissiveMapMapRotation:"number",emissiveIntensity:"number",normalMap:"texture",normalMapTiling:"vec2",normalMapOffset:"vec2",normalMapRotation:"number",normalMapUv:"number",bumpiness:"number",normalDetailMap:"texture",normalDetailMapTiling:"vec2",normalDetailMapOffset:"vec2",normalDetailMapRotation:"number",normalDetailMapUv:"number",normalDetailMapBumpiness:"number",heightMap:"texture",heightMapChannel:"string",heightMapUv:"number",heightMapTiling:"vec2",heightMapOffset:"vec2",heightMapRotation:"number",heightMapFactor:"number",alphaToCoverage:"boolean",alphaTest:"number",alphaFade:"number",opacity:"number",opacityVertexColor:"boolean",opacityVertexColorChannel:"string",opacityMap:"texture",opacityMapChannel:"string",opacityMapUv:"number",opacityMapTiling:"vec2",opacityMapOffset:"vec2",opacityMapRotation:"number",opacityFadesSpecular:"boolean",reflectivity:"number",refraction:"number",refractionIndex:"number",sphereMap:"texture",cubeMap:"cubemap",cubeMapProjection:"number",cubeMapProjectionBox:"boundingbox",lightVertexColor:"boolean",lightVertexColorChannel:"string",lightMap:"texture",lightMapChannel:"string",lightMapUv:"number",lightMapTiling:"vec2",lightMapOffset:"vec2",lightMapRotation:"number",depthTest:"boolean",depthFunc:"enum:depthFunc",depthWrite:"boolean",depthBias:"number",slopeDepthBias:"number",cull:"enum:cull",blendType:"enum:blendType",shadingModel:"enum:shadingModel",useFog:"boolean",useLighting:"boolean",useSkybox:"boolean",useGammaTonemap:"boolean",envAtlas:"texture"},ig=[];for(const e in ag){"texture"===ag[e]&&ig.push(e)}const sg=[];for(const e in ag){"cubemap"===ag[e]&&sg.push(e)}const rg={},og={};let lg=new Set;class cg extends Jf{constructor(){super(),this._dirtyShader=!0,this._assetReferences={},this._activeParams=new Set,this._activeLightingParams=new Set,this.shaderOptBuilder=new ng,this.reset()}reset(){Object.keys(rg).forEach((e=>{this[`_${e}`]=rg[e].value()})),this._chunks={},this._uniformCache={}}set chunks(e){this._dirtyShader=!0,this._chunks=e}get chunks(){return this._dirtyShader=!0,this._chunks}copy(e){super.copy(e),Object.keys(rg).forEach((t=>{this[t]=e[t]}));for(const t in e._chunks)e._chunks.hasOwnProperty(t)&&(this._chunks[t]=e._chunks[t]);return this}_setParameter(e,t){lg.add(e),this.setParameter(e,t)}_setParameters(e){e.forEach((e=>{this._setParameter(e.name,e.value)}))}_processParameters(e){const t=this[e];t.forEach((e=>{lg.has(e)||delete this.parameters[e]})),this[e]=lg,lg=t,lg.clear()}_updateMap(e){const t=e+"Map",n=this[t];if(n){this._setParameter("texture_"+t,n);const e=t+"Transform",a=this.getUniform(e);a&&this._setParameters(a)}}_allocUniform(e,t){let n=this._uniformCache[e];return n||(n=t(),this._uniformCache[e]=n),n}getUniform(e,t,n){return og[e](this,t,n)}updateUniforms(e,t){const n=n=>this.getUniform(n,e,t);this._setParameter("material_ambient",n("ambient")),this.diffuseMap&&!this.diffuseTint||this._setParameter("material_diffuse",n("diffuse")),this.useMetalness?(!this.metalnessMap||this.metalness<1)&&this._setParameter("material_metalness",this.metalness):this.specularMap&&!this.specularTint||this._setParameter("material_specular",n("specular")),this.enableGGXSpecular&&this._setParameter("material_anisotropy",this.anisotropy),this.clearCoat>0&&(this._setParameter("material_clearCoat",this.clearCoat),this._setParameter("material_clearCoatGlossiness",this.clearCoatGlossiness),this._setParameter("material_clearCoatReflectivity",this.clearCoat),this._setParameter("material_clearCoatBumpiness",this.clearCoatBumpiness)),this._setParameter("material_shininess",n("shininess")),this.emissiveMap&&!this.emissiveTint||this._setParameter("material_emissive",n("emissive")),1!==this.emissiveIntensity&&this._setParameter("material_emissiveIntensity",this.emissiveIntensity),this.refraction>0&&(this._setParameter("material_refraction",this.refraction),this._setParameter("material_refractionIndex",this.refractionIndex)),this._setParameter("material_opacity",this.opacity),!1===this.opacityFadesSpecular&&this._setParameter("material_alphaFade",this.alphaFade),this.occludeSpecular&&this._setParameter("material_occludeSpecularIntensity",this.occludeSpecularIntensity),1===this.cubeMapProjection&&this._setParameter(n("cubeMapProjectionBox"));for(const e in xf)this._updateMap(e);this.ambientSH&&this._setParameter("ambientSH[0]",this.ambientSH),this.normalMap&&this._setParameter("material_bumpiness",this.bumpiness),this.normalMap&&this.normalDetailMap&&this._setParameter("material_normalDetailMapBumpiness",this.normalDetailMapBumpiness),this.heightMap&&this._setParameter("material_heightMapFactor",n("heightMapFactor")),this.cubeMap&&this._setParameter("texture_cubeMap",this.cubeMap),this.sphereMap&&this._setParameter("texture_sphereMap",this.sphereMap),this._setParameter("material_reflectivity",this.reflectivity),this._processParameters("_activeParams"),this._dirtyShader&&(this.shader=null,this.clearVariants())}updateEnvUniforms(e,t){const n=this.envAtlas||(this.useSkybox?t.envAtlas:null);n&&(this._setParameter("texture_envAtlas",n),this.useSkybox&&!t.skyboxRotation.equals(Gu.IDENTITY)&&t._skyboxRotationMat3&&this._setParameter("cubeMapRotationMatrix",t._skyboxRotationMat3.data)),this._processParameters("_activeLightingParams")}updateShader(e,t,n,a,i,s){this.updateEnvUniforms(e,t);const r=i>1&&i<=18;let o=r?Tf.optionsContextMin:Tf.optionsContext;r?this.shaderOptBuilder.updateMinRef(o,e,t,this,n,a,i,s):this.shaderOptBuilder.updateRef(o,e,t,this,n,a,i,s),this.onUpdateShader&&(o=this.onUpdateShader(o));const l=e.getProgramLibrary();this.shader=l.getProgram("standard",o),n||(this.clearVariants(),this.variants[0]=this.shader),this._dirtyShader=!1}destroy(){for(const e in this._assetReferences)this._assetReferences[e]._unbind();this._assetReferences=null,super.destroy()}}cg.TEXTURE_PARAMETERS=ig,cg.CUBEMAP_PARAMETERS=sg;const hg=(e,t)=>{og[e]=t},dg=(e,t,n,a)=>{Object.defineProperty(cg.prototype,e,{get:a||function(){return this[`_${e}`]},set:n}),rg[e]={value:t}},pg=e=>{const t=`_${e.name}`,n=e.dirtyShaderFunc||(()=>!0);dg(e.name,(()=>e.defaultValue),(function(e){const a=this[t];a!==e&&(this._dirtyShader=this._dirtyShader||n(a,e),this[t]=e)}),e.getterFunc)},ug=e=>{const t=`_${e.name}`,n=e.dirtyShaderFunc||(()=>!0);dg(e.name,(()=>e.defaultValue.clone()),(function(e){const a=this[t];a.equals(e)||(this._dirtyShader=this._dirtyShader||n(a,e),this[t]=a.copy(e))}),e.getterFunc)},mg=e=>e.defaultValue&&e.defaultValue.clone?ug(e):pg(e);function fg(e,t,n,a,i,s){xf[e]=n,mg({name:`${e}Map`,defaultValue:null,dirtyShaderFunc:(e,t)=>!!e!=!!t||e&&(e.type!==t.type||e.fixCubemapSeams!==t.fixCubemapSeams||e.format!==t.format)}),mg({name:`${e}MapTiling`,defaultValue:new Du(1,1)}),mg({name:`${e}MapOffset`,defaultValue:new Du(0,0)}),mg({name:`${e}MapRotation`,defaultValue:0}),mg({name:`${e}MapUv`,defaultValue:t}),n>0&&mg({name:`${e}MapChannel`,defaultValue:a||(n>1?"rgb":"g")}),i&&(mg({name:`${e}VertexColor`,defaultValue:!1}),n>0&&mg({name:`${e}VertexColorChannel`,defaultValue:a||(n>1?"rgb":"g")})),s&&mg({name:`${e}Mode`,defaultValue:"mul"});const r=`${e}MapTiling`,o=`${e}MapOffset`,l=`${e}MapRotation`,c=`${e}MapTransform`;hg(c,((e,t,n)=>{const a=e[r],i=e[o],s=e[l];if(1===a.x&&1===a.y&&0===i.x&&0===i.y&&0===s)return null;const h=e._allocUniform(c,(()=>[{name:`texture_${c}0`,value:new Float32Array(3)},{name:`texture_${c}1`,value:new Float32Array(3)}])),d=Math.cos(s*Eu.DEG_TO_RAD),p=Math.sin(s*Eu.DEG_TO_RAD),u=h[0].value;u[0]=d*a.x,u[1]=-p*a.y,u[2]=i.x;const m=h[1].value;return m[0]=p*a.x,m[1]=d*a.y,m[2]=1-a.y-i.y,h}))}function gg(e,t){mg({name:e,defaultValue:t,getterFunc:function(){return this._dirtyShader=!0,this[`_${e}`]}}),hg(e,((t,n,a)=>{const i=t._allocUniform(e,(()=>new Float32Array(3))),s=t[e];return t.useGammaTonemap&&a.gammaCorrection?(i[0]=Math.pow(s.r,2.2),i[1]=Math.pow(s.g,2.2),i[2]=Math.pow(s.b,2.2)):(i[0]=s.r,i[1]=s.g,i[2]=s.b),i}))}function yg(e,t,n){mg({name:e,defaultValue:t,dirtyShaderFunc:(e,t)=>(0===e||1===e)!=(0===t||1===t)}),hg(e,n)}function bg(e,t){mg({name:e,defaultValue:null,dirtyShaderFunc:(e,t)=>!!e==!!t}),hg(e,t)}function vg(e,t){mg({name:e,defaultValue:t})}!function(){gg("ambient",new Mu(.7,.7,.7)),gg("diffuse",new Mu(1,1,1)),gg("specular",new Mu(0,0,0)),gg("emissive",new Mu(0,0,0)),yg("emissiveIntensity",1),yg("shininess",25,((e,t,n)=>0===e.shadingModel?Math.pow(2,.01*e.shininess*11):.01*e.shininess)),yg("heightMapFactor",1,((e,t,n)=>.025*e.heightMapFactor)),yg("opacity",1),yg("alphaFade",1),yg("alphaTest",0),yg("bumpiness",1),yg("normalDetailMapBumpiness",1),yg("reflectivity",1),yg("occludeSpecularIntensity",1),yg("refraction",0),yg("refractionIndex",1/1.5),yg("metalness",1),yg("anisotropy",0),yg("clearCoat",0),yg("clearCoatGlossiness",1),yg("clearCoatBumpiness",1),yg("aoUvSet",0,null),bg("ambientSH"),bg("cubeMapProjectionBox",((e,t,n)=>{const a=e._allocUniform("cubeMapProjectionBox",(()=>[{name:"envBoxMin",value:new Float32Array(3)},{name:"envBoxMax",value:new Float32Array(3)}])),i=e.cubeMapProjectionBox.getMin(),s=a[0].value;s[0]=i.x,s[1]=i.y,s[2]=i.z;const r=e.cubeMapProjectionBox.getMax(),o=a[1].value;return o[0]=r.x,o[1]=r.y,o[2]=r.z,a})),vg("ambientTint",!1),vg("diffuseTint",!1),vg("specularTint",!1),vg("emissiveTint",!1),vg("fastTbn",!1),vg("specularAntialias",!1),vg("useMetalness",!1),vg("enableGGXSpecular",!1),vg("occludeDirect",!1),vg("normalizeNormalMap",!0),vg("conserveEnergy",!0),vg("opacityFadesSpecular",!0),vg("occludeSpecular",1),vg("shadingModel",1),vg("fresnelModel",2),vg("cubeMapProjection",0),vg("customFragmentShader",null),vg("forceFragmentPrecision",null),vg("useFog",!0),vg("useLighting",!0),vg("useGammaTonemap",!0),vg("useSkybox",!0),vg("forceUv1",!1),vg("pixelSnap",!1),vg("twoSidedLighting",!1),vg("nineSlicedMode",void 0),fg("diffuse",0,3,"",!0),fg("specular",0,3,"",!0),fg("emissive",0,3,"",!0),fg("normal",0,-1,"",!1),fg("metalness",0,1,"",!0),fg("gloss",0,1,"",!0),fg("opacity",0,1,"a",!0),fg("height",0,1,"",!1),fg("ao",0,1,"",!0),fg("light",1,3,"",!0),fg("msdf",0,3,"",!1),fg("diffuseDetail",0,3,"",!1,!0),fg("normalDetail",0,-1,"",!1),fg("clearCoat",0,1,"",!0),fg("clearCoatGloss",0,1,"",!0),fg("clearCoatNormal",0,-1,"",!1),bg("cubeMap"),bg("sphereMap"),bg("envAtlas");const e=[null,null,null,null,null,null];dg("prefilteredCubemaps",(()=>e.slice()),(function(e){const t=this._prefilteredCubemaps;e=e||[];let n=!1,a=!0;for(let i=0;i<6;++i){const s=e[i]||null;t[i]!==s&&(t[i]=s,n=!0),a=a&&!!t[i]}n&&(a?this.envAtlas=Kf.generatePrefilteredAtlas(t,{target:this.envAtlas}):this.envAtlas&&(this.envAtlas.destroy(),this.envAtlas=null),this._dirtyShader=!0)}),(function(){return this._prefilteredCubemaps}))}();class _g{constructor(e){this._device=e,this._cache={},this._generators={},this._isClearingCache=!1,this._precached=!1,this._programsCollection=[],this._defaultStdMatOption={},this._defaultStdMatOptionMin={};const t=new cg;t.shaderOptBuilder.updateRef(this._defaultStdMatOption,e,{},t,null,[],0,null,null),t.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin,e,{},t,null,[],3,null,null)}register(e,t){this.isRegistered(e)||(this._generators[e]=t)}unregister(e){this.isRegistered(e)&&delete this._generators[e]}isRegistered(e){return void 0!==this._generators[e]}getProgram(e,t){const n=this._generators[e];if(void 0===n)return null;const a=this._device,i=n.generateKey(t);let s=this._cache[i];if(!s){let r;t.lights&&(r=t.lights,t.lights=r.map((function(e){const t=e.clone?e.clone():e;return t.key=e.key,t}))),this.storeNewProgram(e,t),t.lights&&(t.lights=r),this._precached&&console.warn(`ProgramLibrary#getProgram: Cache miss for shader ${e} key ${i} after shaders precaching`);const o=n.createShaderDefinition(a,t);s=this._cache[i]=new fm(a,o)}return s}storeNewProgram(e,t){let n={};if("standard"===e){const e=this._getDefaultStdMatOptions(t.pass);for(const a in t)(t.hasOwnProperty(a)&&e[a]!==t[a]||"pass"===a)&&(n[a]=t[a])}else n=t;this._programsCollection.push(JSON.stringify({name:e,options:n}))}dumpPrograms(){let e="let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n";e+="let shaders = [",this._programsCollection[0]&&(e+="\n\t"+this._programsCollection[0]);for(let t=1;t<this._programsCollection.length;++t)e+=",\n\t"+this._programsCollection[t];e+="\n];\n",e+="device.programLib.precompile(shaders);\n",e+='if (pc.version != "1.53.4" || pc.revision != "7d36fcd91")\n',e+='\tconsole.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");';const t=document.createElement("a");t.setAttribute("href","data:text/plain;charset=utf-8,"+encodeURIComponent(e)),t.setAttribute("download","precompile-shaders.js"),t.style.display="none",document.body.appendChild(t),t.click(),document.body.removeChild(t)}clearCache(){const e=this._cache;this._isClearingCache=!0;for(const t in e)e.hasOwnProperty(t)&&e[t].destroy();this._cache={},this._isClearingCache=!1}removeFromCache(e){if(this._isClearingCache)return;const t=this._cache;for(const n in t)if(t.hasOwnProperty(n)&&t[n]===e){delete t[n];break}}_getDefaultStdMatOptions(e){return e>1&&e<=18?this._defaultStdMatOptionMin:this._defaultStdMatOption}precompile(e){if(e){const t=new Array(e.length);for(let n=0;n<e.length;n++){if("standard"===e[n].name){const t=e[n].options,a=this._getDefaultStdMatOptions(t.pass);for(const e in a)a.hasOwnProperty(e)&&void 0===t[e]&&(t[e]=a[e])}t[n]=this.getProgram(e[n].name,e[n].options)}}this._precached=!0}}class wg extends Qp{constructor(e){super(),this.canvas=void 0,this.scope=void 0,this.maxAnisotropy=void 0,this.maxCubeMapSize=void 0,this.maxTextureSize=void 0,this.maxVolumeSize=void 0,this.precision=void 0,this.supportsInstancing=void 0,this.textureFloatRenderable=void 0,this.textureHalfFloatRenderable=void 0,this.canvas=e,this._width=0,this._height=0,this._maxPixelRatio=1,this.shaders=[],this.buffers=[],this.textures=[],this.targets=[],this._vram={tex:0,vb:0,ib:0},this._shaderStats={vsCompiled:0,fsCompiled:0,linked:0,materialShaders:0,compileTime:0},this.initializeContextCaches(),this._drawCallsPerFrame=0,this._shaderSwitchesPerFrame=0,this._primsPerFrame=[];for(let e=0;e<=6;e++)this._primsPerFrame[e]=0;this._renderTargetCreationTime=0,this.scope=new km("Device"),this.programLib=new _g(this);for(const e in Ef)this.programLib.register(e,Ef[e])}destroy(){this.fire("destroy")}postDestroy(){this.scope=null,this.canvas=null}toJSON(e){}initializeContextCaches(){this.indexBuffer=null,this.vertexBuffers=[],this.shader=null,this.renderTarget=null}getProgramLibrary(){return this.programLib}setProgramLibrary(e){this.programLib=e}setRenderTarget(e){this.renderTarget=e}getRenderTarget(){return this.renderTarget}_isBrowserInterface(e){return"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap}resizeCanvas(e,t){this._width=e,this._height=t;const n=Math.min(this._maxPixelRatio,uu.browser?window.devicePixelRatio:1);e=Math.floor(e*n),t=Math.floor(t*n),this.canvas.width===e&&this.canvas.height===t||(this.canvas.width=e,this.canvas.height=t,this.fire("resizecanvas",e,t))}setResolution(e,t){this._width=e,this._height=t,this.canvas.width=e,this.canvas.height=t,this.fire("resizecanvas",e,t)}updateClientRect(){this.clientRect=this.canvas.getBoundingClientRect()}get width(){return this.canvas.width}get height(){return this.canvas.height}set fullscreen(e){}get fullscreen(){return!1}set maxPixelRatio(e){this._maxPixelRatio=e,this.resizeCanvas(this._width,this._height)}get maxPixelRatio(){return this._maxPixelRatio}}const xg={depth:!0,face:0};class Cg{constructor(e){var t,n;const a=arguments[1],i=arguments[2];if(e instanceof wg?(this._colorBuffer=a,e=i):this._colorBuffer=e.colorBuffer,this._colorBuffer&&(this._colorBuffer._isRenderTarget=!0),e=void 0!==e?e:xg,this._depthBuffer=e.depthBuffer,this._face=void 0!==e.face?e.face:0,this._depthBuffer){const e=this._depthBuffer._format;16===e?(this._depth=!0,this._stencil=!1):17===e?(this._depth=!0,this._stencil=!0):(this._depth=!1,this._stencil=!1)}else this._depth=void 0===e.depth||e.depth,this._stencil=void 0!==e.stencil&&e.stencil;var s,r;(this._device=(null==(t=this._colorBuffer)?void 0:t.device)||(null==(n=this._depthBuffer)?void 0:n.device),this._samples=void 0!==e.samples?Math.min(e.samples,this._device.maxSamples):1,this.autoResolve=void 0===e.autoResolve||e.autoResolve,this.name=e.name,this.name)||(this.name=null==(s=this._colorBuffer)?void 0:s.name);this.name||(this.name=null==(r=this._depthBuffer)?void 0:r.name);this.name||(this.name="Untitled"),this.flipY=!!e.flipY,this.impl=this._device.createRenderTargetImpl(this)}destroy(){const e=this._device;if(e){const t=e.targets.indexOf(this);-1!==t&&e.targets.splice(t,1),this.destroyFrameBuffers()}}destroyFrameBuffers(){const e=this._device;e&&this.impl.destroy(e)}destroyTextureBuffers(){this._depthBuffer&&(this._depthBuffer.destroy(),this._depthBuffer=null),this._colorBuffer&&(this._colorBuffer.destroy(),this._colorBuffer=null)}init(){this.impl.init(this._device,this)}loseContext(){this.impl.loseContext()}resolve(e=!0,t=!!this._depthBuffer){this._device&&this.impl.resolve(this._device,this,e,t)}copy(e,t,n){if(!this._device){if(!e._device)return!1;this._device=e._device}return this._device.copyRenderTarget(e,this,t,n)}get colorBuffer(){return this._colorBuffer}get depthBuffer(){return this._depthBuffer}get face(){return this._face}get width(){return this._colorBuffer?this._colorBuffer.width:this._depthBuffer.width}get height(){return this._colorBuffer?this._colorBuffer.height:this._depthBuffer.height}}class Tg{constructor(e,t,n,a=0,i){this.device=e,this.format=t,this.numIndices=n,this.usage=a,this.impl=e.createIndexBufferImpl(this);const s=sm[t];this.bytesPerIndex=s,this.numBytes=this.numIndices*s,i?this.setData(i):this.storage=new ArrayBuffer(this.numBytes),e._vram.ib+=this.numBytes,this.device.buffers.push(this)}destroy(){const e=this.device,t=e.buffers.indexOf(this);-1!==t&&e.buffers.splice(t,1),this.device.indexBuffer===this&&(this.device.indexBuffer=null),this.impl.destroy(e),this.device._vram.ib-=this.storage.byteLength}loseContext(){this.impl.loseContext()}getFormat(){return this.format}getNumIndices(){return this.numIndices}lock(){return this.storage}unlock(){this.impl.unlock(this)}setData(e){return e.byteLength===this.numBytes&&(this.storage=e,this.unlock(),!0)}_lockTypedArray(){const e=this.lock();return 2===this.format?new Uint32Array(e):1===this.format?new Uint16Array(e):new Uint8Array(e)}writeData(e,t){const n=this._lockTypedArray();if(e.length>t)if(ArrayBuffer.isView(e))e=e.subarray(0,t),n.set(e);else for(let a=0;a<t;a++)n[a]=e[a];else n.set(e);this.unlock()}readData(e){const t=this._lockTypedArray(),n=this.numIndices;if(ArrayBuffer.isView(e))e.set(t);else{e.length=0;for(let a=0;a<n;a++)e[a]=t[a]}return n}}function Eg(e){this.array[this.index]=e}function Sg(e,t){this.array[this.index]=e,this.array[this.index+1]=t}function Ag(e,t,n){this.array[this.index]=e,this.array[this.index+1]=t,this.array[this.index+2]=n}function Mg(e,t,n,a){this.array[this.index]=e,this.array[this.index+1]=t,this.array[this.index+2]=n,this.array[this.index+3]=a}function Lg(e,t,n){this.array[e]=t[n]}function Rg(e,t,n){this.array[e]=t[n],this.array[e+1]=t[n+1]}function Ig(e,t,n){this.array[e]=t[n],this.array[e+1]=t[n+1],this.array[e+2]=t[n+2]}function Pg(e,t,n){this.array[e]=t[n],this.array[e+1]=t[n+1],this.array[e+2]=t[n+2],this.array[e+3]=t[n+3]}function kg(e,t,n){t[n]=this.array[e]}function Dg(e,t,n){t[n]=this.array[e],t[n+1]=this.array[e+1]}function Og(e,t,n){t[n]=this.array[e],t[n+1]=this.array[e+1],t[n+2]=this.array[e+2]}function Fg(e,t,n){t[n]=this.array[e],t[n+1]=this.array[e+1],t[n+2]=this.array[e+2],t[n+3]=this.array[e+3]}class Ng{constructor(e,t,n){switch(this.index=0,this.numComponents=t.numComponents,n.interleaved?this.array=new nm[t.dataType](e,t.offset):this.array=new nm[t.dataType](e,t.offset,n.vertexCount*t.numComponents),this.stride=t.stride/this.array.constructor.BYTES_PER_ELEMENT,t.numComponents){case 1:this.set=Eg,this.getToArray=kg,this.setFromArray=Lg;break;case 2:this.set=Sg,this.getToArray=Dg,this.setFromArray=Rg;break;case 3:this.set=Ag,this.getToArray=Og,this.setFromArray=Ig;break;case 4:this.set=Mg,this.getToArray=Fg,this.setFromArray=Pg}}get(e){return this.array[this.index+e]}set(e,t,n,a){}getToArray(e,t,n){}setFromArray(e,t,n){}}class Vg{constructor(e){this.vertexBuffer=e,this.vertexFormatSize=e.getFormat().size,this.buffer=this.vertexBuffer.lock(),this.accessors=[],this.element={};const t=this.vertexBuffer.getFormat();for(let e=0;e<t.elements.length;e++){const n=t.elements[e];this.accessors[e]=new Ng(this.buffer,n,t),this.element[n.name]=this.accessors[e]}}next(e=1){let t=0;const n=this.accessors,a=this.accessors.length;for(;t<a;){const a=n[t++];a.index+=e*a.stride}}end(){this.vertexBuffer.unlock()}writeData(e,t,n){const a=this.element[e];if(a){n>this.vertexBuffer.numVertices&&(n=this.vertexBuffer.numVertices);const e=a.numComponents;if(this.vertexBuffer.getFormat().interleaved){let i=0;for(let s=0;s<n;s++)a.setFromArray(i,t,s*e),i+=a.stride}else if(t.length>n*e){const i=n*e;if(ArrayBuffer.isView(t))t=t.subarray(0,i),a.array.set(t);else for(let e=0;e<i;e++)a.array[e]=t[e]}else a.array.set(t)}}readData(e,t){const n=this.element[e];let a=0;if(n){let e;a=this.vertexBuffer.numVertices;const i=n.numComponents;if(this.vertexBuffer.getFormat().interleaved){Array.isArray(t)&&(t.length=0),n.index=0;let s=0;for(e=0;e<a;e++)n.getToArray(s,t,e*i),s+=n.stride}else if(ArrayBuffer.isView(t))t.set(n.array);else{t.length=0;const s=a*i;for(e=0;e<s;e++)t[e]=n.array[e]}}return a}}class Bg{constructor(e,t=3){this.device=e.device;const n=this.device.gl;this._inputBuffer=e,3===t&&e.usage!==t&&(n.bindBuffer(n.ARRAY_BUFFER,e.impl.bufferId),n.bufferData(n.ARRAY_BUFFER,e.storage,n.DYNAMIC_COPY)),this._outputBuffer=new lm(e.device,e.format,e.numVertices,t,e.storage)}static createShader(e,t,n){return Mm(e,t,null,n,!0)}destroy(){this._outputBuffer.destroy()}process(e,t=!0){const n=this.device,a=n.getRenderTarget();if(n.setRenderTarget(null),n.updateBegin(),n.setVertexBuffer(this._inputBuffer,0),n.setRaster(!1),n.setTransformFeedbackBuffer(this._outputBuffer),n.setShader(e),n.draw({type:0,base:0,count:this._inputBuffer.numVertices,indexed:!1}),n.setTransformFeedbackBuffer(null),n.setRaster(!0),n.updateEnd(),n.setRenderTarget(a),t){let e=this._inputBuffer.impl.bufferId;this._inputBuffer.impl.bufferId=this._outputBuffer.impl.bufferId,this._outputBuffer.impl.bufferId=e,e=this._inputBuffer.impl.vao,this._inputBuffer.impl.vao=this._outputBuffer.impl.vao,this._outputBuffer.impl.vao=e}}get inputBuffer(){return this._inputBuffer}get outputBuffer(){return this._outputBuffer}}class Ug{constructor(e,t){this.device=e,this.useAlpha=t,this.useMipmaps=e.webgl2,this.texture=null,this.renderTarget=null,this.textureId=null}destroy(){this.textureId=null,this.renderTarget&&(this.renderTarget.destroy(),this.renderTarget=null),this.texture&&(this.texture.destroy(),this.texture=null)}create(){if(!this.texture){const e=new Gm(this.device,{name:"texture_grabPass",format:this.useAlpha?7:6,minFilter:this.useMipmaps?5:1,magFilter:1,addressU:1,addressV:1,mipmaps:this.useMipmaps});this.texture=e,this.renderTarget=new Cg({colorBuffer:e,depth:!1}),this.textureId=this.device.scope.resolve(e.name),this.textureId.setValue(e)}}update(){const e=this.device,t=e.gl;if(!e.grabPassAvailable)return!1;const n=e.renderTarget,a=n&&n.impl._glResolveFrameBuffer,i=this.texture,s=e.width,r=e.height;if(e.webgl2&&!e._tempMacChromeBlitFramebufferWorkaround&&s===i._width&&r===i._height){a&&n.resolve(!0);const i=n?n.impl._glFrameBuffer:null,o=n?n.impl._glResolveFrameBuffer||n.impl._glFrameBuffer:null;e.initRenderTarget(this.renderTarget);const l=this.renderTarget.impl._glFrameBuffer;t.bindFramebuffer(t.READ_FRAMEBUFFER,o),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,l),t.blitFramebuffer(0,0,s,r,0,0,s,r,t.COLOR_BUFFER_BIT,t.NEAREST),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,i)}else{a&&(n.resolve(!0),t.bindFramebuffer(t.FRAMEBUFFER,n.impl._glResolveFrameBuffer));const e=i.impl._glFormat;t.copyTexImage2D(t.TEXTURE_2D,0,e,0,0,s,r,0),i._width=s,i._height=r,a&&t.bindFramebuffer(t.FRAMEBUFFER,n.impl._glFrameBuffer)}return!0}generateMipmaps(){this.useMipmaps&&this.device.gl.generateMipmap(this.texture.impl._glTarget)}prepareTexture(){const e=this.update();return e&&this.generateMipmaps(),e}}class zg{constructor(){this.bufferId=null}destroy(e){this.bufferId&&(e.gl.deleteBuffer(this.bufferId),this.bufferId=null)}loseContext(){this.bufferId=null}unlock(e,t,n,a){const i=e.gl;let s;switch(this.bufferId||(this.bufferId=i.createBuffer()),t){case 0:s=i.STATIC_DRAW;break;case 1:s=i.DYNAMIC_DRAW;break;case 2:s=i.STREAM_DRAW;break;case 3:s=e.webgl2?i.DYNAMIC_COPY:i.STATIC_DRAW}i.bindBuffer(n,this.bufferId),i.bufferData(n,a,s)}}class Gg extends zg{constructor(...e){super(...e),this.vao=null}destroy(e){super.destroy(e),e.boundVao=null,e.gl.bindVertexArray(null)}loseContext(){super.loseContext(),this.vao=null}unlock(e){const t=e.device;super.unlock(t,e.usage,t.gl.ARRAY_BUFFER,e.storage)}}class Hg extends zg{constructor(e){super();const t=e.device.gl,n=e.format;0===n?this.glFormat=t.UNSIGNED_BYTE:1===n?this.glFormat=t.UNSIGNED_SHORT:2===n&&(this.glFormat=t.UNSIGNED_INT)}unlock(e){const t=e.device;super.unlock(t,e.usage,t.gl.ELEMENT_ARRAY_BUFFER,e.storage)}}class Wg{constructor(e,t,n,a){if(this.locationId=a,this.scopeId=e.scope.resolve(t),this.version=new Lm,"[0]"===t.substr(t.length-3))switch(n){case 2:n=17;break;case 3:n=21;break;case 4:n=22;break;case 5:n=23}this.dataType=n,this.value=[null,null,null,null],this.array=[]}}class jg{constructor(e){this.uniforms=[],this.samplers=[],this.attributes=[],this.glProgram=null,this.glVertexShader=null,this.glFragmentShader=null,this.compileAndLink(e.device,e),e.device.shaders.push(e)}destroy(e){const t=e.device,n=t.shaders.indexOf(e);-1!==n&&t.shaders.splice(n,1),this.glProgram&&(t.gl.deleteProgram(this.glProgram),this.glProgram=null,t.removeShaderFromCache(e))}restoreContext(e,t){this.compileAndLink(e,t)}compileAndLink(e,t){const n=t.definition,a=this._compileShaderSource(e,n.vshader,!0),i=this._compileShaderSource(e,n.fshader,!1),s=e.gl,r=s.createProgram();s.attachShader(r,a),s.attachShader(r,i);const o=n.attributes;if(e.webgl2&&n.useTransformFeedback){const e=[];for(const t in o)o.hasOwnProperty(t)&&e.push("out_"+t);s.transformFeedbackVaryings(r,e,s.INTERLEAVED_ATTRIBS)}const l={};for(const e in o)if(o.hasOwnProperty(e)){const t=o[e],n=rm[t];l[n]=e,s.bindAttribLocation(r,n,e)}s.linkProgram(r),this.glVertexShader=a,this.glFragmentShader=i,this.glProgram=r}_compileShaderSource(e,t,n){const a=e.gl,i=n?e.vertexShaderCache:e.fragmentShaderCache;let s=i[t];return s||(s=a.createShader(n?a.VERTEX_SHADER:a.FRAGMENT_SHADER),a.shaderSource(s,t),a.compileShader(s),i[t]=s),s}postLink(e,t){const n=e.gl,a=this.glProgram,i=t.definition;if(!this._isCompiled(e,t,this.glVertexShader,i.vshader,"vertex"))return!1;if(!this._isCompiled(e,t,this.glFragmentShader,i.fshader,"fragment"))return!1;if(!n.getProgramParameter(a,n.LINK_STATUS)){const e="Failed to link shader program. Error: "+n.getProgramInfoLog(a);return console.error(e),!1}let s,r,o,l;s=0;const c=n.getProgramParameter(a,n.ACTIVE_ATTRIBUTES);for(;s<c;)r=n.getActiveAttrib(a,s++),o=n.getAttribLocation(a,r.name),void 0===i.attributes[r.name]&&console.error(`Vertex shader attribute "${r.name}" is not mapped to a semantic in shader definition.`),l=new Wg(e,i.attributes[r.name],e.pcUniformType[r.type],o),this.attributes.push(l);s=0;const h=n.getProgramParameter(a,n.ACTIVE_UNIFORMS);for(;s<h;)r=n.getActiveUniform(a,s++),o=n.getUniformLocation(a,r.name),l=new Wg(e,r.name,e.pcUniformType[r.type],o),r.type===n.SAMPLER_2D||r.type===n.SAMPLER_CUBE||e.webgl2&&(r.type===n.SAMPLER_2D_SHADOW||r.type===n.SAMPLER_CUBE_SHADOW||r.type===n.SAMPLER_3D)?this.samplers.push(l):this.uniforms.push(l);return t.ready=!0,!0}_isCompiled(e,t,n,a,i){const s=e.gl;if(!s.getShaderParameter(n,s.COMPILE_STATUS)){const e=s.getShaderInfoLog(n),[t,r]=this._processError(a,e),o=`Failed to compile ${i} shader:\n\n${e}\n${t}`;return console.error(o),!1}return!0}_processError(e,t){if(!e)return"";const n=e.split("\n"),a={};let i="",s=0,r=n.length;if(t&&t.startsWith("ERROR:")){const e=t.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);e&&(a.message=e[3],a.line=parseInt(e[2],10),s=Math.max(0,a.line-6),r=Math.min(n.length,a.line+5))}for(let e=s;e<r;e++)i+=e+1+":\t"+n[e]+"\n";return a.source=e,[i,a]}}function Xg(e,t){const n=e.width,a=e.height;if(n>t||a>t){const i=t/Math.max(n,a),s=Math.floor(n*i),r=Math.floor(a*i),o=document.createElement("canvas");o.width=s,o.height=r;return o.getContext("2d").drawImage(e,0,0,n,a,0,0,s,r),o}return e}class Yg{constructor(){this._glTexture=null,this._glTarget=void 0,this._glFormat=void 0,this._glInternalFormat=void 0,this._glPixelType=void 0}destroy(e){if(this._glTexture){for(let t=0;t<e.textureUnits.length;t++){const n=e.textureUnits[t];for(let e=0;e<n.length;e++)n[e]===this._glTexture&&(n[e]=null)}e.gl.deleteTexture(this._glTexture),this._glTexture=null}}loseContext(){this._glTexture=null}initialize(e,t){const n=e.gl;let a;switch(this._glTexture=n.createTexture(),this._glTarget=t._cubemap?n.TEXTURE_CUBE_MAP:t._volume?n.TEXTURE_3D:n.TEXTURE_2D,t._format){case 0:this._glFormat=n.ALPHA,this._glInternalFormat=n.ALPHA,this._glPixelType=n.UNSIGNED_BYTE;break;case 1:this._glFormat=n.LUMINANCE,this._glInternalFormat=n.LUMINANCE,this._glPixelType=n.UNSIGNED_BYTE;break;case 2:this._glFormat=n.LUMINANCE_ALPHA,this._glInternalFormat=n.LUMINANCE_ALPHA,this._glPixelType=n.UNSIGNED_BYTE;break;case 3:this._glFormat=n.RGB,this._glInternalFormat=n.RGB,this._glPixelType=n.UNSIGNED_SHORT_5_6_5;break;case 4:this._glFormat=n.RGBA,this._glInternalFormat=n.RGBA,this._glPixelType=n.UNSIGNED_SHORT_5_5_5_1;break;case 5:this._glFormat=n.RGBA,this._glInternalFormat=n.RGBA,this._glPixelType=n.UNSIGNED_SHORT_4_4_4_4;break;case 6:this._glFormat=n.RGB,this._glInternalFormat=e.webgl2?n.RGB8:n.RGB,this._glPixelType=n.UNSIGNED_BYTE;break;case 7:this._glFormat=n.RGBA,this._glInternalFormat=e.webgl2?n.RGBA8:n.RGBA,this._glPixelType=n.UNSIGNED_BYTE;break;case 8:a=e.extCompressedTextureS3TC,this._glFormat=n.RGB,this._glInternalFormat=a.COMPRESSED_RGB_S3TC_DXT1_EXT;break;case 9:a=e.extCompressedTextureS3TC,this._glFormat=n.RGBA,this._glInternalFormat=a.COMPRESSED_RGBA_S3TC_DXT3_EXT;break;case 10:a=e.extCompressedTextureS3TC,this._glFormat=n.RGBA,this._glInternalFormat=a.COMPRESSED_RGBA_S3TC_DXT5_EXT;break;case 21:a=e.extCompressedTextureETC1,this._glFormat=n.RGB,this._glInternalFormat=a.COMPRESSED_RGB_ETC1_WEBGL;break;case 24:a=e.extCompressedTexturePVRTC,this._glFormat=n.RGB,this._glInternalFormat=a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;break;case 25:a=e.extCompressedTexturePVRTC,this._glFormat=n.RGBA,this._glInternalFormat=a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;break;case 26:a=e.extCompressedTexturePVRTC,this._glFormat=n.RGB,this._glInternalFormat=a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;break;case 27:a=e.extCompressedTexturePVRTC,this._glFormat=n.RGBA,this._glInternalFormat=a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;break;case 22:a=e.extCompressedTextureETC,this._glFormat=n.RGB,this._glInternalFormat=a.COMPRESSED_RGB8_ETC2;break;case 23:a=e.extCompressedTextureETC,this._glFormat=n.RGBA,this._glInternalFormat=a.COMPRESSED_RGBA8_ETC2_EAC;break;case 28:a=e.extCompressedTextureASTC,this._glFormat=n.RGBA,this._glInternalFormat=a.COMPRESSED_RGBA_ASTC_4x4_KHR;break;case 29:a=e.extCompressedTextureATC,this._glFormat=n.RGB,this._glInternalFormat=a.COMPRESSED_RGB_ATC_WEBGL;break;case 30:a=e.extCompressedTextureATC,this._glFormat=n.RGBA,this._glInternalFormat=a.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;break;case 11:a=e.extTextureHalfFloat,this._glFormat=n.RGB,e.webgl2?(this._glInternalFormat=n.RGB16F,this._glPixelType=n.HALF_FLOAT):(this._glInternalFormat=n.RGB,this._glPixelType=a.HALF_FLOAT_OES);break;case 12:a=e.extTextureHalfFloat,this._glFormat=n.RGBA,e.webgl2?(this._glInternalFormat=n.RGBA16F,this._glPixelType=n.HALF_FLOAT):(this._glInternalFormat=n.RGBA,this._glPixelType=a.HALF_FLOAT_OES);break;case 13:this._glFormat=n.RGB,e.webgl2?this._glInternalFormat=n.RGB32F:this._glInternalFormat=n.RGB,this._glPixelType=n.FLOAT;break;case 14:this._glFormat=n.RGBA,e.webgl2?this._glInternalFormat=n.RGBA32F:this._glInternalFormat=n.RGBA,this._glPixelType=n.FLOAT;break;case 15:this._glFormat=n.RED,this._glInternalFormat=n.R32F,this._glPixelType=n.FLOAT;break;case 16:e.webgl2?(this._glFormat=n.DEPTH_COMPONENT,this._glInternalFormat=n.DEPTH_COMPONENT32F,this._glPixelType=n.FLOAT):(this._glFormat=n.DEPTH_COMPONENT,this._glInternalFormat=n.DEPTH_COMPONENT,this._glPixelType=n.UNSIGNED_SHORT);break;case 17:this._glFormat=n.DEPTH_STENCIL,this._glInternalFormat=n.DEPTH24_STENCIL8,this._glPixelType=n.UNSIGNED_INT_24_8;break;case 18:this._glFormat=n.RGB,this._glInternalFormat=n.R11F_G11F_B10F,this._glPixelType=n.UNSIGNED_INT_10F_11F_11F_REV;break;case 19:this._glFormat=n.RGB,this._glInternalFormat=n.SRGB8,this._glPixelType=n.UNSIGNED_BYTE;break;case 20:this._glFormat=n.RGBA,this._glInternalFormat=n.SRGB8_ALPHA8,this._glPixelType=n.UNSIGNED_BYTE}}upload(e,t){const n=e.gl;if(!t._needsUpload&&(t._needsMipmapsUpload&&t._mipmapsUploaded||!t.pot))return;let a,i,s=0;const r=Math.log2(Math.max(t._width,t._height))+1;for(;t._levels[s]||0===s;)if(t._needsUpload||0!==s){if(s&&(!t._needsMipmapsUpload||!t._mipmaps))break;if(a=t._levels[s],1===s&&!t._compressed&&t._levels.length<r&&(n.generateMipmap(this._glTarget),t._mipmapsUploaded=!0),t._cubemap){let r;if(e._isBrowserInterface(a[0]))for(r=0;r<6;r++){if(!t._levelsUpdated[0][r])continue;let i=a[r];i instanceof HTMLImageElement&&(i.width>e.maxCubeMapSize||i.height>e.maxCubeMapSize)&&(i=Xg(i,e.maxCubeMapSize),0===s&&(t._width=i.width,t._height=i.height)),e.setUnpackFlipY(!1),e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+r,s,this._glInternalFormat,this._glFormat,this._glPixelType,i)}else for(i=1/Math.pow(2,s),r=0;r<6;r++){if(!t._levelsUpdated[0][r])continue;const o=a[r];t._compressed?n.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+r,s,this._glInternalFormat,Math.max(t._width*i,1),Math.max(t._height*i,1),0,o):(e.setUnpackFlipY(!1),e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+r,s,this._glInternalFormat,Math.max(t._width*i,1),Math.max(t._height*i,1),0,this._glFormat,this._glPixelType,o))}}else t._volume?(i=1/Math.pow(2,s),t._compressed?n.compressedTexImage3D(n.TEXTURE_3D,s,this._glInternalFormat,Math.max(t._width*i,1),Math.max(t._height*i,1),Math.max(t._depth*i,1),0,a):(e.setUnpackFlipY(!1),e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),n.texImage3D(n.TEXTURE_3D,s,this._glInternalFormat,Math.max(t._width*i,1),Math.max(t._height*i,1),Math.max(t._depth*i,1),0,this._glFormat,this._glPixelType,a))):(e._isBrowserInterface(a)?(a instanceof HTMLImageElement&&(a.width>e.maxTextureSize||a.height>e.maxTextureSize)&&(a=Xg(a,e.maxTextureSize),0===s&&(t._width=a.width,t._height=a.height)),e.setUnpackFlipY(t._flipY),e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),n.texImage2D(n.TEXTURE_2D,s,this._glInternalFormat,this._glFormat,this._glPixelType,a)):(i=1/Math.pow(2,s),t._compressed?n.compressedTexImage2D(n.TEXTURE_2D,s,this._glInternalFormat,Math.max(Math.floor(t._width*i),1),Math.max(Math.floor(t._height*i),1),0,a):(e.setUnpackFlipY(!1),e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),n.texImage2D(n.TEXTURE_2D,s,this._glInternalFormat,Math.max(t._width*i,1),Math.max(t._height*i,1),0,this._glFormat,this._glPixelType,a))),t._mipmapsUploaded=0!==s);s++}else s++;if(t._needsUpload)if(t._cubemap)for(let e=0;e<6;e++)t._levelsUpdated[0][e]=!1;else t._levelsUpdated[0]=!1;!t._compressed&&t._mipmaps&&t._needsMipmapsUpload&&(t.pot||e.webgl2)&&1===t._levels.length&&(n.generateMipmap(this._glTarget),t._mipmapsUploaded=!0),t._gpuSize&&t.adjustVramSizeTracking(e._vram,-t._gpuSize),t._gpuSize=t.gpuSize,t.adjustVramSizeTracking(e._vram,t._gpuSize)}}class qg{constructor(){this._glFrameBuffer=null,this._glDepthBuffer=null,this._glResolveFrameBuffer=null,this._glMsaaColorBuffer=null,this._glMsaaDepthBuffer=null}destroy(e){const t=e.gl;this._glFrameBuffer&&(t.deleteFramebuffer(this._glFrameBuffer),this._glFrameBuffer=null),this._glDepthBuffer&&(t.deleteRenderbuffer(this._glDepthBuffer),this._glDepthBuffer=null),this._glResolveFrameBuffer&&(t.deleteFramebuffer(this._glResolveFrameBuffer),this._glResolveFrameBuffer=null),this._glMsaaColorBuffer&&(t.deleteRenderbuffer(this._glMsaaColorBuffer),this._glMsaaColorBuffer=null),this._glMsaaDepthBuffer&&(t.deleteRenderbuffer(this._glMsaaDepthBuffer),this._glMsaaDepthBuffer=null)}init(e,t){const n=e.gl;this._glFrameBuffer=n.createFramebuffer(),e.setFramebuffer(this._glFrameBuffer);const a=t._colorBuffer;a&&(a.impl._glTexture||(a._width=Math.min(a.width,e.maxRenderBufferSize),a._height=Math.min(a.height,e.maxRenderBufferSize),e.setTexture(a,0)),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,a._cubemap?n.TEXTURE_CUBE_MAP_POSITIVE_X+t._face:n.TEXTURE_2D,a.impl._glTexture,0));const i=t._depthBuffer;if(i&&e.webgl2)i.impl._glTexture||(i._width=Math.min(i.width,e.maxRenderBufferSize),i._height=Math.min(i.height,e.maxRenderBufferSize),e.setTexture(i,0)),t._stencil?n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,i._cubemap?n.TEXTURE_CUBE_MAP_POSITIVE_X+t._face:n.TEXTURE_2D,t._depthBuffer.impl._glTexture,0):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,i._cubemap?n.TEXTURE_CUBE_MAP_POSITIVE_X+t._face:n.TEXTURE_2D,t._depthBuffer.impl._glTexture,0);else if(t._depth){if(!(t._samples>1&&e.webgl2)){if(this._glDepthBuffer||(this._glDepthBuffer=n.createRenderbuffer()),n.bindRenderbuffer(n.RENDERBUFFER,this._glDepthBuffer),t._stencil)n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_STENCIL,t.width,t.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,this._glDepthBuffer);else{const a=e.webgl2?n.DEPTH_COMPONENT32F:n.DEPTH_COMPONENT16;n.renderbufferStorage(n.RENDERBUFFER,a,t.width,t.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,this._glDepthBuffer)}n.bindRenderbuffer(n.RENDERBUFFER,null)}}e.webgl2&&t._samples>1&&(this._glResolveFrameBuffer=this._glFrameBuffer,this._glFrameBuffer=n.createFramebuffer(),e.setFramebuffer(this._glFrameBuffer),a&&(this._glMsaaColorBuffer||(this._glMsaaColorBuffer=n.createRenderbuffer()),n.bindRenderbuffer(n.RENDERBUFFER,this._glMsaaColorBuffer),n.renderbufferStorageMultisample(n.RENDERBUFFER,t._samples,a.impl._glInternalFormat,t.width,t.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,this._glMsaaColorBuffer)),t._depth&&(this._glMsaaDepthBuffer||(this._glMsaaDepthBuffer=n.createRenderbuffer()),n.bindRenderbuffer(n.RENDERBUFFER,this._glMsaaDepthBuffer),t._stencil?(n.renderbufferStorageMultisample(n.RENDERBUFFER,t._samples,n.DEPTH24_STENCIL8,t.width,t.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,this._glMsaaDepthBuffer)):(n.renderbufferStorageMultisample(n.RENDERBUFFER,t._samples,n.DEPTH_COMPONENT32F,t.width,t.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,this._glMsaaDepthBuffer))))}_checkFbo(e){const t=e.gl;switch(t.checkFramebufferStatus(t.FRAMEBUFFER)){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:console.error("ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");break;case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:console.error("ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");break;case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:console.error("ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");break;case t.FRAMEBUFFER_UNSUPPORTED:console.error("ERROR: FRAMEBUFFER_UNSUPPORTED");case t.FRAMEBUFFER_COMPLETE:}}loseContext(){this._glFrameBuffer=null,this._glDepthBuffer=null,this._glResolveFrameBuffer=null,this._glMsaaColorBuffer=null,this._glMsaaDepthBuffer=null}resolve(e,t,n,a){if(e.webgl2){const i=e.gl;i.bindFramebuffer(i.READ_FRAMEBUFFER,this._glFrameBuffer),i.bindFramebuffer(i.DRAW_FRAMEBUFFER,this._glResolveFrameBuffer),i.blitFramebuffer(0,0,t.width,t.height,0,0,t.width,t.height,(n?i.COLOR_BUFFER_BIT:0)|(a?i.DEPTH_BUFFER_BIT:0),i.NEAREST),i.bindFramebuffer(i.FRAMEBUFFER,this._glFrameBuffer)}}}function Kg(e,t){let n=!0;const a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,2,2,0,e.RGBA,t,null);const i=e.createFramebuffer();return e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0),e.checkFramebufferStatus(e.FRAMEBUFFER)!==e.FRAMEBUFFER_COMPLETE&&(n=!1),e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(a),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(i),n}class Zg extends wg{constructor(e,t={}){super(e),this.gl=void 0,this.webgl2=void 0,this.defaultFramebuffer=null,this.updateClientRect(),this.contextLost=!1,this._contextLostHandler=e=>{e.preventDefault(),this.contextLost=!0,this.loseContext(),this.fire("devicelost")},this._contextRestoredHandler=()=>{this.restoreContext(),this.contextLost=!1,this.fire("devicerestored")},t.stencil=!0,t.powerPreference||(t.powerPreference="high-performance");const n="undefined"!=typeof navigator&&navigator.userAgent;this.forceDisableMultisampling=n&&n.includes("AppleWebKit")&&(n.includes("15.4")||n.includes("15_4")),this.forceDisableMultisampling&&(t.antialias=!1);const a=void 0===t.preferWebGl2||t.preferWebGl2?["webgl2","webgl","experimental-webgl"]:["webgl","experimental-webgl"];let i=null;for(let n=0;n<a.length;n++)if(i=e.getContext(a[n],t),i){this.webgl2="webgl2"===a[n];break}if(!i)throw new Error("WebGL not supported");const s=uu.browser&&!!window.chrome,r=uu.browser&&-1!==navigator.appVersion.indexOf("Mac");let o,l,c,h,d;this.gl=i,this._tempEnableSafariTextureUnitWorkaround=uu.browser&&!!window.safari,this._tempMacChromeBlitFramebufferWorkaround=r&&s&&!t.alpha,this.webgl2||function(e){if(e.getSupportedExtensions){if(-1!=e.getSupportedExtensions().indexOf("OES_vertex_array_object"))return}else if(e.getExtension&&e.getExtension("OES_vertex_array_object"))return;if(e.getSupportedExtensions){var t=e.getSupportedExtensions;e.getSupportedExtensions=function(){var e=t.call(this)||[];return e.push("OES_vertex_array_object"),e}}var n=e.getExtension;e.getExtension=function(t){return"OES_vertex_array_object"==t?(e.__OESVertexArrayObject||(e.__OESVertexArrayObject=new Yp(e)),e.__OESVertexArrayObject):n?n.call(this,t):null}}(i),e.addEventListener("webglcontextlost",this._contextLostHandler,!1),e.addEventListener("webglcontextrestored",this._contextRestoredHandler,!1),this.initializeExtensions(),this.initializeCapabilities(),this.initializeRenderState(),this.initializeContextCaches(),this.defaultClearOptions={color:[0,0,0,1],depth:1,stencil:0,flags:3},this.glAddress=[i.REPEAT,i.CLAMP_TO_EDGE,i.MIRRORED_REPEAT],this.glBlendEquation=[i.FUNC_ADD,i.FUNC_SUBTRACT,i.FUNC_REVERSE_SUBTRACT,this.webgl2?i.MIN:this.extBlendMinmax?this.extBlendMinmax.MIN_EXT:i.FUNC_ADD,this.webgl2?i.MAX:this.extBlendMinmax?this.extBlendMinmax.MAX_EXT:i.FUNC_ADD],this.glBlendFunction=[i.ZERO,i.ONE,i.SRC_COLOR,i.ONE_MINUS_SRC_COLOR,i.DST_COLOR,i.ONE_MINUS_DST_COLOR,i.SRC_ALPHA,i.SRC_ALPHA_SATURATE,i.ONE_MINUS_SRC_ALPHA,i.DST_ALPHA,i.ONE_MINUS_DST_ALPHA,i.CONSTANT_COLOR,i.ONE_MINUS_CONSTANT_COLOR,i.CONSTANT_ALPHA,i.ONE_MINUS_CONSTANT_ALPHA],this.glComparison=[i.NEVER,i.LESS,i.EQUAL,i.LEQUAL,i.GREATER,i.NOTEQUAL,i.GEQUAL,i.ALWAYS],this.glStencilOp=[i.KEEP,i.ZERO,i.REPLACE,i.INCR,i.INCR_WRAP,i.DECR,i.DECR_WRAP,i.INVERT],this.glClearFlag=[0,i.COLOR_BUFFER_BIT,i.DEPTH_BUFFER_BIT,i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT,i.STENCIL_BUFFER_BIT,i.STENCIL_BUFFER_BIT|i.COLOR_BUFFER_BIT,i.STENCIL_BUFFER_BIT|i.DEPTH_BUFFER_BIT,i.STENCIL_BUFFER_BIT|i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT],this.glCull=[0,i.BACK,i.FRONT,i.FRONT_AND_BACK],this.glFilter=[i.NEAREST,i.LINEAR,i.NEAREST_MIPMAP_NEAREST,i.NEAREST_MIPMAP_LINEAR,i.LINEAR_MIPMAP_NEAREST,i.LINEAR_MIPMAP_LINEAR],this.glPrimitive=[i.POINTS,i.LINES,i.LINE_LOOP,i.LINE_STRIP,i.TRIANGLES,i.TRIANGLE_STRIP,i.TRIANGLE_FAN],this.glType=[i.BYTE,i.UNSIGNED_BYTE,i.SHORT,i.UNSIGNED_SHORT,i.INT,i.UNSIGNED_INT,i.FLOAT],this.pcUniformType={},this.pcUniformType[i.BOOL]=0,this.pcUniformType[i.INT]=1,this.pcUniformType[i.FLOAT]=2,this.pcUniformType[i.FLOAT_VEC2]=3,this.pcUniformType[i.FLOAT_VEC3]=4,this.pcUniformType[i.FLOAT_VEC4]=5,this.pcUniformType[i.INT_VEC2]=6,this.pcUniformType[i.INT_VEC3]=7,this.pcUniformType[i.INT_VEC4]=8,this.pcUniformType[i.BOOL_VEC2]=9,this.pcUniformType[i.BOOL_VEC3]=10,this.pcUniformType[i.BOOL_VEC4]=11,this.pcUniformType[i.FLOAT_MAT2]=12,this.pcUniformType[i.FLOAT_MAT3]=13,this.pcUniformType[i.FLOAT_MAT4]=14,this.pcUniformType[i.SAMPLER_2D]=15,this.pcUniformType[i.SAMPLER_CUBE]=16,this.webgl2&&(this.pcUniformType[i.SAMPLER_2D_SHADOW]=18,this.pcUniformType[i.SAMPLER_CUBE_SHADOW]=19,this.pcUniformType[i.SAMPLER_3D]=20),this.targetToSlot={},this.targetToSlot[i.TEXTURE_2D]=0,this.targetToSlot[i.TEXTURE_CUBE_MAP]=1,this.targetToSlot[i.TEXTURE_3D]=2,this.commitFunction=[],this.commitFunction[0]=function(e,t){e.value!==t&&(i.uniform1i(e.locationId,t),e.value=t)},this.commitFunction[1]=this.commitFunction[0],this.commitFunction[2]=function(e,t){e.value!==t&&(i.uniform1f(e.locationId,t),e.value=t)},this.commitFunction[3]=function(e,t){d=e.value,o=t[0],l=t[1],d[0]===o&&d[1]===l||(i.uniform2fv(e.locationId,t),d[0]=o,d[1]=l)},this.commitFunction[4]=function(e,t){d=e.value,o=t[0],l=t[1],c=t[2],d[0]===o&&d[1]===l&&d[2]===c||(i.uniform3fv(e.locationId,t),d[0]=o,d[1]=l,d[2]=c)},this.commitFunction[5]=function(e,t){d=e.value,o=t[0],l=t[1],c=t[2],h=t[3],d[0]===o&&d[1]===l&&d[2]===c&&d[3]===h||(i.uniform4fv(e.locationId,t),d[0]=o,d[1]=l,d[2]=c,d[3]=h)},this.commitFunction[6]=function(e,t){d=e.value,o=t[0],l=t[1],d[0]===o&&d[1]===l||(i.uniform2iv(e.locationId,t),d[0]=o,d[1]=l)},this.commitFunction[9]=this.commitFunction[6],this.commitFunction[7]=function(e,t){d=e.value,o=t[0],l=t[1],c=t[2],d[0]===o&&d[1]===l&&d[2]===c||(i.uniform3iv(e.locationId,t),d[0]=o,d[1]=l,d[2]=c)},this.commitFunction[10]=this.commitFunction[7],this.commitFunction[8]=function(e,t){d=e.value,o=t[0],l=t[1],c=t[2],h=t[3],d[0]===o&&d[1]===l&&d[2]===c&&d[3]===h||(i.uniform4iv(e.locationId,t),d[0]=o,d[1]=l,d[2]=c,d[3]=h)},this.commitFunction[11]=this.commitFunction[8],this.commitFunction[12]=function(e,t){i.uniformMatrix2fv(e.locationId,!1,t)},this.commitFunction[13]=function(e,t){i.uniformMatrix3fv(e.locationId,!1,t)},this.commitFunction[14]=function(e,t){i.uniformMatrix4fv(e.locationId,!1,t)},this.commitFunction[17]=function(e,t){i.uniform1fv(e.locationId,t)},this.commitFunction[21]=function(e,t){i.uniform2fv(e.locationId,t)},this.commitFunction[22]=function(e,t){i.uniform3fv(e.locationId,t)},this.commitFunction[23]=function(e,t){i.uniform4fv(e.locationId,t)},this.supportsBoneTextures=this.extTextureFloat&&this.maxVertexTextures>0;let p=this.vertexUniformsCount;p-=16,p-=8,p-=1,p-=16,this.boneLimit=Math.floor(p/3),this.boneLimit=Math.min(this.boneLimit,128),"Mali-450 MP"===this.unmaskedRenderer&&(this.boneLimit=34),this.constantTexSource=this.scope.resolve("source"),this.textureBias=this.scope.resolve("textureBias"),this.textureBias.setValue(0),this.extTextureFloat?this.webgl2?this.textureFloatRenderable=!!this.extColorBufferFloat:this.textureFloatRenderable=Kg(i,i.FLOAT):this.textureFloatRenderable=!1,this.extColorBufferHalfFloat?this.textureHalfFloatRenderable=!!this.extColorBufferHalfFloat:this.extTextureHalfFloat?this.webgl2?this.textureHalfFloatRenderable=!!this.extColorBufferFloat:this.textureHalfFloatRenderable=Kg(i,this.extTextureHalfFloat.HALF_FLOAT_OES):this.textureHalfFloatRenderable=!1,this.supportsMorphTargetTexturesCore="highp"===this.maxPrecision&&this.maxVertexTextures>=2,this._textureFloatHighPrecision=void 0,this._textureHalfFloatUpdatable=void 0,this.grabPassAvailable=!0,this.grabPass=new Ug(this,t.alpha),this.grabPass.create(),this.areaLightLutFormat=7,this.extTextureHalfFloat&&this.textureHalfFloatUpdatable&&this.extTextureHalfFloatLinear?this.areaLightLutFormat=12:this.extTextureFloat&&this.extTextureFloatLinear&&(this.areaLightLutFormat=14)}destroy(){super.destroy();const e=this.gl;this.grabPass.destroy(),this.webgl2&&this.feedback&&e.deleteTransformFeedback(this.feedback),this.clearShaderCache(),this.clearVertexArrayObjectCache(),this.canvas.removeEventListener("webglcontextlost",this._contextLostHandler,!1),this.canvas.removeEventListener("webglcontextrestored",this._contextRestoredHandler,!1),this._contextLostHandler=null,this._contextRestoredHandler=null,this.gl=null,super.postDestroy()}createVertexBufferImpl(e,t){return new Gg}createIndexBufferImpl(e){return new Hg(e)}createShaderImpl(e){return new jg(e)}createTextureImpl(){return new Yg}createRenderTargetImpl(e){return new qg(e)}getPrecision(){const e=this.gl;let t="highp";if(e.getShaderPrecisionFormat){const n=e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT),a=e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT),i=e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT),s=e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT),r=n.precision>0&&i.precision>0,o=a.precision>0&&s.precision>0;r||(t=o?"mediump":"lowp")}return t}initializeExtensions(){const e=this.gl,t=e.getSupportedExtensions(),n=function(){for(let n=0;n<arguments.length;n++)if(-1!==t.indexOf(arguments[n]))return e.getExtension(arguments[n]);return null};if(this.webgl2)this.extBlendMinmax=!0,this.extDrawBuffers=!0,this.extInstancing=!0,this.extStandardDerivatives=!0,this.extTextureFloat=!0,this.extTextureHalfFloat=!0,this.extTextureLod=!0,this.extUintElement=!0,this.extVertexArrayObject=!0,this.extColorBufferFloat=n("EXT_color_buffer_float"),this.extDisjointTimerQuery=n("EXT_disjoint_timer_query_webgl2","EXT_disjoint_timer_query"),this.extDepthTexture=!0;else{if(this.extBlendMinmax=n("EXT_blend_minmax"),this.extDrawBuffers=n("EXT_draw_buffers"),this.extInstancing=n("ANGLE_instanced_arrays"),this.extInstancing){const t=this.extInstancing;e.drawArraysInstanced=t.drawArraysInstancedANGLE.bind(t),e.drawElementsInstanced=t.drawElementsInstancedANGLE.bind(t),e.vertexAttribDivisor=t.vertexAttribDivisorANGLE.bind(t)}if(this.extStandardDerivatives=n("OES_standard_derivatives"),this.extTextureFloat=n("OES_texture_float"),this.extTextureHalfFloat=n("OES_texture_half_float"),this.extTextureLod=n("EXT_shader_texture_lod"),this.extUintElement=n("OES_element_index_uint"),this.extVertexArrayObject=n("OES_vertex_array_object"),this.extVertexArrayObject){const t=this.extVertexArrayObject;e.createVertexArray=t.createVertexArrayOES.bind(t),e.deleteVertexArray=t.deleteVertexArrayOES.bind(t),e.isVertexArray=t.isVertexArrayOES.bind(t),e.bindVertexArray=t.bindVertexArrayOES.bind(t)}this.extColorBufferFloat=null,this.extDisjointTimerQuery=null,this.extDepthTexture=e.getExtension("WEBGL_depth_texture")}this.extDebugRendererInfo=n("WEBGL_debug_renderer_info"),this.extTextureFloatLinear=n("OES_texture_float_linear"),this.extTextureHalfFloatLinear=n("OES_texture_half_float_linear"),this.extFloatBlend=n("EXT_float_blend"),this.extTextureFilterAnisotropic=n("EXT_texture_filter_anisotropic","WEBKIT_EXT_texture_filter_anisotropic"),this.extCompressedTextureETC1=n("WEBGL_compressed_texture_etc1"),this.extCompressedTextureETC=n("WEBGL_compressed_texture_etc"),this.extCompressedTexturePVRTC=n("WEBGL_compressed_texture_pvrtc","WEBKIT_WEBGL_compressed_texture_pvrtc"),this.extCompressedTextureS3TC=n("WEBGL_compressed_texture_s3tc","WEBKIT_WEBGL_compressed_texture_s3tc"),this.extCompressedTextureATC=n("WEBGL_compressed_texture_atc"),this.extCompressedTextureASTC=n("WEBGL_compressed_texture_astc"),this.extParallelShaderCompile=n("KHR_parallel_shader_compile"),this.extColorBufferHalfFloat=n("EXT_color_buffer_half_float")}initializeCapabilities(){const e=this.gl;let t;const n="undefined"!=typeof navigator?navigator.userAgent:"";this.maxPrecision=this.precision=this.getPrecision();const a=e.getContextAttributes();this.supportsMsaa=a.antialias,this.supportsStencil=a.stencil,this.supportsInstancing=!!this.extInstancing,this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxCubeMapSize=e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),this.maxRenderBufferSize=e.getParameter(e.MAX_RENDERBUFFER_SIZE),this.maxTextures=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.maxCombinedTextures=e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS),this.maxVertexTextures=e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),this.vertexUniformsCount=e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),this.fragmentUniformsCount=e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),this.webgl2?(this.maxDrawBuffers=e.getParameter(e.MAX_DRAW_BUFFERS),this.maxColorAttachments=e.getParameter(e.MAX_COLOR_ATTACHMENTS),this.maxVolumeSize=e.getParameter(e.MAX_3D_TEXTURE_SIZE)):(t=this.extDrawBuffers,this.maxDrawBuffers=t?e.getParameter(t.MAX_DRAW_BUFFERS_EXT):1,this.maxColorAttachments=t?e.getParameter(t.MAX_COLOR_ATTACHMENTS_EXT):1,this.maxVolumeSize=1),t=this.extDebugRendererInfo,this.unmaskedRenderer=t?e.getParameter(t.UNMASKED_RENDERER_WEBGL):"",this.unmaskedVendor=t?e.getParameter(t.UNMASKED_VENDOR_WEBGL):"";this.supportsGpuParticles=!("ARM"===this.unmaskedVendor&&n.match(/SM-[a-zA-Z0-9]+\)/)),t=this.extTextureFilterAnisotropic,this.maxAnisotropy=t?e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT):1,this.samples=e.getParameter(e.SAMPLES),this.maxSamples=this.webgl2&&!this.forceDisableMultisampling?e.getParameter(e.MAX_SAMPLES):1,this.supportsAreaLights=this.webgl2||!uu.android,this.maxTextures<=8&&(this.supportsAreaLights=!1)}initializeRenderState(){const e=this.gl;this.blending=!1,e.disable(e.BLEND),this.blendSrc=1,this.blendDst=0,this.blendSrcAlpha=1,this.blendDstAlpha=0,this.separateAlphaBlend=!1,this.blendEquation=0,this.blendAlphaEquation=0,this.separateAlphaEquation=!1,e.blendFunc(e.ONE,e.ZERO),e.blendEquation(e.FUNC_ADD),this.blendColor=new Mu(0,0,0,0),e.blendColor(0,0,0,0),this.writeRed=!0,this.writeGreen=!0,this.writeBlue=!0,this.writeAlpha=!0,e.colorMask(!0,!0,!0,!0),this.cullMode=1,e.enable(e.CULL_FACE),e.cullFace(e.BACK),this.depthTest=!0,e.enable(e.DEPTH_TEST),this.depthFunc=3,e.depthFunc(e.LEQUAL),this.depthWrite=!0,e.depthMask(!0),this.stencil=!1,e.disable(e.STENCIL_TEST),this.stencilFuncFront=this.stencilFuncBack=7,this.stencilRefFront=this.stencilRefBack=0,this.stencilMaskFront=this.stencilMaskBack=255,e.stencilFunc(e.ALWAYS,0,255),this.stencilFailFront=this.stencilFailBack=0,this.stencilZfailFront=this.stencilZfailBack=0,this.stencilZpassFront=this.stencilZpassBack=0,this.stencilWriteMaskFront=255,this.stencilWriteMaskBack=255,e.stencilOp(e.KEEP,e.KEEP,e.KEEP),e.stencilMask(255),this.alphaToCoverage=!1,this.raster=!0,this.webgl2&&(e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),e.disable(e.RASTERIZER_DISCARD)),this.depthBiasEnabled=!1,e.disable(e.POLYGON_OFFSET_FILL),this.clearDepth=1,e.clearDepth(1),this.clearColor=new Mu(0,0,0,0),e.clearColor(0,0,0,0),this.clearStencil=0,e.clearStencil(0),this.vx=this.vy=this.vw=this.vh=0,this.sx=this.sy=this.sw=this.sh=0,this.webgl2?e.hint(e.FRAGMENT_SHADER_DERIVATIVE_HINT,e.NICEST):this.extStandardDerivatives&&e.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES,e.NICEST),e.enable(e.SCISSOR_TEST),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,e.NONE),this.unpackFlipY=!1,e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!1),this.unpackPremultiplyAlpha=!1,e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),e.pixelStorei(e.UNPACK_ALIGNMENT,1)}initializeContextCaches(){super.initializeContextCaches(),this.vertexShaderCache={},this.fragmentShaderCache={},this._vaoMap=new Map,this.boundVao=null,this.activeFramebuffer=null,this.feedback=null,this.transformFeedbackBuffer=null,this.textureUnit=0,this.textureUnits=[];for(let e=0;e<this.maxCombinedTextures;e++)this.textureUnits.push([null,null,null])}loseContext(){for(const e of this.shaders)e.loseContext();this.grabPass.destroy();for(const e of this.textures)e.loseContext();for(const e of this.buffers)e.loseContext();for(const e of this.targets)e.loseContext()}restoreContext(){this.initializeExtensions(),this.initializeCapabilities(),this.initializeRenderState(),this.initializeContextCaches();for(const e of this.shaders)e.restoreContext();for(const e of this.buffers)e.unlock();this.grabPass.create()}setViewport(e,t,n,a){this.vx===e&&this.vy===t&&this.vw===n&&this.vh===a||(this.gl.viewport(e,t,n,a),this.vx=e,this.vy=t,this.vw=n,this.vh=a)}setScissor(e,t,n,a){this.sx===e&&this.sy===t&&this.sw===n&&this.sh===a||(this.gl.scissor(e,t,n,a),this.sx=e,this.sy=t,this.sw=n,this.sh=a)}setFramebuffer(e){if(this.activeFramebuffer!==e){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,e),this.activeFramebuffer=e}}copyRenderTarget(e,t,n,a){const i=this.gl;if(!this.webgl2&&a)return!1;if(n)if(t){if(!e._colorBuffer||!t._colorBuffer)return!1;if(e._colorBuffer._format!==t._colorBuffer._format)return!1}else if(!e._colorBuffer)return!1;if(a){if(!e._depthBuffer||!t._depthBuffer)return!1;if(e._depthBuffer._format!==t._depthBuffer._format)return!1}if(this.webgl2&&t){const s=this.renderTarget;this.renderTarget=t,this.updateBegin(),i.bindFramebuffer(i.READ_FRAMEBUFFER,e?e.impl._glFrameBuffer:null),i.bindFramebuffer(i.DRAW_FRAMEBUFFER,t.impl._glFrameBuffer);const r=e?e.width:t.width,o=e?e.height:t.height;i.blitFramebuffer(0,0,r,o,0,0,r,o,(n?i.COLOR_BUFFER_BIT:0)|(a?i.DEPTH_BUFFER_BIT:0),i.NEAREST),this.renderTarget=s,i.bindFramebuffer(i.FRAMEBUFFER,s?s.impl._glFrameBuffer:null)}else{const n=this.getCopyShader();this.constantTexSource.setValue(e._colorBuffer),mm(this,t,n)}return!0}initRenderTarget(e){e.impl._glFrameBuffer||(e.init(),this.targets.push(e))}getCopyShader(){if(!this._copyShader){const e=gm.fullscreenQuadVS,t=gm.outputTex2DPS;this._copyShader=Mm(this,e,t,"outputTex2D")}return this._copyShader}updateBegin(){if(this.boundVao=null,this._tempEnableSafariTextureUnitWorkaround)for(let e=0;e<this.textureUnits.length;++e)for(let t=0;t<3;++t)this.textureUnits[e][t]=null;const e=this.renderTarget;e?e.impl._glFrameBuffer?this.setFramebuffer(e.impl._glFrameBuffer):this.initRenderTarget(e):this.setFramebuffer(this.defaultFramebuffer)}updateEnd(){const e=this.gl;this.boundVao&&(this.boundVao=null,this.gl.bindVertexArray(null));const t=this.renderTarget;if(t){const n=t._colorBuffer;n&&n.impl._glTexture&&n.mipmaps&&(n.pot||this.webgl2)&&(this.activeTexture(this.maxCombinedTextures-1),this.bindTexture(n),e.generateMipmap(n.impl._glTarget)),this.webgl2&&t._samples>1&&t.autoResolve&&t.resolve()}}setUnpackFlipY(e){if(this.unpackFlipY!==e){this.unpackFlipY=e;const t=this.gl;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,e)}}setUnpackPremultiplyAlpha(e){if(this.unpackPremultiplyAlpha!==e){this.unpackPremultiplyAlpha=e;const t=this.gl;t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e)}}activeTexture(e){this.textureUnit!==e&&(this.gl.activeTexture(this.gl.TEXTURE0+e),this.textureUnit=e)}bindTexture(e){const t=e.impl,n=t._glTarget,a=t._glTexture,i=this.textureUnit,s=this.targetToSlot[n];this.textureUnits[i][s]!==a&&(this.gl.bindTexture(n,a),this.textureUnits[i][s]=a)}bindTextureOnUnit(e,t){const n=e.impl,a=n._glTarget,i=n._glTexture,s=this.targetToSlot[a];this.textureUnits[t][s]!==i&&(this.activeTexture(t),this.gl.bindTexture(a,i),this.textureUnits[t][s]=i)}setTextureParameters(e){const t=this.gl,n=e._parameterFlags,a=e.impl._glTarget;if(1&n){let n=e._minFilter;(!e.pot&&!this.webgl2||!e._mipmaps||e._compressed&&1===e._levels.length)&&(2===n||3===n?n=0:4!==n&&5!==n||(n=1)),t.texParameteri(a,t.TEXTURE_MIN_FILTER,this.glFilter[n])}if(2&n&&t.texParameteri(a,t.TEXTURE_MAG_FILTER,this.glFilter[e._magFilter]),4&n&&(this.webgl2?t.texParameteri(a,t.TEXTURE_WRAP_S,this.glAddress[e._addressU]):t.texParameteri(a,t.TEXTURE_WRAP_S,this.glAddress[e.pot?e._addressU:1])),8&n&&(this.webgl2?t.texParameteri(a,t.TEXTURE_WRAP_T,this.glAddress[e._addressV]):t.texParameteri(a,t.TEXTURE_WRAP_T,this.glAddress[e.pot?e._addressV:1])),16&n&&this.webgl2&&t.texParameteri(a,t.TEXTURE_WRAP_R,this.glAddress[e._addressW]),32&n&&this.webgl2&&t.texParameteri(a,t.TEXTURE_COMPARE_MODE,e._compareOnRead?t.COMPARE_REF_TO_TEXTURE:t.NONE),64&n&&this.webgl2&&t.texParameteri(a,t.TEXTURE_COMPARE_FUNC,this.glComparison[e._compareFunc]),128&n){const n=this.extTextureFilterAnisotropic;n&&t.texParameterf(a,n.TEXTURE_MAX_ANISOTROPY_EXT,Math.max(1,Math.min(Math.round(e._anisotropy),this.maxAnisotropy)))}}setTexture(e,t){if(e.impl._glTexture||e.impl.initialize(this,e),e._parameterFlags>0||e._needsUpload||e._needsMipmapsUpload||e===this.grabPass.texture){this.activeTexture(t),this.bindTexture(e),e._parameterFlags&&(this.setTextureParameters(e),e._parameterFlags=0);e===this.grabPass.texture&&this.grabPass.prepareTexture()||!e._needsUpload&&!e._needsMipmapsUpload||(e.impl.upload(this,e),e._needsUpload=!1,e._needsMipmapsUpload=!1)}else this.bindTextureOnUnit(e,t)}createVertexArray(e){let t,n;const a=e.length>1;if(a){t="";for(let n=0;n<e.length;n++){const a=e[n];t+=a.id+a.format.renderingingHash}n=this._vaoMap.get(t)}if(!n){const i=this.gl;n=i.createVertexArray(),i.bindVertexArray(n),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,null);for(let t=0;t<e.length;t++){const n=e[t];i.bindBuffer(i.ARRAY_BUFFER,n.impl.bufferId);const a=n.format.elements;for(let e=0;e<a.length;e++){const t=a[e],s=rm[t.name];i.vertexAttribPointer(s,t.numComponents,this.glType[t.dataType],t.normalize,t.stride,t.offset),i.enableVertexAttribArray(s),n.instancing&&i.vertexAttribDivisor(s,1)}}i.bindVertexArray(null),i.bindBuffer(i.ARRAY_BUFFER,null),a&&this._vaoMap.set(t,n)}return n}setBuffers(){const e=this.gl;let t;if(1===this.vertexBuffers.length){const e=this.vertexBuffers[0];e.impl.vao||(e.impl.vao=this.createVertexArray(this.vertexBuffers)),t=e.impl.vao}else t=this.createVertexArray(this.vertexBuffers);this.boundVao!==t&&(this.boundVao=t,e.bindVertexArray(t)),this.vertexBuffers.length=0;const n=this.indexBuffer?this.indexBuffer.impl.bufferId:null;e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)}draw(e,t,n){const a=this.gl;let i,s,r,o,l,c,h,d;const p=this.shader;if(!p)return;const u=p.impl.samplers,m=p.impl.uniforms;n||this.setBuffers();let f=0;for(let e=0,t=u.length;e<t;e++)if(i=u[e],s=i.scopeId.value,s)if(s instanceof Gm)r=s,this.setTexture(r,f),i.slot!==f&&(a.uniform1i(i.locationId,f),i.slot=f),f++;else{i.array.length=0,o=s.length;for(let e=0;e<o;e++)r=s[e],this.setTexture(r,f),i.array[e]=f,f++;a.uniform1iv(i.locationId,i.array)}for(let e=0,t=m.length;e<t;e++)l=m[e],c=l.scopeId,h=l.version,d=c.versionObject.version,h.globalId===d.globalId&&h.revision===d.revision||(h.globalId=d.globalId,h.revision=d.revision,null!==c.value&&this.commitFunction[l.dataType](l,c.value));this.webgl2&&this.transformFeedbackBuffer&&(a.bindBufferBase(a.TRANSFORM_FEEDBACK_BUFFER,0,this.transformFeedbackBuffer.impl.bufferId),a.beginTransformFeedback(a.POINTS));const g=this.glPrimitive[e.type],y=e.count;if(e.indexed){const n=this.indexBuffer,i=n.impl.glFormat,s=e.base*n.bytesPerIndex;t>0?a.drawElementsInstanced(g,y,i,s,t):a.drawElements(g,y,i,s)}else{const n=e.base;t>0?a.drawArraysInstanced(g,n,y,t):a.drawArrays(g,n,y)}this.webgl2&&this.transformFeedbackBuffer&&(a.endTransformFeedback(),a.bindBufferBase(a.TRANSFORM_FEEDBACK_BUFFER,0,null)),this._drawCallsPerFrame++}clear(e){const t=this.defaultClearOptions,n=null==(e=e||t).flags?t.flags:e.flags;if(0!==n){const a=this.gl;if(1&n){const n=null==e.color?t.color:e.color;this.setClearColor(n[0],n[1],n[2],n[3])}if(2&n){const n=null==e.depth?t.depth:e.depth;this.setClearDepth(n),this.depthWrite||a.depthMask(!0)}if(4&n){const n=null==e.stencil?t.stencil:e.stencil;this.setClearStencil(n)}a.clear(this.glClearFlag[n]),2&n&&(this.depthWrite||a.depthMask(!1))}}readPixels(e,t,n,a,i){const s=this.gl;s.readPixels(e,t,n,a,s.RGBA,s.UNSIGNED_BYTE,i)}setClearDepth(e){e!==this.clearDepth&&(this.gl.clearDepth(e),this.clearDepth=e)}setClearColor(e,t,n,a){const i=this.clearColor;e===i.r&&t===i.g&&n===i.b&&a===i.a||(this.gl.clearColor(e,t,n,a),this.clearColor.set(e,t,n,a))}setClearStencil(e){e!==this.clearStencil&&(this.gl.clearStencil(e),this.clearStencil=e)}getDepthTest(){return this.depthTest}setDepthTest(e){if(this.depthTest!==e){const t=this.gl;e?t.enable(t.DEPTH_TEST):t.disable(t.DEPTH_TEST),this.depthTest=e}}setDepthFunc(e){this.depthFunc!==e&&(this.gl.depthFunc(this.glComparison[e]),this.depthFunc=e)}getDepthWrite(){return this.depthWrite}setDepthWrite(e){this.depthWrite!==e&&(this.gl.depthMask(e),this.depthWrite=e)}setColorWrite(e,t,n,a){this.writeRed===e&&this.writeGreen===t&&this.writeBlue===n&&this.writeAlpha===a||(this.gl.colorMask(e,t,n,a),this.writeRed=e,this.writeGreen=t,this.writeBlue=n,this.writeAlpha=a)}setAlphaToCoverage(e){this.webgl2&&this.alphaToCoverage!==e&&(this.alphaToCoverage=e,e?this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE):this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE))}setTransformFeedbackBuffer(e){if(this.transformFeedbackBuffer!==e&&(this.transformFeedbackBuffer=e,this.webgl2)){const t=this.gl;e?(this.feedback||(this.feedback=t.createTransformFeedback()),t.bindTransformFeedback(t.TRANSFORM_FEEDBACK,this.feedback)):t.bindTransformFeedback(t.TRANSFORM_FEEDBACK,null)}}setRaster(e){this.raster!==e&&(this.raster=e,this.webgl2&&(e?this.gl.disable(this.gl.RASTERIZER_DISCARD):this.gl.enable(this.gl.RASTERIZER_DISCARD)))}setDepthBias(e){this.depthBiasEnabled!==e&&(this.depthBiasEnabled=e,e?this.gl.enable(this.gl.POLYGON_OFFSET_FILL):this.gl.disable(this.gl.POLYGON_OFFSET_FILL))}setDepthBiasValues(e,t){this.gl.polygonOffset(t,e)}getBlending(){return this.blending}setBlending(e){if(this.blending!==e){const t=this.gl;e?t.enable(t.BLEND):t.disable(t.BLEND),this.blending=e}}setStencilTest(e){if(this.stencil!==e){const t=this.gl;e?t.enable(t.STENCIL_TEST):t.disable(t.STENCIL_TEST),this.stencil=e}}setStencilFunc(e,t,n){if(this.stencilFuncFront!==e||this.stencilRefFront!==t||this.stencilMaskFront!==n||this.stencilFuncBack!==e||this.stencilRefBack!==t||this.stencilMaskBack!==n){this.gl.stencilFunc(this.glComparison[e],t,n),this.stencilFuncFront=this.stencilFuncBack=e,this.stencilRefFront=this.stencilRefBack=t,this.stencilMaskFront=this.stencilMaskBack=n}}setStencilFuncFront(e,t,n){if(this.stencilFuncFront!==e||this.stencilRefFront!==t||this.stencilMaskFront!==n){const a=this.gl;a.stencilFuncSeparate(a.FRONT,this.glComparison[e],t,n),this.stencilFuncFront=e,this.stencilRefFront=t,this.stencilMaskFront=n}}setStencilFuncBack(e,t,n){if(this.stencilFuncBack!==e||this.stencilRefBack!==t||this.stencilMaskBack!==n){const a=this.gl;a.stencilFuncSeparate(a.BACK,this.glComparison[e],t,n),this.stencilFuncBack=e,this.stencilRefBack=t,this.stencilMaskBack=n}}setStencilOperation(e,t,n,a){this.stencilFailFront===e&&this.stencilZfailFront===t&&this.stencilZpassFront===n&&this.stencilFailBack===e&&this.stencilZfailBack===t&&this.stencilZpassBack===n||(this.gl.stencilOp(this.glStencilOp[e],this.glStencilOp[t],this.glStencilOp[n]),this.stencilFailFront=this.stencilFailBack=e,this.stencilZfailFront=this.stencilZfailBack=t,this.stencilZpassFront=this.stencilZpassBack=n),this.stencilWriteMaskFront===a&&this.stencilWriteMaskBack===a||(this.gl.stencilMask(a),this.stencilWriteMaskFront=a,this.stencilWriteMaskBack=a)}setStencilOperationFront(e,t,n,a){this.stencilFailFront===e&&this.stencilZfailFront===t&&this.stencilZpassFront===n||(this.gl.stencilOpSeparate(this.gl.FRONT,this.glStencilOp[e],this.glStencilOp[t],this.glStencilOp[n]),this.stencilFailFront=e,this.stencilZfailFront=t,this.stencilZpassFront=n),this.stencilWriteMaskFront!==a&&(this.gl.stencilMaskSeparate(this.gl.FRONT,a),this.stencilWriteMaskFront=a)}setStencilOperationBack(e,t,n,a){this.stencilFailBack===e&&this.stencilZfailBack===t&&this.stencilZpassBack===n||(this.gl.stencilOpSeparate(this.gl.BACK,this.glStencilOp[e],this.glStencilOp[t],this.glStencilOp[n]),this.stencilFailBack=e,this.stencilZfailBack=t,this.stencilZpassBack=n),this.stencilWriteMaskBack!==a&&(this.gl.stencilMaskSeparate(this.gl.BACK,a),this.stencilWriteMaskBack=a)}setBlendFunction(e,t){(this.blendSrc!==e||this.blendDst!==t||this.separateAlphaBlend)&&(this.gl.blendFunc(this.glBlendFunction[e],this.glBlendFunction[t]),this.blendSrc=e,this.blendDst=t,this.separateAlphaBlend=!1)}setBlendFunctionSeparate(e,t,n,a){this.blendSrc===e&&this.blendDst===t&&this.blendSrcAlpha===n&&this.blendDstAlpha===a&&this.separateAlphaBlend||(this.gl.blendFuncSeparate(this.glBlendFunction[e],this.glBlendFunction[t],this.glBlendFunction[n],this.glBlendFunction[a]),this.blendSrc=e,this.blendDst=t,this.blendSrcAlpha=n,this.blendDstAlpha=a,this.separateAlphaBlend=!0)}setBlendEquation(e){(this.blendEquation!==e||this.separateAlphaEquation)&&(this.gl.blendEquation(this.glBlendEquation[e]),this.blendEquation=e,this.separateAlphaEquation=!1)}setBlendEquationSeparate(e,t){this.blendEquation===e&&this.blendAlphaEquation===t&&this.separateAlphaEquation||(this.gl.blendEquationSeparate(this.glBlendEquation[e],this.glBlendEquation[t]),this.blendEquation=e,this.blendAlphaEquation=t,this.separateAlphaEquation=!0)}setBlendColor(e,t,n,a){const i=this.blendColor;e===i.r&&t===i.g&&n===i.b&&a===i.a||(this.gl.blendColor(e,t,n,a),i.set(e,t,n,a))}setCullMode(e){if(this.cullMode!==e){if(0===e)this.gl.disable(this.gl.CULL_FACE);else{0===this.cullMode&&this.gl.enable(this.gl.CULL_FACE);const t=this.glCull[e];this.cullFace!==t&&(this.gl.cullFace(t),this.cullFace=t)}this.cullMode=e}}getCullMode(){return this.cullMode}setIndexBuffer(e){this.indexBuffer=e}setVertexBuffer(e){e&&this.vertexBuffers.push(e)}setShader(e){if(e!==this.shader){if(e.failed)return!1;if(!e.ready&&!e.impl.postLink(this,e))return e.failed=!0,!1;this.shader=e,this.gl.useProgram(e.impl.glProgram),this.attributesInvalidated=!0}return!0}getHdrFormat(){return this.textureHalfFloatRenderable?12:this.textureFloatRenderable?14:7}getBoneLimit(){return this.boneLimit}setBoneLimit(e){this.boneLimit=e}clearShaderCache(){const e=this.gl;for(const t in this.fragmentShaderCache)e.deleteShader(this.fragmentShaderCache[t]),delete this.fragmentShaderCache[t];for(const t in this.vertexShaderCache)e.deleteShader(this.vertexShaderCache[t]),delete this.vertexShaderCache[t];this.programLib.clearCache()}clearVertexArrayObjectCache(){const e=this.gl;this._vaoMap.forEach(((t,n,a)=>{e.deleteVertexArray(t)})),this._vaoMap.clear()}removeShaderFromCache(e){this.programLib.removeFromCache(e)}get width(){return this.gl.drawingBufferWidth||this.canvas.width}get height(){return this.gl.drawingBufferHeight||this.canvas.height}set fullscreen(e){if(e){this.gl.canvas.requestFullscreen()}else document.exitFullscreen()}get fullscreen(){return!!document.fullscreenElement}get textureFloatHighPrecision(){return void 0===this._textureFloatHighPrecision&&(this._textureFloatHighPrecision=function(e){if(!e.textureFloatRenderable)return!1;const t=Mm(e,gm.fullscreenQuadVS,gm.precisionTestPS,"ptest1"),n=Mm(e,gm.fullscreenQuadVS,gm.precisionTest2PS,"ptest2"),a={format:14,width:1,height:1,mipmaps:!1,minFilter:0,magFilter:0},i=new Gm(e,a);i.name="testFHP";const s=new Cg({colorBuffer:i,depth:!1});mm(e,s,t),a.format=7;const r=new Gm(e,a);r.name="testFHP";const o=new Cg({colorBuffer:r,depth:!1});e.constantTexSource.setValue(i),mm(e,o,n);const l=e.activeFramebuffer;e.setFramebuffer(o.impl._glFrameBuffer);const c=new Uint8Array(4);e.readPixels(0,0,1,1,c),e.setFramebuffer(l);const h=c[0]/255/16777216+c[1]/255/65536+c[2]/255/256+c[3]/255;return i.destroy(),s.destroy(),r.destroy(),o.destroy(),0===h}(this)),this._textureFloatHighPrecision}get textureHalfFloatUpdatable(){return void 0===this._textureHalfFloatUpdatable&&(this.webgl2?this._textureHalfFloatUpdatable=!0:this._textureHalfFloatUpdatable=function(e,t){let n=!0;const a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE);const i=new Uint16Array(16);return e.texImage2D(e.TEXTURE_2D,0,e.RGBA,2,2,0,e.RGBA,t,i),e.getError()!==e.NO_ERROR&&(n=!1,console.log("Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support")),e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(a),n}(this.gl,this.extTextureHalfFloat.HALF_FLOAT_OES)),this._textureHalfFloatUpdatable}}class $g{constructor(){this._refCount=0}incRefCount(){this._refCount++}decRefCount(){this._refCount--}get refCount(){return this._refCount}}let Qg;function Jg(){return Qg}function ey(e){Qg=e}let ty=0;class ny{constructor(){this.initDefaults()}initDefaults(){this.recreate=!1,this.verticesUsage=0,this.indicesUsage=0,this.maxVertices=0,this.maxIndices=0,this.vertexCount=0,this.indexCount=0,this.vertexStreamsUpdated=!1,this.indexStreamUpdated=!1,this.vertexStreamDictionary={},this.indices=null}_changeVertexCount(e,t){this.vertexCount||(this.vertexCount=e)}}ny.DEFAULT_COMPONENTS_POSITION=3,ny.DEFAULT_COMPONENTS_NORMAL=3,ny.DEFAULT_COMPONENTS_UV=2,ny.DEFAULT_COMPONENTS_COLORS=4;class ay{constructor(e,t,n,a){this.data=e,this.componentCount=t,this.dataType=n,this.dataTypeNormalize=a}}class iy extends $g{constructor(e){super(),this.id=ty++,this.device=e||Jg().graphicsDevice,this.vertexBuffer=null,this.indexBuffer=[null],this.primitive=[{type:0,base:0,count:0}],this.skin=null,this._morph=null,this._geometryData=null,this._aabb=new qu,this.boneAabb=null}set morph(e){e!==this._morph&&(this._morph&&this._morph.decRefCount(),this._morph=e,e&&e.incRefCount())}get morph(){return this._morph}set aabb(e){this._aabb=e}get aabb(){return this._aabb}destroy(){const e=this.morph;e&&(this.morph=null,e.refCount<1&&e.destroy()),this.vertexBuffer&&(this.vertexBuffer.destroy(),this.vertexBuffer=null);for(let e=0;e<this.indexBuffer.length;e++)this._destroyIndexBuffer(e);this.indexBuffer.length=0,this._geometryData=null}_destroyIndexBuffer(e){this.indexBuffer[e]&&(this.indexBuffer[e].destroy(),this.indexBuffer[e]=null)}_initBoneAabbs(e){let t,n,a,i,s;this.boneAabb=[],this.boneUsed=[];const r=[],o=[],l=this.boneUsed,c=this.skin.boneNames.length;let h,d,p;for(let e=0;e<c;e++)r[e]=new Pu(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),o[e]=new Pu(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);const u=new Vg(this.vertexBuffer),m=u.element.POSITION,f=u.element.BLENDWEIGHT,g=u.element.BLENDINDICES,y=this.vertexBuffer.numVertices;for(let c=0;c<y;c++){for(let u=0;u<4;u++){if(f.array[f.index+u]>0){const f=g.array[g.index+u];if(l[f]=!0,t=m.array[m.index],n=m.array[m.index+1],a=m.array[m.index+2],i=o[f],s=r[f],s.x>t&&(s.x=t),s.y>n&&(s.y=n),s.z>a&&(s.z=a),i.x<t&&(i.x=t),i.y<n&&(i.y=n),i.z<a&&(i.z=a),e){let r=h=t,o=d=n,l=p=a;for(let t=0;t<e.length;t++){const n=e[t],a=n.deltaPositions[3*c],i=n.deltaPositions[3*c+1],s=n.deltaPositions[3*c+2];a<0?r+=a:h+=a,i<0?o+=i:d+=i,s<0?l+=s:p+=s}s.x>r&&(s.x=r),s.y>o&&(s.y=o),s.z>l&&(s.z=l),i.x<h&&(i.x=h),i.y<d&&(i.y=d),i.z<p&&(i.z=p)}}}u.next()}const b=this.vertexBuffer.getFormat().elements.find((e=>"POSITION"===e.name));if(b&&b.normalize){const e=(()=>{switch(b.dataType){case 0:return e=>Math.max(e/127,-1);case 1:return e=>e/255;case 2:return e=>Math.max(e/32767,-1);case 3:return e=>e/65535;default:return e=>e}})();for(let t=0;t<c;t++)if(l[t]){const n=r[t],a=o[t];n.set(e(n.x),e(n.y),e(n.z)),a.set(e(a.x),e(a.y),e(a.z))}}for(let e=0;e<c;e++){const t=new qu;t.setMinMax(r[e],o[e]),this.boneAabb.push(t)}}_initGeometryData(){this._geometryData||(this._geometryData=new ny,this.vertexBuffer&&(this._geometryData.vertexCount=this.vertexBuffer.numVertices,this._geometryData.maxVertices=this.vertexBuffer.numVertices),this.indexBuffer.length>0&&this.indexBuffer[0]&&(this._geometryData.indexCount=this.indexBuffer[0].numIndices,this._geometryData.maxIndices=this.indexBuffer[0].numIndices))}clear(e,t,n=0,a=0){this._initGeometryData(),this._geometryData.initDefaults(),this._geometryData.recreate=!0,this._geometryData.maxVertices=n,this._geometryData.maxIndices=a,this._geometryData.verticesUsage=e?0:1,this._geometryData.indicesUsage=t?0:1}setVertexStream(e,t,n,a,i=6,s=!1){this._initGeometryData();const r=a||t.length/n;this._geometryData._changeVertexCount(r,e),this._geometryData.vertexStreamsUpdated=!0,this._geometryData.vertexStreamDictionary[e]=new ay(t,n,i,s)}getVertexStream(e,t){let n=0,a=!1;if(this._geometryData){const i=this._geometryData.vertexStreamDictionary[e];i&&(a=!0,n=this._geometryData.vertexCount,ArrayBuffer.isView(t)?t.set(i.data):(t.length=0,t.push(i.data)))}if(!a&&this.vertexBuffer){n=new Vg(this.vertexBuffer).readData(e,t)}return n}setPositions(e,t=ny.DEFAULT_COMPONENTS_POSITION,n){this.setVertexStream("POSITION",e,t,n,6,!1)}setNormals(e,t=ny.DEFAULT_COMPONENTS_NORMAL,n){this.setVertexStream("NORMAL",e,t,n,6,!1)}setUvs(e,t,n=ny.DEFAULT_COMPONENTS_UV,a){this.setVertexStream("TEXCOORD"+e,t,n,a,6,!1)}setColors(e,t=ny.DEFAULT_COMPONENTS_COLORS,n){this.setVertexStream("COLOR",e,t,n,6,!1)}setColors32(e,t){this.setVertexStream("COLOR",e,ny.DEFAULT_COMPONENTS_COLORS,t,1,!0)}setIndices(e,t){this._initGeometryData(),this._geometryData.indexStreamUpdated=!0,this._geometryData.indices=e,this._geometryData.indexCount=t||e.length}getPositions(e){return this.getVertexStream("POSITION",e)}getNormals(e){return this.getVertexStream("NORMAL",e)}getUvs(e,t){return this.getVertexStream("TEXCOORD"+e,t)}getColors(e){return this.getVertexStream("COLOR",e)}getIndices(e){let t=0;if(this._geometryData&&this._geometryData.indices){const n=this._geometryData.indices;t=this._geometryData.indexCount,ArrayBuffer.isView(e)?e.set(n):(e.length=0,e.push(n))}else if(this.indexBuffer.length>0&&this.indexBuffer[0]){t=this.indexBuffer[0].readData(e)}return t}update(e=4,t=!0){if(this._geometryData){if(t){const e=this._geometryData.vertexStreamDictionary.POSITION;e&&3===e.componentCount&&this._aabb.compute(e.data,this._geometryData.vertexCount)}let n=this._geometryData.recreate;this._geometryData.vertexCount>this._geometryData.maxVertices&&(n=!0,this._geometryData.maxVertices=this._geometryData.vertexCount),n&&this.vertexBuffer&&(this.vertexBuffer.destroy(),this.vertexBuffer=null);let a=this._geometryData.recreate;this._geometryData.indexCount>this._geometryData.maxIndices&&(a=!0,this._geometryData.maxIndices=this._geometryData.indexCount),a&&this.indexBuffer.length>0&&this.indexBuffer[0]&&(this.indexBuffer[0].destroy(),this.indexBuffer[0]=null),this._geometryData.vertexStreamsUpdated&&this._updateVertexBuffer(),this._geometryData.indexStreamUpdated&&this._updateIndexBuffer(),this.primitive[0].type=e,this.indexBuffer.length>0&&this.indexBuffer[0]?this._geometryData.indexStreamUpdated&&(this.primitive[0].count=this._geometryData.indexCount,this.primitive[0].indexed=!0):this._geometryData.vertexStreamsUpdated&&(this.primitive[0].count=this._geometryData.vertexCount,this.primitive[0].indexed=!1),this._geometryData.vertexCount=0,this._geometryData.indexCount=0,this._geometryData.vertexStreamsUpdated=!1,this._geometryData.indexStreamUpdated=!1,this._geometryData.recreate=!1,this.updateRenderStates()}}_buildVertexFormat(e){const t=[];for(const e in this._geometryData.vertexStreamDictionary){const n=this._geometryData.vertexStreamDictionary[e];t.push({semantic:e,components:n.componentCount,type:n.dataType,normalize:n.dataTypeNormalize})}return new hm(this.device,t,e)}_updateVertexBuffer(){if(!this.vertexBuffer){const e=this._geometryData.maxVertices,t=this._buildVertexFormat(e);this.vertexBuffer=new lm(this.device,t,e,this._geometryData.verticesUsage)}const e=new Vg(this.vertexBuffer),t=this._geometryData.vertexCount;for(const n in this._geometryData.vertexStreamDictionary){const a=this._geometryData.vertexStreamDictionary[n];e.writeData(n,a.data,t),delete this._geometryData.vertexStreamDictionary[n]}e.end()}_updateIndexBuffer(){if(this.indexBuffer.length<=0||!this.indexBuffer[0]){const e=this._geometryData.maxVertices>65535?2:1;this.indexBuffer[0]=new Tg(this.device,e,this._geometryData.maxIndices,this._geometryData.indicesUsage)}const e=this._geometryData.indices;if(e){this.indexBuffer[0].writeData(e,this._geometryData.indexCount),this._geometryData.indices=null}}prepareRenderState(e){1===e?this.generateWireframe():2===e&&(this.primitive[2]={type:0,base:0,count:this.vertexBuffer?this.vertexBuffer.numVertices:0,indexed:!1})}updateRenderStates(){this.primitive[2]&&this.prepareRenderState(2),this.primitive[1]&&this.prepareRenderState(1)}generateWireframe(){this._destroyIndexBuffer(1);const e=[];let t;if(this.indexBuffer.length>0&&this.indexBuffer[0]){const n=[[0,1],[1,2],[2,0]],a=this.primitive[0].base,i=this.primitive[0].count,s=this.indexBuffer[0],r=new im[s.format](s.storage),o={};for(let t=a;t<a+i;t+=3)for(let a=0;a<3;a++){const i=r[t+n[a][0]],s=r[t+n[a][1]],l=i>s?s<<16|i:i<<16|s;void 0===o[l]&&(o[l]=0,e.push(i,s))}t=s.format}else{for(let t=0;t<this.vertexBuffer.numVertices;t+=3)e.push(t,t+1,t+1,t+2,t+2,t);t=e.length>65535?2:1}const n=new Tg(this.vertexBuffer.device,t,e.length);new im[n.format](n.storage).set(e),n.unlock(),this.primitive[1]={type:1,base:0,count:e.length,indexed:!0},this.indexBuffer[1]=n}}const sy=[];function ry(e,t){const n=t.length/3,a=e.length/3,i=new Pu,s=new Pu,r=new Pu,o=new Pu,l=new Pu,c=new Pu,h=[];for(let t=0;t<e.length;t++)h[t]=0;for(let a=0;a<n;a++){const n=t[3*a],d=t[3*a+1],p=t[3*a+2];i.set(e[3*n],e[3*n+1],e[3*n+2]),s.set(e[3*d],e[3*d+1],e[3*d+2]),r.set(e[3*p],e[3*p+1],e[3*p+2]),o.sub2(s,i),l.sub2(r,i),c.cross(o,l).normalize(),h[3*n]+=c.x,h[3*n+1]+=c.y,h[3*n+2]+=c.z,h[3*d]+=c.x,h[3*d+1]+=c.y,h[3*d+2]+=c.z,h[3*p]+=c.x,h[3*p+1]+=c.y,h[3*p+2]+=c.z}for(let e=0;e<a;e++){const t=h[3*e],n=h[3*e+1],a=h[3*e+2],i=1/Math.sqrt(t*t+n*n+a*a);h[3*e]*=i,h[3*e+1]*=i,h[3*e+2]*=i}return h}function oy(e,t,n,a){const i=a.length/3,s=e.length/3,r=new Pu,o=new Pu,l=new Pu,c=new Du,h=new Du,d=new Du,p=new Pu,u=new Pu,m=new Float32Array(3*s),f=new Float32Array(3*s),g=[];for(let t=0;t<i;t++){const i=a[3*t],s=a[3*t+1],g=a[3*t+2];r.set(e[3*i],e[3*i+1],e[3*i+2]),o.set(e[3*s],e[3*s+1],e[3*s+2]),l.set(e[3*g],e[3*g+1],e[3*g+2]),c.set(n[2*i],n[2*i+1]),h.set(n[2*s],n[2*s+1]),d.set(n[2*g],n[2*g+1]);const y=o.x-r.x,b=l.x-r.x,v=o.y-r.y,_=l.y-r.y,w=o.z-r.z,x=l.z-r.z,C=h.x-c.x,T=d.x-c.x,E=h.y-c.y,S=d.y-c.y,A=C*S-T*E;if(0===A)p.set(0,1,0),u.set(1,0,0);else{const e=1/A;p.set((S*y-E*b)*e,(S*v-E*_)*e,(S*w-E*x)*e),u.set((C*b-T*y)*e,(C*_-T*v)*e,(C*x-T*w)*e)}m[3*i+0]+=p.x,m[3*i+1]+=p.y,m[3*i+2]+=p.z,m[3*s+0]+=p.x,m[3*s+1]+=p.y,m[3*s+2]+=p.z,m[3*g+0]+=p.x,m[3*g+1]+=p.y,m[3*g+2]+=p.z,f[3*i+0]+=u.x,f[3*i+1]+=u.y,f[3*i+2]+=u.z,f[3*s+0]+=u.x,f[3*s+1]+=u.y,f[3*s+2]+=u.z,f[3*g+0]+=u.x,f[3*g+1]+=u.y,f[3*g+2]+=u.z}const y=new Pu,b=new Pu,v=new Pu,_=new Pu;for(let e=0;e<s;e++){v.set(t[3*e],t[3*e+1],t[3*e+2]),y.set(m[3*e],m[3*e+1],m[3*e+2]),b.set(f[3*e],f[3*e+1],f[3*e+2]);const n=v.dot(y);_.copy(v).mulScalar(n),_.sub2(y,_).normalize(),g[4*e]=_.x,g[4*e+1]=_.y,g[4*e+2]=_.z,_.cross(v,y),g[4*e+3]=_.dot(b)<0?-1:1}return g}function ly(e,t,n){const a=new iy(e);return a.setPositions(t),n&&(n.normals&&a.setNormals(n.normals),n.tangents&&a.setVertexStream("TANGENT",n.tangents,4),n.colors&&a.setColors32(n.colors),n.uvs&&a.setUvs(0,n.uvs),n.uvs1&&a.setUvs(1,n.uvs1),n.blendIndices&&a.setVertexStream("BLENDINDICES",n.blendIndices,4,n.blendIndices.length/4,1),n.blendWeights&&a.setVertexStream("BLENDWEIGHT",n.blendWeights,4),n.indices&&a.setIndices(n.indices)),a.update(),a}function cy(e,t,n,a,i,s){const r=new Pu,o=new Pu,l=new Pu,c=new Pu,h=new Pu,d=new Pu,p=[],u=[],m=[],f=[],g=[];let y;if(n>0)for(let s=0;s<=a;s++)for(let y=0;y<=i;y++){const b=y/i*2*Math.PI-Math.PI,v=Math.sin(b),_=Math.cos(b);h.set(v*e,-n/2,_*e),c.set(v*t,n/2,_*t),r.lerp(h,c,s/a),o.sub2(c,h).normalize(),d.set(_,0,-v),l.cross(d,o).normalize(),p.push(r.x,r.y,r.z),u.push(l.x,l.y,l.z);let w=y/i,x=s/a;m.push(w,1-x);const C=x;if(x=w,w=C,w=.875*w+.0625,x=.875*x+.0625,w/=3,f.push(w,1-x),s<a&&y<i){const e=s*(i+1)+y,t=s*(i+1)+(y+1),n=(s+1)*(i+1)+y,a=(s+1)*(i+1)+(y+1);g.push(e,t,n),g.push(t,a,n)}}if(s){const e=Math.floor(i/2),s=i,r=n/2;for(let n=0;n<=e;n++){const a=n*Math.PI*.5/e,i=Math.sin(a),o=Math.cos(a);for(let a=0;a<=s;a++){const l=2*a*Math.PI/s-Math.PI/2,c=Math.sin(l),h=Math.cos(l)*i,d=o,g=c*i;let y=1-a/s,b=1-n/e;p.push(h*t,d*t+r,g*t),u.push(h,d,g),m.push(y,1-b),y=.875*y+.0625,b=.875*b+.0625,y/=3,b/=3,y+=1/3,f.push(y,1-b)}}y=(a+1)*(i+1);for(let t=0;t<e;++t)for(let e=0;e<s;++e){const n=t*(s+1)+e,a=n+s+1;g.push(y+n+1,y+a,y+n),g.push(y+n+1,y+a+1,y+a)}for(let n=0;n<=e;n++){const a=.5*Math.PI+n*Math.PI*.5/e,i=Math.sin(a),o=Math.cos(a);for(let a=0;a<=s;a++){const l=2*a*Math.PI/s-Math.PI/2,c=Math.sin(l),h=Math.cos(l)*i,d=o,g=c*i;let y=1-a/s,b=1-n/e;p.push(h*t,d*t-r,g*t),u.push(h,d,g),m.push(y,1-b),y=.875*y+.0625,b=.875*b+.0625,y/=3,b/=3,y+=2/3,f.push(y,1-b)}}y=(a+1)*(i+1)+(s+1)*(e+1);for(let t=0;t<e;++t)for(let e=0;e<s;++e){const n=t*(s+1)+e,a=n+s+1;g.push(y+n+1,y+a,y+n),g.push(y+n+1,y+a+1,y+a)}}else{if(y=(a+1)*(i+1),e>0)for(let t=0;t<i;t++){const a=t/i*2*Math.PI,s=Math.sin(a),r=-n/2,o=Math.cos(a);let l=1-(s+1)/2,c=(o+1)/2;p.push(s*e,r,o*e),u.push(0,-1,0),m.push(l,1-c),l=.875*l+.0625,c=.875*c+.0625,l/=3,c/=3,l+=1/3,f.push(l,1-c),t>1&&g.push(y,y+t,y+t-1)}if(y+=i,t>0)for(let e=0;e<i;e++){const a=e/i*2*Math.PI,s=Math.sin(a),r=n/2,o=Math.cos(a);let l=1-(s+1)/2,c=(o+1)/2;p.push(s*t,r,o*t),u.push(0,1,0),m.push(l,1-c),l=.875*l+.0625,c=.875*c+.0625,l/=3,c/=3,l+=2/3,f.push(l,1-c),e>1&&g.push(y,y+e-1,y+e)}}return{positions:p,normals:u,uvs:m,uvs1:f,indices:g}}function hy(e,t){let n=t&&(t.radius||t.baseRadius);n=void 0!==n?n:.5;const a=t&&void 0!==t.height?t.height:1,i=t&&void 0!==t.heightSegments?t.heightSegments:5,s=t&&void 0!==t.capSegments?t.capSegments:20,r=!(!t||void 0===t.calculateTangents)&&t.calculateTangents,o=cy(n,n,a,i,s,!1);return r&&(o.tangents=oy(o.positions,o.normals,o.uvs,o.indices)),ly(e,o.positions,o)}function dy(e,t){const n=t&&void 0!==t.radius?t.radius:.5,a=t&&void 0!==t.latitudeBands?t.latitudeBands:16,i=t&&void 0!==t.longitudeBands?t.longitudeBands:16,s=!(!t||void 0===t.calculateTangents)&&t.calculateTangents,r=[],o=[],l=[],c=[];for(let e=0;e<=a;e++){const t=e*Math.PI/a,s=Math.sin(t),c=Math.cos(t);for(let t=0;t<=i;t++){const h=2*t*Math.PI/i-Math.PI/2,d=Math.sin(h),p=Math.cos(h)*s,u=c,m=d*s,f=1-t/i,g=1-e/a;r.push(p*n,u*n,m*n),o.push(p,u,m),l.push(f,1-g)}}for(let e=0;e<a;++e)for(let t=0;t<i;++t){const n=e*(i+1)+t,a=n+i+1;c.push(n+1,a,n),c.push(n+1,a+1,a)}const h={normals:o,uvs:l,uvs1:l,indices:c};return s&&(h.tangents=oy(r,o,l,c)),ly(e,r,h)}function py(e,t){const n=t&&void 0!==t.halfExtents?t.halfExtents:new Pu(.5,.5,.5),a=t&&void 0!==t.widthSegments?t.widthSegments:1,i=t&&void 0!==t.lengthSegments?t.lengthSegments:1,s=t&&void 0!==t.heightSegments?t.heightSegments:1,r=!(!t||void 0===t.calculateTangents)&&t.calculateTangents,o=[new Pu(-n.x,-n.y,n.z),new Pu(n.x,-n.y,n.z),new Pu(n.x,n.y,n.z),new Pu(-n.x,n.y,n.z),new Pu(n.x,-n.y,-n.z),new Pu(-n.x,-n.y,-n.z),new Pu(-n.x,n.y,-n.z),new Pu(n.x,n.y,-n.z)],l=[[0,1,3],[4,5,7],[3,2,6],[1,0,4],[1,4,2],[5,0,6]],c=[[0,0,1],[0,0,-1],[0,1,0],[0,-1,0],[1,0,0],[-1,0,0]],h=1,d=2,p=3,u=4,m=5,f=[],g=[],y=[],b=[],v=[];let _=0;const w=(e,t,n)=>{const a=new Pu,i=new Pu,s=new Pu,r=new Pu;for(let h=0;h<=t;h++)for(let d=0;d<=n;d++){a.lerp(o[l[e][0]],o[l[e][1]],h/t),i.lerp(o[l[e][0]],o[l[e][2]],d/n),s.sub2(i,o[l[e][0]]),r.add2(a,s);let p=h/t,u=d/n;f.push(r.x,r.y,r.z),g.push(c[e][0],c[e][1],c[e][2]),y.push(p,1-u),p=.875*p+.0625,u=.875*u+.0625,p/=3,u/=3,p+=e%3/3,u+=Math.floor(e/3)/3,b.push(p,1-u),h<t&&d<n&&(v.push(_+n+1,_+1,_),v.push(_+n+1,_+n+2,_+1)),_++}};w(0,a,s),w(h,a,s),w(d,a,i),w(p,a,i),w(u,i,s),w(m,i,s);const x={normals:g,uvs:y,uvs1:b,indices:v};return r&&(x.tangents=oy(f,g,y,v)),ly(e,f,x)}function uy(e,t){let n=null;for(let a=0;a<sy.length;a++)sy[a].type===t&&sy[a].device===e&&(n=sy[a].primData);if(!n){let a,i;switch(t){case"box":a=py(e,{halfExtents:new Pu(.5,.5,.5)}),i={x:2,y:2,z:2,uv:2/3};break;case"capsule":a=function(e,t){const n=t&&void 0!==t.radius?t.radius:.3,a=t&&void 0!==t.height?t.height:1,i=t&&void 0!==t.heightSegments?t.heightSegments:1,s=t&&void 0!==t.sides?t.sides:20,r=!(!t||void 0===t.calculateTangents)&&t.calculateTangents,o=cy(n,n,a-2*n,i,s,!0);return r&&(o.tangents=oy(o.positions,o.normals,o.uvs,o.indices)),ly(e,o.positions,o)}(e,{radius:.5,height:2}),i={x:2*Math.PI,y:Math.PI,z:2*Math.PI,uv:1/3+1/3/3*2};break;case"cone":a=function(e,t){const n=t&&void 0!==t.baseRadius?t.baseRadius:.5,a=t&&void 0!==t.peakRadius?t.peakRadius:0,i=t&&void 0!==t.height?t.height:1,s=t&&void 0!==t.heightSegments?t.heightSegments:5,r=t&&void 0!==t.capSegments?t.capSegments:18,o=!(!t||void 0===t.calculateTangents)&&t.calculateTangents,l=cy(n,a,i,s,r,!1);return o&&(l.tangents=oy(l.positions,l.normals,l.uvs,l.indices)),ly(e,l.positions,l)}(e,{baseRadius:.5,peakRadius:0,height:1}),i={x:2.54,y:2.54,z:2.54,uv:1/3+1/3/3};break;case"cylinder":a=hy(e,{radius:.5,height:1}),i={x:Math.PI,y:1.58,z:Math.PI,uv:1/3+1/3/3*2};break;case"plane":a=function(e,t){const n=t&&void 0!==t.halfExtents?t.halfExtents:new Du(.5,.5),a=t&&void 0!==t.widthSegments?t.widthSegments:5,i=t&&void 0!==t.lengthSegments?t.lengthSegments:5,s=!(!t||void 0===t.calculateTangents)&&t.calculateTangents,r=[],o=[],l=[],c=[];let h=0;for(let e=0;e<=a;e++)for(let t=0;t<=i;t++){const s=-n.x+2*n.x*e/a,d=0,p=-(-n.y+2*n.y*t/i),u=e/a,m=t/i;r.push(s,d,p),o.push(0,1,0),l.push(u,1-m),e<a&&t<i&&(c.push(h+i+1,h+1,h),c.push(h+i+1,h+i+2,h+1)),h++}const d={normals:o,uvs:l,uvs1:l,indices:c};return s&&(d.tangents=oy(r,o,l,c)),ly(e,r,d)}(e,{halfExtents:new Du(.5,.5),widthSegments:1,lengthSegments:1}),i={x:0,y:1,z:0,uv:1};break;case"sphere":a=dy(e,{radius:.5}),i={x:Math.PI,y:Math.PI,z:Math.PI,uv:1};break;default:throw new Error("Invalid primitive type: "+t)}a.incRefCount(),n={mesh:a,area:i},sy.push({type:t,device:e,primData:n})}return n}class my extends Jf{constructor(){super(),this.color=new Mu(1,1,1,1),this.colorUniform=new Float32Array(4),this.colorMap=null,this.vertexColors=!1}copy(e){return super.copy(e),this.color.copy(e.color),this.colorMap=e.colorMap,this.vertexColors=e.vertexColors,this}updateUniforms(e,t){this.clearParameters(),this.colorUniform[0]=this.color.r,this.colorUniform[1]=this.color.g,this.colorUniform[2]=this.color.b,this.colorUniform[3]=this.color.a,this.setParameter("uColor",this.colorUniform),this.colorMap&&this.setParameter("texture_diffuseMap",this.colorMap)}updateShader(e,t,n,a,i,s){const r={skin:n&&0!=(2&n),screenSpace:n&&0!=(256&n),useInstancing:n&&0!=(32&n),useMorphPosition:n&&0!=(1024&n),useMorphNormal:n&&0!=(2048&n),useMorphTextureBased:n&&0!=(4096&n),vertexColors:this.vertexColors,diffuseMap:!!this.colorMap,pass:i},o=e.getProgramLibrary();this.shader=o.getProgram("basic",r)}}class fy{constructor(e,t,n){this.origMeshInstances=e,this._aabb=new qu,this.meshInstance=null,this.dynamic=t,this.batchGroupId=n}destroy(e,t){this.meshInstance&&(this.removeFromLayers(e,t),this.meshInstance.destroy())}addToLayers(e,t){for(let n=0;n<t.length;n++){const a=e.layers.getLayerById(t[n]);a&&a.addMeshInstances([this.meshInstance])}}removeFromLayers(e,t){for(let n=0;n<t.length;n++){const a=e.layers.getLayerById(t[n]);a&&a.removeMeshInstances([this.meshInstance])}}updateBoundingBox(){this._aabb.copy(this.origMeshInstances[0].aabb);for(let e=1;e<this.origMeshInstances.length;e++)this._aabb.add(this.origMeshInstances[e].aabb);this.meshInstance.aabb=this._aabb,this.meshInstance._aabbVer=0}}class gy{constructor(e,t,n,a,i=[0]){this.dynamic=n,this.maxAabbSize=a,this.id=e,this.name=t,this.layers=i,this._ui=!1,this._sprite=!1,this._obj={model:[],element:[],sprite:[],render:[]}}}gy.MODEL="model",gy.ELEMENT="element",gy.SPRITE="sprite",gy.RENDER="render";const yy=new zu;class by{constructor(e){this.bones=void 0,this._dirty=!0,this._rootBone=null,this._skinUpdateIndex=-1,this._updateBeforeCull=!0,e&&this.initSkin(e)}set rootBone(e){this._rootBone=e}get rootBone(){return this._rootBone}init(e,t){if(e.supportsBoneTextures){const n=3*t;let a=Math.ceil(Math.sqrt(n));a=Eu.roundUp(a,3);const i=Math.ceil(n/a);this.boneTexture=new Gm(e,{width:a,height:i,format:14,mipmaps:!1,minFilter:0,magFilter:0}),this.boneTexture.name="skin",this.matrixPalette=this.boneTexture.lock()}else this.matrixPalette=new Float32Array(12*t)}destroy(){this.boneTexture&&(this.boneTexture.destroy(),this.boneTexture=null)}resolve(e,t){this.rootBone=e;const n=this.skin,a=[];for(let i=0;i<n.boneNames.length;i++){const s=n.boneNames[i];let r=e.findByName(s);r||(r=t),a.push(r)}this.bones=a}initSkin(e){this.skin=e,this.bones=[];const t=e.inverseBindPose.length;this.init(e.device,t),this.matrices=[];for(let e=0;e<t;e++)this.matrices[e]=new zu}uploadBones(e){e.supportsBoneTextures&&(this.boneTexture.lock(),this.boneTexture.unlock())}_updateMatrices(e,t){if(this._skinUpdateIndex!==t){this._skinUpdateIndex=t,yy.copy(e.getWorldTransform()).invert();for(let e=this.bones.length-1;e>=0;e--)this.matrices[e].mulAffine2(yy,this.bones[e].getWorldTransform()),this.matrices[e].mulAffine2(this.matrices[e],this.skin.inverseBindPose[e])}}updateMatrices(e,t){this._updateBeforeCull&&this._updateMatrices(e,t)}updateMatrixPalette(e,t){this._updateMatrices(e,t);const n=this.matrixPalette,a=this.bones.length;for(let e=0;e<a;e++){const t=this.matrices[e].data,a=12*e;n[a]=t[0],n[a+1]=t[4],n[a+2]=t[8],n[a+3]=t[12],n[a+4]=t[1],n[a+5]=t[5],n[a+6]=t[9],n[a+7]=t[13],n[a+8]=t[2],n[a+9]=t[6],n[a+10]=t[10],n[a+11]=t[14]}this.uploadBones(this.skin.device)}}class vy extends by{constructor(e,t,n){super();const a=t.length;this.init(e,a),this.device=e,this.rootNode=n,this.bones=t}updateMatrices(e,t){}updateMatrixPalette(e,t){const n=this.matrixPalette,a=this.bones.length;for(let e=0;e<a;e++){const t=this.bones[e].getWorldTransform().data,a=12*e;n[a]=t[0],n[a+1]=t[4],n[a+2]=t[8],n[a+3]=t[12],n[a+4]=t[1],n[a+5]=t[5],n[a+6]=t[9],n[a+7]=t[13],n[a+8]=t[2],n[a+9]=t[6],n[a+10]=t[10],n[a+11]=t[14]}this.uploadBones(this.device)}}class _y{static incRef(e){this.cache.incRef(e)}static decRef(e){this.cache.decRef(e)}static destroy(){this.cache.destroy()}}_y.cache=new class{constructor(){this.cache=new Map}destroy(){this.cache.forEach(((e,t)=>{t.destroy()})),this.cache.clear()}incRef(e){const t=(this.cache.get(e)||0)+1;this.cache.set(e,t)}decRef(e){if(e){let t=this.cache.get(e);t&&(t--,0===t?(this.cache.delete(e),e.destroy()):this.cache.set(e,t))}}};const wy=new qu,xy=new qu,Cy=new $u,Ty=new Set;class Ey{constructor(e){this.vertexBuffer=null,this.count=e}}class Sy{constructor(e,t,n){this._key=[],this._key[0]=My(e,t,!0,0),this.command=n}set key(e){this._key[0]=e}get key(){return this._key[0]}}class Ay{constructor(e,t,n=null){if(this._material=void 0,e instanceof hf){const a=e;e=t,t=n,n=a}this._key=[0,0],this._shader=[null,null,null],this.isStatic=!1,this._staticLightList=null,this._staticSource=null,this.node=n,this._mesh=e,e.incRefCount(),this.material=t,this._shaderDefs=65536,this._shaderDefs|=e.vertexBuffer.format.hasUv0?4:0,this._shaderDefs|=e.vertexBuffer.format.hasUv1?8:0,this._shaderDefs|=e.vertexBuffer.format.hasColor?16:0,this._shaderDefs|=e.vertexBuffer.format.hasTangents?512:0,this._lightHash=0,this.visible=!0,this.layer=15,this._renderStyle=0,this.castShadow=!1,this._receiveShadow=!0,this._screenSpace=!1,this._noDepthDrawGl1=!1,this.cull=!0,this.pick=!0,this._updateAabb=!0,this._updateAabbFunc=null,this._calculateSortDistance=null,this.updateKey(),this._skinInstance=null,this._morphInstance=null,this.instancingData=null,this._customAabb=null,this.aabb=new qu,this._aabbVer=-1,this.drawOrder=0,this.visibleThisFrame=!1,this.isVisibleFunc=null,this.parameters={},this.stencilFront=null,this.stencilBack=null,this.flipFaces=!1}set renderStyle(e){this._renderStyle=e,this.mesh.prepareRenderState(e)}get renderStyle(){return this._renderStyle}set mesh(e){e!==this._mesh&&(this._mesh&&this._mesh.decRefCount(),this._mesh=e,e&&e.incRefCount())}get mesh(){return this._mesh}set aabb(e){this._aabb=e}get aabb(){if(!this._updateAabb)return this._aabb;if(this._updateAabbFunc)return this._updateAabbFunc(this._aabb);let e=this._customAabb,t=!!e;if(!e)if(e=wy,this.skinInstance){if(!this.mesh.boneAabb){const e=this._morphInstance?this._morphInstance.morph._targets:null;this.mesh._initBoneAabbs(e)}const n=this.mesh.boneUsed;let a=!0;for(let t=0;t<this.mesh.boneAabb.length;t++)n[t]&&(xy.setFromTransformedAabb(this.mesh.boneAabb[t],this.skinInstance.matrices[t]),a?(a=!1,e.center.copy(xy.center),e.halfExtents.copy(xy.halfExtents)):e.add(xy));t=!0}else this.node._aabbVer!==this._aabbVer&&(this.mesh?(e.center.copy(this.mesh.aabb.center),e.halfExtents.copy(this.mesh.aabb.halfExtents)):(e.center.set(0,0,0),e.halfExtents.set(0,0,0)),this.mesh&&this.mesh.morph&&e._expand(this.mesh.morph.aabb.getMin(),this.mesh.morph.aabb.getMax()),t=!0,this._aabbVer=this.node._aabbVer);return t&&this._aabb.setFromTransformedAabb(e,this.node.getWorldTransform()),this._aabb}set material(e){for(let e=0;e<this._shader.length;e++)this._shader[e]=null;const t=this._material;if(t&&t.removeMeshInstanceRef(this),this._material=e,this._material){this._material.addMeshInstanceRef(this),this.updateKey();if((t&&3!==t.blendType)!==(3!==this._material.blendType)){let e=this._material._scene;!e&&t&&t._scene&&(e=t._scene),e?e.layers._dirtyBlend=!0:this._material._dirtyBlend=!0}}}get material(){return this._material}set layer(e){this._layer=e,this.updateKey()}get layer(){return this._layer}set calculateSortDistance(e){this._calculateSortDistance=e}get calculateSortDistance(){return this._calculateSortDistance}set receiveShadow(e){this._receiveShadow=e,this._shaderDefs=e?-2&this._shaderDefs:1|this._shaderDefs,this._shader[0]=null,this._shader[1]=null}get receiveShadow(){return this._receiveShadow}set skinInstance(e){this._skinInstance=e,this._shaderDefs=e?2|this._shaderDefs:-3&this._shaderDefs;for(let e=0;e<this._shader.length;e++)this._shader[e]=null;this._setupSkinUpdate()}get skinInstance(){return this._skinInstance}set morphInstance(e){this._morphInstance=e,this._morphInstance&&(this._morphInstance.meshInstance=this),this._shaderDefs=e&&e.morph.useTextureMorph?4096|this._shaderDefs:-4097&this._shaderDefs,this._shaderDefs=e&&e.morph.morphPositions?1024|this._shaderDefs:-1025&this._shaderDefs,this._shaderDefs=e&&e.morph.morphNormals?2048|this._shaderDefs:-2049&this._shaderDefs;for(let e=0;e<this._shader.length;e++)this._shader[e]=null}get morphInstance(){return this._morphInstance}set screenSpace(e){this._screenSpace=e,this._shaderDefs=e?256|this._shaderDefs:-257&this._shaderDefs,this._shader[0]=null}get screenSpace(){return this._screenSpace}set key(e){this._key[0]=e}get key(){return this._key[0]}set mask(e){const t=65535&this._shaderDefs;this._shaderDefs=t|e<<16,this._shader[0]=null,this._shader[1]=null}get mask(){return this._shaderDefs>>16}set instancingCount(e){this.instancingData&&(this.instancingData.count=e)}get instancingCount(){return this.instancingData?this.instancingData.count:0}destroy(){const e=this.mesh;e&&(this.mesh=null,e.refCount<1&&e.destroy()),this.setRealtimeLightmap(Ay.lightmapParamNames[0],null),this.setRealtimeLightmap(Ay.lightmapParamNames[1],null),this._skinInstance&&(this._skinInstance.destroy(),this._skinInstance=null),this.morphInstance&&(this.morphInstance.destroy(),this.morphInstance=null),this.material=null}static _prepareRenderStyleForArray(e,t){if(e){for(let n=0;n<e.length;n++){e[n]._renderStyle=t;const a=e[n].mesh;Ty.has(a)||(Ty.add(a),a.prepareRenderState(t))}Ty.clear()}}_isVisible(e){return!!this.visible&&(this.isVisibleFunc?this.isVisibleFunc(e):(Cy.center=this.aabb.center,Cy.radius=this._aabb.halfExtents.length(),e.frustum.containsSphere(Cy)))}updateKey(){const e=this.material;this._key[0]=My(this.layer,e.alphaToCoverage||e.alphaTest?2:e.blendType,!1,e.id)}setInstancing(e){e?(this.instancingData=new Ey(e.numVertices),this.instancingData.vertexBuffer=e,e.instancing=!0,this.cull=!1):(this.instancingData=null,this.cull=!0)}clearParameters(){this.parameters={}}getParameters(){return this.parameters}getParameter(e){return this.parameters[e]}setParameter(e,t,n=-262141){if(void 0===t&&"object"==typeof e){const n=e;if(n.length){for(let e=0;e<n.length;e++)this.setParameter(n[e]);return}e=n.name,t=n.value}const a=this.parameters[e];a?(a.data=t,a.passFlags=n):this.parameters[e]={scopeId:null,data:t,passFlags:n}}setRealtimeLightmap(e,t){const n=this.getParameter(e);n!==t&&(n&&_y.decRef(n.data),t?(_y.incRef(t),this.setParameter(e,t)):this.deleteParameter(e))}deleteParameter(e){this.parameters[e]&&delete this.parameters[e]}setParameters(e,t){const n=this.parameters;for(const a in n){const i=n[a];i.passFlags&t&&(i.scopeId||(i.scopeId=e.scope.resolve(a)),i.scopeId.setValue(i.data))}}setLightmapped(e){e?this.mask=-6&(2|this.mask):(this.setRealtimeLightmap(Ay.lightmapParamNames[0],null),this.setRealtimeLightmap(Ay.lightmapParamNames[1],null),this._shaderDefs&=-8385,this.mask=-7&(1|this.mask))}setCustomAabb(e){e?this._customAabb?this._customAabb.copy(e):this._customAabb=e.clone():(this._customAabb=null,this._aabbVer=-1),this._setupSkinUpdate()}_setupSkinUpdate(){this._skinInstance&&(this._skinInstance._updateBeforeCull=!this._customAabb)}}function My(e,t,n,a){return(15&e)<<27|(3===t?1:0)<<26|(n?1:0)<<25|(33554431&a)<<0}function Ly(e,t){if(e&&!t)return!1;if(!e&&t)return!1;if((e=e.data)===(t=t.data))return!0;if(e instanceof Float32Array&&t instanceof Float32Array){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function Ry(e,t){for(const n in e)if(e.hasOwnProperty(n)&&!Ly(e[n],t[n]))return!1;for(const n in t)if(t.hasOwnProperty(n)&&!Ly(t[n],e[n]))return!1;return!0}function Iy(e,t){for(let n=0;n<e.length;n++)if(t.indexOf(e[n])<0)return!1;for(let n=0;n<t.length;n++)if(e.indexOf(t[n])<0)return!1;return!0}Ay.lightmapParamNames=["texture_lightMap","texture_dirLightMap"];const Py=new ku,ky=new Pu,Dy=new Pu,Oy=new Pu;function Fy(e){const t=e.node.worldTransform;return t.getX(ky),t.getY(Dy),t.getZ(Oy),ky.cross(ky,Dy),ky.dot(Oy)>=0?1:-1}class Ny{constructor(e,t,n){this.device=e,this.rootNode=t,this.scene=n,this._init=!1,this._batchGroups={},this._batchGroupCounter=0,this._batchList=[],this._dirtyGroups=[]}destroy(){this.device=null,this.rootNode=null,this.scene=null,this._batchGroups={},this._batchList=[],this._dirtyGroups=[]}addGroup(e,t,n,a,i){if(void 0===a&&(a=this._batchGroupCounter,this._batchGroupCounter++),this._batchGroups[a])return;const s=new gy(a,e,t,n,i);return this._batchGroups[a]=s,s}removeGroup(e){if(!this._batchGroups[e])return;const t=[];for(let n=0;n<this._batchList.length;n++)this._batchList[n].batchGroupId===e?this.destroyBatch(this._batchList[n]):t.push(this._batchList[n]);this._batchList=t,this._removeModelsFromBatchGroup(this.rootNode,e),delete this._batchGroups[e]}markGroupDirty(e){this._dirtyGroups.indexOf(e)<0&&this._dirtyGroups.push(e)}getGroupByName(e){const t=this._batchGroups;for(const n in t)if(t.hasOwnProperty(n)&&t[n].name===e)return t[n];return null}getBatches(e){const t=[],n=this._batchList.length;for(let a=0;a<n;a++){const n=this._batchList[a];n.batchGroupId===e&&t.push(n)}return t}_removeModelsFromBatchGroup(e,t){if(e.enabled){e.model&&e.model.batchGroupId===t&&(e.model.batchGroupId=-1),e.render&&e.render.batchGroupId===t&&(e.render.batchGroupId=-1),e.element&&e.element.batchGroupId===t&&(e.element.batchGroupId=-1),e.sprite&&e.sprite.batchGroupId===t&&(e.sprite.batchGroupId=-1);for(let n=0;n<e._children.length;n++)this._removeModelsFromBatchGroup(e._children[n],t)}}insert(e,t,n){const a=this._batchGroups[t];a&&a._obj[e].indexOf(n)<0&&(a._obj[e].push(n),this.markGroupDirty(t))}remove(e,t,n){const a=this._batchGroups[t];if(a){const i=a._obj[e].indexOf(n);i>=0&&(a._obj[e].splice(i,1),this.markGroupDirty(t))}}_extractRender(e,t,n,a){if(e.render){if(e.render.isStatic){const n=this.scene.drawCalls,a=e.render.meshInstances;for(let e=0;e<n.length;e++)n[e]._staticSource&&(a.indexOf(n[e]._staticSource)<0||t.push(n[e]));for(let e=0;e<a.length;e++)n.indexOf(a[e])>=0&&t.push(a[e])}else t=a[e.render.batchGroupId]=t.concat(e.render.meshInstances);e.render.removeFromLayers()}return t}_extractModel(e,t,n,a){if(e.model&&e.model.model){if(e.model.isStatic){const n=this.scene.drawCalls,a=e.model.meshInstances;for(let e=0;e<n.length;e++)n[e]._staticSource&&(a.indexOf(n[e]._staticSource)<0||t.push(n[e]));for(let e=0;e<a.length;e++)n.indexOf(a[e])>=0&&t.push(a[e])}else t=a[e.model.batchGroupId]=t.concat(e.model.meshInstances);e.model.removeModelFromLayers()}return t}_extractElement(e,t,n){if(!e.element)return;let a=!1;e.element._text&&e.element._text._model.meshInstances.length>0?(t.push(e.element._text._model.meshInstances[0]),e.element.removeModelFromLayers(e.element._text._model),a=!0):e.element._image&&(t.push(e.element._image._renderable.meshInstance),e.element.removeModelFromLayers(e.element._image._renderable.model),e.element._image._renderable.unmaskMeshInstance&&(t.push(e.element._image._renderable.unmaskMeshInstance),e.element._image._renderable.unmaskMeshInstance.stencilFront&&e.element._image._renderable.unmaskMeshInstance.stencilBack||(e.element._dirtifyMask(),e.element._onPrerender())),a=!0),a&&(n._ui=!0)}_collectAndRemoveMeshInstances(e,t){for(let n=0;n<t.length;n++){const a=t[n],i=this._batchGroups[a];if(!i)continue;let s=e[a];s||(s=e[a]=[]);for(let t=0;t<i._obj.model.length;t++)s=this._extractModel(i._obj.model[t],s,i,e);for(let t=0;t<i._obj.render.length;t++)s=this._extractRender(i._obj.render[t],s,i,e);for(let e=0;e<i._obj.element.length;e++)this._extractElement(i._obj.element[e],s,i);for(let e=0;e<i._obj.sprite.length;e++){const t=i._obj.sprite[e];t.sprite&&t.sprite._meshInstance&&(i.dynamic||0===t.sprite.sprite._renderMode)&&(s.push(t.sprite._meshInstance),t.sprite.removeModelFromLayers(),i._sprite=!0,t.sprite._batchGroup=i)}}}generate(e){const t={};e||(e=Object.keys(this._batchGroups));const n=[];for(let t=0;t<this._batchList.length;t++)e.indexOf(this._batchList[t].batchGroupId)<0?n.push(this._batchList[t]):this.destroyBatch(this._batchList[t]);if(this._batchList=n,this._collectAndRemoveMeshInstances(t,e),e===this._dirtyGroups)this._dirtyGroups.length=0;else{const t=[];for(let n=0;n<this._dirtyGroups.length;n++)e.indexOf(this._dirtyGroups[n])<0&&t.push(this._dirtyGroups[n]);this._dirtyGroups=t}let a,i,s,r;for(const e in t)if(t.hasOwnProperty(e)&&(a=t[e],s=this._batchGroups[e],s)){i=this.prepare(a,s.dynamic,s.maxAabbSize,s._ui||s._sprite);for(let t=0;t<i.length;t++)r=this.create(i[t],s.dynamic,parseInt(e,10)),r&&r.addToLayers(this.scene,s.layers)}}prepare(e,t,n=Number.POSITIVE_INFINITY,a){if(0===e.length)return[];const i=.5*n,s=this.device.supportsBoneTextures?1024:this.device.boneLimit,r=this.device.extUintElement?4294967295:65535,o=new qu,l=new qu;let c,h=null;const d=[];let p=0;a&&e.sort((function(e,t){return e.drawOrder-t.drawOrder}));let u,m=e;const f=a?function(e){h?h.add(e.aabb):h=e.aabb.clone(),u.push(e)}:function(e){u.push(e)};for(;m.length>0;){d[p]=[m[0]],u=[];const e=m[0].material,n=m[0].layer,g=m[0]._shaderDefs,y=m[0].parameters,b=m[0].stencilFront,v=m[0]._staticLightList;let _=m[0].mesh.vertexBuffer.getNumVertices();const w=m[0].drawOrder;o.copy(m[0].aabb);const x=Fy(m[0]),C=m[0].mesh.vertexBuffer.format.batchingHash,T=m[0].mesh.primitive[0].indexed;h=null;for(let E=1;E<m.length;E++){const S=m[E];if(t&&d[p].length>=s){u=u.concat(m.slice(E));break}if(e!==S.material||n!==S.layer||C!==S.mesh.vertexBuffer.format.batchingHash||T!==S.mesh.primitive[0].indexed||g!==S._shaderDefs||_+S.mesh.vertexBuffer.getNumVertices()>r){f(S);continue}if(l.copy(o),l.add(S.aabb),l.halfExtents.x>i||l.halfExtents.y>i||l.halfExtents.z>i){f(S);continue}if(b&&(!(c=S.stencilFront)||b.func!==c.func||b.zpass!==c.zpass)){f(S);continue}if(x!==Fy(S)){f(S);continue}if(!Ry(y,S.parameters)){f(S);continue}const A=S._staticLightList;if(v&&A){if(!Iy(v,A)){f(S);continue}}else if(v||A){f(S);continue}a&&h&&h.intersects(S.aabb)&&S.drawOrder!==w?f(S):(o.add(S.aabb),_+=S.mesh.vertexBuffer.getNumVertices(),d[p].push(S))}p++,m=u}return d}collectBatchedMeshData(e,t){let n=null,a=0,i=0,s=null;for(let r=0;r<e.length;r++)if(e[r].visible){const o=e[r].mesh;if(a+=o.vertexBuffer.numVertices,i+=o.primitive[0].indexed?o.primitive[0].count:6===o.primitive[0].type&&4===o.primitive[0].count?6:0,!n){s=e[r].material,n={};const a=o.vertexBuffer.format.elements;for(let e=0;e<a.length;e++){n[a[e].name]={numComponents:a[e].numComponents,dataType:a[e].dataType,normalize:a[e].normalize,count:0}}t&&(n.BLENDINDICES={numComponents:1,dataType:6,normalize:!1,count:0})}}return{streams:n,batchNumVerts:a,batchNumIndices:i,material:s}}create(e,t,n){if(!this._init){const e="#define BONE_LIMIT "+this.device.getBoneLimit()+"\n";this.transformVS=e+"#define DYNAMICBATCH\n"+gm.transformVS,this.skinTexVS=gm.skinBatchTexVS,this.skinConstVS=gm.skinBatchConstVS,this.vertexFormats={},this._init=!0}let a,i,s,r=null,o=null;const l=this.collectBatchedMeshData(e,t);if(l.streams){const c=l.streams;let h=l.material;const d=l.batchNumVerts,p=l.batchNumIndices;let u,m,f;o=new fy(e,t,n),this._batchList.push(o);let g,y=0,b=0;const v=new Pu,_=new(d<=65535?Uint16Array:Uint32Array)(p);for(a in c)r=c[a],r.typeArrayType=nm[r.dataType],r.elementByteSize=am[r.dataType],r.buffer=new r.typeArrayType(d*r.numComponents);for(let n=0;n<e.length;n++)if(e[n].visible){for(a in i=e[n].mesh,s=i.vertexBuffer.numVertices,t||(g=e[n].node.getWorldTransform()),c)if("BLENDINDICES"!==a){r=c[a];const e=new r.typeArrayType(r.buffer.buffer,r.elementByteSize*r.count),n=i.getVertexStream(a,e)*r.numComponents;if(r.count+=n,!t&&r.numComponents>=3)if("POSITION"===a)for(let t=0;t<n;t+=r.numComponents)v.set(e[t],e[t+1],e[t+2]),g.transformPoint(v,v),e[t]=v.x,e[t+1]=v.y,e[t+2]=v.z;else if("NORMAL"===a||"TANGENT"===a){g.invertTo3x3(Py),Py.transpose();for(let t=0;t<n;t+=r.numComponents)v.set(e[t],e[t+1],e[t+2]),Py.transformVector(v,v),e[t]=v.x,e[t+1]=v.y,e[t+2]=v.z}}if(t){r=c.BLENDINDICES;for(let e=0;e<s;e++)r.buffer[r.count++]=n}if(i.primitive[0].indexed){u=i.primitive[0].base,m=i.primitive[0].count;const e=i.indexBuffer[0].getFormat();f=new im[e](i.indexBuffer[0].storage)}else{if(6!==i.primitive[0].type||4!==i.primitive[0].count){m=0;continue}u=0,m=6,f=[0,1,3,2,3,1]}for(let e=0;e<m;e++)_[e+b]=f[u+e]+y;b+=m,y+=s}for(a in i=new iy(this.device),c)r=c[a],i.setVertexStream(a,r.buffer,r.numComponents,void 0,r.dataType,r.normalize);_.length>0&&i.setIndices(_),i.update(4,!1),t&&(h=h.clone(),h.chunks.transformVS=this.transformVS,h.chunks.skinTexVS=this.skinTexVS,h.chunks.skinConstVS=this.skinConstVS,h.update());const w=new Ay(i,h,this.rootNode);w.castShadow=o.origMeshInstances[0].castShadow,w.parameters=o.origMeshInstances[0].parameters,w.isStatic=o.origMeshInstances[0].isStatic,w.layer=o.origMeshInstances[0].layer,w._staticLightList=o.origMeshInstances[0]._staticLightList,w._shaderDefs=o.origMeshInstances[0]._shaderDefs,w.cull=o.origMeshInstances[0].cull;const x=this._batchGroups[n];if(x&&x._ui&&(w.cull=!1),t){const e=[];for(let t=0;t<o.origMeshInstances.length;t++)e.push(o.origMeshInstances[t].node);w.skinInstance=new vy(this.device,e,this.rootNode)}w._updateAabb=!1,w.drawOrder=o.origMeshInstances[0].drawOrder,w.stencilFront=o.origMeshInstances[0].stencilFront,w.stencilBack=o.origMeshInstances[0].stencilBack,w.flipFaces=Fy(o.origMeshInstances[0])<0,w.castShadow=o.origMeshInstances[0].castShadow,o.meshInstance=w,o.updateBoundingBox()}return o}updateAll(){this._dirtyGroups.length>0&&this.generate(this._dirtyGroups);for(let e=0;e<this._batchList.length;e++)this._batchList[e].dynamic&&this._batchList[e].updateBoundingBox()}clone(e,t){const n=new fy(t,e.dynamic,e.batchGroupId);this._batchList.push(n);const a=[];for(let e=0;e<t.length;e++)a.push(t[e].node);return n.meshInstance=new Ay(e.meshInstance.mesh,e.meshInstance.material,e.meshInstance.node),n.meshInstance._updateAabb=!1,n.meshInstance.parameters=t[0].parameters,n.meshInstance.isStatic=t[0].isStatic,n.meshInstance.cull=t[0].cull,n.meshInstance.layer=t[0].layer,n.meshInstance._staticLightList=t[0]._staticLightList,e.dynamic&&(n.meshInstance.skinInstance=new vy(this.device,a,this.rootNode)),n.meshInstance.castShadow=e.meshInstance.castShadow,n.meshInstance._shader=e.meshInstance._shader,n.meshInstance.castShadow=e.meshInstance.castShadow,n}destroyBatch(e){e.destroy(this.scene,this._batchGroups[e.batchGroupId].layers)}}const Vy=new Pu,By=new Pu,Uy=new Pu,zy=new qu;class Gy{constructor(){this.light=null,this.min=new Pu,this.max=new Pu}}class Hy{constructor(e){this.device=e,this.name="Untitled",this.reportCount=0,this.boundsMin=new Pu,this.boundsMax=new Pu,this.boundsDelta=new Pu,this._cells=new Pu(1,1,1),this._cellsLimit=new Pu,this.cells=this._cells,this._maxCellLightCount=0,this._pixelsPerCellCount=0,this.maxCellLightCount=4,this._maxAttenuation=0,this._maxColorValue=0,this._usedLights=[],this._usedLights.push(new Gy),this.lightsBuffer=new wf(e),this.registerUniforms(e)}set maxCellLightCount(e){const t=Eu.roundUp(e,4);t!==this._maxCellLightCount&&(this._maxCellLightCount=t,this._pixelsPerCellCount=this._maxCellLightCount/4,this._cellsDirty=!0)}get maxCellLightCount(){return this._maxCellLightCount}set cells(e){Vy.copy(e).floor(),this._cells.equals(Vy)||(this._cells.copy(Vy),this._cellsLimit.copy(Vy).sub(Pu.ONE),this._cellsDirty=!0)}get cells(){return this._cells}destroy(){this.lightsBuffer.destroy(),this.releaseClusterTexture()}releaseClusterTexture(){this.clusterTexture&&(this.clusterTexture.destroy(),this.clusterTexture=null)}registerUniforms(e){this._clusterWorldTextureId=e.scope.resolve("clusterWorldTexture"),this._clusterPixelsPerCellId=e.scope.resolve("clusterPixelsPerCell"),this._clusterTextureSizeId=e.scope.resolve("clusterTextureSize"),this._clusterTextureSizeData=new Float32Array(3),this._clusterBoundsMinId=e.scope.resolve("clusterBoundsMin"),this._clusterBoundsMinData=new Float32Array(3),this._clusterBoundsDeltaId=e.scope.resolve("clusterBoundsDelta"),this._clusterBoundsDeltaData=new Float32Array(3),this._clusterCellsCountByBoundsSizeId=e.scope.resolve("clusterCellsCountByBoundsSize"),this._clusterCellsCountByBoundsSizeData=new Float32Array(3),this._clusterCellsDotId=e.scope.resolve("clusterCellsDot"),this._clusterCellsDotData=new Float32Array(3),this._clusterCellsMaxId=e.scope.resolve("clusterCellsMax"),this._clusterCellsMaxData=new Float32Array(3),this._clusterCompressionLimit0Id=e.scope.resolve("clusterCompressionLimit0"),this._clusterCompressionLimit0Data=new Float32Array(2)}updateParams(e){e&&(this.cells=e.cells,this.maxCellLightCount=e.maxLightsPerCell,this.lightsBuffer.cookiesEnabled=e.cookiesEnabled,this.lightsBuffer.shadowsEnabled=e.shadowsEnabled,this.lightsBuffer.areaLightsEnabled=e.areaLightsEnabled)}updateCells(){if(this._cellsDirty){this._cellsDirty=!1;const e=this._cells.x,t=this._cells.y,n=this._cells.z,a=e*t*n,i=this._pixelsPerCellCount*a;let s=Math.ceil(Math.sqrt(i));s=Eu.roundUp(s,this._pixelsPerCellCount);const r=Math.ceil(i/s);this._clusterCellsMaxData[0]=e,this._clusterCellsMaxData[1]=t,this._clusterCellsMaxData[2]=n,this._clusterCellsDotData[0]=this._pixelsPerCellCount,this._clusterCellsDotData[1]=e*n*this._pixelsPerCellCount,this._clusterCellsDotData[2]=e*this._pixelsPerCellCount,this.clusters=new Uint8ClampedArray(4*i),this.counts=new Int32Array(a),this._clusterTextureSizeData[0]=s,this._clusterTextureSizeData[1]=1/s,this._clusterTextureSizeData[2]=1/r,this.releaseClusterTexture(),this.clusterTexture=wf.createTexture(this.device,s,r,7,"ClusterTexture")}}uploadTextures(){this.clusterTexture.lock().set(this.clusters),this.clusterTexture.unlock(),this.lightsBuffer.uploadTextures()}updateUniforms(){this.lightsBuffer.updateUniforms(),this._clusterWorldTextureId.setValue(this.clusterTexture);const e=this.boundsDelta;this._clusterCellsCountByBoundsSizeData[0]=this._cells.x/e.x,this._clusterCellsCountByBoundsSizeData[1]=this._cells.y/e.y,this._clusterCellsCountByBoundsSizeData[2]=this._cells.z/e.z,this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData),this._clusterBoundsMinData[0]=this.boundsMin.x,this._clusterBoundsMinData[1]=this.boundsMin.y,this._clusterBoundsMinData[2]=this.boundsMin.z,this._clusterBoundsDeltaData[0]=e.x,this._clusterBoundsDeltaData[1]=e.y,this._clusterBoundsDeltaData[2]=e.z,this._clusterCompressionLimit0Data[0]=this._maxAttenuation,this._clusterCompressionLimit0Data[1]=this._maxColorValue,this._clusterPixelsPerCellId.setValue(this._pixelsPerCellCount),this._clusterTextureSizeId.setValue(this._clusterTextureSizeData),this._clusterBoundsMinId.setValue(this._clusterBoundsMinData),this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData),this._clusterCellsDotId.setValue(this._clusterCellsDotData),this._clusterCellsMaxId.setValue(this._clusterCellsMaxData),this._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data)}evalLightCellMinMax(e,t,n){t.copy(e.min),t.sub(this.boundsMin),t.div(this.boundsDelta),t.mul2(t,this.cells),t.floor(),n.copy(e.max),n.sub(this.boundsMin),n.div(this.boundsDelta),n.mul2(n,this.cells),n.ceil(),t.max(Pu.ZERO),n.min(this._cellsLimit)}collectLights(e){const t=this.lightsBuffer.maxLights,n=this._usedLights;let a=1;for(let i=0;i<e.length;i++){const s=e[i],r=!!(3&s.mask);if(s.enabled&&0!==s.type&&s.visibleThisFrame&&s.intensity>0&&r){if(!(a<t)){console.warn(`Clustered lighting: more than ${t-1} lights in the frame, ignoring some.`);break}{let e;a<n.length?e=n[a]:(e=new Gy,n.push(e)),e.light=s,s.getBoundingBox(zy),e.min.copy(zy.getMin()),e.max.copy(zy.getMax()),a++}}}n.length=a}evaluateBounds(){const e=this._usedLights,t=this.boundsMin,n=this.boundsMax;if(e.length>1){t.copy(e[1].min),n.copy(e[1].max);for(let a=2;a<e.length;a++)t.min(e[a].min),n.max(e[a].max)}else t.set(0,0,0),n.set(1,1,1);this.boundsDelta.sub2(n,t),this.lightsBuffer.setBounds(t,this.boundsDelta)}evaluateCompressionLimits(e){let t=0,n=0;const a=this._usedLights;for(let i=1;i<a.length;i++){const s=a[i].light;t=Math.max(s.attenuationEnd,t);const r=e?s._linearFinalColor:s._finalColor;n=Math.max(r[0],n),n=Math.max(r[1],n),n=Math.max(r[2],n)}this._maxAttenuation=t+1e-6,this._maxColorValue=n+1e-6,this.lightsBuffer.setCompressionRanges(this._maxAttenuation,this._maxColorValue)}updateClusters(e){this.counts.fill(0),this.clusters.fill(0);const t=this._cells.x,n=this._cells.z,a=this.counts,i=this._maxCellLightCount,s=this.clusters,r=this._pixelsPerCellCount,o=this._usedLights;for(let l=1;l<o.length;l++){const c=o[l],h=c.light;this.lightsBuffer.addLightData(h,l,e),this.evalLightCellMinMax(c,By,Uy);const d=By.x,p=Uy.x,u=By.y,m=Uy.y,f=By.z,g=Uy.z;for(let e=d;e<=p;e++)for(let o=f;o<=g;o++)for(let c=u;c<=m;c++){const h=e+t*(o+c*n),d=a[h];d<i&&(s[r*h*4+d]=l,a[h]=d+1)}}}update(e,t,n){this.updateParams(n),this.updateCells(),this.collectLights(e),this.evaluateBounds(),this.evaluateCompressionLimits(t),this.updateClusters(t),this.uploadTextures()}activate(){this.updateUniforms()}}const Wy=new Ou;class jy{constructor(e,t){this.device=e,this.lightTextureAtlas=t,this.blitShader2d=null,this.blitShaderCube=null,this.blitTextureId=null,this.invViewProjId=null}destroy(){}getShader(e,t){return this[e]||(this[e]=Mm(this.device,"\n\t\tattribute vec2 vertex_position;\n\t\tvarying vec2 uv0;\n\t\tvoid main(void) {\n\t\t\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\t\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t\t}",t,`cookie_renderer_${e}`)),this.blitTextureId||(this.blitTextureId=this.device.scope.resolve("blitTexture")),this.invViewProjId||(this.invViewProjId=this.device.scope.resolve("invViewProj")),this[e]}get shader2d(){return this.getShader("blitShader2d","\n\t\tvarying vec2 uv0;\n\t\tuniform sampler2D blitTexture;\n\t\tvoid main(void) {\n\t\t\t\tgl_FragColor = texture2D(blitTexture, uv0);\n\t\t}")}get shaderCube(){return this.getShader("blitShaderCube","\n\t\tvarying vec2 uv0;\n\t\tuniform samplerCube blitTexture;\n\t\tuniform mat4 invViewProj;\n\t\tvoid main(void) {\n\t\t\t\tvec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);\n\t\t\t\tvec4 worldPos = invViewProj * projPos;\n\t\t\t\tgl_FragColor = textureCube(blitTexture, worldPos.xyz);\n\t\t}")}static createTexture(e,t){return new Gm(e,{name:"CookieAtlas",width:t,height:t,format:7,cubemap:!1,mipmaps:!1,minFilter:0,magFilter:0,addressU:1,addressV:1})}initInvViewProjMatrices(){if(!jy._invViewProjMatrices){jy._invViewProjMatrices=[];for(let e=0;e<6;e++){const t=mf.create(null,1,e),n=t.projectionMatrix,a=t.node.getLocalTransform().clone().invert();jy._invViewProjMatrices[e]=(new zu).mul2(n,a).invert()}}}render(e,t){if(e.enabled&&e.cookie&&e.visibleThisFrame){const n=e.numShadowFaces,a=n>1?this.shaderCube:this.shader2d,i=this.device;n>1&&this.initInvViewProjMatrices(),this.blitTextureId.setValue(e.cookie);for(let s=0;s<n;s++){if(Wy.copy(e.atlasViewport),n>1){const e=Wy.z/3,t=this.lightTextureAtlas.cubeSlotsOffsets[s];Wy.x+=e*t.x,Wy.y+=e*t.y,Wy.z=e,Wy.w=e,this.invViewProjId.setValue(jy._invViewProjMatrices[s].data)}Wy.mulScalar(t.colorBuffer.width),mm(i,t,a,Wy)}}}}jy._invViewProjMatrices=null;class Xy{constructor(e,t){this.texture=e,this.cached=!1,this.renderTargets=t}destroy(){this.texture&&(this.texture.destroy(),this.texture=null);const e=this.renderTargets;for(let t=0;t<e.length;t++)e[t].destroy();this.renderTargets.length=0}static getShadowFormat(e,t){return 3===t?14:2===t?12:4===t||0===t&&e.webgl2?16:7}static getShadowFiltering(e,t){return 0!==t||e.webgl2?3===t?e.extTextureFloatLinear?1:0:2===t?e.extTextureHalfFloatLinear?1:0:1:0}static create(e,t){let n=null;return n=1===t._type?this.createCubemap(e,t._shadowResolution):this.create2dMap(e,t._shadowResolution,t._shadowType),n}static createAtlas(e,t,n){const a=this.create2dMap(e,t,n),i=a.renderTargets,s=i[0];for(let e=0;e<5;e++)i.push(s);return a}static create2dMap(e,t,n){const a=this.getShadowFormat(e,n),i=this.getShadowFiltering(e,n),s=new Gm(e,{format:a,width:t,height:t,mipmaps:!1,minFilter:i,magFilter:i,addressU:1,addressV:1});s.name="ShadowMap2D";let r=null;return 4===n||0===n&&e.webgl2?(s.compareOnRead=!0,s.compareFunc=1,r=new Cg({depthBuffer:s})):r=new Cg({colorBuffer:s,depth:!0}),new Xy(s,[r])}static createCubemap(e,t){const n=new Gm(e,{format:7,width:t,height:t,cubemap:!0,mipmaps:!1,minFilter:0,magFilter:0,addressU:1,addressV:1});n.name="ShadowMapCube";const a=[];for(let e=0;e<6;e++){const t=new Cg({colorBuffer:n,face:e,depth:!0});a.push(t)}return new Xy(n,a)}}const Yy=[],qy=[],Ky=new Ou,Zy=new Ou;class $y{constructor(e){this.size=Math.floor(1024*e.w),this.used=!1,this.lightId=-1,this.rect=e}}class Qy{constructor(e){this.device=e,this.version=1,this.shadowAtlasResolution=2048,this.shadowAtlas=null,this.shadowEdgePixels=3,this.cookieAtlasResolution=2048,this.cookieAtlas=null,this.cookieRenderTarget=null,this.slots=[],this.atlasSplit=[],this.cubeSlotsOffsets=[new Du(0,0),new Du(0,1),new Du(1,0),new Du(1,1),new Du(2,0),new Du(2,1)],this.scissorVec=new Ou,this.allocateShadowAtlas(1),this.allocateCookieAtlas(1),this.allocateUniforms()}destroy(){this.destroyShadowAtlas(),this.destroyCookieAtlas()}destroyShadowAtlas(){this.shadowAtlas&&(this.shadowAtlas.destroy(),this.shadowAtlas=null)}destroyCookieAtlas(){this.cookieAtlas&&(this.cookieAtlas.destroy(),this.cookieAtlas=null),this.cookieRenderTarget&&(this.cookieRenderTarget.destroy(),this.cookieRenderTarget=null)}allocateShadowAtlas(e){if(!this.shadowAtlas||this.shadowAtlas.texture.width!==e){this.version++,this.destroyShadowAtlas(),this.shadowAtlas=Xy.createAtlas(this.device,e,0),this.shadowAtlas.cached=!0;const t=4/this.shadowAtlasResolution;this.scissorVec.set(t,t,-2*t,-2*t)}}allocateCookieAtlas(e){this.cookieAtlas&&this.cookieAtlas.width===e||(this.version++,this.destroyCookieAtlas(),this.cookieAtlas=jy.createTexture(this.device,e),this.cookieRenderTarget=new Cg({colorBuffer:this.cookieAtlas,depth:!1,flipY:!0}))}allocateUniforms(){this._shadowAtlasTextureId=this.device.scope.resolve("shadowAtlasTexture"),this._shadowAtlasParamsId=this.device.scope.resolve("shadowAtlasParams"),this._shadowAtlasParams=new Float32Array(2),this._cookieAtlasTextureId=this.device.scope.resolve("cookieAtlasTexture")}updateUniforms(){const e=this.shadowAtlas.renderTargets[0],t=this.device.webgl2?e.depthBuffer:e.colorBuffer;this._shadowAtlasTextureId.setValue(t),this._shadowAtlasParams[0]=this.shadowAtlasResolution,this._shadowAtlasParams[1]=this.shadowEdgePixels,this._shadowAtlasParamsId.setValue(this._shadowAtlasParams),this._cookieAtlasTextureId.setValue(this.cookieAtlas)}subdivide(e,t){let n=t.atlasSplit;if(!n){const t=Math.ceil(Math.sqrt(e));n=qy,n[0]=t,n.length=1}if(!((e,t)=>e.length===t.length&&e.every(((e,n)=>e===t[n])))(n,this.atlasSplit)){this.version++,this.slots.length=0,this.atlasSplit.length=0,this.atlasSplit.push(...n);const e=this.atlasSplit[0];if(e>1){const t=1/e;for(let n=0;n<e;n++)for(let a=0;a<e;a++){const i=new Ou(n*t,a*t,t,t),s=this.atlasSplit[1+n*e+a];if(s>1)for(let e=0;e<s;e++)for(let n=0;n<s;n++){const a=t/s,r=new Ou(i.x+e*a,i.y+n*a,a,a);this.slots.push(new $y(r))}else this.slots.push(new $y(i))}}else this.slots.push(new $y(new Ou(0,0,1,1)));this.slots.sort(((e,t)=>t.size-e.size))}}collectLights(e,t,n){const a=n.cookiesEnabled,i=n.shadowsEnabled;let s=!1,r=!1;const o=Yy;o.length=0;const l=e=>{for(let t=0;t<e.length;t++){const n=e[t];if(n.visibleThisFrame){const e=i&&n.castShadows,t=a&&!!n.cookie;s||(s=e),r||(r=t),(e||t)&&o.push(n)}}};return(a||i)&&(l(e),l(t)),o.sort(((e,t)=>t.maxScreenSize-e.maxScreenSize)),s&&this.allocateShadowAtlas(this.shadowAtlasResolution),r&&this.allocateCookieAtlas(this.cookieAtlasResolution),(s||r)&&this.subdivide(o.length,n),o}setupSlot(e,t){e.atlasViewport.copy(t);const n=e.numShadowFaces;for(let a=0;a<n;a++)if(e.castShadows||e._cookie){if(Ky.copy(t),Zy.copy(t),2===e._type&&Ky.add(this.scissorVec),1===e._type){const e=Ky.z/3,t=this.cubeSlotsOffsets[a];Ky.x+=e*t.x,Ky.y+=e*t.y,Ky.z=e,Ky.w=e,Zy.copy(Ky)}if(e.castShadows){const t=e.getRenderData(null,a);t.shadowViewport.copy(Ky),t.shadowScissor.copy(Zy)}}}assignSlot(e,t,n){e.atlasViewportAllocated=!0;const a=this.slots[t];a.lightId=e.id,a.used=!0,n&&(e.atlasSlotUpdated=!0,e.atlasVersion=this.version,e.atlasSlotIndex=t)}update(e,t,n){this.shadowAtlasResolution=n.shadowAtlasResolution,this.cookieAtlasResolution=n.cookieAtlasResolution;const a=this.collectLights(e,t,n);if(a.length>0){const e=this.slots;for(let t=0;t<e.length;t++)e[t].used=!1;const t=Math.min(a.length,e.length);for(let n=0;n<t;n++){const t=a[n];t.castShadows&&(t._shadowMap=this.shadowAtlas);const i=e[t.atlasSlotIndex];if(t.atlasVersion===this.version&&t.id===(null==i?void 0:i.lightId)){const a=e[t.atlasSlotIndex];a.size!==e[n].size||a.used||this.assignSlot(t,t.atlasSlotIndex,!1)}}let n=0;for(let i=0;i<t;i++){for(;n<e.length&&e[n].used;)n++;const t=a[i];t.atlasViewportAllocated||this.assignSlot(t,n,!0);const s=e[t.atlasSlotIndex];this.setupSlot(t,s.rect)}}this.updateUniforms()}}class Jy{constructor(){this.shadowMapCache=new Map}destroy(){this.clear(),this.shadowMapCache=null}clear(){this.shadowMapCache.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.shadowMapCache.clear()}getKey(e){return`${1===e._type}-${e._shadowType}-${e._shadowResolution}`}get(e,t){const n=this.getKey(t),a=this.shadowMapCache.get(n);if(a&&a.length)return a.pop();const i=Xy.create(e,t);return i.cached=!0,i}add(e,t){const n=this.getKey(e),a=this.shadowMapCache.get(n);a?a.push(t):this.shadowMapCache.set(n,[t])}}const eb=[new Pu,new Pu,new Pu,new Pu,new Pu,new Pu,new Pu,new Pu],tb={min:0,max:0};function nb(e,t,n){eb[0].x=eb[1].x=eb[2].x=eb[3].x=t.x,eb[1].y=eb[3].y=eb[7].y=eb[5].y=t.y,eb[2].z=eb[3].z=eb[6].z=eb[7].z=t.z,eb[4].x=eb[5].x=eb[6].x=eb[7].x=n.x,eb[0].y=eb[2].y=eb[4].y=eb[6].y=n.y,eb[0].z=eb[1].z=eb[4].z=eb[5].z=n.z;let a=9999999999,i=-9999999999;for(let t=0;t<8;++t){e.transformPoint(eb[t],eb[t]);const n=eb[t].z;n<a&&(a=n),n>i&&(i=n)}return tb.min=a,tb.max=i,tb}function ab(e,t){return Math.exp(-e*e/(2*t*t))}const ib=new qu,sb=new zu,rb=new zu,ob=new Float32Array(2),lb=new Ou(1,1,0,0),cb={r:1,g:2,b:3,a:4},hb=new Pu,db=new zu;function pb(e){const t=e.material,n=e.skinInstance?10:0;let a=0;if(t.opacityMap){const e=t.opacityMapChannel;e&&(a=cb[e])}return n+a}class ub{constructor(e,t){this.device=e.device,this.forwardRenderer=e,this.lightTextureAtlas=t;const n=this.device.scope;this.polygonOffsetId=n.resolve("polygonOffset"),this.polygonOffset=new Float32Array(2),this.sourceId=n.resolve("source"),this.pixelOffsetId=n.resolve("pixelOffset"),this.weightId=n.resolve("weight[0]"),this.blurVsmShaderCode=[gm.blurVSMPS,"#define GAUSS\n"+gm.blurVSMPS];const a="#define PACKED\n";this.blurPackedVsmShaderCode=[a+this.blurVsmShaderCode[0],a+this.blurVsmShaderCode[1]],this.blurVsmShader=[{},{}],this.blurPackedVsmShader=[{},{}],this.blurVsmWeights={},this.shadowMapLightRadiusId=n.resolve("light_radius"),this.shadowMapCache=new Jy}destroy(){this.shadowMapCache.destroy(),this.shadowMapCache=null}static createShadowCamera(e,t,n,a){const i=mf.create("ShadowCamera",n,a);return i.clearColor=t>=1&&t<=3?new Mu(0,0,0,0):new Mu(1,1,1,1),i.clearDepthBuffer=!0,i.clearStencilBuffer=!1,i}static setShadowCameraSettings(e,t,n,a,i){let s=4===n||0===n&&t.webgl2;1!==a||i||(s=!1),e.clearColorBuffer=!s}cullShadowCasters(e,t,n){let a=0;const i=e.length;for(let s=0;s<i;s++){const i=e[s];i.cull&&!i._isVisible(n)||(i.visibleThisFrame=!0,t[a]=i,a++)}t.length=a,t.sort(this.forwardRenderer.depthSortCompare)}cullLocal(e,t){const n=this.forwardRenderer.scene.clusteredLightingEnabled;e.visibleThisFrame=!0,n||e._shadowMap||(e._shadowMap=Xy.create(this.device,e));const a=e._type,i=2===a?1:6;for(let s=0;s<i;s++){const i=e.getRenderData(null,s),r=i.shadowCamera;r.nearClip=e.attenuationEnd/1e3,r.farClip=e.attenuationEnd;const o=r._node,l=e._node;if(o.setPosition(l.getPosition()),2===a)r.fov=2*e._outerConeAngle,o.setRotation(l.getRotation()),o.rotateLocal(-90,0,0);else if(1===a)if(n){const t=2/(this.lightTextureAtlas.shadowAtlasResolution*e.atlasViewport.z/3)*this.lightTextureAtlas.shadowEdgePixels;r.fov=Math.atan(1+t)*Eu.RAD_TO_DEG*2}else r.fov=90;this.forwardRenderer.updateCameraFrustum(r),this.cullShadowCasters(t,i.visibleCasters,r)}}generateSplitDistances(e,t,n){e._shadowCascadeDistances.fill(n);for(let a=1;a<e.numCascades;a++){const i=a/e.numCascades,s=t+(n-t)*i,r=t*(n/t)**i,o=Eu.lerp(s,r,e.cascadeDistribution);e._shadowCascadeDistances[a-1]=o}}cullDirectional(e,t,n){e.visibleThisFrame=!0,e._shadowMap||(e._shadowMap=Xy.create(this.device,e));const a=n._nearClip;this.generateSplitDistances(e,a,e.shadowDistance);for(let i=0;i<e.numCascades;i++){const s=e.getRenderData(n,i),r=s.shadowCamera;r.renderTarget=e._shadowMap.renderTargets[0],s.shadowViewport.copy(e.cascades[i]),s.shadowScissor.copy(e.cascades[i]);const o=r._node,l=e._node;o.setPosition(l.getPosition()),o.setRotation(l.getRotation()),o.rotateLocal(-90,0,0);const c=0===i?a:e._shadowCascadeDistances[i-1],h=e._shadowCascadeDistances[i],d=em.getPoints(n,c,h);hb.set(0,0,0);const p=n.node.getWorldTransform();for(let e=0;e<8;e++)p.transformPoint(d[e],d[e]),hb.add(d[e]);hb.mulScalar(1/8);let u=0;for(let e=0;e<8;e++){const t=d[e].sub(hb).length();t>u&&(u=t)}const m=o.right,f=o.up,g=o.forward,y=.25*e._shadowResolution/u,b=Math.ceil(hb.dot(f)*y)/y,v=Math.ceil(hb.dot(m)*y)/y,_=f.mulScalar(b),w=m.mulScalar(v),x=hb.dot(g),C=g.mulScalar(x);hb.add2(_,w).add(C),o.setPosition(hb),o.translateLocal(0,0,1e6),r.nearClip=0,r.farClip=2e6,r.orthoHeight=u,this.forwardRenderer.updateCameraFrustum(r),this.cullShadowCasters(t,s.visibleCasters,r);let T=!0;const E=s.visibleCasters;for(let e=0;e<E.length;e++){const t=E[e];T?(T=!1,ib.copy(t.aabb)):ib.add(t.aabb)}sb.copy(o.getWorldTransform()).invert();const S=nb(sb,ib.getMin(),ib.getMax());o.translateLocal(0,0,S.max+.1),r.farClip=S.max-S.min+.2}}setupRenderState(e,t){const n=this.forwardRenderer.scene.clusteredLightingEnabled;e.webgl2?1!==t._type||n?(e.setDepthBias(!0),e.setDepthBiasValues(-1e3*t.shadowBias,-1e3*t.shadowBias)):e.setDepthBias(!1):e.extStandardDerivatives&&(1===t._type?(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset)):(this.polygonOffset[0]=-1e3*t.shadowBias,this.polygonOffset[1]=-1e3*t.shadowBias,this.polygonOffsetId.setValue(this.polygonOffset))),e.setBlending(!1),e.setDepthWrite(!0),e.setDepthTest(!0),e.setDepthFunc(3);(n?t._isPcf&&e.webgl2:t._isPcf&&e.webgl2&&1!==t._type)?e.setColorWrite(!1,!1,!1,!1):e.setColorWrite(!0,!0,!0,!0)}restoreRenderState(e){e.webgl2?e.setDepthBias(!1):e.extStandardDerivatives&&(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset))}dispatchUniforms(e,t,n,a){const i=t._node;0!==e._type&&(this.forwardRenderer.dispatchViewPos(i.getPosition()),this.shadowMapLightRadiusId.setValue(e.attenuationEnd)),sb.setTRS(i.getPosition(),i.getRotation(),Pu.ONE).invert(),rb.mul2(t.projectionMatrix,sb);const s=n.shadowViewport;t.rect=s,t.scissorRect=n.shadowScissor,db.setViewport(s.x,s.y,s.z,s.w),n.shadowMatrix.mul2(db,rb),0===e._type&&e._shadowMatrixPalette.set(n.shadowMatrix.data,16*a)}submitCasters(e,t){const n=this.device,a=this.forwardRenderer,i=t._shadowType+6*t._type,s=e.length;for(let t=0;t<s;t++){const s=e[t],r=s.mesh,o=s.material;a.setBaseConstants(n,o),a.setSkinning(n,s,o),o.dirty&&(o.updateUniforms(n,a.scene),o.dirty=!1),o.chunks&&(a.setCullMode(!0,!1,s),o.setParameters(n),s.setParameters(n,8));let l=s._shader[3+i];l||(a.updateShader(s,s._shaderDefs,null,3+i),l=s._shader[3+i],s._key[1]=pb(s)),n.setShader(l),a.setVertexBuffers(n,r),a.setMorphing(n,s.morphInstance);const c=s.renderStyle;n.setIndexBuffer(r.indexBuffer[c]),a.drawInstance(n,s,r,c),a._shadowDrawCalls++}}render(e,t){if(e.enabled&&e.castShadows&&0!==e.shadowUpdateMode&&e.visibleThisFrame){const n=this.device;1===e.shadowUpdateMode&&(e.shadowUpdateMode=0);const a=e._type,i=e._shadowType,s=e.numShadowFaces,r=this.forwardRenderer;r._shadowMapUpdates+=s;const o=r.scene.clusteredLightingEnabled;this.setupRenderState(n,e);for(let l=0;l<s;l++){const s=e.getRenderData(0===a?t:null,l),c=s.shadowCamera;ub.setShadowCameraSettings(c,n,i,a,o);const h=0===a?0:l;c.renderTarget=e._shadowMap.renderTargets[h],this.dispatchUniforms(e,c,s,l),r.setCamera(c,c.renderTarget,!0),this.submitCasters(s.visibleCasters,e)}if(e._isVsm&&e._vsmBlurSize>1){this.forwardRenderer.scene.clusteredLightingEnabled&&0!==a||this.applyVsmBlur(e,t)}this.restoreRenderState(n)}}getVsmBlurShader(e,t,n){let a=(e?this.blurPackedVsmShader:this.blurVsmShader)[t][n];if(!a){this.blurVsmWeights[n]=function(e){e>25&&(e=25);const t=(e-1)/6,n=.5*(e-1),a=new Array(e);let i=0;for(let s=0;s<e;++s)a[s]=ab(s-n,t),i+=a[s];for(let t=0;t<e;++t)a[t]/=i;return a}(n);const i=gm.fullscreenQuadVS;let s="#define SAMPLES "+n+"\n";s+=e?this.blurPackedVsmShaderCode[t]:this.blurVsmShaderCode[t];const r="blurVsm"+t+n+e;a=Mm(this.device,i,s,r),e?this.blurPackedVsmShader[t][n]=a:this.blurVsmShader[t][n]=a}return a}applyVsmBlur(e,t){const n=this.device,a=e.getRenderData(0===e._type?t:null,0).shadowCamera.renderTarget,i=this.shadowMapCache.get(n,e),s=i.renderTargets[0],r=1===e._shadowType,o=e.vsmBlurMode,l=e._vsmBlurSize,c=this.getVsmBlurShader(r,o,l);lb.z=e._shadowResolution-2,lb.w=lb.z,this.sourceId.setValue(a.colorBuffer),ob[0]=1/e._shadowResolution,ob[1]=0,this.pixelOffsetId.setValue(ob),1===o&&this.weightId.setValue(this.blurVsmWeights[l]),mm(n,s,c,null,lb),this.sourceId.setValue(s.colorBuffer),ob[1]=ob[0],ob[0]=0,this.pixelOffsetId.setValue(ob),mm(n,a,c,null,lb),this.shadowMapCache.add(e,i)}}const mb=new $u;class fb{static lightCompare(e,t){return e.key-t.key}static prepare(e,t,n,a){const i=n,s=i.length,r=[],o=new Pu,l=new Pu,c=new qu,h=new zu,d=[],p=[],u=[],m=[];for(let t=0;t<s;t++){const n=i[t];if(n.isStatic){const t=n.aabb;m.length=0;for(let e=1;e<=2;e++)for(let i=0;i<a.length;i++){const s=a[i];if(s._type===e&&(s.enabled&&s.mask&n.mask&&s.isStatic)){if(p[i]||(p[i]=new qu,s._node.getWorldTransform(),s.getBoundingSphere(mb),p[i].center.copy(mb.center),p[i].halfExtents.set(mb.radius,mb.radius,mb.radius)),!p[i].intersects(t))continue;m.push(i)}}if(0===m.length){r.push(n);continue}const i=n.mesh,s=i.vertexBuffer,f=i.indexBuffer[n.renderStyle],g=2===f.bytesPerIndex?new Uint16Array(f.lock()):new Uint32Array(f.lock()),y=i.primitive[n.renderStyle].count/3,b=i.primitive[n.renderStyle].base,v=s.format.elements,_=s.format.size/4,w=new Float32Array(s.storage);let x;for(let e=0;e<v.length;e++)"POSITION"===v[e].name&&(x=v[e].offset/4);d.length=y;for(let e=0;e<y;e++)d[e]=0;let C=!1;u.length=6*y;for(let e=0;e<y;e++){let t=Number.MAX_VALUE,n=Number.MAX_VALUE,a=Number.MAX_VALUE,i=-Number.MAX_VALUE,s=-Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let o=0;o<3;o++){let l=g[3*e+o+b];l=l*_+x;const c=w[l],h=w[l+1],d=w[l+2];c<t&&(t=c),h<n&&(n=h),d<a&&(a=d),c>i&&(i=c),h>s&&(s=h),d>r&&(r=d)}const o=6*e;u[o]=t,u[o+1]=n,u[o+2]=a,u[o+3]=i,u[o+4]=s,u[o+5]=r}for(let e=0;e<m.length;e++){const t=m[e];h.copy(n.node.worldTransform).invert(),c.setFromTransformedAabb(p[t],h);const a=c.getMin(),i=c.getMax(),s=1<<e;for(let e=0;e<y;e++){const t=6*e;u[t]<=i.x&&u[t+3]>=a.x&&u[t+1]<=i.y&&u[t+4]>=a.y&&u[t+2]<=i.z&&u[t+5]>=a.z&&(d[e]|=s,C=!0)}}if(C){const t={};for(let e=0;e<y;e++){const n=3*e+b,a=d[e];t[a]||(t[a]=[]);const i=t[a];i.push(g[n]),i.push(g[n+1]),i.push(g[n+2])}for(const i in t){const c=t[i],h=new Tg(e,f.format,c.length,f.usage);(2===h.bytesPerIndex?new Uint16Array(h.lock()):new Uint32Array(h.lock())).set(c),h.unlock();let d=Number.MAX_VALUE,p=Number.MAX_VALUE,u=Number.MAX_VALUE,g=-Number.MAX_VALUE,y=-Number.MAX_VALUE,b=-Number.MAX_VALUE;for(let e=0;e<c.length;e++){const t=c[e],n=w[t*_+x],a=w[t*_+x+1],i=w[t*_+x+2];n<d&&(d=n),a<p&&(p=a),i<u&&(u=i),n>g&&(g=n),a>y&&(y=a),i>b&&(b=i)}o.set(d,p,u),l.set(g,y,b);const v=new qu;v.setMinMax(o,l);const C=new iy(e);C.vertexBuffer=s,C.indexBuffer[0]=h,C.primitive[0].type=4,C.primitive[0].base=0,C.primitive[0].count=c.length,C.primitive[0].indexed=!0,C.aabb=v;const T=new Ay(C,n.material,n.node);T.isStatic=n.isStatic,T.visible=n.visible,T.layer=n.layer,T.castShadow=n.castShadow,T._receiveShadow=n._receiveShadow,T.cull=n.cull,T.pick=n.pick,T.mask=n.mask,T.parameters=n.parameters,T._shaderDefs=n._shaderDefs,T._staticSource=n,n._staticLightList?T._staticLightList=n._staticLightList:T._staticLightList=[];for(let e=0;e<m.length;e++){if(i&1<<e){const t=a[m[e]];T._staticLightList.indexOf(t)<0&&T._staticLightList.push(t)}}T._staticLightList.sort(fb.lightCompare),r.push(T)}}else r.push(n)}else r.push(n)}n.length=r.length;for(let e=0;e<r.length;e++)n[e]=r[e]}static revert(e){const t=e,n=t.length,a=[];let i;for(let e=0;e<n;e++){const n=t[e];n._staticSource?n._staticSource!==i&&(a.push(n._staticSource),i=n._staticSource):a.push(n)}e.length=a.length;for(let t=0;t<a.length;t++)e[t]=a[t]}}new Pu(1,1,1),new Pu(40,0,0);const gb=new zu,yb=new zu,bb=new ku,vb=new zu;let _b;const wb=(new zu).setScale(1,-1,1),xb=new zu,Cb=new zu,Tb=new zu,Eb=new zu,Sb=new zu,Ab=new zu,Mb=new Pu,Lb=new Pu;let Rb,Ib;const Pb=new ku,kb=new ku,Db=new zu,Ob=new zu,Fb=new Pu,Nb=new Pu,Vb=new Pu,Bb=new $u,Ub=[0,0,0,0];let zb,Gb,Hb,Wb,jb,Xb,Yb=0;const qb={drawCalls:[],isNewMaterial:[],lightMaskChanged:[]},Kb=new Set;class Zb{constructor(e){this.device=e,this.scene=null,this._shadowDrawCalls=0,this._forwardDrawCalls=0,this._skinDrawCalls=0,this._numDrawCallsCulled=0,this._instancedDrawCalls=0,this._camerasRendered=0,this._materialSwitches=0,this._shadowMapUpdates=0,this._shadowMapTime=0,this._depthMapTime=0,this._forwardTime=0,this._cullTime=0,this._sortTime=0,this._skinTime=0,this._morphTime=0,this._layerCompositionUpdateTime=0,this._lightClustersTime=0,this._lightClusters=0;const t=this.device;this.library=t.getProgramLibrary(),this.lightTextureAtlas=new Qy(t),this._shadowRenderer=new ub(this,this.lightTextureAtlas),this._cookieRenderer=new jy(t,this.lightTextureAtlas);const n=t.scope;this.projId=n.resolve("matrix_projection"),this.projSkyboxId=n.resolve("matrix_projectionSkybox"),this.viewId=n.resolve("matrix_view"),this.viewId3=n.resolve("matrix_view3"),this.viewInvId=n.resolve("matrix_viewInverse"),this.viewProjId=n.resolve("matrix_viewProjection"),this.viewPos=new Float32Array(3),this.viewPosId=n.resolve("view_position"),this.nearClipId=n.resolve("camera_near"),this.farClipId=n.resolve("camera_far"),this.cameraParamsId=n.resolve("camera_params"),this.tbnBasis=n.resolve("tbnBasis"),this.fogColorId=n.resolve("fog_color"),this.fogStartId=n.resolve("fog_start"),this.fogEndId=n.resolve("fog_end"),this.fogDensityId=n.resolve("fog_density"),this.modelMatrixId=n.resolve("matrix_model"),this.normalMatrixId=n.resolve("matrix_normal"),this.poseMatrixId=n.resolve("matrix_pose[0]"),this.boneTextureId=n.resolve("texture_poseMap"),this.boneTextureSizeId=n.resolve("texture_poseMapSize"),this.morphWeightsA=n.resolve("morph_weights_a"),this.morphWeightsB=n.resolve("morph_weights_b"),this.morphPositionTex=n.resolve("morphPositionTex"),this.morphNormalTex=n.resolve("morphNormalTex"),this.morphTexParams=n.resolve("morph_tex_params"),this.alphaTestId=n.resolve("alpha_ref"),this.opacityMapId=n.resolve("texture_opacityMap"),this.ambientId=n.resolve("light_globalAmbient"),this.exposureId=n.resolve("exposure"),this.skyboxIntensityId=n.resolve("skyboxIntensity"),this.lightColorId=[],this.lightDir=[],this.lightDirId=[],this.lightShadowMapId=[],this.lightShadowMatrixId=[],this.lightShadowParamsId=[],this.lightRadiusId=[],this.lightPos=[],this.lightPosId=[],this.lightWidth=[],this.lightWidthId=[],this.lightHeight=[],this.lightHeightId=[],this.lightInAngleId=[],this.lightOutAngleId=[],this.lightCookieId=[],this.lightCookieIntId=[],this.lightCookieMatrixId=[],this.lightCookieOffsetId=[],this.shadowMatrixPaletteId=[],this.shadowCascadeDistancesId=[],this.shadowCascadeCountId=[],this.depthMapId=n.resolve("uDepthMap"),this.screenSizeId=n.resolve("uScreenSize"),this._screenSize=new Float32Array(4),this.twoSidedLightingNegScaleFactorId=n.resolve("twoSidedLightingNegScaleFactor"),this.fogColor=new Float32Array(3),this.ambientColor=new Float32Array(3),this.cameraParams=new Float32Array(4)}destroy(){this._shadowRenderer.destroy(),this._shadowRenderer=null,this._cookieRenderer.destroy(),this._cookieRenderer=null,this.lightTextureAtlas.destroy(),this.lightTextureAtlas=null}sortCompare(e,t){if(e.layer===t.layer){if(e.drawOrder&&t.drawOrder)return e.drawOrder-t.drawOrder;if(e.zdist&&t.zdist)return t.zdist-e.zdist;if(e.zdist2&&t.zdist2)return e.zdist2-t.zdist2}return t._key[0]-e._key[0]}sortCompareMesh(e,t){if(e.layer===t.layer){if(e.drawOrder&&t.drawOrder)return e.drawOrder-t.drawOrder;if(e.zdist&&t.zdist)return t.zdist-e.zdist}return jb=e._key[0],Xb=t._key[0],jb===Xb&&e.mesh&&t.mesh?t.mesh.id-e.mesh.id:Xb-jb}depthSortCompare(e,t){return jb=e._key[1],Xb=t._key[1],jb===Xb&&e.mesh&&t.mesh?t.mesh.id-e.mesh.id:Xb-jb}updateCameraFrustum(e){if(e.vrDisplay&&e.vrDisplay.presenting){_b=e.vrDisplay.combinedProj;const t=e._node.parent;t?yb.copy(t.getWorldTransform()).mul(e.vrDisplay.combinedViewInv).invert():yb.copy(e.vrDisplay.combinedView),gb.copy(yb).invert(),this.viewInvId.setValue(gb.data),vb.mul2(_b,yb),e.frustum.setFromMat4(vb)}else if(e.xr&&e.xr.views.length){const t=e.xr.views[0];return vb.mul2(t.projMat,t.viewOffMat),void e.frustum.setFromMat4(vb)}if(_b=e.projectionMatrix,e.calculateProjection&&e.calculateProjection(_b,0),e.calculateTransform)e.calculateTransform(gb,0);else{const t=e._node.getPosition(),n=e._node.getRotation();gb.setTRS(t,n,Pu.ONE),this.viewInvId.setValue(gb.data)}yb.copy(gb).invert(),vb.mul2(_b,yb),e.frustum.setFromMat4(vb)}setCamera(e,t,n){const a=e.vrDisplay;let i;if(a&&a.presenting){if(Rb=a.leftProj,Ib=a.rightProj,_b=a.combinedProj,e.calculateProjection&&(e.calculateProjection(Rb,1),e.calculateProjection(Ib,2),e.calculateProjection(_b,0)),e.calculateTransform)e.calculateTransform(Tb,1),e.calculateTransform(Eb,2),e.calculateTransform(gb,0),Sb.copy(Tb).invert(),Ab.copy(Eb).invert(),yb.copy(gb).invert();else{const t=e._node.parent;t?(i=t.getWorldTransform(),Tb.mul2(i,a.leftViewInv),Eb.mul2(i,a.rightViewInv),Sb.copy(Tb).invert(),Ab.copy(Eb).invert(),yb.copy(t.getWorldTransform()).mul(a.combinedViewInv).invert()):(Tb.copy(a.leftViewInv),Eb.copy(a.rightViewInv),Sb.copy(a.leftView),Ab.copy(a.rightView),yb.copy(a.combinedView))}Pb.setFromMat4(Sb),kb.setFromMat4(Ab),Db.mul2(Rb,Sb),Ob.mul2(Ib,Ab),Mb.x=Tb.data[12],Mb.y=Tb.data[13],Mb.z=Tb.data[14],Lb.x=Eb.data[12],Lb.y=Eb.data[13],Lb.z=Eb.data[14],vb.mul2(_b,yb),e.frustum.setFromMat4(vb)}else if(e.xr&&e.xr.session){const t=e._node.parent;t&&(i=t.getWorldTransform());const n=e.xr.views;for(let a=0;a<n.length;a++){const s=n[a];t?(s.viewInvOffMat.mul2(i,s.viewInvMat),s.viewOffMat.copy(s.viewInvOffMat).invert()):(s.viewInvOffMat.copy(s.viewInvMat),s.viewOffMat.copy(s.viewMat)),s.viewMat3.setFromMat4(s.viewOffMat),s.projViewOffMat.mul2(s.projMat,s.viewOffMat),s.position[0]=s.viewInvOffMat.data[12],s.position[1]=s.viewInvOffMat.data[13],s.position[2]=s.viewInvOffMat.data[14],e.frustum.setFromMat4(s.projViewOffMat)}}else{if(_b=e.projectionMatrix,e.calculateProjection&&e.calculateProjection(_b,0),this.projId.setValue(_b.data),this.projSkyboxId.setValue(e.getProjectionMatrixSkybox().data),e.calculateTransform)e.calculateTransform(gb,0);else{const t=e._node.getPosition(),n=e._node.getRotation();gb.setTRS(t,n,Pu.ONE)}this.viewInvId.setValue(gb.data),yb.copy(gb).invert(),this.viewId.setValue(yb.data),bb.setFromMat4(yb),this.viewId3.setValue(bb.data),vb.mul2(_b,yb),t&&t.flipY?(xb.mul2(wb,vb),Cb.mul2(wb,e.getProjectionMatrixSkybox()),this.viewProjId.setValue(xb.data),this.projSkyboxId.setValue(Cb.data)):(this.viewProjId.setValue(vb.data),this.projSkyboxId.setValue(e.getProjectionMatrixSkybox().data)),this.dispatchViewPos(e._node.getPosition()),e.frustum.setFromMat4(vb)}this.tbnBasis.setValue(t&&t.flipY?-1:1),this.nearClipId.setValue(e._nearClip),this.farClipId.setValue(e._farClip);const s=e._nearClip,r=e._farClip;this.cameraParams[0]=1/r,this.cameraParams[1]=r,this.cameraParams[2]=.5*(1-r/s),this.cameraParams[3]=.5*(1+r/s),this.cameraParamsId.setValue(this.cameraParams),this.clearView(e,t,n,!1)}clearView(e,t,n,a,i){const s=this.device;s.setRenderTarget(t),s.updateBegin(),a&&(s.setColorWrite(!0,!0,!0,!0),s.setDepthWrite(!0));const r=t?t.width:s.width,o=t?t.height:s.height,l=e.rect;let c=Math.floor(l.x*r),h=Math.floor(l.y*o),d=Math.floor(l.z*r),p=Math.floor(l.w*o);if(s.setViewport(c,h,d,p),e._scissorRectClear){const t=e.scissorRect;c=Math.floor(t.x*r),h=Math.floor(t.y*o),d=Math.floor(t.z*r),p=Math.floor(t.w*o)}s.setScissor(c,h,d,p),n&&(i||(i=e._clearOptions),s.clear(i||{color:[e._clearColor.r,e._clearColor.g,e._clearColor.b,e._clearColor.a],depth:e._clearDepth,flags:(e._clearColorBuffer?1:0)|(e._clearDepthBuffer?2:0)|(e._clearStencilBuffer?4:0),stencil:e._clearStencil}))}dispatchGlobalLights(e){if(this.ambientColor[0]=e.ambientLight.r,this.ambientColor[1]=e.ambientLight.g,this.ambientColor[2]=e.ambientLight.b,e.gammaCorrection)for(let e=0;e<3;e++)this.ambientColor[e]=Math.pow(this.ambientColor[e],2.2);this.ambientId.setValue(this.ambientColor),this.exposureId.setValue(e.exposure),e.skyboxModel&&this.skyboxIntensityId.setValue(e.skyboxIntensity)}_resolveLight(e,t){const n="light"+t;this.lightColorId[t]=e.resolve(n+"_color"),this.lightDir[t]=new Float32Array(3),this.lightDirId[t]=e.resolve(n+"_direction"),this.lightShadowMapId[t]=e.resolve(n+"_shadowMap"),this.lightShadowMatrixId[t]=e.resolve(n+"_shadowMatrix"),this.lightShadowParamsId[t]=e.resolve(n+"_shadowParams"),this.lightRadiusId[t]=e.resolve(n+"_radius"),this.lightPos[t]=new Float32Array(3),this.lightPosId[t]=e.resolve(n+"_position"),this.lightWidth[t]=new Float32Array(3),this.lightWidthId[t]=e.resolve(n+"_halfWidth"),this.lightHeight[t]=new Float32Array(3),this.lightHeightId[t]=e.resolve(n+"_halfHeight"),this.lightInAngleId[t]=e.resolve(n+"_innerConeAngle"),this.lightOutAngleId[t]=e.resolve(n+"_outerConeAngle"),this.lightCookieId[t]=e.resolve(n+"_cookie"),this.lightCookieIntId[t]=e.resolve(n+"_cookieIntensity"),this.lightCookieMatrixId[t]=e.resolve(n+"_cookieMatrix"),this.lightCookieOffsetId[t]=e.resolve(n+"_cookieOffset"),this.shadowMatrixPaletteId[t]=e.resolve(n+"_shadowMatrixPalette[0]"),this.shadowCascadeDistancesId[t]=e.resolve(n+"_shadowCascadeDistances[0]"),this.shadowCascadeCountId[t]=e.resolve(n+"_shadowCascadeCount")}setLTCDirectionalLight(e,t,n,a,i){this.lightPos[t][0]=a.x-n.x*i,this.lightPos[t][1]=a.y-n.y*i,this.lightPos[t][2]=a.z-n.z*i,this.lightPosId[t].setValue(this.lightPos[t]);const s=e.transformVector(new Pu(-.5,0,0));this.lightWidth[t][0]=s.x*i,this.lightWidth[t][1]=s.y*i,this.lightWidth[t][2]=s.z*i,this.lightWidthId[t].setValue(this.lightWidth[t]);const r=e.transformVector(new Pu(0,0,.5));this.lightHeight[t][0]=r.x*i,this.lightHeight[t][1]=r.y*i,this.lightHeight[t][2]=r.z*i,this.lightHeightId[t].setValue(this.lightHeight[t])}dispatchDirectLights(e,t,n,a){let i=0;const s=this.device.scope;for(let r=0;r<e.length;r++){if(!(e[r].mask&n))continue;const o=e[r],l=o._node.getWorldTransform();if(this.lightColorId[i]||this._resolveLight(s,i),this.lightColorId[i].setValue(t.gammaCorrection?o._linearFinalColor:o._finalColor),l.getY(o._direction).mulScalar(-1),o._direction.normalize(),this.lightDir[i][0]=o._direction.x,this.lightDir[i][1]=o._direction.y,this.lightDir[i][2]=o._direction.z,this.lightDirId[i].setValue(this.lightDir[i]),0!==o.shape&&this.setLTCDirectionalLight(l,i,o._direction,a._node.getPosition(),a.farClip),o.castShadows){const e=o.getRenderData(a,0),t=o._getUniformBiasValues(e);this.lightShadowMapId[i].setValue(e.shadowBuffer),this.lightShadowMatrixId[i].setValue(e.shadowMatrix.data),this.shadowMatrixPaletteId[i].setValue(o._shadowMatrixPalette),this.shadowCascadeDistancesId[i].setValue(o._shadowCascadeDistances),this.shadowCascadeCountId[i].setValue(o.numCascades);const n=o._shadowRenderParams;n.length=3,n[0]=o._shadowResolution,n[1]=t.normalBias,n[2]=t.bias,this.lightShadowParamsId[i].setValue(n)}i++}return i}setLTCPositionalLight(e,t){const n=e.transformVector(new Pu(-.5,0,0));this.lightWidth[t][0]=n.x,this.lightWidth[t][1]=n.y,this.lightWidth[t][2]=n.z,this.lightWidthId[t].setValue(this.lightWidth[t]);const a=e.transformVector(new Pu(0,0,.5));this.lightHeight[t][0]=a.x,this.lightHeight[t][1]=a.y,this.lightHeight[t][2]=a.z,this.lightHeightId[t].setValue(this.lightHeight[t])}dispatchOmniLight(e,t,n,a){const i=n._node.getWorldTransform();if(this.lightColorId[a]||this._resolveLight(t,a),this.lightRadiusId[a].setValue(n.attenuationEnd),this.lightColorId[a].setValue(e.gammaCorrection?n._linearFinalColor:n._finalColor),i.getTranslation(n._position),this.lightPos[a][0]=n._position.x,this.lightPos[a][1]=n._position.y,this.lightPos[a][2]=n._position.z,this.lightPosId[a].setValue(this.lightPos[a]),0!==n.shape&&this.setLTCPositionalLight(i,a),n.castShadows){const e=n.getRenderData(null,0);this.lightShadowMapId[a].setValue(e.shadowBuffer);const t=n._getUniformBiasValues(e),i=n._shadowRenderParams;i.length=4,i[0]=n._shadowResolution,i[1]=t.normalBias,i[2]=t.bias,i[3]=1/n.attenuationEnd,this.lightShadowParamsId[a].setValue(i)}n._cookie&&(this.lightCookieId[a].setValue(n._cookie),this.lightShadowMatrixId[a].setValue(i.data),this.lightCookieIntId[a].setValue(n.cookieIntensity))}dispatchSpotLight(e,t,n,a){const i=n._node.getWorldTransform();if(this.lightColorId[a]||this._resolveLight(t,a),this.lightInAngleId[a].setValue(n._innerConeAngleCos),this.lightOutAngleId[a].setValue(n._outerConeAngleCos),this.lightRadiusId[a].setValue(n.attenuationEnd),this.lightColorId[a].setValue(e.gammaCorrection?n._linearFinalColor:n._finalColor),i.getTranslation(n._position),this.lightPos[a][0]=n._position.x,this.lightPos[a][1]=n._position.y,this.lightPos[a][2]=n._position.z,this.lightPosId[a].setValue(this.lightPos[a]),0!==n.shape&&this.setLTCPositionalLight(i,a),i.getY(n._direction).mulScalar(-1),n._direction.normalize(),this.lightDir[a][0]=n._direction.x,this.lightDir[a][1]=n._direction.y,this.lightDir[a][2]=n._direction.z,this.lightDirId[a].setValue(this.lightDir[a]),n.castShadows){const e=n.getRenderData(null,0);this.lightShadowMapId[a].setValue(e.shadowBuffer),this.lightShadowMatrixId[a].setValue(e.shadowMatrix.data);const t=n._getUniformBiasValues(e),i=n._shadowRenderParams;i.length=4,i[0]=n._shadowResolution,i[1]=t.normalBias,i[2]=t.bias,i[3]=1/n.attenuationEnd,this.lightShadowParamsId[a].setValue(i)}if(n._cookie){if(!n.castShadows){const e=mf.evalSpotCookieMatrix(n);this.lightShadowMatrixId[a].setValue(e.data)}this.lightCookieId[a].setValue(n._cookie),this.lightCookieIntId[a].setValue(n.cookieIntensity),n._cookieTransform&&(n._cookieTransformUniform[0]=n._cookieTransform.x,n._cookieTransformUniform[1]=n._cookieTransform.y,n._cookieTransformUniform[2]=n._cookieTransform.z,n._cookieTransformUniform[3]=n._cookieTransform.w,this.lightCookieMatrixId[a].setValue(n._cookieTransformUniform),n._cookieOffsetUniform[0]=n._cookieOffset.x,n._cookieOffsetUniform[1]=n._cookieOffset.y,this.lightCookieOffsetId[a].setValue(n._cookieOffsetUniform))}}dispatchLocalLights(e,t,n,a,i){let s=a;const r=this.device.scope,o=e[1],l=o.length;for(let e=0;e<l;e++){const a=o[e];a.mask&n&&(a.isStatic||(this.dispatchOmniLight(t,r,a,s),s++))}let c=0;if(i){let e=i[c];for(;e&&1===e._type;)this.dispatchOmniLight(t,r,e,s),s++,c++,e=i[c]}const h=e[2],d=h.length;for(let e=0;e<d;e++){const a=h[e];a.mask&n&&(a.isStatic||(this.dispatchSpotLight(t,r,a,s),s++))}if(i){let e=i[c];for(;e&&2===e._type;)this.dispatchSpotLight(t,r,e,s),s++,c++,e=i[c]}}cull(e,t,n){let a=0;const i=t.length,s=e.cullingMask||4294967295;if(!e.frustumCulling){for(let e=0;e<i;e++){const i=t[e];(i.visible||i.command)&&(i.mask&&0==(i.mask&s)||(n[a]=i,a++,i.visibleThisFrame=!0))}return a}for(let r=0;r<i;r++){const i=t[r];if(i.command)n[a]=i,a++,i.visibleThisFrame=!0;else{if(!i.visible)continue;let t=!0;if(i.mask&&0==(i.mask&s))continue;i.cull&&(t=i._isVisible(e)),t&&(n[a]=i,a++,i.visibleThisFrame=!0)}}return a}cullLights(e,t){const n=this.scene.clusteredLightingEnabled;for(let a=0;a<t.length;a++){const i=t[a];if(i.enabled&&0!==i._type)if(i.getBoundingSphere(Bb),e.frustum.containsSphere(Bb)){i.visibleThisFrame=!0;const t=e.getScreenSize(Bb);i.maxScreenSize=Math.max(i.maxScreenSize,t)}else n||i.castShadows&&!i.shadowMap&&(i.visibleThisFrame=!0)}}updateCpuSkinMatrices(e){Yb++;const t=e.length;if(0!==t)for(let n=0;n<t;n++){const t=e[n].skinInstance;t&&(t.updateMatrices(e[n].node,Yb),t._dirty=!0)}}updateGpuSkinMatrices(e){const t=e.length;for(let n=0;n<t;n++){if(!e[n].visibleThisFrame)continue;const t=e[n].skinInstance;t&&t._dirty&&(t.updateMatrixPalette(e[n].node,Yb),t._dirty=!1)}}updateMorphing(e){const t=e.length;for(let n=0;n<t;n++){const t=e[n].morphInstance;t&&t._dirty&&e[n].visibleThisFrame&&t.update()}}setBaseConstants(e,t){e.setCullMode(t.cull),t.opacityMap&&(this.opacityMapId.setValue(t.opacityMap),this.alphaTestId.setValue(t.alphaTest))}setSkinning(e,t,n){t.skinInstance&&(this._skinDrawCalls++,e.supportsBoneTextures?(zb=t.skinInstance.boneTexture,this.boneTextureId.setValue(zb),Ub[0]=zb.width,Ub[1]=zb.height,Ub[2]=1/zb.width,Ub[3]=1/zb.height,this.boneTextureSizeId.setValue(Ub)):this.poseMatrixId.setValue(t.skinInstance.matrixPalette))}drawInstance(e,t,n,a,i){Gb=t.instancingData,Gb?Gb.count>0&&(this._instancedDrawCalls++,e.setVertexBuffer(Gb.vertexBuffer),e.draw(n.primitive[a],Gb.count)):(Hb=t.node.worldTransform,this.modelMatrixId.setValue(Hb.data),i&&(Wb=t.node.normalMatrix,t.node._dirtyNormal&&(Hb.invertTo3x3(Wb),Wb.transpose(),t.node._dirtyNormal=!1),this.normalMatrixId.setValue(Wb.data)),e.draw(n.primitive[a]))}drawInstance2(e,t,n,a){Gb=t.instancingData,Gb?Gb.count>0&&(this._instancedDrawCalls++,e.draw(n.primitive[a],Gb.count,!0)):e.draw(n.primitive[a],void 0,!0)}renderShadows(e,t){const n=this.scene.clusteredLightingEnabled,a=this.device;a.grabPassAvailable=!1;for(let a=0;a<e.length;a++){const i=e[a];if(n&&0!==i._type){if(!i.atlasViewportAllocated)continue;i.atlasSlotUpdated&&0===i.shadowUpdateMode&&(i.shadowUpdateMode=1)}this._shadowRenderer.render(i,t)}a.grabPassAvailable=!0}renderCookies(e){const t=this.lightTextureAtlas.cookieRenderTarget;for(let n=0;n<e.length;n++){const a=e[n];a.atlasViewportAllocated&&(a.atlasSlotUpdated&&this._cookieRenderer.render(a,t))}}updateShader(e,t,n,a,i){e.material._scene=this.scene,e.material._dirtyBlend&&(this.scene.layers._dirtyBlend=!0),e.material.updateShader(this.device,this.scene,t,n,a,i),e._shader[a]=e.material.shader}setCullMode(e,t,n){const a=n.material;let i=0;if(e){let e=1;if(a.cull>0&&a.cull<3){n.flipFaces&&(e*=-1),t&&(e*=-1);const a=n.node.worldTransform;a.getX(Fb),a.getY(Nb),a.getZ(Vb),Fb.cross(Fb,Nb),Fb.dot(Vb)<0&&(e*=-1)}i=e<0?2===a.cull?1:2:a.cull}if(this.device.setCullMode(i),0===i&&0===a.cull){const e=n.node.worldTransform;e.getX(Fb),e.getY(Nb),e.getZ(Vb),Fb.cross(Fb,Nb),Fb.dot(Vb)<0?this.twoSidedLightingNegScaleFactorId.setValue(-1):this.twoSidedLightingNegScaleFactorId.setValue(1)}}setVertexBuffers(e,t){e.setVertexBuffer(t.vertexBuffer)}setMorphing(e,t){if(t)if(t.morph.useTextureMorph)e.setVertexBuffer(t.morph.vertexBufferIds),this.morphPositionTex.setValue(t.texturePositions),this.morphNormalTex.setValue(t.textureNormals),this.morphTexParams.setValue(t._textureParams);else{for(let n=0;n<t._activeVertexBuffers.length;n++){const a=t._activeVertexBuffers[n];if(a){const t="ATTR"+(n+8);a.format.elements[0].name=t,a.format.elements[0].scopeId=e.scope.resolve(t),a.format.update(),e.setVertexBuffer(a)}}this.morphWeightsA.setValue(t._shaderMorphWeightsA),this.morphWeightsB.setValue(t._shaderMorphWeightsB)}}dispatchViewPos(e){const t=this.viewPos;t[0]=e.x,t[1]=e.y,t[2]=e.z,this.viewPosId.setValue(t)}renderForwardPrepareMaterials(e,t,n,a,i,s,r){const o=(e,t,n)=>{qb.drawCalls.push(e),qb.isNewMaterial.push(t),qb.lightMaskChanged.push(n)};qb.drawCalls.length=0,qb.isNewMaterial.length=0,qb.lightMaskChanged.length=0;const l=this.device,c=this.scene,h=s?s._lightHash:0;let d,p,u,m=null;for(let e=0;e<n;e++){const n=t[e];if(!i||!n.mask||i&n.mask)if(n.command)o(n,!1,!1);else{n.material||(n.material=$f(l));const e=n.material,t=n._shaderDefs,i=n.mask;if(e&&e===m&&t!==d&&(m=null),(n.isStatic||p)&&(m=null),e!==m&&(this._materialSwitches++,e.dirty&&(e.updateUniforms(l,c),e.dirty=!1),!n._shader[r]||n._shaderDefs!==t||n._lightHash!==h)){if(n.isStatic)this.updateShader(n,t,n._staticLightList,r,a);else{const i=r+"_"+t+"_"+h;n._shader[r]=e.variants[i],n._shader[r]||(this.updateShader(n,t,null,r,a),e.variants[i]=n._shader[r])}n._shaderDefs=t,n._lightHash=h}o(n,e!==m,!m||i!==u),m=e,d=t,u=i,p=n.isStatic}}return qb}renderForward(e,t,n,a,i,s,r,o,l){const c=this.device,h=this.scene,d=e.vrDisplay,p=1<<i,u=.5*c.width,m=this.renderForwardPrepareMaterials(e,t,n,a,s,o,i),f=m.drawCalls.length;for(let t=0;t<f;t++){const n=m.drawCalls[t];if(n.command)n.command();else{const s=m.isNewMaterial[t],o=m.lightMaskChanged[t],g=n.material;n._shaderDefs;const y=n.mask;if(s){const t=n._shader[i];if(!t.failed&&c.setShader(t),g.setParameters(c),o){const t=this.dispatchDirectLights(a[0],h,y,e);this.dispatchLocalLights(a,h,y,t,n._staticLightList)}this.alphaTestId.setValue(g.alphaTest),c.setBlending(g.blend),g.blend&&(g.separateAlphaBlend?(c.setBlendFunctionSeparate(g.blendSrc,g.blendDst,g.blendSrcAlpha,g.blendDstAlpha),c.setBlendEquationSeparate(g.blendEquation,g.blendAlphaEquation)):(c.setBlendFunction(g.blendSrc,g.blendDst),c.setBlendEquation(g.blendEquation))),c.setColorWrite(g.redWrite,g.greenWrite,g.blueWrite,g.alphaWrite),c.setDepthWrite(g.depthWrite),g.depthWrite&&!g.depthTest?(c.setDepthFunc(7),c.setDepthTest(!0)):(c.setDepthFunc(g.depthFunc),c.setDepthTest(g.depthTest)),c.setAlphaToCoverage(g.alphaToCoverage),g.depthBias||g.slopeDepthBias?(c.setDepthBias(!0),c.setDepthBiasValues(g.depthBias,g.slopeDepthBias)):c.setDepthBias(!1)}this.setCullMode(e._cullFaces,l,n);const b=n.stencilFront||g.stencilFront,v=n.stencilBack||g.stencilBack;b||v?(c.setStencilTest(!0),b===v?(c.setStencilFunc(b.func,b.ref,b.readMask),c.setStencilOperation(b.fail,b.zfail,b.zpass,b.writeMask)):(b?(c.setStencilFuncFront(b.func,b.ref,b.readMask),c.setStencilOperationFront(b.fail,b.zfail,b.zpass,b.writeMask)):(c.setStencilFuncFront(7,0,255),c.setStencilOperationFront(0,0,0,255)),v?(c.setStencilFuncBack(v.func,v.ref,v.readMask),c.setStencilOperationBack(v.fail,v.zfail,v.zpass,v.writeMask)):(c.setStencilFuncBack(7,0,255),c.setStencilOperationBack(0,0,0,255)))):c.setStencilTest(!1);const _=n.mesh;n.setParameters(c,p),this.setVertexBuffers(c,_),this.setMorphing(c,n.morphInstance),this.setSkinning(c,n,g);const w=n.renderStyle;if(c.setIndexBuffer(_.indexBuffer[w]),r&&r(n,t),d&&d.presenting)c.setViewport(0,0,u,c.height),this.projId.setValue(Rb.data),this.projSkyboxId.setValue(Rb.data),this.viewInvId.setValue(Tb.data),this.viewId.setValue(Sb.data),this.viewId3.setValue(Pb.data),this.viewProjId.setValue(Db.data),this.dispatchViewPos(Mb),this.drawInstance(c,n,_,w,!0),this._forwardDrawCalls++,c.setViewport(u,0,u,c.height),this.projId.setValue(Ib.data),this.projSkyboxId.setValue(Ib.data),this.viewInvId.setValue(Eb.data),this.viewId.setValue(Ab.data),this.viewId3.setValue(kb.data),this.viewProjId.setValue(Ob.data),this.dispatchViewPos(Lb),this.drawInstance2(c,n,_,w),this._forwardDrawCalls++;else if(e.xr&&e.xr.session&&e.xr.views.length){const t=e.xr.views;for(let e=0;e<t.length;e++){const a=t[e];c.setViewport(a.viewport.x,a.viewport.y,a.viewport.z,a.viewport.w),this.projId.setValue(a.projMat.data),this.projSkyboxId.setValue(a.projMat.data),this.viewId.setValue(a.viewOffMat.data),this.viewInvId.setValue(a.viewInvOffMat.data),this.viewId3.setValue(a.viewMat3.data),this.viewProjId.setValue(a.projViewOffMat.data),this.viewPosId.setValue(a.position),0===e?this.drawInstance(c,n,_,w,!0):this.drawInstance2(c,n,_,w),this._forwardDrawCalls++}}else this.drawInstance(c,n,_,w,!0),this._forwardDrawCalls++;t<f-1&&!m.isNewMaterial[t+1]&&g.setParameters(c,n.parameters)}}c.updateEnd(),qb.length=0}updateShaders(e,t){const n=e.length;for(let a=0;a<n;a++){const n=e[a].material;if(n&&!Kb.has(n)&&(Kb.add(n),n.updateShader!==Jf.prototype.updateShader)){if(t&&(!n.useLighting||n.emitter&&!n.emitter.lighting))continue;n.clearVariants(),n.shader=null}}Kb.clear()}beginFrame(e,t){const n=e._meshInstances,a=this.scene;if(a.updateShaders||t){const e=!a.updateShaders&&t;this.updateShaders(n,e),a.updateShaders=!1,a._shaderVersion++}this.updateCpuSkinMatrices(n);const i=n.length;for(let e=0;e<i;e++)n[e].visibleThisFrame=!1;const s=e._lights,r=s.length;for(let e=0;e<r;e++)s[e].beginFrame()}beginLayers(e){const t=e.layerList.length;for(let n=0;n<t;n++)e.layerList[n]._postRenderCounter=0;const n=this.scene,a=n._shaderVersion;for(let i=0;i<t;i++){const t=e.layerList[i];t._shaderVersion=a,t._preRenderCalledForCameras=0,t._postRenderCalledForCameras=0;const s=e.subLayerList[i];t._postRenderCounter|=s?2:1,t._postRenderCounterMax=t._postRenderCounter;for(let e=0;e<t.cameras.length;e++)t.instances.prepare(e);t._needsStaticPrepare&&t._staticLightHash&&!this.scene.clusteredLightingEnabled&&(t._staticPrepareDone&&(fb.revert(t.opaqueMeshInstances),fb.revert(t.transparentMeshInstances)),fb.prepare(this.device,n,t.opaqueMeshInstances,t._lights),fb.prepare(this.device,n,t.transparentMeshInstances,t._lights),e._dirty=!0,n.updateShaders=!0,t._needsStaticPrepare=!1,t._staticPrepareDone=!0)}}gpuUpdate(e){this.updateGpuSkinMatrices(e),this.updateMorphing(e)}setSceneConstants(){const e=this.scene;if(this.dispatchGlobalLights(e),"none"!==e.fog){if(this.fogColor[0]=e.fogColor.r,this.fogColor[1]=e.fogColor.g,this.fogColor[2]=e.fogColor.b,e.gammaCorrection)for(let e=0;e<3;e++)this.fogColor[e]=Math.pow(this.fogColor[e],2.2);this.fogColorId.setValue(this.fogColor),"linear"===e.fog?(this.fogStartId.setValue(e.fogStart),this.fogEndId.setValue(e.fogEnd)):this.fogDensityId.setValue(e.fogDensity)}const t=this.device;this._screenSize[0]=t.width,this._screenSize[1]=t.height,this._screenSize[2]=1/t.width,this._screenSize[3]=1/t.height,this.screenSizeId.setValue(this._screenSize)}updateLightStats(e,t){}cullShadowmaps(e){for(let t=0;t<e._lights.length;t++){const n=e._lights[t];if(0!==n._type&&n.visibleThisFrame&&n.castShadows&&0!==n.shadowUpdateMode){const a=e._lightCompositionData[t].shadowCastersList;this._shadowRenderer.cullLocal(n,a)}}const t=e._renderActions;for(let n=0;n<t.length;n++){const a=t[n],i=a.directionalLightsIndices.length;for(let t=0;t<i;t++){const n=a.directionalLightsIndices[t],i=e._lights[n],s=e._lightCompositionData[n].shadowCastersList;this._shadowRenderer.cullDirectional(i,s,a.camera.camera)}}}cullComposition(e){const t=e._renderActions;for(let n=0;n<t.length;n++){const a=t[n],i=a.layerIndex,s=e.layerList[i];if(!s.enabled||!e.subLayerEnabled[i])continue;const r=e.subLayerList[i],o=a.cameraIndex,l=s.cameras[o];if(l){l.frameBegin(a.renderTarget),a.firstCameraUse&&(this.updateCameraFrustum(l.camera),this._camerasRendered++),this.cullLights(l.camera,s._lights);const e=s.instances,t=r?e.visibleTransparent[o]:e.visibleOpaque[o];if(!t.done){s.onPreCull&&s.onPreCull(o);const e=r?s.transparentMeshInstances:s.opaqueMeshInstances;t.length=this.cull(l.camera,e,t.list),t.done=!0,s.onPostCull&&s.onPostCull(o)}l.frameEnd()}}this.cullShadowmaps(e)}updateLightTextureAtlas(e){this.lightTextureAtlas.update(e._splitLights[2],e._splitLights[1],this.scene.lighting)}updateClusters(e){for(let t=0;t<e._worldClusters.length;t++){e._worldClusters[t].update(e._lights,this.scene.gammaCorrection,this.scene.lighting)}}renderComposition(e){const t=this.device,n=this.scene.clusteredLightingEnabled;this.scene._updateSkybox(this.device),this.beginLayers(e);const a=e._update(t,n),i=0!=(2&a);this.updateLightStats(e,a),this.beginFrame(e,i),this.setSceneConstants(),this.cullComposition(e),this.gpuUpdate(e._meshInstances),n&&(this.updateLightTextureAtlas(e),this.scene.lighting.cookiesEnabled&&(this.renderCookies(e._splitLights[2]),this.renderCookies(e._splitLights[1]))),(!n||n&&this.scene.lighting.shadowsEnabled)&&(this.renderShadows(e._splitLights[2]),this.renderShadows(e._splitLights[1])),n&&this.updateClusters(e);let s=!1;const r=e._renderActions;for(let a=0;a<r.length;a++){const i=r[a],l=i.layerIndex,c=e.layerList[l],h=e.subLayerList[l],d=i.cameraIndex,p=c.cameras[d];if(i.directionalLights.length>0&&this.renderShadows(i.directionalLights,p.camera),c.enabled&&e.subLayerEnabled[l]){if(p&&(p.frameBegin(i.renderTarget),i.firstCameraUse&&p.onPreRender&&p.onPreRender()),!h&&c.onPreRenderOpaque?c.onPreRenderOpaque(d):h&&c.onPreRenderTransparent&&c.onPreRenderTransparent(d),c._preRenderCalledForCameras&1<<d||(c.onPreRender&&c.onPreRender(d),c._preRenderCalledForCameras|=1<<d),p){var o;if(i.clearColor||i.clearDepth||i.clearStencil){const e=p.camera._clearColorBuffer,t=p.camera._clearDepthBuffer,n=p.camera._clearStencilBuffer;p.camera._clearColorBuffer=i.clearColor,p.camera._clearDepthBuffer=i.clearDepth,p.camera._clearStencilBuffer=i.clearStencil,this.clearView(p.camera,i.renderTarget,!0,!0),p.camera._clearColorBuffer=e,p.camera._clearDepthBuffer=t,p.camera._clearStencilBuffer=n}c._sortVisible(h,p.camera.node,d);const e=c.instances,a=h?e.visibleTransparent[d]:e.visibleOpaque[d];this.scene.immediate.onPreRenderLayer(c,a,h),this.scene._activeCamera=p.camera,this.setCamera(p.camera,i.renderTarget),n&&i.lightClusters&&(i.lightClusters.activate(this.lightTextureAtlas),s||this.scene.lighting.debugLayer!==c.id||(s=!0));const r=!!(p.camera._flipFaces^(null==i||null==(o=i.renderTarget)?void 0:o.flipY)),l=this._forwardDrawCalls;this.renderForward(p.camera,a.list,a.length,c._splitLights,c.shaderPass,c.cullingMask,c.onDrawCall,c,r),c._forwardDrawCalls+=this._forwardDrawCalls-l,t.setColorWrite(!0,!0,!0,!0),t.setStencilTest(!1),t.setAlphaToCoverage(!1),t.setDepthBias(!1),p.frameEnd(),i.lastCameraUse&&p.onPostRender&&p.onPostRender(),i.triggerPostprocess&&p.onPostprocessing&&p.onPostprocessing()}!h&&c.onPostRenderOpaque?c.onPostRenderOpaque(d):h&&c.onPostRenderTransparent&&c.onPostRenderTransparent(d),!c.onPostRender||c._postRenderCalledForCameras&1<<d||(c._postRenderCounter&=~(h?2:1),0===c._postRenderCounter&&(c.onPostRender(d),c._postRenderCalledForCameras|=1<<d,c._postRenderCounter=c._postRenderCounterMax))}}}}let $b,Qb,Jb,ev;const tv=[null,function(e,t){return e.drawOrder-t.drawOrder},function(e,t){return $b=e._key[0],Qb=t._key[0],$b===Qb&&e.mesh&&t.mesh?t.mesh.id-e.mesh.id:Qb-$b},function(e,t){return t.zdist-e.zdist},function(e,t){return e.zdist-t.zdist}];function nv(e,t){return t.key-e.key}let av=0;class iv{constructor(){this.list=[],this.length=0,this.done=!1}}class sv{constructor(){this.opaqueMeshInstances=[],this.transparentMeshInstances=[],this.shadowCasters=[],this.visibleOpaque=[],this.visibleTransparent=[]}prepare(e){this.visibleOpaque[e]||(this.visibleOpaque[e]=new iv),this.visibleTransparent[e]||(this.visibleTransparent[e]=new iv),this.visibleOpaque[e].done=!1,this.visibleTransparent[e].done=!1}delete(e){e<this.visibleOpaque.length&&this.visibleOpaque.splice(e,1),e<this.visibleTransparent.length&&this.visibleTransparent.splice(e,1)}}class rv{constructor(e={}){void 0!==e.id?(this.id=e.id,av=Math.max(this.id+1,av)):this.id=av++,this.name=e.name,this._enabled=void 0===e.enabled||e.enabled,this._refCounter=this._enabled?1:0,this.opaqueSortMode=void 0===e.opaqueSortMode?2:e.opaqueSortMode,this.transparentSortMode=void 0===e.transparentSortMode?3:e.transparentSortMode,this.renderTarget=e.renderTarget,this.shaderPass=void 0===e.shaderPass?0:e.shaderPass,this.passThrough=void 0!==e.passThrough&&e.passThrough,this._clearColorBuffer=!!e.clearColorBuffer&&e.clearColorBuffer,this._clearDepthBuffer=!!e.clearDepthBuffer&&e.clearDepthBuffer,this._clearStencilBuffer=!!e.clearStencilBuffer&&e.clearStencilBuffer,this.onPreCull=e.onPreCull,this.onPreRender=e.onPreRender,this.onPreRenderOpaque=e.onPreRenderOpaque,this.onPreRenderTransparent=e.onPreRenderTransparent,this.onPostCull=e.onPostCull,this.onPostRender=e.onPostRender,this.onPostRenderOpaque=e.onPostRenderOpaque,this.onPostRenderTransparent=e.onPostRenderTransparent,this.onDrawCall=e.onDrawCall,this.onEnable=e.onEnable,this.onDisable=e.onDisable,this._enabled&&this.onEnable&&this.onEnable(),this.layerReference=e.layerReference,this.instances=e.layerReference?e.layerReference.instances:new sv,this.cullingMask=e.cullingMask?e.cullingMask:4294967295,this.opaqueMeshInstances=this.instances.opaqueMeshInstances,this.transparentMeshInstances=this.instances.transparentMeshInstances,this.shadowCasters=this.instances.shadowCasters,this.customSortCallback=null,this.customCalculateSortValues=null,this._lights=[],this._lightsSet=new Set,this._clusteredLightsSet=new Set,this._splitLights=[[],[],[]],this.cameras=[],this._dirty=!1,this._dirtyLights=!1,this._dirtyCameras=!1,this._lightHash=0,this._staticLightHash=0,this._needsStaticPrepare=!0,this._staticPrepareDone=!1,this._shaderVersion=-1,this._lightCube=null}set renderTarget(e){this._renderTarget=e,this._dirtyCameras=!0}get renderTarget(){return this._renderTarget}set enabled(e){e!==this._enabled&&(this._enabled=e,e?(this.incrementCounter(),this.onEnable&&this.onEnable()):(this.decrementCounter(),this.onDisable&&this.onDisable()))}get enabled(){return this._enabled}set clearColor(e){this._clearColor.copy(e)}get clearColor(){return this._clearColor}set clearColorBuffer(e){this._clearColorBuffer=e,this._dirtyCameras=!0}get clearColorBuffer(){return this._clearColorBuffer}set clearDepthBuffer(e){this._clearDepthBuffer=e,this._dirtyCameras=!0}get clearDepthBuffer(){return this._clearDepthBuffer}set clearStencilBuffer(e){this._clearStencilBuffer=e,this._dirtyCameras=!0}get clearStencilBuffer(){return this._clearStencilBuffer}get clusteredLightsSet(){return this._clusteredLightsSet}incrementCounter(){0===this._refCounter&&(this._enabled=!0,this.onEnable&&this.onEnable()),this._refCounter++}decrementCounter(){if(1===this._refCounter)this._enabled=!1,this.onDisable&&this.onDisable();else if(0===this._refCounter)return;this._refCounter--}addMeshInstances(e,t){const n=this._shaderVersion,a=this.shadowCasters;for(let i=0;i<e.length;i++){const s=e[i],r=s.material,o=3===r.blendType?this.opaqueMeshInstances:this.transparentMeshInstances;this.opaqueMeshInstances.indexOf(s)<0&&this.transparentMeshInstances.indexOf(s)<0&&o.push(s),!t&&s.castShadow&&a.indexOf(s)<0&&a.push(s),!this.passThrough&&n>=0&&r._shaderVersion!==n&&(r.updateShader!==Jf.prototype.updateShader&&(r.clearVariants(),r.shader=null),r._shaderVersion=n)}this.passThrough||(this._dirty=!0)}removeMeshInstanceFromArray(e,t){let n=-1,a=0;const i=t.length;for(let s=0;s<i;s++){const i=t[s];if(i===e){n=s,a=1;break}if(i._staticSource===e)n<0&&(n=s),a++;else if(n>=0)break}n>=0&&t.splice(n,a)}removeMeshInstances(e,t){const n=this.opaqueMeshInstances,a=this.transparentMeshInstances,i=this.shadowCasters;for(let s=0;s<e.length;s++){const r=e[s];if(this.removeMeshInstanceFromArray(r,n),this.removeMeshInstanceFromArray(r,a),!t){const e=i.indexOf(r);e>=0&&i.splice(e,1)}}this._dirty=!0}clearMeshInstances(e){(0!==this.opaqueMeshInstances.length||0!==this.transparentMeshInstances.length||!e&&0!==this.shadowCasters.length)&&(this.opaqueMeshInstances.length=0,this.transparentMeshInstances.length=0,e||(this.shadowCasters.length=0),this.passThrough||(this._dirty=!0))}addLight(e){const t=e.light;this._lightsSet.has(t)||(this._lightsSet.add(t),0!==t.type&&this._clusteredLightsSet.add(t),this._lights.push(t),this._dirtyLights=!0,this._generateLightHash())}removeLight(e){const t=e.light;this._lightsSet.has(t)&&(this._lightsSet.delete(t),0!==t.type&&this._clusteredLightsSet.delete(t),this._lights.splice(this._lights.indexOf(t),1),this._dirtyLights=!0,this._generateLightHash())}clearLights(){this._lightsSet.clear(),this._clusteredLightsSet.clear(),this._lights.length=0,this._dirtyLights=!0}addShadowCasters(e){const t=this.shadowCasters;for(let n=0;n<e.length;n++){const a=e[n];a.castShadow&&(t.indexOf(a)<0&&t.push(a))}this._dirtyLights=!0}removeShadowCasters(e){const t=this.shadowCasters;for(let n=0;n<e.length;n++){const a=t.indexOf(e[n]);a>=0&&t.splice(a,1)}this._dirtyLights=!0}_generateLightHash(){if(this._lights.length>0){this._lights.sort(nv);let e="",t="";for(let n=0;n<this._lights.length;n++)this._lights[n].isStatic?t+=this._lights[n].key:e+=this._lights[n].key;0===e.length?this._lightHash=0:this._lightHash=cm(e),0===t.length?this._staticLightHash=0:this._staticLightHash=cm(t)}else this._lightHash=0,this._staticLightHash=0}addCamera(e){this.cameras.indexOf(e)>=0||(this.cameras.push(e),this._dirtyCameras=!0)}removeCamera(e){const t=this.cameras.indexOf(e);t>=0&&(this.cameras.splice(t,1),this._dirtyCameras=!0,this.instances.delete(t))}clearCameras(){this.cameras.length=0,this._dirtyCameras=!0}_calculateSortDistances(e,t,n,a){for(let i=0;i<t;i++){const t=e[i];if(t.command)continue;if(t.layer<=2)continue;if(t.calculateSortDistance){t.zdist=t.calculateSortDistance(t,n,a);continue}const s=t.aabb.center,r=s.x-n.x,o=s.y-n.y,l=s.z-n.z;t.zdist=r*a.x+o*a.y+l*a.z}}_sortVisible(e,t,n){const a=this.instances,i=e?this.transparentSortMode:this.opaqueSortMode;if(0===i)return;const s=e?a.visibleTransparent[n]:a.visibleOpaque[n];5===i?(Jb=t.getPosition(),ev=t.forward,this.customCalculateSortValues&&this.customCalculateSortValues(s.list,s.length,Jb,ev),s.list.length!==s.length&&(s.list.length=s.length),this.customSortCallback&&s.list.sort(this.customSortCallback)):(3!==i&&4!==i||(Jb=t.getPosition(),ev=t.forward,this._calculateSortDistances(s.list,s.length,Jb,ev)),s.list.length!==s.length&&(s.list.length=s.length),s.list.sort(tv[i]))}}const ov=function(e,t){if(e.size!==t.size)return!1;for(const n of e)if(!t.has(n))return!1;return!0},lv=(e,t)=>e.priority-t.priority,cv=e=>e.sort(lv);class hv{constructor(){this.layerIndex=0,this.cameraIndex=0,this.camera=null,this.renderTarget=null,this.lightClusters=null,this.clearColor=!1,this.clearDepth=!1,this.clearStencil=!1,this.triggerPostprocess=!1,this.firstCameraUse=!1,this.lastCameraUse=!1,this.directionalLightsSet=new Set,this.directionalLights=[],this.directionalLightsIndices=[]}reset(){this.lightClusters=null,this.directionalLightsSet.clear(),this.directionalLights.length=0,this.directionalLightsIndices.length=0}collectDirectionalLights(e,t,n){this.directionalLightsSet.clear(),this.directionalLights.length=0,this.directionalLightsIndices.length=0;for(let a=0;a<t.length;a++){const i=t[a];if(i.castShadows)for(let t=0;t<e.length;t++)if(e[t]._splitLights[0].indexOf(i)>=0&&!this.directionalLightsSet.has(i)){this.directionalLightsSet.add(i),this.directionalLights.push(i);const e=n.indexOf(i);this.directionalLightsIndices.push(e)}}}}class dv{constructor(){this.shadowCastersSet=new Set,this.shadowCastersList=[]}clearShadowCasters(){this.shadowCastersSet.clear(),this.shadowCastersList.length=0}addShadowCasters(e){for(let t=0;t<e.length;t++){const n=e[t];this.shadowCastersSet.has(n)||(this.shadowCastersSet.add(n),this.shadowCastersList.push(n))}}}const pv=new Set,uv=[];class mv extends Qp{constructor(e="Untitled"){super(),this.name=e,this.logRenderActions=!1,this.layerList=[],this.subLayerList=[],this.subLayerEnabled=[],this._opaqueOrder={},this._transparentOrder={},this._dirty=!1,this._dirtyBlend=!1,this._dirtyLights=!1,this._dirtyCameras=!1,this._meshInstances=[],this._meshInstancesSet=new Set,this._lights=[],this._lightsMap=new Map,this._lightCompositionData=[],this._splitLights=[[],[],[]],this.cameras=[],this._renderActions=[],this._worldClusters=[],this._emptyWorldClusters=null}destroy(){this._emptyWorldClusters&&(this._emptyWorldClusters.destroy(),this._emptyWorldClusters=null),this._worldClusters.forEach((e=>{e.destroy()})),this._worldClusters=null}getEmptyWorldClusters(e){return this._emptyWorldClusters||(this._emptyWorldClusters=new Hy(e),this._emptyWorldClusters.name="ClusterEmpty",this._emptyWorldClusters.update([],!1,null)),this._emptyWorldClusters}_splitLightsArray(e){const t=e._lights;e._splitLights[0].length=0,e._splitLights[1].length=0,e._splitLights[2].length=0;for(let n=0;n<t.length;n++){const a=t[n];a.enabled&&e._splitLights[a._type].push(a)}}_update(e,t=!1){const n=this.layerList.length;let a=0;if(!this._dirty||!this._dirtyLights||!this._dirtyCameras)for(let e=0;e<n;e++){const t=this.layerList[e];t._dirty&&(this._dirty=!0),t._dirtyLights&&(this._dirtyLights=!0),t._dirtyCameras&&(this._dirtyCameras=!0)}function i(e,t,n){let a=!1;const i=n.length;for(let s=0;s<i;s++){const i=n[s];if(!t.has(i)){t.add(i),e.push(i);const n=i.material;n&&n._dirtyBlend&&(a=!0,n._dirtyBlend=!1)}}return a}if(this._dirty){a|=1,this._meshInstances.length=0,this._meshInstancesSet.clear();for(let e=0;e<n;e++){const t=this.layerList[e];t.passThrough||(this._dirtyBlend=i(this._meshInstances,this._meshInstancesSet,t.opaqueMeshInstances)||this._dirtyBlend,this._dirtyBlend=i(this._meshInstances,this._meshInstancesSet,t.transparentMeshInstances)||this._dirtyBlend),t._dirty=!1}this._dirty=!1}function s(e,t,n){for(let i=0;i<t.length;){var a;(null==(a=t[i].material)?void 0:a.transparent)===n?(e.push(t[i]),t[i]=t[t.length-1],t.length--):i++}}if(this._dirtyBlend){a|=8;for(let e=0;e<n;e++){const t=this.layerList[e];t.passThrough||(s(t.opaqueMeshInstances,t.transparentMeshInstances,!1),s(t.transparentMeshInstances,t.opaqueMeshInstances,!0))}this._dirtyBlend=!1}if(this._dirtyLights&&(a|=2,this._dirtyLights=!1,this.updateLights()),a&&this.updateShadowCasters(),this._dirtyCameras||2&a){this._dirtyCameras=!1,a|=4,this.cameras.length=0;for(let e=0;e<n;e++){const t=this.layerList[e];t._dirtyCameras=!1;for(let e=0;e<t.cameras.length;e++){const n=t.cameras[e];this.cameras.indexOf(n)<0&&this.cameras.push(n)}}this.cameras.length>1&&cv(this.cameras);const i=[];let s=0;for(let e=0;e<this.cameras.length;e++){const t=this.cameras[e];i.length=0;let a=!0;const r=s;let o=null,l=!1;for(let e=0;e<n;e++){const n=this.layerList[e];if(n&&n.cameras.length>0&&t.layers.indexOf(n.id)>=0){i.push(n),l||n.id!==t.disablePostEffectsLayer||(l=!0,o&&(o.triggerPostprocess=!0));const r=n.cameras.indexOf(t);r>=0&&(o=this.addRenderAction(this._renderActions,s,n,e,r,a,l),s++,a=!1)}}r<s&&(this._renderActions[r].collectDirectionalLights(i,this._splitLights[0],this._lights),o.lastCameraUse=!0),!l&&o&&(o.triggerPostprocess=!0),t.renderTarget&&t.postEffectsEnabled&&this.propagateRenderTarget(r-1,t)}this._renderActions.length=s,t&&this.allocateLightClusters(e)}return(2&a||4&a)&&this._logRenderActions(),a}updateShadowCasters(){const e=this._lights.length;for(let t=0;t<e;t++)this._lightCompositionData[t].clearShadowCasters();const t=this.layerList.length;for(let e=0;e<t;e++){const t=this.layerList[e];if(!pv.has(t)){pv.add(t);const e=t._lights;for(let n=0;n<e.length;n++)if(e[n].castShadows){const a=this._lightsMap.get(e[n]);this._lightCompositionData[a].addShadowCasters(t.shadowCasters)}}}pv.clear()}updateLights(){this._lights.length=0,this._lightsMap.clear();const e=this.layerList.length;for(let t=0;t<e;t++){const e=this.layerList[t];if(!pv.has(e)){pv.add(e);const t=e._lights;for(let e=0;e<t.length;e++){const n=t[e];let a=this._lightsMap.get(n);if(void 0===a){a=this._lights.length,this._lightsMap.set(n,a),this._lights.push(n);let e=this._lightCompositionData[a];e||(e=new dv,this._lightCompositionData[a]=e)}}}this._splitLightsArray(e),e._dirtyLights=!1}pv.clear(),this._splitLightsArray(this);const t=this._lights.length;this._lightCompositionData.length=t}findCompatibleCluster(e,t){for(let n=0;n<t;n++){const t=this._renderActions[n],a=this.layerList[t.layerIndex];if(e===a)return t.lightClusters;if(t.lightClusters&&ov(e._clusteredLightsSet,a._clusteredLightsSet))return t.lightClusters}return null}allocateLightClusters(e){uv.push(...this._worldClusters),this._worldClusters.length=0;const t=this._renderActions.length;for(let n=0;n<t;n++){const t=this._renderActions[n],a=this.layerList[t.layerIndex];if(a._clusteredLightsSet.size){if((this.subLayerList[t.layerIndex]?a.transparentMeshInstances:a.opaqueMeshInstances).length){let i=this.findCompatibleCluster(a,n);i||(uv.length&&(i=uv.pop()),i||(i=new Hy(e)),i.name="Cluster-"+this._worldClusters.length,this._worldClusters.push(i)),t.lightClusters=i}}t.lightClusters||(t.lightClusters=this.getEmptyWorldClusters(e))}uv.forEach((e=>{e.destroy()})),uv.length=0}addRenderAction(e,t,n,a,i,s,r){let o=e[t];o||(o=e[t]=new hv);let l=n.renderTarget;const c=n.cameras[i];c&&c.renderTarget&&1!==n.id&&(l=c.renderTarget);let h=!1;for(let n=t-1;n>=0;n--)if(e[n].camera===c&&e[n].renderTarget===l){h=!0;break}const d=s||!h;let p=!!d&&c.clearColorBuffer,u=!!d&&c.clearDepthBuffer,m=!!d&&c.clearStencilBuffer;return p|=n.clearColorBuffer,u|=n.clearDepthBuffer,m|=n.clearStencilBuffer,r&&c.postEffectsEnabled&&(l=null),o.reset(),o.triggerPostprocess=!1,o.layerIndex=a,o.cameraIndex=i,o.camera=c,o.renderTarget=l,o.clearColor=p,o.clearDepth=u,o.clearStencil=m,o.firstCameraUse=s,o.lastCameraUse=!1,o}propagateRenderTarget(e,t){for(let n=e;n>=0;n--){const e=this._renderActions[n],a=this.layerList[e.layerIndex];if(e.renderTarget&&1!==a.id)break;if(1===a.id)continue;const i=null==e?void 0:e.camera.camera;if(i&&(!t.camera.rect.equals(i.rect)||!t.camera.scissorRect.equals(i.scissorRect)))break;e.renderTarget=t.renderTarget}}_logRenderActions(){}_isLayerAdded(e){return this.layerList.indexOf(e)>=0}_isSublayerAdded(e,t){for(let n=0;n<this.layerList.length;n++)if(this.layerList[n]===e&&this.subLayerList[n]===t)return!0;return!1}push(e){this._isLayerAdded(e)||(this.layerList.push(e),this.layerList.push(e),this._opaqueOrder[e.id]=this.subLayerList.push(!1)-1,this._transparentOrder[e.id]=this.subLayerList.push(!0)-1,this.subLayerEnabled.push(!0),this.subLayerEnabled.push(!0),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("add",e))}insert(e,t){if(this._isLayerAdded(e))return;this.layerList.splice(t,0,e,e),this.subLayerList.splice(t,0,!1,!0);const n=this.layerList.length;this._updateOpaqueOrder(t,n-1),this._updateTransparentOrder(t,n-1),this.subLayerEnabled.splice(t,0,!0,!0),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("add",e)}remove(e){let t=this.layerList.indexOf(e);for(delete this._opaqueOrder[t],delete this._transparentOrder[t];t>=0;)this.layerList.splice(t,1),this.subLayerList.splice(t,1),this.subLayerEnabled.splice(t,1),t=this.layerList.indexOf(e),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("remove",e);const n=this.layerList.length;this._updateOpaqueOrder(0,n-1),this._updateTransparentOrder(0,n-1)}pushOpaque(e){this._isSublayerAdded(e,!1)||(this.layerList.push(e),this._opaqueOrder[e.id]=this.subLayerList.push(!1)-1,this.subLayerEnabled.push(!0),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("add",e))}insertOpaque(e,t){if(this._isSublayerAdded(e,!1))return;this.layerList.splice(t,0,e),this.subLayerList.splice(t,0,!1);const n=this.subLayerList.length;this._updateOpaqueOrder(t,n-1),this.subLayerEnabled.splice(t,0,!0),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("add",e)}removeOpaque(e){for(let t=0,n=this.layerList.length;t<n;t++)if(this.layerList[t]===e&&!this.subLayerList[t])return this.layerList.splice(t,1),this.subLayerList.splice(t,1),n--,this._updateOpaqueOrder(t,n-1),this.subLayerEnabled.splice(t,1),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,void(this.layerList.indexOf(e)<0&&this.fire("remove",e))}pushTransparent(e){this._isSublayerAdded(e,!0)||(this.layerList.push(e),this._transparentOrder[e.id]=this.subLayerList.push(!0)-1,this.subLayerEnabled.push(!0),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("add",e))}insertTransparent(e,t){if(this._isSublayerAdded(e,!0))return;this.layerList.splice(t,0,e),this.subLayerList.splice(t,0,!0);const n=this.subLayerList.length;this._updateTransparentOrder(t,n-1),this.subLayerEnabled.splice(t,0,!0),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("add",e)}removeTransparent(e){for(let t=0,n=this.layerList.length;t<n;t++)if(this.layerList[t]===e&&this.subLayerList[t])return this.layerList.splice(t,1),this.subLayerList.splice(t,1),n--,this._updateTransparentOrder(t,n-1),this.subLayerEnabled.splice(t,1),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,void(this.layerList.indexOf(e)<0&&this.fire("remove",e))}_getSublayerIndex(e,t){let n=this.layerList.indexOf(e);if(n<0)return-1;if(this.subLayerList[n]!==t){if(n=this.layerList.indexOf(e,n+1),n<0)return-1;if(this.subLayerList[n]!==t)return-1}return n}getOpaqueIndex(e){return this._getSublayerIndex(e,!1)}getTransparentIndex(e){return this._getSublayerIndex(e,!0)}getLayerById(e){for(let t=0;t<this.layerList.length;t++)if(this.layerList[t].id===e)return this.layerList[t];return null}getLayerByName(e){for(let t=0;t<this.layerList.length;t++)if(this.layerList[t].name===e)return this.layerList[t];return null}_updateOpaqueOrder(e,t){for(let n=e;n<=t;n++)!1===this.subLayerList[n]&&(this._opaqueOrder[this.layerList[n].id]=n)}_updateTransparentOrder(e,t){for(let n=e;n<=t;n++)!0===this.subLayerList[n]&&(this._transparentOrder[this.layerList[n].id]=n)}_sortLayersDescending(e,t,n){let a=-1,i=-1;for(let t=0,i=e.length;t<i;t++){const i=e[t];n.hasOwnProperty(i)&&(a=Math.max(a,n[i]))}for(let e=0,a=t.length;e<a;e++){const a=t[e];n.hasOwnProperty(a)&&(i=Math.max(i,n[a]))}return-1===a&&-1!==i?1:-1===i&&-1!==a?-1:i-a}sortTransparentLayers(e,t){return this._sortLayersDescending(e,t,this._transparentOrder)}sortOpaqueLayers(e,t){return this._sortLayersDescending(e,t,this._opaqueOrder)}}const fv=new Pu,gv=new Pu,yv=new Pu,bv={bias:0,normalBias:0},vv={r:0,g:1,b:2,a:3},_v=[[new Ou(0,0,1,1)],[new Ou(0,0,.5,.5),new Ou(0,.5,.5,.5)],[new Ou(0,0,.5,.5),new Ou(0,.5,.5,.5),new Ou(.5,0,.5,.5)],[new Ou(0,0,.5,.5),new Ou(0,.5,.5,.5),new Ou(.5,0,.5,.5),new Ou(.5,.5,.5,.5)]];let wv=0;class xv{constructor(e,t,n,a){this.light=a,this.camera=t,this.shadowCamera=ub.createShadowCamera(e,a._shadowType,a._type,n),this.shadowMatrix=new zu,this.shadowViewport=new Ou(0,0,1,1),this.shadowScissor=new Ou(0,0,1,1),this.face=n,this.visibleCasters=[]}get shadowBuffer(){const e=this.shadowCamera.renderTarget;if(e){const t=this.light;return 1===t._type?e.colorBuffer:t._isPcf&&t.device.webgl2?e.depthBuffer:e.colorBuffer}return null}}class Cv{constructor(e){this.device=e,this.id=wv++,this._type=0,this._color=new Mu(.8,.8,.8),this._intensity=1,this._castShadows=!1,this._enabled=!1,this.mask=1,this.isStatic=!1,this.key=0,this.bakeDir=!0,this.bakeNumSamples=1,this.bakeArea=0,this.attenuationStart=10,this.attenuationEnd=10,this._falloffMode=0,this._shadowType=0,this._vsmBlurSize=11,this.vsmBlurMode=1,this.vsmBias=.0025,this._cookie=null,this.cookieIntensity=1,this._cookieFalloff=!0,this._cookieChannel="rgb",this._cookieTransform=null,this._cookieTransformUniform=new Float32Array(4),this._cookieOffset=null,this._cookieOffsetUniform=new Float32Array(2),this._cookieTransformSet=!1,this._cookieOffsetSet=!1,this._innerConeAngle=40,this._outerConeAngle=45,this.cascades=null,this._shadowMatrixPalette=null,this._shadowCascadeDistances=null,this.numCascades=1,this.cascadeDistribution=.5,this._shape=0,this._finalColor=new Float32Array([.8,.8,.8]);const t=Math.pow(this._finalColor[0],2.2);this._linearFinalColor=new Float32Array([t,t,t]),this._position=new Pu(0,0,0),this._direction=new Pu(0,0,0),this._innerConeAngleCos=Math.cos(this._innerConeAngle*Math.PI/180),this._outerConeAngleCos=Math.cos(this._outerConeAngle*Math.PI/180),this._shadowMap=null,this._shadowRenderParams=[],this.shadowDistance=40,this._shadowResolution=1024,this.shadowBias=-5e-4,this._normalOffsetBias=0,this.shadowUpdateMode=2,this._isVsm=!1,this._isPcf=!0,this._cookieMatrix=null,this._atlasViewport=null,this.atlasViewportAllocated=!1,this.atlasVersion=0,this.atlasSlotIndex=0,this.atlasSlotUpdated=!1,this._scene=null,this._node=null,this._renderData=[],this.visibleThisFrame=!1,this.maxScreenSize=0}destroy(){this._destroyShadowMap(),this._renderData=null}set numCascades(e){this.cascades&&this.numCascades==e||(this.cascades=_v[e-1],this._shadowMatrixPalette=new Float32Array(64),this._shadowCascadeDistances=new Float32Array(4),this._destroyShadowMap(),this.updateKey())}get numCascades(){return this.cascades.length}set shadowMap(e){this._shadowMap!==e&&(this._destroyShadowMap(),this._shadowMap=e)}get shadowMap(){return this._shadowMap}get numShadowFaces(){const e=this._type;return 0===e?this.numCascades:1===e?6:1}set type(e){if(this._type===e)return;this._type=e,this._destroyShadowMap(),this.updateKey();const t=this._shadowType;this._shadowType=null,this.shadowType=t}get type(){return this._type}set shape(e){if(this._shape===e)return;this._shape=e,this._destroyShadowMap(),this.updateKey();const t=this._shadowType;this._shadowType=null,this.shadowType=t}get shape(){return this._shape}set shadowType(e){if(this._shadowType===e)return;const t=this.device;1===this._type&&(e=0),4!==e||t.webgl2||(e=0),3!==e||t.textureFloatRenderable||(e=2),2!==e||t.textureHalfFloatRenderable||(e=1),this._isVsm=e>=1&&e<=3,this._isPcf=4===e||0===e,this._shadowType=e,this._destroyShadowMap(),this.updateKey()}get shadowType(){return this._shadowType}set enabled(e){this._enabled!==e&&(this._enabled=e,this.layersDirty())}get enabled(){return this._enabled}set castShadows(e){this._castShadows!==e&&(this._castShadows=e,this._destroyShadowMap(),this.layersDirty(),this.updateKey())}get castShadows(){return this._castShadows&&4!==this.mask&&0!==this.mask}set shadowResolution(e){this._shadowResolution!==e&&(e=1===this._type?Math.min(e,this.device.maxCubeMapSize):Math.min(e,this.device.maxTextureSize),this._shadowResolution=e,this._destroyShadowMap())}get shadowResolution(){return this._shadowResolution}set vsmBlurSize(e){this._vsmBlurSize!==e&&(e%2==0&&e++,this._vsmBlurSize=e)}get vsmBlurSize(){return this._vsmBlurSize}set normalOffsetBias(e){this._normalOffsetBias!==e&&((!this._normalOffsetBias&&e||this._normalOffsetBias&&!e)&&this.updateKey(),this._normalOffsetBias=e)}get normalOffsetBias(){return this._normalOffsetBias}set falloffMode(e){this._falloffMode!==e&&(this._falloffMode=e,this.updateKey())}get falloffMode(){return this._falloffMode}set innerConeAngle(e){this._innerConeAngle!==e&&(this._innerConeAngle=e,this._innerConeAngleCos=Math.cos(e*Math.PI/180))}get innerConeAngle(){return this._innerConeAngle}set outerConeAngle(e){this._outerConeAngle!==e&&(this._outerConeAngle=e,this._outerConeAngleCos=Math.cos(e*Math.PI/180))}get outerConeAngle(){return this._outerConeAngle}set intensity(e){this._intensity!==e&&(this._intensity=e,this._updateFinalColor())}get intensity(){return this._intensity}get cookieMatrix(){return this._cookieMatrix||(this._cookieMatrix=new zu),this._cookieMatrix}get atlasViewport(){return this._atlasViewport||(this._atlasViewport=new Ou(0,0,1,1)),this._atlasViewport}set cookie(e){this._cookie!==e&&(this._cookie=e,this.updateKey())}get cookie(){return this._cookie}set cookieFalloff(e){this._cookieFalloff!==e&&(this._cookieFalloff=e,this.updateKey())}get cookieFalloff(){return this._cookieFalloff}set cookieChannel(e){if(this._cookieChannel!==e){if(e.length<3){const t=e.charAt(e.length-1),n=3-e.length;for(let a=0;a<n;a++)e+=t}this._cookieChannel=e,this.updateKey()}}get cookieChannel(){return this._cookieChannel}set cookieTransform(e){this._cookieTransform!==e&&(this._cookieTransform=e,this._cookieTransformSet=!!e,e&&!this._cookieOffset&&(this.cookieOffset=new Du,this._cookieOffsetSet=!1),this.updateKey())}get cookieTransform(){return this._cookieTransform}set cookieOffset(e){if(this._cookieOffset===e)return;!(!this._cookieTransformSet&&!e)&&!e&&this._cookieOffset?this._cookieOffset.set(0,0):this._cookieOffset=e,this._cookieOffsetSet=!!e,e&&!this._cookieTransform&&(this.cookieTransform=new Ou(1,1,0,0),this._cookieTransformSet=!1),this.updateKey()}get cookieOffset(){return this._cookieOffset}beginFrame(){this.visibleThisFrame=0===this._type&&this._enabled,this.maxScreenSize=0,this.atlasViewportAllocated=!1,this.atlasSlotUpdated=!1}_destroyShadowMap(){this._renderData&&(this._renderData.length=0),this._shadowMap&&(this._shadowMap.cached||this._shadowMap.destroy(),this._shadowMap=null),0===this.shadowUpdateMode&&(this.shadowUpdateMode=1)}getRenderData(e,t){for(let n=0;n<this._renderData.length;n++){const a=this._renderData[n];if(a.camera===e&&a.face===t)return a}const n=new xv(this.device,e,t,this);return this._renderData.push(n),n}clone(){const e=new Cv(this.device);return e.type=this._type,e.setColor(this._color),e.intensity=this._intensity,e.castShadows=this.castShadows,e._enabled=this._enabled,e.attenuationStart=this.attenuationStart,e.attenuationEnd=this.attenuationEnd,e.falloffMode=this._falloffMode,e.shadowType=this._shadowType,e.vsmBlurSize=this._vsmBlurSize,e.vsmBlurMode=this.vsmBlurMode,e.vsmBias=this.vsmBias,e.shadowUpdateMode=this.shadowUpdateMode,e.mask=this.mask,e.innerConeAngle=this._innerConeAngle,e.outerConeAngle=this._outerConeAngle,e.numCascades=this.numCascades,e.cascadeDistribution=this.cascadeDistribution,e.shape=this._shape,e.shadowBias=this.shadowBias,e.normalOffsetBias=this._normalOffsetBias,e.shadowResolution=this._shadowResolution,e.shadowDistance=this.shadowDistance,e}_getUniformBiasValues(e){const t=e.shadowCamera._farClip;switch(this._type){case 1:bv.bias=this.shadowBias,bv.normalBias=this._normalOffsetBias;break;case 2:this._isVsm?bv.bias=-2e-4:(bv.bias=20*this.shadowBias,!this.device.webgl2&&this.device.extStandardDerivatives&&(bv.bias*=-100)),bv.normalBias=this._isVsm?this.vsmBias/(this.attenuationEnd/7):this._normalOffsetBias;break;case 0:this._isVsm?bv.bias=-2e-4:(bv.bias=this.shadowBias/t*100,!this.device.webgl2&&this.device.extStandardDerivatives&&(bv.bias*=-100)),bv.normalBias=this._isVsm?this.vsmBias/(t/7):this._normalOffsetBias}return bv}getColor(){return this._color}getBoundingSphere(e){if(2===this._type){const t=this.attenuationEnd,n=this._outerConeAngle,a=Math.cos(n*Eu.DEG_TO_RAD),i=this._node;fv.copy(i.up),fv.mulScalar(.5*-t*a),fv.add(i.getPosition()),e.center=fv,gv.copy(i.up),gv.mulScalar(-t),yv.copy(i.right),yv.mulScalar(Math.sin(n*Eu.DEG_TO_RAD)*t),gv.add(yv),e.radius=.5*gv.length()}else 1===this._type&&(e.center=this._node.getPosition(),e.radius=this.attenuationEnd)}getBoundingBox(e){if(2===this._type){const t=this.attenuationEnd,n=this._outerConeAngle,a=this._node,i=Math.abs(Math.sin(n*Eu.DEG_TO_RAD)*t);e.center.set(0,.5*-t,0),e.halfExtents.set(i,.5*t,i),e.setFromTransformedAabb(e,a.getWorldTransform(),!0)}else 1===this._type&&(e.center.copy(this._node.getPosition()),e.halfExtents.set(this.attenuationEnd,this.attenuationEnd,this.attenuationEnd))}_updateFinalColor(){const e=this._color,t=e.r,n=e.g,a=e.b,i=this._intensity,s=this._finalColor,r=this._linearFinalColor;s[0]=t*i,s[1]=n*i,s[2]=a*i,i>=1?(r[0]=Math.pow(t,2.2)*i,r[1]=Math.pow(n,2.2)*i,r[2]=Math.pow(a,2.2)*i):(r[0]=Math.pow(s[0],2.2),r[1]=Math.pow(s[1],2.2),r[2]=Math.pow(s[2],2.2))}setColor(){1===arguments.length?this._color.set(arguments[0].r,arguments[0].g,arguments[0].b):3===arguments.length&&this._color.set(arguments[0],arguments[1],arguments[2]),this._updateFinalColor()}updateShadow(){2!==this.shadowUpdateMode&&(this.shadowUpdateMode=1)}layersDirty(){var e;null!=(e=this._scene)&&e.layers&&(this._scene.layers._dirtyLights=!0)}updateKey(){let e=this._type<<29|(this._castShadows?1:0)<<28|this._shadowType<<25|this._falloffMode<<23|(0!==this._normalOffsetBias?1:0)<<22|(this._cookie?1:0)<<21|(this._cookieFalloff?1:0)<<20|vv[this._cookieChannel.charAt(0)]<<18|(this._cookieTransform?1:0)<<12|this._shape<<10|this.numCascades-1<<8;3===this._cookieChannel.length&&(e|=vv[this._cookieChannel.charAt(1)]<<16,e|=vv[this._cookieChannel.charAt(2)]<<14),e!==this.key&&null!==this._scene&&this.layersDirty(),this.key=e}}class Tv{constructor(e,t,n){this._maxTextureSize=t,this._supportsAreaLights=e,this._dirtyLightsFnc=n,this._areaLightsEnabled=!1,this._cells=new Pu(10,3,10),this._maxLightsPerCell=255,this._shadowsEnabled=!0,this._shadowType=0,this._shadowAtlasResolution=2048,this._cookiesEnabled=!1,this._cookieAtlasResolution=2048,this.atlasSplit=null,this.debugLayer=void 0}set cells(e){this._cells.copy(e)}get cells(){return this._cells}set maxLightsPerCell(e){this._maxLightsPerCell=Eu.clamp(e,1,255)}get maxLightsPerCell(){return this._maxLightsPerCell}set cookieAtlasResolution(e){this._cookieAtlasResolution=Eu.clamp(e,32,this._maxTextureSize)}get cookieAtlasResolution(){return this._cookieAtlasResolution}set shadowAtlasResolution(e){this._shadowAtlasResolution=Eu.clamp(e,32,this._maxTextureSize)}get shadowAtlasResolution(){return this._shadowAtlasResolution}set shadowType(e){this._shadowType!==e&&(this._shadowType=e,this._dirtyLightsFnc())}get shadowType(){return this._shadowType}set cookiesEnabled(e){this._cookiesEnabled!==e&&(this._cookiesEnabled=e,this._dirtyLightsFnc())}get cookiesEnabled(){return this._cookiesEnabled}set areaLightsEnabled(e){this._supportsAreaLights&&this._areaLightsEnabled!==e&&(this._areaLightsEnabled=e,this._dirtyLightsFnc())}get areaLightsEnabled(){return this._areaLightsEnabled}set shadowsEnabled(e){this._shadowsEnabled!==e&&(this._shadowsEnabled=e,this._dirtyLightsFnc())}get shadowsEnabled(){return this._shadowsEnabled}}const Ev=new $u;class Sv{constructor(e,t){this.scene=e,this.light=t,this.store(),t.numCascades=1,0!==t.type&&(t._node.getWorldTransform(),t.getBoundingSphere(Ev),this.lightBounds=new qu,this.lightBounds.center.copy(Ev.center),this.lightBounds.halfExtents.set(Ev.radius,Ev.radius,Ev.radius))}store(){this.mask=this.light.mask,this.shadowUpdateMode=this.light.shadowUpdateMode,this.enabled=this.light.enabled,this.intensity=this.light.intensity,this.rotation=this.light._node.getLocalRotation().clone(),this.numCascades=this.light.numCascades}restore(){const e=this.light;e.mask=this.mask,e.shadowUpdateMode=this.shadowUpdateMode,e.enabled=this.enabled,e.intensity=this.intensity,e._node.setLocalRotation(this.rotation),e.numCascades=this.numCascades}startBake(){this.light.enabled=!0,this.light._destroyShadowMap()}endBake(e){const t=this.light;t.enabled=!1,t.shadowMap&&(t.shadowMap.cached&&e.add(t,t.shadowMap),t.shadowMap=null)}}const Av=new Du;class Mv extends Sv{get numVirtualLights(){return 0===this.light.type?this.light.bakeNumSamples:1}prepareVirtualLight(e,t){const n=this.light;if(n._node.setLocalRotation(this.rotation),e>0){const a=n.bakeArea;Sf(Av,e,t),Av.mulScalar(.5*a),n._node.rotateLocal(Av.x,0,Av.y)}n._node.getWorldTransform();const a=this.scene.gammaCorrection?2.2:1,i=Math.pow(this.intensity,a);n.intensity=Math.pow(i/t,1/a)}}class Lv{constructor(e,t){this.texture0=e,this.texture1=t}destroy(){var e,t;null==(e=this.texture0)||e.destroy(),null==(t=this.texture1)||t.destroy()}}const Rv=new dm;class Iv{static createTexture(e,t,n,a=""){const i=new Gm(e,{width:n,height:n,format:t,addressU:1,addressV:1,type:"default",magFilter:1,minFilter:0,anisotropy:1});return i.name=`AreaLightLUT${a}`,i}static applyTextures(e,t,n){Rv.remove(e),Rv.get(e,(()=>new Lv(t,t===n?null:n))),e.scope.resolve("areaLightsLutTex1").setValue(t),e.scope.resolve("areaLightsLutTex2").setValue(n)}static createPlaceholder(e){const t=Iv.createTexture(e,7,2,"placeholder");t.lock().fill(0),t.unlock(),Iv.applyTextures(e,t,t)}static set(e,t){function n(e,t,n){const a=Iv.createTexture(e,n,64);return a.lock().set(t),a.unlock(),a.upload(),a}function a(e,t,n){const a=e.length,i=new Float32Array(a);for(let s=0;s<a;s++){const a=s%4;i[s]=(e[s]+t[a])*n[a]}return i}function i(e){const t=e.length,n=new Uint16Array(t),a=Bm.float2Half;for(let i=0;i<t;i++)n[i]=a(e[i]);return n}function s(e){const t=e.length,n=new Uint8ClampedArray(t);for(let a=0;a<t;a++)n[a]=255*e[a];return n}const r=new Int16Array(t,0,2),o=r[0],l=r[1];if(0!==o||1!==l);else{const r=new Float32Array(t,4,16384),o=new Float32Array(t,65540,16384);let l,c;const h=e.areaLightLutFormat;if(14===h)l=r,c=o;else if(12===h)l=i(r),c=i(o);else{const e=[-.306897,0,0,0],t=[1.442787,1,1,1];l=s(a(r,[0,.2976,.01381,0],[.999,3.08737,1.6546,.603249])),c=s(a(o,e,t))}const d=n(e,l,h),p=n(e,c,h);Iv.applyTextures(e,d,p)}}}class Pv extends $g{constructor(e,t){super(),this.device=t||Jg().graphicsDevice,this._targets=e,this.device.supportsMorphTargetTexturesCore&&(this.device.extTextureHalfFloat&&this.device.textureHalfFloatRenderable?this._renderTextureFormat=Pv.FORMAT_HALF_FLOAT:this.device.extTextureFloat&&this.device.textureFloatRenderable&&(this._renderTextureFormat=Pv.FORMAT_FLOAT),this.device.extTextureHalfFloat&&this.device.textureHalfFloatUpdatable?this._textureFormat=Pv.FORMAT_HALF_FLOAT:this.device.extTextureFloat&&(this._textureFormat=Pv.FORMAT_FLOAT),void 0!==this._renderTextureFormat&&void 0!==this._textureFormat&&(this._useTextureMorph=!0)),this._init(),this._updateMorphFlags(),this._calculateAabb()}get morphPositions(){return this._morphPositions}get morphNormals(){return this._morphNormals}get maxActiveTargets(){return this._useTextureMorph?this._targets.length:this._morphPositions&&this._morphNormals?4:8}get useTextureMorph(){return this._useTextureMorph}_init(){if(this._useTextureMorph&&(this._useTextureMorph=this._initTextureBased()),!this._useTextureMorph)for(let e=0;e<this._targets.length;e++)this._targets[e]._initVertexBuffers(this.device);for(let e=0;e<this._targets.length;e++)this._targets[e]._postInit()}_initTextureBased(){const e=[],t=[];for(let n=0;n<this._targets.length;n++){const a=this._targets[n];a.options.deltaPositions&&(e.push(a.options.deltaPositions),t.push({target:a,name:"texturePositions"})),a.options.deltaNormals&&(e.push(a.options.deltaNormals),t.push({target:a,name:"textureNormals"}))}const n=[],a=[];let i=1;const s=e[0].length;for(let t=0;t<s;t+=3){let s=!1;for(let n=0;n<e.length;n++){const a=e[n];if(0!==a[t]||0!==a[t+1]||0!==a[t+2]){s=!0;break}}s?(n.push(i+.2),a.push(t/3),i++):n.push(.2)}const r=Math.min(this.device.maxTextureSize,4096);let o=Math.ceil(Math.sqrt(i));o=Math.min(o,r);const l=Math.ceil(i/o);if(l>r)return!1;this.morphTextureWidth=o,this.morphTextureHeight=l;let c=!1,h=3;const d=Bm.float2Half;this._textureFormat===Pv.FORMAT_HALF_FLOAT&&(c=!0,h=4);const p=this.morphTextureWidth*this.morphTextureHeight*h,u=c?new Uint16Array(p):new Float32Array(p);for(let n=0;n<e.length;n++){const i=e[n];for(let e=0;e<a.length;e++){const t=a[e];c?(u[e*h+h]=d(i[3*t]),u[e*h+h+1]=d(i[3*t+1]),u[e*h+h+2]=d(i[3*t+2])):(u[e*h+h]=i[3*t],u[e*h+h+1]=i[3*t+1],u[e*h+h+2]=i[3*t+2])}const s=t[n].target,r=this._textureFormat===Pv.FORMAT_FLOAT?13:12;s._setTexture(t[n].name,this._createTexture("MorphTarget",r,u))}const m=[{semantic:"ATTR15",components:1,type:6}];return this.vertexBufferIds=new lm(this.device,new hm(this.device,m),n.length,0,new Float32Array(n)),!0}destroy(){this.vertexBufferIds&&(this.vertexBufferIds.destroy(),this.vertexBufferIds=null);for(let e=0;e<this._targets.length;e++)this._targets[e].destroy();this._targets.length=0}get targets(){return this._targets}_updateMorphFlags(){this._morphPositions=!1,this._morphNormals=!1;for(let e=0;e<this._targets.length;e++){const t=this._targets[e];t.morphPositions&&(this._morphPositions=!0),t.morphNormals&&(this._morphNormals=!0)}}_calculateAabb(){const e=new Pu,t=new Pu;for(let n=0;n<this._targets.length;n++){const a=this._targets[n].aabb;e.min(a.getMin()),t.max(a.getMax())}this.aabb=new qu,this.aabb.setMinMax(e,t)}_createTexture(e,t,n){const a=new Gm(this.device,{width:this.morphTextureWidth,height:this.morphTextureHeight,format:t,cubemap:!1,mipmaps:!1,minFilter:0,magFilter:0,addressU:1,addressV:1});return a.name=e,n&&(a.lock().set(n),a.unlock()),a}}Pv.FORMAT_FLOAT=0,Pv.FORMAT_HALF_FLOAT=1;class kv{constructor(e){this.morph=e,e.incRefCount(),this.device=e.device,this.meshInstance=null,this._weights=[];for(let t=0;t<e._targets.length;t++)this.setWeight(t,e._targets[t].defaultWeight);if(this._activeTargets=[],e.useTextureMorph){this.shaderCache={},this.maxSubmitCount=this.device.maxTextures,this._shaderMorphWeights=new Float32Array(this.maxSubmitCount);const t=(t,n)=>{const a=e._renderTextureFormat===Pv.FORMAT_FLOAT?14:12;return this[n]=e._createTexture(t,a),new Cg({colorBuffer:this[n],depth:!1})};e.morphPositions&&(this.rtPositions=t("MorphRTPos","texturePositions")),e.morphNormals&&(this.rtNormals=t("MorphRTNrm","textureNormals")),this._textureParams=new Float32Array([e.morphTextureWidth,e.morphTextureHeight,1/e.morphTextureWidth,1/e.morphTextureHeight]);for(let e=0;e<this.maxSubmitCount;e++)this["morphBlendTex"+e]=this.device.scope.resolve("morphBlendTex"+e);this.morphFactor=this.device.scope.resolve("morphFactor[0]"),this.zeroTextures=!1}else this.maxSubmitCount=8,this._shaderMorphWeights=new Float32Array(this.maxSubmitCount),this._shaderMorphWeightsA=new Float32Array(this._shaderMorphWeights.buffer,0,4),this._shaderMorphWeightsB=new Float32Array(this._shaderMorphWeights.buffer,16,4),this._activeVertexBuffers=new Array(this.maxSubmitCount)}destroy(){this.meshInstance=null,this.shader=null;const e=this.morph;e&&(this.morph=null,e.decRefCount(),e.refCount<1&&e.destroy()),this.rtPositions&&(this.rtPositions.destroy(),this.rtPositions=null),this.texturePositions&&(this.texturePositions.destroy(),this.texturePositions=null),this.rtNormals&&(this.rtNormals.destroy(),this.rtNormals=null),this.textureNormals&&(this.textureNormals.destroy(),this.textureNormals=null)}clone(){return new kv(this.morph)}getWeight(e){return this._weights[e]}setWeight(e,t){this._weights[e]=t,this._dirty=!0}_getFragmentShader(e){let t="";e>0&&(t+="varying vec2 uv0;\nuniform highp float morphFactor["+e+"];\n");for(let n=0;n<e;n++)t+="uniform highp sampler2D morphBlendTex"+n+";\n";t+="void main (void) {\n\t\thighp vec4 color = vec4(0, 0, 0, 1);\n";for(let n=0;n<e;n++)t+="\t\tcolor.xyz += morphFactor["+n+"] * texture2D(morphBlendTex"+n+", uv0).xyz;\n";return t+="\t\tgl_FragColor = color;\n}\n",t}_getShader(e){let t=this.shaderCache[e];if(!t){const n=this._getFragmentShader(e);t=Mm(this.device,"\n\t\tattribute vec2 vertex_position;\n\t\tvarying vec2 uv0;\n\t\tvoid main(void) {\n\t\t\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\t\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t\t}\n\t\t",n,"textureMorph"+e),this.shaderCache[e]=t}return t}_updateTextureRenderTarget(e,t){const n=this.device,a=(t,a)=>{this.morphFactor.setValue(this._shaderMorphWeights),n.setBlending(a),a&&(n.setBlendFunction(1,1),n.setBlendEquation(0));const i=this._getShader(t);mm(n,e,i,void 0,void 0,a)};let i=0,s=!1;const r=this._activeTargets.length;for(let e=0;e<r;e++){const n=this._activeTargets[e],r=n.target[t];r&&(this["morphBlendTex"+i].setValue(r),this._shaderMorphWeights[i]=n.weight,i++,i>=this.maxSubmitCount&&(a(i,s),i=0,s=!0))}(i>0||0===r&&!this.zeroTextures)&&a(i,s)}_updateTextureMorph(){this.device,(this._activeTargets.length>0||!this.zeroTextures)&&(this._updateTextureRenderTarget(this.rtPositions,"texturePositions"),this._updateTextureRenderTarget(this.rtNormals,"textureNormals"),this.zeroTextures=0===this._activeTargets.length)}_updateVertexMorph(){const e=this.maxSubmitCount;for(let t=0;t<e;t++)this._shaderMorphWeights[t]=0,this._activeVertexBuffers[t]=null;let t=0,n=this.morph.morphPositions?4:0;for(let e=0;e<this._activeTargets.length;e++){const a=this._activeTargets[e].target;a._vertexBufferPositions&&(this._activeVertexBuffers[t]=a._vertexBufferPositions,this._shaderMorphWeights[t]=this._activeTargets[e].weight,t++),a._vertexBufferNormals&&(this._activeVertexBuffers[n]=a._vertexBufferNormals,this._shaderMorphWeights[n]=this._activeTargets[e].weight,n++)}}update(){this._dirty=!1;const e=this.morph._targets;let t=0;for(let n=0;n<e.length;n++){const a=Math.abs(this.getWeight(n));if(a>1e-5){this._activeTargets.length<=t&&(this._activeTargets[t]={});const i=this._activeTargets[t++];i.absWeight=a,i.weight=this.getWeight(n),i.target=e[n]}}this._activeTargets.length=t;const n=this.morph.maxActiveTargets;this._activeTargets.length>n&&(this._activeTargets.sort((function(e,t){return e.absWeight<t.absWeight?1:t.absWeight<e.absWeight?-1:0})),this._activeTargets.length=n),this.morph.useTextureMorph?this._updateTextureMorph():this._updateVertexMorph()}}class Dv{constructor(){this.graph=null,this.meshInstances=[],this.skinInstances=[],this.morphInstances=[],this.cameras=[],this.lights=[],this._shadersVersion=0,this._immutable=!1}getGraph(){return this.graph}setGraph(e){this.graph=e}getCameras(){return this.cameras}setCameras(e){this.cameras=e}getLights(){return this.lights}setLights(e){this.lights=e}getMaterials(){const e=[];for(let t=0;t<this.meshInstances.length;t++){const n=this.meshInstances[t];-1===e.indexOf(n.material)&&e.push(n.material)}return e}clone(){const e=[],t=[],n=function n(a){const i=a.clone();e.push(a),t.push(i);for(let e=0;e<a._children.length;e++)i.addChild(n(a._children[e]));return i}(this.graph),a=[],i=[],s=[];for(let e=0;e<this.skinInstances.length;e++){const t=this.skinInstances[e].skin,a=new by(t),s=[];for(let e=0;e<t.boneNames.length;e++){const a=t.boneNames[e],i=n.findByName(a);s.push(i)}a.bones=s,i.push(a)}for(let e=0;e<this.morphInstances.length;e++){const t=this.morphInstances[e].morph,n=new kv(t);s.push(n)}for(let n=0;n<this.meshInstances.length;n++){const r=this.meshInstances[n],o=e.indexOf(r.node),l=new Ay(r.mesh,r.material,t[o]);if(r.skinInstance){const e=this.skinInstances.indexOf(r.skinInstance);l.skinInstance=i[e]}if(r.morphInstance){const e=this.morphInstances.indexOf(r.morphInstance);l.morphInstance=s[e]}a.push(l)}const r=new Dv;return r.graph=n,r.meshInstances=a,r.skinInstances=i,r.morphInstances=s,r.getGraph().syncHierarchy(),r}destroy(){const e=this.meshInstances;for(let t=0;t<e.length;t++)e[t].destroy();this.meshInstances.length=0}generateWireframe(){Ay._prepareRenderStyleForArray(this.meshInstances,1)}}const Ov=new hf;Ov.worldTransform=zu.IDENTITY,Ov._dirtyWorld=Ov._dirtyNormal=!1;class Fv{constructor(e,t,n){this.material=t,this.layer=n,this.positions=[],this.colors=[],this.mesh=new iy(e),this.meshInstance=null}addLines(e,t){const n=this.positions,a=e.length;for(let t=0;t<a;t++){const a=e[t];n.push(a.x,a.y,a.z)}const i=this.colors;if(t.length)for(let e=0;e<a;e++){const n=t[e];i.push(n.r,n.g,n.b,n.a)}else for(let e=0;e<a;e++)i.push(t.r,t.g,t.b,t.a)}addLinesArrays(e,t){this.positions.push(...e);const n=this.colors;if(t.length)n.push(...t);else{const a=e.length/3;for(let e=0;e<a;e++)n.push(t.r,t.g,t.b,t.a)}}onPreRender(e,t){this.positions.length>0&&this.material.transparent===t&&(this.mesh.setPositions(this.positions),this.mesh.setColors(this.colors),this.mesh.update(1,!1),this.meshInstance||(this.meshInstance=new Ay(this.mesh,this.material,Ov)),this.positions.length=0,this.colors.length=0,e.list.push(this.meshInstance),e.length++)}}class Nv{constructor(e){this.device=e,this.map=new Map}getBatch(e,t){let n=this.map.get(e);return n||(n=new Fv(this.device,e,t),this.map.set(e,n)),n}onPreRender(e,t){this.map.forEach((n=>{n.onPreRender(e,t)}))}}const Vv=[];class Bv{constructor(e){this.device=e,this.quadMesh=null,this.textureShader=null,this.depthTextureShader=null,this.cubeLocalPos=null,this.cubeWorldPos=null,this.batchesMap=new Map,this.allBatches=new Set,this.updatedLayers=new Set,this._materialDepth=null,this._materialNoDepth=null,this.layerMeshInstances=new Map}createMaterial(e){const t=new my;return t.vertexColors=!0,t.blend=!0,t.blendType=2,t.depthTest=e,t.update(),t}get materialDepth(){return this._materialDepth||(this._materialDepth=this.createMaterial(!0)),this._materialDepth}get materialNoDepth(){return this._materialNoDepth||(this._materialNoDepth=this.createMaterial(!1)),this._materialNoDepth}getBatch(e,t){let n=this.batchesMap.get(e);n||(n=new Nv(this.device),this.batchesMap.set(e,n)),this.allBatches.add(n);const a=t?this.materialDepth:this.materialNoDepth;return n.getBatch(a,e)}static getTextureVS(){return"\n\t\t\t\t\t\tattribute vec2 aPosition;\n\t\t\t\t\t\tuniform mat4 matrix_model;\n\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\tvoid main(void) {\n\t\t\t\t\t\t\t\tgl_Position = matrix_model * vec4(aPosition, 0, 1);\n\t\t\t\t\t\t\t\tuv0 = aPosition.xy + 0.5;\n\t\t\t\t\t\t}\n\t\t\t\t"}getTextureShader(){if(!this.textureShader){const e={attributes:{aPosition:"POSITION"},vshader:Bv.getTextureVS(),fshader:"\n\t\t\t\t\t\t\t\t\t\tprecision lowp float;\n\t\t\t\t\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\t\t\t\t\tuniform sampler2D colorMap;\n\t\t\t\t\t\t\t\t\t\tvoid main (void) {\n\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t"};this.textureShader=new fm(this.device,e)}return this.textureShader}getDepthTextureShader(){if(!this.depthTextureShader){const e=this.device.webgl2?"#define GL2":"",t={attributes:{aPosition:"POSITION"},vshader:Bv.getTextureVS(),fshader:`\n\t\t\t\t\t\t\t\t\t\tprecision ${this.device.precision} float;\n\t\t\t\t\t\t\t\t\t\t${e}\n\t\t\t\t\t\t\t\t\t\t${gm.screenDepthPS}\n\t\t\t\t\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t\t\t\t\t\t\tfloat depth = getLinearScreenDepth(uv0) * camera_params.x;\n\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = vec4(vec3(depth), 1.0);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t`};this.depthTextureShader=new fm(this.device,t)}return this.depthTextureShader}getQuadMesh(){return this.quadMesh||(this.quadMesh=new iy(this.device),this.quadMesh.setPositions([-.5,-.5,0,.5,-.5,0,-.5,.5,0,.5,.5,0]),this.quadMesh.update(5)),this.quadMesh}drawMesh(e,t,n,a,i){if(!a){const i=this.getGraphNode(t);a=new Ay(n,e,i)}let s=this.layerMeshInstances.get(i);s||(s=[],this.layerMeshInstances.set(i,s)),s.push(a)}drawWireAlignedBox(e,t,n,a,i){Vv.push(e.x,e.y,e.z,e.x,t.y,e.z,e.x,t.y,e.z,t.x,t.y,e.z,t.x,t.y,e.z,t.x,e.y,e.z,t.x,e.y,e.z,e.x,e.y,e.z,e.x,e.y,t.z,e.x,t.y,t.z,e.x,t.y,t.z,t.x,t.y,t.z,t.x,t.y,t.z,t.x,e.y,t.z,t.x,e.y,t.z,e.x,e.y,t.z,e.x,e.y,e.z,e.x,e.y,t.z,e.x,t.y,e.z,e.x,t.y,t.z,t.x,t.y,e.z,t.x,t.y,t.z,t.x,e.y,e.z,t.x,e.y,t.z);this.getBatch(i,a).addLinesArrays(Vv,n),Vv.length=0}drawWireSphere(e,t,n,a,i,s){const r=2*Math.PI/a;let o=0;for(let n=0;n<a;n++){const n=Math.sin(o),a=Math.cos(o);o+=r;const i=Math.sin(o),s=Math.cos(o);Vv.push(e.x+t*n,e.y,e.z+t*a),Vv.push(e.x+t*i,e.y,e.z+t*s),Vv.push(e.x+t*n,e.y+t*a,e.z),Vv.push(e.x+t*i,e.y+t*s,e.z),Vv.push(e.x,e.y+t*n,e.z+t*a),Vv.push(e.x,e.y+t*i,e.z+t*s)}this.getBatch(s,i).addLinesArrays(Vv,n),Vv.length=0}getGraphNode(e){const t=new hf;return t.worldTransform=e,t._dirtyWorld=t._dirtyNormal=!1,t}onPreRenderLayer(e,t,n){if(this.batchesMap.forEach(((a,i)=>{i===e&&a.onPreRender(t,n)})),!this.updatedLayers.has(e)){this.updatedLayers.add(e);const n=this.layerMeshInstances.get(e);if(n){for(let e=0;e<n.length;e++)t.list[t.length+e]=n[e];t.length+=n.length,n.length=0}}}onPostRender(){this.allBatches.clear(),this.updatedLayers.clear()}}class Uv extends Qp{constructor(e){super(),this.ambientBake=!1,this.ambientBakeOcclusionBrightness=0,this.ambientBakeOcclusionContrast=0,this.ambientLight=new Mu(0,0,0),this.exposure=1,this.fogColor=new Mu(0,0,0),this.fogDensity=0,this.fogEnd=1e3,this.fogStart=1,this.lightmapSizeMultiplier=1,this.lightmapMaxResolution=2048,this.lightmapMode=1,this.lightmapFilterEnabled=!1,this.root=null,this.device=e||Jg().graphicsDevice,this._gravity=new Pu(0,-9.8,0),this._layers=null,this._fog="none",this._gammaCorrection=1,this._toneMapping=0,this._skyboxCubeMap=null,this._prefilteredCubemaps=[null,null,null,null,null,null],this._envAtlas=null,this._internalEnvAtlas=null,this.skyboxModel=null,this._skyboxIntensity=1,this._skyboxMip=0,this._skyboxRotation=new Gu,this._skyboxRotationMat3=null,this._skyboxRotationMat4=null,this._ambientBakeNumSamples=1,this._ambientBakeSpherePart=.4,this._lightmapFilterRange=10,this._lightmapFilterSmoothness=.2,this._clusteredLightingEnabled=!1,this._lightingParams=new Tv(this.device.supportsAreaLights,this.device.maxTextureSize,(()=>{this._layers._dirtyLights=!0})),this._stats={meshInstances:0,lights:0,dynamicLights:0,bakedLights:0,lastStaticPrepareFullTime:0,lastStaticPrepareSearchTime:0,lastStaticPrepareWriteTime:0,lastStaticPrepareTriAabbTime:0,lastStaticPrepareCombineTime:0,updateShadersTime:0},this.updateShaders=!0,this._shaderVersion=0,this._statsUpdated=!1,this._models=[],this.immediate=new Bv(this.device)}get defaultDrawLayer(){return this.layers.getLayerById(3)}set ambientBakeNumSamples(e){this._ambientBakeNumSamples=Eu.clamp(Math.floor(e),1,255)}get ambientBakeNumSamples(){return this._ambientBakeNumSamples}set ambientBakeSpherePart(e){this._ambientBakeSpherePart=Eu.clamp(e,.001,1)}get ambientBakeSpherePart(){return this._ambientBakeSpherePart}set clusteredLightingEnabled(e){!this._clusteredLightingEnabled||e?this._clusteredLightingEnabled=e:console.error("Turning off enabled clustered lighting is not currently supported")}get clusteredLightingEnabled(){return this._clusteredLightingEnabled}set drawCalls(e){}get drawCalls(){let e=this.layers._meshInstances;return e.length||(this.layers._update(this.device,this.clusteredLightingEnabled),e=this.layers._meshInstances),e}set envAtlas(e){e!==this._envAtlas&&(this._envAtlas=e,this.updateShaders=!0)}get envAtlas(){return this._envAtlas}set fog(e){e!==this._fog&&(this._fog=e,this.updateShaders=!0)}get fog(){return this._fog}set gammaCorrection(e){e!==this._gammaCorrection&&(this._gammaCorrection=e,this.updateShaders=!0)}get gammaCorrection(){return this._gammaCorrection}set layers(e){const t=this._layers;this._layers=e,this.fire("set:layers",t,e)}get layers(){return this._layers}get lighting(){return this._lightingParams}set lightmapFilterRange(e){this._lightmapFilterRange=Math.max(e,.001)}get lightmapFilterRange(){return this._lightmapFilterRange}set lightmapFilterSmoothness(e){this._lightmapFilterSmoothness=Math.max(e,.001)}get lightmapFilterSmoothness(){return this._lightmapFilterSmoothness}set prefilteredCubemaps(e){const t=this._prefilteredCubemaps;e=e||[];let n=!1,a=!0;for(let i=0;i<6;++i){const s=e[i]||null;t[i]!==s&&(t[i]=s,n=!0),a=a&&!!t[i]}n&&(this._resetSkyboxModel(),a?(this._internalEnvAtlas=Kf.generatePrefilteredAtlas(t,{target:this._internalEnvAtlas}),this._envAtlas||(this.envAtlas=this._internalEnvAtlas)):this._internalEnvAtlas&&(this._envAtlas===this._internalEnvAtlas&&(this.envAtlas=null),this._internalEnvAtlas.destroy(),this._internalEnvAtlas=null))}get prefilteredCubemaps(){return this._prefilteredCubemaps}set skybox(e){e!==this._skyboxCubeMap&&(this._skyboxCubeMap=e,this._resetSkyboxModel())}get skybox(){return this._skyboxCubeMap}set skyboxIntensity(e){e!==this._skyboxIntensity&&(this._skyboxIntensity=e,this._resetSkyboxModel())}get skyboxIntensity(){return this._skyboxIntensity}set skyboxMip(e){e!==this._skyboxMip&&(this._skyboxMip=e,this._resetSkyboxModel())}get skyboxMip(){return this._skyboxMip}set skyboxRotation(e){this._skyboxRotation.equals(e)||(this._skyboxRotation.copy(e),this._resetSkyboxModel())}get skyboxRotation(){return this._skyboxRotation}set toneMapping(e){e!==this._toneMapping&&(this._toneMapping=e,this.updateShaders=!0)}get toneMapping(){return this._toneMapping}destroy(){this._resetSkyboxModel(),this.root=null,this.off()}drawLine(e,t,n=Mu.WHITE,a=!0,i=this.defaultDrawLayer){this.immediate.getBatch(i,a).addLines([e,t],[n,n])}drawLines(e,t,n=!0,a=this.defaultDrawLayer){this.immediate.getBatch(a,n).addLines(e,t)}drawLineArrays(e,t,n=!0,a=this.defaultDrawLayer){this.immediate.getBatch(a,n).addLinesArrays(e,t)}applySettings(e){const t=e.physics,n=e.render;this._gravity.set(t.gravity[0],t.gravity[1],t.gravity[2]),this.ambientLight.set(n.global_ambient[0],n.global_ambient[1],n.global_ambient[2]),this._fog=n.fog,this.fogColor.set(n.fog_color[0],n.fog_color[1],n.fog_color[2]),this.fogStart=n.fog_start,this.fogEnd=n.fog_end,this.fogDensity=n.fog_density,this._gammaCorrection=n.gamma_correction,this._toneMapping=n.tonemapping,this.lightmapSizeMultiplier=n.lightmapSizeMultiplier,this.lightmapMaxResolution=n.lightmapMaxResolution,this.lightmapMode=n.lightmapMode,this.exposure=n.exposure,this._skyboxIntensity=void 0===n.skyboxIntensity?1:n.skyboxIntensity,this._skyboxMip=void 0===n.skyboxMip?0:n.skyboxMip,n.skyboxRotation&&this._skyboxRotation.setFromEulerAngles(n.skyboxRotation[0],n.skyboxRotation[1],n.skyboxRotation[2]),["lightmapFilterEnabled","lightmapFilterRange","lightmapFilterSmoothness","ambientBake","ambientBakeNumSamples","ambientBakeSpherePart","ambientBakeOcclusionBrightness","ambientBakeOcclusionContrast"].forEach((e=>{n.hasOwnProperty(e)&&(this[e]=n[e])})),this._resetSkyboxModel()}_getSkyboxTex(){const e=this._prefilteredCubemaps;if(this._skyboxMip){return e[[0,1,3,4,5,6][this._skyboxMip]]||this._envAtlas||e[0]||this._skyboxCubeMap}return this._skyboxCubeMap||e[0]||this._envAtlas}_updateSkybox(e){if(this.skyboxModel)return;const t=this._getSkyboxTex();if(!t)return;const n=new Jf,a=this;n.updateShader=function(n,i,s,r,o){const l=e.getProgramLibrary();t.cubemap?this.shader=l.getProgram("skybox",{type:"cubemap",rgbm:"rgbm"===t.type,hdr:"rgbm"===t.type||14===t.format,useIntensity:1!==a.skyboxIntensity,mip:t.fixCubemapSeams?a.skyboxMip:0,fixSeams:t.fixCubemapSeams,gamma:1===o?a.gammaCorrection?3:0:a.gammaCorrection,toneMapping:1===o?0:a.toneMapping}):this.shader=l.getProgram("skybox",{type:"envAtlas",encoding:t.encoding,useIntensity:1!==a.skyboxIntensity,gamma:1===o?a.gammaCorrection?3:0:a.gammaCorrection,toneMapping:1===o?0:a.toneMapping})},n.updateShader(),t.cubemap?n.setParameter("texture_cubeMap",t):(n.setParameter("texture_envAtlas",t),n.setParameter("mipLevel",this._skyboxMip)),this.skyboxRotation.equals(Gu.IDENTITY)?n.setParameter("cubeMapRotationMatrix",ku.IDENTITY.data):(this._skyboxRotationMat4||(this._skyboxRotationMat4=new zu),this._skyboxRotationMat3||(this._skyboxRotationMat3=new ku),this._skyboxRotationMat4.setTRS(Pu.ZERO,this._skyboxRotation,Pu.ONE),this._skyboxRotationMat4.invertTo3x3(this._skyboxRotationMat3),n.setParameter("cubeMapRotationMatrix",this._skyboxRotationMat3.data)),n.cull=2,n.depthWrite=!1;const i=this.layers.getLayerById(2);if(i){const a=new hf("Skybox"),s=py(e),r=new Ay(s,n,a);r.cull=!1,r._noDepthDrawGl1=!0,r.pick=!1;const o=new Dv;o.graph=a,o.meshInstances=[r],this.skyboxModel=o,i.addMeshInstances(o.meshInstances),this.skyLayer=i,this.fire("set:skybox",t)}}_resetSkyboxModel(){this.skyboxModel&&(this.skyLayer.removeMeshInstances(this.skyboxModel.meshInstances),this.skyboxModel.destroy()),this.skyboxModel=null,this.updateShaders=!0}setSkybox(e){e?(this.skybox=e[0]||null,this.prefilteredCubemaps=e.slice(1)):(this.skybox=null,this.prefilteredCubemaps=[null,null,null,null,null,null])}addModel(e){if(this.containsModel(e))return;const t=this.layers.getLayerById(0);t&&(t.addMeshInstances(e.meshInstances),this._models.push(e))}addShadowCaster(e){const t=this.layers.getLayerById(0);t&&t.addShadowCasters(e.meshInstances)}removeModel(e){const t=this._models.indexOf(e);if(-1!==t){const n=this.layers.getLayerById(0);if(!n)return;n.removeMeshInstances(e.meshInstances),this._models.splice(t,1)}}removeShadowCasters(e){const t=this.layers.getLayerById(0);t&&t.removeShadowCasters(e.meshInstances)}containsModel(e){return this._models.indexOf(e)>=0}getModels(e){return this._models}}function zv(){return!("undefined"==typeof AudioContext&&"undefined"==typeof webkitAudioContext)}class Gv{constructor(e,t,n={}){if(this.volume=void 0===n.volume?1:n.volume,this.loop=void 0!==n.loop&&n.loop,this.pitch=void 0===n.pitch?1:n.pitch,this.sound=t,this.paused=!1,this.suspended=!1,this.manager=e,this.source=null,zv()){this.startTime=0,this.startOffset=0;const t=e.context;this.gain=t.createGain()}else t.audio&&(this.source=t.audio.cloneNode(!1),this.source.pause())}getVolume(){return this.volume}getLoop(){return this.loop}setLoop(e){this.loop=e,this.source&&(this.source.loop=e)}getPitch(){return this.pitch}onManagerVolumeChange(){this.setVolume(this.getVolume())}onManagerSuspend(){this.isPlaying()&&!this.suspended&&(this.suspended=!0,this.pause())}onManagerResume(){this.suspended&&(this.suspended=!1,this.unpause())}play(){if(this.source)throw new Error("Call stop() before calling play()");this._createSource(),this.source&&(this.startTime=this.manager.context.currentTime,this.source.start(0,this.startOffset%this.source.buffer.duration),this.setVolume(this.volume),this.setLoop(this.loop),this.setPitch(this.pitch),this.manager.on("volumechange",this.onManagerVolumeChange,this),this.manager.on("suspend",this.onManagerSuspend,this),this.manager.on("resume",this.onManagerResume,this),this.manager.suspended&&this.onManagerSuspend())}pause(){this.source&&(this.paused=!0,this.startOffset+=this.manager.context.currentTime-this.startTime,this.source.stop(0),this.source=null)}unpause(){!this.source&&this.paused?(this._createSource(),this.source&&(this.startTime=this.manager.context.currentTime,this.source.start(0,this.startOffset%this.source.buffer.duration),this.setVolume(this.volume),this.setLoop(this.loop),this.setPitch(this.pitch),this.paused=!1)):console.warn("Call pause() before unpausing.")}stop(){this.source&&(this.source.stop(0),this.source=null),this.manager.off("volumechange",this.onManagerVolumeChange,this),this.manager.off("suspend",this.onManagerSuspend,this),this.manager.off("resume",this.onManagerResume,this)}setVolume(e){e=Eu.clamp(e,0,1),this.volume=e,this.gain&&(this.gain.gain.value=e*this.manager.volume)}setPitch(e){this.pitch=e,this.source&&(this.source.playbackRate.value=e)}isPlaying(){return!this.paused&&this.source.playbackState===this.source.PLAYING_STATE}getDuration(){return this.source?this.source.buffer.duration:0}_createSource(){const e=this.manager.context;this.sound.buffer&&(this.source=e.createBufferSource(),this.source.buffer=this.sound.buffer,this.source.connect(this.gain),this.gain.connect(e.destination),this.loop||(this.source.onended=this.pause.bind(this)))}}zv()||Object.assign(Gv.prototype,{play:function(){this.source&&(this.paused=!1,this.setVolume(this.volume),this.setLoop(this.loop),this.setPitch(this.pitch),this.source.play()),this.manager.on("volumechange",this.onManagerVolumeChange,this),this.manager.on("suspend",this.onManagerSuspend,this),this.manager.on("resume",this.onManagerResume,this),this.manager.suspended&&this.onManagerSuspend()},pause:function(){this.source&&(this.paused=!0,this.source.pause())},unpause:function(){this.source&&(this.paused=!1,this.source.play())},stop:function(){this.source&&this.source.pause(),this.manager.off("volumechange",this.onManagerVolumeChange,this),this.manager.off("suspend",this.onManagerSuspend,this),this.manager.off("resume",this.onManagerResume,this)},setVolume:function(e){e=Eu.clamp(e,0,1),this.volume=e,this.source&&(this.source.volume=e*this.manager.volume)},setPitch:function(e){this.pitch=e,this.source&&(this.source.playbackRate=e)},getDuration:function(){return this.source&&!isNaN(this.source.duration)?this.source.duration:0},isPlaying:function(){return!this.source.paused}});class Hv extends Gv{constructor(e,t,n){super(e,t,n),this.position=new Pu,this.velocity=new Pu,zv()?this.panner=e.context.createPanner():(this.maxDistance=1e4,this.minDistance=1,this.rollOffFactor=1,this.distanceModel="inverse")}getPosition(){return this.position}setPosition(e){this.position.copy(e);const t=this.panner;"positionX"in t?(t.positionX.value=e.x,t.positionY.value=e.y,t.positionZ.value=e.z):t.setPosition&&t.setPosition(e.x,e.y,e.z)}getVelocity(){return this.velocity}setVelocity(e){this.velocity.copy(e)}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){this.panner.maxDistance=e}getMinDistance(){return this.panner.refDistance}setMinDistance(e){this.panner.refDistance=e}getRollOffFactor(){return this.panner.rolloffFactor}setRollOffFactor(e){this.panner.rolloffFactor=e}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){this.panner.distanceModel=e}_createSource(){const e=this.manager.context;this.source=e.createBufferSource(),this.source.buffer=this.sound.buffer,this.source.connect(this.panner),this.panner.connect(this.gain),this.gain.connect(e.destination),this.loop||(this.source.onended=this.pause.bind(this))}}if(!zv()){let e=new Pu;const t=function(t,n,a,i,s,r){e=e.sub2(t,n);const o=e.length();if(o<a)return 1;if(o>i)return 0;let l=0;return"linear"===r?l=1-s*(o-a)/(i-a):"inverse"===r?l=a/(a+s*(o-a)):"exponential"===r&&(l=Math.pow(o/a,-s)),Eu.clamp(l,0,1)};Object.assign(Hv.prototype,{setPosition:function(e){if(this.position.copy(e),this.source){const e=this.manager.listener.getPosition(),n=t(e,this.position,this.minDistance,this.maxDistance,this.rollOffFactor,this.distanceModel),a=this.getVolume();this.source.volume=a*n}},getMaxDistance:function(){return this.maxDistance},setMaxDistance:function(e){this.maxDistance=e},getMinDistance:function(){return this.minDistance},setMinDistance:function(e){this.minDistance=e},getRollOffFactor:function(){return this.rollOffFactor},setRollOffFactor:function(e){this.rollOffFactor=e},getDistanceModel:function(){return this.distanceModel},setDistanceModel:function(e){this.distanceModel=e}})}class Wv{constructor(e){this._manager=e,this.position=new Pu,this.velocity=new Pu,this.orientation=new zu}getPosition(){return this.position}setPosition(e){this.position.copy(e);const t=this.listener;t&&("positionX"in t?(t.positionX.value=e.x,t.positionY.value=e.y,t.positionZ.value=e.z):t.setPosition&&t.setPosition(e.x,e.y,e.z))}getVelocity(){return this.velocity}setVelocity(e){}setOrientation(e){this.orientation.copy(e);const t=this.listener;if(t){const n=e.data;"forwardX"in t?(t.forwardX.value=-n[8],t.forwardY.value=-n[9],t.forwardZ.value=-n[10],t.upX.value=n[4],t.upY.value=n[5],t.upZ.value=n[6]):t.setOrientation&&t.setOrientation(-n[8],-n[9],-n[10],n[4],n[5],n[6])}}getOrientation(){return this.orientation}get listener(){const e=this._manager.context;return e?e.listener:null}}const jv=["click","contextmenu","auxclick","dblclick","mousedown","mouseup","pointerup","touchend","keydown","keyup"];class Xv extends Qp{constructor(e){super(),this._context=null,this._state="not created",this._forceWebAudioApi=e.forceWebAudioApi,this._resumeContext=null,this._resumeContextAttached=!1,this._unlock=null,this._unlockAttached=!1,zv()||this._forceWebAudioApi?this._addAudioContextUserInteractionListeners():console.warn("No support for 3D audio found"),this.listener=new Wv(this),this._volume=1,this.suspended=!1}set volume(e){e=Eu.clamp(e,0,1),this._volume=e,this.fire("volumechange",e)}get volume(){return this._volume}get context(){return this._context||(zv()||this._forceWebAudioApi)&&("undefined"!=typeof AudioContext?this._context=new AudioContext:"undefined"!=typeof webkitAudioContext&&(this._context=new webkitAudioContext),this._context&&(this._state=this._context.state,this._context.onstatechange=()=>{this._context&&("interrupted"!==this._state&&"suspended"!==this._state||this._safelyResumeContext(),this._state=this._context.state)})),this._context}suspend(){this.suspended=!0,this.fire("suspend")}resume(){this.suspended=!1,this.fire("resume"),!this.context||"interrupted"!==this._state&&"suspended"!==this._state||this._safelyResumeContext()}destroy(){this._resumeContext&&this._resumeContextAttached&&jv.forEach((e=>{window.removeEventListener(e,this._resumeContext)})),this._unlock&&this._unlockAttached&&window.removeEventListener("touchend",this._unlock),this.fire("destroy"),this._context&&this._context.close&&(this._context.close(),this._context=null)}playSound(e,t={}){let n=null;return Gv&&(n=new Gv(this,e,t),n.play()),n}playSound3d(e,t,n={}){let a=null;return Hv&&(a=new Hv(this,e,n),a.setPosition(t),n.volume&&a.setVolume(n.volume),n.loop&&a.setLoop(n.loop),n.maxDistance&&a.setMaxDistance(n.maxDistance),n.minDistance&&a.setMinDistance(n.minDistance),n.rollOffFactor&&a.setRollOffFactor(n.rollOffFactor),n.distanceModel&&a.setDistanceModel(n.distanceModel),a.play()),a}_safelyResumeContext(){this._context&&this._context.resume().then((()=>{"running"!==this._context.state&&this._addAudioContextUserInteractionListeners()})).catch((()=>{this._addAudioContextUserInteractionListeners()}))}_addAudioContextUserInteractionListeners(){this._resumeContext||(this._resumeContext=()=>{this.context&&"running"!==this.context.state?this.context.resume():(jv.forEach((e=>{window.removeEventListener(e,this._resumeContext)})),this._resumeContextAttached=!1)}),this._resumeContextAttached||(jv.forEach((e=>{window.addEventListener(e,this._resumeContext)})),this._resumeContextAttached=!0),uu.ios&&(this._unlock||(this._unlock=()=>{window.removeEventListener("touchend",this._unlock),this._unlockAttached=!1;const e=this.context;if(e){const t=e.createBuffer(1,1,44100),n=e.createBufferSource();n.buffer=t,n.connect(e.destination),n.start(0),n.disconnect()}}),this._unlockAttached||(window.addEventListener("touchend",this._unlock),this._unlockAttached=!0))}}class Yv{constructor(e,t,n,a){this.time=e,this.position=t,this.rotation=n,this.scale=a}}class qv{constructor(){this._name="",this._keys=[]}}class Kv{constructor(){this.name="",this.duration=0,this._nodes=[],this._nodeDict={}}getNode(e){return this._nodeDict[e]}addNode(e){this._nodes.push(e),this._nodeDict[e._name]=e}get nodes(){return this._nodes}}class Zv{constructor(e){2===arguments.length&&(e=arguments[1]),this.options=e,this._name=e.name,this._defaultWeight=e.defaultWeight||0,this.aabb=e.aabb,this.aabb||(this.aabb=new qu,e.deltaPositions&&this.aabb.compute(e.deltaPositions)),this.deltaPositions=e.deltaPositions}get name(){return this._name}get defaultWeight(){return this._defaultWeight}get morphPositions(){return!!this._vertexBufferPositions||!!this.texturePositions}get morphNormals(){return!!this._vertexBufferNormals||!!this.textureNormals}_postInit(){this.options=null}_initVertexBuffers(e){const t=this.options;this._vertexBufferPositions=this._createVertexBuffer(e,t.deltaPositions,t.deltaPositionsType),this._vertexBufferNormals=this._createVertexBuffer(e,t.deltaNormals,t.deltaNormalsType),this._vertexBufferPositions&&(this.deltaPositions=this._vertexBufferPositions.lock())}_createVertexBuffer(e,t,n=6){if(t){return new lm(e,new hm(e,[{semantic:"ATTR0",components:3,type:n}]),t.length/3,0,t)}return null}_setTexture(e,t){this[e]=t}destroy(){this._vertexBufferPositions&&(this._vertexBufferPositions.destroy(),this._vertexBufferPositions=null),this._vertexBufferNormals&&(this._vertexBufferNormals.destroy(),this._vertexBufferNormals=null),this.texturePositions&&(this.texturePositions.destroy(),this.texturePositions=null),this.textureNormals&&(this.textureNormals.destroy(),this.textureNormals=null)}}class $v{constructor(e,t,n){this.device=e,this.inverseBindPose=t,this.boneNames=n}}class Qv extends Qp{constructor(){super(),this._meshes=null}set meshes(e){this.decRefMeshes(),this._meshes=e,this.incRefMeshes(),this.fire("set:meshes",e)}get meshes(){return this._meshes}destroy(){this.meshes=null}decRefMeshes(){if(this._meshes){const e=this._meshes.length;for(let t=0;t<e;t++){const e=this._meshes[t];e&&(e.decRefCount(),e.refCount<1&&(e.destroy(),this._meshes[t]=null))}}}incRefMeshes(){if(this._meshes){const e=this._meshes.length;for(let t=0;t<e;t++)this._meshes[t]&&this._meshes[t].incRefCount()}}}class Jv{constructor(e,t,n,a){this._paths=e,this._input=t,this._output=n,this._interpolation=a}get paths(){return this._paths}get input(){return this._input}get output(){return this._output}get interpolation(){return this._interpolation}}class e_{constructor(e,t){this._components=e,this._data=t}get components(){return this._components}get data(){return this._data}}class t_{constructor(e){this._events=[...e],this._events.sort(((e,t)=>e.time-t.time))}get events(){return this._events}}class n_{constructor(e,t,n,a,i,s=new t_([])){this._name=e,this._duration=t,this._inputs=n,this._outputs=a,this._curves=i,this._animEvents=s}get name(){return this._name}get duration(){return this._duration}get inputs(){return this._inputs}get outputs(){return this._outputs}get curves(){return this._curves}set events(e){this._animEvents=e}get events(){return this._animEvents.events}eval(e,t){t._time=e;const n=this._inputs,a=this._outputs,i=this._curves,s=t._cache,r=t._results;for(let t=0;t<n.length;++t)s[t].update(e,n[t]._data);for(let e=0;e<i.length;++e){const t=i[e],n=a[t._output],o=r[e];s[t._input].eval(o,t._interpolation,n)}}}const a_={en:"en-US",es:"en-ES",zh:"zh-CN","zh-HK":"zh-TW","zh-TW":"zh-HK","zh-MO":"zh-HK",fr:"fr-FR",de:"de-DE",it:"it-IT",ru:"ru-RU",ja:"ja-JP"},i_={};function s_(e,t){for(let n=0,a=e.length;n<a;n++)i_[e[n]]=t}function r_(e){const t=e.indexOf("-");return-1!==t?e.substring(0,t):e}function o_(e,t){if(t[e])return e;let n=a_[e];if(n&&t[n])return n;const a=r_(e);return n=a_[a],t[n]?n:t[a]?a:"en-US"}s_(["ja","ko","th","vi","zh","id"],(function(e){return 0})),s_(["fa","hi"],(function(e){return e>=0&&e<=1?0:1})),s_(["fr","pt"],(function(e){return e>=0&&e<2?0:1})),s_(["da"],(function(e){return 1===e||!Number.isInteger(e)&&e>=0&&e<=1?0:1})),s_(["de","en","it","el","es","tr","fi","sv","nb","no","ur"],(function(e){return 1===e?0:1})),s_(["ru","uk"],(function(e){if(Number.isInteger(e)){const t=e%10,n=e%100;if(1===t&&11!==n)return 0;if(t>=2&&t<=4&&(n<12||n>14))return 1;if(0===t||t>=5&&t<=9||n>=11&&n<=14)return 2}return 3})),s_(["pl"],(function(e){if(Number.isInteger(e)){if(1===e)return 0;const t=e%10,n=e%100;if(t>=2&&t<=4&&(n<12||n>14))return 1;if(t>=0&&t<=1||t>=5&&t<=9||n>=12&&n<=14)return 2}return 3})),s_(["ar"],(function(e){if(0===e)return 0;if(1===e)return 1;if(2===e)return 2;if(Number.isInteger(e)){const t=e%100;if(t>=3&&t<=10)return 3;if(t>=11&&t<=99)return 4}return 5}));const l_=i_[r_("en-US")];function c_(e){return i_[e]||l_}const h_=new RegExp("^\\s*(?:(?:[a-z]+[a-z0-9\\-\\+\\.]*:)?//|data:|blob:)","i");class d_{constructor(e,t,n,a,i,s){this.url=e||"",this.filename=t||"",this.hash=void 0===n?null:n,this.size=void 0===a?null:a,this.opt=void 0===i?null:i,this.contents=s||null}equals(e){return this.url===e.url&&this.filename===e.filename&&this.hash===e.hash&&this.size===e.size&&this.opt===e.opt&&this.contents===e.contents}}let p_=-1;const u_={pvr:"extCompressedTexturePVRTC",dxt:"extCompressedTextureS3TC",etc2:"extCompressedTextureETC",etc1:"extCompressedTextureETC1",basis:"canvas"},m_=["pvr","dxt","etc2","etc1","basis"];class f_ extends Qp{constructor(e,t,n,a,i){super(),this._id=p_--,this.name=e||"",this.type=t,this.tags=new wu(this),this._preload=!1,this._file=null,this._data=a||{},this.options=i||{},this._resources=[],this._i18n={},this.loaded=!1,this.loading=!1,this.registry=null,n&&(this.file=n)}set id(e){this._id=e}get id(){return this._id}set file(e){if(e&&e.variants&&-1!==["texture","textureatlas","bundle"].indexOf(this.type)){var t,n;const a=(null==(t=this.registry)||null==(n=t._loader)?void 0:n._app)||Jg(),i=null==a?void 0:a.graphicsDevice;if(i)for(let t=0,n=m_.length;t<n;t++){const n=m_[t];if(e.variants[n]&&i[u_[n]]){e=e.variants[n];break}if(a.enableBundles){const e=a.bundles.listBundlesForAsset(this);if(e&&e.find((e=>{var t;return null==e||null==(t=e.file)?void 0:t.variants[n]})))break}}}const a=this._file,i=e?new d_(e.url,e.filename,e.hash,e.size,e.opt,e.contents):null;(!!i!=!!a||i&&!i.equals(a))&&(this._file=i,this.fire("change",this,"file",i,a),this.reload())}get file(){return this._file}set data(e){const t=this._data;this._data=e,e!==t&&(this.fire("change",this,"data",e,t),this.loaded&&this.registry._loader.patch(this,this.registry))}get data(){return this._data}set resource(e){const t=this._resources[0];this._resources[0]=e,this.fire("change",this,"resource",e,t)}get resource(){return this._resources[0]}set resources(e){const t=this._resources;this._resources=e,this.fire("change",this,"resources",e,t)}get resources(){return this._resources}set preload(e){e=!!e,this._preload!==e&&(this._preload=e,this._preload&&!this.loaded&&!this.loading&&this.registry&&this.registry.load(this))}get preload(){return this._preload}set loadFaces(e){e=!!e,this.hasOwnProperty("_loadFaces")&&e===this._loadFaces||(this._loadFaces=e,this.loaded&&this.registry._loader.patch(this,this.registry))}get loadFaces(){return this._loadFaces}getFileUrl(){const e=this.file;if(!e||!e.url)return null;let t=e.url;if(this.registry&&this.registry.prefix&&!h_.test(t)&&(t=this.registry.prefix+t),"script"!==this.type&&e.hash){const n=-1!==t.indexOf("?")?"&":"?";t+=n+"t="+e.hash}return t}getAbsoluteUrl(e){if(e.startsWith("blob:")||e.startsWith("data:"))return e;const t=tu.getDirectory(this.file.url);return tu.join(t,e)}getLocalizedAssetId(e){return e=o_(e,this._i18n),this._i18n[e]||null}addLocalizedAssetId(e,t){this._i18n[e]=t,this.fire("add:localized",e,t)}removeLocalizedAssetId(e){const t=this._i18n[e];t&&(delete this._i18n[e],this.fire("remove:localized",e,t))}ready(e,t){t=t||this,this.resource?e.call(t,this):this.once("load",(function(n){e.call(t,n)}))}reload(){this.loaded&&(this.loaded=!1,this.registry.load(this))}unload(){if(!this.loaded&&0===this._resources.length)return;this.fire("unload",this),this.registry.fire("unload:"+this.id,this);const e=this._resources;this.resources=[],this.loaded=!1,this.file&&this.registry._loader.clearCache(this.getFileUrl(),this.type);for(let t=0;t<e.length;++t){const n=e[t];n&&n.destroy&&n.destroy()}}static fetchArrayBuffer(e,t,n,a=0){var i;null!=n&&null!=(i=n.file)&&i.contents?setTimeout((()=>{t(null,n.file.contents)})):Au.get(e,{cache:!0,responseType:"arraybuffer",retry:a>0,maxRetries:a},t)}}class g_ extends $g{constructor(e,t){super(),this.skin=e,this.skinInstance=t}}class y_{static createCachedSkinInstance(e,t,n){let a=y_.getCachedSkinInstance(e,t);return a||(a=new by(e),a.resolve(t,n),y_.addCachedSkinInstance(e,t,a)),a}static getCachedSkinInstance(e,t){let n=null;const a=y_._skinInstanceCache.get(t);if(a){const t=a.find((t=>t.skin===e));t&&(t.incRefCount(),n=t.skinInstance)}return n}static addCachedSkinInstance(e,t,n){let a=y_._skinInstanceCache.get(t);a||(a=[],y_._skinInstanceCache.set(t,a));let i=a.find((t=>t.skin===e));i||(i=new g_(e,n),a.push(i)),i.incRefCount()}static removeCachedSkinInstance(e){if(e){const t=e.rootBone;if(t){const n=y_._skinInstanceCache.get(t);if(n){const a=n.findIndex((t=>t.skinInstance===e));if(a>=0){const i=n[a];i.decRefCount(),0===i.refCount&&(n.splice(a,1),n.length||y_._skinInstanceCache.delete(t),e&&(e.destroy(),i.skinInstance=null))}}}}}}y_._skinInstanceCache=new Map;class b_{constructor(e,t,n,a){const i=function(e,a,i){const s=b_.createAsset(t.name,e,a,i);return n.add(s),s},s=[];for(let t=0;t<e.renders.length;++t)s.push(i("render",e.renders[t],t));const r=[];for(let t=0;t<e.materials.length;++t)r.push(i("material",e.materials[t],t));const o=[];for(let t=0;t<e.animations.length;++t)o.push(i("animation",e.animations[t],t));this.data=e,this._model=null,this._assetName=t.name,this._assets=n,this._defaultMaterial=a,this.renders=s,this.materials=r,this.textures=e.textures,this.animations=o}get model(){if(!this._model){const e=b_.createModel(this.data,this._defaultMaterial),t=b_.createAsset(this._assetName,"model",e,0);this._assets.add(t),this._model=t}return this._model}static createAsset(e,t,n,a){const i=new f_(e+"/"+t+"/"+a,t,{url:""});return i.resource=n,i.loaded=!0,i}instantiateModelEntity(e){const t=new KM;return t.addComponent("model",Object.assign({type:"asset",asset:this.model},e)),t}instantiateRenderEntity(e){const t=this._defaultMaterial,n=[],a=function(e,a,i,s,r,o){const l=void 0===i.materialIndex?t:s[i.materialIndex],c=new Ay(i,l);return i.morph&&(c.morphInstance=new kv(i.morph)),o.hasOwnProperty("skin")&&n.push({meshInstance:c,rootBone:e,entity:a}),c},i=(t,n,s)=>{const r=new KM;n._cloneInternal(r),t||(t=r);let o=null,l=null;for(let e=0;e<s.nodes.length;e++){if(s.nodes[e]===n){const n=s.gltf.nodes[e];if(n.hasOwnProperty("mesh")){const e=s.renders[n.mesh].meshes;l=this.renders[n.mesh];for(var c=0;c<e.length;c++){const i=e[c];if(i){const e=a(t,r,i,s.materials,s.skins,n);o||(o=[]),o.push(e)}}}if(s.lights){const e=s.lights.get(n);e&&r.addChild(e.clone())}if(s.cameras){const e=s.cameras.get(n);e&&e.camera.system.cloneComponent(e,r)}}}o&&(r.addComponent("render",Object.assign({type:"asset",meshInstances:o,rootBone:t},e)),r.render.assignAsset(l));const h=n.children;for(let e=0;e<h.length;e++){const n=i(t,h[e],s);r.addChild(n)}return r},s=[];for(const e of this.data.scenes)s.push(i(null,e,this.data));return n.forEach((e=>{e.meshInstance.skinInstance=y_.createCachedSkinInstance(e.meshInstance.mesh.skin,e.rootBone,e.entity)})),b_.createSceneHierarchy(s,"Entity")}static createSceneHierarchy(e,t){let n=null;if(1===e.length)n=e[0];else{n=new t("SceneGroup");for(const t of e)n.addChild(t)}return n}static createModel(e,t){const n=function(e,n,a,i,s,r,o){const l=void 0===n.materialIndex?t:s[n.materialIndex],c=new Ay(n,l,r);if(n.morph){const t=new kv(n.morph);c.morphInstance=t,e.morphInstances.push(t)}if(o.hasOwnProperty("skin")){const t=o.skin,s=a[t];n.skin=s;const r=i[t];c.skinInstance=r,e.skinInstances.push(r)}e.meshInstances.push(c)},a=new Dv,i=[];for(const t of e.skins){const e=new by(t);e.bones=t.bones,i.push(e)}a.graph=b_.createSceneHierarchy(e.scenes,"GraphNode");for(let t=0;t<e.nodes.length;t++){const r=e.nodes[t];if(r.root===a.graph){const o=e.gltf.nodes[t];if(o.hasOwnProperty("mesh")){const t=e.renders[o.mesh].meshes;for(var s=0;s<t.length;s++){const l=t[s];l&&n(a,l,e.skins,i,e.materials,r,o)}}}}return a}destroy(){const e=this._assets,t=function(t){e.remove(t),t.unload()},n=function(e){e.forEach((function(e){t(e)}))};this.animations&&(n(this.animations),this.animations=null),this.textures&&(n(this.textures),this.textures=null),this.materials&&(n(this.materials),this.materials=null),this.renders&&(n(this.renders),this.renders=null),this._model&&(t(this._model),this._model=null),this.data=null,this.assets=null}}class v_{constructor(e){this.gltf=e,this.nodes=null,this.scenes=null,this.animations=null,this.textures=null,this.materials=null,this.renders=null,this.skins=null,this.lights=null,this.cameras=null}destroy(){this.renders&&this.renders.forEach((e=>{e.meshes=null}))}}const __=function(e){return/^data:.*,.*$/i.test(e)},w_=function(e){switch(e){case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":default:return 3;case"VEC4":case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16}},x_=function(e){switch(e){case 5120:default:return 0;case 5121:return 1;case 5122:return 2;case 5123:return 3;case 5124:return 4;case 5125:return 5;case 5126:return 6}},C_=function(e){switch(e){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5124:case 5125:case 5126:return 4;default:return 0}},T_={POSITION:"POSITION",NORMAL:"NORMAL",TANGENT:"TANGENT",COLOR_0:"COLOR",JOINTS_0:"BLENDINDICES",WEIGHTS_0:"BLENDWEIGHT",TEXCOORD_0:"TEXCOORD0",TEXCOORD_1:"TEXCOORD1",TEXCOORD_2:"TEXCOORD2",TEXCOORD_3:"TEXCOORD3",TEXCOORD_4:"TEXCOORD4",TEXCOORD_5:"TEXCOORD5",TEXCOORD_6:"TEXCOORD6",TEXCOORD_7:"TEXCOORD7"},E_=function(e,t,n){const a=(e=>{switch(e){case 0:return e=>Math.max(e/127,-1);case 1:return e=>e/255;case 2:return e=>Math.max(e/32767,-1);case 3:return e=>e/65535;default:return e=>e}})(n),i=t.length;for(let n=0;n<i;++n)e[n]=a(t[n]);return e},S_=function e(t,n,a=!1){const i=w_(t.type),s=function(e){switch(e){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5124:return Int32Array;case 5125:return Uint32Array;case 5126:return Float32Array;default:return null}}(t.componentType);if(!s)return null;const r=n[t.bufferView];let o;if(t.sparse){const a=t.sparse,r={count:a.count,type:"SCALAR"},l=e(Object.assign(r,a.indices),n,!0),c={count:a.count,type:t.scalar,componentType:t.componentType},h=e(Object.assign(c,a.values),n,!0);if(t.hasOwnProperty("bufferView")){o=e({bufferView:t.bufferView,byteOffset:t.byteOffset,componentType:t.componentType,count:t.count,type:t.type},n,!0).slice()}else o=new s(t.count*i);for(let e=0;e<a.count;++e){const t=l[e];for(let n=0;n<i;++n)o[t*i+n]=h[e*i+n]}}else if(a&&r.hasOwnProperty("byteStride")){const e=i*s.BYTES_PER_ELEMENT,n=new ArrayBuffer(t.count*e),a=new Uint8Array(n);let l=0;for(let n=0;n<t.count;++n){let i=(t.byteOffset||0)+n*r.byteStride;for(let t=0;t<e;++t)a[l++]=r[i++]}o=new s(n)}else o=new s(r.buffer,r.byteOffset+(t.byteOffset||0),t.count*i);return o},A_=function(e,t){const n=S_(e,t,!0);if(n instanceof Float32Array||!e.normalized)return n;const a=new Float32Array(n.length);return E_(a,n,x_(e.componentType)),a},M_=function(e){let t=e.min,n=e.max;if(!t||!n)return null;if(e.normalized){const a=x_(e.componentType);t=E_([],t,a),n=E_([],n,a)}return new qu(new Pu(.5*(n[0]+t[0]),.5*(n[1]+t[1]),.5*(n[2]+t[2])),new Pu(.5*(n[0]-t[0]),.5*(n[1]-t[1]),.5*(n[2]-t[2])))},L_=function(e,t){const n=e.POSITION;if(!n||3!==n.components)return;let a;if(n.size!==n.stride){const e=n.stride/am[n.type],t=new nm[n.type](n.buffer,n.offset,n.count*e);a=new nm[n.type](3*n.count);for(let i=0;i<n.count;++i)a[3*i+0]=t[i*e+0],a[3*i+1]=t[i*e+1],a[3*i+2]=t[i*e+2]}else a=new nm[n.type](n.buffer,n.offset,3*n.count);const i=n.count;t||(t=function(e){const t=new Uint16Array(e);for(let n=0;n<e;n++)t[n]=n;return t}(i));const s=ry(a,t),r=new Float32Array(s.length);r.set(s),e.NORMAL={buffer:r.buffer,size:12,offset:0,stride:12,count:i,components:3,type:6}},R_=function(e){const t=new f_(e.name+"_clone",e.type,e.file,e.data,e.options);return t.loaded=!0,t.resource=function(e){const t=new Gm(e.device,e);return t._levels=function(e){const t=[];for(let n=0;n<e._levels.length;++n){let a=[];if(e.cubemap)for(let t=0;t<6;++t)a.push(e._levels[n][t]);else a=e._levels[n];t.push(a)}return t}(e),t}(e.resource),e.registry.add(t),t},I_=function(e,t,n){const a=t.POSITION;if(!a)return null;const i=a.count,s=[];for(const e in t)t.hasOwnProperty(e)&&s.push({semantic:e,components:t[e].components,type:t[e].type,normalize:!!t[e].normalize});const r=["POSITION","NORMAL","TANGENT","COLOR","BLENDINDICES","BLENDWEIGHT","TEXCOORD0","TEXCOORD1"];let o,l,c,h,d,p;s.sort((function(e,t){const n=r.indexOf(e.semantic),a=r.indexOf(t.semantic);return n<a?-1:a<n?1:0}));const u=new hm(e,s);let m=!0;for(o=0;o<u.elements.length;++o)if(d=u.elements[o],h=t[d.name],p=h.offset-a.offset,h.buffer!==a.buffer||h.stride!==d.stride||h.size!==d.size||p!==d.offset){m=!1;break}const f=new lm(e,u,i,0),g=f.lock(),y=new Uint32Array(g);let b;if(m)b=new Uint32Array(a.buffer,a.offset,i*f.format.size/4),y.set(b);else{let e,n;for(o=0;o<f.format.elements.length;++o){d=f.format.elements[o],e=d.stride/4,h=t[d.name],n=h.stride/4,b=new Uint32Array(h.buffer,h.offset,(h.count-1)*n+(h.size+3)/4);let a=0,s=d.offset/4;const r=Math.floor((h.size+3)/4);for(l=0;l<i;++l){for(c=0;c<r;++c)y[s+c]=b[a+c];a+=n,s+=e}}}return n&&function(e){let t,n;const a=[],i=[],s=[];for(t=0;t<e.format.elements.length;++t){const n=e.format.elements[t];if("TEXCOORD0"===n.name||"TEXCOORD1"===n.name)switch(n.dataType){case 6:a.push({offset:n.offset/4+1,stride:n.stride/4});break;case 3:i.push({offset:n.offset/2+1,stride:n.stride/2});break;case 1:s.push({offset:n.offset+1,stride:n.stride})}}const r=function(a,i,s){const r=new i(e.storage);for(t=0;t<a.length;++t){let i=a[t].offset;const o=a[t].stride;for(n=0;n<e.numVertices;++n)r[i]=s-r[i],i+=o}};a.length>0&&r(a,Float32Array,1),i.length>0&&r(i,Uint16Array,65535),s.length>0&&r(s,Uint8Array,255)}(f),f.unlock(),f},P_=new zu,k_=new Pu,D_=function(e,t,n,a,i,s,r){const o=[];return t.primitives.forEach((function(l){let c,h,d,p=null,u=!0;if(l.hasOwnProperty("extensions")){const t=l.extensions;if(t.hasOwnProperty("KHR_draco_mesh_compression")){const n=window.DracoDecoderModule;if(n){const r=t.KHR_draco_mesh_compression;if(r.hasOwnProperty("attributes")){const t=a[r.bufferView],o=new n.DecoderBuffer;o.Init(t,t.length);const l=new n.Decoder,m=l.GetEncodedGeometryType(o);let f,g;switch(m){case n.POINT_CLOUD:c=0,f=new n.PointCloud,g=l.DecodeBufferToPointCloud(o,f);break;case n.TRIANGULAR_MESH:c=4,f=new n.Mesh,g=l.DecodeBufferToMesh(o,f);case n.INVALID_GEOMETRY_TYPE:}if(!g||!g.ok()||0==f.ptr)return void i("Failed to decode draco compressed asset: "+(g?g.error_msg():"Mesh asset - invalid draco compressed geometry type: "+m));const y=f.num_faces();if(m===n.TRIANGULAR_MESH){const e=f.num_points()>65535;d=3*y;const t=d*(e?4:2),a=n._malloc(t);e?(l.GetTrianglesUInt32Array(f,t,a),p=new Uint32Array(n.HEAPU32.buffer,a,d).slice()):(l.GetTrianglesUInt16Array(f,t,a),p=new Uint16Array(n.HEAPU16.buffer,a,d).slice()),n._free(a)}h=function(e,t,n,a,i,s,r){const o=t.num_points(),l=function(e){const n=a.GetAttributeByUniqueId(t,e),s=o*n.num_components();let r,l,c,h;switch(n.data_type()){case i.DT_UINT8:h=1,c=1,r=i._malloc(s*c),a.GetAttributeDataArrayForAllPoints(t,n,i.DT_UINT8,s*c,r),l=new Uint8Array(i.HEAPU8.buffer,r,s).slice();break;case i.DT_UINT16:h=3,c=2,r=i._malloc(s*c),a.GetAttributeDataArrayForAllPoints(t,n,i.DT_UINT16,s*c,r),l=new Uint16Array(i.HEAPU16.buffer,r,s).slice();break;case i.DT_FLOAT32:default:h=6,c=4,r=i._malloc(s*c),a.GetAttributeDataArrayForAllPoints(t,n,i.DT_FLOAT32,s*c,r),l=new Float32Array(i.HEAPF32.buffer,r,s).slice()}return i._free(r),{values:l,numComponents:n.num_components(),componentSizeInBytes:c,storageType:h,normalized:n.normalized()}},c={},h=n.attributes;for(const e in h)if(h.hasOwnProperty(e)&&T_.hasOwnProperty(e)){const t=T_[e],n=l(h[e]),a=n.numComponents*n.componentSizeInBytes;c[t]={values:n.values,buffer:n.values.buffer,size:a,offset:0,stride:a,count:o,components:n.numComponents,type:n.storageType,normalize:n.normalized}}return c.hasOwnProperty("NORMAL")||L_(c,s),I_(e,c,r)}(e,f,r,l,n,p,s),n.destroy(f),n.destroy(l),n.destroy(o),u=!1}}}}h||(p=l.hasOwnProperty("indices")?S_(n[l.indices],a,!0):null,h=function(e,t,n,a,i,s,r){const o={},l=[];for(const e in t)t.hasOwnProperty(e)&&T_.hasOwnProperty(e)&&(o[e]=t[e],l.push(e+":"+t[e]));l.sort();const c=l.join();let h=r[c];if(!h){const l={};for(const e in o){const n=a[t[e]],s=S_(n,i),r=i[n.bufferView],o=T_[e],c=w_(n.type)*C_(n.componentType),h=r.hasOwnProperty("byteStride")?r.byteStride:c;l[o]={buffer:s.buffer,size:c,offset:s.byteOffset,stride:h,count:n.count,components:w_(n.type),type:x_(n.componentType),normalize:n.normalized}}l.hasOwnProperty("NORMAL")||L_(l,n),h=I_(e,l,s),r[c]=h}return h}(e,l.attributes,p,n,a,s,r),c=function(e){if(!e.hasOwnProperty("mode"))return 4;switch(e.mode){case 0:return 0;case 1:return 1;case 2:return 2;case 3:return 3;case 4:default:return 4;case 5:return 5;case 6:return 6}}(l));let m=null;if(h){if(m=new iy(e),m.vertexBuffer=h,m.primitive[0].type=c,m.primitive[0].base=0,m.primitive[0].indexed=null!==p,null!==p){let t;t=p instanceof Uint8Array?0:p instanceof Uint16Array?1:2,2!==t||e.extUintElement||(t=1,p=new Uint16Array(p));const n=new Tg(e,t,p.length,0,p);m.indexBuffer[0]=n,m.primitive[0].count=p.length}else m.primitive[0].count=h.numVertices;m.materialIndex=l.material;let i=n[l.attributes.POSITION];if(m.aabb=M_(i),u&&l.hasOwnProperty("targets")){const s=[];l.targets.forEach((function(e,r){const o={};e.hasOwnProperty("POSITION")&&(i=n[e.POSITION],o.deltaPositions=A_(i,a),o.deltaPositionsType=6,o.aabb=M_(i)),e.hasOwnProperty("NORMAL")&&(i=n[e.NORMAL],o.deltaNormals=A_(i,a),o.deltaNormalsType=6),t.hasOwnProperty("extras")&&t.extras.hasOwnProperty("targetNames")?o.name=t.extras.targetNames[r]:o.name=r.toString(10),t.hasOwnProperty("weights")&&(o.defaultWeight=t.weights[r]),s.push(new Zv(o))})),m.morph=new Pv(s,e)}}o.push(m)})),o},O_=function(e,t,n){const a=["#ifdef MAPFLOAT","uniform float material_shininess;","#endif","","#ifdef MAPTEXTURE","uniform sampler2D texture_glossMap;","#endif","","void getGlossiness() {","\t\tdGlossiness = 1.0;","","#ifdef MAPFLOAT","\t\tdGlossiness *= material_shininess;","#endif","","#ifdef MAPTEXTURE","\t\tdGlossiness *= texture2D(texture_glossMap, $UV, textureBias).$CH;","#endif","","#ifdef MAPVERTEX","\t\tdGlossiness *= saturate(vVertexColor.$VC);","#endif","","\t\tdGlossiness = 1.0 - dGlossiness;","","\t\tdGlossiness += 0.0000001;","}"].join("\n"),i=["#ifdef MAPCOLOR","uniform vec3 material_specular;","#endif","","#ifdef MAPTEXTURE","uniform sampler2D texture_specularMap;","#endif","","void getSpecularity() {","\t\tdSpecularity = vec3(1.0);","","\t\t#ifdef MAPCOLOR","\t\t\t\tdSpecularity *= material_specular;","\t\t#endif","","\t\t#ifdef MAPTEXTURE","\t\t\t\tvec3 srgb = texture2D(texture_specularMap, $UV, textureBias).$CH;","\t\t\t\tdSpecularity *= vec3(pow(srgb.r, 2.2), pow(srgb.g, 2.2), pow(srgb.b, 2.2));","\t\t#endif","","\t\t#ifdef MAPVERTEX","\t\t\t\tdSpecularity *= saturate(vVertexColor.$VC);","\t\t#endif","}"].join("\n"),s=["#ifdef MAPFLOAT","uniform float material_clearCoatGlossiness;","#endif","","#ifdef MAPTEXTURE","uniform sampler2D texture_clearCoatGlossMap;","#endif","","void getClearCoatGlossiness() {","\t\tccGlossiness = 1.0;","","#ifdef MAPFLOAT","\t\tccGlossiness *= material_clearCoatGlossiness;","#endif","","#ifdef MAPTEXTURE","\t\tccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV, textureBias).$CH;","#endif","","#ifdef MAPVERTEX","\t\tccGlossiness *= saturate(vVertexColor.$VC);","#endif","","\t\tccGlossiness = 1.0 - ccGlossiness;","","\t\tccGlossiness += 0.0000001;","}"].join("\n"),r=[0,0],o=[1,1],l=function(e,t,n){var a;let i;const s=e.texCoord;if(s)for(i=0;i<n.length;++i)t[n[i]+"MapUv"]=s;const l=null==(a=e.extensions)?void 0:a.KHR_texture_transform;if(l){const e=l.offset||r,a=l.scale||o,s=l.rotation?-l.rotation*Eu.RAD_TO_DEG:0,c=new Du(a[0],a[1]),h=new Du(e[0],1-a[1]-e[1]);for(i=0;i<n.length;++i)t[`${n[i]}MapTiling`]=c,t[`${n[i]}MapOffset`]=h,t[`${n[i]}MapRotation`]=s}},c=new cg;let h,d;if(c.occludeSpecular=!0,c.diffuseTint=!0,c.diffuseVertexColor=!0,c.specularTint=!0,c.specularVertexColor=!0,e.hasOwnProperty("name")&&(c.name=e.name),e.hasOwnProperty("extensions")&&e.extensions.hasOwnProperty("KHR_materials_pbrSpecularGlossiness")){const n=e.extensions.KHR_materials_pbrSpecularGlossiness;if(n.hasOwnProperty("diffuseFactor")?(h=n.diffuseFactor,c.diffuse.set(Math.pow(h[0],1/2.2),Math.pow(h[1],1/2.2),Math.pow(h[2],1/2.2)),c.opacity=h[3]):(c.diffuse.set(1,1,1),c.opacity=1),n.hasOwnProperty("diffuseTexture")){const e=n.diffuseTexture;d=t[e.index],c.diffuseMap=d,c.diffuseMapChannel="rgb",c.opacityMap=d,c.opacityMapChannel="a",l(e,c,["diffuse","opacity"])}if(c.useMetalness=!1,n.hasOwnProperty("specularFactor")?(h=n.specularFactor,c.specular.set(Math.pow(h[0],1/2.2),Math.pow(h[1],1/2.2),Math.pow(h[2],1/2.2))):c.specular.set(1,1,1),n.hasOwnProperty("glossinessFactor")?c.shininess=100*n.glossinessFactor:c.shininess=100,n.hasOwnProperty("specularGlossinessTexture")){const e=n.specularGlossinessTexture;c.specularMap=c.glossMap=t[e.index],c.specularMapChannel="rgb",c.glossMapChannel="a",l(e,c,["gloss","metalness"])}c.chunks.specularPS=i}else if(e.hasOwnProperty("pbrMetallicRoughness")){const n=e.pbrMetallicRoughness;if(n.hasOwnProperty("baseColorFactor")?(h=n.baseColorFactor,c.diffuse.set(Math.pow(h[0],1/2.2),Math.pow(h[1],1/2.2),Math.pow(h[2],1/2.2)),c.opacity=h[3]):(c.diffuse.set(1,1,1),c.opacity=1),n.hasOwnProperty("baseColorTexture")){const e=n.baseColorTexture;d=t[e.index],c.diffuseMap=d,c.diffuseMapChannel="rgb",c.opacityMap=d,c.opacityMapChannel="a",l(e,c,["diffuse","opacity"])}if(c.useMetalness=!0,n.hasOwnProperty("metallicFactor")?c.metalness=n.metallicFactor:c.metalness=1,n.hasOwnProperty("roughnessFactor")?c.shininess=100*n.roughnessFactor:c.shininess=100,n.hasOwnProperty("metallicRoughnessTexture")){const e=n.metallicRoughnessTexture;c.metalnessMap=c.glossMap=t[e.index],c.metalnessMapChannel="b",c.glossMapChannel="g",l(e,c,["gloss","metalness"])}c.chunks.glossPS=a}if(e.hasOwnProperty("normalTexture")){const n=e.normalTexture;c.normalMap=t[n.index],l(n,c,["normal"]),n.hasOwnProperty("scale")&&(c.bumpiness=n.scale)}if(e.hasOwnProperty("occlusionTexture")){const n=e.occlusionTexture;c.aoMap=t[n.index],c.aoMapChannel="r",l(n,c,["ao"])}if(e.hasOwnProperty("emissiveFactor")?(h=e.emissiveFactor,c.emissive.set(Math.pow(h[0],1/2.2),Math.pow(h[1],1/2.2),Math.pow(h[2],1/2.2)),c.emissiveTint=!0):(c.emissive.set(0,0,0),c.emissiveTint=!1),e.hasOwnProperty("emissiveTexture")){const n=e.emissiveTexture;c.emissiveMap=t[n.index],l(n,c,["emissive"])}if(e.hasOwnProperty("alphaMode"))switch(e.alphaMode){case"MASK":c.blendType=3,e.hasOwnProperty("alphaCutoff")?c.alphaTest=e.alphaCutoff:c.alphaTest=.5;break;case"BLEND":c.blendType=2,c.depthWrite=!1;break;default:c.blendType=3}else c.blendType=3;if(e.hasOwnProperty("doubleSided")?(c.twoSidedLighting=e.doubleSided,c.cull=e.doubleSided?0:1):(c.twoSidedLighting=!1,c.cull=1),e.hasOwnProperty("extensions")&&e.extensions.hasOwnProperty("KHR_materials_clearcoat")){const n=e.extensions.KHR_materials_clearcoat;if(n.hasOwnProperty("clearcoatFactor")?c.clearCoat=.25*n.clearcoatFactor:c.clearCoat=0,n.hasOwnProperty("clearcoatTexture")){const e=n.clearcoatTexture;c.clearCoatMap=t[e.index],c.clearCoatMapChannel="r",l(e,c,["clearCoat"])}if(n.hasOwnProperty("clearcoatRoughnessFactor")?c.clearCoatGlossiness=n.clearcoatRoughnessFactor:c.clearCoatGlossiness=0,n.hasOwnProperty("clearcoatRoughnessTexture")){const e=n.clearcoatRoughnessTexture;c.clearCoatGlossMap=t[e.index],c.clearCoatGlossMapChannel="g",l(e,c,["clearCoatGloss"])}if(n.hasOwnProperty("clearcoatNormalTexture")){const e=n.clearcoatNormalTexture;c.clearCoatNormalMap=t[e.index],l(e,c,["clearCoatNormal"]),e.hasOwnProperty("scale")&&(c.clearCoatBumpiness=e.scale)}c.chunks.clearCoatGlossPS=s}return e.hasOwnProperty("extensions")&&e.extensions.hasOwnProperty("KHR_materials_unlit")&&(c.useLighting=!1,c.emissive.copy(c.diffuse),c.emissiveTint=c.diffuseTint,c.emissiveMap=c.diffuseMap,c.emissiveMapUv=c.diffuseMapUv,c.emissiveMapTiling.copy(c.diffuseMapTiling),c.emissiveMapOffset.copy(c.diffuseMapOffset),c.emissiveMapChannel=c.diffuseMapChannel,c.emissiveVertexColor=c.diffuseVertexColor,c.emissiveVertexColorChannel=c.diffuseVertexColorChannel,c.diffuse.set(0,0,0),c.diffuseTint=!1,c.diffuseMap=null,c.diffuseVertexColor=!1),c.update(),c},F_=function(e,t){const n=new hf;if(e.hasOwnProperty("name")&&e.name.length>0?n.name=e.name:n.name="node_"+t,e.hasOwnProperty("matrix")&&(P_.data.set(e.matrix),P_.getTranslation(k_),n.setLocalPosition(k_),P_.getEulerAngles(k_),n.setLocalEulerAngles(k_),P_.getScale(k_),n.setLocalScale(k_)),e.hasOwnProperty("rotation")){const t=e.rotation;n.setLocalRotation(t[0],t[1],t[2],t[3])}if(e.hasOwnProperty("translation")){const t=e.translation;n.setLocalPosition(t[0],t[1],t[2])}if(e.hasOwnProperty("scale")){const t=e.scale;n.setLocalScale(t[0],t[1],t[2])}return n},N_=function(e,t){const n="orthographic"===e.type?1:0,a=1===n?e.orthographic:e.perspective,i={enabled:!1,projection:n,nearClip:a.znear,aspectRatioMode:0};a.zfar&&(i.farClip=a.zfar),1===n?(i.orthoHeight=.5*a.ymag,a.ymag&&(i.aspectRatioMode=1,i.aspectRatio=a.xmag/a.ymag)):(i.fov=a.yfov*Eu.RAD_TO_DEG,a.aspectRatio&&(i.aspectRatioMode=1,i.aspectRatio=a.aspectRatio));const s=new KM(e.name);return s.addComponent("camera",i),s},V_=function(e,t){const n={enabled:!1,type:"point"===e.type?"omni":e.type,color:e.hasOwnProperty("color")?new Mu(e.color):Mu.WHITE,range:e.hasOwnProperty("range")?e.range:9999,falloffMode:1,intensity:e.hasOwnProperty("intensity")?Eu.clamp(e.intensity,0,2):1};e.hasOwnProperty("spot")&&(n.innerConeAngle=e.spot.hasOwnProperty("innerConeAngle")?e.spot.innerConeAngle*Eu.RAD_TO_DEG:0,n.outerConeAngle=e.spot.hasOwnProperty("outerConeAngle")?e.spot.outerConeAngle*Eu.RAD_TO_DEG:Math.PI/4);const a=new KM(t.name);return a.rotateLocal(90,0,0),a.addComponent("light",n),a},B_=function(e,t,n,a){if(!t.hasOwnProperty("skins")||0===t.skins.length)return[];const i=new Map;return t.skins.map((function(s){return function(e,t,n,a,i,s){let r,o,l;const c=t.joints,h=c.length,d=[];if(t.hasOwnProperty("inverseBindMatrices")){const e=t.inverseBindMatrices,i=S_(n[e],a,!0),s=[];for(r=0;r<h;r++){for(o=0;o<16;o++)s[o]=i[16*r+o];l=new zu,l.set(s),d.push(l)}}else for(r=0;r<h;r++)l=new zu,d.push(l);const p=[];for(r=0;r<h;r++)p[r]=i[c[r]].name;const u=p.join("#");let m=s.get(u);return m||(m=new $v(e,d,p),s.set(u,m)),m}(e,s,t.accessors,a,n,i)}))},U_=function(e,t,n,a){if(!e.hasOwnProperty("animations")||0===e.animations.length)return[];const i=a&&a.animation&&a.animation.preprocess,s=a&&a.animation&&a.animation.postprocess;return e.animations.map((function(a,r){i&&i(a);const o=function(e,t,n,a,i){const s=function(e){return new e_(w_(e.type),A_(e,a))},r={STEP:0,LINEAR:1,CUBICSPLINE:2},o={},l=[],c={},h=[],d=[];let p;for(p=0;p<e.samplers.length;++p){const t=e.samplers[p];o.hasOwnProperty(t.input)||(o[t.input]=l.length,l.push(s(n[t.input]))),c.hasOwnProperty(t.output)||(c[t.output]=h.length,h.push(s(n[t.output])));const a=t.hasOwnProperty("interpolation")&&r.hasOwnProperty(t.interpolation)?r[t.interpolation]:1;d.push(new Jv([],o[t.input],c[t.output],a))}const u=[],m={translation:"localPosition",rotation:"localRotation",scale:"localScale",weights:"weights"},f=e=>{const t=[];for(;e;)t.unshift(e.name),e=e.parent;return t};for(p=0;p<e.channels.length;++p){const t=e.channels[p],n=t.target,a=d[t.sampler],s=f(i[n.node]);a._paths.push({entityPath:s,component:"graph",propertyPath:[m[n.path]]}),n.path.startsWith("rotation")&&2!==a.interpolation?u.push(a.output):n.path.startsWith("weights")&&(h[a.output]._components=h[a.output].data.length/l[a.input].data.length)}u.sort();let g,y=null;for(p=0;p<u.length;++p){const e=u[p];if(0===p||e!==y){if(g=h[e],4===g.components){const e=g.data,t=e.length-4;for(let n=0;n<t;n+=4)e[n+0]*e[n+4]+e[n+1]*e[n+5]+e[n+2]*e[n+6]+e[n+3]*e[n+7]<0&&(e[n+4]*=-1,e[n+5]*=-1,e[n+6]*=-1,e[n+7]*=-1)}y=e}}let b=0;for(p=0;p<l.length;p++)g=l[p]._data,b=Math.max(b,0===g.length?0:g[g.length-1]);return new n_(e.hasOwnProperty("name")?e.name:"animation_"+t,b,l,h,d)}(a,r,e.accessors,n,t);return s&&s(a,o),o}))},z_=function(e,t,n,a,i,s){const r=i&&i.global&&i.global.preprocess,o=i&&i.global&&i.global.postprocess;r&&r(t);const l=t.asset&&"PlayCanvas"===t.asset.generator,c=function(e,t){if(!e.hasOwnProperty("nodes")||0===e.nodes.length)return[];const n=t&&t.node&&t.node.preprocess,a=t&&t.node&&t.node.process||F_,i=t&&t.node&&t.node.postprocess,s=e.nodes.map((function(e,t){n&&n(e);const s=a(e,t);return i&&i(e,s),s}));for(let t=0;t<e.nodes.length;++t){const n=e.nodes[t];if(n.hasOwnProperty("children")){const e=s[t],a={};for(let t=0;t<n.children.length;++t){const i=s[n.children[t]];i.parent||(a.hasOwnProperty(i.name)?i.name+=a[i.name]++:a[i.name]=1,e.addChild(i))}}}return s}(t,i),h=function(e,t){var n;const a=[],i=e.scenes.length;if(1===i&&1===(null==(n=e.scenes[0].nodes)?void 0:n.length)){const n=e.scenes[0].nodes[0];a.push(t[n])}else for(let n=0;n<i;n++){const i=e.scenes[n];if(i.nodes){const e=new hf(i.name);for(let n=0;n<i.nodes.length;n++){const a=t[i.nodes[n]];e.addChild(a)}a.push(e)}}return a}(t,c),d=function(e,t,n){let a=null;if(e.hasOwnProperty("nodes")&&e.hasOwnProperty("extensions")&&e.extensions.hasOwnProperty("KHR_lights_punctual")&&e.extensions.KHR_lights_punctual.hasOwnProperty("lights")){const i=e.extensions.KHR_lights_punctual.lights;if(i.length){const s=n&&n.light&&n.light.preprocess,r=n&&n.light&&n.light.process||V_,o=n&&n.light&&n.light.postprocess;e.nodes.forEach((function(e,n){if(e.hasOwnProperty("extensions")&&e.extensions.hasOwnProperty("KHR_lights_punctual")&&e.extensions.KHR_lights_punctual.hasOwnProperty("light")){const l=e.extensions.KHR_lights_punctual.light,c=i[l];if(c){s&&s(c);const i=r(c,t[n]);o&&o(c,i),i&&(a||(a=new Map),a.set(e,i))}}}))}}return a}(t,c,i),p=function(e,t,n){let a=null;if(e.hasOwnProperty("nodes")&&e.hasOwnProperty("cameras")&&e.cameras.length>0){const i=n&&n.camera&&n.camera.preprocess,s=n&&n.camera&&n.camera.process||N_,r=n&&n.camera&&n.camera.postprocess;e.nodes.forEach((function(n,o){if(n.hasOwnProperty("camera")){const l=e.cameras[n.camera];if(l){i&&i(l);const e=s(l,t[o]);r&&r(l,e),e&&(a||(a=new Map),a.set(n,e))}}}))}return a}(t,c,i),u=U_(t,c,n,i),m=function(e,t,n,a){if(!e.hasOwnProperty("materials")||0===e.materials.length)return[];const i=n&&n.material&&n.material.preprocess,s=n&&n.material&&n.material.process||O_,r=n&&n.material&&n.material.postprocess;return e.materials.map((function(e){i&&i(e);const n=s(e,t,a);return r&&r(e,n),n}))}(t,a.map((function(e){return e.resource})),i,l),f=function(e,t,n,a,i){if(!t.hasOwnProperty("meshes")||0===t.meshes.length||!t.hasOwnProperty("accessors")||0===t.accessors.length||!t.hasOwnProperty("bufferViews")||0===t.bufferViews.length)return[];const s={};return t.meshes.map((function(r){return D_(e,r,t.accessors,n,a,i,s)}))}(e,t,n,s,l),g=B_(e,t,c,n),y=[];for(let e=0;e<f.length;e++)y[e]=new Qv,y[e].meshes=f[e];!function(e,t,n){e.nodes.forEach((e=>{e.hasOwnProperty("mesh")&&e.hasOwnProperty("skin")&&t[e.mesh].meshes.forEach((t=>{t.skin=n[e.skin]}))}))}(t,y,g);const b=new v_(t);b.nodes=c,b.scenes=h,b.animations=u,b.textures=a,b.materials=m,b.renders=y,b.skins=g,b.lights=d,b.cameras=p,o&&o(t,b),s(null,b)};let G_=0;const H_=function(e,t,n,a,i,s,r){const o=s&&s.image&&s.image.preprocess,l=s&&s.image&&s.image.processAsync||function(e,t){t(null,null)},c=s&&s.image&&s.image.postprocess,h=function(t){c&&c(e,t),r(null,t)},d={"image/png":"png","image/jpeg":"jpg","image/basis":"basis","image/ktx":"ktx","image/ktx2":"ktx2","image/vnd-ms.dds":"dds"},p=function(t,n,a,s){const o=(e.name||"gltf-texture")+"-"+G_++,l={url:t||o};if(n&&(l.contents=n.slice(0).buffer),a){const e=d[a];e&&(l.filename=l.url+"."+e)}const c=new f_(o,"texture",l,null,s);c.on("load",h),c.on("error",r),i.add(c),i.load(c)};o&&o(e),l(e,(function(i,s){var o;i?r(i):s?h(s):e.hasOwnProperty("uri")?__(e.uri)?p(e.uri,null,(o=e.uri).substring(o.indexOf(":")+1,o.indexOf(";")),null):p(tu.join(a,e.uri),null,null,{crossOrigin:"anonymous"}):e.hasOwnProperty("bufferView")&&e.hasOwnProperty("mimeType")?p(null,n[e.bufferView],e.mimeType,null):r("Invalid image found in gltf (neither uri or bufferView found). index="+t)}))},W_=function(e,t){const n=JSON.parse(function(e){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(e);let t="";for(let n=0;n<e.length;n++)t+=String.fromCharCode(e[n]);return decodeURIComponent(escape(t))}(e));n.asset&&n.asset.version&&parseFloat(n.asset.version)<2?t(`Invalid gltf version. Expected version 2.0 or above but found version '${n.asset.version}'.`):t(null,n)},j_=function(e,t,n){e&&e.toLowerCase().endsWith(".glb")?function(e,t){const n=e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength),a=n.getUint32(0,!0),i=n.getUint32(4,!0),s=n.getUint32(8,!0);if(1179937895!==a)return void t("Invalid magic number found in glb header. Expected 0x46546C67, found 0x"+a.toString(16));if(2!==i)return void t("Invalid version number found in glb header. Expected 2, found "+i);if(s<=0||s>n.byteLength)return void t("Invalid length found in glb header. Found "+s);const r=[];let o=12;for(;o<s;){const e=n.getUint32(o,!0);if(o+e+8>n.byteLength)throw new Error("Invalid chunk length found in glb. Found "+e);const t=n.getUint32(o+4,!0),a=new Uint8Array(n.buffer,n.byteOffset+o+8,e);r.push({length:e,type:t,data:a}),o+=e+8}1===r.length||2===r.length?1313821514===r[0].type?r.length>1&&5130562!==r[1].type?t("Invalid chunk type found in glb file. Expected 0x004E4942, found 0x"+r[1].type.toString(16)):t(null,{gltfChunk:r[0].data,binaryChunk:2===r.length?r[1].data:null}):t("Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x"+r[0].type.toString(16)):t("Invalid number of chunks found in glb file.")}(t,n):n(null,{gltfChunk:t,binaryChunk:null})},X_=function(e,t,n,a){const i=[],s=n&&n.bufferView&&n.bufferView.preprocess,r=n&&n.bufferView&&n.bufferView.processAsync||function(e,t,n){n(null,null)},o=n&&n.bufferView&&n.bufferView.postprocess;let l=e.bufferViews?e.bufferViews.length:0;if(!l)return void a(null,null);const c=function(t,n){const s=e.bufferViews[t];s.hasOwnProperty("byteStride")&&(n.byteStride=s.byteStride),i[t]=n,o&&o(s,n),0==--l&&a(null,i)};for(let n=0;n<e.bufferViews.length;++n){const i=e.bufferViews[n];s&&s(i),r(i,t,function(e,n,i,s){if(i)a(i);else if(s)c(e,s);else{const a=t[n.buffer],i=new Uint8Array(a.buffer,a.byteOffset+(n.byteOffset||0),n.byteLength);c(e,i)}}.bind(null,n,i))}};class Y_{static parseAsync(e,t,n,a,i,s,r){j_(e,n,(function(e,n){e?r(e):W_(n.gltfChunk,(function(e,o){e?r(e):function(e,t,n,a,i){const s=[];if(!e.buffers||0===e.buffers.length)return void i(null,s);const r=a&&a.buffer&&a.buffer.preprocess,o=a&&a.buffer&&a.buffer.processAsync||function(e,t){t(null,null)},l=a&&a.buffer&&a.buffer.postprocess;let c=e.buffers.length;const h=function(t,n){s[t]=n,l&&l(e.buffers[t],n),0==--c&&i(null,s)};for(let a=0;a<e.buffers.length;++a){const s=e.buffers[a];r&&r(s),o(s,function(e,a,s,r){if(s)i(s);else if(r)h(e,new Uint8Array(r));else if(a.hasOwnProperty("uri"))if(__(a.uri)){const t=atob(a.uri.split(",")[1]),n=new Uint8Array(t.length);for(let e=0;e<t.length;e++)n[e]=t.charCodeAt(e);h(e,n)}else Au.get(tu.join(n,a.uri),{cache:!0,responseType:"arraybuffer",retry:!1},function(e,t,n){t?i(t):h(e,new Uint8Array(n))}.bind(null,e));else h(e,t)}.bind(null,a,s))}}(o,n.binaryChunk,t,s,(function(e,n){e?r(e):X_(o,n,s,(function(e,n){e?r(e):function(e,t,n,a,i,s){if(!e.hasOwnProperty("images")||0===e.images.length||!e.hasOwnProperty("textures")||0===e.textures.length)return void s(null,[]);const r=i&&i.texture&&i.texture.preprocess,o=i&&i.texture&&i.texture.processAsync||function(e,t,n){n(null,null)},l=i&&i.texture&&i.texture.postprocess,c=[],h=[];let d=e.textures.length;const p=function(t,n){if(h[n]||(h[n]=[]),h[n].push(t),0==--d){const t=[];h.forEach((function(n,a){n.forEach((function(n,i){const s=0===i?c[a]:R_(c[a]);!function(e,t){const n=function(e,t){switch(e){case 9728:return 0;case 9729:return 1;case 9984:return 2;case 9985:return 4;case 9986:return 3;case 9987:return 5;default:return t}},a=function(e,t){switch(e){case 33071:return 1;case 33648:return 2;case 10497:return 0;default:return t}};e&&(t=t||{},e.minFilter=n(t.minFilter,5),e.magFilter=n(t.magFilter,1),e.addressU=a(t.wrapS,0),e.addressV=a(t.wrapT,0))}(s.resource,(e.samplers||[])[e.textures[n].sampler]),t[n]=s,l&&l(e.textures[n],s)}))})),s(null,t)}};for(let l=0;l<e.textures.length;++l){const h=e.textures[l];r&&r(h),o(h,e.images,function(r,o,l,h){var d,u;if(l)s(l);else if(null==h&&void 0===(h=null==o||null==(d=o.extensions)||null==(u=d.KHR_texture_basisu)?void 0:u.source)&&(h=o.source),c[h])p(r,h);else{const o=e.images[h];H_(o,r,t,n,a,i,(function(e,t){e?s(e):(c[h]=t,p(r,h))}))}}.bind(null,l,h))}}(o,n,t,i,s,(function(e,t){e?r(e):z_(a,o,n,t,s,r)}))}))}))}))}))}static parse(e,t,n,a){let i=null;return a=a||{},j_(e,t,(function(e,t){e?console.error(e):W_(t.gltfChunk,(function(e,s){e?console.error(e):X_(s,[t.binaryChunk],a,(function(e,t){e?console.error(e):z_(n,s,t,[],a,(function(e,t){e?console.error(e):i=t}))}))}))})),i}constructor(e,t,n){this._device=e,this._assets=t,this._defaultMaterial=$f(e),this._maxRetries=n}_getUrlWithoutParams(e){return e.indexOf("?")>=0?e.split("?")[0]:e}load(e,t,n){f_.fetchArrayBuffer(e.load,((a,i)=>{a?t(a):Y_.parseAsync(this._getUrlWithoutParams(e.original),tu.extractPath(e.load),i,this._device,n.registry,n.options,((e,a)=>{e?t(e):t(null,new b_(a,n,this._assets,this._defaultMaterial))}))}),n,this._maxRetries)}open(e,t,n){return t}patch(e,t){}}class q_{constructor(){this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e});const n={retry:this.maxRetries>0,maxRetries:this.maxRetries};(e.load.startsWith("blob:")||e.load.startsWith("data:"))&&(".glb"===tu.getExtension(e.original).toLowerCase()?n.responseType=Su.ResponseType.ARRAY_BUFFER:n.responseType=Su.ResponseType.JSON),Au.get(e.load,n,(function(n,a){n?t(`Error loading animation resource: ${e.original} [${n}]`):t(null,a)}))}open(e,t){if(".glb"===tu.getExtension(e).toLowerCase()){const e=Y_.parse("filename.glb",t,null);if(e){const t=e.animations;return e.destroy(),t}return null}return this["_parseAnimationV"+t.animation.version](t)}patch(e,t){}_parseAnimationV3(e){const t=e.animation,n=new Kv;n.name=t.name,n.duration=t.duration;for(let e=0;e<t.nodes.length;e++){const a=new qv,i=t.nodes[e];a._name=i.name;for(let e=0;e<i.keys.length;e++){const t=i.keys[e],n=t.time,s=t.pos,r=t.rot,o=t.scale,l=new Pu(s[0],s[1],s[2]),c=(new Gu).setFromEulerAngles(r[0],r[1],r[2]),h=new Pu(o[0],o[1],o[2]),d=new Yv(n,l,c,h);a._keys.push(d)}n.addNode(a)}return n}_parseAnimationV4(e){const t=e.animation,n=new Kv;n.name=t.name,n.duration=t.duration;for(let e=0;e<t.nodes.length;e++){const a=new qv,i=t.nodes[e];a._name=i.name;const s=i.defaults.p,r=i.defaults.r,o=i.defaults.s;for(let e=0;e<i.keys.length;e++){const t=i.keys[e],n=t.t,l=s||t.p,c=r||t.r,h=o||t.s,d=new Pu(l[0],l[1],l[2]),p=(new Gu).setFromEulerAngles(c[0],c[1],c[2]),u=new Pu(h[0],h[1],h[2]),m=new Yv(n,d,p,u);a._keys.push(m)}n.addNode(a)}return n}}class K_{constructor(){this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e});const n={retry:this.maxRetries>0,maxRetries:this.maxRetries};e.load.startsWith("blob:")&&(n.responseType=Su.ResponseType.JSON),Au.get(e.load,n,(function(n,a){n?t(`Error loading animation clip resource: ${e.original} [${n}]`):t(null,a)}))}open(e,t){const n=t.name,a=t.duration,i=t.inputs.map((function(e){return new e_(1,e)})),s=t.outputs.map((function(e){return new e_(e.components,e.data)})),r=t.curves.map((function(e){return new Jv([e.path],e.inputIndex,e.outputIndex,e.interpolation)}));return new n_(n,a,i,s,r)}patch(e,t){}}class Z_{constructor(e){if(this._layers=[],this._parameters={},Array.isArray(e.layers))this._layers=e.layers;else for(const t in e.layers){const n=e.layers[t],a={name:n.name,blendType:n.blendType,weight:n.weight,states:[],transitions:[]};for(let t=0;t<n.states.length;t++)a.states.push(e.states[n.states[t]]);for(let t=0;t<n.transitions.length;t++){const i=e.transitions[n.transitions[t]];if(i.conditions&&!Array.isArray(i.conditions)){const e=Object.keys(i.conditions),t=[];for(let n=0;n<e.length;n++){const a=i.conditions[e[n]];a.parameterName&&t.push(a)}i.conditions=t}Number.isInteger(i.from)&&(i.from=e.states[i.from].name),Number.isInteger(i.to)&&(i.to=e.states[i.to].name),a.transitions.push(i)}this._layers.push(a)}for(const t in e.parameters){const n=e.parameters[t];this._parameters[n.name]={type:n.type,value:n.value}}}get parameters(){return Object.assign({},this._parameters)}get layers(){return this._layers}}class $_{constructor(){this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e});const n={retry:this.maxRetries>0,maxRetries:this.maxRetries};e.load.startsWith("blob:")&&(n.responseType=Su.ResponseType.JSON),Au.get(e.load,n,(function(n,a){n?t(`Error loading animation state graph resource: ${e.original} [${n}]`):t(null,a)}))}open(e,t){return new Z_(t)}patch(e,t){}}class Q_{constructor(e){this.audio=void 0,this.buffer=void 0,e instanceof Audio?this.audio=e:this.buffer=e}get duration(){let e=0;return this.buffer?e=this.buffer.duration:this.audio&&(e=this.audio.duration),e||0}}const J_=function(){if("undefined"==typeof window)return!1;const e=window.navigator.userAgent,t=e.indexOf("MSIE ");if(t>0)return parseInt(e.substring(t+5,e.indexOf(".",t)),10);if(e.indexOf("Trident/")>0){const t=e.indexOf("rv:");return parseInt(e.substring(t+3,e.indexOf(".",t)),10)}return!1}(),ew={".ogg":"audio/ogg",".mp3":"audio/mpeg",".wav":"audio/x-wav",".mp4a":"audio/mp4",".m4a":"audio/mp4",".mp4":"audio/mp4",".aac":"audio/aac"};class tw{constructor(e){this.manager=e,this.maxRetries=0}_isSupported(e){const t=tu.getExtension(e);return!!ew[t]}load(e,t){"string"==typeof e&&(e={load:e,original:e});const n=function(e){t(null,new Q_(e))},a=function(n){let a="Error loading audio url: "+e.original;n&&(a+=": "+(n.message||n)),console.warn(a),t(a)};if(this._createSound){if(!this._isSupported(e.original))return void a(`Audio format for ${e.original} not supported`);this._createSound(e.load,n,a)}else a(null)}open(e,t){return t}patch(e,t){}_createSound(e,t,n){if(zv()){const a=this.manager;if(!a.context)return void n("Audio manager has no audio context");const i={retry:this.maxRetries>0,maxRetries:this.maxRetries};(e.startsWith("blob:")||e.startsWith("data:"))&&(i.responseType=Su.ResponseType.ARRAY_BUFFER),Au.get(e,i,(function(e,i){e?n(e):a.context.decodeAudioData(i,t,n)}))}else{let a=null;try{a=new Audio}catch(e){return void n("No support for Audio element")}J_&&document.body.appendChild(a);const i=function e(){a.removeEventListener("canplaythrough",e),J_&&document.body.removeChild(a),t(a)};a.onerror=function(){a.onerror=null,J_&&document.body.removeChild(a),n()},a.addEventListener("canplaythrough",i),a.src=e}}}class nw{constructor(){this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e}),Au.get(e.load,{responseType:Su.ResponseType.ARRAY_BUFFER,retry:this.maxRetries>0,maxRetries:this.maxRetries},(function(n,a){n?t(`Error loading binary resource: ${e.original} [${n}]`):t(null,a)}))}open(e,t){return t}patch(e,t){}}class aw{constructor(e){this._blobUrls={};for(let t=0,n=e.length;t<n;t++)e[t].url&&(this._blobUrls[e[t].name]=e[t].url)}hasBlobUrl(e){return!!this._blobUrls[e]}getBlobUrl(e){return this._blobUrls[e]}destroy(){for(const e in this._blobUrls)URL.revokeObjectURL(this._blobUrls[e]);this._blobUrls=null}}let iw;function sw(e){let t,n;if("undefined"!=typeof TextDecoder)try{t=new TextDecoder("utf-8"),n=new TextDecoder("windows-1252")}catch(e){console.warn("TextDecoder not supported - pc.Untar module will not work")}else console.warn("TextDecoder not supported - pc.Untar module will not work");function a(e){this._fields=e}function i(e){this._arrayBuffer=e||new ArrayBuffer(0),this._bufferView=new DataView(this._arrayBuffer),this._globalPaxHeader=null,this._paxHeader=null,this._bytesRead=0}a.parse=function(e,n,i){const s=new Uint8Array(e,n,i);let r=0;const o=[];for(;r<i;){let a;for(a=r;a<i&&32!==s[a];a++);if(a>=i)throw new Error("Invalid PAX header data format.");const l=parseInt(t.decode(new Uint8Array(e,n+r,a-r)),10),c=t.decode(new Uint8Array(e,n+a+1,l-(a-r)-2)).split("=");if(2!==c.length)throw new Error("Invalid PAX header data format.");0===c[1].length&&(c[1]=null),o.push({name:c[0],value:c[1]}),r+=l}return new a(o)},a.prototype.applyHeader=function(e){for(let t=0;t<this._fields.length;t++){let n=this._fields[t].name;const a=this._fields[t].value;"path"===n&&(n="name"),null===a?delete e[n]:e[n]=a}},e||(iw=i),i.prototype._hasNext=function(){return this._bytesRead+4<this._arrayBuffer.byteLength&&0!==this._bufferView.getUint32(this._bytesRead)},i.prototype._readNextFile=function(){const t=new DataView(this._arrayBuffer,this._bytesRead,512),i=n.decode(t);this._bytesRead+=512;let s=i.substr(0,100).replace(/\0/g,"");const r=i.substr(257,6),o=parseInt(i.substr(124,12),8),l=i.substr(156,1),c=this._bytesRead;let h=null,d=!1;switch(l){case"0":case"":if(d=!0,!e){const e=new Blob([this._arrayBuffer.slice(this._bytesRead,this._bytesRead+o)]);h=URL.createObjectURL(e)}break;case"g":this._globalPaxHeader=a.parse(this._arrayBuffer,this._bytesRead,o);break;case"x":this._paxHeader=a.parse(this._arrayBuffer,this._bytesRead,o)}this._bytesRead+=o;const p=o%512;if(0!==p&&(this._bytesRead+=512-p),!d)return null;if(-1!==r.indexOf("ustar")){const e=i.substr(345,155).replace(/\0/g,"");e.length>0&&(s=e.trim()+s.trim())}const u={name:s,start:c,size:o,url:h};return this._globalPaxHeader&&this._globalPaxHeader.applyHeader(u),this._paxHeader&&(this._paxHeader.applyHeader(u),this._paxHeader=null),u},i.prototype.untar=function(e){if(!t)return console.error("Cannot untar because TextDecoder interface is not available for this platform."),[];const n=[];for(;this._hasNext();){const t=this._readNextFile();t&&(e&&t.name&&(t.name=e+t.name),n.push(t))}return n},e&&(self.onmessage=function(e){const t=e.data.id;try{const n=new i(e.data.arrayBuffer).untar(e.data.prefix);postMessage({id:t,files:n,arrayBuffer:e.data.arrayBuffer},[e.data.arrayBuffer])}catch(e){postMessage({id:t,error:e.toString()})}})}let rw=null;class ow{constructor(e){this._requestId=0,this._pendingRequests={},this._filenamePrefix=e,this._worker=new Worker(function(){if(!rw){const e="("+sw.toString()+")(true)\n\n",t=new Blob([e],{type:"application/javascript"});rw=URL.createObjectURL(t)}return rw}()),this._worker.addEventListener("message",this._onMessage.bind(this))}_onMessage(e){const t=e.data.id;if(!this._pendingRequests[t])return;const n=this._pendingRequests[t];if(delete this._pendingRequests[t],e.data.error)n(e.data.error);else{const t=e.data.arrayBuffer;for(let n=0,a=e.data.files.length;n<a;n++){const a=e.data.files[n],i=new Blob([t.slice(a.start,a.start+a.size)]);a.url=URL.createObjectURL(i)}n(null,e.data.files)}}untar(e,t){const n=this._requestId++;this._pendingRequests[n]=t,this._worker.postMessage({id:n,prefix:this._filenamePrefix,arrayBuffer:e},[e])}hasPendingRequests(){return Object.keys(this._pendingRequests).length>0}destroy(){this._worker&&(this._worker.terminate(),this._worker=null,this._pendingRequests=null)}}sw();class lw{constructor(e){this._assets=e,this._worker=null,this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e});const n=this;Au.get(e.load,{responseType:Su.ResponseType.ARRAY_BUFFER,retry:this.maxRetries>0,maxRetries:this.maxRetries},(function(a,i){if(a)t("Error loading bundle resource "+e.original+": "+a);else try{n._untar(i,t)}catch(n){t("Error loading bundle resource "+e.original+": "+n)}}))}_untar(e,t){const n=this;if(uu.workers)n._worker||(n._worker=new ow(n._assets.prefix)),n._worker.untar(e,(function(e,a){t(e,a),n._worker.hasPendingRequests()||(n._worker.destroy(),n._worker=null)}));else{const a=new iw(e).untar(n._assets.prefix);t(null,a)}}open(e,t){return new aw(t)}patch(e,t){}}class cw{constructor(e,t){this.glbParser=new Y_(e,t,0),this.parsers={}}_getUrlWithoutParams(e){return e.indexOf("?")>=0?e.split("?")[0]:e}_getParser(e){const t=e?tu.getExtension(this._getUrlWithoutParams(e)).toLowerCase().replace(".",""):null;return this.parsers[t]||this.glbParser}load(e,t,n){"string"==typeof e&&(e={load:e,original:e}),this._getParser(e.original).load(e,t,n)}open(e,t,n){return this._getParser(e).open(e,t,n)}patch(e,t){}}class hw{constructor(){this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e}),Au.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(function(n,a){n?t(`Error loading css resource: ${e.original} [${n}]`):t(null,a)}))}open(e,t){return t}patch(e,t){}}class dw{constructor(e,t,n){this._device=e,this._registry=t,this._loader=n}load(e,t,n){this.loadAssets(n,t)}open(e,t,n){return n?n.resource:null}patch(e,t){this.loadAssets(e,(function(n,a){n&&(t.fire("error",e),t.fire("error:"+e.id,n,e),e.fire("error",e))}))}getAssetIds(e){const t=[];if(t[0]=e.file,(e.loadFaces||!e.file)&&e.data&&e.data.textures)for(let n=0;n<6;++n)t[n+1]=e.data.textures[n];else t[1]=t[2]=t[3]=t[4]=t[5]=t[6]=null;return t}compareAssetIds(e,t){return e&&t?parseInt(e,10)===e||"string"==typeof e?e===t:e.url===t.url:null!==e==(null!==t)}update(e,t,n){const a=e.data||{},i=e._handlerState.assets,s=e._resources;let r,o,l;const c=[null,null,null,null,null,null,null],h=function(){return a.hasOwnProperty("type")?a.type:a.hasOwnProperty("rgbm")?a.rgbm?"rgbm":"default":null};if(e.loaded&&n[0]===i[0])c[1]=s[1]||null,c[2]=s[2]||null,c[3]=s[3]||null,c[4]=s[4]||null,c[5]=s[5]||null,c[6]=s[6]||null;else if(n[0])for(r=n[0].resource,l=0;l<6;++l)c[l+1]=new Gm(this._device,{name:e.name+"_prelitCubemap"+(r.width>>l),cubemap:!0,type:h()||r.type,width:r.width>>l,height:r.height>>l,format:r.format,levels:[r._levels[l]],fixCubemapSeams:!0,addressU:1,addressV:1,mipmaps:0===l});const d=n.slice(1);if(e.loaded&&this.cmpArrays(d,i.slice(1)))c[0]=s[0]||null;else if(-1===d.indexOf(null)){const t=d.map((function(e){return e.resource})),i=[];for(o=0;o<t[0]._levels.length;++o)i.push(t.map((function(e){return e._levels[o]})));const s=t[0].format,r=new Gm(this._device,{name:e.name+"_faces",cubemap:!0,type:h()||t[0].type,width:t[0].width,height:t[0].height,format:6===s?7:s,levels:i,minFilter:a.hasOwnProperty("minFilter")?a.minFilter:t[0].minFilter,magFilter:a.hasOwnProperty("magFilter")?a.magFilter:t[0].magFilter,anisotropy:a.hasOwnProperty("anisotropy")?a.anisotropy:1,addressU:1,addressV:1,fixCubemapSeams:!!n[0]});c[0]=r}if(!this.cmpArrays(c,s))for(e.resources=c,e._handlerState.assetIds=t,e._handlerState.assets=n,l=0;l<s.length;++l)null!==s[l]&&-1===c.indexOf(s[l])&&s[l].destroy();for(l=0;l<i.length;++l)null!==i[l]&&-1===n.indexOf(i[l])&&i[l].unload()}cmpArrays(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}resolveId(e){const t=parseInt(e,10);return t===e||t.toString()===e?t:e}loadAssets(e,t){e.hasOwnProperty("_handlerState")||(e._handlerState={assetIds:[null,null,null,null,null,null,null],assets:[null,null,null,null,null,null,null]});const n=this,a=n.getAssetIds(e),i=[null,null,null,null,null,null,null],s=e._handlerState.assetIds,r=e._handlerState.assets,o=n._registry;let l=7;const c=function(s,r){i[s]=r,l--,0===l&&(n.update(e,a,i),t(null,e.resources))},h=function(e,n,a){t(n)},d=function(e,t){t.loaded?c(e,t):(o.once("load:"+t.id,c.bind(n,e)),o.once("error:"+t.id,h.bind(n,e)),t.loading||o.load(t))};let p;for(let t=0;t<7;++t){const i=this.resolveId(a[t]);if(i)if(n.compareAssetIds(i,s[t]))c(t,r[t]);else if(parseInt(i,10)===i)p=o.get(i),p?d(t,p):setTimeout(function(e,t){const n=o.get(t);n?d(e,n):h(0,"failed to find dependent cubemap asset="+t)}.bind(null,t,i));else{const a="string"==typeof i?{url:i,filename:i}:i;p=new f_(e.name+"_part_"+t,"texture",a),o.add(p),o.once("load:"+p.id,c.bind(n,t)),o.once("error:"+p.id,h.bind(n,t)),o.load(p)}else c(t,null)}}}class pw{load(e,t){t(null,null)}open(e,t){return t}}class uw{constructor(e,t){this.type=t&&t.type||"msdf",this.em=1,this.textures=e,this.intensity=0,this._data=null,this.data=t}set data(e){if(this._data=e,e&&(void 0!==this._data.intensity&&(this.intensity=this._data.intensity),this._data.info||(this._data.info={}),(!this._data.version||this._data.version<2)&&(this._data.info.maps=[{width:this._data.info.width,height:this._data.info.height}],this._data.chars)))for(const e in this._data.chars)this._data.chars[e].map=0}get data(){return this._data}}function mw(e){return e.version<3&&(e.version<2&&(e.info.maps=e.info.maps||[{width:e.info.width,height:e.info.height}]),e.chars=Object.keys(e.chars||{}).reduce((function(t,n){const a=e.chars[n],i=void 0!==a.letter?a.letter:yu.fromCodePoint(n);return e.version<2&&(a.map=a.map||0),t[i]=a,t}),{}),e.version=3),e}class fw{constructor(e){this._loader=e,this.maxRetries=0}load(e,t,n){"string"==typeof e&&(e={load:e,original:e});const a=this;".json"===tu.getExtension(e.original)?Au.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(function(n,i){if(n)t(`Error loading font resource: ${e.original} [${n}]`);else{const n=mw(i);a._loadTextures(e.load.replace(".json",".png"),n,(function(e,a){if(e)return t(e);t(null,{data:n,textures:a})}))}})):(n&&n.data&&(n.data=mw(n.data)),this._loadTextures(e.load,n&&n.data,t))}_loadTextures(e,t,n){const a=t.info.maps.length;let i=0,s=null;const r=new Array(a),o=this._loader,l=function(t){const l=function(e,o){if(!s){if(e)return s=e,n(e);o.upload(),r[t]=o,i++,i===a&&n(null,r)}};0===t?o.load(e,"texture",l):o.load(e.replace(".png",t+".png"),"texture",l)};for(let e=0;e<a;e++)l(e)}open(e,t,n){let a;return a=t.textures?new uw(t.textures,t.data):new uw(t,null),a}patch(e,t){const n=e.resource;!n.data&&e.data?n.data=e.data:!e.data&&n.data&&(e.data=n.data),e.data&&(e.data=mw(e.data))}}const gw=function(e,t,n){const a=n.singleVecs;let i,s;const r=t.___1;r||(i=n.tripleVecs,s=t.___2);let o=r?r[0]:i[s];e.setLocalPosition(a[o],a[o+1],a[o+2]),o=r?r[1]:i[s+1],e.setLocalEulerAngles(a[o],a[o+1],a[o+2]),o=r?r[2]:i[s+2],e.setLocalScale(a[o],a[o+1],a[o+2])},yw=function(e,t){const n=e.charCodeAt(0)-t.fieldFirstCode;return t.fieldArray[n]},bw=function(e,t){let n=0;for(let a=0;a<e.length;a++)n=n*t.fieldCodeBase+e.charCodeAt(a)-t.fieldFirstCode;return t.fieldArray[n]};class vw{constructor(e,t){this._node=e,this._data=t}run(){const e=Object.prototype.toString.call(this._node);return"[object Object]"===e?this._handleMap():"[object Array]"===e?this._handleArray():this._result=this._node,this._result}_handleMap(){this._result={};Object.keys(this._node).forEach(this._handleKey,this)}_handleKey(e){let t=e;const n=e.length;1===n?t=yw(e,this._data):2===n&&(t=bw(e,this._data)),this._result[t]=new vw(this._node[e],this._data).run()}_handleArray(){this._result=[],this._node.forEach(this._handleArElt,this)}_handleArElt(e){const t=new vw(e,this._data).run();this._result.push(t)}}class _w{constructor(e,t){this._app=e,this._isTemplate=t}parse(e){const t={};let n=null;const a=e.compressedFormat;a&&!e.entDecompressed&&(e.entDecompressed=!0,e.entities=new vw(e.entities,a).run());for(const i in e.entities){const s=e.entities[i],r=this._createEntity(s,a);t[i]=r,null===s.parent&&(n=r)}for(const n in e.entities){const a=t[n],i=e.entities[n].children,s=i.length;for(let e=0;e<s;e++){const n=t[i[e]];n&&a.addChild(n)}}return this._openComponentData(n,e.entities),n}_createEntity(e,t){const n=new KM(e.name,this._app);if(n.setGuid(e.resource_id),this._setPosRotScale(n,e,t),n._enabled=void 0===e.enabled||e.enabled,this._isTemplate?n._template=!0:n._enabledInHierarchy=n._enabled,n.template=e.template,e.tags)for(let t=0;t<e.tags.length;t++)n.tags.add(e.tags[t]);return e.labels&&e.labels.forEach((function(e){n.addLabel(e)})),n}_setPosRotScale(e,t,n){if(n)gw(e,t,n);else{const n=t.position,a=t.rotation,i=t.scale;e.setLocalPosition(n[0],n[1],n[2]),e.setLocalEulerAngles(a[0],a[1],a[2]),e.setLocalScale(i[0],i[1],i[2])}}_openComponentData(e,t){const n=this._app.systems.list;let a=n.length;const i=t[e.getGuid()];for(let t=0;t<a;t++){const a=n[t],s=i.components[a.id];s&&a.addComponent(e,s)}a=i.children.length;const s=e._children;for(let e=0;e<a;e++)s[e]=this._openComponentData(s[e],t);return e}}const ww=function(e,t,n){"string"==typeof e&&(e={load:e,original:e}),Au.get(e.load,{retry:t>0,maxRetries:t},(function(t,a){if(t){let a="Error while loading scene JSON "+e.original;t.message?(a+=": "+t.message,t.stack&&(a+="\n"+t.stack)):a+=": "+t,n(a)}else n(t,a)}))};class xw{constructor(e){this._app=e,this.maxRetries=0}load(e,t){ww(e,this.maxRetries,t)}open(e,t){this._app.systems.script.preloading=!0;const n=new _w(this._app,!1).parse(t);return this._app.systems.script.preloading=!1,n}}class Cw{constructor(){this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e}),Au.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(function(n,a){n?t(`Error loading html resource: ${e.original} [${n}]`):t(null,a)}))}open(e,t){return t}patch(e,t){}}class Tw{constructor(){this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e});const n={retry:this.maxRetries>0,maxRetries:this.maxRetries};e.load.startsWith("blob:")&&(n.responseType=Su.ResponseType.JSON),Au.get(e.load,n,(function(n,a){n?t(`Error loading JSON resource: ${e.original} [${n}]`):t(null,a)}))}open(e,t){return t}patch(e,t){}}class Ew{constructor(e,t,n,a,i){this.propertyName=e,this.parent=t,this._scope=i,this._registry=n,this.id=null,this.url=null,this.asset=null,this._onAssetLoad=a.load,this._onAssetAdd=a.add,this._onAssetRemove=a.remove,this._onAssetUnload=a.unload}set id(e){if(this.url)throw Error("Can't set id and url");this._unbind(),this._id=e,this.asset=this._registry.get(this._id),this._bind()}get id(){return this._id}set url(e){if(this.id)throw Error("Can't set id and url");this._unbind(),this._url=e,this.asset=this._registry.getByUrl(this._url),this._bind()}get url(){return this._url}_bind(){this.id&&(this._onAssetLoad&&this._registry.on("load:"+this.id,this._onLoad,this),this._onAssetAdd&&this._registry.once("add:"+this.id,this._onAdd,this),this._onAssetRemove&&this._registry.on("remove:"+this.id,this._onRemove,this),this._onAssetUnload&&this._registry.on("unload:"+this.id,this._onUnload,this)),this.url&&(this._onAssetLoad&&this._registry.on("load:url:"+this.url,this._onLoad,this),this._onAssetAdd&&this._registry.once("add:url:"+this.url,this._onAdd,this),this._onAssetRemove&&this._registry.on("remove:url:"+this.url,this._onRemove,this))}_unbind(){this.id&&(this._onAssetLoad&&this._registry.off("load:"+this.id,this._onLoad,this),this._onAssetAdd&&this._registry.off("add:"+this.id,this._onAdd,this),this._onAssetRemove&&this._registry.off("remove:"+this.id,this._onRemove,this),this._onAssetUnload&&this._registry.off("unload:"+this.id,this._onUnload,this)),this.url&&(this._onAssetLoad&&this._registry.off("load:"+this.url,this._onLoad,this),this._onAssetAdd&&this._registry.off("add:"+this.url,this._onAdd,this),this._onAssetRemove&&this._registry.off("remove:"+this.url,this._onRemove,this))}_onLoad(e){this._onAssetLoad.call(this._scope,this.propertyName,this.parent,e)}_onAdd(e){this.asset=e,this._onAssetAdd.call(this._scope,this.propertyName,this.parent,e)}_onRemove(e){this._onAssetRemove.call(this._scope,this.propertyName,this.parent,e),this.asset=null}_onUnload(e){this._onAssetUnload.call(this._scope,this.propertyName,this.parent,e)}}function Sw(){return Sw=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},Sw.apply(this,arguments)}class Aw{constructor(){this.removeInvalid=!0,this.valid=!0,this.enumValidators={occludeSpecular:this._createEnumValidator([0,1,2]),cull:this._createEnumValidator([0,1,2,3]),blendType:this._createEnumValidator([0,1,2,3,4,5,6,7,8,9,10]),depthFunc:this._createEnumValidator([0,1,2,3,4,5,6,7]),shadingModel:this._createEnumValidator([0,1])}}setInvalid(e,t){this.valid=!1,this.removeInvalid&&delete t[e]}validate(e){const t=ag,n="path"===e.mappingFormat;for(const a in e){const i=t[a];if(i)if(i.startsWith("enum")){const t=i.split(":")[1];this.enumValidators[t]&&(this.enumValidators[t](e[a])||this.setInvalid(a,e))}else if("number"===i)"number"!=typeof e[a]&&this.setInvalid(a,e);else if("boolean"===i)"boolean"!=typeof e[a]&&this.setInvalid(a,e);else if("string"===i)"string"!=typeof e[a]&&this.setInvalid(a,e);else if("vec2"===i)e[a]instanceof Array&&2===e[a].length||this.setInvalid(a,e);else if("rgb"===i)e[a]instanceof Array&&3===e[a].length||this.setInvalid(a,e);else if("texture"===i)n?"string"!=typeof e[a]&&null!==e[a]&&(e[a]instanceof Gm||this.setInvalid(a,e)):"number"!=typeof e[a]&&null!==e[a]&&(e[a]instanceof Gm||this.setInvalid(a,e));else if("boundingbox"===i)e[a].center&&e[a].center instanceof Array&&3===e[a].center.length||this.setInvalid(a,e),e[a].halfExtents&&e[a].halfExtents instanceof Array&&3===e[a].halfExtents.length||this.setInvalid(a,e);else if("cubemap"===i)"number"!=typeof e[a]&&null!==e[a]&&void 0!==e[a]&&(e[a]instanceof Gm&&e[a].cubemap||this.setInvalid(a,e));else if("chunks"===i){const t=Object.keys(e[a]);for(let n=0;n<t.length;n++)"string"!=typeof e[a][t[n]]&&this.setInvalid(t[n],e[a])}else console.error("Unknown material type: "+i);else this.valid=!1}return e.validated=!0,this.valid}_createEnumValidator(e){return function(t){return e.indexOf(t)>=0}}}class Mw{constructor(){this._validator=null}parse(e){const t=this.migrate(e),n=this._validate(t),a=new cg;return this.initialize(a,n),a}initialize(e,t){t.validated||(t=this._validate(t)),t.chunks&&(e.chunks=Sw({},t.chunks));for(const n in t){const a=ag[n],i=t[n];if("vec2"===a)e[n]=new Du(i[0],i[1]);else if("rgb"===a)e[n]=new Mu(i[0],i[1],i[2]);else if("texture"===a)i instanceof Gm?e[n]=i:e[n]instanceof Gm&&"number"==typeof i&&i>0||(e[n]=null);else if("cubemap"===a)i instanceof Gm?e[n]=i:e[n]instanceof Gm&&"number"==typeof i&&i>0||(e[n]=null),"cubeMap"!==n||i||(e.prefilteredCubemaps=null);else if("boundingbox"===a){const t=new Pu(i.center[0],i.center[1],i.center[2]),a=new Pu(i.halfExtents[0],i.halfExtents[1],i.halfExtents[2]);e[n]=new qu(t,a)}else e[n]=t[n]}e.update()}migrate(e){let t;void 0===e.shadingModel&&("blinn"===e.shader?e.shadingModel=1:e.shadingModel=0),e.shader&&delete e.shader,e.mapping_format&&(e.mappingFormat=e.mapping_format,delete e.mapping_format);const n=[["bumpMapFactor","bumpiness"],["aoUvSet","aoMapUv"],["aoMapVertexColor","aoVertexColor"],["diffuseMapVertexColor","diffuseVertexColor"],["emissiveMapVertexColor","emissiveVertexColor"],["specularMapVertexColor","specularVertexColor"],["metalnessMapVertexColor","metalnessVertexColor"],["opacityMapVertexColor","opacityVertexColor"],["glossMapVertexColor","glossVertexColor"],["lightMapVertexColor","lightVertexColor"],["diffuseMapTint","diffuseTint"],["specularMapTint","specularTint"],["emissiveMapTint","emissiveTint"],["metalnessMapTint","metalnessTint"]];for(t=0;t<n.length;t++){const a=n[t][0],i=n[t][1];void 0!==e[a]&&void 0===e[i]&&(e[i]=e[a],delete e[a])}const a=["fresnelFactor","shadowSampleType"];for(t=0;t<a.length;t++){const n=a[t];e.hasOwnProperty(n)&&delete e[n]}return e}_validate(e){return e.validated||(this._validator||(this._validator=new Aw),this._validator.validate(e)),e}}const Lw={aoMap:"white",diffuseMap:"gray",specularMap:"gray",metalnessMap:"black",glossMap:"gray",emissiveMap:"gray",normalMap:"normal",heightMap:"gray",opacityMap:"gray",sphereMap:"gray",lightMap:"white"};class Rw{constructor(e){this._assets=e.assets,this._device=e.graphicsDevice,this._placeholderTextures=null,this._parser=new Mw,this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e}),Au.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(function(n,a){n?t&&t(`Error loading material: ${e.original} [${n}]`):t&&(a._engine=!0,t(null,a))}))}open(e,t){const n=this._parser.parse(t);return t._engine&&(n._data=t,delete t._engine),n}_createPlaceholders(){this._placeholderTextures={};const e={white:[255,255,255,255],gray:[128,128,128,255],black:[0,0,0,255],normal:[128,128,255,255]};for(const t in e){if(!e.hasOwnProperty(t))continue;this._placeholderTextures[t]=new Gm(this._device,{width:2,height:2,format:7}),this._placeholderTextures[t].name="placeholder";const n=this._placeholderTextures[t].lock();for(let a=0;a<4;a++)for(let i=0;i<4;i++)n[4*a+i]=e[t][i];this._placeholderTextures[t].unlock()}}patch(e,t){e.resource._data&&(e._data=e.resource._data,delete e.resource._data),e.data.name=e.name,e.resource.name=e.name,this._bindAndAssignAssets(e,t),e.off("unload",this._onAssetUnload,this),e.on("unload",this._onAssetUnload,this)}_onAssetUnload(e){delete e.data.parameters,delete e.data.chunks,delete e.data.name}_assignTexture(e,t,n){t.resource[e]=n}_getPlaceholderTexture(e){this._placeholderTextures||this._createPlaceholders();const t=Lw[e];return this._placeholderTextures[t]}_assignPlaceholderTexture(e,t){t.resource[e]=this._getPlaceholderTexture(e)}_onTextureLoad(e,t,n){this._assignTexture(e,t,n.resource),t.resource.update()}_onTextureAdd(e,t,n){this._assets.load(n)}_onTextureRemoveOrUnload(e,t,n){const a=t.resource;a&&t.resource[e]===n.resource&&(this._assignPlaceholderTexture(e,t),a.update())}_assignCubemap(e,t,n){t.resource[e]=n[0],"cubeMap"===e&&(t.resource.prefilteredCubemaps=n.slice(1))}_onCubemapLoad(e,t,n){this._assignCubemap(e,t,n.resources),this._parser.initialize(t.resource,t.data)}_onCubemapAdd(e,t,n){0===t.data.shadingModel&&(t.loadFaces=!0),this._assets.load(n)}_onCubemapRemoveOrUnload(e,t,n){const a=t.resource;t.data.prefilteredCubeMap128===n.resources[1]&&(this._assignCubemap(e,t,[null,null,null,null,null,null,null]),a.update())}_bindAndAssignAssets(e,t){const n=this._parser.migrate(e.data),a=e.resource,i="path"===n.mappingFormat,s=ig;let r,o,l;for(r=0;r<s.length;r++){o=s[r],l=a._assetReferences[o];const c=n[o],h=a[o],d=h===this._getPlaceholderTexture(o),p=n.validated;!c||h&&p&&!d?l&&(i?l.url=null:l.id=null):(l||(l=new Ew(o,e,t,{load:this._onTextureLoad,add:this._onTextureAdd,remove:this._onTextureRemoveOrUnload,unload:this._onTextureRemoveOrUnload},this),a._assetReferences[o]=l),i?l.url=e.getAbsoluteUrl(c):l.id=c,l.asset&&(l.asset.resource?this._assignTexture(o,e,l.asset.resource):this._assignPlaceholderTexture(o,e),t.load(l.asset)))}const c=sg;for(r=0;r<c.length;r++)o=c[r],l=a._assetReferences[o],n[o]&&!e.data.prefilteredCubeMap128&&(l||(l=new Ew(o,e,t,{load:this._onCubemapLoad,add:this._onCubemapAdd,remove:this._onCubemapRemoveOrUnload,unload:this._onCubemapRemoveOrUnload},this),a._assetReferences[o]=l),i?l.url=n[o]:l.id=n[o],l.asset&&(l.asset.loaded&&this._assignCubemap(o,e,l.asset.resources),t.load(l.asset)));this._parser.initialize(a,n)}}class Iw{constructor(e,t){this._device=e,this._defaultMaterial=t}parse(e){const t=Y_.parse("filename.glb",e,this._device);if(t){const e=b_.createModel(t,this._defaultMaterial);return t.destroy(),e}return null}}class Pw{constructor(){this.index=0,this.boneIndices=[0,0,0,0]}}class kw{constructor(){this.partition=0,this.vertexStart=0,this.vertexCount=0,this.indexStart=0,this.indexCount=0,this.boneIndices=[],this.vertices=[],this.indices=[],this.indexMap={},this.originalMesh=null}addVertex(e,t,n){let a=-1;if(void 0!==this.indexMap[t])a=this.indexMap[t],this.indices.push(a);else{for(let a=0;a<4;a++){if(0===n.blendWeight.data[4*t+a])continue;const i=n.blendIndices.data[4*e.index+a];e.boneIndices[a]=this.getBoneRemap(i)}a=this.vertices.length,this.indices.push(a),this.vertices.push(e),this.indexMap[t]=a}}addPrimitive(e,t,n,a){const i=[];let s=0;const r=e.length;for(let t=0;t<r;t++){const a=e[t].index;for(let e=0;e<4;e++)if(n.blendWeight.data[4*a+e]>0){const t=n.blendIndices.data[4*a+e];let r=!0;for(let e=0;e<s;e++)if(i[e]===t){r=!1;break}if(r){i[s]=t;s+=-1===this.getBoneRemap(t)?1:0}}}if(this.boneIndices.length+s>a)return!1;for(let e=0;e<s;e++)this.boneIndices.push(i[e]);for(let a=0;a<r;a++)this.addVertex(e[a],t[a],n);return!0}getBoneRemap(e){for(let t=0;t<this.boneIndices.length;t++)if(this.boneIndices[t]===e)return t;return-1}}const Dw={points:0,lines:1,lineloop:2,linestrip:3,triangles:4,trianglestrip:5,trianglefan:6},Ow={int8:0,uint8:1,int16:2,uint16:3,int32:4,uint32:5,float32:6};class Fw{constructor(e,t){this._device=e,this._defaultMaterial=t}parse(e){const t=e.model;if(!t)return null;if(t.version<=1)return null;const n=this._parseNodes(e),a=this._parseSkins(e,n),i=this._parseVertexBuffers(e),s=this._parseIndexBuffers(e,i),r=this._parseMorphs(e,n,i),o=this._parseMeshes(e,a.skins,r.morphs,i,s.buffer,s.data),l=this._parseMeshInstances(e,n,o,a.skins,a.instances,r.morphs,r.instances),c=new Dv;return c.graph=n[0],c.meshInstances=l,c.skinInstances=a.instances,c.morphInstances=r.instances,c.getGraph().syncHierarchy(),c}_parseNodes(e){const t=e.model,n=[];let a;for(a=0;a<t.nodes.length;a++){const e=t.nodes[a],i=new hf(e.name);i.setLocalPosition(e.position[0],e.position[1],e.position[2]),i.setLocalEulerAngles(e.rotation[0],e.rotation[1],e.rotation[2]),i.setLocalScale(e.scale[0],e.scale[1],e.scale[2]),i.scaleCompensation=!!e.scaleCompensation,n.push(i)}for(a=1;a<t.parents.length;a++)n[t.parents[a]].addChild(n[a]);return n}_parseSkins(e,t){const n=e.model,a=[],i=[];let s,r;if(!this._device.supportsBoneTextures&&n.skins.length>0){!function(e,t,n){let a,i,s,r;!function(e){const t=e.vertices,n=e.skins,a=e.meshes,i=e.meshInstances;for(let e=0;e<a.length;e++)a[e].vertices=t[a[e].vertices],void 0!==a[e].skin&&(a[e].skin=n[a[e].skin]);for(let e=0;e<i.length;e++)i[e].mesh=a[i[e].mesh]}(e);const o=e.vertices,l=e.skins;let c;const h=e.meshes,d=e.meshInstances,p=function(e){const t=new Pw;return t.index=e,t};for(a=l.length-1;a>=0;a--)if(l[a].boneNames.length>n){const e=l.splice(a,1)[0],u=[];for(i=0;i<h.length;i++)h[i].skin===e&&u.push(h[i]);for(i=0;i<u.length;i++)r=h.indexOf(u[i]),-1!==r&&h.splice(r,1);if(0===u.length)throw new Error("partitionSkin: There should be at least one mesh that references a skin");const m=u[0].vertices;for(i=1;i<u.length;i++)if(u[i].vertices!==m)throw new Error("partitionSkin: All meshes that share a skin should also share the same vertex buffer");let f;const g=[],y=[],b=[];let v=0;for(i=0;i<u.length;i++){c=u[i];const e=c.indices;for(let t=c.base;t<c.base+c.count;){r=e[t++],y[0]=p(r),b[0]=r,r=e[t++],y[1]=p(r),b[1]=r,r=e[t++],y[2]=p(r),b[2]=r;let a=!1;for(let e=v;e<g.length;e++)if(f=g[e],f.addPrimitive(y,b,m,n)){a=!0;break}a||(f=new kw,f.originalMesh=c,f.addPrimitive(y,b,m,n),g.push(f))}v=g.length}const _=[],w=[];for(i=0;i<g.length;i++)if(f=g[i],f.vertices.length&&f.indices.length){const e=_.length,t=f.vertices.length,n=w.length,a=f.indices.length;let s,r;for(f.partition=i,f.vertexStart=e,f.vertexCount=t,f.indexStart=n,f.indexCount=a,s=0,r=e;s<t;)_[r++]=f.vertices[s++];for(s=0,r=n;s<a;)w[r++]=f.indices[s++]+e}const x=[];for(i=0;i<g.length;i++){f=g[i];const t=[],n=[];for(s=0;s<f.boneIndices.length;s++)t.push(e.inverseBindMatrices[f.boneIndices[s]]),n.push(e.boneNames[f.boneIndices[s]]);const a={inverseBindMatrices:t,boneNames:n};x.push(a),l.push(a)}let C,T,E,S;const A={};for(T in m)A[T]={components:m[T].components,data:[],type:m[T].type};for(T in m)if("blendIndices"===T){const e=A[T].data;for(i=0;i<_.length;i++){const t=_[i].boneIndices;e.push(t[0],t[1],t[2],t[3])}}else for(C=m[T],E=C.data,S=C.components,i=0;i<_.length;i++)for(r=_[i].index,s=0;s<S;s++)A[T].data.push(E[r*S+s]);for(o[o.indexOf(m)]=A,i=0;i<g.length;i++)for(f=g[i],c={aabb:{min:[0,0,0],max:[0,0,0]},vertices:A,skin:x[i],indices:w.splice(0,f.indexCount),type:"triangles",base:0,count:f.indexCount},h.push(c),s=d.length-1;s>=0;s--)d[s].mesh===f.originalMesh&&(d.push({mesh:c,node:d[s].node}),t&&t.push({material:t[s].material,path:t[s].path}));for(i=0;i<g.length;i++)for(f=g[i],s=d.length-1;s>=0;s--)d[s].mesh===f.originalMesh&&(d.splice(s,1),t&&t.splice(s,1))}!function(e){const t=e.vertices,n=e.skins,a=e.meshes,i=e.meshInstances;for(let e=0;e<a.length;e++)a[e].vertices=t.indexOf(a[e].vertices),void 0!==a[e].skin&&(a[e].skin=n.indexOf(a[e].skin));for(let e=0;e<i.length;e++)i[e].mesh=a.indexOf(i[e].mesh)}(e)}(n,null,this._device.getBoneLimit())}for(s=0;s<n.skins.length;s++){const e=n.skins[s],o=[];for(r=0;r<e.inverseBindMatrices.length;r++){const t=e.inverseBindMatrices[r];o[r]=(new zu).set(t)}const l=new $v(this._device,o,e.boneNames);a.push(l);const c=new by(l),h=[];for(r=0;r<l.boneNames.length;r++){const e=l.boneNames[r],n=t[0].findByName(e);h.push(n)}c.bones=h,i.push(c)}return{skins:a,instances:i}}_getMorphVertexCount(e,t,n){for(let a=0;a<e.meshes.length;a++){const i=e.meshes[a];if(i.morph===t){return n[i.vertices].numVertices}}}_parseMorphs(e,t,n){const a=e.model,i=[],s=[];let r,o,l,c,h,d;if(a.morphs){const e=function(e,t,n){const a=new Float32Array(3*n);for(let n=0;n<t.length;n++){const i=3*t[n];a[i]=e[3*n],a[i+1]=e[3*n+1],a[i+2]=e[3*n+2]}return a};for(r=0;r<a.morphs.length;r++){for(c=a.morphs[r].targets,d=[],l=this._getMorphVertexCount(a,r,n),o=0;o<c.length;o++){const t=c[o].aabb,n=t.min,a=t.max,i=new qu(new Pu(.5*(a[0]+n[0]),.5*(a[1]+n[1]),.5*(a[2]+n[2])),new Pu(.5*(a[0]-n[0]),.5*(a[1]-n[1]),.5*(a[2]-n[2]))),s=c[o].indices;let r=c[o].deltaPositions,p=c[o].deltaNormals;s&&(r=e(r,s,l),p=e(p,s,l)),h=new Zv({deltaPositions:r,deltaNormals:p,name:c[o].name,aabb:i}),d.push(h)}const t=new Pv(d,this._device);i.push(t);const p=new kv(t);s.push(p)}}return{morphs:i,instances:s}}_parseVertexBuffers(e){const t=e.model,n=[],a={position:"POSITION",normal:"NORMAL",tangent:"TANGENT",blendWeight:"BLENDWEIGHT",blendIndices:"BLENDINDICES",color:"COLOR",texCoord0:"TEXCOORD0",texCoord1:"TEXCOORD1",texCoord2:"TEXCOORD2",texCoord3:"TEXCOORD3",texCoord4:"TEXCOORD4",texCoord5:"TEXCOORD5",texCoord6:"TEXCOORD6",texCoord7:"TEXCOORD7"};for(let e=0;e<t.vertices.length;e++){const i=t.vertices[e],s=[];for(const e in i){const t=i[e];s.push({semantic:a[e],components:t.components,type:Ow[t.type],normalize:"COLOR"===a[e]})}const r=new hm(this._device,s),o=i.position.data.length/i.position.components,l=new lm(this._device,r,o),c=new Vg(l);for(let e=0;e<o;e++){for(const t in i){const n=i[t];switch(n.components){case 1:c.element[a[t]].set(n.data[e]);break;case 2:c.element[a[t]].set(n.data[2*e],1-n.data[2*e+1]);break;case 3:c.element[a[t]].set(n.data[3*e],n.data[3*e+1],n.data[3*e+2]);break;case 4:c.element[a[t]].set(n.data[4*e],n.data[4*e+1],n.data[4*e+2],n.data[4*e+3])}}c.next()}c.end(),n.push(l)}return n}_parseIndexBuffers(e,t){const n=e.model;let a,i=null,s=null,r=0;for(a=0;a<n.meshes.length;a++){const e=n.meshes[a];void 0!==e.indices&&(r+=e.indices.length)}let o=0;for(a=0;a<t.length;a++)o=Math.max(o,t[a].numVertices);return r>0&&(o>65535&&this._device.extUintElement?(i=new Tg(this._device,2,r),s=new Uint32Array(i.lock())):(i=new Tg(this._device,1,r),s=new Uint16Array(i.lock()))),{buffer:i,data:s}}_parseMeshes(e,t,n,a,i,s){const r=e.model,o=[];let l=0;for(let e=0;e<r.meshes.length;e++){const c=r.meshes[e],h=c.aabb,d=h.min,p=h.max,u=new qu(new Pu(.5*(p[0]+d[0]),.5*(p[1]+d[1]),.5*(p[2]+d[2])),new Pu(.5*(p[0]-d[0]),.5*(p[1]-d[1]),.5*(p[2]-d[2]))),m=void 0!==c.indices,f=new iy(this._device);f.vertexBuffer=a[c.vertices],f.indexBuffer[0]=m?i:null,f.primitive[0].type=Dw[c.type],f.primitive[0].base=m?c.base+l:c.base,f.primitive[0].count=c.count,f.primitive[0].indexed=m,f.skin=void 0!==c.skin?t[c.skin]:null,f.morph=void 0!==c.morph?n[c.morph]:null,f.aabb=u,m&&(s.set(c.indices,l),l+=c.indices.length),o.push(f)}return null!==i&&i.unlock(),o}_parseMeshInstances(e,t,n,a,i,s,r){const o=e.model,l=[];let c;for(c=0;c<o.meshInstances.length;c++){const e=o.meshInstances[c],h=t[e.node],d=n[e.mesh],p=new Ay(d,this._defaultMaterial,h);if(d.skin){const e=a.indexOf(d.skin);p.skinInstance=i[e]}if(d.morph){const e=s.indexOf(d.morph);p.morphInstance=r[e]}l.push(p)}return l}}class Nw{constructor(e){this._device=e,this._parsers=[],this._defaultMaterial=$f(e),this.maxRetries=0,this.addParser(new Fw(this._device,this._defaultMaterial),(function(e,t){return".json"===tu.getExtension(e)})),this.addParser(new Iw(this._device,this._defaultMaterial),(function(e,t){return".glb"===tu.getExtension(e)}))}load(e,t){"string"==typeof e&&(e={load:e,original:e});const n={retry:this.maxRetries>0,maxRetries:this.maxRetries};(e.load.startsWith("blob:")||e.load.startsWith("data:"))&&(".glb"===tu.getExtension(e.original).toLowerCase()?n.responseType=Su.ResponseType.ARRAY_BUFFER:n.responseType=Su.ResponseType.JSON),Au.get(e.load,n,(function(n,a){t&&(n?t(`Error loading model: ${e.original} [${n}]`):t(null,a))}))}open(e,t){for(let n=0;n<this._parsers.length;n++){const a=this._parsers[n];if(a.decider(e,t))return a.parser.parse(t)}return null}patch(e,t){if(!e.resource)return;const n=e.data,a=this;e.resource.meshInstances.forEach((function(i,s){if(n.mapping){const r=function e(n){n.resource?i.material=n.resource:(n.once("load",e),t.load(n)),n.once("remove",(function(e){i.material===e.resource&&(i.material=a._defaultMaterial)}))};if(!n.mapping[s])return void(i.material=a._defaultMaterial);const o=n.mapping[s].material,l=n.mapping[s].path;let c;if(void 0!==o)o?(c=t.get(o),c?r(c):t.once("add:"+o,r)):i.material=a._defaultMaterial;else if(l){const a=e.getAbsoluteUrl(n.mapping[s].path);c=t.getByUrl(a),c?r(c):t.once("add:url:"+a,r)}}}))}addParser(e,t){this._parsers.push({parser:e,decider:t})}}function Vw(e){const t=this;if(!t.resource)return;const n=e.resource,a=n.renders&&n.renders[t.data.renderIndex];a&&(t.resource.meshes=a.resource.meshes)}function Bw(e){const t=this;t.registry.off("load:"+e.id,Vw,t),t.registry.on("load:"+e.id,Vw,t),t.registry.off("remove:"+e.id,Uw,t),t.registry.once("remove:"+e.id,Uw,t),e.resource?Vw.call(t,e):t.registry.load(e)}function Uw(e){const t=this;t.registry.off("load:"+e.id,Vw,t),t.resource&&t.resource.destroy()}class zw{constructor(e){this._registry=e}load(e,t,n){}open(e,t){return new Qv}patch(e,t){if(!e.data.containerAsset)return;const n=t.get(e.data.containerAsset);n?Bw.call(e,n):t.once("add:"+e.data.containerAsset,Bw,e)}}class Gw{constructor(e){this._handlers={},this._requests={},this._cache={},this._app=e}addHandler(e,t){this._handlers[e]=t,t._loader=this}removeHandler(e){delete this._handlers[e]}getHandler(e){return this._handlers[e]}load(e,t,n,a){const i=this._handlers[t];if(!i){return void n("No handler for asset type: "+t)}if(!e)return void this._loadNull(i,n,a);const s=e+t;if(void 0!==this._cache[s])n(null,this._cache[s]);else if(this._requests[s])this._requests[s].push(n);else{this._requests[s]=[n];const t=this,r=function(e,n){e?t._onFailure(s,e):i.load(n,(function(e,r,o){if(t._requests[s])if(e)t._onFailure(s,e);else try{t._onSuccess(s,i.open(n.original,r,a),o)}catch(e){t._onFailure(s,e)}}),a)},o=e.split("?")[0];if(this._app.enableBundles&&this._app.bundles.hasUrl(o)){if(!this._app.bundles.canLoadUrl(o))return void r(`Bundle for ${e} not loaded yet`);this._app.bundles.loadUrl(o,(function(e,t){r(e,{load:t,original:o})}))}else r(null,{load:e,original:a&&a.file.filename||e})}}_loadNull(e,t,n){e.load(null,(function(a,i,s){if(a)t(a);else try{t(null,e.open(null,i,n),s)}catch(e){t(e)}}),n)}_onSuccess(e,t,n){this._cache[e]=t;for(let a=0;a<this._requests[e].length;a++)this._requests[e][a](null,t,n);delete this._requests[e]}_onFailure(e,t){if(console.error(t),this._requests[e]){for(let n=0;n<this._requests[e].length;n++)this._requests[e][n](t);delete this._requests[e]}}open(e,t){const n=this._handlers[e];return n?n.open(null,t):(console.warn("No resource handler found for: "+e),t)}patch(e,t){const n=this._handlers[e.type];n?n.patch&&n.patch(e,t):console.warn("No resource handler found for: "+e.type)}clearCache(e,t){delete this._cache[e+t]}getFromCache(e,t){if(this._cache[e+t])return this._cache[e+t]}enableRetry(e=5){e=Math.max(0,e)||0;for(const t in this._handlers)this._handlers[t].maxRetries=e}disableRetry(){for(const e in this._handlers)this._handlers[e].maxRetries=0}destroy(){this._handlers={},this._requests={},this._cache={}}}class Hw{constructor(e){this._app=e,this.maxRetries=0}load(e,t){ww(e,this.maxRetries,t)}open(e,t){this._app.systems.script.preloading=!0;const n=new _w(this._app,!1).parse(t),a=this._app.scene;return a.root=n,this._app.applySceneSettings(t.settings),this._app.systems.script.preloading=!1,a}patch(e,t){}}let Ww=!1,jw=!1;const Xw={app:null,create:function(e,t){if(!Ww)return;const n=t(Xw.app);n._pcScriptName=e,Yw._push(n),this.fire("created",e,t)},attribute:function(e,t,n,a){},createLoadingScreen:function(e){if(jw)return;jw=!0;e(Jg())}};Object.defineProperty(Xw,"legacy",{get:function(){return Ww},set:function(e){Ww=e}}),Jp.attach(Xw);class Yw{constructor(e){this._app=e,this._scripts={},this._cache={}}static _push(e){Xw.legacy&&Yw._types.length>0?console.assert("Script Ordering Error. Contact support@playcanvas.com"):Yw._types.push(e)}load(e,t){"string"==typeof e&&(e={load:e,original:e});const n=this;Xw.app=this._app,this._loadScript(e.load,((e,a,i)=>{if(e)t(e);else if(Xw.legacy){let e=null;Yw._types.length&&(e=Yw._types.pop()),e?this._scripts[a]=e:e=null,t(null,e,i)}else{const e={};for(let t=0;t<Yw._types.length;t++)e[Yw._types[t].name]=Yw._types[t];Yw._types.length=0,t(null,e,i),delete n._loader._cache[a+"script"]}}))}open(e,t){return t}patch(e,t){}_loadScript(e,t){const n=document.head,a=document.createElement("script");this._cache[e]=a,a.async=!1,a.addEventListener("error",(function(e){t(`Script: ${e.target.src} failed to load`)}),!1);let i=!1;a.onload=a.onreadystatechange=function(){i||this.readyState&&"loaded"!==this.readyState&&"complete"!==this.readyState||(i=!0,t(null,e,a))},a.src=e,n.appendChild(a)}}Yw._types=[];class qw{constructor(){this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e}),Au.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(function(n,a){n?t(`Error loading shader resource: ${e.original} [${n}]`):t(null,a)}))}open(e,t){return t}patch(e,t){}}const Kw=[0,0,1,0,0,1,0,0,1,0,0,1],Zw=[0,1,3,2,3,1];class $w extends Qp{constructor(e,t){super(),this._device=e,this._pixelsPerUnit=t&&void 0!==t.pixelsPerUnit?t.pixelsPerUnit:1,this._renderMode=t&&void 0!==t.renderMode?t.renderMode:0,this._atlas=t&&void 0!==t.atlas?t.atlas:null,this._frameKeys=t&&void 0!==t.frameKeys?t.frameKeys:null,this._meshes=[],this._updatingProperties=!1,this._meshesDirty=!1,this._atlas&&this._frameKeys&&this._createMeshes()}set frameKeys(e){this._frameKeys=e,this._atlas&&this._frameKeys&&(this._updatingProperties?this._meshesDirty=!0:this._createMeshes()),this.fire("set:frameKeys",e)}get frameKeys(){return this._frameKeys}set atlas(e){e!==this._atlas&&(this._atlas&&(this._atlas.off("set:frames",this._onSetFrames,this),this._atlas.off("set:frame",this._onFrameChanged,this),this._atlas.off("remove:frame",this._onFrameRemoved,this)),this._atlas=e,this._atlas&&this._frameKeys&&(this._atlas.on("set:frames",this._onSetFrames,this),this._atlas.on("set:frame",this._onFrameChanged,this),this._atlas.on("remove:frame",this._onFrameRemoved,this),this._updatingProperties?this._meshesDirty=!0:this._createMeshes()),this.fire("set:atlas",e))}get atlas(){return this._atlas}set pixelsPerUnit(e){this._pixelsPerUnit!==e&&(this._pixelsPerUnit=e,this.fire("set:pixelsPerUnit",e),this._atlas&&this._frameKeys&&0===this.renderMode&&(this._updatingProperties?this._meshesDirty=!0:this._createMeshes()))}get pixelsPerUnit(){return this._pixelsPerUnit}set renderMode(e){if(this._renderMode===e)return;const t=this._renderMode;this._renderMode=e,this.fire("set:renderMode",e),0!==t&&0!==e||this._atlas&&this._frameKeys&&(this._updatingProperties?this._meshesDirty=!0:this._createMeshes())}get renderMode(){return this._renderMode}get meshes(){return this._meshes}_createMeshes(){const e=this._meshes.length;for(let t=0;t<e;t++){const e=this._meshes[t];e&&e.destroy()}const t=this._frameKeys.length;this._meshes=new Array(t);const n=1===this.renderMode||2===this._renderMode?this._create9SliceMesh:this._createSimpleMesh;for(let e=0;e<t;e++){const t=this._atlas.frames[this._frameKeys[e]];this._meshes[e]=t?n.call(this,t):null}this.fire("set:meshes")}_createSimpleMesh(e){const t=e.rect,n=this._atlas.texture.width,a=this._atlas.texture.height,i=t.z/this._pixelsPerUnit,s=t.w/this._pixelsPerUnit,r=e.pivot.x,o=e.pivot.y,l=[-r*i,-o*s,0,(1-r)*i,-o*s,0,(1-r)*i,(1-o)*s,0,-r*i,(1-o)*s,0],c=t.x/n,h=1-t.y/a,d=(t.x+t.z)/n,p=1-(t.y+t.w)/a,u=[c,h,d,h,d,p,c,p];return ly(this._device,l,{uvs:u,normals:Kw,indices:Zw})}_create9SliceMesh(){const e=Du.ONE,t=[],n=[],a=[],i=[];let s=0;for(let r=0;r<=3;r++){const o=0===r||3===r?0:1;for(let l=0;l<=3;l++){const c=-e.x+2*e.x*(r<=1?0:3)/3,h=0,d=-(-e.y+2*e.y*(l<=1?0:3)/3),p=0===l||3===l?0:1;t.push(-c,h,d),n.push(0,1,0),a.push(o,p),r<3&&l<3&&(i.push(s+3+1,s+1,s),i.push(s+3+1,s+3+2,s+1)),s++}}const r={normals:n,uvs:a,indices:i};return ly(this._device,t,r)}_onSetFrames(e){this._updatingProperties?this._meshesDirty=!0:this._createMeshes()}_onFrameChanged(e,t){const n=this._frameKeys.indexOf(e);n<0||(t?0===this.renderMode&&(this._meshes[n]=this._createSimpleMesh(t)):this._meshes[n]=null,this.fire("set:meshes"))}_onFrameRemoved(e){const t=this._frameKeys.indexOf(e);t<0||(this._meshes[t]=null,this.fire("set:meshes"))}startUpdate(){this._updatingProperties=!0,this._meshesDirty=!1}endUpdate(){this._updatingProperties=!1,this._meshesDirty&&this._atlas&&this._frameKeys&&this._createMeshes(),this._meshesDirty=!1}destroy(){for(const e of this._meshes)e&&e.destroy();this._meshes.length=0}}function Qw(e){const t=this;t.resource&&(t.resource.atlas=e.resource)}function Jw(e){this.registry.load(e)}class ex{constructor(e,t){this._assets=e,this._device=t,this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e}),".json"===tu.getExtension(e.original)&&Au.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(function(e,n){e?t(e):t(null,n)}))}open(e,t){const n=new $w(this._device);return e&&(n.__data=t),n}patch(e,t){const n=e.resource;if(n.__data&&(e.data.pixelsPerUnit=n.__data.pixelsPerUnit,e.data.renderMode=n.__data.renderMode,e.data.frameKeys=n.__data.frameKeys,n.__data.textureAtlasAsset)){const a=t.getByUrl(n.__data.textureAtlasAsset);a?e.data.textureAtlasAsset=a.id:console.warn("Could not find textureatlas with url: "+n.__data.textureAtlasAsset)}n.startUpdate(),n.renderMode=e.data.renderMode,n.pixelsPerUnit=e.data.pixelsPerUnit,n.frameKeys=e.data.frameKeys,this._updateAtlas(e),n.endUpdate(),e.off("change",this._onAssetChange,this),e.on("change",this._onAssetChange,this)}_updateAtlas(e){const t=e.resource;if(!e.data.textureAtlasAsset)return void(t.atlas=null);this._assets.off("load:"+e.data.textureAtlasAsset,Qw,e),this._assets.on("load:"+e.data.textureAtlasAsset,Qw,e);const n=this._assets.get(e.data.textureAtlasAsset);n&&n.resource?t.atlas=n.resource:n?this._assets.load(n):(this._assets.off("add:"+e.data.textureAtlasAsset,Jw,e),this._assets.on("add:"+e.data.textureAtlasAsset,Jw,e))}_onAssetChange(e,t,n,a){"data"===t&&n&&n.textureAtlasAsset&&a&&n.textureAtlasAsset!==a.textureAtlasAsset&&(this._assets.off("load:"+a.textureAtlasAsset,Qw,e),this._assets.off("add:"+a.textureAtlasAsset,Jw,e))}}class tx{constructor(e,t){this._app=e,this._data=t,this._templateRoot=null}instantiate(){return this._templateRoot||this._parseTemplate(),this._templateRoot.clone()}_parseTemplate(){const e=new _w(this._app,!0);this._templateRoot=e.parse(this._data)}}class nx{constructor(e){this._app=e,this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e});const n={retry:this.maxRetries>0,maxRetries:this.maxRetries};Au.get(e.load,n,(function(n,a){n?t("Error requesting template: "+e.original):t(n,a)}))}open(e,t){return new tx(this._app,t)}}class ax{constructor(){this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e}),Au.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(function(n,a){n?t(`Error loading text resource: ${e.original} [${n}]`):t(null,a)}))}open(e,t){return t}patch(e,t){}}class ix extends Qp{constructor(){super(),this._texture=null,this._frames=null}set texture(e){this._texture=e,this.fire("set:texture",e)}get texture(){return this._texture}set frames(e){this._frames=e,this.fire("set:frames",e)}get frames(){return this._frames}setFrame(e,t){let n=this._frames[e];n?(n.rect.copy(t.rect),n.pivot.copy(t.pivot),n.border.copy(t.border)):(n={rect:t.rect.clone(),pivot:t.pivot.clone(),border:t.border.clone()},this._frames[e]=n),this.fire("set:frame",e.toString(),n)}removeFrame(e){const t=this._frames[e];t&&(delete this._frames[e],this.fire("remove:frame",e.toString(),t))}destroy(){this._texture&&this._texture.destroy()}}const sx={repeat:0,clamp:1,mirror:2},rx={nearest:0,linear:1,nearest_mip_nearest:2,linear_mip_nearest:4,nearest_mip_linear:3,linear_mip_linear:5},ox=/^data\.frames\.(\d+)$/;class lx{constructor(e){this._loader=e,this.maxRetries=0}load(e,t){"string"==typeof e&&(e={load:e,original:e});const n=this,a=this._loader.getHandler("texture");if(".json"!==tu.getExtension(e.original))return a.load(e,t);Au.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(function(a,i){if(a)t(a);else{const a=e.original.replace(".json",".png");n._loader.load(a,"texture",(function(e,n){e?t(e):t(null,{data:i,texture:n})}))}}))}open(e,t){const n=new ix;if(t.texture&&t.data)n.texture=t.texture,n.__data=t.data;else{const a=this._loader.getHandler("texture").open(e,t);if(!a)return null;n.texture=a}return n}patch(e,t){e.resource.__data&&(void 0!==e.resource.__data.minfilter&&(e.data.minfilter=e.resource.__data.minfilter),void 0!==e.resource.__data.magfilter&&(e.data.magfilter=e.resource.__data.magfilter),void 0!==e.resource.__data.addressu&&(e.data.addressu=e.resource.__data.addressu),void 0!==e.resource.__data.addressv&&(e.data.addressv=e.resource.__data.addressv),void 0!==e.resource.__data.mipmaps&&(e.data.mipmaps=e.resource.__data.mipmaps),void 0!==e.resource.__data.anisotropy&&(e.data.anisotropy=e.resource.__data.anisotropy),void 0!==e.resource.__data.rgbm&&(e.data.rgbm=!!e.resource.__data.rgbm),e.data.frames=e.resource.__data.frames,delete e.resource.__data);const n=e.resource.texture;if(n&&(n.name=e.name,e.data.hasOwnProperty("minfilter")&&n.minFilter!==rx[e.data.minfilter]&&(n.minFilter=rx[e.data.minfilter]),e.data.hasOwnProperty("magfilter")&&n.magFilter!==rx[e.data.magfilter]&&(n.magFilter=rx[e.data.magfilter]),e.data.hasOwnProperty("addressu")&&n.addressU!==sx[e.data.addressu]&&(n.addressU=sx[e.data.addressu]),e.data.hasOwnProperty("addressv")&&n.addressV!==sx[e.data.addressv]&&(n.addressV=sx[e.data.addressv]),e.data.hasOwnProperty("mipmaps")&&n.mipmaps!==e.data.mipmaps&&(n.mipmaps=e.data.mipmaps),e.data.hasOwnProperty("anisotropy")&&n.anisotropy!==e.data.anisotropy&&(n.anisotropy=e.data.anisotropy),e.data.hasOwnProperty("rgbm"))){const t=e.data.rgbm?"rgbm":"default";n.type!==t&&(n.type=t)}e.resource.texture=n;const a={};for(const t in e.data.frames){const n=e.data.frames[t];a[t]={rect:new Ou(n.rect),pivot:new Du(n.pivot),border:new Ou(n.border)}}e.resource.frames=a,e.off("change",this._onAssetChange,this),e.on("change",this._onAssetChange,this)}_onAssetChange(e,t,n){let a;if("data"===t||"data.frames"===t){const t={};for(const e in n.frames)a=n.frames[e],t[e]={rect:new Ou(a.rect),pivot:new Du(a.pivot),border:new Ou(a.border)};e.resource.frames=t}else{const i=t.match(ox);if(i){const t=i[1];n?(e.resource.frames[t]?(a=e.resource.frames[t],a.rect.set(n.rect[0],n.rect[1],n.rect[2],n.rect[3]),a.pivot.set(n.pivot[0],n.pivot[1]),a.border.set(n.border[0],n.border[1],n.border[2],n.border[3])):e.resource.frames[t]={rect:new Ou(n.rect),pivot:new Du(n.pivot),border:new Ou(n.border)},e.resource.fire("set:frame",t,e.resource.frames[t])):e.resource.frames[t]&&(delete e.resource.frames[t],e.resource.fire("remove:frame",t))}}}}function cx(){const e=0,t=1,n=2,a=3,i=8,s=9,r=10,o=11,l=12,c=13,h=14,d=16,p={astc:r,dxt:n,etc1:e,etc2:e,pvr:i,atc:o,none:h},u={astc:r,dxt:a,etc1:d,etc2:t,pvr:s,atc:l,none:d},m=21,f=22,g=23,y=8,b=10,v=26,_=27,w=28,x=29,C=30,T=7,E=3,S=5,A=(p,u)=>{switch(p){case e:return u.formats.etc1?m:f;case t:return g;case n:return y;case a:return b;case i:return v;case s:return _;case r:return w;case o:return x;case l:return C;case c:return T;case h:return E;case d:return S}},M=e=>{const t=function(e,t){const n=e*(2/255)-1,a=t*(2/255)-1,i=Math.sqrt(1-Math.min(1,n*n+a*a));return Math.max(0,Math.min(255,Math.floor(.5*(i+1)*255)))};for(let n=0;n<e.length;n+=4){const a=e[n+3],i=e[n+1];e[n+0]=a,e[n+2]=t(a,i),e[n+3]=255}return e},L=e=>{const t=new Uint16Array(e.length/4);for(let n=0;n<e.length;n+=4){const a=e[n+0],i=e[n+1],s=e[n+2];t[n/4]=(248&a)<<8|(252&i)<<3|s>>3}return t},R=()=>"undefined"!=typeof performance?performance.now():0;let I,P,k;const D=(e,t,n)=>{if(n){if(e.formats.astc)return"astc"}else if(t){if(e.formats.etc2)return"etc2"}else if(e.formats.etc1||e.formats.etc2)return"etc1";return(t=>{for(let n=0;n<t.length;++n){const a=t[n];if(e.formats[a])return a}return"none"})(t?k:P)},O=(c,h,d,p)=>{switch(d){case e:case t:return!0;case n:case a:return 0==(3&c)&&0==(3&h);case i:case s:return((e,t)=>0==(e&e-1)&&0==(t&t-1))(c,h)&&(c===h||p);case r:case o:case l:return!0}},F=(e,t,n)=>n.isKTX2?((e,t,n)=>{if(!I.KTX2File)throw new Error("Basis transcoder module does not include support for KTX2.");const a=R(),i=new I.KTX2File(new Uint8Array(t)),s=i.getWidth(),r=i.getHeight(),o=i.getLevels(),l=!!i.getHasAlpha(),m=i.isUASTC&&i.isUASTC();if(!s||!r||!o)throw i.close(),i.delete(),new Error(`Invalid image dimensions url=${e} width=${s} height=${r} levels=${o}`);const f=D(n.deviceDetails,l,m),g=!!n.isGGGR&&"pvr"===f;let y,b;if(g?y=c:(y=l?u[f]:p[f],O(s,r,y,n.deviceDetails.webgl2)||(y=l?c:h)),!i.startTranscoding())throw i.close(),i.delete(),new Error("Failed to start transcoding url="+e);const v=[];for(let t=0;t<o;++t){const n=i.getImageTranscodedSizeInBytes(t,0,0,y),a=new Uint8Array(n);if(!i.transcodeImage(a,t,0,0,y,0,-1,-1))throw i.close(),i.delete(),new Error("Failed to transcode image url="+e);const s=y===h||y===d;v.push(s?new Uint16Array(a.buffer):a)}if(i.close(),i.delete(),g)for(y=h,b=0;b<v.length;++b)v[b]=L(M(v[b]));return{format:A(y,n.deviceDetails),width:s,height:r,levels:v,cubemap:!1,transcodeTime:R()-a,url:e,unswizzledGGGR:g}})(e,t,n):((e,t,n)=>{const a=R(),i=new I.BasisFile(new Uint8Array(t)),s=i.getImageWidth(0,0),r=i.getImageHeight(0,0),o=i.getNumImages(),l=i.getNumLevels(0),m=!!i.getHasAlpha(),f=i.isUASTC&&i.isUASTC();if(!(s&&r&&o&&l))throw i.close(),i.delete(),new Error(`Invalid image dimensions url=${e} width=${s} height=${r} images=${o} levels=${l}`);const g=D(n.deviceDetails,m,f),y=!!n.isGGGR&&"pvr"===g;let b,v;if(y?b=c:(b=m?u[g]:p[g],O(s,r,b,n.deviceDetails.webgl2)||(b=m?c:h)),!i.startTranscoding())throw i.close(),i.delete(),new Error("Failed to start transcoding url="+e);const _=[];for(let t=0;t<l;++t){const n=i.getImageTranscodedSizeInBytes(0,t,b),a=new Uint8Array(n);if(!i.transcodeImage(a,0,t,b,0,0))throw i.close(),i.delete(),new Error("Failed to transcode image url="+e);const s=b===h||b===d;_.push(s?new Uint16Array(a.buffer):a)}if(i.close(),i.delete(),y)for(b=h,v=0;v<_.length;++v)_[v]=L(M(_[v]));return{format:A(b,n.deviceDetails),width:s,height:r,levels:_,cubemap:!1,transcodeTime:R()-a,url:e,unswizzledGGGR:y}})(e,t,n),N=(e,t,n)=>{try{const a=F(e,t,n);a.levels=a.levels.map((e=>e.buffer)),self.postMessage({url:e,data:a},a.levels)}catch(t){self.postMessage({url:e,err:t},null)}},V=[];self.onmessage=e=>{const t=e.data;switch(t.type){case"init":((e,t)=>{self.importScripts(e.basisUrl),self.BASIS(e.module?{instantiateWasm:(t,n)=>(WebAssembly.instantiate(e.module,t).then((e=>{n(e)})).catch((e=>{console.error("instantiate failed + "+e)})),{})}:null).then((n=>{n.initializeBasis(),I=n,P=e.rgbPriority,k=e.rgbaPriority,t(null)}))})(t.config,(()=>{for(let e=0;e<V.length;++e)N(V[e].url,V[e].data,V[e].options);V.length=0}));break;case"transcode":I?N(t.url,t.data,t.options):V.push(t)}}}const hx=e=>({astc:!!e.extCompressedTextureASTC,atc:!!e.extCompressedTextureATC,dxt:!!e.extCompressedTextureS3TC,etc1:!!e.extCompressedTextureETC1,etc2:!!e.extCompressedTextureETC,pvr:!!e.extCompressedTexturePVRTC});class dx{constructor(e,t,n){this.queue=e,this.worker=new Worker(t.workerUrl),this.worker.addEventListener("message",(e=>{const t=e.data;this.queue.handleResponse(t.url,t.err,t.data),this.eager||this.queue.enqueueClient(this)})),this.worker.postMessage({type:"init",config:t}),this.eager=n}run(e){const t=[];e.data instanceof ArrayBuffer&&t.push(e.data),this.worker.postMessage({type:"transcode",url:e.url,format:e.format,data:e.data,options:e.options},t),this.eager&&this.queue.enqueueClient(this)}}const px=["etc1","etc2","astc","dxt","pvr","atc"],ux=["astc","dxt","etc2","pvr","atc"],mx=new class{constructor(){this.callbacks={},this.queue=[],this.clients=[]}enqueueJob(e,t,n,a){if(this.callbacks.hasOwnProperty(e))this.callbacks[e].push(n);else{this.callbacks[e]=[n];const i={url:e,data:t,options:a};this.clients.length>0?this.clients.shift().run(i):this.queue.push(i)}}enqueueClient(e){this.queue.length>0?e.run(this.queue.shift()):this.clients.push(e)}handleResponse(e,t,n){const a=this.callbacks[e];if(t)for(let e=0;e<a.length;++e)a[e](t);else{3===n.format||5===n.format?n.levels=n.levels.map((function(e){return new Uint16Array(e)})):n.levels=n.levels.map((function(e){return new Uint8Array(e)}));for(let e=0;e<a.length;++e)a[e](null,n)}delete this.callbacks[e]}};let fx=null,gx=!1;function yx(e){if(!gx){if(e){if(e.lazyInit)return void(fx=e)}else e=fx||{};if(!e.glueUrl||!e.wasmUrl||!e.fallbackUrl){const t=((window.config?window.config.wasmModules:window.PRELOAD_MODULES)||[]).find((function(e){return"BASIS"===e.moduleName}));if(t){const n=window.ASSET_PREFIX||"";e.glueUrl||(e.glueUrl=n+t.glueUrl),e.wasmUrl||(e.wasmUrl=n+t.wasmUrl),e.fallbackUrl||(e.fallbackUrl=n+t.fallbackUrl)}}if(e.glueUrl||e.wasmUrl||e.fallbackUrl){gx=!0;const t=Math.max(1,Math.min(16,e.numWorkers||1)),n=1===e.numWorkers||!e.hasOwnProperty("eagerWorkers")||e.eagerWorkers;e.rgbPriority=e.rgbPriority||px,e.rgbaPriority=e.rgbaPriority||ux,e.maxRetries=e.hasOwnProperty("maxRetries")?e.maxRetries:5,((e,t)=>{const n=()=>{const e="("+cx.toString()+")()\n\n";return new Blob([e],{type:"application/javascript"})},a=(a,i)=>{t(null,{workerUrl:URL.createObjectURL(n()),basisUrl:URL.createObjectURL(a),module:i,rgbPriority:e.rgbPriority,rgbaPriority:e.rgbaPriority})},i={responseType:"blob",retry:e.maxRetries>0,maxRetries:e.maxRetries};if(e.glueUrl&&e.wasmUrl&&(()=>{try{if("object"==typeof WebAssembly&&"function"==typeof WebAssembly.instantiate){const e=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(e instanceof WebAssembly.Module)return new WebAssembly.Instance(e)instanceof WebAssembly.Instance}}catch(e){}return!1})()){let n=null,s=null;Au.get(e.glueUrl,i,((e,i)=>{e?t(e):s?a(i,s):n=i}));const r=fetch(e.wasmUrl),o=()=>{r.then((e=>e.arrayBuffer())).then((e=>WebAssembly.compile(e))).then((e=>{n?a(n,e):s=e})).catch((e=>{t(e,null)}))};WebAssembly.compileStreaming?WebAssembly.compileStreaming(r).then((e=>{n?a(n,e):s=e})).catch((e=>{o()})):o()}else Au.get(e.fallbackUrl,i,((e,n)=>{e?t(e,null):a(n,null)}))})(e,((e,a)=>{if(e)console.error(`failed to initialize basis worker: ${e}`);else for(let e=0;e<t;++e)mx.enqueueClient(new dx(mx,a,n))}))}}}let bx=null;function vx(e,t,n,a,i){return yx(),bx||(bx={webgl2:e.webgl2,formats:hx(e)}),mx.enqueueJob(t,n,a,{deviceDetails:bx,isGGGR:!(null==i||!i.isGGGR),isKTX2:!(null==i||!i.isKTX2)}),gx}class _x{constructor(e,t){this.device=t,this.maxRetries=0}load(e,t,n){const a=this.device;f_.fetchArrayBuffer(e.load,((i,s)=>{var r,o,l,c;i?t(i):(r=s,vx(a,e.load,r,t,{isGGGR:0!=(8&(null==n||null==(o=n.file)||null==(l=o.variants)||null==(c=l.basis)?void 0:c.opt))})||t(`Basis module not found. Asset '${n.name}' basis texture variant will not be loaded.`))}),n,this.maxRetries)}open(e,t,n){const a=new Gm(n,{name:e,addressU:t.cubemap?1:0,addressV:t.cubemap?1:0,width:t.width,height:t.height,format:t.format,cubemap:t.cubemap,levels:t.levels});return a.upload(),a}}class wx{constructor(e){this.crossOrigin=e.prefix?"anonymous":null,this.maxRetries=0,this.useImageBitmap=!1}load(e,t,n){var a;const i=!(null==n||null==(a=n.file)||!a.contents);i&&(e={load:URL.createObjectURL(new Blob([n.file.contents])),original:e.original});const s=(n,a)=>{i&&URL.revokeObjectURL(e.load),t(n,a)};let r;n&&n.options&&n.options.hasOwnProperty("crossOrigin")?r=n.options.crossOrigin:h_.test(e.load)&&(r=this.crossOrigin),this.useImageBitmap?this._loadImageBitmap(e.load,e.original,r,s):this._loadImage(e.load,e.original,r,s)}open(e,t,n){const a=tu.getExtension(e).toLowerCase(),i=".jpg"===a||".jpeg"===a?6:7,s=new Gm(n,{name:e,width:t.width,height:t.height,format:i});return s.setSource(t),s}_loadImage(e,t,n,a){const i=new Image;n&&(i.crossOrigin=n);let s=0;const r=this.maxRetries;let o;i.onload=function(){a(null,i)},i.onerror=function(){if(!o)if(r>0&&++s<=r){const n=100*Math.pow(2,s);console.log(`Error loading Texture from: '${t}' - Retrying in ${n}ms...`);const a=e.indexOf("?")>=0?"&":"?";o=setTimeout((function(){i.src=e+a+"retry="+Date.now(),o=null}),n)}else a(`Error loading Texture from: '${t}'`)},i.src=e}_loadImageBitmap(e,t,n,a){const i={cache:!0,responseType:"blob",retry:this.maxRetries>0,maxRetries:this.maxRetries};Au.get(e,i,(function(e,t){e?a(e):createImageBitmap(t,{premultiplyAlpha:"none"}).then((function(e){a(null,e)})).catch((function(e){a(e)}))}))}}const xx=[1481919403,3140563232,169478669],Cx={33776:8,33778:9,33779:10,36196:21,37492:22,37496:23,35840:26,35841:24,35842:27,35843:25,32849:6,32856:7,35905:19,35907:20,35898:18,34843:11,34842:12};class Tx{constructor(e){this.maxRetries=0}load(e,t,n){f_.fetchArrayBuffer(e.load,t,n,this.maxRetries)}open(e,t,n){const a=this.parse(t);if(!a)return null;const i=new Gm(n,{name:e,addressU:a.cubemap?1:0,addressV:a.cubemap?1:0,width:a.width,height:a.height,format:a.format,cubemap:a.cubemap,levels:a.levels});return i.upload(),i}parse(e){const t=new Uint32Array(e);if(xx[0]!==t[0]||xx[1]!==t[1]||xx[2]!==t[2])return null;const n={endianness:t[3],glType:t[4],glTypeSize:t[5],glFormat:t[6],glInternalFormat:t[7],glBaseInternalFormat:t[8],pixelWidth:t[9],pixelHeight:t[10],pixelDepth:t[11],numberOfArrayElements:t[12],numberOfFaces:t[13],numberOfMipmapLevels:t[14],bytesOfKeyValueData:t[15]};if(n.pixelDepth>1)return null;if(0!==n.numberOfArrayElements)return null;const a=Cx[n.glInternalFormat];if(void 0===a)return null;let i=16+n.bytesOfKeyValueData/4;const s=n.numberOfFaces>1,r=[];for(let h=0;h<(n.numberOfMipmapLevels||1);h++){const n=t[i++];s&&r.push([]);const d=s?r[h]:r;for(let t=0;t<(s?6:1);++t)d.push((o=e,l=4*i,c=n,18===a?new Uint32Array(o,l,c/4):new Uint8Array(o,l,c))),i+=n+3>>2}var o,l,c;return{format:a,width:n.pixelWidth,height:n.pixelHeight,levels:r,cubemap:s}}}const Ex=166;class Sx{constructor(e,t){this.maxRetries=0,this.device=t}load(e,t,n){f_.fetchArrayBuffer(e.load,((a,i)=>{a?t(a,i):this.parse(i,e,t,n)}),n,this.maxRetries)}open(e,t,n){const a=new Gm(n,{name:e,addressU:t.cubemap?1:0,addressV:t.cubemap?1:0,width:t.width,height:t.height,format:t.format,cubemap:t.cubemap,levels:t.levels});return a.upload(),a}parse(e,t,n,a){const i=new vu(e),s=[i.readU32be(),i.readU32be(),i.readU32be()];if(2873840728!==s[0]||540160187!==s[1]||218765834!==s[2])return null;const r={vkFormat:i.readU32(),typeSize:i.readU32(),pixelWidth:i.readU32(),pixelHeight:i.readU32(),pixelDepth:i.readU32(),layerCount:i.readU32(),faceCount:i.readU32(),levelCount:i.readU32(),supercompressionScheme:i.readU32()},o={dfdByteOffset:i.readU32(),dfdByteLength:i.readU32(),kvdByteOffset:i.readU32(),kvdByteLength:i.readU32(),sgdByteOffset:i.readU64(),sgdByteLength:i.readU64()},l=[];for(let e=0;e<Math.max(1,r.levelCount);++e)l.push({byteOffset:i.readU64(),byteLength:i.readU64(),uncompressedByteLength:i.readU64()});if(i.readU32()!==o.kvdByteOffset-o.dfdByteOffset)return null;i.skip(8);const c=i.readU8();if(i.skip(o.dfdByteLength-9),i.skip(o.kvdByteLength),1===r.supercompressionScheme||c===Ex){var h,d,p;vx(this.device,t.load,e,n,{isGGGR:0!=(8&(null==a||null==(h=a.file)||null==(d=h.variants)||null==(p=d.basis)?void 0:p.opt)),isKTX2:!0})||n('Basis module not found. Asset "'+a.name+'" basis texture variant will not be loaded.')}else n("unsupported KTX2 pixel format")}}class Ax{constructor(e){this.maxRetries=0}load(e,t,n){f_.fetchArrayBuffer(e.load,t,n,this.maxRetries)}open(e,t,n){const a=new Uint32Array(t,0,32),i=a[4],s=a[3],r=Math.max(a[7],1),o=4===a[20],l=a[21],c=a[22],h=65024===a[28],d=827611204,p=825438800,u=825439312;let m,f=!1,g=!1,y=!1,b=!1,v=null,_=1;if(o?l===d?(v=8,f=!0):894720068===l?(v=10,f=!0):113===l?(v=12,_=2):116===l?(v=14,_=4):826496069===l?(v=21,f=!0,g=!0):l===p||825504336===l?(v=l===p?24:25,f=!0,y=!0):l!==u&&825504848!==l||(v=l===u?26:27,f=!0,b=!0):32===c&&(v=7),!v)return m=new Gm(n,{width:4,height:4,format:6}),m.name="dds-legacy-empty",m;m=new Gm(n,{name:e,addressU:h?1:0,addressV:h?1:0,width:i,height:s,format:v,cubemap:h,mipmaps:r>1});let w=128;const x=h?6:1;let C;const T=l===d?8:16;let E,S,A;for(let e=0;e<x;e++){let n=i,a=s;for(let i=0;i<r;i++){f?g?C=Math.floor((n+3)/4)*Math.floor((a+3)/4)*8:y?C=Math.max(n,16)*Math.max(a,8)/4:b?C=Math.max(n,8)*Math.max(a,8)/2:(E=Math.floor((n+4-1)/4),S=Math.floor((a+4-1)/4),A=E*S,C=A*T):C=n*a*4;const s=14===v?new Float32Array(t,w,C):12===v?new Uint16Array(t,w,C):new Uint8Array(t,w,C);h?(m._levels[i]||(m._levels[i]=[]),m._levels[i][e]=s):m._levels[i]=s,w+=C*_,n=Math.max(.5*n,1),a=Math.max(.5*a,1)}}return m.upload(),m}}class Mx{constructor(e){this.maxRetries=0}load(e,t,n){f_.fetchArrayBuffer(e.load,t,n,this.maxRetries)}open(e,t,n){const a=this.parse(t);if(!a)return null;const i=new Gm(n,{name:e,addressU:0,addressV:1,minFilter:2,magFilter:0,width:a.width,height:a.height,levels:a.levels,format:7,type:"rgbe",mipmaps:!1});return i.upload(),i}parse(e){const t=new vu(e);if(!t.readLine().startsWith("#?RADIANCE"))return null;const n={};for(;;){const e=t.readLine();if(0===e.length)break;{const t=e.split("=");2===t.length&&(n[t[0]]=t[1])}}if(!n.hasOwnProperty("FORMAT"))return null;const a=t.readLine().split(" ");if(4!==a.length)return null;const i=parseInt(a[1],10),s=parseInt(a[3],10),r=this._readPixels(t,s,i,"-Y"===a[0]);return r?{width:s,height:i,levels:[r]}:null}_readPixels(e,t,n,a){if(t<8||t>32767)return this._readPixelsFlat(e,t,n);const i=[0,0,0,0];if(e.readArray(i),2!==i[0]||2!==i[1]||0!=(128&i[2]))return e.skip(-4),this._readPixelsFlat(e,t,n);const s=new ArrayBuffer(t*n*4),r=new Uint8Array(s);let o,l,c,h,d,p,u=a?0:4*t*(n-1);for(l=0;l<n;++l){if(l&&e.readArray(i),(i[2]<<8)+i[3]!==t)return null;for(h=0;h<4;++h)for(o=0;o<t;)if(d=e.readU8(),d>128){if(d-=128,o+d>t)return null;for(p=e.readU8(),c=0;c<d;++c)r[u+h+4*o++]=p}else{if(0===d||o+d>t)return null;for(c=0;c<d;++c)r[u+h+4*o++]=e.readU8()}u+=4*t*(a?1:-1)}return r}_readPixelsFlat(e,t,n){return e.remainingBytes===t*n*4?new Uint8Array(e.arraybuffer,e.offset):null}}const Lx={repeat:0,clamp:1,mirror:2},Rx={nearest:0,linear:1,nearest_mip_nearest:2,linear_mip_nearest:4,nearest_mip_linear:3,linear_mip_linear:5},Ix={default:"default",rgbm:"rgbm",rgbe:"rgbe",swizzleGGGR:"swizzleGGGR"};class Px{constructor(e,t,n){this._device=e,this._assets=t,this._loader=n,this.imgParser=new wx(t),this.parsers={dds:new Ax(t),ktx:new Tx(t),ktx2:new Sx(t,e),basis:new _x(t,e),hdr:new Mx(t)}}set crossOrigin(e){this.imgParser.crossOrigin=e}get crossOrigin(){return this.imgParser.crossOrigin}set maxRetries(e){this.imgParser.maxRetries=e;for(const t in this.parsers)this.parsers.hasOwnProperty(t)&&(this.parsers[t].maxRetries=e)}get maxRetries(){return this.imgParser.maxRetries}_getUrlWithoutParams(e){return e.indexOf("?")>=0?e.split("?")[0]:e}_getParser(e){const t=tu.getExtension(this._getUrlWithoutParams(e)).toLowerCase().replace(".","");return this.parsers[t]||this.imgParser}load(e,t,n){"string"==typeof e&&(e={load:e,original:e}),this._getParser(e.original).load(e,t,n)}open(e,t,n){if(!e)return;let a=this._getParser(e).open(e,t,this._device);return null===a?a=new Gm(this._device,{width:4,height:4,format:6}):(!function(e){const t=Math.log2(Math.max(e._width,e._height))+1;if(7!==e._format&&14!==e._format||e._volume||e._compressed||1===e._levels.length||e._levels.length===t||(n=e._cubemap?e._levels[0][0]:e._levels[0])instanceof HTMLCanvasElement||n instanceof HTMLImageElement||n instanceof HTMLVideoElement)return;var n;const a=function(e,t,n){const a=Math.max(1,e>>1),i=Math.max(1,t>>1),s=new n.constructor(a*i*4),r=Math.floor(e/a),o=Math.floor(t/i),l=r*o;for(let t=0;t<i;++t)for(let i=0;i<a;++i)for(let c=0;c<4;++c){let h=0;for(let a=0;a<o;++a)for(let s=0;s<r;++s)h+=n[4*(i*r+s+(t*o+a)*e)+c];s[4*(i+t*a)+c]=h/l}return s};for(let n=e._levels.length;n<t;++n){const t=Math.max(1,e._width>>n-1),i=Math.max(1,e._height>>n-1);if(e._cubemap){const s=[];for(let r=0;r<6;++r)s.push(a(t,i,e._levels[n-1][r]));e._levels.push(s)}else e._levels.push(a(t,i,e._levels[n-1]))}e._levelsUpdated=e._cubemap?[[!0,!0,!0,!0,!0,!0]]:[!0]}(a),t.unswizzledGGGR&&(n.file.variants.basis.opt&=-9)),a}patch(e,t){const n=e.resource;if(!n)return;e.name&&e.name.length>0&&(n.name=e.name);const a=e.data;a.hasOwnProperty("minfilter")&&(n.minFilter=Rx[a.minfilter]),a.hasOwnProperty("magfilter")&&(n.magFilter=Rx[a.magfilter]),n.cubemap||(a.hasOwnProperty("addressu")&&(n.addressU=Lx[a.addressu]),a.hasOwnProperty("addressv")&&(n.addressV=Lx[a.addressv])),a.hasOwnProperty("mipmaps")&&(n.mipmaps=a.mipmaps),a.hasOwnProperty("anisotropy")&&(n.anisotropy=a.anisotropy),a.hasOwnProperty("flipY")&&(n.flipY=!!a.flipY),a.hasOwnProperty("type")?n.type=Ix[a.type]:a.hasOwnProperty("rgbm")&&a.rgbm?n.type="rgbm":e.file&&0!=(8&e.file.opt)&&(n.type="swizzleGGGR")}}class kx{constructor(e=null){this._index={},this._key=e}addItem(e){const t=e.tags._list;for(const n of t)this.add(n,e)}removeItem(e){const t=e.tags._list;for(const n of t)this.remove(n,e)}add(e,t){this._index[e]&&-1!==this._index[e].list.indexOf(t)||(this._index[e]||(this._index[e]={list:[]},this._key&&(this._index[e].keys={})),this._index[e].list.push(t),this._key&&(this._index[e].keys[t[this._key]]=t))}remove(e,t){if(!this._index[e])return;if(this._key&&!this._index[e].keys[t[this._key]])return;const n=this._index[e].list.indexOf(t);-1!==n&&(this._index[e].list.splice(n,1),this._key&&delete this._index[e].keys[t[this._key]],0===this._index[e].list.length&&delete this._index[e])}find(e){const t={},n=[];let a,i,s,r,o;const l=(e,t)=>this._index[e].list.length-this._index[t].list.length;for(let c=0;c<e.length;c++){if(i=e[c],i instanceof Array){if(0===i.length)continue;if(1!==i.length){o=!1;for(let e=0;e<i.length;e++)if(!this._index[i[e]]){o=!0;break}if(o)continue;s=i.slice(0).sort(l),r=s.slice(1),1===r.length&&(r=r[0]);for(let e=0;e<this._index[s[0]].list.length;e++)a=this._index[s[0]].list[e],(this._key?!t[a[this._key]]:-1===n.indexOf(a))&&a.tags.has(r)&&(this._key&&(t[a[this._key]]=!0),n.push(a));continue}i=i[0]}if(i&&"string"==typeof i&&this._index[i])for(let e=0;e<this._index[i].list.length;e++)a=this._index[i].list[e],this._key?t[a[this._key]]||(t[a[this._key]]=!0,n.push(a)):-1===n.indexOf(a)&&n.push(a)}return n}}class Dx extends Qp{constructor(e){super(),this._loader=e,this._assets=[],this._cache={},this._names={},this._tags=new kx("_id"),this._urls={},this.prefix=null}list(e){return e=e||{},this._assets.filter((t=>{let n=!0;return void 0!==e.preload&&(n=t.preload===e.preload),n}))}add(e){const t=this._assets.push(e)-1;let n;this._cache[e.id]=t,this._names[e.name]||(this._names[e.name]=[]),this._names[e.name].push(t),e.file&&(n=e.file.url,this._urls[n]=t),e.registry=this,this._tags.addItem(e),e.tags.on("add",this._onTagAdd,this),e.tags.on("remove",this._onTagRemove,this),this.fire("add",e),this.fire("add:"+e.id,e),n&&this.fire("add:url:"+n,e),e.preload&&this.load(e)}remove(e){const t=this._cache[e.id],n=e.file?e.file.url:null;if(void 0!==t){this._assets.splice(t,1),delete this._cache[e.id],this._names={},this._urls=[];for(let e=0,t=this._assets.length;e<t;e++){const t=this._assets[e];this._cache[t.id]=e,this._names[t.name]||(this._names[t.name]=[]),this._names[t.name].push(e),t.file&&(this._urls[t.file.url]=e)}return this._tags.removeItem(e),e.tags.off("add",this._onTagAdd,this),e.tags.off("remove",this._onTagRemove,this),e.fire("remove",e),this.fire("remove",e),this.fire("remove:"+e.id,e),n&&this.fire("remove:url:"+n,e),!0}return!1}get(e){const t=this._cache[e];return this._assets[t]}getByUrl(e){const t=this._urls[e];return this._assets[t]}load(e){if(e.loading||e.loaded)return;const t=e.file,n=n=>{n instanceof Array?e.resources=n:e.resource=n,this._loader.patch(e,this),this.fire("load",e),this.fire("load:"+e.id,e),t&&t.url&&this.fire("load:url:"+t.url,e),e.fire("load",e)},a=(t,a,i)=>{if(e.loaded=!0,e.loading=!1,t)this.fire("error",t,e),this.fire("error:"+e.id,t,e),e.fire("error",t,e);else{if(!Xw.legacy&&"script"===e.type){const t=this._loader.getHandler("script");t._cache[e.id]&&t._cache[e.id].parentNode===document.head&&document.head.removeChild(t._cache[e.id]),t._cache[e.id]=i}n(a)}};if(t||"cubemap"===e.type)this.fire("load:start",e),this.fire("load:"+e.id+":start",e),e.loading=!0,this._loader.load(e.getFileUrl(),e.type,a,e);else{const t=this._loader.open(e.type,e.data);e.loaded=!0,n(t)}}loadFromUrl(e,t,n){this.loadFromUrlAndFilename(e,null,t,n)}loadFromUrlAndFilename(e,t,n,a){const i=tu.getBasename(t||e),s={filename:t||i,url:e};let r=this.getByUrl(e);if(r){if(r.loaded)return void a(r.loadFromUrlError||null,r)}else r=new f_(i,n,s),this.add(r);const o=e=>{e.once("load",(e=>{"material"===n?this._loadTextures(e,((t,n)=>{a(t,e)})):a(null,e)})),e.once("error",(t=>{t&&(this.loadFromUrlError=t),a(t,e)})),this.load(e)};r.resource?a(null,r):"model"===n?this._loadModel(r,o):o(r)}_loadModel(e,t){const n=e.getFileUrl(),a=tu.getExtension(n);if(".json"===a||".glb"===a){const i=tu.getDirectory(n),s=tu.getBasename(n),r=tu.join(i,s.replace(a,".mapping.json"));this._loader.load(r,"json",((n,a)=>{n?(e.data={mapping:[]},t(e)):this._loadMaterials(e,a,((n,i)=>{e.data=a,t(e)}))}))}else t(e)}_loadMaterials(e,t,n){const a=[];let i=0;const s=(e,t)=>{this._loadTextures(t,((e,s)=>{a.push(t),a.length===i&&n(null,a)}))};for(let n=0;n<t.mapping.length;n++){const a=t.mapping[n].path;if(a){i++;const t=e.getAbsoluteUrl(a);this.loadFromUrl(t,"material",s)}}0===i&&n(null,a)}_loadTextures(e,t){const n=[];let a=0;const i=e.data;if("path"!==i.mappingFormat)return void t(null,n);const s=(e,i)=>{e&&console.error(e),n.push(i),n.length===a&&t(null,n)},r=ig;for(let t=0;t<r.length;t++){const n=i[r[t]];if(n&&"string"==typeof n){a++;const t=e.getAbsoluteUrl(n);this.loadFromUrl(t,"texture",s)}}0===a&&t(null,n)}findAll(e,t){const n=this._names[e];if(n){const e=n.map((e=>this._assets[e]));return t?e.filter((e=>e.type===t)):e}return[]}_onTagAdd(e,t){this._tags.add(e,t)}_onTagRemove(e,t){this._tags.remove(e,t)}findByTag(){return this._tags.find(arguments)}filter(e){return this._assets.filter((t=>e(t)))}find(e,t){const n=this.findAll(e,t);return n.length>0?n[0]:null}}class Ox{constructor(e){this._assets=e,this._bundleAssets={},this._assetsInBundles={},this._urlsInBundles={},this._fileRequests={},this._assets.on("add",this._onAssetAdded,this),this._assets.on("remove",this._onAssetRemoved,this)}_onAssetAdded(e){if("bundle"===e.type){this._bundleAssets[e.id]=e,this._registerBundleEventListeners(e.id);for(let t=0,n=e.data.assets.length;t<n;t++)this._indexAssetInBundle(e.data.assets[t],e)}else this._assetsInBundles[e.id]&&this._indexAssetFileUrls(e)}_registerBundleEventListeners(e){this._assets.on("load:"+e,this._onBundleLoaded,this),this._assets.on("error:"+e,this._onBundleError,this)}_unregisterBundleEventListeners(e){this._assets.off("load:"+e,this._onBundleLoaded,this),this._assets.off("error:"+e,this._onBundleError,this)}_indexAssetInBundle(e,t){if(this._assetsInBundles[e]){const n=this._assetsInBundles[e];-1===n.indexOf(t)&&n.push(t)}else this._assetsInBundles[e]=[t];const n=this._assets.get(e);n&&this._indexAssetFileUrls(n)}_indexAssetFileUrls(e){const t=this._getAssetFileUrls(e);if(t)for(let n=0,a=t.length;n<a;n++){const a=t[n];this._urlsInBundles[a]=this._assetsInBundles[e.id]}}_getAssetFileUrls(e){let t=e.getFileUrl();if(!t)return null;t=this._normalizeUrl(t);const n=[t];if("font"===e.type){const a=e.data.info.maps.length;for(let e=1;e<a;e++)n.push(t.replace(".png",e+".png"))}return n}_normalizeUrl(e){return e&&e.split("?")[0]}_onAssetRemoved(e){if("bundle"===e.type){delete this._bundleAssets[e.id],this._unregisterBundleEventListeners(e.id);for(const t in this._assetsInBundles){const n=this._assetsInBundles[t],a=n.indexOf(e);if(-1!==a&&(n.splice(a,1),!n.length)){delete this._assetsInBundles[t];for(const e in this._urlsInBundles)this._urlsInBundles[e]===n&&delete this._urlsInBundles[e]}}this._onBundleError(`Bundle ${e.id} was removed`,e)}else if(this._assetsInBundles[e.id]){delete this._assetsInBundles[e.id];const t=this._getAssetFileUrls(e);for(let e=0,n=t.length;e<n;e++)delete this._urlsInBundles[t[e]]}}_onBundleLoaded(e){e.resource?requestAnimationFrame((()=>{if(this._fileRequests)for(const t in this._fileRequests){const n=this._urlsInBundles[t];if(!n||-1===n.indexOf(e))continue;const a=decodeURIComponent(t);let i=null;e.resource.hasBlobUrl(a)||(i=`Bundle ${e.id} does not contain URL ${t}`);const s=this._fileRequests[t];for(let t=0,n=s.length;t<n;t++)i?s[t](i):s[t](null,e.resource.getBlobUrl(a));delete this._fileRequests[t]}})):this._onBundleError(`Bundle ${e.id} failed to load`,e)}_onBundleError(e,t){for(const t in this._fileRequests){if(!this._findLoadedOrLoadingBundleForUrl(t)){const n=this._fileRequests[t];for(let t=0,a=n.length;t<a;t++)n[t](e);delete this._fileRequests[t]}}}_findLoadedOrLoadingBundleForUrl(e){const t=this._urlsInBundles[e];if(!t)return null;const n=t.length;for(let e=0;e<n;e++)if(t[e].loaded&&t[e].resource)return t[e];for(let e=0;e<n;e++)if(t[e].loading)return t[e];return null}listBundlesForAsset(e){return this._assetsInBundles[e.id]||null}list(){const e=[];for(const t in this._bundleAssets)e.push(this._bundleAssets[t]);return e}hasUrl(e){return!!this._urlsInBundles[e]}canLoadUrl(e){return!!this._findLoadedOrLoadingBundleForUrl(e)}loadUrl(e,t){const n=this._findLoadedOrLoadingBundleForUrl(e);if(n)if(n.loaded){const a=decodeURIComponent(e);if(!n.resource.hasBlobUrl(a))return void t(`Bundle ${n.id} does not contain URL ${e}`);t(null,n.resource.getBlobUrl(a))}else this._fileRequests.hasOwnProperty(e)?this._fileRequests[e].push(t):this._fileRequests[e]=[t];else t(`URL ${e} not found in any bundles`)}destroy(){this._assets.off("add",this._onAssetAdded,this),this._assets.off("remove",this._onAssetRemoved,this);for(const e in this._bundleAssets)this._unregisterBundleEventListeners(e);this._assets=null,this._bundleAssets=null,this._assetsInBundles=null,this._urlsInBundles=null,this._fileRequests=null}}const Fx=["x","y","z","w"],Nx=[void 0,void 0,Du,Pu,Ou];function Vx(e,t,n,a){switch(t.type){case"boolean":return!!n;case"number":if("number"==typeof n)return n;if("string"==typeof n){const e=parseInt(n,10);return isNaN(e)?null:e}return"boolean"==typeof n?0+n:null;case"json":{const a={};if(Array.isArray(t.schema)){n&&"object"==typeof n||(n={});for(let i=0;i<t.schema.length;i++){const s=t.schema[i];if(s.name)if(s.array){a[s.name]=[];const t=Array.isArray(n[s.name])?n[s.name]:[];for(let n=0;n<t.length;n++)a[s.name].push(Vx(e,s,t[n]))}else{const t=n.hasOwnProperty(s.name)?n[s.name]:s.default;a[s.name]=Vx(e,s,t)}}}return a}case"asset":return n instanceof f_?n:"number"==typeof n?e.assets.get(n)||null:"string"==typeof n&&e.assets.get(parseInt(n,10))||null;case"entity":return n instanceof hf?n:"string"==typeof n?e.getEntityFromIndex(n):null;case"rgb":case"rgba":if(n instanceof Mu)return a instanceof Mu?(a.copy(n),a):n.clone();if(n instanceof Array&&n.length>=3&&n.length<=4){for(let e=0;e<n.length;e++)if("number"!=typeof n[e])return null;return a||(a=new Mu),a.r=n[0],a.g=n[1],a.b=n[2],a.a=3===n.length?1:n[3],a}return"string"==typeof n&&/#([0-9abcdef]{2}){3,4}/i.test(n)?(a||(a=new Mu),a.fromString(n),a):null;case"vec2":case"vec3":case"vec4":{const e=parseInt(t.type.slice(3),10),i=Nx[e];if(n instanceof i)return a instanceof i?(a.copy(n),a):n.clone();if(n instanceof Array&&n.length===e){for(let e=0;e<n.length;e++)if("number"!=typeof n[e])return null;a||(a=new i);for(let t=0;t<e;t++)a[Fx[t]]=n[t];return a}return null}case"curve":if(n){let e;if(n instanceof Ru||n instanceof Iu)e=n.clone();else{e=new(n.keys[0]instanceof Array?Iu:Ru)(n.keys),e.type=n.type}return e}}return n}class Bx{constructor(e){this.scriptType=e,this.index={}}add(e,t){this.index[e]||Bx.reservedNames.has(e)||(this.index[e]=t,Object.defineProperty(this.scriptType.prototype,e,{get:function(){return this.__attributes[e]},set:function(n){const a="attr",i="attr:"+e,s=this.__attributes[e];let r=s;if(s&&"json"!==t.type&&s.clone&&(this._callbacks.attr||this._callbacks[i])&&(r=s.clone()),t.array){if(this.__attributes[e]=[],n)for(let a=0,i=n.length;a<i;a++)this.__attributes[e].push(Vx(this.app,t,n[a],s?s[a]:null))}else this.__attributes[e]=Vx(this.app,t,n,s);this.fire(a,e,this.__attributes[e],r),this.fire(i,this.__attributes[e],r)}}))}remove(e){return!!this.index[e]&&(delete this.index[e],delete this.scriptType.prototype[e],!0)}has(e){return!!this.index[e]}get(e){return this.index[e]||null}}Bx.reservedNames=new Set(["app","entity","enabled","_enabled","_enabledOld","_destroyed","__attributes","__attributesRaw","__scriptType","__executionOrder","_callbacks","has","get","on","off","fire","once","hasEvent"]);class Ux extends Qp{constructor(e,t){super(),this.system=void 0,this.entity=void 0,this.system=e,this.entity=t,this.system.schema&&!this._accessorsBuilt&&this.buildAccessors(this.system.schema),this.on("set",(function(e,t,n){this.fire("set_"+e,e,t,n)})),this.on("set_enabled",this.onSetEnabled,this)}static _buildAccessors(e,t){t.forEach((function(t){const n="object"==typeof t?t.name:t;Object.defineProperty(e,n,{get:function(){return this.data[n]},set:function(e){const t=this.data,a=t[n];t[n]=e,this.fire("set",n,a,e)},configurable:!0})})),e._accessorsBuilt=!0}buildAccessors(e){Ux._buildAccessors(this,e)}onSetEnabled(e,t,n){t!==n&&this.entity.enabled&&(n?this.onEnable():this.onDisable())}onEnable(){}onDisable(){}onPostStateChange(){}get data(){const e=this.system.store[this.entity.getGuid()];return e?e.data:null}}class zx extends Ux{constructor(e,t){super(e,t),this._scripts=[],this._updateList=new _u({sortBy:"__executionOrder"}),this._postUpdateList=new _u({sortBy:"__executionOrder"}),this._scriptsIndex={},this._destroyedScripts=[],this._destroyed=!1,this._scriptsData=null,this._oldState=!0,this._enabled=!0,this._beingEnabled=!1,this._isLoopingThroughScripts=!1,this._executionOrder=-1,this.on("set_enabled",this._onSetEnabled,this)}set enabled(e){const t=this._enabled;this._enabled=e,this.fire("set","enabled",t,e)}get enabled(){return this._enabled}set scripts(e){this._scriptsData=e;for(const t in e){if(!e.hasOwnProperty(t))continue;const n=this._scriptsIndex[t];if(n){if("boolean"==typeof e[t].enabled&&(n.enabled=!!e[t].enabled),"object"==typeof e[t].attributes)for(const a in e[t].attributes)if(!Bx.reservedNames.has(a)){if(!n.__attributes.hasOwnProperty(a)){const e=this.system.app.scripts.get(t);e&&e.attributes.add(a,{})}n[a]=e[t].attributes[a]}}else console.log(this.order)}}get scripts(){return this._scripts}onEnable(){this._beingEnabled=!0,this._checkState(),this.entity._beingEnabled||this.onPostStateChange(),this._beingEnabled=!1}onDisable(){this._checkState()}onPostStateChange(){const e=this._beginLooping();for(let e=0,t=this.scripts.length;e<t;e++){const t=this.scripts[e];t._initialized&&!t._postInitialized&&t.enabled&&(t._postInitialized=!0,t.postInitialize&&this._scriptMethod(t,zx.scriptMethods.postInitialize))}this._endLooping(e)}_beginLooping(){const e=this._isLoopingThroughScripts;return this._isLoopingThroughScripts=!0,e}_endLooping(e){this._isLoopingThroughScripts=e,this._isLoopingThroughScripts||this._removeDestroyedScripts()}_onSetEnabled(e,t,n){this._beingEnabled=!0,this._checkState(),this._beingEnabled=!1}_checkState(){const e=this.enabled&&this.entity.enabled;if(e===this._oldState)return;this._oldState=e,this.fire(e?"enable":"disable"),this.fire("state",e),e?this.system._addComponentToEnabled(this):this.system._removeComponentFromEnabled(this);const t=this._beginLooping();for(let e=0,t=this.scripts.length;e<t;e++){const t=this.scripts[e];t.enabled=t._enabled}this._endLooping(t)}_onBeforeRemove(){this.fire("remove");const e=this._beginLooping();for(let e=0;e<this.scripts.length;e++){const t=this.scripts[e];t&&this.destroy(t.__scriptType.__name)}this._endLooping(e)}_removeDestroyedScripts(){const e=this._destroyedScripts.length;if(e){for(let t=0;t<e;t++){const e=this._destroyedScripts[t];this._removeScriptInstance(e)}this._destroyedScripts.length=0,this._resetExecutionOrder(0,this._scripts.length)}}_onInitializeAttributes(){for(let e=0,t=this.scripts.length;e<t;e++)this.scripts[e].__initializeAttributes()}_scriptMethod(e,t,n){e[t](n)}_onInitialize(){const e=this._scripts,t=this._beginLooping();for(let t=0,n=e.length;t<n;t++){const n=e[t];!n._initialized&&n.enabled&&(n._initialized=!0,n.initialize&&this._scriptMethod(n,zx.scriptMethods.initialize))}this._endLooping(t)}_onPostInitialize(){this.onPostStateChange()}_onUpdate(e){const t=this._updateList;if(!t.length)return;const n=this._beginLooping();for(t.loopIndex=0;t.loopIndex<t.length;t.loopIndex++){const n=t.items[t.loopIndex];n.enabled&&this._scriptMethod(n,zx.scriptMethods.update,e)}this._endLooping(n)}_onPostUpdate(e){const t=this._postUpdateList;if(!t.length)return;const n=this._beginLooping();for(t.loopIndex=0;t.loopIndex<t.length;t.loopIndex++){const n=t.items[t.loopIndex];n.enabled&&this._scriptMethod(n,zx.scriptMethods.postUpdate,e)}this._endLooping(n)}_insertScriptInstance(e,t,n){-1===t?(this._scripts.push(e),e.__executionOrder=n,e.update&&this._updateList.append(e),e.postUpdate&&this._postUpdateList.append(e)):(this._scripts.splice(t,0,e),e.__executionOrder=t,this._resetExecutionOrder(t+1,n+1),e.update&&this._updateList.insert(e),e.postUpdate&&this._postUpdateList.insert(e))}_removeScriptInstance(e){const t=this._scripts.indexOf(e);return-1===t||(this._scripts.splice(t,1),e.update&&this._updateList.remove(e),e.postUpdate&&this._postUpdateList.remove(e)),t}_resetExecutionOrder(e,t){for(let n=e;n<t;n++)this._scripts[n].__executionOrder=n}_resolveEntityScriptAttribute(e,t,n,a,i,s){if(e.array){const e=n.length;if(!e)return;const r=n.slice();for(let t=0;t<e;t++){const e=r[t]instanceof KM?r[t].getGuid():r[t];s[e]&&(r[t]=a?s[e].getGuid():s[e])}i[t]=r}else{if(n instanceof KM)n=n.getGuid();else if("string"!=typeof n)return;s[n]&&(i[t]=s[n])}}has(e){if("string"==typeof e)return!!this._scriptsIndex[e];if(!e)return!1;const t=e,n=t.__name,a=this._scriptsIndex[n];return(a&&a.instance)instanceof t}get(e){if("string"==typeof e){const t=this._scriptsIndex[e];return t?t.instance:null}if(!e)return null;const t=e,n=t.__name,a=this._scriptsIndex[n],i=a&&a.instance;return i instanceof t?i:null}create(e,t={}){const n=this;let a=e,i=e;if("string"==typeof a?a=this.system.app.scripts.get(a):a&&(i=a.__name),a){if(!this._scriptsIndex[i]||!this._scriptsIndex[i].instance){const e=new a({app:this.system.app,entity:this.entity,enabled:!t.hasOwnProperty("enabled")||t.enabled,attributes:t.attributes}),s=this._scripts.length;let r=-1;return"number"==typeof t.ind&&-1!==t.ind&&s>t.ind&&(r=t.ind),this._insertScriptInstance(e,r,s),this._scriptsIndex[i]={instance:e,onSwap:function(){n.swap(i)}},this[i]=e,t.preloading||e.__initializeAttributes(),this.fire("create",i,e),this.fire("create:"+i,e),this.system.app.scripts.on("swap:"+i,this._scriptsIndex[i].onSwap),t.preloading||(e.enabled&&!e._initialized&&(e._initialized=!0,e.initialize&&this._scriptMethod(e,zx.scriptMethods.initialize)),e.enabled&&!e._postInitialized&&(e._postInitialized=!0,e.postInitialize&&this._scriptMethod(e,zx.scriptMethods.postInitialize))),e}}else this._scriptsIndex[i]={awaiting:!0,ind:this._scripts.length};return null}destroy(e){let t=e,n=e;"string"==typeof n?n=this.system.app.scripts.get(n):n&&(t=n.__name);const a=this._scriptsIndex[t];if(delete this._scriptsIndex[t],!a)return!1;const i=a.instance;if(i&&!i._destroyed)if(i.enabled=!1,i._destroyed=!0,this._isLoopingThroughScripts)this._destroyedScripts.push(i);else{const e=this._removeScriptInstance(i);e>=0&&this._resetExecutionOrder(e,this._scripts.length)}return this.system.app.scripts.off("swap:"+t,a.onSwap),delete this[t],this.fire("destroy",t,i||null),this.fire("destroy:"+t,i||null),i&&i.fire("destroy"),!0}swap(e){let t=e,n=e;"string"==typeof n?n=this.system.app.scripts.get(n):n&&(t=n.__name);const a=this._scriptsIndex[t];if(!a||!a.instance)return!1;const i=a.instance,s=this._scripts.indexOf(i),r=new n({app:this.system.app,entity:this.entity,enabled:i.enabled,attributes:i.__attributes});return!!r.swap&&(r.__initializeAttributes(),this._scripts[s]=r,this._scriptsIndex[t].instance=r,this[t]=r,r.__executionOrder=s,i.update&&this._updateList.remove(i),i.postUpdate&&this._postUpdateList.remove(i),r.update&&this._updateList.insert(r),r.postUpdate&&this._postUpdateList.insert(r),this._scriptMethod(r,zx.scriptMethods.swap,i),this.fire("swap",t,r),this.fire("swap:"+t,r),!0)}resolveDuplicatedEntityReferenceProperties(e,t){const n=this.entity.script;for(const a in e._scriptsIndex){const i=this.system.app.scripts.get(a);if(!i)continue;const s=e._scriptsIndex[a];if(!s||!s.instance)continue;const r=n[a].__attributesRaw,o=n[a].__attributes;if(!r&&!o)continue;const l=!!r,c=s.instance.__attributes;for(const e in c){if(!c[e])continue;const n=i.attributes.get(e);if(n)if("entity"===n.type)this._resolveEntityScriptAttribute(n,e,c[e],l,r||o,t);else if("json"===n.type&&Array.isArray(n.schema)){const a=c[e],i=r?r[e]:o[e];for(let e=0;e<n.schema.length;e++){const s=n.schema[e];if("entity"===s.type)if(n.array)for(let e=0;e<a.length;e++)this._resolveEntityScriptAttribute(s,s.name,a[e][s.name],l,i[e],t);else this._resolveEntityScriptAttribute(s,s.name,a[s.name],l,i,t)}}}}}move(e,t){const n=this._scripts.length;if(t>=n||t<0)return!1;let a=e,i=e;"string"!=typeof i?i=e.__name:a=null;const s=this._scriptsIndex[i];if(!s||!s.instance)return!1;const r=s.instance;if(a&&!(r instanceof a))return!1;const o=this._scripts.indexOf(r);return-1!==o&&o!==t&&(this._scripts.splice(t,0,this._scripts.splice(o,1)[0]),this._resetExecutionOrder(0,n),this._updateList.sort(),this._postUpdateList.sort(),this.fire("move",i,r,t,o),this.fire("move:"+i,r,t,o),!0)}}zx.scriptMethods={initialize:"initialize",postInitialize:"postInitialize",update:"update",postUpdate:"postUpdate",swap:"swap"};const Gx=new RegExp("^\\s*function(?:\\s|\\s*\\/\\*.*\\*\\/\\s*)+([^\\(\\s\\/]*)\\s*");class Hx extends Qp{constructor(e){super(),this.app=void 0,this.entity=void 0,this._enabled=void 0,this._enabledOld=void 0,this._initialized=void 0,this._postInitialized=void 0,this.__destroyed=void 0,this.__attributes=void 0,this.__attributesRaw=void 0,this.__scriptType=void 0,this.__executionOrder=void 0,this.initScriptType(e)}set enabled(e){this._enabled=!!e,this.enabled!==this._enabledOld&&(this._enabledOld=this.enabled,this.fire(this.enabled?"enable":"disable"),this.fire("state",this.enabled),!this._initialized&&this.enabled&&(this._initialized=!0,this.__initializeAttributes(!0),this.initialize&&this.entity.script._scriptMethod(this,zx.scriptMethods.initialize)),this._initialized&&!this._postInitialized&&this.enabled&&!this.entity.script._beingEnabled&&(this._postInitialized=!0,this.postInitialize&&this.entity.script._scriptMethod(this,zx.scriptMethods.postInitialize)))}get enabled(){return this._enabled&&!this._destroyed&&this.entity.script.enabled&&this.entity.enabled}initScriptType(e){const t=this.constructor;this.app=e.app,this.entity=e.entity,this._enabled="boolean"!=typeof e.enabled||e.enabled,this._enabledOld=this.enabled,this.__destroyed=!1,this.__attributes={},this.__attributesRaw=e.attributes||{},this.__scriptType=t,this.__executionOrder=-1}static __getScriptName(e){if("function"!=typeof e)return;if("name"in Function.prototype)return e.name;if(e===Function||e===Function.prototype.constructor)return"Function";const t=(""+e).match(Gx);return t?t[1]:void 0}static get scriptName(){return this.__name}static get attributes(){return this.hasOwnProperty("__attributes")||(this.__attributes=new Bx(this)),this.__attributes}__initializeAttributes(e){if(e||this.__attributesRaw){for(const e in this.__scriptType.attributes.index)this.__attributesRaw&&this.__attributesRaw.hasOwnProperty(e)?this[e]=this.__attributesRaw[e]:this.__attributes.hasOwnProperty(e)||(this.__scriptType.attributes.index[e].hasOwnProperty("default")?this[e]=this.__scriptType.attributes.index[e].default:this[e]=null);this.__attributesRaw=null}}static extend(e){for(const t in e)e.hasOwnProperty(t)&&(this.prototype[t]=e[t])}}Hx.__name=null;class Wx extends Qp{constructor(e){super(),this.app=e,this._scripts={},this._list=[]}destroy(){this.app=null,this.off()}add(e){const t=e.__name;return this._scripts.hasOwnProperty(t)?(setTimeout((()=>{if(e.prototype.swap){const n=this._scripts[t],a=this._list.indexOf(n);this._list[a]=e,this._scripts[t]=e,this.fire("swap",t,e),this.fire("swap:"+t,e)}else console.warn(`script registry already has '${t}' script, define 'swap' method for new script type to enable code hot swapping`)})),!1):(this._scripts[t]=e,this._list.push(e),this.fire("add",t,e),this.fire("add:"+t,e),setTimeout((()=>{if(!this._scripts.hasOwnProperty(t))return;if(!this.app||!this.app.systems||!this.app.systems.script)return;const e=this.app.systems.script._components;let n;const a=[],i=[];for(e.loopIndex=0;e.loopIndex<e.length;e.loopIndex++){const i=e.items[e.loopIndex];if(i._scriptsIndex[t]&&i._scriptsIndex[t].awaiting){i._scriptsData&&i._scriptsData[t]&&(n=i._scriptsData[t].attributes);const e=i.create(t,{preloading:!0,ind:i._scriptsIndex[t].ind,attributes:n});e&&a.push(e)}}for(let e=0;e<a.length;e++)a[e].__initializeAttributes();for(let e=0;e<a.length;e++)a[e].enabled&&(a[e]._initialized=!0,i.push(a[e]),a[e].initialize&&a[e].initialize());for(let e=0;e<i.length;e++)i[e].enabled&&!i[e]._postInitialized&&(i[e]._postInitialized=!0,i[e].postInitialize&&i[e].postInitialize())})),!0)}remove(e){let t=e,n=e;if("string"!=typeof n?n=t.__name:t=this.get(n),this.get(n)!==t)return!1;delete this._scripts[n];const a=this._list.indexOf(t);return this._list.splice(a,1),this.fire("remove",n,t),this.fire("remove:"+n,t),!0}get(e){return this._scripts[e]||null}has(e){if("string"==typeof e)return this._scripts.hasOwnProperty(e);if(!e)return!1;const t=e.__name;return this._scripts[t]===e}list(){return this._list}}class jx{_validate(e){if(!e.header)throw new Error('pc.I18n#addData: Missing "header" field');if(!e.header.version)throw new Error('pc.I18n#addData: Missing "header.version" field');if(1!==e.header.version)throw new Error('pc.I18n#addData: Invalid "header.version" field');if(!e.data)throw new Error('pc.I18n#addData: Missing "data" field');if(!Array.isArray(e.data))throw new Error('pc.I18n#addData: "data" field must be an array');for(let t=0,n=e.data.length;t<n;t++){const n=e.data[t];if(!n.info)throw new Error(`pc.I18n#addData: missing "data[${t}].info" field`);if(!n.info.locale)throw new Error(`pc.I18n#addData: missing "data[${t}].info.locale" field`);if("string"!=typeof n.info.locale)throw new Error(`pc.I18n#addData: "data[${t}].info.locale" must be a string`);if(!n.messages)throw new Error(`pc.I18n#addData: missing "data[${t}].messages" field`)}}parse(e){return e.data}}class Xx extends Qp{constructor(e){super(),this.locale="en-US",this._translations={},this._availableLangs={},this._app=e,this._assets=[],this._parser=new jx}set assets(e){const t={};for(let n=0,a=e.length;n<a;n++){t[e[n]instanceof f_?e[n].id:e[n]]=!0}let n=this._assets.length;for(;n--;){const e=this._assets[n];if(!t[e]){this._app.assets.off("add:"+e,this._onAssetAdd,this);const t=this._app.assets.get(e);t&&this._onAssetRemove(t),this._assets.splice(n,1)}}for(const e in t){const t=parseInt(e,10);if(-1!==this._assets.indexOf(t))continue;this._assets.push(t);const n=this._app.assets.get(t);n?this._onAssetAdd(n):this._app.assets.once("add:"+t,this._onAssetAdd,this)}}get assets(){return this._assets}set locale(e){if(this._locale===e)return;let t=r_(e);if("in"===t&&(t="id",e=function(e,t){const n=e.indexOf("-");return-1!==n?t+e.substring(n):t}(e,t),this._locale===e))return;const n=this._locale;this._locale=e,this._lang=t,this._pluralFn=c_(this._lang),this.fire("set:locale",e,n)}get locale(){return this._locale}static findAvailableLocale(e,t){return o_(e,t)}findAvailableLocale(e){if(this._translations[e])return e;const t=r_(e);return this._findFallbackLocale(e,t)}getText(e,t){let n,a=e;t||(t=this._locale,n=this._lang);let i=this._translations[t];return i||(n||(n=r_(t)),t=this._findFallbackLocale(t,n),i=this._translations[t]),i&&i.hasOwnProperty(e)&&(a=i[e],Array.isArray(a)&&(a=a[0]),null==a&&(a=e)),a}getPluralText(e,t,n){let a,i,s=e;n?(a=r_(n),i=c_(a)):(n=this._locale,a=this._lang,i=this._pluralFn);let r=this._translations[n];if(r||(a=r_(n=this._findFallbackLocale(n,a)),i=c_(a),r=this._translations[n]),r&&r[e]&&i){const n=i(t);s=r[e][n],null==s&&(s=e)}return s}addData(e){let t;try{t=this._parser.parse(e)}catch(e){return void console.error(e)}for(let e=0,n=t.length;e<n;e++){const n=t[e],a=n.info.locale,i=n.messages;if(!this._translations[a]){this._translations[a]={};const e=r_(a);this._availableLangs[e]||(this._availableLangs[e]=a)}Object.assign(this._translations[a],i),this.fire("data:add",a,i)}}removeData(e){let t;try{t=this._parser.parse(e)}catch(e){return void console.error(e)}for(let e=0,n=t.length;e<n;e++){const n=t[e],a=n.info.locale,i=this._translations[a];if(!i)continue;const s=n.messages;for(const e in s)delete i[e];0===Object.keys(i).length&&(delete this._translations[a],delete this._availableLangs[r_(a)]),this.fire("data:remove",a,s)}}destroy(){this._translations=null,this._availableLangs=null,this._assets=null,this._parser=null,this.off()}_findFallbackLocale(e,t){let n=a_[e];return n&&this._translations[n]?n:(n=a_[t],n&&this._translations[n]?n:(n=this._availableLangs[t],n&&this._translations[n]?n:"en-US"))}_onAssetAdd(e){e.on("load",this._onAssetLoad,this),e.on("change",this._onAssetChange,this),e.on("remove",this._onAssetRemove,this),e.on("unload",this._onAssetUnload,this),e.resource&&this._onAssetLoad(e)}_onAssetLoad(e){this.addData(e.resource)}_onAssetChange(e){e.resource&&this.addData(e.resource)}_onAssetRemove(e){e.off("load",this._onAssetLoad,this),e.off("change",this._onAssetChange,this),e.off("remove",this._onAssetRemove,this),e.off("unload",this._onAssetUnload,this),e.resource&&this.removeData(e.resource),this._app.assets.once("add:"+e.id,this._onAssetAdd,this)}_onAssetUnload(e){e.resource&&this.removeData(e.resource)}}class Yx extends Qp{constructor(e,t){super(),this.id=void 0,this.display=void 0,this.presenting=!1,this._app=e,this._device=e.graphicsDevice,this.id=t.displayId,this._frameData=null,window.VRFrameData&&(this._frameData=new window.VRFrameData),this.display=t,this._camera=null,this.sitToStandInv=new zu,this.leftView=new zu,this.leftProj=new zu,this.leftViewInv=new zu,this.leftPos=new Pu,this.rightView=new zu,this.rightProj=new zu,this.rightViewInv=new zu,this.rightPos=new Pu,this.combinedPos=new Pu,this.combinedView=new zu,this.combinedProj=new zu,this.combinedViewInv=new zu,this.combinedFov=0,this.combinedAspect=0,this._presentChange=e=>{let t;if(t=e.display?e.display:e.detail&&e.detail.display?e.detail.display:e.detail&&e.detail.vrdisplay?e.detail.vrdisplay:this.display,t===this.display){if(this.presenting=this.display&&this.display.isPresenting,this.presenting){const e=this.display.getEyeParameters("left"),t=this.display.getEyeParameters("right"),n=2*Math.max(e.renderWidth,t.renderWidth),a=Math.max(e.renderHeight,t.renderHeight);this._app.graphicsDevice.setResolution(n,a),this._app._allowResize=!1}else this._app.setCanvasResolution("AUTO"),this._app._allowResize=!0;this.fire("beforepresentchange",this),this.fire("presentchange",this)}},window.addEventListener("vrdisplaypresentchange",this._presentChange,!1)}destroy(){window.removeEventListener("vrdisplaypresentchange",this._presentChange),this._camera&&(this._camera.vrDisplay=null),this._camera=null}poll(){if(this.display){this.display.getFrameData(this._frameData),this.leftProj.data=this._frameData.leftProjectionMatrix,this.rightProj.data=this._frameData.rightProjectionMatrix;const e=this.display.stageParameters;e?(this.sitToStandInv.set(e.sittingToStandingTransform).invert(),this.combinedView.set(this._frameData.leftViewMatrix),this.leftView.mul2(this.combinedView,this.sitToStandInv),this.combinedView.set(this._frameData.rightViewMatrix),this.rightView.mul2(this.combinedView,this.sitToStandInv)):(this.leftView.set(this._frameData.leftViewMatrix),this.rightView.set(this._frameData.rightViewMatrix));let t=this.leftProj.data[3]+this.leftProj.data[0],n=this.leftProj.data[11]+this.leftProj.data[8],a=1/Math.sqrt(t*t+n*n);t*=a,n*=a;let i=-Math.atan2(n,t);t=this.rightProj.data[3]+this.rightProj.data[0],n=this.rightProj.data[11]+this.rightProj.data[8],a=1/Math.sqrt(t*t+n*n),t*=a,n*=a,i=Math.max(i,-Math.atan2(n,t)),i*=2,this.combinedFov=i;const s=this.rightProj.data[5]/this.rightProj.data[0];this.combinedAspect=s;const r=this.combinedView;r.copy(this.leftView),r.invert(),this.leftViewInv.copy(r);const o=this.combinedPos;o.x=this.leftPos.x=r.data[12],o.y=this.leftPos.y=r.data[13],o.z=this.leftPos.z=r.data[14],r.copy(this.rightView),r.invert(),this.rightViewInv.copy(r);const l=o.x-r.data[12],c=o.y-r.data[13],h=o.z-r.data[14],d=Math.sqrt(l*l+c*c+h*h);this.rightPos.x=r.data[12],this.rightPos.y=r.data[13],this.rightPos.z=r.data[14],o.x+=r.data[12],o.y+=r.data[13],o.z+=r.data[14],o.x*=.5,o.y*=.5,o.z*=.5;const p=.5*Math.PI,u=.5*i,m=Math.PI-(p+u),f=.5*d*Math.sin(m),g=r.data[8],y=r.data[9],b=r.data[10];r.data[12]=o.x+g*f,r.data[13]=o.y+y*f,r.data[14]=o.z+b*f,this.combinedViewInv.copy(r),r.invert(),this.combinedProj.setPerspective(i*Eu.RAD_TO_DEG,s,this.display.depthNear+f,this.display.depthFar+f,!0)}}requestPresent(e){this.display?this.presenting?e&&e(new Error("VrDisplay already presenting")):this.display.requestPresent([{source:this._device.canvas}]).then((function(){e&&e()}),(function(t){e&&e(t)})):e&&e(new Error("No VrDisplay to requestPresent"))}exitPresent(e){this.display||e&&e(new Error("No VrDisplay to exitPresent")),this.presenting?this.display.exitPresent().then((function(){e&&e()}),(function(){e&&e(new Error("exitPresent failed"))})):e&&e(new Error("VrDisplay not presenting"))}requestAnimationFrame(e){this.display&&this.display.requestAnimationFrame(e)}submitFrame(){this.display&&this.display.submitFrame()}reset(){this.display&&this.display.resetPose()}setClipPlanes(e,t){this.display&&(this.display.depthNear=e,this.display.depthFar=t)}getFrameData(){if(this.display)return this._frameData}get capabilities(){return this.display?this.display.capabilities:{}}}class qx extends Qp{constructor(e){super(),this.displays=[],this.display=null,this.isSupported=void 0,this._index={},this._app=e,this.isSupported=qx.isSupported,this._onDisplayConnect=this._onDisplayConnect.bind(this),this._onDisplayDisconnect=this._onDisplayDisconnect.bind(this),this._attach(),this._getDisplays(((e,t)=>{if(e)this.fire("error",e);else{for(let e=0;e<t.length;e++)this._addDisplay(t[e]);this.fire("ready",this.displays)}}))}_attach(){window.addEventListener("vrdisplayconnect",this._onDisplayConnect),window.addEventListener("vrdisplaydisconnect",this._onDisplayDisconnect)}_detach(){window.removeEventListener("vrdisplayconnect",this._onDisplayConnect),window.removeEventListener("vrdisplaydisconnect",this._onDisplayDisconnect)}destroy(){this._detach()}poll(){const e=this.displays.length;if(e)for(let t=0;t<e;t++)this.displays[t]._camera&&this.displays[t].poll()}_getDisplays(e){navigator.getVRDisplays?navigator.getVRDisplays().then((function(t){e&&e(null,t)})):e&&e(new Error("WebVR not supported"))}_addDisplay(e){if(this._index[e.displayId])return;const t=new Yx(this._app,e);this._index[t.id]=t,this.displays.push(t),this.display||(this.display=t),this.fire("displayconnect",t)}_onDisplayConnect(e){e.detail&&e.detail.display?this._addDisplay(e.detail.display):this._addDisplay(e.display)}_onDisplayDisconnect(e){let t;t=e.detail&&e.detail.display?e.detail.display.displayId:e.display.displayId;const n=this._index[t];if(!n)return;n.destroy(),delete this._index[n.id];const a=this.displays.indexOf(n);this.displays.splice(a,1),this.display===n&&(this.displays.length?this.display=this.displays[0]:this.display=null),this.fire("displaydisconnect",n)}}qx.isSupported="undefined"!=typeof navigator&&!!navigator.getVRDisplays;const Kx="immersive-vr",Zx="immersive-ar",$x=[],Qx=[];class Jx extends Qp{constructor(e,t,n){super(),this.manager=void 0,this._xrHitTestSource=void 0,this._transient=void 0,this.manager=e,this._xrHitTestSource=t,this._transient=n}remove(){if(!this._xrHitTestSource)return;const e=this.manager.hitTest.sources,t=e.indexOf(this);-1!==t&&e.splice(t,1),this.onStop()}onStop(){this._xrHitTestSource.cancel(),this._xrHitTestSource=null,this.fire("remove"),this.manager.hitTest.fire("remove",this)}update(e){if(this._transient){const t=e.getHitTestResultsForTransientInput(this._xrHitTestSource);for(let e=0;e<t.length;e++){const n=t[e];let a;n.inputSource&&(a=this.manager.input._getByInputSource(n.inputSource)),this.updateHitResults(n.results,a)}}else this.updateHitResults(e.getHitTestResults(this._xrHitTestSource))}updateHitResults(e,t){for(let n=0;n<e.length;n++){const a=e[n].getPose(this.manager._referenceSpace);let i=$x.pop();i||(i=new Pu),i.copy(a.transform.position);let s=Qx.pop();s||(s=new Gu),s.copy(a.transform.orientation),this.fire("result",i,s,t),this.manager.hitTest.fire("result",this,i,s,t),$x.push(i),Qx.push(s)}}}class eC extends Qp{constructor(e){super(),this.manager=void 0,this._supported=uu.browser&&!(!window.XRSession||!window.XRSession.prototype.requestHitTestSource),this._session=null,this.sources=[],this.manager=e,this._supported&&(this.manager.on("start",this._onSessionStart,this),this.manager.on("end",this._onSessionEnd,this))}_onSessionStart(){this.manager.type===Zx&&(this._session=this.manager.session)}_onSessionEnd(){if(this._session){this._session=null;for(let e=0;e<this.sources.length;e++)this.sources[e].onStop();this.sources=[]}}isAvailable(e,t){let n;return this._supported||(n=new Error("XR HitTest is not supported")),this._session||(n=new Error("XR Session is not started (1)")),this.manager.type!==Zx&&(n=new Error("XR HitTest is available only for AR")),!n||(e&&e(n),t&&t.fire("error",n),!1)}start(e={}){if(!this.isAvailable(e.callback,this))return;let t;e.profile||e.spaceType||(e.spaceType="viewer");const n=e.offsetRay;n&&(t=new XRRay(new DOMPoint(n.origin.x,n.origin.y,n.origin.z),new DOMPoint(n.direction.x,n.direction.y,n.direction.z)));const a=e.callback;e.spaceType?this._session.requestReferenceSpace(e.spaceType).then((n=>{if(!this._session){const e=new Error("XR Session is not started (2)");return a&&a(e),void this.fire("error",e)}this._session.requestHitTestSource({space:n,entityTypes:e.entityTypes||void 0,offsetRay:t}).then((e=>{this._onHitTestSource(e,!1,a)})).catch((e=>{a&&a(e),this.fire("error",e)}))})).catch((e=>{a&&a(e),this.fire("error",e)})):this._session.requestHitTestSourceForTransientInput({profile:e.profile,entityTypes:e.entityTypes||void 0,offsetRay:t}).then((e=>{this._onHitTestSource(e,!0,a)})).catch((e=>{a&&a(e),this.fire("error",e)}))}_onHitTestSource(e,t,n){if(!this._session){e.cancel();const t=new Error("XR Session is not started (3)");return n&&n(t),void this.fire("error",t)}const a=new Jx(this.manager,e,t);this.sources.push(a),n&&n(null,a),this.fire("add",a)}update(e){for(let t=0;t<this.sources.length;t++)this.sources[t].update(e)}get supported(){return this._supported}}class tC{constructor(e,t){this._index=void 0,this._hand=void 0,this._joints=[],this._tip=null,this._index=e,this._hand=t,this._hand._fingers.push(this)}get index(){return this._index}get hand(){return this._hand}get joints(){return this._joints}get tip(){return this._tip}}const nC=uu.browser&&window.XRHand?["thumb-tip","index-finger-tip","middle-finger-tip","ring-finger-tip","pinky-finger-tip"]:[],aC={};for(let e=0;e<nC.length;e++)aC[nC[e]]=!0;class iC{constructor(e,t,n,a=null){this._index=void 0,this._id=void 0,this._hand=void 0,this._finger=void 0,this._wrist=void 0,this._tip=void 0,this._radius=null,this._localTransform=new zu,this._worldTransform=new zu,this._localPosition=new Pu,this._localRotation=new Gu,this._position=new Pu,this._rotation=new Gu,this._dirtyLocal=!0,this._index=e,this._id=t,this._hand=n,this._finger=a,this._wrist="wrist"===t,this._tip=this._finger&&!!aC[t]}update(e){this._dirtyLocal=!0,this._radius=e.radius,this._localPosition.copy(e.transform.position),this._localRotation.copy(e.transform.orientation)}_updateTransforms(){this._dirtyLocal&&(this._dirtyLocal=!1,this._localTransform.setTRS(this._localPosition,this._localRotation,Pu.ONE));const e=this._hand._manager.camera.parent;e?this._worldTransform.mul2(e.getWorldTransform(),this._localTransform):this._worldTransform.copy(this._localTransform)}getPosition(){return this._updateTransforms(),this._worldTransform.getTranslation(this._position),this._position}getRotation(){return this._updateTransforms(),this._rotation.setFromMat4(this._worldTransform),this._rotation}get index(){return this._index}get hand(){return this._hand}get finger(){return this._finger}get wrist(){return this._wrist}get tip(){return this._tip}get radius(){return this._radius||.005}}let sC=[];const rC=new Pu,oC=new Pu,lC=new Pu;uu.browser&&window.XRHand&&(sC=[["thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip"],["index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip"],["middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip"],["ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip"],["pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"]]);class cC extends Qp{constructor(e){super(),this._manager=void 0,this._inputSource=void 0,this._tracking=!1,this._fingers=[],this._joints=[],this._jointsById={},this._tips=[],this._wrist=null;const t=e._xrInputSource.hand;if(this._manager=e._manager,this._inputSource=e,t.get("wrist")){const e=new iC(0,"wrist",this,null);this._wrist=e,this._joints.push(e),this._jointsById.wrist=e}for(let e=0;e<sC.length;e++){const n=new tC(e,this);for(let a=0;a<sC[e].length;a++){const i=sC[e][a];if(!t.get(i))continue;const s=new iC(a,i,this,n);this._joints.push(s),this._jointsById[i]=s,s.tip&&(this._tips.push(s),n._tip=s),n._joints.push(s)}}}update(e){const t=this._inputSource._xrInputSource;for(let n=0;n<this._joints.length;n++){const a=this._joints[n],i=t.hand.get(a._id);if(i){let t;if("hidden"!==e.session.visibilityState&&(t=e.getJointPose(i,this._manager._referenceSpace)),t)a.update(t),a.wrist&&!this._tracking&&(this._tracking=!0,this.fire("tracking"));else if(a.wrist){this._tracking&&(this._tracking=!1,this.fire("trackinglost"));break}}}const n=this._jointsById["thumb-metacarpal"],a=this._jointsById["thumb-tip"],i=this._jointsById["index-finger-phalanx-proximal"],s=this._jointsById["index-finger-tip"],r=this._jointsById["ring-finger-phalanx-proximal"],o=this._jointsById["pinky-finger-phalanx-proximal"];if(n&&a&&i&&s&&r&&o){this._inputSource._dirtyRay=!0,this._inputSource._rayLocal.origin.lerp(a._localPosition,s._localPosition,.5);let e=n,t=o;if("left"===this._inputSource.handedness){const n=e;e=t,t=n}rC.sub2(e._localPosition,this._wrist._localPosition),oC.sub2(t._localPosition,this._wrist._localPosition),lC.cross(rC,oC).normalize(),rC.lerp(i._localPosition,r._localPosition,.5),rC.sub(this._wrist._localPosition).normalize(),this._inputSource._rayLocal.direction.lerp(lC,rC,.5).normalize()}this._fingerIsClosed(1)&&this._fingerIsClosed(2)&&this._fingerIsClosed(3)&&this._fingerIsClosed(4)?this._inputSource._squeezing||(this._inputSource._squeezing=!0,this._inputSource.fire("squeezestart"),this._manager.input.fire("squeezestart",this._inputSource)):this._inputSource._squeezing&&(this._inputSource._squeezing=!1,this._inputSource.fire("squeeze"),this._manager.input.fire("squeeze",this._inputSource),this._inputSource.fire("squeezeend"),this._manager.input.fire("squeezeend",this._inputSource))}_fingerIsClosed(e){const t=this._fingers[e];return rC.sub2(t.joints[0]._localPosition,t.joints[1]._localPosition).normalize(),oC.sub2(t.joints[2]._localPosition,t.joints[3]._localPosition).normalize(),rC.dot(oC)<-.8}getJointById(e){return this._jointsById[e]||null}get fingers(){return this._fingers}get joints(){return this._joints}get tips(){return this._tips}get wrist(){return this._wrist}get tracking(){return this._tracking}}const hC=new Gu;let dC=0;class pC extends Qp{constructor(e,t){super(),this._id=void 0,this._manager=void 0,this._xrInputSource=void 0,this._ray=new tm,this._rayLocal=new tm,this._grip=!1,this._hand=null,this._localTransform=null,this._worldTransform=null,this._position=new Pu,this._rotation=new Gu,this._localPosition=null,this._localRotation=null,this._dirtyLocal=!0,this._dirtyRay=!1,this._selecting=!1,this._squeezing=!1,this._elementInput=!0,this._elementEntity=null,this._hitTestSources=[],this._id=++dC,this._manager=e,this._xrInputSource=t,t.hand&&(this._hand=new cC(this))}get id(){return this._id}get inputSource(){return this._xrInputSource}get targetRayMode(){return this._xrInputSource.targetRayMode}get handedness(){return this._xrInputSource.handedness}get profiles(){return this._xrInputSource.profiles}get grip(){return this._grip}get hand(){return this._hand}get gamepad(){return this._xrInputSource.gamepad||null}get selecting(){return this._selecting}get squeezing(){return this._squeezing}set elementInput(e){this._elementInput!==e&&(this._elementInput=e,this._elementInput||(this._elementEntity=null))}get elementInput(){return this._elementInput}get elementEntity(){return this._elementEntity}get hitTestSources(){return this._hitTestSources}update(e){if(this._hand)this._hand.update(e);else{if(this._xrInputSource.gripSpace){const t=e.getPose(this._xrInputSource.gripSpace,this._manager._referenceSpace);t&&(this._grip||(this._grip=!0,this._localTransform=new zu,this._worldTransform=new zu,this._localPosition=new Pu,this._localRotation=new Gu),this._dirtyLocal=!0,this._localPosition.copy(t.transform.position),this._localRotation.copy(t.transform.orientation))}const t=e.getPose(this._xrInputSource.targetRaySpace,this._manager._referenceSpace);t&&(this._dirtyRay=!0,this._rayLocal.origin.copy(t.transform.position),this._rayLocal.direction.set(0,0,-1),hC.copy(t.transform.orientation),hC.transformVector(this._rayLocal.direction,this._rayLocal.direction))}}_updateTransforms(){this._dirtyLocal&&(this._dirtyLocal=!1,this._localTransform.setTRS(this._localPosition,this._localRotation,Pu.ONE));const e=this._manager.camera.parent;e?this._worldTransform.mul2(e.getWorldTransform(),this._localTransform):this._worldTransform.copy(this._localTransform)}_updateRayTransforms(){const e=this._dirtyRay;this._dirtyRay=!1;if(this._manager.camera.parent){const e=this._manager.camera.parent.getWorldTransform();e.getTranslation(this._position),this._rotation.setFromMat4(e),this._rotation.transformVector(this._rayLocal.origin,this._ray.origin),this._ray.origin.add(this._position),this._rotation.transformVector(this._rayLocal.direction,this._ray.direction)}else e&&(this._ray.origin.copy(this._rayLocal.origin),this._ray.direction.copy(this._rayLocal.direction))}getPosition(){return this._position?(this._updateTransforms(),this._worldTransform.getTranslation(this._position),this._position):null}getLocalPosition(){return this._localPosition}getRotation(){return this._rotation?(this._updateTransforms(),this._rotation.setFromMat4(this._worldTransform),this._rotation):null}getLocalRotation(){return this._localRotation}getOrigin(){return this._updateRayTransforms(),this._ray.origin}getDirection(){return this._updateRayTransforms(),this._ray.direction}hitTestStart(e={}){e.profile=this._xrInputSource.profiles[0];const t=e.callback;e.callback=(e,n)=>{n&&this.onHitTestSourceAdd(n),t&&t(e,n)},this._manager.hitTest.start(e)}onHitTestSourceAdd(e){this._hitTestSources.push(e),this.fire("hittest:add",e),e.on("result",(function(t,n,a){a===this&&this.fire("hittest:result",e,t,n)}),this),e.once("remove",(function(){this.onHitTestSourceRemove(e),this.fire("hittest:remove",e)}),this)}onHitTestSourceRemove(e){const t=this._hitTestSources.indexOf(e);-1!==t&&this._hitTestSources.splice(t,1)}}class uC extends Qp{constructor(e){super(),this.manager=void 0,this._inputSources=[],this._onInputSourcesChangeEvt=void 0,this.manager=e,this._onInputSourcesChangeEvt=e=>{this._onInputSourcesChange(e)},this.manager.on("start",this._onSessionStart,this),this.manager.on("end",this._onSessionEnd,this)}_onSessionStart(){const e=this.manager.session;e.addEventListener("inputsourceschange",this._onInputSourcesChangeEvt),e.addEventListener("select",(e=>{const t=this._getByInputSource(e.inputSource);t.update(e.frame),t.fire("select",e),this.fire("select",t,e)})),e.addEventListener("selectstart",(e=>{const t=this._getByInputSource(e.inputSource);t.update(e.frame),t._selecting=!0,t.fire("selectstart",e),this.fire("selectstart",t,e)})),e.addEventListener("selectend",(e=>{const t=this._getByInputSource(e.inputSource);t.update(e.frame),t._selecting=!1,t.fire("selectend",e),this.fire("selectend",t,e)})),e.addEventListener("squeeze",(e=>{const t=this._getByInputSource(e.inputSource);t.update(e.frame),t.fire("squeeze",e),this.fire("squeeze",t,e)})),e.addEventListener("squeezestart",(e=>{const t=this._getByInputSource(e.inputSource);t.update(e.frame),t._squeezing=!0,t.fire("squeezestart",e),this.fire("squeezestart",t,e)})),e.addEventListener("squeezeend",(e=>{const t=this._getByInputSource(e.inputSource);t.update(e.frame),t._squeezing=!1,t.fire("squeezeend",e),this.fire("squeezeend",t,e)}));const t=e.inputSources;for(let e=0;e<t.length;e++)this._addInputSource(t[e])}_onSessionEnd(){let e=this._inputSources.length;for(;e--;){const t=this._inputSources[e];this._inputSources.splice(e,1),t.fire("remove"),this.fire("remove",t)}this.manager.session.removeEventListener("inputsourceschange",this._onInputSourcesChangeEvt)}_onInputSourcesChange(e){for(let t=0;t<e.removed.length;t++)this._removeInputSource(e.removed[t]);for(let t=0;t<e.added.length;t++)this._addInputSource(e.added[t])}_getByInputSource(e){for(let t=0;t<this._inputSources.length;t++)if(this._inputSources[t].inputSource===e)return this._inputSources[t];return null}_addInputSource(e){if(this._getByInputSource(e))return;const t=new pC(this.manager,e);this._inputSources.push(t),this.fire("add",t)}_removeInputSource(e){for(let t=0;t<this._inputSources.length;t++){if(this._inputSources[t].inputSource!==e)continue;const n=this._inputSources[t];this._inputSources.splice(t,1);let a=n.hitTestSources.length;for(;a--;)n.hitTestSources[a].remove();return n.fire("remove"),void this.fire("remove",n)}}update(e){for(let t=0;t<this._inputSources.length;t++)this._inputSources[t].update(e)}get inputSources(){return this._inputSources}}const mC=new Pu,fC=new Pu,gC=new zu,yC=new zu;class bC extends Qp{constructor(e){super(),this._manager=void 0,this._supported=!1,this._available=!1,this._lightProbeRequested=!1,this._lightProbe=null,this._intensity=0,this._rotation=new Gu,this._color=new Mu,this._sphericalHarmonics=new Float32Array(27),this._manager=e,this._manager.on("start",this._onSessionStart,this),this._manager.on("end",this._onSessionEnd,this)}_onSessionStart(){!!this._manager.session.requestLightProbe&&(this._supported=!0)}_onSessionEnd(){this._supported=!1,this._available=!1,this._lightProbeRequested=!1,this._lightProbe=null}start(){let e;this._manager.session||(e=new Error("XR session is not running")),e||this._manager.type===Zx||(e=new Error("XR session type is not AR")),e||this._supported||(e=new Error("light-estimation is not supported")),(!e&&this._lightProbe||this._lightProbeRequested)&&(e=new Error("light estimation is already requested")),e?this.fire("error",e):(this._lightProbeRequested=!0,this._manager.session.requestLightProbe().then((e=>{const t=this._lightProbeRequested;this._lightProbeRequested=!1,this._manager.active?t&&(this._lightProbe=e):this.fire("error",new Error("XR session is not active"))})).catch((e=>{this._lightProbeRequested=!1,this.fire("error",e)})))}end(){this._lightProbeRequested=!1,this._lightProbe=null,this._available=!1}update(e){if(!this._lightProbe)return;const t=e.getLightEstimate(this._lightProbe);if(!t)return;this._available||(this._available=!0,this.fire("available"));const n=t.primaryLightIntensity;this._intensity=Math.max(1,Math.max(n.x,Math.max(n.y,n.z))),mC.copy(n).mulScalar(1/this._intensity),this._color.set(mC.x,mC.y,mC.z),mC.set(0,0,0),fC.copy(t.primaryLightDirection),gC.setLookAt(fC,mC,Pu.UP),yC.setFromAxisAngle(Pu.RIGHT,90),gC.mul(yC),this._rotation.setFromMat4(gC),this._sphericalHarmonics.set(t.sphericalHarmonicsCoefficients)}get supported(){return this._supported}get available(){return this._available}get intensity(){return this._available?this._intensity:null}get color(){return this._available?this._color:null}get rotation(){return this._available?this._rotation:null}get sphericalHarmonics(){return this._available?this._sphericalHarmonics:null}}class vC extends Qp{constructor(e,t){super(),this._image=void 0,this._width=void 0,this._bitmap=null,this._measuredWidth=0,this._trackable=!1,this._tracking=!1,this._emulated=!1,this._pose=null,this._position=new Pu,this._rotation=new Gu,this._image=e,this._width=t}get image(){return this._image}set width(e){this._width=e}get width(){return this._width}get trackable(){return this._trackable}get tracking(){return this._tracking}get emulated(){return this._emulated}prepare(){return this._bitmap?{image:this._bitmap,widthInMeters:this._width}:createImageBitmap(this._image).then((e=>(this._bitmap=e,{image:this._bitmap,widthInMeters:this._width})))}destroy(){this._image=null,this._pose=null,this._bitmap&&(this._bitmap.close(),this._bitmap=null)}getPosition(){return this._pose&&this._position.copy(this._pose.transform.position),this._position}getRotation(){return this._pose&&this._rotation.copy(this._pose.transform.orientation),this._rotation}}class _C extends Qp{constructor(e){super(),this._manager=void 0,this._supported=uu.browser&&!!window.XRImageTrackingResult,this._available=!1,this._images=[],this._manager=e,this._supported&&(this._manager.on("start",this._onSessionStart,this),this._manager.on("end",this._onSessionEnd,this))}add(e,t){if(!this._supported||this._manager.active)return null;const n=new vC(e,t);return this._images.push(n),n}remove(e){if(this._manager.active)return;const t=this._images.indexOf(e);-1!==t&&(e.destroy(),this._images.splice(t,1))}_onSessionStart(){this._manager.session.getTrackedImageScores().then((e=>{this._available=!0;for(let t=0;t<e.length;t++)this._images[t]._trackable="trackable"===e[t]})).catch((e=>{this._available=!1,this.fire("error",e)}))}_onSessionEnd(){this._available=!1;for(let e=0;e<this._images.length;e++){const t=this._images[e];t._pose=null,t._measuredWidth=0,t._tracking&&(t._tracking=!1,t.fire("untracked"))}}prepareImages(e){this._images.length?Promise.all(this._images.map((function(e){return e.prepare()}))).then((function(t){e(null,t)})).catch((function(t){e(t,null)})):e(null,null)}update(e){if(!this._available)return;const t=e.getImageTrackingResults(),n={};for(let a=0;a<t.length;a++){n[t[a].index]=t[a];const i=this._images[t[a].index];i._emulated="emulated"===t[a].trackingState,i._measuredWidth=t[a].measuredWidthInMeters,i._pose=e.getPose(t[a].imageSpace,this._manager._referenceSpace)}for(let e=0;e<this._images.length;e++)this._images[e]._tracking&&!n[e]?(this._images[e]._tracking=!1,this._images[e].fire("untracked")):!this._images[e]._tracking&&n[e]&&(this._images[e]._tracking=!0,this._images[e].fire("tracked"))}get supported(){return this._supported}get available(){return this._available}get images(){return this._images}}class wC{constructor(e){this._manager=void 0,this._supported=uu.browser&&!!window.XRDOMOverlayState,this._root=null,this._manager=e}get supported(){return this._supported}get available(){return this._supported&&this._manager.active&&null!==this._manager._session.domOverlayState}get state(){return this._supported&&this._manager.active&&this._manager._session.domOverlayState?this._manager._session.domOverlayState.type:null}set root(e){this._supported&&!this._manager.active&&(this._root=e)}get root(){return this._root}}class xC extends Qp{constructor(e){super(),this._manager=void 0,this._available=!1,this._depthInfoCpu=null,this._depthInfoGpu=null,this._usage=null,this._dataFormat=null,this._matrixDirty=!1,this._matrix=new zu,this._emptyBuffer=new Uint8Array(32),this._depthBuffer=null,this._texture=void 0,this._manager=e,this._texture=new Gm(this._manager.app.graphicsDevice,{format:2,mipmaps:!1,addressU:1,addressV:1,minFilter:1,magFilter:1}),this.supported&&(this._manager.on("start",this._onSessionStart,this),this._manager.on("end",this._onSessionEnd,this))}_onSessionStart(){const e=this._manager.session;try{this._usage=e.depthUsage,this._dataFormat=e.depthDataFormat}catch(e){this._usage=null,this._dataFormat=null,this._available=!1,this.fire("error",e)}}_onSessionEnd(){this._depthInfoCpu=null,this._depthInfoGpu=null,this._usage=null,this._dataFormat=null,this._available&&(this._available=!1,this.fire("unavailable")),this._depthBuffer=null,this._texture._width=4,this._texture._height=4,this._texture._levels[0]=this._emptyBuffer,this._texture.upload()}_updateTexture(){const e=this._depthInfoCpu||this._depthInfoGpu;if(e){let t=!1;if(e.width===this._texture.width&&e.height===this._texture.height||(this._texture._width=e.width,this._texture._height=e.height,this._matrixDirty=!0,t=!0),this._depthInfoCpu){const e=this._depthInfoCpu.data;this._depthBuffer=new Uint8Array(e),this._texture._levels[0]=this._depthBuffer,this._texture.upload()}else this._depthInfoGpu&&(this._texture._levels[0]=this._depthInfoGpu.texture,this._texture.upload());t&&this.fire("resize",e.width,e.height)}else this._depthBuffer&&(this._depthBuffer=null,this._texture._width=4,this._texture._height=4,this._texture._levels[0]=this._emptyBuffer,this._texture.upload())}update(e,t){if(!this._usage)return;let n=null,a=null;if("cpu-optimized"===this._usage&&t?n=e.getDepthInformation(t):"gpu-optimized"===this._usage&&t&&(a=e.getDepthInformation(t)),(this._depthInfoCpu&&!n||!this._depthInfoCpu&&n||this.depthInfoGpu&&!a||!this._depthInfoGpu&&a)&&(this._matrixDirty=!0),this._depthInfoCpu=n,this._depthInfoGpu=a,this._updateTexture(),this._matrixDirty){this._matrixDirty=!1;const e=this._depthInfoCpu||this._depthInfoGpu;e?this._matrix.data.set(e.normDepthBufferFromNormView.matrix):this._matrix.setIdentity()}!this._depthInfoCpu&&!this._depthInfoGpu||this._available?this._depthInfoCpu||this._depthInfoGpu||!this._available||(this._available=!1,this.fire("unavailable")):(this._available=!0,this.fire("available"))}getDepth(e,t){return this._depthInfoCpu?this._depthInfoCpu.getDepthInMeters(e,t):null}get supported(){return uu.browser&&!!window.XRDepthInformation}get available(){return this._available}get usage(){return this._usage}get dataFormat(){return this._dataFormat}get width(){const e=this._depthInfoCpu||this._depthInfoGpu;return e&&e.width||0}get height(){const e=this._depthInfoCpu||this._depthInfoGpu;return e&&e.height||0}get texture(){return this._texture}get uvMatrix(){return this._matrix}get rawValueToMeters(){const e=this._depthInfoCpu||this._depthInfoGpu;return e&&e.rawValueToMeters||0}}let CC=0;class TC extends Qp{constructor(e,t){super(),this._id=void 0,this._planeDetection=void 0,this._xrPlane=void 0,this._lastChangedTime=void 0,this._orientation=void 0,this._position=new Pu,this._rotation=new Gu,this._id=++CC,this._planeDetection=e,this._xrPlane=t,this._lastChangedTime=t.lastChangedTime,this._orientation=t.orientation}destroy(){this.fire("remove")}update(e){const t=this._planeDetection._manager,n=e.getPose(this._xrPlane.planeSpace,t._referenceSpace);n&&(this._position.copy(n.transform.position),this._rotation.copy(n.transform.orientation)),this._lastChangedTime!==this._xrPlane.lastChangedTime&&(this._lastChangedTime=this._xrPlane.lastChangedTime,this.fire("change"))}getPosition(){return this._position}getRotation(){return this._rotation}get id(){return this._id}get orientation(){return this._orientation}get points(){return this._xrPlane.polygon}}class EC extends Qp{constructor(e){super(),this._manager=void 0,this._supported=uu.browser&&!!window.XRPlane,this._available=!1,this._planesIndex=new Map,this._planes=null,this._manager=e,this._supported&&this._manager.on("end",this._onSessionEnd,this)}_onSessionEnd(){if(this._planes)for(let e=0;e<this._planes.length;e++)this._planes[e].destroy();this._planesIndex.clear(),this._planes=null,this._available&&(this._available=!1,this.fire("unavailable"))}update(e){let t;if(this._available)t=e.detectedPlanes;else try{t=e.detectedPlanes,this._planes=[],this._available=!0,this.fire("available")}catch(e){return}for(const[e,n]of this._planesIndex)t.has(e)||(this._planesIndex.delete(e),this._planes.splice(this._planes.indexOf(n),1),n.destroy(),this.fire("remove",n));for(const n of t){let t=this._planesIndex.get(n);t?t.update(e):(t=new TC(this,n),this._planesIndex.set(n,t),this._planes.push(t),t.update(e),this.fire("add",t))}}get supported(){return this._supported}get available(){return this._available}get planes(){return this._planes}}class SC extends Qp{constructor(e){super(),this.app=void 0,this._supported=uu.browser&&!!navigator.xr,this._available={},this._type=null,this._spaceType=null,this._session=null,this._baseLayer=null,this._referenceSpace=null,this.depthSensing=void 0,this.domOverlay=void 0,this.hitTest=void 0,this.imageTracking=void 0,this.planeDetection=void 0,this.input=void 0,this.lightEstimation=void 0,this._camera=null,this.views=[],this.viewsPool=[],this._localPosition=new Pu,this._localRotation=new Gu,this._depthNear=.1,this._depthFar=1e3,this._width=0,this._height=0,this.app=e,this._available.inline=!1,this._available[Kx]=!1,this._available[Zx]=!1,this.depthSensing=new xC(this),this.domOverlay=new wC(this),this.hitTest=new eC(this),this.imageTracking=new _C(this),this.planeDetection=new EC(this),this.input=new uC(this),this.lightEstimation=new bC(this),this._supported&&(navigator.xr.addEventListener("devicechange",(()=>{this._deviceAvailabilityCheck()})),this._deviceAvailabilityCheck())}start(e,t,n,a){let i=a;if("object"==typeof a&&(i=a.callback),!this._available[t])return void(i&&i(new Error("XR is not available")));if(this._session)return void(i&&i(new Error("XR session is already started")));this._camera=e,this._camera.camera.xr=this,this._type=t,this._spaceType=n,this._setClipPlanes(e.nearClip,e.farClip);const s={requiredFeatures:[n],optionalFeatures:[]};if(t===Zx){if(s.optionalFeatures.push("light-estimation"),s.optionalFeatures.push("hit-test"),a&&(a.imageTracking&&this.imageTracking.supported&&s.optionalFeatures.push("image-tracking"),a.planeDetection&&s.optionalFeatures.push("plane-detection")),this.domOverlay.supported&&this.domOverlay.root&&(s.optionalFeatures.push("dom-overlay"),s.domOverlay={root:this.domOverlay.root}),a&&a.depthSensing&&this.depthSensing.supported){s.optionalFeatures.push("depth-sensing");const e=["cpu-optimized"],t=["luminance-alpha"];if(a.depthSensing.usagePreference){const t=e.indexOf(a.depthSensing.usagePreference);-1!==t&&e.splice(t,1),e.unshift(a.depthSensing.usagePreference)}if(a.depthSensing.dataFormatPreference){const e=t.indexOf(a.depthSensing.dataFormatPreference);-1!==e&&t.splice(e,1),t.unshift(a.depthSensing.dataFormatPreference)}s.depthSensing={usagePreference:e,dataFormatPreference:t}}}else t===Kx&&s.optionalFeatures.push("hand-tracking");a&&a.optionalFeatures&&(s.optionalFeatures=s.optionalFeatures.concat(a.optionalFeatures)),this.imageTracking.supported&&this.imageTracking.images.length?this.imageTracking.prepareImages(((e,a)=>{if(e)return i&&i(e),void this.fire("error",e);null!==a&&(s.trackedImages=a),this._onStartOptionsReady(t,n,s,i)})):this._onStartOptionsReady(t,n,s,i)}_onStartOptionsReady(e,t,n,a){navigator.xr.requestSession(e,n).then((e=>{this._onSessionStart(e,t,a)})).catch((e=>{this._camera.camera.xr=null,this._camera=null,this._type=null,this._spaceType=null,a&&a(e),this.fire("error",e)}))}end(e){this._session?(e&&this.once("end",e),this._session.end()):e&&e(new Error("XR Session is not initialized"))}isAvailable(e){return this._available[e]}_deviceAvailabilityCheck(){for(const e in this._available)this._sessionSupportCheck(e)}_sessionSupportCheck(e){navigator.xr.isSessionSupported(e).then((t=>{this._available[e]!==t&&(this._available[e]=t,this.fire("available",e,t),this.fire("available:"+e,t))})).catch((e=>{this.fire("error",e)}))}_onSessionStart(e,t,n){let a=!1;this._session=e;const i=()=>{this.fire("visibility:change",e.visibilityState)},s=()=>{this._setClipPlanes(this._camera.nearClip,this._camera.farClip)},r=()=>{this._camera&&(this._camera.off("set_nearClip",s),this._camera.off("set_farClip",s),this._camera.camera.xr=null,this._camera=null),e.removeEventListener("end",r),e.removeEventListener("visibilitychange",i),a||this.fire("end"),this._session=null,this._referenceSpace=null,this.views=[],this._width=0,this._height=0,this._type=null,this._spaceType=null,this.app.tick()};e.addEventListener("end",r),e.addEventListener("visibilitychange",i),this._camera.on("set_nearClip",s),this._camera.on("set_farClip",s),this._baseLayer=new XRWebGLLayer(e,this.app.graphicsDevice.gl,{alpha:!0,depth:!0,stencil:!0}),e.updateRenderState({baseLayer:this._baseLayer,depthNear:this._depthNear,depthFar:this._depthFar}),e.requestReferenceSpace(t).then((e=>{this._referenceSpace=e,this.app.tick(),n&&n(null),this.fire("start")})).catch((t=>{a=!0,e.end(),n&&n(t),this.fire("error",t)}))}_setClipPlanes(e,t){this._depthNear===e&&this._depthFar===t||(this._depthNear=e,this._depthFar=t,this._session&&this._session.updateRenderState({depthNear:this._depthNear,depthFar:this._depthFar}))}update(e){if(!this._session)return;const t=e.session.renderState.baseLayer.framebufferWidth,n=e.session.renderState.baseLayer.framebufferHeight;this._width===t&&this._height===n||(this._width=t,this._height=n,this.app.graphicsDevice.setResolution(t,n));const a=e.getViewerPose(this._referenceSpace),i=a?a.views.length:0;if(i>this.views.length)for(let e=0;e<=i-this.views.length;e++){let e=this.viewsPool.pop();e||(e={viewport:new Ou,projMat:new zu,viewMat:new zu,viewOffMat:new zu,viewInvMat:new zu,viewInvOffMat:new zu,projViewOffMat:new zu,viewMat3:new ku,position:new Float32Array(3),rotation:new Gu}),this.views.push(e)}else if(i<=this.views.length)for(let e=0;e<this.views.length-i;e++)this.viewsPool.push(this.views.pop());if(a){const t=a.transform.position,n=a.transform.orientation;this._localPosition.set(t.x,t.y,t.z),this._localRotation.set(n.x,n.y,n.z,n.w);const i=e.session.renderState.baseLayer;for(let e=0;e<a.views.length;e++){const t=a.views[e],n=this.views[e],s=i.getViewport(t);n.viewport.x=s.x,n.viewport.y=s.y,n.viewport.z=s.width,n.viewport.w=s.height,n.projMat.set(t.projectionMatrix),n.viewMat.set(t.transform.inverse.matrix),n.viewInvMat.set(t.transform.matrix)}}this._camera.camera._node.setLocalPosition(this._localPosition),this._camera.camera._node.setLocalRotation(this._localRotation),this.input.update(e),this._type===Zx&&(this.hitTest.supported&&this.hitTest.update(e),this.lightEstimation.supported&&this.lightEstimation.update(e),this.depthSensing.supported&&this.depthSensing.update(e,a&&a.views[0]),this.imageTracking.supported&&this.imageTracking.update(e),this.planeDetection.supported&&this.planeDetection.update(e)),this.fire("update",e)}get supported(){return this._supported}get active(){return!!this._session}get type(){return this._type}get spaceType(){return this._spaceType}get session(){return this._session}get camera(){return this._camera?this._camera.entity:null}get visibilityState(){return this._session?this._session.visibilityState:null}}class AC extends Qp{constructor(e){super(),this.app=e,this.store={},this.schema=[]}addComponent(e,t={}){const n=new this.ComponentType(this,e),a=new this.DataType;return this.store[e.getGuid()]={entity:e,data:a},e[this.id]=n,e.c[this.id]=n,this.initializeComponentData(n,t,[]),this.fire("add",e,n),n}removeComponent(e){const t=this.store[e.getGuid()],n=e.c[this.id];this.fire("beforeremove",e,n),delete this.store[e.getGuid()],e[this.id]=void 0,delete e.c[this.id],this.fire("remove",e,t.data)}cloneComponent(e,t){const n=this.store[e.getGuid()];return this.addComponent(t,n.data)}initializeComponentData(e,t={},n){for(let a=0,i=n.length;a<i;a++){const i=n[a];let s,r;"object"==typeof i?(s=i.name,r=i.type):(s=i,r=void 0);let o=t[s];void 0!==o?(void 0!==r&&(o=MC(o,r)),e[s]=o):e[s]=e.data[s]}e.enabled&&e.entity.enabled&&e.onEnable()}getPropertiesOfType(e){const t=[];return(this.schema||[]).forEach((function(n){n&&"object"==typeof n&&n.type===e&&t.push(n)})),t}destroy(){this.off()}}function MC(e,t){if(!e)return e;switch(t){case"rgb":return e instanceof Mu?e.clone():new Mu(e[0],e[1],e[2]);case"rgba":return e instanceof Mu?e.clone():new Mu(e[0],e[1],e[2],e[3]);case"vec2":return e instanceof Du?e.clone():new Du(e[0],e[1]);case"vec3":return e instanceof Pu?e.clone():new Pu(e[0],e[1],e[2]);case"vec4":return e instanceof Ou?e.clone():new Ou(e[0],e[1],e[2],e[3]);case"boolean":case"number":case"string":case"entity":return e;default:throw new Error("Could not convert unhandled type: "+t)}}class LC{constructor(){this._left=1/0,this._right=-1/0,this._len=0,this._recip=0,this._p0=0,this._p1=0,this._t=0,this._hermite={valid:!1,p0:0,m0:0,p1:0,m1:0}}update(e,t){if(e<this._left||e>=this._right){const n=t.length;if(n)if(e<t[0])this._left=-1/0,this._right=t[0],this._len=0,this._recip=0,this._p0=this._p1=0;else if(e>=t[n-1])this._left=t[n-1],this._right=1/0,this._len=0,this._recip=0,this._p0=this._p1=n-1;else{const n=this._findKey(e,t);this._left=t[n],this._right=t[n+1],this._len=this._right-this._left;const a=1/this._len;this._recip=isFinite(a)?a:0,this._p0=n,this._p1=n+1}else this._left=-1/0,this._right=1/0,this._len=0,this._recip=0,this._p0=this._p1=0}this._t=0===this._recip?0:(e-this._left)*this._recip,this._hermite.valid=!1}_findKey(e,t){let n=0;for(;e>=t[n+1];)n++;return n}eval(e,t,n){const a=n._data,i=n._components,s=this._p0*i;if(0===t)for(let t=0;t<i;++t)e[t]=a[s+t];else{const n=this._t,r=this._p1*i;switch(t){case 1:for(let t=0;t<i;++t)e[t]=Eu.lerp(a[s+t],a[r+t],n);break;case 2:{const t=this._hermite;if(!t.valid){const e=n*n,a=n+n,i=1-n,s=i*i;t.valid=!0,t.p0=(1+a)*s,t.m0=n*s,t.p1=e*(3-a),t.m1=e*(n-1)}const s=(3*this._p0+1)*i,r=(3*this._p0+2)*i,o=(3*this._p1+1)*i,l=(3*this._p1+0)*i;for(let n=0;n<i;++n)e[n]=t.p0*a[s+n]+t.m0*a[r+n]*this._len+t.p1*a[o+n]+t.m1*a[l+n]*this._len;break}}}}}class RC{constructor(e){this._name=e.name+"Snapshot",this._time=-1,this._cache=[],this._results=[];for(let t=0;t<e._inputs.length;++t)this._cache[t]=new LC;const t=e._curves,n=e._outputs;for(let e=0;e<t.length;++e){const a=n[t[e]._output],i=[];for(let e=0;e<a._components;++e)i[e]=0;this._results[e]=i}}}class IC{constructor(e,t,n,a,i,s){for(this._name=e.name,this._track=e,this._snapshot=new RC(e),this._playing=a,this._time=t,this._speed=n,this._loop=i,this._blendWeight=1,this._blendOrder=0,this._eventHandler=s,this._eventCursor=0;this._track.events[this._eventCursor]&&this._track.events[this._eventCursor].time<this.time;)this._eventCursor++}set name(e){this._name=e}get name(){return this._name}get track(){return this._track}get snapshot(){return this._snapshot}set time(e){this._time=e}get time(){return this._time}set speed(e){this._speed=e}get speed(){return this._speed}set loop(e){this._loop=e}get loop(){return this._loop}set blendWeight(e){this._blendWeight=e}get blendWeight(){return this._blendWeight}set blendOrder(e){this._blendOrder=e}get blendOrder(){return this._blendOrder}set eventCursor(e){this._eventCursor=e}get eventCursor(){return this._eventCursor}activeEventsForFrame(e,t){let n;for(0===e&&(this.eventCursor=0),t>this.track.duration&&(n=t-this.track.duration,t=this.track.duration);this.track.events[this.eventCursor]&&this.track.events[this.eventCursor].time>=e&&(t===this.track.duration?this.track.events[this.eventCursor].time<=t:this.track.events[this.eventCursor].time<t);){const e=this.track.events[this.eventCursor];this._eventHandler.fire(e.name,Sw({track:this.track},e)),this.eventCursor++}Number.isFinite(n)&&this.activeEventsForFrame(0,n)}_update(e){if(this._playing){let t=this._time;const n=this._track.duration,a=this._speed,i=this._loop;this._track.events.length>0&&n>0&&this.activeEventsForFrame(t,t+a*e),t+=a*e,a>=0?t>n&&(i?t=t%n||0:(t=this._track.duration,this.pause())):t<0&&(i?t=n+(t%n||0):(t=0,this.pause())),this._time=t}this._time!==this._snapshot._time&&this._track.eval(this._time,this._snapshot)}play(){this._playing=!0,this._time=0}stop(){this._playing=!1,this._time=0}pause(){this._playing=!1}resume(){this._playing=!0}reset(){this._time=0}}const PC=["START","END","ANY"];class kC{constructor(e,t){this._component=e,this.mask=new Int8Array(e.layers.length),this.weights=new Float32Array(e.layers.length),this.totalWeight=0,this.counter=0,this.layerCounter=0,this.valueType=t,this.dirty=!0,this.value=[0,0,0,1],this.baseValue=null,this.setter=null}get _normalizeWeights(){return this._component.normalizeWeights}getWeight(e){return this.dirty&&this.updateWeights(),this._normalizeWeights&&0===this.totalWeight||!this.mask[e]?0:this._normalizeWeights?this.weights[e]/this.totalWeight:Eu.clamp(this.weights[e],0,1)}_layerBlendType(e){return this._component.layers[e].blendType}setMask(e,t){this.mask[e]=t,this._normalizeWeights&&("OVERWRITE"===this._component.layers[e].blendType&&(this.mask=this.mask.fill(0,0,e)),this.dirty=!0)}updateWeights(){this.totalWeight=0;for(let e=0;e<this.weights.length;e++)this.weights[e]=this._component.layers[e].weight,this.totalWeight+=this.mask[e]*this.weights[e];this.dirty=!1}updateValue(e,t){if(0===this.counter&&(DC._set(this.value,kC.IDENTITY_QUAT_ARR,this.valueType),this._normalizeWeights||DC._blend(this.value,this.baseValue,1,this.valueType)),this.mask[e]&&0!==this.getWeight(e)){if("ADDITIVE"!==this._layerBlendType(e)||this._normalizeWeights)DC._blend(this.value,t,this.getWeight(e),this.valueType);else if(this.valueType===kC.TYPE_QUAT){const n=kC.q1.set(this.value[0],this.value[1],this.value[2],this.value[3]),a=kC.q2.set(this.baseValue[0],this.baseValue[1],this.baseValue[2],this.baseValue[3]),i=kC.q3.set(t[0],t[1],t[2],t[3]),s=a.invert().mul(i);s.slerp(Gu.IDENTITY,s,this.getWeight(e)),n.mul(s),kC.quatArr[0]=n.x,kC.quatArr[1]=n.y,kC.quatArr[2]=n.z,kC.quatArr[3]=n.w,DC._set(this.value,kC.quatArr,this.valueType)}else kC.vecArr[0]=t[0]-this.baseValue[0],kC.vecArr[1]=t[1]-this.baseValue[1],kC.vecArr[2]=t[2]-this.baseValue[2],DC._blend(this.value,kC.vecArr,this.getWeight(e),this.valueType,!0);this.setter(this.value)}}unbind(){this._normalizeWeights||this.setter(this.baseValue)}}kC.TYPE_QUAT="quaternion",kC.TYPE_VEC3="vector3",kC.q1=new Gu,kC.q2=new Gu,kC.q3=new Gu,kC.quatArr=[0,0,0,1],kC.vecArr=[0,0,0],kC.IDENTITY_QUAT_ARR=[0,0,0,1];class DC{constructor(e){this._binder=e,this._clips=[],this._inputs=[],this._outputs=[],this._targets={}}get clips(){return this._clips}static _dot(e,t){const n=e.length;let a=0;for(let i=0;i<n;++i)a+=e[i]*t[i];return a}static _normalize(e){let t=DC._dot(e,e);if(t>0){t=1/Math.sqrt(t);const n=e.length;for(let a=0;a<n;++a)e[a]*=t}}static _set(e,t,n){const a=e.length;if("quaternion"===n){let n=DC._dot(t,t);n>0&&(n=1/Math.sqrt(n));for(let i=0;i<a;++i)e[i]=t[i]*n}else for(let n=0;n<a;++n)e[n]=t[n]}static _blendVec(e,t,n,a){const i=a?1:1-n,s=e.length;for(let a=0;a<s;++a)e[a]=e[a]*i+t[a]*n}static _blendQuat(e,t,n,a){const i=e.length,s=a?1:1-n;DC._dot(e,t)<0&&(n=-n);for(let a=0;a<i;++a)e[a]=e[a]*s+t[a]*n;a||DC._normalize(e)}static _blend(e,t,n,a,i){"quaternion"===a?DC._blendQuat(e,t,n,i):DC._blendVec(e,t,n,i)}static _stableSort(e,t){const n=e.length;for(let a=0;a<n-1;++a)for(let i=a+1;i<n;++i)if(t(e[i],e[a])){const t=e[a];e[a]=e[i],e[i]=t}}addClip(e){const t=this._targets,n=this._binder,a=e.track.curves,i=e.snapshot,s=[],r=[];for(let e=0;e<a.length;++e){const o=a[e].paths;for(let a=0;a<o.length;++a){const l=o[a],c=n.resolve(l);let h=t[c&&c.targetPath||null];if(!h&&c){h={target:c,value:[],curves:0,blendCounter:0};for(let e=0;e<h.target.components;++e)h.value.push(0);if(t[c.targetPath]=h,n.animComponent){if(!n.animComponent.targets[c.targetPath]){let e;e="localRotation"===c.targetPath.substring(c.targetPath.length-13)?kC.TYPE_QUAT:kC.TYPE_VEC3,n.animComponent.targets[c.targetPath]=new kC(n.animComponent,e)}n.animComponent.targets[c.targetPath].layerCounter++,n.animComponent.targets[c.targetPath].setMask(n.layerIndex,1)}}h&&(h.curves++,s.push(i._results[e]),r.push(h))}}this._clips.push(e),this._inputs.push(s),this._outputs.push(r)}removeClip(e){const t=this._targets,n=this._binder,a=this._clips,i=a[e].track.curves;for(let e=0;e<i.length;++e){const a=i[e].paths;for(let e=0;e<a.length;++e){const i=a[e],s=this._binder.resolve(i);s&&(s.curves--,0===s.curves&&(n.unresolve(i),delete t[s.targetPath],n.animComponent&&n.animComponent.targets[s.targetPath].layerCounter--))}}a.splice(e,1),this._inputs.splice(e,1),this._outputs.splice(e,1)}removeClips(){for(;this._clips.length>0;)this.removeClip(0)}findClip(e){const t=this._clips;for(let n=0;n<t.length;++n){const a=t[n];if(a.name===e)return a}return null}rebind(){this._binder.rebind(),this._targets={};const e=[...this.clips];this.removeClips(),e.forEach((e=>{this.addClip(e)}))}assignMask(e){return this._binder.assignMask(e)}update(e){const t=this._clips,n=t.map((function(e,t){return t}));DC._stableSort(n,(function(e,n){return t[e].blendOrder<t[n].blendOrder}));for(let a=0;a<n.length;++a){const i=n[a],s=t[i],r=this._inputs[i],o=this._outputs[i],l=s.blendWeight;let c,h,d;if(l>0&&s._update(e),l>=1)for(let e=0;e<r.length;++e)c=r[e],h=o[e],d=h.value,DC._set(d,c,h.target.type),h.blendCounter++;else if(l>0)for(let e=0;e<r.length;++e)c=r[e],h=o[e],d=h.value,0===h.blendCounter?DC._set(d,c,h.target.type):DC._blend(d,c,l,h.target.type),h.blendCounter++}const a=this._targets,i=this._binder;for(const e in a)if(a.hasOwnProperty(e)){const t=a[e];if(i.animComponent&&t.target.isTransform){const n=i.animComponent.targets[e];n.counter===n.layerCounter&&(n.counter=0),n.path||(n.path=e,n.baseValue=t.target.get(),n.setter=t.target.set),n.updateValue(i.layerIndex,t.value),n.counter++}else t.target.set(t.value);t.blendCounter=0}i.update(e)}}class OC{static joinPath(e,t){t=t||".";return e.map((function(e){return e.replace(/\\/g,"\\\\").replace(new RegExp("\\"+t,"g"),"\\"+t)})).join(t)}static splitPath(e,t){t=t||".";const n=[];let a="",i=0;for(;i<e.length;){let s=e[i++];"\\"===s&&i<e.length?(s=e[i++],a+="\\"===s||s===t?s:"\\"+s):s===t?(n.push(a),a=""):a+=s}return a.length>0&&n.push(a),n}static encode(e,t,n){return`${Array.isArray(e)?e.join("/"):e}/${t}/${Array.isArray(n)?n.join("/"):n}`}resolve(e){return null}unresolve(e){}update(e){}}class FC{constructor(e,t,n,a){e.set?(this._set=e.set,this._get=e.get):this._set=e,this._type=t,this._components=n,this._targetPath=a,this._isTransform="localRotation"===this._targetPath.substring(this._targetPath.length-13)||"localPosition"===this._targetPath.substring(this._targetPath.length-13)||"localScale"===this._targetPath.substring(this._targetPath.length-10)}get set(){return this._set}get get(){return this._get}get type(){return this._type}get components(){return this._components}get targetPath(){return this._targetPath}get isTransform(){return this._isTransform}}class NC{constructor(e){if(this._isPathInMask=(e,t)=>{const n=this._mask[e];return!!n&&!!(n.children||t&&!1!==n.value)},this.graph=e,!e)return;this._mask=null;const t={};!function e(n){t[n.name]=n;for(let t=0;t<n.children.length;++t)e(n.children[t])}(e),this.nodes=t,this.targetCache={};const n=function(e){let t,n=e;for(;n&&!(n instanceof KM);)n=n.parent;return n&&(n.render?t=n.render.meshInstances:n.model&&(t=n.model.meshInstances)),t};this.nodeCounts={},this.activeNodes=[],this.handlers={localPosition:function(e){const t=e.localPosition;return NC.createAnimTarget((function(e){t.set(...e)}),"vector",3,e,"localPosition")},localRotation:function(e){const t=e.localRotation;return NC.createAnimTarget((function(e){t.set(...e)}),"quaternion",4,e,"localRotation")},localScale:function(e){const t=e.localScale;return NC.createAnimTarget((function(e){t.set(...e)}),"vector",3,e,"localScale")},weights:function(e){const t=n(e);if(t){const n=[];for(let a=0;a<t.length;++a)t[a].node.name===e.name&&t[a].morphInstance&&n.push(t[a].morphInstance);if(n.length>0){const t=function(e){for(let t=0;t<e.length;++t)for(let a=0;a<n.length;a++)n[a].setWeight(t,e[t])};return NC.createAnimTarget(t,"vector",n[0].morph._targets.length,e,"weights")}}return null},materialTexture:(e,t)=>{const a=n(e);if(a){let n;for(let t=0;t<a.length;++t)if(a[t].node.name===e.name){n=a[t];break}if(n){const a=e=>{const a=this.animComponent.system.app.assets.get(e[0]);a&&a.resource&&"texture"===a.type&&(n.material[t]=a.resource,n.material.update())};return NC.createAnimTarget(a,"vector",1,e,"materialTexture","material")}}return null}}}_isPathActive(e){if(!this._mask)return!0;const t=[e.entityPath[0],this.graph.name];for(let n=0;n<t.length;++n){let a=t[n];if(this._isPathInMask(a,1===e.entityPath.length))return!0;for(let t=1;t<e.entityPath.length;t++)if(a+="/"+e.entityPath[t],this._isPathInMask(a,t===e.entityPath.length-1))return!0}return!1}findNode(e){if(!this._isPathActive(e))return null;let t;return this.graph&&(t=this.graph.findByPath(e.entityPath)),t||(t=this.nodes[e.entityPath[e.entityPath.length-1]||""]),t}static createAnimTarget(e,t,n,a,i,s){const r=OC.encode(a.path,s||"entity",i);return new FC(e,t,n,r)}resolve(e){const t=OC.encode(e.entityPath,e.component,e.propertyPath);let n=this.targetCache[t];if(n)return n;const a=this.findNode(e);if(!a)return null;const i=this.handlers[e.propertyPath];return i?(n=i(a),n?(this.targetCache[t]=n,this.nodeCounts[a.path]?this.nodeCounts[a.path]++:(this.activeNodes.push(a),this.nodeCounts[a.path]=1),n):null):null}unresolve(e){if("graph"!==e.component)return;const t=this.nodes[e.entityPath[e.entityPath.length-1]||""];if(this.nodeCounts[t.path]--,0===this.nodeCounts[t.path]){const e=this.activeNodes,n=e.indexOf(t.node),a=e.length;n<a-1&&(e[n]=e[a-1]),e.pop()}}update(e){const t=this.activeNodes;for(let e=0;e<t.length;++e)t[e]._dirtifyLocal()}assignMask(e){return e!==this._mask&&(this._mask=e,!0)}}class VC{constructor(){this._written=!1,this._name="",this._keyFrames=[],this._quat=new Gu,this._pos=new Pu,this._scale=new Pu,this._targetNode=null}getTarget(){return this._targetNode}setTarget(e){this._targetNode=e}}class BC{constructor(e){this.looping=!0,this._animation=null,this._time=0,this._interpolatedKeys=[],this._interpolatedKeyDict={},this._currKeyIndices={},this.graph=null;const t=e=>{const n=new VC;n._name=e.name,this._interpolatedKeys.push(n),this._interpolatedKeyDict[e.name]=n,this._currKeyIndices[e.name]=0;for(let n=0;n<e._children.length;n++)t(e._children[n])};t(e)}set animation(e){this._animation=e,this.currentTime=0}get animation(){return this._animation}set currentTime(e){this._time=e;const t=this._interpolatedKeys.length;for(let e=0;e<t;e++){const t=this._interpolatedKeys[e]._name;this._currKeyIndices[t]=0}this.addTime(0),this.updateGraph()}get currentTime(){return this._time}get numNodes(){return this._interpolatedKeys.length}addTime(e){if(null!==this._animation){const t=this._animation._nodes,n=this._animation.duration;if(this._time===n&&!this.looping)return;if(this._time+=e,this._time>n){this._time=this.looping?0:n;for(let e=0;e<t.length;e++){const n=t[e]._name;this._currKeyIndices[n]=0}}else if(this._time<0){this._time=this.looping?n:0;for(let e=0;e<t.length;e++){const n=t[e],a=n._name;this._currKeyIndices[a]=n._keys.length-2}}const a=e>=0?1:-1;for(let e=0;e<t.length;e++){const n=t[e],i=n._name,s=n._keys,r=this._interpolatedKeyDict[i];if(void 0===r)continue;let o=!1;if(1!==s.length)for(let e=this._currKeyIndices[i];e<s.length-1&&e>=0;e+=a){const t=s[e],n=s[e+1];if(t.time<=this._time&&n.time>=this._time){const a=(this._time-t.time)/(n.time-t.time);r._pos.lerp(t.position,n.position,a),r._quat.slerp(t.rotation,n.rotation,a),r._scale.lerp(t.scale,n.scale,a),r._written=!0,this._currKeyIndices[i]=e,o=!0;break}}(1===s.length||!o&&0===this._time&&this.looping)&&(r._pos.copy(s[0].position),r._quat.copy(s[0].rotation),r._scale.copy(s[0].scale),r._written=!0)}}}blend(e,t,n){const a=this._interpolatedKeys.length;for(let i=0;i<a;i++){const a=e._interpolatedKeys[i],s=t._interpolatedKeys[i],r=this._interpolatedKeys[i];a._written&&s._written?(r._quat.slerp(a._quat,t._interpolatedKeys[i]._quat,n),r._pos.lerp(a._pos,t._interpolatedKeys[i]._pos,n),r._scale.lerp(a._scale,s._scale,n),r._written=!0):a._written?(r._quat.copy(a._quat),r._pos.copy(a._pos),r._scale.copy(a._scale),r._written=!0):s._written&&(r._quat.copy(s._quat),r._pos.copy(s._pos),r._scale.copy(s._scale),r._written=!0)}}setGraph(e){if(this.graph=e,e)for(let t=0;t<this._interpolatedKeys.length;t++){const n=this._interpolatedKeys[t],a=e.findByName(n._name);this._interpolatedKeys[t].setTarget(a)}else for(let e=0;e<this._interpolatedKeys.length;e++)this._interpolatedKeys[e].setTarget(null)}updateGraph(){if(this.graph)for(let e=0;e<this._interpolatedKeys.length;e++){const t=this._interpolatedKeys[e];if(t._written){const e=t.getTarget();e.localPosition.copy(t._pos),e.localRotation.copy(t._quat),e.localScale.copy(t._scale),e._dirtyLocal||e._dirtifyLocal(),t._written=!1}}}}class UC extends Ux{constructor(e,t){super(e,t),this.animationsIndex={},this.on("set_animations",this.onSetAnimations,this),this.on("set_assets",this.onSetAssets,this),this.on("set_loop",this.onSetLoop,this)}set currentTime(e){const t=this.data;if(t.skeleton){const n=t.skeleton;n.currentTime=e,n.addTime(0),n.updateGraph()}if(t.animEvaluator){const n=t.animEvaluator;for(let t=0;t<n.clips.length;++t)n.clips[t].time=e}}get currentTime(){const e=this.data;if(e.skeleton)return this.data.skeleton._time;if(e.animEvaluator){const t=e.animEvaluator.clips;if(t.length>0)return t[t.length-1].time}return 0}get duration(){return this.data.animations[this.data.currAnim].duration}play(e,t=0){if(!this.enabled||!this.entity.enabled)return;const n=this.data;if(n.animations[e]){if(n.prevAnim=n.currAnim,n.currAnim=e,n.model){n.skeleton||n.animEvaluator||this._createAnimationController();const e=n.animations[n.prevAnim],a=n.animations[n.currAnim];if(n.blending=t>0&&n.prevAnim,n.blending&&(n.blend=0,n.blendSpeed=1/t),n.skeleton&&(n.blending?(n.fromSkel.animation=e,n.fromSkel.addTime(n.skeleton._time),n.toSkel.animation=a):n.skeleton.animation=a),n.animEvaluator){const e=n.animEvaluator;if(n.blending)for(;e.clips.length>1;)e.removeClip(0);else n.animEvaluator.removeClips();const t=new IC(n.animations[n.currAnim],0,1,!0,n.loop);t.name=n.currAnim,t.blendWeight=n.blending?0:1,t.reset(),n.animEvaluator.addClip(t)}}n.playing=!0}}getAnimation(e){return this.data.animations[e]}setModel(e){const t=this.data;e!==t.model&&(this._resetAnimationController(),t.model=e,t.animations&&t.currAnim&&t.animations[t.currAnim]&&this.play(t.currAnim))}_resetAnimationController(){const e=this.data;e.skeleton=null,e.fromSkel=null,e.toSkel=null,e.animEvaluator=null}_createAnimationController(){const e=this.data,t=e.model,n=e.animations;let a=!1,i=!1;for(const e in n)if(n.hasOwnProperty(e)){n[e].constructor===n_?i=!0:a=!0}const s=t.getGraph();a?(e.fromSkel=new BC(s),e.toSkel=new BC(s),e.skeleton=new BC(s),e.skeleton.looping=e.loop,e.skeleton.setGraph(s)):i&&(e.animEvaluator=new DC(new NC(this.entity)))}loadAnimationAssets(e){if(!e||!e.length)return;const t=this.system.app.assets,n=e=>{if(e.resources.length>1)for(let t=0;t<e.resources.length;t++)this.animations[e.resources[t].name]=e.resources[t],this.animationsIndex[e.id]=e.resources[t].name;else this.animations[e.name]=e.resource,this.animationsIndex[e.id]=e.name;this.animations=this.animations},a=e=>{e.off("change",this.onAssetChanged,this),e.on("change",this.onAssetChanged,this),e.off("remove",this.onAssetRemoved,this),e.on("remove",this.onAssetRemoved,this),e.resource?n(e):(e.once("load",n,this),this.enabled&&this.entity.enabled&&t.load(e))};for(let n=0,i=e.length;n<i;n++){const i=t.get(e[n]);i?a(i):t.on("add:"+e[n],a)}}onAssetChanged(e,t,n,a){if("resource"===t||"resources"===t)if("resources"===t&&n&&0===n.length&&(n=null),n){let t=!1;if(n.length>1){if(a&&a.length>1)for(let e=0;e<a.length;e++)delete this.animations[a[e].name];else delete this.animations[e.name];t=!1;for(let e=0;e<n.length;e++)this.animations[n[e].name]=n[e],t||this.data.currAnim!==n[e].name||this.data.playing&&this.data.enabled&&this.entity.enabled&&(t=!0,this.play(n[e].name));t||(this._stopCurrentAnimation(),this.onSetAnimations())}else{if(a&&a.length>1)for(let e=0;e<a.length;e++)delete this.animations[a[e].name];this.animations[e.name]=n[0]||n,t=!1,this.data.currAnim===e.name&&this.data.playing&&this.data.enabled&&this.entity.enabled&&(t=!0,this.play(e.name)),t||(this._stopCurrentAnimation(),this.onSetAnimations())}this.animationsIndex[e.id]=e.name}else{if(a.length>1)for(let e=0;e<a.length;e++)delete this.animations[a[e].name],this.data.currAnim===a[e].name&&this._stopCurrentAnimation();else delete this.animations[e.name],this.data.currAnim===e.name&&this._stopCurrentAnimation();delete this.animationsIndex[e.id]}}onAssetRemoved(e){if(e.off("remove",this.onAssetRemoved,this),this.animations){if(e.resources.length>1)for(let t=0;t<e.resources.length;t++)delete this.animations[e.resources[t].name],this.data.currAnim===e.resources[t].name&&this._stopCurrentAnimation();else delete this.animations[e.name],this.data.currAnim===e.name&&this._stopCurrentAnimation();delete this.animationsIndex[e.id]}}_stopCurrentAnimation(){const e=this.data;if(e.currAnim=null,e.playing=!1,e.skeleton&&(e.skeleton.currentTime=0,e.skeleton.animation=null),e.animEvaluator){for(let t=0;t<e.animEvaluator.clips.length;++t)e.animEvaluator.clips[t].stop();e.animEvaluator.update(0),e.animEvaluator.removeClips()}}onSetAnimations(e,t,n){const a=this.data,i=this.entity.model;if(i){const e=i.model;e&&e!==a.model&&this.setModel(e)}if(!a.currAnim&&a.activate&&a.enabled&&this.entity.enabled){const e=Object.keys(a.animations);e.length>0&&this.play(e[0])}}onSetAssets(e,t,n){if(t&&t.length)for(let e=0;e<t.length;e++)if(t[e]){const n=this.system.app.assets.get(t[e]);if(n){n.off("change",this.onAssetChanged,this),n.off("remove",this.onAssetRemoved,this);const e=this.animationsIndex[n.id];this.data.currAnim===e&&this._stopCurrentAnimation(),delete this.animations[e],delete this.animationsIndex[n.id]}}const a=n.map((e=>e instanceof f_?e.id:e));this.loadAnimationAssets(a)}onSetLoop(e,t,n){const a=this.data;if(a.skeleton&&(a.skeleton.looping=a.loop),a.animEvaluator)for(let e=0;e<a.animEvaluator.clips.length;++e)a.animEvaluator.clips[e].loop=a.loop}onEnable(){super.onEnable();const e=this.data,t=e.assets,n=this.system.app.assets;if(t)for(let e=0,a=t.length;e<a;e++){let a=t[e];a instanceof f_||(a=n.get(a)),a&&!a.resource&&n.load(a)}if(e.activate&&!e.currAnim){const t=Object.keys(e.animations);t.length>0&&this.play(t[0])}}onBeforeRemove(){for(let e=0;e<this.assets.length;e++){let t=this.assets[e];"number"==typeof t&&(t=this.system.app.assets.get(t)),t&&(t.off("change",this.onAssetChanged,this),t.off("remove",this.onAssetRemoved,this))}const e=this.data;delete e.animation,delete e.skeleton,delete e.fromSkel,delete e.toSkel,delete e.animEvaluator}}class zC{constructor(){this.assets=[],this.speed=1,this.loop=!0,this.activate=!0,this.enabled=!0,this.animations={},this.model=null,this.prevAnim=null,this.currAnim=null,this.blending=!1,this.blend=0,this.blendSpeed=0,this.playing=!1,this.skeleton=null,this.fromSkel=null,this.toSkel=null,this.animEvaluator=null}}const GC=["enabled","assets","speed","loop","activate","animations","skeleton","model","prevAnim","currAnim","fromSkel","toSkel","blending","blendTimeRemaining","playing"];class HC extends AC{constructor(e){super(e),this.id="animation",this.ComponentType=UC,this.DataType=zC,this.schema=GC,this.on("beforeremove",this.onBeforeRemove,this),this.app.systems.on("update",this.onUpdate,this)}initializeComponentData(e,t,n){n=["activate","enabled","loop","speed","assets"],super.initializeComponentData(e,t,n)}cloneComponent(e,t){this.addComponent(t,{}),t.animation.assets=e.animation.assets.slice(),t.animation.data.speed=e.animation.speed,t.animation.data.loop=e.animation.loop,t.animation.data.activate=e.animation.activate,t.animation.data.enabled=e.animation.enabled;const n={},a=e.animation.animations;for(const e in a)a.hasOwnProperty(e)&&(n[e]=a[e]);t.animation.animations=n;const i={},s=e.animation.animationsIndex;for(const e in s)s.hasOwnProperty(e)&&(i[e]=s[e]);return t.animation.animationsIndex=i,t.animation}onBeforeRemove(e,t){t.onBeforeRemove()}onUpdate(e){const t=this.store;for(const n in t)if(t.hasOwnProperty(n)){const a=t[n],i=a.data;if(i.enabled&&a.entity.enabled){if(i.blending&&(i.blend+=e*i.blendSpeed,i.blend>=1&&(i.blend=1)),i.playing){const t=i.skeleton;if(null!==t&&null!==i.model){if(i.blending)t.blend(i.fromSkel,i.toSkel,i.blend);else{const n=e*i.speed;t.addTime(n),(i.speed>0&&t._time===t._animation.duration&&!i.loop||i.speed<0&&0===t._time&&!i.loop)&&(i.playing=!1)}i.blending&&1===i.blend&&(t.animation=i.toSkel._animation),t.updateGraph()}}const t=i.animEvaluator;if(t){for(let e=0;e<t.clips.length;++e){const n=t.clips[e];n.speed=i.speed,i.playing?n.resume():n.pause()}i.blending&&t.clips.length>1&&(t.clips[1].blendWeight=i.blend),t.update(e)}i.blending&&1===i.blend&&(i.blending=!1)}}}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this)}}Ux._buildAccessors(UC.prototype,GC);class WC{constructor(e,t,n,a,i=1){this._state=e,this._parent=t,this._name=n,Array.isArray(a)?(this._point=new Du(a[0],a[1]),this._pointLength=this._point.length()):(this._point=a,this._pointLength=a),this._speed=i,this._weightedSpeed=1,this._weight=1,this._animTrack=null}get parent(){return this._parent}get name(){return this._name}get path(){return this._parent?this._parent.path+"."+this._name:this._name}get point(){return this._point}get pointLength(){return this._pointLength}set weight(e){this._weight=e}get weight(){return this._parent?this._parent.weight*this._weight:this._weight}get normalizedWeight(){const e=this._state.totalWeight;return 0===e?0:this.weight/e}get speed(){return this._weightedSpeed*this._speed}get absoluteSpeed(){return Math.abs(this._speed)}set weightedSpeed(e){this._weightedSpeed=e}get weightedSpeed(){return this._weightedSpeed}set animTrack(e){this._animTrack=e}get animTrack(){return this._animTrack}}class jC extends WC{constructor(e,t,n,a,i,s,r,o,l){super(e,t,n,a),this._parameters=i,this._parameterValues=new Array(i.length),this._children=[],this._findParameter=l,this._syncAnimations=!1!==r,this._pointCache={};for(let t=0;t<s.length;t++){const a=s[t];a.children?this._children.push(o(a.type,this,null,n,1,a.parameter?[a.parameter]:a.parameters,a.children,o,l)):this._children.push(new WC(e,this,a.name,a.point,a.speed))}}get weight(){return this.calculateWeights(),this._parent?this._parent.weight*this._weight:this._weight}get syncAnimations(){return this._syncAnimations}getChild(e){for(let t=0;t<this._children.length;t++)if(this._children[t].name===e)return this._children[t];return null}updateParameterValues(){let e=!0;for(let t=0;t<this._parameterValues.length;t++){const n=this._findParameter(this._parameters[t]).value;this._parameterValues[t]!==n&&(this._parameterValues[t]=n,e=!1)}return e}getNodeWeightedDuration(e){return this._children[e].animTrack.duration/this._children[e].speedMultiplier*this._children[e].weight}getNodeCount(){let e=0;for(let t=0;t<this._children.length;t++){this._children[t].constructor===jC?e+=this._children[t].getNodeCount():e++}return e}}class XC extends jC{constructor(e,t,n,a,i,s,r,o,l){s.sort(((e,t)=>e.point-t.point)),super(e,t,n,a,i,s,r,o,l)}calculateWeights(){if(this.updateParameterValues())return;let e=0;this._children[0].weight=0;for(let t=0;t<this._children.length;t++){const n=this._children[t];if(t!==this._children.length-1){const e=this._children[t+1];if(n.point===e.point)n.weight=.5,e.weight=.5;else if(Eu.between(this._parameterValues[0],n.point,e.point,!0)){const t=Math.abs(n.point-e.point),a=(t-Math.abs(n.point-this._parameterValues[0]))/t;n.weight=a,e.weight=1-a}else e.weight=0}this._syncAnimations&&(e+=n.animTrack.duration/n.absoluteSpeed*n.weight)}if(this._syncAnimations)for(let t=0;t<this._children.length;t++){const n=this._children[t];n.weightedSpeed=n.animTrack.duration/n.absoluteSpeed/e}}}class YC extends jC{pointDistanceCache(e,t){const n=`${e}${t}`;return this._pointCache[n]||(this._pointCache[n]=this._children[t].point.clone().sub(this._children[e].point)),this._pointCache[n]}calculateWeights(){if(this.updateParameterValues())return;let e,t;YC._p.set(...this._parameterValues),e=0,t=0;for(let n=0;n<this._children.length;n++){const a=this._children[n],i=a.point;YC._pip.set(YC._p.x,YC._p.y).sub(i);let s=Number.MAX_VALUE;for(let e=0;e<this._children.length;e++){if(n===e)continue;const t=this.pointDistanceCache(n,e),a=Eu.clamp(1-YC._pip.dot(t)/t.lengthSq(),0,1);a<s&&(s=a)}a.weight=s,e+=s,this._syncAnimations&&(t+=a.animTrack.duration/a.absoluteSpeed*a.weight)}for(let n=0;n<this._children.length;n++){const a=this._children[n];a.weight=a._weight/e,this._syncAnimations&&(a.weightedSpeed=a.animTrack.duration/a.absoluteSpeed/t)}}}YC._p=new Du,YC._pip=new Du;class qC extends jC{pointCache(e,t){const n=`${e}${t}`;return this._pointCache[n]||(this._pointCache[n]=new Du((this._children[t].pointLength-this._children[e].pointLength)/((this._children[t].pointLength+this._children[e].pointLength)/2),2*Du.angleRad(this._children[e].point,this._children[t].point))),this._pointCache[n]}calculateWeights(){if(this.updateParameterValues())return;let e,t;qC._p.set(...this._parameterValues);const n=qC._p.length();e=0,t=0;for(let a=0;a<this._children.length;a++){const i=this._children[a],s=i.point,r=i.pointLength;let o=Number.MAX_VALUE;for(let e=0;e<this._children.length;e++){if(a===e)continue;const t=this.pointCache(a,e),i=this._children[e].pointLength;qC._pip.set((n-r)/((i+r)/2),2*Du.angleRad(s,qC._p));const l=Eu.clamp(1-Math.abs(qC._pip.dot(t)/t.lengthSq()),0,1);l<o&&(o=l)}i.weight=o,e+=o,this._syncAnimations&&(t+=i.animTrack.duration/i.absoluteSpeed*i.weight)}for(let n=0;n<this._children.length;n++){const a=this._children[n];if(a.weight=a._weight/e,this._syncAnimations){const n=a.animTrack.duration/t*e;a.weightedSpeed=a.absoluteSpeed*n}}}}qC._p=new Du,qC._pip=new Du;class KC extends jC{calculateWeights(){if(this.updateParameterValues())return;let e=0,t=0;for(let n=0;n<this._children.length;n++)if(e+=Math.max(this._parameterValues[n],0),this._syncAnimations){const e=this._children[n];t+=e.animTrack.duration/e.absoluteSpeed*e.weight}for(let n=0;n<this._children.length;n++){const a=this._children[n];a.weight=Math.max(this._parameterValues[n],0)/e,this._syncAnimations&&(a.weightedSpeed=a.animTrack.duration/a.absoluteSpeed/t)}}}class ZC{constructor(e,t,n,a,i){this._controller=e,this._name=t,this._animations={},this._animationList=[],this._speed=n||1,this._loop=void 0===a||a;const s=this._controller.findParameter.bind(this._controller);this._blendTree=i?this._createTree(i.type,this,null,t,1,i.parameter?[i.parameter]:i.parameters,i.children,i.syncAnimations,this._createTree,s):new WC(this,null,t,1,n)}_createTree(e,t,n,a,i,s,r,o,l,c){switch(e){case"1D":return new XC(t,n,a,i,s,r,o,l,c);case"2D_CARTESIAN":return new YC(t,n,a,i,s,r,o,l,c);case"2D_DIRECTIONAL":return new qC(t,n,a,i,s,r,o,l,c);case"DIRECT":return new KC(t,n,a,i,s,r,o,l,c)}}_getNodeFromPath(e){let t=this._blendTree;for(let n=1;n<e.length;n++)t=t.getChild(e[n]);return t}addAnimation(e,t){const n=e.join("."),a=this._animationList.findIndex((function(e){return e.path===n}));if(a>=0)this._animationList[a].animTrack=t;else{const n=this._getNodeFromPath(e);n.animTrack=t,this._animationList.push(n)}}get name(){return this._name}set animations(e){this._animationList=e}get animations(){return this._animationList}set speed(e){this._speed=e}get speed(){return this._speed}set loop(e){this._loop=e}get loop(){return this._loop}get nodeCount(){return this._blendTree&&this._blendTree.constructor!==WC?this._blendTree.getNodeCount():1}get playable(){return-1!==PC.indexOf(this.name)||this.animations.length===this.nodeCount}get looping(){if(this.animations.length>0){const e=this.name+"."+this.animations[0].animTrack.name,t=this._controller.animEvaluator.findClip(e);if(t)return t.loop}return!1}get totalWeight(){let e=0;for(let t=0;t<this.animations.length;t++)e+=this.animations[t].weight;return e}get timelineDuration(){let e=0;for(let t=0;t<this.animations.length;t++){const n=this.animations[t];n.animTrack.duration>e&&(e=n.animTrack.duration)}return e}}class $C{constructor({from:e,to:t,time:n=0,priority:a=0,conditions:i=[],exitTime:s=null,transitionOffset:r=null,interruptionSource:o="NONE"}){this._from=e,this._to=t,this._time=n,this._priority=a,this._conditions=i,this._exitTime=s,this._transitionOffset=r,this._interruptionSource=o}get from(){return this._from}set to(e){this._to=e}get to(){return this._to}get time(){return this._time}get priority(){return this._priority}get conditions(){return this._conditions}get exitTime(){return this._exitTime}get transitionOffset(){return this._transitionOffset}get interruptionSource(){return this._interruptionSource}get hasExitTime(){return!!this.exitTime}}class QC{constructor(e,t,n,a,i,s,r){this._animEvaluator=e,this._states={},this._stateNames=[],this._eventHandler=s,this._consumedTriggers=r;for(let e=0;e<t.length;e++)this._states[t[e].name]=new ZC(this,t[e].name,t[e].speed,t[e].loop,t[e].blendTree),this._stateNames.push(t[e].name);this._transitions=n.map((e=>new $C(Sw({},e)))),this._findTransitionsFromStateCache={},this._findTransitionsBetweenStatesCache={},this._parameters=a,this._previousStateName=null,this._activeStateName="START",this._playing=!1,this._activate=i,this._currTransitionTime=1,this._totalTransitionTime=1,this._isTransitioning=!1,this._transitionInterruptionSource="NONE",this._transitionPreviousStates=[],this._timeInState=0,this._timeInStateBefore=0}get animEvaluator(){return this._animEvaluator}set activeState(e){this._activeStateName=e}get activeState(){return this._findState(this._activeStateName)}get activeStateName(){return this._activeStateName}get activeStateAnimations(){return this.activeState.animations}set previousState(e){this._previousStateName=e}get previousState(){return this._findState(this._previousStateName)}get previousStateName(){return this._previousStateName}get playable(){let e=!0;for(let t=0;t<this._stateNames.length;t++)this._states[this._stateNames[t]].playable||(e=!1);return e}set playing(e){this._playing=e}get playing(){return this._playing}get activeStateProgress(){return this._getActiveStateProgressForTime(this._timeInState)}get activeStateDuration(){if("START"===this.activeStateName||"END"===this.activeStateName)return 0;let e=0;for(let t=0;t<this.activeStateAnimations.length;t++){const n=this._animEvaluator.findClip(this.activeStateAnimations[t].name);n&&(e=Math.max(e,n.track.duration))}return e}set activeStateCurrentTime(e){this._timeInStateBefore=e,this._timeInState=e;for(let t=0;t<this.activeStateAnimations.length;t++){const n=this.animEvaluator.findClip(this.activeStateAnimations[t].name);n&&(n.time=e)}}get activeStateCurrentTime(){return this._timeInState}get transitioning(){return this._isTransitioning}get transitionProgress(){return this._currTransitionTime/this._totalTransitionTime}get states(){return this._stateNames}assignMask(e){return this._animEvaluator.assignMask(e)}_findState(e){return this._states[e]}_getActiveStateProgressForTime(e){if("START"===this.activeStateName||"END"===this.activeStateName||"ANY"===this.activeStateName)return 1;const t=this._animEvaluator.findClip(this.activeStateAnimations[0].name);return t?e/t.track.duration:null}_findTransitionsFromState(e){let t=this._findTransitionsFromStateCache[e];return t||(t=this._transitions.filter((function(t){return t.from===e})),cv(t),this._findTransitionsFromStateCache[e]=t),t}_findTransitionsBetweenStates(e,t){let n=this._findTransitionsBetweenStatesCache[e+"->"+t];return n||(n=this._transitions.filter((function(n){return n.from===e&&n.to===t})),cv(n),this._findTransitionsBetweenStatesCache[e+"->"+t]=n),n}_transitionHasConditionsMet(e){const t=e.conditions;for(let e=0;e<t.length;e++){const n=t[e],a=this.findParameter(n.parameterName);switch(n.predicate){case"GREATER_THAN":if(!(a.value>n.value))return!1;break;case"LESS_THAN":if(!(a.value<n.value))return!1;break;case"GREATER_THAN_EQUAL_TO":if(!(a.value>=n.value))return!1;break;case"LESS_THAN_EQUAL_TO":if(!(a.value<=n.value))return!1;break;case"EQUAL_TO":if(a.value!==n.value)return!1;break;case"NOT_EQUAL_TO":if(a.value===n.value)return!1}}return!0}_findTransition(e,t){let n=[];if(e&&t)n=n.concat(this._findTransitionsBetweenStates(e,t));else if(this._isTransitioning)switch(this._transitionInterruptionSource){case"PREV_STATE":n=n.concat(this._findTransitionsFromState(this._previousStateName)),n=n.concat(this._findTransitionsFromState("ANY"));break;case"NEXT_STATE":n=n.concat(this._findTransitionsFromState(this._activeStateName)),n=n.concat(this._findTransitionsFromState("ANY"));break;case"PREV_STATE_NEXT_STATE":n=n.concat(this._findTransitionsFromState(this._previousStateName)),n=n.concat(this._findTransitionsFromState(this._activeStateName)),n=n.concat(this._findTransitionsFromState("ANY"));break;case"NEXT_STATE_PREV_STATE":n=n.concat(this._findTransitionsFromState(this._activeStateName)),n=n.concat(this._findTransitionsFromState(this._previousStateName)),n=n.concat(this._findTransitionsFromState("ANY"))}else n=n.concat(this._findTransitionsFromState(this._activeStateName)),n=n.concat(this._findTransitionsFromState("ANY"));if(n=n.filter((e=>{if(e.to===this.activeStateName)return!1;if(e.hasExitTime){let t=this._getActiveStateProgressForTime(this._timeInStateBefore),n=this._getActiveStateProgressForTime(this._timeInState);if(e.exitTime<1&&this.activeState.loop&&(t-=Math.floor(t),n-=Math.floor(n)),!(e.exitTime>t&&e.exitTime<=n))return null}return this._transitionHasConditionsMet(e)})),n.length>0){const e=n[0];if("END"===e.to){const t=this._findTransitionsFromState("START")[0];e.to=t.to}return e}return null}updateStateFromTransition(e){let t,n,a;this.previousState=e.from?this.activeStateName:null,this.activeState=e.to;for(let t=0;t<e.conditions.length;t++){const n=e.conditions[t];"TRIGGER"===this.findParameter(n.parameterName).type&&this._consumedTriggers.add(n.parameterName)}if(this.previousState){this._isTransitioning||(this._transitionPreviousStates=[]),this._transitionPreviousStates.push({name:this._previousStateName,weight:1});const e=Math.min(0!==this._totalTransitionTime?this._currTransitionTime/this._totalTransitionTime:1,1);for(let i=0;i<this._transitionPreviousStates.length;i++){this._isTransitioning?i!==this._transitionPreviousStates.length-1?this._transitionPreviousStates[i].weight*=1-e:this._transitionPreviousStates[i].weight=e:this._transitionPreviousStates[i].weight=1,t=this._findState(this._transitionPreviousStates[i].name);for(let e=0;e<t.animations.length;e++)n=t.animations[e],a=this._animEvaluator.findClip(n.name+".previous."+i),a||(a=this._animEvaluator.findClip(n.name),a.name=n.name+".previous."+i),i!==this._transitionPreviousStates.length-1&&a.pause()}}this._isTransitioning=!0,this._totalTransitionTime=e.time,this._currTransitionTime=0,this._transitionInterruptionSource=e.interruptionSource;const i=this.activeState,s=e.transitionOffset&&e.transitionOffset>0&&e.transitionOffset<1;let r=0,o=0;if(s){const t=i.timelineDuration*e.transitionOffset;r=t,o=t}this._timeInState=r,this._timeInStateBefore=o;for(let t=0;t<i.animations.length;t++){if(a=this._animEvaluator.findClip(i.animations[t].name),a)a.reset();else{const e=Number.isFinite(i.animations[t].speed)?i.animations[t].speed:i.speed;a=new IC(i.animations[t].animTrack,this._timeInState,e,!0,i.loop,this._eventHandler),a.name=i.animations[t].name,this._animEvaluator.addClip(a)}if(e.time>0?a.blendWeight=0:a.blendWeight=i.animations[t].normalizedWeight,a.play(),s)a.time=i.timelineDuration*e.transitionOffset;else{const e=i.speed>=0?0:this.activeStateDuration;a.time=e}}}_transitionToState(e){if(!this._findState(e))return;let t=this._findTransition(this._activeStateName,e);t||(this._animEvaluator.removeClips(),t=new $C({from:null,to:e})),this.updateStateFromTransition(t)}assignAnimation(e,t,n,a){const i=e.split(".");let s=this._findState(i[0]);s||(s=new ZC(this,i[0],1),this._states[i[0]]=s,this._stateNames.push(i[0])),s.addAnimation(i,t),void 0!==n&&(s.speed=n),void 0!==a&&(s.loop=a),!this._playing&&this._activate&&this.playable&&this.play()}removeNodeAnimations(e){if(-1!==PC.indexOf(e))return;const t=this._findState(e);return t?(t.animations=[],!0):void 0}play(e){e&&this._transitionToState(e),this._playing=!0}pause(){this._playing=!1}reset(){this._previousStateName=null,this._activeStateName="START",this._playing=!1,this._currTransitionTime=1,this._totalTransitionTime=1,this._isTransitioning=!1,this._timeInState=0,this._timeInStateBefore=0,this._animEvaluator.removeClips()}rebind(){this._animEvaluator.rebind()}update(e){if(!this._playing)return;let t,n,a;this._timeInStateBefore=this._timeInState,this._timeInState+=e;const i=this._findTransition(this._activeStateName);if(i&&this.updateStateFromTransition(i),this._isTransitioning)if(this._currTransitionTime+=e,this._currTransitionTime<=this._totalTransitionTime){const e=0!==this._totalTransitionTime?this._currTransitionTime/this._totalTransitionTime:1;for(let i=0;i<this._transitionPreviousStates.length;i++){t=this._findState(this._transitionPreviousStates[i].name);const s=this._transitionPreviousStates[i].weight;for(let r=0;r<t.animations.length;r++)n=t.animations[r],a=this._animEvaluator.findClip(n.name+".previous."+i),a&&(a.blendWeight=(1-e)*n.normalizedWeight*s)}t=this.activeState;for(let a=0;a<t.animations.length;a++)n=t.animations[a],this._animEvaluator.findClip(n.name).blendWeight=e*n.normalizedWeight}else{this._isTransitioning=!1;const e=this.activeStateAnimations.length,i=this._animEvaluator.clips.length;for(let t=0;t<i-e;t++)this._animEvaluator.removeClip(0);this._transitionPreviousStates=[],t=this.activeState;for(let e=0;e<t.animations.length;e++)n=t.animations[e],a=this._animEvaluator.findClip(n.name),a&&(a.blendWeight=n.normalizedWeight)}else if(this.activeState._blendTree.constructor!==WC){t=this.activeState;for(let e=0;e<t.animations.length;e++)n=t.animations[e],a=this._animEvaluator.findClip(n.name),a&&(a.blendWeight=n.normalizedWeight,n.parent.syncAnimations&&(a.speed=n.speed))}this._animEvaluator.update(e)}findParameter(e){return this._parameters[e]}}const JC=new Du,eT=new Pu,tT=new Ou,nT=new Mu,aT=new Gu;class iT extends NC{constructor(e,t,n,a,i){super(t),this.animComponent=e,this._mask=a,this.layerName=n,this.layerIndex=i}static _packFloat(e){return e[0]}static _packBoolean(e){return!!e[0]}static _packVec2(e){return JC.x=e[0],JC.y=e[1],JC}static _packVec3(e){return eT.x=e[0],eT.y=e[1],eT.z=e[2],eT}static _packVec4(e){return tT.x=e[0],tT.y=e[1],tT.z=e[2],tT.w=e[3],tT}static _packColor(e){return nT.r=e[0],nT.g=e[1],nT.b=e[2],nT.a=e[3],nT}static _packQuat(e){return aT.x=e[0],aT.y=e[1],aT.z=e[2],aT.w=e[3],aT}resolve(e){const t=OC.encode(e.entityPath,e.component,e.propertyPath);let n,a,i,s=this.targetCache[t];if(s)return s;switch(e.component){case"entity":n=this._getEntityFromHierarchy(e.entityPath),i=OC.encode(n.path,"entity",e.propertyPath),a=n;break;case"graph":if(a=this.findNode(e),!a)return null;i=OC.encode(a.path,"graph",e.propertyPath);break;default:if(n=this._getEntityFromHierarchy(e.entityPath),a=n.findComponent(e.component),!a)return null;i=OC.encode(n.path,e.component,e.propertyPath)}return s=this._createAnimTargetForProperty(a,e.propertyPath,i),this.targetCache[t]=s,s}update(e){const t=this.activeNodes;if(t)for(let e=0;e<t.length;e++)t[e]._dirtifyLocal()}_getEntityFromHierarchy(e){if(!this.animComponent.entity.name===e[0])return null;const t=this.animComponent.entity;return 1===e.length?t:t._parent.findByPath(e)}_resolvePath(e,t,n){const a=t.length-(n?0:1);for(let n=0;n<a;n++)e=e[t[n]];return e}_setter(e,t,n){const a=this._resolvePath(e,t),i=t[t.length-1],s="set"+i.substring(0,1).toUpperCase()+i.substring(1);if(a[s]){let e=a["get"+i.substring(0,1).toUpperCase()+i.substring(1)].bind(a)();e=[e.x,e.y,e.z,e.w];const t=a[s].bind(a);return{set:e=>{t(n(e))},get:()=>e}}const r=a[i];if("object"==typeof r&&r.hasOwnProperty("copy"))return function(e){r.copy(n(e))};if(-1!==[Du,Pu,Ou,Mu,Gu].indexOf(a.constructor)&&t.length>1){const s=t.length>2?this._resolvePath(e,t.slice(0,-1)):e,r=t[t.length-2];return function(e){a[i]=n(e),s[r]=a}}return function(e){a[i]=n(e)}}_createAnimTargetForProperty(e,t,n){if(this.handlers&&"weights"===t[0])return this.handlers.weights(e);if(this.handlers&&"material"===t[0]&&2===t.length){const n=t[1];if(n.endsWith("Map"))return this.handlers.materialTexture(e,n)}const a=this._resolvePath(e,t,!0);if(void 0===a)return null;let i,s,r;if("number"==typeof a)i=this._setter(e,t,iT._packFloat),s="vector",r=1;else if("boolean"==typeof a)i=this._setter(e,t,iT._packBoolean),s="vector",r=1;else if("object"==typeof a)switch(a.constructor){case Du:i=this._setter(e,t,iT._packVec2),s="vector",r=2;break;case Pu:i=this._setter(e,t,iT._packVec3),s="vector",r=3;break;case Ou:i=this._setter(e,t,iT._packVec4),s="vector",r=4;break;case Mu:i=this._setter(e,t,iT._packColor),s="vector",r=4;break;case Gu:i=this._setter(e,t,iT._packQuat),s="quaternion",r=4;break;default:return null}return-1!==t.indexOf("material")?new FC((function(t){i(t),e.material.update()}),s,r,n):new FC(i,s,r,n)}rebind(){this.targetCache={},this.animComponent.rootBone?this.graph=this.animComponent.rootBone:this.graph=this.animComponent.entity;const e={};!function t(n){e[n.name]=n;for(let e=0;e<n.children.length;++e)t(n.children[e])}(this.graph),this.nodes=e}}class sT{constructor(e,t,n,a=1,i="OVERWRITE",s=!0){this._name=e,this._controller=t,this._component=n,this._weight=a,this._blendType=i,this._normalizedWeight=s,this._mask=null,this._blendTime=0,this._blendTimeElapsed=0,this._startingWeight=0,this._targetWeight=0}get name(){return this._name}set playing(e){this._controller.playing=e}get playing(){return this._controller.playing}get playable(){return this._controller.playable}get activeState(){return this._controller.activeStateName}get previousState(){return this._controller.previousStateName}get activeStateProgress(){return this._controller.activeStateProgress}get activeStateDuration(){return this._controller.activeStateDuration}set activeStateCurrentTime(e){const t=this._controller,n=t.playing;t.playing=!0,t.activeStateCurrentTime=e,n||t.update(0),t.playing=n}get activeStateCurrentTime(){return this._controller.activeStateCurrentTime}get transitioning(){return this._controller.transitioning}get transitionProgress(){return this.transitioning?this._controller.transitionProgress:null}get states(){return this._controller.states}set weight(e){this._weight=e,this._component.dirtifyTargets()}get weight(){return this._weight}set blendType(e){e!==this._blendType&&(this._blendType=e,this._controller.normalizeWeights&&this._component.rebind())}get blendType(){return this._blendType}set mask(e){this._controller.assignMask(e)&&this._component.rebind(),this._mask=e}get mask(){return this._mask}play(e){this._controller.play(e)}pause(){this._controller.pause()}reset(){this._controller.reset()}rebind(){this._controller.rebind()}update(e){this._blendTime&&(this._blendTimeElapsed<this._blendTime?(this.weight=Eu.lerp(this._startingWeight,this._targetWeight,this._blendTimeElapsed/this._blendTime),this._blendTimeElapsed+=e):(this.weight=this._targetWeight,this._blendTime=0,this._blendTimeElapsed=0,this._startingWeight=0,this._targetWeight=0)),this._controller.update(e)}blendToWeight(e,t){this._startingWeight=this.weight,this._targetWeight=e,this._blendTime=Math.max(0,t),this._blendTimeElapsed=0}assignMask(e){this._controller.assignMask(e)&&this._component.rebind(),this._mask=e}assignAnimation(e,t,n,a){t.constructor===n_&&(this._controller.assignAnimation(e,t,n,a),0===this._controller._transitions.length&&this._controller._transitions.push(new $C({from:"START",to:e})),this._component.activate&&this._component.playable&&(this._component.playing=!0))}removeNodeAnimations(e){this._controller.removeNodeAnimations(e)&&(this._component.playing=!1)}getAnimationAsset(e){return this._component.animationAssets[`${this.name}:${e}`]}transition(e,t=0,n=null){this._controller.updateStateFromTransition(new $C({from:this._controller.activeStateName,to:e,time:t,transitionOffset:n}))}}class rT extends Ux{constructor(e,t){super(e,t),this._stateGraphAsset=null,this._animationAssets={},this._speed=1,this._activate=!0,this._playing=!1,this._rootBone=null,this._stateGraph=null,this._layers=[],this._layerIndices={},this._parameters={},this._targets={},this._consumedTriggers=new Set,this._normalizeWeights=!1}set stateGraphAsset(e){if(null===e)return void this.removeStateGraph();if(this._stateGraphAsset){this.system.app.assets.get(this._stateGraphAsset).off("change",this._onStateGraphAssetChangeEvent,this)}let t,n;e instanceof f_?(t=e.id,n=this.system.app.assets.get(t),n||(this.system.app.assets.add(e),n=this.system.app.assets.get(t))):(t=e,n=this.system.app.assets.get(t)),n&&this._stateGraphAsset!==t&&(n.resource?(this._stateGraph=n.resource,this.loadStateGraph(this._stateGraph),n.on("change",this._onStateGraphAssetChangeEvent,this)):(n.once("load",(e=>{this._stateGraph=e.resource,this.loadStateGraph(this._stateGraph)})),n.on("change",this._onStateGraphAssetChangeEvent,this),this.system.app.assets.load(n)),this._stateGraphAsset=t)}get stateGraphAsset(){return this._stateGraphAsset}set normalizeWeights(e){this._normalizeWeights=e,this.unbind()}get normalizeWeights(){return this._normalizeWeights}set animationAssets(e){this._animationAssets=e,this.loadAnimationAssets()}get animationAssets(){return this._animationAssets}set speed(e){this._speed=e}get speed(){return this._speed}set activate(e){this._activate=e}get activate(){return this._activate}set playing(e){this._playing=e}get playing(){return this._playing}set rootBone(e){if("string"==typeof e){const t=this.entity.root.findByGuid(e);this._rootBone=t}else this._rootBone=e instanceof KM?e:null;this.rebind()}get rootBone(){return this._rootBone}set stateGraph(e){this._stateGraph=e}get stateGraph(){return this._stateGraph}get layers(){return this._layers}set layerIndices(e){this._layerIndices=e}get layerIndices(){return this._layerIndices}set parameters(e){this._parameters=e}get parameters(){return this._parameters}set targets(e){this._targets=e}get targets(){return this._targets}get playable(){for(let e=0;e<this._layers.length;e++)if(!this._layers[e].playable)return!1;return!0}get baseLayer(){return this._layers.length>0?this._layers[0]:null}_onStateGraphAssetChangeEvent(e){const t=this.animationAssets,n=this.layers.map((e=>e.mask));this.removeStateGraph(),this._stateGraph=new Z_(e._data),this.loadStateGraph(this._stateGraph),this.animationAssets=t,this.loadAnimationAssets(),this.layers.forEach(((e,t)=>{e.mask=n[t]})),this.rebind()}dirtifyTargets(){const e=Object.values(this._targets);for(let t=0;t<e.length;t++)e[t].dirty=!0}_addLayer({name:e,states:t,transitions:n,weight:a,mask:i,blendType:s}){let r;r=this.rootBone?this.rootBone:this.entity;const o=this._layers.length,l=new iT(this,r,e,i,o),c=new DC(l),h=new QC(c,t,n,this._parameters,this._activate,this,this._consumedTriggers);return this._layers.push(new sT(e,h,this,a,s)),this._layerIndices[e]=o,this._layers[o]}addLayer(e,t,n,a){const i=this.findAnimationLayer(e);if(i)return i;return this._addLayer({name:e,states:[{name:"START",speed:1}],transitions:[],weight:t,mask:n,blendType:a})}loadStateGraph(e){this._stateGraph=e,this._parameters={};const t=Object.keys(e.parameters);for(let n=0;n<t.length;n++){const a=t[n];this._parameters[a]={type:e.parameters[a].type,value:e.parameters[a].value}}this._layers=[];for(let t=0;t<e.layers.length;t++){const n=e.layers[t];this._addLayer.bind(this)(Sw({},n))}this.setupAnimationAssets()}setupAnimationAssets(){for(let e=0;e<this._layers.length;e++){const t=this._layers[e],n=t.name;for(let e=0;e<t.states.length;e++){const a=t.states[e];if(-1===PC.indexOf(a)){const e=n+":"+a;this._animationAssets[e]||(this._animationAssets[e]={asset:null})}}}this.loadAnimationAssets()}loadAnimationAssets(){for(let e=0;e<this._layers.length;e++){const t=this._layers[e];for(let e=0;e<t.states.length;e++){const n=t.states[e];if(-1!==PC.indexOf(n))continue;const a=this._animationAssets[t.name+":"+n];if(!a||!a.asset){this.removeNodeAnimations(n,t.name);continue}const i=a.asset,s=this.system.app.assets.get(i);s&&(s.resource?this.onAnimationAssetLoaded(t.name,n,s):(s.once("load",function(e,t){return function(n){this.onAnimationAssetLoaded(e,t,n)}.bind(this)}.bind(this)(t.name,n)),this.system.app.assets.load(s)))}}}onAnimationAssetLoaded(e,t,n){const a=n.resource;n.data.events&&(a.events=new t_(Object.values(n.data.events))),this.findAnimationLayer(e).assignAnimation(t,n.resource)}removeStateGraph(){this._stateGraph=null,this._stateGraphAsset=null,this._animationAssets={},this._layers=[],this._layerIndices={},this._parameters={},this._playing=!1,this.unbind(),this._targets={}}reset(){this._parameters=Object.assign({},this._stateGraph.parameters);for(let e=0;e<this._layers.length;e++){const t=this._layers[e].playing;this._layers[e].reset(),this._layers[e].playing=t}}unbind(){this._normalizeWeights||Object.keys(this._targets).forEach((e=>{this._targets[e].unbind()}))}rebind(){this._targets={};for(let e=0;e<this._layers.length;e++)this._layers[e].rebind()}findAnimationLayer(e){const t=this._layerIndices[e];return this._layers[t]||null}addAnimationState(e,t,n=1,a=!0,i="Base"){this._stateGraph||this.loadStateGraph(new Z_({layers:[{name:i,states:[{name:"START",speed:1},{name:e,speed:n,loop:a,defaultState:!0}],transitions:[{from:"START",to:e}]}],parameters:{}}));const s=this.findAnimationLayer(i);var r;s?s.assignAnimation(e,t,n,a):null==(r=this.addLayer(i))||r.assignAnimation(e,t,n,a)}assignAnimation(e,t,n,a=1,i=!0){if(!this._stateGraph&&-1===e.indexOf("."))return this.loadStateGraph(new Z_({layers:[{name:"Base",states:[{name:"START",speed:1},{name:e,speed:a,loop:i,defaultState:!0}],transitions:[{from:"START",to:e}]}],parameters:{}})),void this.baseLayer.assignAnimation(e,t);const s=n?this.findAnimationLayer(n):this.baseLayer;s&&s.assignAnimation(e,t,a,i)}removeNodeAnimations(e,t){const n=t?this.findAnimationLayer(t):this.baseLayer;n&&n.removeNodeAnimations(e)}getParameterValue(e,t){const n=this._parameters[e];if(n&&n.type===t)return n.value}setParameterValue(e,t,n){const a=this._parameters[e];a&&a.type===t&&(a.value=n)}getFloat(e){return this.getParameterValue(e,"FLOAT")}setFloat(e,t){this.setParameterValue(e,"FLOAT",t)}getInteger(e){return this.getParameterValue(e,"INTEGER")}setInteger(e,t){"number"==typeof t&&t%1==0&&this.setParameterValue(e,"INTEGER",t)}getBoolean(e){return this.getParameterValue(e,"BOOLEAN")}setBoolean(e,t){this.setParameterValue(e,"BOOLEAN",!!t)}getTrigger(e){return this.getParameterValue(e,"TRIGGER")}setTrigger(e,t=!1){this.setParameterValue(e,"TRIGGER",!0),t&&this._consumedTriggers.add(e)}resetTrigger(e){this.setParameterValue(e,"TRIGGER",!1)}onBeforeRemove(){if(Number.isFinite(this._stateGraphAsset)){this.system.app.assets.get(this._stateGraphAsset).off("change",this._onStateGraphAssetChangeEvent,this)}}update(e){for(let t=0;t<this.layers.length;t++)this.layers[t].update(e*this.speed);this._consumedTriggers.forEach((e=>{this.parameters[e].value=!1})),this._consumedTriggers.clear()}resolveDuplicatedEntityReferenceProperties(e,t){e.rootBone&&t[e.rootBone.getGuid()]?this.rootBone=t[e.rootBone.getGuid()]:this.rebind()}}class oT{constructor(){this.enabled=!0}}const lT=["enabled"];class cT extends AC{constructor(e){super(e),this.id="anim",this.ComponentType=rT,this.DataType=oT,this.schema=lT,this.on("beforeremove",this.onBeforeRemove,this),this.app.systems.on("animationUpdate",this.onAnimationUpdate,this)}initializeComponentData(e,t,n){super.initializeComponentData(e,t,lT);const a=["animationAssets","stateGraph","layers","masks"];Object.keys(t).forEach((n=>{a.includes(n)||(e[n]=t[n])})),t.stateGraph&&(e.stateGraph=t.stateGraph,e.loadStateGraph(e.stateGraph)),t.layers?t.layers.forEach(((t,n)=>{t._controller.states.forEach((a=>{t._controller._states[a]._animationList.forEach((t=>{e.layers[n].assignAnimation(t.name,t.animTrack)}))}))})):t.animationAssets&&(e.animationAssets=Object.assign(e.animationAssets,t.animationAssets)),t.masks&&Object.keys(t.masks).forEach((n=>{if(e.layers[n]){const a=t.masks[n].mask,i={};Object.keys(a).forEach((e=>{i[decodeURI(e)]=a[e]})),e.layers[n].mask=i}}))}onAnimationUpdate(e){const t=this.store;for(const n in t)if(t.hasOwnProperty(n)){const a=t[n].entity.anim;a.data.enabled&&a.entity.enabled&&a.playing&&a.update(e)}}cloneComponent(e,t){let n;e.anim.rootBone&&e.anim.rootBone!==e||(n={},e.anim.layers.forEach(((e,a)=>{if(e.mask){const i={};Object.keys(e.mask).forEach((n=>{const a=n.split("/");a.shift();const s=[t.name,...a].join("/");i[s]=e.mask[n]})),n[a]={mask:i}}})));const a={stateGraphAsset:e.anim.stateGraphAsset,animationAssets:e.anim.animationAssets,speed:e.anim.speed,activate:e.anim.activate,playing:e.anim.playing,rootBone:e.anim.rootBone,stateGraph:e.anim.stateGraph,layers:e.anim.layers,layerIndices:e.anim.layerIndices,parameters:e.anim.parameters,normalizeWeights:e.anim.normalizeWeights,masks:n};return this.addComponent(t,a)}onBeforeRemove(e,t){t.onBeforeRemove()}destroy(){super.destroy(),this.app.systems.off("animationUpdate",this.onAnimationUpdate,this)}}Ux._buildAccessors(rT.prototype,lT);class hT extends Ux{constructor(e,t){super(e,t)}setCurrentListener(){if(this.enabled&&this.entity.audiolistener&&this.entity.enabled){this.system.current=this.entity;const e=this.system.current.getPosition();this.system.manager.listener.setPosition(e)}}onEnable(){this.setCurrentListener()}onDisable(){this.system.current===this.entity&&(this.system.current=null)}}class dT{constructor(){this.enabled=!0}}const pT=["enabled"];class uT extends AC{constructor(e,t){super(e),this.id="audiolistener",this.ComponentType=hT,this.DataType=dT,this.schema=pT,this.manager=t,this.current=null,this.app.systems.on("update",this.onUpdate,this)}initializeComponentData(e,t,n){n=["enabled"],super.initializeComponentData(e,t,n)}onUpdate(e){if(this.current){const e=this.current.getPosition();this.manager.listener.setPosition(e);const t=this.current.getWorldTransform();this.manager.listener.setOrientation(t)}}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this)}}Ux._buildAccessors(hT.prototype,pT);class mT extends Ux{constructor(e,t){super(e,t),this.on("set_assets",this.onSetAssets,this),this.on("set_loop",this.onSetLoop,this),this.on("set_volume",this.onSetVolume,this),this.on("set_pitch",this.onSetPitch,this),this.on("set_minDistance",this.onSetMinDistance,this),this.on("set_maxDistance",this.onSetMaxDistance,this),this.on("set_rollOffFactor",this.onSetRollOffFactor,this),this.on("set_distanceModel",this.onSetDistanceModel,this),this.on("set_3d",this.onSet3d,this)}play(e){if(!this.enabled||!this.entity.enabled)return;let t;this.channel&&this.stop();const n=this.data;if(n.sources[e])if(n["3d"]){const a=this.entity.getPosition();t=this.system.manager.playSound3d(n.sources[e],a,n),n.currentSource=e,n.channel=t}else t=this.system.manager.playSound(n.sources[e],n),n.currentSource=e,n.channel=t}pause(){this.channel&&this.channel.pause()}unpause(){this.channel&&this.channel.paused&&this.channel.unpause()}stop(){this.channel&&(this.channel.stop(),this.channel=null)}onSetAssets(e,t,n){const a=[],i=n.length;if(t&&t.length)for(let e=0;e<t.length;e++)if(t[e]){const n=this.system.app.assets.get(t[e]);n&&(n.off("change",this.onAssetChanged,this),n.off("remove",this.onAssetRemoved,this),this.currentSource===n.name&&this.stop())}if(i)for(let e=0;e<i;e++)t.indexOf(n[e])<0&&(n[e]instanceof f_?a.push(n[e].id):a.push(n[e]));!this.system._inTools&&a.length&&this.loadAudioSourceAssets(a)}onAssetChanged(e,t,n,a){if("resource"===t){this.data.sources&&(this.data.sources[e.name]=n,this.data.currentSource===e.name&&this.channel&&(this.channel.paused?(this.play(e.name),this.pause()):this.play(e.name)))}}onAssetRemoved(e){e.off("remove",this.onAssetRemoved,this),this.data.sources[e.name]&&(delete this.data.sources[e.name],this.data.currentSource===e.name&&(this.stop(),this.data.currentSource=null))}onSetLoop(e,t,n){t!==n&&this.channel&&this.channel.setLoop(n)}onSetVolume(e,t,n){t!==n&&this.channel&&this.channel.setVolume(n)}onSetPitch(e,t,n){t!==n&&this.channel&&this.channel.setPitch(n)}onSetMaxDistance(e,t,n){t!==n&&this.channel instanceof Hv&&this.channel.setMaxDistance(n)}onSetMinDistance(e,t,n){t!==n&&this.channel instanceof Hv&&this.channel.setMinDistance(n)}onSetRollOffFactor(e,t,n){t!==n&&this.channel instanceof Hv&&this.channel.setRollOffFactor(n)}onSetDistanceModel(e,t,n){t!==n&&this.channel instanceof Hv&&this.channel.setDistanceModel(n)}onSet3d(e,t,n){if(t!==n&&this.system.initialized&&this.currentSource){let e=!1,t=!1;this.channel&&(e=this.channel.paused,t=this.channel.suspended),this.play(this.currentSource),this.channel&&(this.channel.paused=e,this.channel.suspended=t)}}onEnable(){const e=this.data.assets;if(e){const t=this.system.app.assets;for(let n=0,a=e.length;n<a;n++){let a=e[n];a instanceof f_||(a=t.get(a)),a&&!a.resource&&t.load(a)}}this.system.initialized&&(this.data.activate&&!this.channel?this.play(this.currentSource):this.unpause())}onDisable(){this.pause()}loadAudioSourceAssets(e){const t=e.map((e=>this.system.app.assets.get(e))),n={};let a=null,i=t.length;const s=e=>{i--},r=()=>{this.data.sources=n,this.data.currentSource=a,this.enabled&&this.activate&&a&&this.onEnable()};t.forEach(((t,o)=>{t?(a=a||t.name,t.off("change",this.onAssetChanged,this),t.on("change",this.onAssetChanged,this),t.off("remove",this.onAssetRemoved,this),t.on("remove",this.onAssetRemoved,this),t.off("error",s,this),t.on("error",s,this),t.ready((e=>{n[e.name]=e.resource,i--,0===i&&r()})),!t.resource&&this.enabled&&this.entity.enabled&&this.system.app.assets.load(t)):(i--,0===i&&r(),this.system.app.assets.on("add:"+e[o],(e=>{e.ready((e=>{this.data.sources[e.name]=e.resource})),e.resource||this.system.app.assets.load(e)})))}))}}class fT{constructor(){this.enabled=!0,this.assets=[],this.activate=!0,this.volume=1,this.pitch=1,this.loop=!1,this["3d"]=!0,this.minDistance=1,this.maxDistance=1e4,this.rollOffFactor=1,this.distanceModel="inverse",this.paused=!0,this.sources={},this.currentSource=null,this.channel=null}}const gT=["enabled","assets","volume","pitch","loop","activate","3d","minDistance","maxDistance","rollOffFactor","distanceModel","sources","currentSource","channel"];class yT extends AC{constructor(e,t){super(e),this.id="audiosource",this.ComponentType=mT,this.DataType=fT,this.schema=gT,this.manager=t,this.initialized=!1,this.app.systems.on("initialize",this.onInitialize,this),this.app.systems.on("update",this.onUpdate,this),this.on("remove",this.onRemove,this)}initializeComponentData(e,t,n){n=["activate","volume","pitch","loop","3d","minDistance","maxDistance","rollOffFactor","distanceModel","enabled","assets"],super.initializeComponentData(e,t,n),e.paused=!(e.enabled&&e.activate)}onInitialize(e){e.audiosource&&e.enabled&&e.audiosource.enabled&&e.audiosource.activate&&e.audiosource.play(e.audiosource.currentSource);const t=e._children;for(let e=0,n=t.length;e<n;e++)t[e]instanceof KM&&this.onInitialize(t[e]);this.initialized=!0}onUpdate(e){const t=this.store;for(const e in t)if(t.hasOwnProperty(e)){const n=t[e],a=n.entity,i=n.data;if(i.enabled&&a.enabled&&i.channel instanceof Hv){const e=a.getPosition();i.channel.setPosition(e)}}}onRemove(e,t){t.channel&&(t.channel.stop(),t.channel=null)}setVolume(e){this.manager.setVolume(e)}destroy(){super.destroy(),this.app.systems.off("initialize",this.onInitialize,this),this.app.systems.off("update",this.onUpdate,this)}}Ux._buildAccessors(mT.prototype,gT);class bT extends Qp{constructor(e,t,n){if(super(),!(e&&e instanceof Ux))throw new Error("The parentComponent argument is required and must be a Component");if(!t||"string"!=typeof t)throw new Error("The propertyName argument is required and must be a string");if(n&&"object"!=typeof n)throw new Error("If provided, the eventConfig argument must be an object");this._parentComponent=e,this._entityPropertyName=t,this._entity=null,this._app=e.system.app,this._configureEventListeners(n||{},{"entity#destroy":this._onEntityDestroy}),this._toggleLifecycleListeners("on")}_configureEventListeners(e,t){const n=this._parseEventListenerConfig(e,"external",this._parentComponent),a=this._parseEventListenerConfig(t,"internal",this);this._eventListenerConfigs=n.concat(a),this._listenerStatusFlags={},this._gainListeners={},this._loseListeners={}}_parseEventListenerConfig(e,t,n){return Object.keys(e).map((function(a,i){const s=a.split("#"),r=s[0],o=s[1],l=e[a];if(2!==s.length||"string"!=typeof r||0===r.length||"string"!=typeof o||0===o.length)throw new Error("Invalid event listener description: `"+a+"`");if("function"!=typeof l)throw new Error("Invalid or missing callback for event listener `"+a+"`");return{id:t+"_"+i+"_"+a,sourceName:r,eventName:o,callback:l,scope:n}}),this)}_toggleLifecycleListeners(e){this._parentComponent[e]("set_"+this._entityPropertyName,this._onSetEntity,this),this._parentComponent.system[e]("beforeremove",this._onParentComponentRemove,this),this._app.systems[e]("postPostInitialize",this._updateEntityReference,this),this._app[e]("tools:sceneloaded",this._onSceneLoaded,this);const t=[];for(let e=0;e<this._eventListenerConfigs.length;++e){const n=this._eventListenerConfigs[e],a=this._app.systems[n.sourceName];a&&(-1===t.indexOf(a)&&t.push(a),a&&"gain"===n.eventName&&(this._gainListeners[n.sourceName]=n),a&&"lose"===n.eventName&&(this._loseListeners[n.sourceName]=n))}for(let n=0;n<t.length;++n)t[n][e]("add",this._onComponentAdd,this),t[n][e]("beforeremove",this._onComponentRemove,this)}_onSetEntity(e,t,n){if(n instanceof KM)this._updateEntityReference();else{if(null!=n&&"string"!=typeof n)return void console.warn("Entity field `"+this._entityPropertyName+"` was set to unexpected type '"+typeof n+"'");t!==n&&this._updateEntityReference()}}onParentComponentEnable(){this._entity||this._updateEntityReference()}_onSceneLoaded(){this._updateEntityReference()}_updateEntityReference(){let e,t=this._parentComponent.data[this._entityPropertyName];if(t instanceof KM)e=t,t=e.getGuid(),this._parentComponent.data[this._entityPropertyName]=t;else{const n=this._parentComponent.system.app.root;e=this._parentComponent.entity.isDescendantOf(n)&&t?n.findByGuid(t):null}this._entity!==e&&(this._entity&&this._onBeforeEntityChange(),this._entity=e,this._entity&&this._onAfterEntityChange(),this.fire("set:entity",this._entity))}_onBeforeEntityChange(){this._toggleEntityListeners("off"),this._callAllGainOrLoseListeners(this._loseListeners)}_onAfterEntityChange(){this._toggleEntityListeners("on"),this._callAllGainOrLoseListeners(this._gainListeners)}_onComponentAdd(e,t){const n=t.system.id;e===this._entity&&(this._callGainOrLoseListener(n,this._gainListeners),this._toggleComponentListeners("on",n))}_onComponentRemove(e,t){const n=t.system.id;e===this._entity&&(this._callGainOrLoseListener(n,this._loseListeners),this._toggleComponentListeners("off",n,!0))}_callAllGainOrLoseListeners(e){for(const t in this._entity.c)this._callGainOrLoseListener(t,e)}_callGainOrLoseListener(e,t){if(this._entity.c.hasOwnProperty(e)&&t[e]){const n=t[e];n.callback.call(n.scope)}}_toggleEntityListeners(e,t){if(this._entity)for(let n=0;n<this._eventListenerConfigs.length;++n)this._safeToggleListener(e,this._eventListenerConfigs[n],t)}_toggleComponentListeners(e,t,n){for(let a=0;a<this._eventListenerConfigs.length;++a){const i=this._eventListenerConfigs[a];i.sourceName===t&&this._safeToggleListener(e,i,n)}}_safeToggleListener(e,t,n){const a="on"===e;if(a&&this._listenerStatusFlags[t.id])return;const i=this._getEventSource(t.sourceName,n);i&&(i[e](t.eventName,t.callback,t.scope),this._listenerStatusFlags[t.id]=a)}_getEventSource(e,t){if("entity"===e)return this._entity;const n=this._entity[e];return n||(t||console.warn("Entity has no component with name "+e),null)}_onEntityDestroy(e){this._entity===e&&(this._toggleEntityListeners("off",!0),this._entity=null)}_onParentComponentRemove(e,t){t===this._parentComponent&&(this._toggleLifecycleListeners("off"),this._toggleEntityListeners("off",!0))}hasComponent(e){return!(!this._entity||!this._entity.c)&&!!this._entity.c[e]}get entity(){return this._entity}}const vT="DEFAULT",_T="HOVER",wT="PRESSED",xT="INACTIVE",CT={};CT[vT]="_defaultTint",CT[_T]="hoverTint",CT[wT]="pressedTint",CT[xT]="inactiveTint";const TT={};TT[vT]="_defaultSpriteAsset",TT[_T]="hoverSpriteAsset",TT[wT]="pressedSpriteAsset",TT[xT]="inactiveSpriteAsset";const ET={};ET[vT]="_defaultSpriteFrame",ET[_T]="hoverSpriteFrame",ET[wT]="pressedSpriteFrame",ET[xT]="inactiveSpriteFrame";class ST extends Ux{constructor(e,t){super(e,t),this._visualState=vT,this._isHovering=!1,this._hoveringCounter=0,this._isPressed=!1,this._defaultTint=new Mu(1,1,1,1),this._defaultSpriteAsset=null,this._defaultSpriteFrame=0,this._imageReference=new bT(this,"imageEntity",{"element#gain":this._onImageElementGain,"element#lose":this._onImageElementLose,"element#set:color":this._onSetColor,"element#set:opacity":this._onSetOpacity,"element#set:spriteAsset":this._onSetSpriteAsset,"element#set:spriteFrame":this._onSetSpriteFrame}),this._toggleLifecycleListeners("on",e)}_toggleLifecycleListeners(e,t){this[e]("set_active",this._onSetActive,this),this[e]("set_transitionMode",this._onSetTransitionMode,this),this[e]("set_hoverTint",this._onSetTransitionValue,this),this[e]("set_pressedTint",this._onSetTransitionValue,this),this[e]("set_inactiveTint",this._onSetTransitionValue,this),this[e]("set_hoverSpriteAsset",this._onSetTransitionValue,this),this[e]("set_hoverSpriteFrame",this._onSetTransitionValue,this),this[e]("set_pressedSpriteAsset",this._onSetTransitionValue,this),this[e]("set_pressedSpriteFrame",this._onSetTransitionValue,this),this[e]("set_inactiveSpriteAsset",this._onSetTransitionValue,this),this[e]("set_inactiveSpriteFrame",this._onSetTransitionValue,this),t.app.systems.element[e]("add",this._onElementComponentAdd,this),t.app.systems.element[e]("beforeremove",this._onElementComponentRemove,this)}_onSetActive(e,t,n){t!==n&&this._updateVisualState()}_onSetTransitionMode(e,t,n){t!==n&&(this._cancelTween(),this._resetToDefaultVisualState(t),this._forceReapplyVisualState())}_onSetTransitionValue(e,t,n){t!==n&&this._forceReapplyVisualState()}_onElementComponentRemove(e){this.entity===e&&this._toggleHitElementListeners("off")}_onElementComponentAdd(e){this.entity===e&&this._toggleHitElementListeners("on")}_onImageElementLose(){this._cancelTween(),this._resetToDefaultVisualState(this.transitionMode)}_onImageElementGain(){this._storeDefaultVisualState(),this._forceReapplyVisualState()}_toggleHitElementListeners(e){if(this.entity.element){const t="on"===e;if(t&&this._hasHitElementListeners)return;this.entity.element[e]("mouseenter",this._onMouseEnter,this),this.entity.element[e]("mouseleave",this._onMouseLeave,this),this.entity.element[e]("mousedown",this._onMouseDown,this),this.entity.element[e]("mouseup",this._onMouseUp,this),this.entity.element[e]("touchstart",this._onTouchStart,this),this.entity.element[e]("touchend",this._onTouchEnd,this),this.entity.element[e]("touchleave",this._onTouchLeave,this),this.entity.element[e]("touchcancel",this._onTouchCancel,this),this.entity.element[e]("selectstart",this._onSelectStart,this),this.entity.element[e]("selectend",this._onSelectEnd,this),this.entity.element[e]("selectenter",this._onSelectEnter,this),this.entity.element[e]("selectleave",this._onSelectLeave,this),this.entity.element[e]("click",this._onClick,this),this._hasHitElementListeners=t}}_storeDefaultVisualState(){if(this._imageReference.hasComponent("element")){const e=this._imageReference.entity.element;"group"!==e.type&&(this._storeDefaultColor(e.color),this._storeDefaultOpacity(e.opacity),this._storeDefaultSpriteAsset(e.spriteAsset),this._storeDefaultSpriteFrame(e.spriteFrame))}}_storeDefaultColor(e){this._defaultTint.r=e.r,this._defaultTint.g=e.g,this._defaultTint.b=e.b}_storeDefaultOpacity(e){this._defaultTint.a=e}_storeDefaultSpriteAsset(e){this._defaultSpriteAsset=e}_storeDefaultSpriteFrame(e){this._defaultSpriteFrame=e}_onSetColor(e){this._isApplyingTint||(this._storeDefaultColor(e),this._forceReapplyVisualState())}_onSetOpacity(e){this._isApplyingTint||(this._storeDefaultOpacity(e),this._forceReapplyVisualState())}_onSetSpriteAsset(e){this._isApplyingSprite||(this._storeDefaultSpriteAsset(e),this._forceReapplyVisualState())}_onSetSpriteFrame(e){this._isApplyingSprite||(this._storeDefaultSpriteFrame(e),this._forceReapplyVisualState())}_onMouseEnter(e){this._isHovering=!0,this._updateVisualState(),this._fireIfActive("mouseenter",e)}_onMouseLeave(e){this._isHovering=!1,this._isPressed=!1,this._updateVisualState(),this._fireIfActive("mouseleave",e)}_onMouseDown(e){this._isPressed=!0,this._updateVisualState(),this._fireIfActive("mousedown",e)}_onMouseUp(e){this._isPressed=!1,this._updateVisualState(),this._fireIfActive("mouseup",e)}_onTouchStart(e){this._isPressed=!0,this._updateVisualState(),this._fireIfActive("touchstart",e)}_onTouchEnd(e){e.event.preventDefault(),this._isPressed=!1,this._updateVisualState(),this._fireIfActive("touchend",e)}_onTouchLeave(e){this._isPressed=!1,this._updateVisualState(),this._fireIfActive("touchleave",e)}_onTouchCancel(e){this._isPressed=!1,this._updateVisualState(),this._fireIfActive("touchcancel",e)}_onSelectStart(e){this._isPressed=!0,this._updateVisualState(),this._fireIfActive("selectstart",e)}_onSelectEnd(e){this._isPressed=!1,this._updateVisualState(),this._fireIfActive("selectend",e)}_onSelectEnter(e){this._hoveringCounter++,1===this._hoveringCounter&&(this._isHovering=!0,this._updateVisualState()),this._fireIfActive("selectenter",e)}_onSelectLeave(e){this._hoveringCounter--,0===this._hoveringCounter&&(this._isHovering=!1,this._isPressed=!1,this._updateVisualState()),this._fireIfActive("selectleave",e)}_onClick(e){this._fireIfActive("click",e)}_fireIfActive(e,t){this.data.active&&this.fire(e,t)}_updateVisualState(e){const t=this._visualState,n=this._determineVisualState();if((t!==n||e)&&this.enabled)switch(this._visualState=n,t===_T&&this._fireIfActive("hoverend"),t===wT&&this._fireIfActive("pressedend"),n===_T&&this._fireIfActive("hoverstart"),n===wT&&this._fireIfActive("pressedstart"),this.transitionMode){case 0:{const e=this[CT[this._visualState]];this._applyTint(e);break}case 1:{const e=TT[this._visualState],t=ET[this._visualState],n=this[e],a=this[t];this._applySprite(n,a);break}}}_forceReapplyVisualState(){this._updateVisualState(!0)}_resetToDefaultVisualState(e){if(this._imageReference.hasComponent("element"))switch(e){case 0:this._cancelTween(),this._applyTintImmediately(this._defaultTint);break;case 1:this._applySprite(this._defaultSpriteAsset,this._defaultSpriteFrame)}}_determineVisualState(){return this.active?this._isPressed?wT:this._isHovering?_T:vT:xT}_applySprite(e,t){t=t||0,this._imageReference.hasComponent("element")&&(this._isApplyingSprite=!0,this._imageReference.entity.element.spriteAsset!==e&&(this._imageReference.entity.element.spriteAsset=e),this._imageReference.entity.element.spriteFrame!==t&&(this._imageReference.entity.element.spriteFrame=t),this._isApplyingSprite=!1)}_applyTint(e){this._cancelTween(),0===this.fadeDuration?this._applyTintImmediately(e):this._applyTintWithTween(e)}_applyTintImmediately(e){if(!e||!this._imageReference.hasComponent("element")||"group"===this._imageReference.entity.element.type)return;const t=AT(e);this._isApplyingTint=!0,t.equals(this._imageReference.entity.element.color)||(this._imageReference.entity.element.color=t),this._imageReference.entity.element.opacity!=e.a&&(this._imageReference.entity.element.opacity=e.a),this._isApplyingTint=!1}_applyTintWithTween(e){if(!e||!this._imageReference.hasComponent("element")||"group"===this._imageReference.entity.element.type)return;const t=AT(e),n=this._imageReference.entity.element.color,a=this._imageReference.entity.element.opacity;t.equals(n)&&e.a==a||(this._tweenInfo={startTime:xu(),from:new Mu(n.r,n.g,n.b,a),to:e.clone(),lerpColor:new Mu})}_updateTintTween(){const e=xu()-this._tweenInfo.startTime;let t=0===this.fadeDuration?1:e/this.fadeDuration;if(t=Eu.clamp(t,0,1),Math.abs(t-1)>1e-5){const e=this._tweenInfo.lerpColor;e.lerp(this._tweenInfo.from,this._tweenInfo.to,t),this._applyTintImmediately(new Mu(e.r,e.g,e.b,e.a))}else this._applyTintImmediately(this._tweenInfo.to),this._cancelTween()}_cancelTween(){delete this._tweenInfo}onUpdate(){this._tweenInfo&&this._updateTintTween()}onEnable(){this._isHovering=!1,this._hoveringCounter=0,this._isPressed=!1,this._imageReference.onParentComponentEnable(),this._toggleHitElementListeners("on"),this._forceReapplyVisualState()}onDisable(){this._toggleHitElementListeners("off"),this._resetToDefaultVisualState(this.transitionMode)}onRemove(){this._toggleLifecycleListeners("off",this.system),this.onDisable()}}function AT(e){return new Mu(e.r,e.g,e.b)}class MT{constructor(){this.enabled=!0,this.active=!0,this.imageEntity=null,this.hitPadding=new Ou,this.transitionMode=0,this.hoverTint=new Mu(.75,.75,.75),this.pressedTint=new Mu(.5,.5,.5),this.inactiveTint=new Mu(.25,.25,.25),this.fadeDuration=0,this.hoverSpriteAsset=null,this.hoverSpriteFrame=0,this.pressedSpriteAsset=null,this.pressedSpriteFrame=0,this.inactiveSpriteAsset=null,this.inactiveSpriteFrame=0}}const LT=["enabled","active",{name:"imageEntity",type:"entity"},{name:"hitPadding",type:"vec4"},"transitionMode",{name:"hoverTint",type:"rgba"},{name:"pressedTint",type:"rgba"},{name:"inactiveTint",type:"rgba"},"fadeDuration","hoverSpriteAsset","hoverSpriteFrame","pressedSpriteAsset","pressedSpriteFrame","inactiveSpriteAsset","inactiveSpriteFrame"];class RT extends AC{constructor(e){super(e),this.id="button",this.ComponentType=ST,this.DataType=MT,this.schema=LT,this.on("beforeremove",this._onRemoveComponent,this),this.app.systems.on("update",this.onUpdate,this)}initializeComponentData(e,t,n){super.initializeComponentData(e,t,LT)}onUpdate(e){const t=this.store;for(const e in t){const n=t[e].entity,a=n.button;a.enabled&&n.enabled&&a.onUpdate()}}_onRemoveComponent(e,t){t.onRemove()}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this)}}let IT;Ux._buildAccessors(ST.prototype,LT);class PT{constructor(e,t){this.effect=e,this.inputTarget=t,this.outputTarget=null,this.name=e.constructor.name}}class kT{constructor(e,t){this.app=e,this.camera=t,this.destinationRenderTarget=null,this.effects=[],this.enabled=!1,this.depthTarget=null,this.renderTargetScale=1,this.resizeTimeout=null,this.resizeLast=0,this._resizeTimeoutCallback=()=>{this.resizeRenderTargets()},t.on("set:rect",this.onCameraRectChanged,this)}_allocateColorBuffer(e,t){const n=this.camera.rect,a=Math.floor(n.z*this.app.graphicsDevice.width*this.renderTargetScale),i=Math.floor(n.w*this.app.graphicsDevice.height*this.renderTargetScale);return new Gm(this.app.graphicsDevice,{name:t,format:e,width:a,height:i,mipmaps:!1,minFilter:0,magFilter:0,addressU:1,addressV:1})}_createOffscreenTarget(e,t){const n=this.app.graphicsDevice,a=t?n.getHdrFormat():7,i=this.camera.entity.name+"-posteffect-"+this.effects.length,s=this._allocateColorBuffer(a,i),r=this.app.graphicsDevice.supportsStencil,o=e?n.samples:1;return new Cg({colorBuffer:s,depth:e,stencil:r,samples:o})}_resizeOffscreenTarget(e){const t=e.colorBuffer.format,n=e.colorBuffer.name;e.destroyFrameBuffers(),e.destroyTextureBuffers(),e._colorBuffer=this._allocateColorBuffer(t,n)}_destroyOffscreenTarget(e){e.destroyTextureBuffers(),e.destroy()}setRenderTargetScale(e){this.renderTargetScale=e,this.resizeRenderTargets()}addEffect(e){const t=this.effects,n=0===t.length,a=this._createOffscreenTarget(n,e.hdr),i=new PT(e,a);t.push(i),this._sourceTarget=i.inputTarget,t.length>1&&(t[t.length-2].outputTarget=i.inputTarget),this._newPostEffect=e,e.needsDepthBuffer&&this._requestDepthMap(),this.enable(),this._newPostEffect=void 0}removeEffect(e){let t=-1;for(let n=0,a=this.effects.length;n<a;n++)if(this.effects[n].effect===e){t=n;break}t>=0&&(t>0?this.effects[t-1].outputTarget=t+1<this.effects.length?this.effects[t+1].inputTarget:null:this.effects.length>1&&(this.effects[1].inputTarget._depth||(this._destroyOffscreenTarget(this.effects[1].inputTarget),this.effects[1].inputTarget=this._createOffscreenTarget(!0,this.effects[1].hdr),this._sourceTarget=this.effects[1].inputTarget),this.camera.renderTarget=this.effects[1].inputTarget),this._destroyOffscreenTarget(this.effects[t].inputTarget),this.effects.splice(t,1)),this.enabled&&e.needsDepthBuffer&&this._releaseDepthMap(),0===this.effects.length&&this.disable()}_requestDepthMaps(){for(let e=0,t=this.effects.length;e<t;e++){const t=this.effects[e].effect;this._newPostEffect!==t&&(t.needsDepthBuffer&&this._requestDepthMap())}}_releaseDepthMaps(){for(let e=0,t=this.effects.length;e<t;e++){this.effects[e].effect.needsDepthBuffer&&this._releaseDepthMap()}}_requestDepthMap(){IT||(IT=this.app.scene.layers.getLayerById(1)),IT&&IT.incrementCounter()}_releaseDepthMap(){IT&&IT.decrementCounter()}destroy(){for(let e=0,t=this.effects.length;e<t;e++)this.effects[e].inputTarget.destroy();this.effects.length=0,this.disable()}enable(){!this.enabled&&this.effects.length&&(this.enabled=!0,this._requestDepthMaps(),this.app.graphicsDevice.on("resizecanvas",this._onCanvasResized,this),this.destinationRenderTarget=this.camera.renderTarget,this.camera.renderTarget=this.effects[0].inputTarget,this.camera.onPostprocessing=()=>{if(this.enabled){let e=null;const t=this.effects.length;if(t)for(let n=0;n<t;n++){const a=this.effects[n];let i=a.outputTarget;n===t-1&&(e=this.camera.rect,this.destinationRenderTarget&&(i=this.destinationRenderTarget)),a.effect.render(a.inputTarget,i,e)}}})}disable(){this.enabled&&(this.enabled=!1,this.app.graphicsDevice.off("resizecanvas",this._onCanvasResized,this),this._releaseDepthMaps(),this._destroyOffscreenTarget(this._sourceTarget),this.camera.renderTarget=null,this.camera.onPostprocessing=null)}_onCanvasResized(e,t){const n=this.camera.rect,a=this.app.graphicsDevice;this.camera.camera.aspectRatio=a.width*n.z/(a.height*n.w),this.resizeTimeout||(xu()-this.resizeLast>100?this.resizeRenderTargets():this.resizeTimeout=setTimeout(this._resizeTimeoutCallback,100))}resizeRenderTargets(){this.resizeTimeout&&(clearTimeout(this.resizeTimeout),this.resizeTimeout=null),this.resizeLast=xu();const e=this.camera.rect,t=Math.floor(e.z*this.app.graphicsDevice.width*this.renderTargetScale),n=Math.floor(e.w*this.app.graphicsDevice.height*this.renderTargetScale),a=this.effects;for(let e=0,i=a.length;e<i;e++){const i=a[e];i.inputTarget.width===t&&i.inputTarget.height===n||this._resizeOffscreenTarget(i.inputTarget)}}onCameraRectChanged(e,t,n){this.enabled&&this.resizeRenderTargets()}}const DT=[{name:"aspectRatio",readonly:!1},{name:"aspectRatioMode",readonly:!1},{name:"calculateProjection",readonly:!1},{name:"calculateTransform",readonly:!1},{name:"clearColor",readonly:!1},{name:"cullFaces",readonly:!1},{name:"farClip",readonly:!1},{name:"flipFaces",readonly:!1},{name:"fov",readonly:!1},{name:"frustumCulling",readonly:!1},{name:"horizontalFov",readonly:!1},{name:"nearClip",readonly:!1},{name:"orthoHeight",readonly:!1},{name:"projection",readonly:!1},{name:"scissorRect",readonly:!1},{name:"vrDisplay",readonly:!1}];class OT extends Ux{constructor(e,t){super(e,t),this.onPostprocessing=null,this.onPreRender=null,this.onPostRender=null,this._camera=new Ym,this._camera.node=t,this._priority=0,this._disablePostEffectsLayer=4,this._postEffects=new kT(e.app,this)}get camera(){return this._camera}set clearColorBuffer(e){this._camera.clearColorBuffer=e,this.dirtyLayerCompositionCameras()}get clearColorBuffer(){return this._camera.clearColorBuffer}set clearDepthBuffer(e){this._camera.clearDepthBuffer=e,this.dirtyLayerCompositionCameras()}get clearDepthBuffer(){return this._camera.clearDepthBuffer}set clearStencilBuffer(e){this._camera.clearStencilBuffer=e,this.dirtyLayerCompositionCameras()}get clearStencilBuffer(){return this._camera.clearStencilBuffer}set disablePostEffectsLayer(e){this._disablePostEffectsLayer=e,this.dirtyLayerCompositionCameras()}get disablePostEffectsLayer(){return this._disablePostEffectsLayer}get frustum(){return this._camera.frustum}set layers(e){const t=this._camera.layers;for(let e=0;e<t.length;e++){const n=this.system.app.scene.layers.getLayerById(t[e]);n&&n.removeCamera(this)}if(this._camera.layers=e,this.enabled&&this.entity.enabled)for(let t=0;t<e.length;t++){const n=this.system.app.scene.layers.getLayerById(e[t]);n&&n.addCamera(this)}}get layers(){return this._camera.layers}get postEffectsEnabled(){return this._postEffects.enabled}get postEffects(){return this._postEffects}set priority(e){this._priority=e,this.dirtyLayerCompositionCameras()}get priority(){return this._priority}get projectionMatrix(){return this._camera.projectionMatrix}set rect(e){this._camera.rect=e,this.fire("set:rect",this._camera.rect)}get rect(){return this._camera.rect}set renderTarget(e){this._camera.renderTarget=e,this.dirtyLayerCompositionCameras()}get renderTarget(){return this._camera.renderTarget}get viewMatrix(){return this._camera.viewMatrix}dirtyLayerCompositionCameras(){this.system.app.scene.layers._dirtyCameras=!0}screenToWorld(e,t,n,a){const i=this.system.app.graphicsDevice,s=i.clientRect.width,r=i.clientRect.height;return this._camera.screenToWorld(e,t,n,s,r,a)}worldToScreen(e,t){const n=this.system.app.graphicsDevice,a=n.clientRect.width,i=n.clientRect.height;return this._camera.worldToScreen(e,a,i,t)}onAppPrerender(){this._camera._viewMatDirty=!0,this._camera._viewProjMatDirty=!0}addCameraToLayers(){const e=this.layers;for(let t=0;t<e.length;t++){const n=this.system.app.scene.layers.getLayerById(e[t]);n&&n.addCamera(this)}}removeCameraFromLayers(){const e=this.layers;for(let t=0;t<e.length;t++){const n=this.system.app.scene.layers.getLayerById(e[t]);n&&n.removeCamera(this)}}onLayersChanged(e,t){this.addCameraToLayers(),e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this)}onLayerAdded(e){this.layers.indexOf(e.id)<0||e.addCamera(this)}onLayerRemoved(e){this.layers.indexOf(e.id)<0||e.removeCamera(this)}onEnable(){const e=this.system,t=e.app.scene,n=t.layers;e.addCamera(this),t.on("set:layers",this.onLayersChanged,this),n&&(n.on("add",this.onLayerAdded,this),n.on("remove",this.onLayerRemoved,this)),this.enabled&&this.entity.enabled&&this.addCameraToLayers(),this.postEffects.enable()}onDisable(){const e=this.system,t=e.app.scene,n=t.layers;this.postEffects.disable(),this.removeCameraFromLayers(),t.off("set:layers",this.onLayersChanged,this),n&&(n.off("add",this.onLayerAdded,this),n.off("remove",this.onLayerRemoved,this)),e.removeCamera(this)}onRemove(){this.onDisable(),this.off()}calculateAspectRatio(e){const t=e||this.system.app.graphicsDevice,n=this.rect;return t.width*n.z/(t.height*n.w)}frameBegin(e){0===this.aspectRatioMode&&(this.aspectRatio=this.calculateAspectRatio(e))}frameEnd(){}enterVr(e,t){if(e instanceof Function&&!t&&(t=e,e=null),this.system.app.vr)if(e||(e=this.system.app.vr.display),e){const n=this;e.capabilities.canPresent?e.requestPresent((function(a){a||(n.vrDisplay=e,n.vrDisplay.once("beforepresentchange",(function(e){e.presenting||(n.vrDisplay=null)}))),t(a)})):(n.vrDisplay=e,t())}else t("No pc.VrDisplay to present");else t("VrManager not created. Enable VR in project settings.")}exitVr(e){if(this.vrDisplay)if(this.vrDisplay.capabilities.canPresent){const t=this.vrDisplay;this.vrDisplay=null,t.exitPresent(e)}else this.vrDisplay=null,e();else e("Not presenting VR")}startXr(e,t,n){this.system.app.xr.start(this,e,t,n)}endXr(e){this._camera.xr?this._camera.xr.end(e):e&&e(new Error("Camera is not in XR"))}copy(e){DT.forEach((t=>{if(!t.readonly){const n=t.name;this[n]=e[n]}})),this.clearColorBuffer=e.clearColorBuffer,this.clearDepthBuffer=e.clearDepthBuffer,this.clearStencilBuffer=e.clearStencilBuffer,this.disablePostEffectsLayer=e.disablePostEffectsLayer,this.layers=e.layers,this.priority=e.priority,this.renderTarget=e.renderTarget,this.rect=e.rect}}DT.forEach((function(e){const t=e.name,n={get:function(){return this._camera[t]}};e.readonly||(n.set=function(e){this._camera[t]=e}),Object.defineProperty(OT.prototype,t,n)}));class FT{constructor(){this.enabled=!0}}const NT=["enabled"];class VT extends AC{constructor(e){super(e),this.cameras=[],this.id="camera",this.ComponentType=OT,this.DataType=FT,this.schema=NT,this.on("beforeremove",this.onBeforeRemove,this),this.app.on("prerender",this.onAppPrerender,this),this.app.systems.on("update",this.onUpdate,this)}initializeComponentData(e,t,n){n=["aspectRatio","aspectRatioMode","calculateProjection","calculateTransform","clearColor","clearColorBuffer","clearDepthBuffer","clearStencilBuffer","cullFaces","farClip","flipFaces","fov","frustumCulling","horizontalFov","layers","renderTarget","nearClip","orthoHeight","projection","priority","rect","scissorRect"];for(let a=0;a<n.length;a++){const i=n[a];if(t.hasOwnProperty(i)){const n=t[i];switch(i){case"rect":case"scissorRect":Array.isArray(n)?e[i]=new Ou(n[0],n[1],n[2],n[3]):e[i]=n;break;case"clearColor":Array.isArray(n)?e[i]=new Mu(n[0],n[1],n[2],n[3]):e[i]=n;break;default:e[i]=n}}}super.initializeComponentData(e,t,["enabled"])}cloneComponent(e,t){const n=e.camera;return this.addComponent(t,{aspectRatio:n.aspectRatio,aspectRatioMode:n.aspectRatioMode,calculateProjection:n.calculateProjection,calculateTransform:n.calculateTransform,clearColor:n.clearColor,clearColorBuffer:n.clearColorBuffer,clearDepthBuffer:n.clearDepthBuffer,clearStencilBuffer:n.clearStencilBuffer,cullFaces:n.cullFaces,enabled:n.enabled,farClip:n.farClip,flipFaces:n.flipFaces,fov:n.fov,frustumCulling:n.frustumCulling,horizontalFov:n.horizontalFov,layers:n.layers,renderTarget:n.renderTarget,nearClip:n.nearClip,orthoHeight:n.orthoHeight,projection:n.projection,priority:n.priority,rect:n.rect,scissorRect:n.scissorRect})}onBeforeRemove(e,t){this.removeCamera(t)}onUpdate(e){if(this.app.vr){const e=this.store;for(const t in e){const n=e[t];if(n.data.enabled&&n.entity.enabled){const e=n.entity.camera,t=e.vrDisplay;t&&(t.setClipPlanes(e.nearClip,e.farClip),n.entity&&(n.entity.localTransform.copy(t.combinedViewInv),n.entity._dirtyLocal=!1,n.entity._dirtifyWorld()))}}}}onAppPrerender(){for(let e=0,t=this.cameras.length;e<t;e++)this.cameras[e].onAppPrerender()}addCamera(e){this.cameras.push(e),cv(this.cameras)}removeCamera(e){const t=this.cameras.indexOf(e);t>=0&&(this.cameras.splice(t,1),cv(this.cameras))}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this)}}Ux._buildAccessors(OT.prototype,NT);class BT extends Ux{constructor(e,t){super(e,t),this._compoundParent=null,this.entity.on("insert",this._onInsert,this),this.on("set_type",this.onSetType,this),this.on("set_halfExtents",this.onSetHalfExtents,this),this.on("set_radius",this.onSetRadius,this),this.on("set_height",this.onSetHeight,this),this.on("set_axis",this.onSetAxis,this),this.on("set_asset",this.onSetAsset,this),this.on("set_renderAsset",this.onSetRenderAsset,this),this.on("set_model",this.onSetModel,this),this.on("set_render",this.onSetRender,this)}onSetType(e,t,n){t!==n&&this.system.changeType(this,t,n)}onSetHalfExtents(e,t,n){const a=this.data.type;this.data.initialized&&"box"===a&&this.system.recreatePhysicalShapes(this)}onSetRadius(e,t,n){const a=this.data.type;!this.data.initialized||"sphere"!==a&&"capsule"!==a&&"cylinder"!==a&&"cone"!==a||this.system.recreatePhysicalShapes(this)}onSetHeight(e,t,n){const a=this.data.type;!this.data.initialized||"capsule"!==a&&"cylinder"!==a&&"cone"!==a||this.system.recreatePhysicalShapes(this)}onSetAxis(e,t,n){const a=this.data.type;!this.data.initialized||"capsule"!==a&&"cylinder"!==a&&"cone"!==a||this.system.recreatePhysicalShapes(this)}onSetAsset(e,t,n){const a=this.system.app.assets;if(t){const e=a.get(t);e&&e.off("remove",this.onAssetRemoved,this)}if(n){n instanceof f_&&(this.data.asset=n.id);const e=a.get(this.data.asset);e&&(e.off("remove",this.onAssetRemoved,this),e.on("remove",this.onAssetRemoved,this))}this.data.initialized&&"mesh"===this.data.type&&(n||(this.data.model=null),this.system.recreatePhysicalShapes(this))}onSetRenderAsset(e,t,n){const a=this.system.app.assets;if(t){const e=a.get(t);e&&e.off("remove",this.onRenderAssetRemoved,this)}if(n){n instanceof f_&&(this.data.renderAsset=n.id);const e=a.get(this.data.renderAsset);e&&(e.off("remove",this.onRenderAssetRemoved,this),e.on("remove",this.onRenderAssetRemoved,this))}this.data.initialized&&"mesh"===this.data.type&&(n||(this.data.render=null),this.system.recreatePhysicalShapes(this))}onSetModel(e,t,n){this.data.initialized&&"mesh"===this.data.type&&this.system.implementations.mesh.doRecreatePhysicalShape(this)}onSetRender(e,t,n){this.onSetModel(e,t,n)}onAssetRemoved(e){e.off("remove",this.onAssetRemoved,this),this.data.asset===e.id&&(this.asset=null)}onRenderAssetRemoved(e){e.off("remove",this.onRenderAssetRemoved,this),this.data.renderAsset===e.id&&(this.renderAsset=null)}_getCompoundChildShapeIndex(e){const t=this.data.shape,n=t.getNumChildShapes();for(let a=0;a<n;a++){if(t.getChildShape(a).ptr===e.ptr)return a}return null}_onInsert(e){if("undefined"!=typeof Ammo)if(this._compoundParent)this.system.recreatePhysicalShapes(this);else if(!this.entity.rigidbody){let e=this.entity.parent;for(;e;){if(e.collision&&"compound"===e.collision.type){0===e.collision.shape.getNumChildShapes()?this.system.recreatePhysicalShapes(e.collision):this.system.recreatePhysicalShapes(this);break}e=e.parent}}}_updateCompound(){const e=this.entity;if(e._dirtyWorld){let t=e._dirtyLocal,n=e;for(;n&&!t&&(!n.collision||n.collision!==this._compoundParent);)n._dirtyLocal&&(t=!0),n=n.parent;if(t){e.forEach(this.system.implementations.compound._updateEachDescendantTransform,e);const t=this._compoundParent.entity.rigidbody;t&&t.activate()}}}onEnable(){if("mesh"===this.data.type&&(this.data.asset||this.data.renderAsset)&&this.data.initialized){const e=this.system.app.assets.get(this.data.asset||this.data.renderAsset);if(e&&(!e.resource||!this.data.shape))return void this.system.recreatePhysicalShapes(this)}if(this.entity.rigidbody)this.entity.rigidbody.enabled&&this.entity.rigidbody.enableSimulation();else if(this._compoundParent&&this!==this._compoundParent)if(0===this._compoundParent.shape.getNumChildShapes())this.system.recreatePhysicalShapes(this._compoundParent);else{const e=this.system._getNodeTransform(this.entity,this._compoundParent.entity);this._compoundParent.shape.addChildShape(e,this.data.shape),Ammo.destroy(e),this._compoundParent.entity.rigidbody&&this._compoundParent.entity.rigidbody.activate()}else this.entity.trigger&&this.entity.trigger.enable()}onDisable(){this.entity.rigidbody?this.entity.rigidbody.disableSimulation():this._compoundParent&&this!==this._compoundParent?this._compoundParent.entity._destroying||(this.system._removeCompoundChild(this._compoundParent,this.data.shape),this._compoundParent.entity.rigidbody&&this._compoundParent.entity.rigidbody.activate()):this.entity.trigger&&this.entity.trigger.disable()}onBeforeRemove(){this.asset&&(this.asset=null),this.renderAsset&&(this.renderAsset=null),this.entity.off("insert",this._onInsert,this),this.off()}}class UT{constructor(){this.enabled=!0,this.type="box",this.halfExtents=new Pu(.5,.5,.5),this.radius=.5,this.axis=1,this.height=2,this.asset=null,this.renderAsset=null,this.shape=null,this.model=null,this.render=null,this.initialized=!1}}let zT,GT,HT;class WT{constructor(e,t,n){this.entity=t.entity,this.component=t,this.app=e,"undefined"==typeof Ammo||zT||(zT=new Ammo.btVector3,GT=new Ammo.btQuaternion,HT=new Ammo.btTransform),this.initialize(n)}initialize(e){const t=this.entity,n=e.shape;if(n&&"undefined"!=typeof Ammo){t.trigger&&t.trigger.destroy();const e=1,a=t.getPosition(),i=t.getRotation();zT.setValue(a.x,a.y,a.z),GT.setValue(i.x,i.y,i.z,i.w),HT.setOrigin(zT),HT.setRotation(GT);const s=this.app.systems.rigidbody.createBody(e,n,HT);s.setRestitution(0),s.setFriction(0),s.setDamping(0,0),zT.setValue(0,0,0),s.setLinearFactor(zT),s.setAngularFactor(zT),s.setCollisionFlags(4|s.getCollisionFlags()),s.entity=t,this.body=s,this.component.enabled&&t.enabled&&this.enable()}}destroy(){const e=this.body;e&&(this.disable(),this.app.systems.rigidbody.destroyBody(e))}_getEntityTransform(e){const t=this.entity.getPosition(),n=this.entity.getRotation();zT.setValue(t.x,t.y,t.z),GT.setValue(n.x,n.y,n.z,n.w),e.setOrigin(zT),e.setRotation(GT)}updateTransform(){this._getEntityTransform(HT);const e=this.body;e.setWorldTransform(HT),e.activate()}enable(){const e=this.body;if(!e)return;const t=this.app.systems;t.rigidbody.addBody(e,16,65517),t.rigidbody._triggers.push(this),e.forceActivationState(1),this.updateTransform()}disable(){const e=this.body;if(!e)return;const t=this.app.systems,n=t.rigidbody._triggers.indexOf(this);n>-1&&t.rigidbody._triggers.splice(n,1),t.rigidbody.removeBody(e),e.forceActivationState(5)}}const jT=new zu,XT=new Pu,YT=new Gu,qT=new hf,KT=["enabled","type","halfExtents","radius","axis","height","asset","renderAsset","shape","model","render"];class ZT{constructor(e){this.system=e}beforeInitialize(e,t){t.shape=null,t.model=new Dv,t.model.graph=new hf}afterInitialize(e,t){this.recreatePhysicalShapes(e),e.data.initialized=!0}reset(e,t){this.beforeInitialize(e,t),this.afterInitialize(e,t)}recreatePhysicalShapes(e){const t=e.entity,n=e.data;if("undefined"!=typeof Ammo){t.trigger&&(t.trigger.destroy(),delete t.trigger),n.shape&&(e._compoundParent&&(this.system._removeCompoundChild(e._compoundParent,n.shape),e._compoundParent.entity.rigidbody&&e._compoundParent.entity.rigidbody.activate()),Ammo.destroy(n.shape),n.shape=null),n.shape=this.createPhysicalShape(e.entity,n);const a=!e._compoundParent;if("compound"!==n.type||e._compoundParent&&e!==e._compoundParent){if("compound"!==n.type&&(e._compoundParent&&e===e._compoundParent&&t.forEach(this.system.implementations.compound._updateEachDescendant,e),!e.rigidbody)){e._compoundParent=null;let n=t.parent;for(;n;){if(n.collision&&"compound"===n.collision.type){e._compoundParent=n.collision;break}n=n.parent}}}else e._compoundParent=e,t.forEach(this._addEachDescendant,e);e._compoundParent&&e!==e._compoundParent&&(a&&0===e._compoundParent.shape.getNumChildShapes()?this.system.recreatePhysicalShapes(e._compoundParent):(this.system.updateCompoundChildTransform(t),e._compoundParent.entity.rigidbody&&e._compoundParent.entity.rigidbody.activate())),t.rigidbody?(t.rigidbody.disableSimulation(),t.rigidbody.createBody(),t.enabled&&t.rigidbody.enabled&&t.rigidbody.enableSimulation()):e._compoundParent||(t.trigger?t.trigger.initialize(n):t.trigger=new WT(this.system.app,e,n))}}createPhysicalShape(e,t){}updateTransform(e,t,n,a){e.entity.trigger&&e.entity.trigger.updateTransform()}beforeRemove(e,t){t.data.shape&&(t._compoundParent&&!t._compoundParent.entity._destroying&&(this.system._removeCompoundChild(t._compoundParent,t.data.shape),t._compoundParent.entity.rigidbody&&t._compoundParent.entity.rigidbody.activate()),t._compoundParent=null,Ammo.destroy(t.data.shape),t.data.shape=null)}remove(e,t){const n=this.system.app;e.rigidbody&&e.rigidbody.body&&e.rigidbody.disableSimulation(),e.trigger&&(e.trigger.destroy(),delete e.trigger),n.scene.containsModel(t.model)&&(n.root.removeChild(t.model.graph),n.scene.removeModel(t.model))}clone(e,t){const n=this.system.store[e.getGuid()],a={enabled:n.data.enabled,type:n.data.type,halfExtents:[n.data.halfExtents.x,n.data.halfExtents.y,n.data.halfExtents.z],radius:n.data.radius,axis:n.data.axis,height:n.data.height,asset:n.data.asset,renderAsset:n.data.renderAsset,model:n.data.model,render:n.data.render};return this.system.addComponent(t,a)}}class $T extends ZT{createPhysicalShape(e,t){if("undefined"!=typeof Ammo){const e=t.halfExtents,n=new Ammo.btVector3(e?e.x:.5,e?e.y:.5,e?e.z:.5),a=new Ammo.btBoxShape(n);return Ammo.destroy(n),a}}}class QT extends ZT{createPhysicalShape(e,t){if("undefined"!=typeof Ammo)return new Ammo.btSphereShape(t.radius)}}class JT extends ZT{createPhysicalShape(e,t){const n=void 0!==t.axis?t.axis:1,a=t.radius||.5,i=Math.max((t.height||2)-2*a,0);let s=null;if("undefined"!=typeof Ammo)switch(n){case 0:s=new Ammo.btCapsuleShapeX(a,i);break;case 1:s=new Ammo.btCapsuleShape(a,i);break;case 2:s=new Ammo.btCapsuleShapeZ(a,i)}return s}}class eE extends ZT{createPhysicalShape(e,t){const n=void 0!==t.axis?t.axis:1,a=void 0!==t.radius?t.radius:.5,i=void 0!==t.height?t.height:1;let s=null,r=null;if("undefined"!=typeof Ammo)switch(n){case 0:s=new Ammo.btVector3(.5*i,a,a),r=new Ammo.btCylinderShapeX(s);break;case 1:s=new Ammo.btVector3(a,.5*i,a),r=new Ammo.btCylinderShape(s);break;case 2:s=new Ammo.btVector3(a,a,.5*i),r=new Ammo.btCylinderShapeZ(s)}return s&&Ammo.destroy(s),r}}class tE extends ZT{createPhysicalShape(e,t){const n=void 0!==t.axis?t.axis:1,a=void 0!==t.radius?t.radius:.5,i=void 0!==t.height?t.height:1;let s=null;if("undefined"!=typeof Ammo)switch(n){case 0:s=new Ammo.btConeShapeX(a,i);break;case 1:s=new Ammo.btConeShape(a,i);break;case 2:s=new Ammo.btConeShapeZ(a,i)}return s}}class nE extends ZT{beforeInitialize(e,t){}createAmmoMesh(e,t,n){let a;if(this.system._triMeshCache[e.id])a=this.system._triMeshCache[e.id];else{const t=e.vertexBuffer,n=t.getFormat();let i,s;for(let e=0;e<n.elements.length;e++){const a=n.elements[e];if("POSITION"===a.name){s=new Float32Array(t.lock(),a.offset),i=a.stride/4;break}}const r=[];e.getIndices(r);const o=e.primitive[0].count/3,l=new Ammo.btVector3,c=new Ammo.btVector3,h=new Ammo.btVector3;let d,p,u;const m=e.primitive[0].base;a=new Ammo.btTriangleMesh,this.system._triMeshCache[e.id]=a;for(let e=0;e<o;e++)d=r[m+3*e]*i,p=r[m+3*e+1]*i,u=r[m+3*e+2]*i,l.setValue(s[d],s[d+1],s[d+2]),c.setValue(s[p],s[p+1],s[p+2]),h.setValue(s[u],s[u+1],s[u+2]),a.addTriangle(l,c,h,!0);Ammo.destroy(l),Ammo.destroy(c),Ammo.destroy(h)}const i=new Ammo.btBvhTriangleMeshShape(a,!0),s=this.system._getNodeScaling(t);i.setLocalScaling(s),Ammo.destroy(s);const r=this.system._getNodeTransform(t);n.addChildShape(r,i),Ammo.destroy(r)}createPhysicalShape(e,t){if("undefined"!=typeof Ammo&&(t.model||t.render)){const n=new Ammo.btCompoundShape;if(t.model){const e=t.model.meshInstances;for(let t=0;t<e.length;t++)this.createAmmoMesh(e[t].mesh,e[t].node,n)}else if(t.render){const e=t.render.meshes;for(let t=0;t<e.length;t++)this.createAmmoMesh(e[t],qT,n)}const a=e.getWorldTransform().getScale(),i=new Ammo.btVector3(a.x,a.y,a.z);return n.setLocalScaling(i),Ammo.destroy(i),n}}recreatePhysicalShapes(e){const t=e.data;(t.renderAsset||t.asset)&&e.enabled&&e.entity.enabled?this.loadAsset(e,t.renderAsset||t.asset,t.renderAsset?"render":"model"):this.doRecreatePhysicalShape(e)}loadAsset(e,t,n){const a=e.data,i=this.system.app.assets,s=i.get(t);s?(s.ready((t=>{a[n]=t.resource,this.doRecreatePhysicalShape(e)})),i.load(s)):i.once("add:"+t,(t=>{t.ready((t=>{a[n]=t.resource,this.doRecreatePhysicalShape(e)})),i.load(t)}))}doRecreatePhysicalShape(e){const t=e.entity,n=e.data;n.model||n.render?(this.destroyShape(n),n.shape=this.createPhysicalShape(t,n),t.rigidbody?(t.rigidbody.disableSimulation(),t.rigidbody.createBody(),t.enabled&&t.rigidbody.enabled&&t.rigidbody.enableSimulation()):t.trigger?t.trigger.initialize(n):t.trigger=new WT(this.system.app,e,n)):(this.beforeRemove(t,e),this.remove(t,n))}updateTransform(e,t,n,a){if(e.shape){const t=e.entity.getWorldTransform().getScale(),n=e.shape.getLocalScaling();t.x===n.x()&&t.y===n.y()&&t.z===n.z()||this.doRecreatePhysicalShape(e)}super.updateTransform(e,t,n,a)}destroyShape(e){if(!e.shape)return;const t=e.shape.getNumChildShapes();for(let n=0;n<t;n++){const t=e.shape.getChildShape(n);Ammo.destroy(t)}Ammo.destroy(e.shape),e.shape=null}remove(e,t){this.destroyShape(t),super.remove(e,t)}}class aE extends ZT{createPhysicalShape(e,t){if("undefined"!=typeof Ammo)return new Ammo.btCompoundShape}_addEachDescendant(e){e.collision&&!e.rigidbody&&(e.collision._compoundParent=this,e!==this.entity&&e.collision.system.recreatePhysicalShapes(e.collision))}_updateEachDescendant(e){e.collision&&e.collision._compoundParent===this&&(e.collision._compoundParent=null,e===this.entity||e.rigidbody||e.collision.system.recreatePhysicalShapes(e.collision))}_updateEachDescendantTransform(e){e.collision&&e.collision._compoundParent===this.collision._compoundParent&&this.collision.system.updateCompoundChildTransform(e)}}class iE extends AC{constructor(e){super(e),this.id="collision",this.ComponentType=BT,this.DataType=UT,this.schema=KT,this.implementations={},this._triMeshCache={},this.on("beforeremove",this.onBeforeRemove,this),this.on("remove",this.onRemove,this)}initializeComponentData(e,t,n){const a={};for(let e=0,i=(n=["type","halfExtents","radius","axis","height","shape","model","asset","render","renderAsset","enabled"]).length;e<i;e++){const i=n[e];a[i]=t[i]}let i;t.hasOwnProperty("asset")?(i=n.indexOf("model"),-1!==i&&n.splice(i,1),i=n.indexOf("render"),-1!==i&&n.splice(i,1)):t.hasOwnProperty("model")&&(i=n.indexOf("asset"),-1!==i&&n.splice(i,1)),a.type||(a.type=e.data.type),e.data.type=a.type,a.halfExtents&&Array.isArray(a.halfExtents)&&(a.halfExtents=new Pu(a.halfExtents[0],a.halfExtents[1],a.halfExtents[2]));const s=this._createImplementation(a.type);s.beforeInitialize(e,a),super.initializeComponentData(e,a,n),s.afterInitialize(e,a)}_createImplementation(e){if(void 0===this.implementations[e]){let t;switch(e){case"box":t=new $T(this);break;case"sphere":t=new QT(this);break;case"capsule":t=new JT(this);break;case"cylinder":t=new eE(this);break;case"cone":t=new tE(this);break;case"mesh":t=new nE(this);break;case"compound":t=new aE(this)}this.implementations[e]=t}return this.implementations[e]}_getImplementation(e){return this.implementations[e.collision.data.type]}cloneComponent(e,t){return this._getImplementation(e).clone(e,t)}onBeforeRemove(e,t){this.implementations[t.data.type].beforeRemove(e,t),t.onBeforeRemove()}onRemove(e,t){this.implementations[t.type].remove(e,t)}updateCompoundChildTransform(e){if(this._removeCompoundChild(e.collision._compoundParent,e.collision.data.shape),e.enabled&&e.collision.enabled){const t=this._getNodeTransform(e,e.collision._compoundParent.entity);e.collision._compoundParent.shape.addChildShape(t,e.collision.data.shape),Ammo.destroy(t)}}_removeCompoundChild(e,t){if(e.shape.removeChildShape)e.shape.removeChildShape(t);else{const n=e._getCompoundChildShapeIndex(t);null!==n&&e.shape.removeChildShapeByIndex(n)}}onTransformChanged(e,t,n,a){this.implementations[e.data.type].updateTransform(e,t,n,a)}changeType(e,t,n){this.implementations[t].beforeRemove(e.entity,e),this.implementations[t].remove(e.entity,e.data),this._createImplementation(n).reset(e,e.data)}recreatePhysicalShapes(e){this.implementations[e.data.type].recreatePhysicalShapes(e)}_calculateNodeRelativeTransform(e,t){if(e===t){const t=e.getWorldTransform().getScale();jT.setScale(t.x,t.y,t.z)}else this._calculateNodeRelativeTransform(e.parent,t),jT.mul(e.getLocalTransform())}_getNodeScaling(e){const t=e.getWorldTransform().getScale();return new Ammo.btVector3(t.x,t.y,t.z)}_getNodeTransform(e,t){let n,a;t?(this._calculateNodeRelativeTransform(e,t),n=XT,a=YT,jT.getTranslation(n),a.setFromMat4(jT)):(n=e.getPosition(),a=e.getRotation());const i=new Ammo.btTransform;i.setIdentity();const s=i.getOrigin();s.setValue(n.x,n.y,n.z);const r=new Ammo.btQuaternion;return r.setValue(a.x,a.y,a.z,a.w),i.setRotation(r),Ammo.destroy(r),Ammo.destroy(s),i}destroy(){for(const e in this._triMeshCache)Ammo.destroy(this._triMeshCache[e]);this._triMeshCache=null,super.destroy()}}Ux._buildAccessors(BT.prototype,KT);class sE extends Qp{constructor(){super(),this.anim=void 0,this.animation=void 0,this.audiolistener=void 0,this.audiosource=void 0,this.button=void 0,this.camera=void 0,this.collision=void 0,this.element=void 0,this.joint=void 0,this.layoutchild=void 0,this.layoutgroup=void 0,this.light=void 0,this.model=void 0,this.particlesystem=void 0,this.render=void 0,this.rigidbody=void 0,this.screen=void 0,this.script=void 0,this.scrollbar=void 0,this.scrollview=void 0,this.sound=void 0,this.sprite=void 0,this.zone=void 0,this.list=[]}add(e){const t=e.id;if(this[t])throw new Error(`ComponentSystem name '${t}' already registered or not allowed`);this[t]=e,this.list.push(e)}remove(e){const t=e.id;if(!this[t])throw new Error(`No ComponentSystem named '${t}' registered`);delete this[t];const n=this.list.indexOf(this[t]);-1!==n&&this.list.splice(n,1)}destroy(){this.off();for(let e=0;e<this.list.length;e++)this.list[e].destroy()}}class rE{constructor(e){this.func=void 0===e.func?7:e.func,this.ref=e.ref||0,this.readMask=void 0===e.readMask?255:e.readMask,this.writeMask=void 0===e.writeMask?255:e.writeMask,this.fail=e.fail||0,this.zfail=e.zfail||0,this.zpass=e.zpass||0}clone(){return new rE({func:this.func,ref:this.ref,readMask:this.readMask,writeMask:this.writeMask,fail:this.fail,zfail:this.zfail,zpass:this.zpass})}}class oE{constructor(e,t,n){this._entity=e,this._element=e.element,this.model=new Dv,this.node=new hf,this.model.graph=this.node,this.mesh=t,this.meshInstance=new Ay(this.mesh,n,this.node),this.meshInstance.name="ImageElement: "+e.name,this.meshInstance.castShadow=!1,this.meshInstance.receiveShadow=!1,this._meshDirty=!1,this.model.meshInstances.push(this.meshInstance),this._entity.addChild(this.model.graph),this.model._entity=this._entity,this.unmaskMeshInstance=null}destroy(){this.setMaterial(null),this._element.removeModelFromLayers(this.model),this.model.destroy(),this.model=null,this.node=null,this.mesh=null,this.meshInstance=null,this._entity=null,this._element=null}setMesh(e){this.meshInstance&&(this.mesh=e,this.meshInstance.mesh=e,this.meshInstance.visible=!!e,this.unmaskMeshInstance&&(this.unmaskMeshInstance.mesh=e),this.forceUpdateAabb())}setMask(e){if(this.meshInstance){if(e){this.unmaskMeshInstance=new Ay(this.mesh,this.meshInstance.material,this.node),this.unmaskMeshInstance.name="Unmask: "+this._entity.name,this.unmaskMeshInstance.castShadow=!1,this.unmaskMeshInstance.receiveShadow=!1,this.unmaskMeshInstance.pick=!1,this.model.meshInstances.push(this.unmaskMeshInstance);for(const e in this.meshInstance.parameters)this.unmaskMeshInstance.setParameter(e,this.meshInstance.parameters[e].data)}else{const e=this.model.meshInstances.indexOf(this.unmaskMeshInstance);e>=0&&this.model.meshInstances.splice(e,1),this.unmaskMeshInstance=null}this._entity.enabled&&this._element.enabled&&(this._element.removeModelFromLayers(this.model),this._element.addModelToLayers(this.model))}}setMaterial(e){this.meshInstance&&(this.meshInstance.material=e,this.unmaskMeshInstance&&(this.unmaskMeshInstance.material=e))}setParameter(e,t){this.meshInstance&&(this.meshInstance.setParameter(e,t),this.unmaskMeshInstance&&this.unmaskMeshInstance.setParameter(e,t))}deleteParameter(e){this.meshInstance&&(this.meshInstance.deleteParameter(e),this.unmaskMeshInstance&&this.unmaskMeshInstance.deleteParameter(e))}setUnmaskDrawOrder(){if(!this.meshInstance)return;const e=function e(t){let n;const a=t.children,i=a.length;if(i){for(let e=0;e<i;e++)a[e].element&&(n=a[e]);if(!n)return null;const t=e(n);return t||n}return null};if(this.unmaskMeshInstance){const t=e(this._entity);t&&t.element?this.unmaskMeshInstance.drawOrder=t.element.drawOrder+t.element.getMaskOffset():this.unmaskMeshInstance.drawOrder=this.meshInstance.drawOrder+this._element.getMaskOffset()}}setDrawOrder(e){this.meshInstance&&(this.meshInstance.drawOrder=e)}setCull(e){if(!this.meshInstance)return;const t=this._element;let n=null;e&&t._isScreenCulled()&&(n=function(e){return t.isVisibleForCamera(e)}),this.meshInstance.cull=e,this.meshInstance.isVisibleFunc=n,this.unmaskMeshInstance&&(this.unmaskMeshInstance.cull=e,this.unmaskMeshInstance.isVisibleFunc=n)}setScreenSpace(e){this.meshInstance&&(this.meshInstance.screenSpace=e,this.unmaskMeshInstance&&(this.unmaskMeshInstance.screenSpace=e))}setLayer(e){this.meshInstance&&(this.meshInstance.layer=e,this.unmaskMeshInstance&&(this.unmaskMeshInstance.layer=e))}forceUpdateAabb(e){this.meshInstance&&(this.meshInstance._aabbVer=-1,this.unmaskMeshInstance&&(this.unmaskMeshInstance._aabbVer=-1))}setAabbFunc(e){this.meshInstance&&(this.meshInstance._updateAabbFunc=e,this.unmaskMeshInstance&&(this.unmaskMeshInstance._updateAabbFunc=e))}}class lE{constructor(e){this._element=e,this._entity=e.entity,this._system=e.system,this._textureAsset=null,this._texture=null,this._materialAsset=null,this._material=null,this._spriteAsset=null,this._sprite=null,this._spriteFrame=0,this._pixelsPerUnit=null,this._rect=new Ou(0,0,1,1),this._mask=!1,this._maskRef=0,this._outerScale=new Du,this._outerScaleUniform=new Float32Array(2),this._innerOffset=new Ou,this._innerOffsetUniform=new Float32Array(4),this._atlasRect=new Ou,this._atlasRectUniform=new Float32Array(4),this._defaultMesh=this._createMesh(),this._renderable=new oE(this._entity,this._defaultMesh,this._material),this._color=new Mu(1,1,1,1),this._colorUniform=new Float32Array([1,1,1]),this._renderable.setParameter("material_emissive",this._colorUniform),this._renderable.setParameter("material_opacity",1),this._updateAabbFunc=this._updateAabb.bind(this),this._onScreenChange(this._element.screen),this._element.on("resize",this._onParentResizeOrPivotChange,this),this._element.on("set:pivot",this._onParentResizeOrPivotChange,this),this._element.on("screen:set:screenspace",this._onScreenSpaceChange,this),this._element.on("set:screen",this._onScreenChange,this),this._element.on("set:draworder",this._onDrawOrderChange,this),this._element.on("screen:set:resolution",this._onResolutionChange,this)}destroy(){this.textureAsset=null,this.spriteAsset=null,this.materialAsset=null,this._renderable.setMesh(this._defaultMesh),this._renderable.destroy(),this._defaultMesh=null,this._element.off("resize",this._onParentResizeOrPivotChange,this),this._element.off("set:pivot",this._onParentResizeOrPivotChange,this),this._element.off("screen:set:screenspace",this._onScreenSpaceChange,this),this._element.off("set:screen",this._onScreenChange,this),this._element.off("set:draworder",this._onDrawOrderChange,this),this._element.off("screen:set:resolution",this._onResolutionChange,this)}_onResolutionChange(e){}_onParentResizeOrPivotChange(){this._renderable.mesh&&this._updateMesh(this._renderable.mesh)}_onScreenSpaceChange(e){this._updateMaterial(e)}_onScreenChange(e,t){e?this._updateMaterial(e.screen.screenSpace):this._updateMaterial(!1)}_onDrawOrderChange(e){this._renderable.setDrawOrder(e),this.mask&&this._element.screen&&this._element.screen.screen.once("syncdraworder",(function(){this._renderable.setUnmaskDrawOrder()}),this)}_hasUserMaterial(){return!!this._materialAsset||!!this._material&&-1===this._system.defaultImageMaterials.indexOf(this._material)}_use9Slicing(){return this.sprite&&(1===this.sprite.renderMode||2===this.sprite.renderMode)}_updateMaterial(e){const t=!!this._mask,n=!(!this.sprite||1!==this.sprite.renderMode),a=!(!this.sprite||2!==this.sprite.renderMode);this._hasUserMaterial()||(this._material=this._system.getImageElementMaterial(e,t,n,a)),this._renderable&&(this._renderable.setCull(!0),this._renderable.setMaterial(this._material),this._renderable.setScreenSpace(e),this._renderable.setLayer(e?0:15))}_createMesh(){const e=this._element,t=e.calculatedWidth,n=e.calculatedHeight,a=this._rect,i=new ArrayBuffer(128),s=new Float32Array(i);s[5]=1,s[6]=a.x,s[7]=1-a.y,s[8]=t,s[13]=1,s[14]=a.x+a.z,s[15]=1-a.y,s[16]=t,s[17]=n,s[21]=1,s[22]=a.x+a.z,s[23]=1-(a.y+a.w),s[25]=n,s[29]=1,s[30]=a.x,s[31]=1-(a.y+a.w);const r=[{semantic:"POSITION",components:3,type:6},{semantic:"NORMAL",components:3,type:6},{semantic:"TEXCOORD0",components:2,type:6}],o=this._system.app.graphicsDevice,l=new hm(o,r),c=new lm(o,l,4,0,i),h=new iy(o);return h.vertexBuffer=c,h.primitive[0].type=6,h.primitive[0].base=0,h.primitive[0].count=4,h.primitive[0].indexed=!1,h.aabb.setMinMax(Pu.ZERO,new Pu(t,n,0)),this._updateMesh(h),h}_updateMesh(e){const t=this._element,n=t.calculatedWidth,a=t.calculatedHeight,i=t._isScreenSpace();if(this._updateMaterial(i),this._renderable&&this._renderable.forceUpdateAabb(),!this.sprite||1!==this.sprite.renderMode&&2!==this.sprite.renderMode){const i=e.vertexBuffer,s=new Float32Array(i.lock()),r=t.pivot.x,o=t.pivot.y;s[0]=0-r*n,s[1]=0-o*a,s[8]=n-r*n,s[9]=0-o*a,s[16]=n-r*n,s[17]=a-o*a,s[24]=0-r*n,s[25]=a-o*a;let l=1,c=1,h=this._rect;if(this._sprite&&this._sprite.frameKeys[this._spriteFrame]&&this._sprite.atlas){const e=this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];e&&(h=e.rect,l=this._sprite.atlas.texture.width,c=this._sprite.atlas.texture.height)}s[6]=h.x/l,s[7]=1-h.y/c,s[14]=(h.x+h.z)/l,s[15]=1-h.y/c,s[22]=(h.x+h.z)/l,s[23]=1-(h.y+h.w)/c,s[30]=h.x/l,s[31]=1-(h.y+h.w)/c,i.unlock();const d=new Pu(0-r*n,0-o*a,0),p=new Pu(n-r*n,a-o*a,0);e.aabb.setMinMax(d,p),this._renderable&&(this._renderable.node.setLocalScale(1,1,1),this._renderable.node.setLocalPosition(0,0,0),this._renderable.setAabbFunc(null))}else{const e=this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]],i=2/e.rect.z,s=2/e.rect.w;this._innerOffset.set(e.border.x*i,e.border.y*s,e.border.z*i,e.border.w*s);const r=this.sprite.atlas.texture;this._atlasRect.set(e.rect.x/r.width,e.rect.y/r.height,e.rect.z/r.width,e.rect.w/r.height);const o=null!==this._pixelsPerUnit?this._pixelsPerUnit:this.sprite.pixelsPerUnit,l=e.rect.z/o,c=e.rect.w/o;this._outerScale.set(Math.max(n,this._innerOffset.x*l),Math.max(a,this._innerOffset.y*c));let h=l,d=c;this._outerScale.x/=l,this._outerScale.y/=c,h*=Eu.clamp(n/(this._innerOffset.x*l),1e-4,1),d*=Eu.clamp(a/(this._innerOffset.y*c),1e-4,1),this._renderable&&(this._innerOffsetUniform[0]=this._innerOffset.x,this._innerOffsetUniform[1]=this._innerOffset.y,this._innerOffsetUniform[2]=this._innerOffset.z,this._innerOffsetUniform[3]=this._innerOffset.w,this._renderable.setParameter("innerOffset",this._innerOffsetUniform),this._atlasRectUniform[0]=this._atlasRect.x,this._atlasRectUniform[1]=this._atlasRect.y,this._atlasRectUniform[2]=this._atlasRect.z,this._atlasRectUniform[3]=this._atlasRect.w,this._renderable.setParameter("atlasRect",this._atlasRectUniform),this._outerScaleUniform[0]=this._outerScale.x,this._outerScaleUniform[1]=this._outerScale.y,this._renderable.setParameter("outerScale",this._outerScaleUniform),this._renderable.setAabbFunc(this._updateAabbFunc),this._renderable.node.setLocalScale(h,d,1),this._renderable.node.setLocalPosition((.5-t.pivot.x)*n,(.5-t.pivot.y)*a,0))}this._meshDirty=!1}_updateSprite(){let e=!1,t=null;this._sprite&&this._sprite.atlas&&(t=this._sprite.meshes[this.spriteFrame],e=1===this._sprite.renderMode||2===this._sprite.renderMode),this.mesh=e?t:this._defaultMesh,this.mesh&&(this._element._beingInitialized?this._meshDirty=!0:this._updateMesh(this.mesh))}_updateAabb(e){return e.center.set(0,0,0),e.halfExtents.set(.5*this._outerScale.x,.5*this._outerScale.y,.001),e.setFromTransformedAabb(e,this._renderable.node.getWorldTransform()),e}_toggleMask(){this._element._dirtifyMask();const e=this._element._isScreenSpace();this._updateMaterial(e),this._renderable.setMask(!!this._mask)}_onMaterialLoad(e){this.material=e.resource}_onMaterialAdded(e){this._system.app.assets.off("add:"+e.id,this._onMaterialAdded,this),this._materialAsset===e.id&&this._bindMaterialAsset(e)}_bindMaterialAsset(e){this._entity.enabled&&(e.on("load",this._onMaterialLoad,this),e.on("change",this._onMaterialChange,this),e.on("remove",this._onMaterialRemove,this),e.resource?this._onMaterialLoad(e):this._system.app.assets.load(e))}_unbindMaterialAsset(e){e.off("load",this._onMaterialLoad,this),e.off("change",this._onMaterialChange,this),e.off("remove",this._onMaterialRemove,this)}_onMaterialChange(){}_onMaterialRemove(){}_onTextureAdded(e){this._system.app.assets.off("add:"+e.id,this._onTextureAdded,this),this._textureAsset===e.id&&this._bindTextureAsset(e)}_bindTextureAsset(e){this._entity.enabled&&(e.on("load",this._onTextureLoad,this),e.on("change",this._onTextureChange,this),e.on("remove",this._onTextureRemove,this),e.resource?this._onTextureLoad(e):this._system.app.assets.load(e))}_unbindTextureAsset(e){e.off("load",this._onTextureLoad,this),e.off("change",this._onTextureChange,this),e.off("remove",this._onTextureRemove,this)}_onTextureLoad(e){this.texture=e.resource}_onTextureChange(e){}_onTextureRemove(e){}_onSpriteAssetAdded(e){this._system.app.assets.off("add:"+e.id,this._onSpriteAssetAdded,this),this._spriteAsset===e.id&&this._bindSpriteAsset(e)}_bindSpriteAsset(e){this._entity.enabled&&(e.on("load",this._onSpriteAssetLoad,this),e.on("change",this._onSpriteAssetChange,this),e.on("remove",this._onSpriteAssetRemove,this),e.resource?this._onSpriteAssetLoad(e):this._system.app.assets.load(e))}_unbindSpriteAsset(e){e.off("load",this._onSpriteAssetLoad,this),e.off("change",this._onSpriteAssetChange,this),e.off("remove",this._onSpriteAssetRemove,this),e.data.textureAtlasAsset&&this._system.app.assets.off("load:"+e.data.textureAtlasAsset,this._onTextureAtlasLoad,this)}_onSpriteAssetLoad(e){if(e&&e.resource)if(e.resource.atlas)this.sprite=e.resource;else{const t=e.data.textureAtlasAsset;if(t){const e=this._system.app.assets;e.off("load:"+t,this._onTextureAtlasLoad,this),e.once("load:"+t,this._onTextureAtlasLoad,this)}}else this.sprite=null}_onSpriteAssetChange(e){this._onSpriteAssetLoad(e)}_onSpriteAssetRemove(e){}_bindSprite(e){e.on("set:meshes",this._onSpriteMeshesChange,this),e.on("set:pixelsPerUnit",this._onSpritePpuChange,this),e.on("set:atlas",this._onAtlasTextureChange,this),e.atlas&&e.atlas.on("set:texture",this._onAtlasTextureChange,this)}_unbindSprite(e){e.off("set:meshes",this._onSpriteMeshesChange,this),e.off("set:pixelsPerUnit",this._onSpritePpuChange,this),e.off("set:atlas",this._onAtlasTextureChange,this),e.atlas&&e.atlas.off("set:texture",this._onAtlasTextureChange,this)}_onSpriteMeshesChange(){this._sprite&&(this._spriteFrame=Eu.clamp(this._spriteFrame,0,this._sprite.frameKeys.length-1)),this._updateSprite()}_onSpritePpuChange(){0!==this.sprite.renderMode&&null===this._pixelsPerUnit&&this._updateSprite()}_onAtlasTextureChange(){this.sprite&&this.sprite.atlas&&this.sprite.atlas.texture?(this._renderable.setParameter("texture_emissiveMap",this._sprite.atlas.texture),this._renderable.setParameter("texture_opacityMap",this._sprite.atlas.texture)):(this._renderable.deleteParameter("texture_emissiveMap"),this._renderable.deleteParameter("texture_opacityMap"))}_onTextureAtlasLoad(e){const t=this._spriteAsset;t instanceof f_?this._onSpriteAssetLoad(t):this._onSpriteAssetLoad(this._system.app.assets.get(t))}onEnable(){if(this._materialAsset){const e=this._system.app.assets.get(this._materialAsset);e&&e.resource!==this._material&&this._bindMaterialAsset(e)}if(this._textureAsset){const e=this._system.app.assets.get(this._textureAsset);e&&e.resource!==this._texture&&this._bindTextureAsset(e)}if(this._spriteAsset){const e=this._system.app.assets.get(this._spriteAsset);e&&e.resource!==this._sprite&&this._bindSpriteAsset(e)}this._element.addModelToLayers(this._renderable.model)}onDisable(){this._element.removeModelFromLayers(this._renderable.model)}_setStencil(e){this._renderable.meshInstance.stencilFront=e,this._renderable.meshInstance.stencilBack=e;let t=0;if(this._element.maskedBy&&(t=this._element.maskedBy.element._image._maskRef),this._renderable.unmaskMeshInstance){const e=new rE({ref:t+1,func:2,zpass:5});this._renderable.unmaskMeshInstance.stencilFront=e,this._renderable.unmaskMeshInstance.stencilBack=e}}set color(e){const t=e.r,n=e.g,a=e.b;this._color.r===t&&this._color.g===n&&this._color.b===a||(this._color.r=t,this._color.g=n,this._color.b=a,this._colorUniform[0]=t,this._colorUniform[1]=n,this._colorUniform[2]=a,this._renderable.setParameter("material_emissive",this._colorUniform)),this._element&&this._element.fire("set:color",this._color)}get color(){return this._color}set opacity(e){e!==this._color.a&&(this._color.a=e,this._renderable.setParameter("material_opacity",e)),this._element&&this._element.fire("set:opacity",e)}get opacity(){return this._color.a}set rect(e){let t,n,a,i;e instanceof Ou?(t=e.x,n=e.y,a=e.z,i=e.w):(t=e[0],n=e[1],a=e[2],i=e[3]),t===this._rect.x&&n===this._rect.y&&a===this._rect.z&&i===this._rect.w||(this._rect.set(t,n,a,i),this._renderable.mesh&&(this._element._beingInitialized?this._meshDirty=!0:this._updateMesh(this._renderable.mesh)))}get rect(){return this._rect}set material(e){if(this._material!==e){if(!e){const t=this._element._isScreenSpace();e=this.mask?t?this._system.defaultScreenSpaceImageMaskMaterial:this._system.defaultImageMaskMaterial:t?this._system.defaultScreenSpaceImageMaterial:this._system.defaultImageMaterial}this._material=e,e&&(this._renderable.setMaterial(e),this._hasUserMaterial()?(this._renderable.deleteParameter("material_opacity"),this._renderable.deleteParameter("material_emissive")):(this._colorUniform[0]=this._color.r,this._colorUniform[1]=this._color.g,this._colorUniform[2]=this._color.b,this._renderable.setParameter("material_emissive",this._colorUniform),this._renderable.setParameter("material_opacity",this._color.a)))}}get material(){return this._material}set materialAsset(e){const t=this._system.app.assets;let n=e;if(e instanceof f_&&(n=e.id),this._materialAsset!==n){if(this._materialAsset){t.off("add:"+this._materialAsset,this._onMaterialAdded,this);const e=t.get(this._materialAsset);e&&(e.off("load",this._onMaterialLoad,this),e.off("change",this._onMaterialChange,this),e.off("remove",this._onMaterialRemove,this))}if(this._materialAsset=n,this._materialAsset){const e=t.get(this._materialAsset);e?this._bindMaterialAsset(e):(this.material=null,t.on("add:"+this._materialAsset,this._onMaterialAdded,this))}else this.material=null}}get materialAsset(){return this._materialAsset}set texture(e){if(this._texture!==e){if(this._textureAsset){const t=this._system.app.assets.get(this._textureAsset);t&&t.resource!==e&&(this.textureAsset=null)}this._texture=e,e?(this._spriteAsset&&(this.spriteAsset=null),this._renderable.setParameter("texture_emissiveMap",this._texture),this._renderable.setParameter("texture_opacityMap",this._texture),this._colorUniform[0]=this._color.r,this._colorUniform[1]=this._color.g,this._colorUniform[2]=this._color.b,this._renderable.setParameter("material_emissive",this._colorUniform),this._renderable.setParameter("material_opacity",this._color.a)):(this._renderable.deleteParameter("texture_emissiveMap"),this._renderable.deleteParameter("texture_opacityMap"))}}get texture(){return this._texture}set textureAsset(e){const t=this._system.app.assets;let n=e;if(e instanceof f_&&(n=e.id),this._textureAsset!==n){if(this._textureAsset){t.off("add:"+this._textureAsset,this._onTextureAdded,this);const e=t.get(this._textureAsset);e&&(e.off("load",this._onTextureLoad,this),e.off("change",this._onTextureChange,this),e.off("remove",this._onTextureRemove,this))}if(this._textureAsset=n,this._textureAsset){const e=t.get(this._textureAsset);e?this._bindTextureAsset(e):(this.texture=null,t.on("add:"+this._textureAsset,this._onTextureAdded,this))}else this.texture=null}}get textureAsset(){return this._textureAsset}set spriteAsset(e){const t=this._system.app.assets;let n=e;if(e instanceof f_&&(n=e.id),this._spriteAsset!==n){if(this._spriteAsset){t.off("add:"+this._spriteAsset,this._onSpriteAssetAdded,this);const e=t.get(this._spriteAsset);e&&this._unbindSpriteAsset(e)}if(this._spriteAsset=n,this._spriteAsset){const e=t.get(this._spriteAsset);e?this._bindSpriteAsset(e):(this.sprite=null,t.on("add:"+this._spriteAsset,this._onSpriteAssetAdded,this))}else this.sprite=null}this._element&&this._element.fire("set:spriteAsset",n)}get spriteAsset(){return this._spriteAsset}set sprite(e){if(this._sprite!==e){if(this._sprite&&this._unbindSprite(this._sprite),this._spriteAsset){const t=this._system.app.assets.get(this._spriteAsset);t&&t.resource!==e&&(this.spriteAsset=null)}this._sprite=e,this._sprite&&(this._bindSprite(this._sprite),this._textureAsset&&(this.textureAsset=null)),this._sprite&&this._sprite.atlas&&this._sprite.atlas.texture?(this._renderable.setParameter("texture_emissiveMap",this._sprite.atlas.texture),this._renderable.setParameter("texture_opacityMap",this._sprite.atlas.texture)):(this._renderable.deleteParameter("texture_emissiveMap"),this._renderable.deleteParameter("texture_opacityMap")),this._sprite&&(this._spriteFrame=Eu.clamp(this._spriteFrame,0,this._sprite.frameKeys.length-1)),this._updateSprite()}}get sprite(){return this._sprite}set spriteFrame(e){const t=this._spriteFrame;this._sprite?this._spriteFrame=Eu.clamp(e,0,this._sprite.frameKeys.length-1):this._spriteFrame=e,this._spriteFrame!==t&&this._updateSprite(),this._element&&this._element.fire("set:spriteFrame",e)}get spriteFrame(){return this._spriteFrame}set mesh(e){this._renderable.setMesh(e),this._defaultMesh===e?this._renderable.setAabbFunc(null):this._renderable.setAabbFunc(this._updateAabbFunc)}get mesh(){return this._renderable.mesh}set mask(e){this._mask!==e&&(this._mask=e,this._toggleMask())}get mask(){return this._mask}set pixelsPerUnit(e){this._pixelsPerUnit!==e&&(this._pixelsPerUnit=e,!this._sprite||1!==this._sprite.renderMode&&2!==this._sprite.renderMode||this._updateSprite())}get pixelsPerUnit(){return this._pixelsPerUnit}get aabb(){return this._renderable.meshInstance?this._renderable.meshInstance.aabb:null}}class cE extends Qp{constructor(e){super(),this._app=e,e.i18n.on("set:locale",this._onSetLocale,this),this._autoLoad=!1,this._disableLocalization=!1,this._defaultAsset=null,this._localizedAsset=null}set defaultAsset(e){const t=e instanceof f_?e.id:e;this._defaultAsset!==t&&(this._defaultAsset&&this._unbindDefaultAsset(),this._defaultAsset=t,this._defaultAsset&&this._bindDefaultAsset(),this._onSetLocale(this._app.i18n.locale))}get defaultAsset(){return this._defaultAsset}set localizedAsset(e){const t=e instanceof f_?e.id:e;if(this._localizedAsset!==t&&(this._localizedAsset&&(this._app.assets.off("add:"+this._localizedAsset,this._onLocalizedAssetAdd,this),this._unbindLocalizedAsset(),this._localizedAsset=null),this._localizedAsset=t,this._localizedAsset)){this._app.assets.get(this._localizedAsset)?this._bindLocalizedAsset():this._app.assets.once("add:"+this._localizedAsset,this._onLocalizedAssetAdd,this)}}get localizedAsset(){return this._localizedAsset}set autoLoad(e){this._autoLoad!==e&&(this._autoLoad=e,this._autoLoad&&this._localizedAsset&&(this._unbindLocalizedAsset(),this._bindLocalizedAsset()))}get autoLoad(){return this._autoLoad}set disableLocalization(e){this._disableLocalization!==e&&(this._disableLocalization=e,this._onSetLocale(this._app.i18n.locale))}get disableLocalization(){return this._disableLocalization}_bindDefaultAsset(){const e=this._app.assets.get(this._defaultAsset);e?this._onDefaultAssetAdd(e):this._app.assets.once("add:"+this._defaultAsset,this._onDefaultAssetAdd,this)}_unbindDefaultAsset(){if(!this._defaultAsset)return;this._app.assets.off("add:"+this._defaultAsset,this._onDefaultAssetAdd,this);const e=this._app.assets.get(this._defaultAsset);e&&(e.off("add:localized",this._onLocaleAdd,this),e.off("remove:localized",this._onLocaleRemove,this),e.off("remove",this._onDefaultAssetRemove,this))}_onDefaultAssetAdd(e){this._defaultAsset===e.id&&(e.on("add:localized",this._onLocaleAdd,this),e.on("remove:localized",this._onLocaleRemove,this),e.once("remove",this._onDefaultAssetRemove,this))}_onDefaultAssetRemove(e){this._defaultAsset===e.id&&(e.off("add:localized",this._onLocaleAdd,this),e.off("remove:localized",this._onLocaleAdd,this),this._app.assets.once("add:"+this._defaultAsset,this._onDefaultAssetAdd,this))}_bindLocalizedAsset(){if(!this._autoLoad)return;const e=this._app.assets.get(this._localizedAsset);e&&(e.on("load",this._onLocalizedAssetLoad,this),e.on("change",this._onLocalizedAssetChange,this),e.on("remove",this._onLocalizedAssetRemove,this),e.resource?this._onLocalizedAssetLoad(e):this._app.assets.load(e))}_unbindLocalizedAsset(){const e=this._app.assets.get(this._localizedAsset);e&&(e.off("load",this._onLocalizedAssetLoad,this),e.off("change",this._onLocalizedAssetChange,this),e.off("remove",this._onLocalizedAssetRemove,this))}_onLocalizedAssetAdd(e){this._localizedAsset===e.id&&this._bindLocalizedAsset()}_onLocalizedAssetLoad(e){this.fire("load",e)}_onLocalizedAssetChange(e,t,n,a){this.fire("change",e,t,n,a)}_onLocalizedAssetRemove(e){this._localizedAsset===e.id&&(this.localizedAsset=this._defaultAsset),this.fire("remove",e)}_onLocaleAdd(e,t){this._app.i18n.locale===e&&this._onSetLocale(e)}_onLocaleRemove(e,t){this._app.i18n.locale===e&&this._onSetLocale(e)}_onSetLocale(e){if(!this._defaultAsset)return void(this.localizedAsset=null);const t=this._app.assets.get(this._defaultAsset);if(!t||this._disableLocalization)return void(this.localizedAsset=this._defaultAsset);const n=t.getLocalizedAssetId(e);this.localizedAsset=n||this._defaultAsset}destroy(){this.defaultAsset=null,this._app.i18n.off("set:locale",this._onSetLocale,this),this.off()}}const hE=/[A-Z|a-z|0-9|_|-|/]/;class dE{constructor(e){this._symbols=e,this._index=0,this._last=0,this._cur=this._symbols.length>0?this._symbols[0]:null,this._buf=[],this._mode="text",this._error=null}read(){let e=this._read();for(;8===e;)e=this._read();return 0!==e&&1!==e&&(this._last=this._index),e}buf(){return this._buf}last(){return this._last}error(){return this._error}debugPrint(){const e=["EOF","ERROR","TEXT","OPEN_BRACKET","CLOSE_BRACKET","EQUALS","STRING","IDENTIFIER","WHITESPACE"];let t=this.read(),n="";for(;n+=(n.length>0?"\n":"")+e[t]+" '"+this.buf().join("")+"'",0!==t&&1!==t;)t=this.read();return n}_read(){return this._buf=[],this._eof()?0:"text"===this._mode?this._text():this._tag()}_text(){for(;;)switch(this._cur){case null:return this._buf.length>0?2:0;case"[":return this._mode="tag",this._buf.length>0?2:this._tag();case"\\":if(this._next(),"["===this._cur)this._store();else this._output("\\");break;default:this._store()}}_tag(){switch(this._cur){case null:return this._error="unexpected end of input reading tag",1;case"[":return this._store(),3;case"]":return this._store(),this._mode="text",4;case"=":return this._store(),5;case" ":case"\t":case"\n":case"\r":case"\v":case"\f":return this._whitespace();case'"':return this._string();default:return this._isIdentifierSymbol(this._cur)?this._identifier():(this._error="unrecognized character",1)}}_whitespace(){for(this._store();-1!==" \t\n\r\v\f".indexOf(this._cur);)this._store();return 8}_string(){for(this._next();;)switch(this._cur){case null:return this._error="unexpected end of input reading string",1;case'"':return this._next(),6;default:this._store()}}_identifier(){for(this._store();null!==this._cur&&this._isIdentifierSymbol(this._cur);)this._store();return 7}_isIdentifierSymbol(e){return 1===e.length&&null!==e.match(hE)}_eof(){return null===this._cur}_next(){return this._eof()||(this._index++,this._cur=this._index<this._symbols.length?this._symbols[this._index]:null),this._cur}_store(){return this._buf.push(this._cur),this._next()}_output(e){this._buf.push(e)}}class pE{constructor(e){this._scanner=new dE(e),this._error=null}parse(e,t){for(;;){switch(this._scanner.read()){case 0:return!0;case 1:default:return!1;case 2:Array.prototype.push.apply(e,this._scanner.buf());break;case 3:if(!this._parseTag(e,t))return!1}}}error(){return"Error evaluating markup at #"+this._scanner.last().toString()+" ("+(this._scanner.error()||this._error)+")"}_parseTag(e,t){let n=this._scanner.read();if(7!==n)return this._error="expected identifier",!1;const a=this._scanner.buf().join("");if("/"===a[0]){for(let i=t.length-1;i>=0;--i)if(a==="/"+t[i].name&&null===t[i].end)return t[i].end=e.length,n=this._scanner.read(),4===n||(this._error="expected close bracket",!1);return this._error="failed to find matching tag",!1}const i={name:a,value:null,attributes:{},start:e.length,end:null};if(n=this._scanner.read(),5===n){if(n=this._scanner.read(),6!==n)return this._error="expected string",!1;i.value=this._scanner.buf().join(""),n=this._scanner.read()}for(;;){switch(n){case 4:return t.push(i),!0;case 7:{const e=this._scanner.buf().join("");if(n=this._scanner.read(),5!==n)return this._error="expected equals",!1;if(n=this._scanner.read(),6!==n)return this._error="expected string",!1;const t=this._scanner.buf().join("");i.attributes[e]=t;break}default:return this._error="expected close bracket or identifier",!1}n=this._scanner.read()}}}function uE(e,t){for(const n in t){if(!t.hasOwnProperty(n))continue;const a=t[n];a instanceof Object?(e.hasOwnProperty(n)||(e[n]={}),uE(e[n],t[n])):e[n]=a}}function mE(e){if(0===e.length)return null;const t={};for(let n=0;n<e.length;++n){const a=e[n],i={};i[a.name]={value:a.value,attributes:a.attributes},uE(t,i)}return t}function fE(e){const t=new pE(e),n=[],a=[];if(!t.parse(n,a))return console.warn(t.error()),{symbols:e,tags:null};const i=a.find((function(e){return null===e.end}));if(i)return console.warn(`Markup error: found unclosed tag='${i.name}'`),{symbols:e,tags:null};const s=function(e,t){if(0===e.length)return null;const n={};for(let t=0;t<e.length;++t){const a=e[t];n.hasOwnProperty(a.start)?null===n[a.start].open?n[a.start].open=[a]:n[a.start].open.push(a):n[a.start]={open:[a],close:null},n.hasOwnProperty(a.end)?null===n[a.end].close?n[a.end].close=[a]:n[a.end].close.push(a):n[a.end]={open:null,close:[a]}}let a=[];function i(e){a=a.filter((function(t){return void 0===e.find((function(e){return e===t}))}))}function s(e){for(let t=0;t<e.length;++t)a.push(e[t])}const r=Object.keys(n).sort((function(e,t){return e-t})),o=[];for(let e=0;e<r.length;++e){const t=n[r[e]];null!==t.close&&i(t.close),null!==t.open&&s(t.open),o.push({start:r[e],tags:mE(a)})}const l=[];let c=null;for(let e=0;e<o.length;++e){const t=o[e];for(;l.length<t.start;)l.push(c?c.tags:null);c=t}for(;l.length<t;)l.push(null);return l}(a,n.length);return{symbols:n,tags:s}}class gE{constructor(){this.count=0,this.quad=0,this.lines={},this.positions=[],this.normals=[],this.uvs=[],this.colors=[],this.indices=[],this.meshInstance=null}}const yE=/^[\r\n]$/,bE=/^[ \t]$/,vE=/^[ \t\-]|[\u200b]$/,_E=/^[a-z0-9]$/i,wE=/^[\u1100-\u11ff]|[\u3000-\u9fff]|[\ua960-\ua97f]|[\uac00-\ud7ff]$/,xE=/^[〕〉》」』】〙〗〟ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻]$/,CE=["​","؜","‎","‏","‪","‫","‬","‭","‮","⁦","⁧","⁨","⁩"],TE={width:0,height:0,xadvance:0,xoffset:0,yoffset:0};class EE{constructor(e){this._element=e,this._system=e.system,this._entity=e.entity,this._text="",this._symbols=[],this._colorPalette=[],this._symbolColors=null,this._i18nKey=null,this._fontAsset=new cE(this._system.app),this._fontAsset.disableLocalization=!0,this._fontAsset.on("load",this._onFontLoad,this),this._fontAsset.on("change",this._onFontChange,this),this._fontAsset.on("remove",this._onFontRemove,this),this._font=null,this._color=new Mu(1,1,1,1),this._colorUniform=new Float32Array(3),this._spacing=1,this._fontSize=32,this._fontMinY=0,this._fontMaxY=0,this._originalFontSize=32,this._maxFontSize=32,this._minFontSize=8,this._autoFitWidth=!1,this._autoFitHeight=!1,this._maxLines=-1,this._lineHeight=32,this._scaledLineHeight=32,this._wrapLines=!1,this._drawOrder=0,this._alignment=new Du(.5,.5),this._autoWidth=!0,this._autoHeight=!0,this.width=0,this.height=0,this._node=new hf,this._model=new Dv,this._model.graph=this._node,this._entity.addChild(this._node),this._meshInfo=[],this._material=null,this._aabbDirty=!0,this._aabb=new qu,this._noResize=!1,this._currentMaterialType=null,this._maskedMaterialSrc=null,this._rtlReorder=!1,this._unicodeConverter=!1,this._rtl=!1,this._outlineColor=new Mu(0,0,0,1),this._outlineColorUniform=new Float32Array(4),this._outlineThicknessScale=.2,this._outlineThickness=0,this._shadowColor=new Mu(0,0,0,1),this._shadowColorUniform=new Float32Array(4),this._shadowOffsetScale=.005,this._shadowOffset=new Du(0,0),this._shadowOffsetUniform=new Float32Array(2),this._enableMarkup=!1,this._onScreenChange(this._element.screen),e.on("resize",this._onParentResize,this),e.on("set:screen",this._onScreenChange,this),e.on("screen:set:screenspace",this._onScreenSpaceChange,this),e.on("set:draworder",this._onDrawOrderChange,this),e.on("set:pivot",this._onPivotChange,this),this._system.app.i18n.on("set:locale",this._onLocaleSet,this),this._system.app.i18n.on("data:add",this._onLocalizationData,this),this._system.app.i18n.on("data:remove",this._onLocalizationData,this),this._rangeStart=0,this._rangeEnd=0}destroy(){this._setMaterial(null),this._model&&(this._element.removeModelFromLayers(this._model),this._model.destroy(),this._model=null),this._fontAsset.destroy(),this.font=null,this._element.off("resize",this._onParentResize,this),this._element.off("set:screen",this._onScreenChange,this),this._element.off("screen:set:screenspace",this._onScreenSpaceChange,this),this._element.off("set:draworder",this._onDrawOrderChange,this),this._element.off("set:pivot",this._onPivotChange,this),this._system.app.i18n.off("set:locale",this._onLocaleSet,this),this._system.app.i18n.off("data:add",this._onLocalizationData,this),this._system.app.i18n.off("data:remove",this._onLocalizationData,this)}_onParentResize(e,t){this._noResize||this._font&&this._updateText()}_onScreenChange(e){e?this._updateMaterial(e.screen.screenSpace):this._updateMaterial(!1)}_onScreenSpaceChange(e){this._updateMaterial(e)}_onDrawOrderChange(e){if(this._drawOrder=e,this._model)for(let t=0,n=this._model.meshInstances.length;t<n;t++)this._model.meshInstances[t].drawOrder=e}_onPivotChange(e){this._font&&this._updateText()}_onLocaleSet(e){if(this._i18nKey){if(this.fontAsset){const e=this._system.app.assets.get(this.fontAsset);e&&e.resource&&e.resource===this._font||(this.font=null)}this._resetLocalizedText()}}_onLocalizationData(e,t){this._i18nKey&&t[this._i18nKey]&&this._resetLocalizedText()}_resetLocalizedText(){this._setText(this._system.app.i18n.getText(this._i18nKey))}_setText(e){if(this.unicodeConverter){const t=this._system.getUnicodeConverter();t?e=t(e):console.warn("Element created with unicodeConverter option but no unicodeConverter function registered")}this._text!==e&&(this._font&&this._updateText(e),this._text=e)}_updateText(e){let t;if(void 0===e&&(e=this._text),this._symbols=yu.getSymbols(e.normalize?e.normalize("NFC"):e),0===this._symbols.length&&(this._symbols=[" "]),this._enableMarkup){const e=class{static evaluate(e){return fE(e)}}.evaluate(this._symbols);this._symbols=e.symbols,t=e.tags}if(this._rtlReorder){const e=this._system.app.systems.element.getRtlReorder();if(e){const n=e(this._symbols);this._rtl=n.rtl,this._symbols=n.mapping.map((function(e){return this._symbols[e]}),this),t&&(t=n.mapping.map((function(e){return t[e]})))}else console.warn("Element created with rtlReorder option but no rtlReorder function registered")}else this._rtl=!1;if(t){const e={};this._colorPalette=[Math.round(255*this._color.r),Math.round(255*this._color.g),Math.round(255*this._color.b)],this._symbolColors=[],e[this._color.toString(!1).toLowerCase()]=0;for(let n=0,a=this._symbols.length;n<a;++n){const a=t[n];let i=0;if(a&&a.color&&a.color.value){const t=a.color.value;if(7===t.length&&"#"===t[0]){const n=t.substring(1).toLowerCase();e.hasOwnProperty(n)?i=e[n]:/^([0-9a-f]{2}){3}$/.test(n)&&(i=this._colorPalette.length/3,e[n]=i,this._colorPalette.push(parseInt(n.substring(0,2),16)),this._colorPalette.push(parseInt(n.substring(2,4),16)),this._colorPalette.push(parseInt(n.substring(4,6),16)))}}this._symbolColors.push(i)}}else this._colorPalette=[],this._symbolColors=null;const n=this._calculateCharsPerTexture();let a=!1;const i=this._element,s=i._isScreenSpace(),r=i._isScreenCulled(),o=function(e){return i.isVisibleForCamera(e)};for(let e=0,t=this._meshInfo.length;e<t;e++){const t=n[e]||0,l=this._meshInfo[e];if(l.count!==t){if(a||(i.removeModelFromLayers(this._model),a=!0),l.count=t,l.positions.length=l.normals.length=3*t*4,l.indices.length=3*t*2,l.uvs.length=2*t*4,l.colors.length=4*t*4,l.meshInstance&&this._removeMeshInstance(l.meshInstance),0===t){l.meshInstance=null;continue}for(let e=0;e<t;e++)l.indices[3*e*2+0]=4*e,l.indices[3*e*2+1]=4*e+1,l.indices[3*e*2+2]=4*e+3,l.indices[3*e*2+3]=4*e+2,l.indices[3*e*2+4]=4*e+3,l.indices[3*e*2+5]=4*e+1,l.normals[4*e*3+0]=0,l.normals[4*e*3+1]=0,l.normals[4*e*3+2]=-1,l.normals[4*e*3+3]=0,l.normals[4*e*3+4]=0,l.normals[4*e*3+5]=-1,l.normals[4*e*3+6]=0,l.normals[4*e*3+7]=0,l.normals[4*e*3+8]=-1,l.normals[4*e*3+9]=0,l.normals[4*e*3+10]=0,l.normals[4*e*3+11]=-1;const n=ly(this._system.app.graphicsDevice,l.positions,{uvs:l.uvs,normals:l.normals,colors:l.colors,indices:l.indices}),c=new Ay(n,this._material,this._node);c.name="Text Element: "+this._entity.name,c.castShadow=!1,c.receiveShadow=!1,c.cull=!s,c.screenSpace=s,c.drawOrder=this._drawOrder,r&&(c.cull=!0,c.isVisibleFunc=o),this._setTextureParams(c,this._font.textures[e]),this._symbolColors?(this._colorUniform[0]=1,this._colorUniform[1]=1,this._colorUniform[2]=1):(this._colorUniform[0]=this._color.r,this._colorUniform[1]=this._color.g,this._colorUniform[2]=this._color.b),c.setParameter("material_emissive",this._colorUniform),c.setParameter("material_opacity",this._color.a),c.setParameter("font_sdfIntensity",this._font.intensity),c.setParameter("font_pxrange",this._getPxRange(this._font)),c.setParameter("font_textureWidth",this._font.data.info.maps[e].width),this._outlineColorUniform[0]=this._outlineColor.r,this._outlineColorUniform[1]=this._outlineColor.g,this._outlineColorUniform[2]=this._outlineColor.b,this._outlineColorUniform[3]=this._outlineColor.a,c.setParameter("outline_color",this._outlineColorUniform),c.setParameter("outline_thickness",this._outlineThicknessScale*this._outlineThickness),this._shadowColorUniform[0]=this._shadowColor.r,this._shadowColorUniform[1]=this._shadowColor.g,this._shadowColorUniform[2]=this._shadowColor.b,this._shadowColorUniform[3]=this._shadowColor.a,c.setParameter("shadow_color",this._shadowColorUniform);const h=-this._font.data.info.maps[e].width/this._font.data.info.maps[e].height;this._shadowOffsetUniform[0]=this._shadowOffsetScale*this._shadowOffset.x,this._shadowOffsetUniform[1]=h*this._shadowOffsetScale*this._shadowOffset.y,c.setParameter("shadow_offset",this._shadowOffsetUniform),l.meshInstance=c,this._model.meshInstances.push(c)}}this._element.maskedBy&&this._element._setMaskedBy(this._element.maskedBy),a&&this._element.enabled&&this._entity.enabled&&this._element.addModelToLayers(this._model),this._updateMeshes(),this._rangeStart=0,this._rangeEnd=this._symbols.length,this._updateRenderRange()}_removeMeshInstance(e){e.destroy();const t=this._model.meshInstances.indexOf(e);-1!==t&&this._model.meshInstances.splice(t,1)}_setMaterial(e){if(this._material=e,this._model)for(let t=0,n=this._model.meshInstances.length;t<n;t++){this._model.meshInstances[t].material=e}}_updateMaterial(e){const t=this._element,n=t._isScreenCulled(),a=function(e){return t.isVisibleForCamera(e)},i=this._font&&"msdf"===this._font.type;if(this._material=this._system.getTextElementMaterial(e,i),this._model)for(let t=0,i=this._model.meshInstances.length;t<i;t++){const i=this._model.meshInstances[t];i.cull=!e,i.material=this._material,i.screenSpace=e,n?(i.cull=!0,i.isVisibleFunc=a):i.isVisibleFunc=null}}_isWordBoundary(e){return vE.test(e)}_isValidNextChar(e){return null!==e&&!xE.test(e)}_isNextCJKBoundary(e,t){return wE.test(e)&&(vE.test(t)||_E.test(t))}_isNextCJKWholeWord(e){return wE.test(e)}_updateMeshes(){const e=this._font.data,t=this,n=Math.min(this._minFontSize,this._maxFontSize),a=this._maxFontSize,i=this._shouldAutoFit();i&&(this._fontSize=this._maxFontSize);const s=this._symbols.length;let r=0,o=0,l=0,c=0,h=1,d=0,p=0,u=0,m=0,f=0,g=0;const y=Math.abs(this._element.anchor.x-this._element.anchor.z)>=1e-4;let b=this._element.calculatedWidth;(this.autoWidth&&!y||!this._wrapLines)&&(b=Number.POSITIVE_INFINITY);let v,_,w,x,C=0,T=0;function E(e,n,a){t._lineWidths.push(Math.abs(a));const i=u>n?n+1:u,s=u>n?u+1:n,l=e.slice(i,s);if(g){let e=l.length;for(;e--&&g>0;)yE.test(l[e])&&(l.splice(e,1),g--)}t._lineContents.push(l.join("")),r=0,o-=t._scaledLineHeight,h++,m=0,f=0,g=0,d=0,u=n}let S=!0;for(;S;){S=!1,this._scaledLineHeight=i?this._lineHeight*this._fontSize/(this._maxFontSize||1e-4):this._lineHeight,this.width=0,this.height=0,this._lineWidths=[],this._lineContents=[],r=0,o=0,l=0,c=0,h=1,d=0,p=0,u=0,m=0,f=0,g=0;const t=this._fontSize/32;C=this._fontMinY*t,T=this._fontMaxY*t;for(let e=0;e<this._meshInfo.length;e++)this._meshInfo[e].quad=0,this._meshInfo[e].lines={};let y=255,A=255,M=255;for(let i=0;i<s;i++){v=this._symbols[i],x=i+1>=s?null:this._symbols[i+1];if(yE.test(v)){g++,(!this._wrapLines||this._maxLines<0||h<this._maxLines)&&(E(this._symbols,i,c),p=i+1,u=i+1);continue}let L,R,I=0,P=0,k=0,D=1;if(_=e.chars[v],!_)if(-1!==CE.indexOf(v))_=TE;else if(e.chars[" "])_=e.chars[" "];else for(const t in e.chars){_=e.chars[t];break}if(_){let e=0;if(f>0){const t=this._font.data.kerning;if(t){const n=t[yu.getCodePoint(this._symbols[i-1])||0];n&&(e=n[yu.getCodePoint(this._symbols[i])||0]||0)}}L=_.scale||1,R=(_.width+_.height)/2,D=t*R/L,k=(_.xadvance+e)*t,I=(_.xoffset-e)*t,P=_.yoffset*t}else console.error(`Couldn't substitute missing character: '${v}'`);const O=bE.test(v),F=this._meshInfo[_&&_.map||0],N=r+this._spacing*k;if(N>b&&f>0&&!O&&(this._maxLines<0||h<this._maxLines)){if(0!==m){const t=Math.max(i-p,0);if(this._meshInfo.length<=1)F.lines[h-1]-=t,F.quad-=t;else{const t=i;for(let n=p;n<t;n++){const t=this._symbols[n],a=e.chars[t],i=this._meshInfo[a&&a.map||0];i.lines[h-1]-=1,i.quad-=1}}i-=t+1,E(this._symbols,p,d);continue}p=i,E(this._symbols,i,c)}w=F.quad,F.lines[h-1]=w;let V=r-I,B=V+D;const U=o-P,z=U+D;if(this._rtl){const e=D-I-this._spacing*k-I;V-=e,B-=e}let G;if(F.positions[4*w*3+0]=V,F.positions[4*w*3+1]=U,F.positions[4*w*3+2]=l,F.positions[4*w*3+3]=B,F.positions[4*w*3+4]=U,F.positions[4*w*3+5]=l,F.positions[4*w*3+6]=B,F.positions[4*w*3+7]=z,F.positions[4*w*3+8]=l,F.positions[4*w*3+9]=V,F.positions[4*w*3+10]=z,F.positions[4*w*3+11]=l,this.width=Math.max(this.width,N),this._shouldAutoFitWidth()&&this.width>this._element.calculatedWidth&&(G=Math.floor(this._element.fontSize*this._element.calculatedWidth/(this.width||1e-4)),G=Eu.clamp(G,n,a),G!==this._element.fontSize)){this._fontSize=G,S=!0;break}if(this.height=Math.max(this.height,T-(o+C)),this._shouldAutoFitHeight()&&this.height>this._element.calculatedHeight&&(G=Eu.clamp(this._fontSize-1,n,a),G!==this._element.fontSize)){this._fontSize=G,S=!0;break}r+=this._spacing*k,O||(c=r),(this._isWordBoundary(v)||this._isValidNextChar(x)&&(this._isNextCJKBoundary(v,x)||this._isNextCJKWholeWord(x)))&&(m++,d=c,p=i+1),f++;const H=this._getUv(v);if(F.uvs[4*w*2+0]=H[0],F.uvs[4*w*2+1]=1-H[1],F.uvs[4*w*2+2]=H[2],F.uvs[4*w*2+3]=1-H[1],F.uvs[4*w*2+4]=H[2],F.uvs[4*w*2+5]=1-H[3],F.uvs[4*w*2+6]=H[0],F.uvs[4*w*2+7]=1-H[3],this._symbolColors){const e=3*this._symbolColors[i];y=this._colorPalette[e],A=this._colorPalette[e+1],M=this._colorPalette[e+2]}F.colors[4*w*4+0]=y,F.colors[4*w*4+1]=A,F.colors[4*w*4+2]=M,F.colors[4*w*4+3]=255,F.colors[4*w*4+4]=y,F.colors[4*w*4+5]=A,F.colors[4*w*4+6]=M,F.colors[4*w*4+7]=255,F.colors[4*w*4+8]=y,F.colors[4*w*4+9]=A,F.colors[4*w*4+10]=M,F.colors[4*w*4+11]=255,F.colors[4*w*4+12]=y,F.colors[4*w*4+13]=A,F.colors[4*w*4+14]=M,F.colors[4*w*4+15]=255,F.quad++}S||u<s&&E(this._symbols,s,r)}this._noResize=!0,this.autoWidth=this._autoWidth,this.autoHeight=this._autoHeight,this._noResize=!1;const A=this._element.pivot.x,M=this._element.pivot.y,L=this._alignment.x,R=this._alignment.y;for(let e=0;e<this._meshInfo.length;e++){if(0===this._meshInfo[e].count)continue;let t=0;for(const n in this._meshInfo[e].lines){const a=this._meshInfo[e].lines[n],i=this._lineWidths[parseInt(n,10)],s=-A*this._element.calculatedWidth+L*(this._element.calculatedWidth-i)*(this._rtl?-1:1),r=(1-M)*this._element.calculatedHeight-T-(1-R)*(this._element.calculatedHeight-this.height);for(let n=t;n<=a;n++)this._meshInfo[e].positions[4*n*3]+=s,this._meshInfo[e].positions[4*n*3+3]+=s,this._meshInfo[e].positions[4*n*3+6]+=s,this._meshInfo[e].positions[4*n*3+9]+=s,this._meshInfo[e].positions[4*n*3+1]+=r,this._meshInfo[e].positions[4*n*3+4]+=r,this._meshInfo[e].positions[4*n*3+7]+=r,this._meshInfo[e].positions[4*n*3+10]+=r;if(this._rtl)for(let n=t;n<=a;n++){const t=4*n*3;for(let n=0;n<4;++n)this._meshInfo[e].positions[t+3*n]=this._element.calculatedWidth-this._meshInfo[e].positions[t+3*n]+2*s;const a=this._meshInfo[e].positions[t+3],i=this._meshInfo[e].positions[t+6];this._meshInfo[e].positions[t+3]=this._meshInfo[e].positions[t+0],this._meshInfo[e].positions[t+6]=this._meshInfo[e].positions[t+9],this._meshInfo[e].positions[t+0]=a,this._meshInfo[e].positions[t+9]=i}t=a+1}const n=4*this._meshInfo[e].count,a=4*this._meshInfo[e].quad,i=new Vg(this._meshInfo[e].meshInstance.mesh.vertexBuffer);for(let t=0;t<n;t++)t>=a?(i.element.POSITION.set(0,0,0),i.element.TEXCOORD0.set(0,0),i.element.COLOR.set(0,0,0,0)):(i.element.POSITION.set(this._meshInfo[e].positions[3*t+0],this._meshInfo[e].positions[3*t+1],this._meshInfo[e].positions[3*t+2]),i.element.TEXCOORD0.set(this._meshInfo[e].uvs[2*t+0],this._meshInfo[e].uvs[2*t+1]),i.element.COLOR.set(this._meshInfo[e].colors[4*t+0],this._meshInfo[e].colors[4*t+1],this._meshInfo[e].colors[4*t+2],this._meshInfo[e].colors[4*t+3])),i.next();i.end(),this._meshInfo[e].meshInstance.mesh.aabb.compute(this._meshInfo[e].positions),this._meshInfo[e].meshInstance._aabbVer=-1}this._aabbDirty=!0}_onFontRender(){this.font=this._font}_onFontLoad(e){this.font!==e.resource&&(this.font=e.resource)}_onFontChange(e,t,n,a){if("data"===t){this._font.data=n;const e=this._font.data.info.maps.length;for(let t=0;t<e;t++){if(!this._meshInfo[t])continue;const e=this._meshInfo[t].meshInstance;e&&(e.setParameter("font_sdfIntensity",this._font.intensity),e.setParameter("font_pxrange",this._getPxRange(this._font)),e.setParameter("font_textureWidth",this._font.data.info.maps[t].width))}}}_onFontRemove(e){}_setTextureParams(e,t){this._font&&("msdf"===this._font.type?(e.deleteParameter("texture_emissiveMap"),e.deleteParameter("texture_opacityMap"),e.setParameter("texture_msdfMap",t)):"bitmap"===this._font.type&&(e.deleteParameter("texture_msdfMap"),e.setParameter("texture_emissiveMap",t),e.setParameter("texture_opacityMap",t)))}_getPxRange(e){const t=Object.keys(this._font.data.chars);for(let e=0;e<t.length;e++){const n=this._font.data.chars[t[e]];if(n.range)return(n.scale||1)*n.range}return 2}_getUv(e){const t=this._font.data;if(!t.chars[e]){const e=" ";return t.chars[e]?this._getUv(e):[0,0,0,0]}const n=t.chars[e].map,a=t.info.maps[n].width,i=t.info.maps[n].height,s=t.chars[e].x,r=t.chars[e].y,o=s,l=r,c=s+t.chars[e].width,h=r-t.chars[e].height,d=1-t.chars[e].height/i;return[o/a,d-l/i,c/a,d-h/i]}onEnable(){this._fontAsset.autoLoad=!0,this._model&&this._element.addModelToLayers(this._model)}onDisable(){this._fontAsset.autoLoad=!1,this._model&&this._element.removeModelFromLayers(this._model)}_setStencil(e){if(this._model){const t=this._model.meshInstances;for(let n=0;n<t.length;n++)t[n].stencilFront=e,t[n].stencilBack=e}}_shouldAutoFitWidth(){return this._autoFitWidth&&!this._autoWidth}_shouldAutoFitHeight(){return this._autoFitHeight&&!this._autoHeight}_shouldAutoFit(){return this._autoFitWidth&&!this._autoWidth||this._autoFitHeight&&!this._autoHeight}_calculateCharsPerTexture(e){const t={};void 0===e&&(e=this._symbols.length);for(let n=0,a=e;n<a;n++){const e=this._symbols[n];let a=this._font.data.chars[e];a||(a=this._font.data.chars[" "],a||(a=this._font.data.chars[Object.keys(this._font.data.chars)[0]]));const i=a.map;t[i]?t[i]++:t[i]=1}return t}_updateRenderRange(){const e=0===this._rangeStart?0:this._calculateCharsPerTexture(this._rangeStart),t=0===this._rangeEnd?0:this._calculateCharsPerTexture(this._rangeEnd);for(let n=0,a=this._meshInfo.length;n<a;n++){const a=e[n]||0,i=t[n]||0,s=this._meshInfo[n].meshInstance;if(s){const e=s.mesh;e&&(e.primitive[0].base=3*a*2,e.primitive[0].count=3*(i-a)*2)}}}set text(e){this._i18nKey=null;const t=null!=e&&e.toString()||"";this._setText(t)}get text(){return this._text}set key(e){const t=null!==e?e.toString():null;this._i18nKey!==t&&(this._i18nKey=t,t?(this._fontAsset.disableLocalization=!1,this._resetLocalizedText()):this._fontAsset.disableLocalization=!0)}get key(){return this._i18nKey}set color(e){const t=e.r,n=e.g,a=e.b;if(this._color.r!==t||this._color.g!==n||this._color.b!==a)if(this._color.r=t,this._color.g=n,this._color.b=a,this._symbolColors)this._font&&this._updateText();else{this._colorUniform[0]=this._color.r,this._colorUniform[1]=this._color.g,this._colorUniform[2]=this._color.b;for(let e=0,t=this._model.meshInstances.length;e<t;e++){this._model.meshInstances[e].setParameter("material_emissive",this._colorUniform)}}this._element&&this._element.fire("set:color",this._color)}get color(){return this._color}set opacity(e){if(this._color.a!==e&&(this._color.a=e,this._model))for(let t=0,n=this._model.meshInstances.length;t<n;t++){this._model.meshInstances[t].setParameter("material_opacity",e)}this._element&&this._element.fire("set:opacity",e)}get opacity(){return this._color.a}set lineHeight(e){const t=this._lineHeight;this._lineHeight=e,this._scaledLineHeight=e,t!==e&&this._font&&this._updateText()}get lineHeight(){return this._lineHeight}set wrapLines(e){const t=this._wrapLines;this._wrapLines=e,t!==e&&this._font&&this._updateText()}get wrapLines(){return this._wrapLines}get lines(){return this._lineContents}set spacing(e){const t=this._spacing;this._spacing=e,t!==e&&this._font&&this._updateText()}get spacing(){return this._spacing}set fontSize(e){const t=this._fontSize;this._fontSize=e,this._originalFontSize=e,t!==e&&this._font&&this._updateText()}get fontSize(){return this._fontSize}set fontAsset(e){this._fontAsset.defaultAsset=e}get fontAsset(){return this._fontAsset.localizedAsset}set font(e){let t;if(this._font&&(t=this._font.type,this._font.off&&this._font.off("render",this._onFontRender,this)),this._font=e,this._fontMinY=0,this._fontMaxY=0,!e)return;const n=this._font.data;for(const e in n.chars){const t=n.chars[e];t.bounds&&(this._fontMinY=Math.min(this._fontMinY,t.bounds[1]),this._fontMaxY=Math.max(this._fontMaxY,t.bounds[3]))}if(this._font.on&&this._font.on("render",this._onFontRender,this),this._fontAsset.localizedAsset){this._system.app.assets.get(this._fontAsset.localizedAsset).resource!==this._font&&(this._fontAsset.defaultAsset=null)}if(e.type!==t){const e=this._element._isScreenSpace();this._updateMaterial(e)}for(let e=0,t=this._font.textures.length;e<t;e++)if(this._meshInfo[e]){const t=this._meshInfo[e].meshInstance;t&&(t.setParameter("font_sdfIntensity",this._font.intensity),t.setParameter("font_pxrange",this._getPxRange(this._font)),t.setParameter("font_textureWidth",this._font.data.info.maps[e].width),this._setTextureParams(t,this._font.textures[e]))}else this._meshInfo[e]=new gE;let a=!1;for(let e=this._font.textures.length;e<this._meshInfo.length;e++)this._meshInfo[e].meshInstance&&(a||(this._element.removeModelFromLayers(this._model),a=!0),this._removeMeshInstance(this._meshInfo[e].meshInstance));this._meshInfo.length>this._font.textures.length&&(this._meshInfo.length=this._font.textures.length),this._updateText()}get font(){return this._font}set alignment(e){e instanceof Du?this._alignment.set(e.x,e.y):this._alignment.set(e[0],e[1]),this._font&&this._updateText()}get alignment(){return this._alignment}set autoWidth(e){const t=this._autoWidth;if(this._autoWidth=e,e&&Math.abs(this._element.anchor.x-this._element.anchor.z)<1e-4&&(this._element.width=this.width),t!==e){const e=this._shouldAutoFit()?this._maxFontSize:this._originalFontSize;e!==this._fontSize&&(this._fontSize=e,this._font&&this._updateText())}}get autoWidth(){return this._autoWidth}set autoHeight(e){const t=this._autoHeight;if(this._autoHeight=e,e&&Math.abs(this._element.anchor.y-this._element.anchor.w)<1e-4&&(this._element.height=this.height),t!==e){const e=this._shouldAutoFit()?this._maxFontSize:this._originalFontSize;e!==this._fontSize&&(this._fontSize=e,this._font&&this._updateText())}}get autoHeight(){return this._autoHeight}set rtlReorder(e){this._rtlReorder!==e&&(this._rtlReorder=e,this._font&&this._updateText())}get rtlReorder(){return this._rtlReorder}set unicodeConverter(e){this._unicodeConverter!==e&&(this._unicodeConverter=e,this._setText(this._text))}get unicodeConverter(){return this._unicodeConverter}get aabb(){if(this._aabbDirty){let e=!1;for(let t=0;t<this._meshInfo.length;t++)this._meshInfo[t].meshInstance&&(e?this._aabb.add(this._meshInfo[t].meshInstance.aabb):(this._aabb.copy(this._meshInfo[t].meshInstance.aabb),e=!0));this._aabbDirty=!1}return this._aabb}set outlineColor(e){const t=e instanceof Mu?e.r:e[0],n=e instanceof Mu?e.g:e[1],a=e instanceof Mu?e.b:e[2],i=e instanceof Mu?e.a:e[3];if((this._outlineColor.r!==t||this._outlineColor.g!==n||this._outlineColor.b!==a||this._outlineColor.a!==i)&&(this._outlineColor.r=t,this._outlineColor.g=n,this._outlineColor.b=a,this._outlineColor.a=i,this._model)){this._outlineColorUniform[0]=this._outlineColor.r,this._outlineColorUniform[1]=this._outlineColor.g,this._outlineColorUniform[2]=this._outlineColor.b,this._outlineColorUniform[3]=this._outlineColor.a;for(let e=0,t=this._model.meshInstances.length;e<t;e++){this._model.meshInstances[e].setParameter("outline_color",this._outlineColorUniform)}}}get outlineColor(){return this._outlineColor}set outlineThickness(e){const t=this._outlineThickness;if(this._outlineThickness=e,t!==e&&this._font&&this._model)for(let e=0,t=this._model.meshInstances.length;e<t;e++){this._model.meshInstances[e].setParameter("outline_thickness",this._outlineThicknessScale*this._outlineThickness)}}get outlineThickness(){return this._outlineThickness}set shadowColor(e){const t=e instanceof Mu?e.r:e[0],n=e instanceof Mu?e.g:e[1],a=e instanceof Mu?e.b:e[2],i=e instanceof Mu?e.a:e[3];if((this._shadowColor.r!==t||this._shadowColor.g!==n||this._shadowColor.b!==a||this._shadowColor.a!==i)&&(this._shadowColor.r=t,this._shadowColor.g=n,this._shadowColor.b=a,this._shadowColor.a=i,this._model)){this._shadowColorUniform[0]=this._shadowColor.r,this._shadowColorUniform[1]=this._shadowColor.g,this._shadowColorUniform[2]=this._shadowColor.b,this._shadowColorUniform[3]=this._shadowColor.a;for(let e=0,t=this._model.meshInstances.length;e<t;e++){this._model.meshInstances[e].setParameter("shadow_color",this._shadowColorUniform)}}}get shadowColor(){return this._shadowColor}set shadowOffset(e){const t=e instanceof Du?e.x:e[0],n=e instanceof Du?e.y:e[1];if((this._shadowOffset.x!==t||this._shadowOffset.y!==n)&&(this._shadowOffset.set(t,n),this._font&&this._model))for(let e=0,t=this._model.meshInstances.length;e<t;e++){const t=-this._font.data.info.maps[e].width/this._font.data.info.maps[e].height;this._shadowOffsetUniform[0]=this._shadowOffsetScale*this._shadowOffset.x,this._shadowOffsetUniform[1]=t*this._shadowOffsetScale*this._shadowOffset.y;this._model.meshInstances[e].setParameter("shadow_offset",this._shadowOffsetUniform)}}get shadowOffset(){return this._shadowOffset}set minFontSize(e){this._minFontSize!==e&&(this._minFontSize=e,this.font&&this._shouldAutoFit()&&this._updateText())}get minFontSize(){return this._minFontSize}set maxFontSize(e){this._maxFontSize!==e&&(this._maxFontSize=e,this.font&&this._shouldAutoFit()&&this._updateText())}get maxFontSize(){return this._maxFontSize}set autoFitWidth(e){this._autoFitWidth!==e&&(this._autoFitWidth=e,this._fontSize=this._shouldAutoFit()?this._maxFontSize:this._originalFontSize,this.font&&this._updateText())}get autoFitWidth(){return this._autoFitWidth}set autoFitHeight(e){this._autoFitHeight!==e&&(this._autoFitHeight=e,this._fontSize=this._shouldAutoFit()?this._maxFontSize:this._originalFontSize,this.font&&this._updateText())}get autoFitHeight(){return this._autoFitHeight}set maxLines(e){this._maxLines!==e&&(null===e&&-1===this._maxLines||(this._maxLines=null===e?-1:e,this.font&&this._wrapLines&&this._updateText()))}get maxLines(){return this._maxLines}set enableMarkup(e){e=!!e,this._enableMarkup!==e&&(this._enableMarkup=e,this.font&&this._updateText())}get enableMarkup(){return this._enableMarkup}get symbols(){return this._symbols}get symbolColors(){return null===this._symbolColors?null:this._symbolColors.map((function(e){return this._colorPalette.slice(3*e,3*e+3)}),this)}get rtl(){return this._rtl}set rangeStart(e){(e=Math.max(0,Math.min(e,this._symbols.length)))!==this._rangeStart&&(this._rangeStart=e,this._updateRenderRange())}get rangeStart(){return this._rangeStart}set rangeEnd(e){(e=Math.max(this._rangeStart,Math.min(e,this._symbols.length)))!==this._rangeEnd&&(this._rangeEnd=e,this._updateRenderRange())}get rangeEnd(){return this._rangeEnd}}const SE=new Pu,AE=new zu,ME=new Pu,LE=new Pu,RE=new zu,IE=new zu,PE=new zu,kE=new zu;class DE extends Ux{constructor(e,t){super(e,t),this._beingInitialized=!1,this._anchor=new Ou,this._localAnchor=new Ou,this._pivot=new Du,this._width=this._calculatedWidth=32,this._height=this._calculatedHeight=32,this._margin=new Ou(0,0,-32,-32),this._modelTransform=new zu,this._screenToWorld=new zu,this._anchorTransform=new zu,this._anchorDirty=!0,this._parentWorldTransform=new zu,this._screenTransform=new zu,this._screenCorners=[new Pu,new Pu,new Pu,new Pu],this._canvasCorners=[new Du,new Du,new Du,new Du],this._worldCorners=[new Pu,new Pu,new Pu,new Pu],this._cornersDirty=!0,this._canvasCornersDirty=!0,this._worldCornersDirty=!0,this.entity.on("insert",this._onInsert,this),this._patch(),this.screen=null,this._type="group",this._image=null,this._text=null,this._group=null,this._drawOrder=0,this._useInput=!1,this._layers=[4],this._addedModels=[],this._batchGroupId=-1,this._offsetReadAt=0,this._maskOffset=.5,this._maskedBy=null}get _absLeft(){return this._localAnchor.x+this._margin.x}get _absRight(){return this._localAnchor.z-this._margin.z}get _absTop(){return this._localAnchor.w-this._margin.w}get _absBottom(){return this._localAnchor.y+this._margin.y}get _hasSplitAnchorsX(){return Math.abs(this._anchor.x-this._anchor.z)>.001}get _hasSplitAnchorsY(){return Math.abs(this._anchor.y-this._anchor.w)>.001}get aabb(){return this._image?this._image.aabb:this._text?this._text.aabb:null}set anchor(e){e instanceof Ou?this._anchor.set(e.x,e.y,e.z,e.w):this._anchor.set(e[0],e[1],e[2],e[3]),this.entity._parent||this.screen?this._calculateSize(this._hasSplitAnchorsX,this._hasSplitAnchorsY):this._calculateLocalAnchors(),this._anchorDirty=!0,this.entity._dirtyLocal||this.entity._dirtifyLocal(),this.fire("set:anchor",this._anchor)}get anchor(){return this._anchor}set batchGroupId(e){this._batchGroupId!==e&&(this.entity.enabled&&this._batchGroupId>=0&&this.system.app.batcher.remove(gy.ELEMENT,this.batchGroupId,this.entity),this.entity.enabled&&e>=0&&this.system.app.batcher.insert(gy.ELEMENT,e,this.entity),e<0&&this._batchGroupId>=0&&this.enabled&&this.entity.enabled&&(this._image&&this._image._renderable.model?this.addModelToLayers(this._image._renderable.model):this._text&&this._text._model&&this.addModelToLayers(this._text._model)),this._batchGroupId=e)}get batchGroupId(){return this._batchGroupId}set bottom(e){this._margin.y=e;const t=this.entity.getLocalPosition(),n=this._absTop,a=this._localAnchor.y+e;this._setHeight(n-a),t.y=e+this._calculatedHeight*this._pivot.y,this.entity.setLocalPosition(t)}get bottom(){return this._margin.y}set calculatedWidth(e){this._setCalculatedWidth(e,!0)}get calculatedWidth(){return this._calculatedWidth}set calculatedHeight(e){this._setCalculatedHeight(e,!0)}get calculatedHeight(){return this._calculatedHeight}get canvasCorners(){if(!this._canvasCornersDirty||!this.screen||!this.screen.screen.screenSpace)return this._canvasCorners;const e=this.system.app.graphicsDevice,t=this.screenCorners,n=e.canvas.clientWidth/e.width,a=e.canvas.clientHeight/e.height;for(let i=0;i<4;i++)this._canvasCorners[i].set(t[i].x*n,(e.height-t[i].y)*a);return this._canvasCornersDirty=!1,this._canvasCorners}set drawOrder(e){let t=0;this.screen&&(t=this.screen.screen.priority),e>16777215&&(e=16777215),this._drawOrder=(t<<24)+e,this.fire("set:draworder",this._drawOrder)}get drawOrder(){return this._drawOrder}set height(e){this._height=e,this._hasSplitAnchorsY||this._setCalculatedHeight(e,!0),this.fire("set:height",this._height)}get height(){return this._height}set layers(e){if(this._addedModels.length)for(let e=0;e<this._layers.length;e++){const t=this.system.app.scene.layers.getLayerById(this._layers[e]);if(t)for(let e=0;e<this._addedModels.length;e++)t.removeMeshInstances(this._addedModels[e].meshInstances)}if(this._layers=e,this.enabled&&this.entity.enabled&&this._addedModels.length)for(let e=0;e<this._layers.length;e++){const t=this.system.app.scene.layers.getLayerById(this._layers[e]);if(t)for(let e=0;e<this._addedModels.length;e++)t.addMeshInstances(this._addedModels[e].meshInstances)}}get layers(){return this._layers}set left(e){this._margin.x=e;const t=this.entity.getLocalPosition(),n=this._absRight,a=this._localAnchor.x+e;this._setWidth(n-a),t.x=e+this._calculatedWidth*this._pivot.x,this.entity.setLocalPosition(t)}get left(){return this._margin.x}set margin(e){this._margin.copy(e),this._calculateSize(!0,!0),this.fire("set:margin",this._margin)}get margin(){return this._margin}get maskedBy(){return this._maskedBy}set pivot(e){const t=this._pivot.x,n=this._pivot.y;e instanceof Du?this._pivot.set(e.x,e.y):this._pivot.set(e[0],e[1]);const a=this._margin.x+this._margin.z,i=this._pivot.x-t;this._margin.x+=a*i,this._margin.z-=a*i;const s=this._margin.y+this._margin.w,r=this._pivot.y-n;this._margin.y+=s*r,this._margin.w-=s*r,this._anchorDirty=!0,this._cornersDirty=!0,this._worldCornersDirty=!0,this._calculateSize(!1,!1),this._flagChildrenAsDirty(),this.fire("set:pivot",this._pivot)}get pivot(){return this._pivot}set right(e){this._margin.z=e;const t=this.entity.getLocalPosition(),n=this._absLeft,a=this._localAnchor.z-e;this._setWidth(a-n),t.x=this._localAnchor.z-this._localAnchor.x-e-this._calculatedWidth*(1-this._pivot.x),this.entity.setLocalPosition(t)}get right(){return this._margin.z}get screenCorners(){if(!this._cornersDirty||!this.screen)return this._screenCorners;const e=this.entity.parent&&this.entity.parent.element&&this.entity.parent.element.screenCorners[0];this._screenCorners[0].set(this._absLeft,this._absBottom,0),this._screenCorners[1].set(this._absRight,this._absBottom,0),this._screenCorners[2].set(this._absRight,this._absTop,0),this._screenCorners[3].set(this._absLeft,this._absTop,0);const t=this.screen.screen.screenSpace;for(let n=0;n<4;n++)this._screenTransform.transformPoint(this._screenCorners[n],this._screenCorners[n]),t&&this._screenCorners[n].mulScalar(this.screen.screen.scale),e&&this._screenCorners[n].add(e);return this._cornersDirty=!1,this._canvasCornersDirty=!0,this._worldCornersDirty=!0,this._screenCorners}get textWidth(){return this._text?this._text.width:0}get textHeight(){return this._text?this._text.height:0}set top(e){this._margin.w=e;const t=this.entity.getLocalPosition(),n=this._absBottom,a=this._localAnchor.w-e;this._setHeight(a-n),t.y=this._localAnchor.w-this._localAnchor.y-e-this._calculatedHeight*(1-this._pivot.y),this.entity.setLocalPosition(t)}get top(){return this._margin.w}set type(e){e!==this._type&&(this._type=e,this._image&&(this._image.destroy(),this._image=null),this._text&&(this._text.destroy(),this._text=null),"image"===e?this._image=new lE(this):"text"===e&&(this._text=new EE(this)))}get type(){return this._type}set useInput(e){this._useInput!==e&&(this._useInput=e,this.system.app.elementInput?e?this.enabled&&this.entity.enabled&&this.system.app.elementInput.addElement(this):this.system.app.elementInput.removeElement(this):!0===this._useInput&&console.warn("Elements will not get any input events because this.system.app.elementInput is not created"),this.fire("set:useInput",e))}get useInput(){return this._useInput}set width(e){this._width=e,this._hasSplitAnchorsX||this._setCalculatedWidth(e,!0),this.fire("set:width",this._width)}get width(){return this._width}get worldCorners(){if(!this._worldCornersDirty)return this._worldCorners;if(this.screen){const e=this.screenCorners;if(!this.screen.screen.screenSpace){RE.copy(this.screen.screen._screenMatrix),RE.data[13]=-RE.data[13],RE.mul2(this.screen.getWorldTransform(),RE);for(let t=0;t<4;t++)RE.transformPoint(e[t],this._worldCorners[t])}}else{const e=this.entity.getLocalPosition();RE.setTranslate(-e.x,-e.y,-e.z),IE.setTRS(Pu.ZERO,this.entity.getLocalRotation(),this.entity.getLocalScale()),PE.setTranslate(e.x,e.y,e.z);const t=this.entity.parent?this.entity.parent:this.entity;kE.copy(t.getWorldTransform()),kE.mul(PE).mul(IE).mul(RE),ME.set(e.x-this.pivot.x*this.calculatedWidth,e.y-this.pivot.y*this.calculatedHeight,e.z),kE.transformPoint(ME,this._worldCorners[0]),ME.set(e.x+(1-this.pivot.x)*this.calculatedWidth,e.y-this.pivot.y*this.calculatedHeight,e.z),kE.transformPoint(ME,this._worldCorners[1]),ME.set(e.x+(1-this.pivot.x)*this.calculatedWidth,e.y+(1-this.pivot.y)*this.calculatedHeight,e.z),kE.transformPoint(ME,this._worldCorners[2]),ME.set(e.x-this.pivot.x*this.calculatedWidth,e.y+(1-this.pivot.y)*this.calculatedHeight,e.z),kE.transformPoint(ME,this._worldCorners[3])}return this._worldCornersDirty=!1,this._worldCorners}_patch(){this.entity._sync=this._sync,this.entity.setPosition=this._setPosition,this.entity.setLocalPosition=this._setLocalPosition}_unpatch(){this.entity._sync=KM.prototype._sync,this.entity.setPosition=KM.prototype.setPosition,this.entity.setLocalPosition=KM.prototype.setLocalPosition}_setPosition(e,t,n){if(!this.element.screen)return KM.prototype.setPosition.call(this,e,t,n);e instanceof Pu?SE.copy(e):SE.set(e,t,n),this.getWorldTransform(),AE.copy(this.element._screenToWorld).invert(),AE.transformPoint(SE,this.localPosition),this._dirtyLocal||this._dirtifyLocal()}_setLocalPosition(e,t,n){e instanceof Pu?this.localPosition.copy(e):this.localPosition.set(e,t,n);const a=this.element,i=this.localPosition,s=a._pivot;a._margin.x=i.x-a._calculatedWidth*s.x,a._margin.z=a._localAnchor.z-a._localAnchor.x-a._calculatedWidth-a._margin.x,a._margin.y=i.y-a._calculatedHeight*s.y,a._margin.w=a._localAnchor.w-a._localAnchor.y-a._calculatedHeight-a._margin.y,this._dirtyLocal||this._dirtifyLocal()}_sync(){const e=this.element,t=e.screen;if(t){if(e._anchorDirty){let n=0,a=0,i=0,s=1;if(this._parent&&this._parent.element)n=this._parent.element.calculatedWidth,a=this._parent.element.calculatedHeight,i=this._parent.element.pivot.x,s=this._parent.element.pivot.y;else{const e=t.screen.resolution;n=e.x/t.screen.scale,a=e.y/t.screen.scale}e._anchorTransform.setTranslate(n*(e.anchor.x-i),-a*(s-e.anchor.y),0),e._anchorDirty=!1,e._calculateLocalAnchors()}e._sizeDirty&&e._calculateSize(!1,!1)}if(this._dirtyLocal){this.localTransform.setTRS(this.localPosition,this.localRotation,this.localScale);const t=this.localPosition,n=e._pivot;e._margin.x=t.x-e._calculatedWidth*n.x,e._margin.z=e._localAnchor.z-e._localAnchor.x-e._calculatedWidth-e._margin.x,e._margin.y=t.y-e._calculatedHeight*n.y,e._margin.w=e._localAnchor.w-e._localAnchor.y-e._calculatedHeight-e._margin.y,this._dirtyLocal=!1}if(!t)return this._dirtyWorld&&(e._cornersDirty=!0,e._canvasCornersDirty=!0,e._worldCornersDirty=!0),KM.prototype._sync.call(this);if(this._dirtyWorld){if(null===this._parent)this.worldTransform.copy(this.localTransform);else if(this._parent.element?e._screenToWorld.mul2(this._parent.element._modelTransform,e._anchorTransform):e._screenToWorld.copy(e._anchorTransform),e._modelTransform.mul2(e._screenToWorld,this.localTransform),t){e._screenToWorld.mul2(t.screen._screenMatrix,e._screenToWorld),t.screen.screenSpace||e._screenToWorld.mul2(t.worldTransform,e._screenToWorld),this.worldTransform.mul2(e._screenToWorld,this.localTransform);const n=e._parentWorldTransform;n.setIdentity();const a=this._parent;a&&a.element&&a!==t&&(RE.setTRS(Pu.ZERO,a.getLocalRotation(),a.getLocalScale()),n.mul2(a.element._parentWorldTransform,RE));const i=ME;i.set(0,0,this.localPosition.z);const s=LE;s.set(e._absLeft+e._pivot.x*e.calculatedWidth,e._absBottom+e._pivot.y*e.calculatedHeight,0),RE.setTranslate(-s.x,-s.y,-s.z),IE.setTRS(i,this.getLocalRotation(),this.getLocalScale()),PE.setTranslate(s.x,s.y,s.z),e._screenTransform.mul2(e._parentWorldTransform,PE).mul(IE).mul(RE),e._cornersDirty=!0,e._canvasCornersDirty=!0,e._worldCornersDirty=!0}else this.worldTransform.copy(e._modelTransform);this._dirtyWorld=!1}}_onInsert(e){const t=this._parseUpToScreen();this.entity._dirtifyWorld(),this._updateScreen(t.screen),this._dirtifyMask()}_dirtifyMask(){let e=this.entity;for(;e;){const t=e.parent;if((null===t||t.screen)&&e.element){this.system._prerender&&this.system._prerender.length||(this.system._prerender=[],this.system.app.once("prerender",this._onPrerender,this));const t=this.system._prerender.indexOf(this.entity);t>=0&&this.system._prerender.splice(t,1);this.system._prerender.indexOf(e)<0&&this.system._prerender.push(e)}e=t}}_onPrerender(){for(let e=0;e<this.system._prerender.length;e++){const t=this.system._prerender[e];if(t.element){const e=1;t.element.syncMask(e)}}this.system._prerender.length=0}_bindScreen(e){e._bindElement(this)}_unbindScreen(e){e._unbindElement(this)}_updateScreen(e){this.screen&&this.screen!==e&&this._unbindScreen(this.screen.screen);const t=this.screen;this.screen=e,this.screen&&this._bindScreen(this.screen.screen),this._calculateSize(this._hasSplitAnchorsX,this._hasSplitAnchorsY),this.fire("set:screen",this.screen,t),this._anchorDirty=!0;const n=this.entity.children;for(let t=0,a=n.length;t<a;t++)n[t].element&&n[t].element._updateScreen(e);this.screen&&this.screen.screen.syncDrawOrder()}syncMask(e){const t=this._parseUpToScreen();this._updateMask(t.mask,e)}_setMaskedBy(e){const t=this._image||this._text;if(e){const n=e.element._image._maskRef,a=new rE({ref:n,func:2});t&&t._setStencil&&t._setStencil(a),this._maskedBy=e}else t&&t._setStencil&&t._setStencil(null),this._maskedBy=null}_updateMask(e,t){if(e){if(this._setMaskedBy(e),this.mask){const n=e.element._image._maskRef,a=new rE({ref:n,func:2,zpass:3});this._image._setStencil(a),this._image._maskRef=t,t++,e=this.entity}const n=this.entity.children;for(let a=0,i=n.length;a<i;a++)n[a].element&&n[a].element._updateMask(e,t);this.mask&&t--}else{if(this._setMaskedBy(null),this.mask){const n=new rE({ref:t,func:7,zpass:2});this._image._setStencil(n),this._image._maskRef=t,t++,e=this.entity}const n=this.entity.children;for(let a=0,i=n.length;a<i;a++)n[a].element&&n[a].element._updateMask(e,t);this.mask&&t--}}_parseUpToScreen(){const e={screen:null,mask:null};let t=this.entity._parent;for(;t&&!t.screen;)t.element&&t.element.mask&&(e.mask||(e.mask=t)),t=t.parent;return t&&t.screen&&(e.screen=t),e}_onScreenResize(e){this._anchorDirty=!0,this._cornersDirty=!0,this._worldCornersDirty=!0,this._calculateSize(this._hasSplitAnchorsX,this._hasSplitAnchorsY),this.fire("screen:set:resolution",e)}_onScreenSpaceChange(){this.fire("screen:set:screenspace",this.screen.screen.screenSpace)}_onScreenRemove(){this.screen&&(this.screen._destroying?this.screen=null:this._updateScreen(null))}_calculateLocalAnchors(){let e=1e3,t=1e3;const n=this.entity._parent;if(n&&n.element)e=n.element.calculatedWidth,t=n.element.calculatedHeight;else if(this.screen){const n=this.screen.screen.resolution,a=this.screen.screen.scale;e=n.x/a,t=n.y/a}this._localAnchor.set(this._anchor.x*e,this._anchor.y*t,this._anchor.z*e,this._anchor.w*t)}getOffsetPosition(e,t){const n=this.entity.getLocalPosition().clone();return n.x+=e,n.y+=t,this._screenToWorld.transformPoint(n,n),n}onLayersChanged(e,t){this.addModelToLayers(this._image?this._image._renderable.model:this._text._model),e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this)}onLayerAdded(e){this.layers.indexOf(e.id)<0||(this._image?e.addMeshInstances(this._image._renderable.model.meshInstances):this._text&&e.addMeshInstances(this._text._model.meshInstances))}onLayerRemoved(e){this.layers.indexOf(e.id)<0||(this._image?e.removeMeshInstances(this._image._renderable.model.meshInstances):this._text&&e.removeMeshInstances(this._text._model.meshInstances))}onEnable(){this._image&&this._image.onEnable(),this._text&&this._text.onEnable(),this._group&&this._group.onEnable(),this.useInput&&this.system.app.elementInput&&this.system.app.elementInput.addElement(this),this.system.app.scene.on("set:layers",this.onLayersChanged,this),this.system.app.scene.layers&&(this.system.app.scene.layers.on("add",this.onLayerAdded,this),this.system.app.scene.layers.on("remove",this.onLayerRemoved,this)),this._batchGroupId>=0&&this.system.app.batcher.insert(gy.ELEMENT,this.batchGroupId,this.entity),this.fire("enableelement")}onDisable(){this.system.app.scene.off("set:layers",this.onLayersChanged,this),this.system.app.scene.layers&&(this.system.app.scene.layers.off("add",this.onLayerAdded,this),this.system.app.scene.layers.off("remove",this.onLayerRemoved,this)),this._image&&this._image.onDisable(),this._text&&this._text.onDisable(),this._group&&this._group.onDisable(),this.system.app.elementInput&&this.useInput&&this.system.app.elementInput.removeElement(this),this._batchGroupId>=0&&this.system.app.batcher.remove(gy.ELEMENT,this.batchGroupId,this.entity),this.fire("disableelement")}onRemove(){this.entity.off("insert",this._onInsert,this),this._unpatch(),this._image&&this._image.destroy(),this._text&&this._text.destroy(),this.system.app.elementInput&&this.useInput&&this.system.app.elementInput.removeElement(this),this.screen&&this.screen.screen&&(this._unbindScreen(this.screen.screen),this.screen.screen.syncDrawOrder()),this.off()}_calculateSize(e,t){if(!this.entity._parent&&!this.screen)return;this._calculateLocalAnchors();const n=this._absRight-this._absLeft,a=this._absTop-this._absBottom;e?this._setWidth(n):this._setCalculatedWidth(n,!1),t?this._setHeight(a):this._setCalculatedHeight(a,!1);const i=this.entity.getLocalPosition();i.x=this._margin.x+this._calculatedWidth*this._pivot.x,i.y=this._margin.y+this._calculatedHeight*this._pivot.y,this.entity.setLocalPosition(i),this._sizeDirty=!1}_setWidth(e){this._width=e,this._setCalculatedWidth(e,!1),this.fire("set:width",this._width)}_setHeight(e){this._height=e,this._setCalculatedHeight(e,!1),this.fire("set:height",this._height)}_setCalculatedWidth(e,t){if(!(Math.abs(e-this._calculatedWidth)<=1e-4)){if(this._calculatedWidth=e,this.entity._dirtifyLocal(),t){const e=this.entity.getLocalPosition(),t=this._pivot;this._margin.x=e.x-this._calculatedWidth*t.x,this._margin.z=this._localAnchor.z-this._localAnchor.x-this._calculatedWidth-this._margin.x}this._flagChildrenAsDirty(),this.fire("set:calculatedWidth",this._calculatedWidth),this.fire("resize",this._calculatedWidth,this._calculatedHeight)}}_setCalculatedHeight(e,t){if(!(Math.abs(e-this._calculatedHeight)<=1e-4)){if(this._calculatedHeight=e,this.entity._dirtifyLocal(),t){const e=this.entity.getLocalPosition(),t=this._pivot;this._margin.y=e.y-this._calculatedHeight*t.y,this._margin.w=this._localAnchor.w-this._localAnchor.y-this._calculatedHeight-this._margin.y}this._flagChildrenAsDirty(),this.fire("set:calculatedHeight",this._calculatedHeight),this.fire("resize",this._calculatedWidth,this._calculatedHeight)}}_flagChildrenAsDirty(){const e=this.entity._children;for(let t=0,n=e.length;t<n;t++)e[t].element&&(e[t].element._anchorDirty=!0,e[t].element._sizeDirty=!0)}addModelToLayers(e){this._addedModels.push(e);for(let t=0;t<this.layers.length;t++){const n=this.system.app.scene.layers.getLayerById(this.layers[t]);n&&n.addMeshInstances(e.meshInstances)}}removeModelFromLayers(e){const t=this._addedModels.indexOf(e);t>=0&&this._addedModels.splice(t,1);for(let t=0;t<this.layers.length;t++){const n=this.system.app.scene.layers.getLayerById(this.layers[t]);n&&n.removeMeshInstances(e.meshInstances)}}getMaskOffset(){const e=this.system.app.frame;this._offsetReadAt!==e&&(this._maskOffset=.5,this._offsetReadAt=e);const t=this._maskOffset;return this._maskOffset-=.001,t}isVisibleForCamera(e){let t,n,a,i;if(this.maskedBy){const e=this.maskedBy.element.screenCorners;t=Math.min(Math.min(e[0].x,e[1].x),Math.min(e[2].x,e[3].x)),n=Math.max(Math.max(e[0].x,e[1].x),Math.max(e[2].x,e[3].x)),i=Math.min(Math.min(e[0].y,e[1].y),Math.min(e[2].y,e[3].y)),a=Math.max(Math.max(e[0].y,e[1].y),Math.max(e[2].y,e[3].y))}else{const s=this.system.app.graphicsDevice.width,r=this.system.app.graphicsDevice.height,o=e._rect.z*s,l=e._rect.w*r;t=e._rect.x*s,n=t+o,a=(1-e._rect.y)*r,i=a-l}const s=this.screenCorners,r=Math.min(Math.min(s[0].x,s[1].x),Math.min(s[2].x,s[3].x)),o=Math.max(Math.max(s[0].x,s[1].x),Math.max(s[2].x,s[3].x)),l=Math.min(Math.min(s[0].y,s[1].y),Math.min(s[2].y,s[3].y)),c=Math.max(Math.max(s[0].y,s[1].y),Math.max(s[2].y,s[3].y));return!(o<t||r>n||l>a||c<i)}_isScreenSpace(){return!(!this.screen||!this.screen.screen)&&this.screen.screen.screenSpace}_isScreenCulled(){return!(!this.screen||!this.screen.screen)&&this.screen.screen.cull}}function OE(e){Object.defineProperty(DE.prototype,e,{get:function(){return this._text?this._text[e]:this._image?this._image[e]:null},set:function(t){this._text?this._text[e]=t:this._image&&(this._image[e]=t)}})}OE("fontSize"),OE("minFontSize"),OE("maxFontSize"),OE("maxLines"),OE("autoFitWidth"),OE("autoFitHeight"),OE("color"),OE("font"),OE("fontAsset"),OE("spacing"),OE("lineHeight"),OE("wrapLines"),OE("lines"),OE("alignment"),OE("autoWidth"),OE("autoHeight"),OE("rtlReorder"),OE("unicodeConverter"),OE("text"),OE("key"),OE("texture"),OE("textureAsset"),OE("material"),OE("materialAsset"),OE("sprite"),OE("spriteAsset"),OE("spriteFrame"),OE("pixelsPerUnit"),OE("opacity"),OE("rect"),OE("mask"),OE("outlineColor"),OE("outlineThickness"),OE("shadowColor"),OE("shadowOffset"),OE("enableMarkup"),OE("rangeStart"),OE("rangeEnd");class FE{constructor(){this.enabled=!0}}const NE=["enabled"];class VE extends AC{constructor(e){super(e),this.id="element",this.ComponentType=DE,this.DataType=FE,this.schema=NE,this._unicodeConverter=null,this._rtlReorder=null,this._defaultTexture=new Gm(e.graphicsDevice,{width:1,height:1,format:7}),this._defaultTexture.name="element-system";const t=this._defaultTexture.lock(),n=new Uint8Array(4);n[0]=255,n[1]=255,n[2]=255,n[3]=255,t.set(n),this._defaultTexture.unlock(),this.defaultImageMaterial=null,this.defaultImage9SlicedMaterial=null,this.defaultImage9TiledMaterial=null,this.defaultImageMaskMaterial=null,this.defaultImage9SlicedMaskMaterial=null,this.defaultImage9TiledMaskMaterial=null,this.defaultScreenSpaceImageMaterial=null,this.defaultScreenSpaceImage9SlicedMaterial=null,this.defaultScreenSpaceImage9TiledMaterial=null,this.defaultScreenSpaceImageMask9SlicedMaterial=null,this.defaultScreenSpaceImageMask9TiledMaterial=null,this.defaultScreenSpaceImageMaskMaterial=null,this.defaultTextMaterial=null,this.defaultBitmapTextMaterial=null,this.defaultScreenSpaceTextMaterial=null,this.defaultScreenSpaceBitmapTextMaterial=null,this.defaultImageMaterials=[],this.on("beforeremove",this.onRemoveComponent,this)}destroy(){super.destroy(),this._defaultTexture.destroy()}initializeComponentData(e,t,n){e._beingInitialized=!0,void 0!==t.anchor&&(t.anchor instanceof Ou?e.anchor.copy(t.anchor):e.anchor.set(t.anchor[0],t.anchor[1],t.anchor[2],t.anchor[3])),void 0!==t.pivot&&(t.pivot instanceof Du?e.pivot.copy(t.pivot):e.pivot.set(t.pivot[0],t.pivot[1]));const a=Math.abs(e.anchor.x-e.anchor.z)>.001,i=Math.abs(e.anchor.y-e.anchor.w)>.001;let s,r=!1;void 0!==t.margin&&(t.margin instanceof Ou?e.margin.copy(t.margin):e._margin.set(t.margin[0],t.margin[1],t.margin[2],t.margin[3]),r=!0),void 0!==t.left&&(e._margin.x=t.left,r=!0),void 0!==t.bottom&&(e._margin.y=t.bottom,r=!0),void 0!==t.right&&(e._margin.z=t.right,r=!0),void 0!==t.top&&(e._margin.w=t.top,r=!0),r&&(e.margin=e._margin);let o=!1;void 0===t.width||a?a&&(o=!0):e.width=t.width,void 0===t.height||i?i&&(o=!0):e.height=t.height,o&&(e.anchor=e.anchor),void 0!==t.enabled&&(e.enabled=t.enabled),void 0!==t.useInput&&(e.useInput=t.useInput),e.batchGroupId=void 0===t.batchGroupId||null===t.batchGroupId?-1:t.batchGroupId,t.layers&&Array.isArray(t.layers)&&(e.layers=t.layers.slice(0)),void 0!==t.type&&(e.type=t.type),"image"===e.type?(void 0!==t.rect&&(e.rect=t.rect),void 0!==t.color&&(s=t.color,s instanceof Mu||(s=new Mu(t.color[0],t.color[1],t.color[2])),e.color=s),void 0!==t.opacity&&(e.opacity=t.opacity),void 0!==t.textureAsset&&(e.textureAsset=t.textureAsset),t.texture&&(e.texture=t.texture),void 0!==t.spriteAsset&&(e.spriteAsset=t.spriteAsset),t.sprite&&(e.sprite=t.sprite),void 0!==t.spriteFrame&&(e.spriteFrame=t.spriteFrame),void 0!==t.pixelsPerUnit&&null!==t.pixelsPerUnit&&(e.pixelsPerUnit=t.pixelsPerUnit),void 0!==t.materialAsset&&(e.materialAsset=t.materialAsset),t.material&&(e.material=t.material),void 0!==t.mask&&(e.mask=t.mask)):"text"===e.type&&(void 0!==t.autoWidth&&(e.autoWidth=t.autoWidth),void 0!==t.autoHeight&&(e.autoHeight=t.autoHeight),void 0!==t.rtlReorder&&(e.rtlReorder=t.rtlReorder),void 0!==t.unicodeConverter&&(e.unicodeConverter=t.unicodeConverter),null!==t.text&&void 0!==t.text?e.text=t.text:null!==t.key&&void 0!==t.key&&(e.key=t.key),void 0!==t.color&&(s=t.color,s instanceof Mu||(s=new Mu(s[0],s[1],s[2])),e.color=s),void 0!==t.opacity&&(e.opacity=t.opacity),void 0!==t.spacing&&(e.spacing=t.spacing),void 0!==t.fontSize&&(e.fontSize=t.fontSize,t.lineHeight||(e.lineHeight=t.fontSize)),void 0!==t.lineHeight&&(e.lineHeight=t.lineHeight),void 0!==t.maxLines&&(e.maxLines=t.maxLines),void 0!==t.wrapLines&&(e.wrapLines=t.wrapLines),void 0!==t.minFontSize&&(e.minFontSize=t.minFontSize),void 0!==t.maxFontSize&&(e.maxFontSize=t.maxFontSize),t.autoFitWidth&&(e.autoFitWidth=t.autoFitWidth),t.autoFitHeight&&(e.autoFitHeight=t.autoFitHeight),void 0!==t.fontAsset&&(e.fontAsset=t.fontAsset),void 0!==t.font&&(e.font=t.font),void 0!==t.alignment&&(e.alignment=t.alignment),void 0!==t.outlineColor&&(e.outlineColor=t.outlineColor),void 0!==t.outlineThickness&&(e.outlineThickness=t.outlineThickness),void 0!==t.shadowColor&&(e.shadowColor=t.shadowColor),void 0!==t.shadowOffset&&(e.shadowOffset=t.shadowOffset),void 0!==t.enableMarkup&&(e.enableMarkup=t.enableMarkup));const l=e._parseUpToScreen();l.screen&&e._updateScreen(l.screen),super.initializeComponentData(e,t,n),e._beingInitialized=!1,"image"===e.type&&e._image._meshDirty&&e._image._updateMesh(e._image.mesh)}onRemoveComponent(e,t){t.onRemove()}cloneComponent(e,t){const n=e.element,a={enabled:n.enabled,width:n.width,height:n.height,anchor:n.anchor.clone(),pivot:n.pivot.clone(),margin:n.margin.clone(),alignment:n.alignment&&n.alignment.clone()||n.alignment,autoWidth:n.autoWidth,autoHeight:n.autoHeight,type:n.type,rect:n.rect&&n.rect.clone()||n.rect,rtlReorder:n.rtlReorder,unicodeConverter:n.unicodeConverter,materialAsset:n.materialAsset,material:n.material,color:n.color&&n.color.clone()||n.color,opacity:n.opacity,textureAsset:n.textureAsset,texture:n.texture,spriteAsset:n.spriteAsset,sprite:n.sprite,spriteFrame:n.spriteFrame,pixelsPerUnit:n.pixelsPerUnit,spacing:n.spacing,lineHeight:n.lineHeight,wrapLines:n.wrapLines,layers:n.layers,fontSize:n.fontSize,minFontSize:n.minFontSize,maxFontSize:n.maxFontSize,autoFitWidth:n.autoFitWidth,autoFitHeight:n.autoFitHeight,maxLines:n.maxLines,fontAsset:n.fontAsset,font:n.font,useInput:n.useInput,batchGroupId:n.batchGroupId,mask:n.mask,outlineColor:n.outlineColor&&n.outlineColor.clone()||n.outlineColor,outlineThickness:n.outlineThickness,shadowColor:n.shadowColor&&n.shadowColor.clone()||n.shadowColor,shadowOffset:n.shadowOffset&&n.shadowOffset.clone()||n.shadowOffset,enableMarkup:n.enableMarkup};return void 0!==n.key&&null!==n.key?a.key=n.key:a.text=n.text,this.addComponent(t,a)}getTextElementMaterial(e,t){return e?t?(this.defaultScreenSpaceTextMaterial||(this.defaultScreenSpaceTextMaterial=new cg,this.defaultScreenSpaceTextMaterial.name="defaultScreenSpaceTextMaterial",this.defaultScreenSpaceTextMaterial.msdfMap=this._defaultTexture,this.defaultScreenSpaceTextMaterial.useLighting=!1,this.defaultScreenSpaceTextMaterial.useGammaTonemap=!1,this.defaultScreenSpaceTextMaterial.useFog=!1,this.defaultScreenSpaceTextMaterial.useSkybox=!1,this.defaultScreenSpaceTextMaterial.diffuse.set(0,0,0),this.defaultScreenSpaceTextMaterial.emissive.set(1,1,1),this.defaultScreenSpaceTextMaterial.opacity=.5,this.defaultScreenSpaceTextMaterial.blendType=4,this.defaultScreenSpaceTextMaterial.depthWrite=!1,this.defaultScreenSpaceTextMaterial.depthTest=!1,this.defaultScreenSpaceTextMaterial.emissiveVertexColor=!0,this.defaultScreenSpaceTextMaterial.update()),this.defaultScreenSpaceTextMaterial):(this.defaultScreenSpaceBitmapTextMaterial||(this.defaultScreenSpaceBitmapTextMaterial=new cg,this.defaultScreenSpaceBitmapTextMaterial.name="defaultScreenSpaceBitmapTextMaterial",this.defaultScreenSpaceBitmapTextMaterial.emissive.set(.5,.5,.5),this.defaultScreenSpaceBitmapTextMaterial.emissiveMap=this._defaultTexture,this.defaultScreenSpaceBitmapTextMaterial.emissiveTint=!0,this.defaultScreenSpaceBitmapTextMaterial.opacity=.5,this.defaultScreenSpaceBitmapTextMaterial.opacityMap=this._defaultTexture,this.defaultScreenSpaceBitmapTextMaterial.opacityMapChannel="a",this.defaultScreenSpaceBitmapTextMaterial.useLighting=!1,this.defaultScreenSpaceBitmapTextMaterial.useGammaTonemap=!1,this.defaultScreenSpaceBitmapTextMaterial.useFog=!1,this.defaultScreenSpaceBitmapTextMaterial.useSkybox=!1,this.defaultScreenSpaceBitmapTextMaterial.diffuse.set(0,0,0),this.defaultScreenSpaceBitmapTextMaterial.blendType=4,this.defaultScreenSpaceBitmapTextMaterial.depthWrite=!1,this.defaultScreenSpaceBitmapTextMaterial.depthTest=!1,this.defaultScreenSpaceBitmapTextMaterial.emissiveVertexColor=!0,this.defaultScreenSpaceBitmapTextMaterial.update()),this.defaultScreenSpaceBitmapTextMaterial):t?(this.defaultTextMaterial||(this.defaultTextMaterial=new cg,this.defaultTextMaterial.name="defaultTextMaterial",this.defaultTextMaterial.msdfMap=this._defaultTexture,this.defaultTextMaterial.useLighting=!1,this.defaultTextMaterial.useGammaTonemap=!1,this.defaultTextMaterial.useFog=!1,this.defaultTextMaterial.useSkybox=!1,this.defaultTextMaterial.diffuse.set(0,0,0),this.defaultTextMaterial.emissive.set(1,1,1),this.defaultTextMaterial.opacity=.5,this.defaultTextMaterial.blendType=4,this.defaultTextMaterial.depthWrite=!1,this.defaultTextMaterial.emissiveVertexColor=!0,this.defaultTextMaterial.update()),this.defaultTextMaterial):(this.defaultBitmapTextMaterial||(this.defaultBitmapTextMaterial=new cg,this.defaultBitmapTextMaterial.name="defaultBitmapTextMaterial",this.defaultBitmapTextMaterial.emissive.set(.5,.5,.5),this.defaultBitmapTextMaterial.emissiveTint=!0,this.defaultBitmapTextMaterial.emissiveMap=this._defaultTexture,this.defaultBitmapTextMaterial.opacity=.5,this.defaultBitmapTextMaterial.opacityMap=this._defaultTexture,this.defaultBitmapTextMaterial.opacityMapChannel="a",this.defaultBitmapTextMaterial.useLighting=!1,this.defaultBitmapTextMaterial.useGammaTonemap=!1,this.defaultBitmapTextMaterial.useFog=!1,this.defaultBitmapTextMaterial.useSkybox=!1,this.defaultBitmapTextMaterial.diffuse.set(0,0,0),this.defaultBitmapTextMaterial.blendType=4,this.defaultBitmapTextMaterial.depthWrite=!1,this.defaultBitmapTextMaterial.emissiveVertexColor=!0,this.defaultBitmapTextMaterial.update()),this.defaultBitmapTextMaterial)}_createBaseImageMaterial(){const e=new cg;return e.diffuse.set(0,0,0),e.emissive.set(.5,.5,.5),e.emissiveMap=this._defaultTexture,e.emissiveTint=!0,e.opacityMap=this._defaultTexture,e.opacityMapChannel="a",e.opacityTint=!0,e.opacity=0,e.useLighting=!1,e.useGammaTonemap=!1,e.useFog=!1,e.useSkybox=!1,e.blendType=4,e.depthWrite=!1,e}getImageElementMaterial(e,t,n,a){return e?t?n?(this.defaultScreenSpaceImageMask9SlicedMaterial||(this.defaultScreenSpaceImageMask9SlicedMaterial=this._createBaseImageMaterial(),this.defaultScreenSpaceImageMask9SlicedMaterial.name="defaultScreenSpaceImageMask9SlicedMaterial",this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode=1,this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest=!1,this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest=1,this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite=!1,this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite=!1,this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite=!1,this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite=!1,this.defaultScreenSpaceImageMask9SlicedMaterial.update(),this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial)),this.defaultScreenSpaceImageMask9SlicedMaterial):a?(this.defaultScreenSpaceImageMask9TiledMaterial||(this.defaultScreenSpaceImageMask9TiledMaterial=this.defaultScreenSpaceImage9TiledMaterial.clone(),this.defaultScreenSpaceImageMask9TiledMaterial.name="defaultScreenSpaceImageMask9TiledMaterial",this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode=2,this.defaultScreenSpaceImageMask9TiledMaterial.depthTest=!1,this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest=1,this.defaultScreenSpaceImageMask9TiledMaterial.redWrite=!1,this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite=!1,this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite=!1,this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite=!1,this.defaultScreenSpaceImageMask9TiledMaterial.update(),this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial)),this.defaultScreenSpaceImageMask9TiledMaterial):(this.defaultScreenSpaceImageMaskMaterial||(this.defaultScreenSpaceImageMaskMaterial=this._createBaseImageMaterial(),this.defaultScreenSpaceImageMaskMaterial.name="defaultScreenSpaceImageMaskMaterial",this.defaultScreenSpaceImageMaskMaterial.depthTest=!1,this.defaultScreenSpaceImageMaskMaterial.alphaTest=1,this.defaultScreenSpaceImageMaskMaterial.redWrite=!1,this.defaultScreenSpaceImageMaskMaterial.greenWrite=!1,this.defaultScreenSpaceImageMaskMaterial.blueWrite=!1,this.defaultScreenSpaceImageMaskMaterial.alphaWrite=!1,this.defaultScreenSpaceImageMaskMaterial.update(),this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial)),this.defaultScreenSpaceImageMaskMaterial):n?(this.defaultScreenSpaceImage9SlicedMaterial||(this.defaultScreenSpaceImage9SlicedMaterial=this._createBaseImageMaterial(),this.defaultScreenSpaceImage9SlicedMaterial.name="defaultScreenSpaceImage9SlicedMaterial",this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode=1,this.defaultScreenSpaceImage9SlicedMaterial.depthTest=!1,this.defaultScreenSpaceImage9SlicedMaterial.update(),this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial)),this.defaultScreenSpaceImage9SlicedMaterial):a?(this.defaultScreenSpaceImage9TiledMaterial||(this.defaultScreenSpaceImage9TiledMaterial=this._createBaseImageMaterial(),this.defaultScreenSpaceImage9TiledMaterial.name="defaultScreenSpaceImage9TiledMaterial",this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode=2,this.defaultScreenSpaceImage9TiledMaterial.depthTest=!1,this.defaultScreenSpaceImage9TiledMaterial.update(),this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial)),this.defaultScreenSpaceImage9TiledMaterial):(this.defaultScreenSpaceImageMaterial||(this.defaultScreenSpaceImageMaterial=this._createBaseImageMaterial(),this.defaultScreenSpaceImageMaterial.name="defaultScreenSpaceImageMaterial",this.defaultScreenSpaceImageMaterial.depthTest=!1,this.defaultScreenSpaceImageMaterial.update(),this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial)),this.defaultScreenSpaceImageMaterial):t?n?(this.defaultImage9SlicedMaskMaterial||(this.defaultImage9SlicedMaskMaterial=this._createBaseImageMaterial(),this.defaultImage9SlicedMaskMaterial.name="defaultImage9SlicedMaskMaterial",this.defaultImage9SlicedMaskMaterial.nineSlicedMode=1,this.defaultImage9SlicedMaskMaterial.alphaTest=1,this.defaultImage9SlicedMaskMaterial.redWrite=!1,this.defaultImage9SlicedMaskMaterial.greenWrite=!1,this.defaultImage9SlicedMaskMaterial.blueWrite=!1,this.defaultImage9SlicedMaskMaterial.alphaWrite=!1,this.defaultImage9SlicedMaskMaterial.update(),this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial)),this.defaultImage9SlicedMaskMaterial):a?(this.defaultImage9TiledMaskMaterial||(this.defaultImage9TiledMaskMaterial=this._createBaseImageMaterial(),this.defaultImage9TiledMaskMaterial.name="defaultImage9TiledMaskMaterial",this.defaultImage9TiledMaskMaterial.nineSlicedMode=2,this.defaultImage9TiledMaskMaterial.alphaTest=1,this.defaultImage9TiledMaskMaterial.redWrite=!1,this.defaultImage9TiledMaskMaterial.greenWrite=!1,this.defaultImage9TiledMaskMaterial.blueWrite=!1,this.defaultImage9TiledMaskMaterial.alphaWrite=!1,this.defaultImage9TiledMaskMaterial.update(),this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial)),this.defaultImage9TiledMaskMaterial):(this.defaultImageMaskMaterial||(this.defaultImageMaskMaterial=this._createBaseImageMaterial(),this.defaultImageMaskMaterial.name="defaultImageMaskMaterial",this.defaultImageMaskMaterial.alphaTest=1,this.defaultImageMaskMaterial.redWrite=!1,this.defaultImageMaskMaterial.greenWrite=!1,this.defaultImageMaskMaterial.blueWrite=!1,this.defaultImageMaskMaterial.alphaWrite=!1,this.defaultImageMaskMaterial.update(),this.defaultImageMaterials.push(this.defaultImageMaskMaterial)),this.defaultImageMaskMaterial):n?(this.defaultImage9SlicedMaterial||(this.defaultImage9SlicedMaterial=this._createBaseImageMaterial(),this.defaultImage9SlicedMaterial.name="defaultImage9SlicedMaterial",this.defaultImage9SlicedMaterial.nineSlicedMode=1,this.defaultImage9SlicedMaterial.update(),this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial)),this.defaultImage9SlicedMaterial):a?(this.defaultImage9TiledMaterial||(this.defaultImage9TiledMaterial=this._createBaseImageMaterial(),this.defaultImage9TiledMaterial.name="defaultImage9TiledMaterial",this.defaultImage9TiledMaterial.nineSlicedMode=2,this.defaultImage9TiledMaterial.update(),this.defaultImageMaterials.push(this.defaultImage9TiledMaterial)),this.defaultImage9TiledMaterial):(this.defaultImageMaterial||(this.defaultImageMaterial=this._createBaseImageMaterial(),this.defaultImageMaterial.name="defaultImageMaterial",this.defaultImageMaterial.update(),this.defaultImageMaterials.push(this.defaultImageMaterial)),this.defaultImageMaterial)}registerUnicodeConverter(e){this._unicodeConverter=e}registerRtlReorder(e){this._rtlReorder=e}getUnicodeConverter(){return this._unicodeConverter}getRtlReorder(){return this._rtlReorder}}Ux._buildAccessors(DE.prototype,NE);const BE=["angularDampingX","angularDampingY","angularDampingZ","angularEquilibriumX","angularEquilibriumY","angularEquilibriumZ","angularLimitsX","angularLimitsY","angularLimitsZ","angularMotionX","angularMotionY","angularMotionZ","angularSpringX","angularSpringY","angularSpringZ","angularStiffnessX","angularStiffnessY","angularStiffnessZ","breakForce","enableCollision","enabled","entityA","entityB","linearDampingX","linearDampingY","linearDampingZ","linearEquilibriumX","linearEquilibriumY","linearEquilibriumZ","linearLimitsX","linearLimitsY","linearLimitsZ","linearMotionX","linearMotionY","linearMotionZ","linearSpringX","linearSpringY","linearSpringZ","linearStiffnessX","linearStiffnessY","linearStiffnessZ"];class UE extends Ux{constructor(e,t){super(e,t),this._constraint=null,this._entityA=null,this._entityB=null,this._breakForce=34e37,this._enableCollision=!0,this._linearMotionX="locked",this._linearLimitsX=new Du(0,0),this._linearSpringX=!1,this._linearStiffnessX=0,this._linearDampingX=1,this._linearEquilibriumX=0,this._linearMotionY="locked",this._linearLimitsY=new Du(0,0),this._linearSpringY=!1,this._linearStiffnessY=0,this._linearDampingY=1,this._linearEquilibriumY=0,this._linearMotionZ="locked",this._linearLimitsZ=new Du(0,0),this._linearSpringZ=!1,this._linearStiffnessZ=0,this._linearDampingZ=1,this._linearEquilibriumZ=0,this._angularMotionX="locked",this._angularLimitsX=new Du(0,0),this._angularSpringX=!1,this._angularStiffnessX=0,this._angularDampingX=1,this._angularEquilibriumX=0,this._angularMotionY="locked",this._angularLimitsY=new Du(0,0),this._angularSpringY=!1,this._angularStiffnessY=0,this._angularDampingY=1,this._angularEquilibriumY=0,this._angularMotionZ="locked",this._angularLimitsZ=new Du(0,0),this._angularSpringZ=!1,this._angularEquilibriumZ=0,this._angularDampingZ=1,this._angularStiffnessZ=0,this.on("set_enabled",this._onSetEnabled,this)}set entityA(e){this._destroyConstraint(),this._entityA=e,this._createConstraint()}get entityA(){return this._entityA}set entityB(e){this._destroyConstraint(),this._entityB=e,this._createConstraint()}get entityB(){return this._entityB}set breakForce(e){this._constraint&&this._breakForce!==e&&(this._constraint.setBreakingImpulseThreshold(e),this._breakForce=e)}get breakForce(){return this._breakForce}set enableCollision(e){this._destroyConstraint(),this._enableCollision=e,this._createConstraint()}get enableCollision(){return this._enableCollision}set angularLimitsX(e){this._angularLimitsX.equals(e)||(this._angularLimitsX.copy(e),this._updateAngularLimits())}get angularLimitsX(){return this._angularLimitsX}set angularMotionX(e){this._angularMotionX!==e&&(this._angularMotionX=e,this._updateAngularLimits())}get angularMotionX(){return this._angularMotionX}set angularLimitsY(e){this._angularLimitsY.equals(e)||(this._angularLimitsY.copy(e),this._updateAngularLimits())}get angularLimitsY(){return this._angularLimitsY}set angularMotionY(e){this._angularMotionY!==e&&(this._angularMotionY=e,this._updateAngularLimits())}get angularMotionY(){return this._angularMotionY}set angularLimitsZ(e){this._angularLimitsZ.equals(e)||(this._angularLimitsZ.copy(e),this._updateAngularLimits())}get angularLimitsZ(){return this._angularLimitsZ}set angularMotionZ(e){this._angularMotionZ!==e&&(this._angularMotionZ=e,this._updateAngularLimits())}get angularMotionZ(){return this._angularMotionZ}set linearLimitsX(e){this._linearLimitsX.equals(e)||(this._linearLimitsX.copy(e),this._updateLinearLimits())}get linearLimitsX(){return this._linearLimitsX}set linearMotionX(e){this._linearMotionX!==e&&(this._linearMotionX=e,this._updateLinearLimits())}get linearMotionX(){return this._linearMotionX}set linearLimitsY(e){this._linearLimitsY.equals(e)||(this._linearLimitsY.copy(e),this._updateLinearLimits())}get linearLimitsY(){return this._linearLimitsY}set linearMotionY(e){this._linearMotionY!==e&&(this._linearMotionY=e,this._updateLinearLimits())}get linearMotionY(){return this._linearMotionY}set linearLimitsZ(e){this._linearLimitsZ.equals(e)||(this._linearLimitsZ.copy(e),this._updateLinearLimits())}get linearLimitsZ(){return this._linearLimitsZ}set linearMotionZ(e){this._linearMotionZ!==e&&(this._linearMotionZ=e,this._updateLinearLimits())}get linearMotionZ(){return this._linearMotionZ}_convertTransform(e,t){const n=e.getTranslation(),a=new Gu;a.setFromMat4(e);const i=new Ammo.btVector3(n.x,n.y,n.z),s=new Ammo.btQuaternion(a.x,a.y,a.z,a.w);t.setOrigin(i),t.setRotation(s),Ammo.destroy(i),Ammo.destroy(s)}_updateAngularLimits(){const e=this._constraint;if(e){let t,n,a,i,s,r;"limited"===this._angularMotionX?(t=this._angularLimitsX.x*Eu.DEG_TO_RAD,i=this._angularLimitsX.y*Eu.DEG_TO_RAD):"free"===this._angularMotionX?(t=1,i=0):t=i=0,"limited"===this._angularMotionY?(n=this._angularLimitsY.x*Eu.DEG_TO_RAD,s=this._angularLimitsY.y*Eu.DEG_TO_RAD):"free"===this._angularMotionY?(n=1,s=0):n=s=0,"limited"===this._angularMotionZ?(a=this._angularLimitsZ.x*Eu.DEG_TO_RAD,r=this._angularLimitsZ.y*Eu.DEG_TO_RAD):"free"===this._angularMotionZ?(a=1,r=0):a=r=0;const o=new Ammo.btVector3(t,n,a);e.setAngularLowerLimit(o),o.setValue(i,s,r),e.setAngularUpperLimit(o),Ammo.destroy(o)}}_updateLinearLimits(){const e=this._constraint;if(e){let t,n,a,i,s,r;"limited"===this._linearMotionX?(t=this._linearLimitsX.x,i=this._linearLimitsX.y):"free"===this._linearMotionX?(t=1,i=0):t=i=0,"limited"===this._linearMotionY?(n=this._linearLimitsY.x,s=this._linearLimitsY.y):"free"===this._linearMotionY?(n=1,s=0):n=s=0,"limited"===this._linearMotionZ?(a=this._linearLimitsZ.x,r=this._linearLimitsZ.y):"free"===this._linearMotionZ?(a=1,r=0):a=r=0;const o=new Ammo.btVector3(t,n,a);e.setLinearLowerLimit(o),o.setValue(i,s,r),e.setLinearUpperLimit(o),Ammo.destroy(o)}}_createConstraint(){if(this._entityA&&this._entityA.rigidbody){this._destroyConstraint();const e=new zu,t=this._entityA.rigidbody.body;t.activate();const n=this.entity.getWorldTransform(),a=this._entityA.getWorldTransform().clone().invert();e.mul2(a,n);const i=new Ammo.btTransform;if(this._convertTransform(e,i),this._entityB&&this._entityB.rigidbody){const a=this._entityB.rigidbody.body;a.activate();const s=this._entityB.getWorldTransform().clone().invert();e.mul2(s,n);const r=new Ammo.btTransform;this._convertTransform(e,r),this._constraint=new Ammo.btGeneric6DofSpringConstraint(t,a,i,r,!this._enableCollision),Ammo.destroy(r)}else this._constraint=new Ammo.btGeneric6DofSpringConstraint(t,i,!this._enableCollision);Ammo.destroy(i);const s=["X","Y","Z","X","Y","Z"];for(let e=0;e<6;e++){const t=e<3?"_linear":"_angular";this._constraint.enableSpring(e,this[t+"Spring"+s[e]]),this._constraint.setDamping(e,this[t+"Damping"+s[e]]),this._constraint.setEquilibriumPoint(e,this[t+"Equilibrium"+s[e]]),this._constraint.setStiffness(e,this[t+"Stiffness"+s[e]])}this._constraint.setBreakingImpulseThreshold(this._breakForce),this._updateLinearLimits(),this._updateAngularLimits();this.system.app.systems.rigidbody.dynamicsWorld.addConstraint(this._constraint,!this._enableCollision)}}_destroyConstraint(){if(this._constraint){this.system.app.systems.rigidbody.dynamicsWorld.removeConstraint(this._constraint),Ammo.destroy(this._constraint),this._constraint=null}}initFromData(e){for(const t of BE)e.hasOwnProperty(t)&&(e[t]instanceof Du?this["_"+t].copy(e[t]):this["_"+t]=e[t]);this._createConstraint()}onEnable(){this._createConstraint()}onDisable(){this._destroyConstraint()}_onSetEnabled(e,t,n){}_onBeforeRemove(){this.fire("remove")}}const zE={Damping:"setDamping",Equilibrium:"setEquilibriumPoint",Spring:"enableSpring",Stiffness:"setStiffness"};["linear","angular"].forEach((e=>{["Damping","Equilibrium","Spring","Stiffness"].forEach((t=>{["X","Y","Z"].forEach((n=>{const a=e+t+n,i="_"+a;let s="linear"===e?0:3;"Y"===n&&(s+=1),"Z"===n&&(s+=2),Object.defineProperty(UE.prototype,a,{get:function(){return this[i]},set:function(e){this[i]!==e&&(this[i]=e,this._constraint[zE[t]](s,e))}})}))}))}));class GE{constructor(){this.enabled=!0}}const HE=["enabled"];class WE extends AC{constructor(e){super(e),this.id="joint",this.app=e,this.ComponentType=UE,this.DataType=GE,this.schema=HE}initializeComponentData(e,t,n){e.initFromData(t)}}Ux._buildAccessors(UE.prototype,HE);class jE extends Ux{constructor(e,t){super(e,t),this._minWidth=0,this._minHeight=0,this._maxWidth=null,this._maxHeight=null,this._fitWidthProportion=0,this._fitHeightProportion=0,this._excludeFromLayout=!1}set minWidth(e){e!==this._minWidth&&(this._minWidth=e,this.fire("resize"))}get minWidth(){return this._minWidth}set minHeight(e){e!==this._minHeight&&(this._minHeight=e,this.fire("resize"))}get minHeight(){return this._minHeight}set maxWidth(e){e!==this._maxWidth&&(this._maxWidth=e,this.fire("resize"))}get maxWidth(){return this._maxWidth}set maxHeight(e){e!==this._maxHeight&&(this._maxHeight=e,this.fire("resize"))}get maxHeight(){return this._maxHeight}set fitWidthProportion(e){e!==this._fitWidthProportion&&(this._fitWidthProportion=e,this.fire("resize"))}get fitWidthProportion(){return this._fitWidthProportion}set fitHeightProportion(e){e!==this._fitHeightProportion&&(this._fitHeightProportion=e,this.fire("resize"))}get fitHeightProportion(){return this._fitHeightProportion}set excludeFromLayout(e){e!==this._excludeFromLayout&&(this._excludeFromLayout=e,this.fire("resize"))}get excludeFromLayout(){return this._excludeFromLayout}}class XE{constructor(){this.enabled=!0}}const YE=["enabled"];class qE extends AC{constructor(e){super(e),this.id="layoutchild",this.ComponentType=jE,this.DataType=XE,this.schema=YE}initializeComponentData(e,t,n){void 0!==t.enabled&&(e.enabled=t.enabled),void 0!==t.minWidth&&(e.minWidth=t.minWidth),void 0!==t.minHeight&&(e.minHeight=t.minHeight),void 0!==t.maxWidth&&(e.maxWidth=t.maxWidth),void 0!==t.maxHeight&&(e.maxHeight=t.maxHeight),void 0!==t.fitWidthProportion&&(e.fitWidthProportion=t.fitWidthProportion),void 0!==t.fitHeightProportion&&(e.fitHeightProportion=t.fitHeightProportion),void 0!==t.excludeFromLayout&&(e.excludeFromLayout=t.excludeFromLayout),super.initializeComponentData(e,t,n)}cloneComponent(e,t){const n=e.layoutchild;return this.addComponent(t,{enabled:n.enabled,minWidth:n.minWidth,minHeight:n.minHeight,maxWidth:n.maxWidth,maxHeight:n.maxHeight,fitWidthProportion:n.fitWidthProportion,fitHeightProportion:n.fitHeightProportion,excludeFromLayout:n.excludeFromLayout})}}Ux._buildAccessors(jE.prototype,YE);const KE={0:{axis:"x",size:"width",calculatedSize:"calculatedWidth",minSize:"minWidth",maxSize:"maxWidth",fitting:"widthFitting",fittingProportion:"fitWidthProportion"},1:{axis:"y",size:"height",calculatedSize:"calculatedHeight",minSize:"minHeight",maxSize:"maxHeight",fitting:"heightFitting",fittingProportion:"fitHeightProportion"}},ZE={0:1,1:0},$E={minWidth:0,minHeight:0,maxWidth:Number.POSITIVE_INFINITY,maxHeight:Number.POSITIVE_INFINITY,width:null,height:null,fitWidthProportion:0,fitHeightProportion:0},QE="NONE",JE="APPLY_STRETCHING",eS="APPLY_SHRINKING",tS=new Du;function nS(e){let t;const n=KE[e],a=KE[ZE[e]];function i(e,t){return-t[n.size]*e.pivot[n.axis]}function s(e,t){return-t[a.size]*e.pivot[a.axis]}function r(e,t){return t[n.size]*(1-e.pivot[n.axis])}function o(e){const t=e.entity.layoutchild;return!t||!t.enabled||!t.excludeFromLayout}function l(e,t,n){switch(e){case 0:return QE;case 1:return t<n?JE:QE;case 2:return t>=n?eS:QE;case 3:return t<n?JE:eS;default:throw new Error(`Unrecognized fitting mode: ${e}`)}}function c(e,n){return g(e,n.size)+(e.length-1)*t.spacing[n.axis]}function h(e,t,n){const a=b(e,n.maxSize),i=y(e,n.fittingProportion),s=w(i,a);let r=tS[n.axis]-t;for(let t=0;t<e.length;++t){const o=a[t],l=p(o,r,i,s),c=e[o][n.size]+l,h=e[o][n.maxSize],d=Math.min(c,h);e[o][n.size]=d;r-=l-Math.max(c-d,0)}}function d(e,t,n){const a=b(e,n.minSize,!0),i=function(e){if(1===e.length)return[1];const t=[],n=e.length;for(let a=0;a<n;++a)t.push((1-e[a])/(n-1));return t}(y(e,n.fittingProportion)),s=w(i,a);let r=t-tS[n.axis];for(let t=0;t<e.length;++t){const o=a[t],l=p(o,r,i,s),c=e[o][n.size]-l,h=e[o][n.minSize],d=Math.max(c,h);e[o][n.size]=d;r-=l-Math.max(d-c,0)}}function p(e,t,n,a){const i=n[e],s=a[e];return Math.abs(i)<1e-5&&Math.abs(s)<1e-5?t:t*i/s}function u(e){const t=[];for(let n=0;n<e.length;++n){const a=e[n],i=Math.max(m(a,"minWidth"),0),s=Math.max(m(a,"minHeight"),0),r=Math.max(m(a,"maxWidth"),i),o=Math.max(m(a,"maxHeight"),s),l=f(m(a,"width"),i,r),c=f(m(a,"height"),s,o),h=m(a,"fitWidthProportion"),d=m(a,"fitHeightProportion");t.push({minWidth:i,minHeight:s,maxWidth:r,maxHeight:o,width:l,height:c,fitWidthProportion:h,fitHeightProportion:d})}return t}function m(e,t){const n=e.entity.layoutchild;return n&&n.enabled&&void 0!==n[t]&&null!==n[t]?n[t]:void 0!==e[t]?e[t]:$E[t]}function f(e,t,n){return Math.min(Math.max(e,t),n)}function g(e,t){return e.reduce((function(e,n){return e+n[t]}),0)}function y(e,t){const n=g(e,t),a=[],i=e.length;if(0===n)for(let e=0;e<i;++e)a.push(1/i);else for(let s=0;s<i;++s)a.push(e[s][t]/n);return a}function b(e,t,n){return e.forEach(v),e.slice().sort((function(e,a){return n?a[t]-e[t]:e[t]-a[t]})).map(_)}function v(e,t){e.index=t}function _(e){return e.index}function w(e,t){const n=[];n[t[e.length-1]]=e[t[e.length-1]];for(let a=e.length-2;a>=0;--a)n[t[a]]=n[t[a+1]]+e[t[a]];return n}return function(e,p){e=e.filter(o),t=p,tS.x=t.containerSize.x-t.padding.x-t.padding.z,tS.y=t.containerSize.y-t.padding.y-t.padding.w,function(e){for(let t=0;t<e.length;++t){const n=e[t],a=n.anchor;0===a.x&&0===a.y&&0===a.z&&0===a.w||(n.anchor=Ou.ZERO)}}(e);const m=function(e){const n=0===t.orientation&&t.reverseX||1===t.orientation&&t.reverseY,a=0===t.orientation&&t.reverseY||1===t.orientation&&t.reverseX;if(n)for(let t=0;t<e.length;++t)n&&e[t].reverse();a&&e.reverse();return e}(function(e){if(!t.wrap)return[e];const a=[[]],i=u(e);let s=0;const r=2===t[n.fitting];for(let o=0;o<e.length;++o){a[a.length-1].length>0&&(s+=t.spacing[n.axis]);const l=i[o][n.size];s+=l,!r&&s>tS[n.axis]&&0!==a[a.length-1].length&&(s=l,a.push([])),a[a.length-1].push(e[o]),r&&s>tS[n.axis]&&o!==e.length-1&&(s=0,a.push([]))}return a}(e)),f=function(e,n){const i=[],s=[];for(let t=0;t<e.length;++t){const r=e[t];r.largestElement=null,r.largestSize={width:Number.NEGATIVE_INFINITY,height:Number.NEGATIVE_INFINITY};for(let e=0;e<r.length;++e){const i=n[t][e];i[a.size]>r.largestSize[a.size]&&(r.largestElement=r[e],r.largestSize=i)}i.push(r.largestElement),s.push(r.largestSize)}const r=c(s,a),o=l(t[a.fitting],r,tS[a.axis]);o===JE?h(s,r,a):o===eS&&d(s,r,a);for(let i=0;i<e.length;++i){const s=e[i];for(let r=0;r<s.length;++r){const o=n[i][r],c=o[a.size],h=1===e.length?tS[a.axis]:s.largestSize[a.size],d=l(t[a.fitting],c,h);d===JE?o[a.size]=Math.min(h,o[a.maxSize]):d===eS&&(o[a.size]=Math.max(h,o[a.minSize]))}}return n}(m,function(e){const a=[];for(let i=0;i<e.length;++i){const s=u(e[i]),r=c(s,n),o=l(t[n.fitting],r,tS[n.axis]);o===JE?h(s,r,n):o===eS&&d(s,r,n),a.push(s)}return a}(m)),g=function(e,o){const l={};l[n.axis]=0,l[a.axis]=0,e[n.size]=Number.NEGATIVE_INFINITY;const c=[];for(let h=0;h<e.length;++h){const d=e[h];if(0===d.length){c.push([]);continue}const p=[],u=o[h];for(let e=0;e<d.length;++e){const o=d[e],c=u[e];l[a.axis]-=s(o,c),l[n.axis]-=i(o,c),p[e]={},p[e][n.axis]=l[n.axis],p[e][a.axis]=l[a.axis],l[a.axis]+=s(o,c),l[n.axis]+=r(o,c)+t.spacing[n.axis]}d[n.size]=l[n.axis]-t.spacing[n.axis],d[a.size]=d.largestSize[a.size],e[n.size]=Math.max(e[n.size],d[n.size]),l[n.axis]=0,l[a.axis]+=d[a.size]+t.spacing[a.axis],c.push(p)}return e[a.size]=l[a.axis]-t.spacing[a.axis],c}(m,f);return function(e,i,s){const r=t.alignment[n.axis],o=t.alignment[a.axis],l=t.padding[n.axis],c=t.padding[a.axis];for(let h=0;h<e.length;++h){const d=e[h],p=i[h],u=s[h],m=(tS[n.axis]-d[n.size])*r+l,f=(tS[a.axis]-e[a.size])*o+c;for(let e=0;e<d.length;++e){const i=(d[a.size]-p[e][a.size])*t.alignment[a.axis];u[e][n.axis]+=m,u[e][a.axis]+=f+i}}}(m,f,g),function(e,i,s){for(let r=0;r<e.length;++r){const o=e[r],l=i[r],c=s[r];for(let e=0;e<o.length;++e){const i=o[e];i[n.calculatedSize]=l[e][n.size],i[a.calculatedSize]=l[e][a.size],0===t.orientation?i.entity.setLocalPosition(c[e][n.axis],c[e][a.axis],i.entity.getLocalPosition().z):i.entity.setLocalPosition(c[e][a.axis],c[e][n.axis],i.entity.getLocalPosition().z)}}}(m,f,g),function(e){const n=e.width,a=e.height,i=(tS.x-n)*t.alignment.x+t.padding.x,s=(tS.y-a)*t.alignment.y+t.padding.y;return{bounds:new Ou(i,s,n,a)}}(m)}}const aS={};aS[0]=nS(0),aS[1]=nS(1);class iS{calculateLayout(e,t){const n=aS[t.orientation];if(n)return n(e,t);throw new Error("Unrecognized orientation value: "+t.orientation)}}function sS(e){return e.element}function rS(e){return e.enabled&&e.element&&e.element.enabled}class oS extends Ux{constructor(e,t){super(e,t),this._orientation=0,this._reverseX=!1,this._reverseY=!0,this._alignment=new Du(0,1),this._padding=new Ou,this._spacing=new Du,this._widthFitting=0,this._heightFitting=0,this._wrap=!1,this._layoutCalculator=new iS,this._listenForReflowEvents(this.entity,"on"),this.entity.children.forEach((e=>{this._listenForReflowEvents(e,"on")})),this.entity.on("childinsert",this._onChildInsert,this),this.entity.on("childremove",this._onChildRemove,this),e.app.systems.element.on("add",this._onElementOrLayoutComponentAdd,this),e.app.systems.element.on("beforeremove",this._onElementOrLayoutComponentRemove,this),e.app.systems.layoutchild.on("add",this._onElementOrLayoutComponentAdd,this),e.app.systems.layoutchild.on("beforeremove",this._onElementOrLayoutComponentRemove,this)}set orientation(e){e!==this._orientation&&(this._orientation=e,this._scheduleReflow())}get orientation(){return this._orientation}set reverseX(e){e!==this._reverseX&&(this._reverseX=e,this._scheduleReflow())}get reverseX(){return this._reverseX}set reverseY(e){e!==this._reverseY&&(this._reverseY=e,this._scheduleReflow())}get reverseY(){return this._reverseY}set alignment(e){e.equals(this._alignment)||(this._alignment.copy(e),this._scheduleReflow())}get alignment(){return this._alignment}set padding(e){e.equals(this._padding)||(this._padding.copy(e),this._scheduleReflow())}get padding(){return this._padding}set spacing(e){e.equals(this._spacing)||(this._spacing.copy(e),this._scheduleReflow())}get spacing(){return this._spacing}set widthFitting(e){e!==this._widthFitting&&(this._widthFitting=e,this._scheduleReflow())}get widthFitting(){return this._widthFitting}set heightFitting(e){e!==this._heightFitting&&(this._heightFitting=e,this._scheduleReflow())}get heightFitting(){return this._heightFitting}set wrap(e){e!==this._wrap&&(this._wrap=e,this._scheduleReflow())}get wrap(){return this._wrap}_isSelfOrChild(e){return e===this.entity||-1!==this.entity.children.indexOf(e)}_listenForReflowEvents(e,t){e.element&&(e.element[t]("enableelement",this._scheduleReflow,this),e.element[t]("disableelement",this._scheduleReflow,this),e.element[t]("resize",this._scheduleReflow,this),e.element[t]("set:pivot",this._scheduleReflow,this)),e.layoutchild&&(e.layoutchild[t]("set_enabled",this._scheduleReflow,this),e.layoutchild[t]("resize",this._scheduleReflow,this))}_onElementOrLayoutComponentAdd(e){this._isSelfOrChild(e)&&(this._listenForReflowEvents(e,"on"),this._scheduleReflow())}_onElementOrLayoutComponentRemove(e){this._isSelfOrChild(e)&&(this._listenForReflowEvents(e,"off"),this._scheduleReflow())}_onChildInsert(e){this._listenForReflowEvents(e,"on"),this._scheduleReflow()}_onChildRemove(e){this._listenForReflowEvents(e,"off"),this._scheduleReflow()}_scheduleReflow(){this.enabled&&this.entity&&this.entity.enabled&&!this._isPerformingReflow&&this.system.scheduleReflow(this)}reflow(){const e=sS(this.entity),t=this.entity.children.filter(rS).map(sS);if(!e||0===t.length)return;const n=Math.max(e.calculatedWidth,0),a=Math.max(e.calculatedHeight,0),i={orientation:this._orientation,reverseX:this._reverseX,reverseY:this._reverseY,alignment:this._alignment,padding:this._padding,spacing:this._spacing,widthFitting:this._widthFitting,heightFitting:this._heightFitting,wrap:this._wrap,containerSize:new Du(n,a)};this._isPerformingReflow=!0;const s=this._layoutCalculator.calculateLayout(t,i);this._isPerformingReflow=!1,this.fire("reflow",s)}onEnable(){this._scheduleReflow()}onRemove(){this.entity.off("childinsert",this._onChildInsert,this),this.entity.off("childremove",this._onChildRemove,this),this._listenForReflowEvents(this.entity,"off"),this.entity.children.forEach((e=>{this._listenForReflowEvents(e,"off")})),this.system.app.systems.element.off("add",this._onElementOrLayoutComponentAdd,this),this.system.app.systems.element.off("beforeremove",this._onElementOrLayoutComponentRemove,this),this.system.app.systems.layoutchild.off("add",this._onElementOrLayoutComponentAdd,this),this.system.app.systems.layoutchild.off("beforeremove",this._onElementOrLayoutComponentRemove,this)}}class lS{constructor(){this.enabled=!0}}const cS=["enabled"];class hS extends AC{constructor(e){super(e),this.id="layoutgroup",this.ComponentType=oS,this.DataType=lS,this.schema=cS,this._reflowQueue=[],this.on("beforeremove",this._onRemoveComponent,this),this.app.systems.on("postUpdate",this._onPostUpdate,this)}initializeComponentData(e,t,n){void 0!==t.enabled&&(e.enabled=t.enabled),void 0!==t.orientation&&(e.orientation=t.orientation),void 0!==t.reverseX&&(e.reverseX=t.reverseX),void 0!==t.reverseY&&(e.reverseY=t.reverseY),void 0!==t.alignment&&(e.alignment=Array.isArray(t.alignment)?new Du(t.alignment):t.alignment),void 0!==t.padding&&(e.padding=Array.isArray(t.padding)?new Ou(t.padding):t.padding),void 0!==t.spacing&&(e.spacing=Array.isArray(t.spacing)?new Du(t.spacing):t.spacing),void 0!==t.widthFitting&&(e.widthFitting=t.widthFitting),void 0!==t.heightFitting&&(e.heightFitting=t.heightFitting),void 0!==t.wrap&&(e.wrap=t.wrap),super.initializeComponentData(e,t,n)}cloneComponent(e,t){const n=e.layoutgroup;return this.addComponent(t,{enabled:n.enabled,orientation:n.orientation,reverseX:n.reverseX,reverseY:n.reverseY,alignment:n.alignment,padding:n.padding,spacing:n.spacing,widthFitting:n.widthFitting,heightFitting:n.heightFitting,wrap:n.wrap})}scheduleReflow(e){-1===this._reflowQueue.indexOf(e)&&this._reflowQueue.push(e)}_onPostUpdate(){this._processReflowQueue()}_processReflowQueue(){if(0===this._reflowQueue.length)return;let e=0;for(;this._reflowQueue.length>0;){const t=this._reflowQueue.slice();this._reflowQueue.length=0,t.sort((function(e,t){return e.entity.graphDepth-t.entity.graphDepth}));for(let e=0;e<t.length;++e)t[e].reflow();if(++e>=100){console.warn("Max reflow iterations limit reached, bailing.");break}}}_onRemoveComponent(e,t){t.onRemove()}destroy(){super.destroy(),this.app.systems.off("postUpdate",this._onPostUpdate,this)}}Ux._buildAccessors(oS.prototype,cS);const dS=[],pS=[];class uS extends Ux{constructor(e,t){super(e,t),this._cookieAsset=null,this._cookieAssetId=null,this._cookieAssetAdd=!1,this._cookieMatrix=null}addLightToLayers(){for(let e=0;e<this.layers.length;e++){const t=this.system.app.scene.layers.getLayerById(this.layers[e]);t&&t.addLight(this)}}removeLightFromLayers(){for(let e=0;e<this.layers.length;e++){const t=this.system.app.scene.layers.getLayerById(this.layers[e]);t&&t.removeLight(this)}}onLayersChanged(e,t){this.enabled&&this.entity.enabled&&this.addLightToLayers(),e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this)}onLayerAdded(e){this.layers.indexOf(e.id)>=0&&this.enabled&&this.entity.enabled&&e.addLight(this)}onLayerRemoved(e){this.layers.indexOf(e.id)>=0&&e.removeLight(this)}refreshProperties(){for(let e=0;e<dS.length;e++){const t=dS[e];this[t]=this[t]}this.enabled&&this.entity.enabled&&this.onEnable()}updateShadow(){this.light.updateShadow()}onCookieAssetSet(){let e=!1;"cubemap"!==this._cookieAsset.type||this._cookieAsset.loadFaces||(this._cookieAsset.loadFaces=!0,e=!0),this._cookieAsset.resource&&!e||this.system.app.assets.load(this._cookieAsset),this._cookieAsset.resource&&this.onCookieAssetLoad()}onCookieAssetAdd(e){this._cookieAssetId===e.id&&(this._cookieAsset=e,this.light.enabled&&this.onCookieAssetSet(),this._cookieAsset.on("load",this.onCookieAssetLoad,this),this._cookieAsset.on("remove",this.onCookieAssetRemove,this))}onCookieAssetLoad(){this._cookieAsset&&this._cookieAsset.resource&&(this.cookie=this._cookieAsset.resource)}onCookieAssetRemove(){this._cookieAssetId&&(this._cookieAssetAdd&&(this.system.app.assets.off("add:"+this._cookieAssetId,this.onCookieAssetAdd,this),this._cookieAssetAdd=!1),this._cookieAsset&&(this._cookieAsset.off("load",this.onCookieAssetLoad,this),this._cookieAsset.off("remove",this.onCookieAssetRemove,this),this._cookieAsset=null),this.cookie=null)}onEnable(){this.light.enabled=!0,this.system.app.scene.on("set:layers",this.onLayersChanged,this),this.system.app.scene.layers&&(this.system.app.scene.layers.on("add",this.onLayerAdded,this),this.system.app.scene.layers.on("remove",this.onLayerRemoved,this)),this.enabled&&this.entity.enabled&&this.addLightToLayers(),this._cookieAsset&&!this.cookie&&this.onCookieAssetSet()}onDisable(){this.light.enabled=!1,this.system.app.scene.off("set:layers",this.onLayersChanged,this),this.system.app.scene.layers&&(this.system.app.scene.layers.off("add",this.onLayerAdded,this),this.system.app.scene.layers.off("remove",this.onLayerRemoved,this)),this.removeLightFromLayers()}onRemove(){this.onDisable(),this.light.destroy(),this.cookieAsset=null}}function mS(e,t,n,a){const i=uS.prototype;dS.push(e),pS.push(t),Object.defineProperty(i,e,{get:function(){return this.data[e]},set:function(t){const i=this.data,s=i[e];(a||s!==t)&&(i[e]=t,n&&n.call(this,t,s))},configurable:!0})}mS("enabled",!0,(function(e,t){this.onSetEnabled(null,t,e)})),mS("light",null),mS("type","directional",(function(e,t){this.system.changeType(this,t,e),this.refreshProperties()})),mS("color",new Mu(1,1,1),(function(e,t){this.light.setColor(e)}),!0),mS("intensity",1,(function(e,t){this.light.intensity=e})),mS("shape",0,(function(e,t){this.light.shape=e})),mS("castShadows",!1,(function(e,t){this.light.castShadows=e})),mS("shadowDistance",40,(function(e,t){this.light.shadowDistance=e})),mS("shadowResolution",1024,(function(e,t){this.light.shadowResolution=e})),mS("shadowBias",.05,(function(e,t){this.light.shadowBias=-.01*Eu.clamp(e,0,1)})),mS("numCascades",1,(function(e,t){this.light.numCascades=Eu.clamp(Math.floor(e),1,4)})),mS("bakeNumSamples",1,(function(e,t){this.light.bakeNumSamples=Eu.clamp(Math.floor(e),1,255)})),mS("bakeArea",0,(function(e,t){this.light.bakeArea=Eu.clamp(e,0,180)})),mS("cascadeDistribution",.5,(function(e,t){this.light.cascadeDistribution=Eu.clamp(e,0,1)})),mS("normalOffsetBias",0,(function(e,t){this.light.normalOffsetBias=Eu.clamp(e,0,1)})),mS("range",10,(function(e,t){this.light.attenuationEnd=e})),mS("innerConeAngle",40,(function(e,t){this.light.innerConeAngle=e})),mS("outerConeAngle",45,(function(e,t){this.light.outerConeAngle=e})),mS("falloffMode",0,(function(e,t){this.light.falloffMode=e})),mS("shadowType",0,(function(e,t){this.light.shadowType=e})),mS("vsmBlurSize",11,(function(e,t){this.light.vsmBlurSize=e})),mS("vsmBlurMode",1,(function(e,t){this.light.vsmBlurMode=e})),mS("vsmBias",.0025,(function(e,t){this.light.vsmBias=Eu.clamp(e,0,1)})),mS("cookieAsset",null,(function(e,t){if(!this._cookieAssetId||!(e instanceof f_&&e.id===this._cookieAssetId||e===this._cookieAssetId))if(this.onCookieAssetRemove(),this._cookieAssetId=null,e instanceof f_)this.data.cookieAsset=e.id,this._cookieAssetId=e.id,this.onCookieAssetAdd(e);else if("number"==typeof e){this._cookieAssetId=e;const t=this.system.app.assets.get(e);t?this.onCookieAssetAdd(t):(this._cookieAssetAdd=!0,this.system.app.assets.on("add:"+this._cookieAssetId,this.onCookieAssetAdd,this))}})),mS("cookie",null,(function(e,t){this.light.cookie=e})),mS("cookieIntensity",1,(function(e,t){this.light.cookieIntensity=Eu.clamp(e,0,1)})),mS("cookieFalloff",!0,(function(e,t){this.light.cookieFalloff=e})),mS("cookieChannel","rgb",(function(e,t){this.light.cookieChannel=e})),mS("cookieAngle",0,(function(e,t){if(0!==e||null!==this.cookieScale){this._cookieMatrix||(this._cookieMatrix=new Ou);let t=1,n=1;this.cookieScale&&(t=this.cookieScale.x,n=this.cookieScale.y);const a=Math.cos(e*Eu.DEG_TO_RAD),i=Math.sin(e*Eu.DEG_TO_RAD);this._cookieMatrix.set(a/t,-i/t,i/n,a/n),this.light.cookieTransform=this._cookieMatrix}else this.light.cookieTransform=null})),mS("cookieScale",null,(function(e,t){if(null!==e||0!==this.cookieAngle){this._cookieMatrix||(this._cookieMatrix=new Ou);const t=e.x,n=e.y,a=Math.cos(this.cookieAngle*Eu.DEG_TO_RAD),i=Math.sin(this.cookieAngle*Eu.DEG_TO_RAD);this._cookieMatrix.set(a/t,-i/t,i/n,a/n),this.light.cookieTransform=this._cookieMatrix}else this.light.cookieTransform=null}),!0),mS("cookieOffset",null,(function(e,t){this.light.cookieOffset=e}),!0),mS("shadowUpdateMode",2,(function(e,t){this.light.shadowUpdateMode=e}),!0),mS("mask",1,(function(e,t){this.light.mask=e})),mS("affectDynamic",!0,(function(e,t){e?this.light.mask|=1:this.light.mask&=-2,this.light.layersDirty()})),mS("affectLightmapped",!1,(function(e,t){e?(this.light.mask|=2,this.bake&&(this.light.mask&=-5)):(this.light.mask&=-3,this.bake&&(this.light.mask|=4))})),mS("bake",!1,(function(e,t){e?(this.light.mask|=4,this.affectLightmapped&&(this.light.mask&=-3)):(this.light.mask&=-5,this.affectLightmapped&&(this.light.mask|=2)),this.light.layersDirty()})),mS("bakeDir",!0,(function(e,t){this.light.bakeDir=e})),mS("isStatic",!1,(function(e,t){this.light.isStatic=e})),mS("layers",[0],(function(e,t){for(let e=0;e<t.length;e++){const n=this.system.app.scene.layers.getLayerById(t[e]);n&&n.removeLight(this)}for(let t=0;t<e.length;t++){const n=this.system.app.scene.layers.getLayerById(e[t]);n&&this.enabled&&this.entity.enabled&&n.addLight(this)}}));class fS{constructor(){const e=dS,t=pS;for(let n=0;n<e.length;n++){const a=t[n];a&&a.clone?this[e[n]]=a.clone():this[e[n]]=a}}}const gS={directional:0,omni:1,point:1,spot:2};class yS extends AC{constructor(e){super(e),this.id="light",this.ComponentType=uS,this.DataType=fS,this.on("beforeremove",this._onRemoveComponent,this)}initializeComponentData(e,t){const n=dS,a={};for(let e=0,i=n.length;e<i;e++){const i=n[e];a[i]=t[i]}a.type||(a.type=e.data.type),e.data.type=a.type,a.layers&&Array.isArray(a.layers)&&(a.layers=a.layers.slice(0)),a.color&&Array.isArray(a.color)&&(a.color=new Mu(a.color[0],a.color[1],a.color[2])),a.cookieOffset&&a.cookieOffset instanceof Array&&(a.cookieOffset=new Du(a.cookieOffset[0],a.cookieOffset[1])),a.cookieScale&&a.cookieScale instanceof Array&&(a.cookieScale=new Du(a.cookieScale[0],a.cookieScale[1])),a.enable&&(console.warn("WARNING: enable: Property is deprecated. Set enabled property instead."),a.enabled=a.enable),a.shape||(a.shape=0);const i=new Cv(this.app.graphicsDevice);i.type=gS[a.type],i._node=e.entity,i._scene=this.app.scene,e.data.light=i,super.initializeComponentData(e,a,n)}_onRemoveComponent(e,t){t.onRemove()}cloneComponent(e,t){const n=e.light,a=[];let i;const s=dS;for(let e=0;e<s.length;e++)i=s[e],"light"!==i&&(n[i]&&n[i].clone?a[i]=n[i].clone():a[i]=n[i]);return this.addComponent(t,a)}changeType(e,t,n){t!==n&&(e.light.type=gS[n])}}class bS extends Ux{constructor(e,t){super(e,t),this._type="asset",this._asset=null,this._model=null,this._mapping={},this._castShadows=!0,this._receiveShadows=!0,this._materialAsset=null,this._material=void 0,this._castShadowsLightmap=!0,this._lightmapped=!1,this._lightmapSizeMultiplier=1,this._isStatic=!1,this._layers=[0],this._batchGroupId=-1,this._customAabb=null,this._area=null,this._materialEvents=null,this._clonedModel=!1,this._material=e.defaultMaterial,t.on("remove",this.onRemoveChild,this),t.on("removehierarchy",this.onRemoveChild,this),t.on("insert",this.onInsertChild,this),t.on("inserthierarchy",this.onInsertChild,this)}set meshInstances(e){this._model&&(this._model.meshInstances=e)}get meshInstances(){return this._model?this._model.meshInstances:null}set customAabb(e){if(this._customAabb=e,this._model){const e=this._model.meshInstances;if(e)for(let t=0;t<e.length;t++)e[t].setCustomAabb(this._customAabb)}}get customAabb(){return this._customAabb}set type(e){if(this._type!==e)if(this._area=null,this._type=e,"asset"===e)null!==this._asset?this._bindModelAsset(this._asset):this.model=null;else{const t=uy(this.system.app.graphicsDevice,e);this._area=t.area;const n=t.mesh,a=new hf,i=new Dv;i.graph=a,i.meshInstances=[new Ay(n,this._material,a)],this.model=i,this._asset=null}}get type(){return this._type}set asset(e){const t=this.system.app.assets;let n=e;if(e instanceof f_&&(n=e.id),this._asset!==n){if(this._asset){t.off("add:"+this._asset,this._onModelAssetAdded,this);const e=t.get(this._asset);e&&this._unbindModelAsset(e)}if(this._asset=n,this._asset){const e=t.get(this._asset);e?this._bindModelAsset(e):(this.model=null,t.on("add:"+this._asset,this._onModelAssetAdded,this))}else this.model=null}}get asset(){return this._asset}set model(e){if(this._model!==e&&(!e||!e._immutable)&&(this._model&&(this._model._immutable=!1,this.removeModelFromLayers(),this.entity.removeChild(this._model.getGraph()),delete this._model._entity,this._clonedModel&&(this._model.destroy(),this._clonedModel=!1)),this._model=e,this._model)){this._model._immutable=!0;const e=this._model.meshInstances;for(let t=0;t<e.length;t++)e[t].castShadow=this._castShadows,e[t].receiveShadow=this._receiveShadows,e[t].isStatic=this._isStatic,e[t].setCustomAabb(this._customAabb);this.lightmapped=this._lightmapped,this.entity.addChild(this._model.graph),this.enabled&&this.entity.enabled&&this.addModelToLayers(),this._model._entity=this.entity,this.entity.animation&&this.entity.animation.setModel(this._model),this.entity.anim&&this.entity.anim.rebind(),"asset"===this.type?this.mapping=this._mapping:this._unsetMaterialEvents()}}get model(){return this._model}set lightmapped(e){if(e!==this._lightmapped&&(this._lightmapped=e,this._model)){const t=this._model.meshInstances;for(let n=0;n<t.length;n++)t[n].setLightmapped(e)}}get lightmapped(){return this._lightmapped}set castShadows(e){if(this._castShadows===e)return;const t=this._model;if(t){const n=this.layers,a=this.system.app.scene;if(this._castShadows&&!e)for(let e=0;e<n.length;e++){const n=this.system.app.scene.layers.getLayerById(this.layers[e]);n&&n.removeShadowCasters(t.meshInstances)}const i=t.meshInstances;for(let t=0;t<i.length;t++)i[t].castShadow=e;if(!this._castShadows&&e)for(let e=0;e<n.length;e++){const i=a.layers.getLayerById(n[e]);i&&i.addShadowCasters(t.meshInstances)}}this._castShadows=e}get castShadows(){return this._castShadows}set receiveShadows(e){if(this._receiveShadows!==e&&(this._receiveShadows=e,this._model)){const t=this._model.meshInstances;for(let n=0,a=t.length;n<a;n++)t[n].receiveShadow=e}}get receiveShadows(){return this._receiveShadows}set castShadowsLightmap(e){this._castShadowsLightmap=e}get castShadowsLightmap(){return this._castShadowsLightmap}set lightmapSizeMultiplier(e){this._lightmapSizeMultiplier=e}get lightmapSizeMultiplier(){return this._lightmapSizeMultiplier}set isStatic(e){if(this._isStatic!==e&&(this._isStatic=e,this._model)){const t=this._model.meshInstances;for(let n=0;n<t.length;n++){t[n].isStatic=e}}}get isStatic(){return this._isStatic}set layers(e){const t=this.system.app.scene.layers;if(this.meshInstances)for(let e=0;e<this._layers.length;e++){const n=t.getLayerById(this._layers[e]);n&&n.removeMeshInstances(this.meshInstances)}this._layers.length=0;for(let t=0;t<e.length;t++)this._layers[t]=e[t];if(this.enabled&&this.entity.enabled&&this.meshInstances)for(let e=0;e<this._layers.length;e++){const n=t.getLayerById(this._layers[e]);n&&n.addMeshInstances(this.meshInstances)}}get layers(){return this._layers}set batchGroupId(e){if(this._batchGroupId===e)return;const t=this.system.app.batcher;this.entity.enabled&&this._batchGroupId>=0&&t.remove(gy.MODEL,this.batchGroupId,this.entity),this.entity.enabled&&e>=0&&t.insert(gy.MODEL,e,this.entity),e<0&&this._batchGroupId>=0&&this.enabled&&this.entity.enabled&&this.addModelToLayers(),this._batchGroupId=e}get batchGroupId(){return this._batchGroupId}set materialAsset(e){let t=e;e instanceof f_&&(t=e.id);const n=this.system.app.assets;if(t!==this._materialAsset){if(this._materialAsset){n.off("add:"+this._materialAsset,this._onMaterialAssetAdd,this);const e=n.get(this._materialAsset);e&&this._unbindMaterialAsset(e)}if(this._materialAsset=t,this._materialAsset){const e=n.get(this._materialAsset);e?this._bindMaterialAsset(e):(this._setMaterial(this.system.defaultMaterial),n.on("add:"+this._materialAsset,this._onMaterialAssetAdd,this))}else this._setMaterial(this.system.defaultMaterial)}}get materialAsset(){return this._materialAsset}set material(e){this._material!==e&&(this.materialAsset=null,this._setMaterial(e))}get material(){return this._material}set mapping(e){if("asset"!==this._type)return;if(this._unsetMaterialEvents(),e||(e={}),this._mapping=e,!this._model)return;const t=this._model.meshInstances,n=this.asset?this.system.app.assets.get(this.asset):null,a=n?n.data.mapping:null;let i=null;for(let n=0,s=t.length;n<s;n++)if(void 0!==e[n])e[n]?(i=this.system.app.assets.get(e[n]),this._loadAndSetMeshInstanceMaterial(i,t[n],n)):t[n].material=this.system.defaultMaterial;else if(a)if(a[n]&&(a[n].material||a[n].path)){if(void 0!==a[n].material)i=this.system.app.assets.get(a[n].material);else if(void 0!==a[n].path){const e=this._getMaterialAssetUrl(a[n].path);e&&(i=this.system.app.assets.getByUrl(e))}this._loadAndSetMeshInstanceMaterial(i,t[n],n)}else t[n].material=this.system.defaultMaterial}get mapping(){return this._mapping}addModelToLayers(){const e=this.system.app.scene.layers;for(let t=0;t<this._layers.length;t++){const n=e.getLayerById(this._layers[t]);n&&n.addMeshInstances(this.meshInstances)}}removeModelFromLayers(){const e=this.system.app.scene.layers;for(let t=0;t<this._layers.length;t++){const n=e.getLayerById(this._layers[t]);n&&n.removeMeshInstances(this.meshInstances)}}onRemoveChild(){this._model&&this.removeModelFromLayers()}onInsertChild(){this._model&&this.enabled&&this.entity.enabled&&this.addModelToLayers()}onRemove(){this.asset=null,this.model=null,this.materialAsset=null,this._unsetMaterialEvents(),this.entity.off("remove",this.onRemoveChild,this),this.entity.off("insert",this.onInsertChild,this)}onLayersChanged(e,t){this.addModelToLayers(),e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this)}onLayerAdded(e){this.layers.indexOf(e.id)<0||e.addMeshInstances(this.meshInstances)}onLayerRemoved(e){this.layers.indexOf(e.id)<0||e.removeMeshInstances(this.meshInstances)}_setMaterialEvent(e,t,n,a){const i=t+":"+n;this.system.app.assets.on(i,a,this),this._materialEvents||(this._materialEvents=[]),this._materialEvents[e]||(this._materialEvents[e]={}),this._materialEvents[e][i]={id:n,handler:a}}_unsetMaterialEvents(){const e=this.system.app.assets,t=this._materialEvents;if(t){for(let n=0,a=t.length;n<a;n++){if(!t[n])continue;const a=t[n];for(const t in a)e.off(t,a[t].handler,this)}this._materialEvents=null}}_getAssetByIdOrPath(e){let t=null;if(isNaN(parseInt(e,10))){if(this.asset){const n=this._getMaterialAssetUrl(e);n&&(t=this.system.app.assets.getByUrl(n))}}else t=this.system.app.assets.get(e);return t}_getMaterialAssetUrl(e){if(!this.asset)return null;const t=this.system.app.assets.get(this.asset);return t?t.getAbsoluteUrl(e):null}_loadAndSetMeshInstanceMaterial(e,t,n){const a=this.system.app.assets;e&&(e.resource?(t.material=e.resource,this._setMaterialEvent(n,"remove",e.id,(function(){t.material=this.system.defaultMaterial}))):(this._setMaterialEvent(n,"load",e.id,(function(a){t.material=a.resource,this._setMaterialEvent(n,"remove",e.id,(function(){t.material=this.system.defaultMaterial}))})),this.enabled&&this.entity.enabled&&a.load(e)))}onEnable(){const e=this.system.app,t=e.scene;t.on("set:layers",this.onLayersChanged,this),t.layers&&(t.layers.on("add",this.onLayerAdded,this),t.layers.on("remove",this.onLayerRemoved,this));const n="asset"===this._type;let a;if(this._model?this.addModelToLayers():n&&this._asset&&(a=e.assets.get(this._asset),a&&a.resource!==this._model&&this._bindModelAsset(a)),this._materialAsset&&(a=e.assets.get(this._materialAsset),a&&a.resource!==this._material&&this._bindMaterialAsset(a)),n&&this._mapping)for(const t in this._mapping)this._mapping[t]&&(a=this._getAssetByIdOrPath(this._mapping[t]),a&&!a.resource&&e.assets.load(a));this._batchGroupId>=0&&e.batcher.insert(gy.MODEL,this.batchGroupId,this.entity)}onDisable(){const e=this.system.app,t=e.scene;t.off("set:layers",this.onLayersChanged,this),t.layers&&(t.layers.off("add",this.onLayerAdded,this),t.layers.off("remove",this.onLayerRemoved,this)),this._batchGroupId>=0&&e.batcher.remove(gy.MODEL,this.batchGroupId,this.entity),this._model&&this.removeModelFromLayers()}hide(){if(this._model){const e=this._model.meshInstances;for(let t=0,n=e.length;t<n;t++)e[t].visible=!1}}show(){if(this._model){const e=this._model.meshInstances;for(let t=0,n=e.length;t<n;t++)e[t].visible=!0}}_bindMaterialAsset(e){if(e.on("load",this._onMaterialAssetLoad,this),e.on("unload",this._onMaterialAssetUnload,this),e.on("remove",this._onMaterialAssetRemove,this),e.on("change",this._onMaterialAssetChange,this),e.resource)this._onMaterialAssetLoad(e);else{if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(e)}}_unbindMaterialAsset(e){e.off("load",this._onMaterialAssetLoad,this),e.off("unload",this._onMaterialAssetUnload,this),e.off("remove",this._onMaterialAssetRemove,this),e.off("change",this._onMaterialAssetChange,this)}_onMaterialAssetAdd(e){this.system.app.assets.off("add:"+e.id,this._onMaterialAssetAdd,this),this._materialAsset===e.id&&this._bindMaterialAsset(e)}_onMaterialAssetLoad(e){this._setMaterial(e.resource)}_onMaterialAssetUnload(e){this._setMaterial(this.system.defaultMaterial)}_onMaterialAssetRemove(e){this._onMaterialAssetUnload(e)}_onMaterialAssetChange(e){}_bindModelAsset(e){if(this._unbindModelAsset(e),e.on("load",this._onModelAssetLoad,this),e.on("unload",this._onModelAssetUnload,this),e.on("change",this._onModelAssetChange,this),e.on("remove",this._onModelAssetRemove,this),e.resource)this._onModelAssetLoad(e);else{if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(e)}}_unbindModelAsset(e){e.off("load",this._onModelAssetLoad,this),e.off("unload",this._onModelAssetUnload,this),e.off("change",this._onModelAssetChange,this),e.off("remove",this._onModelAssetRemove,this)}_onModelAssetAdded(e){this.system.app.assets.off("add:"+e.id,this._onModelAssetAdded,this),e.id===this._asset&&this._bindModelAsset(e)}_onModelAssetLoad(e){this.model=e.resource.clone(),this._clonedModel=!0}_onModelAssetUnload(e){this.model=null}_onModelAssetChange(e,t,n,a){"data"===t&&(this.mapping=this._mapping)}_onModelAssetRemove(e){this.model=null}_setMaterial(e){if(this._material===e)return;this._material=e;const t=this._model;if(t&&"asset"!==this._type){const n=t.meshInstances;for(let t=0,a=n.length;t<a;t++)n[t].material=e}}}class vS{constructor(){this.enabled=!0}}const _S=["enabled"];class wS extends AC{constructor(e){super(e),this.id="model",this.ComponentType=bS,this.DataType=vS,this.schema=_S,this.defaultMaterial=$f(e.graphicsDevice),this.on("beforeremove",this.onRemove,this)}initializeComponentData(e,t,n){n=["material","materialAsset","asset","castShadows","receiveShadows","castShadowsLightmap","lightmapped","lightmapSizeMultiplier","type","mapping","layers","isStatic","batchGroupId"],null!==t.batchGroupId&&void 0!==t.batchGroupId||(t.batchGroupId=-1),t.layers&&t.layers.length&&(t.layers=t.layers.slice(0));for(let a=0;a<n.length;a++)t.hasOwnProperty(n[a])&&(e[n[a]]=t[n[a]]);t.aabbCenter&&t.aabbHalfExtents&&(e.customAabb=new qu(new Pu(t.aabbCenter),new Pu(t.aabbHalfExtents))),super.initializeComponentData(e,t,["enabled"])}cloneComponent(e,t){const n={type:e.model.type,asset:e.model.asset,castShadows:e.model.castShadows,receiveShadows:e.model.receiveShadows,castShadowsLightmap:e.model.castShadowsLightmap,lightmapped:e.model.lightmapped,lightmapSizeMultiplier:e.model.lightmapSizeMultiplier,isStatic:e.model.isStatic,enabled:e.model.enabled,layers:e.model.layers,batchGroupId:e.model.batchGroupId,mapping:Zp({},e.model.mapping)};let a=e.model.materialAsset;a instanceof f_||null==a||(a=this.app.assets.get(a));const i=e.model.material;i&&i!==this.defaultMaterial&&a&&i!==a.resource||(n.materialAsset=a);const s=this.addComponent(t,n);if(e.model.model&&"asset"===e.model.type&&!e.model.asset&&(s.model=e.model.model.clone(),s._clonedModel=!0),n.materialAsset||(s.material=i),e.model.model){const t=e.model.model.meshInstances,n=s.model.meshInstances;for(let e=0;e<t.length;e++)n[e].mask=t[e].mask,n[e].material=t[e].material,n[e].layer=t[e].layer,n[e].receiveShadow=t[e].receiveShadow}return e.model.customAabb&&(s.customAabb=e.model.customAabb.clone()),s}onRemove(e,t){t.onRemove()}}Ux._buildAccessors(bS.prototype,_S);class xS extends Ux{constructor(e,t){super(e,t),this._type="asset",this._castShadows=!0,this._receiveShadows=!0,this._castShadowsLightmap=!0,this._lightmapped=!1,this._lightmapSizeMultiplier=1,this._isStatic=!1,this._batchGroupId=-1,this._layers=[0],this._renderStyle=0,this._meshInstances=[],this._customAabb=null,this._area=null,this._assetReference=[],this._materialReferences=[],this._material=void 0,this._rootBone=void 0,this._rootBone=new bT(this,"rootBone"),this._rootBone.on("set:entity",this._onSetRootBone,this),this._assetReference=new Ew("asset",this,e.app.assets,{add:this._onRenderAssetAdded,load:this._onRenderAssetLoad,remove:this._onRenderAssetRemove,unload:this._onRenderAssetUnload},this),this._material=e.defaultMaterial,t.on("remove",this.onRemoveChild,this),t.on("removehierarchy",this.onRemoveChild,this),t.on("insert",this.onInsertChild,this),t.on("inserthierarchy",this.onInsertChild,this)}set renderStyle(e){this._renderStyle!==e&&(this._renderStyle=e,Ay._prepareRenderStyleForArray(this._meshInstances,e))}get renderStyle(){return this._renderStyle}set customAabb(e){this._customAabb=e;const t=this._meshInstances;if(t)for(let e=0;e<t.length;e++)t[e].setCustomAabb(this._customAabb)}get customAabb(){return this._customAabb}set type(e){if(this._type!==e&&(this._area=null,this._type=e,this.destroyMeshInstances(),"asset"!==e)){let t=this._material;t&&t!==this.system.defaultMaterial||(t=this._materialReferences[0]&&this._materialReferences[0].asset&&this._materialReferences[0].asset.resource);const n=uy(this.system.app.graphicsDevice,e);this._area=n.area,this.meshInstances=[new Ay(n.mesh,t||this.system.defaultMaterial,this.entity)]}}get type(){return this._type}set meshInstances(e){if(this.destroyMeshInstances(),this._meshInstances=e,this._meshInstances){const e=this._meshInstances;for(let t=0;t<e.length;t++)e[t].node||(e[t].node=this.entity),e[t].castShadow=this._castShadows,e[t].receiveShadow=this._receiveShadows,e[t].isStatic=this._isStatic,e[t].renderStyle=this._renderStyle,e[t].setLightmapped(this._lightmapped),e[t].setCustomAabb(this._customAabb);this.enabled&&this.entity.enabled&&this.addToLayers()}}get meshInstances(){return this._meshInstances}set lightmapped(e){if(e!==this._lightmapped){this._lightmapped=e;const t=this._meshInstances;if(t)for(let n=0;n<t.length;n++)t[n].setLightmapped(e)}}get lightmapped(){return this._lightmapped}set castShadows(e){if(this._castShadows!==e){const t=this._meshInstances;if(t){const n=this.layers,a=this.system.app.scene;if(this._castShadows&&!e)for(let e=0;e<n.length;e++){const n=a.layers.getLayerById(this.layers[e]);n&&n.removeShadowCasters(t)}for(let n=0;n<t.length;n++)t[n].castShadow=e;if(!this._castShadows&&e)for(let e=0;e<n.length;e++){const i=a.layers.getLayerById(n[e]);i&&i.addShadowCasters(t)}}this._castShadows=e}}get castShadows(){return this._castShadows}set receiveShadows(e){if(this._receiveShadows!==e){this._receiveShadows=e;const t=this._meshInstances;if(t)for(let n=0;n<t.length;n++)t[n].receiveShadow=e}}get receiveShadows(){return this._receiveShadows}set castShadowsLightmap(e){this._castShadowsLightmap=e}get castShadowsLightmap(){return this._castShadowsLightmap}set lightmapSizeMultiplier(e){this._lightmapSizeMultiplier=e}get lightmapSizeMultiplier(){return this._lightmapSizeMultiplier}set isStatic(e){if(this._isStatic!==e){this._isStatic=e;const t=this._meshInstances;if(t)for(let n=0;n<t.length;n++)t[n].isStatic=e}}get isStatic(){return this._isStatic}set layers(e){const t=this.system.app.scene.layers;let n;if(this._meshInstances)for(let e=0;e<this._layers.length;e++)n=t.getLayerById(this._layers[e]),n&&n.removeMeshInstances(this._meshInstances);this._layers.length=0;for(let t=0;t<e.length;t++)this._layers[t]=e[t];if(this.enabled&&this.entity.enabled&&this._meshInstances)for(let e=0;e<this._layers.length;e++)n=t.getLayerById(this._layers[e]),n&&n.addMeshInstances(this._meshInstances)}get layers(){return this._layers}set batchGroupId(e){if(this._batchGroupId!==e){const t=this.system.app.batcher;this.entity.enabled&&this._batchGroupId>=0&&t.remove(gy.RENDER,this.batchGroupId,this.entity),this.entity.enabled&&e>=0&&t.insert(gy.RENDER,e,this.entity),e<0&&this._batchGroupId>=0&&this.enabled&&this.entity.enabled&&this.addToLayers(),this._batchGroupId=e}}get batchGroupId(){return this._batchGroupId}set material(e){if(this._material!==e&&(this._material=e,this._meshInstances&&"asset"!==this._type))for(let t=0;t<this._meshInstances.length;t++)this._meshInstances[t].material=e}get material(){return this._material}set materialAssets(e=[]){if(this._materialReferences.length>e.length){for(let t=e.length;t<this._materialReferences.length;t++)this._materialReferences[t].id=null;this._materialReferences.length=e.length}for(let t=0;t<e.length;t++)if(this._materialReferences[t]||this._materialReferences.push(new Ew(t,this,this.system.app.assets,{add:this._onMaterialAdded,load:this._onMaterialLoad,remove:this._onMaterialRemove,unload:this._onMaterialUnload},this)),e[t]){const n=e[t]instanceof f_?e[t].id:e[t];this._materialReferences[t].id!==n&&(this._materialReferences[t].id=n),this._materialReferences[t].asset&&this._onMaterialAdded(t,this,this._materialReferences[t].asset)}else this._materialReferences[t].id=null,this._meshInstances[t]&&(this._meshInstances[t].material=this.system.defaultMaterial)}get materialAssets(){return this._materialReferences.map((function(e){return e.id}))}set asset(e){const t=e instanceof f_?e.id:e;this._assetReference.id!==t&&(this._assetReference.asset&&this._assetReference.asset.resource&&this._onRenderAssetRemove(),this._assetReference.id=t,this._assetReference.asset&&this._onRenderAssetAdded())}get asset(){return this._assetReference.id}assignAsset(e){const t=e instanceof f_?e.id:e;this._assetReference.id=t}_onSetRootBone(e){e&&this._onRootBoneChanged()}_onRootBoneChanged(){this._clearSkinInstances(),this.enabled&&this.entity.enabled&&this._cloneSkinInstances()}destroyMeshInstances(){const e=this._meshInstances;if(e){this.removeFromLayers(),this._clearSkinInstances();for(let t=0;t<e.length;t++)e[t].destroy();this._meshInstances.length=0}}addToLayers(){const e=this.system.app.scene.layers;for(let t=0;t<this._layers.length;t++){const n=e.getLayerById(this._layers[t]);n&&n.addMeshInstances(this._meshInstances)}}removeFromLayers(){if(this._meshInstances&&this._meshInstances.length){const e=this.system.app.scene.layers;for(let t=0;t<this._layers.length;t++){const n=e.getLayerById(this._layers[t]);n&&n.removeMeshInstances(this._meshInstances)}}}onRemoveChild(){this.removeFromLayers()}onInsertChild(){this._meshInstances&&this.enabled&&this.entity.enabled&&this.addToLayers()}onRemove(){this.destroyMeshInstances(),this.asset=null,this.materialAsset=null,this._assetReference.id=null;for(let e=0;e<this._materialReferences.length;e++)this._materialReferences[e].id=null;this.entity.off("remove",this.onRemoveChild,this),this.entity.off("insert",this.onInsertChild,this)}onLayersChanged(e,t){this.addToLayers(),e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this)}onLayerAdded(e){this.layers.indexOf(e.id)<0||e.addMeshInstances(this._meshInstances)}onLayerRemoved(e){this.layers.indexOf(e.id)<0||e.removeMeshInstances(this._meshInstances)}onEnable(){const e=this.system.app,t=e.scene;this._rootBone.onParentComponentEnable(),this._cloneSkinInstances(),t.on("set:layers",this.onLayersChanged,this),t.layers&&(t.layers.on("add",this.onLayerAdded,this),t.layers.on("remove",this.onLayerRemoved,this));const n="asset"===this._type;this._meshInstances&&this._meshInstances.length?this.addToLayers():n&&this.asset&&this._onRenderAssetAdded();for(let e=0;e<this._materialReferences.length;e++)this._materialReferences[e].asset&&this.system.app.assets.load(this._materialReferences[e].asset);this._batchGroupId>=0&&e.batcher.insert(gy.RENDER,this.batchGroupId,this.entity)}onDisable(){const e=this.system.app,t=e.scene;t.off("set:layers",this.onLayersChanged,this),t.layers&&(t.layers.off("add",this.onLayerAdded,this),t.layers.off("remove",this.onLayerRemoved,this)),this._batchGroupId>=0&&e.batcher.remove(gy.RENDER,this.batchGroupId,this.entity),this.removeFromLayers()}hide(){if(this._meshInstances)for(let e=0;e<this._meshInstances.length;e++)this._meshInstances[e].visible=!1}show(){if(this._meshInstances)for(let e=0;e<this._meshInstances.length;e++)this._meshInstances[e].visible=!0}_onRenderAssetAdded(){this._assetReference.asset&&(this._assetReference.asset.resource?this._onRenderAssetLoad():this.enabled&&this.entity.enabled&&this.system.app.assets.load(this._assetReference.asset))}_onRenderAssetLoad(){if(this.destroyMeshInstances(),this._assetReference.asset){const e=this._assetReference.asset.resource;e.off("set:meshes",this._onSetMeshes,this),e.on("set:meshes",this._onSetMeshes,this),e.meshes&&this._onSetMeshes(e.meshes)}}_onSetMeshes(e){this._cloneMeshes(e)}_clearSkinInstances(){for(let e=0;e<this._meshInstances.length;e++){const t=this._meshInstances[e];y_.removeCachedSkinInstance(t.skinInstance),t.skinInstance=null}}_cloneSkinInstances(){if(this._meshInstances.length&&this._rootBone.entity instanceof hf)for(let e=0;e<this._meshInstances.length;e++){const t=this._meshInstances[e],n=t.mesh;n.skin&&!n.skinInstance&&(t.skinInstance=y_.createCachedSkinInstance(n.skin,this._rootBone.entity,this.entity))}}_cloneMeshes(e){if(e&&e.length){const t=[];for(let n=0;n<e.length;n++){const a=e[n],i=this._materialReferences[n]&&this._materialReferences[n].asset&&this._materialReferences[n].asset.resource,s=new Ay(a,i||this.system.defaultMaterial,this.entity);t.push(s),a.morph&&(s.morphInstance=new kv(a.morph))}this.meshInstances=t,this._cloneSkinInstances()}}_onRenderAssetUnload(){"asset"===this._type&&this.destroyMeshInstances()}_onRenderAssetRemove(){this._assetReference.asset&&this._assetReference.asset.resource&&this._assetReference.asset.resource.off("set:meshes",this._onSetMeshes,this),this._onRenderAssetUnload()}_onMaterialAdded(e,t,n){n.resource?this._onMaterialLoad(e,t,n):this.enabled&&this.entity.enabled&&this.system.app.assets.load(n)}_updateMainMaterial(e,t){0===e&&(this.material=t)}_onMaterialLoad(e,t,n){this._meshInstances[e]&&(this._meshInstances[e].material=n.resource),this._updateMainMaterial(e,n.resource)}_onMaterialRemove(e,t,n){this._meshInstances[e]&&(this._meshInstances[e].material=this.system.defaultMaterial),this._updateMainMaterial(e,this.system.defaultMaterial)}_onMaterialUnload(e,t,n){this._meshInstances[e]&&(this._meshInstances[e].material=this.system.defaultMaterial),this._updateMainMaterial(e,this.system.defaultMaterial)}resolveDuplicatedEntityReferenceProperties(e,t){e.rootBone&&t[e.rootBone]&&(this.rootBone=t[e.rootBone]),this._clearSkinInstances()}}class CS{constructor(){this.enabled=!0,this.rootBone=null}}const TS=[{name:"rootBone",type:"entity"},"enabled"],ES=["material","meshInstances","asset","materialAssets","castShadows","receiveShadows","castShadowsLightmap","lightmapped","lightmapSizeMultiplier","renderStyle","type","layers","isStatic","batchGroupId"];class SS extends AC{constructor(e){super(e),this.id="render",this.ComponentType=xS,this.DataType=CS,this.schema=TS,this.defaultMaterial=$f(e.graphicsDevice),this.on("beforeremove",this.onRemove,this)}initializeComponentData(e,t,n){null!==t.batchGroupId&&void 0!==t.batchGroupId||(t.batchGroupId=-1),t.layers&&t.layers.length&&(t.layers=t.layers.slice(0));for(let n=0;n<ES.length;n++)t.hasOwnProperty(ES[n])&&(e[ES[n]]=t[ES[n]]);t.aabbCenter&&t.aabbHalfExtents&&(e.customAabb=new qu(new Pu(t.aabbCenter),new Pu(t.aabbHalfExtents))),super.initializeComponentData(e,t,TS)}cloneComponent(e,t){const n={};for(let t=0;t<ES.length;t++)n[ES[t]]=e.render[ES[t]];n.enabled=e.render.enabled,delete n.meshInstances;const a=this.addComponent(t,n),i=e.render.meshInstances,s=i.map((e=>e.mesh));a._onSetMeshes(s);for(let e=0;e<i.length;e++)a.meshInstances[e].material=i[e].material;return e.render.customAabb&&(a.customAabb=e.render.customAabb.clone()),a}onRemove(e,t){t.onRemove()}}let AS;Ux._buildAccessors(xS.prototype,TS);let MS=1;const LS=new zu,RS=new zu,IS=new Pu,PS=new Pu,kS=new Pu,DS=new Pu,OS=new Pu,FS=new Pu,NS=new Pu,VS=new Pu,BS=new Pu,US=new Pu,zS=new Pu,GS=new Pu,HS=new Pu;function WS(e){return e-Math.floor(e)}function jS(e){return Math.max(Math.min(e,1),0)}function XS(e,t){return e-t*Math.floor(e/t)}function YS(e){let t=WS(e),n=WS(255*e);return t-=n/255,n-=n/255,[t,n]}class qS{constructor(e){this._emitter=e}calcSpawnPosition(e,t,n,a,i){const s=this._emitter,r=Math.random(),o=Math.random(),l=Math.random(),c=Math.random();if(s.useCpu&&(e[4*i+0+2*s.numParticlesPot*4]=r,e[4*i+1+2*s.numParticlesPot*4]=o,e[4*i+2+2*s.numParticlesPot*4]=l),PS.x=r-.5,PS.y=o-.5,PS.z=l-.5,0===s.emitterShape){const e=Math.max(Math.abs(PS.x),Math.max(Math.abs(PS.y),Math.abs(PS.z))),i=e+(.5-e)*n[0],r=e+(.5-e)*n[1],o=e+(.5-e)*n[2];PS.x=i*(e===Math.abs(PS.x)?Math.sign(PS.x):2*PS.x),PS.y=r*(e===Math.abs(PS.y)?Math.sign(PS.y):2*PS.y),PS.z=o*(e===Math.abs(PS.z)?Math.sign(PS.z):2*PS.z),s.localSpace?IS.copy(t.transformPoint(PS)):IS.copy(a).add(t.transformPoint(PS))}else{PS.normalize();const e=0===s.emitterRadius?0:s.emitterRadiusInner/s.emitterRadius,t=c*(1-e)+e;s.localSpace?IS.copy(PS.mulScalar(t*s.emitterRadius)):IS.copy(a).add(PS.mulScalar(t*s.emitterRadius))}let h=-Eu.lerp(s.rate,s.rate2,r)*i;if(s.pack8){const t=(IS.x-s.worldBounds.center.x)/s.worldBoundsSize.x+.5,n=(IS.y-s.worldBounds.center.y)/s.worldBoundsSize.y+.5,a=(IS.z-s.worldBounds.center.z)/s.worldBoundsSize.z+.5;let o=Eu.lerp(s.startAngle*Eu.DEG_TO_RAD,s.startAngle2*Eu.DEG_TO_RAD,r);o=o%(2*Math.PI)/(2*Math.PI);const l=YS(t);e[4*i]=l[0],e[4*i+1]=l[1];const c=YS(n);e[4*i+2]=c[0],e[4*i+3]=c[1];const d=YS(a);e[4*i+0+4*s.numParticlesPot]=d[0],e[4*i+1+4*s.numParticlesPot]=d[1];const p=YS(o);e[4*i+2+4*s.numParticlesPot]=p[0],e[4*i+3+4*s.numParticlesPot]=p[1];const u=1;e[4*i+3+4*s.numParticlesPot*2]=u;const m=Math.max(s.lifetime,(s.numParticles-1)*Math.max(s.rate,s.rate2));h=(h+m)/(m+(s.lifetime+1));const f=function(e){let t=WS(e),n=WS(255*e),a=WS(65025*e),i=WS(160581375*e);return t-=n/255,n-=a/255,a-=i/255,i-=i/255,[t,n,a,i]}(h);e[4*i+0+4*s.numParticlesPot*3]=f[0],e[4*i+1+4*s.numParticlesPot*3]=f[1],e[4*i+2+4*s.numParticlesPot*3]=f[2],e[4*i+3+4*s.numParticlesPot*3]=f[3]}else e[4*i]=IS.x,e[4*i+1]=IS.y,e[4*i+2]=IS.z,e[4*i+3]=Eu.lerp(s.startAngle*Eu.DEG_TO_RAD,s.startAngle2*Eu.DEG_TO_RAD,r),e[4*i+3+4*s.numParticlesPot]=h}update(e,t,n,a,i,s,r,o){let l,c,h;const d=this._emitter;if(d.meshInstance.node){const e=d.meshInstance.node.worldTransform;for(let t=0;t<12;t++)LS.data[t]=e.data[t];RS.copy(LS),RS.invert(),AS=d.meshInstance.node.localScale,MS=Math.max(Math.max(AS.x,AS.y),AS.z)}s=null===d.meshInstance.node||d.localSpace?Pu.ZERO:d.meshInstance.node.getPosition();const p=d.camera?d.camera._node.getPosition():Pu.ZERO,u=d.useMesh?17:15;let m,f,g,y,b,v,_,w,x;const C=d.precision-1;for(let t=0;t<d.numParticles;t++){const T=Math.floor(d.vbCPU[t*d.numParticleVerts*(d.useMesh?6:4)+3]),E=n[4*T+0+2*d.numParticlesPot*4];kS.x=E,kS.y=n[4*T+1+2*d.numParticlesPot*4],kS.z=n[4*T+2+2*d.numParticlesPot*4];const S=d.rate+(d.rate2-d.rate)*E,A=d.lifetime;let M=n[4*T+3+4*d.numParticlesPot]+r;const L=jS(M/A);let R=0,I=0;const P=0;(M-r<=0||M>=A)&&this.calcSpawnPosition(n,a,i,s,T);let k=M>0&&M<A;k&&(h=L*C,m=Math.floor(h),f=Math.ceil(h),h%=1,l=d.qRotSpeed[m],c=d.qRotSpeed[f],g=l+(c-l)*h,l=d.qRotSpeed2[m],c=d.qRotSpeed2[f],y=l+(c-l)*h,l=d.qScale[m],c=d.qScale[f],R=l+(c-l)*h,l=d.qScale2[m],c=d.qScale2[f],b=l+(c-l)*h,l=d.qAlpha[m],c=d.qAlpha[f],v=l+(c-l)*h,l=d.qAlpha2[m],c=d.qAlpha2[f],_=l+(c-l)*h,l=d.qRadialSpeed[m],c=d.qRadialSpeed[f],w=l+(c-l)*h,l=d.qRadialSpeed2[m],c=d.qRadialSpeed2[f],x=l+(c-l)*h,w+=100*E%1*(x-w),DS.x=n[4*T],DS.y=n[4*T+1],DS.z=n[4*T+2],d.localSpace?BS.copy(DS):BS.copy(DS).sub(s),BS.normalize().mulScalar(w),m*=3,f*=3,l=d.qLocalVelocity[m],c=d.qLocalVelocity[f],FS.x=l+(c-l)*h,l=d.qLocalVelocity[m+1],c=d.qLocalVelocity[f+1],FS.y=l+(c-l)*h,l=d.qLocalVelocity[m+2],c=d.qLocalVelocity[f+2],FS.z=l+(c-l)*h,l=d.qLocalVelocity2[m],c=d.qLocalVelocity2[f],VS.x=l+(c-l)*h,l=d.qLocalVelocity2[m+1],c=d.qLocalVelocity2[f+1],VS.y=l+(c-l)*h,l=d.qLocalVelocity2[m+2],c=d.qLocalVelocity2[f+2],VS.z=l+(c-l)*h,l=d.qVelocity[m],c=d.qVelocity[f],OS.x=l+(c-l)*h,l=d.qVelocity[m+1],c=d.qVelocity[f+1],OS.y=l+(c-l)*h,l=d.qVelocity[m+2],c=d.qVelocity[f+2],OS.z=l+(c-l)*h,l=d.qVelocity2[m],c=d.qVelocity2[f],NS.x=l+(c-l)*h,l=d.qVelocity2[m+1],c=d.qVelocity2[f+1],NS.y=l+(c-l)*h,l=d.qVelocity2[m+2],c=d.qVelocity2[f+2],NS.z=l+(c-l)*h,FS.x+=(VS.x-FS.x)*kS.x,FS.y+=(VS.y-FS.y)*kS.y,FS.z+=(VS.z-FS.z)*kS.z,d.initialVelocity>0&&(1===d.emitterShape?(PS.copy(kS).mulScalar(2).sub(Pu.ONE).normalize(),FS.add(PS.mulScalar(d.initialVelocity))):FS.add(Pu.FORWARD.mulScalar(d.initialVelocity))),OS.x+=(NS.x-OS.x)*kS.x,OS.y+=(NS.y-OS.y)*kS.y,OS.z+=(NS.z-OS.z)*kS.z,g+=(y-g)*kS.y,R=(R+1e4*E%1*(b-R))*MS,I=1e3*E%1*(_-v),d.meshInstance.node&&(d.localSpace?(FS.x/=AS.x,FS.y/=AS.y,FS.z/=AS.z):LS.transformPoint(FS,FS)),d.localSpace?(RS.transformPoint(OS,OS),FS.add(OS).add(BS)):(FS.add(OS.mul(AS)),FS.add(BS.mul(AS))),GS.copy(FS),US.copy(DS).add(FS.mulScalar(r)),zS.copy(US),n[4*T]=zS.x,n[4*T+1]=zS.y,n[4*T+2]=zS.z,n[4*T+3]+=g*r,d.wrap&&d.wrapBounds&&(d.localSpace||zS.sub(s),zS.x=XS(zS.x,d.wrapBounds.x)-.5*d.wrapBounds.x,zS.y=XS(zS.y,d.wrapBounds.y)-.5*d.wrapBounds.y,zS.z=XS(zS.z,d.wrapBounds.z)-.5*d.wrapBounds.z,d.localSpace||zS.add(s)),d.sort>0&&(1===d.sort?(HS.copy(zS).sub(p),d.particleDistance[T]=-(HS.x*HS.x+HS.y*HS.y+HS.z*HS.z)):2===d.sort?d.particleDistance[T]=M:3===d.sort&&(d.particleDistance[T]=-M))),o?M<0&&(n[4*T+3+2*d.numParticlesPot*4]=-1):(M>=A&&(M-=Math.max(A,(d.numParticles-1)*S),n[4*T+3+2*d.numParticlesPot*4]=d.loop?1:-1),M<0&&d.loop&&(n[4*T+3+2*d.numParticlesPot*4]=1)),n[4*T+3+2*d.numParticlesPot*4]<0&&(k=!1),n[4*T+3+4*d.numParticlesPot]=M;for(let a=0;a<d.numParticleVerts;a++){const i=(t*d.numParticleVerts+a)*(d.useMesh?6:4);let s=d.vbCPU[i],r=d.vbCPU[i+1],o=d.vbCPU[i+2];k||(s=r=o=0);const l=t*d.numParticleVerts*u+a*u;e[l]=zS.x,e[l+1]=zS.y,e[l+2]=zS.z,e[l+3]=L,e[l+4]=d.alignToMotion?P:n[4*T+3],e[l+5]=R,e[l+6]=I,e[l+7]=GS.x,e[l+8]=s,e[l+9]=r,e[l+10]=o,e[l+11]=GS.y,e[l+12]=T,e[l+13]=GS.z,e[l+14]=d.vbCPU[i+3],d.useMesh&&(e[l+15]=d.vbCPU[i+4],e[l+16]=d.vbCPU[i+5])}}if(d.sort>0&&d.camera){const e=d.useMesh?6:4,n=d.particleDistance;for(let a=0;a<d.numParticles;a++)t[a][0]=a,t[a][1]=n[Math.floor(d.vbCPU[a*d.numParticleVerts*e+3])];d.vbOld.set(d.vbCPU),t.sort((function(e,t){return e[1]-t[1]}));for(let n=0;n<d.numParticles;n++){const a=t[n][0]*d.numParticleVerts*e,i=n*d.numParticleVerts*e;for(let t=0;t<d.numParticleVerts*e;t++)d.vbCPU[i+t]=d.vbOld[a+t]}}}}const KS=new ku,ZS=new ku,$S=new ku;class QS{constructor(e,t){this._emitter=e,this.frameRandomUniform=new Float32Array(3),this.emitterPosUniform=new Float32Array(3),this.emitterScaleUniform=new Float32Array([1,1,1]),this.worldBoundsMulUniform=new Float32Array(3),this.worldBoundsAddUniform=new Float32Array(3),this.inBoundsSizeUniform=new Float32Array(3),this.inBoundsCenterUniform=new Float32Array(3),this.constantParticleTexIN=t.scope.resolve("particleTexIN"),this.constantParticleTexOUT=t.scope.resolve("particleTexOUT"),this.constantEmitterPos=t.scope.resolve("emitterPos"),this.constantEmitterScale=t.scope.resolve("emitterScale"),this.constantSpawnBounds=t.scope.resolve("spawnBounds"),this.constantSpawnPosInnerRatio=t.scope.resolve("spawnPosInnerRatio"),this.constantSpawnBoundsSphere=t.scope.resolve("spawnBoundsSphere"),this.constantSpawnBoundsSphereInnerRatio=t.scope.resolve("spawnBoundsSphereInnerRatio"),this.constantInitialVelocity=t.scope.resolve("initialVelocity"),this.constantFrameRandom=t.scope.resolve("frameRandom"),this.constantDelta=t.scope.resolve("delta"),this.constantRate=t.scope.resolve("rate"),this.constantRateDiv=t.scope.resolve("rateDiv"),this.constantLifetime=t.scope.resolve("lifetime"),this.constantGraphSampleSize=t.scope.resolve("graphSampleSize"),this.constantGraphNumSamples=t.scope.resolve("graphNumSamples"),this.constantInternalTex0=t.scope.resolve("internalTex0"),this.constantInternalTex1=t.scope.resolve("internalTex1"),this.constantInternalTex2=t.scope.resolve("internalTex2"),this.constantInternalTex3=t.scope.resolve("internalTex3"),this.constantEmitterMatrix=t.scope.resolve("emitterMatrix"),this.constantEmitterMatrixInv=t.scope.resolve("emitterMatrixInv"),this.constantNumParticles=t.scope.resolve("numParticles"),this.constantNumParticlesPot=t.scope.resolve("numParticlesPot"),this.constantLocalVelocityDivMult=t.scope.resolve("localVelocityDivMult"),this.constantVelocityDivMult=t.scope.resolve("velocityDivMult"),this.constantRotSpeedDivMult=t.scope.resolve("rotSpeedDivMult"),this.constantSeed=t.scope.resolve("seed"),this.constantStartAngle=t.scope.resolve("startAngle"),this.constantStartAngle2=t.scope.resolve("startAngle2"),this.constantOutBoundsMul=t.scope.resolve("outBoundsMul"),this.constantOutBoundsAdd=t.scope.resolve("outBoundsAdd"),this.constantInBoundsSize=t.scope.resolve("inBoundsSize"),this.constantInBoundsCenter=t.scope.resolve("inBoundsCenter"),this.constantMaxVel=t.scope.resolve("maxVel"),this.constantFaceTangent=t.scope.resolve("faceTangent"),this.constantFaceBinorm=t.scope.resolve("faceBinorm")}_setInputBounds(){this.inBoundsSizeUniform[0]=this._emitter.prevWorldBoundsSize.x,this.inBoundsSizeUniform[1]=this._emitter.prevWorldBoundsSize.y,this.inBoundsSizeUniform[2]=this._emitter.prevWorldBoundsSize.z,this.constantInBoundsSize.setValue(this.inBoundsSizeUniform),this.inBoundsCenterUniform[0]=this._emitter.prevWorldBoundsCenter.x,this.inBoundsCenterUniform[1]=this._emitter.prevWorldBoundsCenter.y,this.inBoundsCenterUniform[2]=this._emitter.prevWorldBoundsCenter.z,this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform)}randomize(){this.frameRandomUniform[0]=Math.random(),this.frameRandomUniform[1]=Math.random(),this.frameRandomUniform[2]=Math.random()}update(e,t,n,a,i){const s=this._emitter;e.setBlending(!1),e.setColorWrite(!0,!0,!0,!0),e.setCullMode(0),e.setDepthTest(!1),e.setDepthWrite(!1),this.randomize(),this.constantGraphSampleSize.setValue(1/s.precision),this.constantGraphNumSamples.setValue(s.precision),this.constantNumParticles.setValue(s.numParticles),this.constantNumParticlesPot.setValue(s.numParticlesPot),this.constantInternalTex0.setValue(s.internalTex0),this.constantInternalTex1.setValue(s.internalTex1),this.constantInternalTex2.setValue(s.internalTex2),this.constantInternalTex3.setValue(s.internalTex3);const r=s.meshInstance.node,o=null===r?Pu.ONE:r.localScale;if(s.pack8){this.worldBoundsMulUniform[0]=s.worldBoundsMul.x,this.worldBoundsMulUniform[1]=s.worldBoundsMul.y,this.worldBoundsMulUniform[2]=s.worldBoundsMul.z,this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform),this.worldBoundsAddUniform[0]=s.worldBoundsAdd.x,this.worldBoundsAddUniform[1]=s.worldBoundsAdd.y,this.worldBoundsAddUniform[2]=s.worldBoundsAdd.z,this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform),this._setInputBounds();let e=s.maxVel*Math.max(Math.max(o.x,o.y),o.z);e=Math.max(e,1),this.constantMaxVel.setValue(e)}const l=null===r||s.localSpace?Pu.ZERO:r.getPosition(),c=null===r?zu.IDENTITY:r.getWorldTransform();0===s.emitterShape?(KS.setFromMat4(t),this.constantSpawnBounds.setValue(KS.data),this.constantSpawnPosInnerRatio.setValue(n)):(this.constantSpawnBoundsSphere.setValue(s.emitterRadius),this.constantSpawnBoundsSphereInnerRatio.setValue(0===s.emitterRadius?0:s.emitterRadiusInner/s.emitterRadius)),this.constantInitialVelocity.setValue(s.initialVelocity),ZS.setFromMat4(c),c.invertTo3x3($S),this.emitterPosUniform[0]=l.x,this.emitterPosUniform[1]=l.y,this.emitterPosUniform[2]=l.z,this.constantEmitterPos.setValue(this.emitterPosUniform),this.constantFrameRandom.setValue(this.frameRandomUniform),this.constantDelta.setValue(a),this.constantRate.setValue(s.rate),this.constantRateDiv.setValue(s.rate2-s.rate),this.constantStartAngle.setValue(s.startAngle*Eu.DEG_TO_RAD),this.constantStartAngle2.setValue(s.startAngle2*Eu.DEG_TO_RAD),this.constantSeed.setValue(s.seed),this.constantLifetime.setValue(s.lifetime),this.emitterScaleUniform[0]=o.x,this.emitterScaleUniform[1]=o.y,this.emitterScaleUniform[2]=o.z,this.constantEmitterScale.setValue(this.emitterScaleUniform),this.constantEmitterMatrix.setValue(ZS.data),this.constantEmitterMatrixInv.setValue($S.data),this.constantLocalVelocityDivMult.setValue(s.localVelocityUMax),this.constantVelocityDivMult.setValue(s.velocityUMax),this.constantRotSpeedDivMult.setValue(s.rotSpeedUMax[0]);let h=s.swapTex?s.particleTexOUT:s.particleTexIN;h=s.beenReset?s.particleTexStart:h;const d=s.swapTex?s.particleTexIN:s.particleTexOUT;this.constantParticleTexIN.setValue(h),mm(e,s.swapTex?s.rtParticleTexIN:s.rtParticleTexOUT,i?s.shaderParticleUpdateOnStop:s.loop?s.shaderParticleUpdateRespawn:s.shaderParticleUpdateNoRespawn),s.material.setParameter("particleTexOUT",h),s.material.setParameter("particleTexIN",d),s.beenReset=!1,s.swapTex=!s.swapTex,e.setDepthTest(!0),e.setDepthWrite(!0),s.prevWorldBoundsSize.copy(s.worldBoundsSize),s.prevWorldBoundsCenter.copy(s.worldBounds.center),s.pack8&&this._setInputBounds()}}const JS=[[-1,-1],[1,-1],[1,1],[-1,1]];function eA(e,t,n,a,i=14,s,r){let o=0;r&&7===i&&(o=1);const l=new Gm(e,{width:t,height:n,format:i,cubemap:!1,mipmaps:!1,minFilter:o,magFilter:o,addressU:1,addressV:1});l.name="PSTexture";const c=l.lock();if(7===i){const e=new Uint8Array(a.length);for(let t=0;t<a.length;t++)e[t]=a[t]*s*255;a=e}return c.set(a),l.unlock(),l}function tA(e){return Math.max(Math.min(e,1),0)}const nA=new Ru([0,0,1,0]),aA=new Ru([0,1,1,1]),iA=new Iu([0,0,1,0],[0,0,1,0],[0,0,1,0]),sA=new Iu([0,1,1,1],[0,1,1,1],[0,1,1,1]);let rA=2;const oA=new Float32Array(3),lA=new zu,cA=new Pu,hA=new Pu,dA=new Pu;let pA,uA;function mA(e,t){void 0!==uA[e]&&null!==uA[e]?pA[e]=uA[e]:pA[e]=t}function fA(e,t,n){return(255*e<<16|255*t<<8|255*n)/(1<<24)}function gA(e,t){const n=e.length/3,a=new Array(4*n);for(let i=0;i<n;i++)a[4*i]=e[3*i],a[4*i+1]=e[3*i+1],a[4*i+2]=e[3*i+2],a[4*i+3]=fA(t[3*i],t[3*i+1],t[3*i+2]);return a}function yA(e,t){const n=t.length,a=e.length/n;for(let i=0;i<a;i++)for(let a=0;a<n;a++){const s=Math.abs(e[i*n+a]);t[a]=Math.max(t[a],s)}}function bA(e,t,n){const a=function(e,t){const n=new Float32Array(e.length);for(let a=0;a<e.length;a++)n[a]=e[a]-t[a];return n}(t,e);return yA(a,n),function(e,t){const n=t.length,a=e.length/n;for(let i=0;i<a;i++)for(let a=0;a<n;a++)e[i*n+a]/=0===t[a]?1:t[a],e[i*n+a]*=.5,e[i*n+a]+=.5}(a,n),a}const vA=new dm;class _A{constructor(e,t){this.graphicsDevice=e;const n=e;this.precision=32,this._addTimeTime=0,pA=this,uA=t,mA("numParticles",1),this.numParticles>e.maxTextureSize&&(this.numParticles=e.maxTextureSize),mA("rate",1),mA("rate2",this.rate),mA("lifetime",50),mA("emitterExtents",new Pu(0,0,0)),mA("emitterExtentsInner",new Pu(0,0,0)),mA("emitterRadius",0),mA("emitterRadiusInner",0),mA("emitterShape",0),mA("initialVelocity",1),mA("wrap",!1),mA("localSpace",!1),mA("screenSpace",!1),mA("wrapBounds",null),mA("colorMap",this.defaultParamTexture),mA("normalMap",null),mA("loop",!0),mA("preWarm",!1),mA("sort",0),mA("mode",0),mA("scene",null),mA("lighting",!1),mA("halfLambert",!1),mA("intensity",1),mA("stretch",0),mA("alignToMotion",!1),mA("depthSoftening",0),mA("mesh",null),mA("particleNormal",new Pu(0,1,0)),mA("orientation",0),mA("depthWrite",!1),mA("noFog",!1),mA("blendType",2),mA("node",null),mA("startAngle",0),mA("startAngle2",this.startAngle),mA("animTilesX",1),mA("animTilesY",1),mA("animStartFrame",0),mA("animNumFrames",1),mA("animNumAnimations",1),mA("animIndex",0),mA("randomizeAnimIndex",!1),mA("animSpeed",1),mA("animLoop",!0),this._gpuUpdater=new QS(this,n),this._cpuUpdater=new qS(this),this.constantLightCube=n.scope.resolve("lightCube[0]"),this.emitterPosUniform=new Float32Array(3),this.wrapBoundsUniform=new Float32Array(3),this.emitterScaleUniform=new Float32Array([1,1,1]),mA("colorGraph",sA),mA("colorGraph2",this.colorGraph),mA("scaleGraph",aA),mA("scaleGraph2",this.scaleGraph),mA("alphaGraph",aA),mA("alphaGraph2",this.alphaGraph),mA("localVelocityGraph",iA),mA("localVelocityGraph2",this.localVelocityGraph),mA("velocityGraph",iA),mA("velocityGraph2",this.velocityGraph),mA("rotationSpeedGraph",nA),mA("rotationSpeedGraph2",this.rotationSpeedGraph),mA("radialSpeedGraph",nA),mA("radialSpeedGraph2",this.radialSpeedGraph),this.lightCube=new Float32Array(18),this.lightCubeDir=new Array(6),this.lightCubeDir[0]=new Pu(-1,0,0),this.lightCubeDir[1]=new Pu(1,0,0),this.lightCubeDir[2]=new Pu(0,-1,0),this.lightCubeDir[3]=new Pu(0,1,0),this.lightCubeDir[4]=new Pu(0,0,-1),this.lightCubeDir[5]=new Pu(0,0,1),this.animTilesParams=new Float32Array(2),this.animParams=new Float32Array(4),this.animIndexParams=new Float32Array(2),this.internalTex0=null,this.internalTex1=null,this.internalTex2=null,this.colorParam=null,this.vbToSort=null,this.vbOld=null,this.particleDistance=null,this.camera=null,this.swapTex=!1,this.useMesh=!0,this.useCpu=!e.supportsGpuParticles,this.pack8=!0,this.localBounds=new qu,this.worldBoundsNoTrail=new qu,this.worldBoundsTrail=[new qu,new qu],this.worldBounds=new qu,this.worldBoundsSize=new Pu,this.prevWorldBoundsSize=new Pu,this.prevWorldBoundsCenter=new Pu,this.prevEmitterExtents=this.emitterExtents,this.prevEmitterRadius=this.emitterRadius,this.worldBoundsMul=new Pu,this.worldBoundsAdd=new Pu,this.timeToSwitchBounds=0,this.shaderParticleUpdateRespawn=null,this.shaderParticleUpdateNoRespawn=null,this.shaderParticleUpdateOnStop=null,this.numParticleVerts=0,this.numParticleIndices=0,this.material=null,this.meshInstance=null,this.drawOrder=0,this.seed=Math.random(),this.fixedTimeStep=1/60,this.maxSubSteps=10,this.simTime=0,this.simTimeTotal=0,this.beenReset=!1,this._layer=null,this.rebuild()}get defaultParamTexture(){return vA.get(this.graphicsDevice,(()=>{const e=16,t=new Float32Array(1024);for(let n=0;n<e;n++)for(let a=0;a<e;a++){const i=a+1-8.5,s=n+1-8.5,r=tA(1-tA(Math.sqrt(i*i+s*s)/e)-.5),o=n*e+a;t[4*o]=1,t[4*o+1]=1,t[4*o+2]=1,t[4*o+3]=r}const n=eA(this.graphicsDevice,e,e,t,7,1,!0);return n.minFilter=1,n.magFilter=1,n}))}onChangeCamera(){this.regenShader(),this.resetMaterial()}calculateBoundsMad(){this.worldBoundsMul.x=1/this.worldBoundsSize.x,this.worldBoundsMul.y=1/this.worldBoundsSize.y,this.worldBoundsMul.z=1/this.worldBoundsSize.z,this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1),this.worldBoundsAdd.x+=.5,this.worldBoundsAdd.y+=.5,this.worldBoundsAdd.z+=.5}calculateWorldBounds(){if(!this.node)return;if(this.prevWorldBoundsSize.copy(this.worldBoundsSize),this.prevWorldBoundsCenter.copy(this.worldBounds.center),!this.useCpu){let e=!1;e=0===this.emitterShape?!this.emitterExtents.equals(this.prevEmitterExtents):!(this.emitterRadius===this.prevEmitterRadius),e&&this.calculateLocalBounds()}const e=this.node.getWorldTransform();this.localSpace?this.worldBoundsNoTrail.copy(this.localBounds):this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds,e),this.worldBoundsTrail[0].add(this.worldBoundsNoTrail),this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);const t=this.simTimeTotal;t>=this.timeToSwitchBounds&&(this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]),this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail),this.timeToSwitchBounds=t+this.lifetime),this.worldBounds.copy(this.worldBoundsTrail[0]),this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2),this.localSpace?(this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds,e),this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds,e)):(this.meshInstance.aabb.copy(this.worldBounds),this.meshInstance.mesh.aabb.copy(this.worldBounds)),this.meshInstance._aabbVer=1-this.meshInstance._aabbVer,this.pack8&&this.calculateBoundsMad()}resetWorldBounds(){this.node&&(this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds,this.localSpace?zu.IDENTITY:this.node.getWorldTransform()),this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail),this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail),this.worldBounds.copy(this.worldBoundsTrail[0]),this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2),this.prevWorldBoundsSize.copy(this.worldBoundsSize),this.prevWorldBoundsCenter.copy(this.worldBounds.center),this.simTimeTotal=0,this.timeToSwitchBounds=0)}calculateLocalBounds(){let e=Number.MAX_VALUE,t=Number.MAX_VALUE,n=Number.MAX_VALUE,a=-Number.MAX_VALUE,i=-Number.MAX_VALUE,s=-Number.MAX_VALUE,r=0,o=0;const l=this.lifetime/this.precision,c=[this.qVelocity,this.qVelocity2],h=[this.qLocalVelocity,this.qLocalVelocity2],d=[0,0],p=[0,0],u=[0,0],m=[0,0],f=[0,0];let g,y,b;for(let v=0;v<this.precision+1;v++){const _=Math.min(v,this.precision-1);for(let r=0;r<2;r++)g=h[r][3*_+0]*l+d[r],y=h[r][3*_+1]*l+p[r],b=h[r][3*_+2]*l+u[r],e=Math.min(g,e),t=Math.min(y,t),n=Math.min(b,n),a=Math.max(g,a),i=Math.max(y,i),s=Math.max(b,s),d[r]=g,p[r]=y,u[r]=b;for(let e=0;e<2;e++)f[e]+=l*Math.sqrt(c[e][3*_+0]*c[e][3*_+0]+c[e][3*_+1]*c[e][3*_+1]+c[e][3*_+2]*c[e][3*_+2]);m[0]+=this.qRadialSpeed[_]*l,m[1]+=this.qRadialSpeed2[_]*l,r=Math.max(r,Math.max(Math.abs(m[0]),Math.abs(m[1]))),o=Math.max(o,this.qScale[_])}0===this.emitterShape?(g=.5*this.emitterExtents.x,y=.5*this.emitterExtents.y,b=.5*this.emitterExtents.z):(g=this.emitterRadius,y=this.emitterRadius,b=this.emitterRadius);const v=Math.max(f[0],f[1]);hA.x=e-o-g-r-v,hA.y=t-o-y-r-v,hA.z=n-o-b-r-v,dA.x=a+o+g+r+v,dA.y=i+o+y+r+v,dA.z=s+o+b+r+v,this.localBounds.setMinMax(hA,dA)}rebuild(){const e=this.graphicsDevice;if(null===this.colorMap&&(this.colorMap=this.defaultParamTexture),this.spawnBounds=0===this.emitterShape?this.emitterExtents:this.emitterRadius,this.useCpu=this.useCpu||this.sort>0||e.maxVertexTextures<=1||e.fragmentUniformsCount<64||e.forceCpuParticles||!e.extTextureFloat,this._destroyResources(),this.pack8=(this.pack8||!e.textureFloatRenderable)&&!this.useCpu,rA=this.useCpu||this.pack8?4:2,this.useMesh=!1,this.mesh){this.numParticles*this.mesh.vertexBuffer.numVertices>65535||(this.useMesh=!0)}this.numParticlesPot=Eu.nextPowerOfTwo(this.numParticles),this.rebuildGraphs(),this.calculateLocalBounds(),this.resetWorldBounds(),this.node&&(this.worldBounds.setFromTransformedAabb(this.localBounds,this.localSpace?zu.IDENTITY:this.node.getWorldTransform()),this.worldBoundsTrail[0].copy(this.worldBounds),this.worldBoundsTrail[1].copy(this.worldBounds),this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2),this.prevWorldBoundsSize.copy(this.worldBoundsSize),this.prevWorldBoundsCenter.copy(this.worldBounds.center),this.pack8&&this.calculateBoundsMad()),this.vbToSort=new Array(this.numParticles);for(let e=0;e<this.numParticles;e++)this.vbToSort[e]=[0,0];this.particleDistance=new Float32Array(this.numParticles),this._gpuUpdater.randomize(),this.particleTex=new Float32Array(this.numParticlesPot*rA*4);const t=null===this.node||this.localSpace?Pu.ZERO:this.node.getPosition();0===this.emitterShape&&(null===this.node||this.localSpace?lA.setTRS(Pu.ZERO,Gu.IDENTITY,this.spawnBounds):lA.setTRS(Pu.ZERO,this.node.getRotation(),cA.copy(this.spawnBounds).mul(this.node.localScale)),oA[0]=0!==this.emitterExtents.x?this.emitterExtentsInner.x/this.emitterExtents.x:0,oA[1]=0!==this.emitterExtents.y?this.emitterExtentsInner.y/this.emitterExtents.y:0,oA[2]=0!==this.emitterExtents.z?this.emitterExtentsInner.z/this.emitterExtents.z:0);for(let e=0;e<this.numParticles;e++)this._cpuUpdater.calcSpawnPosition(this.particleTex,lA,oA,t,e),this.useCpu&&(this.particleTex[4*e+3+2*this.numParticlesPot*4]=1);this.particleTexStart=new Float32Array(this.numParticlesPot*rA*4);for(let e=0;e<this.particleTexStart.length;e++)this.particleTexStart[e]=this.particleTex[e];this.useCpu||(this.pack8?(this.particleTexIN=eA(e,this.numParticlesPot,rA,this.particleTex,7,1,!1),this.particleTexOUT=eA(e,this.numParticlesPot,rA,this.particleTex,7,1,!1),this.particleTexStart=eA(e,this.numParticlesPot,rA,this.particleTexStart,7,1,!1)):(this.particleTexIN=eA(e,this.numParticlesPot,rA,this.particleTex),this.particleTexOUT=eA(e,this.numParticlesPot,rA,this.particleTex),this.particleTexStart=eA(e,this.numParticlesPot,rA,this.particleTexStart)),this.rtParticleTexIN=new Cg({colorBuffer:this.particleTexIN,depth:!1}),this.rtParticleTexOUT=new Cg({colorBuffer:this.particleTexOUT,depth:!1}),this.swapTex=!1);const n=(this.localSpace?"#define LOCAL_SPACE\n":"")+gm.particleUpdaterInitPS+(this.pack8?gm.particleInputRgba8PS+gm.particleOutputRgba8PS:gm.particleInputFloatPS+gm.particleOutputFloatPS)+(0===this.emitterShape?gm.particleUpdaterAABBPS:gm.particleUpdaterSpherePS)+gm.particleUpdaterStartPS,a=n+gm.particleUpdaterRespawnPS+gm.particleUpdaterEndPS,i=n+gm.particleUpdaterNoRespawnPS+gm.particleUpdaterEndPS,s=n+gm.particleUpdaterOnStopPS+gm.particleUpdaterEndPS,r=this.emitterShape+""+this.pack8+this.localSpace;this.shaderParticleUpdateRespawn=Mm(e,gm.fullscreenQuadVS,a,"fsQuad0"+r),this.shaderParticleUpdateNoRespawn=Mm(e,gm.fullscreenQuadVS,i,"fsQuad1"+r),this.shaderParticleUpdateOnStop=Mm(e,gm.fullscreenQuadVS,s,"fsQuad2"+r),this.numParticleVerts=this.useMesh?this.mesh.vertexBuffer.numVertices:4,this.numParticleIndices=this.useMesh?this.mesh.indexBuffer[0].numIndices:6,this._allocate(this.numParticles);const o=new iy(e);o.vertexBuffer=this.vertexBuffer,o.indexBuffer[0]=this.indexBuffer,o.primitive[0].type=4,o.primitive[0].base=0,o.primitive[0].count=this.numParticles*this.numParticleIndices,o.primitive[0].indexed=!0,this.material=new Jf,this.material.name=this.node.name,this.material.cull=0,this.material.alphaWrite=!1,this.material.blend=!0,this.material.blendType=this.blendType,this.material.depthWrite=this.depthWrite,this.material.emitter=this,this.regenShader(),this.resetMaterial();const l=!this.meshInstance||this.meshInstance.visible;this.meshInstance=new Ay(o,this.material,this.node),this.meshInstance.pick=!1,this.meshInstance.updateKey(),this.meshInstance.cull=!0,this.meshInstance._noDepthDrawGl1=!0,this.localSpace?this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds,this.node.getWorldTransform()):this.meshInstance.aabb.copy(this.worldBounds),this.meshInstance._updateAabb=!1,this.meshInstance.visible=l,this._initializeTextures(),this.resetTime(),this.addTime(0,!1),this.preWarm&&this.prewarm(this.lifetime)}_isAnimated(){return this.animNumFrames>=1&&(this.animTilesX>1||this.animTilesY>1)&&(this.colorMap&&this.colorMap!==this.defaultParamTexture||this.normalMap)}rebuildGraphs(){const e=this.precision,t=this.graphicsDevice;this.qLocalVelocity=this.localVelocityGraph.quantize(e),this.qVelocity=this.velocityGraph.quantize(e),this.qColor=this.colorGraph.quantizeClamped(e,0,1),this.qRotSpeed=this.rotationSpeedGraph.quantize(e),this.qScale=this.scaleGraph.quantize(e),this.qAlpha=this.alphaGraph.quantize(e),this.qRadialSpeed=this.radialSpeedGraph.quantize(e),this.qLocalVelocity2=this.localVelocityGraph2.quantize(e),this.qVelocity2=this.velocityGraph2.quantize(e),this.qColor2=this.colorGraph2.quantizeClamped(e,0,1),this.qRotSpeed2=this.rotationSpeedGraph2.quantize(e),this.qScale2=this.scaleGraph2.quantize(e),this.qAlpha2=this.alphaGraph2.quantize(e),this.qRadialSpeed2=this.radialSpeedGraph2.quantize(e);for(let t=0;t<e;t++)this.qRotSpeed[t]*=Eu.DEG_TO_RAD,this.qRotSpeed2[t]*=Eu.DEG_TO_RAD;if(this.localVelocityUMax=new Float32Array(3),this.velocityUMax=new Float32Array(3),this.colorUMax=new Float32Array(3),this.rotSpeedUMax=[0],this.scaleUMax=[0],this.alphaUMax=[0],this.radialSpeedUMax=[0],this.qLocalVelocityDiv=bA(this.qLocalVelocity,this.qLocalVelocity2,this.localVelocityUMax),this.qVelocityDiv=bA(this.qVelocity,this.qVelocity2,this.velocityUMax),this.qColorDiv=bA(this.qColor,this.qColor2,this.colorUMax),this.qRotSpeedDiv=bA(this.qRotSpeed,this.qRotSpeed2,this.rotSpeedUMax),this.qScaleDiv=bA(this.qScale,this.qScale2,this.scaleUMax),this.qAlphaDiv=bA(this.qAlpha,this.qAlpha2,this.alphaUMax),this.qRadialSpeedDiv=bA(this.qRadialSpeed,this.qRadialSpeed2,this.radialSpeedUMax),this.pack8){const e=[0,0,0];yA(this.qVelocity,e);const t=[0,0,0];yA(this.qVelocity2,t);const n=[0,0,0];yA(this.qLocalVelocity,n);const a=[0,0,0];yA(this.qLocalVelocity2,a);const i=[0];yA(this.qRadialSpeed,i);const s=[0];yA(this.qRadialSpeed2,s);let r=Math.max(e[0],t[0]);r=Math.max(r,e[1]),r=Math.max(r,t[1]),r=Math.max(r,e[2]),r=Math.max(r,t[2]);let o=Math.max(n[0],a[0]);o=Math.max(o,n[1]),o=Math.max(o,a[1]),o=Math.max(o,n[2]),o=Math.max(o,a[2]);const l=Math.max(i[0],s[0]);this.maxVel=r+o+l}this.useCpu||(this.internalTex0=eA(t,e,1,gA(this.qLocalVelocity,this.qLocalVelocityDiv)),this.internalTex1=eA(t,e,1,gA(this.qVelocity,this.qVelocityDiv)),this.internalTex2=eA(t,e,1,function(e,t,n,a,i){const s=new Array(4*e.length);for(let r=0;r<e.length;r++)s[4*r]=e[r],s[4*r+1]=t[r],s[4*r+2]=0,s[4*r+3]=fA(n[r],a[r],i[r]);return s}(this.qRotSpeed,this.qScale,this.qScaleDiv,this.qRotSpeedDiv,this.qAlphaDiv)),this.internalTex3=eA(t,e,1,function(e,t){const n=new Array(4*e.length);for(let a=0;a<e.length;a++)n[4*a]=e[a],n[4*a+1]=t[a],n[4*a+2]=0,n[4*a+3]=0;return n}(this.qRadialSpeed,this.qRadialSpeedDiv))),this.colorParam=eA(t,e,1,function(e,t){const n=new Array(4*t.length);for(let a=0;a<t.length;a++)n[4*a]=e[3*a],n[4*a+1]=e[3*a+1],n[4*a+2]=e[3*a+2],n[4*a+3]=t[a];return n}(this.qColor,this.qAlpha),7,1,!0)}_initializeTextures(){this.colorMap&&(this.material.setParameter("colorMap",this.colorMap),this.lighting&&this.normalMap&&this.material.setParameter("normalMap",this.normalMap))}regenShader(){const e=this.graphicsDevice.getProgramLibrary(),t=null!==this.normalMap;this.normalOption=0,this.lighting&&(this.normalOption=t?2:1),this.material.updateShader=function(){this.emitter.scene&&this.emitter.camera!==this.emitter.scene._activeCamera&&(this.emitter.camera=this.emitter.scene._activeCamera,this.emitter.onChangeCamera());const t=this.emitter.inTools,n=e.getProgram("particle",{useCpu:this.emitter.useCpu,normal:this.emitter.normalOption,halflambert:this.emitter.halfLambert,stretch:this.emitter.stretch,alignToMotion:this.emitter.alignToMotion,soft:this.emitter.depthSoftening,mesh:this.emitter.useMesh,gamma:this.emitter.scene?this.emitter.scene.gammaCorrection:0,toneMap:this.emitter.scene?this.emitter.scene.toneMapping:0,fog:this.emitter.scene&&!this.emitter.noFog?this.emitter.scene.fog:"none",wrap:this.emitter.wrap&&this.emitter.wrapBounds,localSpace:this.emitter.localSpace,screenSpace:!t&&this.emitter.screenSpace,blend:this.blendType,animTex:this.emitter._isAnimated(),animTexLoop:this.emitter.animLoop,pack8:this.emitter.pack8,customFace:0!==this.emitter.orientation});this.shader=n},this.material.updateShader()}resetMaterial(){const e=this.material;e.setParameter("stretch",this.stretch),this._isAnimated()&&(e.setParameter("animTexTilesParams",this.animTilesParams),e.setParameter("animTexParams",this.animParams),e.setParameter("animTexIndexParams",this.animIndexParams)),e.setParameter("colorMult",this.intensity),this.useCpu||(e.setParameter("internalTex0",this.internalTex0),e.setParameter("internalTex1",this.internalTex1),e.setParameter("internalTex2",this.internalTex2),e.setParameter("internalTex3",this.internalTex3)),e.setParameter("colorParam",this.colorParam),e.setParameter("numParticles",this.numParticles),e.setParameter("numParticlesPot",this.numParticlesPot),e.setParameter("lifetime",this.lifetime),e.setParameter("rate",this.rate),e.setParameter("rateDiv",this.rate2-this.rate),e.setParameter("seed",this.seed),e.setParameter("scaleDivMult",this.scaleUMax[0]),e.setParameter("alphaDivMult",this.alphaUMax[0]),e.setParameter("radialSpeedDivMult",this.radialSpeedUMax[0]),e.setParameter("graphNumSamples",this.precision),e.setParameter("graphSampleSize",1/this.precision),e.setParameter("emitterScale",new Float32Array([1,1,1])),this.pack8&&(this._gpuUpdater._setInputBounds(),e.setParameter("inBoundsSize",this._gpuUpdater.inBoundsSizeUniform),e.setParameter("inBoundsCenter",this._gpuUpdater.inBoundsCenterUniform),e.setParameter("maxVel",this.maxVel)),this.wrap&&this.wrapBounds&&(this.wrapBoundsUniform[0]=this.wrapBounds.x,this.wrapBoundsUniform[1]=this.wrapBounds.y,this.wrapBoundsUniform[2]=this.wrapBounds.z,e.setParameter("wrapBounds",this.wrapBoundsUniform)),this.colorMap&&e.setParameter("colorMap",this.colorMap),this.lighting&&this.normalMap&&e.setParameter("normalMap",this.normalMap),this.depthSoftening>0&&e.setParameter("softening",1/(this.depthSoftening*this.depthSoftening*100)),this.stretch>0&&(e.cull=0),this._compParticleFaceParams()}_compParticleFaceParams(){let e,t;if(0===this.orientation)e=new Float32Array([1,0,0]),t=new Float32Array([0,0,1]);else{let n;if(1===this.orientation)n=this.particleNormal.normalize();else{n=(null===this.node?zu.IDENTITY:this.node.getWorldTransform()).transformVector(this.particleNormal).normalize()}const a=new Pu(1,0,0);1===Math.abs(a.dot(n))&&a.set(0,0,1);const i=(new Pu).cross(n,a).normalize();a.cross(i,n).normalize(),e=new Float32Array([a.x,a.y,a.z]),t=new Float32Array([i.x,i.y,i.z])}this.material.setParameter("faceTangent",e),this.material.setParameter("faceBinorm",t)}_allocate(e){const t=e*this.numParticleVerts,n=e*this.numParticleIndices;if(void 0===this.vertexBuffer||this.vertexBuffer.getNumVertices()!==t){if(this.useCpu){const e=[{semantic:"ATTR0",components:4,type:6},{semantic:"ATTR1",components:4,type:6},{semantic:"ATTR2",components:4,type:6},{semantic:"ATTR3",components:1,type:6},{semantic:"ATTR4",components:this.useMesh?4:2,type:6}],a=new hm(this.graphicsDevice,e);this.vertexBuffer=new lm(this.graphicsDevice,a,t,1),this.indexBuffer=new Tg(this.graphicsDevice,1,n)}else{const e=[{semantic:"ATTR0",components:4,type:6}];this.useMesh&&e.push({semantic:"ATTR1",components:2,type:6});const a=new hm(this.graphicsDevice,e);this.vertexBuffer=new lm(this.graphicsDevice,a,t,1),this.indexBuffer=new Tg(this.graphicsDevice,1,n)}const a=new Float32Array(this.vertexBuffer.lock());let i,s,r;if(this.useMesh){i=new Float32Array(this.mesh.vertexBuffer.lock()),s=i.length/this.mesh.vertexBuffer.numVertices;for(let e=0;e<this.mesh.vertexBuffer.format.elements.length;e++)if("TEXCOORD0"===this.mesh.vertexBuffer.format.elements[e].name){r=this.mesh.vertexBuffer.format.elements[e].offset/4;break}}for(let e=0;e<t;e++){const t=Math.floor(e/this.numParticleVerts);if(this.useMesh){const n=e%this.numParticleVerts;a[6*e]=i[n*s],a[6*e+1]=i[n*s+1],a[6*e+2]=i[n*s+2],a[6*e+3]=t,a[6*e+4]=i[n*s+r+0],a[6*e+5]=1-i[n*s+r+1]}else{const n=e%4;a[4*e]=JS[n][0],a[4*e+1]=JS[n][1],a[4*e+2]=0,a[4*e+3]=t}}this.useCpu&&(this.vbCPU=new Float32Array(a),this.vbOld=new Float32Array(this.vbCPU.length)),this.vertexBuffer.unlock(),this.useMesh&&this.mesh.vertexBuffer.unlock();let o=0;const l=new Uint16Array(this.indexBuffer.lock());this.useMesh&&(i=new Uint16Array(this.mesh.indexBuffer[0].lock()));for(let t=0;t<e;t++)if(this.useMesh)for(let e=0;e<this.numParticleIndices;e++)l[t*this.numParticleIndices+e]=i[e]+t*this.numParticleVerts;else{const e=4*t;l[o++]=e,l[o++]=e+1,l[o++]=e+2,l[o++]=e,l[o++]=e+2,l[o++]=e+3}this.indexBuffer.unlock(),this.useMesh&&this.mesh.indexBuffer[0].unlock()}}reset(){if(this.beenReset=!0,this.seed=Math.random(),this.material.setParameter("seed",this.seed),this.useCpu)for(let e=0;e<this.particleTexStart.length;e++)this.particleTex[e]=this.particleTexStart[e];else this._initializeTextures();this.resetWorldBounds(),this.resetTime();const e=this.loop;this.loop=!0,this.addTime(0,!1),this.loop=e,this.preWarm&&this.prewarm(this.lifetime)}prewarm(e){const t=e/this.lifetime,n=Math.min(Math.floor(t*this.precision),this.precision),a=e/n;for(let e=0;e<n;e++)this.addTime(a,!1)}resetTime(){this.endTime=function(e){const t=Math.max(e.rate,e.rate2)*e.numParticles+e.lifetime;return Date.now()+1e3*t}(this)}finishFrame(){this.useCpu&&this.vertexBuffer.unlock()}addTime(e,t){const n=this.graphicsDevice;if(this.simTimeTotal+=e,this.calculateWorldBounds(),this._isAnimated()){const e=this.animTilesParams;e[0]=1/this.animTilesX,e[1]=1/this.animTilesY;const t=this.animParams;t[0]=this.animStartFrame,t[1]=this.animNumFrames*this.animSpeed,t[2]=this.animNumFrames-1,t[3]=this.animNumAnimations-1;const n=this.animIndexParams;n[0]=this.animIndex,n[1]=this.randomizeAnimIndex}let a;this.scene&&this.camera!==this.scene._activeCamera&&(this.camera=this.scene._activeCamera,this.onChangeCamera()),0===this.emitterShape&&(oA[0]=0!==this.emitterExtents.x?this.emitterExtentsInner.x/this.emitterExtents.x:0,oA[1]=0!==this.emitterExtents.y?this.emitterExtentsInner.y/this.emitterExtents.y:0,oA[2]=0!==this.emitterExtents.z?this.emitterExtentsInner.z/this.emitterExtents.z:0,null===this.meshInstance.node?lA.setTRS(Pu.ZERO,Gu.IDENTITY,this.emitterExtents):lA.setTRS(Pu.ZERO,this.meshInstance.node.getRotation(),cA.copy(this.emitterExtents).mul(this.meshInstance.node.localScale)));const i=null===this.meshInstance.node?Pu.ONE:this.meshInstance.node.localScale;if(this.emitterScaleUniform[0]=i.x,this.emitterScaleUniform[1]=i.y,this.emitterScaleUniform[2]=i.z,this.material.setParameter("emitterScale",this.emitterScaleUniform),this.localSpace&&this.meshInstance.node&&(a=this.meshInstance.node.getPosition(),this.emitterPosUniform[0]=a.x,this.emitterPosUniform[1]=a.y,this.emitterPosUniform[2]=a.z,this.material.setParameter("emitterPos",this.emitterPosUniform)),this._compParticleFaceParams(),this.useCpu){const n=new Float32Array(this.vertexBuffer.lock());this._cpuUpdater.update(n,this.vbToSort,this.particleTex,lA,oA,a,e,t)}else this._gpuUpdater.update(n,lA,oA,e,t);this.loop||Date.now()>this.endTime&&(this.onFinished&&this.onFinished(),this.meshInstance.visible=!1),this.meshInstance&&(this.meshInstance.drawOrder=this.drawOrder)}_destroyResources(){this.particleTexIN&&(this.particleTexIN.destroy(),this.particleTexIN=null),this.particleTexOUT&&(this.particleTexOUT.destroy(),this.particleTexOUT=null),this.particleTexStart&&this.particleTexStart.destroy&&(this.particleTexStart.destroy(),this.particleTexStart=null),this.rtParticleTexIN&&(this.rtParticleTexIN.destroy(),this.rtParticleTexIN=null),this.rtParticleTexOUT&&(this.rtParticleTexOUT.destroy(),this.rtParticleTexOUT=null),this.internalTex0&&(this.internalTex0.destroy(),this.internalTex0=null),this.internalTex1&&(this.internalTex1.destroy(),this.internalTex1=null),this.internalTex2&&(this.internalTex2.destroy(),this.internalTex2=null),this.internalTex3&&(this.internalTex3.destroy(),this.internalTex3=null),this.colorParam&&(this.colorParam.destroy(),this.colorParam=null),this.vertexBuffer&&(this.vertexBuffer.destroy(),this.vertexBuffer=void 0),this.indexBuffer&&(this.indexBuffer.destroy(),this.indexBuffer=void 0),this.material&&(this.material.destroy(),this.material=null)}destroy(){this.camera=null,this._destroyResources()}}const wA=["emitterExtents","emitterRadius","emitterExtentsInner","emitterRadiusInner","loop","initialVelocity","animSpeed","normalMap","particleNormal"],xA=["numParticles","lifetime","rate","rate2","startAngle","startAngle2","lighting","halfLambert","intensity","wrap","wrapBounds","depthWrite","noFog","sort","stretch","alignToMotion","preWarm","emitterShape","animTilesX","animTilesY","animStartFrame","animNumFrames","animNumAnimations","animIndex","randomizeAnimIndex","animLoop","colorMap","localSpace","screenSpace","orientation"],CA=["scaleGraph","scaleGraph2","colorGraph","colorGraph2","alphaGraph","alphaGraph2","velocityGraph","velocityGraph2","localVelocityGraph","localVelocityGraph2","rotationSpeedGraph","rotationSpeedGraph2","radialSpeedGraph","radialSpeedGraph2"],TA=["colorMapAsset","normalMapAsset","meshAsset","renderAsset"];let EA;class SA extends Ux{constructor(e,t){super(e,t),this._requestedDepth=!1,this._drawOrder=0,this.on("set_colorMapAsset",this.onSetColorMapAsset,this),this.on("set_normalMapAsset",this.onSetNormalMapAsset,this),this.on("set_meshAsset",this.onSetMeshAsset,this),this.on("set_mesh",this.onSetMesh,this),this.on("set_renderAsset",this.onSetRenderAsset,this),this.on("set_loop",this.onSetLoop,this),this.on("set_blendType",this.onSetBlendType,this),this.on("set_depthSoftening",this.onSetDepthSoftening,this),this.on("set_layers",this.onSetLayers,this),wA.forEach((e=>{this.on(`set_${e}`,this.onSetSimpleProperty,this)})),xA.forEach((e=>{this.on(`set_${e}`,this.onSetComplexProperty,this)})),CA.forEach((e=>{this.on(`set_${e}`,this.onSetGraphProperty,this)}))}set drawOrder(e){this._drawOrder=e,this.emitter&&(this.emitter.drawOrder=e)}get drawOrder(){return this._drawOrder}addMeshInstanceToLayers(){if(this.emitter)for(let e=0;e<this.layers.length;e++){const t=this.system.app.scene.layers.getLayerById(this.layers[e]);t&&(t.addMeshInstances([this.emitter.meshInstance]),this.emitter._layer=t)}}removeMeshInstanceFromLayers(){if(this.emitter)for(let e=0;e<this.layers.length;e++){const t=this.system.app.scene.layers.getLayerById(this.layers[e]);t&&t.removeMeshInstances([this.emitter.meshInstance])}}onSetLayers(e,t,n){if(this.emitter){for(let e=0;e<t.length;e++){const n=this.system.app.scene.layers.getLayerById(t[e]);n&&n.removeMeshInstances([this.emitter.meshInstance])}if(this.enabled&&this.entity.enabled)for(let e=0;e<n.length;e++){const t=this.system.app.scene.layers.getLayerById(n[e]);t&&t.addMeshInstances([this.emitter.meshInstance])}}}onLayersChanged(e,t){this.addMeshInstanceToLayers(),e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this)}onLayerAdded(e){if(!this.emitter)return;this.layers.indexOf(e.id)<0||e.addMeshInstances([this.emitter.meshInstance])}onLayerRemoved(e){if(!this.emitter)return;this.layers.indexOf(e.id)<0||e.removeMeshInstances([this.emitter.meshInstance])}_bindColorMapAsset(e){if(e.on("load",this._onColorMapAssetLoad,this),e.on("unload",this._onColorMapAssetUnload,this),e.on("remove",this._onColorMapAssetRemove,this),e.on("change",this._onColorMapAssetChange,this),e.resource)this._onColorMapAssetLoad(e);else{if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(e)}}_unbindColorMapAsset(e){e.off("load",this._onColorMapAssetLoad,this),e.off("unload",this._onColorMapAssetUnload,this),e.off("remove",this._onColorMapAssetRemove,this),e.off("change",this._onColorMapAssetChange,this)}_onColorMapAssetLoad(e){this.colorMap=e.resource}_onColorMapAssetUnload(e){this.colorMap=null}_onColorMapAssetRemove(e){this._onColorMapAssetUnload(e)}_onColorMapAssetChange(e){}onSetColorMapAsset(e,t,n){const a=this.system.app.assets;if(t){const e=a.get(t);e&&this._unbindColorMapAsset(e)}if(n){n instanceof f_&&(this.data.colorMapAsset=n.id,n=n.id);const e=a.get(n);e?this._bindColorMapAsset(e):a.once("add:"+n,(e=>{this._bindColorMapAsset(e)}))}else this.colorMap=null}_bindNormalMapAsset(e){if(e.on("load",this._onNormalMapAssetLoad,this),e.on("unload",this._onNormalMapAssetUnload,this),e.on("remove",this._onNormalMapAssetRemove,this),e.on("change",this._onNormalMapAssetChange,this),e.resource)this._onNormalMapAssetLoad(e);else{if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(e)}}_unbindNormalMapAsset(e){e.off("load",this._onNormalMapAssetLoad,this),e.off("unload",this._onNormalMapAssetUnload,this),e.off("remove",this._onNormalMapAssetRemove,this),e.off("change",this._onNormalMapAssetChange,this)}_onNormalMapAssetLoad(e){this.normalMap=e.resource}_onNormalMapAssetUnload(e){this.normalMap=null}_onNormalMapAssetRemove(e){this._onNormalMapAssetUnload(e)}_onNormalMapAssetChange(e){}onSetNormalMapAsset(e,t,n){const a=this.system.app.assets;if(t){const e=a.get(t);e&&this._unbindNormalMapAsset(e)}if(n){n instanceof f_&&(this.data.normalMapAsset=n.id,n=n.id);const e=a.get(n);e?this._bindNormalMapAsset(e):a.once("add:"+n,(e=>{this._bindNormalMapAsset(e)}))}else this.normalMap=null}_bindMeshAsset(e){if(e.on("load",this._onMeshAssetLoad,this),e.on("unload",this._onMeshAssetUnload,this),e.on("remove",this._onMeshAssetRemove,this),e.on("change",this._onMeshAssetChange,this),e.resource)this._onMeshAssetLoad(e);else{if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(e)}}_unbindMeshAsset(e){e.off("load",this._onMeshAssetLoad,this),e.off("unload",this._onMeshAssetUnload,this),e.off("remove",this._onMeshAssetRemove,this),e.off("change",this._onMeshAssetChange,this)}_onMeshAssetLoad(e){this._onMeshChanged(e.resource)}_onMeshAssetUnload(e){this.mesh=null}_onMeshAssetRemove(e){this._onMeshAssetUnload(e)}_onMeshAssetChange(e){}onSetMeshAsset(e,t,n){const a=this.system.app.assets;if(t){const e=a.get(t);e&&this._unbindMeshAsset(e)}if(n){n instanceof f_&&(this.data.meshAsset=n.id,n=n.id);const e=a.get(n);e&&this._bindMeshAsset(e)}else this._onMeshChanged(null)}onSetMesh(e,t,n){!n||n instanceof f_||"number"==typeof n?this.meshAsset=n:this._onMeshChanged(n)}_onMeshChanged(e){!e||e instanceof iy||(e=e.meshInstances[0]?e.meshInstances[0].mesh:null),this.data.mesh=e,this.emitter&&(this.emitter.mesh=e,this.emitter.resetMaterial(),this.rebuild())}onSetRenderAsset(e,t,n){const a=this.system.app.assets;if(t){const e=a.get(t);e&&this._unbindRenderAsset(e)}if(n){n instanceof f_&&(this.data.renderAsset=n.id,n=n.id);const e=a.get(n);e&&this._bindRenderAsset(e)}else this._onRenderChanged(null)}_bindRenderAsset(e){if(e.on("load",this._onRenderAssetLoad,this),e.on("unload",this._onRenderAssetUnload,this),e.on("remove",this._onRenderAssetRemove,this),e.resource)this._onRenderAssetLoad(e);else{if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(e)}}_unbindRenderAsset(e){e.off("load",this._onRenderAssetLoad,this),e.off("unload",this._onRenderAssetUnload,this),e.off("remove",this._onRenderAssetRemove,this),e.resource&&e.resource.off("set:meshes",this._onRenderSetMeshes,this)}_onRenderAssetLoad(e){this._onRenderChanged(e.resource)}_onRenderAssetUnload(e){this._onRenderChanged(null)}_onRenderAssetRemove(e){this._onRenderAssetUnload(e)}_onRenderChanged(e){e?(e.off("set:meshes",this._onRenderSetMeshes,this),e.on("set:meshes",this._onRenderSetMeshes,this),e.meshes&&this._onRenderSetMeshes(e.meshes)):this._onMeshChanged(null)}_onRenderSetMeshes(e){this._onMeshChanged(e&&e[0])}onSetLoop(e,t,n){this.emitter&&(this.emitter[e]=n,this.emitter.resetTime())}onSetBlendType(e,t,n){this.emitter&&(this.emitter[e]=n,this.emitter.material.blendType=n,this.emitter.resetMaterial(),this.rebuild())}_requestDepth(){this._requestedDepth||(EA||(EA=this.system.app.scene.layers.getLayerById(1)),EA&&(EA.incrementCounter(),this._requestedDepth=!0))}_releaseDepth(){this._requestedDepth&&EA&&(EA.decrementCounter(),this._requestedDepth=!1)}onSetDepthSoftening(e,t,n){t!==n&&(n?(this.enabled&&this.entity.enabled&&this._requestDepth(),this.emitter&&(this.emitter[e]=n)):(this.enabled&&this.entity.enabled&&this._releaseDepth(),this.emitter&&(this.emitter[e]=n)),this.emitter&&(this.reset(),this.emitter.resetMaterial(),this.rebuild()))}onSetSimpleProperty(e,t,n){this.emitter&&(this.emitter[e]=n,this.emitter.resetMaterial())}onSetComplexProperty(e,t,n){this.emitter&&(this.emitter[e]=n,this.emitter.resetMaterial(),this.rebuild(),this.reset())}onSetGraphProperty(e,t,n){this.emitter&&(this.emitter[e]=n,this.emitter.rebuildGraphs(),this.emitter.resetMaterial())}onEnable(){const e=this.data;for(let t=0,n=TA.length;t<n;t++){let n=e[TA[t]];if(n){if(!(n instanceof f_)){if(!(parseInt(n,10)>=0))continue;n=this.system.app.assets.get(n)}n&&!n.resource&&this.system.app.assets.load(n)}}if(!this.emitter){let t=e.mesh;t instanceof iy||(t=null),this.emitter=new _A(this.system.app.graphicsDevice,{numParticles:e.numParticles,emitterExtents:e.emitterExtents,emitterExtentsInner:e.emitterExtentsInner,emitterRadius:e.emitterRadius,emitterRadiusInner:e.emitterRadiusInner,emitterShape:e.emitterShape,initialVelocity:e.initialVelocity,wrap:e.wrap,localSpace:e.localSpace,screenSpace:e.screenSpace,wrapBounds:e.wrapBounds,lifetime:e.lifetime,rate:e.rate,rate2:e.rate2,orientation:e.orientation,particleNormal:e.particleNormal,animTilesX:e.animTilesX,animTilesY:e.animTilesY,animStartFrame:e.animStartFrame,animNumFrames:e.animNumFrames,animNumAnimations:e.animNumAnimations,animIndex:e.animIndex,randomizeAnimIndex:e.randomizeAnimIndex,animSpeed:e.animSpeed,animLoop:e.animLoop,startAngle:e.startAngle,startAngle2:e.startAngle2,scaleGraph:e.scaleGraph,scaleGraph2:e.scaleGraph2,colorGraph:e.colorGraph,colorGraph2:e.colorGraph2,alphaGraph:e.alphaGraph,alphaGraph2:e.alphaGraph2,localVelocityGraph:e.localVelocityGraph,localVelocityGraph2:e.localVelocityGraph2,velocityGraph:e.velocityGraph,velocityGraph2:e.velocityGraph2,rotationSpeedGraph:e.rotationSpeedGraph,rotationSpeedGraph2:e.rotationSpeedGraph2,radialSpeedGraph:e.radialSpeedGraph,radialSpeedGraph2:e.radialSpeedGraph2,colorMap:e.colorMap,normalMap:e.normalMap,loop:e.loop,preWarm:e.preWarm,sort:e.sort,stretch:e.stretch,alignToMotion:e.alignToMotion,lighting:e.lighting,halfLambert:e.halfLambert,intensity:e.intensity,depthSoftening:e.depthSoftening,scene:this.system.app.scene,mesh:t,depthWrite:e.depthWrite,noFog:e.noFog,node:this.entity,blendType:e.blendType}),this.emitter.meshInstance.node=this.entity,this.emitter.drawOrder=this.drawOrder,e.autoPlay||(this.pause(),this.emitter.meshInstance.visible=!1)}this.emitter.colorMap&&this.addMeshInstanceToLayers(),this.system.app.scene.on("set:layers",this.onLayersChanged,this),this.system.app.scene.layers&&(this.system.app.scene.layers.on("add",this.onLayerAdded,this),this.system.app.scene.layers.on("remove",this.onLayerRemoved,this)),this.enabled&&this.entity.enabled&&e.depthSoftening&&this._requestDepth()}onDisable(){this.system.app.scene.off("set:layers",this.onLayersChanged,this),this.system.app.scene.layers&&(this.system.app.scene.layers.off("add",this.onLayerAdded,this),this.system.app.scene.layers.off("remove",this.onLayerRemoved,this)),this.emitter&&(this.removeMeshInstanceFromLayers(),this.data.depthSoftening&&this._releaseDepth(),this.emitter.camera=null)}onBeforeRemove(){this.enabled&&(this.enabled=!1),this.emitter&&(this.emitter.destroy(),this.emitter=null);for(let e=0;e<TA.length;e++){const t=TA[e];this.data[t]&&(this[t]=null)}this.off()}reset(){this.emitter&&this.emitter.reset()}stop(){this.emitter&&(this.emitter.loop=!1,this.emitter.resetTime(),this.emitter.addTime(0,!0))}pause(){this.data.paused=!0}unpause(){this.data.paused=!1}play(){this.data.paused=!1,this.emitter&&(this.emitter.meshInstance.visible=!0,this.emitter.loop=this.data.loop,this.emitter.resetTime())}isPlaying(){return!this.data.paused&&(!(!this.emitter||!this.emitter.loop)||Date.now()<=this.emitter.endTime)}rebuild(){const e=this.enabled;this.enabled=!1,this.emitter&&(this.emitter.rebuild(),this.emitter.meshInstance.node=this.entity),this.enabled=e}}class AA{constructor(){this.numParticles=1,this.rate=1,this.rate2=null,this.startAngle=0,this.startAngle2=null,this.lifetime=50,this.emitterExtents=new Pu,this.emitterExtentsInner=new Pu,this.emitterRadius=0,this.emitterRadiusInner=0,this.emitterShape=0,this.initialVelocity=0,this.wrapBounds=new Pu,this.localSpace=!1,this.screenSpace=!1,this.colorMap=null,this.colorMapAsset=null,this.normalMap=null,this.normalMapAsset=null,this.loop=!0,this.preWarm=!1,this.sort=0,this.mode=0,this.scene=null,this.lighting=!1,this.halfLambert=!1,this.intensity=1,this.stretch=0,this.alignToMotion=!1,this.depthSoftening=0,this.meshAsset=null,this.mesh=null,this.depthWrite=!1,this.noFog=!1,this.orientation=0,this.particleNormal=new Pu(0,1,0),this.animTilesX=1,this.animTilesY=1,this.animStartFrame=0,this.animNumFrames=1,this.animNumAnimations=1,this.animIndex=0,this.randomizeAnimIndex=!1,this.animSpeed=1,this.animLoop=!0,this.scaleGraph=null,this.scaleGraph2=null,this.colorGraph=null,this.colorGraph2=null,this.alphaGraph=null,this.alphaGraph2=null,this.localVelocityGraph=null,this.localVelocityGraph2=null,this.velocityGraph=null,this.velocityGraph2=null,this.rotationSpeedGraph=null,this.rotationSpeedGraph2=null,this.radialSpeedGraph=null,this.radialSpeedGraph2=null,this.blendType=2,this.enabled=!0,this.paused=!1,this.autoPlay=!0,this.layers=[0]}}const MA=["enabled","autoPlay","numParticles","lifetime","rate","rate2","startAngle","startAngle2","loop","preWarm","lighting","halfLambert","intensity","depthWrite","noFog","depthSoftening","sort","blendType","stretch","alignToMotion","emitterShape","emitterExtents","emitterExtentsInner","emitterRadius","emitterRadiusInner","initialVelocity","wrap","wrapBounds","localSpace","screenSpace","colorMapAsset","normalMapAsset","mesh","meshAsset","renderAsset","orientation","particleNormal","localVelocityGraph","localVelocityGraph2","velocityGraph","velocityGraph2","rotationSpeedGraph","rotationSpeedGraph2","radialSpeedGraph","radialSpeedGraph2","scaleGraph","scaleGraph2","colorGraph","colorGraph2","alphaGraph","alphaGraph2","colorMap","normalMap","animTilesX","animTilesY","animStartFrame","animNumFrames","animNumAnimations","animIndex","randomizeAnimIndex","animSpeed","animLoop","layers"];class LA extends AC{constructor(e){super(e),this.id="particlesystem",this.ComponentType=SA,this.DataType=AA,this.schema=MA,this.propertyTypes={emitterExtents:"vec3",emitterExtentsInner:"vec3",particleNormal:"vec3",wrapBounds:"vec3",localVelocityGraph:"curveset",localVelocityGraph2:"curveset",velocityGraph:"curveset",velocityGraph2:"curveset",colorGraph:"curveset",colorGraph2:"curveset",alphaGraph:"curve",alphaGraph2:"curve",rotationSpeedGraph:"curve",rotationSpeedGraph2:"curve",radialSpeedGraph:"curve",radialSpeedGraph2:"curve",scaleGraph:"curve",scaleGraph2:"curve"},this.on("beforeremove",this.onBeforeRemove,this),this.app.systems.on("update",this.onUpdate,this)}initializeComponentData(e,t,n){const a={};n=[];const i=this.propertyTypes;(t.mesh instanceof f_||"number"==typeof t.mesh)&&(t.meshAsset=t.mesh,delete t.mesh);for(const e in t){if(t.hasOwnProperty(e)&&(n.push(e),a[e]=t[e]),"vec3"===i[e])Array.isArray(a[e])&&(a[e]=new Pu(a[e][0],a[e][1],a[e][2]));else if("curve"===i[e]){if(!(a[e]instanceof Ru)){const t=a[e].type;a[e]=new Ru(a[e].keys),a[e].type=t}}else if("curveset"===i[e]&&!(a[e]instanceof Iu)){const t=a[e].type;a[e]=new Iu(a[e].keys),a[e].type=t}a.layers&&Array.isArray(a.layers)&&(a.layers=a.layers.slice(0))}super.initializeComponentData(e,a,n)}cloneComponent(e,t){const n=e.particlesystem.data,a=this.schema,i={};for(let e=0,t=a.length;e<t;e++){const t=a[e];let s=n[t];s instanceof Pu||s instanceof Ru||s instanceof Iu?(s=s.clone(),i[t]=s):"layers"===t?i.layers=n.layers.slice(0):null!=s&&(i[t]=s)}return this.addComponent(t,i)}onUpdate(e){const t=this.store;let n;const a=this.app.stats.particles;for(const i in t)if(t.hasOwnProperty(i)){const s=t[i],r=s.entity,o=s.data;if(o.enabled&&r.enabled){const t=r.particlesystem.emitter;if(!t.meshInstance.visible)continue;if(t.lighting){const e=o.layers;let n;for(let a=0;a<e.length;a++){const i=this.app.scene.layers.getLayerById(e[a]);if(!i)continue;i._lightCube||(i._lightCube=new Float32Array(18)),n=i._lightCube;for(let e=0;e<6;e++)n[3*e]=this.app.scene.ambientLight.r,n[3*e+1]=this.app.scene.ambientLight.g,n[3*e+2]=this.app.scene.ambientLight.b;const s=i._splitLights[0];for(let e=0;e<s.length;e++)for(let a=0;a<6;a++){const i=Math.max(t.lightCubeDir[a].dot(s[e]._direction),0)*s[e]._intensity;n[3*a]+=s[e]._color.r*i,n[3*a+1]+=s[e]._color.g*i,n[3*a+2]+=s[e]._color.b*i}}t.constantLightCube.setValue(n)}if(!o.paused){if(t.simTime+=e,t.simTime>t.fixedTimeStep&&(n=Math.floor(t.simTime/t.fixedTimeStep),t.simTime-=n*t.fixedTimeStep),n){n=Math.min(n,t.maxSubSteps);for(let e=0;e<n;e++)t.addTime(t.fixedTimeStep,!1);a._updatesPerFrame+=n,a._frameTime+=t._addTimeTime,t._addTimeTime=0}t.finishFrame()}}}}onBeforeRemove(e,t){t.onBeforeRemove()}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this)}}Ux._buildAccessors(SA.prototype,MA);class RA{constructor(e,t){this._constructor=e,this._pool=[],this._count=0,this._resize(t)}_resize(e){if(e>this._pool.length)for(let t=this._pool.length;t<e;t++)this._pool[t]=new this._constructor}allocate(){return this._count>=this._pool.length&&this._resize(2*this._pool.length),this._pool[this._count++]}freeAll(){this._count=0}}let IA,PA,kA,DA,OA,FA,NA;class VA extends Ux{constructor(e,t){super(e,t),this._angularDamping=0,this._angularFactor=new Pu(1,1,1),this._angularVelocity=new Pu,this._body=null,this._friction=.5,this._group=2,this._linearDamping=0,this._linearFactor=new Pu(1,1,1),this._linearVelocity=new Pu,this._mask=65533,this._mass=1,this._restitution=0,this._rollingFriction=0,this._simulationEnabled=!1,this._type="static"}static onLibraryLoaded(){"undefined"==typeof Ammo||IA||(IA=new Ammo.btTransform,PA=new Ammo.btVector3,kA=new Ammo.btVector3,DA=new Ammo.btQuaternion,OA=new Ammo.btVector3(0,0,0))}set angularDamping(e){this._angularDamping!==e&&(this._angularDamping=e,this._body&&this._body.setDamping(this._linearDamping,e))}get angularDamping(){return this._angularDamping}set angularFactor(e){this._angularFactor.equals(e)||(this._angularFactor.copy(e),this._body&&"dynamic"===this._type&&(PA.setValue(e.x,e.y,e.z),this._body.setAngularFactor(PA)))}get angularFactor(){return this._angularFactor}set angularVelocity(e){this._body&&"dynamic"===this._type&&(this._body.activate(),PA.setValue(e.x,e.y,e.z),this._body.setAngularVelocity(PA),this._angularVelocity.copy(e))}get angularVelocity(){if(this._body&&"dynamic"===this._type){const e=this._body.getAngularVelocity();this._angularVelocity.set(e.x(),e.y(),e.z())}return this._angularVelocity}set body(e){this._body!==e&&(this._body=e,e&&this._simulationEnabled&&e.activate())}get body(){return this._body}set friction(e){this._friction!==e&&(this._friction=e,this._body&&this._body.setFriction(e))}get friction(){return this._friction}set group(e){this._group!==e&&(this._group=e,this.enabled&&this.entity.enabled&&(this.disableSimulation(),this.enableSimulation()))}get group(){return this._group}set linearDamping(e){this._linearDamping!==e&&(this._linearDamping=e,this._body&&this._body.setDamping(e,this._angularDamping))}get linearDamping(){return this._linearDamping}set linearFactor(e){this._linearFactor.equals(e)||(this._linearFactor.copy(e),this._body&&"dynamic"===this._type&&(PA.setValue(e.x,e.y,e.z),this._body.setLinearFactor(PA)))}get linearFactor(){return this._linearFactor}set linearVelocity(e){this._body&&"dynamic"===this._type&&(this._body.activate(),PA.setValue(e.x,e.y,e.z),this._body.setLinearVelocity(PA),this._linearVelocity.copy(e))}get linearVelocity(){if(this._body&&"dynamic"===this._type){const e=this._body.getLinearVelocity();this._linearVelocity.set(e.x(),e.y(),e.z())}return this._linearVelocity}set mask(e){this._mask!==e&&(this._mask=e,this.enabled&&this.entity.enabled&&(this.disableSimulation(),this.enableSimulation()))}get mask(){return this._mask}set mass(e){if(this._mass!==e&&(this._mass=e,this._body&&"dynamic"===this._type)){const t=this.enabled&&this.entity.enabled;t&&this.disableSimulation(),this._body.getCollisionShape().calculateLocalInertia(e,PA),this._body.setMassProps(e,PA),this._body.updateInertiaTensor(),t&&this.enableSimulation()}}get mass(){return this._mass}set restitution(e){this._restitution!==e&&(this._restitution=e,this._body&&this._body.setRestitution(e))}get restitution(){return this._restitution}set rollingFriction(e){this._rollingFriction!==e&&(this._rollingFriction=e,this._body&&this._body.setRollingFriction(e))}get rollingFriction(){return this._rollingFriction}set type(e){if(this._type!==e){switch(this._type=e,this.disableSimulation(),e){case"dynamic":this._group=1,this._mask=65535;break;case"kinematic":this._group=4,this._mask=65535;break;default:this._group=2,this._mask=65533}this.createBody()}}get type(){return this._type}createBody(){const e=this.entity;let t;if(e.collision&&(t=e.collision.shape,e.trigger&&(e.trigger.destroy(),delete e.trigger)),t){this._body&&this.system.onRemove(e,this);const n="dynamic"===this._type?this._mass:0;this._getEntityTransform(IA);const a=this.system.createBody(n,t,IA);if(a.setRestitution(this._restitution),a.setFriction(this._friction),a.setRollingFriction(this._rollingFriction),a.setDamping(this._linearDamping,this._angularDamping),"dynamic"===this._type){const e=this._linearFactor;PA.setValue(e.x,e.y,e.z),a.setLinearFactor(PA);const t=this._angularFactor;PA.setValue(t.x,t.y,t.z),a.setAngularFactor(PA)}else"kinematic"===this._type&&(a.setCollisionFlags(2|a.getCollisionFlags()),a.setActivationState(4));a.entity=e,this.body=a,this.enabled&&e.enabled&&this.enableSimulation()}}isActive(){return!!this._body&&this._body.isActive()}activate(){this._body&&this._body.activate()}enableSimulation(){const e=this.entity;if(e.collision&&e.collision.enabled&&!this._simulationEnabled){const t=this._body;if(t){switch(this.system.addBody(t,this._group,this._mask),this._type){case"dynamic":this.system._dynamic.push(this),t.forceActivationState(1),this.syncEntityToBody();break;case"kinematic":this.system._kinematic.push(this),t.forceActivationState(4);break;case"static":t.forceActivationState(1),this.syncEntityToBody()}"compound"===e.collision.type&&this.system._compounds.push(e.collision),t.activate(),this._simulationEnabled=!0}}}disableSimulation(){const e=this._body;if(e&&this._simulationEnabled){const t=this.system;let n=t._compounds.indexOf(this.entity.collision);n>-1&&t._compounds.splice(n,1),n=t._dynamic.indexOf(this),n>-1&&t._dynamic.splice(n,1),n=t._kinematic.indexOf(this),n>-1&&t._kinematic.splice(n,1),t.removeBody(e),e.forceActivationState(5),this._simulationEnabled=!1}}applyForce(){let e,t,n,a,i,s;switch(arguments.length){case 1:e=arguments[0].x,t=arguments[0].y,n=arguments[0].z;break;case 2:e=arguments[0].x,t=arguments[0].y,n=arguments[0].z,a=arguments[1].x,i=arguments[1].y,s=arguments[1].z;break;case 3:e=arguments[0],t=arguments[1],n=arguments[2];break;case 6:e=arguments[0],t=arguments[1],n=arguments[2],a=arguments[3],i=arguments[4],s=arguments[5]}const r=this._body;r&&(r.activate(),PA.setValue(e,t,n),void 0!==a?(kA.setValue(a,i,s),r.applyForce(PA,kA)):r.applyForce(PA,OA))}applyTorque(){let e,t,n;switch(arguments.length){case 1:e=arguments[0].x,t=arguments[0].y,n=arguments[0].z;break;case 3:e=arguments[0],t=arguments[1],n=arguments[2];break;default:return}const a=this._body;a&&(a.activate(),PA.setValue(e,t,n),a.applyTorque(PA))}applyImpulse(){let e,t,n,a,i,s;switch(arguments.length){case 1:e=arguments[0].x,t=arguments[0].y,n=arguments[0].z;break;case 2:e=arguments[0].x,t=arguments[0].y,n=arguments[0].z,a=arguments[1].x,i=arguments[1].y,s=arguments[1].z;break;case 3:e=arguments[0],t=arguments[1],n=arguments[2];break;case 6:e=arguments[0],t=arguments[1],n=arguments[2],a=arguments[3],i=arguments[4],s=arguments[5];break;default:return}const r=this._body;r&&(r.activate(),PA.setValue(e,t,n),void 0!==a?(kA.setValue(a,i,s),r.applyImpulse(PA,kA)):r.applyImpulse(PA,OA))}applyTorqueImpulse(){let e,t,n;switch(arguments.length){case 1:e=arguments[0].x,t=arguments[0].y,n=arguments[0].z;break;case 3:e=arguments[0],t=arguments[1],n=arguments[2];break;default:return}const a=this._body;a&&(a.activate(),PA.setValue(e,t,n),a.applyTorqueImpulse(PA))}isStatic(){return"static"===this._type}isStaticOrKinematic(){return"static"===this._type||"kinematic"===this._type}isKinematic(){return"kinematic"===this._type}_getEntityTransform(e){const t=this.entity,n=t.getPosition(),a=t.getRotation();PA.setValue(n.x,n.y,n.z),DA.setValue(a.x,a.y,a.z,a.w),e.setOrigin(PA),e.setRotation(DA)}syncEntityToBody(){const e=this._body;if(e){if(this._getEntityTransform(IA),e.setWorldTransform(IA),"kinematic"===this._type){const t=e.getMotionState();t&&t.setWorldTransform(IA)}e.activate()}}_updateDynamic(){const e=this._body;if(e.isActive()){const t=e.getMotionState();if(t){t.getWorldTransform(IA);const e=IA.getOrigin(),n=IA.getRotation();this.entity.setPosition(e.x(),e.y(),e.z()),this.entity.setRotation(n.x(),n.y(),n.z(),n.w())}}}_updateKinematic(){const e=this._body.getMotionState();e&&(this._getEntityTransform(IA),e.setWorldTransform(IA))}teleport(){arguments.length<3?(arguments[0]&&this.entity.setPosition(arguments[0]),arguments[1]&&(arguments[1]instanceof Gu?this.entity.setRotation(arguments[1]):this.entity.setEulerAngles(arguments[1]))):(6===arguments.length&&this.entity.setEulerAngles(arguments[3],arguments[4],arguments[5]),this.entity.setPosition(arguments[0],arguments[1],arguments[2])),this.syncEntityToBody()}onEnable(){this._body||this.createBody(),this.enableSimulation()}onDisable(){this.disableSimulation()}}class BA{constructor(){this.enabled=!0}}class UA{constructor(e,t,n){this.entity=e,this.point=t,this.normal=n}}class zA{constructor(e,t,n){0===arguments.length?(this.a=null,this.b=null,this.impulse=0,this.localPointA=new Pu,this.localPointB=new Pu,this.pointA=new Pu,this.pointB=new Pu,this.normal=new Pu):(this.a=e,this.b=t,this.impulse=n.impulse,this.localPointA=n.localPoint,this.localPointB=n.localPointOther,this.pointA=n.point,this.pointB=n.pointOther,this.normal=n.normal)}}class GA{constructor(e=new Pu,t=new Pu,n=new Pu,a=new Pu,i=new Pu,s=0){this.localPoint=e,this.localPointOther=t,this.point=n,this.pointOther=a,this.normal=i,this.impulse=s}}class HA{constructor(e,t){this.other=e,this.contacts=t}}const WA=["enabled"];class jA extends AC{constructor(e){super(e),this.maxSubSteps=10,this.fixedTimeStep=1/60,this.gravity=new Pu(0,-9.81,0),this._dynamic=[],this._kinematic=[],this._triggers=[],this._compounds=[],this.id="rigidbody",this._stats=e.stats.frame,this.ComponentType=VA,this.DataType=BA,this.contactPointPool=null,this.contactResultPool=null,this.singleContactResultPool=null,this.schema=WA,this.collisions={},this.frameCollisions={},this.on("beforeremove",this.onBeforeRemove,this),this.on("remove",this.onRemove,this)}onLibraryLoaded(){if("undefined"!=typeof Ammo){if(this.collisionConfiguration=new Ammo.btDefaultCollisionConfiguration,this.dispatcher=new Ammo.btCollisionDispatcher(this.collisionConfiguration),this.overlappingPairCache=new Ammo.btDbvtBroadphase,this.solver=new Ammo.btSequentialImpulseConstraintSolver,this.dynamicsWorld=new Ammo.btDiscreteDynamicsWorld(this.dispatcher,this.overlappingPairCache,this.solver,this.collisionConfiguration),this.dynamicsWorld.setInternalTickCallback){const e=Ammo.addFunction(this._checkForCollisions.bind(this),"vif");this.dynamicsWorld.setInternalTickCallback(e)}FA=new Ammo.btVector3,NA=new Ammo.btVector3,VA.onLibraryLoaded(),this.contactPointPool=new RA(GA,1),this.contactResultPool=new RA(HA,1),this.singleContactResultPool=new RA(zA,1),this.app.systems.on("update",this.onUpdate,this)}else this.app.systems.off("update",this.onUpdate,this)}initializeComponentData(e,t,n){const a=["mass","linearDamping","angularDamping","linearFactor","angularFactor","friction","rollingFriction","restitution","type","group","mask"];for(const n of a)if(t.hasOwnProperty(n)){const a=t[n];Array.isArray(a)?e[n]=new Pu(a[0],a[1],a[2]):e[n]=a}super.initializeComponentData(e,t,["enabled"])}cloneComponent(e,t){const n=e.rigidbody,a={enabled:n.enabled,mass:n.mass,linearDamping:n.linearDamping,angularDamping:n.angularDamping,linearFactor:[n.linearFactor.x,n.linearFactor.y,n.linearFactor.z],angularFactor:[n.angularFactor.x,n.angularFactor.y,n.angularFactor.z],friction:n.friction,rollingFriction:n.rollingFriction,restitution:n.restitution,type:n.type,group:n.group,mask:n.mask};return this.addComponent(t,a)}onBeforeRemove(e,t){t.enabled&&(t.enabled=!1)}onRemove(e,t){const n=t.body;n&&(this.removeBody(n),this.destroyBody(n),t.body=null)}addBody(e,t,n){void 0!==t&&void 0!==n?this.dynamicsWorld.addRigidBody(e,t,n):this.dynamicsWorld.addRigidBody(e)}removeBody(e){this.dynamicsWorld.removeRigidBody(e)}createBody(e,t,n){const a=new Ammo.btVector3(0,0,0);0!==e&&t.calculateLocalInertia(e,a);const i=new Ammo.btDefaultMotionState(n),s=new Ammo.btRigidBodyConstructionInfo(e,i,t,a),r=new Ammo.btRigidBody(s);return Ammo.destroy(s),Ammo.destroy(a),r}destroyBody(e){const t=e.getMotionState();t&&Ammo.destroy(t),Ammo.destroy(e)}raycastFirst(e,t){let n=null;FA.setValue(e.x,e.y,e.z),NA.setValue(t.x,t.y,t.z);const a=new Ammo.ClosestRayResultCallback(FA,NA);if(this.dynamicsWorld.rayTest(FA,NA,a),a.hasHit()){const e=a.get_m_collisionObject(),t=Ammo.castObject(e,Ammo.btRigidBody);if(t){const e=a.get_m_hitPointWorld(),i=a.get_m_hitNormalWorld();if(n=new UA(t.entity,new Pu(e.x(),e.y(),e.z()),new Pu(i.x(),i.y(),i.z())),arguments.length>2){(0,arguments[2])(n)}}}return Ammo.destroy(a),n}raycastAll(e,t){const n=[];FA.setValue(e.x,e.y,e.z),NA.setValue(t.x,t.y,t.z);const a=new Ammo.AllHitsRayResultCallback(FA,NA);if(this.dynamicsWorld.rayTest(FA,NA,a),a.hasHit()){const e=a.get_m_collisionObjects(),t=a.get_m_hitPointWorld(),i=a.get_m_hitNormalWorld(),s=e.size();for(let a=0;a<s;a++){const s=Ammo.castObject(e.at(a),Ammo.btRigidBody);if(s){const e=t.at(a),r=i.at(a),o=new UA(s.entity,new Pu(e.x(),e.y(),e.z()),new Pu(r.x(),r.y(),r.z()));n.push(o)}}}return Ammo.destroy(a),n}_storeCollision(e,t){let n=!1;const a=e.getGuid();return this.collisions[a]=this.collisions[a]||{others:[],entity:e},this.collisions[a].others.indexOf(t)<0&&(this.collisions[a].others.push(t),n=!0),this.frameCollisions[a]=this.frameCollisions[a]||{others:[],entity:e},this.frameCollisions[a].others.push(t),n}_createContactPointFromAmmo(e){const t=e.get_m_localPointA(),n=e.get_m_localPointB(),a=e.getPositionWorldOnA(),i=e.getPositionWorldOnB(),s=e.get_m_normalWorldOnB(),r=this.contactPointPool.allocate();return r.localPoint.set(t.x(),t.y(),t.z()),r.localPointOther.set(n.x(),n.y(),n.z()),r.point.set(a.x(),a.y(),a.z()),r.pointOther.set(i.x(),i.y(),i.z()),r.normal.set(s.x(),s.y(),s.z()),r.impulse=e.getAppliedImpulse(),r}_createReverseContactPointFromAmmo(e){const t=e.get_m_localPointA(),n=e.get_m_localPointB(),a=e.getPositionWorldOnA(),i=e.getPositionWorldOnB(),s=e.get_m_normalWorldOnB(),r=this.contactPointPool.allocate();return r.localPointOther.set(t.x(),t.y(),t.z()),r.localPoint.set(n.x(),n.y(),n.z()),r.pointOther.set(a.x(),a.y(),a.z()),r.point.set(i.x(),i.y(),i.z()),r.normal.set(s.x(),s.y(),s.z()),r.impulse=e.getAppliedImpulse(),r}_createSingleContactResult(e,t,n){const a=this.singleContactResultPool.allocate();return a.a=e,a.b=t,a.localPointA=n.localPoint,a.localPointB=n.localPointOther,a.pointA=n.point,a.pointB=n.pointOther,a.normal=n.normal,a.impulse=n.impulse,a}_createContactResult(e,t){const n=this.contactResultPool.allocate();return n.other=e,n.contacts=t,n}_cleanOldCollisions(){for(const e in this.collisions)if(this.collisions.hasOwnProperty(e)){const t=this.frameCollisions[e],n=this.collisions[e],a=n.entity,i=a.collision,s=a.rigidbody,r=n.others;let o=r.length;for(;o--;){const e=r[o];(!t||t.others.indexOf(e)<0)&&(r.splice(o,1),a.trigger?(i&&i.fire("triggerleave",e),e.rigidbody&&e.rigidbody.fire("triggerleave",a)):e.trigger||(s&&s.fire("collisionend",e),i&&i.fire("collisionend",e)))}0===r.length&&delete this.collisions[e]}}_hasContactEvent(e){const t=e.collision;if(t&&(t.hasEvent("collisionstart")||t.hasEvent("collisionend")||t.hasEvent("contact")))return!0;const n=e.rigidbody;return n&&(n.hasEvent("collisionstart")||n.hasEvent("collisionend")||n.hasEvent("contact"))}_checkForCollisions(e,t){const n=Ammo.wrapPointer(e,Ammo.btDynamicsWorld).getDispatcher(),a=n.getNumManifolds();this.frameCollisions={};for(let e=0;e<a;e++){const t=n.getManifoldByIndexInternal(e),a=t.getBody0(),i=t.getBody1(),s=Ammo.castObject(a,Ammo.btRigidBody),r=Ammo.castObject(i,Ammo.btRigidBody),o=s.entity,l=r.entity;if(!o||!l)continue;const c=s.getCollisionFlags(),h=r.getCollisionFlags(),d=t.getNumContacts(),p=[],u=[];let m;if(d>0)if(4&c||4&h){const e=o.collision&&(o.collision.hasEvent("triggerenter")||o.collision.hasEvent("triggerleave")),t=l.collision&&(l.collision.hasEvent("triggerenter")||l.collision.hasEvent("triggerleave")),n=o.rigidbody&&(o.rigidbody.hasEvent("triggerenter")||o.rigidbody.hasEvent("triggerleave")),a=l.rigidbody&&(l.rigidbody.hasEvent("triggerenter")||l.rigidbody.hasEvent("triggerleave"));e&&(m=this._storeCollision(o,l),!m||4&h||o.collision.fire("triggerenter",l)),t&&(m=this._storeCollision(l,o),!m||4&c||l.collision.fire("triggerenter",o)),n&&(m||(m=this._storeCollision(l,o)),m&&o.rigidbody.fire("triggerenter",l)),a&&(m||(m=this._storeCollision(o,l)),m&&l.rigidbody.fire("triggerenter",o))}else{const e=this._hasContactEvent(o),n=this._hasContactEvent(l),a=this.hasEvent("contact");if(a||e||n){for(let i=0;i<d;i++){const s=t.getContactPoint(i),r=this._createContactPointFromAmmo(s);if(e||n){p.push(r);const e=this._createReverseContactPointFromAmmo(s);u.push(e)}if(a){const e=this._createSingleContactResult(o,l,r);this.fire("contact",e)}}if(e){const e=this._createContactResult(l,p);m=this._storeCollision(o,l),o.collision&&(o.collision.fire("contact",e),m&&o.collision.fire("collisionstart",e)),o.rigidbody&&(o.rigidbody.fire("contact",e),m&&o.rigidbody.fire("collisionstart",e))}if(n){const e=this._createContactResult(o,u);m=this._storeCollision(l,o),l.collision&&(l.collision.fire("contact",e),m&&l.collision.fire("collisionstart",e)),l.rigidbody&&(l.rigidbody.fire("contact",e),m&&l.rigidbody.fire("collisionstart",e))}}}}this._cleanOldCollisions(),this.contactPointPool.freeAll(),this.contactResultPool.freeAll(),this.singleContactResultPool.freeAll()}onUpdate(e){let t,n;const a=this.dynamicsWorld.getGravity();a.x()===this.gravity.x&&a.y()===this.gravity.y&&a.z()===this.gravity.z||(a.setValue(this.gravity.x,this.gravity.y,this.gravity.z),this.dynamicsWorld.setGravity(a));const i=this._triggers;for(t=0,n=i.length;t<n;t++)i[t].updateTransform();const s=this._compounds;for(t=0,n=s.length;t<n;t++)s[t]._updateCompound();const r=this._kinematic;for(t=0,n=r.length;t<n;t++)r[t]._updateKinematic();this.dynamicsWorld.stepSimulation(e,this.maxSubSteps,this.fixedTimeStep);const o=this._dynamic;for(t=0,n=o.length;t<n;t++)o[t]._updateDynamic();this.dynamicsWorld.setInternalTickCallback||this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld),e)}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this),"undefined"!=typeof Ammo&&(Ammo.destroy(this.dynamicsWorld),Ammo.destroy(this.solver),Ammo.destroy(this.overlappingPairCache),Ammo.destroy(this.dispatcher),Ammo.destroy(this.collisionConfiguration),this.dynamicsWorld=null,this.solver=null,this.overlappingPairCache=null,this.dispatcher=null,this.collisionConfiguration=null)}}Ux._buildAccessors(VA.prototype,WA);const XA=new zu;class YA extends Ux{constructor(e,t){super(e,t),this._resolution=new Du(640,320),this._referenceResolution=new Du(640,320),this._scaleMode="none",this.scale=1,this._scaleBlend=.5,this._priority=0,this._screenSpace=!1,this.cull=this._screenSpace,this._screenMatrix=new zu,this._elements=new Set,e.app.graphicsDevice.on("resizecanvas",this._onResize,this)}syncDrawOrder(){this.system.queueDrawOrderSync(this.entity.getGuid(),this._processDrawOrderSync,this)}_recurseDrawOrderSync(e,t){if(!(e instanceof KM))return t;if(e.element){const n=e.element.drawOrder;e.element.drawOrder=t++,e.element._batchGroupId>=0&&n!==e.element.drawOrder&&this.system.app.batcher.markGroupDirty(e.element._batchGroupId)}e.particlesystem&&(e.particlesystem.drawOrder=t++);const n=e.children;for(let e=0;e<n.length;e++)t=this._recurseDrawOrderSync(n[e],t);return t}_processDrawOrderSync(){this._recurseDrawOrderSync(this.entity,1),this.fire("syncdraworder")}_calcProjectionMatrix(){const e=this._resolution.x/this.scale,t=this._resolution.y/this.scale,n=e,a=-t;this._screenMatrix.setOrtho(0,n,a,0,1,-1),this._screenSpace||(XA.setScale(.5*e,.5*t,1),this._screenMatrix.mul2(XA,this._screenMatrix))}_updateScale(){this.scale=this._calcScale(this._resolution,this.referenceResolution)}_calcScale(e,t){const n=Math.log2(e.x/t.x),a=Math.log2(e.y/t.y);return Math.pow(2,n*(1-this._scaleBlend)+a*this._scaleBlend)}_onResize(e,t){this._screenSpace&&(this._resolution.set(e,t),this.resolution=this._resolution)}_bindElement(e){this._elements.add(e)}_unbindElement(e){this._elements.delete(e)}onRemove(){this.system.app.graphicsDevice.off("resizecanvas",this._onResize,this),this.fire("remove"),this._elements.forEach((e=>e._onScreenRemove())),this._elements.clear(),this.off()}set resolution(e){this._screenSpace?this._resolution.set(this.system.app.graphicsDevice.width,this.system.app.graphicsDevice.height):this._resolution.set(e.x,e.y),this._updateScale(),this._calcProjectionMatrix(),this.entity._dirtyLocal||this.entity._dirtifyLocal(),this.fire("set:resolution",this._resolution),this._elements.forEach((e=>e._onScreenResize(this._resolution)))}get resolution(){return this._resolution}set referenceResolution(e){this._referenceResolution.set(e.x,e.y),this._updateScale(),this._calcProjectionMatrix(),this.entity._dirtyLocal||this.entity._dirtifyLocal(),this.fire("set:referenceresolution",this._resolution),this._elements.forEach((e=>e._onScreenResize(this._resolution)))}get referenceResolution(){return"none"===this._scaleMode?this._resolution:this._referenceResolution}set screenSpace(e){this._screenSpace=e,this._screenSpace&&this._resolution.set(this.system.app.graphicsDevice.width,this.system.app.graphicsDevice.height),this.resolution=this._resolution,this.entity._dirtyLocal||this.entity._dirtifyLocal(),this.fire("set:screenspace",this._screenSpace),this._elements.forEach((e=>e._onScreenSpaceChange()))}get screenSpace(){return this._screenSpace}set scaleMode(e){"none"!==e&&"blend"!==e&&(e="none"),this._screenSpace||"none"===e||(e="none"),this._scaleMode=e,this.resolution=this._resolution,this.fire("set:scalemode",this._scaleMode)}get scaleMode(){return this._scaleMode}set scaleBlend(e){this._scaleBlend=e,this._updateScale(),this._calcProjectionMatrix(),this.entity._dirtyLocal||this.entity._dirtifyLocal(),this.fire("set:scaleblend",this._scaleBlend),this._elements.forEach((e=>e._onScreenResize(this._resolution)))}get scaleBlend(){return this._scaleBlend}set priority(e){e>255&&(e=255),this._priority=e}get priority(){return this._priority}}class qA{constructor(){this.enabled=!0}}const KA=["enabled"];class ZA extends AC{constructor(e){super(e),this.id="screen",this.ComponentType=YA,this.DataType=qA,this.schema=KA,this.windowResolution=new Du,this._drawOrderSyncQueue=new bu,this.app.graphicsDevice.on("resizecanvas",this._onResize,this),this.app.systems.on("update",this._onUpdate,this),this.on("beforeremove",this.onRemoveComponent,this)}initializeComponentData(e,t,n){void 0!==t.priority&&(e.priority=t.priority),void 0!==t.screenSpace&&(e.screenSpace=t.screenSpace),e.cull=e.screenSpace,void 0!==t.scaleMode&&(e.scaleMode=t.scaleMode),void 0!==t.scaleBlend&&(e.scaleBlend=t.scaleBlend),void 0!==t.resolution&&(t.resolution instanceof Du?e._resolution.copy(t.resolution):e._resolution.set(t.resolution[0],t.resolution[1]),e.resolution=e._resolution),void 0!==t.referenceResolution&&(t.referenceResolution instanceof Du?e._referenceResolution.copy(t.referenceResolution):e._referenceResolution.set(t.referenceResolution[0],t.referenceResolution[1]),e.referenceResolution=e._referenceResolution),e.syncDrawOrder(),super.initializeComponentData(e,t,n)}destroy(){super.destroy(),this.app.graphicsDevice.off("resizecanvas",this._onResize,this),this.app.systems.off("update",this._onUpdate,this)}_onUpdate(e){const t=this.store;for(const n in t)t[n].entity.screen.update&&t[n].entity.screen.update(e)}_onResize(e,t){this.windowResolution.x=e,this.windowResolution.y=t}cloneComponent(e,t){const n=e.screen;return this.addComponent(t,{enabled:n.enabled,screenSpace:n.screenSpace,scaleMode:n.scaleMode,resolution:n.resolution.clone(),referenceResolution:n.referenceResolution.clone()})}onRemoveComponent(e,t){t.onRemove()}processDrawOrderSyncQueue(){const e=this._drawOrderSyncQueue.list();for(let t=0;t<e.length;t++){const n=e[t];n.callback.call(n.scope)}this._drawOrderSyncQueue.clear()}queueDrawOrderSync(e,t,n){this._drawOrderSyncQueue.list().length||this.app.once("prerender",this.processDrawOrderSyncQueue,this),this._drawOrderSyncQueue.has(e)||this._drawOrderSyncQueue.push(e,{callback:t,scope:n})}}Ux._buildAccessors(YA.prototype,KA);class $A{constructor(){this.enabled=!0}}let QA=0;class JA extends AC{constructor(e){super(e),this.id="script",this.ComponentType=zx,this.DataType=$A,this._components=new _u({sortBy:"_executionOrder"}),this._enabledComponents=new _u({sortBy:"_executionOrder"}),this.preloading=!0,this.on("beforeremove",this._onBeforeRemove,this),this.app.systems.on("initialize",this._onInitialize,this),this.app.systems.on("postInitialize",this._onPostInitialize,this),this.app.systems.on("update",this._onUpdate,this),this.app.systems.on("postUpdate",this._onPostUpdate,this)}initializeComponentData(e,t){if(e._executionOrder=QA++,this._components.append(e),QA>Number.MAX_SAFE_INTEGER&&this._resetExecutionOrder(),e.enabled=!t.hasOwnProperty("enabled")||!!t.enabled,e.enabled&&e.entity.enabled&&this._enabledComponents.append(e),t.hasOwnProperty("order")&&t.hasOwnProperty("scripts")){e._scriptsData=t.scripts;for(let n=0;n<t.order.length;n++)e.create(t.order[n],{enabled:t.scripts[t.order[n]].enabled,attributes:t.scripts[t.order[n]].attributes,preloading:this.preloading})}}cloneComponent(e,t){const n=[],a={};for(let t=0;t<e.script._scripts.length;t++){const i=e.script._scripts[t],s=i.__scriptType.__name;n.push(s);const r={};for(const e in i.__attributes)r[e]=i.__attributes[e];a[s]={enabled:i._enabled,attributes:r}}for(const t in e.script._scriptsIndex)t.awaiting&&n.splice(t.ind,0,t);const i={enabled:e.script.enabled,order:n,scripts:a};return this.addComponent(t,i)}_resetExecutionOrder(){QA=0;for(let e=0,t=this._components.length;e<t;e++)this._components.items[e]._executionOrder=QA++}_callComponentMethod(e,t,n){for(e.loopIndex=0;e.loopIndex<e.length;e.loopIndex++)e.items[e.loopIndex][t](n)}_onInitialize(){this.preloading=!1,this._callComponentMethod(this._components,"_onInitializeAttributes"),this._callComponentMethod(this._enabledComponents,"_onInitialize")}_onPostInitialize(){this._callComponentMethod(this._enabledComponents,"_onPostInitialize")}_onUpdate(e){this._callComponentMethod(this._enabledComponents,"_onUpdate",e)}_onPostUpdate(e){this._callComponentMethod(this._enabledComponents,"_onPostUpdate",e)}_addComponentToEnabled(e){this._enabledComponents.insert(e)}_removeComponentFromEnabled(e){this._enabledComponents.remove(e)}_onBeforeRemove(e,t){this._components.items.indexOf(t)>=0&&t._onBeforeRemove(),this._removeComponentFromEnabled(t),this._components.remove(t)}destroy(){super.destroy(),this.app.systems.off("initialize",this._onInitialize,this),this.app.systems.off("postInitialize",this._onPostInitialize,this),this.app.systems.off("update",this._onUpdate,this),this.app.systems.off("postUpdate",this._onPostUpdate,this)}}class eM extends Ux{constructor(e,t){super(e,t),this.on("set_scripts",this.onSetScripts,this)}send(e,t){const n=Array.prototype.slice.call(arguments,2),a=this.entity.script.instances;let i;if(a&&a[e]&&(i=a[e].instance[t],i))return i.apply(a[e].instance,n)}onEnable(){this.data.areScriptsLoaded&&!this.system.preloading&&(this.data.initialized?this.system._enableScriptComponent(this):this.system._initializeScriptComponent(this),this.data.postInitialized||this.system._postInitializeScriptComponent(this))}onDisable(){this.system._disableScriptComponent(this)}onSetScripts(e,t,n){if(!this.system._inTools||this.runInTools){if(this._updateScriptAttributes(t,n))return;this.enabled&&this.system._disableScriptComponent(this),this.system._destroyScriptComponent(this),this.data.areScriptsLoaded=!1;const e=n.map((function(e){return e.url}));if(this._loadFromCache(e))return;this._loadScripts(e)}}_updateScriptAttributes(e,t){let n=!0;if(e.length!==t.length)n=!1;else for(let a=0,i=t.length;a<i;a++)if(e[a].url!==t[a].url){n=!1;break}if(n)for(const e in this.instances)this.instances.hasOwnProperty(e)&&this.system._updateAccessors(this.entity,this.instances[e]);return n}_loadFromCache(e){const t=[],n=this.system.app._scriptPrefix||"",a=/^http(s)?:\/\//i;for(let i=0,s=e.length;i<s;i++){let s=e[i];a.test(s)||(s=tu.join(n,s));const r=this.system.app.loader.getFromCache(s,"script");if(!r)return!1;t.push(r)}for(let n=0,a=t.length;n<a;n++){const a=t[n];if(!0!==a&&(a&&this.entity.script&&!this.entity.script.instances[a._pcScriptName])){const t=new a(this.entity);this.system._preRegisterInstance(this.entity,e[n],a._pcScriptName,t)}}return this.data&&(this.data.areScriptsLoaded=!0),this.system.preloading||(this.system.onInitialize(this.entity),this.system.onPostInitialize(this.entity)),!0}_loadScripts(e){let t=e.length;const n=this.system.app._scriptPrefix||"";e.forEach((e=>{let a=null,i=null;e.toLowerCase().startsWith("http://")||e.toLowerCase().startsWith("https://")?(i=e,a=e):(i=e,a=tu.join(n,e)),this.system.app.loader.load(a,"script",((e,n)=>{if(t--,e)console.error(e);else if(n&&this.entity.script&&!this.entity.script.instances[n._pcScriptName]){const e=new n(this.entity);this.system._preRegisterInstance(this.entity,i,n._pcScriptName,e)}0===t&&(this.data.areScriptsLoaded=!0,this.system.preloading||(this.system.onInitialize(this.entity),this.system.onPostInitialize(this.entity)))}))}))}}class tM{constructor(){this.scripts=[],this.enabled=!0,this.instances={},this._instances={},this.runInTools=!1,this.attributes={},this.initialized=!1,this.postInitialized=!1,this.areScriptsLoaded=!1}}const nM=["enabled","scripts","instances","runInTools"];class aM extends AC{constructor(e){super(e),this.id="script",this.ComponentType=eM,this.DataType=tM,this.schema=nM,this.preloading=!1,this.instancesWithUpdate=[],this.instancesWithFixedUpdate=[],this.instancesWithPostUpdate=[],this.instancesWithToolsUpdate=[],this.on("beforeremove",this.onBeforeRemove,this),this.app.systems.on("initialize",this.onInitialize,this),this.app.systems.on("postInitialize",this.onPostInitialize,this),this.app.systems.on("update",this.onUpdate,this),this.app.systems.on("fixedUpdate",this.onFixedUpdate,this),this.app.systems.on("postUpdate",this.onPostUpdate,this),this.app.systems.on("toolsUpdate",this.onToolsUpdate,this)}initializeComponentData(e,t,n){n=["runInTools","enabled","scripts"],t.scripts&&t.scripts.length&&t.scripts.forEach((function(e){if(e.attributes&&Array.isArray(e.attributes)){const t={};for(let n=0;n<e.attributes.length;n++)t[e.attributes[n].name]=e.attributes[n];e.attributes=t}})),super.initializeComponentData(e,t,n)}cloneComponent(e,t){const n=this.store[e.getGuid()],a={runInTools:n.data.runInTools,scripts:[],enabled:n.data.enabled},i=n.data.scripts;for(let e=0,t=i.length;e<t;e++){const t=i[e].attributes;t&&delete i[e].attributes,a.scripts.push(Zp({},i[e])),t&&(a.scripts[e].attributes=this._cloneAttributes(t),i[e].attributes=t)}return this.addComponent(t,a)}onBeforeRemove(e,t){t.enabled&&this._disableScriptComponent(t),this._destroyScriptComponent(t)}onInitialize(e){if(this._registerInstances(e),e.enabled){e.script&&e.script.enabled&&this._initializeScriptComponent(e.script);const t=e._children;for(let e=0,n=t.length;e<n;e++)t[e]instanceof KM&&this.onInitialize(t[e])}}onPostInitialize(e){if(e.enabled){e.script&&e.script.enabled&&this._postInitializeScriptComponent(e.script);const t=e._children;for(let e=0,n=t.length;e<n;e++)t[e]instanceof KM&&this.onPostInitialize(t[e])}}_callInstancesMethod(e,t){const n=e.data.instances;for(const e in n)if(n.hasOwnProperty(e)){const a=n[e].instance;a[t]&&a[t]()}}_initializeScriptComponent(e){this._callInstancesMethod(e,"initialize"),e.data.initialized=!0,e.enabled&&e.entity.enabled&&this._enableScriptComponent(e)}_enableScriptComponent(e){this._callInstancesMethod(e,"onEnable")}_disableScriptComponent(e){this._callInstancesMethod(e,"onDisable")}_destroyScriptComponent(e){const t=e.data.instances;for(const n in t)if(t.hasOwnProperty(n)){const a=t[n].instance;if(a.destroy&&a.destroy(),a.update){const e=this.instancesWithUpdate.indexOf(a);e>=0&&this.instancesWithUpdate.splice(e,1)}if(a.fixedUpdate){const e=this.instancesWithFixedUpdate.indexOf(a);e>=0&&this.instancesWithFixedUpdate.splice(e,1)}if(a.postUpdate){const e=this.instancesWithPostUpdate.indexOf(a);e>=0&&this.instancesWithPostUpdate.splice(e,1)}if(a.toolsUpdate){const e=this.instancesWithToolsUpdate.indexOf(a);e>=0&&this.instancesWithToolsUpdate.splice(e,1)}e.instances[n].instance===e[n]&&delete e[n],delete e.instances[n]}}_postInitializeScriptComponent(e){this._callInstancesMethod(e,"postInitialize"),e.data.postInitialized=!0}_updateInstances(e,t,n){for(let a=0,i=t.length;a<i;a++){const i=t[a];i&&i.entity&&i.entity.enabled&&i.entity.script.enabled&&i[e](n)}}onUpdate(e){this._updateInstances("update",this.instancesWithUpdate,e)}onFixedUpdate(e){this._updateInstances("fixedUpdate",this.instancesWithFixedUpdate,e)}onPostUpdate(e){this._updateInstances("postUpdate",this.instancesWithPostUpdate,e)}onToolsUpdate(e){this._updateInstances("toolsUpdate",this.instancesWithToolsUpdate,e)}broadcast(e,t){const n=Array.prototype.slice.call(arguments,2),a=this.store;for(const i in a)if(a.hasOwnProperty(i)){const s=a[i].data;if(s.instances[e]){const a=s.instances[e].instance[t];a&&a.apply(s.instances[e].instance,n)}}}_preRegisterInstance(e,t,n,a){if(e.script){if(e.script.data._instances=e.script.data._instances||{},e.script.data._instances[n])throw Error(`Script name collision '${n}'. Scripts from '${t}' and '${e.script.data._instances[n].url}' {${e.getGuid()}}`);e.script.data._instances[n]={url:t,name:n,instance:a}}}_registerInstances(e){if(e.script&&e.script.data._instances){e.script.instances=e.script.data._instances;for(const t in e.script.instances){const n=e.script.instances[t],a=n.instance;if(Jp.attach(a),a.update&&this.instancesWithUpdate.push(a),a.fixedUpdate&&this.instancesWithFixedUpdate.push(a),a.postUpdate&&this.instancesWithPostUpdate.push(a),a.toolsUpdate&&this.instancesWithToolsUpdate.push(a),e.script.scripts&&this._createAccessors(e,n),e.script[t])throw Error(`Script with name '${t}' is already attached to Script Component`);e.script[t]=a}delete e.script.data._instances}const t=e._children;for(let e=0,n=t.length;e<n;e++)t[e]instanceof KM&&this._registerInstances(t[e])}_cloneAttributes(e){const t={};for(const n in e)if(e.hasOwnProperty(n))if("entity"!==e[n].type)t[n]=Zp({},e[n]);else{const a=e[n].value;delete e[n].value,t[n]=Zp({},e[n]),t[n].value=a,e[n].value=a}return t}_createAccessors(e,t){const n=e.script.scripts.length,a=t.url;for(let i=0;i<n;i++){const n=e.script.scripts[i];if(n.url===a){const a=n.attributes;if(n.name&&a){for(const e in a)a.hasOwnProperty(e)&&this._createAccessor(a[e],t);e.script.data.attributes[n.name]=this._cloneAttributes(a)}break}}}_createAccessor(e,t){const n=this;e={name:e.name,value:e.value,type:e.type},this._convertAttributeValue(e),Object.defineProperty(t.instance,e.name,{get:function(){return e.value},set:function(a){const i=e.value;e.value=a,n._convertAttributeValue(e),t.instance.fire("set",e.name,i,e.value)},configurable:!0})}_updateAccessors(e,t){const n=e.script.scripts.length,a=t.url;for(let i=0;i<n;i++){const n=e.script,s=n.scripts[i];if(s.url===a){const e=s.name,a=s.attributes;if(e){if(a)for(const e in a)a.hasOwnProperty(e)&&this._createAccessor(a[e],t);const i=n.data.attributes[e];if(i)for(const e in i){const n=i[e];e in a?a[e].value!==n.value&&t.instance.onAttributeChanged&&t.instance.onAttributeChanged(n.name,n.value,a[e].value):delete t.instance[n.name]}a?n.data.attributes[e]=this._cloneAttributes(a):delete n.data.attributes[e]}break}}}_convertAttributeValue(e){if("rgb"===e.type||"rgba"===e.type)Array.isArray(e.value)&&(e.value=3===e.value.length?new Mu(e.value[0],e.value[1],e.value[2]):new Mu(e.value[0],e.value[1],e.value[2],e.value[3]));else if("vec2"===e.type)Array.isArray(e.value)&&(e.value=new Du(e.value[0],e.value[1]));else if("vec3"===e.type||"vector"===e.type)Array.isArray(e.value)&&(e.value=new Pu(e.value[0],e.value[1],e.value[2]));else if("vec4"===e.type)Array.isArray(e.value)&&(e.value=new Ou(e.value[0],e.value[1],e.value[2],e.value[3]));else if("entity"===e.type)null!==e.value&&"string"==typeof e.value&&(e.value=this.app.root.findByGuid(e.value));else if("curve"===e.type||"colorcurve"===e.type){const t=e.value.keys[0]instanceof Array?Iu:Ru;e.value=new t(e.value.keys),e.value.type=e.value.type}}destroy(){super.destroy(),this.app.systems.off("initialize",this.onInitialize,this),this.app.systems.off("postInitialize",this.onPostInitialize,this),this.app.systems.off("update",this.onUpdate,this),this.app.systems.off("fixedUpdate",this.onFixedUpdate,this),this.app.systems.off("postUpdate",this.onPostUpdate,this),this.app.systems.off("toolsUpdate",this.onToolsUpdate,this)}}Ux._buildAccessors(eM.prototype,nM);const iM=new Du,sM=new Pu,rM=new Pu,oM=new Pu,lM=new Pu,cM=new Pu,hM=new Gu,dM={x:"y",y:"x"};class pM extends Qp{constructor(e,t){if(super(),!(e&&e instanceof DE))throw new Error("Element was null or not an ElementComponent");if(t&&"x"!==t&&"y"!==t)throw new Error("Unrecognized axis: "+t);this._element=e,this._app=e.system.app,this._axis=t||null,this._enabled=!0,this._dragScale=new Pu,this._dragStartMousePosition=new Pu,this._dragStartHandlePosition=new Pu,this._deltaMousePosition=new Pu,this._deltaHandlePosition=new Pu,this._isDragging=!1,this._toggleLifecycleListeners("on")}_toggleLifecycleListeners(e){this._element[e]("mousedown",this._onMouseDownOrTouchStart,this),this._element[e]("touchstart",this._onMouseDownOrTouchStart,this)}_toggleDragListeners(e){const t="on"===e,n=t?"addEventListener":"removeEventListener";this._hasDragListeners&&t||(this._handleMouseUpOrTouchEnd||(this._handleMouseUpOrTouchEnd=this._onMouseUpOrTouchEnd.bind(this)),this._app.mouse&&(this._app.mouse[e]("mousemove",this._onMove,this),window[n]("mouseup",this._handleMouseUpOrTouchEnd,!1)),uu.touch&&(this._app.touch[e]("touchmove",this._onMove,this),window[n]("touchend",this._handleMouseUpOrTouchEnd,!1),window[n]("touchcancel",this._handleMouseUpOrTouchEnd,!1)),this._hasDragListeners=t)}_onMouseDownOrTouchStart(e){if(this._element&&!this._isDragging&&this.enabled){this._dragCamera=e.camera,this._calculateDragScale();const t=this._screenToLocal(e);t&&(this._toggleDragListeners("on"),this._isDragging=!0,this._dragStartMousePosition.copy(t),this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition()),this.fire("drag:start"))}}_onMouseUpOrTouchEnd(){this._isDragging&&(this._isDragging=!1,this._toggleDragListeners("off"),this.fire("drag:end"))}_screenToLocal(e){this._determineInputPosition(e),this._chooseRayOriginAndDirection(),lM.copy(this._element.entity.getPosition()),cM.copy(this._element.entity.forward).mulScalar(-1);const t=cM.dot(oM);if(Math.abs(t)>0){const e=lM.sub(rM).dot(cM)/t,n=rM.add(oM.mulScalar(e));return hM.copy(this._element.entity.getRotation()).invert().transformVector(n,n),n.mul(this._dragScale),n}return null}_determineInputPosition(e){const t=this._app.graphicsDevice.maxPixelRatio;void 0!==e.x&&void 0!==e.y?(iM.x=e.x*t,iM.y=e.y*t):e.changedTouches?(iM.x=e.changedTouches[0].x*t,iM.y=e.changedTouches[0].y*t):console.warn("Could not determine position from input event")}_chooseRayOriginAndDirection(){this._element.screen&&this._element.screen.screen.screenSpace?(rM.set(iM.x,-iM.y,0),oM.set(0,0,-1)):(sM.copy(this._dragCamera.screenToWorld(iM.x,iM.y,1)),rM.copy(this._dragCamera.entity.getPosition()),oM.copy(sM).sub(rM).normalize())}_calculateDragScale(){let e=this._element.entity.parent;const t=this._element.screen&&this._element.screen.screen,n=t&&t.screenSpace,a=n?t.scale:1,i=this._dragScale;for(i.set(a,a,a);e&&(i.mul(e.getLocalScale()),e=e.parent,!n||!e.screen););i.x=1/i.x,i.y=1/i.y,i.z=1/i.z}_onMove(e){if(this._element&&this._isDragging&&this.enabled&&this._element.enabled&&this._element.entity.enabled){const t=this._screenToLocal(e);if(this._dragStartMousePosition&&t){if(this._deltaMousePosition.copy(t).sub(this._dragStartMousePosition),this._deltaHandlePosition.copy(this._dragStartHandlePosition).add(this._deltaMousePosition),this._axis){const e=this._element.entity.getLocalPosition(),t=dM[this._axis];this._deltaHandlePosition[t]=e[t]}this._element.entity.setLocalPosition(this._deltaHandlePosition),this.fire("drag:move",this._deltaHandlePosition)}}}destroy(){this._toggleLifecycleListeners("off"),this._toggleDragListeners("off")}set enabled(e){this._enabled=e}get enabled(){return this._enabled}get isDragging(){return this._isDragging}}const uM=new Du;class mM extends Ux{constructor(e,t){super(e,t),this._viewportReference=new bT(this,"viewportEntity",{"element#gain":this._onViewportElementGain,"element#resize":this._onSetContentOrViewportSize}),this._contentReference=new bT(this,"contentEntity",{"element#gain":this._onContentElementGain,"element#lose":this._onContentElementLose,"element#resize":this._onSetContentOrViewportSize}),this._scrollbarUpdateFlags={},this._scrollbarReferences={},this._scrollbarReferences[0]=new bT(this,"horizontalScrollbarEntity",{"scrollbar#set:value":this._onSetHorizontalScrollbarValue,"scrollbar#gain":this._onHorizontalScrollbarGain}),this._scrollbarReferences[1]=new bT(this,"verticalScrollbarEntity",{"scrollbar#set:value":this._onSetVerticalScrollbarValue,"scrollbar#gain":this._onVerticalScrollbarGain}),this._prevContentSizes={},this._prevContentSizes[0]=null,this._prevContentSizes[1]=null,this._scroll=new Du,this._velocity=new Pu,this._dragStartPosition=new Pu,this._disabledContentInput=!1,this._disabledContentInputEntities=[],this._toggleLifecycleListeners("on",e),this._toggleElementListeners("on")}_toggleLifecycleListeners(e,t){this[e]("set_horizontal",this._onSetHorizontalScrollingEnabled,this),this[e]("set_vertical",this._onSetVerticalScrollingEnabled,this),t.app.systems.element[e]("add",this._onElementComponentAdd,this),t.app.systems.element[e]("beforeremove",this._onElementComponentRemove,this)}_toggleElementListeners(e){if(this.entity.element){if("on"===e&&this._hasElementListeners)return;this.entity.element[e]("resize",this._onSetContentOrViewportSize,this),this.entity.element[e]("mousewheel",this._onMouseWheel,this),this._hasElementListeners="on"===e}}_onElementComponentAdd(e){this.entity===e&&this._toggleElementListeners("on")}_onElementComponentRemove(e){this.entity===e&&this._toggleElementListeners("off")}_onViewportElementGain(){this._syncAll()}_onContentElementGain(){this._destroyDragHelper(),this._contentDragHelper=new pM(this._contentReference.entity.element),this._contentDragHelper.on("drag:start",this._onContentDragStart,this),this._contentDragHelper.on("drag:end",this._onContentDragEnd,this),this._contentDragHelper.on("drag:move",this._onContentDragMove,this),this._prevContentSizes[0]=null,this._prevContentSizes[1]=null,this._syncAll()}_onContentElementLose(){this._destroyDragHelper()}_onContentDragStart(){this._contentReference.entity&&this.enabled&&this.entity.enabled&&this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition())}_onContentDragEnd(){this._prevContentDragPosition=null,this._enableContentInput()}_onContentDragMove(e){if(this._contentReference.entity&&this.enabled&&this.entity.enabled&&(this._wasDragged=!0,this._setScrollFromContentPosition(e),this._setVelocityFromContentPositionDelta(e),!this._disabledContentInput)){const t=e.x-this._dragStartPosition.x,n=e.y-this._dragStartPosition.y;(Math.abs(t)>this.dragThreshold||Math.abs(n)>this.dragThreshold)&&this._disableContentInput()}}_onSetContentOrViewportSize(){this._syncAll()}_onSetHorizontalScrollbarValue(e){!this._scrollbarUpdateFlags[0]&&this.enabled&&this.entity.enabled&&this._onSetScroll(e,null)}_onSetVerticalScrollbarValue(e){!this._scrollbarUpdateFlags[1]&&this.enabled&&this.entity.enabled&&this._onSetScroll(null,e)}_onSetHorizontalScrollingEnabled(){this._syncScrollbarEnabledState(0)}_onSetVerticalScrollingEnabled(){this._syncScrollbarEnabledState(1)}_onHorizontalScrollbarGain(){this._syncScrollbarEnabledState(0),this._syncScrollbarPosition(0)}_onVerticalScrollbarGain(){this._syncScrollbarEnabledState(1),this._syncScrollbarPosition(1)}_onSetScroll(e,t,n){!1!==n&&this._velocity.set(0,0,0);const a=this._updateAxis(e,"x",0),i=this._updateAxis(t,"y",1);(a||i)&&this.fire("set:scroll",this._scroll)}_updateAxis(e,t,n){const a=null!==e&&Math.abs(e-this._scroll[t])>1e-5;return(a||this._isDragging()||0===e)&&(this._scroll[t]=this._determineNewScrollValue(e,t,n),this._syncContentPosition(n),this._syncScrollbarPosition(n)),a}_determineNewScrollValue(e,t,n){if(!this._getScrollingEnabled(n))return this._scroll[t];switch(this.scrollMode){case 0:return Eu.clamp(e,0,this._getMaxScrollValue(n));case 1:return this._setVelocityFromOvershoot(e,t,n),e;case 2:return e;default:return console.warn("Unhandled scroll mode:"+this.scrollMode),e}}_syncAll(){this._syncContentPosition(0),this._syncContentPosition(1),this._syncScrollbarPosition(0),this._syncScrollbarPosition(1),this._syncScrollbarEnabledState(0),this._syncScrollbarEnabledState(1)}_syncContentPosition(e){const t=this._getAxis(e),n=this._getSign(e),a=this._contentReference.entity;if(a){const i=this._prevContentSizes[e],s=this._getContentSize(e);if(null!==i&&Math.abs(i-s)>1e-4){const n=this._getMaxOffset(e,i),a=this._getMaxOffset(e,s);this._scroll[t]=0===a?1:Eu.clamp(this._scroll[t]*n/a,0,1)}const r=this._scroll[t]*this._getMaxOffset(e),o=a.getLocalPosition();o[t]=r*n,a.setLocalPosition(o),this._prevContentSizes[e]=s}}_syncScrollbarPosition(e){const t=this._getAxis(e),n=this._scrollbarReferences[e].entity;n&&n.scrollbar&&(this._scrollbarUpdateFlags[e]=!0,n.scrollbar.value=this._scroll[t],n.scrollbar.handleSize=this._getScrollbarHandleSize(t,e),this._scrollbarUpdateFlags[e]=!1)}_syncScrollbarEnabledState(e){const t=this._scrollbarReferences[e].entity;if(t){const n=this._getScrollingEnabled(e),a=this._getScrollbarVisibility(e);switch(a){case 0:return void(t.enabled=n);case 1:return void(t.enabled=n&&this._contentIsLargerThanViewport(e));default:console.warn("Unhandled scrollbar visibility:"+a),t.enabled=n}}}_contentIsLargerThanViewport(e){return this._getContentSize(e)>this._getViewportSize(e)}_contentPositionToScrollValue(e){const t=this._getMaxOffset(0),n=this._getMaxOffset(1);return uM.x=0===t?0:e.x/t,uM.y=0===n?0:e.y/-n,uM}_getMaxOffset(e,t){t=void 0===t?this._getContentSize(e):t;const n=this._getViewportSize(e);return t<n?-this._getViewportSize(e):n-t}_getMaxScrollValue(e){return this._contentIsLargerThanViewport(e)?1:0}_getScrollbarHandleSize(e,t){const n=this._getViewportSize(t),a=this._getContentSize(t);if(Math.abs(a)<.001)return 1;const i=Math.min(n/a,1),s=this._toOvershoot(this._scroll[e],t);return 0===s?i:i/(1+Math.abs(s))}_getViewportSize(e){return this._getSize(e,this._viewportReference)}_getContentSize(e){return this._getSize(e,this._contentReference)}_getSize(e,t){return t.entity&&t.entity.element?t.entity.element[this._getCalculatedDimension(e)]:0}_getScrollingEnabled(e){return 0===e?this.horizontal:1===e?this.vertical:void console.warn("Unrecognized orientation: "+e)}_getScrollbarVisibility(e){return 0===e?this.horizontalScrollbarVisibility:1===e?this.verticalScrollbarVisibility:void console.warn("Unrecognized orientation: "+e)}_getSign(e){return 0===e?1:-1}_getAxis(e){return 0===e?"x":"y"}_getCalculatedDimension(e){return 0===e?"calculatedWidth":"calculatedHeight"}_destroyDragHelper(){this._contentDragHelper&&this._contentDragHelper.destroy()}onUpdate(){this._contentReference.entity&&(this._updateVelocity(),this._syncScrollbarEnabledState(0),this._syncScrollbarEnabledState(1))}_updateVelocity(){if(!this._isDragging()){if(1===this.scrollMode&&(this._hasOvershoot("x",0)&&this._setVelocityFromOvershoot(this.scroll.x,"x",0),this._hasOvershoot("y",1)&&this._setVelocityFromOvershoot(this.scroll.y,"y",1)),Math.abs(this._velocity.x)>1e-4||Math.abs(this._velocity.y)>1e-4){const e=this._contentReference.entity.getLocalPosition();e.x+=this._velocity.x,e.y+=this._velocity.y,this._contentReference.entity.setLocalPosition(e),this._setScrollFromContentPosition(e)}this._velocity.x*=1-this.friction,this._velocity.y*=1-this.friction}}_hasOvershoot(e,t){return Math.abs(this._toOvershoot(this.scroll[e],t))>.001}_toOvershoot(e,t){const n=this._getMaxScrollValue(t);return e<0?e:e>n?e-n:0}_setVelocityFromOvershoot(e,t,n){const a=this._toOvershoot(e,n)*this._getMaxOffset(n)*this._getSign(n);Math.abs(a)>0&&(this._velocity[t]=-a/(50*this.bounceAmount+1))}_setVelocityFromContentPositionDelta(e){this._prevContentDragPosition?(this._velocity.sub2(e,this._prevContentDragPosition),this._prevContentDragPosition.copy(e)):(this._velocity.set(0,0,0),this._prevContentDragPosition=e.clone())}_setScrollFromContentPosition(e){let t=this._contentPositionToScrollValue(e);this._isDragging()&&(t=this._applyScrollValueTension(t)),this._onSetScroll(t.x,t.y,!1)}_applyScrollValueTension(e){let t=this._getMaxScrollValue(0),n=this._toOvershoot(e.x,0);return n>0?e.x=t+1*Math.log10(1+n):n<0&&(e.x=-1*Math.log10(1-n)),t=this._getMaxScrollValue(1),n=this._toOvershoot(e.y,1),n>0?e.y=t+1*Math.log10(1+n):n<0&&(e.y=-1*Math.log10(1-n)),e}_isDragging(){return this._contentDragHelper&&this._contentDragHelper.isDragging}_setScrollbarComponentsEnabled(e){this._scrollbarReferences[0].hasComponent("scrollbar")&&(this._scrollbarReferences[0].entity.scrollbar.enabled=e),this._scrollbarReferences[1].hasComponent("scrollbar")&&(this._scrollbarReferences[1].entity.scrollbar.enabled=e)}_setContentDraggingEnabled(e){this._contentDragHelper&&(this._contentDragHelper.enabled=e)}_onMouseWheel(e){if(this.useMouseWheel){const t=e.event,n=t.deltaX/this._contentReference.entity.element.calculatedWidth*this.mouseWheelSensitivity.x,a=t.deltaY/this._contentReference.entity.element.calculatedHeight*this.mouseWheelSensitivity.y,i=Eu.clamp(this._scroll.x+n,0,this._getMaxScrollValue(0)),s=Eu.clamp(this._scroll.y+a,0,this._getMaxScrollValue(1));this.scroll=new Du(i,s)}}_enableContentInput(){for(;this._disabledContentInputEntities.length;){const e=this._disabledContentInputEntities.pop();e.element&&(e.element.useInput=!0)}this._disabledContentInput=!1}_disableContentInput(){const e=t=>{t.element&&t.element.useInput&&(this._disabledContentInputEntities.push(t),t.element.useInput=!1);const n=t.children;for(let t=0,a=n.length;t<a;t++)e(n[t])},t=this._contentReference.entity;if(t){const n=t.children;for(let t=0,a=n.length;t<a;t++)e(n[t])}this._disabledContentInput=!0}onEnable(){this._viewportReference.onParentComponentEnable(),this._contentReference.onParentComponentEnable(),this._scrollbarReferences[0].onParentComponentEnable(),this._scrollbarReferences[1].onParentComponentEnable(),this._setScrollbarComponentsEnabled(!0),this._setContentDraggingEnabled(!0),this._syncAll()}onDisable(){this._setScrollbarComponentsEnabled(!1),this._setContentDraggingEnabled(!1)}onRemove(){this._toggleLifecycleListeners("off",this.system),this._toggleElementListeners("off"),this._destroyDragHelper()}set scroll(e){this._onSetScroll(e.x,e.y)}get scroll(){return this._scroll}}class fM{constructor(){this.enabled=!0}}const gM=[{name:"enabled",type:"boolean"},{name:"horizontal",type:"boolean"},{name:"vertical",type:"boolean"},{name:"scrollMode",type:"number"},{name:"bounceAmount",type:"number"},{name:"friction",type:"number"},{name:"dragThreshold",type:"number"},{name:"useMouseWheel",type:"boolean"},{name:"mouseWheelSensitivity",type:"vec2"},{name:"horizontalScrollbarVisibility",type:"number"},{name:"verticalScrollbarVisibility",type:"number"},{name:"viewportEntity",type:"entity"},{name:"contentEntity",type:"entity"},{name:"horizontalScrollbarEntity",type:"entity"},{name:"verticalScrollbarEntity",type:"entity"}];class yM extends AC{constructor(e){super(e),this.id="scrollview",this.ComponentType=mM,this.DataType=fM,this.schema=gM,this.on("beforeremove",this._onRemoveComponent,this),this.app.systems.on("update",this.onUpdate,this)}initializeComponentData(e,t,n){void 0===t.dragThreshold&&(t.dragThreshold=10),void 0===t.useMouseWheel&&(t.useMouseWheel=!0),void 0===t.mouseWheelSensitivity&&(t.mouseWheelSensitivity=new Du(1,1)),super.initializeComponentData(e,t,gM)}onUpdate(e){const t=this.store;for(const e in t){const n=t[e].entity,a=n.scrollview;a.enabled&&n.enabled&&a.onUpdate()}}_onRemoveComponent(e,t){t.onRemove()}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this)}}Ux._buildAccessors(mM.prototype,gM);class bM extends Ux{constructor(e,t){super(e,t),this._handleReference=new bT(this,"handleEntity",{"element#gain":this._onHandleElementGain,"element#lose":this._onHandleElementLose,"element#set:anchor":this._onSetHandleAlignment,"element#set:margin":this._onSetHandleAlignment,"element#set:pivot":this._onSetHandleAlignment}),this._toggleLifecycleListeners("on")}_toggleLifecycleListeners(e){this[e]("set_value",this._onSetValue,this),this[e]("set_handleSize",this._onSetHandleSize,this),this[e]("set_orientation",this._onSetOrientation,this)}_onHandleElementGain(){this._destroyDragHelper(),this._handleDragHelper=new pM(this._handleReference.entity.element,this._getAxis()),this._handleDragHelper.on("drag:move",this._onHandleDrag,this),this._updateHandlePositionAndSize()}_onHandleElementLose(){this._destroyDragHelper()}_onHandleDrag(e){this._handleReference.entity&&this.enabled&&this.entity.enabled&&(this.value=this._handlePositionToScrollValue(e[this._getAxis()]))}_onSetValue(e,t,n){Math.abs(n-t)>1e-5&&(this.data.value=Eu.clamp(n,0,1),this._updateHandlePositionAndSize(),this.fire("set:value",this.data.value))}_onSetHandleSize(e,t,n){Math.abs(n-t)>1e-5&&(this.data.handleSize=Eu.clamp(n,0,1),this._updateHandlePositionAndSize())}_onSetHandleAlignment(){this._updateHandlePositionAndSize()}_onSetOrientation(e,t,n){n!==t&&this._handleReference.hasComponent("element")&&(this._handleReference.entity.element[this._getOppositeDimension()]=0)}_updateHandlePositionAndSize(){const e=this._handleReference.entity,t=e&&e.element;if(e){const t=e.getLocalPosition();t[this._getAxis()]=this._getHandlePosition(),this._handleReference.entity.setLocalPosition(t)}t&&(t[this._getDimension()]=this._getHandleLength())}_handlePositionToScrollValue(e){return e*this._getSign()/this._getUsableTrackLength()}_scrollValueToHandlePosition(e){return e*this._getSign()*this._getUsableTrackLength()}_getUsableTrackLength(){return Math.max(this._getTrackLength()-this._getHandleLength(),.001)}_getTrackLength(){return this.entity.element?0===this.orientation?this.entity.element.calculatedWidth:this.entity.element.calculatedHeight:0}_getHandleLength(){return this._getTrackLength()*this.handleSize}_getHandlePosition(){return this._scrollValueToHandlePosition(this.value)}_getSign(){return 0===this.orientation?1:-1}_getAxis(){return 0===this.orientation?"x":"y"}_getDimension(){return 0===this.orientation?"width":"height"}_getOppositeDimension(){return 0===this.orientation?"height":"width"}_destroyDragHelper(){this._handleDragHelper&&this._handleDragHelper.destroy()}_setHandleDraggingEnabled(e){this._handleDragHelper&&(this._handleDragHelper.enabled=e)}onEnable(){this._handleReference.onParentComponentEnable(),this._setHandleDraggingEnabled(!0)}onDisable(){this._setHandleDraggingEnabled(!1)}onRemove(){this._destroyDragHelper(),this._toggleLifecycleListeners("off")}}class vM{constructor(){this.enabled=!0}}const _M=[{name:"enabled",type:"boolean"},{name:"orientation",type:"number"},{name:"value",type:"number"},{name:"handleSize",type:"number"},{name:"handleEntity",type:"entity"}];class wM extends AC{constructor(e){super(e),this.id="scrollbar",this.ComponentType=bM,this.DataType=vM,this.schema=_M,this.on("beforeremove",this._onRemoveComponent,this)}initializeComponentData(e,t,n){super.initializeComponentData(e,t,_M)}_onRemoveComponent(e,t){t.onRemove()}}Ux._buildAccessors(bM.prototype,_M);function xM(e,t){return e%t||0}class CM extends Qp{constructor(e,t,n){super(),this.source=null,this._manager=e,this._volume=void 0!==n.volume?Eu.clamp(Number(n.volume)||0,0,1):1,this._pitch=void 0!==n.pitch?Math.max(.01,Number(n.pitch)||0):1,this._loop=!(void 0===n.loop||!n.loop),this._sound=t,this._state=2,this._suspended=!1,this._suspendEndEvent=!1,this._suspendInstanceEvents=!1,this._playWhenLoaded=!0,this._startTime=Math.max(0,Number(n.startTime)||0),this._duration=Math.max(0,Number(n.duration)||0),this._startOffset=null,this._onPlayCallback=n.onPlay,this._onPauseCallback=n.onPause,this._onResumeCallback=n.onResume,this._onStopCallback=n.onStop,this._onEndCallback=n.onEnd,zv()?(this._startedAt=0,this._currentTime=0,this._currentOffset=0,this._inputNode=null,this._connectorNode=null,this._firstNode=null,this._lastNode=null,this._initializeNodes(),this._endedHandler=this._onEnded.bind(this)):(this._isReady=!1,this._loadedMetadataHandler=this._onLoadedMetadata.bind(this),this._timeUpdateHandler=this._onTimeUpdate.bind(this),this._endedHandler=this._onEnded.bind(this),this._createSource())}set currentTime(e){if(!(e<0))if(0===this._state){const t=this._suspendInstanceEvents;this._suspendInstanceEvents=!0,this.stop(),this._startOffset=e,this.play(),this._suspendInstanceEvents=t}else this._startOffset=e,this._currentTime=e}get currentTime(){return null!==this._startOffset?this._startOffset:1===this._state?this._currentTime:2!==this._state&&this.source?(this._updateCurrentTime(),this._currentTime):0}set duration(e){this._duration=Math.max(0,Number(e)||0);const t=0===this._state;this.stop(),t&&this.play()}get duration(){return this._sound?this._duration?xM(this._duration,this._sound.duration):this._sound.duration:0}get isPaused(){return 1===this._state}get isPlaying(){return 0===this._state}get isStopped(){return 2===this._state}get isSuspended(){return this._suspended}set loop(e){this._loop=!!e,this.source&&(this.source.loop=this._loop)}get loop(){return this._loop}set pitch(e){this._currentOffset=this.currentTime,this._startedAt=this._manager.context.currentTime,this._pitch=Math.max(Number(e)||0,.01),this.source&&(this.source.playbackRate.value=this._pitch)}get pitch(){return this._pitch}set sound(e){this._sound=e,2!==this._state?this.stop():this._createSource()}get sound(){return this._sound}set startTime(e){this._startTime=Math.max(0,Number(e)||0);const t=0===this._state;this.stop(),t&&this.play()}get startTime(){return this._startTime}set volume(e){e=Eu.clamp(e,0,1),this._volume=e,this.gain&&(this.gain.gain.value=e*this._manager.volume)}get volume(){return this._volume}_onPlay(){this.fire("play"),this._onPlayCallback&&this._onPlayCallback(this)}_onPause(){this.fire("pause"),this._onPauseCallback&&this._onPauseCallback(this)}_onResume(){this.fire("resume"),this._onResumeCallback&&this._onResumeCallback(this)}_onStop(){this.fire("stop"),this._onStopCallback&&this._onStopCallback(this)}_onEnded(){this._suspendEndEvent?this._suspendEndEvent=!1:(this.fire("end"),this._onEndCallback&&this._onEndCallback(this),this.stop())}_onManagerVolumeChange(){this.volume=this._volume}_onManagerSuspend(){0!==this._state||this._suspended||(this._suspended=!0,this.pause())}_onManagerResume(){this._suspended&&(this._suspended=!1,this.resume())}_initializeNodes(){this.gain=this._manager.context.createGain(),this._inputNode=this.gain,this._connectorNode=this.gain,this._connectorNode.connect(this._manager.context.destination)}play(){2!==this._state&&this.stop(),this.source||this._createSource();let e=xM(this._startOffset,this.duration);return e=xM(this._startTime+e,this._sound.duration),this._startOffset=null,this._duration?this.source.start(0,e,this._duration):this.source.start(0,e),this._startedAt=this._manager.context.currentTime,this._currentTime=0,this._currentOffset=e,this._state=0,this._playWhenLoaded=!1,this.volume=this._volume,this.loop=this._loop,this.pitch=this._pitch,this._manager.on("volumechange",this._onManagerVolumeChange,this),this._manager.on("suspend",this._onManagerSuspend,this),this._manager.on("resume",this._onManagerResume,this),this._manager.on("destroy",this._onManagerDestroy,this),this._manager.suspended&&this._onManagerSuspend(),this._suspendInstanceEvents||this._onPlay(),!0}pause(){return this._playWhenLoaded=!1,!(0!==this._state||!this.source)&&(this._updateCurrentTime(),this._state=1,this._suspendEndEvent=!0,this.source.stop(0),this.source=null,this._startOffset=null,this._suspendInstanceEvents||this._onPause(),!0)}resume(){if(1!==this._state)return!1;this.source||this._createSource();let e=this.currentTime;return null!==this._startOffset&&(e=xM(this._startOffset,this.duration),e=xM(this._startTime+e,this._sound.duration),this._startOffset=null),this._duration?this.source.start(0,e,this._duration):this.source.start(0,e),this._state=0,this._startedAt=this._manager.context.currentTime,this._currentOffset=e,this.volume=this._volume,this.loop=this._loop,this.pitch=this._pitch,this._playWhenLoaded=!1,this._suspendInstanceEvents||this._onResume(),!0}stop(){return this._playWhenLoaded=!1,!(2===this._state||!this.source)&&(this._manager.off("volumechange",this._onManagerVolumeChange,this),this._manager.off("suspend",this._onManagerSuspend,this),this._manager.off("resume",this._onManagerResume,this),this._manager.off("destroy",this._onManagerDestroy,this),this._startedAt=0,this._currentTime=0,this._currentOffset=0,this._startOffset=null,this._suspendEndEvent=!0,0===this._state&&this.source.stop(0),this.source=null,this._state=2,this._suspendInstanceEvents||this._onStop(),!0)}setExternalNodes(e,t){if(!e)return void console.error("The firstNode must be a valid Audio Node");t||(t=e);const n=this._manager.context.destination;this._firstNode!==e&&(this._firstNode?this._connectorNode.disconnect(this._firstNode):this._connectorNode.disconnect(n),this._firstNode=e,this._connectorNode.connect(e)),this._lastNode!==t&&(this._lastNode&&this._lastNode.disconnect(n),this._lastNode=t,this._lastNode.connect(n))}clearExternalNodes(){const e=this._manager.context.destination;this._firstNode&&(this._connectorNode.disconnect(this._firstNode),this._firstNode=null),this._lastNode&&(this._lastNode.disconnect(e),this._lastNode=null),this._connectorNode.connect(e)}getExternalNodes(){return[this._firstNode,this._lastNode]}_createSource(){if(!this._sound)return null;const e=this._manager.context;return this._sound.buffer&&(this.source=e.createBufferSource(),this.source.buffer=this._sound.buffer,this.source.connect(this._inputNode),this.source.onended=this._endedHandler,this.source.loopStart=xM(this._startTime,this.source.buffer.duration),this._duration&&(this.source.loopEnd=Math.max(this.source.loopStart,xM(this._startTime+this._duration,this.source.buffer.duration)))),this.source}_updateCurrentTime(){this._currentTime=xM((this._manager.context.currentTime-this._startedAt)*this._pitch+this._currentOffset,this.duration)}_onManagerDestroy(){this.source&&0===this._state&&(this.source.stop(0),this.source=null)}}zv()||(Object.assign(CM.prototype,{play:function(){return 2!==this._state&&this.stop(),!(!this.source&&!this._createSource())&&(this.volume=this._volume,this.pitch=this._pitch,this.loop=this._loop,this.source.play(),this._state=0,this._playWhenLoaded=!1,this._manager.on("volumechange",this._onManagerVolumeChange,this),this._manager.on("suspend",this._onManagerSuspend,this),this._manager.on("resume",this._onManagerResume,this),this._manager.on("destroy",this._onManagerDestroy,this),this._manager.suspended&&this._onManagerSuspend(),this._suspendInstanceEvents||this._onPlay(),!0)},pause:function(){return!(!this.source||0!==this._state)&&(this._suspendEndEvent=!0,this.source.pause(),this._playWhenLoaded=!1,this._state=1,this._startOffset=null,this._suspendInstanceEvents||this._onPause(),!0)},resume:function(){return!(!this.source||1!==this._state)&&(this._state=0,this._playWhenLoaded=!1,this.source.paused&&(this.source.play(),this._suspendInstanceEvents||this._onResume()),!0)},stop:function(){return!(!this.source||2===this._state)&&(this._manager.off("volumechange",this._onManagerVolumeChange,this),this._manager.off("suspend",this._onManagerSuspend,this),this._manager.off("resume",this._onManagerResume,this),this._manager.off("destroy",this._onManagerDestroy,this),this._suspendEndEvent=!0,this.source.pause(),this._playWhenLoaded=!1,this._state=2,this._startOffset=null,this._suspendInstanceEvents||this._onStop(),!0)},setExternalNodes:function(){},clearExternalNodes:function(){},getExternalNodes:function(){return[null,null]},_onLoadedMetadata:function(){this.source.removeEventListener("loadedmetadata",this._loadedMetadataHandler),this._isReady=!0;let e=xM(this._startOffset,this.duration);e=xM(this._startTime+e,this._sound.duration),this._startOffset=null,this.source.currentTime=e},_createSource:function(){return this._sound&&this._sound.audio&&(this._isReady=!1,this.source=this._sound.audio.cloneNode(!0),this.source.addEventListener("loadedmetadata",this._loadedMetadataHandler),this.source.addEventListener("timeupdate",this._timeUpdateHandler),this.source.onended=this._endedHandler),this.source},_onTimeUpdate:function(){this._duration&&this.source.currentTime>xM(this._startTime+this._duration,this.source.duration)&&(this.loop?this.source.currentTime=xM(this._startTime,this.source.duration):(this.source.removeEventListener("timeupdate",this._timeUpdateHandler),this.source.pause(),this._onEnded()))},_onManagerDestroy:function(){this.source&&this.source.pause()}}),Object.defineProperty(CM.prototype,"volume",{get:function(){return this._volume},set:function(e){e=Eu.clamp(e,0,1),this._volume=e,this.source&&(this.source.volume=e*this._manager.volume)}}),Object.defineProperty(CM.prototype,"pitch",{get:function(){return this._pitch},set:function(e){this._pitch=Math.max(Number(e)||0,.01),this.source&&(this.source.playbackRate=this._pitch)}}),Object.defineProperty(CM.prototype,"sound",{get:function(){return this._sound},set:function(e){this.stop(),this._sound=e}}),Object.defineProperty(CM.prototype,"currentTime",{get:function(){return null!==this._startOffset?this._startOffset:2!==this._state&&this.source?this.source.currentTime-this._startTime:0},set:function(e){e<0||(this._startOffset=e,this.source&&this._isReady&&(this.source.currentTime=xM(this._startTime+xM(e,this.duration),this._sound.duration),this._startOffset=null))}}));class TM extends CM{constructor(e,t,n={}){super(e,t,n),this._position=new Pu,this._velocity=new Pu,n.position&&(this.position=n.position),this.maxDistance=void 0!==n.maxDistance?Number(n.maxDistance):1e4,this.refDistance=void 0!==n.refDistance?Number(n.refDistance):1,this.rollOffFactor=void 0!==n.rollOffFactor?Number(n.rollOffFactor):1,this.distanceModel=void 0!==n.distanceModel?n.distanceModel:"linear"}_initializeNodes(){this.gain=this._manager.context.createGain(),this.panner=this._manager.context.createPanner(),this.panner.connect(this.gain),this._inputNode=this.panner,this._connectorNode=this.gain,this._connectorNode.connect(this._manager.context.destination)}set position(e){this._position.copy(e);const t=this.panner;"positionX"in t?(t.positionX.value=e.x,t.positionY.value=e.y,t.positionZ.value=e.z):t.setPosition&&t.setPosition(e.x,e.y,e.z)}get position(){return this._position}set velocity(e){this._velocity.copy(e)}get velocity(){return this._velocity}set maxDistance(e){this.panner.maxDistance=e}get maxDistance(){return this.panner.maxDistance}set refDistance(e){this.panner.refDistance=e}get refDistance(){return this.panner.refDistance}set rollOffFactor(e){this.panner.rolloffFactor=e}get rollOffFactor(){return this.panner.rolloffFactor}set distanceModel(e){this.panner.distanceModel=e}get distanceModel(){return this.panner.distanceModel}}if(!zv()){let e=new Pu;const t=function(t,n,a,i,s,r){e=e.sub2(t,n);const o=e.length();if(o<a)return 1;if(o>i)return 0;let l=0;return"linear"===r?l=1-s*(o-a)/(i-a):"inverse"===r?l=a/(a+s*(o-a)):"exponential"===r&&(l=Math.pow(o/a,-s)),Eu.clamp(l,0,1)};Object.defineProperty(TM.prototype,"position",{get:function(){return this._position},set:function(e){if(this._position.copy(e),this.source){const e=this._manager.listener.getPosition(),n=t(e,this._position,this.refDistance,this.maxDistance,this.rollOffFactor,this.distanceModel),a=this.volume;this.source.volume=a*n*this._manager.volume}}}),Object.defineProperty(TM.prototype,"maxDistance",{get:function(){return this._maxDistance},set:function(e){this._maxDistance=e}}),Object.defineProperty(TM.prototype,"refDistance",{get:function(){return this._refDistance},set:function(e){this._refDistance=e}}),Object.defineProperty(TM.prototype,"rollOffFactor",{get:function(){return this._rollOffFactor},set:function(e){this._rollOffFactor=e}}),Object.defineProperty(TM.prototype,"distanceModel",{get:function(){return this._distanceModel},set:function(e){this._distanceModel=e}})}const EM={volume:0,pitch:0,loop:!1,startTime:0,duration:0,position:new Pu,maxDistance:0,refDistance:0,rollOffFactor:0,distanceModel:0,onPlay:null,onPause:null,onResume:null,onStop:null,onEnd:null};class SM extends Qp{constructor(e,t="Untitled",n={}){super(),this.name=void 0,this.instances=[],this._component=e,this._assets=e.system.app.assets,this._manager=e.system.manager,this.name=t,this._volume=void 0!==n.volume?Eu.clamp(Number(n.volume)||0,0,1):1,this._pitch=void 0!==n.pitch?Math.max(.01,Number(n.pitch)||0):1,this._loop=!(void 0===n.loop||!n.loop),this._duration=n.duration>0?n.duration:null,this._startTime=Math.max(0,Number(n.startTime)||0),this._overlap=!!n.overlap,this._autoPlay=!!n.autoPlay,this._firstNode=null,this._lastNode=null,this._asset=n.asset,this._asset instanceof f_&&(this._asset=this._asset.id),this._onInstancePlayHandler=this._onInstancePlay.bind(this),this._onInstancePauseHandler=this._onInstancePause.bind(this),this._onInstanceResumeHandler=this._onInstanceResume.bind(this),this._onInstanceStopHandler=this._onInstanceStop.bind(this),this._onInstanceEndHandler=this._onInstanceEnd.bind(this)}play(){if(this.overlap||this.stop(),!this.isLoaded&&!this._hasAsset())return;const e=this._createInstance();if(this.instances.push(e),this.isLoaded)e.play();else{const t=function(t){const n=e._playWhenLoaded;e.sound=t,n&&e.play()};this.off("load",t),this.once("load",t),this.load()}return e}pause(){let e=!1;const t=this.instances;for(let n=0,a=t.length;n<a;n++)t[n].pause()&&(e=!0);return e}resume(){let e=!1;const t=this.instances;for(let n=0,a=t.length;n<a;n++)t[n].resume()&&(e=!0);return e}stop(){let e=!1;const t=this.instances;let n=t.length;for(;n--;)t[n].stop(),e=!0;return t.length=0,e}load(){if(!this._hasAsset())return;const e=this._assets.get(this._asset);return e?(e.off("remove",this._onAssetRemoved,this),e.on("remove",this._onAssetRemoved,this),e.resource?void this.fire("load",e.resource):(e.off("load",this._onAssetLoad,this),e.once("load",this._onAssetLoad,this),void this._assets.load(e))):(this._assets.off("add:"+this._asset,this._onAssetAdd,this),void this._assets.once("add:"+this._asset,this._onAssetAdd,this))}setExternalNodes(e,t){if(e){if(t||(t=e),this._firstNode=e,this._lastNode=t,!this._overlap){const n=this.instances;for(let a=0,i=n.length;a<i;a++)n[a].setExternalNodes(e,t)}}else console.error("The firstNode must have a valid AudioNode")}clearExternalNodes(){if(this._firstNode=null,this._lastNode=null,!this._overlap){const e=this.instances;for(let t=0,n=e.length;t<n;t++)e[t].clearExternalNodes()}}getExternalNodes(){return[this._firstNode,this._lastNode]}_hasAsset(){return null!=this._asset}_createInstance(){let e=null;const t=this._component;let n=null;if(this._hasAsset()){const e=this._assets.get(this._asset);e&&(n=e.resource)}const a=EM;return a.volume=this._volume*t.volume,a.pitch=this._pitch*t.pitch,a.loop=this._loop,a.startTime=this._startTime,a.duration=this._duration,a.onPlay=this._onInstancePlayHandler,a.onPause=this._onInstancePauseHandler,a.onResume=this._onInstanceResumeHandler,a.onStop=this._onInstanceStopHandler,a.onEnd=this._onInstanceEndHandler,t.positional?(a.position.copy(t.entity.getPosition()),a.maxDistance=t.maxDistance,a.refDistance=t.refDistance,a.rollOffFactor=t.rollOffFactor,a.distanceModel=t.distanceModel,e=new TM(this._manager,n,a)):e=new CM(this._manager,n,a),this._firstNode&&e.setExternalNodes(this._firstNode,this._lastNode),e}_onInstancePlay(e){this.fire("play",e),this._component.fire("play",this,e)}_onInstancePause(e){this.fire("pause",e),this._component.fire("pause",this,e)}_onInstanceResume(e){this.fire("resume",e),this._component.fire("resume",this,e)}_onInstanceStop(e){const t=this.instances.indexOf(e);-1!==t&&this.instances.splice(t,1),this.fire("stop",e),this._component.fire("stop",this,e)}_onInstanceEnd(e){const t=this.instances.indexOf(e);-1!==t&&this.instances.splice(t,1),this.fire("end",e),this._component.fire("end",this,e)}_onAssetAdd(e){this.load()}_onAssetLoad(e){this.load()}_onAssetRemoved(e){e.off("remove",this._onAssetRemoved,this),this._assets.off("add:"+e.id,this._onAssetAdd,this),this.stop()}updatePosition(e){const t=this.instances;for(let n=0,a=t.length;n<a;n++)t[n].position=e}set asset(e){const t=this._asset;if(t){this._assets.off("add:"+t,this._onAssetAdd,this);const e=this._assets.get(t);e&&e.off("remove",this._onAssetRemoved,this)}this._asset=e,this._asset instanceof f_&&(this._asset=this._asset.id),this._hasAsset()&&this._component.enabled&&this._component.entity.enabled&&this.load()}get asset(){return this._asset}set autoPlay(e){this._autoPlay=!!e}get autoPlay(){return this._autoPlay}set duration(e){if(this._duration=Math.max(0,Number(e)||0)||null,!this._overlap){const e=this.instances;for(let t=0,n=e.length;t<n;t++)e[t].duration=this._duration}}get duration(){let e=0;if(this._hasAsset()){const t=this._assets.get(this._asset);e=null!=t&&t.resource?t.resource.duration:0}return null!=this._duration?this._duration%(e||1):e}get isLoaded(){if(this._hasAsset()){const e=this._assets.get(this._asset);if(e)return!!e.resource}return!1}get isPaused(){const e=this.instances,t=e.length;if(0===t)return!1;for(let n=0;n<t;n++)if(!e[n].isPaused)return!1;return!0}get isPlaying(){const e=this.instances;for(let t=0,n=e.length;t<n;t++)if(e[t].isPlaying)return!0;return!1}get isStopped(){const e=this.instances;for(let t=0,n=e.length;t<n;t++)if(!e[t].isStopped)return!1;return!0}set loop(e){this._loop=!!e;const t=this.instances;for(let e=0,n=t.length;e<n;e++)t[e].loop=this._loop}get loop(){return this._loop}set overlap(e){this._overlap=!!e}get overlap(){return this._overlap}set pitch(e){if(this._pitch=Math.max(Number(e)||0,.01),!this._overlap){const e=this.instances;for(let t=0,n=e.length;t<n;t++)e[t].pitch=this.pitch*this._component.pitch}}get pitch(){return this._pitch}set startTime(e){if(this._startTime=Math.max(0,Number(e)||0),!this._overlap){const e=this.instances;for(let t=0,n=e.length;t<n;t++)e[t].startTime=this._startTime}}get startTime(){return this._startTime}set volume(e){if(this._volume=Eu.clamp(Number(e)||0,0,1),!this._overlap){const e=this.instances;for(let t=0,n=e.length;t<n;t++)e[t].volume=this._volume*this._component.volume}}get volume(){return this._volume}}class AM extends Ux{constructor(e,t){super(e,t),this._volume=1,this._pitch=1,this._positional=!0,this._refDistance=1,this._maxDistance=1e4,this._rollOffFactor=1,this._distanceModel="linear",this._slots={},this._playingBeforeDisable={}}_updateSoundInstances(e,t,n){const a=this._slots;for(const i in a){const s=a[i];if(!s.overlap){const a=s.instances;for(let i=0,r=a.length;i<r;i++)a[i][e]=n?s[e]*t:t}}}set distanceModel(e){this._distanceModel=e,this._updateSoundInstances("distanceModel",e,!1)}get distanceModel(){return this._distanceModel}set maxDistance(e){this._maxDistance=e,this._updateSoundInstances("maxDistance",e,!1)}get maxDistance(){return this._maxDistance}set refDistance(e){this._refDistance=e,this._updateSoundInstances("refDistance",e,!1)}get refDistance(){return this._refDistance}set rollOffFactor(e){this._rollOffFactor=e,this._updateSoundInstances("rollOffFactor",e,!1)}get rollOffFactor(){return this._rollOffFactor}set pitch(e){this._pitch=e,this._updateSoundInstances("pitch",e,!0)}get pitch(){return this._pitch}set volume(e){this._volume=e,this._updateSoundInstances("volume",e,!0)}get volume(){return this._volume}set positional(e){this._positional=e;const t=this._slots;for(const e in t){const n=t[e];if(!n.overlap){const e=n.instances;for(let t=e.length-1;t>=0;t--){const a=e[t].isPlaying||e[t].isSuspended,i=e[t].currentTime;a&&e[t].stop();const s=n._createInstance();a&&(s.play(),s.currentTime=i),e.push(s)}}}}get positional(){return this._positional}set slots(e){const t=this._slots;if(t)for(const e in t)t[e].stop();const n={};for(const t in e)e[t]instanceof SM?n[e[t].name]=e[t]:e[t].name&&(n[e[t].name]=new SM(this,e[t].name,e[t]));this._slots=n,this.enabled&&this.entity.enabled&&this.onEnable()}get slots(){return this._slots}onEnable(){if(this.system._inTools)return;const e=this._slots,t=this._playingBeforeDisable;for(const n in e){const a=e[n];a.autoPlay&&a.isStopped?a.play():t[n]?a.resume():a.isLoaded||a.load()}}onDisable(){const e=this._slots,t={};for(const n in e)e[n].overlap||e[n].isPlaying&&(e[n].pause(),t[n]=!0);this._playingBeforeDisable=t}onRemove(){this.off()}addSlot(e,t){const n=this._slots;if(n[e])return null;const a=new SM(this,e,t);return n[e]=a,a.autoPlay&&this.enabled&&this.entity.enabled&&a.play(),a}removeSlot(e){const t=this._slots;t[e]&&(t[e].stop(),delete t[e])}slot(e){return this._slots[e]}play(e){if(!this.enabled||!this.entity.enabled)return null;const t=this._slots[e];return t?t.play():null}pause(e){const t=this._slots;if(e){const n=t[e];if(!n)return;n.pause()}else for(const e in t)t[e].pause()}resume(e){const t=this._slots;if(e){const n=t[e];if(!n)return;n.isPaused&&n.resume()}else for(const e in t)t[e].resume()}stop(e){const t=this._slots;if(e){const n=t[e];if(!n)return;n.stop()}else for(const e in t)t[e].stop()}}class MM{constructor(){this.enabled=!0}}const LM=["enabled"];class RM extends AC{constructor(e,t){super(e),this.id="sound",this.ComponentType=AM,this.DataType=MM,this.schema=LM,this.manager=t,this.app.systems.on("update",this.onUpdate,this),this.on("beforeremove",this.onBeforeRemove,this)}set volume(e){this.manager.volume=e}get volume(){return this.manager.volume}get context(){return zv()?this.manager.context:null}initializeComponentData(e,t,n){n=["volume","pitch","positional","refDistance","maxDistance","rollOffFactor","distanceModel","slots"];for(let a=0;a<n.length;a++)t.hasOwnProperty(n[a])&&(e[n[a]]=t[n[a]]);super.initializeComponentData(e,t,["enabled"])}cloneComponent(e,t){const n=e.sound,a=n.slots,i={};for(const e in a){const t=a[e];i[e]={name:t.name,volume:t.volume,pitch:t.pitch,loop:t.loop,duration:t.duration,startTime:t.startTime,overlap:t.overlap,autoPlay:t.autoPlay,asset:t.asset}}const s={distanceModel:n.distanceModel,enabled:n.enabled,maxDistance:n.maxDistance,pitch:n.pitch,positional:n.positional,refDistance:n.refDistance,rollOffFactor:n.rollOffFactor,slots:i,volume:n.volume};return this.addComponent(t,s)}onUpdate(e){const t=this.store;for(const e in t)if(t.hasOwnProperty(e)){const n=t[e].entity;if(n.enabled){const e=n.sound;if(e.enabled&&e.positional){const t=n.getPosition(),a=e.slots;for(const e in a)a[e].updatePosition(t)}}}}onBeforeRemove(e,t){const n=t.slots;for(const e in n)n[e].overlap||n[e].stop();t.onRemove()}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this)}}Ux._buildAccessors(AM.prototype,LM);class IM extends Qp{constructor(e,t){super(),this._component=e,this._frame=0,this._sprite=null,this._spriteAsset=null,this.spriteAsset=t.spriteAsset,this.name=t.name,this.fps=t.fps||0,this.loop=t.loop||!1,this._playing=!1,this._paused=!1,this._time=0}get duration(){if(this._sprite){const e=this.fps||Number.MIN_VALUE;return this._sprite.frameKeys.length/Math.abs(e)}return 0}set frame(e){this._setFrame(e);const t=this.fps||Number.MIN_VALUE;this._setTime(this._frame/t)}get frame(){return this._frame}get isPaused(){return this._paused}get isPlaying(){return this._playing}set sprite(e){if(this._sprite&&(this._sprite.off("set:meshes",this._onSpriteMeshesChange,this),this._sprite.off("set:pixelsPerUnit",this._onSpritePpuChanged,this),this._sprite.off("set:atlas",this._onSpriteMeshesChange,this),this._sprite.atlas&&this._sprite.atlas.off("set:texture",this._onSpriteMeshesChange,this)),this._sprite=e,this._sprite&&(this._sprite.on("set:meshes",this._onSpriteMeshesChange,this),this._sprite.on("set:pixelsPerUnit",this._onSpritePpuChanged,this),this._sprite.on("set:atlas",this._onSpriteMeshesChange,this),this._sprite.atlas&&this._sprite.atlas.on("set:texture",this._onSpriteMeshesChange,this)),this._component.currentClip===this){let t;e&&e.atlas?(e.atlas.texture&&(t=this._component._meshInstance,t&&(t.setParameter("texture_emissiveMap",e.atlas.texture),t.setParameter("texture_opacityMap",e.atlas.texture)),this._component.enabled&&this._component.entity.enabled&&this._component._showModel()),this.time&&this.fps?this.time=this.time:this.frame=this.frame):(t=this._component._meshInstance,t&&(t.deleteParameter("texture_emissiveMap"),t.deleteParameter("texture_opacityMap")),this._component._hideModel())}}get sprite(){return this._sprite}set spriteAsset(e){const t=this._component.system.app.assets;let n=e;if(e instanceof f_&&(n=e.id),this._spriteAsset!==n){if(this._spriteAsset){const e=t.get(this._spriteAsset);e&&this._unbindSpriteAsset(e)}if(this._spriteAsset=n,this._spriteAsset){const e=t.get(this._spriteAsset);e?this._bindSpriteAsset(e):(this.sprite=null,t.on("add:"+this._spriteAsset,this._onSpriteAssetAdded,this))}else this.sprite=null}}get spriteAsset(){return this._spriteAsset}set time(e){this._setTime(e),this._sprite?this.frame=Math.min(this._sprite.frameKeys.length-1,Math.floor(this._time*Math.abs(this.fps))):this.frame=0}get time(){return this._time}_onSpriteAssetAdded(e){this._component.system.app.assets.off("add:"+e.id,this._onSpriteAssetAdded,this),this._spriteAsset===e.id&&this._bindSpriteAsset(e)}_bindSpriteAsset(e){e.on("load",this._onSpriteAssetLoad,this),e.on("remove",this._onSpriteAssetRemove,this),e.resource?this._onSpriteAssetLoad(e):this._component.system.app.assets.load(e)}_unbindSpriteAsset(e){e.off("load",this._onSpriteAssetLoad,this),e.off("remove",this._onSpriteAssetRemove,this),e.resource&&e.resource.atlas&&this._component.system.app.assets.off("load:"+e.data.textureAtlasAsset,this._onTextureAtlasLoad,this)}_onSpriteAssetLoad(e){if(e.resource)if(e.resource.atlas)this.sprite=e.resource;else{const t=e.data.textureAtlasAsset,n=this._component.system.app.assets;n.off("load:"+t,this._onTextureAtlasLoad,this),n.once("load:"+t,this._onTextureAtlasLoad,this)}else this.sprite=null}_onTextureAtlasLoad(e){const t=this._spriteAsset;t instanceof f_?this._onSpriteAssetLoad(t):this._onSpriteAssetLoad(this._component.system.app.assets.get(t))}_onSpriteAssetRemove(e){this.sprite=null}_onSpriteMeshesChange(){this._component.currentClip===this&&this._component._showFrame(this.frame)}_onSpritePpuChanged(){this._component.currentClip===this&&0!==this.sprite.renderMode&&this._component._showFrame(this.frame)}_update(e){if(0===this.fps)return;if(!this._playing||this._paused||!this._sprite)return;const t=this.fps<0?-1:1,n=this._time+e*this._component.speed*t,a=this.duration,i=n>a||n<0;this._setTime(n);let s=this.frame;s=this._sprite?Math.floor(this._sprite.frameKeys.length*this._time/a):0,s!==this._frame&&this._setFrame(s),i&&(this.loop?(this.fire("loop"),this._component.fire("loop",this)):(this._playing=!1,this._paused=!1,this.fire("end"),this._component.fire("end",this)))}_setTime(e){this._time=e;const t=this.duration;this._time<0?this.loop?this._time=this._time%t+t:this._time=0:this._time>t&&(this.loop?this._time%=t:this._time=t)}_setFrame(e){this._sprite?this._frame=Eu.clamp(e,0,this._sprite.frameKeys.length-1):this._frame=e,this._component.currentClip===this&&this._component._showFrame(this._frame)}_destroy(){this._sprite&&(this.sprite=null),this._spriteAsset&&(this.spriteAsset=null)}play(){this._playing||(this._playing=!0,this._paused=!1,this.frame=0,this.fire("play"),this._component.fire("play",this))}pause(){this._playing&&!this._paused&&(this._paused=!0,this.fire("pause"),this._component.fire("pause",this))}resume(){this._paused&&(this._paused=!1,this.fire("resume"),this._component.fire("resume",this))}stop(){this._playing&&(this._playing=!1,this._paused=!1,this._time=0,this.frame=0,this.fire("stop"),this._component.fire("stop",this))}}class PM extends Ux{constructor(e,t){super(e,t),this._type="simple",this._material=e.defaultMaterial,this._color=new Mu(1,1,1,1),this._colorUniform=new Float32Array(3),this._speed=1,this._flipX=!1,this._flipY=!1,this._width=1,this._height=1,this._drawOrder=0,this._layers=[0],this._outerScale=new Du(1,1),this._outerScaleUniform=new Float32Array(2),this._innerOffset=new Ou,this._innerOffsetUniform=new Float32Array(4),this._atlasRect=new Ou,this._atlasRectUniform=new Float32Array(4),this._batchGroupId=-1,this._batchGroup=null,this._node=new hf,this._model=new Dv,this._model.graph=this._node,this._meshInstance=null,t.addChild(this._model.graph),this._model._entity=t,this._updateAabbFunc=this._updateAabb.bind(this),this._addedModel=!1,this._autoPlayClip=null,this._clips={},this._defaultClip=new IM(this,{name:this.entity.name,fps:0,loop:!1,spriteAsset:null}),this._currentClip=this._defaultClip}set type(e){this._type!==e&&(this._type=e,"simple"===this._type?(this.stop(),this._currentClip=this._defaultClip,this.enabled&&this.entity.enabled&&(this._currentClip.frame=this.frame,this._currentClip.sprite?this._showModel():this._hideModel())):"animated"===this._type&&(this.stop(),this._autoPlayClip&&this._tryAutoPlay(),this._currentClip&&this._currentClip.isPlaying&&this.enabled&&this.entity.enabled?this._showModel():this._hideModel()))}get type(){return this._type}set frame(e){this._currentClip.frame=e}get frame(){return this._currentClip.frame}set spriteAsset(e){this._defaultClip.spriteAsset=e}get spriteAsset(){return this._defaultClip._spriteAsset}set sprite(e){this._currentClip.sprite=e}get sprite(){return this._currentClip.sprite}set material(e){this._material=e,this._meshInstance&&(this._meshInstance.material=e)}get material(){return this._material}set color(e){this._color.r=e.r,this._color.g=e.g,this._color.b=e.b,this._meshInstance&&(this._colorUniform[0]=this._color.r,this._colorUniform[1]=this._color.g,this._colorUniform[2]=this._color.b,this._meshInstance.setParameter("material_emissive",this._colorUniform))}get color(){return this._color}set opacity(e){this._color.a=e,this._meshInstance&&this._meshInstance.setParameter("material_opacity",e)}get opacity(){return this._color.a}set clips(e){if(e){for(const t in this._clips){let n=!1;for(const a in e)if(e[a].name===t){n=!0,this._clips[t].fps=e[a].fps,this._clips[t].loop=e[a].loop,e[a].hasOwnProperty("sprite")?this._clips[t].sprite=e[a].sprite:e[a].hasOwnProperty("spriteAsset")&&(this._clips[t].spriteAsset=e[a].spriteAsset);break}n||this.removeClip(t)}for(const t in e)this._clips[e[t].name]||this.addClip(e[t]);this._autoPlayClip&&this._tryAutoPlay(),this._currentClip&&this._currentClip.sprite||this._hideModel()}else for(const e in this._clips)this.removeClip(e)}get clips(){return this._clips}get currentClip(){return this._currentClip}set speed(e){this._speed=e}get speed(){return this._speed}set flipX(e){this._flipX!==e&&(this._flipX=e,this._updateTransform())}get flipX(){return this._flipX}set flipY(e){this._flipY!==e&&(this._flipY=e,this._updateTransform())}get flipY(){return this._flipY}set width(e){e!==this._width&&(this._width=e,this._outerScale.x=this._width,!this.sprite||2!==this.sprite.renderMode&&1!==this.sprite.renderMode||this._updateTransform())}get width(){return this._width}set height(e){e!==this._height&&(this._height=e,this._outerScale.y=this.height,!this.sprite||2!==this.sprite.renderMode&&1!==this.sprite.renderMode||this._updateTransform())}get height(){return this._height}set batchGroupId(e){if(this._batchGroupId===e)return;const t=this._batchGroupId;this._batchGroupId=e,this.entity.enabled&&t>=0&&this.system.app.batcher.remove(gy.SPRITE,t,this.entity),this.entity.enabled&&e>=0?this.system.app.batcher.insert(gy.SPRITE,e,this.entity):t>=0&&this._currentClip&&this._currentClip.sprite&&this.enabled&&this.entity.enabled&&this._showModel()}get batchGroupId(){return this._batchGroupId}set autoPlayClip(e){this._autoPlayClip=e instanceof IM?e.name:e,this._tryAutoPlay()}get autoPlayClip(){return this._autoPlayClip}set drawOrder(e){this._drawOrder=e,this._meshInstance&&(this._meshInstance.drawOrder=e)}get drawOrder(){return this._drawOrder}set layers(e){this._addedModel&&this._hideModel(),this._layers=e,this._meshInstance&&this.enabled&&this.entity.enabled&&this._showModel()}get layers(){return this._layers}get aabb(){return this._meshInstance?this._meshInstance.aabb:null}onEnable(){const e=this.system.app,t=e.scene;t.on("set:layers",this._onLayersChanged,this),t.layers&&(t.layers.on("add",this._onLayerAdded,this),t.layers.on("remove",this._onLayerRemoved,this)),this._showModel(),this._autoPlayClip&&this._tryAutoPlay(),this._batchGroupId>=0&&e.batcher.insert(gy.SPRITE,this._batchGroupId,this.entity)}onDisable(){const e=this.system.app,t=e.scene;t.off("set:layers",this._onLayersChanged,this),t.layers&&(t.layers.off("add",this._onLayerAdded,this),t.layers.off("remove",this._onLayerRemoved,this)),this.stop(),this._hideModel(),this._batchGroupId>=0&&e.batcher.remove(gy.SPRITE,this._batchGroupId,this.entity)}onDestroy(){this._currentClip=null,this._defaultClip&&(this._defaultClip._destroy(),this._defaultClip=null);for(const e in this._clips)this._clips[e]._destroy();this._clips=null,this._hideModel(),this._model=null,this._node&&(this._node.parent&&this._node.parent.removeChild(this._node),this._node=null),this._meshInstance&&(this._meshInstance.material=null,this._meshInstance.mesh=null,this._meshInstance=null)}_showModel(){if(this._addedModel)return;if(!this._meshInstance)return;const e=[this._meshInstance];for(let t=0,n=this._layers.length;t<n;t++){const n=this.system.app.scene.layers.getLayerById(this._layers[t]);n&&n.addMeshInstances(e)}this._addedModel=!0}_hideModel(){if(!this._addedModel||!this._meshInstance)return;const e=[this._meshInstance];for(let t=0,n=this._layers.length;t<n;t++){const n=this.system.app.scene.layers.getLayerById(this._layers[t]);n&&n.removeMeshInstances(e)}this._addedModel=!1}_showFrame(e){if(!this.sprite)return;const t=this.sprite.meshes[e];if(!t)return void(this._meshInstance&&(this._meshInstance.mesh=null,this._meshInstance.visible=!1));let n;if(n=1===this.sprite.renderMode?this.system.default9SlicedMaterialSlicedMode:2===this.sprite.renderMode?this.system.default9SlicedMaterialTiledMode:this.system.defaultMaterial,this._meshInstance||(this._meshInstance=new Ay(t,this._material,this._node),this._meshInstance.castShadow=!1,this._meshInstance.receiveShadow=!1,this._meshInstance.drawOrder=this._drawOrder,this._model.meshInstances.push(this._meshInstance),this._colorUniform[0]=this._color.r,this._colorUniform[1]=this._color.g,this._colorUniform[2]=this._color.b,this._meshInstance.setParameter("material_emissive",this._colorUniform),this._meshInstance.setParameter("material_opacity",this._color.a),this.enabled&&this.entity.enabled&&this._showModel()),this._meshInstance.material!==n&&(this._meshInstance.material=n),this._meshInstance.mesh!==t&&(this._meshInstance.mesh=t,this._meshInstance.visible=!0,this._meshInstance._aabbVer=-1),this.sprite.atlas&&this.sprite.atlas.texture?(this._meshInstance.setParameter("texture_emissiveMap",this.sprite.atlas.texture),this._meshInstance.setParameter("texture_opacityMap",this.sprite.atlas.texture)):(this._meshInstance.deleteParameter("texture_emissiveMap"),this._meshInstance.deleteParameter("texture_opacityMap")),!this.sprite.atlas||1!==this.sprite.renderMode&&2!==this.sprite.renderMode)this._meshInstance._updateAabbFunc=null;else{this._meshInstance._updateAabbFunc=this._updateAabbFunc;const t=this.sprite.atlas.frames[this.sprite.frameKeys[e]];if(t){const e=2/t.rect.z,n=2/t.rect.w;this._innerOffset.set(t.border.x*e,t.border.y*n,t.border.z*e,t.border.w*n);const a=this.sprite.atlas.texture;this._atlasRect.set(t.rect.x/a.width,t.rect.y/a.height,t.rect.z/a.width,t.rect.w/a.height)}else this._innerOffset.set(0,0,0,0);this._innerOffsetUniform[0]=this._innerOffset.x,this._innerOffsetUniform[1]=this._innerOffset.y,this._innerOffsetUniform[2]=this._innerOffset.z,this._innerOffsetUniform[3]=this._innerOffset.w,this._meshInstance.setParameter("innerOffset",this._innerOffsetUniform),this._atlasRectUniform[0]=this._atlasRect.x,this._atlasRectUniform[1]=this._atlasRect.y,this._atlasRectUniform[2]=this._atlasRect.z,this._atlasRectUniform[3]=this._atlasRect.w,this._meshInstance.setParameter("atlasRect",this._atlasRectUniform)}this._updateTransform()}_updateTransform(){let e=this.flipX?-1:1,t=this.flipY?-1:1,n=0,a=0;if(this.sprite&&(1===this.sprite.renderMode||2===this.sprite.renderMode)){let i=1,s=1;if(this.sprite.atlas){const e=this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];e&&(i=e.rect.z,s=e.rect.w,n=(.5-e.pivot.x)*this._width,a=(.5-e.pivot.y)*this._height)}const r=i/this.sprite.pixelsPerUnit,o=s/this.sprite.pixelsPerUnit;this._outerScale.set(Math.max(this._width,this._innerOffset.x*r),Math.max(this._height,this._innerOffset.y*o)),e*=r,t*=o,this._outerScale.x/=r,this._outerScale.y/=o,e*=Eu.clamp(this._width/(this._innerOffset.x*r),1e-4,1),t*=Eu.clamp(this._height/(this._innerOffset.y*o),1e-4,1),this._meshInstance&&(this._outerScaleUniform[0]=this._outerScale.x,this._outerScaleUniform[1]=this._outerScale.y,this._meshInstance.setParameter("outerScale",this._outerScaleUniform))}this._node.setLocalScale(e,t,1),this._node.setLocalPosition(n,a,0)}_updateAabb(e){return e.center.set(0,0,0),e.halfExtents.set(.5*this._outerScale.x,.5*this._outerScale.y,.001),e.setFromTransformedAabb(e,this._node.getWorldTransform()),e}_tryAutoPlay(){if(!this._autoPlayClip)return;if("animated"!==this.type)return;const e=this._clips[this._autoPlayClip];!e||e.isPlaying||this._currentClip&&this._currentClip.isPlaying||this.enabled&&this.entity.enabled&&this.play(e.name)}_onLayersChanged(e,t){e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this),this.enabled&&this.entity.enabled&&this._showModel()}_onLayerAdded(e){this.layers.indexOf(e.id)<0||this._addedModel&&this.enabled&&this.entity.enabled&&this._meshInstance&&e.addMeshInstances([this._meshInstance])}_onLayerRemoved(e){if(!this._meshInstance)return;this.layers.indexOf(e.id)<0||e.removeMeshInstances([this._meshInstance])}removeModelFromLayers(){for(let e=0;e<this.layers.length;e++){const t=this.system.app.scene.layers.getLayerById(this.layers[e]);t&&t.removeMeshInstances([this._meshInstance])}}addClip(e){const t=new IM(this,{name:e.name,fps:e.fps,loop:e.loop,spriteAsset:e.spriteAsset});return this._clips[e.name]=t,t.name&&t.name===this._autoPlayClip&&this._tryAutoPlay(),t}removeClip(e){delete this._clips[e]}clip(e){return this._clips[e]}play(e){const t=this._clips[e],n=this._currentClip;return n&&n!==t&&(n._playing=!1),this._currentClip=t,this._currentClip&&(this._currentClip=t,this._currentClip.play()),t}pause(){this._currentClip!==this._defaultClip&&this._currentClip.isPlaying&&this._currentClip.pause()}resume(){this._currentClip!==this._defaultClip&&this._currentClip.isPaused&&this._currentClip.resume()}stop(){this._currentClip!==this._defaultClip&&this._currentClip.stop()}}class kM{constructor(){this.enabled=!0}}const DM=["enabled"];class OM extends AC{constructor(e){super(e),this.id="sprite",this.ComponentType=PM,this.DataType=kM,this.schema=DM,this._defaultTexture=null,this._defaultMaterial=null,this._default9SlicedMaterialSlicedMode=null,this._default9SlicedMaterialTiledMode=null,this.app.systems.on("update",this.onUpdate,this),this.on("beforeremove",this.onBeforeRemove,this)}set defaultMaterial(e){this._defaultMaterial=e}get defaultMaterial(){if(!this._defaultMaterial){const e=new Gm(this.app.graphicsDevice,{width:1,height:1,format:7}),t=new Uint8Array(e.lock());t[0]=t[1]=t[2]=t[3]=255,e.name="sprite",e.unlock();const n=new cg;n.diffuse.set(0,0,0),n.emissive.set(.5,.5,.5),n.emissiveMap=e,n.emissiveMapTint=!0,n.opacityMap=e,n.opacityMapChannel="a",n.opacityTint=!0,n.opacity=0,n.useLighting=!1,n.useGammaTonemap=!1,n.useFog=!1,n.useSkybox=!1,n.blendType=4,n.depthWrite=!1,n.pixelSnap=!1,n.cull=0,n.update(),this._defaultTexture=e,this._defaultMaterial=n}return this._defaultMaterial}set default9SlicedMaterialSlicedMode(e){this._default9SlicedMaterialSlicedMode=e}get default9SlicedMaterialSlicedMode(){if(!this._default9SlicedMaterialSlicedMode){const e=this.defaultMaterial.clone();e.nineSlicedMode=1,e.update(),this._default9SlicedMaterialSlicedMode=e}return this._default9SlicedMaterialSlicedMode}set default9SlicedMaterialTiledMode(e){this._default9SlicedMaterialTiledMode=e}get default9SlicedMaterialTiledMode(){if(!this._default9SlicedMaterialTiledMode){const e=this.defaultMaterial.clone();e.nineSlicedMode=2,e.update(),this._default9SlicedMaterialTiledMode=e}return this._default9SlicedMaterialTiledMode}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this),this._defaultTexture&&(this._defaultTexture.destroy(),this._defaultTexture=null)}initializeComponentData(e,t,n){if(void 0!==t.enabled&&(e.enabled=t.enabled),e.type=t.type,t.layers&&Array.isArray(t.layers)&&(e.layers=t.layers.slice(0)),void 0!==t.drawOrder&&(e.drawOrder=t.drawOrder),void 0!==t.color&&(t.color instanceof Mu?e.color.set(t.color.r,t.color.g,t.color.b,void 0!==t.opacity?t.opacity:1):e.color.set(t.color[0],t.color[1],t.color[2],void 0!==t.opacity?t.opacity:1),e.color=e.color),void 0!==t.opacity&&(e.opacity=t.opacity),void 0!==t.flipX&&(e.flipX=t.flipX),void 0!==t.flipY&&(e.flipY=t.flipY),void 0!==t.width&&(e.width=t.width),void 0!==t.height&&(e.height=t.height),void 0!==t.spriteAsset&&(e.spriteAsset=t.spriteAsset),t.sprite&&(e.sprite=t.sprite),void 0!==t.frame&&(e.frame=t.frame),t.clips)for(const n in t.clips)e.addClip(t.clips[n]);void 0!==t.speed&&(e.speed=t.speed),t.autoPlayClip&&(e.autoPlayClip=t.autoPlayClip),e.batchGroupId=void 0===t.batchGroupId||null===t.batchGroupId?-1:t.batchGroupId,super.initializeComponentData(e,t,n)}cloneComponent(e,t){const n=e.sprite;return this.addComponent(t,{enabled:n.enabled,type:n.type,spriteAsset:n.spriteAsset,sprite:n.sprite,frame:n.frame,color:n.color.clone(),opacity:n.opacity,flipX:n.flipX,flipY:n.flipY,speed:n.speed,clips:n.clips,autoPlayClip:n.autoPlayClip,batchGroupId:n.batchGroupId,drawOrder:n.drawOrder,layers:n.layers.slice(0)})}onUpdate(e){const t=this.store;for(const n in t)if(t.hasOwnProperty(n)){const a=t[n];if(a.data.enabled&&a.entity.enabled){const t=a.entity.sprite;t._currentClip&&t._currentClip._update(e)}}}onBeforeRemove(e,t){t.onDestroy()}}Ux._buildAccessors(PM.prototype,DM);class FM extends Ux{constructor(e,t){super(e,t),this._oldState=!0,this._size=new Pu,this.on("set_enabled",this._onSetEnabled,this)}set size(e){e instanceof Pu?this._size.copy(e):e instanceof Array&&e.length>=3&&this.size.set(e[0],e[1],e[2])}get size(){return this._size}onEnable(){this._checkState()}onDisable(){this._checkState()}_onSetEnabled(e,t,n){this._checkState()}_checkState(){const e=this.enabled&&this.entity.enabled;e!==this._oldState&&(this._oldState=e,this.fire("enable"),this.fire("state",this.enabled))}_onBeforeRemove(){this.fire("remove")}}class NM{constructor(){this.enabled=!0}}const VM=["enabled"];class BM extends AC{constructor(e){super(e),this.id="zone",this.ComponentType=FM,this.DataType=NM,this.schema=VM,this.on("beforeremove",this._onBeforeRemove,this)}initializeComponentData(e,t,n){e.enabled=!t.hasOwnProperty("enabled")||!!t.enabled,t.size&&(t.size instanceof Pu?e.size.copy(t.size):t.size instanceof Array&&t.size.length>=3&&e.size.set(t.size[0],t.size[1],t.size[2]))}cloneComponent(e,t){const n={size:e.zone.size};return this.addComponent(t,n)}_onBeforeRemove(e,t){t._onBeforeRemove()}}Ux._buildAccessors(FM.prototype,VM);class UM{constructor(e){this.frame={fps:0,ms:0,dt:0,updateStart:0,updateTime:0,renderStart:0,renderTime:0,physicsStart:0,physicsTime:0,cullTime:0,sortTime:0,skinTime:0,morphTime:0,instancingTime:0,triangles:0,otherPrimitives:0,shaders:0,materials:0,cameras:0,shadowMapUpdates:0,shadowMapTime:0,depthMapTime:0,forwardTime:0,lightClustersTime:0,lightClusters:0,_timeToCountFrames:0,_fpsAccum:0},this.drawCalls={forward:0,depth:0,shadow:0,immediate:0,misc:0,total:0,skinned:0,instanced:0,removedByInstancing:0},this.misc={renderTargetCreationTime:0},this.particles={updatesPerFrame:0,_updatesPerFrame:0,frameTime:0,_frameTime:0},this.shaders=e._shaderStats,this.vram=e._vram,Object.defineProperty(this.vram,"totalUsed",{get:function(){return this.tex+this.vb+this.ib}}),Object.defineProperty(this.vram,"geom",{get:function(){return this.vb+this.ib}})}get scene(){return Jg().scene._stats}get lightmapper(){return Jg().lightmapper.stats}get batcher(){return Jg().batcher._stats}}class zM{constructor(e,t){this.name=e,this.url=t,this.data=null,this._loading=!1,this._onLoadedCallbacks=[]}get loaded(){return!!this.data}get loading(){return this._loading}}class GM{constructor(e){this._app=e,this._list=[],this._index={},this._urlIndex={}}destroy(){this._app=null}list(){return this._list}add(e,t){if(this._index.hasOwnProperty(e))return!1;const n=new zM(e,t),a=this._list.push(n);return this._index[n.name]=a-1,this._urlIndex[n.url]=a-1,!0}find(e){return this._index.hasOwnProperty(e)?this._list[this._index[e]]:null}findByUrl(e){return this._urlIndex.hasOwnProperty(e)?this._list[this._urlIndex[e]]:null}remove(e){if(this._index.hasOwnProperty(e)){const t=this._index[e];let n=this._list[t];delete this._urlIndex[n.url],delete this._index[e],this._list.splice(t,1);for(let e=0;e<this._list.length;e++)n=this._list[e],this._index[n.name]=e,this._urlIndex[n.url]=e}}_loadSceneData(e,t,n){let a=e;if(e instanceof zM?a=e.url:(e=this.findByUrl(a))||(e=new zM("Untitled",a)),!e.url)return void n("URL or SceneRegistryItem is null when loading a scene");if(e.loaded)return void n(null,e);const i=this._app.loader.getHandler("hierarchy");this._app.assets&&this._app.assets.prefix&&!h_.test(a)&&(a=tu.join(this._app.assets.prefix,a)),e._onLoadedCallbacks.push(n),e._loading||i.load(a,(function(n,a){e.data=a,e._loading=!1;for(let t=0;t<e._onLoadedCallbacks.length;t++)e._onLoadedCallbacks[t](n,e);t||(e.data=null),e._onLoadedCallbacks.length=0})),e._loading=!0}loadSceneData(e,t){this._loadSceneData(e,!0,t)}unloadSceneData(e){"string"==typeof e&&(e=this.findByUrl(e)),e&&(e.data=null)}loadSceneHierarchy(e,t){const n=this,a=this._app.loader.getHandler("hierarchy");this._loadSceneData(e,!1,(function(e,i){if(e)return void(t&&t(e));const s=i.url,r=i.data;n._app._preloadScripts(r,(function(){n._app.systems.script.preloading=!0;const i=a.open(s,r);n._app.systems.script.preloading=!1,n._app.loader.clearCache(s,"hierarchy"),n._app.root.addChild(i),n._app.systems.fire("initialize",i),n._app.systems.fire("postInitialize",i),n._app.systems.fire("postPostInitialize",i),t&&t(e,i)}))}))}loadSceneSettings(e,t){const n=this;this._loadSceneData(e,!1,(function(e,a){e?t&&t(e):(n._app.applySceneSettings(a.data.settings),t&&t(null))}))}loadScene(e,t){const n=this,a=this._app.loader.getHandler("scene");this._app.assets&&this._app.assets.prefix&&!h_.test(e)&&(e=tu.join(this._app.assets.prefix,e)),a.load(e,(function(i,s){if(i)t&&t(i);else{const i=function(){n._app.systems.script.preloading=!0;const i=a.open(e,s),r=n.findByUrl(e);r&&!r.loaded&&(r.data=s),n._app.systems.script.preloading=!1,n._app.loader.clearCache(e,"scene"),n._app.loader.patch({resource:i,type:"scene"},n._app.assets),n._app.root.addChild(i.root),n._app.systems.rigidbody&&"undefined"!=typeof Ammo&&n._app.systems.rigidbody.gravity.set(i._gravity.x,i._gravity.y,i._gravity.z),t&&t(null,i)};n._app._preloadScripts(s,i)}}))}}class HM{constructor(e){this.application=e,this.device=e.graphicsDevice,this.clearOptions=null,this.layer=null,this.init()}allocateTexture(e,t,n){const a=new Gm(e,{format:n,width:e.width,height:e.height,mipmaps:!1,minFilter:0,magFilter:0,addressU:1,addressV:1});return a.name=t,e.scope.resolve("uDepthMap").setValue(a),a}allocateRenderTarget(e,t,n,a,i){const s=this.allocateTexture(t,n,a);return e?(e.destroyFrameBuffers(),i?e._depthBuffer=s:e._colorBuffer=s):e=new Cg({colorBuffer:i?null:s,depthBuffer:i?s:null,depth:!i,stencil:t.supportsStencil,autoResolve:!1}),e}releaseRenderTarget(e){e&&(e.destroyTextureBuffers(),e.destroy())}initWebGl2(){const e=this.application,t=this;this.clearOptions={flags:0},this.layer=new rv({enabled:!1,name:"Depth",id:1,onEnable:function(){t.releaseRenderTarget(this.renderTarget),this.renderTarget=t.allocateRenderTarget(this.renderTarget,e.graphicsDevice,"rt-depth2",17,!0)},onDisable:function(){t.releaseRenderTarget(this.renderTarget),this.renderTarget=null},onPreRenderOpaque:function(n){const a=e.graphicsDevice.gl;this.srcFbo=a.getParameter(a.FRAMEBUFFER_BINDING),this.renderTarget.width===e.graphicsDevice.width&&this.renderTarget.height===e.graphicsDevice.height||this.onEnable(),this.oldClear=this.cameras[n].camera._clearOptions,this.cameras[n].camera._clearOptions=t.clearOptions},onPostRenderOpaque:function(t){if(this.renderTarget){this.cameras[t].camera._clearOptions=this.oldClear,e.graphicsDevice.setRenderTarget(this.renderTarget),e.graphicsDevice.updateBegin();const n=e.graphicsDevice.gl;n.bindFramebuffer(n.READ_FRAMEBUFFER,this.srcFbo),n.bindFramebuffer(n.DRAW_FRAMEBUFFER,this.renderTarget.impl._glFrameBuffer),n.blitFramebuffer(0,0,this.renderTarget.width,this.renderTarget.height,0,0,this.renderTarget.width,this.renderTarget.height,n.DEPTH_BUFFER_BIT,n.NEAREST)}}})}initWebGl1(){const e=this.application,t=this;this.clearOptions={color:[254/255,254/255,254/255,254/255],depth:1,flags:3},this.layer=new rv({enabled:!1,name:"Depth",id:1,shaderPass:2,onEnable:function(){t.releaseRenderTarget(this.renderTarget),this.renderTarget=t.allocateRenderTarget(this.renderTarget,e.graphicsDevice,"rt-depth1",7,!1)},onDisable:function(){t.releaseRenderTarget(this.renderTarget),this.renderTarget=null},onPostCull:function(t){const n=this.instances.visibleOpaque[t],a=n.list,i=e.scene.layers,s=i.subLayerEnabled,r=i.subLayerList,o=e.scene.layers.getLayerById(0).renderTarget,l=this.cameras[t];let c=0;const h=i.layerList;for(let e=0;e<h.length;e++){const t=h[e];if(t===this)break;if(t.renderTarget!==o||!t.enabled||!s[e])continue;const n=t.cameras.indexOf(l);if(n<0)continue;let i=r[e]?t.instances.visibleTransparent[n]:t.instances.visibleOpaque[n];const d=i.length;i=i.list;for(let e=0;e<d;e++){const t=i[e];t.material&&t.material.depthWrite&&!t._noDepthDrawGl1&&(a[c]=t,c++)}}n.length=c},onPreRenderOpaque:function(n){this.renderTarget.width===e.graphicsDevice.width&&this.renderTarget.height===e.graphicsDevice.height||this.onEnable(),this.oldClear=this.cameras[n].camera._clearOptions,this.cameras[n].camera._clearOptions=t.clearOptions},onDrawCall:function(){e.graphicsDevice.setColorWrite(!0,!0,!0,!0)},onPostRenderOpaque:function(e){this.renderTarget&&(this.cameras[e].camera._clearOptions=this.oldClear)}})}init(){this.device.webgl2?this.initWebGl2():this.initWebGl1()}patch(e){e.onEnable=this.layer.onEnable,e.onDisable=this.layer.onDisable,e.onPreRenderOpaque=this.layer.onPreRenderOpaque,e.onPostRenderOpaque=this.layer.onPostRenderOpaque,e.shaderPass=this.layer.shaderPass,e.onPostCull=this.layer.onPostCull,e.onDrawCall=this.layer.onDrawCall}}class WM{constructor(e){this.length=e,this.count=0}inc(){this.count++}done(){return this.count===this.length}}class jM extends Qp{constructor(e,t={}){super(),jM._applications[e.id]=this,ey(this),this._destroyRequested=!1,this._inFrameUpdate=!1,this._time=0,this.timeScale=1,this.maxDeltaTime=.1,this.frame=0,this.autoRender=!0,this.renderNextFrame=!1,this.useLegacyScriptAttributeCloning=Xw.legacy,this._librariesLoaded=!1,this._fillMode="KEEP_ASPECT",this._resolutionMode="FIXED",this._allowResize=!0,this.context=this,t.graphicsDeviceOptions||(t.graphicsDeviceOptions={}),uu.browser&&navigator.xr&&(t.graphicsDeviceOptions.xrCompatible=!0),t.graphicsDeviceOptions.alpha=t.graphicsDeviceOptions.alpha||!1,this.graphicsDevice=new Zg(e,t.graphicsDeviceOptions),this._initDefaultMaterial(),this.stats=new UM(this.graphicsDevice),this._soundManager=new Xv(t),this.loader=new Gw(this),wf.init(this.graphicsDevice),this._entityIndex={},this.scene=new Uv(this.graphicsDevice),this._registerSceneImmediate(this.scene),this.root=new KM,this.root._enabledInHierarchy=!0,this.assets=new Dx(this.loader),t.assetPrefix&&(this.assets.prefix=t.assetPrefix),this.bundles=new Ox(this.assets),this.enableBundles="undefined"!=typeof TextDecoder,this.scriptsOrder=t.scriptsOrder||[],this.scripts=new Wx(this),this.i18n=new Xx(this),this.scenes=new GM(this);const n=this;this.defaultLayerWorld=new rv({name:"World",id:0}),this.sceneDepth=new HM(this),this.defaultLayerDepth=this.sceneDepth.layer,this.defaultLayerSkybox=new rv({enabled:!0,name:"Skybox",id:2,opaqueSortMode:0}),this.defaultLayerUi=new rv({enabled:!0,name:"UI",id:4,transparentSortMode:1,passThrough:!1}),this.defaultLayerImmediate=new rv({enabled:!0,name:"Immediate",id:3,opaqueSortMode:0,passThrough:!0});const a=new mv("default");a.pushOpaque(this.defaultLayerWorld),a.pushOpaque(this.defaultLayerDepth),a.pushOpaque(this.defaultLayerSkybox),a.pushTransparent(this.defaultLayerWorld),a.pushOpaque(this.defaultLayerImmediate),a.pushTransparent(this.defaultLayerImmediate),a.pushTransparent(this.defaultLayerUi),this.scene.layers=a,this.scene.on("set:layers",(function(e,t){const a=t.layerList;let i;for(let e=0;e<a.length;e++)switch(i=a[e],i.id){case 1:n.sceneDepth.patch(i);break;case 4:i.passThrough=n.defaultLayerUi.passThrough;break;case 3:i.passThrough=n.defaultLayerImmediate.passThrough}})),Iv.createPlaceholder(this.graphicsDevice),this.renderer=new Zb(this.graphicsDevice),this.renderer.scene=this.scene,this.lightmapper=new nL(this.graphicsDevice,this.root,this.scene,this.renderer,this.assets),this.once("prerender",this._firstBake,this),this.batcher=new Ny(this.graphicsDevice,this.root,this.scene),this.once("prerender",this._firstBatch,this),this.keyboard=t.keyboard||null,this.mouse=t.mouse||null,this.touch=t.touch||null,this.gamepads=t.gamepads||null,this.elementInput=t.elementInput||null,this.elementInput&&(this.elementInput.app=this),this.vr=null,this.xr=new SC(this),this.elementInput&&this.elementInput.attachSelectEvents(),this._inTools=!1,this._skyboxAsset=null,this._scriptPrefix=t.scriptPrefix||"",this.enableBundles&&this.loader.addHandler("bundle",new lw(this.assets)),this.loader.addHandler("animation",new q_),this.loader.addHandler("animclip",new K_),this.loader.addHandler("animstategraph",new $_),this.loader.addHandler("model",new Nw(this.graphicsDevice)),this.loader.addHandler("render",new zw(this.assets)),this.loader.addHandler("material",new Rw(this)),this.loader.addHandler("texture",new Px(this.graphicsDevice,this.assets,this.loader)),this.loader.addHandler("text",new ax),this.loader.addHandler("json",new Tw),this.loader.addHandler("audio",new tw(this._soundManager)),this.loader.addHandler("script",new Yw(this)),this.loader.addHandler("scene",new Hw(this)),this.loader.addHandler("cubemap",new dw(this.graphicsDevice,this.assets,this.loader)),this.loader.addHandler("html",new Cw),this.loader.addHandler("css",new hw),this.loader.addHandler("shader",new qw),this.loader.addHandler("hierarchy",new xw(this)),this.loader.addHandler("folder",new pw),this.loader.addHandler("font",new fw(this.loader)),this.loader.addHandler("binary",new nw),this.loader.addHandler("textureatlas",new lx(this.loader)),this.loader.addHandler("sprite",new ex(this.assets,this.graphicsDevice)),this.loader.addHandler("template",new nx(this)),this.loader.addHandler("container",new cw(this.graphicsDevice,this.assets)),this.systems=new sE,this.systems.add(new jA(this)),this.systems.add(new iE(this)),this.systems.add(new WE(this)),this.systems.add(new HC(this)),this.systems.add(new cT(this)),this.systems.add(new wS(this)),this.systems.add(new SS(this)),this.systems.add(new VT(this)),this.systems.add(new yS(this)),Xw.legacy?this.systems.add(new aM(this)):this.systems.add(new JA(this)),this.systems.add(new yT(this,this._soundManager)),this.systems.add(new RM(this,this._soundManager)),this.systems.add(new uT(this,this._soundManager)),this.systems.add(new LA(this)),this.systems.add(new ZA(this)),this.systems.add(new VE(this)),this.systems.add(new RT(this)),this.systems.add(new yM(this)),this.systems.add(new wM(this)),this.systems.add(new OM(this)),this.systems.add(new hS(this)),this.systems.add(new qE(this)),this.systems.add(new BM(this)),this._visibilityChangeHandler=this.onVisibilityChange.bind(this),"undefined"!=typeof document&&(void 0!==document.hidden?(this._hiddenAttr="hidden",document.addEventListener("visibilitychange",this._visibilityChangeHandler,!1)):void 0!==document.mozHidden?(this._hiddenAttr="mozHidden",document.addEventListener("mozvisibilitychange",this._visibilityChangeHandler,!1)):void 0!==document.msHidden?(this._hiddenAttr="msHidden",document.addEventListener("msvisibilitychange",this._visibilityChangeHandler,!1)):void 0!==document.webkitHidden&&(this._hiddenAttr="webkitHidden",document.addEventListener("webkitvisibilitychange",this._visibilityChangeHandler,!1))),this.tick=YM(this)}static getApplication(e){return e?jM._applications[e]:Jg()}_initDefaultMaterial(){const e=new cg;e.name="Default Material",e.shadingModel=1,function(e,t){Zf.get(e,(()=>t))}(this.graphicsDevice,e)}get fillMode(){return this._fillMode}get resolutionMode(){return this._resolutionMode}configure(e,t){Au.get(e,((e,n)=>{if(e)return void t(e);const a=n.application_properties,i=n.scenes,s=n.assets;this._parseApplicationProperties(a,(e=>{this._parseScenes(i),this._parseAssets(s),t(e||null)}))}))}preload(e){this.fire("preload:start");const t=this.assets.list({preload:!0}),n=new WM(t.length);let a=!1;const i=()=>{this.graphicsDevice&&!a&&n.done()&&(a=!0,this.fire("preload:end"),e())},s=t.length;if(n.length){const e=e=>{n.inc(),this.fire("preload:progress",n.count/s),n.done()&&i()},a=(e,t)=>{n.inc(),this.fire("preload:progress",n.count/s),n.done()&&i()};for(let r=0;r<t.length;r++)t[r].loaded?(n.inc(),this.fire("preload:progress",n.count/s),n.done()&&i()):(t[r].once("load",e),t[r].once("error",a),this.assets.load(t[r]))}else i()}_preloadScripts(e,t){if(!Xw.legacy)return void t();this.systems.script.preloading=!0;const n=this._getScriptReferences(e),a=n.length,i=new WM(a),s=/^http(s)?:\/\//;if(a){const e=(e,n)=>{e&&console.error(e),i.inc(),i.done()&&(this.systems.script.preloading=!1,t())};for(let t=0;t<a;t++){let a=n[t];!s.test(a.toLowerCase())&&this._scriptPrefix&&(a=tu.join(self._scriptPrefix,n[t])),this.loader.load(a,"script",e)}}else this.systems.script.preloading=!1,t()}_handleAreaLightDataProperty(e){const t=this.assets.get(e);t?this.setAreaLightLuts(t):this.assets.once("add:"+e,this.setAreaLightLuts,this)}_parseApplicationProperties(e,t){if("number"==typeof e.maxAssetRetries&&e.maxAssetRetries>0&&this.loader.enableRetry(e.maxAssetRetries),e.useDevicePixelRatio||(e.useDevicePixelRatio=e.use_device_pixel_ratio),e.resolutionMode||(e.resolutionMode=e.resolution_mode),e.fillMode||(e.fillMode=e.fill_mode),this._width=e.width,this._height=e.height,e.useDevicePixelRatio&&(this.graphicsDevice.maxPixelRatio=window.devicePixelRatio),this.setCanvasResolution(e.resolutionMode,this._width,this._height),this.setCanvasFillMode(e.fillMode,this._width,this._height),e.layers&&e.layerOrder){const t=new mv("application"),n={};for(const t in e.layers){const a=e.layers[t];a.id=parseInt(t,10),a.enabled=1!==a.id,n[t]=new rv(a)}for(let a=0,i=e.layerOrder.length;a<i;a++){const i=e.layerOrder[a],s=n[i.layer];s&&(i.transparent?t.pushTransparent(s):t.pushOpaque(s),t.subLayerEnabled[a]=i.enabled)}this.scene.layers=t}if(e.batchGroups)for(let t=0,n=e.batchGroups.length;t<n;t++){const n=e.batchGroups[t];this.batcher.addGroup(n.name,n.dynamic,n.maxAabbSize,n.id,n.layers)}e.i18nAssets&&(this.i18n.assets=e.i18nAssets),e.areaLightDataAsset&&this._handleAreaLightDataProperty(e.areaLightDataAsset),this._loadLibraries(e.libraries,t)}_loadLibraries(e,t){const n=e.length;let a=n;const i=/^http(s)?:\/\//;if(n){const s=(e,n)=>{a--,e?t(e):0===a&&(this.onLibrariesLoaded(),t(null))};for(let t=0;t<n;++t){let n=e[t];!i.test(n.toLowerCase())&&this._scriptPrefix&&(n=tu.join(this._scriptPrefix,n)),this.loader.load(n,"script",s)}}else this.onLibrariesLoaded(),t(null)}_parseScenes(e){if(e)for(let t=0;t<e.length;t++)this.scenes.add(e[t].name,e[t].url)}_parseAssets(e){const t=[],n={},a={};if(Xw.legacy){if(this.enableBundles)for(const n in e)"bundle"===e[n].type&&(a[n]=!0,t.push(e[n]));for(const n in e)a[n]||t.push(e[n])}else{for(let a=0;a<this.scriptsOrder.length;a++){const i=this.scriptsOrder[a];e[i]&&(n[i]=!0,t.push(e[i]))}if(this.enableBundles)for(const n in e)"bundle"===e[n].type&&(a[n]=!0,t.push(e[n]));for(const i in e)n[i]||a[i]||t.push(e[i])}for(let e=0;e<t.length;e++){const n=t[e],a=new f_(n.name,n.type,n.file,n.data);if(a.id=parseInt(n.id,10),a.preload=!!n.preload&&n.preload,a.loaded="script"===n.type&&n.data&&n.data.loadingType>0,a.tags.add(n.tags),n.i18n)for(const e in n.i18n)a.addLocalizedAssetId(e,n.i18n[e]);this.assets.add(a)}}_getScriptReferences(e){let t=[];e.settings.priority_scripts&&(t=e.settings.priority_scripts);const n=[],a={};for(let e=0;e<t.length;e++)n.push(t[e]),a[t[e]]=!0;const i=e.entities;for(const e in i){if(!i[e].components.script)continue;const t=i[e].components.script.scripts;for(let e=0;e<t.length;e++)a[t[e].url]||(n.push(t[e].url),a[t[e].url]=!0)}return n}start(){this.frame=0,this.fire("start",{timestamp:xu(),target:this}),this._librariesLoaded||this.onLibrariesLoaded(),this.systems.fire("initialize",this.root),this.fire("initialize"),this.systems.fire("postInitialize",this.root),this.systems.fire("postPostInitialize",this.root),this.fire("postinitialize"),this.tick()}inputUpdate(e){this.controller&&this.controller.update(e),this.mouse&&this.mouse.update(),this.keyboard&&this.keyboard.update(),this.gamepads&&this.gamepads.update()}update(e){this.frame++,this.graphicsDevice.updateClientRect(),this.vr&&this.vr.poll(),Xw.legacy&&this.systems.fire("fixedUpdate",1/60),this.systems.fire(this._inTools?"toolsUpdate":"update",e),this.systems.fire("animationUpdate",e),this.systems.fire("postUpdate",e),this.fire("update",e),this.inputUpdate(e)}render(){this.fire("prerender"),this.root.syncHierarchy(),this.batcher.updateAll(),this.renderer.renderComposition(this.scene.layers),this.fire("postrender")}_fillFrameStatsBasic(e,t,n){const a=this.stats.frame;a.dt=t,a.ms=n,e>a._timeToCountFrames?(a.fps=a._fpsAccum,a._fpsAccum=0,a._timeToCountFrames=e+1e3):a._fpsAccum++,this.stats.drawCalls.total=this.graphicsDevice._drawCallsPerFrame,this.graphicsDevice._drawCallsPerFrame=0}_fillFrameStats(){let e=this.stats.frame;e.cameras=this.renderer._camerasRendered,e.materials=this.renderer._materialSwitches,e.shaders=this.graphicsDevice._shaderSwitchesPerFrame,e.shadowMapUpdates=this.renderer._shadowMapUpdates,e.shadowMapTime=this.renderer._shadowMapTime,e.depthMapTime=this.renderer._depthMapTime,e.forwardTime=this.renderer._forwardTime;const t=this.graphicsDevice._primsPerFrame;e.triangles=t[4]/3+Math.max(t[5]-2,0)+Math.max(t[6]-2,0),e.cullTime=this.renderer._cullTime,e.sortTime=this.renderer._sortTime,e.skinTime=this.renderer._skinTime,e.morphTime=this.renderer._morphTime,e.lightClusters=this.renderer._lightClusters,e.lightClustersTime=this.renderer._lightClustersTime,e.otherPrimitives=0;for(let n=0;n<t.length;n++)n<4&&(e.otherPrimitives+=t[n]),t[n]=0;this.renderer._camerasRendered=0,this.renderer._materialSwitches=0,this.renderer._shadowMapUpdates=0,this.graphicsDevice._shaderSwitchesPerFrame=0,this.renderer._cullTime=0,this.renderer._layerCompositionUpdateTime=0,this.renderer._lightClustersTime=0,this.renderer._sortTime=0,this.renderer._skinTime=0,this.renderer._morphTime=0,this.renderer._shadowMapTime=0,this.renderer._depthMapTime=0,this.renderer._forwardTime=0,e=this.stats.drawCalls,e.forward=this.renderer._forwardDrawCalls,e.culled=this.renderer._numDrawCallsCulled,e.depth=0,e.shadow=this.renderer._shadowDrawCalls,e.skinned=this.renderer._skinDrawCalls,e.immediate=0,e.instanced=0,e.removedByInstancing=0,e.misc=e.total-(e.forward+e.shadow),this.renderer._depthDrawCalls=0,this.renderer._shadowDrawCalls=0,this.renderer._forwardDrawCalls=0,this.renderer._numDrawCallsCulled=0,this.renderer._skinDrawCalls=0,this.renderer._immediateRendered=0,this.renderer._instancedDrawCalls=0,this.stats.misc.renderTargetCreationTime=this.graphicsDevice.renderTargetCreationTime,e=this.stats.particles,e.updatesPerFrame=e._updatesPerFrame,e.frameTime=e._frameTime,e._updatesPerFrame=0,e._frameTime=0}setCanvasFillMode(e,t,n){this._fillMode=e,this.resizeCanvas(t,n)}setCanvasResolution(e,t,n){this._resolutionMode=e,"AUTO"===e&&void 0===t&&(t=this.graphicsDevice.canvas.clientWidth,n=this.graphicsDevice.canvas.clientHeight),this.graphicsDevice.resizeCanvas(t,n)}isHidden(){return document[this._hiddenAttr]}onVisibilityChange(){this.isHidden()?this._soundManager.suspend():this._soundManager.resume()}resizeCanvas(e,t){if(!this._allowResize)return;if(this.xr&&this.xr.session)return;const n=window.innerWidth,a=window.innerHeight;if("KEEP_ASPECT"===this._fillMode){const i=this.graphicsDevice.canvas.width/this.graphicsDevice.canvas.height;i>n/a?t=(e=n)/i:e=(t=a)*i}else"FILL_WINDOW"===this._fillMode&&(e=n,t=a);return this.graphicsDevice.canvas.style.width=e+"px",this.graphicsDevice.canvas.style.height=t+"px",this.updateCanvasSize(),{width:e,height:t}}updateCanvasSize(){if(this._allowResize&&!this.xr.active&&"AUTO"===this._resolutionMode){const e=this.graphicsDevice.canvas;this.graphicsDevice.resizeCanvas(e.clientWidth,e.clientHeight)}}onLibrariesLoaded(){this._librariesLoaded=!0,this.systems.rigidbody.onLibraryLoaded()}applySceneSettings(e){let t;if(this.systems.rigidbody&&"undefined"!=typeof Ammo){const t=e.physics.gravity;this.systems.rigidbody.gravity.set(t[0],t[1],t[2])}this.scene.applySettings(e),e.render.hasOwnProperty("skybox")&&(e.render.skybox?(t=this.assets.get(e.render.skybox),t?this.setSkybox(t):this.assets.once("add:"+e.render.skybox,this.setSkybox,this)):this.setSkybox(null))}setAreaLightLuts(e){if(e){const t=this.graphicsDevice;e.ready((e=>{Iv.set(t,e.resource)})),this.assets.load(e)}}setSkybox(e){if(e!==this._skyboxAsset){const t=()=>{this.setSkybox(null)},n=()=>{this.scene.setSkybox(this._skyboxAsset?this._skyboxAsset.resources:null)};this._skyboxAsset&&(this.assets.off("load:"+this._skyboxAsset.id,n,this),this.assets.off("remove:"+this._skyboxAsset.id,t,this),this._skyboxAsset.off("change",n,this)),this._skyboxAsset=e,this._skyboxAsset&&(this.assets.on("load:"+this._skyboxAsset.id,n,this),this.assets.once("remove:"+this._skyboxAsset.id,t,this),this._skyboxAsset.on("change",n,this),0!==this.scene.skyboxMip||this._skyboxAsset.loadFaces||(this._skyboxAsset.loadFaces=!0),this.assets.load(this._skyboxAsset)),n()}}enableVr(){this.vr||(this.vr=new qx(this))}disableVr(){this.vr&&(this.vr.destroy(),this.vr=null)}_firstBake(){this.lightmapper.bake(null,this.scene.lightmapMode)}_firstBatch(){this.batcher.generate()}_processTimestamp(e){return e}drawLine(e,t,n,a,i){this.scene.drawLine(e,t,n,a,i)}drawLines(e,t,n=!0,a=this.scene.defaultDrawLayer){this.scene.drawLines(e,t,n,a)}drawLineArrays(e,t,n=!0,a=this.scene.defaultDrawLayer){this.scene.drawLineArrays(e,t,n,a)}drawWireSphere(e,t,n=Mu.WHITE,a=20,i=!0,s=this.scene.defaultDrawLayer){this.scene.immediate.drawWireSphere(e,t,n,a,i,s)}drawWireAlignedBox(e,t,n=Mu.WHITE,a=!0,i=this.scene.defaultDrawLayer){this.scene.immediate.drawWireAlignedBox(e,t,n,a,i)}drawMeshInstance(e,t=this.scene.defaultDrawLayer){this.scene.immediate.drawMesh(null,null,null,e,t)}drawMesh(e,t,n,a=this.scene.defaultDrawLayer){this.scene.immediate.drawMesh(t,n,e,null,a)}drawQuad(e,t,n=this.scene.defaultDrawLayer){this.scene.immediate.drawMesh(t,e,this.scene.immediate.getQuadMesh(),null,n)}drawTexture(e,t,n,a,i,s,r=this.scene.defaultDrawLayer){const o=new zu;o.setTRS(new Pu(e,t,0),Gu.IDENTITY,new Pu(n,a,0)),s||((s=new Jf).setParameter("colorMap",i),s.shader=this.scene.immediate.getTextureShader(),s.update()),this.drawQuad(o,s,r)}drawDepthTexture(e,t,n,a,i=this.scene.defaultDrawLayer){const s=new Jf;s.shader=this.scene.immediate.getDepthTextureShader(),s.update(),this.drawTexture(e,t,n,a,null,s,i)}destroy(){if(this._inFrameUpdate)return void(this._destroyRequested=!0);const e=this.graphicsDevice.canvas.id;this.off("librariesloaded"),"undefined"!=typeof document&&(document.removeEventListener("visibilitychange",this._visibilityChangeHandler,!1),document.removeEventListener("mozvisibilitychange",this._visibilityChangeHandler,!1),document.removeEventListener("msvisibilitychange",this._visibilityChangeHandler,!1),document.removeEventListener("webkitvisibilitychange",this._visibilityChangeHandler,!1)),this._visibilityChangeHandler=null,this.root.destroy(),this.root=null,this.mouse&&(this.mouse.off(),this.mouse.detach(),this.mouse=null),this.keyboard&&(this.keyboard.off(),this.keyboard.detach(),this.keyboard=null),this.touch&&(this.touch.off(),this.touch.detach(),this.touch=null),this.elementInput&&(this.elementInput.detach(),this.elementInput=null),this.controller&&(this.controller=null),this.systems.destroy(),this.scene.layers&&this.scene.layers.destroy();const t=this.assets.list();for(let e=0;e<t.length;e++)t[e].unload(),t[e].off();this.assets.off(),this.bundles.destroy(),this.bundles=null,this.i18n.destroy(),this.i18n=null;for(const e in this.loader.getHandler("script")._cache){const t=this.loader.getHandler("script")._cache[e],n=t.parentNode;n&&n.removeChild(t)}this.loader.getHandler("script")._cache={},this.loader.destroy(),this.loader=null,this.scene.destroy(),this.scene=null,this.systems=null,this.context=null,this.scripts.destroy(),this.scripts=null,this.scenes.destroy(),this.scenes=null,this.lightmapper.destroy(),this.lightmapper=null,this.batcher.destroy(),this.batcher=null,this._entityIndex={},this.defaultLayerDepth.onPreRenderOpaque=null,this.defaultLayerDepth.onPostRenderOpaque=null,this.defaultLayerDepth.onDisable=null,this.defaultLayerDepth.onEnable=null,this.defaultLayerDepth=null,this.defaultLayerWorld=null,this.vr&&(this.vr.destroy(),this.vr=null),this.xr.end(),this.renderer.destroy(),this.renderer=null,this.graphicsDevice.destroy(),this.graphicsDevice=null,this.tick=null,this.off(),this._soundManager&&(this._soundManager.destroy(),this._soundManager=null),Xw.app=null,jM._applications[e]=null,Jg()===this&&ey(null)}getEntityFromIndex(e){return this._entityIndex[e]}_registerSceneImmediate(e){this.on("postrender",e.immediate.onPostRender,e.immediate)}}jM._applications={};const XM={},YM=function(e){const t=e;let n;return function(e,a){if(!t.graphicsDevice)return;ey(t),n&&(window.cancelAnimationFrame(n),n=null);const i=t._processTimestamp(e)||xu(),s=i-(t._time||i);let r=s/1e3;r=Eu.clamp(r,0,t.maxDeltaTime),r*=t.timeScale,t._time=i,n=t.vr&&t.vr.display?t.vr.display.requestAnimationFrame(t.tick):t.xr.session?t.xr.session.requestAnimationFrame(t.tick):uu.browser?window.requestAnimationFrame(t.tick):null,t.graphicsDevice.contextLost||(t._fillFrameStatsBasic(i,r,s),t._inFrameUpdate=!0,t.fire("frameupdate",s),a?(t.xr.update(a),t.graphicsDevice.defaultFramebuffer=a.session.renderState.baseLayer.framebuffer):t.graphicsDevice.defaultFramebuffer=null,t.update(r),t.fire("framerender"),(t.autoRender||t.renderNextFrame)&&(t.updateCanvasSize(),t.render(),t.renderNextFrame=!1),XM.timestamp=xu(),XM.target=t,t.fire("frameend",XM),t.fire("frameEnd",XM),t.vr&&t.vr.display&&t.vr.display.presenting&&t.vr.display.submitFrame(),t._inFrameUpdate=!1,t._destroyRequested&&t.destroy())}},qM=[];class KM extends hf{constructor(e,t){if(super(e),this.anim=void 0,this.animation=void 0,this.audiolistener=void 0,this.button=void 0,this.camera=void 0,this.collision=void 0,this.element=void 0,this.layoutchild=void 0,this.layoutgroup=void 0,this.light=void 0,this.model=void 0,this.particlesystem=void 0,this.render=void 0,this.rigidbody=void 0,this.screen=void 0,this.script=void 0,this.scrollbar=void 0,this.scrollview=void 0,this.sound=void 0,this.sprite=void 0,this.c={},this._app=void 0,this._destroying=!1,this._guid=null,this._template=!1,e instanceof jM&&(t=e),!t&&!(t=jM.getApplication()))throw new Error("Couldn't find current application");this._app=t}addComponent(e,t){const n=this._app.systems[e];return n?this.c[e]?null:n.addComponent(this,t):null}removeComponent(e){const t=this._app.systems[e];t&&this.c[e]&&t.removeComponent(this)}findComponent(e){const t=this.findOne((function(t){return t.c&&t.c[e]}));return t&&t.c[e]}findComponents(e){return this.find((function(t){return t.c&&t.c[e]})).map((function(t){return t.c[e]}))}getGuid(){return this._guid||this.setGuid(eu()),this._guid}setGuid(e){const t=this._app._entityIndex;this._guid&&delete t[this._guid],this._guid=e,t[this._guid]=this}_notifyHierarchyStateChanged(e,t){let n=!1;e===this&&0===qM.length&&(n=!0),e._beingEnabled=!0,e._onHierarchyStateChanged(t),e._onHierarchyStatePostChanged&&qM.push(e);const a=e._children;for(let e=0,n=a.length;e<n;e++)a[e]._enabled&&this._notifyHierarchyStateChanged(a[e],t);if(e._beingEnabled=!1,n){for(let e=0;e<qM.length;e++)qM[e]._onHierarchyStatePostChanged();qM.length=0}}_onHierarchyStateChanged(e){super._onHierarchyStateChanged(e);const t=this.c;for(const n in t)if(t.hasOwnProperty(n)){const a=t[n];a.enabled&&(e?a.onEnable():a.onDisable())}}_onHierarchyStatePostChanged(){const e=this.c;for(const t in e)e.hasOwnProperty(t)&&e[t].onPostStateChange()}findByGuid(e){if(this._guid===e)return this;const t=this._app._entityIndex[e];return t&&(t===this||t.isDescendantOf(this))?t:null}destroy(){this._destroying=!0;for(const e in this.c)this.c[e].enabled=!1;for(const e in this.c)this.c[e].system.removeComponent(this);this._parent&&this._parent.removeChild(this);const e=this._children;let t=e.shift();for(;t;)t instanceof KM&&t.destroy(),t._parent=null,t=e.shift();this.fire("destroy",this),this.off(),this._guid&&delete this._app._entityIndex[this._guid],this._destroying=!1}clone(){const e={},t=this._cloneRecursively(e);return e[this.getGuid()]=t,ZM(this,this,t,e),t}_cloneRecursively(e){const t=new KM(this._app);super._cloneInternal(t);for(const e in this.c){this.c[e].system.cloneComponent(this,t)}for(let n=0;n<this._children.length;n++){const a=this._children[n];if(a instanceof KM){const n=a._cloneRecursively(e);t.addChild(n),e[a.getGuid()]=n}}return t}}function ZM(e,t,n,a){if(t instanceof KM){const i=t.c;for(const t in i){const s=i[t],r=s.system.getPropertiesOfType("entity");for(let i=0,o=r.length;i<o;i++){const o=r[i].name,l=s[o];if(!!e.findByGuid(l)){const e=a[l].getGuid();e&&(n.c[t][o]=e)}}}i.script&&!n._app.useLegacyScriptAttributeCloning&&n.script.resolveDuplicatedEntityReferenceProperties(i.script,a),i.render&&n.render.resolveDuplicatedEntityReferenceProperties(i.render,a),i.anim&&n.anim.resolveDuplicatedEntityReferenceProperties(i.anim,a);const s=t.children.filter((function(e){return e instanceof KM})),r=n.children.filter((function(e){return e instanceof KM}));for(let t=0,n=s.length;t<n;t++)ZM(e,s[t],r[t],a)}}const $M=new Pu;class QM extends Sv{constructor(e){const t=new KM("AmbientLight");t.addComponent("light",{type:"directional",affectDynamic:!0,affectLightmapped:!1,bake:!0,bakeNumSamples:e.ambientBakeNumSamples,castShadows:!0,normalOffsetBias:.05,shadowBias:.2,shadowDistance:1,shadowResolution:2048,shadowType:0,color:Mu.WHITE,intensity:1,bakeDir:!1}),super(e,t.light.light)}get numVirtualLights(){return this.light.bakeNumSamples}prepareVirtualLight(e,t){Af($M,e,t,0,this.scene.ambientBakeSpherePart),this.light._node.lookAt($M.mulScalar(-1)),this.light._node.rotateLocal(90,0,0);const n=this.scene.gammaCorrection?2.2:1,a=2*Math.PI*this.scene.ambientBakeSpherePart,i=Math.pow(a,n);this.light.intensity=Math.pow(i/t,1/n)}}class JM{constructor(e,t=null){this.node=e,this.component=e.render||e.model,t=t||this.component.meshInstances,this.store(),this.meshInstances=t,this.bounds=null,this.renderTargets=[]}store(){this.castShadows=this.component.castShadows}restore(){this.component.castShadows=this.castShadows}}class eL{constructor(e){this.device=e,this.shaderDilate=Mm(e,gm.fullscreenQuadVS,gm.dilatePS,"lmDilate"),this.constantTexSource=e.scope.resolve("source"),this.constantPixelOffset=e.scope.resolve("pixelOffset"),this.pixelOffset=new Float32Array(2),this.shaderDenoise=null,this.sigmas=null,this.constantSigmas=null,this.kernel=null}setSourceTexture(e){this.constantTexSource.setValue(e)}prepare(e,t){this.pixelOffset[0]=1/e,this.pixelOffset[1]=1/t,this.constantPixelOffset.setValue(this.pixelOffset)}prepareDenoise(e,t){this.shaderDenoise||(this.shaderDenoise=Mm(this.device,gm.fullscreenQuadVS,gm.bilateralDeNoisePS,"lmBilateralDeNoise"),this.sigmas=new Float32Array(2),this.constantSigmas=this.device.scope.resolve("sigmas"),this.constantKernel=this.device.scope.resolve("kernel[0]"),this.bZnorm=this.device.scope.resolve("bZnorm")),this.sigmas[0]=e,this.sigmas[1]=t,this.constantSigmas.setValue(this.sigmas),this.evaluateDenoiseUniforms(e,t)}evaluateDenoiseUniforms(e,t){function n(e,t){return.39894*Math.exp(-.5*e*e/(t*t))/t}this.kernel=this.kernel||new Float32Array(15);const a=this.kernel,i=Math.floor(7);for(let t=0;t<=i;++t){const s=n(t,e);a[i+t]=s,a[i-t]=s}this.constantKernel.setValue(this.kernel);const s=1/n(0,t);this.bZnorm.setValue(s)}}const tL=new Pu;class nL{constructor(e,t,n,a,i){this.device=e,this.root=t,this.scene=n,this.renderer=a,this.assets=i,this.shadowMapCache=a._shadowRenderer.shadowMapCache,this._tempSet=new Set,this._initCalled=!1,this.passMaterials=[],this.ambientAOMaterial=null,this.fog="",this.ambientLight=new Mu,this.renderTargets=new Map,this.stats={renderPasses:0,lightmapCount:0,totalRenderTime:0,forwardTime:0,fboTime:0,shadowMapTime:0,compileTime:0,shadersLinked:0}}destroy(){_y.decRef(this.blackTex),this.blackTex=null,_y.destroy(),this.device=null,this.root=null,this.scene=null,this.renderer=null,this.assets=null}initBake(e){if(!this._initCalled){this._initCalled=!0,this.lightmapFilters=new eL(e),this.constantBakeDir=e.scope.resolve("bakeDir"),this.materials=[],this.blackTex=new Gm(this.device,{width:4,height:4,format:7,type:"rgbm"}),this.blackTex.name="lightmapBlack",_y.incRef(this.blackTex);const t=new Ym;t.clearColor.set(0,0,0,0),t.clearColorBuffer=!0,t.clearDepthBuffer=!1,t.clearStencilBuffer=!1,t.frustumCulling=!1,t.projection=1,t.aspectRatio=1,t.node=new hf,this.camera=t}if(this.scene.clusteredLightingEnabled){const t=new Tv(e.supportsAreaLights,e.maxTextureSize,(()=>{}));this.lightingParams=t;const n=this.scene.lighting;t.shadowsEnabled=n.shadowsEnabled,t.shadowAtlasResolution=n.shadowAtlasResolution,t.cookiesEnabled=n.cookiesEnabled,t.cookieAtlasResolution=n.cookieAtlasResolution,t.areaLightsEnabled=n.areaLightsEnabled,t.cells=new Pu(3,3,3),t.maxLightsPerCell=4,this.worldClusters=new Hy(e),this.worldClusters.name="ClusterLightmapper"}}finishBake(e){function t(e){_y.decRef(e.colorBuffer),e.destroy()}this.materials=[],this.renderTargets.forEach((e=>{t(e)})),this.renderTargets.clear(),e.forEach((e=>{e.renderTargets.forEach((e=>{t(e)})),e.renderTargets.length=0})),this.ambientAOMaterial=null,this.worldClusters&&(this.worldClusters.destroy(),this.worldClusters=null)}createMaterialForPass(e,t,n,a){const i=new cg;if(i.name=`lmMaterial-pass:${n}-ambient:${a}`,i.chunks.transformVS="#define UV1LAYOUT\n"+gm.transformVS,0===n){let e=gm.bakeLmEndPS;a?e=`\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = ((dDiffuseLight - 0.5) * max(${t.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight += vec3(${t.ambientBakeOcclusionBrightness.toFixed(1)});\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = saturate(dDiffuseLight);\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight *= dAmbientLight;\n\t\t\t\t\t\t\t\t`+e:(i.ambient=new Mu(0,0,0),i.ambientTint=!0),i.chunks.endPS=e,i.lightMap=this.blackTex}else i.chunks.basePS=gm.basePS+"\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n",i.chunks.endPS=gm.bakeDirLmEndPS;return i.chunks.outputAlphaPS="\n",i.chunks.outputAlphaOpaquePS="\n",i.chunks.outputAlphaPremulPS="\n",i.cull=0,i.forceUv1=!0,i.update(),i.updateShader(e,t),i}createMaterials(e,t,n){for(let a=0;a<n;a++)this.passMaterials[a]||(this.passMaterials[a]=this.createMaterialForPass(e,t,a,!1));this.ambientAOMaterial||(this.ambientAOMaterial=this.createMaterialForPass(e,t,0,!0),this.ambientAOMaterial.onUpdateShader=function(e){return e.lightMapWithoutAmbient=!0,e.separateAmbient=!0,e})}createTexture(e,t,n){const a=new Gm(this.device,{width:e,height:e,format:7,mipmaps:!1,type:t,minFilter:0,magFilter:0,addressU:1,addressV:1});return a.name=n,a}collectModels(e,t,n){var a,i,s;if(!e.enabled)return;let r;if(null!=(a=e.model)&&a.model&&null!=(i=e.model)&&i.enabled&&(n&&n.push(new JM(e)),e.model.lightmapped&&t&&(r=e.model.model.meshInstances)),null!=(s=e.render)&&s.enabled&&(n&&n.push(new JM(e)),e.render.lightmapped&&t&&(r=e.render.meshInstances)),r){let n=!0;for(let e=0;e<r.length;e++)if(!r[e].mesh.vertexBuffer.format.hasUv1){n=!1;break}if(n){const n=[];for(let a=0;a<r.length;a++){const i=r[a].mesh;this._tempSet.has(i)?t.push(new JM(e,[r[a]])):n.push(r[a]),this._tempSet.add(i)}this._tempSet.clear(),n.length>0&&t.push(new JM(e,n))}}for(let a=0;a<e._children.length;a++)this.collectModels(e._children[a],t,n)}prepareShadowCasters(e){const t=[];for(let n=0;n<e.length;n++){const a=e[n].component;if(a.castShadows=a.castShadowsLightmap,a.castShadowsLightmap){const a=e[n].meshInstances;for(let e=0;e<a.length;e++)a[e].visibleThisFrame=!0,t.push(a[e])}}return t}updateTransforms(e){for(let t=0;t<e.length;t++){const n=e[t].meshInstances;for(let e=0;e<n.length;e++)n[e].node.getWorldTransform()}}calculateLightmapSize(e){let t;const n=this.scene.lightmapSizeMultiplier||16,a=tL;let i,s;e.model?(s=e.model.lightmapSizeMultiplier,e.model.asset?(t=this.assets.get(e.model.asset).data,t.area&&(i=t.area)):e.model._area&&(t=e.model,t._area&&(i=t._area))):e.render&&(s=e.render.lightmapSizeMultiplier,"asset"!==e.render.type&&e.render._area&&(t=e.render,t._area&&(i=t._area)));const r={x:1,y:1,z:1,uv:1};i&&(r.x=i.x,r.y=i.y,r.z=i.z,r.uv=i.uv);const o=s||1;r.x*=o,r.y*=o,r.z*=o;const l=e.render||e.model,c=this.computeNodeBounds(l.meshInstances);a.copy(c.halfExtents);let h=r.x*a.y*a.z+r.y*a.x*a.z+r.z*a.x*a.y;h/=r.uv,h=Math.sqrt(h);return Math.min(Eu.nextPowerOfTwo(h*n),this.scene.lightmapMaxResolution||2048)}setLightmapping(e,t,n,a){for(let i=0;i<e.length;i++){const s=e[i],r=s.meshInstances;for(let e=0;e<r.length;e++){const i=r[e];if(i.setLightmapped(t),t){a&&(i._shaderDefs|=a),i.mask=2;for(let e=0;e<n;e++){const t=s.renderTargets[e].colorBuffer;t.minFilter=1,t.magFilter=1,i.setRealtimeLightmap(Ay.lightmapParamNames[e],t)}}}}}bake(e,t=1){const n=this.device,a=xu();this.scene._updateSkybox(n),this.stats.renderPasses=0,this.stats.shadowMapTime=0,this.stats.forwardTime=0;const i=n._shaderStats.linked,s=n._renderTargetCreationTime,r=n._shaderStats.compileTime,o=[],l=[];if(e){for(let t=0;t<e.length;t++)this.collectModels(e[t],o,null);this.collectModels(this.root,null,l)}else this.collectModels(this.root,o,l);if(o.length>0){const e=1===t?2:1;this.setLightmapping(o,!1,e),this.initBake(n),this.bakeInternal(e,o,l);let a=64;1===t&&(a|=128),this.scene.ambientBake&&(a|=8192),this.setLightmapping(o,!0,e,a),this.finishBake(o)}const c=xu();this.stats.totalRenderTime=c-a,this.stats.shadersLinked=n._shaderStats.linked-i,this.stats.compileTime=n._shaderStats.compileTime-r,this.stats.fboTime=n._renderTargetCreationTime-s,this.stats.lightmapCount=o.length}allocateTextures(e,t){for(let n=0;n<e.length;n++){const a=e[n],i=this.calculateLightmapSize(a.node);for(let e=0;e<t;e++){const t=this.createTexture(i,"default","lightmapper_lightmap_"+n);_y.incRef(t),a.renderTargets[e]=new Cg({colorBuffer:t,depth:!1})}if(!this.renderTargets.has(i)){const e=this.createTexture(i,"default","lightmapper_temp_lightmap_"+i);_y.incRef(e),this.renderTargets.set(i,new Cg({colorBuffer:e,depth:!1}))}}}prepareLightsToBake(e,t,n){if(this.scene.ambientBake){const e=new QM(this.scene);n.push(e)}const a=e._lights;for(let e=0;e<a.length;e++){const i=a[e],s=new Mv(this.scene,i);t.push(s),i.enabled&&0!=(4&i.mask)&&(i.isStatic=!1,i.mask=4294967295,i.shadowUpdateMode=0===i.type?2:1,n.push(s))}n.sort()}restoreLights(e){for(let t=0;t<e.length;t++)e[t].restore()}setupScene(){this.revertStatic=!1,this.scene._needsStaticPrepare&&(this.scene._needsStaticPrepare=!1,this.revertStatic=!0),this.fog=this.scene.fog,this.ambientLight.copy(this.scene.ambientLight),this.scene.fog="none",this.scene.ambientBake||this.scene.ambientLight.set(0,0,0),this.renderer.setSceneConstants()}restoreScene(){this.scene.fog=this.fog,this.scene.ambientLight.copy(this.ambientLight),this.revertStatic&&(this.scene._needsStaticPrepare=!0)}computeNodeBounds(e){const t=new qu;if(e.length>0){t.copy(e[0].aabb);for(let n=1;n<e.length;n++)t.add(e[n].aabb)}return t}computeNodesBounds(e){for(let t=0;t<e.length;t++){const n=e[t].meshInstances;e[t].bounds=this.computeNodeBounds(n)}}computeBounds(e){const t=new qu;for(let n=0;n<e.length;n++){t.copy(e[0].aabb);for(let n=1;n<e.length;n++)t.add(e[n].aabb)}return t}backupMaterials(e){for(let t=0;t<e.length;t++)this.materials[t]=e[t].material}restoreMaterials(e){for(let t=0;t<e.length;t++)e[t].material=this.materials[t]}lightCameraPrepare(e,t){const n=t.light;let a;if(2===n.type){a=n.getRenderData(null,0).shadowCamera,a._node.setPosition(n._node.getPosition()),a._node.setRotation(n._node.getRotation()),a._node.rotateLocal(-90,0,0),a.projection=0,a.nearClip=n.attenuationEnd/1e3,a.farClip=n.attenuationEnd,a.aspectRatio=1,a.fov=2*n._outerConeAngle,this.renderer.updateCameraFrustum(a)}return a}lightCameraPrepareAndCull(e,t,n,a){const i=e.light;let s=!0;if(0===i.type){tL.copy(a.center),tL.y+=a.halfExtents.y,this.camera.node.setPosition(tL),this.camera.node.setEulerAngles(-90,0,0),this.camera.nearClip=0,this.camera.farClip=2*a.halfExtents.y;const e=Math.max(a.halfExtents.x,a.halfExtents.z);this.camera.orthoHeight=e}else e.lightBounds.intersects(t.bounds)||(s=!1);if(2===i.type){let e=!1;const a=t.meshInstances;for(let t=0;t<a.length;t++)if(a[t]._isVisible(n)){e=!0;break}e||(s=!1)}return s}setupLightArray(e,t){e[0].length=0,e[1].length=0,e[2].length=0,e[t.type][0]=t,t.visibleThisFrame=!0}renderShadowMap(e,t,n,a){const i=a.light;return!e&&i.castShadows&&(i.shadowMap||this.scene.clusteredLightingEnabled||(i.shadowMap=this.shadowMapCache.get(this.device,i)),0===i.type?this.renderer._shadowRenderer.cullDirectional(i,t,this.camera):this.renderer._shadowRenderer.cullLocal(i,t),this.renderer.renderShadows(n[i.type],this.camera)),!0}postprocessTextures(e,t,n){const a=this.lightmapFilters.shaderDilate,i=this.scene.lightmapFilterEnabled;i&&this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange,this.scene.lightmapFilterSmoothness);for(let s=0;s<t.length;s++){const r=t[s];for(let t=0;t<n;t++){const n=r.renderTargets[t],s=n.colorBuffer,o=this.renderTargets.get(s.width),l=o.colorBuffer;this.lightmapFilters.prepare(s.width,s.height);for(let r=0;r<1;r++){this.lightmapFilters.setSourceTexture(s);mm(e,o,i&&0===t&&0===r?this.lightmapFilters.shaderDenoise:a),this.lightmapFilters.setSourceTexture(l),mm(e,n,a)}}}}bakeInternal(e,t,n){const a=this.scene,i=this.device,s=a.clusteredLightingEnabled;this.createMaterials(i,a,e),this.setupScene(),a.layers._update(),this.computeNodesBounds(t),this.allocateTextures(t,e);const r=[],o=[];this.prepareLightsToBake(a.layers,r,o),this.updateTransforms(n);const l=this.prepareShadowCasters(n);this.renderer.updateCpuSkinMatrices(l),this.renderer.gpuUpdate(l);const c=this.computeBounds(l);let h,d,p,u;for(h=0;h<t.length;h++){for(p=t[h].meshInstances,d=0;d<p.length;d++)u=p[d],u.setLightmapped(!1),u.mask=4,u.setRealtimeLightmap(Ay.lightmapParamNames[0],u.material.lightMap?u.material.lightMap:this.blackTex),u.setRealtimeLightmap(Ay.lightmapParamNames[1],this.blackTex)}for(d=0;d<o.length;d++)o[d].light.enabled=!1;const m=[[],[],[]];let f,g,y=!1;for(h=0;h<o.length;h++){const n=o[h],r=n instanceof QM;let b=n.numVirtualLights;e>1&&b>1&&n.light.bakeDir&&(b=1);for(let o=0;o<b;o++){b>1&&n.prepareVirtualLight(o,b),n.startBake();let h=!1;const v=this.lightCameraPrepare(i,n);for(g=0;g<t.length;g++){const i=t[g];p=i.meshInstances;if(this.lightCameraPrepareAndCull(n,i,v,c)){if(this.setupLightArray(m,n.light),s&&this.renderer.lightTextureAtlas.update(m[2],m[1],this.lightingParams),h=this.renderShadowMap(h,l,m,n),s){const e=m[2].concat(m[1]);this.worldClusters.update(e,this.scene.gammaCorrection,this.lightingParams)}for(this.backupMaterials(p),f=0;f<e&&!(f>0&&o>0)&&!(r&&f>0);f++){const e=i.renderTargets[f],t=i.renderTargets[f].colorBuffer.width,l=this.renderTargets.get(t),c=l.colorBuffer;0===f?y=a.updateShaders:y&&(a.updateShaders=!0);let h=this.passMaterials[f];if(r){o+1===b&&0===f&&(h=this.ambientAOMaterial)}for(d=0;d<p.length;d++)p[d].material=h;for(this.renderer.updateShaders(p),this.renderer.setCamera(this.camera,l,!0),1===f&&this.constantBakeDir.setValue(n.light.bakeDir?1:0),s&&this.worldClusters.activate(this.renderer.lightTextureAtlas),this.renderer._forwardTime=0,this.renderer._shadowMapTime=0,this.renderer.renderForward(this.camera,p,p.length,m,1),i.renderTargets[f]=l,this.renderTargets.set(t,e),d=0;d<p.length;d++)u=p[d],u.setRealtimeLightmap(Ay.lightmapParamNames[f],c),u._shaderDefs|=64}this.restoreMaterials(p)}}n.endBake(this.shadowMapCache)}}for(this.postprocessTextures(i,t,e),g=0;g<n.length;g++)n[g].restore();this.restoreLights(r),this.restoreScene(),s||this.shadowMapCache.clear()}}const aL=new Set,iL={depth:1,flags:2};class sL{constructor(e,t,n){e instanceof wg&&(e=Jg()),this.app=e,this.device=e.graphicsDevice,this.pickColor=new Float32Array(4),this.pickColor[3]=1,this.mapping=[],this.cameraEntity=null,this.layer=null,this.layerComp=null,this.initLayerComposition(),this._renderTarget=null;const a=this.device;this.clearDepthCommand=new Sy(0,0,(function(){a.clear(iL)})),this.width=0,this.height=0,this.resize(t,n)}getSelection(e,t,n,a){const i=this.device;if("object"==typeof e){const i=e;e=i.x,t=i.y,n=i.width,a=i.height}else t=this.renderTarget.height-(t+(a||1));e=Math.floor(e),t=Math.floor(t),n=Math.floor(Math.max(n||1,1)),a=Math.floor(Math.max(a||1,1));const s=i.renderTarget;i.setRenderTarget(this.renderTarget),i.updateBegin();const r=new Uint8Array(4*n*a);i.readPixels(e,t,n,a,r),i.updateEnd(),i.setRenderTarget(s);const o=this.mapping;for(let e=0;e<n*a;e++){const t=r[4*e+0]<<16|r[4*e+1]<<8|r[4*e+2];16777215!==t&&aL.add(o[t])}const l=[];return aL.forEach((e=>l.push(e))),aL.clear(),l}allocateRenderTarget(){const e=new Gm(this.device,{format:7,width:this.width,height:this.height,mipmaps:!1,minFilter:0,magFilter:0,addressU:1,addressV:1});e.name="pick",this.renderTarget=new Cg({colorBuffer:e,depth:!0})}releaseRenderTarget(){this.cameraEntity.camera.renderTarget=null,this._renderTarget&&(this._renderTarget._colorBuffer.destroy(),this._renderTarget.destroy(),this._renderTarget=null)}initLayerComposition(){const e=this.device,t=this,n=e.scope.resolve("uColor");this.cameraEntity=new KM,this.cameraEntity.addComponent("camera"),this.layer=new rv({name:"Picker",shaderPass:18,opaqueSortMode:0,onDrawCall:function(a,i){t.pickColor[0]=(i>>16&255)/255,t.pickColor[1]=(i>>8&255)/255,t.pickColor[2]=(255&i)/255,n.setValue(t.pickColor),e.setBlending(!1),t.mapping[i]=a}}),this.layer.addCamera(this.cameraEntity.camera),this.layerComp=new mv("picker"),this.layerComp.pushOpaque(this.layer)}prepare(e,t,n){e instanceof Ym&&(e=e.node.camera),n instanceof rv&&(n=[n]),this.layer.clearMeshInstances();const a=this.layer.opaqueMeshInstances,i=t.layers.layerList,s=t.layers.subLayerEnabled,r=t.layers.subLayerList;for(let t=0;t<i.length;t++){const o=i[t];if(!(n&&n.indexOf(o)<0)&&(o.enabled&&s[t])){if(o.cameras.indexOf(e)>=0){o._clearDepthBuffer&&a.push(this.clearDepthCommand);const e=r[t]?o.instances.transparentMeshInstances:o.instances.opaqueMeshInstances;for(let t=0;t<e.length;t++){const n=e[t];n.pick&&a.push(n)}}}}this.renderTarget&&this.width===this.renderTarget.width&&this.height===this.renderTarget.height||(this.releaseRenderTarget(),this.allocateRenderTarget()),this.updateCamera(e),this.mapping.length=0,this.app.renderer.renderComposition(this.layerComp)}updateCamera(e){this.cameraEntity.copy(e.entity),this.cameraEntity.name="PickerCamera";const t=this.cameraEntity.camera;t.copy(e),t.clearColorBuffer=!0,t.clearDepthBuffer=!0,t.clearStencilBuffer=!0,t.clearColor=Mu.WHITE,t.renderTarget=this.renderTarget,this.layer.clearCameras(),this.layer.addCamera(t),t.layers=[this.layer.id]}resize(e,t){this.width=Math.floor(e),this.height=Math.floor(t)}}class rL extends Qp{constructor(e,t={}){super(),this.type="bitmap",this.app=e,this.intensity=0,this.fontWeight=t.fontWeight||"normal",this.fontSize=parseInt(t.fontSize,10),this.glyphSize=this.fontSize,this.fontName=t.fontName||"Arial",this.color=t.color||new Mu(1,1,1),this.padding=t.padding||0;const n=t.width>4096?4096:t.width||512,a=t.height>4096?4096:t.height||512,i=document.createElement("canvas");i.height=a,i.width=n;const s=new Gm(this.app.graphicsDevice,{name:"font",format:7,minFilter:5,magFilter:1,addressU:1,addressV:1,mipmaps:!0});s.setSource(i),this.textures=[s],this.chars="",this.data={}}createTextures(e){const t=this._normalizeCharsSet(e);if(t.length===this.chars.length){for(let e=0;e<t.length;e++)if(t[e]!==this.chars[e])return void this._renderAtlas(t)}else this._renderAtlas(t)}updateTextures(e){const t=this._normalizeCharsSet(e),n=[];for(let e=0;e<t.length;e++){const a=t[e];this.data.chars[a]||n.push(a)}n.length>0&&this._renderAtlas(this.chars.concat(n))}destroy(){for(let e=0;e<this.textures.length;e++)this.textures[e].destroy();this.chars=null,this.color=null,this.data=null,this.fontName=null,this.fontSize=null,this.glyphSize=null,this.intensity=null,this.textures=null,this.type=null,this.fontWeight=null}_getAndClearContext(e,t){const n=e.width,a=e.height,i=e.getContext("2d",{alpha:!0});return i.clearRect(0,0,n,a),i.fillStyle=t,i.fillRect(0,0,n,a),i}_colorToRgbString(e,t){let n;const a=Math.round(255*e.r),i=Math.round(255*e.g),s=Math.round(255*e.b);return n=t?`rgba(${a}, ${i}, ${s}, ${e.a})`:`rgb(${a}, ${i}, ${s})`,n}renderCharacter(e,t,n,a,i){e.fillStyle=i,e.fillText(t,n,a)}_renderAtlas(e){this.chars=e;let t=1,n=this.textures[t-1].getSource();const a=n.width,i=n.height,s=this._colorToRgbString(this.color,!1),r=this.color.a;this.color.a=1/255;const o=this._colorToRgbString(this.color,!0);this.color.a=r;const l="center",c="alphabetic";let h=this._getAndClearContext(n,o);h.font=this.fontWeight+" "+this.fontSize.toString()+"px "+this.fontName,h.textAlign=l,h.textBaseline=c,this.data=this._createJson(this.chars,this.fontName,a,i);const d=yu.getSymbols(this.chars.join("")),p=this.textures.length;let u=0,m=0;const f={};for(let e=0;e<d.length;e++){const t=d[e];f[t]=this._getTextMetrics(t),u=Math.max(u,f[t].height),m=Math.max(m,f[t].descent)}this.glyphSize=Math.max(this.glyphSize,u);const g=this.glyphSize+2*this.padding,y=this.glyphSize+2*this.padding,b=this.glyphSize/2+this.padding,v=y-m-this.padding;let _=0,w=0;for(let e=0;e<d.length;e++){const r=d[e],u=yu.getCodePoint(d[e]);let x=this.fontSize;h.font=this.fontWeight+" "+x.toString()+"px "+this.fontName,h.textAlign=l,h.textBaseline=c;let C=h.measureText(r).width;C>x&&(x=this.fontSize*this.fontSize/C,h.font=this.fontWeight+" "+x.toString()+"px "+this.fontName,C=this.fontSize),this.renderCharacter(h,r,_+b,w+v,s);const T=this.padding+(this.glyphSize-C)/2,E=-this.padding+f[r].descent-m,S=C;if(this._addChar(this.data,r,u,_,w,g,y,T,E,S,t-1,a,i),_+=g,_+g>a&&(_=0,w+=y,w+y>i))if(this.textures[t-1].upload(),t++,w=0,t>p){n=document.createElement("canvas"),n.height=i,n.width=a,h=this._getAndClearContext(n,o);const e=new Gm(this.app.graphicsDevice,{format:7,mipmaps:!0});e.name="font-atlas",e.setSource(n),e.minFilter=5,e.magFilter=1,e.addressU=1,e.addressV=1,this.textures.push(e)}else n=this.textures[t-1].getSource(),h=this._getAndClearContext(n,o)}if(this.textures[t-1].upload(),t<p){for(let e=t;e<p;e++)this.textures[e].destroy();this.textures.splice(t)}this.fire("render")}_createJson(e,t,n,a){return{version:3,intensity:this.intensity,info:{face:t,width:n,height:a,maps:[{width:n,height:a}]},chars:{}}}_addChar(e,t,n,a,i,s,r,o,l,c,h,d,p){e.info.maps.length<h+1&&e.info.maps.push({width:d,height:p});const u=this.fontSize/32;e.chars[t]={id:n,letter:t,x:a,y:i,width:s,height:r,xadvance:c/u,xoffset:o/u,yoffset:(l+this.padding)/u,scale:u,range:1,map:h,bounds:[0,0,s/u,r/u]}}_normalizeCharsSet(e){const t=this.app.systems.element.getUnicodeConverter();t&&(e=t(e));const n={},a=yu.getSymbols(e);for(let e=0;e<a.length;e++){const t=a[e];n[t]||(n[t]=t)}return Object.keys(n).sort()}_getTextMetrics(e){const t=document.createElement("span");t.id="content-span",t.innerHTML=e;const n=document.createElement("div");n.id="content-block",n.style.display="inline-block",n.style.width="1px",n.style.height="0px";const a=document.createElement("div");a.appendChild(t),a.appendChild(n),a.style.font=this.fontSize+"px "+this.fontName;document.body.appendChild(a);let i=-1,s=-1,r=-1;try{n.style["vertical-align"]="baseline",i=n.offsetTop-t.offsetTop,n.style["vertical-align"]="bottom",r=n.offsetTop-t.offsetTop,s=r-i}finally{document.body.removeChild(a)}return{ascent:i,descent:s,height:r}}}const oL=new Set(["system","entity","create","destroy","swap","move","scripts","_scripts","_scriptsIndex","_scriptsData","enabled","_oldState","onEnable","onDisable","onPostStateChange","_onSetEnabled","_checkState","_onBeforeRemove","_onInitializeAttributes","_onInitialize","_onPostInitialize","_onUpdate","_onPostUpdate","_callbacks","has","get","on","off","fire","once","hasEvent"]);function lL(e,t){if(Xw.legacy)return null;if(oL.has(e))throw new Error(`script name: '${e}' is reserved, please change script name`);const n=function(e){Qp.prototype.initEventHandler.call(this),Hx.prototype.initScriptType.call(this,e)};return(n.prototype=Object.create(Hx.prototype)).constructor=n,n.extend=Hx.extend,n.attributes=new Bx(n),function(e,t,n){if(e.legacy)return;if("function"!=typeof e)throw new Error(`script class: '${e}' must be a constructor function (i.e. class).`);if(!(e.prototype instanceof Hx))throw new Error(`script class: '${Hx.__getScriptName(e)}' does not extend pc.ScriptType.`);if(t=t||e.__name||Hx.__getScriptName(e),oL.has(t))throw new Error(`script name: '${t}' is reserved, please change script name`);e.__name=t;(n?n.scripts:jM.getApplication().scripts).add(e),Yw._push(e)}(n,e,t),n}const cL={};Bx.reservedNames.forEach(((e,t,n)=>{cL[e]=1})),lL.reservedAttributes=cL;const hL=new class{constructor(e,t){t?(this.key=t.keyCode,this.element=t.target,this.event=t):(this.key=null,this.element=null,this.event=null)}};function dL(e){return hL.key=e.keyCode,hL.element=e.target,hL.event=e,hL}function pL(e){return"string"==typeof e?e.toUpperCase().charCodeAt(0):e}const uL={9:"Tab",13:"Enter",16:"Shift",17:"Control",18:"Alt",27:"Escape",37:"Left",38:"Up",39:"Right",40:"Down",46:"Delete",91:"Win"};class mL extends Qp{constructor(e,t={}){super(),this._element=null,this._keyDownHandler=this._handleKeyDown.bind(this),this._keyUpHandler=this._handleKeyUp.bind(this),this._keyPressHandler=this._handleKeyPress.bind(this),this._visibilityChangeHandler=this._handleVisibilityChange.bind(this),this._windowBlurHandler=this._handleWindowBlur.bind(this),this._keymap={},this._lastmap={},e&&this.attach(e),this.preventDefault=t.preventDefault||!1,this.stopPropagation=t.stopPropagation||!1}attach(e){this._element&&this.detach(),this._element=e,this._element.addEventListener("keydown",this._keyDownHandler,!1),this._element.addEventListener("keypress",this._keyPressHandler,!1),this._element.addEventListener("keyup",this._keyUpHandler,!1),document.addEventListener("visibilitychange",this._visibilityChangeHandler,!1),window.addEventListener("blur",this._windowBlurHandler,!1)}detach(){this._element&&(this._element.removeEventListener("keydown",this._keyDownHandler),this._element.removeEventListener("keypress",this._keyPressHandler),this._element.removeEventListener("keyup",this._keyUpHandler),this._element=null,document.removeEventListener("visibilitychange",this._visibilityChangeHandler,!1),window.removeEventListener("blur",this._windowBlurHandler,!1))}toKeyIdentifier(e){e=pL(e);const t=uL[e.toString()];if(t)return t;let n=e.toString(16).toUpperCase();const a=n.length;for(let e=0;e<4-a;e++)n="0"+n;return"U+"+n}_handleKeyDown(e){const t=e.keyCode||e.charCode;if(void 0===t)return;const n=this.toKeyIdentifier(t);this._keymap[n]=!0,this.fire("keydown",dL(e)),this.preventDefault&&e.preventDefault(),this.stopPropagation&&e.stopPropagation()}_handleKeyUp(e){const t=e.keyCode||e.charCode;if(void 0===t)return;const n=this.toKeyIdentifier(t);delete this._keymap[n],this.fire("keyup",dL(e)),this.preventDefault&&e.preventDefault(),this.stopPropagation&&e.stopPropagation()}_handleKeyPress(e){this.fire("keypress",dL(e)),this.preventDefault&&e.preventDefault(),this.stopPropagation&&e.stopPropagation()}_handleVisibilityChange(){"hidden"===document.visibilityState&&this._handleWindowBlur()}_handleWindowBlur(){this._keymap={},this._lastmap={}}update(){for(const e in this._lastmap)delete this._lastmap[e];for(const e in this._keymap)this._keymap.hasOwnProperty(e)&&(this._lastmap[e]=this._keymap[e])}isPressed(e){const t=pL(e),n=this.toKeyIdentifier(t);return!!this._keymap[n]}wasPressed(e){const t=pL(e),n=this.toKeyIdentifier(t);return!!this._keymap[n]&&!this._lastmap[n]}wasReleased(e){const t=pL(e),n=this.toKeyIdentifier(t);return!this._keymap[n]&&!!this._lastmap[n]}}function fL(){return!!(document.pointerLockElement||document.mozPointerLockElement||document.webkitPointerLockElement)}class gL{constructor(e,t){let n={x:0,y:0};if(t){if(t instanceof gL)throw Error("Expected MouseEvent");n=e._getTargetCoords(t)}else t={};if(n)this.x=n.x,this.y=n.y;else{if(!fL())return;this.x=0,this.y=0}this.wheelDelta=0,"wheel"===t.type&&(t.deltaY>0?this.wheelDelta=1:t.deltaY<0&&(this.wheelDelta=-1)),fL()?(this.dx=t.movementX||t.webkitMovementX||t.mozMovementX||0,this.dy=t.movementY||t.webkitMovementY||t.mozMovementY||0):(this.dx=this.x-e._lastX,this.dy=this.y-e._lastY),"mousedown"===t.type||"mouseup"===t.type?this.button=t.button:this.button=-1,this.buttons=e._buttons.slice(0),this.element=t.target,this.ctrlKey=t.ctrlKey||!1,this.altKey=t.altKey||!1,this.shiftKey=t.shiftKey||!1,this.metaKey=t.metaKey||!1,this.event=t}}class yL extends Qp{constructor(e){super(),this._lastX=0,this._lastY=0,this._buttons=[!1,!1,!1],this._lastbuttons=[!1,!1,!1],this._upHandler=this._handleUp.bind(this),this._downHandler=this._handleDown.bind(this),this._moveHandler=this._handleMove.bind(this),this._wheelHandler=this._handleWheel.bind(this),this._contextMenuHandler=e=>{e.preventDefault()},this._target=null,this._attached=!1,this.attach(e)}static isPointerLocked(){return fL()}attach(e){if(this._target=e,this._attached)return;this._attached=!0;const t=!!uu.passiveEvents&&{passive:!1};window.addEventListener("mouseup",this._upHandler,t),window.addEventListener("mousedown",this._downHandler,t),window.addEventListener("mousemove",this._moveHandler,t),window.addEventListener("wheel",this._wheelHandler,t)}detach(){if(!this._attached)return;this._attached=!1,this._target=null;const e=!!uu.passiveEvents&&{passive:!1};window.removeEventListener("mouseup",this._upHandler,e),window.removeEventListener("mousedown",this._downHandler,e),window.removeEventListener("mousemove",this._moveHandler,e),window.removeEventListener("wheel",this._wheelHandler,e)}disableContextMenu(){this._target&&this._target.addEventListener("contextmenu",this._contextMenuHandler)}enableContextMenu(){this._target&&this._target.removeEventListener("contextmenu",this._contextMenuHandler)}enablePointerLock(e,t){if(!document.body.requestPointerLock)return void(t&&t());const n=()=>{e(),document.removeEventListener("pointerlockchange",n)},a=()=>{t(),document.removeEventListener("pointerlockerror",a)};e&&document.addEventListener("pointerlockchange",n,!1),t&&document.addEventListener("pointerlockerror",a,!1),document.body.requestPointerLock()}disablePointerLock(e){if(!document.exitPointerLock)return;const t=()=>{e(),document.removeEventListener("pointerlockchange",t)};e&&document.addEventListener("pointerlockchange",t,!1),document.exitPointerLock()}update(){this._lastbuttons[0]=this._buttons[0],this._lastbuttons[1]=this._buttons[1],this._lastbuttons[2]=this._buttons[2]}isPressed(e){return this._buttons[e]}wasPressed(e){return this._buttons[e]&&!this._lastbuttons[e]}wasReleased(e){return!this._buttons[e]&&this._lastbuttons[e]}_handleUp(e){this._buttons[e.button]=!1;const t=new gL(this,e);t.event&&this.fire("mouseup",t)}_handleDown(e){this._buttons[e.button]=!0;const t=new gL(this,e);t.event&&this.fire("mousedown",t)}_handleMove(e){const t=new gL(this,e);t.event&&(this.fire("mousemove",t),this._lastX=t.x,this._lastY=t.y)}_handleWheel(e){const t=new gL(this,e);t.event&&this.fire("mousewheel",t)}_getTargetCoords(e){const t=this._target.getBoundingClientRect(),n=Math.floor(t.left),a=Math.floor(t.top);return e.clientX<n||e.clientX>=n+this._target.clientWidth||e.clientY<a||e.clientY>=a+this._target.clientHeight?null:{x:e.clientX-n,y:e.clientY-a}}}let bL,vL;const _L=new Pu,wL=new Pu,xL=new tm,CL=new tm,TL=new tm;xL.end=new Pu,CL.end=new Pu,TL.end=new Pu;const EL=new Pu,SL=new Pu,AL=new Pu,ML=new Pu,LL=new Pu,RL=new Pu,IL=new Pu,PL=new Pu,kL=new Pu,DL=new Pu,OL=new Pu,FL=new Pu,NL=new Pu,VL=new Pu,BL=new Pu,UL=new Pu,zL=new Pu,GL=new Pu,HL=new Pu,WL=new Pu,jL=new Ou;function XL(e,t,n){return OL.cross(e,t).dot(n)}class YL{constructor(e,t,n){this.event=e,this.element=t,this.camera=n,this._stopPropagation=!1}stopPropagation(){this._stopPropagation=!0,this.event&&(this.event.stopImmediatePropagation(),this.event.stopPropagation())}}class qL extends YL{constructor(e,t,n,a,i,s,r){super(e,t,n),this.x=a,this.y=i,this.ctrlKey=e.ctrlKey||!1,this.altKey=e.altKey||!1,this.shiftKey=e.shiftKey||!1,this.metaKey=e.metaKey||!1,this.button=e.button,yL.isPointerLocked()?(this.dx=e.movementX||e.webkitMovementX||e.mozMovementX||0,this.dy=e.movementY||e.webkitMovementY||e.mozMovementY||0):(this.dx=a-s,this.dy=i-r),this.wheelDelta=0,"wheel"===e.type&&(e.deltaY>0?this.wheelDelta=1:e.deltaY<0&&(this.wheelDelta=-1))}}class KL extends YL{constructor(e,t,n,a,i,s){super(e,t,n),this.touches=e.touches,this.changedTouches=e.changedTouches,this.x=a,this.y=i,this.touch=s}}class ZL extends YL{constructor(e,t,n,a){super(e,t,n),this.inputSource=a}}class $L{constructor(e,t){this._app=null,this._attached=!1,this._target=null,this._enabled=!0,this._lastX=0,this._lastY=0,this._upHandler=this._handleUp.bind(this),this._downHandler=this._handleDown.bind(this),this._moveHandler=this._handleMove.bind(this),this._wheelHandler=this._handleWheel.bind(this),this._touchstartHandler=this._handleTouchStart.bind(this),this._touchendHandler=this._handleTouchEnd.bind(this),this._touchcancelHandler=this._touchendHandler,this._touchmoveHandler=this._handleTouchMove.bind(this),this._sortHandler=this._sortElements.bind(this),this._elements=[],this._hoveredElement=null,this._pressedElement=null,this._touchedElements={},this._touchesForWhichTouchLeaveHasFired={},this._selectedElements={},this._selectedPressedElements={},this._useMouse=!t||!1!==t.useMouse,this._useTouch=!t||!1!==t.useTouch,this._useXr=!t||!1!==t.useXr,this._selectEventsAttached=!1,uu.touch&&(this._clickedEntities={}),this.attach(e)}set enabled(e){this._enabled=e}get enabled(){return this._enabled}set app(e){this._app=e}get app(){return this._app||Jg()}attach(e){this._attached&&(this._attached=!1,this.detach()),this._target=e,this._attached=!0;const t=!!uu.passiveEvents&&{passive:!0};this._useMouse&&(window.addEventListener("mouseup",this._upHandler,t),window.addEventListener("mousedown",this._downHandler,t),window.addEventListener("mousemove",this._moveHandler,t),window.addEventListener("wheel",this._wheelHandler,t)),this._useTouch&&uu.touch&&(this._target.addEventListener("touchstart",this._touchstartHandler,t),this._target.addEventListener("touchend",this._touchendHandler,!1),this._target.addEventListener("touchmove",this._touchmoveHandler,!1),this._target.addEventListener("touchcancel",this._touchcancelHandler,!1)),this.attachSelectEvents()}attachSelectEvents(){!this._selectEventsAttached&&this._useXr&&this.app&&this.app.xr&&this.app.xr.supported&&(this._clickedEntities||(this._clickedEntities={}),this._selectEventsAttached=!0,this.app.xr.on("start",this._onXrStart,this))}detach(){if(!this._attached)return;this._attached=!1;const e=!!uu.passiveEvents&&{passive:!0};this._useMouse&&(window.removeEventListener("mouseup",this._upHandler,e),window.removeEventListener("mousedown",this._downHandler,e),window.removeEventListener("mousemove",this._moveHandler,e),window.removeEventListener("wheel",this._wheelHandler,e)),this._useTouch&&(this._target.removeEventListener("touchstart",this._touchstartHandler,e),this._target.removeEventListener("touchend",this._touchendHandler,!1),this._target.removeEventListener("touchmove",this._touchmoveHandler,!1),this._target.removeEventListener("touchcancel",this._touchcancelHandler,!1)),this._selectEventsAttached&&(this._selectEventsAttached=!1,this.app.xr.off("start",this._onXrStart,this),this.app.xr.off("end",this._onXrEnd,this),this.app.xr.off("update",this._onXrUpdate,this),this.app.xr.input.off("selectstart",this._onSelectStart,this),this.app.xr.input.off("selectend",this._onSelectEnd,this),this.app.xr.input.off("remove",this._onXrInputRemove,this)),this._target=null}addElement(e){-1===this._elements.indexOf(e)&&this._elements.push(e)}removeElement(e){const t=this._elements.indexOf(e);-1!==t&&this._elements.splice(t,1)}_handleUp(e){this._enabled&&(yL.isPointerLocked()||(this._calcMouseCoords(e),null!==bL&&this._onElementMouseEvent("mouseup",e)))}_handleDown(e){this._enabled&&(yL.isPointerLocked()||(this._calcMouseCoords(e),null!==bL&&this._onElementMouseEvent("mousedown",e)))}_handleMove(e){this._enabled&&(this._calcMouseCoords(e),null!==bL&&(this._onElementMouseEvent("mousemove",e),this._lastX=bL,this._lastY=vL))}_handleWheel(e){this._enabled&&(this._calcMouseCoords(e),null!==bL&&this._onElementMouseEvent("mousewheel",e))}_determineTouchedElements(e){const t={},n=this.app.systems.camera.cameras;for(let a=n.length-1;a>=0;a--){const i=n[a];let s=0;const r=e.changedTouches.length;for(let n=0;n<r;n++){if(t[e.changedTouches[n].identifier]){s++;continue}const a=this._calcTouchCoords(e.changedTouches[n]),r=this._getTargetElement(i,a.x,a.y);r&&(s++,t[e.changedTouches[n].identifier]={element:r,camera:i,x:a.x,y:a.y})}if(s===r)break}return t}_handleTouchStart(e){if(!this._enabled)return;const t=this._determineTouchedElements(e);for(let n=0,a=e.changedTouches.length;n<a;n++){const a=e.changedTouches[n],i=t[a.identifier],s=this._touchedElements[a.identifier];!i||s&&i.element===s.element||(this._fireEvent(e.type,new KL(e,i.element,i.camera,i.x,i.y,a)),this._touchesForWhichTouchLeaveHasFired[a.identifier]=!1)}for(const e in t)this._touchedElements[e]=t[e]}_handleTouchEnd(e){if(!this._enabled)return;const t=this.app.systems.camera.cameras;for(const e in this._clickedEntities)delete this._clickedEntities[e];for(let n=0,a=e.changedTouches.length;n<a;n++){const a=e.changedTouches[n],i=this._touchedElements[a.identifier];if(!i)continue;const s=i.element,r=i.camera,o=i.x,l=i.y;if(delete this._touchedElements[a.identifier],delete this._touchesForWhichTouchLeaveHasFired[a.identifier],this._fireEvent(e.type,new KL(e,s,r,o,l,a)),0===e.touches.length){const n=this._calcTouchCoords(a);for(let i=t.length-1;i>=0;i--){this._getTargetElement(t[i],n.x,n.y)===s&&(this._clickedEntities[s.entity.getGuid()]||(this._fireEvent("click",new KL(e,s,r,o,l,a)),this._clickedEntities[s.entity.getGuid()]=!0))}}}}_handleTouchMove(e){if(e.preventDefault(),!this._enabled)return;const t=this._determineTouchedElements(e);for(let n=0,a=e.changedTouches.length;n<a;n++){const a=e.changedTouches[n],i=t[a.identifier],s=this._touchedElements[a.identifier];if(s){const t=this._calcTouchCoords(a);i&&i.element===s.element||this._touchesForWhichTouchLeaveHasFired[a.identifier]||(this._fireEvent("touchleave",new KL(e,s.element,s.camera,t.x,t.y,a)),this._touchesForWhichTouchLeaveHasFired[a.identifier]=!0),this._fireEvent("touchmove",new KL(e,s.element,s.camera,t.x,t.y,a))}}}_onElementMouseEvent(e,t){let n;const a=this._hoveredElement;this._hoveredElement=null;const i=this.app.systems.camera.cameras;let s;for(let e=i.length-1;e>=0&&(s=i[e],n=this._getTargetElement(s,bL,vL),!n);e--);n&&(this._fireEvent(e,new qL(t,n,s,bL,vL,this._lastX,this._lastY)),this._hoveredElement=n,"mousedown"===e&&(this._pressedElement=n)),a!==this._hoveredElement&&(a&&this._fireEvent("mouseleave",new qL(t,a,s,bL,vL,this._lastX,this._lastY)),this._hoveredElement&&this._fireEvent("mouseenter",new qL(t,this._hoveredElement,s,bL,vL,this._lastX,this._lastY))),"mouseup"===e&&this._pressedElement&&(this._pressedElement===this._hoveredElement?(this._pressedElement=null,this._clickedEntities&&this._clickedEntities[this._hoveredElement.entity.getGuid()]||this._fireEvent("click",new qL(t,this._hoveredElement,s,bL,vL,this._lastX,this._lastY))):this._pressedElement=null)}_onXrStart(){this.app.xr.on("end",this._onXrEnd,this),this.app.xr.on("update",this._onXrUpdate,this),this.app.xr.input.on("selectstart",this._onSelectStart,this),this.app.xr.input.on("selectend",this._onSelectEnd,this),this.app.xr.input.on("remove",this._onXrInputRemove,this)}_onXrEnd(){this.app.xr.off("update",this._onXrUpdate,this),this.app.xr.input.off("selectstart",this._onSelectStart,this),this.app.xr.input.off("selectend",this._onSelectEnd,this),this.app.xr.input.off("remove",this._onXrInputRemove,this)}_onXrUpdate(){if(!this._enabled)return;const e=this.app.xr.input.inputSources;for(let t=0;t<e.length;t++)this._onElementSelectEvent("selectmove",e[t],null)}_onXrInputRemove(e){const t=this._selectedElements[e.id];t&&(e._elementEntity=null,this._fireEvent("selectleave",new ZL(null,t,null,e))),delete this._selectedElements[e.id],delete this._selectedPressedElements[e.id]}_onSelectStart(e,t){this._enabled&&this._onElementSelectEvent("selectstart",e,t)}_onSelectEnd(e,t){this._enabled&&this._onElementSelectEvent("selectend",e,t)}_onElementSelectEvent(e,t,n){let a;const i=this._selectedElements[t.id];let s;const r=this.app.systems.camera.cameras;let o;if(t.elementInput){TL.set(t.getOrigin(),t.getDirection());for(let e=r.length-1;e>=0&&(o=r[e],a=this._getTargetElementByRay(TL,o),!a);e--);}t._elementEntity=a||null,a?(this._selectedElements[t.id]=a,s=a):delete this._selectedElements[t.id],i!==s&&(i&&this._fireEvent("selectleave",new ZL(n,i,o,t)),s&&this._fireEvent("selectenter",new ZL(n,s,o,t))),"selectstart"===e&&(this._selectedPressedElements[t.id]=s,s&&this._fireEvent("selectstart",new ZL(n,s,o,t)));const l=this._selectedPressedElements[t.id];!t.elementInput&&l&&(delete this._selectedPressedElements[t.id],i&&this._fireEvent("selectend",new ZL(n,i,o,t))),"selectend"===e&&t.elementInput&&(delete this._selectedPressedElements[t.id],i&&this._fireEvent("selectend",new ZL(n,i,o,t)),l&&l===i&&this._fireEvent("click",new ZL(n,l,o,t)))}_fireEvent(e,t){let n=t.element;for(;n.fire(e,t),!t._stopPropagation&&n.entity.parent&&(n=n.entity.parent.element,n););}_calcMouseCoords(e){const t=this._target.getBoundingClientRect(),n=Math.floor(t.left),a=Math.floor(t.top);e.clientX<n||e.clientX>=n+this._target.clientWidth||e.clientY<a||e.clientY>=a+this._target.clientHeight?(bL=null,vL=null):(bL=e.clientX-n,vL=e.clientY-a)}_calcTouchCoords(e){let t=0,n=0,a=e.target;for(;!(a instanceof HTMLElement);)a=a.parentNode;let i=a;do{t+=i.offsetLeft-i.scrollLeft,n+=i.offsetTop-i.scrollTop,i=i.offsetParent}while(i);return{x:e.pageX-t,y:e.pageY-n}}_sortElements(e,t){const n=this.app.scene.layers.sortTransparentLayers(e.layers,t.layers);return 0!==n?n:e.screen&&!t.screen?-1:!e.screen&&t.screen?1:e.screen||t.screen?e.screen.screen.screenSpace&&!t.screen.screen.screenSpace?-1:t.screen.screen.screenSpace&&!e.screen.screen.screenSpace?1:t.drawOrder-e.drawOrder:0}_getTargetElement(e,t,n){let a,i,s=null,r=1/0;this._elements.sort(this._sortHandler);for(let o=0,l=this._elements.length;o<l;o++){const l=this._elements[o];if(l.screen&&l.screen.screen.screenSpace){if(void 0===a&&(a=this._calculateRayScreen(t,n,e,xL)?xL:null),!a)continue;if(this._checkElement(a,l,!0)>=0){s=l;break}}else{if(void 0===i&&(i=this._calculateRay3d(t,n,e,CL)?CL:null),!i)continue;const a=this._checkElement(i,l,!1);if(a>=0&&(a<r&&(s=l,r=a),l.screen)){s=l;break}}}return s}_getTargetElementByRay(e,t){let n=null;xL.origin.copy(e.origin),xL.direction.copy(e.direction),xL.end.copy(xL.direction).mulScalar(2*t.farClip).add(xL.origin),this._elements.sort(this._sortHandler);for(let e=0,t=this._elements.length;e<t;e++){const t=this._elements[e];if((!t.screen||!t.screen.screen.screenSpace)&&this._checkElement(xL,t,!1)>=0){n=t;break}}return n}_buildHitCorners(e,t,n,a,i){let s=t;if(e.entity&&e.entity.button){const t=e.entity.button.hitPadding||jL;NL.copy(e.entity.up),VL.copy(NL).mulScalar(-1),UL.copy(e.entity.right),BL.copy(UL).mulScalar(-1),NL.mulScalar(t.w*a),VL.mulScalar(t.y*a),UL.mulScalar(t.z*n),BL.mulScalar(t.x*n),zL.copy(s[0]).add(VL).add(BL),GL.copy(s[1]).add(VL).add(UL),HL.copy(s[2]).add(NL).add(UL),WL.copy(s[3]).add(NL).add(BL),s=[zL,GL,HL,WL]}if(n<0){const e=s[2].x,t=s[0].x;s[0].x=e,s[1].x=t,s[2].x=t,s[3].x=e}if(a<0){const e=s[2].y,t=s[0].y;s[0].y=e,s[1].y=e,s[2].y=t,s[3].y=t}if(i<0){const e=s[2].x,t=s[2].y,n=s[2].z;s[2].x=s[0].x,s[2].y=s[0].y,s[2].z=s[0].z,s[0].x=e,s[0].y=t,s[0].z=n}return s}_calculateScaleToScreen(e){let t=e.entity;const n=e.screen.screen.scale;for(FL.set(n,n,n);t&&!t.screen;)FL.mul(t.getLocalScale()),t=t.parent;return FL}_calculateScaleToWorld(e){let t=e.entity;for(FL.set(1,1,1);t;)FL.mul(t.getLocalScale()),t=t.parent;return FL}_calculateRayScreen(e,t,n,a){const i=this.app.graphicsDevice.width,s=this.app.graphicsDevice.height,r=n.rect.z*i,o=n.rect.w*s,l=n.rect.x*i,c=l+r,h=(1-n.rect.y)*s,d=h-o;let p=e*i/this._target.clientWidth,u=t*s/this._target.clientHeight;return p>=l&&p<=c&&u<=h&&u>=d&&(p=i*(p-l)/r,u=s*(u-d)/o,u=s-u,a.origin.set(p,u,1),a.direction.set(0,0,-1),a.end.copy(a.direction).mulScalar(2).add(a.origin),!0)}_calculateRay3d(e,t,n,a){const i=this._target.clientWidth,s=this._target.clientHeight,r=n.rect.z*i,o=n.rect.w*s,l=n.rect.x*i,c=l+r,h=(1-n.rect.y)*s,d=h-o;let p=e,u=t;return e>=l&&e<=c&&t<=h&&u>=d&&(p=i*(p-l)/r,u=s*(u-d)/o,n.screenToWorld(p,u,n.nearClip,_L),n.screenToWorld(p,u,n.farClip,wL),a.origin.copy(_L),a.direction.set(0,0,-1),a.end.copy(wL),!0)}_checkElement(e,t,n){if(t.maskedBy&&this._checkElement(e,t.maskedBy.element,n)<0)return-1;let a;a=n?this._calculateScaleToScreen(t):this._calculateScaleToWorld(t);const i=this._buildHitCorners(t,n?t.screenCorners:t.worldCorners,a.x,a.y,a.z);return function(e,t,n){EL.sub2(t,e),SL.sub2(n[0],e),AL.sub2(n[1],e),ML.sub2(n[2],e),RL.cross(ML,EL);let a,i,s=SL.dot(RL);if(s>=0){if(a=-AL.dot(RL),a<0)return-1;if(i=XL(EL,AL,SL),i<0)return-1;const e=1/(a+s+i);IL.copy(n[0]).mulScalar(a*e),PL.copy(n[1]).mulScalar(s*e),kL.copy(n[2]).mulScalar(i*e),DL.copy(IL).add(PL).add(kL)}else{if(LL.sub2(n[3],e),a=LL.dot(RL),a<0)return-1;if(i=XL(EL,SL,LL),i<0)return-1;s=-s;const t=1/(a+s+i);IL.copy(n[0]).mulScalar(a*t),PL.copy(n[3]).mulScalar(s*t),kL.copy(n[2]).mulScalar(i*t),DL.copy(IL).add(PL).add(kL)}return EL.sub2(n[0],n[2]).lengthSq()<1e-8||EL.sub2(n[1],n[3]).lengthSq()<1e-8?-1:DL.sub(e).lengthSq()}(e.origin,e.end,i)}}const QL={DEFAULT:{buttons:["PAD_FACE_1","PAD_FACE_2","PAD_FACE_3","PAD_FACE_4","PAD_L_SHOULDER_1","PAD_R_SHOULDER_1","PAD_L_SHOULDER_2","PAD_R_SHOULDER_2","PAD_SELECT","PAD_START","PAD_L_STICK_BUTTON","PAD_R_STICK_BUTTON","PAD_UP","PAD_DOWN","PAD_LEFT","PAD_RIGHT","PAD_VENDOR"],axes:["PAD_L_STICK_X","PAD_L_STICK_Y","PAD_R_STICK_X","PAD_R_STICK_Y"]},PS3:{buttons:["PAD_FACE_1","PAD_FACE_2","PAD_FACE_4","PAD_FACE_3","PAD_L_SHOULDER_1","PAD_R_SHOULDER_1","PAD_L_SHOULDER_2","PAD_R_SHOULDER_2","PAD_SELECT","PAD_START","PAD_L_STICK_BUTTON","PAD_R_STICK_BUTTON","PAD_UP","PAD_DOWN","PAD_LEFT","PAD_RIGHT","PAD_VENDOR"],axes:["PAD_L_STICK_X","PAD_L_STICK_Y","PAD_R_STICK_X","PAD_R_STICK_Y"]}},JL={"Product: 0268":"PS3"};class eR{constructor(){this.gamepadsSupported=!!navigator.getGamepads||!!navigator.webkitGetGamepads,this.current=[],this.previous=[],this.deadZone=.25}update(){for(let e=0,t=this.current.length;e<t;e++){const t=this.current[e].pad.buttons,n=t.length;for(let a=0;a<n;a++)void 0===this.previous[e]&&(this.previous[e]=[]),this.previous[e][a]=t[a].pressed}this.poll(this.current)}poll(e=[]){if(e.length>0&&(e.length=0),this.gamepadsSupported){const t=navigator.getGamepads?navigator.getGamepads():navigator.webkitGetGamepads();for(let n=0,a=t.length;n<a;n++)t[n]&&e.push({map:this.getMap(t[n]),pad:t[n]})}return e}getMap(e){for(const t in JL)if(e.id.indexOf(t)>=0)return QL[JL[t]];return QL.DEFAULT}isPressed(e,t){if(!this.current[e])return!1;const n=this.current[e].map.buttons[t];return this.current[e].pad.buttons[pc[n]].pressed}wasPressed(e,t){if(!this.current[e])return!1;const n=this.current[e].map.buttons[t],a=pc[n];return this.current[e].pad.buttons[a].pressed&&!(this.previous[e]&&this.previous[e][a])}wasReleased(e,t){if(!this.current[e])return!1;const n=this.current[e].map.buttons[t],a=pc[n];return!this.current[e].pad.buttons[a].pressed&&this.previous[e]&&this.previous[e][a]}getAxis(e,t){if(!this.current[e])return 0;const n=this.current[e].map.axes[t];let a=this.current[e].pad.axes[pc[n]];return Math.abs(a)<this.deadZone&&(a=0),a}}class tR{constructor(e){const t=function(e){let t=0,n=0,a=e.target;for(;!(a instanceof HTMLElement);)a=a.parentNode;let i=a;do{t+=i.offsetLeft-i.scrollLeft,n+=i.offsetTop-i.scrollTop,i=i.offsetParent}while(i);return{x:e.pageX-t,y:e.pageY-n}}(e);this.id=e.identifier,this.x=t.x,this.y=t.y,this.target=e.target,this.touch=e}}class nR{constructor(e,t){if(this.element=t.target,this.event=t,this.touches=[],this.changedTouches=[],t){for(let e=0,n=t.touches.length;e<n;e++)this.touches.push(new tR(t.touches[e]));for(let e=0,n=t.changedTouches.length;e<n;e++)this.changedTouches.push(new tR(t.changedTouches[e]))}}getTouchById(e,t){for(let n=0,a=t.length;n<a;n++)if(t[n].id===e)return t[n];return null}}class aR extends Qp{constructor(e){super(),this._element=null,this._startHandler=this._handleTouchStart.bind(this),this._endHandler=this._handleTouchEnd.bind(this),this._moveHandler=this._handleTouchMove.bind(this),this._cancelHandler=this._handleTouchCancel.bind(this),this.attach(e)}attach(e){this._element&&this.detach(),this._element=e,this._element.addEventListener("touchstart",this._startHandler,!1),this._element.addEventListener("touchend",this._endHandler,!1),this._element.addEventListener("touchmove",this._moveHandler,!1),this._element.addEventListener("touchcancel",this._cancelHandler,!1)}detach(){this._element&&(this._element.removeEventListener("touchstart",this._startHandler,!1),this._element.removeEventListener("touchend",this._endHandler,!1),this._element.removeEventListener("touchmove",this._moveHandler,!1),this._element.removeEventListener("touchcancel",this._cancelHandler,!1)),this._element=null}_handleTouchStart(e){this.fire("touchstart",new nR(this,e))}_handleTouchEnd(e){this.fire("touchend",new nR(this,e))}_handleTouchMove(e){e.preventDefault(),this.fire("touchmove",new nR(this,e))}_handleTouchCancel(e){this.fire("touchcancel",new nR(this,e))}}yu.endsWith=function(e,t){return e.endsWith(t)},yu.startsWith=function(e,t){return e.startsWith(t)},Object.defineProperty(Mu.prototype,"data",{get:function(){return this._data||(this._data=new Float32Array(4)),this._data[0]=this.r,this._data[1]=this.g,this._data[2]=this.b,this._data[3]=this.a,this._data}}),Object.defineProperty(Mu.prototype,"data3",{get:function(){return this._data3||(this._data3=new Float32Array(3)),this._data3[0]=this.r,this._data3[1]=this.g,this._data3[2]=this.b,this._data3}}),Eu.INV_LOG2=Math.LOG2E,Eu.intToBytes=Eu.intToBytes32,Eu.bytesToInt=Eu.bytesToInt32,Object.defineProperty(Du.prototype,"data",{get:function(){return this._data||(this._data=new Float32Array(2)),this._data[0]=this.x,this._data[1]=this.y,this._data}}),Du.prototype.scale=Du.prototype.mulScalar,Object.defineProperty(Pu.prototype,"data",{get:function(){return this._data||(this._data=new Float32Array(3)),this._data[0]=this.x,this._data[1]=this.y,this._data[2]=this.z,this._data}}),Pu.prototype.scale=Pu.prototype.mulScalar,Object.defineProperty(Ou.prototype,"data",{get:function(){return this._data||(this._data=new Float32Array(4)),this._data[0]=this.x,this._data[1]=this.y,this._data[2]=this.z,this._data[3]=this.w,this._data}}),Ou.prototype.scale=Ou.prototype.mulScalar,$u.prototype.intersectRay=$u.prototype.intersectsRay,em.prototype.update=function(e,t){const n=new zu;n.mul2(e,t),this.setFromMat4(n)},Object.defineProperty(gm,"transformSkinnedVS",{get:function(){return"#define SKIN\n"+gm.transformVS}});const iR={"ambientPrefilteredCube.frag":"ambientEnv.frag","ambientPrefilteredCubeLod.frag":"ambientEnv.frag","dpAtlasQuad.frag":null,"genParaboloid.frag":null,"prefilterCubemap.frag":null,"reflectionDpAtlas.frag":"reflectionEnv.frag","reflectionPrefilteredCube.frag":"reflectionEnv.frag","reflectionPrefilteredCubeLod.frag":"reflectionEnv.frag"};function sR(e,t){Object.defineProperty(cg.prototype,t,{get:function(){return this[e]},set:function(t){this[e]=t}})}Object.keys(iR).forEach((e=>{Object.defineProperty(gm,e,{get:function(){return null},set:function(){}})})),Object.defineProperties(Cg.prototype,{_glFrameBuffer:{get:function(){return this.impl._glFrameBuffer},set:function(e){}}}),hm.prototype.update=function(){},Object.defineProperties(Gm.prototype,{rgbm:{get:function(){return"rgbm"===this.type},set:function(e){this.type=e?"rgbm":"default"}},swizzleGGGR:{get:function(){return"swizzleGGGR"===this.type},set:function(e){this.type=e?"swizzleGGGR":"default"}},_glTexture:{get:function(){return this.impl._glTexture}}}),Object.defineProperty(Uv.prototype,"defaultMaterial",{get:function(){return $f(Jg().graphicsDevice)}}),["128","64","32","16","8","4"].forEach(((e,t)=>{Object.defineProperty(Uv.prototype,`skyboxPrefiltered${e}`,{get:function(){return this._prefilteredCubemaps[t]},set:function(e){this._prefilteredCubemaps[t]=e,this.updateShaders=!0}})})),Object.defineProperty(fy.prototype,"model",{get:function(){return null}}),Ay.prototype.syncAabb=function(){},Pv.prototype.getTarget=function(e){return this.targets[e]},hf.prototype._dirtify=function(e){e?this._dirtifyLocal():this._dirtifyWorld()},hf.prototype.addLabel=function(e){this._labels[e]=!0},hf.prototype.getLabels=function(){return Object.keys(this._labels)},hf.prototype.hasLabel=function(e){return!!this._labels[e]},hf.prototype.removeLabel=function(e){delete this._labels[e]},hf.prototype.findByLabel=function(e,t=[]){this.hasLabel(e)&&t.push(this);for(let n=0;n<this._children.length;++n)t=this._children[n].findByLabel(e,t);return t},hf.prototype.getChildren=function(){return this.children},hf.prototype.getName=function(){return this.name},hf.prototype.getPath=function(){return this.path},hf.prototype.getRoot=function(){return this.root},hf.prototype.getParent=function(){return this.parent},hf.prototype.setName=function(e){this.name=e},Jf.prototype.getName=function(){return this.name},Jf.prototype.setName=function(e){this.name=e},Jf.prototype.getShader=function(){return this.shader},Jf.prototype.setShader=function(e){this.shader=e},sR("diffuseTint","diffuseMapTint"),sR("specularTint","specularMapTint"),sR("emissiveTint","emissiveMapTint"),sR("aoVertexColor","aoMapVertexColor"),sR("diffuseVertexColor","diffuseMapVertexColor"),sR("specularVertexColor","specularMapVertexColor"),sR("emissiveVertexColor","emissiveMapVertexColor"),sR("metalnessVertexColor","metalnessMapVertexColor"),sR("glossVertexColor","glossMapVertexColor"),sR("opacityVertexColor","opacityMapVertexColor"),sR("lightVertexColor","lightMapVertexColor"),Kv.prototype.getDuration=function(){return this.duration},Kv.prototype.getName=function(){return this.name},Kv.prototype.getNodes=function(){return this.nodes},Kv.prototype.setDuration=function(e){this.duration=e},Kv.prototype.setName=function(e){this.name=e},BC.prototype.getAnimation=function(){return this.animation},BC.prototype.getCurrentTime=function(){return this.currentTime},BC.prototype.getLooping=function(){return this.looping},BC.prototype.getNumNodes=function(){return this.numNodes},BC.prototype.setAnimation=function(e){this.animation=e},BC.prototype.setCurrentTime=function(e){this.currentTime=e},BC.prototype.setLooping=function(e){this.looping=e},Xv.prototype.getListener=function(){return this.listener},Xv.prototype.getVolume=function(){return this.volume},Xv.prototype.setVolume=function(e){this.volume=e},Dx.prototype.getAssetById=function(e){return this.get(e)},Object.defineProperty(pC.prototype,"ray",{get:function(){return this._rayLocal}}),Object.defineProperty(pC.prototype,"position",{get:function(){return this._localPosition}}),Object.defineProperty(pC.prototype,"rotation",{get:function(){return this._localRotation}}),Object.defineProperty($L.prototype,"wheel",{get:function(){return-2*this.wheelDelta}}),Object.defineProperty(gL.prototype,"wheel",{get:function(){return-2*this.wheelDelta}}),jM.prototype.isFullscreen=function(){return!!document.fullscreenElement},jM.prototype.enableFullscreen=function(e,t,n){e=e||this.graphicsDevice.canvas;const a=function e(){t(),document.removeEventListener("fullscreenchange",e)},i=function e(){n(),document.removeEventListener("fullscreenerror",e)};t&&document.addEventListener("fullscreenchange",a,!1),n&&document.addEventListener("fullscreenerror",i,!1),e.requestFullscreen?e.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT):n()},jM.prototype.disableFullscreen=function(e){const t=function t(){e(),document.removeEventListener("fullscreenchange",t)};e&&document.addEventListener("fullscreenchange",t,!1),document.exitFullscreen()},jM.prototype.getSceneUrl=function(e){const t=this.scenes.find(e);return t?t.url:null},jM.prototype.loadScene=function(e,t){this.scenes.loadScene(e,t)},jM.prototype.loadSceneHierarchy=function(e,t){this.scenes.loadSceneHierarchy(e,t)},jM.prototype.loadSceneSettings=function(e,t){this.scenes.loadSceneSettings(e,t)},jM.prototype.renderMeshInstance=function(e,t){const n=null!=t&&t.layer?t.layer:this.scene.defaultDrawLayer;this.scene.immediate.drawMesh(null,null,null,e,n)},jM.prototype.renderMesh=function(e,t,n,a){const i=null!=a&&a.layer?a.layer:this.scene.defaultDrawLayer;this.scene.immediate.drawMesh(t,n,e,null,i)},jM.prototype._addLines=function(e,t,n){const a=n&&n.layer?n.layer:this.scene.layers.getLayerById(3),i=!n||void 0===n.depthTest||n.depthTest;this.scene.immediate.getBatch(a,i).addLines(e,t)},jM.prototype.renderLine=function(e,t,n){let a,i=n;const s=arguments[3],r=arguments[4];s instanceof Mu?(i=s,a="number"==typeof r?1===r?{layer:this.scene.layers.getLayerById(3),depthTest:!1}:{layer:this.scene.layers.getLayerById(3),depthTest:!0}:r):"number"==typeof s?(i=n,a=1===s?{layer:this.scene.layers.getLayerById(3),depthTest:!1}:{layer:this.scene.layers.getLayerById(3),depthTest:!0}):s&&(a=s),this._addLines([e,t],[n,i],a)},jM.prototype.renderLines=function(e,t,n){n?"number"==typeof n&&(n=1===n?{layer:this.scene.layers.getLayerById(3),depthTest:!1}:{layer:this.scene.layers.getLayerById(3),depthTest:!0}):n={layer:this.scene.layers.getLayerById(3),depthTest:!0};!t.length||e.length===t.length?e.length%2==0?this._addLines(e,t,n):console.error("renderLines: array length is not divisible by 2"):console.error("renderLines: position/color arrays have different lengths")},Object.defineProperty(OT.prototype,"node",{get:function(){return this.entity}}),Object.defineProperty(uS.prototype,"enable",{get:function(){return this.enabled},set:function(e){this.enabled=e}}),bS.prototype.setVisible=function(e){this.enabled=e},Object.defineProperty(bS.prototype,"aabb",{get:function(){return null},set:function(e){}}),Object.defineProperty(xS.prototype,"aabb",{get:function(){return null},set:function(e){}}),Object.defineProperty(VA.prototype,"bodyType",{get:function(){return this.type},set:function(e){this.type=e}}),VA.prototype.syncBodyToEntity=function(){this._updateDynamic()},jA.prototype.setGravity=function(){1===arguments.length?this.gravity.copy(arguments[0]):this.gravity.set(arguments[0],arguments[1],arguments[2])};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var rR=function(e,t){return rR=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},rR(e,t)};function oR(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}rR(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var lR=function(){return lR=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e},lR.apply(this,arguments)};function cR(e,t,n,a){return new(n||(n=Promise))((function(i,s){function r(e){try{l(a.next(e))}catch(e){s(e)}}function o(e){try{l(a.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,o)}l((a=a.apply(e,t||[])).next())}))}function hR(e,t){var n,a,i,s,r={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return s={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function o(s){return function(o){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;r;)try{if(n=1,a&&(i=2&s[0]?a.return:s[0]?a.throw||((i=a.return)&&i.call(a),0):a.next)&&!(i=i.call(a,s[1])).done)return i;switch(a=0,i&&(s=[2&s[0],i.value]),s[0]){case 0:case 1:i=s;break;case 4:return r.label++,{value:s[1],done:!1};case 5:r.label++,a=s[1],s=[0];continue;case 7:s=r.ops.pop(),r.trys.pop();continue;default:if(!(i=r.trys,(i=i.length>0&&i[i.length-1])||6!==s[0]&&2!==s[0])){r=0;continue}if(3===s[0]&&(!i||s[1]>i[0]&&s[1]<i[3])){r.label=s[1];break}if(6===s[0]&&r.label<i[1]){r.label=i[1],i=s;break}if(i&&r.label<i[2]){r.label=i[2],r.ops.push(s);break}i[2]&&r.ops.pop(),r.trys.pop();continue}s=t.call(e,r)}catch(e){s=[6,e],a=0}finally{n=i=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,o])}}}var dR=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return oR(t,e),t.load=function(e,t,n){if(e.data){var a=new f_(e.name,e.type,"cubemap"===e.type?{url:e.url}:null,e.data);a.on("load",(function(t){n(e.name,t)})),t.assets.add(a),t.assets.load(a)}else t.assets.loadFromUrl(e.url,e.type,(function(t,a){!t&&a&&n(e.name,a)}))},t}(N.Component),pR=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return oR(t,e),t.load=function(e,t,n){fetch(e.url).then((function(e){return e.text()})).then((function(t){window[e.name]=(Function("module","exports",t).call(module,module,module.exports),module).exports,n()}))},t}(N.Component);!function(e){if(!e||!window)return;const t=document.createElement("style");t.setAttribute("type","text/css"),t.innerHTML=e,document.head.appendChild(t)}('.pcui-numeric-input-slider-control {\n  display: none;\n  position: absolute;\n  width: 10px;\n  height: 10px;\n  right: 3px;\n  border: 2px solid #20292b;\n  background-color: #293538;\n  border-radius: 100px;\n  z-index: 9999;\n  transform: translateY(-50%);\n  top: 50%;\n  cursor: ew-resize;\n}\n\n.pcui-numeric-input-slider-control:after {\n  content: "\\e408";\n  font-size: 15px;\n  font-family: "pc-icon";\n  position: absolute;\n  left: -5px;\n  top: -5px;\n  transform: rotateZ(90deg);\n}\n\n.pcui-numeric-input-slider-control:hover {\n  opacity: 50%;\n  color: #b1b8ba;\n}\n\n.pcui-numeric-input-slider-control-active {\n  opacity: 100% !important;\n  color: #7f7 !important;\n}\n\n.pcui-numeric-input-slider-control-hidden {\n  display: none !important;\n}\n\n.pcui-numeric-input:hover .pcui-numeric-input-slider-control {\n  display: block;\n}\n\n.pcui-numeric-input.pcui-disabled:hover .pcui-numeric-input-slider-control {\n  display: none;\n}\n\n.pcui-numeric-input.pcui-disabled .pcui-numeric-input-slider-control, .pcui-numeric-input.pcui-readonly .pcui-numeric-input-slider-control {\n  display: none;\n}');const uR=/,/g;class mR extends Rp{constructor(e){const t=(e=Object.assign({},e)).value;delete e.value;const n=e.renderChanges||!1;if(delete e.renderChanges,super(e),this.class.add("pcui-numeric-input"),this._min=void 0!==e.min?e.min:null,this._max=void 0!==e.max?e.max:null,this._allowNull=e.allowNull||!1,this._precision=Number.isFinite(e.precision)?e.precision:7,Number.isFinite(e.step)?this._step=e.step:Number.isFinite(e.precision)?this._step=1/Math.pow(10,e.precision):this._step=1,this._oldValue=void 0,this.value=t,this._historyCombine=!1,this._historyPostfix=null,this._sliderPrevValue=0,this.renderChanges=n,this._domEvtPointerLock=null,this._domEvtSliderMouseDown=null,this._domEvtSliderMouseUp=null,this._domEvtMouseWheel=null,!e.hideSlider){this._sliderControl=new xh,this._sliderControl.class.add("pcui-numeric-input-slider-control"),this.dom.append(this._sliderControl.dom);let e=!1;this._domEvtSliderMouseDown=()=>{this._sliderControl.dom.requestPointerLock(),this._sliderMovement=0,this._sliderPrevValue=this.value,e=!0,this.binding&&(this._historyCombine=this.binding.historyCombine,this._historyPostfix=this.binding.historyPostfix,this.binding.historyCombine=!0,this.binding.historyPostfix=`(${Date.now()})`)},this._domEvtSliderMouseUp=()=>{document.exitPointerLock(),e&&(e=!1,this.value=this._sliderPrevValue+this._sliderMovement,this.binding&&(this.binding.historyCombine=this._historyCombine,this.binding.historyPostfix=this._historyPostfix,this._historyCombine=!1,this._historyPostfix=null))},this._domEvtPointerLock=this._pointerLockChangeAlert.bind(this),this._domEvtMouseWheel=this._updatePosition.bind(this),this._sliderControl.dom.addEventListener("mousedown",this._domEvtSliderMouseDown),this._sliderControl.dom.addEventListener("mouseup",this._domEvtSliderMouseUp),document.addEventListener("pointerlockchange",this._domEvtPointerLock,!1),document.addEventListener("mozpointerlockchange",this._domEvtPointerLock,!1)}}_updatePosition(e){let t=0;e.constructor===WheelEvent?t=e.deltaY:e.constructor===MouseEvent&&(t=e.movementX),this._sliderMovement+=t/100*this._step,this.value=this._sliderPrevValue+this._sliderMovement}_onInputChange(e){this.value=this._domInput.value}_onInputKeyDown(e){if(!this.enabled||this.readOnly)return super._onInputKeyDown(e);if(38!==e.keyCode&&40!==e.keyCode)super._onInputKeyDown(e);else{const t=(e.shiftKey?10:1)*(40===e.keyCode?-1:1);this.value+=this.step*t}}_isScrolling(){return!!this._sliderControl&&(document.pointerLockElement===this._sliderControl.dom||document.mozPointerLockElement===this._sliderControl.dom)}_pointerLockChangeAlert(){this._isScrolling()?(this._sliderControl.dom.addEventListener("mousemove",this._domEvtMouseWheel,!1),this._sliderControl.dom.addEventListener("wheel",this._domEvtMouseWheel,!1),this._sliderControl.class.add("pcui-numeric-input-slider-control-active")):(this._sliderControl.dom.removeEventListener("mousemove",this._domEvtMouseWheel,!1),this._sliderControl.dom.removeEventListener("wheel",this._domEvtMouseWheel,!1),this._sliderControl.class.remove("pcui-numeric-input-slider-control-active"))}_normalizeValue(e){try{if("string"==typeof e&&null!==(e=(e=(e=e.replace(uR,".")).replace(/\s/g,"")).match(/^[*/+\-0-9().]+$/))&&e[0].length<20){var t=e[0];["+","-","/","*"].forEach((e=>{var n=t.split(e);n.forEach(((e,t)=>{n[t]=n[t].replace(/^0+/,"")})),t=n.join(e)})),e=Function('"use strict";return ('+t+")")()}}catch(t){e=null}if(null===e||isNaN(e)){if(this._allowNull)return null;e=0}return null!==this.min&&e<this.min&&(e=this.min),null!==this.max&&e>this.max&&(e=this.max),null!==this.precision&&(e=parseFloat(Number(e).toFixed(this.precision),10)),e}_updateValue(e,t){const n=e!==this._oldValue||t;return this._oldValue=e,this._domInput.value=e,this.class.remove(gh),n&&this.emit("change",e),n}get value(){const e=super.value;return""!==e?parseFloat(e,10):null}set value(e){e=this._normalizeValue(e);const t=this.class.contains(gh)&&null===e&&this._allowNull;this._updateValue(e,t)&&this.binding&&this.binding.setValue(e),this._sliderControl&&this._sliderControl.class.remove("pcui-numeric-input-slider-control-hidden")}set values(e){let t=!1;const n=this._normalizeValue(e[0]);for(let a=1;a<e.length;a++)if(n!==this._normalizeValue(e[a])){t=!0;break}t?(this._updateValue(null),this.class.add(gh),this._sliderControl&&this._sliderControl.class.add("pcui-numeric-input-slider-control-hidden")):(this._updateValue(n),this._sliderControl&&this._sliderControl.class.remove("pcui-numeric-input-slider-control-hidden"))}get min(){return this._min}set min(e){this._min!==e&&(this._min=e,null!==this._min&&(this.value=this.value))}get max(){return this._max}set max(e){this._max!==e&&(this._max=e,null!==this._max&&(this.value=this.value))}get precision(){return this._precision}set precision(e){this._precision!==e&&(this._precision=e,null!==this._precision&&(this.value=this.value))}get step(){return this._step}set step(e){this._step=e}destroy(){this.destroyed||(this._domEvtSliderMouseDown&&(this._sliderControl.dom.removeEventListener("mousedown",this._domEvtSliderMouseDown),this._sliderControl.dom.removeEventListener("mouseup",this._domEvtSliderMouseUp)),this._domEvtMouseWheel&&(this._sliderControl.dom.removeEventListener("mousemove",this._domEvtMouseWheel,!1),this._sliderControl.dom.removeEventListener("wheel",this._domEvtMouseWheel,!1)),this._domEvtPointerLock&&(document.removeEventListener("pointerlockchange",this._domEvtPointerLock,!1),document.removeEventListener("mozpointerlockchange",this._domEvtPointerLock,!1)),super.destroy())}}xh.register("number",mR,{renderChanges:!0});var fR,gR,yR,bR,vR={};vR.deepCopy=function e(t){if(null==t||"object"!=typeof t)return t;if(t instanceof Array){for(var n=[],a=0;a<t.length;a++)n[a]=e(t[a]);return n}var i={};for(var s in t)t.hasOwnProperty(s)&&(i[s]=e(t[s]));return i},vR.isMobile=function(){return/Android/i.test(navigator.userAgent)||/iPhone|iPad|iPod/i.test(navigator.userAgent)},vR.implements=function(e,t){var n=Object.getOwnPropertyDescriptors(t.prototype);for(var a in n)e.prototype.hasOwnProperty(a)&&delete n[a];Object.defineProperties(e.prototype,n)},vR.proxy=function(e,t,n){n.forEach((n=>{Object.defineProperty(e.prototype,n,{get:function(){return this[t][n]},set:function(e){this[t][n]=e}})}))},String.prototype.startsWith||Object.defineProperty(String.prototype,"startsWith",{enumerable:!1,configurable:!1,writable:!1,value:function(e){for(var t=e.length,n=0;n<t;n++)if(this[n]!==e[n])return!1;return!0}}),String.prototype.endsWith||Object.defineProperty(String.prototype,"endsWith",{enumerable:!1,configurable:!1,writable:!1,value:function(e){for(var t=0,n=e.length;t<n;t++)if(this[t+this.length-n]!==e[t])return!1;return!0}}),String.prototype.appendQuery||Object.defineProperty(String.prototype,"appendQuery",{enumerable:!1,configurable:!1,writable:!1,value:function(e){return this+(-1!==this.indexOf("?")?"&":"?")+e}}),vR.arrayEquals=function(e,t){if(!e)return!1;if(!t)return!1;if(e.length!==t.length)return!1;for(var n=0,a=e.length;n<a;n++)if(this[n]instanceof Array&&t[n]instanceof Array){if(!this[n].equals(t[n]))return!1}else if(this[n]!==t[n])return!1;return!0},fR=document.createElement("div"),gR=DOMTokenList.prototype,yR=gR.add,bR=gR.remove,fR.classList.add("class1","class2"),fR.classList.contains("class2")||(gR.add=function(){Array.prototype.forEach.call(arguments,yR.bind(this))},gR.remove=function(){Array.prototype.forEach.call(arguments,bR.bind(this))}),function(e){if(!e||!window)return;const t=document.createElement("style");t.setAttribute("type","text/css"),t.innerHTML=e,document.head.appendChild(t)}('@font-face {\n  font-family: "pc-icon";\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot");\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix") format("embedded-opentype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2") format("woff2"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff") format("woff"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf") format("truetype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg") format("svg");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon {\n  font-family: "pc-icon";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, "Ubuntu Mono", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect, .pcui-slider {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-slider {\n  display: inline-flex;\n  height: 24px;\n  margin: 6px;\n  align-items: center;\n}\n.pcui-slider > .pcui-numeric-input {\n  flex: 1;\n  margin-left: 0;\n}\n\n.pcui-slider-container {\n  flex: 3;\n}\n\n.pcui-slider-bar {\n  position: relative;\n  width: calc(100% - 18px);\n  height: 4px;\n  margin: 9px 8px;\n  background-color: #2c393c;\n  border: 1px solid #293538;\n}\n\n.pcui-slider-handle {\n  position: absolute;\n  top: -7px;\n  left: 0;\n  margin-left: -9px;\n  width: 8px;\n  height: 16px;\n  background-color: #5b7073;\n  border: 1px solid #293538;\n  transition: left 100ms ease;\n}\n.pcui-slider-handle:hover, .pcui-slider-handle:focus {\n  outline: none;\n}\n\n.pcui-slider-active {\n  cursor: ew-resize;\n}\n.pcui-slider-active .pcui-slider-bar {\n  border-color: #20292b;\n  background-color: #20292b;\n}\n.pcui-slider-active .pcui-slider-handle {\n  border-color: #20292b;\n  background-color: #ffffff;\n  transition: none;\n}\n\n.pcui-slider:not(.pcui-disabled):not(.pcui-readonly):hover {\n  cursor: pointer;\n}\n.pcui-slider:not(.pcui-disabled):not(.pcui-readonly) .pcui-slider-handle:focus, .pcui-slider:not(.pcui-disabled):not(.pcui-readonly) .pcui-slider-handle:hover {\n  cursor: ew-resize;\n  outline: none;\n  border-color: #20292b;\n  background-color: #ffffff;\n}\n\n.pcui-slider.pcui-readonly .pcui-numeric-input {\n  flex: 1;\n}\n.pcui-slider.pcui-readonly .pcui-slider-bar {\n  display: none;\n}\n\n.pcui-slider.pcui-multiple-values .pcui-slider-handle {\n  display: none;\n}');const _R=/Chrome\//.test(navigator.userAgent),wR=["allowNull","max","min","keyChange","placeholder","precision","renderChanges","step"];class xR extends xh{constructor(e){e=Object.assign({},e);const t={};wR.forEach((n=>{t[n]=e[n]})),void 0===t.precision&&(t.precision=2),delete t.binding,super(e.dom?e.dom:document.createElement("div"),e),e.pre&&(this.precision=e.pre),this.class.add("pcui-slider"),this._historyCombine=!1,this._historyPostfix=null,this._numericInput=new mR({...t,hideSlider:!0}),this._numericInput.on("change",this._onValueChange.bind(this)),this._numericInput.on("focus",(()=>{this.emit("focus")})),this._numericInput.on("blur",(()=>{this.emit("blur")})),this._sliderMin=void 0!==e.sliderMin?e.sliderMin:this.min||0,this._sliderMax=void 0!==e.sliderMax?e.sliderMax:this.max||1,this.dom.appendChild(this._numericInput.dom),this._numericInput.parent=this,this._domSlider=document.createElement("div"),this._domSlider.classList.add("pcui-slider-container"),this.dom.appendChild(this._domSlider),this._domBar=document.createElement("div"),this._domBar.classList.add("pcui-slider-bar"),this._domBar.ui=this,this._domSlider.appendChild(this._domBar),this._domHandle=document.createElement("div"),this._domHandle.ui=this,this._domHandle.tabIndex=0,this._domHandle.classList.add("pcui-slider-handle"),this._domBar.appendChild(this._domHandle),this._cursorHandleOffset=0,this._domMouseDown=this._onMouseDown.bind(this),this._domMouseMove=this._onMouseMove.bind(this),this._domMouseUp=this._onMouseUp.bind(this),this._domTouchStart=this._onTouchStart.bind(this),this._domTouchMove=this._onTouchMove.bind(this),this._domTouchEnd=this._onTouchEnd.bind(this),this._domKeyDown=this._onKeyDown.bind(this),this._touchId=null,this._domSlider.addEventListener("mousedown",this._domMouseDown),this._domSlider.addEventListener("touchstart",this._domTouchStart,{passive:!0}),this._domHandle.addEventListener("keydown",this._domKeyDown),void 0!==e.value&&(this.value=e.value),0===this.value&&this._updateHandle(0)}_onMouseDown(e){0===e.button&&this.enabled&&!this.readOnly&&this._onSlideStart(e.pageX)}_onMouseMove(e){e.stopPropagation(),e.preventDefault(),this._onSlideMove(e.pageX)}_onMouseUp(e){e.stopPropagation(),e.preventDefault(),this._onSlideEnd(e.pageX)}_onTouchStart(e){if(this.enabled&&!this.readOnly)for(let t=0;t<e.changedTouches.length;t++){const n=e.changedTouches[t];if(n.target.ui&&n.target.ui===this){this._touchId=n.identifier,this._onSlideStart(n.pageX);break}}}_onTouchMove(e){for(let t=0;t<e.changedTouches.length;t++){const n=e.changedTouches[t];if(n.identifier===this._touchId){e.stopPropagation(),e.preventDefault(),this._onSlideMove(n.pageX);break}}}_onTouchEnd(e){for(let t=0;t<e.changedTouches.length;t++){const n=e.changedTouches[t];if(n.identifier===this._touchId){e.stopPropagation(),e.preventDefault(),this._onSlideEnd(n.pageX),this._touchId=null;break}}}_onKeyDown(e){if(27===e.keyCode)return void this.blur();if(!this.enabled||this.readOnly)return;if(37!==e.keyCode&&39!==e.keyCode)return;e.stopPropagation(),e.preventDefault();let t=37===e.keyCode?-1:1;e.shiftKey&&(t*=10),this.value+=t*this.step}_updateHandle(e){const t=100*Math.max(0,Math.min(1,((e||0)-this._sliderMin)/(this._sliderMax-this._sliderMin))),n=this._domHandle.getBoundingClientRect().width;this._domHandle.style.left=`calc(${t}% + ${n/2}px)`}_onValueChange(e){this._updateHandle(e),this.emit("change",e),this._binding&&this._binding.setValue(e)}_calculateCursorHandleOffset(e){const t=_R?2:0,n=this._domHandle.getBoundingClientRect(),a=n.left-t,i=n.right;return this._cursorHandleOffset=e>=a&&e<=i?e-(a+(i-a)/2):0,this._cursorHandleOffset}_onSlideStart(e){this._domHandle.focus(),null===this._touchId?(window.addEventListener("mousemove",this._domMouseMove),window.addEventListener("mouseup",this._domMouseUp)):(window.addEventListener("touchmove",this._domTouchMove),window.addEventListener("touchend",this._domTouchEnd)),this.class.add("pcui-slider-active"),this._calculateCursorHandleOffset(e)||this._onSlideMove(e),this.binding&&(this._historyCombine=this.binding.historyCombine,this._historyPostfix=this.binding.historyPostfix,this.binding.historyCombine=!0,this.binding.historyPostfix=`(${Date.now()})`)}_onSlideMove(e){const t=this._domBar.getBoundingClientRect();e-=this._cursorHandleOffset;let n=Math.max(0,Math.min(1,(e-t.left)/t.width))*(this._sliderMax-this._sliderMin)+this._sliderMin;n=parseFloat(n.toFixed(this.precision),10),this.value=n}_onSlideEnd(e){this._calculateCursorHandleOffset(e)||this._onSlideMove(e),this.class.remove("pcui-slider-active"),null===this._touchId?(window.removeEventListener("mousemove",this._domMouseMove),window.removeEventListener("mouseup",this._domMouseUp)):(window.removeEventListener("touchmove",this._domTouchMove),window.removeEventListener("touchend",this._domTouchEnd)),this.binding&&(this.binding.historyCombine=this._historyCombine,this.binding.historyPostfix=this._historyPostfix,this._historyCombine=!1,this._historyPostfix=null)}focus(){this._numericInput.focus()}blur(){this._domHandle.blur(),this._numericInput.blur()}destroy(){this._destroyed||(this._domSlider.removeEventListener("mousedown",this._domMouseDown),this._domSlider.removeEventListener("touchstart",this._domTouchStart),this._domHandle.removeEventListener("keydown",this._domKeyDown),this.dom.removeEventListener("mouseup",this._domMouseUp),this.dom.removeEventListener("mousemove",this._domMouseMove),this.dom.removeEventListener("touchmove",this._domTouchMove),this.dom.removeEventListener("touchend",this._domTouchEnd),super.destroy())}get sliderMin(){return this._sliderMin}set sliderMin(e){this._sliderMin!==e&&(this._sliderMin=e,this._updateHandle(this.value))}get sliderMax(){return this._sliderMax}set sliderMax(e){this._sliderMax!==e&&(this._sliderMax=e,this._updateHandle(this.value))}get value(){return this._numericInput.value}set value(e){this._numericInput.value=e,this._numericInput.class.contains(gh)?this.class.add(gh):this.class.remove(gh)}set values(e){this._numericInput.values=e,this._numericInput.class.contains(gh)?this.class.add(gh):this.class.remove(gh)}}vR.proxy(xR,"_numericInput",wR),xh.register("slider",xR,{renderChanges:!0});var CR=function(e){oh(n,Sh);var t=ph(n);function n(e){var a;return ah(this,n),(a=t.call(this,e)).elementClass=xR,a}return sh(n,[{key:"render",value:function(){return uh(lh(n.prototype),"render",this).call(this)}}]),n}();CR.propTypes={},CR.ctor=xR,CR.defaultProps={};var TR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"model",type:"container",url:"/static/assets/models/bitmoji.glb"}),N.createElement(dR,{name:"idleAnim",type:"container",url:"/static/assets/animations/bitmoji/idle.glb"}),N.createElement(dR,{name:"danceAnim",type:"container",url:"/static/assets/animations/bitmoji/win-dance.glb"}),N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}),N.createElement(dR,{name:"bloom",type:"script",url:"/static/scripts/posteffects/posteffect-bloom.js"}))},e.prototype.controls=function(e){return N.createElement(N.Fragment,null,N.createElement(Dp,{text:"blend"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"blend"}})))},e.prototype.example=function(e,t,n){var a=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});a.scene.exposure=2,a.scene.skyboxMip=2,a.scene.setSkybox(t["helipad.dds"].resources);var i=new KM;i.addComponent("camera",{clearColor:new Mu(.1,.1,.1)}),i.translate(0,.75,3),i.addComponent("script"),i.script.create("bloom",{attributes:{bloomIntensity:1,bloomThreshold:.7,blurAmount:4}}),a.root.addChild(i);var s=new KM;s.addComponent("light",{castShadows:!0,intensity:1.5,normalOffsetBias:.02,shadowType:4,shadowDistance:6,shadowResolution:2048,shadowBias:.02}),a.root.addChild(s),s.setLocalEulerAngles(45,30,0);var r=t.model.resource.instantiateRenderEntity({castShadows:!0});r.addComponent("anim",{activate:!0});r.anim.loadStateGraph({layers:[{name:"characterState",states:[{name:"START"},{name:"Movement",speed:1,loop:!0,blendTree:{type:"1D",parameter:"blend",children:[{name:"Idle",point:0},{name:"Dance",point:1,speed:.85}]}}],transitions:[{from:"START",to:"Movement"}]}],parameters:{blend:{name:"blend",type:"FLOAT",value:0}}});var o=r.anim.baseLayer;o.assignAnimation("Movement.Idle",t.idleAnim.resource.animations[0].resource),o.assignAnimation("Movement.Dance",t.danceAnim.resource.animations[0].resource),a.root.addChild(r),a.start(),n.on("blend:set",(function(e){r.anim.setFloat("blend",e)}))},e.CATEGORY="Animation",e.NAME="Blend Trees 1D",e}(),ER=function(){function t(){}return t.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"model",type:"container",url:"/static/assets/models/bitmoji.glb"}),N.createElement(dR,{name:"idleAnim",type:"container",url:"/static/assets/animations/bitmoji/idle.glb"}),N.createElement(dR,{name:"eagerAnim",type:"container",url:"/static/assets/animations/bitmoji/idle-eager.glb"}),N.createElement(dR,{name:"walkAnim",type:"container",url:"/static/assets/animations/bitmoji/walk.glb"}),N.createElement(dR,{name:"danceAnim",type:"container",url:"/static/assets/animations/bitmoji/win-dance.glb"}),N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}),N.createElement(dR,{name:"bloom",type:"script",url:"/static/scripts/posteffects/posteffect-bloom.js"}))},t.prototype.controls=function(){return e.exports.useEffect((function(){if(document.getElementById("exampleIframe").contentWindow.pc){var e=document.getElementById("2d-blend-control"),t=document.getElementById("exampleIframe").contentWindow.pc.app.root.findByName("model"),n=window.controlPanel.offsetWidth,a=n,i=Math.floor(n/2),s=Math.floor(a/2);e.setAttribute("style","width: "+n+"px; height: "+a+"px;"),e.setAttribute("width",n),e.setAttribute("height",a);var r=e.getContext("2d"),o=new Du(0),l=function(e){e.clearRect(0,0,n,a),e.fillStyle="rgba(128, 128, 128, 0.5)",e.fillRect(0,0,n,a),e.fillStyle="#B1B8BA",e.fillRect(i,0,1,a),e.fillRect(0,s,n,1),e.fillStyle="#232e30",t.anim.baseLayer._controller.activeState.animations.forEach((function(t){if(t.point){var n=(t.point.x+1)*i,a=(-1*t.point.y+1)*s;e.fillStyle="#ffffff80",e.beginPath(),e.arc(n,a,.5*i*t.weight,0,2*Math.PI),e.fill(),e.fillStyle="#283538",e.beginPath(),e.moveTo(n,a-4),e.lineTo(n-4,a),e.lineTo(n,a+4),e.lineTo(n+4,a),e.closePath(),e.fill()}})),e.fillStyle="#F60",e.beginPath(),e.arc((t.anim.getFloat("posX")+1)*i,(-1*t.anim.getFloat("posY")+1)*s,5,0,2*Math.PI),e.fill(),e.fillStyle="#283538",e.stroke()};l(r);var c=function(a){if(a.targetTouches){var i=e.getBoundingClientRect();o=new Du(a.targetTouches[0].clientX-i.x,a.targetTouches[0].clientY-i.y).mulScalar(1/(n/2)).sub(Du.ONE)}else{if(!a.buttons)return;o=new Du(a.offsetX,a.offsetY).mulScalar(1/(n/2)).sub(Du.ONE)}o.y*=-1,t.anim.setFloat("posX",o.x),t.anim.setFloat("posY",o.y),l(r)};e.addEventListener("mousemove",c),e.addEventListener("mousedown",c),e.addEventListener("touchmove",c),e.addEventListener("touchstart",c)}})),N.createElement(N.Fragment,null,N.createElement("canvas",{id:"2d-blend-control"}))},t.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.scene.exposure=2,n.scene.skyboxMip=2,n.scene.setSkybox(t["helipad.dds"].resources);var a=new KM;a.addComponent("camera",{clearColor:new Mu(.1,.1,.1)}),a.translate(0,.75,3),a.addComponent("script"),a.script.create("bloom",{attributes:{bloomIntensity:1,bloomThreshold:.7,blurAmount:4}}),n.root.addChild(a);var i=new KM;i.addComponent("light",{castShadows:!0,intensity:1.5,normalOffsetBias:.02,shadowType:4,shadowDistance:6,shadowResolution:2048,shadowBias:.02}),n.root.addChild(i),i.setLocalEulerAngles(45,30,0);var s=t.model.resource.instantiateRenderEntity({castShadows:!0});s.name="model",s.addComponent("anim",{activate:!0});var r={layers:[{name:"base",states:[{name:"START"},{name:"Emote",speed:1,loop:!0,blendTree:{type:"2D_CARTESIAN",parameters:["posX","posY"],children:[{name:"Idle",point:[-.5,.5]},{name:"Eager",point:[.5,.5]},{name:"Walk",point:[.5,-.5]},{name:"Dance",point:[-.5,-.5]}]}}],transitions:[{from:"START",to:"Emote"}]}],parameters:{posX:{name:"posX",type:"FLOAT",value:-.5},posY:{name:"posY",type:"FLOAT",value:.5}}};s.anim.loadStateGraph(r);var o=s.anim.baseLayer;o.assignAnimation("Emote.Idle",t.idleAnim.resource.animations[0].resource),o.assignAnimation("Emote.Eager",t.eagerAnim.resource.animations[0].resource),o.assignAnimation("Emote.Dance",t.danceAnim.resource.animations[0].resource),o.assignAnimation("Emote.Walk",t.walkAnim.resource.animations[0].resource),n.root.addChild(s),n.start()},t.CATEGORY="Animation",t.NAME="Blend Trees 2D Cartesian",t}(),SR=function(){function t(){}return t.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"model",type:"container",url:"/static/assets/models/bitmoji.glb"}),N.createElement(dR,{name:"idleAnim",type:"container",url:"/static/assets/animations/bitmoji/idle.glb"}),N.createElement(dR,{name:"walkAnim",type:"container",url:"/static/assets/animations/bitmoji/walk.glb"}),N.createElement(dR,{name:"jogAnim",type:"container",url:"/static/assets/animations/bitmoji/run.glb"}),N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}),N.createElement(dR,{name:"bloom",type:"script",url:"/static/scripts/posteffects/posteffect-bloom.js"}))},t.prototype.controls=function(){return e.exports.useEffect((function(){if(document.getElementById("exampleIframe").contentWindow.pc){var e=document.getElementById("2d-blend-control"),t=document.getElementById("exampleIframe").contentWindow.pc.app.root.findByName("model"),n=window.controlPanel.offsetWidth,a=n,i=Math.floor(n/2),s=Math.floor(a/2);e.setAttribute("style","width: "+n+"px; height: "+a+"px;"),e.setAttribute("width",n),e.setAttribute("height",a);var r=e.getContext("2d"),o=new Du(0),l=function(e){e.clearRect(0,0,n,a),e.fillStyle="rgba(128, 128, 128, 0.5)",e.fillRect(0,0,n,a),e.fillStyle="#B1B8BA",e.fillRect(i,0,1,a),e.fillRect(0,s,n,1),e.fillStyle="#232e30",t.anim.baseLayer._controller.activeState.animations.forEach((function(t){if(t.point){var n=(t.point.x+1)*i,a=(-1*t.point.y+1)*s;e.fillStyle="#ffffff80",e.beginPath(),e.arc(n,a,.5*i*t.weight,0,2*Math.PI),e.fill(),e.fillStyle="#283538",e.beginPath(),e.moveTo(n,a-4),e.lineTo(n-4,a),e.lineTo(n,a+4),e.lineTo(n+4,a),e.closePath(),e.fill()}})),e.fillStyle="#F60",e.beginPath(),e.arc((t.anim.getFloat("posX")+1)*i,(-1*t.anim.getFloat("posY")+1)*s,5,0,2*Math.PI),e.fill(),e.fillStyle="#283538",e.stroke()};l(r);var c=function(e){e.buttons&&((o=new Du(e.offsetX,e.offsetY).mulScalar(1/(n/2)).sub(Du.ONE)).y*=-1,t.anim.setFloat("posX",o.x),t.anim.setFloat("posY",o.y),l(r))};e.addEventListener("mousemove",c),e.addEventListener("mousedown",c)}})),N.createElement(N.Fragment,null,N.createElement("canvas",{id:"2d-blend-control"}))},t.prototype.example=function(e,t,n){var a=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});a.scene.exposure=2,a.scene.skyboxMip=2,a.scene.setSkybox(t["helipad.dds"].resources);var i=new KM;i.addComponent("camera",{clearColor:new Mu(.1,.1,.1)}),i.translate(0,.75,3),i.addComponent("script"),i.script.create("bloom",{attributes:{bloomIntensity:1,bloomThreshold:.7,blurAmount:4}}),a.root.addChild(i);var s=new KM;s.addComponent("light",{castShadows:!0,intensity:1.5,normalOffsetBias:.02,shadowType:4,shadowDistance:6,shadowResolution:2048,shadowBias:.02}),a.root.addChild(s),s.setLocalEulerAngles(45,30,0);var r=t.model.resource.instantiateRenderEntity({castShadows:!0});r.name="model",r.addComponent("anim",{activate:!0});var o={layers:[{name:"locomotion",states:[{name:"START"},{name:"Travel",speed:1,loop:!0,blendTree:{type:"2D_DIRECTIONAL",syncDurations:!0,parameters:["posX","posY"],children:[{name:"Idle",point:[0,0]},{speed:-1,name:"WalkBackwards",point:[0,-.5]},{speed:1,name:"Walk",point:[0,.5]},{speed:1,name:"Jog",point:[0,1]}]}}],transitions:[{from:"START",to:"Travel"}]}],parameters:{posX:{name:"posX",type:"FLOAT",value:0},posY:{name:"posY",type:"FLOAT",value:0}}};r.anim.loadStateGraph(o);var l=r.anim.baseLayer;l.assignAnimation("Travel.Idle",t.idleAnim.resource.animations[0].resource),l.assignAnimation("Travel.Walk",t.walkAnim.resource.animations[0].resource),l.assignAnimation("Travel.WalkBackwards",t.walkAnim.resource.animations[0].resource),l.assignAnimation("Travel.Jog",t.jogAnim.resource.animations[0].resource),a.root.addChild(r),a.start()},t.CATEGORY="Animation",t.NAME="Blend Trees 2D Directional",t}(),AR=function(e){oh(n,Sh);var t=ph(n);function n(e){var a;return ah(this,n),(a=t.call(this,e)).elementClass=Ap,a}return sh(n,[{key:"render",value:function(){return N.createElement("button",{ref:this.attachElement})}}]),n}();AR.ctor=Ap;var MR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"playcanvasGreyTexture",type:"texture",url:"/static/assets/textures/playcanvas-grey.png"}))},e.prototype.controls=function(e){return N.createElement(N.Fragment,null,N.createElement(AR,{text:"Flash",onClick:function(){e.set("flash",!e.get("flash"))}}))},e.prototype.example=function(e,t,n){var a=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)}),i=new K_,s=i.open(void 0,{name:"staticLight",duration:1,inputs:[[0]],outputs:[{components:4,data:[0,1,0,1]},{components:4,data:[0,0,0,0]}],curves:[{path:{entityPath:["lights","spotLight1"],component:"light",propertyPath:["color"]},inputIndex:0,outputIndex:0,interpolation:1},{path:{entityPath:["lights","spotLight2"],component:"light",propertyPath:["color"]},inputIndex:0,outputIndex:0,interpolation:1},{path:{entityPath:["lights","spotLight1"],component:"entity",propertyPath:["localEulerAngles"]},inputIndex:0,outputIndex:1,interpolation:1},{path:{entityPath:["lights","spotLight2"],component:"entity",propertyPath:["localEulerAngles"]},inputIndex:0,outputIndex:1,interpolation:1}]}),r=i.open(void 0,{name:"flashingLight",duration:2,inputs:[[0,.5,1,1.5,2],[0,1,2]],outputs:[{components:4,data:[1,0,0,1,.4,0,0,1,1,0,0,1,.4,0,0,1,1,0,0,1]},{components:4,data:[4,0,0,0,4,180,0,0,4,0,0,0]},{components:4,data:[-4,0,0,0,-4,180,0,0,-4,0,0,0]}],curves:[{path:{entityPath:["lights","spotLight1"],component:"light",propertyPath:["color"]},inputIndex:0,outputIndex:0,interpolation:1},{path:{entityPath:["lights","spotLight2"],component:"light",propertyPath:["color"]},inputIndex:0,outputIndex:0,interpolation:1},{path:{entityPath:["lights","spotLight1"],component:"entity",propertyPath:["localEulerAngles"]},inputIndex:1,outputIndex:1,interpolation:1},{path:{entityPath:["lights","spotLight2"],component:"entity",propertyPath:["localEulerAngles"]},inputIndex:1,outputIndex:2,interpolation:1}]}),o=new KM;o.name="camera",o.addComponent("camera",{clearColor:new Mu(0,0,0)}),o.translateLocal(7,10,7),o.lookAt(0,0,0);var l=new KM;l.addComponent("render",{type:"box"}),l.name="model",l.setPosition(0,.25,0),l.setLocalScale(.5,.5,.5);var c=new cg;c.diffuseMap=t.playcanvasGreyTexture.resource,c.update(),l.render.meshInstances[0].material=c;var h=new KM;h.name="plane",h.addComponent("render",{type:"plane"}),h.setLocalScale(15,1,15),h.setPosition(0,0,0);var d=new KM;d.name="lights";var p=new KM;p.name="spotLight1",p.addComponent("light",{type:"spot",color:new Mu(0,0,0,1),intensity:1,range:15,innerConeAngle:5,outerConeAngle:10}),p.setPosition(0,10,0);var u=new KM;u.name="spotLight2",u.addComponent("light",{type:"spot",color:new Mu(0,0,0,1),intensity:1,range:15,innerConeAngle:5,outerConeAngle:10}),u.setPosition(0,10,0),a.root.addChild(o),d.addChild(p),d.addChild(u),a.root.addChild(d),a.root.addChild(l),a.root.addChild(h),d.addComponent("anim",{speed:1,activate:!0}),d.anim.assignAnimation("Static",s),d.anim.assignAnimation("Flash",r),a.start(),n.on("flash:set",(function(){"Static"===d.anim.baseLayer.activeState?d.anim.baseLayer.transition("Flash",.5):d.anim.baseLayer.transition("Static",.5)}))},e.CATEGORY="Animation",e.NAME="Component Properties",e}(),LR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"model",type:"container",url:"/static/assets/models/bitmoji.glb"}),N.createElement(dR,{name:"walkAnim",type:"container",url:"/static/assets/animations/bitmoji/walk.glb"}),N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}),N.createElement(dR,{name:"bloom",type:"script",url:"/static/scripts/posteffects/posteffect-bloom.js"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body)});n.scene.exposure=2,n.start(),n.scene.skyboxMip=2,n.scene.setSkybox(t["helipad.dds"].resources),n.scene.skyboxIntensity=.4;var a=new KM;a.addComponent("camera",{clearColor:new Mu(.1,.1,.1)}),a.translate(0,1,0),a.addComponent("script"),a.script.create("bloom",{attributes:{bloomIntensity:1,bloomThreshold:.7,blurAmount:4}}),n.root.addChild(a);for(var i={},s=[],r=-5;r<=5;r++)for(var o=-5;o<=5;o++){var l=new KM;i["".concat(r).concat(o)]=l,l.addComponent("model",{type:"box"}),l.setPosition(r,-.5,o),l.setLocalScale(.95,1,.95);var c=new cg;c.diffuse=new Mu(.7,.7,.7),c.shininess=30,c.metalness=.2,c.useMetalness=!0,l.model.material=c,c.update(),n.root.addChild(l)}var h=t.model.resource.instantiateRenderEntity({castShadows:!0});h.addComponent("anim",{activate:!0}),h.setLocalPosition(-3,0,0);var d=new KM;d.addChild(h),n.root.addChild(d),n.on("update",(function(e){d.rotate(0,13.8*e,0)}));var p=t.walkAnim.resource.animations[0].resource;p.events=new t_([{time:.1*p.duration,name:"foot_step",bone:"R_foot0002_bind_JNT"},{time:.6*p.duration,name:"foot_step",bone:"L_foot0002_bind_JNT"}]),h.anim.assignAnimation("Walk",p,void 0,.62),h.anim.on("foot_step",(function(e){!function(e){var t=Math.floor(e.x+.5),n=Math.floor(e.z+.5),a=new Pu(Math.random(),Math.random(),Math.random());a.mulScalar(1/a.length()),i["".concat(t).concat(n)].model.material.emissive=new Mu(a.x,a.y,a.z),s.push(i["".concat(t).concat(n)])}(h.findByName(e.bone).getPosition())})),n.on("update",(function(e){for(s.forEach((function(e){var t=e.model.material,n=t.emissive;n.lerp(n,Mu.BLACK,.08),t.update()}));s.length>5;)s.shift();var t=h.getPosition().clone();t.y=.5,a.lookAt(t)}))},e.CATEGORY="Animation",e.NAME="Events",e}();const RR=function(e,t){if(0===e.length)return t.length;if(0===t.length)return e.length;if(e===t)return 0;var n,a,i=[];for(n=0;n<=t.length;n++)i[n]=[n];for(a=0;a<=e.length;a++)i[0][a]=a;for(n=1;n<=t.length;n++)for(a=1;a<=e.length;a++)t.charAt(n-1)===e.charAt(a-1)?i[n][a]=i[n-1][a-1]:i[n][a]=Math.min(i[n-1][a-1]+1,Math.min(i[n][a-1]+1,i[n-1][a]+1));return i[t.length][e.length]},IR=function(e,t){if(e===t)return e.length;var n,a=0,i={};for(n=0;n<t.length;n++)i[t.charAt(n)]=!0;for(n=0;n<e.length;n++)i[e.charAt(n)]&&a++;return a},PR=function(e){for(var t=[],n=e.replace(/([^A-Z])([A-Z][^A-Z])/g,"$1 $2").replace(/([A-Z0-9]{2,})/g," $1").split(/(\s|\-|_)/g),a=0;a<n.length;a++)n[a]=n[a].toLowerCase().trim(),n[a]&&"-"!==n[a]&&"_"!==n[a]&&t.push(n[a]);return t},kR=function(e,t,n){for(var a=[],i=0;i<e.length;i++){var s=e[i];if(s.subFull===1/0)if(s.name!==t&&0!==s.name.indexOf(t)){if(!(IR(t,s.name)/t.length<n.containsCharsTolerance)){for(var r=1/0,o=1/0,l=0;l<s.tokens.length;l++){if(s.tokens[l]===t){r=0,o=l;break}var c=RR(t,s.tokens[l]);(o===1/0||c<r)&&-1!==s.tokens[l].indexOf(t)?(o=l,r=c):o===1/0&&c<r&&c/Math.max(t.length,s.tokens[l].length)<=n.editsDistanceTolerance&&(r=c)}r!==1/0&&(a.push(s),s.edits=s.edits===1/0?r:s.edits+r,s.sub=s.sub===1/0?o:s.sub+o)}}else a.push(s),s.edits===1/0&&(s.edits=0),s.sub===1/0&&(s.sub=0);else a.push(s),s.edits===1/0&&(s.edits=0),s.sub===1/0&&(s.sub=s.subFull)}return a};!function(e){if(!e||!window)return;const t=document.createElement("style");t.setAttribute("type","text/css"),t.innerHTML=e,document.head.appendChild(t)}('@font-face {\n  font-family: "pc-icon";\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot");\n  src: url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix") format("embedded-opentype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2") format("woff2"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff") format("woff"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf") format("truetype"), url("https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg") format("svg");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon, .pcui-select-input-create-new > .pcui-label:last-child:before, .pcui-select-input-list .pcui-label.pcui-selected:after, .pcui-select-input-icon:after {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon, .pcui-select-input-create-new > .pcui-label:last-child:before, .pcui-select-input-list .pcui-label.pcui-selected:after, .pcui-select-input-icon:after {\n  font-family: "pc-icon";\n}\n\n.fixedFont, .pcui-select-input-tag > .pcui-label, .pcui-select-input-list .pcui-label, .pcui-select-input-value {\n  font-family: inconsolatamedium, Monaco, Menlo, "Ubuntu Mono", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex, .pcui-select-input-container-value, .pcui-select-input {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden), .pcui-select-input-container-value:not(.pcui-hidden), .pcui-select-input:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-select-input {\n  box-sizing: border-box;\n  margin: 6px;\n  border-radius: 2px;\n  min-width: 0;\n}\n\n.pcui-select-input-container-value {\n  background-color: #2c393c;\n  transition: box-shadow 100ms, opacity 100ms;\n}\n\n.pcui-select-input-shadow {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  transition: box-shadow 100ms;\n  border-radius: 2px;\n  pointer-events: none;\n  z-index: 1;\n}\n\n.pcui-select-input-value {\n  margin: 0;\n  padding: 0 24px 0 8px;\n  height: 24px;\n  line-height: 24px;\n  font-size: 12px;\n  transition: background-color 100ms, color 100ms;\n}\n.pcui-select-input-value:not(.pcui-hidden) {\n  display: block;\n}\n\n.pcui-select-input-textinput {\n  margin: 0;\n}\n\n.pcui-select-input-textinput:not(.pcui-disabled):not(.pcui-readonly):not(.pcui-error).pcui-focus, .pcui-select-input-textinput:not(.pcui-disabled):not(.pcui-readonly):not(.pcui-error):hover {\n  box-shadow: none;\n}\n\n.pcui-select-input-icon {\n  position: absolute;\n  right: 6px;\n  color: #5b7073;\n  pointer-events: none;\n  transition: color 100ms;\n  margin: 0;\n  height: 24px;\n  line-height: 24px;\n}\n.pcui-select-input-icon:after {\n  content: "\\e159";\n  vertical-align: middle;\n}\n\n.pcui-select-input.pcui-open .pcui-select-input-shadow {\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-select-input.pcui-open .pcui-select-input-value {\n  color: #ffffff;\n  background-color: #20292b;\n}\n.pcui-select-input.pcui-open .pcui-select-input-icon:after {\n  color: #ffffff;\n  content: "\\e157";\n}\n\n.pcui-select-input-list {\n  position: absolute;\n  z-index: 1;\n  top: 100%;\n  width: 100%;\n  max-height: 200px;\n  overflow-y: auto;\n  background-color: #293538;\n}\n.pcui-select-input-list .pcui-label {\n  font-size: 12px;\n  height: 22px;\n  line-height: 22px;\n  padding: 0 24px 0 6px;\n  margin: 0;\n  transition: background-color 100ms, color 100ms;\n}\n.pcui-select-input-list .pcui-label:not(.pcui-hidden) {\n  display: block;\n}\n.pcui-select-input-list .pcui-label.pcui-selected {\n  color: #ffffff;\n}\n.pcui-select-input-list .pcui-label.pcui-selected:after {\n  content: "\\e133";\n  color: #5b7073;\n  position: absolute;\n  right: 6px;\n}\n\n.pcui-select-input-fit-height .pcui-select-input-list {\n  top: initial;\n  bottom: 100%;\n}\n.pcui-select-input-fit-height .pcui-select-input-shadow {\n  top: initial;\n  bottom: 0;\n}\n\n.pcui-select-input-tags:not(.pcui-select-input-tags-empty) {\n  margin-top: 1px;\n  flex-wrap: wrap;\n}\n\n.pcui-select-input-tag {\n  background-color: #293538;\n  align-items: center;\n  border-radius: 2px;\n  border: 1px solid #232e30;\n  margin-right: 2px;\n  margin-top: 2px;\n  min-width: 0;\n  height: 18px;\n}\n.pcui-select-input-tag > * {\n  margin: 0;\n  background-color: transparent;\n  border: 0;\n}\n.pcui-select-input-tag > .pcui-label {\n  padding: 0 5px 0 8px;\n}\n.pcui-select-input-tag > .pcui-button {\n  padding: 0 5px;\n  height: 18px;\n  line-height: 18px;\n  flex-shrink: 0;\n}\n.pcui-select-input-tag > .pcui-button:not(.pcui-disabled):not(.pcui-readonly):hover {\n  box-shadow: none;\n  color: #d34141;\n}\n\n.pcui-select-input-tag-not-everywhere > .pcui-label {\n  opacity: 0.5;\n}\n.pcui-select-input-tag-not-everywhere > .pcui-label:before {\n  content: "*";\n  margin-right: 5px;\n}\n\n.pcui-select-input:not(.pcui-disabled):not(.pcui-readonly) .pcui-select-input-container-value:hover .pcui-select-input-shadow {\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-select-input:not(.pcui-disabled):not(.pcui-readonly) .pcui-select-input-container-value:hover .pcui-select-input-icon {\n  color: #9ba1a3;\n}\n.pcui-select-input:not(.pcui-disabled):not(.pcui-readonly).pcui-focus .pcui-select-input-shadow {\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-select-input:not(.pcui-disabled):not(.pcui-readonly).pcui-focus .pcui-select-input-icon {\n  color: #9ba1a3;\n}\n.pcui-select-input:not(.pcui-disabled):not(.pcui-readonly) .pcui-select-input-value:hover {\n  color: #ffffff;\n  background-color: #20292b;\n  cursor: pointer;\n}\n.pcui-select-input:not(.pcui-disabled):not(.pcui-readonly) .pcui-select-input-list > *:hover, .pcui-select-input:not(.pcui-disabled):not(.pcui-readonly) .pcui-select-input-list > .pcui-select-input-label-highlighted {\n  background-color: #20292b;\n  color: #ffffff;\n  cursor: pointer;\n}\n\n.pcui-select-input-create-new > .pcui-label {\n  padding-right: 6px;\n}\n.pcui-select-input-create-new > .pcui-label:last-child {\n  flex-shrink: 0;\n  margin-left: auto;\n}\n.pcui-select-input-create-new > .pcui-label:last-child:before {\n  content: "\\e120";\n  margin-right: 6px;\n}\n\n.pcui-select-input.pcui-disabled {\n  opacity: 0.4;\n}\n\n.pcui-select-input.pcui-readonly .pcui-select-input-icon {\n  display: none;\n}\n.pcui-select-input.pcui-readonly.pcui-select-input-multi .pcui-select-input-container-value {\n  display: none;\n}\n.pcui-select-input.pcui-readonly.pcui-select-input-multi .pcui-select-input-tag > .pcui-button {\n  display: none;\n}\n.pcui-select-input.pcui-readonly.pcui-select-input-allow-input:not(.pcui-select-input-multi) {\n  opacity: 0.7;\n}\n.pcui-select-input.pcui-readonly.pcui-select-input-allow-input:not(.pcui-select-input-multi) .pcui-select-input-textinput:after {\n  display: none;\n}');class DR extends xh{constructor(e){e||(e={});const t=new Eh({dom:e.dom});super(t.dom,e),this._container=t,this._container.parent=this,this.class.add("pcui-select-input"),this._containerValue=new Eh({class:"pcui-select-input-container-value"}),this._container.append(this._containerValue),this._domShadow=document.createElement("div"),this._domShadow.classList.add("pcui-select-input-shadow"),this._containerValue.append(this._domShadow),this._allowInput=e.allowInput||!1,this._allowInput&&this.class.add("pcui-select-input-allow-input"),this._allowCreate=e.allowCreate||!1,this._createFn=e.createFn,this._createLabelText=e.createLabelText||null,this._labelValue=new Sp({class:"pcui-select-input-value",tabIndex:0}),this._labelValue.on("click",this._onValueClick.bind(this)),this._containerValue.append(this._labelValue),this._timeoutLabelValueTabIndex=null,this._labelIcon=new Sp({class:"pcui-select-input-icon",hidden:e.allowInput&&e.multiSelect}),this._containerValue.append(this._labelIcon),this._input=new Rp({class:"pcui-select-input-textinput",blurOnEnter:!1,keyChange:!0}),this._containerValue.append(this._input),this._lastInputValue="",this._suspendInputChange=!1,this._input.on("change",this._onInputChange.bind(this)),this._input.on("keydown",this._onInputKeyDown.bind(this)),this._input.on("focus",this._onFocus.bind(this)),this._input.on("blur",this._onBlur.bind(this)),e.placeholder&&(this.placeholder=e.placeholder),this._containerOptions=new Eh({class:"pcui-select-input-list",hidden:!0}),this._containerValue.append(this._containerOptions),this._containerTags=new Eh({class:"pcui-select-input-tags",flex:!0,flexDirection:"row",hidden:!0}),this._container.append(this._containerTags),e.multiSelect&&(this.class.add("pcui-select-input-multi"),this._containerTags.hidden=!1),this._domEvtKeyDown=this._onKeyDown.bind(this),this._domEvtFocus=this._onFocus.bind(this),this._domEvtBlur=this._onBlur.bind(this),this._domEvtMouseDown=this._onMouseDown.bind(this),this._domEvtWindowMouseDown=this._onWindowMouseDown.bind(this),this._domEvtWheel=this._onWheel.bind(this),this._labelValue.dom.addEventListener("keydown",this._domEvtKeyDown),this._labelValue.dom.addEventListener("focus",this._domEvtFocus),this._labelValue.dom.addEventListener("blur",this._domEvtBlur),this._labelValue.dom.addEventListener("mousedown",this._domEvtMouseDown),this._containerOptions.dom.addEventListener("wheel",this._domEvtWheel,{passive:!0}),this.on("hide",this.close.bind(this)),this._type=e.type||"string",this._optionsIndex={},this._labelsIndex={},this._labelHighlighted=null,this.invalidOptions=e.invalidOptions,this.options=e.options||[],this._optionsFn=e.optionsFn,this._allowNull=e.allowNull||!1,this._values=null,void 0!==e.value?this.value=e.value:e.defaultValue?this.value=e.defaultValue:this.value=null,this.renderChanges=e.renderChanges||!1,this.on("change",(()=>{this._updateInputFieldsVisibility(),this.renderChanges&&!this.multiSelect&&this._labelValue.flash()})),this._updateInputFieldsVisibility(!1)}_initializeCreateLabel(){const e=new Eh({class:"pcui-select-input-create-new",flex:!0,flexDirection:"row"}),t=new Sp({text:this._input.value,tabIndex:-1});e.append(t);let n=this._input.on("change",(n=>{t.destroyed||(t.text=n,this.invalidOptions&&-1!==this.invalidOptions.indexOf(n)?e.hidden||(e.hidden=!0,this._resizeShadow()):e.hidden&&(e.hidden=!1,this._resizeShadow()))}));e.on("click",(e=>{e.stopPropagation();const n=t.text;this.focus(),this.close(),this._createFn?this._createFn(n):n&&this._onSelectValue(n)})),t.on("destroy",(()=>{n.unbind(),n=null}));const a=new Sp({text:this._createLabelText});return e.append(a),this._containerOptions.append(e),e}_convertSingleValue(e){if(null===e&&this._allowNull)return e;if("string"===this._type)e=e?e.toString():"";else if("number"===this._type)e=e?parseInt(e,10):0;else if("boolean"===this._type)return!!e;return e}_convertValue(e){return null===e&&this._allowNull?e:this.multiSelect?Array.isArray(e)?e.map((e=>this._convertSingleValue(e))):e:this._convertSingleValue(e)}_onValueClick(){this.enabled&&!this.readOnly&&this.toggle()}_onSelectValue(e){if(e=this._convertSingleValue(e),this.multiSelect)if(this._values){let t=!1;this._values.forEach((n=>{n?-1===n.indexOf(e)&&(n.push(e),t=!0):(n=[e],t=!0)})),t&&(this._onMultipleValuesChange(this._values),this.emit("change",this.value),this._binding&&this._binding.addValues([e]))}else this._value&&Array.isArray(this._value)?-1===this._value.indexOf(e)&&(this._value.push(e),this._addTag(e),this.emit("change",this.value),this._binding&&this._binding.addValues([e])):this.value=[e];else this.value=e}_highlightLabel(e){if(this._labelHighlighted!==e&&(this._labelHighlighted&&this._labelHighlighted.class.remove("pcui-select-input-label-highlighted"),this._labelHighlighted=e,this._labelHighlighted)){this._labelHighlighted.class.add("pcui-select-input-label-highlighted");const e=this._labelHighlighted.dom.offsetTop,t=this._containerOptions.dom.scrollTop;e<t?this._containerOptions.dom.scrollTop=e:e+this._labelHighlighted.height>this._containerOptions.height+t&&(this._containerOptions.dom.scrollTop=e+this._labelHighlighted.height-this._containerOptions.height)}}_onValueChange(e){if(this.multiSelect){if(this._labelValue.value="",this._containerTags.clear(),this._containerTags.class.add("pcui-select-input-tags-empty"),e&&Array.isArray(e)){e.forEach((e=>{this._addTag(e),this._labelsIndex[e]&&this._labelsIndex[e].class.add("pcui-selected")}));for(const t in this._labelsIndex)-1!==e.indexOf(this._convertSingleValue(t))?this._labelsIndex[t].class.add("pcui-selected"):this._labelsIndex[t].class.remove("pcui-selected")}}else for(var t in this._labelValue.value=this._optionsIndex[e]||"",e=""+e,this._labelsIndex)t===e?this._labelsIndex[t].class.add("pcui-selected"):this._labelsIndex[t].class.remove("pcui-selected")}_onMultipleValuesChange(e){this._labelValue.value="",this._containerTags.clear(),this._containerTags.class.add("pcui-select-input-tags-empty");const t={},n={};for(var a in e.forEach((e=>{e&&e.forEach((e=>{t[e]?n[e]++:(t[e]=this._addTag(e),n[e]=1)}))})),n)n[a]!==e.length&&(t[a].class.add("pcui-select-input-tag-not-everywhere"),this._labelsIndex[a]&&this._labelsIndex[a].class.remove("pcui-selected"))}_addTag(e){const t=new Eh({flex:!0,flexDirection:"row",class:"pcui-select-input-tag"});t.append(new Sp({text:this._optionsIndex[e]||e}));const n=new Ap({size:"small",icon:"E132",tabIndex:-1});return t.append(n),n.on("click",(()=>this._removeTag(t,e))),this._containerTags.append(t),this._containerTags.class.remove("pcui-select-input-tags-empty"),this._labelsIndex[e]&&this._labelsIndex[e].class.add("pcui-selected"),t.value=e,t}_removeTag(e,t){if(e.destroy(),this._labelsIndex[t]&&this._labelsIndex[t].class.remove("pcui-selected"),this._values)this._values.forEach((e=>{if(!e)return;const n=e.indexOf(t);-1!==n&&e.splice(n,1)}));else if(this._value&&Array.isArray(this._value)){const e=this._value.indexOf(t);-1!==e&&this._value.splice(e,1)}this.emit("change",this.value),this._binding&&this._binding.removeValues([t])}_onInputChange(e){this._suspendInputChange||this._lastInputValue!==e&&(this.open(),this._lastInputValue=e,this._filterOptions(e))}_filterOptions(e){const t=this._containerOptions.dom;for(;t.firstChild;)t.removeChild(t.lastChild);if(e){const n=function(e,t,n){let a;if(!(t=(t||"").toLowerCase().trim()))return[];var i=PR(t);if(!i.length)return[];(n=n||{}).containsCharsTolerance=n.containsCharsTolerance||.5,n.editsDistanceTolerance=n.editsDistanceTolerance||.5;var s=[];for(a=0;a<e.length;a++){var r=e[a][0].toLowerCase().trim().indexOf(t);s.push({name:e[a][0],item:e[a][1],tokens:PR(e[a][0]),edits:1/0,subFull:-1!==r?r:1/0,sub:1/0})}for(a=0;a<i.length;a++)s=kR(s,i[a],n);for(s.sort(((e,t)=>e.subFull!==t.subFull?e.subFull-t.subFull:e.sub!==t.sub?e.sub-t.sub:e.edits!==t.edits?e.edits-t.edits:e.name.length-t.name.length)),a=0;a<s.length;a++)s[a]=s[a].item;return n.hasOwnProperty("limitResults")&&s.length>n.limitResults&&(s=s.slice(0,n.limitResults)),s}(this.options.map((e=>[e.t,e.v])),e);n.forEach((e=>{t.appendChild(this._labelsIndex[e].dom)}))}else this.options.forEach((e=>{t.appendChild(this._labelsIndex[e.v].dom)}));this._createLabelContainer&&t.appendChild(this._createLabelContainer.dom),t.firstChild&&this._highlightLabel(t.firstChild.ui),this._resizeShadow()}_onInputKeyDown(e){if(13===e.keyCode&&this.enabled&&!this.readOnly){let t;if(e.stopPropagation(),e.preventDefault(),t=this._labelHighlighted&&void 0!==this._labelHighlighted._optionValue?this._labelHighlighted._optionValue:this._input.value,void 0!==t)return this.focus(),this.close(),void(this._optionsIndex[t]?this._onSelectValue(t):this._allowCreate&&(this._createFn?this._createFn(t):this._onSelectValue(t)))}this._onKeyDown(e)}_onWindowMouseDown(e){this.dom.contains(e.target)||this.close()}_onKeyDown(e){if(27!==e.keyCode)if(9!==e.keyCode){if(this.enabled&&!this.readOnly)if(13!==e.keyCode||this._allowInput){if(-1!==[38,40].indexOf(e.keyCode))if(e.stopPropagation(),e.preventDefault(),(this._allowInput||this.multiSelect)&&this._containerOptions.hidden)this.open();else if(this._containerOptions.hidden){if(!this._options.length)return;let t=-1;for(let e=0;e<this._options.length;e++)if(this._options[e].v===this.value){t=e;break}38===e.keyCode?t--:40===e.keyCode&&t++,t>=0&&t<this._options.length&&this._onSelectValue(this._options[t].v)}else{if(!this._containerOptions.dom.childNodes.length)return;if(this._labelHighlighted){let t=this._labelHighlighted.dom;do{38===e.keyCode?t=t.previousSibling:40===e.keyCode&&(t=t.nextSibling)}while(t&&t.ui.hidden);t&&this._highlightLabel(t.ui)}else this._highlightLabel(this._containerOptions.dom.childNodes[0].ui)}}else this._labelHighlighted&&void 0!==this._labelHighlighted._optionValue&&(this._onSelectValue(this._labelHighlighted._optionValue),this.close())}else this.close();else this.close()}_resizeShadow(){this._domShadow.style.height=this._containerValue.height+this._containerOptions.height+"px"}_onMouseDown(){this._allowInput||this.focus()}_onFocus(){this.class.add(fh),this.emit("focus"),this._input.hidden||this.open()}_onBlur(){this.class.remove(fh),this.emit("blur")}_onWheel(e){e.stopPropagation()}_updateInputFieldsVisibility(e){let t=!1,n=!1;this._allowInput&&(e?(t=!0,n=!0):t=this.multiSelect||!this._labelsIndex[this.value]),this._labelValue.hidden=t,this._labelIcon.hidden=t,this._input.hidden=!t,n&&this._input.focus(),this._labelValue.hidden||(this._labelValue.tabIndex=-1,this._timeoutLabelValueTabIndex||(this._timeoutLabelValueTabIndex=requestAnimationFrame((()=>{this._timeoutLabelValueTabIndex=null,this._labelValue.tabIndex=0}))))}focus(){this._input.hidden?this._labelValue.dom.focus():this._input.focus()}blur(){this._allowInput?this._input.blur():this._labelValue.dom.blur()}open(){if(!this._containerOptions.hidden||!this.enabled||this.readOnly)return;if(this._updateInputFieldsVisibility(!0),this._optionsFn&&(this.options=this._optionsFn()),0===this._containerOptions.dom.childNodes.length)return;this._containerOptions.forEachChild((e=>{e.hidden=!1,e._optionValue===this.value&&this._highlightLabel(e)})),this._labelHighlighted||this._highlightLabel(this._containerOptions.dom.childNodes[0].ui),this._containerOptions.hidden=!1,this.class.add("pcui-open"),window.addEventListener("keydown",this._domEvtKeyDown),window.addEventListener("mousedown",this._domEvtWindowMouseDown);const e=(this._allowInput?this._input.dom:this._labelValue.dom).getBoundingClientRect();let t=e.bottom+this._containerOptions.height+25>=window.innerHeight;t&&e.top-this._containerOptions.height<0&&(t=!1,this._containerOptions.style.maxHeight=window.innerHeight-e.bottom-25+"px"),t?this.class.add("pcui-select-input-fit-height"):this.class.remove("pcui-select-input-fit-height"),this._resizeShadow()}close(){this._containerOptions.style.maxHeight="",this._highlightLabel(null),this._updateInputFieldsVisibility(!1),this._suspendInputChange=!0,this._input.value="",this._lastInputValue&&(this._lastInputValue="",this._filterOptions(null)),this._suspendInputChange=!1,this._containerOptions.hidden||(this._containerOptions.hidden=!0,this._domShadow.style.height="",this.class.remove("pcui-open"),window.removeEventListener("keydown",this._domEvtKeyDown),window.removeEventListener("mousedown",this._domEvtWindowMouseDown))}toggle(){this._containerOptions.hidden?this.open():this.close()}unlink(){super.unlink(),this._containerOptions.hidden||this.close()}destroy(){this._destroyed||(this._labelValue.dom.removeEventListener("keydown",this._domEvtKeyDown),this._labelValue.dom.removeEventListener("mousedown",this._domEvtMouseDown),this._labelValue.dom.removeEventListener("focus",this._domEvtFocus),this._labelValue.dom.removeEventListener("blur",this._domEvtBlur),this._containerOptions.dom.removeEventListener("wheel",this._domEvtWheel),window.removeEventListener("keydown",this._domEvtKeyDown),window.removeEventListener("mousedown",this._domEvtWindowMouseDown),this._timeoutLabelValueTabIndex&&(cancelAnimationFrame(this._timeoutLabelValueTabIndex),this._timeoutLabelValueTabIndex=null),super.destroy())}get options(){return this._options.slice()}set options(e){this._options&&this._options===e||(this._containerOptions.clear(),this._labelHighlighted=null,this._optionsIndex={},this._labelsIndex={},this._options=e,this._options.forEach((e=>{if(this._optionsIndex[e.v]=e.t,""===e.v)return;const t=new Sp({text:e.t,tabIndex:-1});t._optionValue=e.v,this._labelsIndex[e.v]=t,t.on("click",(t=>{t.stopPropagation(),this._onSelectValue(e.v),this.close()})),this._containerOptions.append(t)})),this._createLabelContainer=null,this._createLabelText&&(this._createLabelContainer=this._initializeCreateLabel()),this.multiSelect&&this._values?this._onMultipleValuesChange(this._values):this._onValueChange(this.value),this._lastInputValue&&this._filterOptions(this._lastInputValue))}get invalidOptions(){return this._invalidOptions}set invalidOptions(e){this._invalidOptions=e||null}get multiSelect(){return this.class.contains("pcui-select-input-multi")}get value(){if(!this.multiSelect)return this._value;const e=[];return this._containerTags.dom.childNodes.forEach((t=>{e.push(t.ui.value)})),e}set value(e){this._values=null,this._suspendInputChange=!0,this._input.value="",this._lastInputValue&&(this._lastInputValue="",this._filterOptions(null)),this._suspendInputChange=!1,this.class.remove(gh),e=this._convertValue(e),(!(this._value===e||this.multiSelect&&this._value&&this._value.equals(e))||null===e&&this._allowNull&&this.class.contains(gh))&&(this._value=e,this._onValueChange(e),this.emit("change",e),this._binding&&this._binding.setValue(e))}set values(e){let t=!1;const n=(e=e.map(this._convertValue.bind(this)))[0],a=this.multiSelect;this._values=null;for(let i=1;i<e.length;i++)if(!(e[i]===n||a&&e[i]&&e[i].equals(n))){t=!0;break}t?(this._labelValue.values=e,a?(this._values=e,this._value=null,this._onMultipleValuesChange(this._values),this.emit("change",this.value)):null!==this._value&&(this._value=null,this.emit("change",null)),this.class.add(gh)):this.value=e[0]}get placeholder(){return this._input.placeholder}set placeholder(e){this._input.placeholder=e}}xh.register("select",DR,{renderChanges:!0}),xh.register("multiselect",DR,{multiSelect:!0,renderChanges:!0}),xh.register("tags",DR,{allowInput:!0,allowCreate:!0,multiSelect:!0,renderChanges:!0});var OR=function(e){oh(n,Sh);var t=ph(n);function n(e){var a;return ah(this,n),(a=t.call(this,e)).elementClass=DR,a}return sh(n,[{key:"render",value:function(){return uh(lh(n.prototype),"render",this).call(this)}}]),n}();OR.propTypes={},OR.ctor=DR,OR.defaultProps={options:[{v:"Foo",t:"Foo"},{v:"Bar",t:"Bar"}]};var FR=function(){function e(){}return e.prototype.controls=function(e){return N.createElement(N.Fragment,null,N.createElement(Lp,{headerText:"Full Body Layer"},N.createElement(Dp,{text:"active state"},N.createElement(OR,{options:[{v:"Idle",t:"Idle"},{v:"Walk",t:"Walk"}],binding:new Up,link:{observer:e,path:"fullBodyLayer.state"}})),N.createElement(Dp,{text:"blend type"},N.createElement(OR,{options:[{v:"OVERWRITE",t:"Overwrite"},{v:"ADDITIVE",t:"Additive"}],value:"ADDITIVE",binding:new Up,link:{observer:e,path:"fullBodyLayer.blendType"}}))),N.createElement(Lp,{headerText:"Upper Body Layer"},N.createElement(Dp,{text:"active state"},N.createElement(OR,{options:[{v:"Eager",t:"Eager"},{v:"Idle",t:"Idle"},{v:"Dance",t:"Dance"}],binding:new Up,link:{observer:e,path:"upperBodyLayer.state"}})),N.createElement(Dp,{text:"blend type"},N.createElement(OR,{options:[{v:"OVERWRITE",t:"Overwrite"},{v:"ADDITIVE",t:"Additive"}],value:"ADDITIVE",binding:new Up,link:{observer:e,path:"upperBodyLayer.blendType"}})),N.createElement(Dp,{text:"use mask"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"upperBodyLayer.useMask"}}))),N.createElement(Lp,{headerText:"Options"},N.createElement(Dp,{text:"blend"},N.createElement(CR,{min:.01,max:.99,binding:new Up,link:{observer:e,path:"options.blend"},value:.5})),N.createElement(Dp,{text:"skeleton"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"options.skeleton"}}))))},e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"model",type:"container",url:"/static/assets/models/bitmoji.glb"}),N.createElement(dR,{name:"idleAnim",type:"container",url:"/static/assets/animations/bitmoji/idle.glb"}),N.createElement(dR,{name:"idleEagerAnim",type:"container",url:"/static/assets/animations/bitmoji/idle-eager.glb"}),N.createElement(dR,{name:"walkAnim",type:"container",url:"/static/assets/animations/bitmoji/walk.glb"}),N.createElement(dR,{name:"danceAnim",type:"container",url:"/static/assets/animations/bitmoji/win-dance.glb"}),N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}),N.createElement(dR,{name:"bloom",type:"script",url:"/static/scripts/posteffects/posteffect-bloom.js"}))},e.prototype.example=function(e,t,n){var a=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body)});a.start(),n.set("fullBodyLayer",{state:"Idle",blendType:"OVERWRITE"}),n.set("upperBodyLayer",{state:"Eager",blendType:"ADDITIVE",useMask:!0}),n.set("options",{blend:.5,skeleton:!0}),a.scene.exposure=2,a.scene.skyboxMip=2,a.scene.setSkybox(t["helipad.dds"].resources);var i=new KM;i.addComponent("camera",{clearColor:new Mu(.1,.1,.1)}),i.translate(0,.75,3),i.addComponent("script"),i.script.create("bloom",{attributes:{bloomIntensity:1,bloomThreshold:.7,blurAmount:4}}),a.root.addChild(i);var s=new KM;s.addComponent("light",{castShadows:!0,intensity:1.5,normalOffsetBias:.02,shadowType:4,shadowDistance:6,shadowResolution:2048,shadowBias:.02}),a.root.addChild(s),s.setLocalEulerAngles(45,30,0);var r=t.model.resource.instantiateRenderEntity({castShadows:!0});r.addComponent("anim",{activate:!0}),a.root.addChild(r);var o=t.idleAnim.resource.animations[0].resource,l=t.walkAnim.resource.animations[0].resource,c=t.danceAnim.resource.animations[0].resource,h=t.idleEagerAnim.resource.animations[0].resource;r.anim.assignAnimation("Idle",o),r.anim.assignAnimation("Walk",l),r.anim.baseLayer.weight=1-n.get("options.blend");var d=r.anim.addLayer("UpperBody",n.get("options.blend"),{"RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT":{children:!0},"RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT/C_Head":!0},n.get("upperBodyLayer.blendType"));d.assignAnimation("Eager",h),d.assignAnimation("Idle",o),d.assignAnimation("Dance",c),n.on("*:set",(function(e,t){"fullBodyLayer.state"===e&&r.anim.baseLayer.transition(t,.4),"upperBodyLayer.state"===e&&d.transition(t,.4),"fullBodyLayer.blendType"===e&&(r.anim.baseLayer.blendType=t),"upperBodyLayer.blendType"===e&&(d.blendType=t),"upperBodyLayer.useMask"===e&&(d.mask=t?{"RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT":{children:!0}}:null),"options.blend"===e&&(r.anim.baseLayer.weight=1-t,d.weight=t)}));var p=function(e,t){e.children.forEach((function(t){var n=r.anim._targets[e.path+"/graph/localPosition"];n&&a.drawLine(e.getPosition(),t.getPosition(),new Mu(n.getWeight(0),0,n.getWeight(1),1),!1),p(t)}))};a.on("update",(function(){n.get("options.skeleton")&&p(r,new Mu(1,0,0,.5*r.anim.baseLayer.weight))}))},e.CATEGORY="Animation",e.NAME="Layer Masks",e}(),NR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"playcanvasGreyTexture",type:"texture",url:"/static/assets/textures/playcanvas-grey.png"}),N.createElement(dR,{name:"model",type:"container",url:"/static/assets/models/bitmoji.glb"}),N.createElement(dR,{name:"idleAnim",type:"container",url:"/static/assets/animations/bitmoji/idle.glb"}),N.createElement(dR,{name:"walkAnim",type:"container",url:"/static/assets/animations/bitmoji/walk.glb"}),N.createElement(dR,{name:"jogAnim",type:"container",url:"/static/assets/animations/bitmoji/run.glb"}),N.createElement(dR,{name:"jumpAnim",type:"container",url:"/static/assets/animations/bitmoji/jump-flip.glb"}),N.createElement(dR,{name:"cubemap",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}))},e.prototype.controls=function(e){return N.createElement(N.Fragment,null,N.createElement(AR,{text:"Jump",onClick:function(){return e.emit("jump")}}),N.createElement(Dp,{text:"Run: "},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"jogToggle"}})))},e.prototype.example=function(e,t,n,a,i){function s(){var a=new jM(e,{});a.scene.skyboxMip=2,a.scene.skyboxIntensity=.7,a.scene.setSkybox(t.cubemap.resources),a.scene.toneMapping=3;var i=new KM;i.name="Camera",i.addComponent("camera",{clearColor:new Mu(.1,.15,.2)}),i.translateLocal(.5,3,8),i.rotateLocal(-30,0,0),a.root.addChild(i);var s=new KM;s.addComponent("light",{type:"directional",color:new Mu(1,1,1),castShadows:!0,intensity:2,shadowBias:.2,shadowDistance:16,normalOffsetBias:.05,shadowResolution:2048}),s.setLocalEulerAngles(60,30,0),a.root.addChild(s),a.start();var r=new KM,o=t.model.resource.instantiateRenderEntity({castShadows:!0});r.addChild(o),r.addComponent("anim",{activate:!0});var l={layers:[{name:"locomotion",states:[{name:"START"},{name:"Idle",speed:1},{name:"Walk",speed:1},{name:"Jump",speed:1},{name:"Jog",speed:1},{name:"END"}],transitions:[{from:"START",to:"Idle",time:0,priority:0},{from:"Idle",to:"Walk",time:.1,priority:0,conditions:[{parameterName:"speed",predicate:"GREATER_THAN",value:0}]},{from:"ANY",to:"Jump",time:.1,priority:0,conditions:[{parameterName:"jump",predicate:"EQUAL_TO",value:!0}]},{from:"Jump",to:"Idle",time:.2,priority:0,exitTime:.8},{from:"Jump",to:"Walk",time:.2,priority:0,exitTime:.8},{from:"Walk",to:"Idle",time:.1,priority:0,conditions:[{parameterName:"speed",predicate:"LESS_THAN_EQUAL_TO",value:0}]},{from:"Walk",to:"Jog",time:.1,priority:0,conditions:[{parameterName:"speed",predicate:"GREATER_THAN",value:1}]},{from:"Jog",to:"Walk",time:.1,priority:0,conditions:[{parameterName:"speed",predicate:"LESS_THAN",value:2}]}]}],parameters:{speed:{name:"speed",type:"INTEGER",value:0},jump:{name:"jump",type:"TRIGGER",value:!1}}};r.anim.loadStateGraph(l);var c=r.anim.baseLayer;c.assignAnimation("Idle",t.idleAnim.resource.animations[0].resource),c.assignAnimation("Walk",t.walkAnim.resource.animations[0].resource),c.assignAnimation("Jog",t.jogAnim.resource.animations[0].resource),c.assignAnimation("Jump",t.jumpAnim.resource.animations[0].resource),a.root.addChild(r);var h=new KM;h.name="Plane",h.addComponent("render",{type:"plane"}),h.addComponent("collision",{type:"box",halfExtents:new Pu(7.5,0,7.5)}),h.addComponent("rigidbody",{type:"static"}),h.setLocalScale(15,1,15),h.setPosition(0,0,0);var d=new cg;d.diffuseMap=t.playcanvasGreyTexture.resource,d.update(),h.render.meshInstances[0].material=d,a.root.addChild(h),n.on("jump",(function(){"Jump"===r.anim.baseLayer.activeState||r.anim.setTrigger("jump")}));var p,u,m=lL("Locomotion");function f(e){switch(e){case"Walk":return 1;case"Jog":return 4;default:return 0}}m.prototype.initialize=function(){p=new Pu(1,0,0),u=new Pu(2,0,2),document.addEventListener("mousedown",this.onMouseDown)},m.prototype.onMouseDown=function(e){if(0===e.button){var t=a.root.findByName("Camera"),i=t.camera.screenToWorld(e.x,e.y,t.camera.nearClip),s=t.camera.screenToWorld(e.x,e.y,t.camera.farClip),o=a.systems.rigidbody.raycastFirst(s,i);o&&(u=new Pu(o.point.x,0,o.point.z),r.anim.setInteger("speed",n.get("jogToggle")?2:1))}};var g=new Pu(0,0,0);m.prototype.update=function(e){if(r.anim.getInteger("speed")){var t=f(r.anim.baseLayer.activeState);if(r.anim.baseLayer.transitioning){var n=f(r.anim.baseLayer.previousState),a=r.anim.baseLayer.transitionProgress;t=n*(1-a)+t*a}var i=u.clone().sub(g),s=i.clone().normalize();p=(new Pu).sub(s);var o=s.clone().mulScalar(e*t);o.length()<i.length()?(g.add(o),r.setPosition(g),r.lookAt(r.getPosition().clone().add(p))):(g.copy(u),r.setPosition(g),r.anim.setInteger("speed",0))}},r.addComponent("script"),r.script.create("Locomotion",{})}a()?i("Ammo","/static/lib/ammo/ammo.wasm.js","/static/lib/ammo/ammo.wasm.wasm",s):i("Ammo","/static/lib/ammo/ammo.js","",s)},e.CATEGORY="Animation",e.NAME="Locomotion",e}(),VR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(pR,{name:"TWEEN",url:"https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"}),N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/arial.json"}),N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/animation/tween.js"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)}));for(var a=function(e,t,a,i,s,r){var o=new KM;o.addComponent("element",{anchor:[.5,.5,.5,.5],fontAsset:e,fontSize:.5,pivot:[1,.5],text:t,type:"text"}),o.setLocalPosition(a,i,s),o.setLocalEulerAngles(0,0,r),n.root.addChild(o)},i=["Linear","Quadratic","Cubic","Quartic","Quintic","Sinusoidal","Exponential","Circular","Elastic","Back","Bounce"],s=[],r=[],o=0;o<i.length;o++){var l=new KM;l.addComponent("render",{type:"sphere"});var c=l.render.material;c.diffuse.set(1,0,0),c.specular.set(.6,.6,.6),c.shininess=20,l.addComponent("script"),l.script.create("tween",{attributes:{tweens:[{autoPlay:!0,delay:0,duration:1500,easingFunction:o,easingType:2,end:new Ou(4,-o,0,0),path:"localPosition",repeat:-1,repeatDelay:0,start:new Ou(0,-o,0,0),yoyo:!0}]}}),l.setLocalScale(.8,.8,.8),n.root.addChild(l),s.push(new Pu(0,-o,0),new Pu(4,-o,0)),r.push(Mu.WHITE,Mu.WHITE),a(t.font,i[o],-.5,-o,0,0)}var h=new KM;h.addComponent("light",{type:"directional"}),h.setLocalEulerAngles(70,30,0),n.root.addChild(h);var d=new KM;d.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),d.translate(.65,-5.5,20),n.root.addChild(d),n.on("update",(function(){n.drawLines(s,r)}))},e.CATEGORY="Animation",e.NAME="Tween",e}(),BR=Object.freeze({__proto__:null,BlendTrees1DExample:TR,BlendTrees2DCartesianExample:ER,BlendTrees2DDirectionalExample:SR,ComponentPropertiesExample:MR,EventsExample:LR,LayerMasksExample:FR,LocomotionExample:NR,TweenExample:VR}),UR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}),N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/camera/first-person-camera.js"}))},e.prototype.example=function(e,t,n,a){n()?a("Ammo","/static/lib/ammo/ammo.wasm.js","/static/lib/ammo/ammo.wasm.wasm",s):a("Ammo","/static/lib/ammo/ammo.js","",s);var i=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),gamepads:new eR,keyboard:new mL(window)});function s(){i.start();var e=new KM;e.addComponent("collision",{type:"box",halfExtents:new Pu(100,.5,100)}),e.addComponent("rigidbody",{type:"static",restitution:.5}),e.setLocalPosition(0,-.5,0),i.root.addChild(e);var n=new KM;n.addComponent("model",{type:"plane"}),n.setLocalPosition(0,.5,0),n.setLocalScale(200,1,200),e.addChild(n);var a=t.statue.resource.instantiateRenderEntity({castShadows:!0});a.addComponent("collision",{type:"mesh",asset:t.statue.resource.model}),a.addComponent("rigidbody",{type:"static",restitution:.5}),i.root.addChild(a);var s=new KM;s.addComponent("camera",{clearColor:new Mu(.4,.45,.5),farClip:100,fov:65,nearClip:.1}),s.setLocalPosition(0,1,0);var r=new KM;r.addComponent("collision",{axis:0,height:2,radius:.5,type:"capsule"}),r.addComponent("rigidbody",{angularDamping:0,angularFactor:Pu.ZERO,friction:.3,linearDamping:0,linearFactor:Pu.ONE,mass:80,restitution:0,type:"dynamic"}),r.addComponent("script"),r.script.create("characterController"),r.script.create("firstPersonCamera",{attributes:{camera:s}}),r.script.create("gamePadInput"),r.script.create("keyboardInput"),r.script.create("mouseInput"),r.script.create("touchInput"),r.setLocalPosition(0,1,10),i.root.addChild(r),r.addChild(s);var o=new KM;o.addComponent("light",{castShadows:!0,color:new Mu(1,1,1),normalOffsetBias:.05,shadowBias:.2,shadowDistance:40,type:"directional",shadowResolution:2048}),i.root.addChild(o),o.setLocalEulerAngles(45,30,0)}i.setCanvasFillMode("FILL_WINDOW"),i.setCanvasResolution("AUTO")},e.CATEGORY="Camera",e.NAME="First Person",e}(),zR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}),N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/camera/orbit-camera.js"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body)}),a=t.statue.resource.instantiateRenderEntity();a.setLocalScale(.07,.07,.07),a.setLocalPosition(0,-.5,0),n.root.addChild(a);var i=new KM;i.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),i.addComponent("script"),i.script.create("orbitCamera",{attributes:{inertiaFactor:.2}}),i.script.create("orbitCameraInputMouse"),i.script.create("orbitCameraInputTouch"),n.root.addChild(i);var s=new KM;s.addComponent("light",{type:"directional"}),n.root.addChild(s),s.setLocalEulerAngles(45,30,0),n.start()},e.CATEGORY="Camera",e.NAME="Orbit",e}(),GR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/camera/fly-camera.js"}))},e.prototype.example=function(e){var t=new jM(e,{mouse:new yL(e),keyboard:new mL(window)});function n(e){var t=new cg;return t.diffuse=e,t.update(),t}function a(e,n,a){var i=new KM;i.addComponent("render",{type:"box",material:a}),i.setLocalPosition(e),i.setLocalScale(n),t.root.addChild(i)}t.scene.ambientLight=new Mu(.2,.2,.2),t.start();for(var i=n(Mu.RED),s=0;s<3;s++)for(var r=0;r<2;r++)a(new Pu(2*s,0,4*r),Pu.ONE,i);var o=n(Mu.WHITE);a(new Pu(0,-.5,0),new Pu(10,.1,10),o);var l=new KM;l.addComponent("light",{type:"omni",color:new Mu(1,1,1),range:100}),l.setLocalPosition(0,0,2),t.root.addChild(l);var c=new KM;c.addComponent("camera",{clearColor:new Mu(.5,.5,.8),nearClip:.3,farClip:30}),c.addComponent("script"),c.script.create("flyCamera"),t.root.addChild(c),c.translate(2,.8,9)},e.CATEGORY="Camera",e.NAME="Fly",e}(),HR=Object.freeze({__proto__:null,FirstPersonExample:UR,OrbitExample:zR,FlyExample:GR}),WR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"color",type:"texture",url:"/static/assets/textures/seaside-rocks01-color.jpg"}),N.createElement(dR,{name:"normal",type:"texture",url:"/static/assets/textures/seaside-rocks01-normal.jpg"}),N.createElement(dR,{name:"gloss",type:"texture",url:"/static/assets/textures/seaside-rocks01-gloss.jpg"}),N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}),N.createElement(dR,{name:"luts",type:"binary",url:"/static/assets/binary/area-light-luts.bin"}),N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}))},e.prototype.example=function(e,t){var n=new jM(e,{});function a(e,t,a,i,s,r,o,l){var c=new KM;c.translate(a),n.root.addChild(c);var h=new KM;h.addComponent("light",{type:e,shape:t,color:s,intensity:r,falloffMode:1,range:l,castShadows:o,innerConeAngle:80,outerConeAngle:85,shadowBias:.1,normalOffsetBias:.1,shadowResolution:2048}),h.setLocalScale(i,i,i),c.addChild(h);var d=new cg;d.emissive=s,d.useLighting=!1,d.cull=1===t?0:1,d.update();var p=new KM;if(p.addComponent("render",{type:3===t?"sphere":2===t?"cone":"plane",material:d,castShadows:"directional"!==e}),p.setLocalScale("directional"===e?i*l:i,2===t?.001:"directional"===e?i*l:i,"directional"===e?i*l:i),c.addChild(p),"spot"===e){var u=new cg;u.diffuse=new Mu(0,0,0),u.useLighting=!1,u.cull=1===t?0:1,u.update();var m=new KM;m.addComponent("render",{type:3===t?"sphere":2===t?"cone":"plane",material:u}),m.setLocalPosition(0,.01/i,0),m.setLocalEulerAngles(-180,0,0),p.addChild(m)}return c}var i=5e3;n.start(),n.setAreaLightLuts(t.luts),n.scene.toneMapping=3,n.scene.skyboxMip=1,n.scene.skyboxIntensity=.4,n.scene.setSkybox(t["helipad.dds"].resources),function(e,t,a,i,s){var r=new cg;r.diffuse=i,r.shininess=80,r.useMetalness=!0,s&&(r.diffuseMap=s.color.resource,r.normalMap=s.normal.resource,r.glossMap=s.gloss.resource,r.metalness=.7,r.diffuseMapTiling.set(7,7),r.normalMapTiling.set(7,7),r.glossMapTiling.set(7,7)),r.update();var o=new KM;o.addComponent("render",{type:e,material:r}),o.setLocalPosition(t),o.setLocalScale(a),n.root.addChild(o)}("plane",new Pu(0,0,0),new Pu(20,20,20),new Mu(.3,.3,.3),t);var s=t.statue.resource.instantiateRenderEntity();s.setLocalScale(.4,.4,.4),n.root.addChild(s);var r=new KM;r.addComponent("camera",{clearColor:new Mu(.2,.2,.2),fov:60,farClip:1e5}),n.root.addChild(r),r.setLocalPosition(0,2.5,12),r.lookAt(0,0,0);var o=a("spot",1,new Pu(-3,4,0),4,new Mu(1,1,1),2,!0,10),l=a("omni",3,new Pu(5,2,-2),2,new Mu(1,1,0),2,!1,10),c=a("directional",2,new Pu(0,0,0),.2,new Mu(.7,.7,1),10,!0,i),h=0;n.on("update",(function(e){h+=e;var t=.5*(Math.sin(h)+1),n=.5*(Math.sin(.6*h)+1),a=.5*(Math.sin(.4*h)+1);if(o&&(o.setLocalEulerAngles(Eu.lerp(-90,110,t),0,90),o.setLocalPosition(-4,Eu.lerp(2,4,a),Eu.lerp(-2,2,n))),l&&l.setLocalPosition(5,Eu.lerp(1,3,t),Eu.lerp(-2,2,n)),c){c.setLocalEulerAngles(Eu.lerp(230,310,n),Eu.lerp(-30,0,a),90);var s=c.getWorldTransform().getY(),d=r.getPosition();c.setPosition(d.x+s.x*i,d.y+s.y*i,d.z+s.z*i)}}))},e.CATEGORY="Graphics",e.NAME="Area Lights",e}(),jR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"bloom",type:"script",url:"/static/scripts/posteffects/posteffect-bloom.js"}),N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.scene.skyboxMip=2,n.scene.setSkybox(t["helipad.dds"].resources),n.scene.skyboxIntensity=.1;for(var a=.25,i=0,s=0,r=0;r<300;r++){var o=Math.random()<.5?"cylinder":"sphere",l=new Pu(30*Math.random()-15,30*Math.random()-15,30*Math.random()-15),c=1+Math.random(),h=p(o,l,new Pu(c,c,c));n.root.addChild(h)}new yL(document.body).on("mousemove",(function(e){i=e.x,s=e.y}),this);var d=new sL(n,e.clientWidth*a,e.clientHeight*a);function p(e,t,n){var a=new cg;a.diffuse=new Mu(Math.random(),Math.random(),Math.random()),a.shininess=60,a.metalness=.4,a.useMetalness=!0,a.update();var i=new KM;return i.addComponent("render",{type:e,material:a}),i.setLocalPosition(t),i.setLocalScale(n),i}var u=new KM;function m(e,t,a,i){var s=new Mu(1,.02,.58),r=u.camera.screenToWorld(e,t,1),o=u.camera.screenToWorld(e+a,t,1),l=u.camera.screenToWorld(e+a,t+i,1),c=u.camera.screenToWorld(e,t+i,1),h=[r,o,o,l,l,c,c,r],d=[s,s,s,s,s,s,s,s];n.drawLines(h,d)}function f(e,t){e.emissive=t,e.update()}u.addComponent("camera",{clearColor:new Mu(.1,.1,.1)}),u.addComponent("script"),u.script.create("bloom",{attributes:{bloomIntensity:1,bloomThreshold:.7,blurAmount:4}}),n.root.addChild(u);var g=[],y=0;n.on("update",(function(t){if(y+=.1*t,u){u.setLocalPosition(40*Math.sin(y),0,40*Math.cos(y)),u.lookAt(Pu.ZERO);for(var r=0;r<g.length;r++)f(g[r],Mu.BLACK);g.length=0,d&&(d.resize(e.clientWidth*a,e.clientHeight*a),d.prepare(u.camera,n.scene));for(var o=[{pos:new Du(.3*e.clientWidth,.3*e.clientHeight),size:new Du(100,200),color:Mu.YELLOW},{pos:new Du(.6*e.clientWidth,.7*e.clientHeight),size:new Du(200,20),color:Mu.CYAN},{pos:new Du(.8*e.clientWidth,.3*e.clientHeight),size:new Du(5,5),color:Mu.MAGENTA},{pos:new Du(i,s),size:new Du(1,1),color:Mu.RED}],l=0;l<o.length;l++){var c=o[l].pos,h=o[l].size,p=o[l].color;m(c.x,c.y,h.x,h.y);for(var b=d.getSelection(c.x*a,c.y*a,h.x*a,h.y*a),v=0;v<b.length;v++)if(b[v]){var _=b[v].material;f(_,p),g.push(_)}}}}))},e.CATEGORY="Graphics",e.NAME="Area Picker",e}(),XR=function(){function e(){}return e.prototype.example=function(e){var t=new jM(e,{});t.start(),t.setCanvasFillMode("FILL_WINDOW"),t.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){t.resizeCanvas(e.width,e.height)}));var n=new cg;n.diffuse=new Mu(1,1,0),n.shininess=40,n.metalness=.5,n.useMetalness=!0,n.update();var a=new cg;a.diffuse=new Mu(0,1,1),a.shininess=40,a.metalness=.5,a.useMetalness=!0,a.update();for(var i=t.batcher.addGroup("Meshes",!0,100),s=["box","cone","cylinder","sphere","capsule"],r=[],o=0;o<500;o++){var l=s[Math.floor(Math.random()*s.length)],c=new KM;c.addComponent("render",{type:l,material:Math.random()<.5?n:a,castShadows:!0,batchGroupId:i.id}),t.root.addChild(c),r.push(c)}var h=new KM;h.addComponent("render",{type:"box",material:a}),h.setLocalScale(150,1,150),h.setLocalPosition(0,-26,0),t.root.addChild(h);var d=new KM;d.addComponent("camera",{clearColor:new Mu(.2,.2,.2)}),t.root.addChild(d);var p=new KM;p.addComponent("light",{type:"directional",castShadows:!0,shadowBias:.2,normalOffsetBias:.06,shadowDistance:150}),d.addChild(p),p.setLocalEulerAngles(15,30,0);var u=0;t.on("update",(function(e){u+=e;for(var t=0;t<r.length;t++){var n=5+20*t/500,a=t/500;r[t].setLocalPosition(n*Math.sin(t+u*a),n*Math.cos(t+u*a),n*Math.cos(t+2*u*a)),r[t].lookAt(Pu.ZERO)}d.setLocalPosition(70*Math.sin(u),0,70*Math.cos(u)),d.lookAt(Pu.ZERO)}))},e.CATEGORY="Graphics",e.NAME="Batching Dynamic",e}(),YR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/camera/orbit-camera.js"}),N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/utils/cubemap-renderer.js"}),N.createElement(dR,{name:"normal",type:"texture",url:"/static/assets/textures/normal-map.png"}))},e.prototype.controls=function(e){return N.createElement(N.Fragment,null,N.createElement(Lp,{headerText:"Settings"},N.createElement(Dp,{text:"Update"},N.createElement(OR,{binding:new Up,link:{observer:e,path:"settings.updateFrequency"},type:"number",options:[{v:0,t:"Once"},{v:1,t:"Every frame"},{v:10,t:"Every 10 frames"},{v:30,t:"Every 30 frames"}]})),N.createElement(Dp,{text:"Shininess"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"settings.shininess"},min:0,max:100,precision:0})),N.createElement(Dp,{text:"Metalness"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"settings.metalness"},min:0,max:1,precision:2})),N.createElement(Dp,{text:"Bumpiness"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"settings.bumpiness"},min:0,max:1,precision:2}))))},e.prototype.example=function(e,t,n){var a=new jM(e,{});a.start(),n.set("settings",{updateFrequency:10,shininess:90,metalness:.7,bumpiness:.2}),a.setCanvasFillMode("FILL_WINDOW"),a.setCanvasResolution("AUTO");var i=new rv({name:"Excluded"});a.scene.layers.push(i);var s=a.scene.layers.getLayerByName("World"),r=new Gm(a.graphicsDevice,{width:512,height:512,format:7,type:"rgbm",projection:"equirect",addressU:1,addressV:1,mipmaps:!1}),o=new cg;o.useMetalness=!0,o.diffuse=Mu.WHITE,o.normalMap=t.normal.resource,o.normalMapTiling.set(5,5),o.bumpiness=.1,o.shininess=90,o.envAtlas=r,o.metalness=.5,o.cubeMapProjection=1,o.cubeMapProjectionBox=new qu(new Pu(0,200,0),new Pu(400,200,400)),o.update();var l=new cg;l.emissive=Mu.MAGENTA,l.diffuse=Mu.BLACK,l.update();var c=new cg;c.emissive=Mu.WHITE,c.diffuse=Mu.BLACK,c.update();var h=new cg;h.useMetalness=!0,h.diffuse=Mu.WHITE,h.normalMap=t.normal.resource,h.normalMapTiling.set(5,5),h.bumpiness=.7,h.shininess=90,h.metalness=.6,h.envAtlas=r,h.update();var d=new Gm(a.graphicsDevice,{format:3,mipmaps:!1,minFilter:1,magFilter:1,addressU:1,addressV:1}),p=document.createElement("video");p.id="vid",p.loop=!0,p.muted=!0,p.autoplay=!0,p.playsInline=!0,p.crossOrigin="anonymous",p.setAttribute("style","display: block; width: 1px; height: 1px; position: absolute; opacity: 0; z-index: -1000; top: 0px; pointer-events: none"),p.src="/static/assets/video/SampleVideo_1280x720_1mb.mp4",document.body.append(p),p.addEventListener("canplaythrough",(function(){d.setSource(p)}));var u=new cg;function m(e,t,n,r){var o=new KM;o.addComponent("render",{type:e,material:r,layers:[s.id,i.id]}),o.setLocalPosition(t),o.setLocalScale(n),a.root.addChild(o)}u.useLighting=!1,u.emissiveMap=d,u.update(),m("box",new Pu(0,0,0),new Pu(800,2,800),o),m("box",new Pu(0,400,0),new Pu(800,2,800),o),m("box",new Pu(400,200,0),new Pu(2,400,800),o),m("box",new Pu(-400,200,0),new Pu(2,400,800),o),m("box",new Pu(0,200,-400),new Pu(800,400,0),o),m("box",new Pu(0,200,400),new Pu(800,400,0),o),m("box",new Pu(400,200,-50),new Pu(20,400,20),l),m("box",new Pu(400,200,50),new Pu(20,400,20),l),m("box",new Pu(-400,200,50),new Pu(20,400,20),l),m("box",new Pu(-400,200,-50),new Pu(20,400,20),l),m("box",new Pu(0,400,50),new Pu(800,20,20),l),m("box",new Pu(0,400,-50),new Pu(800,20,20),l),m("box",new Pu(0,200,400),new Pu(500,250,5),u),m("sphere",new Pu(0,150,0),new Pu(150,150,150),h);var f=new KM;f.addComponent("light",{type:"omni",layers:[i.id],castShadows:!1,color:Mu.WHITE,intensity:.2,range:1e3}),f.addComponent("render",{type:"sphere",layers:[i.id],material:c}),f.setLocalScale(20,20,20),a.root.addChild(f);var g=new KM;g.addComponent("camera",{fov:100,layers:[s.id,i.id],farClip:1500}),g.setLocalPosition(270,90,-260),g.addComponent("script"),g.script.create("orbitCamera",{attributes:{inertiaFactor:.2,distanceMax:390,frameOnStart:!1}}),g.script.create("orbitCameraInputMouse"),g.script.create("orbitCameraInputTouch"),a.root.addChild(g);var y=new KM;y.addComponent("script"),y.addComponent("camera",{clearColorBuffer:!1,priority:-1,layers:[s.id],enabled:!1,nearClip:1,farClip:500}),y.script.create("cubemapRenderer",{attributes:{resolution:128,mipmaps:!0,depth:!0}}),y.setPosition(0,200,0),a.root.addChild(y),y.on("onCubemapPostRender",(function(){Kf.generateAtlas(y.script.cubemapRenderer.cubeMap,{target:r})}));var b=0,v=1,_=!0;a.on("update",(function(e){b+=.3*e,_&&d.upload(),_=!_,f.setLocalPosition(300*Math.sin(b),300,300*Math.cos(b));var t=n.get("settings.updateFrequency");v--,0===t&&(v=1),v<=0?(y.enabled=!0,v=t):y.enabled=!1;var a=n.get("settings.shininess"),i=n.get("settings.metalness"),s=n.get("settings.bumpiness");o.shininess=a,o.metalness=i,o.bumpiness=s,o.update(),h.shininess=a,h.metalness=i,h.bumpiness=s,h.update()}))},e.CATEGORY="Graphics",e.NAME="Box Reflection",e}(),qR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"bloom",type:"script",url:"/static/scripts/posteffects/posteffect-bloom.js"}),N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/camera/orbit-camera.js"}),N.createElement(dR,{name:"color",type:"texture",url:"/static/assets/textures/seaside-rocks01-color.jpg"}),N.createElement(dR,{name:"normal",type:"texture",url:"/static/assets/textures/seaside-rocks01-normal.jpg"}),N.createElement(dR,{name:"gloss",type:"texture",url:"/static/assets/textures/seaside-rocks01-gloss.jpg"}),N.createElement(dR,{name:"luts",type:"binary",url:"/static/assets/binary/area-light-luts.bin"}))},e.prototype.controls=function(e){return N.createElement(N.Fragment,null,N.createElement(Lp,{headerText:"Material"},N.createElement(Dp,{text:"Shininess"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"settings.material.shininess"},min:0,max:100,precision:0})),N.createElement(Dp,{text:"Metalness"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"settings.material.metalness"},min:0,max:1,precision:2}))))},e.prototype.example=function(e,t,n){n.set("settings",{material:{shininess:80,metalness:.7}});var a=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body)});a.scene.toneMapping=3,a.scene.clusteredLightingEnabled=!0;var i=a.scene.lighting;i.cells=new Pu(30,2,30),i.maxLightsPerCell=20,i.areaLightsEnabled=!0,i.shadowsEnabled=!1;var s=new cg;s.diffuse=new Mu(0,0,0),s.useLighting=!1,s.update();var r=new cg;function o(e,t,n,i,r,o,l){var c=new KM;c.addComponent("light",{type:e,shape:t,color:r,intensity:o,falloffMode:1,range:l,innerConeAngle:88,outerConeAngle:89}),c.setLocalScale(i),c.setLocalPosition(n),"spot"===e&&c.rotate(-90,0,0),a.root.addChild(c);var h=new cg;h.emissive=new Mu(.8*r.r,.8*r.g,.8*r.b),h.useLighting=!1,h.update();var d=3===t?"sphere":2===t?"cylinder":"box",p=new Pu(1,3!==t?.001:1,1),u=new KM;if(u.addComponent("render",{type:d,material:h}),u.setLocalScale(p),c.addChild(u),"spot"===e){var m=new KM;m.addComponent("render",{type:d,material:s}),m.setLocalPosition(0,.004,0),m.setLocalEulerAngles(-180,0,0),m.setLocalScale(p),c.addChild(m)}return c}r.diffuse=Mu.GRAY,r.shininess=80,r.metalness=.7,r.useMetalness=!0,a.start(),a.setAreaLightLuts(t.luts),a.scene.toneMapping=3;var l=function(e,t,n,i){i&&(r.diffuseMap=i.color.resource,r.normalMap=i.normal.resource,r.glossMap=i.gloss.resource,r.diffuseMapTiling.set(17,17),r.normalMapTiling.set(17,17),r.glossMapTiling.set(17,17)),r.update();var s=new KM;return s.addComponent("render",{type:e,material:r}),s.setLocalPosition(t),s.setLocalScale(n),a.root.addChild(s),s}("plane",new Pu(0,0,0),new Pu(45,1,45),t),c=new KM;c.addComponent("camera",{clearColor:new Mu(.1,.1,.1),fov:60,farClip:1e3}),c.setLocalPosition(3,3,12),c.addComponent("script"),c.script.create("orbitCamera",{attributes:{inertiaFactor:.2,focusEntity:l,distanceMax:60,frameOnStart:!1}}),c.script.create("orbitCameraInputMouse"),c.script.create("orbitCameraInputTouch"),a.root.addChild(c),c.script.create("bloom",{attributes:{bloomIntensity:1.5,bloomThreshold:.6,blurAmount:6}});for(var h=-20;h<=20;h+=5)for(var d=-20;d<=20;d+=5){var p=new Pu(h,.6,d),u=new Mu(.3+.7*Math.random(),.3+.7*Math.random(),.3+.7*Math.random()),m=Math.random();m<.3?o("omni",3,p,new Pu(1.5,1.5,1.5),u,2,6):m<.6?o("spot",2,p,new Pu(1.5,1.5,1.5),u,2.5,5):o("spot",1,p,new Pu(2,1,1),u,2.5,5)}n.on("*:set",(function(e,t){var n=e.split(".");"shininess"===n[2]&&(r.shininess=t),"metalness"===n[2]&&(r.metalness=t),r.update()}))},e.CATEGORY="Graphics",e.NAME="Clustered Area Lights",e}(),KR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/camera/orbit-camera.js"}),N.createElement(dR,{name:"normal",type:"texture",url:"/static/assets/textures/normal-map.png"}))},e.prototype.example=function(e,t){var n=new jM(e,{}),a=[],i=[],s=null;n.start(),n.scene.clusteredLightingEnabled=!0;var r=n.scene.lighting;r.cells=new Pu(12,16,12),r.maxLightsPerCell=48,r.shadowsEnabled=!1,n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)}));var o=new cg;o.normalMap=t.normal.resource,o.normalMapTiling.set(5,5),o.bumpiness=1,o.shininess=50,o.metalness=.3,o.useMetalness=!0,o.update();var l=new KM;l.addComponent("render",{type:"plane",material:o}),l.setLocalScale(150,150,150),n.root.addChild(l);var c=hy(n.graphicsDevice,{capSegments:200}),h=new KM;h.addComponent("render",{material:o,meshInstances:[new Ay(c,o)],castShadows:!0}),n.root.addChild(h),h.setLocalPosition(0,50,0),h.setLocalScale(50,100,50);for(var d=30,p=0;p<d;p++){var u=new Mu(Math.random(),Math.random(),Math.random(),1),m=new KM;m.addComponent("light",{type:"omni",color:u,range:12,castShadows:!1,falloffMode:1});var f=new cg;f.emissive=u,f.update(),m.addComponent("render",{type:"sphere",material:f,castShadows:!0}),m.setLocalScale(5,5,5),n.root.addChild(m),a.push(m)}d=16;for(p=0;p<d;p++){u=new Mu(Math.random(),Math.random(),Math.random(),1);var g=new KM;g.addComponent("light",{type:"spot",color:u,innerConeAngle:5,outerConeAngle:6+40*Math.random(),range:25,castShadows:!1}),(o=new cg).emissive=u,o.update(),g.addComponent("render",{type:"cone",material:o}),g.setLocalScale(5,5,5),g.setLocalPosition(100,50,70),g.lookAt(new Pu(100,60,70)),n.root.addChild(g),i.push(g)}(s=new KM).addComponent("light",{type:"directional",color:Mu.WHITE,intensity:.15,range:300,shadowDistance:600,castShadows:!0,shadowBias:.2,normalOffsetBias:.05}),n.root.addChild(s);var y=new KM;y.addComponent("camera",{clearColor:new Mu(.05,.05,.05),farClip:500,nearClip:.1}),y.setLocalPosition(140,140,140),y.lookAt(new Pu(0,40,0)),y.addComponent("script"),y.script.create("orbitCamera",{attributes:{inertiaFactor:.2,focusEntity:n.root,distanceMax:400,frameOnStart:!1}}),y.script.create("orbitCameraInputMouse"),y.script.create("orbitCameraInputTouch"),n.root.addChild(y);var b=0;n.on("update",(function(e){b+=e,a.forEach((function(e,t){var n=t/a.length*Math.PI*2,i=30*Math.sin(.5*b+7*n)+70;e.setLocalPosition(30*Math.sin(n),i,30*Math.cos(n))})),i.forEach((function(e,t){var n=t/i.length*Math.PI*2;e.setLocalPosition(40*Math.sin(b+n),5,40*Math.cos(b+n)),e.lookAt(Pu.ZERO),e.rotateLocal(90,0,0)})),s&&s.setLocalEulerAngles(25,-30*b,0)}))},e.CATEGORY="Graphics",e.NAME="Clustered Lighting",e.ENGINE="PERFORMANCE",e}(),ZR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/camera/orbit-camera.js"}),N.createElement(dR,{name:"normal",type:"texture",url:"/static/assets/textures/normal-map.png"}),N.createElement(dR,{name:"xmas_negx",type:"texture",url:"/static/assets/cubemaps/xmas_faces/xmas_negx.png"}),N.createElement(dR,{name:"xmas_negy",type:"texture",url:"/static/assets/cubemaps/xmas_faces/xmas_negy.png"}),N.createElement(dR,{name:"xmas_negz",type:"texture",url:"/static/assets/cubemaps/xmas_faces/xmas_negz.png"}),N.createElement(dR,{name:"xmas_posx",type:"texture",url:"/static/assets/cubemaps/xmas_faces/xmas_posx.png"}),N.createElement(dR,{name:"xmas_posy",type:"texture",url:"/static/assets/cubemaps/xmas_faces/xmas_posy.png"}),N.createElement(dR,{name:"xmas_posz",type:"texture",url:"/static/assets/cubemaps/xmas_faces/xmas_posz.png"}))},e.prototype.controls=function(e){return N.createElement(N.Fragment,null,N.createElement(Lp,{headerText:"Settings"},N.createElement(Dp,{text:"Filter"},N.createElement(OR,{binding:new Up,link:{observer:e,path:"settings.shadowType"},type:"number",options:[{v:5,t:"PCF1"},{v:0,t:"PCF3"},{v:4,t:"PCF5"}]})),N.createElement(Dp,{text:"Shadow Res"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"settings.shadowAtlasResolution"},min:512,max:4096,precision:0})),N.createElement(Dp,{text:"Shadows On"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"settings.shadowsEnabled"},value:e.get("settings.shadowsEnabled")})),N.createElement(Dp,{text:"Cookies On"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"settings.cookiesEnabled"},value:e.get("settings.cookiesEnabled")}))))},e.prototype.example=function(e,t,n){var a=new jM(e,{});a.start(),a.scene.toneMapping=3,n.set("settings",{shadowAtlasResolution:1300,shadowType:0,shadowsEnabled:!0,cookiesEnabled:!0}),a.setCanvasFillMode("FILL_WINDOW"),a.setCanvasResolution("AUTO"),a.scene.clusteredLightingEnabled=!0;var i=a.scene.lighting;function s(e,n,i){var s=new cg;s.diffuse=new Mu(.7,.7,.7),s.normalMap=t.normal.resource,s.normalMapTiling.set(5,5),s.bumpiness=.7,s.shininess=40,s.metalness=.3,s.useMetalness=!0,s.update();var r=new KM;return r.addComponent("render",{type:e,material:s}),r.setLocalPosition(n),r.setLocalScale(i),a.root.addChild(r),r}i.cells=new Pu(16,12,16),i.maxLightsPerCell=12,i.shadowsEnabled=!0,i.cookiesEnabled=!0,i.shadowAtlasResolution=n.get("settings.shadowAtlasResolution"),i.cookieAtlasResolution=2048,s("box",new Pu(0,0,0),new Pu(800,2,800)),s("box",new Pu(0,400,0),new Pu(800,2,800)),s("box",new Pu(400,200,0),new Pu(2,400,800)),s("box",new Pu(-400,200,0),new Pu(2,400,800)),s("box",new Pu(0,200,400),new Pu(800,400,0)),s("box",new Pu(0,200,-400),new Pu(800,400,0));for(var r=0;r<7;r++){for(var o=25,l=r/7*Math.PI*2,c=r%2?340:210,h=0;h<=7;h++){s("box",new Pu(c*Math.sin(l),2+25*h,c*Math.cos(l)),new Pu(o,o,o)).setLocalEulerAngles(360*Math.random(),360*Math.random(),360*Math.random())}o-=1.5}var d=new f_("xmas_cubemap","cubemap",null,{textures:[t.xmas_posx.id,t.xmas_negx.id,t.xmas_posy.id,t.xmas_negy.id,t.xmas_posz.id,t.xmas_negz.id]});d.loadFaces=!0,a.assets.add(d);var p=[];for(r=0;r<10;r++){var u=new KM("Omni");u.addComponent("light",{type:"omni",color:Mu.WHITE,intensity:1,range:350,castShadows:!0,shadowBias:.2,normalOffsetBias:.2,cookieAsset:d,cookieChannel:"rgb"});var m=new cg;m.emissive=Mu.WHITE,m.update(),u.addComponent("render",{type:"sphere",material:m,castShadows:!1}),u.setPosition(0,120,0),u.setLocalScale(5,5,5),a.root.addChild(u),p.push(u)}var f=new KM;f.addComponent("camera",{fov:80,clearColor:new Mu(.1,.1,.1),farClip:1500}),f.setLocalPosition(300,120,25),f.addComponent("script"),f.script.create("orbitCamera",{attributes:{inertiaFactor:.2,focusEntity:a.root,distanceMax:1200,frameOnStart:!1}}),f.script.create("orbitCameraInputMouse"),f.script.create("orbitCameraInputTouch"),a.root.addChild(f),n.on("*:set",(function(e,t){var n=e.split(".");i[n[1]]=t}));var g=0;a.on("update",(function(e){g+=.3*e;for(var t=0;t<p.length;t++){var n=t/p.length*Math.PI*2;p[t].setPosition(250*Math.sin(g+n),190+150*Math.sin(g+n),250*Math.cos(g+n))}}))},e.CATEGORY="Graphics",e.NAME="Clustered Omni Shadows",e}(),$R=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/camera/orbit-camera.js"}),N.createElement(dR,{name:"channels",type:"texture",url:"/static/assets/textures/channels.png"}),N.createElement(dR,{name:"heart",type:"texture",url:"/static/assets/textures/heart.png"}),N.createElement(dR,{name:"normal",type:"texture",url:"/static/assets/textures/normal-map.png"}),N.createElement(dR,{name:"cubemap",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}))},e.prototype.controls=function(e){return N.createElement(N.Fragment,null,N.createElement(Lp,{headerText:"Atlas"},N.createElement(Dp,{text:"Resolution"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"settings.shadowAtlasResolution"},min:256,max:4096,precision:0})),N.createElement(Dp,{text:"Split"},N.createElement(OR,{binding:new Up,link:{observer:e,path:"settings.atlasSplit"},type:"number",options:[{v:0,t:"Automatic"},{v:1,t:"7 Shadows"},{v:2,t:"12 Shadows"},{v:3,t:"16 Shadows"}]})),N.createElement(Dp,{text:"Filter"},N.createElement(OR,{binding:new Up,link:{observer:e,path:"settings.shadowType"},type:"number",options:[{v:5,t:"PCF1"},{v:0,t:"PCF3"},{v:4,t:"PCF5"}]}))),N.createElement(Lp,{headerText:"Lights"},N.createElement(Dp,{text:"Shadows On"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"settings.shadowsEnabled"},value:e.get("settings.shadowsEnabled")})),N.createElement(Dp,{text:"Cookies On"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"settings.cookiesEnabled"},value:e.get("settings.cookiesEnabled")})),N.createElement(Dp,{text:"Static"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"settings.static"},value:e.get("settings.static")})),N.createElement(AR,{text:"Add Light",onClick:function(){return e.emit("add")}}),N.createElement(AR,{text:"Remove Light",onClick:function(){return e.emit("remove")}}),N.createElement(Dp,{text:"Light Count"},N.createElement(Pp,{binding:new Up,link:{observer:e,path:"settings.numLights"},value:e.get("settings.numLights")}))),N.createElement(Lp,{headerText:"Debug"},N.createElement(Dp,{text:"Cells"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"settings.debug"},value:e.get("settings.debug")})),N.createElement(Dp,{text:"Atlas"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"settings.debugAtlas"},value:e.get("settings.debugAtlas")}))))},e.prototype.example=function(e,t,n){var a=new jM(e,{});a.start(),n.set("settings",{shadowAtlasResolution:1024,shadowType:0,shadowsEnabled:!0,cookiesEnabled:!0,numLights:0,debug:!1,debugAtlas:!1,splitOptions:0,static:!1}),a.scene.skyboxMip=3,a.scene.skyboxIntensity=.1,a.scene.setSkybox(t.cubemap.resources),a.scene.clusteredLightingEnabled=!0;var i=a.scene.lighting;i.cells=new Pu(12,4,12);i.maxLightsPerCell=24,i.shadowsEnabled=!0,i.cookiesEnabled=!0,i.shadowAtlasResolution=n.get("settings.shadowAtlasResolution"),i.cookieAtlasResolution=1500;var s=[null,[2,1,1,2,1],[3,2],[4]],r=!1,o=!1;a.setCanvasFillMode("FILL_WINDOW"),a.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){a.resizeCanvas(e.width,e.height)}));var l=new cg;function c(e,t,n){var i=new KM;return i.addComponent("render",{type:e,castShadows:!0,material:l}),i.setLocalPosition(t),i.setLocalScale(n),a.root.addChild(i),i}l.shininess=25,l.metalness=.4,l.useMetalness=!0,l.normalMap=t.normal.resource,l.normalMapTiling.set(10,10),l.bumpiness=.5,l.update();for(var h=c("box",new Pu(0,0,0),new Pu(500,0,500)),d=0;d<8;d++){for(var p=12,u=d/8*Math.PI*2,m=0;m<=10;m++){var f=200*(1-m/12);c("box",new Pu(f*Math.sin(u),6*m,f*Math.cos(u)),new Pu(p,p,p)).setLocalEulerAngles(360*Math.random(),360*Math.random(),360*Math.random())}p-=1.5}var g=[],y=["r","g","b","a","rgb"];function b(e){var n=new Mu(1.5*Math.random(),1.5*Math.random(),1.5*Math.random(),1),i=new KM("Spot-".concat(e)),s=Math.random()<.5,o=s?t.heart:t.channels,l=s?"a":y[Math.floor(Math.random()*y.length)];i.addComponent("light",{type:"spot",color:n,intensity:3,innerConeAngle:30,outerConeAngle:35,range:150,castShadows:!0,shadowBias:.4,normalOffsetBias:.1,shadowResolution:512,shadowUpdateMode:r?1:2,cookie:o.resource,cookieChannel:l,cookieIntensity:.5});var c=new cg;c.emissive=n,c.update(),i.addComponent("render",{type:"cone",material:c,castShadows:!1}),i.setLocalScale(5,5,5),a.root.addChild(i),g.push(i)}for(d=0;d<10;d++)b(d);_();var v=new KM;function _(){n.set("settings.numLights",g.length),g.forEach((function(e){e.light.shadowUpdateMode=r?1:2}))}v.addComponent("camera",{clearColor:new Mu(.2,.2,.2),farClip:2e3,nearClip:1}),a.root.addChild(v),v.setLocalPosition(300*Math.sin(0),150,300*Math.cos(0)),v.addComponent("script"),v.script.create("orbitCamera",{attributes:{inertiaFactor:.2,focusEntity:h,distanceMax:1200,frameOnStart:!1}}),v.script.create("orbitCameraInputMouse"),v.script.create("orbitCameraInputTouch"),n.on("*:set",(function(e,t){var n=e.split(".");"static"===n[1]?(r=t,_()):"atlasSplit"===n[1]?i.atlasSplit=s[t]:"debug"===n[1]?i.debugLayer=t?a.scene.layers.getLayerByName("World").id:void 0:"debugAtlas"===n[1]?o=t:i[n[1]]=t})),n.on("add",(function(){g.length<24&&(b(g.length),_())})),n.on("remove",(function(){if(g.length){var e=g.pop();a.root.removeChild(e),e.destroy(),_()}}));var w=0;a.on("update",(function(e){r||(w+=.15*e);var t=new Pu;g.forEach((function(e,n){var a=n/g.length*Math.PI*2,i=130*Math.sin(a+w),s=130*Math.cos(a+w);t.set(i,100,s),e.setLocalPosition(t),t.y=0,e.lookAt(t,Pu.RIGHT),e.rotateLocal(90,0,0)})),o&&a.drawTexture(-.7,.2,.4,.4,a.renderer.lightTextureAtlas.cookieAtlas)}))},e.CATEGORY="Graphics",e.NAME="Clustered Spot Shadows",e.ENGINE="DEBUG",e}(),QR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"shader.vert",type:"shader",data:"\nattribute vec3 aPosition;\nattribute vec2 aUv;\n\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\n\nvarying vec2 texCoord;\n\nvoid main(void)\n{\n    // project the position\n    vec4 pos = matrix_model * vec4(aPosition, 1.0);\n    gl_Position = matrix_viewProjection * pos;\n\n\n    texCoord = aUv;\n}\n"}),N.createElement(dR,{name:"shader.frag",type:"shader",data:"\nprecision mediump float;\n\n// use the special texture_grabPass texture, which is a built-in texture. Each time this texture is used\n// for rendering, the engine will copy color framebuffer to it which represents already rendered scene\nuniform sampler2D texture_grabPass;\n\n// normal map providing offsets\nuniform sampler2D uOffsetMap;\n\n// roughness map\nuniform sampler2D uRoughnessMap;\n\n// engine built-in constant storing render target size in .xy and inverse size in .zw\nuniform vec4 uScreenSize;\n\nvarying vec2 texCoord;\n\nvoid main(void)\n{\n    float roughness = 1.0 - texture2D(uRoughnessMap, texCoord).r;\n\n    // sample offset texture - used to add distortion to the sampled background\n    vec2 offset = texture2D(uOffsetMap, texCoord).rg;\n    offset = 2.0 * offset - 1.0;\n\n    // offset strength\n    offset *= (0.2 + roughness) * 0.015;\n\n    // get normalized uv coordinates for canvas\n    vec2 grabUv = gl_FragCoord.xy * uScreenSize.zw;\n\n    // roughness dictates which mipmap level gets used, in 0..4 range\n    float mipmap = roughness * 5.0;\n\n    // get background pixel color with distorted offset\n    #ifdef GL2\n        // only webgl2 (and webgl1 extension - not handled here) supports reading specified mipmap\n        vec3 grabColor = texture2D(texture_grabPass, grabUv + offset, mipmap).rgb;\n    #else\n        vec3 grabColor = texture2D(texture_grabPass, grabUv + offset).rgb;\n    #endif\n\n    // brighten the refracted texture a little bit\n    // brighten even more the rough parts of the glass\n    gl_FragColor = vec4(grabColor * 1.1, 1.0) + roughness * 0.09;\n}\n"}),N.createElement(dR,{name:"normal",type:"texture",url:"/static/assets/textures/normal-map.png"}),N.createElement(dR,{name:"roughness",type:"texture",url:"/static/assets/textures/pc-gray.png"}),N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.skyboxMip=0,n.scene.exposure=2,n.scene.setSkybox(t["helipad.dds"].resources),n.scene.toneMapping=3;var a=n.scene.layers.getLayerByName("Immediate");function i(e,t,i,s){var r=new cg;r.diffuse=s,r.shininess=60,r.metalness=.4,r.useMetalness=!0,r.update();var o=new KM;return o.addComponent("render",{type:e,material:r,layers:[a.id]}),o.setLocalPosition(t),o.setLocalScale(i),n.root.addChild(o),o}a.opaqueSortMode=3;for(var s=[],r=["box","cone","cylinder","sphere","capsule"],o=0;o<7;o++){var l=r[Math.floor(Math.random()*r.length)],c=new Mu(Math.random(),Math.random(),Math.random()),h=2*Math.PI*o/7,d=new Pu(12*Math.sin(h),0,12*Math.cos(h));s.push(i(l,d,new Pu(4,8,4),c))}var p=new KM;p.addComponent("camera",{clearColor:new Mu(.2,.2,.2)}),n.root.addChild(p),p.setLocalPosition(0,10,20),p.lookAt(Pu.ZERO);var u=i("box",new Pu(1,3,0),new Pu(10,10,10),new Mu(1,1,1));u.render.castShadows=!1,u.render.receiveShadows=!1;var m=n.graphicsDevice.webgl2?"#define GL2\n":"",f={attributes:{aPosition:"POSITION",aUv:"TEXCOORD0"},vshader:t["shader.vert"].data,fshader:m+t["shader.frag"].data},g=new Jf;g.shader=new fm(n.graphicsDevice,f),u.render.material=g,g.setParameter("uOffsetMap",t.normal.resource),g.setParameter("uRoughnessMap",t.roughness.resource),g.update(),n.start();var y=0;n.on("update",(function(e){y+=e,s.forEach((function(e){e.rotate(.3,.2,.1)})),u.rotate(-.1,.1,-.15),p.setLocalPosition(20*Math.sin(.2*y),7,20*Math.cos(.2*y)),p.lookAt(new Pu(0,2,0))}))},e.CATEGORY="Graphics",e.NAME="Grab Pass",e}(),JR=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.scene.skyboxMip=2,n.scene.exposure=.3,n.scene.setSkybox(t["helipad.dds"].resources),n.scene.toneMapping=3,n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.ambientLight=new Mu(.1,.1,.1);var a=new KM;a.addComponent("camera",{}),n.root.addChild(a),a.translate(0,0,10);var i=new cg;i.onUpdateShader=function(e){return e.useInstancing=!0,e},i.shininess=60,i.metalness=.7,i.useMetalness=!0,i.update();var s=new KM;if(s.addComponent("render",{material:i,type:"cylinder"}),n.root.addChild(s),n.graphicsDevice.supportsInstancing){for(var r=1e3,o=new Float32Array(16e3),l=0,c=new Pu,h=new Gu,d=new Pu,p=new zu,u=0;u<r;u++){c.set(5*Math.random()-2.5,5*Math.random()-2.5,5*Math.random()-2.5),d.set(.1+.1*Math.random(),.1+.3*Math.random(),.1+.1*Math.random()),h.setFromEulerAngles(30*u,50*u,70*u),p.setTRS(c,h,d);for(var m=0;m<16;m++)o[l++]=p.data[m]}var f=new lm(n.graphicsDevice,hm.defaultInstancingFormat,r,0,o);s.render.meshInstances[0].setInstancing(f)}var g=0;n.on("update",(function(e){g+=.2*e,a.setLocalPosition(8*Math.sin(g),0,8*Math.cos(g)),a.lookAt(Pu.ZERO)}))},e.CATEGORY="Graphics",e.NAME="Hardware Instancing",e}(),eI=function(){function e(){}return e.prototype.example=function(e){var t=new jM(e,{});function n(e,t,n){var a=new cg;a.diffuse=new Mu(Math.random(),Math.random(),Math.random()),a.update();var i=new KM;return i.addComponent("render",{type:e,material:a}),i.setLocalPosition(t),i.setLocalScale(n),i}t.start(),t.setCanvasFillMode("FILL_WINDOW"),t.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){t.resizeCanvas(e.width,e.height)})),t.scene.ambientLight=new Mu(.2,.2,.2);var a=[];var i=new KM;t.root.addChild(i);!function e(t,i,s,r,o,l){if(l>=0)for(var c=o*(i-1)*.5,h=0;h<i;h++)for(var d=0;d<i;d++){var p=n(Math.random()<.5?"box":"sphere",new Pu(h*o-c,o,d*o-c),new Pu(s,s,s));t.addChild(p),a.push(p),e(p,i,s-r,r,.7*o,l-1)}}(i,2,1.7,.25,7,5),console.log("number of created entities: "+a.length);var s=new KM;s.addComponent("camera",{clearColor:new Mu(.1,.1,.1)}),s.setLocalPosition(90*Math.sin(0),40,90*Math.cos(0)),s.lookAt(new Pu(0,5,0)),t.root.addChild(s);var r=new KM;r.addComponent("light",{type:"omni",color:new Mu(1,1,1),range:150}),r.translate(40,60,50),t.root.addChild(r);var o=0;t.on("update",(function(e){o+=e;var t=new Gu;t.setFromEulerAngles(5*o,13*o,6*o);for(var n=0;n<a.length;n++)a[n].setLocalRotation(t)}))},e.CATEGORY="Graphics",e.NAME="Hierarchy",e}(),tI=function(){function e(){}return e.prototype.example=function(e){var t=new jM(e,{});t.start(),t.setCanvasFillMode("FILL_WINDOW"),t.setCanvasResolution("AUTO"),t.scene.ambientLight=new Mu(.2,.2,.2);var n=new rv({name:"Front Layer"}),a=t.scene.layers.getLayerByName("World"),i=t.scene.layers.getTransparentIndex(a);t.scene.layers.insert(n,i+1);var s=new KM;s.addComponent("camera",{clearColor:new Mu(.4,.45,.5),layers:[a.id,n.id]}),s.translate(0,0,24),t.root.addChild(s);var r=new KM;r.addComponent("light",{type:"omni",color:new Mu(1,1,1),range:100,layers:[a.id,n.id]}),r.translate(5,0,15),t.root.addChild(r);var o=new cg;o.diffuse.set(1,0,0),o.blendType=2,o.opacity=.5,o.update();var l=new cg;l.diffuse.set(0,0,1),l.depthTest=!1,l.update();var c=new KM;c.addComponent("model",{type:"box"}),c.model.material=o,c.setLocalScale(5,5,5),t.root.addChild(c);var h=new KM;h.addComponent("model",{type:"box",layers:[n.id]}),h.model.material=l,h.setLocalScale(2.5,2.5,2.5),t.root.addChild(h),t.on("update",(function(e){c&&c.rotate(0,10*e,0),h&&h.rotate(0,-10*e,0),h.model.meshInstances[0].layer=10}))},e.CATEGORY="Graphics",e.NAME="Layers",e}(),nI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"cubemap",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}),N.createElement(dR,{name:"house",type:"container",url:"/static/assets/models/house.glb"}),N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/camera/orbit-camera.js"}))},e.prototype.controls=function(e){return N.createElement(N.Fragment,null,N.createElement(Lp,{headerText:"Lightmap Filter Settings"},N.createElement(Dp,{text:"enable"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"data.settings.lightmapFilterEnabled"},value:e.get("data.settings.lightmapFilterEnabled")})),N.createElement(Dp,{text:"range"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"data.settings.lightmapFilterRange"},value:e.get("data.settings.lightmapFilterRange"),min:1,max:20,precision:0})),N.createElement(Dp,{text:"smoothness"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"data.settings.lightmapFilterSmoothness"},value:e.get("data.settings.lightmapFilterSmoothness"),min:.1,max:2,precision:1}))),N.createElement(Lp,{headerText:"Ambient light"},N.createElement(Dp,{text:"bake"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"data.ambient.ambientBake"},value:e.get("data.ambient.ambientBake")})),N.createElement(Dp,{text:"cubemap"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"data.ambient.cubemap"},value:e.get("data.ambient.cubemap")})),N.createElement(Dp,{text:"hemisphere"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"data.ambient.hemisphere"},value:e.get("data.ambient.hemisphere")})),N.createElement(Dp,{text:"samples"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"data.ambient.ambientBakeNumSamples"},value:e.get("data.ambient.ambientBakeNumSamples"),max:64,precision:0})),N.createElement(Dp,{text:"contrast"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"data.ambient.ambientBakeOcclusionContrast"},value:e.get("data.ambient.ambientBakeOcclusionContrast"),min:-1,max:1,precision:1})),N.createElement(Dp,{text:"brightness"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"data.ambient.ambientBakeOcclusionBrightness"},value:e.get("data.ambient.ambientBakeOcclusionBrightness"),min:-1,max:1,precision:1}))),N.createElement(Lp,{headerText:"Directional light"},N.createElement(Dp,{text:"enable"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"data.directional.enabled"},value:e.get("data.directional.enabled")})),N.createElement(Dp,{text:"bake"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"data.directional.bake"},value:e.get("data.directional.bake")})),N.createElement(Dp,{text:"samples"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"data.directional.bakeNumSamples"},value:e.get("data.directional.bakeNumSamples"),max:64,precision:0})),N.createElement(Dp,{text:"area"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"data.directional.bakeArea"},value:e.get("data.directional.bakeArea"),max:40,precision:0}))),N.createElement(Lp,{headerText:"Other lights"},N.createElement(Dp,{text:"enable"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"data.other.enabled"},value:e.get("data.other.enabled")}))),N.createElement(Lp,{headerText:"Bake stats"},N.createElement(Dp,{text:"duration"},N.createElement(Pp,{binding:new Up,link:{observer:e,path:"data.stats.duration"},value:e.get("data.stats.duration")}))))},e.prototype.example=function(e,t,n){var a=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body)});a.start(),a.setCanvasFillMode("FILL_WINDOW"),a.setCanvasResolution("AUTO"),a.scene.skyboxMip=3,a.scene.skyboxIntensity=.6,a.scene.setSkybox(t.cubemap.resources),a.scene.ambientLight=new Mu(.1,.3,.4);var i=t.house.resource.instantiateRenderEntity();i.setLocalScale(100,100,100),a.root.addChild(i),i.findComponents("render").forEach((function(e){e.castShadows=!0,e.castShadowsLightmap=!0,e.lightmapped=!0}));var s=new KM("Directional");s.addComponent("light",{type:"directional",affectDynamic:!0,affectLightmapped:!0,castShadows:!0,normalOffsetBias:.05,shadowBias:.2,shadowDistance:100,shadowResolution:2048,shadowType:0,color:new Mu(.7,.7,.5),intensity:1.6}),a.root.addChild(s),s.setLocalEulerAngles(-55,0,-30);var r=new KM("Omni");r.addComponent("light",{type:"omni",affectDynamic:!1,affectLightmapped:!0,bake:!0,castShadows:!0,normalOffsetBias:.05,shadowBias:.2,shadowDistance:25,shadowResolution:512,shadowType:0,color:Mu.YELLOW,range:25,intensity:.9}),r.setLocalPosition(-4,10,5),a.root.addChild(r);var o=new KM("Spot");o.addComponent("light",{type:"spot",affectDynamic:!1,affectLightmapped:!0,bake:!0,castShadows:!0,normalOffsetBias:.05,shadowBias:.2,shadowDistance:50,shadowResolution:512,shadowType:0,color:Mu.RED,range:10,intensity:2.5}),o.setLocalPosition(-5,10,-7.5),a.root.addChild(o);var l=new KM;l.addComponent("camera",{clearColor:new Mu(.4,.45,.5),farClip:100,nearClip:1}),l.setLocalPosition(40,20,40),l.addComponent("script"),l.script.create("orbitCamera",{attributes:{inertiaFactor:.2,focusEntity:i,distanceMax:60}}),l.script.create("orbitCameraInputMouse"),l.script.create("orbitCameraInputTouch"),a.root.addChild(l);a.scene.lightmapMode=0,a.scene.lightmapMaxResolution=1024,a.scene.lightmapSizeMultiplier=512;var c=!1;n.on("*:set",(function(e,n){var i=!0,l=e.split(".");"ambient"===l[1]?"cubemap"===l[2]?a.scene.setSkybox(n?t.cubemap.resources:null):"hemisphere"===l[2]?a.scene.ambientBakeSpherePart=n?.4:1:a.scene[l[2]]=n:"directional"===l[1]?s.light[l[2]]=n:"settings"===l[1]?a.scene[l[2]]=n:"other"===l[1]?(r.light[l[2]]=n,o.light[l[2]]=n):i=!1,c||(c=i)})),n.set("data",{settings:{lightmapFilterEnabled:!0,lightmapFilterRange:10,lightmapFilterSmoothness:.2},ambient:{ambientBake:!0,cubemap:!0,hemisphere:!0,ambientBakeNumSamples:20,ambientBakeOcclusionContrast:-.6,ambientBakeOcclusionBrightness:-.5},directional:{enabled:!0,bake:!0,bakeNumSamples:15,bakeArea:10},other:{enabled:!0},stats:{duration:""}}),a.on("update",(function(e){c&&(c=!1,a.lightmapper.bake(null,0),n.set("data.stats.duration",a.lightmapper.stats.totalRenderTime.toFixed(1)+"ms"))}))},e.CATEGORY="Graphics",e.NAME="Lights Baked AO",e}(),aI=function(){function e(){}return e.prototype.example=function(e){var t=new jM(e,{});t.start(),t.setCanvasFillMode("FILL_WINDOW"),t.setCanvasResolution("AUTO");for(var n=["box","cone","cylinder","sphere","capsule"],a=0;a<40;a++){var i=n[Math.floor(Math.random()*n.length)],s=new KM;s.addComponent("render",{castShadows:!1,castShadowsLightmap:!0,lightmapped:!0,type:i}),t.root.addChild(s),s.setLocalPosition(10*Math.random()-5,5*Math.random(),10*Math.random()-5)}var r=new KM;r.addComponent("render",{castShadows:!1,castShadowsLightmap:!1,lightmapped:!0,type:"plane"}),t.root.addChild(r),r.setLocalPosition(0,-1,0),r.setLocalScale(40,40,40);var o=new KM;o.addComponent("light",{affectDynamic:!1,affectLightmapped:!0,bake:!0,castShadows:!0,normalOffsetBias:.05,shadowBias:.2,shadowDistance:50,shadowResolution:2048,shadowType:0,color:Mu.GREEN,type:"directional"}),t.root.addChild(o),o.setLocalEulerAngles(45,30,0);var l=new KM;l.addComponent("light",{affectDynamic:!1,affectLightmapped:!0,bake:!0,castShadows:!0,normalOffsetBias:.05,shadowBias:.2,shadowDistance:50,shadowResolution:512,shadowType:0,color:Mu.RED,range:100,type:"point"}),l.setLocalPosition(0,2,0),t.root.addChild(l);var c=new KM;c.addComponent("camera",{clearColor:new Mu(.4,.45,.5),farClip:100,nearClip:.05}),t.root.addChild(c),t.scene.lightmapMode=0,t.scene.lightmapMaxResolution=2048,t.scene.lightmapSizeMultiplier=32,t.lightmapper.bake(null,0);var h=4;t.on("update",(function(e){h+=e,c.setLocalPosition(20*Math.sin(.4*h),3,6),c.lookAt(Pu.ZERO)}))},e.CATEGORY="Graphics",e.NAME="Lights Baked",e}(),iI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}),N.createElement(dR,{name:"heart",type:"texture",url:"/static/assets/textures/heart.png"}),N.createElement(dR,{name:"xmas_negx",type:"texture",url:"/static/assets/cubemaps/xmas_faces/xmas_negx.png"}),N.createElement(dR,{name:"xmas_negy",type:"texture",url:"/static/assets/cubemaps/xmas_faces/xmas_negy.png"}),N.createElement(dR,{name:"xmas_negz",type:"texture",url:"/static/assets/cubemaps/xmas_faces/xmas_negz.png"}),N.createElement(dR,{name:"xmas_posx",type:"texture",url:"/static/assets/cubemaps/xmas_faces/xmas_posx.png"}),N.createElement(dR,{name:"xmas_posy",type:"texture",url:"/static/assets/cubemaps/xmas_faces/xmas_posy.png"}),N.createElement(dR,{name:"xmas_posz",type:"texture",url:"/static/assets/cubemaps/xmas_faces/xmas_posz.png"}))},e.prototype.controls=function(e){return N.createElement(N.Fragment,null,N.createElement(Lp,{headerText:"OMNI LIGHT [KEY_1]"},N.createElement(Dp,{text:"enabled"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"lights.omni.enabled"}})),N.createElement(Dp,{text:"intensity"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"lights.omni.intensity"}})),N.createElement(Dp,{text:"cookie"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"lights.omni.cookieIntensity"}}))),N.createElement(Lp,{headerText:"SPOT LIGHT [KEY_2]"},N.createElement(Dp,{text:"enabled"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"lights.spot.enabled"}})),N.createElement(Dp,{text:"intensity"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"lights.spot.intensity"}})),N.createElement(Dp,{text:"cookie"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"lights.spot.cookieIntensity"}}))),N.createElement(Lp,{headerText:"DIRECTIONAL LIGHT [KEY_3]"},N.createElement(Dp,{text:"enabled"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"lights.directional.enabled"}})),N.createElement(Dp,{text:"intensity"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"lights.directional.intensity"}}))))},e.prototype.example=function(e,t,n){function a(e){var t=new cg;for(var n in e)t[n]=e[n];return t.update(),t}var i=new jM(e,{keyboard:new mL(window)});i.start(),i.setCanvasFillMode("FILL_WINDOW"),i.setCanvasResolution("AUTO"),i.scene.ambientLight=new Mu(.2,.2,.2);var s=t.statue.resource.instantiateRenderEntity();i.root.addChild(s);var r=new KM;r.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),r.translate(0,15,35),r.rotate(-14,0,0),i.root.addChild(r);var o=a({ambient:Mu.GRAY,diffuse:Mu.GRAY}),l=new KM;l.addComponent("render",{type:"box",material:o}),l.setLocalScale(70,1,70),l.setLocalPosition(0,-.5,0),i.root.addChild(l),n.set("lights",{spot:{enabled:!0,intensity:.8,cookieIntensity:1},omni:{enabled:!0,intensity:.8,cookieIntensity:1},directional:{enabled:!0,intensity:.8}});var c={};c.spot=new KM,c.spot.addComponent("light",lR({type:"spot",color:Mu.WHITE,innerConeAngle:30,outerConeAngle:31,range:100,castShadows:!0,shadowBias:.05,normalOffsetBias:.03,shadowResolution:2048,cookie:t.heart.resource,cookieChannel:"a"},n.get("lights.spot")));var h=new KM;h.addComponent("render",{type:"cone",castShadows:!1,material:a({emissive:Mu.WHITE})}),c.spot.addChild(h),i.root.addChild(c.spot);var d=new f_("xmas_cubemap","cubemap",null,{textures:[t.xmas_posx.id,t.xmas_negx.id,t.xmas_posy.id,t.xmas_negy.id,t.xmas_posz.id,t.xmas_negz.id]});d.loadFaces=!0,i.assets.add(d),c.omni=new KM,c.omni.addComponent("light",lR({type:"omni",color:Mu.YELLOW,castShadows:!0,range:111,cookieAsset:d,cookieChannel:"rgb"},n.get("lights.omni"))),c.omni.addComponent("render",{type:"sphere",castShadows:!1,material:a({diffuse:Mu.BLACK,emissive:Mu.YELLOW})}),i.root.addChild(c.omni),c.directional=new KM,c.directional.addComponent("light",lR({type:"directional",color:Mu.CYAN,range:100,shadowDistance:50,castShadows:!0,shadowBias:.1,normalOffsetBias:.2},n.get("lights.directional"))),i.root.addChild(c.directional),i.keyboard.on("keydown",(function(e){if("HTMLInputElement"!==e.element.constructor.name)switch(e.key){case 49:n.set("lights.omni.enabled",!n.get("lights.omni.enabled"));break;case 50:n.set("lights.spot.enabled",!n.get("lights.spot.enabled"));break;case 51:n.set("lights.directional.enabled",!n.get("lights.directional.enabled"))}}),this);var p=1;i.on("update",(function(e){p+=.3*e,s&&(c.spot.lookAt(new Pu(0,-5,0)),c.spot.rotateLocal(90,0,0),c.spot.setLocalPosition(15*Math.sin(p),25,15*Math.cos(p)),c.omni.setLocalPosition(5*Math.sin(-2*p),10,5*Math.cos(-2*p)),c.omni.rotate(0,50*e,0),c.directional.setLocalEulerAngles(45,-60*p,0))})),n.on("*:set",(function(e,t){var n=e.split(".");"enabled"===n[2]?c[n[1]].enabled=t:c[n[1]].light[n[2]]=t}))},e.CATEGORY="Graphics",e.NAME="Lights",e}(),sI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.scene.skyboxMip=2,n.scene.exposure=.2,n.scene.setSkybox(t["helipad.dds"].resources),n.scene.skyboxRotation=(new Gu).setFromEulerAngles(0,30,0),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO");var a=new KM;a.addComponent("camera",{clearColor:new Mu(.1,.1,.1)}),a.setLocalPosition(80,40,80),a.lookAt(new Pu(0,-35,0)),n.root.addChild(a);var i=new KM;i.addComponent("light",{type:"directional",color:Mu.WHITE,castShadows:!1}),n.root.addChild(i);for(var s=[],r=0;r<10;r++){var o=new KM;o.setLocalScale(4,4,4);var l=new cg;l.diffuse=new Mu(Math.random(),Math.random(),Math.random()),l.update(),o.addComponent("render",{type:r%2?"sphere":"cylinder",material:l}),r%2||o.setLocalScale(3,5,3),n.root.addChild(o),s.push(o)}function c(e,t,n){return 2*Math.sin(e+.2*t)+Math.cos(.2*e+.5*n+.2*t)}function h(e,t){e.lerp(Mu.GREEN,Mu.RED,Eu.clamp(.25*(t.y+3),0,1))}var d=0;n.on("update",(function(e){d+=e;for(var t=[],a=[],i=new Pu,r=new Pu,o=new Pu,l=new Mu,p=new Mu,u=new Mu,m=1;m<60;m++)for(var f=1;f<60;f++)i.set(m,c(d,m,f),f),r.set(m-1,c(d,m-1,f),f),o.set(m,c(d,m,f-1),f-1),h(l,i),h(p,r),h(u,o),m>1&&(t.push(i.x,i.y,i.z,r.x,r.y,r.z),a.push(l.r,l.g,l.b,l.a,p.r,p.g,p.b,p.a)),f>1&&(t.push(i.x,i.y,i.z,o.x,o.y,o.z),a.push(l.r,l.g,l.b,l.a,u.r,u.g,u.b,u.a));n.drawLineArrays(t,a);for(var g=[],y=[],b=0;b<10;b++){var v=b*Math.PI*2/10,_=s[b];_.setLocalPosition(30+20*Math.sin(.2*d+v),5+2*Math.sin(d+3*b/10),30+20*Math.cos(.2*d+v)),_.rotate((b+1)*e,4*(b+1)*e,6*(b+1)*e);var w=s[(b+1)%s.length];n.drawLine(_.getPosition(),w.getPosition(),Mu.MAGENTA),g.push(_.getPosition(),new Pu(0,10,0)),y.push(Mu.GRAY,Mu.GRAY)}n.drawLines(g,y)}))},e.CATEGORY="Graphics",e.NAME="Lines",e}(),rI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}),N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/arial.json"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.toneMapping=3,n.scene.skyboxMip=1;var a=new KM;a.addComponent("camera"),a.translate(0,6,6),a.rotate(-48,0,0),n.root.addChild(a);var i=new KM;i.addComponent("light",{type:"directional"}),n.root.addChild(i);var s=i.getLocalEulerAngles();i.setLocalEulerAngles(s.x+90,s.y-75,s.z),n.scene.setSkybox(t["helipad.dds"].resources);for(var r=function(e,t,a){var i=new cg;i.metalness=1,i.shininess=a/5*100,i.useMetalness=!0,i.anisotropy=-1*(2*e/10-1),i.enableGGXSpecular=!0,i.update();var s=new KM;s.addComponent("render",{material:i,type:"sphere"}),s.setLocalPosition(e-5,t,a-2.5),s.setLocalScale(.7,.7,.7),n.root.addChild(s)},o=function(e,t,a,i,s,r,o){var l=new KM;l.addComponent("element",{anchor:[.5,.5,.5,.5],fontAsset:e,fontSize:.5,pivot:[.5,.5],text:t,type:"text"}),l.setLocalPosition(a,i,s),l.setLocalEulerAngles(r,o,0),n.root.addChild(l)},l=0;l<6;l++)for(var c=0;c<11;c++)r(c,0,l);o(t.font,"Anisotropy",0,0,3.5,-90,0),o(t.font,"Roughness",-6,0,0,-90,90)},e.CATEGORY="Graphics",e.NAME="Material Anisotropic",e}(),oI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}),N.createElement(dR,{name:"normal",type:"texture",url:"/static/assets/textures/flakes5n.png"}),N.createElement(dR,{name:"diffuse",type:"texture",url:"/static/assets/textures/flakes5c.png"}),N.createElement(dR,{name:"other",type:"texture",url:"/static/assets/textures/flakes5o.png"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.toneMapping=3,n.scene.skyboxMip=1;var a=new KM;a.addComponent("camera"),a.translate(0,0,3),n.root.addChild(a);var i=new KM;i.addComponent("light",{type:"directional",color:new Mu(1,.8,.25)}),n.root.addChild(i),i.setLocalEulerAngles(85,-100,0),n.scene.setSkybox(t["helipad.dds"].resources);var s=function(e,t,a,i){var s=new KM;s.addComponent("render",{material:i,type:"sphere"}),s.setLocalPosition(e,t,a),s.setLocalScale(.7,.7,.7),n.root.addChild(s)},r=new cg;r.diffuseMap=t.diffuse.resource,r.metalnessMap=t.other.resource,r.metalnessMapChannel="r",r.glossMap=t.other.resource,r.glossMapChannel="g",r.normalMap=t.normal.resource,r.diffuse=new Mu(.6,.6,.9),r.diffuseTint=!0,r.metalness=1,r.shininess=90,r.bumpiness=.7,r.useMetalness=!0,r.update(),s(-.5,0,0,r);var o=new cg;o.diffuseMap=t.diffuse.resource,o.metalnessMap=t.other.resource,o.metalnessMapChannel="r",o.glossMap=t.other.resource,o.glossMapChannel="g",o.normalMap=t.normal.resource,o.diffuse=new Mu(.6,.6,.9),o.diffuseTint=!0,o.metalness=1,o.shininess=90,o.bumpiness=.7,o.useMetalness=!0,o.clearCoat=.25,o.clearCoatGlossiness=.9,o.update(),s(.5,0,0,o),n.start();var l=0;n.on("update",(function(e){l+=e,a.setLocalPosition(3*Math.sin(.5*l),0,3*Math.cos(.5*l)),a.lookAt(Pu.ZERO)}))},e.CATEGORY="Graphics",e.NAME="Material Clear Coat",e}(),lI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}),N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/arial.json"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.toneMapping=3,n.scene.skyboxMip=1;var a=new KM;a.addComponent("camera"),a.translate(0,0,9),n.root.addChild(a),n.scene.setSkybox(t["helipad.dds"].resources);for(var i=function(e,t,a){var i=new cg;i.metalness=t/4,i.shininess=e/4*100,i.useMetalness=!0,i.update();var s=new KM;s.addComponent("render",{material:i,type:"sphere"}),s.setLocalPosition(e-2,t-2,a),s.setLocalScale(.9,.9,.9),n.root.addChild(s)},s=function(e,t,a,i,s,r){var o=new KM;o.addComponent("element",{anchor:[.5,.5,.5,.5],fontAsset:e,fontSize:.5,pivot:[.5,.5],text:t,type:"text"}),o.setLocalPosition(a,i,s),o.setLocalEulerAngles(0,0,r),n.root.addChild(o)},r=0;r<5;r++)for(var o=0;o<5;o++)i(o,r,0);s(t.font,"Glossiness",0,-3,0,0),s(t.font,"Metalness",-3,0,0,90);var l=new yL(document.body),c=0,h=0,d=new Gu;l.on("mousemove",(function(e){e.buttons[0]&&(c+=e.dx,h+=e.dy,d.setFromEulerAngles(.2*h,.2*c,0),n.scene.skyboxRotation=d)}))},e.CATEGORY="Graphics",e.NAME="Material Physical",e}(),cI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}),N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/arial.json"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.toneMapping=3,n.scene.skyboxMip=1,n.scene.skyboxIntensity=1;var a=new KM;a.addComponent("camera"),a.translate(0,0,8),a.rotate(0,0,0),n.root.addChild(a);for(var i=0;i<3;i++){var s=new KM;s.addComponent("light",{type:"directional"}),n.root.addChild(s),s.rotateLocal(60+10*i,30+90*i,0)}n.scene.setSkybox(t["helipad.dds"].resources);var r=function(e,t,a){var i=new cg;i.diffuse=new Mu(.7,.7,.7),i.metalness=0,i.shininess=a/4*50+50,i.useMetalness=!0,i.blendType=2,i.opacity=e>=5?((e-5)/5+.2)*((e-5)/5+.2):(e/5+.2)*(e/5+.2),i.opacityFadesSpecular=!(e>=5),i.alphaWrite=!1,i.update();var s=new KM;s.addComponent("render",{material:i,type:"sphere"}),s.setLocalPosition(e-4.5,a-2,0),s.setLocalScale(.7,.7,.7),n.root.addChild(s)},o=function(e,t,a,i,s,r,o){var l=new KM;l.addComponent("element",{anchor:[.5,.5,.5,.5],fontAsset:e,fontSize:.5,pivot:[.5,.5],text:t,type:"text"}),l.setLocalPosition(a,i,s),l.setLocalEulerAngles(r,o,0),n.root.addChild(l)};for(i=0;i<5;i++)for(var l=0;l<10;l++)r(l,0,i);o(t.font,"Spec Fade On",-2.5,-3,0,-0,0),o(t.font,"Spec Fade Off",2.5,-3,0,-0,0)},e.CATEGORY="Graphics",e.NAME="Material Translucent Specular",e}(),hI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"spark",type:"texture",url:"/static/assets/textures/spark.png"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.ambientLight=new Mu(.2,.2,.2);var a=new cg;a.shininess=60,a.metalness=.3,a.useMetalness=!0,a.update();var i=new KM;i.addComponent("render",{type:"plane",material:a}),i.setLocalScale(new Pu(20,20,20)),i.setLocalPosition(new Pu(0,-.01,0)),n.root.addChild(i);var s=new KM;s.addComponent("light",{type:"omni",color:new Mu(.2,.2,.2),range:30,castShadows:!0,shadowBias:.1,normalOffsetBias:.2}),s.translate(0,8,0),n.root.addChild(s);var r=new KM;r.addComponent("camera",{clearColor:new Mu(.2,.2,.2)}),n.root.addChild(r),r.translate(0,10,20),r.lookAt(Pu.ZERO);var o=new KM;o.addComponent("render",{type:"sphere"}),n.root.addChild(o);for(var l=500,c=new Float32Array(6e3),h=new Uint8ClampedArray(8e3),d=[],p=0;p<l;p++)d.push(0,0,0,1,1,1,1,0);var u=[0,1,2,2,3,0],m=new Uint16Array(3e3);for(p=0;p<l;p++)m[6*p+0]=4*p+u[0],m[6*p+1]=4*p+u[1],m[6*p+2]=4*p+u[2],m[6*p+3]=4*p+u[3],m[6*p+4]=4*p+u[4],m[6*p+5]=4*p+u[5];function f(e,t,n,a){t&&e.setPositions(c),n&&e.setColors32(h),a&&(e.setIndices(m),e.setUvs(0,d)),e.update(4)}var g=new iy(n.graphicsDevice);g.clear(!0,!1),f(g,!0,!0,!0);var y=new cg;y.useLighting=!1,y.diffuse=new Mu(0,0,0),y.emissiveVertexColor=!0,y.blendType=1,y.depthWrite=!1,y.emissiveMap=t.spark.resource,y.update();var b=new Ay(g,y),v=new KM;v.addComponent("render",{type:"asset",meshInstances:[b],castShadows:!1}),n.root.addChild(v);var _=0,w=0;n.on("update",(function(e){var t=_;_+=e;var n=Math.abs(9*Math.sin(.55*_)),a=2*Math.cos(7*t),i=2*Math.cos(7*_);o.setLocalPosition(new Pu(n*Math.sin(_),.5+Math.abs(i),n*Math.cos(_)));var s=!1,r=!1;if((a<0&&i>=0||i<0&&a>=0)&&(!function(e,t){for(var n=.5+Math.random(),a=Math.random()*Math.PI,i=255*Math.random(),s=255*Math.random(),r=255*Math.random(),o=0;o<4;o++)h[16*e+4*o+0]=i,h[16*e+4*o+1]=s,h[16*e+4*o+2]=r,h[16*e+4*o+3]=0;c[12*e+0]=t.x+n*Math.sin(a),c[12*e+1]=0,c[12*e+2]=t.z+n*Math.cos(a),a+=.5*Math.PI,c[12*e+3]=t.x+n*Math.sin(a),c[12*e+4]=0,c[12*e+5]=t.z+n*Math.cos(a),a+=.5*Math.PI,c[12*e+6]=t.x+n*Math.sin(a),c[12*e+7]=0,c[12*e+8]=t.z+n*Math.cos(a),a+=.5*Math.PI,c[12*e+9]=t.x+n*Math.sin(a),c[12*e+10]=0,c[12*e+11]=t.z+n*Math.cos(a),a+=.5*Math.PI}(w,o.getLocalPosition()),++w>=l&&(w=0),s=!0,r=!0),Math.round(_)!=Math.round(t)){for(var d=0;d<h.length;d++)h[d]-=2;r=!0}f(g,s,r)})),n.start()},e.CATEGORY="Graphics",e.NAME="Mesh Decals",e}(),dI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}),N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.skyboxMip=2,n.scene.exposure=1,n.scene.setSkybox(t["helipad.dds"].resources);var a=new KM;a.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),a.translate(0,7,24),n.root.addChild(a);var i=t.statue.resource.instantiateRenderEntity();n.root.addChild(i);var s=[];i.findComponents("render").forEach((function(e){for(var t=e.meshInstances,n=0;n<t.length;n++){var a=t[n].mesh,i=[];a.getPositions(i),s.push({mesh:a,srcPositions:i})}})),n.start();var r=[],o=0;n.on("update",(function(e){if(o+=e,i){a.setLocalPosition(25*Math.sin(.2*o),15,25*Math.cos(.2*o)),a.lookAt(new Pu(0,7,0));for(var t=0;t<s.length;t++){r.length=0;for(var n=s[t].srcPositions,l=0;l<n.length;l+=3)r[l]=n[l]+50*Math.sin(o+.01*n[l+1]),r[l+1]=n[l+1],r[l+2]=n[l+2]+50*Math.sin(o+.01*n[l+1]);var c=s[t].mesh;c.setPositions(r),c.update()}}}))},e.CATEGORY="Graphics",e.NAME="Mesh Deformation",e}(),pI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"playcanvasGrey",type:"texture",url:"/static/assets/textures/playcanvas-grey.png"}))},e.prototype.example=function(e,t){var n=new jM(e,{});function a(e,t){var a=new KM;a.addComponent("light",{type:"omni",color:e,radius:10,castShadows:!1});var i=new cg;return i.emissive=e,i.update(),a.addComponent("render",{type:"sphere",material:i}),a.setLocalScale(t,t,t),n.root.addChild(a),a}n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.ambientLight=new Mu(.1,.1,.1);var i=[{radius:7,speed:1,scale:2.5,light:a(new Mu(.3,.9,.6),1)},{radius:3,speed:1.2,scale:3,light:a(new Mu(.7,.2,.3),1.3)},{radius:5,speed:-.8,scale:4,light:a(new Mu(.2,.2,.9),1.5)},{radius:4,speed:-.3,scale:5.5,light:a(new Mu(.8,.9,.4),1.7)}],s=new KM;s.addComponent("camera",{clearColor:new Mu(.2,.2,.2)}),n.root.addChild(s),s.translate(0,5,20),s.lookAt(Pu.ZERO);for(var r=60,o=20/r,l=new Float32Array(10800),c=new Float32Array(7200),h=0,d=0;d<r;d++)for(var p=0;p<r;p++)l[3*h]=o*(d-30),l[3*h+1]=0,l[3*h+2]=o*(p-30),c[2*h]=d/r,c[2*h+1]=1-p/r,h++;var u=[];for(d=0;d<59;d++)for(var m=0;m<59;m++)u.push(d*r+m+1,(d+1)*r+m,d*r+m,(d+1)*r+m,d*r+m+1,(d+1)*r+m+1);function f(e,t){e.setPositions(l),e.setNormals(ry(l,u)),t&&(e.setUvs(0,c),e.setIndices(u)),e.update(4)}var g=new iy(n.graphicsDevice);g.clear(!0,!1),f(g,!0);var y=new cg;y.diffuseMap=t.playcanvasGrey.resource,y.shininess=50,y.metalness=.3,y.useMetalness=!0,y.update();var b=new Ay(g,y),v=new KM;v.addComponent("render",{meshInstances:[b]}),n.root.addChild(v);var _=0;n.on("update",(function(e){_+=e;for(var t=[],n=0;n<i.length;n++){var a=i[n],s=new Du(a.radius*Math.sin(_*a.speed),a.radius*Math.cos(_*a.speed));t.push(s),a.light.setLocalPosition(s.x,3,s.y)}for(var o=0,c=0;c<r;c++)for(var h=0;h<r;h++){var d=0;for(n=0;n<t.length;n++){var p=l[o]-t[n].x,u=l[o+2]-t[n].y,m=Math.sqrt(p*p+u*u);m=Eu.clamp(m,0,i[n].scale),d+=1-(m=Eu.smoothstep(0,i[n].scale,m))}l[o+1]=d,o+=3}f(g)})),n.start()},e.CATEGORY="Graphics",e.NAME="Mesh Generation",e}(),uI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.scene.skyboxMip=2,n.scene.exposure=.6,n.scene.setSkybox(t["helipad.dds"].resources),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO");var a=new KM;a.addComponent("light",{type:"directional",castShadows:!0,shadowBias:.5,shadowDistance:25,color:new Mu(.5,.5,.5)}),n.root.addChild(a),a.setLocalEulerAngles(45,45,0);var i=new KM;i.addComponent("camera",{clearColor:new Mu(.1,.1,.1)}),n.root.addChild(i),i.setLocalPosition(0,4,14),i.lookAt(Pu.ZERO);var s=function(e,t,n,a,i,s,r){return(r=Math.abs(a*e+i*t+s*n+r))/Math.sqrt(a*a+i*i+s*s)},r=function(e,t,n,a,i,r,o){var l,c,h,d=new Float32Array(e.length),p=.2+.5*Math.random(),u=1+2*Math.random();for(c=0;c<e.length;c+=3)l=s(e[c],e[c+1],e[c+2],i,r,o,a),h=1-(h=Eu.smoothstep(0,p,l)),h*=u,d[c]=e[c]+t[c]*h,d[c+1]=e[c+1]+t[c+1]*h,d[c+2]=e[c+2]+t[c+2]*h;var m=new Float32Array(ry(d,n));for(c=0;c<m.length;c++)d[c]-=e[c],m[c]-=t[c];return new Zv({deltaPositions:d,deltaNormals:m})},o=hy(n.graphicsDevice,{height:10,heightSegments:200,capSegments:100}),l=[],c=[],h=[];o.getPositions(l),o.getNormals(c),o.getIndices(h);for(var d=[],p=-4.5,u=(4.5-p)/11,m=0;m<12;m++)d.push(r(l,c,h,p,0,1,0)),p+=u;o.morph=new Pv(d,n.graphicsDevice);var f=new cg;f.shininess=50,f.metalness=.3,f.useMetalness=!0,f.update();var g=new Ay(o,f),y=new kv(o.morph);g.morphInstance=y;var b=new KM;b.addComponent("render",{material:f,meshInstances:[g]}),b.setLocalPosition(0,0,0),n.root.addChild(b);var v=0;n.on("update",(function(e){v+=e;for(var t=0;t<d.length;t++)y.setWeight(t,Math.abs(Math.sin(2*v*(t+5)/d.length)))}))},e.CATEGORY="Graphics",e.NAME="Mesh Morph Many",e}(),mI=function(){function e(){}return e.prototype.example=function(e){var t=new jM(e,{});t.start(),t.setCanvasFillMode("FILL_WINDOW"),t.setCanvasResolution("AUTO");var n=new KM;n.addComponent("light",{type:"directional"}),t.root.addChild(n),n.setLocalEulerAngles(45,30,0);var a=new KM;a.addComponent("camera",{clearColor:new Mu(.1,.1,.1)}),t.root.addChild(a);for(var i=function(e,t,n,a,i,s){return Math.abs(a*e+i*t+s*n)/Math.sqrt(a*a+i*i+s*s)},s=function(e,t,n,a,s,r){var o,l,c,h=new Float32Array(e.length);for(l=0;l<e.length;l+=3)o=i(e[l],e[l+1],e[l+2],a,s,r),c=1-(c=Eu.smoothstep(0,.2,o)),h[l]=e[l]+t[l]*c,h[l+1]=e[l+1]+t[l+1]*c,h[l+2]=e[l+2]+t[l+2]*c;var d=new Float32Array(ry(h,n));for(l=0;l<d.length;l++)h[l]-=e[l],d[l]-=t[l];return new Zv({deltaPositions:h,deltaNormals:d})},r=function(e,n,a){var i=dy(t.graphicsDevice,{latitudeBands:200,longitudeBands:200}),r=[],o=[],l=[];i.getPositions(r),i.getNormals(o),i.getIndices(l);var c=[];c.push(s(r,o,l,1,0,0)),c.push(s(r,o,l,0,1,0)),c.push(s(r,o,l,0,0,1)),i.morph=new Pv(c,t.graphicsDevice);var h=new cg,d=new Ay(i,h),p=new kv(i.morph);d.morphInstance=p;var u=new KM;return u.setLocalPosition(e,n,a),t.root.addChild(u),u.addComponent("render",{material:h,meshInstances:[d]}),p},o=[],l=0;l<3;l++)o.push(r(6*Math.random()-3,6*Math.random()-3,6*Math.random()-3));var c=0;t.on("update",(function(e){c+=e;for(var t=0;t<o.length;t++)o[t].setWeight(0,Math.abs(Math.sin(c+t))),o[t].setWeight(1,Math.abs(Math.sin(.3*c+t))),o[t].setWeight(2,Math.abs(Math.sin(.7*c+t)));a.setLocalPosition(16*Math.sin(.2*c),4,16*Math.cos(.2*c)),a.lookAt(Pu.ZERO)}))},e.CATEGORY="Graphics",e.NAME="Mesh Morph",e}(),fI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.ambientLight=new Mu(.2,.2,.2),n.start();var a=t.statue.resource.instantiateModelEntity({castShadows:!0});n.root.addChild(a);var i=a.clone();i.setLocalScale(.2,.2,.2),i.setLocalPosition(-4,12,0),n.root.addChild(i);var s=new KM;s.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),s.translate(0,7,24),n.root.addChild(s);var r=new KM;r.addComponent("light",{type:"omni",color:new Mu(1,1,1),range:100,castShadows:!0}),r.translate(5,0,15),n.root.addChild(r),n.on("update",(function(e){a&&a.rotate(0,10*e,0)}))},e.CATEGORY="Graphics",e.NAME="Model Asset",e}(),gI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"outline",type:"script",url:"/static/scripts/posteffects/posteffect-outline.js"}))},e.prototype.example=function(e){var t=new jM(e,{});function n(e,n,a,i,s){var r=new cg;r.diffuse=i,r.update();var o=new KM;return o.addComponent("render",{type:e,layers:s,material:r}),o.setLocalPosition(n),o.setLocalScale(a),t.root.addChild(o),o}t.start(),t.setCanvasFillMode("FILL_WINDOW"),t.setCanvasResolution("AUTO"),t.scene.ambientLight=new Mu(.2,.2,.2);var a=new Gm(t.graphicsDevice,{width:t.graphicsDevice.width,height:t.graphicsDevice.height,format:7,mipmaps:!0,minFilter:1,magFilter:1}),i=new Cg({colorBuffer:a,depth:!0}),s=new rv({name:"OutlineLayer"});t.scene.layers.insert(s,0),s.renderTarget=i;var r=t.scene.layers.getLayerByName("World");n("plane",new Pu(0,0,0),new Pu(20,20,20),new Mu(.3,.5,.3),[r.id]),n("sphere",new Pu(-2,1,0),new Pu(2,2,2),new Mu(1,0,0),[r.id]),n("box",new Pu(2,1,0),new Pu(2,2,2),new Mu(1,1,0),[r.id,s.id]),n("cone",new Pu(0,1,-2),new Pu(2,2,2),new Mu(0,1,1),[r.id]);var o=new KM;o.addComponent("camera",{clearColor:new Mu(.2,.2,.4),layers:[r.id]}),o.translate(0,20,25),o.lookAt(Pu.ZERO);var l=new KM;l.addComponent("camera",{clearColor:new Mu(0,0,0,0),layers:[s.id]}),t.root.addChild(l);var c=new OutlineEffect(t.graphicsDevice,3);c.color=new Mu(0,.5,1,1),c.texture=a,o.camera.postEffects.addEffect(c),t.root.addChild(o);var h=new KM;h.addComponent("light",{type:"omni",color:new Mu(1,1,1),range:200,castShadows:!0,layers:[r.id]}),h.translate(0,2,5),t.root.addChild(h),window.addEventListener("resize",(function(){t.resizeCanvas(e.width,e.height),o.camera.postEffects.removeEffect(c),t.scene.layers.remove(s),a.destroy(),a=new Gm(t.graphicsDevice,{width:t.graphicsDevice.width,height:t.graphicsDevice.height,format:7,mipmaps:!0,minFilter:1,magFilter:1}),i.destroy(),i=new Cg({colorBuffer:a,depth:!0}),s.renderTarget=i,t.scene.layers.insert(s,0),c.texture=a,o.camera.postEffects.addEffect(c)}));var d=0;t.on("update",(function(e){d+=e,o.setLocalPosition(12*Math.sin(d),5,12*Math.cos(d)),o.lookAt(Pu.ZERO),l.setLocalPosition(12*Math.sin(d),5,12*Math.cos(d)),l.lookAt(Pu.ZERO)}))},e.CATEGORY="Graphics",e.NAME="Model Outline",e}(),yI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"clouds",type:"texture",url:"/static/assets/textures/clouds.jpg"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.ambientLight=new Mu(.2,.2,.2);var a=new KM;a.addComponent("model",{type:"box"});var i=new KM;i.addComponent("light",{type:"omni",color:new Mu(1,0,0),radius:10}),i.addComponent("model",{type:"sphere"}),i.setLocalScale(.1,.1,.1);var s=new KM;s.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),n.root.addChild(a),n.root.addChild(i),n.root.addChild(s),s.translate(0,0,10);var r=0;n.on("update",(function(e){(r+=e)>360&&(r=0),i.setLocalPosition(3*Math.sin(r),0,3*Math.cos(r)),a.setEulerAngles(2*r,4*r,8*r)}));var o=new cg;o.diffuseMap=t.clouds.resource,o.update(),a.model.material=o},e.CATEGORY="Graphics",e.NAME="Model Textured Box",e}(),bI=function(){function e(){}return e.prototype.example=function(e){var t=new jM(e,{});function n(e,n,a,i,s){var r=new KM;return r.addComponent("render",{type:e,layers:i,material:s,castShadows:!1,receiveShadows:!1}),r.setLocalPosition(n),r.setLocalScale(a),t.root.addChild(r),r}t.start(),t.setCanvasFillMode("FILL_WINDOW"),t.setCanvasResolution("AUTO");var a=new Gm(t.graphicsDevice,{width:1024,height:1024,format:6,mipmaps:!1,minFilter:1,magFilter:1}),i=new Cg({colorBuffer:a,depth:!1}),s=new rv({name:"paintLayer"});t.scene.layers.insert(s,0);var r=new cg;r.emissiveTint=!0,r.useLighting=!1,r.update();var o=[];function l(){var e;return 0===o.length?e=n("sphere",new Pu(2,1,0),new Pu(1,1,1),[s.id],r):(e=o.pop()).enabled=!0,e}var c=new KM;c.addComponent("camera",{clearColorBuffer:!1,projection:1,layers:[s.id],renderTarget:i,priority:-1}),c.setLocalPosition(0,0,-10),c.lookAt(Pu.ZERO),t.root.addChild(c);var h=new KM;h.addComponent("camera",{clearColor:new Mu(.2,.2,.2)}),h.translate(0,0,30),h.lookAt(Pu.ZERO),t.root.addChild(h);var d=new cg;d.emissiveMap=a,d.useLighting=!1,d.update();var p,u,m,f=t.scene.layers.getLayerByName("World"),g=n("box",new Pu(0,0,0),new Pu(15,15,15),[f.id],d),y=1,b=new Pu,v=[];t.on("update",(function(e){for(y>=1&&(y=0,u=new Pu(20*Math.random()-10,20*Math.random()-10,0),m=new Pu(20*Math.random()-10,20*Math.random()-10,0),p=.1+Math.random(),r.emissive=new Mu(Math.random(),Math.random(),Math.random()),r.update());v.length>0;){var t=v.pop();t.enabled=!1,o.push(t)}for(var n=0;n<30;n++){b.lerp(u,m,y);var a=l();a.setLocalPosition(b),a.setLocalScale(p,p,p),v.push(a),y+=.005}g.rotate(5*e,10*e,15*e)}))},e.CATEGORY="Graphics",e.NAME="Painter",e}(),vI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"particlesNumbers",type:"texture",url:"/static/assets/textures/particles-numbers.png"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO");var a=new KM;a.addComponent("camera",{clearColor:new Mu(.75,.75,.75)}),a.rotateLocal(0,0,0),a.translateLocal(0,0,20);var i=new KM;i.addComponent("light",{type:"directional",color:new Mu(1,1,1),intensity:1}),i.setLocalEulerAngles(45,0,0);var s=new KM;s.addComponent("screen",{resolution:new Du(640,480),screenSpace:!0}),s.screen.scaleMode="blend",s.screen.referenceResolution=new Du(1280,720);var r=new KM;s.addChild(r),n.root.addChild(a),n.root.addChild(i),n.root.addChild(s);var o=new KM;n.root.addChild(o),o.setLocalPosition(-3,3,0);var l=new KM;n.root.addChild(l),l.setLocalPosition(3,3,0);var c=new KM;n.root.addChild(c),c.setLocalPosition(-3,-3,0);var h=new KM;n.root.addChild(h),h.setLocalPosition(3,-3,0);var d,p=new Ru([0,0,1,1]),u={numParticles:8,lifetime:4,rate:.5,colorMap:t.particlesNumbers.resource,initialVelocity:.25,emitterShape:1,emitterRadius:.1,animLoop:!0,animTilesX:4,animTilesY:4,animSpeed:1,autoPlay:!0,scaleGraph:p};d=Object.assign(u,{animNumFrames:4,animIndex:0}),o.addComponent("particlesystem",d),d=Object.assign(u,{animNumFrames:4,animIndex:1}),l.addComponent("particlesystem",d),d=Object.assign(u,{animNumFrames:4,animIndex:2}),c.addComponent("particlesystem",d),d=Object.assign(u,{animNumFrames:4,animIndex:3}),h.addComponent("particlesystem",d),r.addComponent("element",{anchor:new Ou(.5,.5,.5,.5),pivot:new Du(.5,.5),width:100,height:100,type:"image",textureAsset:t.particlesNumbers}),n.start()},e.CATEGORY="Graphics",e.NAME="Particles: Anim Index",e}(),_I=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"particlesCoinsTexture",type:"texture",url:"/static/assets/textures/particles-coins.png"}),N.createElement(dR,{name:"particlesBonusTexture",type:"texture",url:"/static/assets/textures/particles-bonus.png"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)}),a=new KM;a.addComponent("camera",{clearColor:new Mu(.23,.5,.75)}),a.rotateLocal(0,0,0),a.translateLocal(0,0,20);var i=new KM;i.addComponent("light",{type:"directional",color:new Mu(1,1,1),intensity:1}),i.setLocalEulerAngles(45,0,0);var s=new KM;s.addComponent("screen",{resolution:new Du(640,480),screenSpace:!0}),s.screen.scaleMode="blend",s.screen.referenceResolution=new Du(1280,720);var r=new KM;s.addChild(r);var o=new KM;s.addChild(o),n.root.addChild(a),n.root.addChild(i),n.root.addChild(s);var l=new KM;n.root.addChild(l),l.setLocalPosition(-3,3,0);var c=new KM;n.root.addChild(c),c.setLocalPosition(3,3,0);var h=new Ru([0,.1,1,.5]),d=new Ru([0,0,.5,1,1,0]),p=function(e,t,n){return{numParticles:32,lifetime:2,rate:.2,colorMap:e.resource,initialVelocity:.125,emitterShape:1,emitterRadius:2,animLoop:!0,animTilesX:t,animTilesY:n,animSpeed:4,autoPlay:!0,alphaGraph:d,scaleGraph:h}};l.addComponent("particlesystem",Object.assign(p(t.particlesCoinsTexture,4,6),{animNumAnimations:4,animNumFrames:6,randomizeAnimIndex:!0})),r.addComponent("element",{anchor:new Ou(.5,.5,.5,.5),pivot:new Du(1.75,1),width:150,height:225,type:"image",textureAsset:t.particlesCoinsTexture}),c.addComponent("particlesystem",Object.assign(p(t.particlesBonusTexture,4,2),{animNumAnimations:7,animNumFrames:1,randomizeAnimIndex:!0})),o.addComponent("element",{anchor:new Ou(.5,.5,.5,.5),pivot:new Du(-.5,1),width:200,height:100,type:"image",textureAsset:t.particlesBonusTexture}),n.start()},e.CATEGORY="Graphics",e.NAME="Particles: Random Sprites",e}(),wI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"snowflake",type:"texture",url:"/static/assets/textures/snowflake.png"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO");var a=new KM;a.addComponent("camera",{clearColor:new Mu(0,0,0)}),a.rotateLocal(0,0,0),a.translateLocal(0,0,10);var i=new KM;i.addComponent("light",{type:"directional",color:new Mu(1,1,1),intensity:1}),i.setLocalEulerAngles(45,0,0),n.root.addChild(a),n.root.addChild(i);var s=new Iu([[0,0],[0,-.7],[0,0]]),r=new Iu([[0,0],[0,-.4],[0,0]]),o=new Ru([0,100]),l=new Ru([0,-100]),c=new Ru([0,.1]),h=new KM;n.root.addChild(h),h.setLocalPosition(0,3,0),n.assets.loadFromUrl("/static/assets/textures/snowflake.png","texture",(function(e,n){h.addComponent("particlesystem",{numParticles:100,lifetime:10,rate:.1,startAngle:360,startAngle2:-360,emitterExtents:new Pu(5,0,0),velocityGraph:s,velocityGraph2:r,scaleGraph:c,rotationSpeedGraph:o,rotationSpeedGraph2:l,colorMap:t.snowflake.resource})}))},e.CATEGORY="Graphics",e.NAME="Particles: Snow",e}(),xI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"spark",type:"texture",url:"/static/assets/textures/spark.png"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO");var a=new KM;a.addComponent("camera",{clearColor:new Mu(0,0,.05)}),a.rotateLocal(0,0,0),a.translateLocal(0,0,10);var i=new KM;i.addComponent("light",{type:"directional",color:new Mu(1,1,1),intensity:1}),i.setLocalEulerAngles(45,0,0),n.root.addChild(a),n.root.addChild(i),new Iu([[0,0,1,4],[0,0,1,3],[0,0,1,0]]).type=0;var s=new Iu([[0,0,1,8],[0,0,1,6],[0,0,1,0]]),r=new Iu([[0,0,1,-8],[0,0,1,-6],[0,0,1,0]]),o=new Iu([[0,0],[0,0,.2,6,1,-48],[0,0]]),l=new Ru([0,0,.5,.3,.8,.2,1,.1]),c=new Ru([0,360]),h=new Iu([[0,1,.25,1,.375,.5,.5,0],[0,0,.125,.25,.25,.5,.375,.75,.5,1],[0,0,1,0]]),d=new KM;n.root.addChild(d),d.setLocalPosition(0,0,0),d.addComponent("particlesystem",{numParticles:200,lifetime:2,rate:.01,scaleGraph:l,rotationSpeedGraph:c,colorGraph:h,colorMap:t.spark.resource,velocityGraph:o,localVelocityGraph:s,localVelocityGraph2:r})},e.CATEGORY="Graphics",e.NAME="Particles: Spark",e}(),CI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"shader.vert",type:"shader",data:"\n// Attributes per vertex: position\nattribute vec4 aPosition;\n\nuniform mat4   matrix_viewProjection;\nuniform mat4   matrix_model;\n\n// position of the camera\nuniform vec3 view_position;\n\n// Color to fragment program\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    // Transform the geometry\n    mat4 modelViewProj = matrix_viewProjection * matrix_model;\n    gl_Position = modelViewProj * aPosition;\n\n    // vertex in world space\n    vec4 vertexWorld = matrix_model * aPosition;\n\n    // point sprite size depends on its distance to camera\n    float dist = 25.0 - length(vertexWorld.xyz - view_position);\n    gl_PointSize = clamp(dist * 2.0 - 1.0, 1.0, 15.0);\n\n    // color depends on position of particle\n    outColor = vec4(vertexWorld.y * 0.1, 0.1, vertexWorld.z * 0.1, 1);\n}\n"}),N.createElement(dR,{name:"shader.frag",type:"shader",data:"\nprecision mediump float;\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    // color supplied by vertex shader\n    gl_FragColor = outColor;\n\n    // make point round instead of square - make pixels outside of the circle black, using provided gl_PointCoord\n    vec2 dist = gl_PointCoord.xy - vec2(0.5, 0.5);\n    gl_FragColor.a = 1.0 - smoothstep(0.4, 0.5, sqrt(dot(dist, dist)));\n\n}\n"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO");var a=new KM;a.addComponent("camera",{clearColor:new Mu(0,0,0)}),n.root.addChild(a);for(var i=1e5,s=1e4,r=new Float32Array(3e5),o=new Float32Array(3e5),l=0;l<3e5;l++)r[l]=2*Math.random()-1,o[l]=r[l]+.04*Math.random()-.01;function c(e){e.setPositions(r,3,s),e.update(0,!1)}var h=new iy(n.graphicsDevice);h.clear(!0),c(h),h.aabb=new qu(new Pu(0,0,0),new Pu(15,15,15));var d=new fm(n.graphicsDevice,{attributes:{aPosition:"POSITION"},vshader:t["shader.vert"].data,fshader:t["shader.frag"].data}),p=new Jf;p.shader=d,p.blendType=6,p.depthWrite=!1;var u=new Ay(h,p),m=new KM;m.addComponent("render",{type:"asset",meshInstances:[u],material:p,castShadows:!1}),n.root.addChild(m);var f,g=0;n.on("update",(function(e){f=g,g+=e;for(var t=new Pu,n=new Pu,l=new Pu,d=new Pu,p=0;p<i;p++)n.set(o[3*p],o[3*p+1],o[3*p+2]),t.set(r[3*p],r[3*p+1],r[3*p+2]),l.sub2(t,n),d.add2(t,l),d.length()>15&&d.copy(n),r[3*p]=d.x,r[3*p+1]=d.y,r[3*p+2]=d.z,o[3*p]=t.x,o[3*p+1]=t.y,o[3*p+2]=t.z;Math.round(g)!==Math.round(f)&&(s=Math.floor(5e4+Math.random()*i-5e4)),c(h);var u=.2*g,m=new Pu(20*Math.sin(u),10,20*Math.cos(u));a.setLocalPosition(m),a.lookAt(Pu.ZERO)}))},e.CATEGORY="Graphics",e.NAME="Point Cloud Simulation",e}(),TI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}),N.createElement(dR,{name:"shader.vert",type:"shader",data:"\n// Attributes per vertex: position\nattribute vec4 aPosition;\n\nuniform mat4   matrix_viewProjection;\nuniform mat4   matrix_model;\nuniform mat4   matrix_view;\n\n// time\nuniform float uTime;\n\n// Color to fragment program\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    // Transform the geometry\n    mat4 modelView = matrix_view * matrix_model;\n    mat4 modelViewProj = matrix_viewProjection * matrix_model;\n    gl_Position = modelViewProj * aPosition;\n\n    // vertex in world space\n    vec4 vertexWorld = matrix_model * aPosition;\n\n    // use sine way to generate intensity value based on time and also y-coordinate of model\n    float intensity = abs(sin(0.6 * vertexWorld.y + uTime * 1.0));\n\n    // intensity smoothly drops to zero for smaller values than 0.9\n    intensity = smoothstep(0.9, 1.0, intensity);\n\n    // point size depends on intensity\n    gl_PointSize = clamp(12.0 * intensity, 1.0, 64.0);\n\n    // color mixes red and yellow based on intensity\n    outColor = mix(vec4(1.0, 1.0, 0.0, 1.0), vec4(0.9, 0.0, 0.0, 1.0), intensity);\n}\n"}),N.createElement(dR,{name:"shader.frag",type:"shader",data:"\nprecision lowp float;\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    // just output color supplied by vertex shader\n    gl_FragColor = outColor;\n}\n"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO");var a=new KM;a.addComponent("camera",{clearColor:new Mu(.1,.1,.1)}),a.translate(0,7,24),n.root.addChild(a),n.start();var i=t.statue.resource.instantiateRenderEntity();n.root.addChild(i);var s={attributes:{aPosition:"POSITION"},vshader:t["shader.vert"].data,fshader:t["shader.frag"].data},r=new fm(n.graphicsDevice,s),o=new Jf;o.shader=r,i.findComponents("render").forEach((function(e){e.meshInstances.forEach((function(e){e.material=o})),e.renderStyle=2}));var l=0;n.on("update",(function(e){l+=e,o.setParameter("uTime",l),i.rotate(0,15*e,0)}))},e.CATEGORY="Graphics",e.NAME="Point Cloud",e}(),EI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}),N.createElement(dR,{name:"portal",type:"container",url:"/static/assets/models/portal.glb"}),N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}),N.createElement(dR,{name:"bitmoji",type:"container",url:"/static/assets/models/bitmoji.glb"}))},e.prototype.example=function(e,t){var n=new jM(e,{keyboard:new mL(window)});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.start(),n.scene.setSkybox(t["helipad.dds"].resources),n.scene.toneMapping=3,n.scene.skyboxMip=1,n.scene.skyboxIntensity=.7;var a=lL("rotator"),i=0;a.prototype.update=function(e){i+=e,this.entity.setEulerAngles(0,40*Math.sin(i),0)},lL("portal").prototype.initialize=function(){var e=new rE({zpass:3});this.entity.findComponents("render").forEach((function(t){for(var n=0,a=t.meshInstances;n<a.length;n++){var i=a[n].material;i.stencilBack=i.stencilFront=e,i.depthWrite=!1,i.redWrite=i.greenWrite=i.blueWrite=i.alphaWrite=!1,i.update()}}))};var s=lL("portalGeometry");s.attributes.add("inside",{type:"boolean",default:!0,title:"True indicating the geometry is inside the portal, false for outside"}),s.prototype.initialize=function(){var e=new rE({func:this.inside?5:2,ref:0});this.entity.findComponents("render").forEach((function(t){for(var n=0,a=t.meshInstances;n<a.length;n++){var i=a[n];i.material.stencilBack=i.material.stencilFront=e}}))};var r=n.scene.layers.getLayerByName("World"),o=n.scene.layers.getLayerByName("Skybox"),l=new rv({name:"Portal"});n.scene.layers.insert(l,0);var c=new KM;c.addComponent("camera",{layers:[r.id,l.id,o.id]}),c.setLocalPosition(7,5.5,7.1),c.setLocalEulerAngles(-27,45,0),n.root.addChild(c);var h=new KM;h.addComponent("light",{type:"directional",color:new Mu(1,1,1)}),h.setEulerAngles(45,35,0),n.root.addChild(h);var d=new KM;d.addComponent("script"),d.script.create("rotator"),n.root.addChild(d);var p=new KM("Portal");p.addComponent("render",{type:"plane",material:new cg,layers:[l.id]}),p.addComponent("script"),p.script.create("portal"),p.setLocalPosition(0,.4,-.3),p.setLocalEulerAngles(90,0,0),p.setLocalScale(3.7,1,6.7),d.addChild(p);var u=t.portal.resource.instantiateRenderEntity();u.setLocalPosition(0,-3,0),u.setLocalScale(.02,.02,.02),d.addChild(u);var m=t.statue.resource.instantiateRenderEntity();m.addComponent("script"),m.script.create("portalGeometry",{attributes:{inside:!0}}),m.setLocalPosition(0,-1,-2),m.setLocalScale(.25,.25,.25),d.addChild(m);var f=t.bitmoji.resource.instantiateRenderEntity();f.addComponent("script"),f.script.create("portalGeometry",{attributes:{inside:!1}}),f.setLocalPosition(0,-1,-2),f.setLocalScale(2.5,2.5,2.5),d.addChild(f)},e.CATEGORY="Graphics",e.NAME="Portal",e}(),SI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"bloom",type:"script",url:"/static/scripts/posteffects/posteffect-bloom.js"}),N.createElement(dR,{name:"bokeh",type:"script",url:"/static/scripts/posteffects/posteffect-bokeh.js"}),N.createElement(dR,{name:"sepia",type:"script",url:"/static/scripts/posteffects/posteffect-sepia.js"}),N.createElement(dR,{name:"vignette",type:"script",url:"/static/scripts/posteffects/posteffect-vignette.js"}),N.createElement(dR,{name:"ssao",type:"script",url:"/static/scripts/posteffects/posteffect-ssao.js"}),N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/arial.json"}),N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}))},e.prototype.controls=function(e){return N.createElement(N.Fragment,null,N.createElement(Lp,{headerText:"BLOOM [KEY_1]"},N.createElement(Dp,{text:"enabled"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"scripts.bloom.enabled"}})),N.createElement(Dp,{text:"intensity"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"scripts.bloom.bloomIntensity"}})),N.createElement(Dp,{text:"threshold"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"scripts.bloom.bloomThreshold"}})),N.createElement(Dp,{text:"blur amount"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"scripts.bloom.blurAmount"},min:1,max:30}))),N.createElement(Lp,{headerText:"SEPIA [KEY_2]"},N.createElement(Dp,{text:"enabled"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"scripts.sepia.enabled"}})),N.createElement(Dp,{text:"amount"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"scripts.sepia.amount"}}))),N.createElement(Lp,{headerText:"VIGNETTE [KEY_3]"},N.createElement(Dp,{text:"enabled"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"scripts.vignette.enabled"}})),N.createElement(Dp,{text:"darkness"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"scripts.vignette.darkness"}})),N.createElement(Dp,{text:"offset"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"scripts.vignette.offset"},max:2}))),N.createElement(Lp,{headerText:"BOKEH [KEY_4]"},N.createElement(Dp,{text:"enabled"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"scripts.bokeh.enabled"}})),N.createElement(Dp,{text:"aperture"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"scripts.bokeh.aperture"},max:.2})),N.createElement(Dp,{text:"max blur"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"scripts.bokeh.maxBlur"},max:.1}))),N.createElement(Lp,{headerText:"SSAO [KEY_5]"},N.createElement(Dp,{text:"enabled"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"scripts.ssao.enabled"}})),N.createElement(Dp,{text:"radius"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"scripts.ssao.radius"},max:10})),N.createElement(Dp,{text:"samples"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"scripts.ssao.samples"},max:32})),N.createElement(Dp,{text:"brightness"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"scripts.ssao.brightness"}}))),N.createElement(Lp,{headerText:"POST-PROCESS UI [KEY_6]"},N.createElement(Dp,{text:"enabled"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:e,path:"data.postProcessUI.enabled"}}))))},e.prototype.example=function(e,t,n){var a=new jM(e,{keyboard:new mL(window)});function i(e,t,n,i,s){void 0===s&&(s=!0);var r=new cg;r.shininess=40,r.metalness=.6,r.useMetalness=!0,r.diffuse=new Mu(i,i,i),s&&Math.random()<.15&&(r.emissive=new Mu(Math.random(),Math.random(),Math.random())),r.update();var o=new KM;return o.addComponent("render",{type:e,material:r}),o.setLocalPosition(t),o.setLocalScale(n),a.root.addChild(o),o}a.start(),a.setCanvasFillMode("FILL_WINDOW"),a.setCanvasResolution("AUTO"),a.scene.setSkybox(t["helipad.dds"].resources),a.scene.skyboxMip=3,a.scene.exposure=1;for(var s=-2;s<=2;s+=.5)for(var r=0;r<=10;r+=.5)i("box",new Pu(40*s,-5,40*r),new Pu(18,2,18),Math.random());for(var o=16,l=0;l<=7;l++){for(s=-1;s<=1;s+=2)for(r=0;r<=10;r+=2){i("box",new Pu(40*s,2+10*l,40*r),new Pu(o,o,o),Math.random()).setLocalEulerAngles(360*Math.random(),360*Math.random(),360*Math.random())}o-=1.5}var c=i("sphere",Pu.ZERO,new Pu(10,10,10),1.5,!1),h=new KM;h.addComponent("light",{type:"omni",color:Mu.WHITE,intensity:4,range:100,castShadows:!1}),c.addChild(h);var d=new KM;d.addComponent("camera",{clearColor:new Mu(.4,.45,.5),farClip:500}),d.addComponent("script"),n.set("scripts",{ssao:{enabled:!0,radius:5,samples:16,brightness:0},bloom:{enabled:!0,bloomIntensity:.8,bloomThreshold:.8,blurAmount:15},sepia:{enabled:!0,amount:.4},vignette:{enabled:!0,darkness:1,offset:1.2},bokeh:{enabled:!0,aperture:.1,maxBlur:.01}}),Object.keys(n.get("scripts")).forEach((function(e){d.script.create(e,{attributes:n.get("scripts.".concat(e))})})),d.setLocalPosition(0,30,-60),d.lookAt(0,0,100),a.root.addChild(d),a.keyboard.on("keydown",(function(e){if("HTMLInputElement"!==e.element.constructor.name)switch(e.key){case 49:n.set("scripts.bloom.enabled",!n.get("scripts.bloom.enabled"));break;case 50:n.set("scripts.sepia.enabled",!n.get("scripts.sepia.enabled"));break;case 51:n.set("scripts.vignette.enabled",!n.get("scripts.vignette.enabled"));break;case 52:n.set("scripts.bokeh.enabled",!n.get("scripts.bokeh.enabled"));break;case 53:n.set("scripts.ssao.enabled",!n.get("scripts.ssao.enabled"));break;case 54:n.set("data.postProcessUI.enabled",!n.get("data.postProcessUI.enabled"))}}),this);var p=new KM;p.addComponent("screen",{referenceResolution:new Du(1280,720),scaleBlend:.5,scaleMode:"blend",screenSpace:!0}),a.root.addChild(p);var u=new KM;u.addComponent("element",{anchor:new Ou(.1,.1,.5,.5),fontAsset:t.font,fontSize:28,pivot:new Du(.5,.1),type:"text",alignment:Du.ZERO}),p.addChild(u),u.element.text="Test UI Text";var m=0;a.on("update",(function(e){m+=e,a.scene.skyboxRotation=(new Gu).setFromEulerAngles(0,20*m,0);var t=new Pu(0,10,400*Math.abs(Math.sin(.1*m)));c.setPosition(t),d.script.bokeh.focus=-t.sub(d.getPosition()).length(),d.script.bokeh.enabled&&a.drawDepthTexture(.7,-.7,.5,.5)})),n.on("*:set",(function(e,t){var n=e.split(".");"scripts"===n[0]?d.script[n[1]][n[2]]=t:d.camera.disablePostEffectsLayer=4===d.camera.disablePostEffectsLayer?void 0:4}))},e.CATEGORY="Graphics",e.NAME="Post Effects",e}(),AI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}),N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}),N.createElement(dR,{name:"cube",type:"container",url:"/static/assets/models/playcanvas-cube.glb"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO");var a=[];n.start(),a[0]=t.cube.resource.instantiateRenderEntity(),a[0].setLocalPosition(7,12,0),a[0].setLocalScale(3,3,3),n.root.addChild(a[0]),a[1]=a[0].clone(),a[1].setLocalPosition(-7,12,0),a[1].setLocalScale(3,3,3),n.root.addChild(a[1]);var i=t.statue.resource.instantiateRenderEntity();n.root.addChild(i);var s=new KM;s.addComponent("camera",{clearColor:new Mu(.2,.1,.1),farClip:100}),s.translate(-20,15,20),s.lookAt(0,7,0),n.root.addChild(s),n.scene.setSkybox(t["helipad.dds"].resources),n.scene.toneMapping=3,n.scene.skyboxMip=1,n.on("update",(function(e){a[0]&&a[0].rotate(3*e,10*e,6*e),a[1]&&a[1].rotate(-7*e,5*e,-2*e),i&&i.rotate(0,-12*e,0)}))},e.CATEGORY="Graphics",e.NAME="Render Asset",e}(),MI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}),N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/utils/cubemap-renderer.js"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.toneMapping=3,n.scene.skyboxMip=0,n.scene.skyboxIntensity=2,n.scene.setSkybox(t["helipad.dds"].resources);function a(e,t,a,i,s){var r=new cg;r.diffuse=i,r.shininess=60,r.metalness=.7,r.useMetalness=!0,r.update();var o=new KM;return o.addComponent("render",{type:e,layers:s,material:r}),o.setLocalPosition(t),o.setLocalScale(a),n.root.addChild(o),o}var i=new rv({name:"Excluded"});n.scene.layers.push(i);var s=new cg,r=function(e,t){var a=new KM("ShinyBall");n.root.addChild(a);var i=dy(n.graphicsDevice,{latitudeBands:200,longitudeBands:200});return a.addComponent("render",{type:"asset",layers:t,meshInstances:[new Ay(i,e)]}),a}(s,[i.id]);r.setLocalPosition(0,0,0),r.setLocalScale(10,10,10);var o=n.scene.layers.getLayerByName("World"),l=n.scene.layers.getLayerByName("Skybox"),c=n.scene.layers.getLayerByName("Immediate");r.addComponent("camera",{clearColorBuffer:!1,layers:[o.id,l.id],priority:-1,enabled:!1}),r.addComponent("script"),r.script.create("cubemapRenderer",{attributes:{resolution:256,mipmaps:!0,depth:!0}}),s.diffuse=new Mu(.6,.6,.6),s.useSkybox=!1,s.cubeMap=r.script.cubemapRenderer.cubeMap,s.metalness=1,s.useMetalness=!0,s.update();for(var h=[],d=["box","cone","cylinder","sphere","capsule"],p=0;p<6;p++){var u=d[Math.floor(Math.random()*d.length)],m=new Mu(Math.random(),Math.random(),Math.random());h.push(a(u,Pu.ZERO,new Pu(3,3,3),m,[o.id]))}a("plane",new Pu(0,-8,0),new Pu(20,20,20),new Mu(.3,.5,.3),[o.id]);var f=new KM("MainCamera");f.addComponent("camera",{fov:60,layers:[o.id,i.id,l.id,c.id]}),n.root.addChild(f);var g=new KM;function y(e,t){return new Gm(n.graphicsDevice,{width:t,height:t,format:6,mipmaps:!1,minFilter:1,magFilter:1,addressU:1,addressV:1,projection:e})}g.addComponent("light",{type:"directional",color:Mu.YELLOW,range:40,castShadows:!0,layers:[o.id],shadowBias:.2,shadowResolution:1024,normalOffsetBias:.05,shadowDistance:40}),n.root.addChild(g);var b=y("equirect",256),v=y("equirect",256),_=y("octahedral",64),w=y("octahedral",32),x=0;n.on("update",(function(e){x+=e;for(var t=0;t<h.length;t++){var a=(t+1)/h.length,i=x+200*t;h[t].setLocalPosition(7*Math.sin(i),2*(t-3),7*Math.cos(i)),h[t].rotate(1*a,2*a,3*a)}f.setLocalPosition(20*Math.cos(.2*x),2,20*Math.sin(.2*x)),f.lookAt(Pu.ZERO);var s=r.script.cubemapRenderer.cubeMap;Yf(s,b,{numSamples:1}),n.drawTexture(-.6,.7,.6,.3,b),Yf(s,_,{numSamples:1}),n.drawTexture(.7,.7,.4,.4,_),Yf(b,w,{specularPower:32,numSamples:1024}),n.drawTexture(-.7,-.7,.4,.4,w),Yf(_,v,{specularPower:16,numSamples:512}),n.drawTexture(.6,-.7,.6,.3,v)}))},e.CATEGORY="Graphics",e.NAME="Render Cubemap",e}(),LI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"helipad.dds",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}))},e.prototype.example=function(e,t){var n=new jM(e,{});function a(e,t,a,i,s){var r=new cg;r.diffuse=i,r.update();var o=new KM;return o.addComponent("render",{type:e,layers:s,material:r}),o.setLocalPosition(t),o.setLocalScale(a),n.root.addChild(o),o}n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO");var i=new Gm(n.graphicsDevice,{width:512,height:256,format:6,mipmaps:!0,minFilter:1,magFilter:1,addressU:1,addressV:1}),s=new Cg({colorBuffer:i,depth:!0,flipY:!0,samples:2}),r=new rv({name:"Excluded"});n.scene.layers.push(r);var o=n.scene.layers.getLayerByName("World"),l=n.scene.layers.getLayerByName("Skybox");a("plane",new Pu(0,0,0),new Pu(20,20,20),new Mu(.2,.4,.2),[o.id]),a("sphere",new Pu(-2,1,0),new Pu(2,2,2),Mu.RED,[o.id]),a("box",new Pu(2,1,0),new Pu(2,2,2),Mu.YELLOW,[o.id]),a("cone",new Pu(0,1,-2),new Pu(2,2,2),Mu.CYAN,[o.id]);var c=new KM("Camera");c.addComponent("camera",{fov:100,layers:[o.id,r.id,l.id]}),c.translate(0,9,15),c.lookAt(1,4,0),n.root.addChild(c);var h=new KM("TextureCamera");h.addComponent("camera",{layers:[o.id,l.id],priority:-1,renderTarget:s}),h.addComponent("render",{type:"sphere"}),n.root.addChild(h);var d=new KM;d.addComponent("light",{type:"omni",color:Mu.WHITE,range:200,castShadows:!0,layers:[o.id]}),d.translate(0,2,5),n.root.addChild(d);var p=a("plane",new Pu(6,8,-5),new Pu(20,10,10),Mu.BLACK,[r.id]);p.setLocalEulerAngles(90,0,0),p.render.castShadows=!1,p.render.receiveShadows=!1;var u=p.render.material;u.emissiveMap=i,u.update(),n.scene.skyboxMip=0,n.scene.setSkybox(t["helipad.dds"].resources),n.scene.toneMapping=3;var m=0,f=0;n.on("update",(function(e){m+=e,h.setLocalPosition(12*Math.sin(m),3,12*Math.cos(m)),h.lookAt(Pu.ZERO),(f+=e)>5&&(f=0,1===h.camera.projection?h.camera.projection=0:(h.camera.projection=1,h.camera.orthoHeight=5))}))},e.CATEGORY="Graphics",e.NAME="Render to Texture",e}(),RI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}),N.createElement(dR,{name:"clouds",type:"texture",url:"/static/assets/textures/clouds.jpg"}),N.createElement(dR,{name:"shader.vert",type:"shader",data:"\nattribute vec3 aPosition;\nattribute vec2 aUv0;\n\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\n\nvarying vec2 vUv0;\n\nvoid main(void)\n{\n    vUv0 = aUv0;\n    gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, 1.0);\n}\n"}),N.createElement(dR,{name:"shader.frag",type:"shader",data:"\nprecision mediump float;\n\nvarying vec2 vUv0;\n\nuniform sampler2D uDiffuseMap;\nuniform sampler2D uHeightMap;\nuniform float uTime;\n\nvoid main(void)\n{\n    float height = texture2D(uHeightMap, vUv0).r;\n    vec4 color = texture2D(uDiffuseMap, vUv0);\n    if (height < uTime) {\n      discard;\n    }\n    if (height < (uTime + uTime * 0.1)) {\n      color = vec4(1.0, 0.2, 0.0, 1.0);\n    }\n    gl_FragColor = color;\n}\n"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.scene.ambientLight=new Mu(.2,.2,.2);var a=new KM;a.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),a.translate(0,7,24);var i=new KM;i.addComponent("light",{type:"omni",color:new Mu(1,1,1),radius:10}),i.translate(0,1,0),n.root.addChild(a),n.root.addChild(i),n.start();var s={attributes:{aPosition:"POSITION",aUv0:"TEXCOORD0"},vshader:t["shader.vert"].data,fshader:t["shader.frag"].data},r=new fm(n.graphicsDevice,s),o=new Jf;o.shader=r,o.setParameter("uHeightMap",t.clouds.resource);var l=t.statue.resource.instantiateRenderEntity();n.root.addChild(l);var c=null;l.findComponents("render").forEach((function(e){for(var t=e.meshInstances,n=0;n<t.length;n++){var a=t[n];if(!c){var i=a.material;c=i.diffuseMap}a.material=o}})),o.setParameter("uDiffuseMap",c),o.update();var h=0;n.on("update",(function(e){var t=(h+=.2*e)%2;t>1&&(t=1-(t-1)),o.setParameter("uTime",t),o.update()}))},e.CATEGORY="Graphics",e.NAME="Shader Burn",e}(),II=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}),N.createElement(dR,{name:"shader.vert",type:"shader",data:"\n// Attributes per vertex: position, normal and texture coordinates\nattribute vec4 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aUv;\n\nuniform mat4   matrix_viewProjection;\nuniform mat4   matrix_model;\nuniform mat4   matrix_view;\nuniform mat3   matrix_normal;\nuniform vec3   uLightPos;\n\n// Color to fragment program\nvarying float vertOutTexCoord;\nvarying vec2 texCoord;\n\nvoid main(void)\n{\n    mat4 modelView = matrix_view * matrix_model;\n    mat4 modelViewProj = matrix_viewProjection * matrix_model;\n\n    // Get surface normal in eye coordinates\n    vec3 eyeNormal = normalize(matrix_normal * aNormal);\n\n    // Get vertex position in eye coordinates\n    vec4 vertexPos = modelView * aPosition;\n    vec3 vertexEyePos = vertexPos.xyz / vertexPos.w;\n\n    // Get vector to light source\n    vec3 lightDir = normalize(uLightPos - vertexEyePos);\n\n    // Dot product gives us diffuse intensity. The diffuse intensity will be\n    // used as the 1D color texture coordinate to look for the color of the\n    // resulting fragment (see fragment shader).\n    vertOutTexCoord = max(0.0, dot(eyeNormal, lightDir));\n    texCoord = aUv;\n\n    // Transform the geometry\n    gl_Position = modelViewProj * aPosition;\n}"}),N.createElement(dR,{name:"shader.frag",type:"shader",data:"\nprecision mediump float;\nuniform sampler2D uTexture;\nvarying float vertOutTexCoord;\nvarying vec2 texCoord;\nvoid main(void)\n{\n    float v = vertOutTexCoord;\n    v = float(int(v * 6.0)) / 6.0;\n    // vec4 color = texture2D (uTexture, texCoord); // try this to use the diffuse color.\n    vec4 color = vec4(0.5, 0.47, 0.43, 1.0);\n    gl_FragColor = color * vec4(v, v, v, 1.0);\n}\n"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.scene.ambientLight=new Mu(.2,.2,.2);var a=new KM;a.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),a.translate(0,7,24);var i=new KM;i.addComponent("light",{type:"omni",color:new Mu(1,1,1),radius:10}),i.translate(0,1,0),n.root.addChild(a),n.root.addChild(i),n.start();var s={attributes:{aPosition:"POSITION",aNormal:"NORMAL",aUv:"TEXCOORD0"},vshader:t["shader.vert"].data,fshader:t["shader.frag"].data},r=new fm(n.graphicsDevice,s),o=new Jf;o.shader=r;var l=t.statue.resource.instantiateRenderEntity();n.root.addChild(l);var c=null;l.findComponents("render").forEach((function(e){for(var t=e.meshInstances,n=0;n<t.length;n++){var a=t[n];if(!c){var i=a.material;c=i.diffuseMap}a.material=o}}));var h=[i.getPosition().x,i.getPosition().y,i.getPosition().z];o.setParameter("uLightPos",h),o.setParameter("uTexture",c),o.update(),n.on("update",(function(e){l.rotate(0,60*e,0)}))},e.CATEGORY="Graphics",e.NAME="Shader Toon",e}(),PI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}),N.createElement(dR,{name:"shader.vert",type:"shader",data:"\nattribute vec3 aPosition;\nattribute vec2 aUv0;\n\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\nuniform float uTime;\n\nvarying vec2 vUv0;\n\nvoid main(void)\n{\n    vec4 pos = matrix_model * vec4(aPosition, 1.0);\n    pos.x += sin(uTime + pos.y * 4.0) * 0.1;\n    pos.y += cos(uTime + pos.x * 4.0) * 0.1;\n    vUv0 = aUv0;\n    gl_Position = matrix_viewProjection * pos;\n}\n"}),N.createElement(dR,{name:"shader.frag",type:"shader",data:"\nprecision mediump float;\n\nuniform sampler2D uDiffuseMap;\n\nvarying vec2 vUv0;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uDiffuseMap, vUv0);\n}\n"}))},e.prototype.example=function(e,t){var n=0,a=new jM(e,{});a.setCanvasFillMode("FILL_WINDOW"),a.setCanvasResolution("AUTO"),a.scene.ambientLight=new Mu(.2,.2,.2);var i=new KM;i.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),i.translate(0,7,25);var s=new KM;s.addComponent("light",{type:"omni",color:new Mu(1,1,1),radius:10}),s.translate(0,1,0),a.root.addChild(i),a.root.addChild(s);var r={attributes:{aPosition:"POSITION",aUv0:"TEXCOORD0"},vshader:t["shader.vert"].data,fshader:t["shader.frag"].data},o=new fm(a.graphicsDevice,r),l=new Jf;l.shader=o;var c=t.statue.resource.instantiateRenderEntity();a.root.addChild(c);var h=null;c.findComponents("render").forEach((function(e){for(var t=e.meshInstances,n=0;n<t.length;n++){var a=t[n];if(!h){var i=a.material;h=i.diffuseMap}a.material=l}})),l.setParameter("uDiffuseMap",h),l.update(),a.on("update",(function(e){n+=e,l.setParameter("uTime",n),l.update()})),a.start()},e.CATEGORY="Graphics",e.NAME="Shader Wobble",e}(),kI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/camera/orbit-camera.js"}),N.createElement(dR,{name:"terrain",type:"container",url:"/static/assets/models/terrain.glb"}),N.createElement(dR,{name:"helipad",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}))},e.prototype.controls=function(e){return N.createElement(N.Fragment,null,N.createElement(Lp,{headerText:"Shadow Cascade Settings"},N.createElement(Dp,{text:"Filtering"},N.createElement(OR,{binding:new Up,link:{observer:e,path:"settings.light.shadowType"},type:"number",options:[{v:0,t:"PCF3"},{v:4,t:"PCF5"},{v:1,t:"VSM8"},{v:2,t:"VSM16"},{v:3,t:"VSM32"}]})),N.createElement(Dp,{text:"Count"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"settings.light.numCascades"},min:1,max:4,precision:0})),N.createElement(Dp,{text:"Resolution"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"settings.light.shadowResolution"},min:128,max:2048,precision:0})),N.createElement(Dp,{text:"Distribution"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"settings.light.cascadeDistribution"},min:0,max:1,precision:2})),N.createElement(Dp,{text:"VSM Blur"},N.createElement(CR,{binding:new Up,link:{observer:e,path:"settings.light.vsmBlurSize"},min:1,max:25,precision:0}))))},e.prototype.example=function(e,t,n){var a=new jM(e,{});a.start(),n.set("settings",{light:{numCascades:4,shadowResolution:2048,cascadeDistribution:.5,shadowType:0,vsmBlurSize:11}}),a.setCanvasFillMode("FILL_WINDOW"),a.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){a.resizeCanvas(e.width,e.height)})),a.scene.skyboxMip=3,a.scene.setSkybox(t.helipad.resources),a.scene.skyboxRotation=(new Gu).setFromEulerAngles(0,-70,0),a.scene.toneMapping=3;var i=t.terrain.resource.instantiateRenderEntity();i.setLocalScale(30,30,30),a.root.addChild(i);var s=i.findOne("name","Arbol 2.002"),r=new KM;r.addComponent("camera",{clearColor:new Mu(.9,.9,.9),farClip:1e3}),r.setLocalPosition(300,60,25),r.addComponent("script"),r.script.create("orbitCamera",{attributes:{inertiaFactor:.2,focusEntity:s,distanceMax:600}}),r.script.create("orbitCameraInputMouse"),r.script.create("orbitCameraInputTouch"),a.root.addChild(r);var o=new KM;o.addComponent("light",lR({type:"directional",color:Mu.WHITE,shadowBias:.3,normalOffsetBias:.2,intensity:1,castShadows:!0,shadowDistance:1e3},n.get("settings.light"))),a.root.addChild(o),o.setLocalEulerAngles(45,350,20),n.on("*:set",(function(e,t){var n=e.split(".");o.light[n[2]]=t}));var l=!0;a.on("update",(function(e){l&&(l=!1,r.script.orbitCamera.distance=320)}))},e.CATEGORY="Graphics",e.NAME="Shadow Cascades",e}(),DI=function(){function e(){}return e.prototype.example=function(e){var t=new jM(e,{});t.start(),t.setCanvasFillMode("FILL_WINDOW"),t.setCanvasResolution("AUTO"),t.scene.ambientLight=new Mu(.2,.2,.2);var n=-1,a=-1;["box","plane","cone","cylinder","sphere","capsule"].forEach((function(e){var i=new KM;i.addComponent("render",{type:e}),t.root.addChild(i),i.setLocalPosition(1.2*n,a,0),1==n++&&(n=-1,a=1)}));var i=new KM;i.addComponent("light",{type:"directional"}),t.root.addChild(i),i.setLocalEulerAngles(45,30,0);var s=new KM;s.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),t.root.addChild(s),s.setLocalPosition(0,0,5)},e.CATEGORY="Graphics",e.NAME="Shapes",e}(),OI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"color",type:"texture",url:"/static/assets/textures/seaside-rocks01-color.basis"}),N.createElement(dR,{name:"gloss",type:"texture",url:"/static/assets/textures/seaside-rocks01-gloss.basis"}),N.createElement(dR,{name:"normal",type:"texture",url:"/static/assets/textures/seaside-rocks01-normal.basis",data:{type:"swizzleGGGR"}}),N.createElement(dR,{name:"helipad",type:"cubemap",url:"/static/assets/cubemaps/helipad.dds",data:{type:"rgbm"}}))},e.prototype.example=function(e,t){var n=new jM(e,{});yx({glueUrl:"/static/lib/basis/basis.wasm.js",wasmUrl:"/static/lib/basis/basis.wasm.wasm",fallbackUrl:"/static/lib/basis/basis.js"}),n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.toneMapping=3,n.scene.skyboxMip=1,n.scene.skyboxIntensity=.7,n.scene.setSkybox(t.helipad.resources);var a=new KM;a.addComponent("light",{type:"directional"}),a.setLocalEulerAngles(45,0,45);var i=new cg;i.useMetalness=!0,i.diffuse=new Mu(.3,.3,.3),i.shininess=80,i.metalness=.7,i.diffuseMap=t.color.resource,i.normalMap=t.normal.resource,i.glossMap=t.gloss.resource,i.diffuseMapTiling.set(7,7),i.normalMapTiling.set(7,7),i.glossMapTiling.set(7,7),i.update();var s=function(e,t){const n=t&&void 0!==t.tubeRadius?t.tubeRadius:.2,a=t&&void 0!==t.ringRadius?t.ringRadius:.3,i=t&&void 0!==t.segments?t.segments:30,s=t&&void 0!==t.sides?t.sides:20,r=!(!t||void 0===t.calculateTangents)&&t.calculateTangents,o=[],l=[],c=[],h=[];for(let e=0;e<=s;e++)for(let t=0;t<=i;t++){const r=Math.cos(2*Math.PI*t/i)*(a+n*Math.cos(2*Math.PI*e/s)),d=Math.sin(2*Math.PI*e/s)*n,p=Math.sin(2*Math.PI*t/i)*(a+n*Math.cos(2*Math.PI*e/s)),u=Math.cos(2*Math.PI*t/i)*Math.cos(2*Math.PI*e/s),m=Math.sin(2*Math.PI*e/s),f=Math.sin(2*Math.PI*t/i)*Math.cos(2*Math.PI*e/s),g=e/s,y=1-t/i;if(o.push(r,d,p),l.push(u,m,f),c.push(g,1-y),e<s&&t<i){const n=e*(i+1)+t,a=(e+1)*(i+1)+t,s=e*(i+1)+(t+1),r=(e+1)*(i+1)+(t+1);h.push(n,a,s),h.push(a,r,s)}}const d={normals:l,uvs:c,indices:h};return r&&(d.tangents=oy(o,l,c,h)),ly(e,o,d)}(n.graphicsDevice,{tubeRadius:.2,ringRadius:.3,segments:50,sides:40}),r=new KM;r.addComponent("render",{material:i,meshInstances:[new Ay(s,i)]}),r.setPosition(0,0,0),r.setLocalScale(2,2,2);var o=new KM;o.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),o.translate(0,0,4),n.root.addChild(a),n.root.addChild(r),n.root.addChild(o);var l=0;n.on("update",(function(e){l=(l+10*e)%360,r.setEulerAngles(l,2*l,4*l)}))},e.CATEGORY="Graphics",e.NAME="Texture Basis",e}(),FI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}),N.createElement(dR,{name:"vshaderFeedback",type:"shader",data:"\n// vertex shader used to move particles during transform-feedback simulation step\n\n// input and output is vec4, containing position in .xyz and lifetime in .w\nattribute vec4 vertex_position;\nvarying vec4 out_vertex_position;\n\n// parameters controlling simulation\nuniform float deltaTime;\nuniform float areaSize;\n\n// texture storing random direction vectors\nuniform sampler2D directionSampler;\n\n// function returning random number based on vec2 seed parameter\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main(void) {\n\n    // texture contains direction of particle movement - read it based on particle's position\n    vec2 texCoord = vertex_position.xz / areaSize + 0.5;\n    vec3 dir = texture2D(directionSampler, texCoord).xyz;\n    dir = dir * 2.0 - 1.0;\n\n    // move particle along direction with some speed\n    float speed = 20.0 * deltaTime;\n    vec3 pos = vertex_position.xyz + dir * speed;\n\n    // age the particle\n    float liveTime = vertex_position.w;\n    liveTime -= deltaTime;\n\n    // if particle is too old, regenerate it\n    if (liveTime <= 0.0) {\n\n        // random life time\n        liveTime = rand(pos.xy) * 2.0;\n\n        // random position\n        pos.x = rand(pos.xz) * areaSize - 0.5 * areaSize;\n        pos.y = rand(pos.xy) * 4.0;\n        pos.z = rand(pos.yz) * areaSize - 0.5 * areaSize;\n    }\n\n    // write out updated particle\n    out_vertex_position = vec4(pos, liveTime);\n}\n"}),N.createElement(dR,{name:"vshaderCloud",type:"shader",data:"\n// vertex shader used to render point sprite particles\n\n// Attributes per vertex: position\nattribute vec4 aPosition;\n\nuniform mat4   matrix_viewProjection;\n\n// Color to fragment program\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    // Transform the geometry (ignore life time which is stored in .w of position)\n    vec4 worldPosition = vec4(aPosition.xyz, 1);\n    gl_Position = matrix_viewProjection * worldPosition;\n\n    // point sprite size\n    gl_PointSize = 2.0;\n\n    // color depends on position of particle\n    outColor = vec4(worldPosition.y * 0.25, 0.1, worldPosition.z * 0.2, 1);\n}\n"}),N.createElement(dR,{name:"fshaderCloud",type:"shader",data:"\n// fragment shader used to render point sprite particles\nprecision mediump float;\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    // color supplied by vertex shader\n    gl_FragColor = outColor;\n}\n"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.ambientLight=new Mu(.2,.2,.2);for(var a=10,i=new Uint8ClampedArray(400),s=0;s<100;s++)i[4*s]=127+50*Math.random()-25,i[4*s+1]=127+50*Math.random()-25,i[4*s+2]=127+50*Math.random()-25,i[4*s+3]=255;var r=new Gm(n.graphicsDevice,{width:a,height:a,format:7,cubemap:!1,mipmaps:!1,minFilter:1,magFilter:1,addressU:1,addressV:1});r.lock().set(i),r.unlock();var o,l,c=new KM;c.addComponent("camera",{clearColor:new Mu(.1,.1,.1)}),n.root.addChild(c);var h=n.graphicsDevice.scope.resolve("areaSize"),d=n.graphicsDevice.scope.resolve("deltaTime"),p=n.graphicsDevice.scope.resolve("directionSampler");if(n.graphicsDevice.webgl2){var u=2e5,m=new Float32Array(8e5);for(s=0;s<u;s++)m[4*s]=Math.random(),m[4*s+1]=Math.random(),m[4*s+2]=Math.random(),m[4*s+3]=0;var f=new iy(n.graphicsDevice);f.setPositions(m,4),f.update(0,!1),f.aabb=new qu(new Pu(0,0,0),new Pu(100,100,100)),l=new fm(n.graphicsDevice,{attributes:{aPosition:"POSITION"},vshader:t.vshaderCloud.data,fshader:t.fshaderCloud.data});var g=new Jf;g.shader=l,g.blendType=6,g.depthWrite=!1;var y=new hf,b=new Ay(f,g,y),v=new KM;v.addComponent("render",{type:"asset",meshInstances:[b]}),n.root.addChild(v),o=new Bg(f.vertexBuffer),l=Bg.createShader(n.graphicsDevice,t.vshaderFeedback.data,"transformShaderExample")}var _=0;n.on("update",(function(e){_+=e,c.setLocalPosition(9*Math.sin(.2*_),6,25*Math.cos(.2*_)),c.lookAt(new Pu(0,3,0)),o&&(h.setValue(30),d.setValue(e),p.setValue(r),o.process(l))}))},e.CATEGORY="Graphics",e.NAME="Transform Feedback",e}(),NI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"tv",type:"container",url:"/static/assets/models/tv.glb"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),n.scene.ambientLight=new Mu(.2,.2,.2);var a=new KM;a.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),a.translate(0,0,15);var i=new KM;i.addComponent("light",{type:"omni",color:new Mu(1,1,1),range:30}),i.translate(5,5,10),n.root.addChild(a),n.root.addChild(i);var s=new Gm(n.graphicsDevice,{format:3,mipmaps:!1,minFilter:1,magFilter:1,addressU:1,addressV:1}),r=document.createElement("video");r.id="vid",r.loop=!0,r.muted=!0,r.autoplay=!0,r.playsInline=!0,r.crossOrigin="anonymous",r.setAttribute("style","display: block; width: 1px; height: 1px; position: absolute; opacity: 0; z-index: -1000; top: 0px; pointer-events: none"),r.src="/static/assets/video/SampleVideo_1280x720_1mb.mp4",document.body.append(r),r.addEventListener("canplaythrough",(function(){s.setSource(r)}));var o=t.tv.resource.instantiateRenderEntity();n.root.addChild(o);var l=new cg;l.useLighting=!1,l.emissiveMap=s,l.update(),o.render.meshInstances[1].material=l,r.load(),new yL(document.body).on("mousedown",(function(e){o&&e.buttons[0]&&(r.muted=!r.muted)}));var c=!1,h=0;n.on("update",(function(e){h+=e,o.setLocalEulerAngles(100+50*Math.sin(h),0,-90),(c=!c)&&s.upload()}))},e.CATEGORY="Graphics",e.NAME="Video Texture",e}(),VI=Object.freeze({__proto__:null,AreaLightsExample:WR,AreaPickerExample:jR,BatchingDynamicExample:XR,BoxReflectionExample:YR,ClusteredAreaLightsExample:qR,ClusteredLightingExample:KR,ClusteredOmniShadowsExample:ZR,ClusteredSpotShadowsExample:$R,GrabPassExample:QR,HardwareInstancingExample:JR,HierarchyExample:eI,LayersExample:tI,LightsBakedAOExample:nI,LightsBakedExample:aI,LightsExample:iI,LinesExample:sI,MaterialAnisotropicExample:rI,MaterialClearCoatExample:oI,MaterialPhysicalExample:lI,MaterialTranslucentSpecularExample:cI,MeshDecalsExample:hI,MeshDeformationExample:dI,MeshGenerationExample:pI,MeshMorphManyExample:uI,MeshMorphExample:mI,ModelAssetExample:fI,ModelOutlineExample:gI,ModelTexturedBoxExample:yI,PainterExample:bI,ParticlesAnimIndexExample:vI,ParticlesRandomSpritesExample:_I,ParticlesSnowExample:wI,ParticlesSparkExample:xI,PointCloudSimulationExample:CI,PointCloudExample:TI,PortalExample:EI,PostEffectsExample:SI,RenderAssetExample:AI,RenderCubemapExample:MI,RenderToTextureExample:LI,ShaderBurnExample:RI,ShaderToonExample:II,ShaderWobbleExample:PI,ShadowCascadesExample:kI,ShapesExample:DI,TextureBasisExample:OI,TransformFeedbackExample:FI,VideoTextureExample:NI}),BI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.scene.ambientLight=new Mu(.2,.2,.2);var a=new KM;a.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),a.translate(0,7,25),n.root.addChild(a);var i=new KM;i.addComponent("light",{type:"omni",color:new Mu(1,1,1),range:100}),i.translate(5,5,10),n.root.addChild(i);var s=t.statue.resource.instantiateRenderEntity();n.root.addChild(s);var r=new eR;n.on("update",(function(){r.update(),r.isPressed(0,14)&&s.rotate(0,-1,0),r.isPressed(0,15)&&s.rotate(0,1,0),r.wasPressed(0,12)&&s.rotate(-1,0,0),r.wasPressed(0,13)&&s.rotate(1,0,0)}))},e.CATEGORY="Input",e.NAME="Gamepad",e}(),UI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.scene.ambientLight=new Mu(.2,.2,.2);var a=new KM;a.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),a.translate(0,7,25),n.root.addChild(a);var i=new KM;i.addComponent("light",{type:"omni",color:new Mu(1,1,1),range:100}),i.translate(5,5,10),n.root.addChild(i);var s=t.statue.resource.instantiateRenderEntity();n.root.addChild(s);var r=new mL(document.body);n.on("update",(function(){r.isPressed(37)&&s.rotate(0,-1,0),r.isPressed(39)&&s.rotate(0,1,0)}))},e.CATEGORY="Input",e.NAME="Keyboard",e}(),zI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"statue",type:"container",url:"/static/assets/models/statue.glb"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.scene.ambientLight=new Mu(.2,.2,.2);var a=new KM;a.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),a.translate(0,7,25),n.root.addChild(a);var i=new KM;i.addComponent("light",{type:"omni",color:new Mu(1,1,1),range:100}),i.translate(5,5,10),n.root.addChild(i);var s=t.statue.resource.instantiateRenderEntity();n.root.addChild(s);var r=new yL(document.body),o=0;r.on("mousemove",(function(e){e.buttons[0]&&(o+=e.dx,s.setLocalEulerAngles(0,.2*o,0))}))},e.CATEGORY="Input",e.NAME="Mouse",e}(),GI=Object.freeze({__proto__:null,GamepadExample:BI,KeyboardExample:UI,MouseExample:zI}),HI=function(){function e(){}return e.prototype.example=function(e,t,n,a){var i=new jM(e,{});function s(){i.scene.ambientLight=new Mu(.2,.2,.2);i.assets.loadFromUrl("/static/assets/models/heart_draco.glb","container",(function(e,t){i.start();var n=t.resource.instantiateRenderEntity({castShadows:!0});i.root.addChild(n),n.setLocalScale(20,20,20);var a=new KM;a.addComponent("camera",{clearColor:new Mu(.2,.2,.2)}),a.translate(0,.5,4),i.root.addChild(a);var s=new KM;s.addComponent("light",{type:"omni",intensity:3}),s.setLocalPosition(1,1,5),i.root.addChild(s),i.on("update",(function(e){n&&n.rotate(4*e,-20*e,0)}))}))}n()?a("DracoDecoderModule","/static/lib/draco/draco.wasm.js","/static/lib/draco/draco.wasm.wasm",s):a("DracoDecoderModule","/static/lib/draco/draco.js","",s)},e.CATEGORY="Loaders",e.NAME="Draco GLB",e}(),WI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"shader.vert",type:"shader",data:"\n    // Attributes per vertex: position\n    attribute vec4 aPosition;\n    attribute vec4 aColor;\n\n    uniform mat4   matrix_viewProjection;\n    uniform mat4   matrix_model;\n\n    // Color to fragment program\n    varying vec4 outColor;\n\n    void main(void)\n    {\n        mat4 modelViewProj = matrix_viewProjection * matrix_model;\n        gl_Position = modelViewProj * aPosition;\n\n        gl_PointSize = 1.5;\n        outColor = aColor;\n    }\n"}),N.createElement(dR,{name:"shader.frag",type:"shader",data:"\n    precision lowp float;\n    varying vec4 outColor;\n\n    void main(void)\n    {\n        // just output color supplied by vertex shader\n        gl_FragColor = outColor;\n    }\n"}),N.createElement(pR,{name:"CORE",url:"https://cdn.jsdelivr.net/npm/@loaders.gl/core@2.3.6/dist/dist.min.js"}),N.createElement(pR,{name:"DRACO",url:"https://cdn.jsdelivr.net/npm/@loaders.gl/draco@2.3.6/dist/dist.min.js"}))},e.prototype.example=function(e,t){var n=new jM(e,{});var a=new KM;a.addComponent("camera",{clearColor:new Mu(.1,.1,.1),farClip:100}),a.translate(-20,15,20),a.lookAt(0,7,0),n.root.addChild(a),function(e){return cR(this,void 0,void 0,(function(){var a,i,s,r,o,l,c,h,d,p;return hR(this,(function(u){switch(u.label){case 0:return[4,CORE.load(e,DRACO.DracoLoader)];case 1:for(a=u.sent(),i=a.attributes.COLOR_0.value,s=i.length/a.attributes.COLOR_0.size,r=new Uint8Array(4*s),o=0;o<s;o++)r[4*o+0]=i[3*o+0],r[4*o+1]=i[3*o+1],r[4*o+2]=i[3*o+2],r[4*o+3]=255;return(l=new iy(n.graphicsDevice)).clear(!0,!1),l.setPositions(a.attributes.POSITION.value,a.attributes.POSITION.size),l.setColors32(r),l.update(0),c={attributes:{aPosition:"POSITION",aColor:"COLOR"},vshader:t["shader.vert"].data,fshader:t["shader.frag"].data},h=new fm(n.graphicsDevice,c),(d=new Jf).shader=h,d.blendType=10,d.cull=0,(p=new KM).addComponent("render",{material:d,meshInstances:[new Ay(l,d)]}),n.root.addChild(p),[2]}}))}))}("/static/assets/models/park_points.drc").then((function(){n.start()}));var i=0;n.on("update",(function(e){i+=e,a&&(a.setLocalPosition(40*Math.sin(.5*i),10,20*Math.cos(.5*i)),a.lookAt(Pu.ZERO))}))},e.CATEGORY="Loaders",e.NAME="Loaders.gl",e}(),jI=function(){function e(){}return e.prototype.example=function(e){var t=new jM(e,{}),n=null;t.assets.loadFromUrl("/static/assets/models/geometry-camera-light.glb","container",(function(e,a){t.start();var i=a.resource.instantiateRenderEntity();t.root.addChild(i),(n=i.findComponents("camera")).forEach((function(e){e.aspectRatioMode=0})),i.findComponents("light").forEach((function(e){e.enabled=!0}));var s=0,r=0;t.on("update",(function(e){(s-=e)<=0&&(s=2,n[r].enabled=!1,r=(r+1)%n.length,n[r].enabled=!0)}))}))},e.CATEGORY="Loaders",e.NAME="GLB",e}(),XI=function(){function e(){}return e.prototype.example=function(e){var t=new jM(e,{});t.scene.ambientLight=new Mu(.2,.2,.2);var n;t.assets.loadFromUrl("/static/scripts/parsers/obj-model.js","script",(function(){t.loader.getHandler("model").addParser(new ObjModelParser(t.graphicsDevice),(function(e){return".obj"===tu.getExtension(e)})),t.assets.loadFromUrl("/static/assets/models/monkey.obj","model",(function(e,a){t.start(),(n=new KM).addComponent("model"),n.model.model=a.resource,t.root.addChild(n);for(var i=n.model.meshInstances,s=0;s<i.length;s++){var r=new cg;r.diffuse=new Mu(Eu.random(0,1),Eu.random(0,1),Eu.random(0,1)),r.update(),i[s].material=r}}))}));var a=new KM;a.addComponent("camera",{clearColor:new Mu(.4,.45,.5)}),a.translate(0,0,5),t.root.addChild(a);var i=new KM;i.addComponent("light",{type:"omni",color:new Mu(1,1,1),range:100}),i.translate(5,0,15),t.root.addChild(i),t.on("update",(function(e){n&&n.rotate(0,100*e,0)}))},e.CATEGORY="Loaders",e.NAME="OBJ",e}(),YI=Object.freeze({__proto__:null,DracoGlbExample:HI,LoadersGlExample:WI,GlbExample:jI,ObjExample:XI}),qI=function(){function e(){}return e.prototype.example=function(e){var t=new jM(e,{}),n=new KM("cube");n.addComponent("render",{type:"box"}),t.root.addChild(n);var a=new KM("camera");a.addComponent("camera",{clearColor:new Mu(.5,.6,.9)}),t.root.addChild(a),a.setPosition(0,0,3);var i=new KM("light");i.addComponent("light"),t.root.addChild(i),i.setEulerAngles(45,0,0),t.on("update",(function(e){return n.rotate(10*e,20*e,30*e)})),t.start()},e.CATEGORY="Misc",e.NAME="Hello World",e}(),KI=function(){function e(){}return e.prototype.example=function(e,t){var n=new jM(e,{});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)}));var a=t.MiniStats.getDefaultOptions();a.sizes=[{width:128,height:16,spacing:0,graphs:!1},{width:256,height:32,spacing:2,graphs:!0},{width:500,height:64,spacing:2,graphs:!0}],a.startSizeIndex=2,a.stats=[{name:"Update",stats:["frame.updateTime"],decimalPlaces:1,unitsName:"ms",watermark:33},{name:"DrawCalls",stats:["drawCalls.total"],watermark:2e3},{name:"triCount",stats:["frame.triangles"],decimalPlaces:1,multiplier:.001,unitsName:"k",watermark:500},{name:"materials",stats:["frame.materials"],watermark:2e3},{name:"cull",stats:["frame.cullTime"],decimalPlaces:1,watermark:1,unitsName:"ms"},{name:"VRAM",stats:["vram.tex","vram.geom"],decimalPlaces:1,multiplier:1/1048576,unitsName:"MB",watermark:100},{name:"FPS",stats:["frame.fps"],watermark:60},{name:"Frame",stats:["frame.ms"],decimalPlaces:1,unitsName:"ms",watermark:33}],new t.MiniStats(n,a);var i=new KM;i.addComponent("light",{type:"directional"}),n.root.addChild(i),i.setLocalEulerAngles(45,30,0);var s=new KM;function r(e,t,n){var a=new cg;a.diffuse=new Mu(Math.random(),Math.random(),Math.random()),a.update();var i=new KM;return i.addComponent("model",{type:e}),i.model.material=a,i.setLocalPosition(t),i.setLocalScale(n),i}s.addComponent("camera",{clearColor:new Mu(.1,.1,.1)}),n.root.addChild(s),s.setLocalPosition(20,10,10),s.lookAt(Pu.ZERO);var o,l,c=[],h=[],d=[],p=!0;n.on("update",(function(e){for(var t=0;t<10;t++)if(p){var a=Math.random()<.5?"box":"sphere",i=new Pu(10*Math.random(),10*Math.random(),10*Math.random()),s=.5+Math.random();o=r(a,i,new Pu(s,s,s)),c.push(o),n.root.addChild(o),c.length>=2e3&&(p=!1);var u=new Float32Array(8e3);l=new lm(n.graphicsDevice,hm.defaultInstancingFormat,500,0,u),h.push(l);var m=new Gm(n.graphicsDevice,{width:64,height:64,format:6,mipmaps:!1});d.push(m),m.lock(),m.unlock(),n.graphicsDevice.setTexture(m,0)}else c.length>0?((o=c[c.length-1]).destroy(),c.length--,(l=h[h.length-1]).destroy(),h.length--,d[d.length-1].destroy(),d.length--):p=!0}))},e.CATEGORY="Misc",e.NAME="Mini Stats",e.ENGINE="PERFORMANCE",e}(),ZI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"skeleton",type:"json",url:"/static/assets/spine/spineboy-pro.json"}),N.createElement(dR,{name:"atlas",type:"text",url:"/static/assets/spine/spineboy-pro.atlas"}),N.createElement(dR,{name:"texture",type:"texture",url:"/static/assets/spine/spineboy-pro.png"}),N.createElement(dR,{name:"spinescript",type:"script",url:"/static/scripts/spine/playcanvas-spine.3.8.js"}))},e.prototype.example=function(e,t){var n=new jM(e,{});n.start();var a=new KM("camera");a.addComponent("camera",{clearColor:new Mu(.5,.6,.9)}),n.root.addChild(a),a.translateLocal(0,7,20);var i=function(e,a,i){var s=new KM;s.addComponent("spine",{atlasAsset:t.atlas.id,skeletonAsset:t.skeleton.id,textureAssets:[t.texture.id]}),s.setLocalPosition(e),s.setLocalScale(a),n.root.addChild(s),s.spine.state.setAnimation(0,"portal",!0),s.spine.state.timeScale=i};i(new Pu(2,2,0),new Pu(1,1,1),1),i(new Pu(2,10,0),new Pu(-.5,.5,.5),.5)},e.CATEGORY="Misc",e.NAME="Spineboy",e}(),$I=Object.freeze({__proto__:null,HelloWorldExample:qI,MiniStatsExample:KI,SpineboyExample:ZI}),QI=function(){function e(){}return e.prototype.example=function(e,t,n){function a(){var t=new jM(e,{});function n(e){var t=new cg;return t.diffuse=e,t.update(),t}t.start(),t.scene.ambientLight=new Mu(.2,.2,.2);var a=n(new Mu(.7,.3,.3)),i=n(new Mu(.7,.7,.7));function s(e){var t=new KM(e.name);return e.pos&&t.setLocalPosition(e.pos[0],e.pos[1],e.pos[2]),e.rot&&t.setLocalEulerAngles(e.rot[0],e.rot[1],e.rot[2]),e.scl&&t.setLocalScale(e.scl[0],e.scl[1],e.scl[2]),e.components&&e.components.forEach((function(e){t.addComponent(e.type,e.options)})),e.children&&e.children.forEach((function(e){t.addChild(s(e))})),t}[{name:"Chair",pos:[0,1,0],components:[{type:"collision",options:{type:"compound"}},{type:"rigidbody",options:{type:"dynamic",friction:.5,mass:10,restitution:.5}}],children:[{name:"Seat",components:[{type:"collision",options:{type:"box",halfExtents:[.25,.025,.25]}}],children:[{name:"Seat Model",scl:[.5,.05,.5],components:[{type:"render",options:{type:"box",material:i}}]}]},{name:"Seat Back",pos:[0,.3,-.2],components:[{type:"collision",options:{type:"box",halfExtents:[.25,.2,.025]}}],children:[{name:"Seat Back Model",scl:[.5,.4,.05],components:[{type:"render",options:{type:"box",material:i}}]}]},{name:"Leg 1",pos:[.2,-.25,.2],components:[{type:"collision",options:{type:"cylinder",height:.5,radius:.025}}],children:[{name:"Leg 1 Model",scl:[.05,.5,.05],components:[{type:"render",options:{type:"cylinder",material:i}}]}]},{name:"Leg 2",pos:[-.2,-.25,.2],components:[{type:"collision",options:{type:"cylinder",height:.5,radius:.025}}],children:[{name:"Leg 2 Model",scl:[.05,.5,.05],components:[{type:"render",options:{type:"cylinder",material:i}}]}]},{name:"Leg 3",pos:[.2,0,-.2],components:[{type:"collision",options:{type:"cylinder",height:1,radius:.025}}],children:[{name:"Leg 3 Model",scl:[.05,1,.05],components:[{type:"render",options:{type:"cylinder",material:i}}]}]},{name:"Leg 4",pos:[-.2,0,-.2],components:[{type:"collision",options:{type:"cylinder",height:1,radius:.025}}],children:[{name:"Leg 4 Model",scl:[.05,1,.05],components:[{type:"render",options:{type:"cylinder",material:i}}]}]}]},{name:"Ground",pos:[0,-.5,0],components:[{type:"collision",options:{type:"box",halfExtents:[5,.5,5]}},{type:"rigidbody",options:{type:"static",restitution:.5}}],children:[{name:"Ground Model",scl:[10,1,10],components:[{type:"render",options:{type:"box",material:i}}]}]},{name:"Directional Light",rot:[45,130,0],components:[{type:"light",options:{type:"directional",castShadows:!0,shadowDistance:8,shadowBias:.1,intensity:1,normalOffsetBias:.05}}]},{name:"Camera",pos:[0,4,7],rot:[-30,0,0],components:[{type:"camera",options:{color:[.5,.5,.5]}}]}].forEach((function(e){t.root.addChild(s(e))}));var r=0;var o=0;t.on("update",(function(e){var n;(o+=e)>.25&&r<100&&((n=t.root.findByName("Chair").clone()).setLocalPosition(5*Math.random()-2.5,2*Math.random()+1,5*Math.random()-2.5),t.root.addChild(n),r++,o=0),t.root.findComponents("rigidbody").forEach((function(e){e.entity.findComponents("render").forEach((function(t){t.material=e.isActive()?a:i}))}))}))}t()?n("Ammo","/static/lib/ammo/ammo.wasm.js","/static/lib/ammo/ammo.wasm.wasm",a):n("Ammo","/static/lib/ammo/ammo.js","",a)},e.CATEGORY="Physics",e.NAME="Compound Collision",e}(),JI=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"torus",type:"container",url:"/static/assets/models/torus.glb"}))},e.prototype.example=function(e,t,n,a){var i=new jM(e,{});function s(){function e(e){var t=new cg;return t.diffuse=e,t.update(),t}i.start(),i.scene.ambientLight=new Mu(.2,.2,.2),i.systems.rigidbody.gravity.set(0,-9.81,0);var n=e(new Mu(1,.3,.3)),a=e(new Mu(.7,.7,.7)),s=new KM;s.addComponent("render",{type:"box",material:a}),s.setLocalScale(10,1,10),s.addComponent("rigidbody",{type:"static",restitution:.5}),s.addComponent("collision",{type:"box",halfExtents:new Pu(5,.5,5)}),i.root.addChild(s);var r=new KM;r.addComponent("light",{type:"directional",color:new Mu(1,1,1),castShadows:!0,shadowBias:.2,shadowDistance:25,normalOffsetBias:.05,shadowResolution:2048}),r.setLocalEulerAngles(45,30,0),i.root.addChild(r);var o=new KM;o.addComponent("camera",{clearColor:new Mu(.5,.5,.8),farClip:50}),i.root.addChild(o),o.translate(0,10,15),o.lookAt(0,2,0);var l=function(e,t,n){return n||(n=new KM).addComponent("render",{type:e}),n.addComponent("rigidbody",{type:"dynamic",mass:50,restitution:.5}),n.addComponent("collision",t),n},c=l("box",{type:"box",halfExtents:new Pu(.5,.5,.5)}),h=l("sphere",{type:"sphere",radius:.5}),d=l("capsule",{type:"capsule",radius:.5,height:2}),p=l("cylinder",{type:"cylinder",radius:.5,height:1}),u=t.torus.resource,m=u.instantiateRenderEntity();l(null,{type:"mesh",renderAsset:u.renders[0]},m);var f=[c,h,d,p,m];f.forEach((function(e){e.enabled=!1}));var g=0,y=40;i.on("update",(function(e){if(y>0&&(g-=e)<=0){y--,g=.2;var t=f[Math.floor(Math.random()*f.length)].clone();t.enabled=!0,i.root.addChild(t),t.rigidbody.teleport(Eu.random(-1,1),10,Eu.random(-1,1)),t.rigidbody.angularVelocity=new Pu(10*Math.random()-5,10*Math.random()-5,10*Math.random()-5)}i.root.findComponents("rigidbody").forEach((function(e){e.entity.render.meshInstances[0].material=e.isActive()?n:a}))}))}n()?a("Ammo","/static/lib/ammo/ammo.wasm.js","/static/lib/ammo/ammo.wasm.wasm",s):a("Ammo","/static/lib/ammo/ammo.js","",s)},e.CATEGORY="Physics",e.NAME="Falling Shapes",e}(),eP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/arial.json"}))},e.prototype.example=function(e,t,n,a){function i(){var n=new jM(e,{});function a(e){var t=new cg;return t.diffuse=e,t.update(),t}n.start(),n.scene.ambientLight=new Mu(.2,.2,.2);var i=a(new Mu(1,0,0)),s=a(new Mu(0,1,0)),r=new KM;r.addComponent("light",{type:"directional"}),n.root.addChild(r),r.setEulerAngles(45,30,0);var o=new KM;function l(e,t,a,i,s){var r=new KM;return n.root.addChild(r),r.setPosition(a,i,s),r.addComponent("render",{type:e,material:t}),r.addComponent("rigidbody",{type:"static"}),r.addComponent("collision",{type:e,height:"capsule"===e?2:1}),r}o.addComponent("camera",{clearColor:new Mu(.5,.5,.8)}),n.root.addChild(o),o.setPosition(5,0,15);var c=["box","capsule","cone","cylinder","sphere"];c.forEach((function(e,t){l(e,s,2*t+1,2,0)})),c.forEach((function(e,t){l(e,s,2*t+1,-2,0)}));var h=new Mu(1,1,1),d=new Mu(0,0,1),p=new Pu,u=new Pu,m=new Pu,f=0,g=0;n.on("update",(function(e){f+=e,n.root.findComponents("render").forEach((function(e){e.material=s})),g=2+1.2*Math.sin(f),p.set(0,g,0),u.set(10,g,0),n.drawLine(p,u,h);var t=n.systems.rigidbody.raycastFirst(p,u);t&&(t.entity.render.material=i,m.copy(t.normal).mulScalar(.3).add(t.point),n.drawLine(t.point,m,d)),g=1.2*Math.sin(f)-2,p.set(0,g,0),u.set(10,g,0),n.drawLine(p,u,h),n.systems.rigidbody.raycastAll(p,u).forEach((function(e){e.entity.render.material=i,m.copy(e.normal).mulScalar(.3).add(e.point),n.drawLine(e.point,m,d)}),this)}));var y=function(e,t,a,i,s,r){var o=new KM;o.addComponent("element",{anchor:[.5,.5,.5,.5],fontAsset:e,fontSize:.5,pivot:[0,.5],text:t,type:"text"}),o.setLocalPosition(a,i,s),o.setLocalEulerAngles(0,0,r),n.root.addChild(o)};y(t.font,"raycastFirst",.5,3.75,0,0),y(t.font,"raycastAll",.5,-.25,0,0)}n()?a("Ammo","/static/lib/ammo/ammo.wasm.js","/static/lib/ammo/ammo.wasm.wasm",i):a("Ammo","/static/lib/ammo/ammo.js","",i)},e.CATEGORY="Physics",e.NAME="Raycast",e}(),tP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"script1",type:"script",url:"/static/scripts/camera/tracking-camera.js"}),N.createElement(dR,{name:"script2",type:"script",url:"/static/scripts/physics/render-physics.js"}),N.createElement(dR,{name:"script3",type:"script",url:"/static/scripts/physics/action-physics-reset.js"}),N.createElement(dR,{name:"script4",type:"script",url:"/static/scripts/physics/vehicle.js"}))},e.prototype.example=function(e,t,n,a){function i(){var t=new jM(e,{keyboard:new mL(window)});t.start();var n=new KM("Ground");n.addComponent("rigidbody",{type:"static"}),n.addComponent("collision",{type:"box",halfExtents:new Pu(50,.5,50)}),n.setLocalPosition(0,-.5,0),t.root.addChild(n);var a=[];[{name:"Front Left Wheel",pos:new Pu(.8,.4,1.2),front:!0},{name:"Front Right Wheel",pos:new Pu(-.8,.4,1.2),front:!0},{name:"Back Left Wheel",pos:new Pu(.8,.4,-1.2),front:!1},{name:"Back Right Wheel",pos:new Pu(-.8,.4,-1.2),front:!1}].forEach((function(e){var t=new KM(e.name);t.addComponent("script"),t.script.create("vehicleWheel",{attributes:{debugRender:!0,isFront:e.front}}),t.setLocalPosition(e.pos),a.push(t)}));var i=new KM("Vehicle");i.addComponent("rigidbody",{mass:800,type:"dynamic"}),i.addComponent("collision",{type:"compound"}),i.addComponent("script"),i.script.create("vehicle",{attributes:{wheels:a}}),i.script.create("vehicleControls"),i.script.create("actionPhysicsReset",{attributes:{event:"reset"}}),i.setLocalPosition(0,2,0);var s=new KM("Chassis");s.addComponent("collision",{type:"box",halfExtents:[.6,.35,1.65]}),s.setLocalPosition(0,.65,0);var r=new KM("Cab");r.addComponent("collision",{type:"box",halfExtents:[.5,.2,1]}),r.setLocalPosition(0,1.2,-.25),a.forEach((function(e){i.addChild(e)})),i.addChild(s),i.addChild(r),t.root.addChild(i);for(var o=0;o<10;o++)for(var l=0;l<5;l++){var c=new KM("Block");c.addComponent("rigidbody",{type:"dynamic"}),c.addComponent("collision",{type:"box"}),c.addComponent("script"),c.script.create("actionPhysicsReset",{attributes:{event:"reset"}}),c.setLocalPosition(o-4.5,l+.5,-10),t.root.addChild(c)}var h=new KM("Directional Light");h.addComponent("light",{type:"directional",color:new Mu(1,1,1),castShadows:!0,shadowBias:.2,shadowDistance:40,normalOffsetBias:.05,shadowResolution:2048}),h.setLocalEulerAngles(45,30,0),t.root.addChild(h);var d=new KM("Camera");d.addComponent("camera"),d.addComponent("script"),d.script.create("trackingCamera",{attributes:{target:i}}),d.translate(0,10,15),d.lookAt(0,0,0),t.root.addChild(d),t.root.addComponent("script"),t.root.script.create("renderPhysics",{attributes:{drawShapes:!0,opacity:1}}),t.keyboard.on("keydown",(function(e){82===e.key&&t.fire("reset")}))}n()?a("Ammo","/static/lib/ammo/ammo.wasm.js","/static/lib/ammo/ammo.wasm.wasm",i):a("Ammo","/static/lib/ammo/ammo.js","",i)},e.CATEGORY="Physics",e.NAME="Vehicle",e}(),nP=Object.freeze({__proto__:null,CompoundCollisionExample:QI,FallingShapesExample:JI,RaycastExample:eP,VehicleExample:tP}),aP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"model",type:"model",url:"/static/assets/models/playbot/playbot.json"}),N.createElement(dR,{name:"runAnim",type:"animation",url:"/static/assets/animations/playbot/playbot-run.json"}),N.createElement(dR,{name:"gravel",type:"audio",url:"/static/assets/sounds/footsteps.mp3"}))},e.prototype.example=function(e,t){var n=new jM(e,{}),a=new KM;a.addComponent("camera",{clearColor:new Mu(1,0,0)}),a.addComponent("audiolistener"),a.rotateLocal(-30,0,0),a.translateLocal(0,0,5),n.root.addChild(a);var i=new cg;i.diffuse=Mu.GRAY,i.update();var s=new KM;s.addComponent("render",{type:"box",material:i}),s.setLocalScale(50,1,50),s.setLocalPosition(0,-.5,0),n.root.addChild(s);var r=new KM;r.addComponent("light",{type:"directional",color:new Mu(1,1,1),castShadows:!0,intensity:2,shadowBias:.2,shadowDistance:16,normalOffsetBias:.05,shadowResolution:2048}),r.setLocalEulerAngles(45,30,0),n.root.addChild(r),n.start();var o=new KM;o.addComponent("sound"),o.sound.addSlot("footsteps",{asset:t.gravel.id,pitch:1.7,loop:!0,autoPlay:!0}),o.addComponent("model",{type:"asset",asset:t.model,castShadows:!0}),o.addComponent("animation",{assets:[t.runAnim],speed:.8}),n.root.addChild(o);var l=135;n.on("update",(function(e){(l+=30*e)>360&&(l-=360),o.setLocalPosition(3*Math.sin(l*Eu.DEG_TO_RAD),0,3*Math.cos(l*Eu.DEG_TO_RAD)),o.setLocalEulerAngles(0,l+90,0)}))},e.CATEGORY="Sound",e.NAME="Positional",e}(),iP=Object.freeze({__proto__:null,PositionalExample:aP}),sP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/courier.json"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)}));var a=new KM;a.addComponent("camera",{clearColor:new Mu(30/255,30/255,30/255)}),n.root.addChild(a);var i=new KM;i.addComponent("screen",{referenceResolution:new Du(1280,720),scaleBlend:.5,scaleMode:"blend",screenSpace:!0}),n.root.addChild(i);var s=new KM;s.addComponent("button",{imageEntity:s}),s.addComponent("element",{anchor:[.5,.5,.5,.5],height:40,pivot:[.5,.5],type:"image",width:175,useInput:!0}),i.addChild(s);var r=new KM;r.addComponent("element",{anchor:[.5,.5,.5,.5],color:new Mu(0,0,0),fontAsset:t.font.id,fontSize:32,height:64,pivot:[.5,.5],text:"CLICK ME",type:"text",width:128,wrapLines:!0}),s.addChild(r),s.button.on("click",(function(e){a.camera.clearColor=new Mu(Math.random(),Math.random(),Math.random())}))},e.CATEGORY="User Interface",e.NAME="Button Basic",e}(),rP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/courier.json"}),N.createElement(dR,{name:"red_button_atlas",type:"texture",url:"/static/assets/button/red_button_atlas.png"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.start();var a=new KM;a.addComponent("camera",{clearColor:new Mu(30/255,30/255,30/255)}),n.root.addChild(a);var i=new KM;i.addComponent("screen",{referenceResolution:new Du(1280,720),scaleBlend:.5,scaleMode:"blend",screenSpace:!0}),n.root.addChild(i);var s=new KM;s.addComponent("button",{active:!0,imageEntity:s,transitionMode:1}),s.addComponent("element",{anchor:[.5,.5,.5,.5],height:64,pivot:[.5,.5],type:"image",width:175,useInput:!0}),i.addChild(s);var r=new KM;r.addComponent("element",{anchor:[.5,.5,.5,.5],color:new Mu(1,1,1),fontAsset:t.font.id,fontSize:32,height:64,opacity:.5,pivot:[.5,.5],text:"CLICK ME",type:"text",width:128,wrapLines:!0}),s.addChild(r),s.button.on("click",(function(){var e=Math.random();a.camera.clearColor=new Mu(e,e,e)})),s.button.on("pressedstart",(function(){r.translateLocal(0,-4,0)})),s.button.on("pressedend",(function(){r.translateLocal(0,4,0)}));var o=t.red_button_atlas.resource;o.addressU=1,o.addressV=1,o.minFilter=0,o.magFilter=0;var l=new ix;l.frames={0:{rect:new Ou(0,147,190,49),pivot:new Du(.5,.5),border:new Ou(7,11,7,7)},1:{rect:new Ou(0,98,190,49),pivot:new Du(.5,.5),border:new Ou(7,11,7,7)},2:{rect:new Ou(0,49,190,49),pivot:new Du(.5,.5),border:new Ou(7,11,7,7)},3:{rect:new Ou(0,0,190,49),pivot:new Du(.5,.5),border:new Ou(7,11,7,7)}},l.texture=o;var c=function(e){var t=new $w(n.graphicsDevice,{atlas:l,frameKeys:[e],pixelsPerUnit:1,renderMode:0}),a=new f_("sprite","sprite",{url:""});return a.resource=t,a.loaded=!0,n.assets.add(a),a};s.element.spriteAsset=c("0").id,s.button.hoverSpriteAsset=c("1"),s.button.pressedSpriteAsset=c("2"),s.button.inactiveSpriteAsset=c("3")},e.CATEGORY="User Interface",e.NAME="Button Sprite",e}(),oP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"playcanvas",type:"texture",url:"/static/assets/textures/playcanvas.png"}),N.createElement(dR,{name:"shader.vert",type:"shader",data:"\n/**\n * Simple Screen-Space Vertex Shader with one UV coordinate.\n * This shader is useful for simple UI shaders.\n * \n * Usage: the following attributes must be configured when creating a new pc.Shader:\n *   vertex_position: pc.SEMANTIC_POSITION\n *   vertex_texCoord0: pc.SEMANTIC_TEXCOORD0\n */\n\n// Default PlayCanvas uniforms\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n\n// Additional inputs\nattribute vec3 vertex_position;\nattribute vec2 vertex_texCoord0;\n\n// Additional shader outputs\nvarying vec2 vUv0;\n\nvoid main(void) {\n    // UV is simply passed along as varying\n    vUv0 = vertex_texCoord0;\n\n    // Position for screen-space\n    gl_Position = matrix_model * vec4(vertex_position, 1.0);\n    gl_Position.zw = vec2(0.0, 1.0);\n}\n"}),N.createElement(dR,{name:"shader.frag",type:"shader",data:"\n/**\n * Simple Color-Inverse Fragment Shader with intensity control.\n * \n * Usage: the following parameters must be set:\n *   uDiffuseMap: image texture.\n *   amount: float that controls the amount of the inverse-color effect. 0 means none (normal color), while 1 means full inverse.\n *\n * Additionally, the Vertex shader that is paired with this Fragment shader must specify:\n *   varying vec2 vUv0: for the UV.\n */\n\n// The following line is for setting the shader precision for floats. It is commented out because, ideally, it must be configured\n// on a per-device basis before loading the Shader. Please check the accompanying TypeScript code and look for 'app.graphicsDevice.precision'.\n\n// precision mediump float;\n\n// Additional varying from vertex shader\nvarying vec2 vUv0;\n\n// Custom Parameters (must be set from code via material.setParameter())\nuniform sampler2D uDiffuseMap;\nuniform float amount;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uDiffuseMap, vUv0);\n    vec3 roloc = vec3(1.0 - color.r, 1.0 - color.g, 1.0 - color.b);\n    gl_FragColor = vec4(mix(color.rgb, roloc, amount), color.a);\n}\n"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)}));var a=new KM;a.addComponent("camera",{clearColor:new Mu(30/255,30/255,30/255)}),n.root.addChild(a);var i=new KM;i.addComponent("screen",{referenceResolution:new Du(1280,720),scaleBlend:.5,scaleMode:"blend",screenSpace:!0}),n.root.addChild(i);var s="precision "+n.graphicsDevice.precision+" float;\n"+t["shader.frag"].data,r=new fm(n.graphicsDevice,{attributes:{vertex_position:"POSITION",vertex_texCoord0:"TEXCOORD0"},vshader:t["shader.vert"].data,fshader:s}),o=new Jf;o.shader=r,o.blendType=6,o.depthWrite=!0,o.setParameter("uDiffuseMap",t.playcanvas.resource),o.update();var l=new KM;l.addComponent("element",{pivot:new Du(.5,.5),anchor:new Ou(.5,.5,.5,.5),width:350,height:350,type:"image"}),l.element.material=o,i.addChild(l);var c=0;n.on("update",(function(e){c+=e,o.setParameter("amount",.5*(Math.sin(4*c)+1))}))},e.CATEGORY="User Interface",e.NAME="Custom Shader",e}(),lP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/courier.json"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)}));var a=new KM;a.addComponent("camera",{clearColor:new Mu(30/255,30/255,30/255)}),n.root.addChild(a);var i=new KM;i.addComponent("screen",{referenceResolution:new Du(1280,720),scaleBlend:.5,scaleMode:"blend",screenSpace:!0}),n.root.addChild(i);var s=new KM;s.addComponent("element",{type:"group",anchor:[.5,.5,.5,.5],pivot:[.5,.5],width:350,height:150}),s.addComponent("layoutgroup",{orientation:0,spacing:new Du(10,10),widthFitting:3,heightFitting:3,wrap:!0}),i.addChild(s);for(var r=0;r<15;++r){var o=new KM;o.addComponent("element",{anchor:[.5,.5,.5,.5],pivot:[.5,.5],color:new Mu(Math.random(),Math.random(),Math.random()),type:"image"}),o.addComponent("layoutchild",{excludeFromLayout:!1}),s.addChild(o);var l=new KM;l.addComponent("element",{anchor:[0,0,1,1],margin:[0,0,0,0],pivot:[.5,.5],color:new Mu(1,1,1),fontAsset:t.font.id,text:"".concat(r+1),type:"text",autoWidth:!1,autoHeight:!1,autoFitWidth:!0,autoFitHeight:!0}),o.addChild(l)}},e.CATEGORY="User Interface",e.NAME="Layout Group",e}(),cP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/courier.json"}),N.createElement(dR,{name:"spark",type:"texture",url:"/static/assets/textures/spark.png"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)}));var a=new KM;a.addComponent("camera",{clearColor:new Mu(30/255,30/255,30/255)}),n.root.addChild(a);var i=new KM;i.addComponent("screen",{referenceResolution:new Du(1280,720),scaleBlend:.5,scaleMode:"blend",screenSpace:!0}),n.root.addChild(i);var s=new KM;s.addComponent("element",{anchor:[.5,.5,.5,.5],color:new Mu(.4,.4,.4),height:40,pivot:[.5,.5],type:"image",width:175,useInput:!0}),i.addChild(s);var r=new KM;r.addComponent("element",{anchor:[.5,.5,.5,.5],color:new Mu(1,1,0),fontAsset:t.font.id,fontSize:36,height:64,pivot:[.5,.5],text:"LABEL",type:"text",width:128,wrapLines:!0}),s.addChild(r);var o=new KM;s.insertChild(o,0);var l=n.scene.layers.getLayerByName("UI"),c=new Ru([0,.03]),h=new Iu([[0,1,.25,1,.375,.5,.5,0],[0,0,.125,.25,.25,.5,.375,.75,.5,1],[0,0,1,0]]),d=new Iu([[0,0],[0,0,.1,.1,.1,-.1],[0,0]]),p=new Ru([0,360]);o.addComponent("particlesystem",{numParticles:100,lifetime:1,rate:.01,localSpace:!0,screenSpace:!0,emitterShape:1,emitterRadius:100,scaleGraph:c,rotationSpeedGraph:p,colorGraph:h,velocityGraph:d,colorMap:t.spark.resource,layers:[l.id]}),i.screen.syncDrawOrder();var u=0;n.on("update",(function(e){u+=.3*e,s.setLocalPosition(300*Math.sin(u),300*Math.cos(u),0)}))},e.CATEGORY="User Interface",e.NAME="Particle System",e}(),hP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/courier.json"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.start();var a=new KM;n.root.addChild(a),a.addComponent("camera",{clearColor:new Mu(30/255,30/255,30/255)});var i=new KM;function s(e){var t=new KM("Handle"),n={type:"image",color:new Mu(1,1,1),opacity:1,margin:new Ou(0,0,0,0),rect:new Ou(0,0,1,1),mask:!1,useInput:!0};e?(n.anchor=new Ou(0,0,0,1),n.pivot=new Du(0,0)):(n.anchor=new Ou(0,1,1,1),n.pivot=new Du(1,1)),t.addComponent("element",n),t.addComponent("button",{active:!0,imageEntity:t,hitPadding:new Ou(0,0,0,0),transitionMode:0,hoverTint:new Mu(1,1,1),pressedTint:new Mu(1,1,1),inactiveTint:new Mu(1,1,1),fadeDuration:0});var a=new KM(e?"HorizontalScrollbar":"VerticalScrollbar");a.addChild(t);var i={type:"image",color:new Mu(.5,.5,.5),opacity:1,rect:new Ou(0,0,1,1),mask:!1,useInput:!1};return e?(i.anchor=new Ou(0,0,1,0),i.pivot=new Du(0,0),i.margin=new Ou(0,0,20,-20)):(i.anchor=new Ou(1,0,1,1),i.pivot=new Du(1,1),i.margin=new Ou(-20,20,0,0)),a.addComponent("element",i),a.addComponent("scrollbar",{orientation:e?0:1,value:0,handleSize:.5,handleEntity:t}),a}n.root.addChild(i),i.addComponent("screen",{screenSpace:!0,referenceResolution:new Du(1280,720),scaleMode:"blend",scaleBlend:.5});var r=new KM("Text");r.addComponent("element",{alignment:new Du(0,0),anchor:new Ou(0,1,0,1),autoHeight:!0,autoWidth:!1,fontAsset:t.font.id,fontSize:32,lineHeight:36,pivot:new Du(0,1),text:"This is a scroll view control. You can scroll the content by dragging the vertical or horizontal scroll bars, by dragging the content itself, by using the mouse wheel, or by using a trackpad. Notice the elastic bounce if you drag the content beyond the limits of the scroll view.",type:"text",width:600,wrapLines:!0});var o=new KM("Content");o.addChild(r),o.addComponent("element",{anchor:new Ou(0,1,0,1),height:400,pivot:new Du(0,1),type:"group",useInput:!0,width:600});var l=new KM("Viewport");l.addChild(o),l.addComponent("element",{anchor:new Ou(0,0,1,1),color:new Mu(.2,.2,.2),margin:new Ou(0,20,20,0),mask:!0,opacity:1,pivot:new Du(0,1),rect:new Ou(0,0,1,1),type:"image",useInput:!1});var c=s(!0),h=s(!1),d=new KM("ScrollView");d.addChild(l),d.addChild(c),d.addChild(h),i.addChild(d),d.addComponent("element",{anchor:new Ou(.5,.5,.5,.5),height:200,pivot:new Du(.5,.5),type:"group",useInput:!1,width:400}),d.addComponent("scrollview",{bounceAmount:.1,contentEntity:o,friction:.05,useMouseWheel:!0,mouseWheelSensitivity:Du.ONE,horizontal:!0,horizontalScrollbarEntity:c,horizontalScrollbarVisibility:1,scrollMode:1,vertical:!0,verticalScrollbarEntity:h,verticalScrollbarVisibility:1,viewportEntity:l})},e.CATEGORY="User Interface",e.NAME="Scroll View",e}(),dP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/courier.json"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)}));var a=new KM;a.addComponent("camera",{clearColor:new Mu(30/255,30/255,30/255)}),n.root.addChild(a);var i=new KM;i.addComponent("screen",{referenceResolution:new Du(1280,720),scaleBlend:.5,scaleMode:"blend",screenSpace:!0}),n.root.addChild(i);var s=new KM;s.addComponent("element",{pivot:new Du(.5,.5),anchor:new Ou(.5,.5,.5,.5),width:220,height:50,color:new Mu(60/255,60/255,60/255),type:"image"});var r=new KM;r.addComponent("element",{pivot:new Du(.5,.5),anchor:new Ou(0,0,1,1),margin:new Ou(0,0,0,0),fontAsset:t.font.id,autoWidth:!1,autoHeight:!1,autoFitWidth:!0,autoFitHeight:!0,minFontSize:10,maxFontSize:100,text:"Auto font size!",type:"text"}),i.addChild(s),s.addChild(r);var o=0;n.on("update",(function(e){o+=e,s.element.width=280+80*Math.sin(o),s.element.height=60+50*Math.sin(.5*o)}))},e.CATEGORY="User Interface",e.NAME="Text Auto Font Size",e}(),pP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/arial.json"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)}));var a=new KM;a.addComponent("camera",{clearColor:new Mu(30/255,30/255,30/255)}),n.root.addChild(a);var i=new KM;i.addComponent("screen",{referenceResolution:new Du(1280,720),scaleBlend:.5,scaleMode:"blend",screenSpace:!0}),n.root.addChild(i);var s="PlayCanvas supports Emojis via CanvasFont!",r="Flags: 🇺🇸🇩🇪🇮🇪🇮🇹🏴‍☠️🇨🇦",o="Complex emoji: 👨🏿3️⃣👁️‍🗨️",l=new rL(n,{color:new Mu(1,1,1),fontName:"Arial",fontSize:64,width:256,height:256});function c(e,t){var n=new KM;n.setLocalPosition(0,e,0),n.addComponent("element",{pivot:new Du(.5,.5),anchor:new Ou(.5,.5,.5,.5),fontSize:32,text:t,type:"text"}),n.element.font=l,i.addChild(n)}l.createTextures(s),l.updateTextures(r),l.updateTextures(o),c(225,s),c(150,r),c(100,o);var h=new KM;h.setLocalPosition(0,-50,0),h.addComponent("element",{pivot:new Du(.5,.5),anchor:new Ou(.5,.5,.5,.5),fontAsset:t.font.id,fontSize:32,text:"The following are the CanvasFont's Texture Atlases,\ncontaining all the rendered characters:",type:"text"}),i.addChild(h);var d=new KM;d.setLocalPosition(0,-150,0),d.addComponent("element",{type:"group",anchor:[.5,.5,.5,.5],pivot:[.5,.5],width:300,height:100}),d.addComponent("layoutgroup",{orientation:0,widthFitting:3,heightFitting:3,wrap:!0}),i.addChild(d);for(var p=0;p<l.textures.length;p++){var u=l.textures[p],m=new KM;m.addComponent("element",{anchor:[.5,.5,.5,.5],pivot:[.5,.5],texture:u,type:"image"}),m.addComponent("layoutchild",{excludeFromLayout:!1}),d.addChild(m)}},e.CATEGORY="User Interface",e.NAME="Text Emojis",e}(),uP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/courier.json"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.start(),n.i18n.addData({header:{version:1},data:[{info:{locale:"en-US"},messages:{HELLO:"Hi"}},{info:{locale:"fr-FR"},messages:{HELLO:"Salut"}},{info:{locale:"es-ES"},messages:{HELLO:"Hola"}},{info:{locale:"pt-BR"},messages:{HELLO:"Oi!"}}]}),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)}));var a=new KM;a.addComponent("camera",{clearColor:new Mu(30/255,30/255,30/255)}),n.root.addChild(a);var i=new KM;i.addComponent("screen",{referenceResolution:new Du(1280,720),scaleBlend:.5,scaleMode:"blend",screenSpace:!0}),n.root.addChild(i);var s=new KM;function r(e,a,i){var s=new KM;s.addComponent("button",{imageEntity:s}),s.addComponent("element",{anchor:[.5,.5,.5,.5],height:40,pivot:[.5,.5],type:"image",width:128,useInput:!0});var r=new KM;return r.addComponent("element",{anchor:[.5,.5,.5,.5],color:new Mu(0,0,0),fontAsset:t.font.id,fontSize:32,height:64,pivot:[.5,.5],text:e,type:"text",width:128,wrapLines:!0}),s.addChild(r),s.button.on("click",(function(t){n.i18n.locale=e})),s.setLocalPosition(a,i,0),s}s.addComponent("element",{anchor:[.5,.5,.5,.5],autoWidth:!1,fontAsset:t.font.id,fontSize:128,pivot:[.5,.5],key:"HELLO",type:"text",width:640}),i.addChild(s),i.addChild(r("en-US",-225,-100)),i.addChild(r("fr-FR",-75,-100)),i.addChild(r("es-ES",75,-100)),i.addChild(r("pt-BR",225,-100))},e.CATEGORY="User Interface",e.NAME="Text Localization",e}(),mP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/courier.json"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.start();var a=new KM;a.addComponent("camera",{clearColor:new Mu(30/255,30/255,30/255)}),n.root.addChild(a);var i=new KM;i.addComponent("screen",{referenceResolution:new Du(1280,720),scaleBlend:.5,scaleMode:"blend",screenSpace:!0}),n.root.addChild(i);var s="Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",r=new KM;r.addComponent("element",{anchor:[.5,.5,.5,.5],autoWidth:!1,fontAsset:t.font.id,fontSize:32,pivot:[.5,.5],text:s,type:"text",width:512,wrapLines:!0}),i.addChild(r),r.element.rangeStart=0,r.element.rangeEnd=0,setInterval((function(){r.element.rangeEnd+=1,r.element.rangeEnd>=s.length&&(r.element.rangeEnd=0)}),75)},e.CATEGORY="User Interface",e.NAME="Text Typewriter",e}(),fP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/courier.json"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.start(),n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)}));var a=new KM;a.addComponent("camera",{clearColor:new Mu(30/255,30/255,30/255)}),n.root.addChild(a);var i=new KM;i.addComponent("screen",{referenceResolution:new Du(1280,720),scaleBlend:.5,scaleMode:"blend",screenSpace:!0}),n.root.addChild(i);var s=new KM;s.setLocalPosition(0,200,0),s.addComponent("element",{pivot:new Du(.5,.5),anchor:new Ou(.5,.5,.5,.5),fontAsset:t.font.id,fontSize:42,text:"Basic Text",type:"text"}),i.addChild(s);var r=new KM;r.setLocalPosition(0,50,0),r.addComponent("element",{pivot:new Du(.5,.5),anchor:new Ou(.5,.5,.5,.5),fontAsset:t.font.id,fontSize:32,text:'There are seven colors in the rainbow: [color="#ff0000"]red[/color], [color="#ffa500"]orange[/color], [color="#ffff00"]yellow[/color], [color="#00ff00"]green[/color], [color="#0000ff"]blue[/color], [color="#4b0082"]indigo[/color] and [color="#7f00ff"]violet[/color].',width:500,height:100,autoWidth:!1,autoHeight:!1,wrapLines:!0,enableMarkup:!0,type:"text"}),i.addChild(r);var o=new KM;o.setLocalPosition(0,-100,0),o.addComponent("element",{pivot:new Du(.5,.5),anchor:new Ou(.5,.5,.5,.5),fontAsset:t.font.id,fontSize:62,text:"Outline",color:new Mu(0,0,0),outlineColor:new Mu(1,1,1),outlineThickness:.75,type:"text"}),i.addChild(o);var l=new KM;l.setLocalPosition(0,-200,0),l.addComponent("element",{pivot:new Du(.5,.5),anchor:new Ou(.5,.5,.5,.5),fontAsset:t.font.id,fontSize:62,text:"Drop Shadow",shadowColor:new Mu(1,0,0),shadowOffset:new Du(.25,-.25),type:"text"}),i.addChild(l)},e.CATEGORY="User Interface",e.NAME="Text",e}(),gP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"checkboard",type:"texture",url:"/static/assets/textures/checkboard.png"}),N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/courier.json"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.start();var a=new KM;a.addComponent("camera",{clearColor:new Mu(30/255,30/255,30/255)}),a.rotateLocal(-30,0,0),a.translateLocal(0,0,7),n.root.addChild(a);var i=new cg;i.diffuse=Mu.WHITE,i.diffuseMap=t.checkboard.resource,i.diffuseMapTiling=new Du(50,50),i.update();var s=new KM;s.addComponent("render",{type:"box",material:i}),s.setLocalScale(50,1,50),s.setLocalPosition(0,-.5,0),n.root.addChild(s);var r=new KM;r.addComponent("light",{type:"directional",color:new Mu(1,1,1),castShadows:!0,intensity:1,shadowBias:.2,shadowDistance:16,normalOffsetBias:.05,shadowResolution:2048}),r.setLocalEulerAngles(45,30,0),n.root.addChild(r);var o=new KM;function l(e,i,s,r){var l=new KM;l.setLocalScale(new Pu(.5,.5,.5)),l.addComponent("render",{type:"capsule"}),n.root.addChild(l);var c=i;n.on("update",(function(e){(c+=e*s)>360&&(c-=360),l.setLocalPosition(r*Math.sin(c*Eu.DEG_TO_RAD),.5,r*Math.cos(c*Eu.DEG_TO_RAD)),l.setLocalEulerAngles(0,c+90,0)}));var h=new KM;h.addComponent("element",{pivot:new Du(.5,0),anchor:new Ou(0,0,0,0),width:150,height:50,opacity:.05,type:"image"}),o.addChild(h);var d=new KM;d.addComponent("element",{pivot:new Du(.5,.5),anchor:new Ou(0,.4,1,1),margin:new Ou(0,0,0,0),fontAsset:t.font.id,fontSize:20,text:"Player ".concat(e),useInput:!0,type:"text"}),d.addComponent("button",{imageEntity:d}),d.button.on("click",(function(e){var t=new Mu(Math.random(),Math.random(),Math.random());d.element.color=t,l.render.material.setParameter("material_diffuse",[t.r,t.g,t.b])})),h.addChild(d);var p=new KM;p.addComponent("element",{pivot:new Du(.5,0),anchor:new Ou(0,0,1,.4),margin:new Ou(0,0,0,0),color:new Mu(.2,.6,.2,1),opacity:1,type:"image"}),h.addChild(p),n.on("update",(function(){var e=l.getPosition();e.y+=.6;var t=function(e,t,a){var i=t.worldToScreen(e),s=n.graphicsDevice.maxPixelRatio;i.x*=s,i.y*=s;var r=a.scale;return i.y=a.resolution.y-i.y,new Pu(i.x/r,i.y/r,i.z/r)}(e,a.camera,o.screen);t.z>0?(h.enabled=!0,h.setLocalPosition(t)):h.enabled=!1}))}o.setLocalScale(.01,.01,.01),o.addComponent("screen",{referenceResolution:new Du(1280,720),screenSpace:!0}),n.root.addChild(o),l(1,135,30,1.5),l(2,65,-18,1),l(3,0,15,2.5)},e.CATEGORY="User Interface",e.NAME="World to Screen",e}(),yP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"checkboard",type:"texture",url:"/static/assets/textures/checkboard.png"}),N.createElement(dR,{name:"font",type:"font",url:"/static/assets/fonts/courier.json"}),N.createElement(dR,{name:"script",type:"script",url:"/static/scripts/camera/orbit-camera.js"}))},e.prototype.example=function(e,t){var n=new jM(e,{mouse:new yL(document.body),touch:new aR(document.body),elementInput:new $L(e)});n.start();var a=new KM;a.addComponent("camera",{clearColor:new Mu(30/255,30/255,30/255)}),a.rotateLocal(-30,0,0),a.translateLocal(0,0,7),a.addComponent("script"),a.script.create("orbitCamera",{attributes:{inertiaFactor:.2}}),a.script.create("orbitCameraInputMouse"),a.script.create("orbitCameraInputTouch"),n.root.addChild(a);var i=new cg;i.diffuse=Mu.WHITE,i.diffuseMap=t.checkboard.resource,i.diffuseMapTiling=new Du(50,50),i.update();var s=new KM;s.addComponent("render",{type:"box",material:i}),s.setLocalScale(50,1,50),s.setLocalPosition(0,-.5,0),n.root.addChild(s);var r=new KM;r.addComponent("light",{type:"directional",color:new Mu(1,1,1),castShadows:!0,intensity:1,shadowBias:.2,shadowDistance:16,normalOffsetBias:.05,shadowResolution:2048}),r.setLocalEulerAngles(45,30,0),n.root.addChild(r);var o=new KM;o.setLocalScale(.01,.01,.01),o.setPosition(0,.01,0),o.setLocalRotation((new Gu).setFromEulerAngles(-90,0,0)),o.addComponent("screen",{referenceResolution:new Du(1280,720),screenSpace:!1}),n.root.addChild(o);var l=new KM;l.setLocalPosition(0,25,0),l.addComponent("element",{pivot:new Du(.5,.5),anchor:new Ou(.5,.5,.5,.5),fontAsset:t.font.id,fontSize:18,text:"this is a UI screen placed in the 3D world",width:200,height:100,autoWidth:!1,autoHeight:!1,wrapLines:!0,enableMarkup:!0,type:"text"}),o.addChild(l);var c=new KM;c.setLocalPosition(0,-25,0),c.addComponent("button",{imageEntity:c}),c.addComponent("element",{anchor:[.5,.5,.5,.5],width:100,height:25,pivot:[.5,.5],type:"image",useInput:!0}),o.addChild(c);var h=new KM;h.addComponent("element",{pivot:new Du(.5,.5),anchor:new Ou(0,0,1,1),margin:new Ou(0,0,0,0),color:new Mu(0,0,0),fontAsset:t.font.id,fontSize:12,text:"and this is a button",type:"text",wrapLines:!0}),c.addChild(h),c.button.on("click",(function(e){a.camera.clearColor=new Mu(Math.random(),Math.random(),Math.random())}))},e.CATEGORY="User Interface",e.NAME="World UI",e}(),bP=Object.freeze({__proto__:null,ButtonBasicExample:sP,ButtonSpriteExample:rP,CustomShaderExample:oP,LayoutGroupExample:lP,ParticleSystemExample:cP,ScrollViewExample:hP,TextAutoFontSizeExample:dP,TextEmojisExample:pP,TextLocalizationExample:uP,TextTypewriterExample:mP,TextExample:fP,WorldToScreenExample:gP,WorldUiExample:yP}),vP=function(){function e(){}return e.prototype.example=function(e){var t=function(e){var t=document.querySelector(".message");t||((t=document.createElement("div")).classList.add("message"),document.body.append(t)),t.textContent=e},n=new jM(e,{mouse:new yL(e),touch:new aR(e),keyboard:new mL(window),graphicsDeviceOptions:{alpha:!0}});n.graphicsDevice.maxPixelRatio=window.devicePixelRatio,n.start();var a=new KM;a.addComponent("camera",{clearColor:new Mu(0,0,0,0),farClip:1e4}),n.root.addChild(a);var i=new KM;i.addComponent("light",{type:"spot",range:30}),i.translate(0,10,0),n.root.addChild(i);for(var s=function(e,t,a){var i=new KM;i.addComponent("model",{type:"box"}),i.setLocalScale(.5,.5,.5),i.translate(.5*e,t,.5*a),n.root.addChild(i)},r=0;r<4;r++)for(var o=0;o<4;o++)s(2*r-4,.25,2*o-4);if(n.xr.supported){var l=function(){n.xr.isAvailable(Zx)?a.camera.startXr(Zx,"local-floor",{callback:function(e){e&&t("WebXR Immersive AR failed to start: "+e.message)}}):t("Immersive AR is not available")};n.mouse.on("mousedown",(function(){n.xr.active||l()})),n.touch&&n.touch.on("touchend",(function(e){n.xr.active?a.camera.endXr():l(),e.event.preventDefault(),e.event.stopPropagation()})),n.keyboard.on("keydown",(function(e){27===e.key&&n.xr.active&&n.xr.end()})),n.xr.on("start",(function(){t("Immersive AR session has started")})),n.xr.on("end",(function(){t("Immersive AR session has ended")})),n.xr.on("available:"+Zx,(function(e){t("Immersive AR is "+(e?"available":"unavailable"))})),n.xr.isAvailable(Zx)||t("Immersive AR is not available")}else t("WebXR is not supported")},e.CATEGORY="XR",e.NAME="AR Basic",e}(),_P=function(){function e(){}return e.prototype.example=function(e){var t=function(e){var t=document.querySelector(".message");t||((t=document.createElement("div")).classList.add("message"),document.body.append(t)),t.textContent=e},n=new jM(e,{mouse:new yL(e),touch:new aR(e),keyboard:new mL(window),graphicsDeviceOptions:{alpha:!0}});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)})),n.graphicsDevice.maxPixelRatio=window.devicePixelRatio,n.start();var a=new KM;a.addComponent("camera",{clearColor:new Mu(0,0,0,0),farClip:1e4}),n.root.addChild(a);var i=new KM;i.addComponent("light",{type:"spot",range:30}),i.translate(0,10,0),n.root.addChild(i);var s=new KM;if(s.addComponent("model",{type:"cylinder"}),s.setLocalScale(.5,.01,.5),n.root.addChild(s),n.xr.supported){var r=function(){n.xr.isAvailable(Zx)?a.camera.startXr(Zx,"local-floor",{callback:function(e){e&&t("WebXR Immersive AR failed to start: "+e.message)}}):t("Immersive AR is not available")};n.mouse.on("mousedown",(function(){n.xr.active||r()})),n.touch&&n.touch.on("touchend",(function(e){n.xr.active?a.camera.endXr():r(),e.event.preventDefault(),e.event.stopPropagation()})),n.keyboard.on("keydown",(function(e){27===e.key&&n.xr.active&&n.xr.end()})),n.xr.on("start",(function(){t("Immersive AR session has started"),n.xr.hitTest.supported&&n.xr.hitTest.start({entityTypes:["point","plane"],callback:function(e,n){e?t("Failed to start AR hit test"):n.on("result",(function(e,t){s.setPosition(e),s.setRotation(t)}))}})})),n.xr.on("end",(function(){t("Immersive AR session has ended")})),n.xr.on("available:"+Zx,(function(e){e?n.xr.hitTest.supported?t("Touch screen to start AR session and look at the floor or walls"):t("AR Hit Test is not supported"):t("Immersive AR is unavailable")})),n.xr.isAvailable(Zx)?n.xr.hitTest.supported?t("Touch screen to start AR session and look at the floor or walls"):t("AR Hit Test is not supported"):t("Immersive AR is not available")}else t("WebXR is not supported")},e.CATEGORY="XR",e.NAME="AR Hit Test",e}(),wP=function(){function e(){}return e.prototype.example=function(e){var t=function(e){var t=document.querySelector(".message");t||((t=document.createElement("div")).classList.add("message"),document.body.append(t)),t.textContent=e},n=new jM(e,{mouse:new yL(e),touch:new aR(e),keyboard:new mL(window)});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)})),n.graphicsDevice.maxPixelRatio=window.devicePixelRatio,n.start();var a=new KM;a.addComponent("camera",{clearColor:new Mu(44/255,62/255,80/255),farClip:1e4}),n.root.addChild(a);var i=new KM;i.addComponent("light",{type:"spot",range:30}),i.translate(0,10,0),n.root.addChild(i);for(var s=function(e,t,a){var i=new KM;i.addComponent("render",{type:"box"}),i.setLocalScale(1,1,1),i.translate(e,t,a),n.root.addChild(i)},r=0;r<16;r++)for(var o=0;o<16;o++)s(2*r-16,-1.5,2*o-16);if(n.xr.supported){var l=function(){n.xr.isAvailable(Kx)?a.camera.startXr(Kx,"local",{callback:function(e){e&&t("WebXR Immersive VR failed to start: "+e.message)}}):t("Immersive VR is not available")};n.mouse.on("mousedown",(function(){n.xr.active||l()})),n.touch&&n.touch.on("touchend",(function(e){n.xr.active?a.camera.endXr():l(),e.event.preventDefault(),e.event.stopPropagation()})),n.keyboard.on("keydown",(function(e){27===e.key&&n.xr.active&&n.xr.end()})),n.xr.on("start",(function(){t("Immersive VR session has started")})),n.xr.on("end",(function(){t("Immersive VR session has ended")})),n.xr.on("available:"+Kx,(function(e){t("Immersive VR is "+(e?"available":"unavailable"))})),n.xr.isAvailable(Kx)||t("Immersive VR is not available")}else t("WebXR is not supported")},e.CATEGORY="XR",e.NAME="VR Basic",e}(),xP=function(){function e(){}return e.prototype.load=function(){return N.createElement(N.Fragment,null,N.createElement(dR,{name:"glb",type:"container",url:"/static/assets/models/vr-controller.glb"}))},e.prototype.example=function(e,t){var n=function(e){var t=document.querySelector(".message");t||((t=document.createElement("div")).classList.add("message"),document.body.append(t)),t.textContent=e},a=new jM(e,{mouse:new yL(e),touch:new aR(e),keyboard:new mL(window)});a.setCanvasFillMode("FILL_WINDOW"),a.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){a.resizeCanvas(e.width,e.height)})),a.graphicsDevice.maxPixelRatio=window.devicePixelRatio,a.start();var i=new KM;i.addComponent("camera",{clearColor:new Mu(44/255,62/255,80/255)}),a.root.addChild(i);var s=new KM;s.addComponent("light",{type:"directional",castShadows:!0,shadowBias:.05,normalOffsetBias:.05,shadowDistance:5}),s.setEulerAngles(45,135,0),a.root.addChild(s);for(var r=function(e,t,n){var i=new KM;i.addComponent("model",{type:"box",material:new cg}),i.translate(e,t,n),a.root.addChild(i)},o=[],l=0;l<=4;l++)for(var c=0;c<=4;c++)r(2*l-4,-1.5,2*c-4);if(a.xr.supported){var h=function(){a.xr.isAvailable(Kx)?i.camera.startXr(Kx,"local",{callback:function(e){e&&n("Immersive VR failed to start: "+e.message)}}):n("Immersive VR is not available")};a.mouse.on("mousedown",(function(){a.xr.active||h()})),a.touch&&a.touch.on("touchend",(function(e){a.xr.active?i.camera.endXr():h(),e.event.preventDefault(),e.event.stopPropagation()})),a.keyboard.on("keydown",(function(e){27===e.key&&a.xr.active&&a.xr.end()})),a.xr.input.on("add",(function(e){n("Controller Added"),function(e){var n=new KM;n.addComponent("model",{type:"asset",asset:t.glb.resource.model,castShadows:!0}),a.root.addChild(n),n.inputSource=e,o.push(n),e.on("remove",(function(){o.splice(o.indexOf(n),1),n.destroy()}))}(e)})),n("Tap on screen to enter VR, and see controllers"),a.on("update",(function(){for(var e=0;e<o.length;e++){var t=o[e].inputSource;t.grip?(o[e].enabled=!0,o[e].setLocalPosition(t.getLocalPosition()),o[e].setLocalRotation(t.getLocalRotation())):o[e].enabled=!1}}))}else n("WebXR is not supported")},e.CATEGORY="XR",e.NAME="VR Controllers",e}(),CP=function(){function e(){}return e.prototype.example=function(e){var t=function(e){var t=document.querySelector(".message");t||((t=document.createElement("div")).classList.add("message"),document.body.append(t)),t.textContent=e},n=new jM(e,{mouse:new yL(e),touch:new aR(e),keyboard:new mL(window)});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)})),n.graphicsDevice.maxPixelRatio=window.devicePixelRatio,n.scene.ambientLight=new Mu(.1,.1,.1),n.start();var a=new KM;a.addComponent("camera",{clearColor:new Mu(44/255,62/255,80/255)}),n.root.addChild(a);var i=new KM;i.addComponent("light",{type:"directional"}),i.setEulerAngles(45,135,0),n.root.addChild(i);for(var s=function(e,t,a){var i=new KM;i.addComponent("model",{type:"box",material:new cg}),i.translate(e,t,a),n.root.addChild(i)},r=[],o=0;o<=4;o++)for(var l=0;l<=4;l++)s(2*o-4,-1.5,2*l-4);if(n.xr.supported){var c=function(){n.xr.isAvailable(Kx)?a.camera.startXr(Kx,"local",{callback:function(e){e&&t("Immersive VR failed to start: "+e.message)}}):t("Immersive VR is not available")};n.mouse.on("mousedown",(function(){n.xr.active||c()})),n.touch&&n.touch.on("touchend",(function(e){n.xr.active?a.camera.endXr():c(),e.event.preventDefault(),e.event.stopPropagation()})),n.keyboard.on("keydown",(function(e){27===e.key&&n.xr.active&&n.xr.end()})),n.xr.input.on("add",(function(e){t("Controller Added"),function(e){var t=new KM;if(e.hand){t.joints=[];for(var a=new cg,i=0;i<e.hand.joints.length;i++){var s=e.hand.joints[i],o=new KM;o.addComponent("model",{type:"box",material:a}),o.joint=s,t.joints.push(o),t.addChild(o)}e.hand.on("trackinglost",(function(){t.joints[0].model.material.diffuse.set(1,0,0),t.joints[0].model.material.update()})),e.hand.on("tracking",(function(){t.joints[0].model.material.diffuse.set(1,1,1),t.joints[0].model.material.update()}))}else t.addComponent("model",{type:"box",castShadows:!0}),t.setLocalScale(.05,.05,.05);n.root.addChild(t),t.inputSource=e,r.push(t),e.on("remove",(function(){r.splice(r.indexOf(t),1),t.destroy()}))}(e)})),window.XRHand?t("Tap on screen to enter VR, and switch to hand input"):t("WebXR Hands Input is not supported by your platform"),n.on("update",(function(){for(var e=0;e<r.length;e++){var t=r[e].inputSource;if(t.hand){r[e].enabled=!0;for(var n=0;n<r[e].joints.length;n++){var a=r[e].joints[n].joint,i=2*a.radius;r[e].joints[n].setLocalScale(i,i,i),r[e].joints[n].setPosition(a.getPosition()),r[e].joints[n].setRotation(a.getRotation())}}else t.grip?(r[e].enabled=!0,r[e].setLocalPosition(t.getLocalPosition()),r[e].setLocalRotation(t.getLocalRotation())):r[e].enabled=!1}}))}else t("WebXR is not supported")},e.CATEGORY="XR",e.NAME="VR Hands",e}(),TP=function(){function e(){}return e.prototype.example=function(e){var t=function(e){var t=document.querySelector(".message");t||((t=document.createElement("div")).classList.add("message"),document.body.append(t)),t.textContent=e},n=new jM(e,{mouse:new yL(e),touch:new aR(e),keyboard:new mL(window)});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)})),n.graphicsDevice.maxPixelRatio=window.devicePixelRatio,n.start();var a=new KM;n.root.addChild(a);var i=new KM;i.addComponent("camera",{clearColor:new Mu(44/255,62/255,80/255),farClip:1e4}),a.addChild(i);var s=new KM;s.addComponent("light",{type:"spot",range:30}),s.translate(0,10,0),n.root.addChild(s);for(var r=function(e,t,a){var i=new KM;i.addComponent("model",{type:"box",material:new cg}),i.setLocalScale(1,1,1),i.translate(e,t,a),n.root.addChild(i)},o=[],l=0;l<=4;l++)for(var c=0;c<=4;c++)r(2*l-4,-1.5,2*c-4);if(n.xr.supported){var h=function(){n.xr.isAvailable(Kx)?i.camera.startXr(Kx,"local",{callback:function(e){e&&t("Immersive VR failed to start: "+e.message)}}):t("Immersive VR is not available")};n.mouse.on("mousedown",(function(){n.xr.active||h()})),n.touch&&n.touch.on("touchend",(function(e){n.xr.active?i.camera.endXr():h(),e.event.preventDefault(),e.event.stopPropagation()})),n.keyboard.on("keydown",(function(e){27===e.key&&n.xr.active&&n.xr.end()})),n.xr.input.on("add",(function(e){!function(e){var t=new KM;t.addComponent("model",{type:"box"}),t.setLocalScale(.05,.05,.05),a.addChild(t),t.inputSource=e,o.push(t),e.on("remove",(function(){o.splice(o.indexOf(t),1),t.destroy()}))}(e)})),t("Tap on screen to enter VR, use left thumbstick to move and right thumbstick to rotate");var d=0,p=new Du,u=new Du,m=new Pu,f=new Pu,g=new Mu(1,1,1);n.on("update",(function(e){var t,s;for(t=0;t<o.length;t++)if((s=o[t].inputSource).gamepad)if("left"===s.handedness){if(p.set(s.gamepad.axes[2],s.gamepad.axes[3]),p.length()){p.normalize(),u.x=i.forward.x,u.y=i.forward.z,u.normalize();var r=Math.atan2(u.x,u.y)-Math.PI/2,l=p.x*Math.sin(r)-p.y*Math.cos(r);p.y=p.y*Math.sin(r)+p.x*Math.cos(r),p.x=l,p.mulScalar(1.5*e),a.translate(p.x,0,p.y)}}else if("right"===s.handedness){var c=-s.gamepad.axes[2];(d>0&&c<.25||d<0&&c>-.25)&&(d=0),0===d&&Math.abs(c)>.5&&(d=Math.sign(c),m.copy(i.getLocalPosition()),a.translateLocal(m),a.rotateLocal(0,45*Math.sign(c),0),a.translateLocal(m.mulScalar(-1)))}for(t=0;t<o.length;t++)s=o[t].inputSource,m.copy(s.getOrigin()),f.copy(s.getDirection()),f.mulScalar(100).add(m),n.drawLine(m,f,g),s.grip?(o[t].model.enabled=!0,o[t].setLocalPosition(s.getLocalPosition),o[t].setLocalRotation(s.getLocalRotation)):o[t].model.enabled=!1}))}else t("WebXR is not supported")},e.CATEGORY="XR",e.NAME="VR Movement",e}(),EP=function(){function e(){}return e.prototype.example=function(e){var t=function(e){var t=document.querySelector(".message");t||((t=document.createElement("div")).classList.add("message"),document.body.append(t)),t.textContent=e},n=new jM(e,{mouse:new yL(e),touch:new aR(e),keyboard:new mL(window)});n.setCanvasFillMode("FILL_WINDOW"),n.setCanvasResolution("AUTO"),window.addEventListener("resize",(function(){n.resizeCanvas(e.width,e.height)})),n.graphicsDevice.maxPixelRatio=window.devicePixelRatio,n.start();var a=new KM;a.addComponent("camera",{clearColor:new Mu(44/255,62/255,80/255),farClip:1e4}),n.root.addChild(a);var i=new KM;i.addComponent("light",{type:"spot",range:30}),i.translate(0,10,0),n.root.addChild(i);for(var s=[],r=function(e,t,a){var i=new KM;i.addComponent("model",{type:"box",material:new cg}),i.setLocalScale(1,1,1),i.translate(e,t,a),n.root.addChild(i),s.push(i)},o=0;o<=4;o++)for(var l=0;l<=4;l++)r(2*o-4,-1.5,2*l-4);if(n.xr.supported){var c=function(){n.xr.isAvailable(Kx)?a.camera.startXr(Kx,"local",{callback:function(e){e&&t("Immersive VR failed to start: "+e.message)}}):t("Immersive VR is not available")};n.mouse.on("mousedown",(function(){n.xr.active||c()})),n.touch&&n.touch.on("touchend",(function(e){n.xr.active?a.camera.endXr():c(),e.event.preventDefault(),e.event.stopPropagation()})),n.keyboard.on("keydown",(function(e){27===e.key&&n.xr.active&&n.xr.end()})),t("Tap on screen to enter VR, and then pick objects");var h=new tm;n.xr.input.on("select",(function(e){for(var t=null,n=1/0,i=0;i<s.length;i++){var r=s[i].model.meshInstances[0];if(h.set(e.getOrigin(),e.getDirection()),r.aabb.intersectsRay(h)){var o=r.aabb.center.distance(a.getPosition());o<n&&(t=r,n=o)}}t&&(t.material.diffuse.set(Math.random(),Math.random(),Math.random()),t.material.update())}));var d=new Pu,p=new Mu(1,1,1);n.on("update",(function(){for(var e=0;e<n.xr.input.inputSources.length;e++){var t=n.xr.input.inputSources[e],a=t.getDirection(),i=t.getOrigin();d.copy(a).mulScalar(100).add(i),n.drawLine(t.getOrigin(),d,p)}}))}else t("WebXR is not supported")},e.CATEGORY="XR",e.NAME="XR Picking",e}(),SP=Object.freeze({__proto__:null,ArBasicExample:vP,ArHitTestExample:_P,VrBasicExample:wP,VrControllersExample:xP,VrHandsExample:CP,VrMovementExample:TP,XrPickingExample:EP}),AP=Object.freeze({__proto__:null,Animation:BR,Camera:HR,Graphics:VI,Input:GI,Loaders:YI,Physics:nP,Misc:$I,Sound:iP,UserInterface:bP,Xr:SP});function MP(e){return e.charAt(0).toUpperCase()+e.slice(1)}const LP={},RP={};Object.keys(zp).forEach((e=>{const t=e.split("-").map((e=>MP(e))).join(""),n=AP[t];n&&(LP[e]={examples:{}},Object.keys(zp[e]).forEach(((t,a)=>{const i=t.split("-").map((e=>MP(e))).join("").replace("1d","1D").replace("2d","2D"),s=n[`${i}Example`];if(0===a&&(LP[e].name=s.CATEGORY),s.HIDDEN)return;const r=new s;LP[e].examples[t]=r;const o=[{name:"example.js",text:zp[e][t].javaScriptFunction,type:"javascript"},{name:"example.ts",text:zp[e][t].typeScriptFunction,type:"typescript"}];if(r.load){let e=r.load().props.children;Array.isArray(e)||(e=[e]),e.forEach((e=>{"shader"===e.props.type?o.push({name:e.props.name,text:e.props.data,type:"shader"}):"json"===e.props.type&&o.push({name:e.props.name,text:JSON.stringify(e.props.data,null,4),type:"json"})}))}RP[`/${e}/${t}`]={path:`/${e}/${t}`,example:s,files:o}})))}));var IP={categories:LP,paths:RP},PP=function(){document.getElementById("sideBar").classList.toggle("collapsed")},kP=function(){var t=IP.categories,n=e.exports.useState(null),a=n[0],i=n[1],s=e.exports.useState(location.hash),r=s[0],o=s[1],l=new vh({largeThumbnails:!1});e.exports.useEffect((function(){var e,t=document.getElementById("sideBar"),n=document.querySelector(".sideBar-panel-toggle");if(n.removeEventListener("click",PP),n.addEventListener("click",PP),window.addEventListener("hashchange",(function(){o(location.hash)})),l.on("largeThumbnails:set",(function(){var e,n=Number.MAX_VALUE;document.querySelectorAll(".nav-item").forEach((function(t){var a=Math.abs(120-t.getBoundingClientRect().top);a<n&&(n=a,e=t)})),t.classList.toggle("small-thumbnails"),e.scrollIntoView()})),!a&&document.body.offsetWidth<601&&(t.ui.collapsed=!0),t.classList.add("visible"),!window._scrolledToExample){var i=location.hash.split("/");null===(e=document.getElementById("link-".concat(i[1],"-").concat(i[2])))||void 0===e||e.scrollIntoView(),window._scrolledToExample=!0}}));var c=a||t;return N.createElement(N.Fragment,null,N.createElement(Lp,{headerText:"EXAMPLES",collapsible:document.body.offsetWidth<601,collapsed:!0,id:"sideBar",class:"small-thumbnails"},N.createElement(Ip,{class:"filter-input",keyChange:!0,placeholder:"Filter...",onChange:function(e){var n=e&&e.length>0?new RegExp(e,"i"):null;if(n){var a={};Object.keys(t).forEach((function(e){if(-1!==t[e].name.search(n))return a[e]=t[e],null;Object.keys(t[e].examples).forEach((function(i){var s;-1!==t[e].examples[i].constructor.NAME.search(n)&&(a[e]?a[e].examples[i]=t[e].examples[i]:a[e]={name:t[e].name,examples:(s={},s[i]=t[e].examples[i],s)})}))})),i(a)}else i(t)}}),N.createElement(Dp,{text:"Large thumbnails:"},N.createElement(Fp,{type:"toggle",binding:new Up,link:{observer:l,path:"largeThumbnails"}})),N.createElement(Ah,{id:"sideBar-contents"},Object.keys(c).sort((function(e,t){return e>t?1:-1})).map((function(e){return N.createElement(Lp,{key:e,class:"categoryPanel",headerText:c[e].name,collapsible:!0,collapsed:!1},N.createElement("ul",{className:"category-nav"},Object.keys(c[e].examples).sort((function(e,t){return e>t?1:-1})).map((function(t){var n=new RegExp("/".concat(e,"/").concat(t,"$")).test(r),a="nav-item ".concat(n?"selected":"");return N.createElement(Cp,{key:t,to:"/".concat(e,"/").concat(t),onClick:function(){document.getElementById("sideBar").ui.collapsed=!0}},N.createElement("div",{className:a,id:"link-".concat(e,"-").concat(t)},N.createElement("img",{className:"small-thumbnail",loading:"lazy",src:"./thumbnails/".concat(e,"_").concat(t,"_small.png")}),N.createElement("img",{className:"large-thumbnail",loading:"lazy",src:"./thumbnails/".concat(e,"_").concat(t,"_large.png")}),N.createElement("div",{className:"nav-item-text"},c[e].examples[t].constructor.NAME.toUpperCase())))}))))})),0===Object.keys(c).length&&N.createElement(Pp,{text:"No results"}))),N.createElement("div",{className:"panel-toggle sideBar-panel-toggle"}))};function DP(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function OP(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function FP(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?OP(Object(n),!0).forEach((function(t){DP(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):OP(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function NP(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,a=new Array(t);n<t;n++)a[n]=e[n];return a}function VP(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function BP(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function UP(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?BP(Object(n),!0).forEach((function(t){VP(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):BP(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function zP(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(e){return t.reduceRight((function(e,t){return t(e)}),e)}}function GP(e){return function t(){for(var n=this,a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];return i.length>=e.length?e.apply(this,i):function(){for(var e=arguments.length,a=new Array(e),s=0;s<e;s++)a[s]=arguments[s];return t.apply(n,[].concat(i,a))}}}function HP(e){return{}.toString.call(e).includes("Object")}function WP(e){return"function"==typeof e}var jP=GP((function(e,t){throw new Error(e[t]||e.default)}))({initialIsRequired:"initial state is required",initialType:"initial state should be an object",initialContent:"initial state shouldn't be an empty object",handlerType:"handler should be an object or a function",handlersType:"all handlers should be a functions",selectorType:"selector should be a function",changeType:"provided value of changes should be an object",changeField:'it seams you want to change a field in the state which is not specified in the "initial" state',default:"an unknown error accured in `state-local` package"}),XP={changes:function(e,t){return HP(t)||jP("changeType"),Object.keys(t).some((function(t){return n=e,a=t,!Object.prototype.hasOwnProperty.call(n,a);var n,a}))&&jP("changeField"),t},selector:function(e){WP(e)||jP("selectorType")},handler:function(e){WP(e)||HP(e)||jP("handlerType"),HP(e)&&Object.values(e).some((function(e){return!WP(e)}))&&jP("handlersType")},initial:function(e){var t;e||jP("initialIsRequired"),HP(e)||jP("initialType"),t=e,Object.keys(t).length||jP("initialContent")}};function YP(e,t){return WP(t)?t(e.current):t}function qP(e,t){return e.current=UP(UP({},e.current),t),t}function KP(e,t,n){return WP(t)?t(e.current):Object.keys(n).forEach((function(n){var a;return null===(a=t[n])||void 0===a?void 0:a.call(t,e.current[n])})),n}var ZP={create:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};XP.initial(e),XP.handler(t);var n={current:e},a=GP(KP)(n,t),i=GP(qP)(n),s=GP(XP.changes)(e),r=GP(YP)(n);function o(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(e){return e};return XP.selector(e),e(n.current)}function l(e){zP(a,i,s,r)(e)}return[o,l]}};var $P,QP={configIsRequired:"the configuration object is required",configType:"the configuration object should be an object",default:"an unknown error accured in `@monaco-editor/loader` package",deprecation:"Deprecation warning!\n    You are using deprecated way of configuration.\n\n    Instead of using\n      monaco.config({ urls: { monacoBase: '...' } })\n    use\n      monaco.config({ paths: { vs: '...' } })\n\n    For more please check the link https://github.com/suren-atoyan/monaco-loader#config\n  "},JP=($P=function(e,t){throw new Error(e[t]||e.default)},function e(){for(var t=this,n=arguments.length,a=new Array(n),i=0;i<n;i++)a[i]=arguments[i];return a.length>=$P.length?$P.apply(this,a):function(){for(var n=arguments.length,i=new Array(n),s=0;s<n;s++)i[s]=arguments[s];return e.apply(t,[].concat(a,i))}})(QP),ek={config:function(e){var t;return e||JP("configIsRequired"),t=e,{}.toString.call(t).includes("Object")||JP("configType"),e.urls?(console.warn(QP.deprecation),{paths:{vs:e.urls.monacoBase}}):e}};function tk(e,t){return Object.keys(t).forEach((function(n){t[n]instanceof Object&&e[n]&&Object.assign(t[n],tk(e[n],t[n]))})),FP(FP({},e),t)}var nk={type:"cancelation",msg:"operation is manually canceled"};function ak(e){var t=!1,n=new Promise((function(n,a){e.then((function(e){return t?a(nk):n(e)})),e.catch(a)}));return n.cancel=function(){return t=!0},n}var ik,sk,rk=ZP.create({config:{paths:{vs:"https://cdn.jsdelivr.net/npm/monaco-editor@0.28.1/min/vs"}},isInitialized:!1,resolve:null,reject:null,monaco:null}),ok=(sk=2,function(e){if(Array.isArray(e))return e}(ik=rk)||function(e,t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e)){var n=[],a=!0,i=!1,s=void 0;try{for(var r,o=e[Symbol.iterator]();!(a=(r=o.next()).done)&&(n.push(r.value),!t||n.length!==t);a=!0);}catch(e){i=!0,s=e}finally{try{a||null==o.return||o.return()}finally{if(i)throw s}}return n}}(ik,sk)||function(e,t){if(e){if("string"==typeof e)return NP(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?NP(e,t):void 0}}(ik,sk)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),lk=ok[0],ck=ok[1];function hk(e){return document.body.appendChild(e)}function dk(e){var t=lk((function(e){return{config:e.config,reject:e.reject}})),n=function(e){var t=document.createElement("script");return e&&(t.src=e),t}("".concat(t.config.paths.vs,"/loader.js"));return n.onload=function(){return e()},n.onerror=t.reject,n}function pk(){var e=lk((function(e){return{config:e.config,resolve:e.resolve,reject:e.reject}})),t=window.require;t.config(e.config),t(["vs/editor/editor.main"],(function(t){uk(t),e.resolve(t)}),(function(t){e.reject(t)}))}function uk(e){lk().monaco||ck({monaco:e})}var mk=new Promise((function(e,t){return ck({resolve:e,reject:t})})),fk={config:function(e){ck((function(t){return{config:tk(t.config,ek.config(e))}}))},init:function(){if(!lk((function(e){return{isInitialized:e.isInitialized}})).isInitialized){if(window.monaco&&window.monaco.editor)return uk(window.monaco),ak(Promise.resolve(window.monaco));!function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(e){return t.reduceRight((function(e,t){return t(e)}),e)}}(hk,dk)(pk),ck({isInitialized:!0})}return ak(mk)},__getMonacoInstance:function(){return lk((function(e){return e.monaco}))}};function gk(){return gk=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},gk.apply(this,arguments)}const yk={display:"flex",height:"100%",width:"100%",justifyContent:"center",alignItems:"center"};function bk({content:e}){return N.createElement("div",{style:yk},e)}const vk={display:"flex",position:"relative",textAlign:"initial"},_k={width:"100%"},wk={display:"none"};function xk({width:e,height:t,isEditorReady:n,loading:a,_ref:i,className:s,wrapperProps:r}){return N.createElement("section",gk({style:{...vk,width:e,height:t}},r),!n&&N.createElement(bk,{content:a}),N.createElement("div",{ref:i,style:{..._k,...!n&&wk},className:s}))}xk.propTypes={width:nd.oneOfType([nd.number,nd.string]).isRequired,height:nd.oneOfType([nd.number,nd.string]).isRequired,loading:nd.oneOfType([nd.element,nd.string]).isRequired,isEditorReady:nd.bool.isRequired,className:nd.string,wrapperProps:nd.object};var Ck=e.exports.memo(xk);function Tk(t,n,a=!0){const i=e.exports.useRef(!0);e.exports.useEffect(i.current||!a?()=>{i.current=!1}:t,n)}function Ek(){}function Sk(e,t,n,a){return function(e,t){return e.editor.getModel(Ak(e,t))}(e,a)||function(e,t,n,a){return e.editor.createModel(t,n,a&&Ak(e,a))}(e,t,n,a)}function Ak(e,t){return e.Uri.parse(t)}nd.string,nd.string,nd.string,nd.string,nd.string,nd.string,nd.string,nd.bool,nd.bool,nd.string,nd.oneOfType([nd.element,nd.string]),nd.object,nd.oneOfType([nd.number,nd.string]),nd.oneOfType([nd.number,nd.string]),nd.string,nd.object,nd.func,nd.func;const Mk=new Map;function Lk({defaultValue:t,defaultLanguage:n,defaultPath:a,value:i,language:s,path:r,theme:o,line:l,loading:c,options:h,overrideServices:d,saveViewState:p,keepCurrentModel:u,width:m,height:f,className:g,wrapperProps:y,beforeMount:b,onMount:v,onChange:_,onValidate:w}){const[x,C]=e.exports.useState(!1),[T,E]=e.exports.useState(!0),S=e.exports.useRef(null),A=e.exports.useRef(null),M=e.exports.useRef(null),L=e.exports.useRef(v),R=e.exports.useRef(b),I=e.exports.useRef(null),P=e.exports.useRef(i),k=function(t){const n=e.exports.useRef();return e.exports.useEffect((()=>{n.current=t}),[t]),n.current}(r);var D;D=()=>{const e=fk.init();return e.then((e=>(S.current=e)&&E(!1))).catch((e=>"cancelation"!==(null==e?void 0:e.type)&&console.error("Monaco initialization: error:",e))),()=>{return A.current?(null===(t=I.current)||void 0===t||t.dispose(),u?p&&Mk.set(r,A.current.saveViewState()):null===(n=A.current.getModel())||void 0===n||n.dispose(),void A.current.dispose()):e.cancel();var t,n}},e.exports.useEffect(D,[]),Tk((()=>{const e=Sk(S.current,t||i,n||s,r);e!==A.current.getModel()&&(p&&Mk.set(k,A.current.saveViewState()),A.current.setModel(e),p&&A.current.restoreViewState(Mk.get(r)))}),[r],x),Tk((()=>{A.current.updateOptions(h)}),[h],x),Tk((()=>{A.current.getOption(S.current.editor.EditorOption.readOnly)?A.current.setValue(i):i!==A.current.getValue()&&(A.current.executeEdits("",[{range:A.current.getModel().getFullModelRange(),text:i,forceMoveMarkers:!0}]),A.current.pushUndoStop())}),[i],x),Tk((()=>{S.current.editor.setModelLanguage(A.current.getModel(),s)}),[s],x),Tk((()=>{void 0!==l&&A.current.revealLine(l)}),[l],x),Tk((()=>{S.current.editor.setTheme(o)}),[o],x);const O=e.exports.useCallback((()=>{R.current(S.current);const e=r||a,l=Sk(S.current,i||t,n||s,e);A.current=S.current.editor.create(M.current,{model:l,automaticLayout:!0,...h},d),p&&A.current.restoreViewState(Mk.get(e)),S.current.editor.setTheme(o),C(!0)}),[t,n,a,i,s,r,h,d,p,o]);return e.exports.useEffect((()=>{x&&L.current(A.current,S.current)}),[x]),e.exports.useEffect((()=>{!T&&!x&&O()}),[T,x,O]),P.current=i,e.exports.useEffect((()=>{var e,t;x&&_&&(null===(e=I.current)||void 0===e||e.dispose(),I.current=null===(t=A.current)||void 0===t?void 0:t.onDidChangeModelContent((e=>{const t=A.current.getValue();P.current!==t&&_(t,e)})))}),[x,_]),e.exports.useEffect((()=>{if(x){const e=S.current.editor.onDidChangeMarkers((e=>{var t;const n=null===(t=A.current.getModel())||void 0===t?void 0:t.uri;if(n){if(e.find((e=>e.path===n.path))){const e=S.current.editor.getModelMarkers({resource:n});null==w||w(e)}}}));return()=>{null==e||e.dispose()}}}),[x,w]),N.createElement(Ck,{width:m,height:f,isEditorReady:x,loading:c,_ref:M,className:g,wrapperProps:y})}Lk.propTypes={defaultValue:nd.string,defaultPath:nd.string,defaultLanguage:nd.string,value:nd.string,language:nd.string,path:nd.string,theme:nd.string,line:nd.number,loading:nd.oneOfType([nd.element,nd.string]),options:nd.object,overrideServices:nd.object,saveViewState:nd.bool,keepCurrentModel:nd.bool,width:nd.oneOfType([nd.number,nd.string]),height:nd.oneOfType([nd.number,nd.string]),className:nd.string,wrapperProps:nd.object,beforeMount:nd.func,onMount:nd.func,onChange:nd.func,onValidate:nd.func},Lk.defaultProps={theme:"light",loading:"Loading...",options:{},overrideServices:{},saveViewState:!0,keepCurrentModel:!1,width:"100%",height:"100%",wrapperProps:{},beforeMount:Ek,onMount:Ek,onValidate:Ek};var Rk=e.exports.memo(Lk),Ik='/**\n * Callback used by {@link EventHandler } functions. Note the callback is limited to 8 arguments.\n */\nexport type HandleEventCallback = (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any) => any;\n/**\n * Callback used by {@link EventHandler} functions. Note the callback is limited to 8 arguments.\n *\n * @callback HandleEventCallback\n * @param {*} [arg1] - First argument that is passed from caller.\n * @param {*} [arg2] - Second argument that is passed from caller.\n * @param {*} [arg3] - Third argument that is passed from caller.\n * @param {*} [arg4] - Fourth argument that is passed from caller.\n * @param {*} [arg5] - Fifth argument that is passed from caller.\n * @param {*} [arg6] - Sixth argument that is passed from caller.\n * @param {*} [arg7] - Seventh argument that is passed from caller.\n * @param {*} [arg8] - Eighth argument that is passed from caller.\n */\n/**\n * Abstract base class that implements functionality for event handling.\n */\ndeclare class EventHandler {\n    /**\n     * @type {object}\n     * @private\n     */\n    private _callbacks;\n    /**\n     * @type {object}\n     * @private\n     */\n    private _callbackActive;\n    /**\n     * Reinitialize the event handler.\n     *\n     * @private\n     */\n    private initEventHandler;\n    /**\n     * Registers a new event handler.\n     *\n     * @param {string} name - Name of the event to bind the callback to.\n     * @param {HandleEventCallback} callback - Function that is called when event is fired. Note\n     * the callback is limited to 8 arguments.\n     * @param {object} [scope] - Object to use as \'this\' when the event is fired, defaults to\n     * current this.\n     * @param {boolean} [once=false] - If true, the callback will be unbound after being fired once.\n     * @private\n     */\n    private _addCallback;\n    /**\n     * Attach an event handler to an event.\n     *\n     * @param {string} name - Name of the event to bind the callback to.\n     * @param {HandleEventCallback} callback - Function that is called when event is fired. Note\n     * the callback is limited to 8 arguments.\n     * @param {object} [scope] - Object to use as \'this\' when the event is fired, defaults to\n     * current this.\n     * @returns {EventHandler} Self for chaining.\n     * @example\n     * obj.on(\'test\', function (a, b) {\n     *     console.log(a + b);\n     * });\n     * obj.fire(\'test\', 1, 2); // prints 3 to the console\n     */\n    on(name: string, callback: HandleEventCallback, scope?: object): EventHandler;\n    /**\n     * Detach an event handler from an event. If callback is not provided then all callbacks are\n     * unbound from the event, if scope is not provided then all events with the callback will be\n     * unbound.\n     *\n     * @param {string} [name] - Name of the event to unbind.\n     * @param {HandleEventCallback} [callback] - Function to be unbound.\n     * @param {object} [scope] - Scope that was used as the this when the event is fired.\n     * @returns {EventHandler} Self for chaining.\n     * @example\n     * var handler = function () {\n     * };\n     * obj.on(\'test\', handler);\n     *\n     * obj.off(); // Removes all events\n     * obj.off(\'test\'); // Removes all events called \'test\'\n     * obj.off(\'test\', handler); // Removes all handler functions, called \'test\'\n     * obj.off(\'test\', handler, this); // Removes all handler functions, called \'test\' with scope this\n     */\n    off(name?: string, callback?: HandleEventCallback, scope?: object): EventHandler;\n    /**\n     * Fire an event, all additional arguments are passed on to the event listener.\n     *\n     * @param {string} name - Name of event to fire.\n     * @param {*} [arg1] - First argument that is passed to the event handler.\n     * @param {*} [arg2] - Second argument that is passed to the event handler.\n     * @param {*} [arg3] - Third argument that is passed to the event handler.\n     * @param {*} [arg4] - Fourth argument that is passed to the event handler.\n     * @param {*} [arg5] - Fifth argument that is passed to the event handler.\n     * @param {*} [arg6] - Sixth argument that is passed to the event handler.\n     * @param {*} [arg7] - Seventh argument that is passed to the event handler.\n     * @param {*} [arg8] - Eighth argument that is passed to the event handler.\n     * @returns {EventHandler} Self for chaining.\n     * @example\n     * obj.fire(\'test\', \'This is the message\');\n     */\n    fire(name: string, arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): EventHandler;\n    /**\n     * Attach an event handler to an event. This handler will be removed after being fired once.\n     *\n     * @param {string} name - Name of the event to bind the callback to.\n     * @param {HandleEventCallback} callback - Function that is called when event is fired. Note\n     * the callback is limited to 8 arguments.\n     * @param {object} [scope] - Object to use as \'this\' when the event is fired, defaults to\n     * current this.\n     * @returns {EventHandler} Self for chaining.\n     * @example\n     * obj.once(\'test\', function (a, b) {\n     *     console.log(a + b);\n     * });\n     * obj.fire(\'test\', 1, 2); // prints 3 to the console\n     * obj.fire(\'test\', 1, 2); // not going to get handled\n     */\n    once(name: string, callback: HandleEventCallback, scope?: object): EventHandler;\n    /**\n     * Test if there are any handlers bound to an event name.\n     *\n     * @param {string} name - The name of the event to test.\n     * @returns {boolean} True if the object has handlers bound to the specified event name.\n     * @example\n     * obj.on(\'test\', function () { }); // bind an event to \'test\'\n     * obj.hasEvent(\'test\'); // returns true\n     * obj.hasEvent(\'hello\'); // returns false\n     */\n    hasEvent(name: string): boolean;\n}\n\ndeclare namespace events {\n    function attach(target: any): any;\n    const _addCallback: (name: string, callback: HandleEventCallback, scope?: any, once?: boolean) => void;\n    const on: (name: string, callback: HandleEventCallback, scope?: any) => EventHandler;\n    const off: (name?: string, callback?: HandleEventCallback, scope?: any) => EventHandler;\n    const fire: (name: string, arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any) => EventHandler;\n    const once: (name: string, callback: HandleEventCallback, scope?: any) => EventHandler;\n    const hasEvent: (name: string) => boolean;\n}\n\ndeclare namespace guid {\n    function create(): string;\n}\n\ndeclare namespace path {\n    const delimiter: string;\n    function join(...args: string[]): string;\n    function normalize(pathname: string): string;\n    function split(pathname: string): string[];\n    function getBasename(pathname: string): string;\n    function getDirectory(pathname: string): string;\n    function getExtension(pathname: string): string;\n    function isRelativePath(pathname: string): boolean;\n    function extractPath(pathname: string): string;\n}\n\ndeclare namespace platform {\n    export { environment };\n    export const global: object;\n    export const browser: boolean;\n    export { desktop };\n    export { mobile };\n    export { ios };\n    export { android };\n    export { windows };\n    export { xbox };\n    export { gamepads };\n    export { touch };\n    export { workers };\n    export { passiveEvents };\n}\ndeclare const environment: "browser" | "node";\ndeclare let desktop: boolean;\ndeclare let mobile: boolean;\ndeclare let ios: boolean;\ndeclare let android: boolean;\ndeclare let windows: boolean;\ndeclare let xbox: boolean;\ndeclare let gamepads: boolean;\ndeclare let touch: boolean;\ndeclare let workers: boolean;\ndeclare let passiveEvents: boolean;\n\ndeclare namespace string {\n    export { ASCII_LOWERCASE };\n    export { ASCII_UPPERCASE };\n    export { ASCII_LETTERS };\n    export function format(s: string, ...args: any[]): string;\n    export function toBool(s: string, strict?: boolean): boolean;\n    export function getCodePoint(string: string, i?: number): number;\n    export function getCodePoints(string: string): number[];\n    export function getSymbols(string: string): string[];\n    export function fromCodePoint(...args: number[]): string;\n}\ndeclare const ASCII_LOWERCASE: "abcdefghijklmnopqrstuvwxyz";\ndeclare const ASCII_UPPERCASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZ";\ndeclare const ASCII_LETTERS: string;\n\n/**\n * A ordered list-type data structure that can provide item look up by key and can also return a list.\n *\n * @ignore\n */\ndeclare class IndexedList {\n    /**\n     * @type {object[]}\n     * @private\n     */\n    private _list;\n    /**\n     * @type {Object.<string, number>}\n     * @private\n     */\n    private _index;\n    /**\n     * Add a new item into the list with a index key.\n     *\n     * @param {string} key -  Key used to look up item in index.\n     * @param {object} item - Item to be stored.\n     */\n    push(key: string, item: object): void;\n    /**\n     * Test whether a key has been added to the index.\n     *\n     * @param {string} key - The key to test.\n     * @returns {boolean} Returns true if key is in the index, false if not.\n     */\n    has(key: string): boolean;\n    /**\n     * Return the item indexed by a key.\n     *\n     * @param {string} key - The key of the item to retrieve.\n     * @returns {object|null} The item stored at key. Returns null if key is not in the index.\n     */\n    get(key: string): object | null;\n    /**\n     * Remove the item indexed by key from the list.\n     *\n     * @param {string} key - The key at which to remove the item.\n     * @returns {boolean} Returns true if the key exists and an item was removed, returns false if\n     * no item was removed.\n     */\n    remove(key: string): boolean;\n    /**\n     * Returns the list of items.\n     *\n     * @returns {object[]} The list of items.\n     */\n    list(): object[];\n    /**\n     * Remove all items from the list.\n     */\n    clear(): void;\n}\n\n/**\n * Helper class for organized reading of memory.\n *\n * @ignore\n */\ndeclare class ReadStream {\n    constructor(arraybuffer: any);\n    arraybuffer: any;\n    dataView: DataView;\n    offset: number;\n    stack: any[];\n    get remainingBytes(): number;\n    reset(offset?: number): void;\n    skip(bytes: any): void;\n    align(bytes: any): void;\n    _inc(amount: any): number;\n    readChar(): string;\n    readChars(numChars: any): string;\n    readU8(): number;\n    readU16(): number;\n    readU32(): number;\n    readU64(): number;\n    readU32be(): number;\n    readArray(result: any): void;\n    readLine(): string;\n}\n\n/**\n * Helper class used to hold an array of items in a specific order. This array is safe to modify\n * while we loop through it. The class assumes that it holds objects that need to be sorted based\n * on one of their fields.\n *\n * @ignore\n */\ndeclare class SortedLoopArray {\n    /**\n     * Create a new SortedLoopArray instance.\n     *\n     * @param {object} args - Arguments.\n     * @param {string} args.sortBy - The name of the field that each element in the array is going\n     * to be sorted by.\n     * @example\n     * var array = new pc.SortedLoopArray({ sortBy: \'priority\' });\n     * array.insert(item); // adds item to the right slot based on item.priority\n     * array.append(item); // adds item to the end of the array\n     * array.remove(item); // removes item from array\n     * for (array.loopIndex = 0; array.loopIndex < array.length; array.loopIndex++) {\n     *   // do things with array elements\n     *   // safe to remove and add elements into the array while looping\n     * }\n     */\n    constructor(args: {\n        sortBy: string;\n    });\n    /**\n     * The internal array that holds the actual array elements.\n     *\n     * @type {object[]}\n     */\n    items: object[];\n    /**\n     * The number of elements in the array.\n     *\n     * @type {number}\n     */\n    length: number;\n    /**\n     * The current index used to loop through the array. This gets modified if we add or remove\n     * elements from the array while looping. See the example to see how to loop through this\n     * array.\n     *\n     * @type {number}\n     */\n    loopIndex: number;\n    _sortBy: string;\n    _sortHandler: any;\n    /**\n     * Searches for the right spot to insert the specified item.\n     *\n     * @param {object} item - The item.\n     * @returns {number} The index where to insert the item.\n     * @private\n     */\n    private _binarySearch;\n    _doSort(a: any, b: any): number;\n    /**\n     * Inserts the specified item into the array at the right index based on the \'sortBy\' field\n     * passed into the constructor. This also adjusts the loopIndex accordingly.\n     *\n     * @param {object} item - The item to insert.\n     */\n    insert(item: object): void;\n    /**\n     * Appends the specified item to the end of the array. Faster than insert() as it does not\n     * binary search for the right index. This also adjusts the loopIndex accordingly.\n     *\n     * @param {object} item - The item to append.\n     */\n    append(item: object): void;\n    /**\n     * Removes the specified item from the array.\n     *\n     * @param {object} item - The item to remove.\n     */\n    remove(item: object): void;\n    /**\n     * Sorts elements in the array based on the \'sortBy\' field passed into the constructor. This\n     * also updates the loopIndex if we are currently looping.\n     *\n     * WARNING: Be careful if you are sorting while iterating because if after sorting the array\n     * element that you are currently processing is moved behind other elements then you might end\n     * up iterating over elements more than once!\n     */\n    sort(): void;\n}\n\n/**\n * Set of tag names. Tags are automatically available on {@link Entity} and {@link Asset} as `tags`\n * field.\n *\n * @augments EventHandler\n */\ndeclare class Tags extends EventHandler {\n    /**\n     * Create an instance of a Tags.\n     *\n     * @param {object} [parent] - Parent object who tags belong to.\n     */\n    constructor(parent?: object);\n    _index: {};\n    _list: any[];\n    _parent: any;\n    /**\n     * Add a tag, duplicates are ignored. Can be array or comma separated arguments for multiple tags.\n     *\n     * @param {...*} name - Name of a tag, or array of tags.\n     * @returns {boolean} True if any tag were added.\n     * @example\n     * tags.add(\'level-1\');\n     * @example\n     * tags.add(\'ui\', \'settings\');\n     * @example\n     * tags.add([\'level-2\', \'mob\']);\n     */\n    add(...args: any[]): boolean;\n    /**\n     * Remove tag.\n     *\n     * @param {...*} name - Name of a tag or array of tags.\n     * @returns {boolean} True if any tag were removed.\n     * @example\n     * tags.remove(\'level-1\');\n     * @example\n     * tags.remove(\'ui\', \'settings\');\n     * @example\n     * tags.remove([\'level-2\', \'mob\']);\n     */\n    remove(...args: any[]): boolean;\n    /**\n     * Remove all tags.\n     *\n     * @example\n     * tags.clear();\n     */\n    clear(): void;\n    /**\n     * Check if tags satisfy filters. Filters can be provided by simple name of tag, as well as by\n     * array of tags. When an array is provided it will check if tags contain each tag within the\n     * array. If any of comma separated argument is satisfied, then it will return true. Any number\n     * of combinations are valid, and order is irrelevant.\n     *\n     * @param {...*} query - Name of a tag or array of tags.\n     * @returns {boolean} True if filters are satisfied.\n     * @example\n     * tags.has(\'player\'); // player\n     * @example\n     * tags.has(\'mob\', \'player\'); // player OR mob\n     * @example\n     * tags.has([\'level-1\', \'mob\']); // monster AND level-1\n     * @example\n     * tags.has([\'ui\', \'settings\'], [\'ui\', \'levels\']); // (ui AND settings) OR (ui AND levels)\n     */\n    has(...args: any[]): boolean;\n    /**\n     * @param {string[]|string[][]} tags - Array of tags.\n     * @returns {boolean} True if the supplied tags are present.\n     * @private\n     */\n    private _has;\n    /**\n     * Returns immutable array of tags.\n     *\n     * @returns {string[]} Copy of tags array.\n     */\n    list(): string[];\n    /**\n     * @param {IArguments} args - Arguments to process.\n     * @param {boolean} [flat] - If true, will flatten array of tags. Defaults to false.\n     * @returns {string[]|string[][]} Array of tags.\n     * @private\n     */\n    private _processArguments;\n    /**\n     * Number of tags in set.\n     *\n     * @type {number}\n     */\n    get size(): number;\n}\n\n/**\n * A linear interpolation scheme.\n *\n * @type {number}\n */\ndeclare const CURVE_LINEAR: number;\n/**\n * A smooth step interpolation scheme.\n *\n * @type {number}\n */\ndeclare const CURVE_SMOOTHSTEP: number;\n/**\n * A Catmull-Rom spline interpolation scheme. This interpolation scheme is deprecated. Use\n * CURVE_SPLINE instead.\n *\n * @type {number}\n * @deprecated\n * @ignore\n */\ndeclare const CURVE_CATMULL: number;\n/**\n * A cardinal spline interpolation scheme. This interpolation scheme is deprecated. Use\n * CURVE_SPLINE instead.\n *\n * @type {number}\n * @deprecated\n * @ignore\n */\ndeclare const CURVE_CARDINAL: number;\n/**\n * Cardinal spline interpolation scheme. For Catmull-Rom, specify curve tension 0.5.\n *\n * @type {number}\n */\ndeclare const CURVE_SPLINE: number;\n/**\n * A stepped interpolator, free from the shackles of blending.\n *\n * @type {number}\n */\ndeclare const CURVE_STEP: number;\n\n/**\n * Ignores the integer part of texture coordinates, using only the fractional part.\n *\n * @type {number}\n */\ndeclare const ADDRESS_REPEAT: number;\n/**\n * Clamps texture coordinate to the range 0 to 1.\n *\n * @type {number}\n */\ndeclare const ADDRESS_CLAMP_TO_EDGE: number;\n/**\n * Texture coordinate to be set to the fractional part if the integer part is even. If the integer\n * part is odd, then the texture coordinate is set to 1 minus the fractional part.\n *\n * @type {number}\n */\ndeclare const ADDRESS_MIRRORED_REPEAT: number;\n/**\n * Multiply all fragment components by zero.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_ZERO: number;\n/**\n * Multiply all fragment components by one.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_ONE: number;\n/**\n * Multiply all fragment components by the components of the source fragment.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_SRC_COLOR: number;\n/**\n * Multiply all fragment components by one minus the components of the source fragment.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_ONE_MINUS_SRC_COLOR: number;\n/**\n * Multiply all fragment components by the components of the destination fragment.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_DST_COLOR: number;\n/**\n * Multiply all fragment components by one minus the components of the destination fragment.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_ONE_MINUS_DST_COLOR: number;\n/**\n * Multiply all fragment components by the alpha value of the source fragment.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_SRC_ALPHA: number;\n/**\n * Multiply all fragment components by the alpha value of the source fragment.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_SRC_ALPHA_SATURATE: number;\n/**\n * Multiply all fragment components by one minus the alpha value of the source fragment.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_ONE_MINUS_SRC_ALPHA: number;\n/**\n * Multiply all fragment components by the alpha value of the destination fragment.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_DST_ALPHA: number;\n/**\n * Multiply all fragment components by one minus the alpha value of the destination fragment.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_ONE_MINUS_DST_ALPHA: number;\n/**\n * Multiplies all colors by a constant color.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_CONSTANT_COLOR: number;\n/**\n * Multiplies all colors by 1 minus a constant color.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_ONE_MINUS_CONSTANT_COLOR: number;\n/**\n * Multiplies all colors by a constant alpha value.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_CONSTANT_ALPHA: number;\n/**\n * Multiplies all colors by 1 minus a constant alpha value.\n *\n * @type {number}\n */\ndeclare const BLENDMODE_ONE_MINUS_CONSTANT_ALPHA: number;\n/**\n * Add the results of the source and destination fragment multiplies.\n *\n * @type {number}\n */\ndeclare const BLENDEQUATION_ADD: number;\n/**\n * Subtract the results of the source and destination fragment multiplies.\n *\n * @type {number}\n */\ndeclare const BLENDEQUATION_SUBTRACT: number;\n/**\n * Reverse and subtract the results of the source and destination fragment multiplies.\n *\n * @type {number}\n */\ndeclare const BLENDEQUATION_REVERSE_SUBTRACT: number;\n/**\n * Use the smallest value. Check app.graphicsDevice.extBlendMinmax for support.\n *\n * @type {number}\n */\ndeclare const BLENDEQUATION_MIN: number;\n/**\n * Use the largest value. Check app.graphicsDevice.extBlendMinmax for support.\n *\n * @type {number}\n */\ndeclare const BLENDEQUATION_MAX: number;\n/**\n * The data store contents will be modified once and used many times.\n *\n * @type {number}\n */\ndeclare const BUFFER_STATIC: number;\n/**\n * The data store contents will be modified repeatedly and used many times.\n *\n * @type {number}\n */\ndeclare const BUFFER_DYNAMIC: number;\n/**\n * The data store contents will be modified once and used at most a few times.\n *\n * @type {number}\n */\ndeclare const BUFFER_STREAM: number;\n/**\n * The data store contents will be modified repeatedly on the GPU and used many times. Optimal for\n * transform feedback usage (WebGL2 only).\n *\n * @type {number}\n */\ndeclare const BUFFER_GPUDYNAMIC: number;\n/**\n * Clear the color buffer.\n *\n * @type {number}\n */\ndeclare const CLEARFLAG_COLOR: number;\n/**\n * Clear the depth buffer.\n *\n * @type {number}\n */\ndeclare const CLEARFLAG_DEPTH: number;\n/**\n * Clear the stencil buffer.\n *\n * @type {number}\n */\ndeclare const CLEARFLAG_STENCIL: number;\n/**\n * The positive X face of a cubemap.\n *\n * @type {number}\n */\ndeclare const CUBEFACE_POSX: number;\n/**\n * The negative X face of a cubemap.\n *\n * @type {number}\n */\ndeclare const CUBEFACE_NEGX: number;\n/**\n * The positive Y face of a cubemap.\n *\n * @type {number}\n */\ndeclare const CUBEFACE_POSY: number;\n/**\n * The negative Y face of a cubemap.\n *\n * @type {number}\n */\ndeclare const CUBEFACE_NEGY: number;\n/**\n * The positive Z face of a cubemap.\n *\n * @type {number}\n */\ndeclare const CUBEFACE_POSZ: number;\n/**\n * The negative Z face of a cubemap.\n *\n * @type {number}\n */\ndeclare const CUBEFACE_NEGZ: number;\n/**\n * No triangles are culled.\n *\n * @type {number}\n */\ndeclare const CULLFACE_NONE: number;\n/**\n * Triangles facing away from the view direction are culled.\n *\n * @type {number}\n */\ndeclare const CULLFACE_BACK: number;\n/**\n * Triangles facing the view direction are culled.\n *\n * @type {number}\n */\ndeclare const CULLFACE_FRONT: number;\n/**\n * Triangles are culled regardless of their orientation with respect to the view direction. Note\n * that point or line primitives are unaffected by this render state.\n *\n * @type {number}\n */\ndeclare const CULLFACE_FRONTANDBACK: number;\n/**\n * Point sample filtering.\n *\n * @type {number}\n */\ndeclare const FILTER_NEAREST: number;\n/**\n * Bilinear filtering.\n *\n * @type {number}\n */\ndeclare const FILTER_LINEAR: number;\n/**\n * Use the nearest neighbor in the nearest mipmap level.\n *\n * @type {number}\n */\ndeclare const FILTER_NEAREST_MIPMAP_NEAREST: number;\n/**\n * Linearly interpolate in the nearest mipmap level.\n *\n * @type {number}\n */\ndeclare const FILTER_NEAREST_MIPMAP_LINEAR: number;\n/**\n * Use the nearest neighbor after linearly interpolating between mipmap levels.\n *\n * @type {number}\n */\ndeclare const FILTER_LINEAR_MIPMAP_NEAREST: number;\n/**\n * Linearly interpolate both the mipmap levels and between texels.\n *\n * @type {number}\n */\ndeclare const FILTER_LINEAR_MIPMAP_LINEAR: number;\n/**\n * Never pass.\n *\n * @type {number}\n */\ndeclare const FUNC_NEVER: number;\n/**\n * Pass if (ref & mask) < (stencil & mask).\n *\n * @type {number}\n */\ndeclare const FUNC_LESS: number;\n/**\n * Pass if (ref & mask) == (stencil & mask).\n *\n * @type {number}\n */\ndeclare const FUNC_EQUAL: number;\n/**\n * Pass if (ref & mask) <= (stencil & mask).\n *\n * @type {number}\n */\ndeclare const FUNC_LESSEQUAL: number;\n/**\n * Pass if (ref & mask) > (stencil & mask).\n *\n * @type {number}\n */\ndeclare const FUNC_GREATER: number;\n/**\n * Pass if (ref & mask) != (stencil & mask).\n *\n * @type {number}\n */\ndeclare const FUNC_NOTEQUAL: number;\n/**\n * Pass if (ref & mask) >= (stencil & mask).\n *\n * @type {number}\n */\ndeclare const FUNC_GREATEREQUAL: number;\n/**\n * Always pass.\n *\n * @type {number}\n */\ndeclare const FUNC_ALWAYS: number;\n/**\n * 8-bit unsigned vertex indices (0 to 255).\n *\n * @type {number}\n */\ndeclare const INDEXFORMAT_UINT8: number;\n/**\n * 16-bit unsigned vertex indices (0 to 65,535).\n *\n * @type {number}\n */\ndeclare const INDEXFORMAT_UINT16: number;\n/**\n * 32-bit unsigned vertex indices (0 to 4,294,967,295).\n *\n * @type {number}\n */\ndeclare const INDEXFORMAT_UINT32: number;\n/**\n * 8-bit alpha.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_A8: number;\n/**\n * 8-bit luminance.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_L8: number;\n/**\n * 8-bit luminance with 8-bit alpha.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_L8_A8: number;\n/**\n * 16-bit RGB (5-bits for red channel, 6 for green and 5 for blue).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_R5_G6_B5: number;\n/**\n * 16-bit RGBA (5-bits for red channel, 5 for green, 5 for blue with 1-bit alpha).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_R5_G5_B5_A1: number;\n/**\n * 16-bit RGBA (4-bits for red channel, 4 for green, 4 for blue with 4-bit alpha).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_R4_G4_B4_A4: number;\n/**\n * 24-bit RGB (8-bits for red channel, 8 for green and 8 for blue).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_R8_G8_B8: number;\n/**\n * 32-bit RGBA (8-bits for red channel, 8 for green, 8 for blue with 8-bit alpha).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_R8_G8_B8_A8: number;\n/**\n * Block compressed format storing 16 input pixels in 64 bits of output, consisting of two 16-bit\n * RGB 5:6:5 color values and a 4x4 two bit lookup table.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_DXT1: number;\n/**\n * Block compressed format storing 16 input pixels (corresponding to a 4x4 pixel block) into 128\n * bits of output, consisting of 64 bits of alpha channel data (4 bits for each pixel) followed by\n * 64 bits of color data; encoded the same way as DXT1.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_DXT3: number;\n/**\n * Block compressed format storing 16 input pixels into 128 bits of output, consisting of 64 bits\n * of alpha channel data (two 8 bit alpha values and a 4x4 3 bit lookup table) followed by 64 bits\n * of color data (encoded the same way as DXT1).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_DXT5: number;\n/**\n * 16-bit floating point RGB (16-bit float for each red, green and blue channels).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_RGB16F: number;\n/**\n * 16-bit floating point RGBA (16-bit float for each red, green, blue and alpha channels).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_RGBA16F: number;\n/**\n * 32-bit floating point RGB (32-bit float for each red, green and blue channels).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_RGB32F: number;\n/**\n * 32-bit floating point RGBA (32-bit float for each red, green, blue and alpha channels).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_RGBA32F: number;\n/**\n * 32-bit floating point single channel format (WebGL2 only).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_R32F: number;\n/**\n * A readable depth buffer format.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_DEPTH: number;\n/**\n * A readable depth/stencil buffer format (WebGL2 only).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_DEPTHSTENCIL: number;\n/**\n * A floating-point color-only format with 11 bits for red and green channels and 10 bits for the\n * blue channel (WebGL2 only).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_111110F: number;\n/**\n * Color-only sRGB format (WebGL2 only).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_SRGB: number;\n/**\n * Color sRGB format with additional alpha channel (WebGL2 only).\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_SRGBA: number;\n/**\n * ETC1 compressed format.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_ETC1: number;\n/**\n * ETC2 (RGB) compressed format.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_ETC2_RGB: number;\n/**\n * ETC2 (RGBA) compressed format.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_ETC2_RGBA: number;\n/**\n * PVRTC (2BPP RGB) compressed format.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_PVRTC_2BPP_RGB_1: number;\n/**\n * PVRTC (2BPP RGBA) compressed format.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_PVRTC_2BPP_RGBA_1: number;\n/**\n * PVRTC (4BPP RGB) compressed format.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_PVRTC_4BPP_RGB_1: number;\n/**\n * PVRTC (4BPP RGBA) compressed format.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_PVRTC_4BPP_RGBA_1: number;\n/**\n * ATC compressed format with alpha channel in blocks of 4x4.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_ASTC_4x4: number;\n/**\n * ATC compressed format with no alpha channel.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_ATC_RGB: number;\n/**\n * ATC compressed format with alpha channel.\n *\n * @type {number}\n */\ndeclare const PIXELFORMAT_ATC_RGBA: number;\n/**\n * List of distinct points.\n *\n * @type {number}\n */\ndeclare const PRIMITIVE_POINTS: number;\n/**\n * Discrete list of line segments.\n *\n * @type {number}\n */\ndeclare const PRIMITIVE_LINES: number;\n/**\n * List of points that are linked sequentially by line segments, with a closing line segment\n * between the last and first points.\n *\n * @type {number}\n */\ndeclare const PRIMITIVE_LINELOOP: number;\n/**\n * List of points that are linked sequentially by line segments.\n *\n * @type {number}\n */\ndeclare const PRIMITIVE_LINESTRIP: number;\n/**\n * Discrete list of triangles.\n *\n * @type {number}\n */\ndeclare const PRIMITIVE_TRIANGLES: number;\n/**\n * Connected strip of triangles where a specified vertex forms a triangle using the previous two.\n *\n * @type {number}\n */\ndeclare const PRIMITIVE_TRISTRIP: number;\n/**\n * Connected fan of triangles where the first vertex forms triangles with the following pairs of vertices.\n *\n * @type {number}\n */\ndeclare const PRIMITIVE_TRIFAN: number;\n/**\n * Vertex attribute to be treated as a position.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_POSITION: string;\n/**\n * Vertex attribute to be treated as a normal.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_NORMAL: string;\n/**\n * Vertex attribute to be treated as a tangent.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_TANGENT: string;\n/**\n * Vertex attribute to be treated as skin blend weights.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_BLENDWEIGHT: string;\n/**\n * Vertex attribute to be treated as skin blend indices.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_BLENDINDICES: string;\n/**\n * Vertex attribute to be treated as a color.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_COLOR: string;\ndeclare const SEMANTIC_TEXCOORD: "TEXCOORD";\n/**\n * Vertex attribute to be treated as a texture coordinate (set 0).\n *\n * @type {string}\n */\ndeclare const SEMANTIC_TEXCOORD0: string;\n/**\n * Vertex attribute to be treated as a texture coordinate (set 1).\n *\n * @type {string}\n */\ndeclare const SEMANTIC_TEXCOORD1: string;\n/**\n * Vertex attribute to be treated as a texture coordinate (set 2).\n *\n * @type {string}\n */\ndeclare const SEMANTIC_TEXCOORD2: string;\n/**\n * Vertex attribute to be treated as a texture coordinate (set 3).\n *\n * @type {string}\n */\ndeclare const SEMANTIC_TEXCOORD3: string;\n/**\n * Vertex attribute to be treated as a texture coordinate (set 4).\n *\n * @type {string}\n */\ndeclare const SEMANTIC_TEXCOORD4: string;\n/**\n * Vertex attribute to be treated as a texture coordinate (set 5).\n *\n * @type {string}\n */\ndeclare const SEMANTIC_TEXCOORD5: string;\n/**\n * Vertex attribute to be treated as a texture coordinate (set 6).\n *\n * @type {string}\n */\ndeclare const SEMANTIC_TEXCOORD6: string;\n/**\n * Vertex attribute to be treated as a texture coordinate (set 7).\n *\n * @type {string}\n */\ndeclare const SEMANTIC_TEXCOORD7: string;\ndeclare const SEMANTIC_ATTR: "ATTR";\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR0: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR1: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR2: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR3: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR4: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR5: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR6: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR7: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR8: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR9: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR10: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR11: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR12: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR13: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR14: string;\n/**\n * Vertex attribute with a user defined semantic.\n *\n * @type {string}\n */\ndeclare const SEMANTIC_ATTR15: string;\ndeclare const SHADERTAG_MATERIAL: 1;\n/**\n * Don\'t change the stencil buffer value.\n *\n * @type {number}\n */\ndeclare const STENCILOP_KEEP: number;\n/**\n * Set value to zero.\n *\n * @type {number}\n */\ndeclare const STENCILOP_ZERO: number;\n/**\n * Replace value with the reference value (see {@link GraphicsDevice#setStencilFunc}).\n *\n * @type {number}\n */\ndeclare const STENCILOP_REPLACE: number;\n/**\n * Increment the value.\n *\n * @type {number}\n */\ndeclare const STENCILOP_INCREMENT: number;\n/**\n * Increment the value but wrap it to zero when it\'s larger than a maximum representable value.\n *\n * @type {number}\n */\ndeclare const STENCILOP_INCREMENTWRAP: number;\n/**\n * Decrement the value.\n *\n * @type {number}\n */\ndeclare const STENCILOP_DECREMENT: number;\n/**\n * Decrement the value but wrap it to a maximum representable value if the current value is 0.\n *\n * @type {number}\n */\ndeclare const STENCILOP_DECREMENTWRAP: number;\n/**\n * Invert the value bitwise.\n *\n * @type {number}\n */\ndeclare const STENCILOP_INVERT: number;\n/**\n * Read only. Any changes to the locked mip level\'s pixels will not update the texture.\n *\n * @type {number}\n */\ndeclare const TEXTURELOCK_READ: number;\n/**\n * Write only. The contents of the specified mip level will be entirely replaced.\n *\n * @type {number}\n */\ndeclare const TEXTURELOCK_WRITE: number;\n/**\n * Texture is a default type.\n *\n * @type {string}\n */\ndeclare const TEXTURETYPE_DEFAULT: string;\n/**\n * Texture stores high dynamic range data in RGBM format.\n *\n * @type {string}\n */\ndeclare const TEXTURETYPE_RGBM: string;\n/**\n * Texture stores high dynamic range data in RGBE format.\n *\n * @type {string}\n */\ndeclare const TEXTURETYPE_RGBE: string;\n/**\n * Texture stores normalmap data swizzled in GGGR format. This is used for tangent space normal\n * maps. The R component is stored in alpha and G is stored in RGB. This packing can result in\n * higher quality when the texture data is compressed.\n *\n * @type {string}\n */\ndeclare const TEXTURETYPE_SWIZZLEGGGR: string;\ndeclare const TEXHINT_NONE: 0;\ndeclare const TEXHINT_SHADOWMAP: 1;\ndeclare const TEXHINT_ASSET: 2;\ndeclare const TEXHINT_LIGHTMAP: 3;\n/**\n * Texture data is not stored a specific projection format.\n *\n * @type {string}\n */\ndeclare const TEXTUREPROJECTION_NONE: string;\n/**\n * Texture data is stored in cubemap projection format.\n *\n * @type {string}\n */\ndeclare const TEXTUREPROJECTION_CUBE: string;\n/**\n * Texture data is stored in equirectangular projection format.\n *\n * @type {string}\n */\ndeclare const TEXTUREPROJECTION_EQUIRECT: string;\n/**\n * Texture data is stored in octahedral projection format.\n *\n * @type {string}\n */\ndeclare const TEXTUREPROJECTION_OCTAHEDRAL: string;\n/**\n * Signed byte vertex element type.\n *\n * @type {number}\n */\ndeclare const TYPE_INT8: number;\n/**\n * Unsigned byte vertex element type.\n *\n * @type {number}\n */\ndeclare const TYPE_UINT8: number;\n/**\n * Signed short vertex element type.\n *\n * @type {number}\n */\ndeclare const TYPE_INT16: number;\n/**\n * Unsigned short vertex element type.\n *\n * @type {number}\n */\ndeclare const TYPE_UINT16: number;\n/**\n * Signed integer vertex element type.\n *\n * @type {number}\n */\ndeclare const TYPE_INT32: number;\n/**\n * Unsigned integer vertex element type.\n *\n * @type {number}\n */\ndeclare const TYPE_UINT32: number;\n/**\n * Floating point vertex element type.\n *\n * @type {number}\n */\ndeclare const TYPE_FLOAT32: number;\ndeclare const UNIFORMTYPE_BOOL: 0;\ndeclare const UNIFORMTYPE_INT: 1;\ndeclare const UNIFORMTYPE_FLOAT: 2;\ndeclare const UNIFORMTYPE_VEC2: 3;\ndeclare const UNIFORMTYPE_VEC3: 4;\ndeclare const UNIFORMTYPE_VEC4: 5;\ndeclare const UNIFORMTYPE_IVEC2: 6;\ndeclare const UNIFORMTYPE_IVEC3: 7;\ndeclare const UNIFORMTYPE_IVEC4: 8;\ndeclare const UNIFORMTYPE_BVEC2: 9;\ndeclare const UNIFORMTYPE_BVEC3: 10;\ndeclare const UNIFORMTYPE_BVEC4: 11;\ndeclare const UNIFORMTYPE_MAT2: 12;\ndeclare const UNIFORMTYPE_MAT3: 13;\ndeclare const UNIFORMTYPE_MAT4: 14;\ndeclare const UNIFORMTYPE_TEXTURE2D: 15;\ndeclare const UNIFORMTYPE_TEXTURECUBE: 16;\ndeclare const UNIFORMTYPE_FLOATARRAY: 17;\ndeclare const UNIFORMTYPE_TEXTURE2D_SHADOW: 18;\ndeclare const UNIFORMTYPE_TEXTURECUBE_SHADOW: 19;\ndeclare const UNIFORMTYPE_TEXTURE3D: 20;\ndeclare const UNIFORMTYPE_VEC2ARRAY: 21;\ndeclare const UNIFORMTYPE_VEC3ARRAY: 22;\ndeclare const UNIFORMTYPE_VEC4ARRAY: 23;\ndeclare const typedArrayTypes: (Int8ArrayConstructor | Uint8ArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor)[];\ndeclare const typedArrayTypesByteSize: number[];\ndeclare namespace typedArrayToType {\n    export { TYPE_INT8 as Int8Array };\n    export { TYPE_UINT8 as Uint8Array };\n    export { TYPE_INT16 as Int16Array };\n    export { TYPE_UINT16 as Uint16Array };\n    export { TYPE_INT32 as Int32Array };\n    export { TYPE_UINT32 as Uint32Array };\n    export { TYPE_FLOAT32 as Float32Array };\n}\ndeclare const typedArrayIndexFormats: (Uint8ArrayConstructor | Uint16ArrayConstructor | Uint32ArrayConstructor)[];\ndeclare const typedArrayIndexFormatsByteSize: number[];\n/**\n * Map of engine semantics into location on device in range 0..15 (note - semantics mapping to the\n * same location cannot be used at the same time) organized in a way that ATTR0-ATTR7 do not\n * overlap with common important semantics.\n *\n * @type {object}\n * @ignore\n */\ndeclare const semanticToLocation: object;\n\n/**\n * Subtract the color of the source fragment from the destination fragment and write the result to\n * the frame buffer.\n *\n * @type {number}\n */\ndeclare const BLEND_SUBTRACTIVE: number;\n/**\n * Add the color of the source fragment to the destination fragment and write the result to the\n * frame buffer.\n *\n * @type {number}\n */\ndeclare const BLEND_ADDITIVE: number;\n/**\n * Enable simple translucency for materials such as glass. This is equivalent to enabling a source\n * blend mode of {@link BLENDMODE_SRC_ALPHA} and a destination blend mode of\n * {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.\n *\n * @type {number}\n */\ndeclare const BLEND_NORMAL: number;\n/**\n * Disable blending.\n *\n * @type {number}\n */\ndeclare const BLEND_NONE: number;\n/**\n * Similar to {@link BLEND_NORMAL} expect the source fragment is assumed to have already been\n * multiplied by the source alpha value.\n *\n * @type {number}\n */\ndeclare const BLEND_PREMULTIPLIED: number;\n/**\n * Multiply the color of the source fragment by the color of the destination fragment and write the\n * result to the frame buffer.\n *\n * @type {number}\n */\ndeclare const BLEND_MULTIPLICATIVE: number;\n/**\n * Same as {@link BLEND_ADDITIVE} except the source RGB is multiplied by the source alpha.\n *\n * @type {number}\n */\ndeclare const BLEND_ADDITIVEALPHA: number;\n/**\n * Multiplies colors and doubles the result.\n *\n * @type {number}\n */\ndeclare const BLEND_MULTIPLICATIVE2X: number;\n/**\n * Softer version of additive.\n *\n * @type {number}\n */\ndeclare const BLEND_SCREEN: number;\n/**\n * Minimum color. Check app.graphicsDevice.extBlendMinmax for support.\n *\n * @type {number}\n */\ndeclare const BLEND_MIN: number;\n/**\n * Maximum color. Check app.graphicsDevice.extBlendMinmax for support.\n *\n * @type {number}\n */\ndeclare const BLEND_MAX: number;\n/**\n * No fog is applied to the scene.\n *\n * @type {string}\n */\ndeclare const FOG_NONE: string;\n/**\n * Fog rises linearly from zero to 1 between a start and end depth.\n *\n * @type {string}\n */\ndeclare const FOG_LINEAR: string;\n/**\n * Fog rises according to an exponential curve controlled by a density value.\n *\n * @type {string}\n */\ndeclare const FOG_EXP: string;\n/**\n * Fog rises according to an exponential curve controlled by a density value.\n *\n * @type {string}\n */\ndeclare const FOG_EXP2: string;\n/**\n * No Fresnel.\n *\n * @type {number}\n */\ndeclare const FRESNEL_NONE: number;\n/**\n * Schlick\'s approximation of Fresnel.\n *\n * @type {number}\n */\ndeclare const FRESNEL_SCHLICK: number;\ndeclare const LAYER_HUD: 0;\ndeclare const LAYER_GIZMO: 1;\ndeclare const LAYER_FX: 2;\ndeclare const LAYER_WORLD: 15;\n/**\n * The world layer.\n *\n * @type {number}\n */\ndeclare const LAYERID_WORLD: number;\n/**\n * The depth layer.\n *\n * @type {number}\n */\ndeclare const LAYERID_DEPTH: number;\n/**\n * The skybox layer.\n *\n * @type {number}\n */\ndeclare const LAYERID_SKYBOX: number;\n/**\n * The immediate layer.\n *\n * @type {number}\n */\ndeclare const LAYERID_IMMEDIATE: number;\n/**\n * The UI layer.\n *\n * @type {number}\n */\ndeclare const LAYERID_UI: number;\n/**\n * Directional (global) light source.\n *\n * @type {number}\n */\ndeclare const LIGHTTYPE_DIRECTIONAL: number;\n/**\n * Omni-directional (local) light source.\n *\n * @type {number}\n */\ndeclare const LIGHTTYPE_OMNI: number;\n/**\n * Point (local) light source.\n *\n * @type {number}\n * @ignore\n */\ndeclare const LIGHTTYPE_POINT: number;\n/**\n * Spot (local) light source.\n *\n * @type {number}\n */\ndeclare const LIGHTTYPE_SPOT: number;\n/**\n * Infinitesimally small point light source shape.\n *\n * @type {number}\n */\ndeclare const LIGHTSHAPE_PUNCTUAL: number;\n/**\n * Rectangle shape of light source.\n *\n * @type {number}\n */\ndeclare const LIGHTSHAPE_RECT: number;\n/**\n * Disk shape of light source.\n *\n * @type {number}\n */\ndeclare const LIGHTSHAPE_DISK: number;\n/**\n * Sphere shape of light source.\n *\n * @type {number}\n */\ndeclare const LIGHTSHAPE_SPHERE: number;\n/**\n * Linear distance falloff model for light attenuation.\n *\n * @type {number}\n */\ndeclare const LIGHTFALLOFF_LINEAR: number;\n/**\n * Inverse squared distance falloff model for light attenuation.\n *\n * @type {number}\n */\ndeclare const LIGHTFALLOFF_INVERSESQUARED: number;\n/**\n * Render depth (color-packed on WebGL 1.0), can be used for PCF 3x3 sampling.\n *\n * @type {number}\n */\ndeclare const SHADOW_PCF3: number;\ndeclare const SHADOW_DEPTH: 0;\n/**\n * Render packed variance shadow map. All shadow receivers must also cast shadows for this mode to\n * work correctly.\n *\n * @type {number}\n */\ndeclare const SHADOW_VSM8: number;\n/**\n * Render 16-bit exponential variance shadow map. Requires OES_texture_half_float extension. Falls\n * back to {@link SHADOW_VSM8}, if not supported.\n *\n * @type {number}\n */\ndeclare const SHADOW_VSM16: number;\n/**\n * Render 32-bit exponential variance shadow map. Requires OES_texture_float extension. Falls back\n * to {@link SHADOW_VSM16}, if not supported.\n *\n * @type {number}\n */\ndeclare const SHADOW_VSM32: number;\n/**\n * Render depth buffer only, can be used for hardware-accelerated PCF 5x5 sampling. Requires\n * WebGL 2. Falls back to {@link SHADOW_PCF3} on WebGL 1.\n *\n * @type {number}\n */\ndeclare const SHADOW_PCF5: number;\n/**\n * Render depth (color-packed on WebGL 1.0), can be used for PCF 1x1 sampling.\n *\n * @type {number}\n */\ndeclare const SHADOW_PCF1: number;\ndeclare const SHADOW_COUNT: 6;\n/**\n * map of engine SHADOW__*** to a string representation\n *\n * @type {object}\n * @ignore\n */\ndeclare const shadowTypeToString: object;\n/**\n * Box filter.\n *\n * @type {number}\n */\ndeclare const BLUR_BOX: number;\n/**\n * Gaussian filter. May look smoother than box, but requires more samples.\n *\n * @type {number}\n */\ndeclare const BLUR_GAUSSIAN: number;\n/**\n * No sorting, particles are drawn in arbitrary order. Can be simulated on GPU.\n *\n * @type {number}\n */\ndeclare const PARTICLESORT_NONE: number;\n/**\n * Sorting based on distance to the camera. CPU only.\n *\n * @type {number}\n */\ndeclare const PARTICLESORT_DISTANCE: number;\n/**\n * Newer particles are drawn first. CPU only.\n *\n * @type {number}\n */\ndeclare const PARTICLESORT_NEWER_FIRST: number;\n/**\n * Older particles are drawn first. CPU only.\n *\n * @type {number}\n */\ndeclare const PARTICLESORT_OLDER_FIRST: number;\ndeclare const PARTICLEMODE_GPU: 0;\ndeclare const PARTICLEMODE_CPU: 1;\n/**\n * Box shape parameterized by emitterExtents. Initial velocity is directed towards local Z axis.\n *\n * @type {number}\n */\ndeclare const EMITTERSHAPE_BOX: number;\n/**\n * Sphere shape parameterized by emitterRadius. Initial velocity is directed outwards from the\n * center.\n *\n * @type {number}\n */\ndeclare const EMITTERSHAPE_SPHERE: number;\n/**\n * Particles are facing camera.\n *\n * @type {number}\n */\ndeclare const PARTICLEORIENTATION_SCREEN: number;\n/**\n * User defines world space normal (particleNormal) to set planes orientation.\n *\n * @type {number}\n */\ndeclare const PARTICLEORIENTATION_WORLD: number;\n/**\n * Similar to previous, but the normal is affected by emitter(entity) transformation.\n *\n * @type {number}\n */\ndeclare const PARTICLEORIENTATION_EMITTER: number;\n/**\n * A perspective camera projection where the frustum shape is essentially pyramidal.\n *\n * @type {number}\n */\ndeclare const PROJECTION_PERSPECTIVE: number;\n/**\n * An orthographic camera projection where the frustum shape is essentially a cuboid.\n *\n * @type {number}\n */\ndeclare const PROJECTION_ORTHOGRAPHIC: number;\n/**\n * Render mesh instance as solid geometry.\n *\n * @type {number}\n */\ndeclare const RENDERSTYLE_SOLID: number;\n/**\n * Render mesh instance as wireframe.\n *\n * @type {number}\n */\ndeclare const RENDERSTYLE_WIREFRAME: number;\n/**\n * Render mesh instance as points.\n *\n * @type {number}\n */\ndeclare const RENDERSTYLE_POINTS: number;\n/**\n * The cube map is treated as if it is infinitely far away.\n *\n * @type {number}\n */\ndeclare const CUBEPROJ_NONE: number;\n/**\n * The cube map is box-projected based on a world space axis-aligned bounding box.\n *\n * @type {number}\n */\ndeclare const CUBEPROJ_BOX: number;\n/**\n * Phong without energy conservation. You should only use it as a backwards compatibility with\n * older projects.\n *\n * @type {number}\n */\ndeclare const SPECULAR_PHONG: number;\n/**\n * Energy-conserving Blinn-Phong.\n *\n * @type {number}\n */\ndeclare const SPECULAR_BLINN: number;\n/**\n * Multiply together the primary and secondary colors.\n *\n * @type {string}\n */\ndeclare const DETAILMODE_MUL: string;\n/**\n * Add together the primary and secondary colors.\n *\n * @type {string}\n */\ndeclare const DETAILMODE_ADD: string;\n/**\n * Softer version of {@link DETAILMODE_ADD}.\n *\n * @name DETAILMODE_SCREEN\n */\ndeclare const DETAILMODE_SCREEN: "screen";\n/**\n * Multiplies or screens the colors, depending on the primary color.\n *\n * @type {string}\n */\ndeclare const DETAILMODE_OVERLAY: string;\n/**\n * Select whichever of the primary and secondary colors is darker, component-wise.\n *\n * @type {string}\n */\ndeclare const DETAILMODE_MIN: string;\n/**\n * Select whichever of the primary and secondary colors is lighter, component-wise.\n *\n * @type {string}\n */\ndeclare const DETAILMODE_MAX: string;\n/**\n * No gamma correction.\n *\n * @type {number}\n */\ndeclare const GAMMA_NONE: number;\n/**\n * Apply sRGB gamma correction.\n *\n * @type {number}\n */\ndeclare const GAMMA_SRGB: number;\n/**\n * Apply sRGB (fast) gamma correction.\n *\n * @type {number}\n * @deprecated\n * @ignore\n */\ndeclare const GAMMA_SRGBFAST: number;\n/**\n * Apply sRGB (HDR) gamma correction.\n *\n * @type {number}\n */\ndeclare const GAMMA_SRGBHDR: number;\n/**\n * Linear tonemapping.\n *\n * @type {number}\n */\ndeclare const TONEMAP_LINEAR: number;\n/**\n * Filmic tonemapping curve.\n *\n * @type {number}\n */\ndeclare const TONEMAP_FILMIC: number;\n/**\n * Hejl filmic tonemapping curve.\n *\n * @type {number}\n */\ndeclare const TONEMAP_HEJL: number;\n/**\n * ACES filmic tonemapping curve.\n *\n * @type {number}\n */\ndeclare const TONEMAP_ACES: number;\n/**\n * ACES v2 filmic tonemapping curve.\n *\n * @type {number}\n */\ndeclare const TONEMAP_ACES2: number;\n/**\n * No specular occlusion.\n *\n * @type {number}\n */\ndeclare const SPECOCC_NONE: number;\n/**\n * Use AO directly to occlude specular.\n *\n * @type {number}\n */\ndeclare const SPECOCC_AO: number;\n/**\n * Modify AO based on material glossiness/view angle to occlude specular.\n *\n * @type {number}\n */\ndeclare const SPECOCC_GLOSSDEPENDENT: number;\ndeclare const SHADERDEF_NOSHADOW: 1;\ndeclare const SHADERDEF_SKIN: 2;\ndeclare const SHADERDEF_UV0: 4;\ndeclare const SHADERDEF_UV1: 8;\ndeclare const SHADERDEF_VCOLOR: 16;\ndeclare const SHADERDEF_INSTANCING: 32;\ndeclare const SHADERDEF_LM: 64;\ndeclare const SHADERDEF_DIRLM: 128;\ndeclare const SHADERDEF_SCREENSPACE: 256;\ndeclare const SHADERDEF_TANGENTS: 512;\ndeclare const SHADERDEF_MORPH_POSITION: 1024;\ndeclare const SHADERDEF_MORPH_NORMAL: 2048;\ndeclare const SHADERDEF_MORPH_TEXTURE_BASED: 4096;\ndeclare const SHADERDEF_LMAMBIENT: 8192;\ndeclare const LINEBATCH_WORLD: 0;\ndeclare const LINEBATCH_OVERLAY: 1;\ndeclare const LINEBATCH_GIZMO: 2;\n/**\n * The shadow map is not to be updated.\n *\n * @type {number}\n */\ndeclare const SHADOWUPDATE_NONE: number;\n/**\n * The shadow map is regenerated this frame and not on subsequent frames.\n *\n * @type {number}\n */\ndeclare const SHADOWUPDATE_THISFRAME: number;\n/**\n * The shadow map is regenerated every frame.\n *\n * @type {number}\n */\ndeclare const SHADOWUPDATE_REALTIME: number;\ndeclare const SORTKEY_FORWARD: 0;\ndeclare const SORTKEY_DEPTH: 1;\ndeclare const MASK_AFFECT_DYNAMIC: 1;\ndeclare const MASK_AFFECT_LIGHTMAPPED: 2;\ndeclare const MASK_BAKE: 4;\n/**\n * Render shaded materials with gamma correction and tonemapping.\n *\n * @type {number}\n */\ndeclare const SHADER_FORWARD: number;\n/**\n * Render shaded materials without gamma correction and tonemapping.\n *\n * @type {number}\n */\ndeclare const SHADER_FORWARDHDR: number;\n/**\n * Render RGBA-encoded depth value.\n *\n * @type {number}\n */\ndeclare const SHADER_DEPTH: number;\ndeclare const SHADER_SHADOW: 3;\ndeclare const SHADER_PICK: 18;\n/**\n * This mode renders a sprite as a simple quad.\n *\n * @type {number}\n */\ndeclare const SPRITE_RENDERMODE_SIMPLE: number;\n/**\n * This mode renders a sprite using 9-slicing in \'sliced\' mode. Sliced mode stretches the top and\n * bottom regions of the sprite horizontally, the left and right regions vertically and the middle\n * region both horizontally and vertically.\n *\n * @type {number}\n */\ndeclare const SPRITE_RENDERMODE_SLICED: number;\n/**\n * This mode renders a sprite using 9-slicing in \'tiled\' mode. Tiled mode tiles the top and bottom\n * regions of the sprite horizontally, the left and right regions vertically and the middle region\n * both horizontally and vertically.\n *\n * @type {number}\n */\ndeclare const SPRITE_RENDERMODE_TILED: number;\n/**\n * Single color lightmap.\n *\n * @type {number}\n */\ndeclare const BAKE_COLOR: number;\n/**\n * Single color lightmap + dominant light direction (used for bump/specular).\n *\n * @type {number}\n */\ndeclare const BAKE_COLORDIR: number;\n/**\n * Center of view.\n *\n * @type {number}\n */\ndeclare const VIEW_CENTER: number;\n/**\n * Left of view. Only used in stereo rendering.\n *\n * @type {number}\n */\ndeclare const VIEW_LEFT: number;\n/**\n * Right of view. Only used in stereo rendering.\n *\n * @type {number}\n */\ndeclare const VIEW_RIGHT: number;\n/**\n * No sorting is applied. Mesh instances are rendered in the same order they were added to a layer.\n *\n * @type {number}\n */\ndeclare const SORTMODE_NONE: number;\n/**\n * Mesh instances are sorted based on {@link MeshInstance#drawOrder}.\n *\n * @type {number}\n */\ndeclare const SORTMODE_MANUAL: number;\n/**\n * Mesh instances are sorted to minimize switching between materials and meshes to improve\n * rendering performance.\n *\n * @type {number}\n */\ndeclare const SORTMODE_MATERIALMESH: number;\n/**\n * Mesh instances are sorted back to front. This is the way to properly render many\n * semi-transparent objects on different depth, one is blended on top of another.\n *\n * @type {number}\n */\ndeclare const SORTMODE_BACK2FRONT: number;\n/**\n * Mesh instances are sorted front to back. Depending on GPU and the scene, this option may give\n * better performance than {@link SORTMODE_MATERIALMESH} due to reduced overdraw.\n *\n * @type {number}\n */\ndeclare const SORTMODE_FRONT2BACK: number;\n/**\n * Provide custom functions for sorting drawcalls and calculating distance.\n *\n * @type {number}\n * @ignore\n */\ndeclare const SORTMODE_CUSTOM: number;\ndeclare const COMPUPDATED_INSTANCES: 1;\ndeclare const COMPUPDATED_LIGHTS: 2;\ndeclare const COMPUPDATED_CAMERAS: 4;\ndeclare const COMPUPDATED_BLEND: 8;\n/**\n * Automatically set aspect ratio to current render target\'s width divided by height.\n *\n * @type {number}\n */\ndeclare const ASPECT_AUTO: number;\n/**\n * Use the manual aspect ratio value.\n *\n * @type {number}\n */\ndeclare const ASPECT_MANUAL: number;\n/**\n * Horizontal orientation.\n *\n * @type {number}\n */\ndeclare const ORIENTATION_HORIZONTAL: number;\n/**\n * Vertical orientation.\n *\n * @type {number}\n */\ndeclare const ORIENTATION_VERTICAL: number;\n\n/**\n * A stepped interpolation scheme.\n *\n * @type {number}\n * @ignore\n */\ndeclare const INTERPOLATION_STEP: number;\n/**\n * A linear interpolation scheme.\n *\n * @type {number}\n * @ignore\n */\ndeclare const INTERPOLATION_LINEAR: number;\n/**\n * A cubic spline interpolation scheme.\n *\n * @type {number}\n * @ignore\n */\ndeclare const INTERPOLATION_CUBIC: number;\n\n/**\n * Used to set the anim state graph transition interruption source to no state.\n *\n * @type {string}\n */\ndeclare const ANIM_INTERRUPTION_NONE: string;\n/**\n * Used to set the anim state graph transition interruption source as the previous state only.\n *\n * @type {string}\n */\ndeclare const ANIM_INTERRUPTION_PREV: string;\n/**\n * Used to set the anim state graph transition interruption source as the next state only.\n *\n * @type {string}\n */\ndeclare const ANIM_INTERRUPTION_NEXT: string;\n/**\n * Used to set the anim state graph transition interruption sources as the previous state followed\n * by the next state.\n *\n * @type {string}\n */\ndeclare const ANIM_INTERRUPTION_PREV_NEXT: string;\n/**\n * Used to set the anim state graph transition interruption sources as the next state followed by\n * the previous state.\n *\n * @type {string}\n */\ndeclare const ANIM_INTERRUPTION_NEXT_PREV: string;\n/**\n * Used to set an anim state graph transition condition predicate as \'>\'.\n *\n * @type {string}\n */\ndeclare const ANIM_GREATER_THAN: string;\n/**\n * Used to set an anim state graph transition condition predicate as \'<\'.\n *\n * @type {string}\n */\ndeclare const ANIM_LESS_THAN: string;\n/**\n * Used to set an anim state graph transition condition predicate as \'>=\'.\n *\n * @type {string}\n */\ndeclare const ANIM_GREATER_THAN_EQUAL_TO: string;\n/**\n * Used to set an anim state graph transition condition predicate as \'<=\'.\n *\n * @type {string}\n */\ndeclare const ANIM_LESS_THAN_EQUAL_TO: string;\n/**\n * Used to set an anim state graph transition condition predicate as \'===\'.\n *\n * @type {string}\n */\ndeclare const ANIM_EQUAL_TO: string;\n/**\n * Used to set an anim state graph transition condition predicate as \'!==\'.\n *\n * @type {string}\n */\ndeclare const ANIM_NOT_EQUAL_TO: string;\n/**\n * Used to set an anim state graph parameter as type integer.\n *\n * @type {string}\n */\ndeclare const ANIM_PARAMETER_INTEGER: string;\n/**\n * Used to set an anim state graph parameter as type float.\n *\n * @type {string}\n */\ndeclare const ANIM_PARAMETER_FLOAT: string;\n/**\n * Used to set an anim state graph parameter as type boolean.\n *\n * @type {string}\n */\ndeclare const ANIM_PARAMETER_BOOLEAN: string;\n/**\n * Used to set an anim state graph parameter as type trigger.\n *\n * @type {string}\n */\ndeclare const ANIM_PARAMETER_TRIGGER: string;\n/**\n * @type {string}\n */\ndeclare const ANIM_BLEND_1D: string;\n/**\n * @type {string}\n */\ndeclare const ANIM_BLEND_2D_DIRECTIONAL: string;\n/**\n * @type {string}\n */\ndeclare const ANIM_BLEND_2D_CARTESIAN: string;\n/**\n * @type {string}\n */\ndeclare const ANIM_BLEND_DIRECT: string;\n/**\n * The starting state in an anim state graph layer.\n *\n * @type {string}\n */\ndeclare const ANIM_STATE_START: string;\n/**\n * The ending state in an anim state graph layer.\n *\n * @type {string}\n */\ndeclare const ANIM_STATE_END: string;\n/**\n * Used to indicate any state in an anim state graph layer.\n *\n * @type {string}\n */\ndeclare const ANIM_STATE_ANY: string;\ndeclare const ANIM_CONTROL_STATES: string[];\n/**\n * Used to indicate that a layers animations should overwrite all previous layers.\n *\n * @type {string}\n */\ndeclare const ANIM_LAYER_OVERWRITE: string;\n/**\n * Used to indicate that a layers animations should blend additively with previous layers.\n *\n * @type {string}\n */\ndeclare const ANIM_LAYER_ADDITIVE: string;\n\ndeclare const FONT_MSDF: "msdf";\ndeclare const FONT_BITMAP: "bitmap";\n\n/**\n * Linear distance model.\n *\n * @type {string}\n */\ndeclare const DISTANCE_LINEAR: string;\n/**\n * Inverse distance model.\n *\n * @type {string}\n */\ndeclare const DISTANCE_INVERSE: string;\n/**\n * Exponential distance model.\n *\n * @type {string}\n */\ndeclare const DISTANCE_EXPONENTIAL: string;\n\ndeclare const ABSOLUTE_URL: RegExp;\n/**\n * Asset type name for animation.\n *\n * @type {string}\n */\ndeclare const ASSET_ANIMATION: string;\n/**\n * Asset type name for audio.\n *\n * @type {string}\n */\ndeclare const ASSET_AUDIO: string;\n/**\n * Asset type name for image.\n *\n * @type {string}\n */\ndeclare const ASSET_IMAGE: string;\n/**\n * Asset type name for json.\n *\n * @type {string}\n */\ndeclare const ASSET_JSON: string;\n/**\n * Asset type name for model.\n *\n * @type {string}\n */\ndeclare const ASSET_MODEL: string;\n/**\n * Asset type name for material.\n *\n * @type {string}\n */\ndeclare const ASSET_MATERIAL: string;\n/**\n * Asset type name for text.\n *\n * @type {string}\n */\ndeclare const ASSET_TEXT: string;\n/**\n * Asset type name for texture.\n *\n * @type {string}\n */\ndeclare const ASSET_TEXTURE: string;\n/**\n * Asset type name for cubemap.\n *\n * @type {string}\n */\ndeclare const ASSET_CUBEMAP: string;\n/**\n * Asset type name for shader.\n *\n * @type {string}\n */\ndeclare const ASSET_SHADER: string;\n/**\n * Asset type name for CSS.\n *\n * @type {string}\n */\ndeclare const ASSET_CSS: string;\n/**\n * Asset type name for HTML.\n *\n * @type {string}\n */\ndeclare const ASSET_HTML: string;\n/**\n * Asset type name for script.\n *\n * @type {string}\n */\ndeclare const ASSET_SCRIPT: string;\n/**\n * Asset type name for a container.\n *\n * @type {string}\n */\ndeclare const ASSET_CONTAINER: string;\n\ndeclare const ACTION_MOUSE: "mouse";\ndeclare const ACTION_KEYBOARD: "keyboard";\ndeclare const ACTION_GAMEPAD: "gamepad";\ndeclare const AXIS_MOUSE_X: "mousex";\ndeclare const AXIS_MOUSE_Y: "mousey";\ndeclare const AXIS_PAD_L_X: "padlx";\ndeclare const AXIS_PAD_L_Y: "padly";\ndeclare const AXIS_PAD_R_X: "padrx";\ndeclare const AXIS_PAD_R_Y: "padry";\ndeclare const AXIS_KEY: "key";\n/**\n * Name of event fired when a key is pressed.\n *\n * @type {string}\n */\ndeclare const EVENT_KEYDOWN: string;\n/**\n * Name of event fired when a key is released.\n *\n * @type {string}\n */\ndeclare const EVENT_KEYUP: string;\n/**\n * Name of event fired when a mouse button is pressed.\n *\n * @type {string}\n */\ndeclare const EVENT_MOUSEDOWN: string;\n/**\n * Name of event fired when the mouse is moved.\n *\n * @type {string}\n */\ndeclare const EVENT_MOUSEMOVE: string;\n/**\n * Name of event fired when a mouse button is released.\n *\n * @type {string}\n */\ndeclare const EVENT_MOUSEUP: string;\n/**\n * Name of event fired when the mouse wheel is rotated.\n *\n * @type {string}\n */\ndeclare const EVENT_MOUSEWHEEL: string;\n/**\n * Name of event fired when a new touch occurs. For example, a finger is placed on the device.\n *\n * @type {string}\n */\ndeclare const EVENT_TOUCHSTART: string;\n/**\n * Name of event fired when touch ends. For example, a finger is lifted off the device.\n *\n * @type {string}\n */\ndeclare const EVENT_TOUCHEND: string;\n/**\n * Name of event fired when a touch moves.\n *\n * @type {string}\n */\ndeclare const EVENT_TOUCHMOVE: string;\n/**\n * Name of event fired when a touch point is interrupted in some way. The exact reasons for\n * canceling a touch can vary from device to device. For example, a modal alert pops up during the\n * interaction; the touch point leaves the document area, or there are more touch points than the\n * device supports, in which case the earliest touch point is canceled.\n *\n * @type {string}\n */\ndeclare const EVENT_TOUCHCANCEL: string;\n/**\n * Name of event fired when a new xr select occurs. For example, primary trigger was pressed.\n *\n * @type {string}\n */\ndeclare const EVENT_SELECT: string;\n/**\n * Name of event fired when a new xr select starts. For example, primary trigger is now pressed.\n *\n * @type {string}\n */\ndeclare const EVENT_SELECTSTART: string;\n/**\n * Name of event fired when xr select ends. For example, a primary trigger is now released.\n *\n * @type {string}\n */\ndeclare const EVENT_SELECTEND: string;\n/**\n * @type {number}\n */\ndeclare const KEY_BACKSPACE: number;\n/**\n * @type {number}\n */\ndeclare const KEY_TAB: number;\n/**\n * @type {number}\n */\ndeclare const KEY_RETURN: number;\n/**\n * @type {number}\n */\ndeclare const KEY_ENTER: number;\n/**\n * @type {number}\n */\ndeclare const KEY_SHIFT: number;\n/**\n * @type {number}\n */\ndeclare const KEY_CONTROL: number;\n/**\n * @type {number}\n */\ndeclare const KEY_ALT: number;\n/**\n * @type {number}\n */\ndeclare const KEY_PAUSE: number;\n/**\n * @type {number}\n */\ndeclare const KEY_CAPS_LOCK: number;\n/**\n * @type {number}\n */\ndeclare const KEY_ESCAPE: number;\n/**\n * @type {number}\n */\ndeclare const KEY_SPACE: number;\n/**\n * @type {number}\n */\ndeclare const KEY_PAGE_UP: number;\n/**\n * @type {number}\n */\ndeclare const KEY_PAGE_DOWN: number;\n/**\n * @type {number}\n */\ndeclare const KEY_END: number;\n/**\n * @type {number}\n */\ndeclare const KEY_HOME: number;\n/**\n * @type {number}\n */\ndeclare const KEY_LEFT: number;\n/**\n * @type {number}\n */\ndeclare const KEY_UP: number;\n/**\n * @type {number}\n */\ndeclare const KEY_RIGHT: number;\n/**\n * @type {number}\n */\ndeclare const KEY_DOWN: number;\n/**\n * @type {number}\n */\ndeclare const KEY_PRINT_SCREEN: number;\n/**\n * @type {number}\n */\ndeclare const KEY_INSERT: number;\n/**\n * @type {number}\n */\ndeclare const KEY_DELETE: number;\n/**\n * @type {number}\n */\ndeclare const KEY_0: number;\n/**\n * @type {number}\n */\ndeclare const KEY_1: number;\n/**\n * @type {number}\n */\ndeclare const KEY_2: number;\n/**\n * @type {number}\n */\ndeclare const KEY_3: number;\n/**\n * @type {number}\n */\ndeclare const KEY_4: number;\n/**\n * @type {number}\n */\ndeclare const KEY_5: number;\n/**\n * @type {number}\n */\ndeclare const KEY_6: number;\n/**\n * @type {number}\n */\ndeclare const KEY_7: number;\n/**\n * @type {number}\n */\ndeclare const KEY_8: number;\n/**\n * @type {number}\n */\ndeclare const KEY_9: number;\n/**\n * @type {number}\n */\ndeclare const KEY_SEMICOLON: number;\n/**\n * @type {number}\n */\ndeclare const KEY_EQUAL: number;\n/**\n * @type {number}\n */\ndeclare const KEY_A: number;\n/**\n * @type {number}\n */\ndeclare const KEY_B: number;\n/**\n * @type {number}\n */\ndeclare const KEY_C: number;\n/**\n * @type {number}\n */\ndeclare const KEY_D: number;\n/**\n * @type {number}\n */\ndeclare const KEY_E: number;\n/**\n * @type {number}\n */\ndeclare const KEY_F: number;\n/**\n * @type {number}\n */\ndeclare const KEY_G: number;\n/**\n * @type {number}\n */\ndeclare const KEY_H: number;\n/**\n * @type {number}\n */\ndeclare const KEY_I: number;\n/**\n * @type {number}\n */\ndeclare const KEY_J: number;\n/**\n * @type {number}\n */\ndeclare const KEY_K: number;\n/**\n * @type {number}\n */\ndeclare const KEY_L: number;\n/**\n * @type {number}\n */\ndeclare const KEY_M: number;\n/**\n * @type {number}\n */\ndeclare const KEY_N: number;\n/**\n * @type {number}\n */\ndeclare const KEY_O: number;\n/**\n * @type {number}\n */\ndeclare const KEY_P: number;\n/**\n * @type {number}\n */\ndeclare const KEY_Q: number;\n/**\n * @type {number}\n */\ndeclare const KEY_R: number;\n/**\n * @type {number}\n */\ndeclare const KEY_S: number;\n/**\n * @type {number}\n */\ndeclare const KEY_T: number;\n/**\n * @type {number}\n */\ndeclare const KEY_U: number;\n/**\n * @type {number}\n */\ndeclare const KEY_V: number;\n/**\n * @type {number}\n */\ndeclare const KEY_W: number;\n/**\n * @type {number}\n */\ndeclare const KEY_X: number;\n/**\n * @type {number}\n */\ndeclare const KEY_Y: number;\n/**\n * @type {number}\n */\ndeclare const KEY_Z: number;\n/**\n * @type {number}\n */\ndeclare const KEY_WINDOWS: number;\n/**\n * @type {number}\n */\ndeclare const KEY_CONTEXT_MENU: number;\n/**\n * @type {number}\n */\ndeclare const KEY_NUMPAD_0: number;\n/**\n * @type {number}\n */\ndeclare const KEY_NUMPAD_1: number;\n/**\n * @type {number}\n */\ndeclare const KEY_NUMPAD_2: number;\n/**\n * @type {number}\n */\ndeclare const KEY_NUMPAD_3: number;\n/**\n * @type {number}\n */\ndeclare const KEY_NUMPAD_4: number;\n/**\n * @type {number}\n */\ndeclare const KEY_NUMPAD_5: number;\n/**\n * @type {number}\n */\ndeclare const KEY_NUMPAD_6: number;\n/**\n * @type {number}\n */\ndeclare const KEY_NUMPAD_7: number;\n/**\n * @type {number}\n */\ndeclare const KEY_NUMPAD_8: number;\n/**\n * @type {number}\n */\ndeclare const KEY_NUMPAD_9: number;\n/**\n * @type {number}\n */\ndeclare const KEY_MULTIPLY: number;\n/**\n * @type {number}\n */\ndeclare const KEY_ADD: number;\n/**\n * @type {number}\n */\ndeclare const KEY_SEPARATOR: number;\n/**\n * @type {number}\n */\ndeclare const KEY_SUBTRACT: number;\n/**\n * @type {number}\n */\ndeclare const KEY_DECIMAL: number;\n/**\n * @type {number}\n */\ndeclare const KEY_DIVIDE: number;\n/**\n * @type {number}\n */\ndeclare const KEY_F1: number;\n/**\n * @type {number}\n */\ndeclare const KEY_F2: number;\n/**\n * @type {number}\n */\ndeclare const KEY_F3: number;\n/**\n * @type {number}\n */\ndeclare const KEY_F4: number;\n/**\n * @type {number}\n */\ndeclare const KEY_F5: number;\n/**\n * @type {number}\n */\ndeclare const KEY_F6: number;\n/**\n * @type {number}\n */\ndeclare const KEY_F7: number;\n/**\n * @type {number}\n */\ndeclare const KEY_F8: number;\n/**\n * @type {number}\n */\ndeclare const KEY_F9: number;\n/**\n * @type {number}\n */\ndeclare const KEY_F10: number;\n/**\n * @type {number}\n */\ndeclare const KEY_F11: number;\n/**\n * @type {number}\n */\ndeclare const KEY_F12: number;\n/**\n * @type {number}\n */\ndeclare const KEY_COMMA: number;\n/**\n * @type {number}\n */\ndeclare const KEY_PERIOD: number;\n/**\n * @type {number}\n */\ndeclare const KEY_SLASH: number;\n/**\n * @type {number}\n */\ndeclare const KEY_OPEN_BRACKET: number;\n/**\n * @type {number}\n */\ndeclare const KEY_BACK_SLASH: number;\n/**\n * @type {number}\n */\ndeclare const KEY_CLOSE_BRACKET: number;\n/**\n * @type {number}\n */\ndeclare const KEY_META: number;\n/**\n * No mouse buttons pressed.\n *\n * @type {number}\n */\ndeclare const MOUSEBUTTON_NONE: number;\n/**\n * The left mouse button.\n *\n * @type {number}\n */\ndeclare const MOUSEBUTTON_LEFT: number;\n/**\n * The middle mouse button.\n *\n * @type {number}\n */\ndeclare const MOUSEBUTTON_MIDDLE: number;\n/**\n * The right mouse button.\n *\n * @type {number}\n */\ndeclare const MOUSEBUTTON_RIGHT: number;\n/**\n * Index for pad 1.\n *\n * @type {number}\n */\ndeclare const PAD_1: number;\n/**\n * Index for pad 2.\n *\n * @type {number}\n */\ndeclare const PAD_2: number;\n/**\n * Index for pad 3.\n *\n * @type {number}\n */\ndeclare const PAD_3: number;\n/**\n * Index for pad 4.\n *\n * @type {number}\n */\ndeclare const PAD_4: number;\n/**\n * The first face button, from bottom going clockwise.\n *\n * @type {number}\n */\ndeclare const PAD_FACE_1: number;\n/**\n * The second face button, from bottom going clockwise.\n *\n * @type {number}\n */\ndeclare const PAD_FACE_2: number;\n/**\n * The third face button, from bottom going clockwise.\n *\n * @type {number}\n */\ndeclare const PAD_FACE_3: number;\n/**\n * The fourth face button, from bottom going clockwise.\n *\n * @type {number}\n */\ndeclare const PAD_FACE_4: number;\n/**\n * The first shoulder button on the left.\n *\n * @type {number}\n */\ndeclare const PAD_L_SHOULDER_1: number;\n/**\n * The first shoulder button on the right.\n *\n * @type {number}\n */\ndeclare const PAD_R_SHOULDER_1: number;\n/**\n * The second shoulder button on the left.\n *\n * @type {number}\n */\ndeclare const PAD_L_SHOULDER_2: number;\n/**\n * The second shoulder button on the right.\n *\n * @type {number}\n */\ndeclare const PAD_R_SHOULDER_2: number;\n/**\n * The select button.\n *\n * @type {number}\n */\ndeclare const PAD_SELECT: number;\n/**\n * The start button.\n *\n * @type {number}\n */\ndeclare const PAD_START: number;\n/**\n * The button when depressing the left analogue stick.\n *\n * @type {number}\n */\ndeclare const PAD_L_STICK_BUTTON: number;\n/**\n * The button when depressing the right analogue stick.\n *\n * @type {number}\n */\ndeclare const PAD_R_STICK_BUTTON: number;\n/**\n * Direction pad up.\n *\n * @type {number}\n */\ndeclare const PAD_UP: number;\n/**\n * Direction pad down.\n *\n * @type {number}\n */\ndeclare const PAD_DOWN: number;\n/**\n * Direction pad left.\n *\n * @type {number}\n */\ndeclare const PAD_LEFT: number;\n/**\n * Direction pad right.\n *\n * @type {number}\n */\ndeclare const PAD_RIGHT: number;\n/**\n * Vendor specific button.\n *\n * @type {number}\n */\ndeclare const PAD_VENDOR: number;\n/**\n * Horizontal axis on the left analogue stick.\n *\n * @type {number}\n */\ndeclare const PAD_L_STICK_X: number;\n/**\n * Vertical axis on the left analogue stick.\n *\n * @type {number}\n */\ndeclare const PAD_L_STICK_Y: number;\n/**\n * Horizontal axis on the right analogue stick.\n *\n * @type {number}\n */\ndeclare const PAD_R_STICK_X: number;\n/**\n * Vertical axis on the right analogue stick.\n *\n * @type {number}\n */\ndeclare const PAD_R_STICK_Y: number;\n\n/**\n * When resizing the window the size of the canvas will not change.\n *\n * @type {string}\n */\ndeclare const FILLMODE_NONE: string;\n/**\n * When resizing the window the size of the canvas will change to fill the window exactly.\n *\n * @type {string}\n */\ndeclare const FILLMODE_FILL_WINDOW: string;\n/**\n * When resizing the window the size of the canvas will change to fill the window as best it can,\n * while maintaining the same aspect ratio.\n *\n * @type {string}\n */\ndeclare const FILLMODE_KEEP_ASPECT: string;\n/**\n * When the canvas is resized the resolution of the canvas will change to match the size of the\n * canvas.\n *\n * @type {string}\n */\ndeclare const RESOLUTION_AUTO: string;\n/**\n * When the canvas is resized the resolution of the canvas will remain at the same value and the\n * output will just be scaled to fit the canvas.\n *\n * @type {string}\n */\ndeclare const RESOLUTION_FIXED: string;\n\n/**\n * Specifies different color tints for the hover, pressed and inactive states.\n *\n * @type {number}\n */\ndeclare const BUTTON_TRANSITION_MODE_TINT: number;\n/**\n * Specifies different sprites for the hover, pressed and inactive states.\n *\n * @type {number}\n */\ndeclare const BUTTON_TRANSITION_MODE_SPRITE_CHANGE: number;\n\n/**\n * A {@link ElementComponent} that contains child {@link ElementComponent}s.\n *\n * @type {string}\n */\ndeclare const ELEMENTTYPE_GROUP: string;\n/**\n * A {@link ElementComponent} that displays an image.\n *\n * @type {string}\n */\ndeclare const ELEMENTTYPE_IMAGE: string;\n/**\n * A {@link ElementComponent} that displays text.\n *\n * @type {string}\n */\ndeclare const ELEMENTTYPE_TEXT: string;\n\n/**\n * Specified degree of freedom has free movement.\n *\n * @type {string}\n * @ignore\n */\ndeclare const MOTION_FREE: string;\n/**\n * Specified degree of freedom has limited movement.\n *\n * @type {string}\n * @ignore\n */\ndeclare const MOTION_LIMITED: string;\n/**\n * Specified degree of freedom is locked and allows no movement.\n *\n * @type {string}\n * @ignore\n */\ndeclare const MOTION_LOCKED: string;\n\n/**\n * Disable all fitting logic.\n *\n * @type {number}\n */\ndeclare const FITTING_NONE: number;\n/**\n * Stretch child elements to fit the parent container.\n *\n * @type {number}\n */\ndeclare const FITTING_STRETCH: number;\n/**\n * Shrink child elements to fit the parent container.\n *\n * @type {number}\n */\ndeclare const FITTING_SHRINK: number;\n/**\n * Apply both STRETCH and SHRINK fitting logic where applicable.\n *\n * @type {number}\n */\ndeclare const FITTING_BOTH: number;\n\n/**\n * Rigid body has infinite mass and cannot move.\n *\n * @type {string}\n */\ndeclare const BODYTYPE_STATIC: string;\n/**\n * Rigid body is simulated according to applied forces.\n *\n * @type {string}\n */\ndeclare const BODYTYPE_DYNAMIC: string;\n/**\n * Rigid body has infinite mass and does not respond to forces but can still be moved by setting\n * their velocity or position.\n *\n * @type {string}\n */\ndeclare const BODYTYPE_KINEMATIC: string;\ndeclare const BODYFLAG_STATIC_OBJECT: 1;\ndeclare const BODYFLAG_KINEMATIC_OBJECT: 2;\ndeclare const BODYFLAG_NORESPONSE_OBJECT: 4;\ndeclare const BODYSTATE_ACTIVE_TAG: 1;\ndeclare const BODYSTATE_ISLAND_SLEEPING: 2;\ndeclare const BODYSTATE_WANTS_DEACTIVATION: 3;\ndeclare const BODYSTATE_DISABLE_DEACTIVATION: 4;\ndeclare const BODYSTATE_DISABLE_SIMULATION: 5;\ndeclare const BODYGROUP_NONE: 0;\ndeclare const BODYGROUP_DEFAULT: 1;\ndeclare const BODYGROUP_DYNAMIC: 1;\ndeclare const BODYGROUP_STATIC: 2;\ndeclare const BODYGROUP_KINEMATIC: 4;\ndeclare const BODYGROUP_ENGINE_1: 8;\ndeclare const BODYGROUP_TRIGGER: 16;\ndeclare const BODYGROUP_ENGINE_2: 32;\ndeclare const BODYGROUP_ENGINE_3: 64;\ndeclare const BODYGROUP_USER_1: 128;\ndeclare const BODYGROUP_USER_2: 256;\ndeclare const BODYGROUP_USER_3: 512;\ndeclare const BODYGROUP_USER_4: 1024;\ndeclare const BODYGROUP_USER_5: 2048;\ndeclare const BODYGROUP_USER_6: 4096;\ndeclare const BODYGROUP_USER_7: 8192;\ndeclare const BODYGROUP_USER_8: 16384;\ndeclare const BODYMASK_NONE: 0;\ndeclare const BODYMASK_ALL: 65535;\ndeclare const BODYMASK_STATIC: 2;\ndeclare const BODYMASK_NOT_STATIC: number;\ndeclare const BODYMASK_NOT_STATIC_KINEMATIC: number;\n\n/**\n * Always use the application\'s resolution as the resolution for the {@link ScreenComponent}.\n *\n * @type {string}\n */\ndeclare const SCALEMODE_NONE: string;\n/**\n * Scale the {@link ScreenComponent} when the application\'s resolution is different than the\n * ScreenComponent\'s referenceResolution.\n *\n * @type {string}\n */\ndeclare const SCALEMODE_BLEND: string;\n\n/**\n * Content does not scroll any further than its bounds.\n *\n * @type {number}\n */\ndeclare const SCROLL_MODE_CLAMP: number;\n/**\n * Content scrolls past its bounds and then gently bounces back.\n *\n * @type {number}\n */\ndeclare const SCROLL_MODE_BOUNCE: number;\n/**\n * Content can scroll forever.\n *\n * @type {number}\n */\ndeclare const SCROLL_MODE_INFINITE: number;\n/**\n * The scrollbar will be visible all the time.\n *\n * @type {number}\n */\ndeclare const SCROLLBAR_VISIBILITY_SHOW_ALWAYS: number;\n/**\n * The scrollbar will be visible only when content exceeds the size of the viewport.\n *\n * @type {number}\n */\ndeclare const SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED: number;\n\n/**\n * A {@link SpriteComponent} that displays a single frame from a sprite asset.\n *\n * @type {string}\n */\ndeclare const SPRITETYPE_SIMPLE: string;\n/**\n * A {@link SpriteComponent} that renders sprite animations.\n *\n * @type {string}\n */\ndeclare const SPRITETYPE_ANIMATED: string;\n\n/**\n * Inline - always available type of session. It has limited features availability and is rendered\n * into HTML element.\n *\n * @type {string}\n */\ndeclare const XRTYPE_INLINE: string;\n/**\n * Immersive VR - session that provides exclusive access to VR device with best available tracking\n * features.\n *\n * @type {string}\n */\ndeclare const XRTYPE_VR: string;\n/**\n * Immersive AR - session that provides exclusive access to VR/AR device that is intended to be\n * blended with real-world environment.\n *\n * @type {string}\n */\ndeclare const XRTYPE_AR: string;\n/**\n * Viewer - always supported space with some basic tracking capabilities.\n *\n * @type {string}\n */\ndeclare const XRSPACE_VIEWER: string;\n/**\n * Local - represents a tracking space with a native origin near the viewer at the time of\n * creation. The exact position and orientation will be initialized based on the conventions of the\n * underlying platform. When using this reference space the user is not expected to move beyond\n * their initial position much, if at all, and tracking is optimized for that purpose. For devices\n * with 6DoF tracking, local reference spaces should emphasize keeping the origin stable relative\n * to the user\'s environment.\n *\n * @type {string}\n */\ndeclare const XRSPACE_LOCAL: string;\n/**\n * Local Floor - represents a tracking space with a native origin at the floor in a safe position\n * for the user to stand. The y axis equals 0 at floor level, with the x and z position and\n * orientation initialized based on the conventions of the underlying platform. Floor level value\n * might be estimated by the underlying platform. When using this reference space, the user is not\n * expected to move beyond their initial position much, if at all, and tracking is optimized for\n * that purpose. For devices with 6DoF tracking, local-floor reference spaces should emphasize\n * keeping the origin stable relative to the user\'s environment.\n *\n * @type {string}\n */\ndeclare const XRSPACE_LOCALFLOOR: string;\n/**\n * Bounded Floor - represents a tracking space with its native origin at the floor, where the user\n * is expected to move within a pre-established boundary. Tracking in a bounded-floor reference\n * space is optimized for keeping the native origin and bounds geometry stable relative to the\n * user\'s environment.\n *\n * @type {string}\n */\ndeclare const XRSPACE_BOUNDEDFLOOR: string;\n/**\n * Unbounded - represents a tracking space where the user is expected to move freely around their\n * environment, potentially even long distances from their starting point. Tracking in an unbounded\n * reference space is optimized for stability around the user\'s current position, and as such the\n * native origin may drift over time.\n *\n * @type {string}\n */\ndeclare const XRSPACE_UNBOUNDED: string;\n/**\n * Gaze - indicates the target ray will originate at the viewer and follow the direction it is\n * facing. This is commonly referred to as a "gaze input" device in the context of head-mounted\n * displays.\n *\n * @type {string}\n */\ndeclare const XRTARGETRAY_GAZE: string;\n/**\n * Screen - indicates that the input source was an interaction with the canvas element associated\n * with an inline session\'s output context, such as a mouse click or touch event.\n *\n * @type {string}\n */\ndeclare const XRTARGETRAY_SCREEN: string;\n/**\n * Tracked Pointer - indicates that the target ray originates from either a handheld device or\n * other hand-tracking mechanism and represents that the user is using their hands or the held\n * device for pointing.\n *\n * @type {string}\n */\ndeclare const XRTARGETRAY_POINTER: string;\n/**\n * None - input source is not meant to be held in hands.\n *\n * @type {string}\n */\ndeclare const XRHAND_NONE: string;\n/**\n * Left - indicates that input source is meant to be held in left hand.\n *\n * @type {string}\n */\ndeclare const XRHAND_LEFT: string;\n/**\n * Right - indicates that input source is meant to be held in right hand.\n *\n * @type {string}\n */\ndeclare const XRHAND_RIGHT: string;\n/**\n * Point - indicates that the hit test results will be computed based on the feature points\n * detected by the underlying Augmented Reality system.\n *\n * @type {string}\n */\ndeclare const XRTRACKABLE_POINT: string;\n/**\n * Plane - indicates that the hit test results will be computed based on the planes detected by the\n * underlying Augmented Reality system.\n *\n * @type {string}\n */\ndeclare const XRTRACKABLE_PLANE: string;\n/**\n * Mesh - indicates that the hit test results will be computed based on the meshes detected by the\n * underlying Augmented Reality system.\n *\n * @type {string}\n */\ndeclare const XRTRACKABLE_MESH: string;\n/**\n * CPU - indicates that depth sensing preferred usage is CPU. This usage path is guaranteed to be\n * supported.\n *\n * @type {string}\n */\ndeclare const XRDEPTHSENSINGUSAGE_CPU: string;\n/**\n * GPU - indicates that depth sensing preferred usage is GPU.\n *\n * @type {string}\n */\ndeclare const XRDEPTHSENSINGUSAGE_GPU: string;\n/**\n * Luminance Alpha - indicates that depth sensing preferred raw data format is Luminance Alpha.\n * This format is guaranteed to be supported.\n *\n * @type {string}\n */\ndeclare const XRDEPTHSENSINGFORMAT_L8A8: string;\n/**\n * Float 32 - indicates that depth sensing preferred raw data format is Float 32.\n *\n * @type {string}\n */\ndeclare const XRDEPTHSENSINGFORMAT_F32: string;\n\ndeclare function now(): number;\n/**\n * A Timer counts milliseconds from when start() is called until when stop() is called.\n *\n * @ignore\n */\ndeclare class Timer {\n    _isRunning: boolean;\n    _a: number;\n    _b: number;\n    /**\n     * Start the timer.\n     */\n    start(): void;\n    /**\n     * Stop the timer.\n     */\n    stop(): void;\n    /**\n     * Get the number of milliseconds that passed between start() and stop() being called.\n     *\n     * @returns {number} The elapsed milliseconds.\n     */\n    getMilliseconds(): number;\n}\n\n/**\n * 3-dimensional vector.\n */\ndeclare class Vec3 {\n    /**\n     * A constant vector set to [0, 0, 0].\n     *\n     * @type {Vec3}\n     * @readonly\n     */\n    static readonly ZERO: Vec3;\n    /**\n     * A constant vector set to [1, 1, 1].\n     *\n     * @type {Vec3}\n     * @readonly\n     */\n    static readonly ONE: Vec3;\n    /**\n     * A constant vector set to [0, 1, 0].\n     *\n     * @type {Vec3}\n     * @readonly\n     */\n    static readonly UP: Vec3;\n    /**\n     * A constant vector set to [0, -1, 0].\n     *\n     * @type {Vec3}\n     * @readonly\n     */\n    static readonly DOWN: Vec3;\n    /**\n     * A constant vector set to [1, 0, 0].\n     *\n     * @type {Vec3}\n     * @readonly\n     */\n    static readonly RIGHT: Vec3;\n    /**\n     * A constant vector set to [-1, 0, 0].\n     *\n     * @type {Vec3}\n     * @readonly\n     */\n    static readonly LEFT: Vec3;\n    /**\n     * A constant vector set to [0, 0, -1].\n     *\n     * @type {Vec3}\n     * @readonly\n     */\n    static readonly FORWARD: Vec3;\n    /**\n     * A constant vector set to [0, 0, 1].\n     *\n     * @type {Vec3}\n     * @readonly\n     */\n    static readonly BACK: Vec3;\n    /**\n     * Creates a new Vec3 object.\n     *\n     * @param {number|number[]} [x] - The x value. Defaults to 0. If x is an array of length 3, the\n     * array will be used to populate all components.\n     * @param {number} [y] - The y value. Defaults to 0.\n     * @param {number} [z] - The z value. Defaults to 0.\n     * @example\n     * var v = new pc.Vec3(1, 2, 3);\n     */\n    constructor(x?: number | number[], y?: number, z?: number);\n    /**\n     * The first component of the vector.\n     *\n     * @type {number}\n     */\n    x: number;\n    /**\n     * The second component of the vector.\n     *\n     * @type {number}\n     */\n    y: number;\n    /**\n     * The third component of the vector.\n     *\n     * @type {number}\n     */\n    z: number;\n    /**\n     * Adds a 3-dimensional vector to another in place.\n     *\n     * @param {Vec3} rhs - The vector to add to the specified vector.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(10, 10, 10);\n     * var b = new pc.Vec3(20, 20, 20);\n     *\n     * a.add(b);\n     *\n     * // Outputs [30, 30, 30]\n     * console.log("The result of the addition is: " + a.toString());\n     */\n    add(rhs: Vec3): Vec3;\n    /**\n     * Adds two 3-dimensional vectors together and returns the result.\n     *\n     * @param {Vec3} lhs - The first vector operand for the addition.\n     * @param {Vec3} rhs - The second vector operand for the addition.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(10, 10, 10);\n     * var b = new pc.Vec3(20, 20, 20);\n     * var r = new pc.Vec3();\n     *\n     * r.add2(a, b);\n     * // Outputs [30, 30, 30]\n     *\n     * console.log("The result of the addition is: " + r.toString());\n     */\n    add2(lhs: Vec3, rhs: Vec3): Vec3;\n    /**\n     * Adds a number to each element of a vector.\n     *\n     * @param {number} scalar - The number to add.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var vec = new pc.Vec3(3, 4, 5);\n     *\n     * vec.addScalar(2);\n     *\n     * // Outputs [5, 6, 7]\n     * console.log("The result of the addition is: " + vec.toString());\n     */\n    addScalar(scalar: number): Vec3;\n    /**\n     * Returns an identical copy of the specified 3-dimensional vector.\n     *\n     * @returns {Vec3} A 3-dimensional vector containing the result of the cloning.\n     * @example\n     * var v = new pc.Vec3(10, 20, 30);\n     * var vclone = v.clone();\n     * console.log("The result of the cloning is: " + vclone.toString());\n     */\n    clone(): Vec3;\n    /**\n     * Copies the contents of a source 3-dimensional vector to a destination 3-dimensional vector.\n     *\n     * @param {Vec3} rhs - A vector to copy to the specified vector.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var src = new pc.Vec3(10, 20, 30);\n     * var dst = new pc.Vec3();\n     *\n     * dst.copy(src);\n     *\n     * console.log("The two vectors are " + (dst.equals(src) ? "equal" : "different"));\n     */\n    copy(rhs: Vec3): Vec3;\n    /**\n     * Returns the result of a cross product operation performed on the two specified 3-dimensional\n     * vectors.\n     *\n     * @param {Vec3} lhs - The first 3-dimensional vector operand of the cross product.\n     * @param {Vec3} rhs - The second 3-dimensional vector operand of the cross product.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var back = new pc.Vec3().cross(pc.Vec3.RIGHT, pc.Vec3.UP);\n     *\n     * // Prints the Z axis (i.e. [0, 0, 1])\n     * console.log("The result of the cross product is: " + back.toString());\n     */\n    cross(lhs: Vec3, rhs: Vec3): Vec3;\n    /**\n     * Returns the distance between the two specified 3-dimensional vectors.\n     *\n     * @param {Vec3} rhs - The second 3-dimensional vector to test.\n     * @returns {number} The distance between the two vectors.\n     * @example\n     * var v1 = new pc.Vec3(5, 10, 20);\n     * var v2 = new pc.Vec3(10, 20, 40);\n     * var d = v1.distance(v2);\n     * console.log("The distance between v1 and v2 is: " + d);\n     */\n    distance(rhs: Vec3): number;\n    /**\n     * Divides a 3-dimensional vector by another in place.\n     *\n     * @param {Vec3} rhs - The vector to divide the specified vector by.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(4, 9, 16);\n     * var b = new pc.Vec3(2, 3, 4);\n     *\n     * a.div(b);\n     *\n     * // Outputs [2, 3, 4]\n     * console.log("The result of the division is: " + a.toString());\n     */\n    div(rhs: Vec3): Vec3;\n    /**\n     * Divides one 3-dimensional vector by another and writes the result to the specified vector.\n     *\n     * @param {Vec3} lhs - The dividend vector (the vector being divided).\n     * @param {Vec3} rhs - The divisor vector (the vector dividing the dividend).\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(4, 9, 16);\n     * var b = new pc.Vec3(2, 3, 4);\n     * var r = new pc.Vec3();\n     *\n     * r.div2(a, b);\n     * // Outputs [2, 3, 4]\n     *\n     * console.log("The result of the division is: " + r.toString());\n     */\n    div2(lhs: Vec3, rhs: Vec3): Vec3;\n    /**\n     * Divides each element of a vector by a number.\n     *\n     * @param {number} scalar - The number to divide by.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var vec = new pc.Vec3(3, 6, 9);\n     *\n     * vec.divScalar(3);\n     *\n     * // Outputs [1, 2, 3]\n     * console.log("The result of the division is: " + vec.toString());\n     */\n    divScalar(scalar: number): Vec3;\n    /**\n     * Returns the result of a dot product operation performed on the two specified 3-dimensional\n     * vectors.\n     *\n     * @param {Vec3} rhs - The second 3-dimensional vector operand of the dot product.\n     * @returns {number} The result of the dot product operation.\n     * @example\n     * var v1 = new pc.Vec3(5, 10, 20);\n     * var v2 = new pc.Vec3(10, 20, 40);\n     * var v1dotv2 = v1.dot(v2);\n     * console.log("The result of the dot product is: " + v1dotv2);\n     */\n    dot(rhs: Vec3): number;\n    /**\n     * Reports whether two vectors are equal.\n     *\n     * @param {Vec3} rhs - The vector to compare to the specified vector.\n     * @returns {boolean} True if the vectors are equal and false otherwise.\n     * @example\n     * var a = new pc.Vec3(1, 2, 3);\n     * var b = new pc.Vec3(4, 5, 6);\n     * console.log("The two vectors are " + (a.equals(b) ? "equal" : "different"));\n     */\n    equals(rhs: Vec3): boolean;\n    /**\n     * Returns the magnitude of the specified 3-dimensional vector.\n     *\n     * @returns {number} The magnitude of the specified 3-dimensional vector.\n     * @example\n     * var vec = new pc.Vec3(3, 4, 0);\n     * var len = vec.length();\n     * // Outputs 5\n     * console.log("The length of the vector is: " + len);\n     */\n    length(): number;\n    /**\n     * Returns the magnitude squared of the specified 3-dimensional vector.\n     *\n     * @returns {number} The magnitude of the specified 3-dimensional vector.\n     * @example\n     * var vec = new pc.Vec3(3, 4, 0);\n     * var len = vec.lengthSq();\n     * // Outputs 25\n     * console.log("The length squared of the vector is: " + len);\n     */\n    lengthSq(): number;\n    /**\n     * Returns the result of a linear interpolation between two specified 3-dimensional vectors.\n     *\n     * @param {Vec3} lhs - The 3-dimensional to interpolate from.\n     * @param {Vec3} rhs - The 3-dimensional to interpolate to.\n     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,\n     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this\n     * range, the linear interpolant will occur on a ray extrapolated from this line.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(0, 0, 0);\n     * var b = new pc.Vec3(10, 10, 10);\n     * var r = new pc.Vec3();\n     *\n     * r.lerp(a, b, 0);   // r is equal to a\n     * r.lerp(a, b, 0.5); // r is 5, 5, 5\n     * r.lerp(a, b, 1);   // r is equal to b\n     */\n    lerp(lhs: Vec3, rhs: Vec3, alpha: number): Vec3;\n    /**\n     * Multiplies a 3-dimensional vector to another in place.\n     *\n     * @param {Vec3} rhs - The 3-dimensional vector used as the second multiplicand of the operation.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(2, 3, 4);\n     * var b = new pc.Vec3(4, 5, 6);\n     *\n     * a.mul(b);\n     *\n     * // Outputs 8, 15, 24\n     * console.log("The result of the multiplication is: " + a.toString());\n     */\n    mul(rhs: Vec3): Vec3;\n    /**\n     * Returns the result of multiplying the specified 3-dimensional vectors together.\n     *\n     * @param {Vec3} lhs - The 3-dimensional vector used as the first multiplicand of the operation.\n     * @param {Vec3} rhs - The 3-dimensional vector used as the second multiplicand of the operation.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(2, 3, 4);\n     * var b = new pc.Vec3(4, 5, 6);\n     * var r = new pc.Vec3();\n     *\n     * r.mul2(a, b);\n     *\n     * // Outputs 8, 15, 24\n     * console.log("The result of the multiplication is: " + r.toString());\n     */\n    mul2(lhs: Vec3, rhs: Vec3): Vec3;\n    /**\n     * Multiplies each element of a vector by a number.\n     *\n     * @param {number} scalar - The number to multiply by.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var vec = new pc.Vec3(3, 6, 9);\n     *\n     * vec.mulScalar(3);\n     *\n     * // Outputs [9, 18, 27]\n     * console.log("The result of the multiplication is: " + vec.toString());\n     */\n    mulScalar(scalar: number): Vec3;\n    /**\n     * Returns this 3-dimensional vector converted to a unit vector in place. If the vector has a\n     * length of zero, the vector\'s elements will be set to zero.\n     *\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var v = new pc.Vec3(25, 0, 0);\n     *\n     * v.normalize();\n     *\n     * // Outputs 1, 0, 0\n     * console.log("The result of the vector normalization is: " + v.toString());\n     */\n    normalize(): Vec3;\n    /**\n     * Each element is set to the largest integer less than or equal to its value.\n     *\n     * @returns {Vec3} Self for chaining.\n     */\n    floor(): Vec3;\n    /**\n     * Each element is rounded up to the next largest integer.\n     *\n     * @returns {Vec3} Self for chaining.\n     */\n    ceil(): Vec3;\n    /**\n     * Each element is rounded up or down to the nearest integer.\n     *\n     * @returns {Vec3} Self for chaining.\n     */\n    round(): Vec3;\n    /**\n     * Each element is assigned a value from rhs parameter if it is smaller.\n     *\n     * @param {Vec3} rhs - The 3-dimensional vector used as the source of elements to compare to.\n     * @returns {Vec3} Self for chaining.\n     */\n    min(rhs: Vec3): Vec3;\n    /**\n     * Each element is assigned a value from rhs parameter if it is larger.\n     *\n     * @param {Vec3} rhs - The 3-dimensional vector used as the source of elements to compare to.\n     * @returns {Vec3} Self for chaining.\n     */\n    max(rhs: Vec3): Vec3;\n    /**\n     * Projects this 3-dimensional vector onto the specified vector.\n     *\n     * @param {Vec3} rhs - The vector onto which the original vector will be projected on.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var v = new pc.Vec3(5, 5, 5);\n     * var normal = new pc.Vec3(1, 0, 0);\n     *\n     * v.project(normal);\n     *\n     * // Outputs 5, 0, 0\n     * console.log("The result of the vector projection is: " + v.toString());\n     */\n    project(rhs: Vec3): Vec3;\n    /**\n     * Sets the specified 3-dimensional vector to the supplied numerical values.\n     *\n     * @param {number} x - The value to set on the first component of the vector.\n     * @param {number} y - The value to set on the second component of the vector.\n     * @param {number} z - The value to set on the third component of the vector.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var v = new pc.Vec3();\n     * v.set(5, 10, 20);\n     *\n     * // Outputs 5, 10, 20\n     * console.log("The result of the vector set is: " + v.toString());\n     */\n    set(x: number, y: number, z: number): Vec3;\n    /**\n     * Subtracts a 3-dimensional vector from another in place.\n     *\n     * @param {Vec3} rhs - The vector to add to the specified vector.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(10, 10, 10);\n     * var b = new pc.Vec3(20, 20, 20);\n     *\n     * a.sub(b);\n     *\n     * // Outputs [-10, -10, -10]\n     * console.log("The result of the subtraction is: " + a.toString());\n     */\n    sub(rhs: Vec3): Vec3;\n    /**\n     * Subtracts two 3-dimensional vectors from one another and returns the result.\n     *\n     * @param {Vec3} lhs - The first vector operand for the addition.\n     * @param {Vec3} rhs - The second vector operand for the addition.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(10, 10, 10);\n     * var b = new pc.Vec3(20, 20, 20);\n     * var r = new pc.Vec3();\n     *\n     * r.sub2(a, b);\n     *\n     * // Outputs [-10, -10, -10]\n     * console.log("The result of the subtraction is: " + r.toString());\n     */\n    sub2(lhs: Vec3, rhs: Vec3): Vec3;\n    /**\n     * Subtracts a number from each element of a vector.\n     *\n     * @param {number} scalar - The number to subtract.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var vec = new pc.Vec3(3, 4, 5);\n     *\n     * vec.subScalar(2);\n     *\n     * // Outputs [1, 2, 3]\n     * console.log("The result of the subtraction is: " + vec.toString());\n     */\n    subScalar(scalar: number): Vec3;\n    /**\n     * Converts the vector to string form.\n     *\n     * @returns {string} The vector in string form.\n     * @example\n     * var v = new pc.Vec3(20, 10, 5);\n     * // Outputs [20, 10, 5]\n     * console.log(v.toString());\n     */\n    toString(): string;\n}\n\n/**\n * An infinite ray.\n */\ndeclare class Ray {\n    /**\n     * Creates a new Ray instance. The ray is infinite, starting at a given origin and pointing in\n     * a given direction.\n     *\n     * @param {Vec3} [origin] - The starting point of the ray. The constructor takes a reference of\n     * this parameter. Defaults to the origin (0, 0, 0).\n     * @param {Vec3} [direction] - The direction of the ray. The constructor takes a reference of\n     * this parameter. Defaults to a direction down the world negative Z axis (0, 0, -1).\n     * @example\n     * // Create a new ray starting at the position of this entity and pointing down\n     * // the entity\'s negative Z axis\n     * var ray = new pc.Ray(this.entity.getPosition(), this.entity.forward);\n     */\n    constructor(origin?: Vec3, direction?: Vec3);\n    /**\n     * The starting point of the ray.\n     *\n     * @type {Vec3}\n     */\n    origin: Vec3;\n    /**\n     * The direction of the ray.\n     *\n     * @type {Vec3}\n     */\n    direction: Vec3;\n    /**\n     * Sets origin and direction to the supplied vector values.\n     *\n     * @param {Vec3} origin - The starting point of the ray.\n     * @param {Vec3} direction - The direction of the ray.\n     * @returns {Ray} Self for chaining.\n     */\n    set(origin: Vec3, direction: Vec3): Ray;\n}\n\n\n/**\n * A bounding sphere is a volume for facilitating fast intersection testing.\n */\ndeclare class BoundingSphere {\n    /**\n     * Creates a new BoundingSphere instance.\n     *\n     * @param {Vec3} [center] - The world space coordinate marking the center of the sphere. The\n     * constructor takes a reference of this parameter.\n     * @param {number} [radius] - The radius of the bounding sphere. Defaults to 0.5.\n     * @example\n     * // Create a new bounding sphere centered on the origin with a radius of 0.5\n     * var sphere = new pc.BoundingSphere();\n     */\n    constructor(center?: Vec3, radius?: number);\n    /**\n     * Center of sphere.\n     *\n     * @type {Vec3}\n     */\n    center: Vec3;\n    /**\n     * The radius of the bounding sphere.\n     *\n     * @type {number}\n     */\n    radius: number;\n    containsPoint(point: any): boolean;\n    /**\n     * Test if a ray intersects with the sphere.\n     *\n     * @param {Ray} ray - Ray to test against (direction must be normalized).\n     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied\n     * into here.\n     * @returns {boolean} True if there is an intersection.\n     */\n    intersectsRay(ray: Ray, point?: Vec3): boolean;\n    /**\n     * Test if a Bounding Sphere is overlapping, enveloping, or inside this Bounding Sphere.\n     *\n     * @param {BoundingSphere} sphere - Bounding Sphere to test.\n     * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping, or inside this Bounding Sphere and false otherwise.\n     */\n    intersectsBoundingSphere(sphere: BoundingSphere): boolean;\n}\n\n\n/** @typedef {import(\'./mat4.js\').Mat4} Mat4 */\n/**\n * A quaternion.\n */\ndeclare class Quat {\n    /**\n     * A constant quaternion set to [0, 0, 0, 1] (the identity).\n     *\n     * @type {Quat}\n     * @readonly\n     */\n    static readonly IDENTITY: Quat;\n    /**\n     * A constant quaternion set to [0, 0, 0, 0].\n     *\n     * @type {Quat}\n     * @readonly\n     */\n    static readonly ZERO: Quat;\n    /**\n     * Create a new Quat instance.\n     *\n     * @param {number|number[]} [x] - The quaternion\'s x component. Defaults to 0. If x is an array\n     * of length 4, the array will be used to populate all components.\n     * @param {number} [y] - The quaternion\'s y component. Defaults to 0.\n     * @param {number} [z] - The quaternion\'s z component. Defaults to 0.\n     * @param {number} [w] - The quaternion\'s w component. Defaults to 1.\n     */\n    constructor(x?: number | number[], y?: number, z?: number, w?: number);\n    /**\n     * The x component of the quaternion.\n     *\n     * @type {number}\n     */\n    x: number;\n    /**\n     * The y component of the quaternion.\n     *\n     * @type {number}\n     */\n    y: number;\n    /**\n     * The z component of the quaternion.\n     *\n     * @type {number}\n     */\n    z: number;\n    /**\n     * The w component of the quaternion.\n     *\n     * @type {number}\n     */\n    w: number;\n    /**\n     * Returns an identical copy of the specified quaternion.\n     *\n     * @returns {Quat} A quaternion containing the result of the cloning.\n     * @example\n     * var q = new pc.Quat(-0.11, -0.15, -0.46, 0.87);\n     * var qclone = q.clone();\n     *\n     * console.log("The result of the cloning is: " + q.toString());\n     */\n    clone(): Quat;\n    conjugate(): Quat;\n    /**\n     * Copies the contents of a source quaternion to a destination quaternion.\n     *\n     * @param {Quat} rhs - The quaternion to be copied.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * var src = new pc.Quat();\n     * var dst = new pc.Quat();\n     * dst.copy(src, src);\n     * console.log("The two quaternions are " + (src.equals(dst) ? "equal" : "different"));\n     */\n    copy(rhs: Quat): Quat;\n    /**\n     * Reports whether two quaternions are equal.\n     *\n     * @param {Quat} rhs - The quaternion to be compared against.\n     * @returns {boolean} True if the quaternions are equal and false otherwise.\n     * @example\n     * var a = new pc.Quat();\n     * var b = new pc.Quat();\n     * console.log("The two quaternions are " + (a.equals(b) ? "equal" : "different"));\n     */\n    equals(rhs: Quat): boolean;\n    /**\n     * Gets the rotation axis and angle for a given quaternion. If a quaternion is created with\n     * `setFromAxisAngle`, this method will return the same values as provided in the original\n     * parameter list OR functionally equivalent values.\n     *\n     * @param {Vec3} axis - The 3-dimensional vector to receive the axis of rotation.\n     * @returns {number} Angle, in degrees, of the rotation.\n     * @example\n     * var q = new pc.Quat();\n     * q.setFromAxisAngle(new pc.Vec3(0, 1, 0), 90);\n     * var v = new pc.Vec3();\n     * var angle = q.getAxisAngle(v);\n     * // Outputs 90\n     * console.log(angle);\n     * // Outputs [0, 1, 0]\n     * console.log(v.toString());\n     */\n    getAxisAngle(axis: Vec3): number;\n    /**\n     * Converts the supplied quaternion to Euler angles.\n     *\n     * @param {Vec3} [eulers] - The 3-dimensional vector to receive the Euler angles.\n     * @returns {Vec3} The 3-dimensional vector holding the Euler angles that\n     * correspond to the supplied quaternion.\n     */\n    getEulerAngles(eulers?: Vec3): Vec3;\n    /**\n     * Generates the inverse of the specified quaternion.\n     *\n     * @returns {Quat} Self for chaining.\n     * @example\n     * // Create a quaternion rotated 180 degrees around the y-axis\n     * var rot = new pc.Quat().setFromEulerAngles(0, 180, 0);\n     *\n     * // Invert in place\n     * rot.invert();\n     */\n    invert(): Quat;\n    /**\n     * Returns the magnitude of the specified quaternion.\n     *\n     * @returns {number} The magnitude of the specified quaternion.\n     * @example\n     * var q = new pc.Quat(0, 0, 0, 5);\n     * var len = q.length();\n     * // Outputs 5\n     * console.log("The length of the quaternion is: " + len);\n     */\n    length(): number;\n    /**\n     * Returns the magnitude squared of the specified quaternion.\n     *\n     * @returns {number} The magnitude of the specified quaternion.\n     * @example\n     * var q = new pc.Quat(3, 4, 0);\n     * var lenSq = q.lengthSq();\n     * // Outputs 25\n     * console.log("The length squared of the quaternion is: " + lenSq);\n     */\n    lengthSq(): number;\n    /**\n     * Returns the result of multiplying the specified quaternions together.\n     *\n     * @param {Quat} rhs - The quaternion used as the second multiplicand of the operation.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * var a = new pc.Quat().setFromEulerAngles(0, 30, 0);\n     * var b = new pc.Quat().setFromEulerAngles(0, 60, 0);\n     *\n     * // a becomes a 90 degree rotation around the Y axis\n     * // In other words, a = a * b\n     * a.mul(b);\n     *\n     * console.log("The result of the multiplication is: " + a.toString());\n     */\n    mul(rhs: Quat): Quat;\n    /**\n     * Returns the result of multiplying the specified quaternions together.\n     *\n     * @param {Quat} lhs - The quaternion used as the first multiplicand of the operation.\n     * @param {Quat} rhs - The quaternion used as the second multiplicand of the operation.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * var a = new pc.Quat().setFromEulerAngles(0, 30, 0);\n     * var b = new pc.Quat().setFromEulerAngles(0, 60, 0);\n     * var r = new pc.Quat();\n     *\n     * // r is set to a 90 degree rotation around the Y axis\n     * // In other words, r = a * b\n     * r.mul2(a, b);\n     *\n     * console.log("The result of the multiplication is: " + r.toString());\n     */\n    mul2(lhs: Quat, rhs: Quat): Quat;\n    /**\n     * Returns the specified quaternion converted in place to a unit quaternion.\n     *\n     * @returns {Quat} The result of the normalization.\n     * @example\n     * var v = new pc.Quat(0, 0, 0, 5);\n     *\n     * v.normalize();\n     *\n     * // Outputs 0, 0, 0, 1\n     * console.log("The result of the vector normalization is: " + v.toString());\n     */\n    normalize(): Quat;\n    /**\n     * Sets the specified quaternion to the supplied numerical values.\n     *\n     * @param {number} x - The x component of the quaternion.\n     * @param {number} y - The y component of the quaternion.\n     * @param {number} z - The z component of the quaternion.\n     * @param {number} w - The w component of the quaternion.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * var q = new pc.Quat();\n     * q.set(1, 0, 0, 0);\n     *\n     * // Outputs 1, 0, 0, 0\n     * console.log("The result of the vector set is: " + q.toString());\n     */\n    set(x: number, y: number, z: number, w: number): Quat;\n    /**\n     * Sets a quaternion from an angular rotation around an axis.\n     *\n     * @param {Vec3} axis - World space axis around which to rotate.\n     * @param {number} angle - Angle to rotate around the given axis in degrees.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * var q = new pc.Quat();\n     * q.setFromAxisAngle(pc.Vec3.UP, 90);\n     */\n    setFromAxisAngle(axis: Vec3, angle: number): Quat;\n    /**\n     * Sets a quaternion from Euler angles specified in XYZ order.\n     *\n     * @param {number|Vec3} ex - Angle to rotate around X axis in degrees. If ex is a Vec3, the\n     * three angles will be read from it instead.\n     * @param {number} [ey] - Angle to rotate around Y axis in degrees.\n     * @param {number} [ez] - Angle to rotate around Z axis in degrees.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * // Create a quaternion from 3 euler angles\n     * var q = new pc.Quat();\n     * q.setFromEulerAngles(45, 90, 180);\n     *\n     * // Create the same quaternion from a vector containing the same 3 euler angles\n     * var v = new pc.Vec3(45, 90, 180);\n     * var r = new pc.Quat();\n     * r.setFromEulerAngles(v);\n     */\n    setFromEulerAngles(ex: number | Vec3, ey?: number, ez?: number): Quat;\n    /**\n     * Converts the specified 4x4 matrix to a quaternion. Note that since a quaternion is purely a\n     * representation for orientation, only the translational part of the matrix is lost.\n     *\n     * @param {Mat4} m - The 4x4 matrix to convert.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * // Create a 4x4 rotation matrix of 180 degrees around the y-axis\n     * var rot = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);\n     *\n     * // Convert to a quaternion\n     * var q = new pc.Quat().setFromMat4(rot);\n     */\n    setFromMat4(m: Mat4): Quat;\n    /**\n     * Performs a spherical interpolation between two quaternions. The result of the interpolation\n     * is written to the quaternion calling the function.\n     *\n     * @param {Quat} lhs - The quaternion to interpolate from.\n     * @param {Quat} rhs - The quaternion to interpolate to.\n     * @param {number} alpha - The value controlling the interpolation in relation to the two input\n     * quaternions. The value is in the range 0 to 1, 0 generating q1, 1 generating q2 and anything\n     * in between generating a spherical interpolation between the two.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * var q1 = new pc.Quat(-0.11, -0.15, -0.46, 0.87);\n     * var q2 = new pc.Quat(-0.21, -0.21, -0.67, 0.68);\n     *\n     * var result;\n     * result = new pc.Quat().slerp(q1, q2, 0);   // Return q1\n     * result = new pc.Quat().slerp(q1, q2, 0.5); // Return the midpoint interpolant\n     * result = new pc.Quat().slerp(q1, q2, 1);   // Return q2\n     */\n    slerp(lhs: Quat, rhs: Quat, alpha: number): Quat;\n    /**\n     * Transforms a 3-dimensional vector by the specified quaternion.\n     *\n     * @param {Vec3} vec - The 3-dimensional vector to be transformed.\n     * @param {Vec3} [res] - An optional 3-dimensional vector to receive the result of the transformation.\n     * @returns {Vec3} The input vector v transformed by the current instance.\n     * @example\n     * // Create a 3-dimensional vector\n     * var v = new pc.Vec3(1, 2, 3);\n     *\n     * // Create a 4x4 rotation matrix\n     * var q = new pc.Quat().setFromEulerAngles(10, 20, 30);\n     *\n     * var tv = q.transformVector(v);\n     */\n    transformVector(vec: Vec3, res?: Vec3): Vec3;\n    /**\n     * Converts the quaternion to string form.\n     *\n     * @returns {string} The quaternion in string form.\n     * @example\n     * var v = new pc.Quat(0, 0, 0, 1);\n     * // Outputs [0, 0, 0, 1]\n     * console.log(v.toString());\n     */\n    toString(): string;\n}\n\n/**\n * A 4-dimensional vector.\n */\ndeclare class Vec4 {\n    /**\n     * A constant vector set to [0, 0, 0, 0].\n     *\n     * @type {Vec4}\n     * @readonly\n     */\n    static readonly ZERO: Vec4;\n    /**\n     * A constant vector set to [1, 1, 1, 1].\n     *\n     * @type {Vec4}\n     * @readonly\n     */\n    static readonly ONE: Vec4;\n    /**\n     * Creates a new Vec4 object.\n     *\n     * @param {number|number[]} [x] - The x value. Defaults to 0. If x is an array of length 4, the\n     * array will be used to populate all components.\n     * @param {number} [y] - The y value. Defaults to 0.\n     * @param {number} [z] - The z value. Defaults to 0.\n     * @param {number} [w] - The w value. Defaults to 0.\n     * @example\n     * var v = new pc.Vec4(1, 2, 3, 4);\n     */\n    constructor(x?: number | number[], y?: number, z?: number, w?: number);\n    /**\n     * The first component of the vector.\n     *\n     * @type {number}\n     */\n    x: number;\n    /**\n     * The second component of the vector.\n     *\n     * @type {number}\n     */\n    y: number;\n    /**\n     * The third component of the vector.\n     *\n     * @type {number}\n     */\n    z: number;\n    /**\n     * The fourth component of the vector.\n     *\n     * @type {number}\n     */\n    w: number;\n    /**\n     * Adds a 4-dimensional vector to another in place.\n     *\n     * @param {Vec4} rhs - The vector to add to the specified vector.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(10, 10, 10, 10);\n     * var b = new pc.Vec4(20, 20, 20, 20);\n     *\n     * a.add(b);\n     *\n     * // Outputs [30, 30, 30]\n     * console.log("The result of the addition is: " + a.toString());\n     */\n    add(rhs: Vec4): Vec4;\n    /**\n     * Adds two 4-dimensional vectors together and returns the result.\n     *\n     * @param {Vec4} lhs - The first vector operand for the addition.\n     * @param {Vec4} rhs - The second vector operand for the addition.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(10, 10, 10, 10);\n     * var b = new pc.Vec4(20, 20, 20, 20);\n     * var r = new pc.Vec4();\n     *\n     * r.add2(a, b);\n     * // Outputs [30, 30, 30]\n     *\n     * console.log("The result of the addition is: " + r.toString());\n     */\n    add2(lhs: Vec4, rhs: Vec4): Vec4;\n    /**\n     * Adds a number to each element of a vector.\n     *\n     * @param {number} scalar - The number to add.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var vec = new pc.Vec4(3, 4, 5, 6);\n     *\n     * vec.addScalar(2);\n     *\n     * // Outputs [5, 6, 7, 8]\n     * console.log("The result of the addition is: " + vec.toString());\n     */\n    addScalar(scalar: number): Vec4;\n    /**\n     * Returns an identical copy of the specified 4-dimensional vector.\n     *\n     * @returns {Vec4} A 4-dimensional vector containing the result of the cloning.\n     * @example\n     * var v = new pc.Vec4(10, 20, 30, 40);\n     * var vclone = v.clone();\n     * console.log("The result of the cloning is: " + vclone.toString());\n     */\n    clone(): Vec4;\n    /**\n     * Copies the contents of a source 4-dimensional vector to a destination 4-dimensional vector.\n     *\n     * @param {Vec4} rhs - A vector to copy to the specified vector.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var src = new pc.Vec4(10, 20, 30, 40);\n     * var dst = new pc.Vec4();\n     *\n     * dst.copy(src);\n     *\n     * console.log("The two vectors are " + (dst.equals(src) ? "equal" : "different"));\n     */\n    copy(rhs: Vec4): Vec4;\n    /**\n     * Divides a 4-dimensional vector by another in place.\n     *\n     * @param {Vec4} rhs - The vector to divide the specified vector by.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(4, 9, 16, 25);\n     * var b = new pc.Vec4(2, 3, 4, 5);\n     *\n     * a.div(b);\n     *\n     * // Outputs [2, 3, 4, 5]\n     * console.log("The result of the division is: " + a.toString());\n     */\n    div(rhs: Vec4): Vec4;\n    /**\n     * Divides one 4-dimensional vector by another and writes the result to the specified vector.\n     *\n     * @param {Vec4} lhs - The dividend vector (the vector being divided).\n     * @param {Vec4} rhs - The divisor vector (the vector dividing the dividend).\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(4, 9, 16, 25);\n     * var b = new pc.Vec4(2, 3, 4, 5);\n     * var r = new pc.Vec4();\n     *\n     * r.div2(a, b);\n     * // Outputs [2, 3, 4, 5]\n     *\n     * console.log("The result of the division is: " + r.toString());\n     */\n    div2(lhs: Vec4, rhs: Vec4): Vec4;\n    /**\n     * Divides each element of a vector by a number.\n     *\n     * @param {number} scalar - The number to divide by.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var vec = new pc.Vec4(3, 6, 9, 12);\n     *\n     * vec.divScalar(3);\n     *\n     * // Outputs [1, 2, 3, 4]\n     * console.log("The result of the division is: " + vec.toString());\n     */\n    divScalar(scalar: number): Vec4;\n    /**\n     * Returns the result of a dot product operation performed on the two specified 4-dimensional\n     * vectors.\n     *\n     * @param {Vec4} rhs - The second 4-dimensional vector operand of the dot product.\n     * @returns {number} The result of the dot product operation.\n     * @example\n     * var v1 = new pc.Vec4(5, 10, 20, 40);\n     * var v2 = new pc.Vec4(10, 20, 40, 80);\n     * var v1dotv2 = v1.dot(v2);\n     * console.log("The result of the dot product is: " + v1dotv2);\n     */\n    dot(rhs: Vec4): number;\n    /**\n     * Reports whether two vectors are equal.\n     *\n     * @param {Vec4} rhs - The vector to compare to the specified vector.\n     * @returns {boolean} True if the vectors are equal and false otherwise.\n     * @example\n     * var a = new pc.Vec4(1, 2, 3, 4);\n     * var b = new pc.Vec4(5, 6, 7, 8);\n     * console.log("The two vectors are " + (a.equals(b) ? "equal" : "different"));\n     */\n    equals(rhs: Vec4): boolean;\n    /**\n     * Returns the magnitude of the specified 4-dimensional vector.\n     *\n     * @returns {number} The magnitude of the specified 4-dimensional vector.\n     * @example\n     * var vec = new pc.Vec4(3, 4, 0, 0);\n     * var len = vec.length();\n     * // Outputs 5\n     * console.log("The length of the vector is: " + len);\n     */\n    length(): number;\n    /**\n     * Returns the magnitude squared of the specified 4-dimensional vector.\n     *\n     * @returns {number} The magnitude of the specified 4-dimensional vector.\n     * @example\n     * var vec = new pc.Vec4(3, 4, 0);\n     * var len = vec.lengthSq();\n     * // Outputs 25\n     * console.log("The length squared of the vector is: " + len);\n     */\n    lengthSq(): number;\n    /**\n     * Returns the result of a linear interpolation between two specified 4-dimensional vectors.\n     *\n     * @param {Vec4} lhs - The 4-dimensional to interpolate from.\n     * @param {Vec4} rhs - The 4-dimensional to interpolate to.\n     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,\n     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this\n     * range, the linear interpolant will occur on a ray extrapolated from this line.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(0, 0, 0, 0);\n     * var b = new pc.Vec4(10, 10, 10, 10);\n     * var r = new pc.Vec4();\n     *\n     * r.lerp(a, b, 0);   // r is equal to a\n     * r.lerp(a, b, 0.5); // r is 5, 5, 5, 5\n     * r.lerp(a, b, 1);   // r is equal to b\n     */\n    lerp(lhs: Vec4, rhs: Vec4, alpha: number): Vec4;\n    /**\n     * Multiplies a 4-dimensional vector to another in place.\n     *\n     * @param {Vec4} rhs - The 4-dimensional vector used as the second multiplicand of the operation.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(2, 3, 4, 5);\n     * var b = new pc.Vec4(4, 5, 6, 7);\n     *\n     * a.mul(b);\n     *\n     * // Outputs 8, 15, 24, 35\n     * console.log("The result of the multiplication is: " + a.toString());\n     */\n    mul(rhs: Vec4): Vec4;\n    /**\n     * Returns the result of multiplying the specified 4-dimensional vectors together.\n     *\n     * @param {Vec4} lhs - The 4-dimensional vector used as the first multiplicand of the operation.\n     * @param {Vec4} rhs - The 4-dimensional vector used as the second multiplicand of the operation.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(2, 3, 4, 5);\n     * var b = new pc.Vec4(4, 5, 6, 7);\n     * var r = new pc.Vec4();\n     *\n     * r.mul2(a, b);\n     *\n     * // Outputs 8, 15, 24, 35\n     * console.log("The result of the multiplication is: " + r.toString());\n     */\n    mul2(lhs: Vec4, rhs: Vec4): Vec4;\n    /**\n     * Multiplies each element of a vector by a number.\n     *\n     * @param {number} scalar - The number to multiply by.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var vec = new pc.Vec4(3, 6, 9, 12);\n     *\n     * vec.mulScalar(3);\n     *\n     * // Outputs [9, 18, 27, 36]\n     * console.log("The result of the multiplication is: " + vec.toString());\n     */\n    mulScalar(scalar: number): Vec4;\n    /**\n     * Returns this 4-dimensional vector converted to a unit vector in place. If the vector has a\n     * length of zero, the vector\'s elements will be set to zero.\n     *\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var v = new pc.Vec4(25, 0, 0, 0);\n     *\n     * v.normalize();\n     *\n     * // Outputs 1, 0, 0, 0\n     * console.log("The result of the vector normalization is: " + v.toString());\n     */\n    normalize(): Vec4;\n    /**\n     * Each element is set to the largest integer less than or equal to its value.\n     *\n     * @returns {Vec4} Self for chaining.\n     */\n    floor(): Vec4;\n    /**\n     * Each element is rounded up to the next largest integer.\n     *\n     * @returns {Vec4} Self for chaining.\n     */\n    ceil(): Vec4;\n    /**\n     * Each element is rounded up or down to the nearest integer.\n     *\n     * @returns {Vec4} Self for chaining.\n     */\n    round(): Vec4;\n    /**\n     * Each element is assigned a value from rhs parameter if it is smaller.\n     *\n     * @param {Vec4} rhs - The 4-dimensional vector used as the source of elements to compare to.\n     * @returns {Vec4} Self for chaining.\n     */\n    min(rhs: Vec4): Vec4;\n    /**\n     * Each element is assigned a value from rhs parameter if it is larger.\n     *\n     * @param {Vec4} rhs - The 4-dimensional vector used as the source of elements to compare to.\n     * @returns {Vec4} Self for chaining.\n     */\n    max(rhs: Vec4): Vec4;\n    /**\n     * Sets the specified 4-dimensional vector to the supplied numerical values.\n     *\n     * @param {number} x - The value to set on the first component of the vector.\n     * @param {number} y - The value to set on the second component of the vector.\n     * @param {number} z - The value to set on the third component of the vector.\n     * @param {number} w - The value to set on the fourth component of the vector.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var v = new pc.Vec4();\n     * v.set(5, 10, 20, 40);\n     *\n     * // Outputs 5, 10, 20, 40\n     * console.log("The result of the vector set is: " + v.toString());\n     */\n    set(x: number, y: number, z: number, w: number): Vec4;\n    /**\n     * Subtracts a 4-dimensional vector from another in place.\n     *\n     * @param {Vec4} rhs - The vector to add to the specified vector.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(10, 10, 10, 10);\n     * var b = new pc.Vec4(20, 20, 20, 20);\n     *\n     * a.sub(b);\n     *\n     * // Outputs [-10, -10, -10, -10]\n     * console.log("The result of the subtraction is: " + a.toString());\n     */\n    sub(rhs: Vec4): Vec4;\n    /**\n     * Subtracts two 4-dimensional vectors from one another and returns the result.\n     *\n     * @param {Vec4} lhs - The first vector operand for the subtraction.\n     * @param {Vec4} rhs - The second vector operand for the subtraction.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(10, 10, 10, 10);\n     * var b = new pc.Vec4(20, 20, 20, 20);\n     * var r = new pc.Vec4();\n     *\n     * r.sub2(a, b);\n     *\n     * // Outputs [-10, -10, -10, -10]\n     * console.log("The result of the subtraction is: " + r.toString());\n     */\n    sub2(lhs: Vec4, rhs: Vec4): Vec4;\n    /**\n     * Subtracts a number from each element of a vector.\n     *\n     * @param {number} scalar - The number to subtract.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var vec = new pc.Vec4(3, 4, 5, 6);\n     *\n     * vec.subScalar(2);\n     *\n     * // Outputs [1, 2, 3, 4]\n     * console.log("The result of the subtraction is: " + vec.toString());\n     */\n    subScalar(scalar: number): Vec4;\n    /**\n     * Converts the vector to string form.\n     *\n     * @returns {string} The vector in string form.\n     * @example\n     * var v = new pc.Vec4(20, 10, 5, 0);\n     * // Outputs [20, 10, 5, 0]\n     * console.log(v.toString());\n     */\n    toString(): string;\n}\n\n\n/**\n * A 4x4 matrix.\n */\ndeclare class Mat4 {\n    static _getPerspectiveHalfSize(halfSize: any, fov: any, aspect: any, znear: any, fovIsHorizontal: any): void;\n    /**\n     * A constant matrix set to the identity.\n     *\n     * @type {Mat4}\n     * @readonly\n     */\n    static readonly IDENTITY: Mat4;\n    /**\n     * A constant matrix with all elements set to 0.\n     *\n     * @type {Mat4}\n     * @readonly\n     */\n    static readonly ZERO: Mat4;\n    /**\n     * Matrix elements in the form of a flat array.\n     *\n     * @type {Float32Array}\n     */\n    data: Float32Array;\n    /**\n     * Adds the specified 4x4 matrices together and stores the result in the current instance.\n     *\n     * @param {Mat4} lhs - The 4x4 matrix used as the first operand of the addition.\n     * @param {Mat4} rhs - The 4x4 matrix used as the second operand of the addition.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var m = new pc.Mat4();\n     *\n     * m.add2(pc.Mat4.IDENTITY, pc.Mat4.ONE);\n     *\n     * console.log("The result of the addition is: " + m.toString());\n     */\n    add2(lhs: Mat4, rhs: Mat4): Mat4;\n    /**\n     * Adds the specified 4x4 matrix to the current instance.\n     *\n     * @param {Mat4} rhs - The 4x4 matrix used as the second operand of the addition.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var m = new pc.Mat4();\n     *\n     * m.add(pc.Mat4.ONE);\n     *\n     * console.log("The result of the addition is: " + m.toString());\n     */\n    add(rhs: Mat4): Mat4;\n    /**\n     * Creates a duplicate of the specified matrix.\n     *\n     * @returns {Mat4} A duplicate matrix.\n     * @example\n     * var src = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     * var dst = src.clone();\n     * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));\n     */\n    clone(): Mat4;\n    /**\n     * Copies the contents of a source 4x4 matrix to a destination 4x4 matrix.\n     *\n     * @param {Mat4} rhs - A 4x4 matrix to be copied.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var src = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     * var dst = new pc.Mat4();\n     * dst.copy(src);\n     * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));\n     */\n    copy(rhs: Mat4): Mat4;\n    /**\n     * Reports whether two matrices are equal.\n     *\n     * @param {Mat4} rhs - The other matrix.\n     * @returns {boolean} True if the matrices are equal and false otherwise.\n     * @example\n     * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     * var b = new pc.Mat4();\n     * console.log("The two matrices are " + (a.equals(b) ? "equal" : "different"));\n     */\n    equals(rhs: Mat4): boolean;\n    /**\n     * Reports whether the specified matrix is the identity matrix.\n     *\n     * @returns {boolean} True if the matrix is identity and false otherwise.\n     * @example\n     * var m = new pc.Mat4();\n     * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));\n     */\n    isIdentity(): boolean;\n    /**\n     * Multiplies the specified 4x4 matrices together and stores the result in the current\n     * instance.\n     *\n     * @param {Mat4} lhs - The 4x4 matrix used as the first multiplicand of the operation.\n     * @param {Mat4} rhs - The 4x4 matrix used as the second multiplicand of the operation.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     * var b = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);\n     * var r = new pc.Mat4();\n     *\n     * // r = a * b\n     * r.mul2(a, b);\n     *\n     * console.log("The result of the multiplication is: " + r.toString());\n     */\n    mul2(lhs: Mat4, rhs: Mat4): Mat4;\n    /**\n     * Multiplies the specified 4x4 matrices together and stores the result in the current\n     * instance. This function assumes the matrices are affine transformation matrices, where the\n     * upper left 3x3 elements are a rotation matrix, and the bottom left 3 elements are\n     * translation. The rightmost column is assumed to be [0, 0, 0, 1]. The parameters are not\n     * verified to be in the expected format. This function is faster than general\n     * {@link Mat4#mul2}.\n     *\n     * @param {Mat4} lhs - The affine transformation 4x4 matrix used as the first multiplicand of\n     * the operation.\n     * @param {Mat4} rhs - The affine transformation 4x4 matrix used as the second multiplicand of\n     * the operation.\n     * @returns {Mat4} Self for chaining.\n     */\n    mulAffine2(lhs: Mat4, rhs: Mat4): Mat4;\n    /**\n     * Multiplies the current instance by the specified 4x4 matrix.\n     *\n     * @param {Mat4} rhs - The 4x4 matrix used as the second multiplicand of the operation.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     * var b = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);\n     *\n     * // a = a * b\n     * a.mul(b);\n     *\n     * console.log("The result of the multiplication is: " + a.toString());\n     */\n    mul(rhs: Mat4): Mat4;\n    /**\n     * Transforms a 3-dimensional point by a 4x4 matrix.\n     *\n     * @param {Vec3} vec - The 3-dimensional point to be transformed.\n     * @param {Vec3} [res] - An optional 3-dimensional point to receive the result of the\n     * transformation.\n     * @returns {Vec3} The input point v transformed by the current instance.\n     * @example\n     * // Create a 3-dimensional point\n     * var v = new pc.Vec3(1, 2, 3);\n     *\n     * // Create a 4x4 rotation matrix\n     * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     *\n     * var tv = m.transformPoint(v);\n     */\n    transformPoint(vec: Vec3, res?: Vec3): Vec3;\n    /**\n     * Transforms a 3-dimensional vector by a 4x4 matrix.\n     *\n     * @param {Vec3} vec - The 3-dimensional vector to be transformed.\n     * @param {Vec3} [res] - An optional 3-dimensional vector to receive the result of the\n     * transformation.\n     * @returns {Vec3} The input vector v transformed by the current instance.\n     * @example\n     * // Create a 3-dimensional vector\n     * var v = new pc.Vec3(1, 2, 3);\n     *\n     * // Create a 4x4 rotation matrix\n     * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     *\n     * var tv = m.transformVector(v);\n     */\n    transformVector(vec: Vec3, res?: Vec3): Vec3;\n    /**\n     * Transforms a 4-dimensional vector by a 4x4 matrix.\n     *\n     * @param {Vec4} vec - The 4-dimensional vector to be transformed.\n     * @param {Vec4} [res] - An optional 4-dimensional vector to receive the result of the\n     * transformation.\n     * @returns {Vec4} The input vector v transformed by the current instance.\n     * @example\n     * // Create an input 4-dimensional vector\n     * var v = new pc.Vec4(1, 2, 3, 4);\n     *\n     * // Create an output 4-dimensional vector\n     * var result = new pc.Vec4();\n     *\n     * // Create a 4x4 rotation matrix\n     * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     *\n     * m.transformVec4(v, result);\n     */\n    transformVec4(vec: Vec4, res?: Vec4): Vec4;\n    /**\n     * Sets the specified matrix to a viewing matrix derived from an eye point, a target point and\n     * an up vector. The matrix maps the target point to the negative z-axis and the eye point to\n     * the origin, so that when you use a typical projection matrix, the center of the scene maps\n     * to the center of the viewport. Similarly, the direction described by the up vector projected\n     * onto the viewing plane is mapped to the positive y-axis so that it points upward in the\n     * viewport. The up vector must not be parallel to the line of sight from the eye to the\n     * reference point.\n     *\n     * @param {Vec3} position - 3-d vector holding view position.\n     * @param {Vec3} target - 3-d vector holding reference point.\n     * @param {Vec3} up - 3-d vector holding the up direction.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var position = new pc.Vec3(10, 10, 10);\n     * var target = new pc.Vec3(0, 0, 0);\n     * var up = new pc.Vec3(0, 1, 0);\n     * var m = new pc.Mat4().setLookAt(position, target, up);\n     */\n    setLookAt(position: Vec3, target: Vec3, up: Vec3): Mat4;\n    /**\n     * Sets the specified matrix to a perspective projection matrix. The function\'s parameters\n     * define the shape of a frustum.\n     *\n     * @param {number} left - The x-coordinate for the left edge of the camera\'s projection plane\n     * in eye space.\n     * @param {number} right - The x-coordinate for the right edge of the camera\'s projection plane\n     * in eye space.\n     * @param {number} bottom - The y-coordinate for the bottom edge of the camera\'s projection\n     * plane in eye space.\n     * @param {number} top - The y-coordinate for the top edge of the camera\'s projection plane in\n     * eye space.\n     * @param {number} znear - The near clip plane in eye coordinates.\n     * @param {number} zfar - The far clip plane in eye coordinates.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 perspective projection matrix\n     * var f = pc.Mat4().setFrustum(-2, 2, -1, 1, 1, 1000);\n     * @ignore\n     */\n    setFrustum(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Mat4;\n    /**\n     * Sets the specified matrix to a perspective projection matrix. The function\'s parameters\n     * define the shape of a frustum.\n     *\n     * @param {number} fov - The frustum\'s field of view in degrees. The fovIsHorizontal parameter\n     * controls whether this is a vertical or horizontal field of view. By default, it\'s a vertical\n     * field of view.\n     * @param {number} aspect - The aspect ratio of the frustum\'s projection plane\n     * (width / height).\n     * @param {number} znear - The near clip plane in eye coordinates.\n     * @param {number} zfar - The far clip plane in eye coordinates.\n     * @param {boolean} [fovIsHorizontal=false] - Set to true to treat the fov as horizontal\n     * (x-axis) and false for vertical (y-axis). Defaults to false.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 perspective projection matrix\n     * var persp = pc.Mat4().setPerspective(45, 16 / 9, 1, 1000);\n     */\n    setPerspective(fov: number, aspect: number, znear: number, zfar: number, fovIsHorizontal?: boolean): Mat4;\n    /**\n     * Sets the specified matrix to an orthographic projection matrix. The function\'s parameters\n     * define the shape of a cuboid-shaped frustum.\n     *\n     * @param {number} left - The x-coordinate for the left edge of the camera\'s projection plane\n     * in eye space.\n     * @param {number} right - The x-coordinate for the right edge of the camera\'s projection plane\n     * in eye space.\n     * @param {number} bottom - The y-coordinate for the bottom edge of the camera\'s projection\n     * plane in eye space.\n     * @param {number} top - The y-coordinate for the top edge of the camera\'s projection plane in\n     * eye space.\n     * @param {number} near - The near clip plane in eye coordinates.\n     * @param {number} far - The far clip plane in eye coordinates.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 orthographic projection matrix\n     * var ortho = pc.Mat4().ortho(-2, 2, -2, 2, 1, 1000);\n     */\n    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): Mat4;\n    /**\n     * Sets the specified matrix to a rotation matrix equivalent to a rotation around an axis. The\n     * axis must be normalized (unit length) and the angle must be specified in degrees.\n     *\n     * @param {Vec3} axis - The normalized axis vector around which to rotate.\n     * @param {number} angle - The angle of rotation in degrees.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 rotation matrix\n     * var rm = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 90);\n     */\n    setFromAxisAngle(axis: Vec3, angle: number): Mat4;\n    /**\n     * Sets the specified matrix to a translation matrix.\n     *\n     * @param {number} x - The x-component of the translation.\n     * @param {number} y - The y-component of the translation.\n     * @param {number} z - The z-component of the translation.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 translation matrix\n     * var tm = new pc.Mat4().setTranslate(10, 10, 10);\n     * @ignore\n     */\n    setTranslate(x: number, y: number, z: number): Mat4;\n    /**\n     * Sets the specified matrix to a scale matrix.\n     *\n     * @param {number} x - The x-component of the scale.\n     * @param {number} y - The y-component of the scale.\n     * @param {number} z - The z-component of the scale.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 scale matrix\n     * var sm = new pc.Mat4().setScale(10, 10, 10);\n     * @ignore\n     */\n    setScale(x: number, y: number, z: number): Mat4;\n    /**\n     * Sets the specified matrix to a matrix transforming a normalized view volume (in range of\n     * -1 .. 1) to their position inside a viewport (in range of 0 .. 1). This encapsulates a\n     * scaling to the size of the viewport and a translation to the position of the viewport.\n     *\n     * @param {number} x - The x-component of the position of the viewport (in 0..1 range).\n     * @param {number} y - The y-component of the position of the viewport (in 0..1 range).\n     * @param {number} width - The width of the viewport (in 0..1 range).\n     * @param {number} height - The height of the viewport (in 0..1 range).\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 viewport matrix which scales normalized view volume to full texture viewport\n     * var vm = new pc.Mat4().setViewport(0, 0, 1, 1);\n     * @ignore\n     */\n    setViewport(x: number, y: number, width: number, height: number): Mat4;\n    /**\n     * Sets the specified matrix to its inverse.\n     *\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 rotation matrix of 180 degrees around the y-axis\n     * var rot = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);\n     *\n     * // Invert in place\n     * rot.invert();\n     */\n    invert(): Mat4;\n    /**\n     * Sets matrix data from an array.\n     *\n     * @param {number[]} src - Source array. Must have 16 values.\n     * @returns {Mat4} Self for chaining.\n     */\n    set(src: number[]): Mat4;\n    /**\n     * Sets the specified matrix to the identity matrix.\n     *\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * m.setIdentity();\n     * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));\n     */\n    setIdentity(): Mat4;\n    /**\n     * Sets the specified matrix to the concatenation of a translation, a quaternion rotation and a\n     * scale.\n     *\n     * @param {Vec3} t - A 3-d vector translation.\n     * @param {Quat} r - A quaternion rotation.\n     * @param {Vec3} s - A 3-d vector scale.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var t = new pc.Vec3(10, 20, 30);\n     * var r = new pc.Quat();\n     * var s = new pc.Vec3(2, 2, 2);\n     *\n     * var m = new pc.Mat4();\n     * m.setTRS(t, r, s);\n     */\n    setTRS(t: Vec3, r: Quat, s: Vec3): Mat4;\n    /**\n     * Sets the specified matrix to its transpose.\n     *\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var m = new pc.Mat4();\n     *\n     * // Transpose in place\n     * m.transpose();\n     */\n    transpose(): Mat4;\n    invertTo3x3(res: any): Mat4;\n    /**\n     * Extracts the translational component from the specified 4x4 matrix.\n     *\n     * @param {Vec3} [t] - The vector to receive the translation of the matrix.\n     * @returns {Vec3} The translation of the specified 4x4 matrix.\n     * @example\n     * // Create a 4x4 matrix\n     * var m = new pc.Mat4();\n     *\n     * // Query the z-axis component\n     * var t = new pc.Vec3();\n     * m.getTranslation(t);\n     */\n    getTranslation(t?: Vec3): Vec3;\n    /**\n     * Extracts the x-axis from the specified 4x4 matrix.\n     *\n     * @param {Vec3} [x] - The vector to receive the x axis of the matrix.\n     * @returns {Vec3} The x-axis of the specified 4x4 matrix.\n     * @example\n     * // Create a 4x4 matrix\n     * var m = new pc.Mat4();\n     *\n     * // Query the z-axis component\n     * var x = new pc.Vec3();\n     * m.getX(x);\n     */\n    getX(x?: Vec3): Vec3;\n    /**\n     * Extracts the y-axis from the specified 4x4 matrix.\n     *\n     * @param {Vec3} [y] - The vector to receive the y axis of the matrix.\n     * @returns {Vec3} The y-axis of the specified 4x4 matrix.\n     * @example\n     * // Create a 4x4 matrix\n     * var m = new pc.Mat4();\n     *\n     * // Query the z-axis component\n     * var y = new pc.Vec3();\n     * m.getY(y);\n     */\n    getY(y?: Vec3): Vec3;\n    /**\n     * Extracts the z-axis from the specified 4x4 matrix.\n     *\n     * @param {Vec3} [z] - The vector to receive the z axis of the matrix.\n     * @returns {Vec3} The z-axis of the specified 4x4 matrix.\n     * @example\n     * // Create a 4x4 matrix\n     * var m = new pc.Mat4();\n     *\n     * // Query the z-axis component\n     * var z = new pc.Vec3();\n     * m.getZ(z);\n     */\n    getZ(z?: Vec3): Vec3;\n    /**\n     * Extracts the scale component from the specified 4x4 matrix.\n     *\n     * @param {Vec3} [scale] - Vector to receive the scale.\n     * @returns {Vec3} The scale in X, Y and Z of the specified 4x4 matrix.\n     * @example\n     * // Query the scale component\n     * var scale = m.getScale();\n     */\n    getScale(scale?: Vec3): Vec3;\n    /**\n     * Sets the specified matrix to a rotation matrix defined by Euler angles. The Euler angles are\n     * specified in XYZ order and in degrees.\n     *\n     * @param {number} ex - Angle to rotate around X axis in degrees.\n     * @param {number} ey - Angle to rotate around Y axis in degrees.\n     * @param {number} ez - Angle to rotate around Z axis in degrees.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var m = new pc.Mat4();\n     * m.setFromEulerAngles(45, 90, 180);\n     */\n    setFromEulerAngles(ex: number, ey: number, ez: number): Mat4;\n    /**\n     * Extracts the Euler angles equivalent to the rotational portion of the specified matrix. The\n     * returned Euler angles are in XYZ order an in degrees.\n     *\n     * @param {Vec3} [eulers] - A 3-d vector to receive the Euler angles.\n     * @returns {Vec3} A 3-d vector containing the Euler angles.\n     * @example\n     * // Create a 4x4 rotation matrix of 45 degrees around the y-axis\n     * var m = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 45);\n     *\n     * var eulers = m.getEulerAngles();\n     */\n    getEulerAngles(eulers?: Vec3): Vec3;\n    /**\n     * Converts the specified matrix to string form.\n     *\n     * @returns {string} The matrix in string form.\n     * @example\n     * var m = new pc.Mat4();\n     * // Outputs [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]\n     * console.log(m.toString());\n     */\n    toString(): string;\n}\n\n\n\n\n/**\n * Axis-Aligned Bounding Box.\n */\ndeclare class BoundingBox {\n    /**\n     * Create a new BoundingBox instance. The bounding box is axis-aligned.\n     *\n     * @param {Vec3} [center] - Center of box. The constructor takes a reference of this parameter.\n     * @param {Vec3} [halfExtents] - Half the distance across the box in each axis. The constructor\n     * takes a reference of this parameter. Defaults to 0.5 on each axis.\n     */\n    constructor(center?: Vec3, halfExtents?: Vec3);\n    /**\n     * Center of box.\n     *\n     * @type {Vec3}\n     */\n    center: Vec3;\n    /**\n     * Half the distance across the box in each axis.\n     *\n     * @type {Vec3}\n     */\n    halfExtents: Vec3;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private _min;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private _max;\n    /**\n     * Combines two bounding boxes into one, enclosing both.\n     *\n     * @param {BoundingBox} other - Bounding box to add.\n     */\n    add(other: BoundingBox): void;\n    /**\n     * Copies the contents of a source AABB.\n     *\n     * @param {BoundingBox} src - The AABB to copy from.\n     */\n    copy(src: BoundingBox): void;\n    /**\n     * Returns a clone of the AABB.\n     *\n     * @returns {BoundingBox} A duplicate AABB.\n     */\n    clone(): BoundingBox;\n    /**\n     * Test whether two axis-aligned bounding boxes intersect.\n     *\n     * @param {BoundingBox} other - Bounding box to test against.\n     * @returns {boolean} True if there is an intersection.\n     */\n    intersects(other: BoundingBox): boolean;\n    _intersectsRay(ray: any, point: any): boolean;\n    _fastIntersectsRay(ray: any): boolean;\n    /**\n     * Test if a ray intersects with the AABB.\n     *\n     * @param {Ray} ray - Ray to test against (direction must be normalized).\n     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied into here.\n     * @returns {boolean} True if there is an intersection.\n     */\n    intersectsRay(ray: Ray, point?: Vec3): boolean;\n    /**\n     * Sets the minimum and maximum corner of the AABB. Using this function is faster than\n     * assigning min and max separately.\n     *\n     * @param {Vec3} min - The minimum corner of the AABB.\n     * @param {Vec3} max - The maximum corner of the AABB.\n     */\n    setMinMax(min: Vec3, max: Vec3): void;\n    /**\n     * Return the minimum corner of the AABB.\n     *\n     * @returns {Vec3} Minimum corner.\n     */\n    getMin(): Vec3;\n    /**\n     * Return the maximum corner of the AABB.\n     *\n     * @returns {Vec3} Maximum corner.\n     */\n    getMax(): Vec3;\n    /**\n     * Test if a point is inside a AABB.\n     *\n     * @param {Vec3} point - Point to test.\n     * @returns {boolean} True if the point is inside the AABB and false otherwise.\n     */\n    containsPoint(point: Vec3): boolean;\n    /**\n     * Set an AABB to enclose the specified AABB if it were to be transformed by the specified 4x4\n     * matrix.\n     *\n     * @param {BoundingBox} aabb - Box to transform and enclose.\n     * @param {Mat4} m - Transformation matrix to apply to source AABB.\n     * @param {boolean} ignoreScale - If true is specified, a scale from the matrix is ignored. Defaults to false.\n     */\n    setFromTransformedAabb(aabb: BoundingBox, m: Mat4, ignoreScale?: boolean): void;\n    /**\n     * Compute the size of the AABB to encapsulate all specified vertices.\n     *\n     * @param {number[]|Float32Array} vertices - The vertices used to compute the new size for the\n     * AABB.\n     * @param {number} [numVerts] - Number of vertices to use from the beginning of vertices array.\n     * All vertices are used if not specified.\n     */\n    compute(vertices: number[] | Float32Array, numVerts?: number): void;\n    /**\n     * Test if a Bounding Sphere is overlapping, enveloping, or inside this AABB.\n     *\n     * @param {BoundingSphere} sphere - Bounding Sphere to test.\n     * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping, or inside the\n     * AABB and false otherwise.\n     */\n    intersectsBoundingSphere(sphere: BoundingSphere): boolean;\n    _distanceToBoundingSphereSq(sphere: any): number;\n    _expand(expandMin: any, expandMax: any): void;\n}\n\n\n/**\n * An infinite plane.\n *\n * @ignore\n */\ndeclare class Plane {\n    /**\n     * Create a new Plane instance.\n     *\n     * @param {Vec3} [point] - Point position on the plane. The constructor takes a reference of\n     * this parameter.\n     * @param {Vec3} [normal] - Normal of the plane. The constructor takes a reference of this\n     * parameter.\n     */\n    constructor(point?: Vec3, normal?: Vec3);\n    normal: Vec3;\n    point: Vec3;\n    /**\n     * Test if the plane intersects between two points.\n     *\n     * @param {Vec3} start - Start position of line.\n     * @param {Vec3} end - End position of line.\n     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied\n     * into here.\n     * @returns {boolean} True if there is an intersection.\n     */\n    intersectsLine(start: Vec3, end: Vec3, point?: Vec3): boolean;\n    /**\n     * Test if a ray intersects with the infinite plane.\n     *\n     * @param {Ray} ray - Ray to test against (direction must be normalized).\n     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied\n     * into here.\n     * @returns {boolean} True if there is an intersection.\n     */\n    intersectsRay(ray: Ray, point?: Vec3): boolean;\n}\n\n\n/** @typedef {import(\'./graphics-device.js\').GraphicsDevice} GraphicsDevice */\n/**\n * A shader is a program that is responsible for rendering graphical primitives on a device\'s\n * graphics processor. The shader is generated from a shader definition. This shader definition\n * specifies the code for processing vertices and fragments processed by the GPU. The language of\n * the code is GLSL (or more specifically ESSL, the OpenGL ES Shading Language). The shader\n * definition also describes how the PlayCanvas engine should map vertex buffer elements onto the\n * attributes specified in the vertex shader code.\n */\ndeclare class Shader {\n    /**\n     * Creates a new Shader instance.\n     *\n     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this shader.\n     * @param {object} definition - The shader definition from which to build the shader.\n     * @param {Object.<string, string>} definition.attributes - Object detailing the mapping of\n     * vertex shader attribute names to semantics SEMANTIC_*. This enables the engine to match\n     * vertex buffer data as inputs to the shader.\n     * @param {string} definition.vshader - Vertex shader source (GLSL code).\n     * @param {string} definition.fshader - Fragment shader source (GLSL code).\n     * @param {boolean} [definition.useTransformFeedback] - Specifies that this shader outputs\n     * post-VS data to a buffer.\n     * @example\n     * // Create a shader that renders primitives with a solid red color\n     * var shaderDefinition = {\n     *     attributes: {\n     *         aPosition: pc.SEMANTIC_POSITION\n     *     },\n     *     vshader: [\n     *         "attribute vec3 aPosition;",\n     *         "",\n     *         "void main(void)",\n     *         "{",\n     *         "    gl_Position = vec4(aPosition, 1.0);",\n     *         "}"\n     *     ].join("\\n"),\n     *     fshader: [\n     *         "precision " + graphicsDevice.precision + " float;",\n     *         "",\n     *         "void main(void)",\n     *         "{",\n     *         "    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);",\n     *         "}"\n     *     ].join("\\n")\n     * };\n     *\n     * var shader = new pc.Shader(graphicsDevice, shaderDefinition);\n     */\n    constructor(graphicsDevice: GraphicsDevice, definition: {\n        attributes: {\n            [x: string]: string;\n        };\n        vshader: string;\n        fshader: string;\n        useTransformFeedback?: boolean;\n    });\n    device: GraphicsDevice;\n    definition: {\n        attributes: {\n            [x: string]: string;\n        };\n        vshader: string;\n        fshader: string;\n        useTransformFeedback?: boolean;\n    };\n    impl: any;\n    /**\n     * Initialize a shader back to its default state.\n     *\n     * @private\n     */\n    private init;\n    ready: boolean;\n    failed: boolean;\n    /**\n     * Frees resources associated with this shader.\n     */\n    destroy(): void;\n    /**\n     * Called when the WebGL context was lost. It releases all context related resources.\n     *\n     * @ignore\n     */\n    loseContext(): void;\n    restoreContext(): void;\n}\n\n\n/**\n * A render target is a rectangular rendering surface.\n */\ndeclare class RenderTarget {\n    /**\n     * Creates a new RenderTarget instance. A color buffer or a depth buffer must be set.\n     *\n     * @param {object} options - Object for passing optional arguments.\n     * @param {boolean} [options.autoResolve] - If samples > 1, enables or disables automatic MSAA\n     * resolve after rendering to this RT (see {@link RenderTarget#resolve}). Defaults to true.\n     * @param {Texture} [options.colorBuffer] - The texture that this render target will treat as a\n     * rendering surface.\n     * @param {boolean} [options.depth] - If set to true, depth buffer will be created. Defaults to\n     * true. Ignored if depthBuffer is defined.\n     * @param {Texture} [options.depthBuffer] - The texture that this render target will treat as a\n     * depth/stencil surface (WebGL2 only). If set, the \'depth\' and \'stencil\' properties are\n     * ignored. Texture must have {@link PIXELFORMAT_DEPTH} or {@link PIXELFORMAT_DEPTHSTENCIL}\n     * format.\n     * @param {number} [options.face] - If the colorBuffer parameter is a cubemap, use this option\n     * to specify the face of the cubemap to render to. Can be:\n     *\n     * - {@link CUBEFACE_POSX}\n     * - {@link CUBEFACE_NEGX}\n     * - {@link CUBEFACE_POSY}\n     * - {@link CUBEFACE_NEGY}\n     * - {@link CUBEFACE_POSZ}\n     * - {@link CUBEFACE_NEGZ}\n     *\n     * Defaults to {@link CUBEFACE_POSX}.\n     * @param {boolean} [options.flipY] - When set to true the image will be flipped in Y. Default\n     * is false.\n     * @param {string} [options.name] - The name of the render target.\n     * @param {number} [options.samples] - Number of hardware anti-aliasing samples (WebGL2 only).\n     * Default is 1.\n     * @param {boolean} [options.stencil] - If set to true, depth buffer will include stencil.\n     * Defaults to false. Ignored if depthBuffer is defined or depth is false.\n     * @example\n     * // Create a 512x512x24-bit render target with a depth buffer\n     * var colorBuffer = new pc.Texture(graphicsDevice, {\n     *     width: 512,\n     *     height: 512,\n     *     format: pc.PIXELFORMAT_R8_G8_B8\n     * });\n     * var renderTarget = new pc.RenderTarget({\n     *     colorBuffer: colorBuffer,\n     *     depth: true\n     * });\n     *\n     * // Set the render target on a camera component\n     * camera.renderTarget = renderTarget;\n     *\n     * // Destroy render target at a later stage. Note that the color buffer needs\n     * // to be destroyed separately.\n     * renderTarget.colorBuffer.destroy();\n     * renderTarget.destroy();\n     * camera.renderTarget = null;\n     */\n    constructor(options: {\n        autoResolve?: boolean;\n        colorBuffer?: Texture;\n        depth?: boolean;\n        depthBuffer?: Texture;\n        face?: number;\n        flipY?: boolean;\n        name?: string;\n        samples?: number;\n        stencil?: boolean;\n    }, ...args: any[]);\n    _colorBuffer: any;\n    _depthBuffer: Texture;\n    _face: number;\n    _depth: boolean;\n    _stencil: boolean;\n    _device: any;\n    _samples: number;\n    autoResolve: boolean;\n    name: any;\n    flipY: boolean;\n    impl: any;\n    /**\n     * Frees resources associated with this render target.\n     */\n    destroy(): void;\n    /**\n     * Free device resources associated with this render target.\n     *\n     * @ignore\n     */\n    destroyFrameBuffers(): void;\n    /**\n     * Free textures associated with this render target.\n     *\n     * @ignore\n     */\n    destroyTextureBuffers(): void;\n    /**\n     * Initialises the resources associated with this render target.\n     *\n     * @ignore\n     */\n    init(): void;\n    /**\n     * Called when the device context was lost. It releases all context related resources.\n     *\n     * @ignore\n     */\n    loseContext(): void;\n    /**\n     * If samples > 1, resolves the anti-aliased render target (WebGL2 only). When you\'re rendering\n     * to an anti-aliased render target, pixels aren\'t written directly to the readable texture.\n     * Instead, they\'re first written to a MSAA buffer, where each sample for each pixel is stored\n     * independently. In order to read the results, you first need to \'resolve\' the buffer - to\n     * average all samples and create a simple texture with one color per pixel. This function\n     * performs this averaging and updates the colorBuffer and the depthBuffer. If autoResolve is\n     * set to true, the resolve will happen after every rendering to this render target, otherwise\n     * you can do it manually, during the app update or inside a {@link Command}.\n     *\n     * @param {boolean} [color] - Resolve color buffer. Defaults to true.\n     * @param {boolean} [depth] - Resolve depth buffer. Defaults to true if the render target has a\n     * depth buffer.\n     */\n    resolve(color?: boolean, depth?: boolean): void;\n    /**\n     * Copies color and/or depth contents of source render target to this one. Formats, sizes and\n     * anti-aliasing samples must match. Depth buffer can only be copied on WebGL 2.0.\n     *\n     * @param {RenderTarget} source - Source render target to copy from.\n     * @param {boolean} [color] - If true will copy the color buffer. Defaults to false.\n     * @param {boolean} [depth] - If true will copy the depth buffer. Defaults to false.\n     * @returns {boolean} True if the copy was successful, false otherwise.\n     */\n    copy(source: RenderTarget, color?: boolean, depth?: boolean): boolean;\n    /**\n     * Color buffer set up on the render target.\n     *\n     * @type {Texture}\n     */\n    get colorBuffer(): Texture;\n    /**\n     * Depth buffer set up on the render target. Only available, if depthBuffer was set in\n     * constructor. Not available if depth property was used instead.\n     *\n     * @type {Texture}\n     */\n    get depthBuffer(): Texture;\n    /**\n     * If the render target is bound to a cubemap, this property specifies which face of the\n     * cubemap is rendered to. Can be:\n     *\n     * - {@link CUBEFACE_POSX}\n     * - {@link CUBEFACE_NEGX}\n     * - {@link CUBEFACE_POSY}\n     * - {@link CUBEFACE_NEGY}\n     * - {@link CUBEFACE_POSZ}\n     * - {@link CUBEFACE_NEGZ}\n     *\n     * @type {number}\n     */\n    get face(): number;\n    /**\n     * Width of the render target in pixels.\n     *\n     * @type {number}\n     */\n    get width(): number;\n    /**\n     * Height of the render target in pixels.\n     *\n     * @type {number}\n     */\n    get height(): number;\n}\n\ndeclare class Version {\n    globalId: number;\n    revision: number;\n    equals(other: any): boolean;\n    copy(other: any): void;\n    reset(): void;\n}\n\ndeclare class VersionedObject {\n    version: Version;\n    increment(): void;\n}\n\n/**\n * The scope for a variable.\n */\ndeclare class ScopeId {\n    /**\n     * Create a new ScopeId instance.\n     *\n     * @param {string} name - The variable name.\n     */\n    constructor(name: string);\n    /**\n     * The variable name.\n     *\n     * @type {string}\n     */\n    name: string;\n    value: any;\n    versionObject: VersionedObject;\n    /**\n     * Set variable value.\n     *\n     * @param {*} value - The value.\n     */\n    setValue(value: any): void;\n    /**\n     * Get variable value.\n     *\n     * @returns {*} The value.\n     */\n    getValue(): any;\n}\n\n/**\n * The scope for variables.\n */\ndeclare class ScopeSpace {\n    /**\n     * Create a new ScopeSpace instance.\n     *\n     * @param {string} name - The scope name.\n     */\n    constructor(name: string);\n    /**\n     * The scope name.\n     *\n     * @type {string}\n     */\n    name: string;\n    variables: Map<any, any>;\n    /**\n     * Get (or create, if it doesn\'t already exist) a variable in the scope.\n     *\n     * @param {string} name - The variable name.\n     * @returns {ScopeId} The variable instance.\n     */\n    resolve(name: string): ScopeId;\n    /**\n     * Clears value for any uniform with matching value (used to remove deleted textures).\n     *\n     * @param {*} value - The value to clear.\n     * @ignore\n     */\n    removeValue(value: any): void;\n}\n\ndeclare class ProgramLibrary {\n    constructor(device: any);\n    _device: any;\n    _cache: {};\n    _generators: {};\n    _isClearingCache: boolean;\n    _precached: boolean;\n    _programsCollection: any[];\n    _defaultStdMatOption: {};\n    _defaultStdMatOptionMin: {};\n    register(name: any, generator: any): void;\n    unregister(name: any): void;\n    isRegistered(name: any): boolean;\n    getProgram(name: any, options: any): any;\n    storeNewProgram(name: any, options: any): void;\n    dumpPrograms(): void;\n    clearCache(): void;\n    removeFromCache(shader: any): void;\n    _getDefaultStdMatOptions(pass: any): {};\n    precompile(cache: any): void;\n}\n\n\n\n\n/** @typedef {import(\'./render-target.js\').RenderTarget} RenderTarget */\n/** @typedef {import(\'./shader.js\').Shader} Shader */\n/** @typedef {import(\'./texture.js\').Texture} Texture */\n/**\n * The graphics device manages the underlying graphics context. It is responsible for submitting\n * render state changes and graphics primitives to the hardware. A graphics device is tied to a\n * specific canvas HTML element. It is valid to have more than one canvas element per page and\n * create a new graphics device against each.\n *\n * @augments EventHandler\n */\ndeclare class GraphicsDevice extends EventHandler {\n    constructor(canvas: any);\n    /**\n     * The canvas DOM element that provides the underlying WebGL context used by the graphics device.\n     *\n     * @type {HTMLCanvasElement}\n     */\n    canvas: HTMLCanvasElement;\n    /**\n     * The scope namespace for shader attributes and variables.\n     *\n     * @type {ScopeSpace}\n     */\n    scope: ScopeSpace;\n    /**\n     * The maximum supported texture anisotropy setting.\n     *\n     * @type {number}\n     */\n    maxAnisotropy: number;\n    /**\n     * The maximum supported dimension of a cube map.\n     *\n     * @type {number}\n     */\n    maxCubeMapSize: number;\n    /**\n     * The maximum supported dimension of a texture.\n     *\n     * @type {number}\n     */\n    maxTextureSize: number;\n    /**\n     * The maximum supported dimension of a 3D texture (any axis).\n     *\n     * @type {number}\n     */\n    maxVolumeSize: number;\n    /**\n     * The highest shader precision supported by this graphics device. Can be \'hiphp\', \'mediump\' or\n     * \'lowp\'.\n     *\n     * @type {string}\n     */\n    precision: string;\n    /**\n     * True if hardware instancing is supported.\n     *\n     * @type {boolean}\n     */\n    supportsInstancing: boolean;\n    /**\n     * True if 32-bit floating-point textures can be used as a frame buffer.\n     *\n     * @type {boolean}\n     */\n    textureFloatRenderable: boolean;\n    /**\n     * True if 16-bit floating-point textures can be used as a frame buffer.\n     *\n     * @type {boolean}\n     */\n    textureHalfFloatRenderable: boolean;\n    _width: number;\n    _height: number;\n    _maxPixelRatio: number;\n    /** @type {Shader[]} */\n    shaders: Shader[];\n    buffers: any[];\n    /** @type {Texture[]} */\n    textures: Texture[];\n    /** @type {RenderTarget[]} */\n    targets: RenderTarget[];\n    _vram: {\n        texShadow: number;\n        texAsset: number;\n        texLightmap: number;\n        tex: number;\n        vb: number;\n        ib: number;\n    };\n    _shaderStats: {\n        vsCompiled: number;\n        fsCompiled: number;\n        linked: number;\n        materialShaders: number;\n        compileTime: number;\n    };\n    _drawCallsPerFrame: number;\n    _shaderSwitchesPerFrame: number;\n    _primsPerFrame: number[];\n    _renderTargetCreationTime: number;\n    programLib: ProgramLibrary;\n    destroy(): void;\n    postDestroy(): void;\n    toJSON(key: any): any;\n    initializeContextCaches(): void;\n    indexBuffer: any;\n    vertexBuffers: any[];\n    shader: any;\n    renderTarget: RenderTarget;\n    /**\n     * Retrieves the program library assigned to the specified graphics device.\n     *\n     * @returns {ProgramLibrary} The program library assigned to the device.\n     * @ignore\n     */\n    getProgramLibrary(): ProgramLibrary;\n    /**\n     * Assigns a program library to the specified device. By default, a graphics device is created\n     * with a program library that manages all of the programs that are used to render any\n     * graphical primitives. However, this function allows the user to replace the existing program\n     * library with a new one.\n     *\n     * @param {ProgramLibrary} programLib - The program library to assign to the device.\n     * @ignore\n     */\n    setProgramLibrary(programLib: ProgramLibrary): void;\n    /**\n     * Sets the specified render target on the device. If null is passed as a parameter, the back\n     * buffer becomes the current target for all rendering operations.\n     *\n     * @param {RenderTarget} renderTarget - The render target to activate.\n     * @example\n     * // Set a render target to receive all rendering output\n     * device.setRenderTarget(renderTarget);\n     *\n     * // Set the back buffer to receive all rendering output\n     * device.setRenderTarget(null);\n     */\n    setRenderTarget(renderTarget: RenderTarget): void;\n    /**\n     * Queries the currently set render target on the device.\n     *\n     * @returns {RenderTarget} The current render target.\n     * @example\n     * // Get the current render target\n     * var renderTarget = device.getRenderTarget();\n     */\n    getRenderTarget(): RenderTarget;\n    /**\n     * Reports whether a texture source is a canvas, image, video or ImageBitmap.\n     *\n     * @param {*} texture - Texture source data.\n     * @returns {boolean} True if the texture is a canvas, image, video or ImageBitmap and false\n     * otherwise.\n     * @ignore\n     */\n    _isBrowserInterface(texture: any): boolean;\n    /**\n     * Sets the width and height of the canvas, then fires the `resizecanvas` event. Note that the\n     * specified width and height values will be multiplied by the value of\n     * {@link GraphicsDevice#maxPixelRatio} to give the final resultant width and height for the\n     * canvas.\n     *\n     * @param {number} width - The new width of the canvas.\n     * @param {number} height - The new height of the canvas.\n     * @ignore\n     */\n    resizeCanvas(width: number, height: number): void;\n    /**\n     * Sets the width and height of the canvas, then fires the `resizecanvas` event. Note that the\n     * value of {@link GraphicsDevice#maxPixelRatio} is ignored.\n     *\n     * @param {number} width - The new width of the canvas.\n     * @param {number} height - The new height of the canvas.\n     * @ignore\n     */\n    setResolution(width: number, height: number): void;\n    updateClientRect(): void;\n    clientRect: DOMRect;\n    /**\n     * Width of the back buffer in pixels.\n     *\n     * @type {number}\n     */\n    get width(): number;\n    /**\n     * Height of the back buffer in pixels.\n     *\n     * @type {number}\n     */\n    get height(): number;\n    /**\n     * Fullscreen mode.\n     *\n     * @type {boolean}\n     */\n    set fullscreen(arg: boolean);\n    get fullscreen(): boolean;\n    /**\n     * Maximum pixel ratio.\n     *\n     * @type {number}\n     */\n    set maxPixelRatio(arg: number);\n    get maxPixelRatio(): number;\n}\n\n\n/**\n * A texture is a container for texel data that can be utilized in a fragment shader. Typically,\n * the texel data represents an image that is mapped over geometry.\n */\ndeclare class Texture {\n    /**\n     * Calculate the GPU memory required for a texture.\n     *\n     * @param {number} width - Texture\'s width.\n     * @param {number} height - Texture\'s height.\n     * @param {number} depth - Texture\'s depth.\n     * @param {number} format - Texture\'s pixel format PIXELFORMAT_***.\n     * @param {boolean} mipmaps - True if the texture includes mipmaps, false otherwise.\n     * @param {boolean} cubemap - True is the texture is a cubemap, false otherwise.\n     * @returns {number} The number of bytes of GPU memory required for the texture.\n     * @ignore\n     */\n    static calcGpuSize(width: number, height: number, depth: number, format: number, mipmaps: boolean, cubemap: boolean): number;\n    /**\n     * Create a new Texture instance.\n     *\n     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this texture.\n     * @param {object} [options] - Object for passing optional arguments.\n     * @param {string} [options.name] - The name of the texture.\n     * @param {number} [options.width] - The width of the texture in pixels. Defaults to 4.\n     * @param {number} [options.height] - The height of the texture in pixels. Defaults to 4.\n     * @param {number} [options.depth] - The number of depth slices in a 3D texture (WebGL2 only).\n     * Defaults to 1 (single 2D image).\n     * @param {number} [options.format] - The pixel format of the texture. Can be:\n     *\n     * - {@link PIXELFORMAT_A8}\n     * - {@link PIXELFORMAT_L8}\n     * - {@link PIXELFORMAT_L8_A8}\n     * - {@link PIXELFORMAT_R5_G6_B5}\n     * - {@link PIXELFORMAT_R5_G5_B5_A1}\n     * - {@link PIXELFORMAT_R4_G4_B4_A4}\n     * - {@link PIXELFORMAT_R8_G8_B8}\n     * - {@link PIXELFORMAT_R8_G8_B8_A8}\n     * - {@link PIXELFORMAT_DXT1}\n     * - {@link PIXELFORMAT_DXT3}\n     * - {@link PIXELFORMAT_DXT5}\n     * - {@link PIXELFORMAT_RGB16F}\n     * - {@link PIXELFORMAT_RGBA16F}\n     * - {@link PIXELFORMAT_RGB32F}\n     * - {@link PIXELFORMAT_RGBA32F}\n     * - {@link PIXELFORMAT_ETC1}\n     * - {@link PIXELFORMAT_PVRTC_2BPP_RGB_1}\n     * - {@link PIXELFORMAT_PVRTC_2BPP_RGBA_1}\n     * - {@link PIXELFORMAT_PVRTC_4BPP_RGB_1}\n     * - {@link PIXELFORMAT_PVRTC_4BPP_RGBA_1}\n     * - {@link PIXELFORMAT_111110F}\n     * - {@link PIXELFORMAT_ASTC_4x4}>/li>\n     * - {@link PIXELFORMAT_ATC_RGB}\n     * - {@link PIXELFORMAT_ATC_RGBA}\n     *\n     * Defaults to {@link PIXELFORMAT_R8_G8_B8_A8}.\n     * @param {string} [options.projection] - The projection type of the texture, used when the\n     * texture represents an environment. Can be:\n     *\n     * - {@link TEXTUREPROJECTION_NONE}\n     * - {@link TEXTUREPROJECTION_CUBE}\n     * - {@link TEXTUREPROJECTION_EQUIRECT}\n     * - {@link TEXTUREPROJECTION_OCTAHEDRAL}\n     *\n     * Defaults to {@link TEXTUREPROJECTION_CUBE} if options.cubemap is specified, otherwise\n     * {@link TEXTUREPROJECTION_NONE}.\n     * @param {number} [options.minFilter] - The minification filter type to use. Defaults to\n     * {@link FILTER_LINEAR_MIPMAP_LINEAR}.\n     * @param {number} [options.magFilter] - The magnification filter type to use. Defaults to\n     * {@link FILTER_LINEAR}.\n     * @param {number} [options.anisotropy] - The level of anisotropic filtering to use. Defaults\n     * to 1.\n     * @param {number} [options.addressU] - The repeat mode to use in the U direction. Defaults to\n     * {@link ADDRESS_REPEAT}.\n     * @param {number} [options.addressV] - The repeat mode to use in the V direction. Defaults to\n     * {@link ADDRESS_REPEAT}.\n     * @param {number} [options.addressW] - The repeat mode to use in the W direction. Defaults to\n     * {@link ADDRESS_REPEAT}.\n     * @param {boolean} [options.mipmaps] - When enabled try to generate or use mipmaps for this\n     * texture. Default is true.\n     * @param {boolean} [options.cubemap] - Specifies whether the texture is to be a cubemap.\n     * Defaults to false.\n     * @param {boolean} [options.volume] - Specifies whether the texture is to be a 3D volume\n     * (WebGL2 only). Defaults to false.\n     * @param {string} [options.type] - Specifies the image type, see {@link TEXTURETYPE_DEFAULT}.\n     * @param {boolean} [options.fixCubemapSeams] - Specifies whether this cubemap texture requires\n     * special seam fixing shader code to look right. Defaults to false.\n     * @param {boolean} [options.flipY] - Specifies whether the texture should be flipped in the\n     * Y-direction. Only affects textures with a source that is an image, canvas or video element.\n     * Does not affect cubemaps, compressed textures or textures set from raw pixel data. Defaults\n     * to false.\n     * @param {boolean} [options.premultiplyAlpha] - If true, the alpha channel of the texture (if\n     * present) is multiplied into the color channels. Defaults to false.\n     * @param {boolean} [options.compareOnRead] - When enabled, and if texture format is\n     * {@link PIXELFORMAT_DEPTH} or {@link PIXELFORMAT_DEPTHSTENCIL}, hardware PCF is enabled for\n     * this texture, and you can get filtered results of comparison using texture() in your shader\n     * (WebGL2 only). Defaults to false.\n     * @param {number} [options.compareFunc] - Comparison function when compareOnRead is enabled\n     * (WebGL2 only). Can be:\n     *\n     * - {@link FUNC_LESS}\n     * - {@link FUNC_LESSEQUAL}\n     * - {@link FUNC_GREATER}\n     * - {@link FUNC_GREATEREQUAL}\n     * - {@link FUNC_EQUAL}\n     * - {@link FUNC_NOTEQUAL}\n     *\n     * Defaults to {@link FUNC_LESS}.\n     * @example\n     * // Create a 8x8x24-bit texture\n     * var texture = new pc.Texture(graphicsDevice, {\n     *     width: 8,\n     *     height: 8,\n     *     format: pc.PIXELFORMAT_R8_G8_B8\n     * });\n     *\n     * // Fill the texture with a gradient\n     * var pixels = texture.lock();\n     * var count = 0;\n     * for (var i = 0; i < 8; i++) {\n     *     for (var j = 0; j < 8; j++) {\n     *         pixels[count++] = i * 32;\n     *         pixels[count++] = j * 32;\n     *         pixels[count++] = 255;\n     *     }\n     * }\n     * texture.unlock();\n     */\n    constructor(graphicsDevice: GraphicsDevice, options?: {\n        name?: string;\n        width?: number;\n        height?: number;\n        depth?: number;\n        format?: number;\n        projection?: string;\n        minFilter?: number;\n        magFilter?: number;\n        anisotropy?: number;\n        addressU?: number;\n        addressV?: number;\n        addressW?: number;\n        mipmaps?: boolean;\n        cubemap?: boolean;\n        volume?: boolean;\n        type?: string;\n        fixCubemapSeams?: boolean;\n        flipY?: boolean;\n        premultiplyAlpha?: boolean;\n        compareOnRead?: boolean;\n        compareFunc?: number;\n    });\n    device: GraphicsDevice;\n    /**\n     * The name of the texture. Defaults to null.\n     *\n     * @type {string}\n     */\n    name: string;\n    _width: number;\n    _height: number;\n    _depth: number;\n    _format: number;\n    type: string;\n    projection: string;\n    _cubemap: boolean;\n    _volume: boolean;\n    fixCubemapSeams: boolean;\n    _flipY: boolean;\n    _premultiplyAlpha: boolean;\n    _isRenderTarget: boolean;\n    _mipmaps: any;\n    _minFilter: number;\n    _magFilter: number;\n    _anisotropy: number;\n    _addressU: number;\n    _addressV: number;\n    _addressW: number;\n    _compareOnRead: boolean;\n    _compareFunc: any;\n    profilerHint: any;\n    _levels: any;\n    _compressed: boolean;\n    _invalid: boolean;\n    _lockedLevel: number;\n    _gpuSize: number;\n    impl: any;\n    /**\n     * Frees resources associated with this texture.\n     */\n    destroy(): void;\n    /**\n     * Called when the rendering context was lost. It releases all context related resources.\n     *\n     * @ignore\n     */\n    loseContext(): void;\n    /**\n     * Updates vram size tracking for the texture, size can be positive to add or negative to subtract\n     *\n     * @ignore\n     */\n    adjustVramSizeTracking(vram: any, size: any): void;\n    /**\n     * The minification filter to be applied to the texture. Can be:\n     *\n     * - {@link FILTER_NEAREST}\n     * - {@link FILTER_LINEAR}\n     * - {@link FILTER_NEAREST_MIPMAP_NEAREST}\n     * - {@link FILTER_NEAREST_MIPMAP_LINEAR}\n     * - {@link FILTER_LINEAR_MIPMAP_NEAREST}\n     * - {@link FILTER_LINEAR_MIPMAP_LINEAR}\n     *\n     * @type {number}\n     */\n    set minFilter(arg: number);\n    get minFilter(): number;\n    /**\n     * The magnification filter to be applied to the texture. Can be:\n     *\n     * - {@link FILTER_NEAREST}\n     * - {@link FILTER_LINEAR}\n     *\n     * @type {number}\n     */\n    set magFilter(arg: number);\n    get magFilter(): number;\n    /**\n     * The addressing mode to be applied to the texture horizontally. Can be:\n     *\n     * - {@link ADDRESS_REPEAT}\n     * - {@link ADDRESS_CLAMP_TO_EDGE}\n     * - {@link ADDRESS_MIRRORED_REPEAT}\n     *\n     * @type {number}\n     */\n    set addressU(arg: number);\n    get addressU(): number;\n    /**\n     * The addressing mode to be applied to the texture vertically. Can be:\n     *\n     * - {@link ADDRESS_REPEAT}\n     * - {@link ADDRESS_CLAMP_TO_EDGE}\n     * - {@link ADDRESS_MIRRORED_REPEAT}\n     *\n     * @type {number}\n     */\n    set addressV(arg: number);\n    get addressV(): number;\n    /**\n     * The addressing mode to be applied to the 3D texture depth (WebGL2 only). Can be:\n     *\n     * - {@link ADDRESS_REPEAT}\n     * - {@link ADDRESS_CLAMP_TO_EDGE}\n     * - {@link ADDRESS_MIRRORED_REPEAT}\n     *\n     * @type {number}\n     */\n    set addressW(arg: number);\n    get addressW(): number;\n    /**\n     * When enabled, and if texture format is {@link PIXELFORMAT_DEPTH} or\n     * {@link PIXELFORMAT_DEPTHSTENCIL}, hardware PCF is enabled for this texture, and you can get\n     * filtered results of comparison using texture() in your shader (WebGL2 only).\n     *\n     * @type {boolean}\n     */\n    set compareOnRead(arg: boolean);\n    get compareOnRead(): boolean;\n    /**\n     * Comparison function when compareOnRead is enabled (WebGL2 only). Possible values:\n     *\n     * - {@link FUNC_LESS}\n     * - {@link FUNC_LESSEQUAL}\n     * - {@link FUNC_GREATER}\n     * - {@link FUNC_GREATEREQUAL}\n     * - {@link FUNC_EQUAL}\n     * - {@link FUNC_NOTEQUAL}\n     *\n     * @type {number}\n     */\n    set compareFunc(arg: any);\n    get compareFunc(): any;\n    /**\n     * Integer value specifying the level of anisotropic to apply to the texture ranging from 1 (no\n     * anisotropic filtering) to the {@link GraphicsDevice} property maxAnisotropy.\n     *\n     * @type {number}\n     */\n    set anisotropy(arg: number);\n    get anisotropy(): number;\n    /**\n     * Toggles automatic mipmap generation. Can\'t be used on non power of two textures.\n     *\n     * @type {boolean}\n     * @ignore\n     * @deprecated\n     */\n    set autoMipmap(arg: any);\n    get autoMipmap(): any;\n    /**\n     * Defines if texture should generate/upload mipmaps if possible.\n     *\n     * @type {boolean}\n     */\n    set mipmaps(arg: any);\n    get mipmaps(): any;\n    _needsMipmapsUpload: any;\n    /**\n     * The width of the texture in pixels.\n     *\n     * @type {number}\n     */\n    get width(): number;\n    /**\n     * The height of the texture in pixels.\n     *\n     * @type {number}\n     */\n    get height(): number;\n    /**\n     * The number of depth slices in a 3D texture (WebGL2 only).\n     *\n     * @type {number}\n     */\n    get depth(): number;\n    /**\n     * The pixel format of the texture. Can be:\n     *\n     * - {@link PIXELFORMAT_A8}\n     * - {@link PIXELFORMAT_L8}\n     * - {@link PIXELFORMAT_L8_A8}\n     * - {@link PIXELFORMAT_R5_G6_B5}\n     * - {@link PIXELFORMAT_R5_G5_B5_A1}\n     * - {@link PIXELFORMAT_R4_G4_B4_A4}\n     * - {@link PIXELFORMAT_R8_G8_B8}\n     * - {@link PIXELFORMAT_R8_G8_B8_A8}\n     * - {@link PIXELFORMAT_DXT1}\n     * - {@link PIXELFORMAT_DXT3}\n     * - {@link PIXELFORMAT_DXT5}\n     * - {@link PIXELFORMAT_RGB16F}\n     * - {@link PIXELFORMAT_RGBA16F}\n     * - {@link PIXELFORMAT_RGB32F}\n     * - {@link PIXELFORMAT_RGBA32F}\n     * - {@link PIXELFORMAT_ETC1}\n     * - {@link PIXELFORMAT_PVRTC_2BPP_RGB_1}\n     * - {@link PIXELFORMAT_PVRTC_2BPP_RGBA_1}\n     * - {@link PIXELFORMAT_PVRTC_4BPP_RGB_1}\n     * - {@link PIXELFORMAT_PVRTC_4BPP_RGBA_1}\n     * - {@link PIXELFORMAT_111110F}\n     * - {@link PIXELFORMAT_ASTC_4x4}>/li>\n     * - {@link PIXELFORMAT_ATC_RGB}\n     * - {@link PIXELFORMAT_ATC_RGBA}\n     *\n     * @type {number}\n     */\n    get format(): number;\n    /**\n     * Returns true if this texture is a cube map and false otherwise.\n     *\n     * @type {boolean}\n     */\n    get cubemap(): boolean;\n    get gpuSize(): number;\n    /**\n     * Returns true if this texture is a 3D volume and false otherwise.\n     *\n     * @type {boolean}\n     */\n    get volume(): boolean;\n    /**\n     * Specifies whether the texture should be flipped in the Y-direction. Only affects textures\n     * with a source that is an image, canvas or video element. Does not affect cubemaps,\n     * compressed textures or textures set from raw pixel data. Defaults to true.\n     *\n     * @type {boolean}\n     */\n    set flipY(arg: boolean);\n    get flipY(): boolean;\n    _needsUpload: boolean;\n    set premultiplyAlpha(arg: boolean);\n    get premultiplyAlpha(): boolean;\n    /**\n     * Returns true if all dimensions of the texture are power of two, and false otherwise.\n     *\n     * @type {boolean}\n     */\n    get pot(): boolean;\n    get encoding(): "srgb" | "linear" | "rgbm" | "rgbe";\n    dirtyAll(): void;\n    _levelsUpdated: boolean[] | boolean[][];\n    _mipmapsUploaded: boolean;\n    _parameterFlags: number;\n    /**\n     * Locks a miplevel of the texture, returning a typed array to be filled with pixel data.\n     *\n     * @param {object} [options] - Optional options object. Valid properties are as follows:\n     * @param {number} [options.level] - The mip level to lock with 0 being the top level. Defaults\n     * to 0.\n     * @param {number} [options.face] - If the texture is a cubemap, this is the index of the face\n     * to lock.\n     * @param {number} [options.mode] - The lock mode. Can be:\n     * - {@link TEXTURELOCK_READ}\n     * - {@link TEXTURELOCK_WRITE}\n     * Defaults to {@link TEXTURELOCK_WRITE}.\n     * @returns {Uint8Array|Uint16Array|Float32Array} A typed array containing the pixel data of\n     * the locked mip level.\n     */\n    lock(options?: {\n        level?: number;\n        face?: number;\n        mode?: number;\n    }): Uint8Array | Uint16Array | Float32Array;\n    /**\n     * Set the pixel data of the texture from a canvas, image, video DOM element. If the texture is\n     * a cubemap, the supplied source must be an array of 6 canvases, images or videos.\n     *\n     * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement[]|HTMLImageElement[]|HTMLVideoElement[]} source - A\n     * canvas, image or video element, or an array of 6 canvas, image or video elements.\n     * @param {number} [mipLevel] - A non-negative integer specifying the image level of detail.\n     * Defaults to 0, which represents the base image source. A level value of N, that is greater\n     * than 0, represents the image source for the Nth mipmap reduction level.\n     */\n    setSource(source: HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | HTMLCanvasElement[] | HTMLImageElement[] | HTMLVideoElement[], mipLevel?: number): void;\n    /**\n     * Get the pixel data of the texture. If this is a cubemap then an array of 6 images will be\n     * returned otherwise a single image.\n     *\n     * @param {number} [mipLevel] - A non-negative integer specifying the image level of detail.\n     * Defaults to 0, which represents the base image source. A level value of N, that is greater\n     * than 0, represents the image source for the Nth mipmap reduction level.\n     * @returns {HTMLImageElement} The source image of this texture. Can be null if source not\n     * assigned for specific image level.\n     */\n    getSource(mipLevel?: number): HTMLImageElement;\n    /**\n     * Unlocks the currently locked mip level and uploads it to VRAM.\n     */\n    unlock(): void;\n    /**\n     * Forces a reupload of the textures pixel data to graphics memory. Ordinarily, this function\n     * is called by internally by {@link Texture#setSource} and {@link Texture#unlock}. However, it\n     * still needs to be called explicitly in the case where an HTMLVideoElement is set as the\n     * source of the texture.  Normally, this is done once every frame before video textured\n     * geometry is rendered.\n     */\n    upload(): void;\n    /**\n     * Generate an in-memory DDS representation of this texture. Only works on RGBA8 textures.\n     * Currently, only used by the Editor to write prefiltered cubemaps to DDS format.\n     *\n     * @returns {ArrayBuffer} Buffer containing the DDS data.\n     * @ignore\n     */\n    getDds(): ArrayBuffer;\n}\n\n\n\n\n\n\n/**\n * Draws a screen-space quad using a specific shader. Mostly used by post-effects.\n *\n * @param {GraphicsDevice} device - The graphics device used to draw the quad.\n * @param {RenderTarget|undefined} target - The destination render target. If undefined, target is\n * the frame buffer.\n * @param {Shader} shader - The shader used for rendering the quad. Vertex shader should contain\n * `attribute vec2 vertex_position`.\n * @param {Vec4} [rect] - The viewport rectangle of the quad, in pixels. Defaults to fullscreen\n * (`0, 0, target.width, target.height`).\n * @param {Vec4} [scissorRect] - The scissor rectangle of the quad, in pixels. Defaults to\n * fullscreen (`0, 0, target.width, target.height`).\n * @param {boolean} [useBlend] - True to enable blending. Defaults to false, disabling blending.\n */\ndeclare function drawQuadWithShader(device: GraphicsDevice, target: RenderTarget | undefined, shader: Shader, rect?: Vec4, scissorRect?: Vec4, useBlend?: boolean): void;\n/**\n * Draws a texture in screen-space. Mostly used by post-effects.\n *\n * @param {GraphicsDevice} device - The graphics device used to draw the texture.\n * @param {Texture} texture - The source texture to be drawn. Accessible as `uniform sampler2D\n * source` in shader.\n * @param {RenderTarget} [target] - The destination render target. Defaults to the frame buffer.\n * @param {Shader} [shader] - The shader used for rendering the texture. Defaults to {@link GraphicsDevice#getCopyShader}.\n * @param {Vec4} [rect] - The viewport rectangle to use for the texture, in pixels. Defaults to\n * fullscreen (`0, 0, target.width, target.height`).\n * @param {Vec4} [scissorRect] - The scissor rectangle to use for the texture, in pixels. Defaults\n * to fullscreen (`0, 0, target.width, target.height`).\n * @param {boolean} [useBlend] - True to enable blending. Defaults to false, disabling blending.\n */\ndeclare function drawTexture(device: GraphicsDevice, texture: Texture, target?: RenderTarget, shader?: Shader, rect?: Vec4, scissorRect?: Vec4, useBlend?: boolean): void;\n\ndeclare function begin(): string;\ndeclare function end(): string;\ndeclare function dummyFragmentCode(): string;\ndeclare function fogCode(value: any, chunks: any): any;\ndeclare function gammaCode(value: any, chunks: any): any;\ndeclare function precisionCode(device: any): string;\ndeclare function skinCode(device: any, chunks: any): any;\ndeclare function tonemapCode(value: any, chunks: any): any;\ndeclare function versionCode(device: any): "" | "#version 300 es\\n";\n\ndeclare namespace basic {\n    function generateKey(options: any): string;\n    function createShaderDefinition(device: any, options: any): {\n        attributes: {\n            vertex_position: string;\n        };\n        vshader: string;\n        fshader: string;\n    };\n}\n\ndeclare namespace particle {\n    function generateKey(options: any): string;\n    function _animTex(options: any): string;\n    function createShaderDefinition(device: any, options: any): {\n        attributes: {\n            [x: string]: string;\n        };\n        vshader: string;\n        fshader: string;\n    };\n}\n\ndeclare namespace skybox {\n    function generateKey(options: any): string;\n    function createShaderDefinition(device: any, options: any): {\n        attributes: {\n            aPosition: string;\n        };\n        vshader: any;\n        fshader: string;\n    };\n}\n\ndeclare namespace standard {\n    const optionsContext: {};\n    const optionsContextMin: {};\n    const generateKey: Function;\n    function _correctChannel(p: any, chan: any): any;\n    function _setMapTransform(codes: any, name: any, id: any, uv: any): any;\n    function _getUvSourceExpression(transformPropName: string, uVPropName: string, options: any): string;\n    function _addMapDef(name: any, enabled: any): string;\n    function _addMapDefs(float: any, color: any, vertex: any, map: any): string;\n    function _addMap(propName: string, chunkName: string, options: any, chunks: any, samplerFormat: string): string;\n    function _directionalShadowMapProjection(light: any, shadowCoordArgs: any, shadowParamArg: any, lightIndex: any, coordsFunctionName: any): string;\n    function _nonPointShadowMapProjection(device: any, light: any, shadowMatArg: any, shadowParamArg: any, lightIndex: any): string;\n    function _addVaryingIfNeeded(code: any, type: any, name: any): string;\n    function _getLightSourceShapeString(shape: any): "" | "Rect" | "Disk" | "Sphere";\n    function _getPassDefineString(pass: any): "" | "#define PICK_PASS\\n" | "#define DEPTH_PASS\\n" | "#define SHADOW_PASS\\n";\n    function _vsAddTransformCode(code: any, device: any, chunks: any, options: any): any;\n    function _vsAddBaseCode(code: any, device: any, chunks: any, options: any): any;\n    function _fsAddBaseCode(code: string, device: GraphicsDevice, chunks: any, options: any): string;\n    function _decodeFunc(textureFormat: any): any;\n    function _fsAddStartCode(code: string, device: GraphicsDevice, chunks: any, options: any): string;\n    function _buildShadowPassFragmentCode(code: any, device: any, chunks: any, options: any, varyings: any): any;\n    const createShaderDefinition: Function;\n}\n\ndeclare namespace programlib {\n    export { begin };\n    export { dummyFragmentCode };\n    export { end };\n    export { fogCode };\n    export { gammaCode };\n    export { precisionCode };\n    export { skinCode };\n    export { tonemapCode };\n    export { versionCode };\n    export { basic };\n    export { particle };\n    export { skybox };\n    export { standard };\n}\n\n/**\n * @static\n * @readonly\n * @type {object}\n * @name shaderChunks\n * @description Object containing all default shader chunks used by shader generators.\n */\ndeclare const shaderChunks: object;\n\n\n/** @typedef {import(\'./graphics-device.js\').GraphicsDevice} GraphicsDevice */\n/**\n * An index buffer stores index values into a {@link VertexBuffer}. Indexed graphical primitives\n * can normally utilize less memory that unindexed primitives (if vertices are shared).\n *\n * Typically, index buffers are set on {@link Mesh} objects.\n */\ndeclare class IndexBuffer {\n    /**\n     * Create a new IndexBuffer instance.\n     *\n     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this index\n     * buffer.\n     * @param {number} format - The type of each index to be stored in the index buffer. Can be:\n     *\n     * - {@link INDEXFORMAT_UINT8}\n     * - {@link INDEXFORMAT_UINT16}\n     * - {@link INDEXFORMAT_UINT32}\n     * @param {number} numIndices - The number of indices to be stored in the index buffer.\n     * @param {number} [usage] - The usage type of the vertex buffer. Can be:\n     *\n     * - {@link BUFFER_DYNAMIC}\n     * - {@link BUFFER_STATIC}\n     * - {@link BUFFER_STREAM}\n     *\n     * Defaults to {@link BUFFER_STATIC}.\n     * @param {ArrayBuffer} [initialData] - Initial data. If left unspecified, the index buffer\n     * will be initialized to zeros.\n     * @example\n     * // Create an index buffer holding 3 16-bit indices. The buffer is marked as\n     * // static, hinting that the buffer will never be modified.\n     * var indices = new UInt16Array([0, 1, 2]);\n     * var indexBuffer = new pc.IndexBuffer(graphicsDevice,\n     *                                      pc.INDEXFORMAT_UINT16,\n     *                                      3,\n     *                                      pc.BUFFER_STATIC,\n     *                                      indices);\n     */\n    constructor(graphicsDevice: GraphicsDevice, format: number, numIndices: number, usage?: number, initialData?: ArrayBuffer);\n    device: GraphicsDevice;\n    format: number;\n    numIndices: number;\n    usage: number;\n    impl: any;\n    bytesPerIndex: number;\n    numBytes: number;\n    storage: ArrayBuffer;\n    /**\n     * Frees resources associated with this index buffer.\n     */\n    destroy(): void;\n    /**\n     * Called when the rendering context was lost. It releases all context related resources.\n     *\n     * @ignore\n     */\n    loseContext(): void;\n    /**\n     * Returns the data format of the specified index buffer.\n     *\n     * @returns {number} The data format of the specified index buffer. Can be:\n     *\n     * - {@link INDEXFORMAT_UINT8}\n     * - {@link INDEXFORMAT_UINT16}\n     * - {@link INDEXFORMAT_UINT32}\n     */\n    getFormat(): number;\n    /**\n     * Returns the number of indices stored in the specified index buffer.\n     *\n     * @returns {number} The number of indices stored in the specified index buffer.\n     */\n    getNumIndices(): number;\n    /**\n     * Gives access to the block of memory that stores the buffer\'s indices.\n     *\n     * @returns {ArrayBuffer} A contiguous block of memory where index data can be written to.\n     */\n    lock(): ArrayBuffer;\n    /**\n     * Signals that the block of memory returned by a call to the lock function is ready to be\n     * given to the graphics hardware. Only unlocked index buffers can be set on the currently\n     * active device.\n     */\n    unlock(): void;\n    /**\n     * Set preallocated data on the index buffer.\n     *\n     * @param {ArrayBuffer} data - The index data to set.\n     * @returns {boolean} True if the data was set successfully, false otherwise.\n     * @ignore\n     */\n    setData(data: ArrayBuffer): boolean;\n    /**\n     * Get the appropriate typed array from an index buffer.\n     *\n     * @returns {Uint8Array|Uint16Array|Uint32Array} The typed array containing the index data.\n     * @private\n     */\n    private _lockTypedArray;\n    /**\n     * Copies the specified number of elements from data into index buffer. Optimized for\n     * performance from both typed array as well as array.\n     *\n     * @param {Uint8Array|Uint16Array|Uint32Array|number[]} data - The data to write.\n     * @param {number} count - The number of indices to write.\n     * @ignore\n     */\n    writeData(data: Uint8Array | Uint16Array | Uint32Array | number[], count: number): void;\n    /**\n     * Copies index data from index buffer into provided data array.\n     *\n     * @param {Uint8Array|Uint16Array|Uint32Array|number[]} data - The data array to write to.\n     * @returns {number} The number of indices read.\n     * @ignore\n     */\n    readData(data: Uint8Array | Uint16Array | Uint32Array | number[]): number;\n}\n\n\n/** @typedef {import(\'./graphics-device.js\').GraphicsDevice} GraphicsDevice */\n/**\n * Representation of a shader uniform.\n *\n * @ignore\n */\ndeclare class ShaderInput {\n    /**\n     * Create a new ShaderInput instance.\n     *\n     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this shader input.\n     * @param {string} name - The name of the shader input.\n     * @param {number} type - The type of the shader input.\n     * @param {number} locationId - The location id of the shader input.\n     */\n    constructor(graphicsDevice: GraphicsDevice, name: string, type: number, locationId: number);\n    locationId: number;\n    scopeId: ScopeId;\n    version: Version;\n    dataType: number;\n    value: any[];\n    array: any[];\n}\n\n\n/** @typedef {import(\'./graphics-device.js\').GraphicsDevice} GraphicsDevice */\n/**\n * A vertex format is a descriptor that defines the layout of vertex data inside a\n * {@link VertexBuffer}.\n *\n * @property {object[]} elements The vertex attribute elements.\n * @property {string} elements[].name The meaning of the vertex element. This is used to link the\n * vertex data to a shader input. Can be:\n *\n * - {@link SEMANTIC_POSITION}\n * - {@link SEMANTIC_NORMAL}\n * - {@link SEMANTIC_TANGENT}\n * - {@link SEMANTIC_BLENDWEIGHT}\n * - {@link SEMANTIC_BLENDINDICES}\n * - {@link SEMANTIC_COLOR}\n * - {@link SEMANTIC_TEXCOORD0}\n * - {@link SEMANTIC_TEXCOORD1}\n * - {@link SEMANTIC_TEXCOORD2}\n * - {@link SEMANTIC_TEXCOORD3}\n * - {@link SEMANTIC_TEXCOORD4}\n * - {@link SEMANTIC_TEXCOORD5}\n * - {@link SEMANTIC_TEXCOORD6}\n * - {@link SEMANTIC_TEXCOORD7}\n *\n * If vertex data has a meaning other that one of those listed above, use the user-defined\n * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.\n * @property {number} elements[].numComponents The number of components of the vertex attribute.\n * Can be 1, 2, 3 or 4.\n * @property {number} elements[].dataType The data type of the attribute. Can be:\n *\n * - {@link TYPE_INT8}\n * - {@link TYPE_UINT8}\n * - {@link TYPE_INT16}\n * - {@link TYPE_UINT16}\n * - {@link TYPE_INT32}\n * - {@link TYPE_UINT32}\n * - {@link TYPE_FLOAT32}\n * @property {boolean} elements[].normalize If true, vertex attribute data will be mapped from a 0\n * to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data is left\n * unchanged. If this property is unspecified, false is assumed.\n * @property {number} elements[].offset The number of initial bytes at the start of a vertex that\n * are not relevant to this attribute.\n * @property {number} elements[].stride The number of total bytes that are between the start of one\n * vertex, and the start of the next.\n * @property {number} elements[].size The size of the attribute in bytes.\n */\ndeclare class VertexFormat {\n    /**\n     * @type {VertexFormat}\n     * @private\n     */\n    private static _defaultInstancingFormat;\n    /**\n     * The {@link VertexFormat} used to store matrices of type {@link Mat4} for hardware instancing.\n     *\n     * @type {VertexFormat}\n     */\n    static get defaultInstancingFormat(): VertexFormat;\n    /**\n     * Create a new VertexFormat instance.\n     *\n     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this vertex format.\n     * @param {object[]} description - An array of vertex attribute descriptions.\n     * @param {string} description[].semantic - The meaning of the vertex element. This is used to link\n     * the vertex data to a shader input. Can be:\n     *\n     * - {@link SEMANTIC_POSITION}\n     * - {@link SEMANTIC_NORMAL}\n     * - {@link SEMANTIC_TANGENT}\n     * - {@link SEMANTIC_BLENDWEIGHT}\n     * - {@link SEMANTIC_BLENDINDICES}\n     * - {@link SEMANTIC_COLOR}\n     * - {@link SEMANTIC_TEXCOORD0}\n     * - {@link SEMANTIC_TEXCOORD1}\n     * - {@link SEMANTIC_TEXCOORD2}\n     * - {@link SEMANTIC_TEXCOORD3}\n     * - {@link SEMANTIC_TEXCOORD4}\n     * - {@link SEMANTIC_TEXCOORD5}\n     * - {@link SEMANTIC_TEXCOORD6}\n     * - {@link SEMANTIC_TEXCOORD7}\n     *\n     * If vertex data has a meaning other that one of those listed above, use the user-defined\n     * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.\n     * @param {number} description[].components - The number of components of the vertex attribute.\n     * Can be 1, 2, 3 or 4.\n     * @param {number} description[].type - The data type of the attribute. Can be:\n     *\n     * - {@link TYPE_INT8}\n     * - {@link TYPE_UINT8}\n     * - {@link TYPE_INT16}\n     * - {@link TYPE_UINT16}\n     * - {@link TYPE_INT32}\n     * - {@link TYPE_UINT32}\n     * - {@link TYPE_FLOAT32}\n     *\n     * @param {boolean} [description[].normalize] - If true, vertex attribute data will be mapped\n     * from a 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data\n     * is left unchanged. If this property is unspecified, false is assumed.\n     * @param {number} [vertexCount] - When specified, vertex format will be set up for\n     * non-interleaved format with a specified number of vertices. (example: PPPPNNNNCCCC), where\n     * arrays of individual attributes will be stored one right after the other (subject to\n     * alignment requirements). Note that in this case, the format depends on the number of\n     * vertices, and needs to change when the number of vertices changes. When not specified,\n     * vertex format will be interleaved. (example: PNCPNCPNCPNC).\n     * @example\n     * // Specify 3-component positions (x, y, z)\n     * var vertexFormat = new pc.VertexFormat(graphicsDevice, [\n     *     { semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }\n     * ]);\n     * @example\n     * // Specify 2-component positions (x, y), a texture coordinate (u, v) and a vertex color (r, g, b, a)\n     * var vertexFormat = new pc.VertexFormat(graphicsDevice, [\n     *     { semantic: pc.SEMANTIC_POSITION, components: 2, type: pc.TYPE_FLOAT32 },\n     *     { semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 },\n     *     { semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_UINT8, normalize: true }\n     * ]);\n     */\n    constructor(graphicsDevice: GraphicsDevice, description: {\n        semantic: string;\n        components: number;\n        type: number;\n        normalize?: boolean;\n    }[], vertexCount?: number);\n    _elements: {\n        name: string;\n        offset: any;\n        stride: any;\n        dataType: number;\n        numComponents: number;\n        normalize: boolean;\n        size: number;\n    }[];\n    hasUv0: boolean;\n    hasUv1: boolean;\n    hasColor: boolean;\n    hasTangents: boolean;\n    verticesByteSize: number;\n    vertexCount: number;\n    interleaved: boolean;\n    size: number;\n    get elements(): {\n        name: string;\n        offset: any;\n        stride: any;\n        dataType: number;\n        numComponents: number;\n        normalize: boolean;\n        size: number;\n    }[];\n    /**\n     * Evaluates hash values for the format allowing fast compare of batching / rendering compatibility.\n     *\n     * @private\n     */\n    private _evaluateHash;\n    batchingHash: number;\n    renderingingHash: number;\n}\n\n\n\n/**\n * A vertex buffer is the mechanism via which the application specifies vertex data to the graphics\n * hardware.\n */\ndeclare class VertexBuffer {\n    /**\n     * Create a new VertexBuffer instance.\n     *\n     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this vertex\n     * buffer.\n     * @param {VertexFormat} format - The vertex format of this vertex buffer.\n     * @param {number} numVertices - The number of vertices that this vertex buffer will hold.\n     * @param {number} [usage] - The usage type of the vertex buffer (see BUFFER_*). Defaults to BUFFER_STATIC.\n     * @param {ArrayBuffer} [initialData] - Initial data.\n     */\n    constructor(graphicsDevice: GraphicsDevice, format: VertexFormat, numVertices: number, usage?: number, initialData?: ArrayBuffer);\n    device: GraphicsDevice;\n    format: VertexFormat;\n    numVertices: number;\n    usage: number;\n    id: number;\n    impl: any;\n    instancing: boolean;\n    numBytes: number;\n    storage: ArrayBuffer;\n    /**\n     * Frees resources associated with this vertex buffer.\n     */\n    destroy(): void;\n    /**\n     * Called when the rendering context was lost. It releases all context related resources.\n     *\n     * @ignore\n     */\n    loseContext(): void;\n    /**\n     * Returns the data format of the specified vertex buffer.\n     *\n     * @returns {VertexFormat} The data format of the specified vertex buffer.\n     */\n    getFormat(): VertexFormat;\n    /**\n     * Returns the usage type of the specified vertex buffer. This indicates whether the buffer can\n     * be modified once and used many times {@link BUFFER_STATIC}, modified repeatedly and used\n     * many times {@link BUFFER_DYNAMIC} or modified once and used at most a few times\n     * {@link BUFFER_STREAM}.\n     *\n     * @returns {number} The usage type of the vertex buffer (see BUFFER_*).\n     */\n    getUsage(): number;\n    /**\n     * Returns the number of vertices stored in the specified vertex buffer.\n     *\n     * @returns {number} The number of vertices stored in the vertex buffer.\n     */\n    getNumVertices(): number;\n    /**\n     * Returns a mapped memory block representing the content of the vertex buffer.\n     *\n     * @returns {ArrayBuffer} An array containing the byte data stored in the vertex buffer.\n     */\n    lock(): ArrayBuffer;\n    /**\n     * Notifies the graphics engine that the client side copy of the vertex buffer\'s memory can be\n     * returned to the control of the graphics driver.\n     */\n    unlock(): void;\n    /**\n     * Copies data into vertex buffer\'s memory.\n     *\n     * @param {ArrayBuffer} [data] - Source data to copy.\n     * @returns {boolean} True if function finished successfully, false otherwise.\n     */\n    setData(data?: ArrayBuffer): boolean;\n}\n\n\n\n\n/**\n * A vertex iterator simplifies the process of writing vertex data to a vertex buffer.\n */\ndeclare class VertexIterator {\n    /**\n     * Create a new VertexIterator instance.\n     *\n     * @param {VertexBuffer} vertexBuffer - The vertex buffer to be iterated.\n     */\n    constructor(vertexBuffer: VertexBuffer);\n    vertexBuffer: VertexBuffer;\n    vertexFormatSize: number;\n    buffer: ArrayBuffer;\n    accessors: VertexIteratorAccessor[];\n    /**\n     * The vertex buffer elements.\n     *\n     * @type {Object.<string, VertexIteratorAccessor>}\n     */\n    element: {\n        [x: string]: VertexIteratorAccessor;\n    };\n    /**\n     * Moves the vertex iterator on to the next vertex.\n     *\n     * @param {number} [count] - Optional number of steps to move on when calling next. Defaults to\n     * 1.\n     * @example\n     * var iterator = new pc.VertexIterator(vertexBuffer);\n     * iterator.element[pc.SEMANTIC_POSITION].set(-0.9, -0.9, 0.0);\n     * iterator.element[pc.SEMANTIC_COLOR].set(255, 0, 0, 255);\n     * iterator.next();\n     * iterator.element[pc.SEMANTIC_POSITION].set(0.9, -0.9, 0.0);\n     * iterator.element[pc.SEMANTIC_COLOR].set(0, 255, 0, 255);\n     * iterator.next();\n     * iterator.element[pc.SEMANTIC_POSITION].set(0.0, 0.9, 0.0);\n     * iterator.element[pc.SEMANTIC_COLOR].set(0, 0, 255, 255);\n     * iterator.end();\n     */\n    next(count?: number): void;\n    /**\n     * Notifies the vertex buffer being iterated that writes are complete. Internally the vertex\n     * buffer is unlocked and vertex data is uploaded to video memory.\n     *\n     * @example\n     * var iterator = new pc.VertexIterator(vertexBuffer);\n     * iterator.element[pc.SEMANTIC_POSITION].set(-0.9, -0.9, 0.0);\n     * iterator.element[pc.SEMANTIC_COLOR].set(255, 0, 0, 255);\n     * iterator.next();\n     * iterator.element[pc.SEMANTIC_POSITION].set(0.9, -0.9, 0.0);\n     * iterator.element[pc.SEMANTIC_COLOR].set(0, 255, 0, 255);\n     * iterator.next();\n     * iterator.element[pc.SEMANTIC_POSITION].set(0.0, 0.9, 0.0);\n     * iterator.element[pc.SEMANTIC_COLOR].set(0, 0, 255, 255);\n     * iterator.end();\n     */\n    end(): void;\n    /**\n     * Copies data for specified semantic into vertex buffer. Works with both interleaved (slower)\n     * and non-interleaved (fast) vertex buffers.\n     *\n     * @param {string} semantic - The semantic of the vertex element to set.\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - The data to set.\n     * @param {number} numVertices - The number of vertices to write.\n     * @ignore\n     */\n    writeData(semantic: string, data: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, numVertices: number): void;\n    /**\n     * Function to extract elements of a specified semantic from vertex buffer into flat array\n     * (data). Works with both interleaved (slower) and non-interleaved (fast) vertex buffers.\n     * Returns number of vertices. Note: when data is a typed array and is smaller than needed,\n     * only part of the data gets copied out (typed arrays ignore read/write out of range).\n     *\n     * @param {string} semantic - The semantic of the vertex element to read.\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - The\n     * array to receive the data.\n     * @returns {number} The number of vertices read.\n     * @ignore\n     */\n    readData(semantic: string, data: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;\n}\n/**\n * Helps with accessing a specific vertex attribute.\n */\ndeclare class VertexIteratorAccessor {\n    /**\n     * Create a new VertexIteratorAccessor instance.\n     *\n     * @param {ArrayBuffer} buffer - The vertex buffer containing the attribute to be accessed.\n     * @param {object} vertexElement - The vertex attribute to be accessed.\n     * @param {string} vertexElement.name - The meaning of the vertex element. This is used to link\n     * the vertex data to a shader input. Can be:\n     *\n     * - {@link SEMANTIC_POSITION}\n     * - {@link SEMANTIC_NORMAL}\n     * - {@link SEMANTIC_TANGENT}\n     * - {@link SEMANTIC_BLENDWEIGHT}\n     * - {@link SEMANTIC_BLENDINDICES}\n     * - {@link SEMANTIC_COLOR}\n     * - {@link SEMANTIC_TEXCOORD0}\n     * - {@link SEMANTIC_TEXCOORD1}\n     * - {@link SEMANTIC_TEXCOORD2}\n     * - {@link SEMANTIC_TEXCOORD3}\n     * - {@link SEMANTIC_TEXCOORD4}\n     * - {@link SEMANTIC_TEXCOORD5}\n     * - {@link SEMANTIC_TEXCOORD6}\n     * - {@link SEMANTIC_TEXCOORD7}\n     *\n     * If vertex data has a meaning other that one of those listed above, use the user-defined\n     * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.\n     * @param {number} vertexElement.numComponents - The number of components of the vertex\n     * attribute. Can be 1, 2, 3 or 4.\n     * @param {number} vertexElement.dataType - The data type of the attribute. Can be:\n     *\n     * - {@link TYPE_INT8}\n     * - {@link TYPE_UINT8}\n     * - {@link TYPE_INT16}\n     * - {@link TYPE_UINT16}\n     * - {@link TYPE_INT32}\n     * - {@link TYPE_UINT32}\n     * - {@link TYPE_FLOAT32}\n     * @param {boolean} vertexElement.normalize - If true, vertex attribute data will be mapped\n     * from a 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data\n     * is left unchanged. If this property is unspecified, false is assumed.\n     * @param {number} vertexElement.offset - The number of initial bytes at the start of a vertex\n     * that are not relevant to this attribute.\n     * @param {number} vertexElement.stride - The number of total bytes that are between the start\n     * of one vertex, and the start of the next.\n     * @param {ScopeId} vertexElement.scopeId - The shader input variable corresponding to the\n     * attribute.\n     * @param {number} vertexElement.size - The size of the attribute in bytes.\n     * @param {VertexFormat} vertexFormat - A vertex format that defines the layout of vertex data\n     * inside the buffer.\n     */\n    constructor(buffer: ArrayBuffer, vertexElement: {\n        name: string;\n        numComponents: number;\n        dataType: number;\n        normalize: boolean;\n        offset: number;\n        stride: number;\n        scopeId: ScopeId;\n        size: number;\n    }, vertexFormat: VertexFormat);\n    index: number;\n    numComponents: number;\n    array: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array;\n    stride: number;\n    /**\n     * Set all the attribute components at the iterator\'s current index.\n     *\n     * @param {number} a - The first component value.\n     * @param {number} [b] - The second component value (if applicable).\n     * @param {number} [c] - The third component value (if applicable).\n     * @param {number} [d] - The fourth component value (if applicable).\n     */\n    set(a: number, b?: number, c?: number, d?: number): void;\n    /**\n     * Read attribute components to an output array.\n     *\n     * @param {number} offset - The component offset at which to read data from the buffer. Will be\n     * used instead of the iterator\'s current index.\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} outputArray - The output array to write data into.\n     * @param {number} outputIndex - The output index at which to write into the output array.\n     */\n    getToArray(offset: number, outputArray: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, outputIndex: number): void;\n    /**\n     * Write attribute components from an input array.\n     *\n     * @param {number} index - The starting index at which to write data into the buffer. Will be\n     * used instead of the iterator\'s current index.\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} inputArray - The input array to read data from.\n     * @param {number} inputIndex - The input index at which to read from the input array.\n     */\n    setFromArray(index: number, inputArray: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, inputIndex: number): void;\n    /**\n     * Get a attribute component at the iterator\'s current index.\n     *\n     * @param {number} offset - The component offset. Should be either 0, 1, 2, or 3.\n     * @returns {number} The value of a attribute component.\n     */\n    get(offset: number): number;\n}\n\n\n\n\n\n/**\n * Create a vertex buffer with 4 vertices representing a fullscreen quad.\n *\n * @param {GraphicsDevice} device - The graphics device.\n * @returns {VertexBuffer} - The fullscreen quad vertex buffer.\n * @ignore\n */\ndeclare function createFullscreenQuad(device: GraphicsDevice): VertexBuffer;\n/**\n * Draw a screen-space rectangle in a render target. Primarily meant to be used in custom post\n * effects based on {@link PostEffect}.\n *\n * @param {GraphicsDevice} device - The graphics device of the application.\n * @param {RenderTarget} target - The output render target.\n * @param {VertexBuffer} vertexBuffer - The vertex buffer for the rectangle mesh. When calling from\n * a custom post effect, pass the field {@link PostEffect#vertexBuffer}.\n * @param {Shader} shader - The shader to be used for drawing the rectangle. When calling from a\n * custom post effect, pass the field {@link PostEffect#shader}.\n * @param {Vec4} [rect] - The normalized screen-space position (rect.x, rect.y) and size (rect.z,\n * rect.w) of the rectangle. Default is [0, 0, 1, 1].\n */\ndeclare function drawFullscreenQuad(device: GraphicsDevice, target: RenderTarget, vertexBuffer: VertexBuffer, shader: Shader, rect?: Vec4): void;\n/**\n * Base class for all post effects. Post effects take a a render target as input apply effects to\n * it and then render the result to an output render target or the screen if no output is\n * specified.\n */\ndeclare class PostEffect$1 {\n    /**\n     * Create a new PostEffect instance.\n     *\n     * @param {GraphicsDevice} graphicsDevice - The graphics device of the application.\n     */\n    constructor(graphicsDevice: GraphicsDevice);\n    /**\n     * The graphics device of the application.\n     *\n     * @type {GraphicsDevice}\n     */\n    device: GraphicsDevice;\n    /**\n     * The shader definition for the fullscreen quad. Needs to be set by the custom post effect\n     * (default is null). Used when calling {@link drawFullscreenQuad}.\n     *\n     * @type {Shader|null}\n     */\n    shader: Shader | null;\n    /**\n     * The vertex buffer for the fullscreen quad. Used when calling {@link drawFullscreenQuad}.\n     *\n     * @type {VertexBuffer}\n     */\n    vertexBuffer: VertexBuffer;\n    /**\n     * The property that should to be set to `true` (by the custom post effect) if a depth map\n     * is necessary (default is false).\n     *\n     * @type {boolean}\n     */\n    needsDepthBuffer: boolean;\n    depthMap: any;\n    /**\n     * Render the post effect using the specified inputTarget to the specified outputTarget.\n     *\n     * @param {RenderTarget} inputTarget - The input render target.\n     * @param {RenderTarget} outputTarget - The output render target. If null then this will be the\n     * screen.\n     * @param {Vec4} [rect] - The rect of the current camera. If not specified, it will default to\n     * [0, 0, 1, 1].\n     */\n    render(inputTarget: RenderTarget, outputTarget: RenderTarget, rect?: Vec4): void;\n}\n\n\n\n/** @typedef {import(\'../graphics/graphics-device.js\').GraphicsDevice} GraphicsDevice */\n/** @typedef {import(\'../math/mat4.js\').Mat4} Mat4 */\n/**\n * A skin contains data about the bones in a hierarchy that drive a skinned mesh animation.\n * Specifically, the skin stores the bone name and inverse bind matrix and for each bone. Inverse\n * bind matrices are instrumental in the mathematics of vertex skinning.\n */\ndeclare class Skin {\n    /**\n     * Create a new Skin instance.\n     *\n     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this skin.\n     * @param {Mat4[]} ibp - The array of inverse bind matrices.\n     * @param {string[]} boneNames - The array of bone names for the bones referenced by this skin.\n     */\n    constructor(graphicsDevice: GraphicsDevice, ibp: Mat4[], boneNames: string[]);\n    device: GraphicsDevice;\n    inverseBindPose: Mat4[];\n    boneNames: string[];\n}\n\n/**\n * Callback used by {@link GraphNodefind } and {@link GraphNodefindOne } to search through a graph\n * node and all of its descendants.\n */\nexport type FindNodeCallback = (node: GraphNode) => boolean;\n/**\n * Callback used by {@link GraphNodeforEach } to iterate through a graph node and all of its\n * descendants.\n */\nexport type ForEachNodeCallback = (node: GraphNode) => any;\n/**\n * Callback used by {@link GraphNode#find} and {@link GraphNode#findOne} to search through a graph\n * node and all of its descendants.\n *\n * @callback FindNodeCallback\n * @param {GraphNode} node - The current graph node.\n * @returns {boolean} Returning `true` will result in that node being returned from\n * {@link GraphNode#find} or {@link GraphNode#findOne}.\n */\n/**\n * Callback used by {@link GraphNode#forEach} to iterate through a graph node and all of its\n * descendants.\n *\n * @callback ForEachNodeCallback\n * @param {GraphNode} node - The current graph node.\n */\n/**\n * A hierarchical scene node.\n *\n * @augments EventHandler\n */\ndeclare class GraphNode extends EventHandler {\n    /**\n     * Create a new GraphNode instance.\n     *\n     * @param {string} [name] - The non-unique name of a graph node. Defaults to \'Untitled\'.\n     */\n    constructor(name?: string);\n    /**\n     * The non-unique name of a graph node. Defaults to \'Untitled\'.\n     *\n     * @type {string}\n     */\n    name: string;\n    /**\n     * Interface for tagging graph nodes. Tag based searches can be performed using the\n     * {@link GraphNode#findByTag} function.\n     *\n     * @type {Tags}\n     */\n    tags: Tags;\n    /** @private */\n    private _labels;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private localPosition;\n    /**\n     * @type {Quat}\n     * @private\n     */\n    private localRotation;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private localScale;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private localEulerAngles;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private position;\n    /**\n     * @type {Quat}\n     * @private\n     */\n    private rotation;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private eulerAngles;\n    /**\n     * @type {Vec3|null}\n     * @private\n     */\n    private _scale;\n    /**\n     * @type {Mat4}\n     * @private\n     */\n    private localTransform;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _dirtyLocal;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _aabbVer;\n    /**\n     * Marks the node to ignore hierarchy sync entirely (including children nodes). The engine\n     * code automatically freezes and unfreezes objects whenever required. Segregating dynamic\n     * and stationary nodes into subhierarchies allows to reduce sync time significantly.\n     *\n     * @type {boolean}\n     * @private\n     */\n    private _frozen;\n    /**\n     * @type {Mat4}\n     * @private\n     */\n    private worldTransform;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _dirtyWorld;\n    /**\n     * @type {Mat3}\n     * @private\n     */\n    private normalMatrix;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _dirtyNormal;\n    /**\n     * @type {Vec3|null}\n     * @private\n     */\n    private _right;\n    /**\n     * @type {Vec3|null}\n     * @private\n     */\n    private _up;\n    /**\n     * @type {Vec3|null}\n     * @private\n     */\n    private _forward;\n    /**\n     * @type {GraphNode|null}\n     * @private\n     */\n    private _parent;\n    /**\n     * @type {GraphNode[]}\n     * @private\n     */\n    private _children;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _graphDepth;\n    /**\n     * Represents enabled state of the entity. If the entity is disabled, the entity including\n     * all children are excluded from updates.\n     *\n     * @type {boolean}\n     * @private\n     */\n    private _enabled;\n    /**\n     * Represents enabled state of the entity in the hierarchy. It\'s true only if this entity\n     * and all parent entities all the way to the scene\'s root are enabled.\n     *\n     * @type {boolean}\n     * @private\n     */\n    private _enabledInHierarchy;\n    /**\n     * @type {boolean}\n     * @ignore\n     */\n    scaleCompensation: boolean;\n    /**\n     * The normalized local space X-axis vector of the graph node in world space.\n     *\n     * @type {Vec3}\n     */\n    get right(): Vec3;\n    /**\n     * The normalized local space Y-axis vector of the graph node in world space.\n     *\n     * @type {Vec3}\n     */\n    get up(): Vec3;\n    /**\n     * The normalized local space negative Z-axis vector of the graph node in world space.\n     *\n     * @type {Vec3}\n     */\n    get forward(): Vec3;\n    /**\n     * Enable or disable a GraphNode. If one of the GraphNode\'s parents is disabled there will be\n     * no other side effects. If all the parents are enabled then the new value will activate or\n     * deactivate all the enabled children of the GraphNode.\n     *\n     * @type {boolean}\n     */\n    set enabled(arg: boolean);\n    get enabled(): boolean;\n    /**\n     * A read-only property to get a parent graph node.\n     *\n     * @type {GraphNode|null}\n     */\n    get parent(): GraphNode;\n    /**\n     * A read-only property to get the path of the graph node relative to the root of the hierarchy.\n     *\n     * @type {string}\n     */\n    get path(): string;\n    /**\n     * A read-only property to get highest graph node from current node.\n     *\n     * @type {GraphNode}\n     */\n    get root(): GraphNode;\n    /**\n     * A read-only property to get the children of this graph node.\n     *\n     * @type {GraphNode[]}\n     */\n    get children(): GraphNode[];\n    /**\n     * A read-only property to get the depth of this child within the graph. Note that for\n     * performance reasons this is only recalculated when a node is added to a new parent, i.e. It\n     * is not recalculated when a node is simply removed from the graph.\n     *\n     * @type {number}\n     */\n    get graphDepth(): number;\n    /**\n     * @param {GraphNode} node - Graph node to update.\n     * @param {boolean} enabled - True if enabled in the hierarchy, false if disabled.\n     * @private\n     */\n    private _notifyHierarchyStateChanged;\n    /**\n     * Called when the enabled flag of the entity or one of its parents changes.\n     *\n     * @param {boolean} enabled - True if enabled in the hierarchy, false if disabled.\n     * @private\n     */\n    private _onHierarchyStateChanged;\n    /**\n     * @param {GraphNode} clone - The cloned graph node to copy into.\n     * @private\n     */\n    private _cloneInternal;\n    /**\n     * Clone a graph node.\n     *\n     * @returns {GraphNode} A clone of the specified graph node.\n     */\n    clone(): GraphNode;\n    /**\n     * Copy a graph node.\n     *\n     * @param {GraphNode} source - The graph node to copy.\n     * @returns {GraphNode} The destination graph node.\n     * @ignore\n     */\n    copy(source: GraphNode): GraphNode;\n    /**\n     * Search the graph node and all of its descendants for the nodes that satisfy some search\n     * criteria.\n     *\n     * @param {FindNodeCallback|string} attr - This can either be a function or a string. If it\'s a\n     * function, it is executed for each descendant node to test if node satisfies the search\n     * logic. Returning true from the function will include the node into the results. If it\'s a\n     * string then it represents the name of a field or a method of the node. If this is the name\n     * of a field then the value passed as the second argument will be checked for equality. If\n     * this is the name of a function then the return value of the function will be checked for\n     * equality against the valued passed as the second argument to this function.\n     * @param {object} [value] - If the first argument (attr) is a property name then this value\n     * will be checked against the value of the property.\n     * @returns {GraphNode[]} The array of graph nodes that match the search criteria.\n     * @example\n     * // Finds all nodes that have a model component and have `door` in their lower-cased name\n     * var doors = house.find(function (node) {\n     *     return node.model && node.name.toLowerCase().indexOf(\'door\') !== -1;\n     * });\n     * @example\n     * // Finds all nodes that have the name property set to \'Test\'\n     * var entities = parent.find(\'name\', \'Test\');\n     */\n    find(attr: FindNodeCallback | string, value?: object): GraphNode[];\n    /**\n     * Search the graph node and all of its descendants for the first node that satisfies some\n     * search criteria.\n     *\n     * @param {FindNodeCallback|string} attr - This can either be a function or a string. If it\'s a\n     * function, it is executed for each descendant node to test if node satisfies the search\n     * logic. Returning true from the function will result in that node being returned from\n     * findOne. If it\'s a string then it represents the name of a field or a method of the node. If\n     * this is the name of a field then the value passed as the second argument will be checked for\n     * equality. If this is the name of a function then the return value of the function will be\n     * checked for equality against the valued passed as the second argument to this function.\n     * @param {object} [value] - If the first argument (attr) is a property name then this value\n     * will be checked against the value of the property.\n     * @returns {GraphNode|null} A graph node that match the search criteria. Returns null if no\n     * node is found.\n     * @example\n     * // Find the first node that is called `head` and has a model component\n     * var head = player.findOne(function (node) {\n     *     return node.model && node.name === \'head\';\n     * });\n     * @example\n     * // Finds the first node that has the name property set to \'Test\'\n     * var node = parent.findOne(\'name\', \'Test\');\n     */\n    findOne(attr: FindNodeCallback | string, value?: object): GraphNode | null;\n    /**\n     * Return all graph nodes that satisfy the search query. Query can be simply a string, or comma\n     * separated strings, to have inclusive results of assets that match at least one query. A\n     * query that consists of an array of tags can be used to match graph nodes that have each tag\n     * of array.\n     *\n     * @param {...*} query - Name of a tag or array of tags.\n     * @returns {GraphNode[]} A list of all graph nodes that match the query.\n     * @example\n     * // Return all graph nodes that tagged by `animal`\n     * var animals = node.findByTag("animal");\n     * @example\n     * // Return all graph nodes that tagged by `bird` OR `mammal`\n     * var birdsAndMammals = node.findByTag("bird", "mammal");\n     * @example\n     * // Return all assets that tagged by `carnivore` AND `mammal`\n     * var meatEatingMammals = node.findByTag(["carnivore", "mammal"]);\n     * @example\n     * // Return all assets that tagged by (`carnivore` AND `mammal`) OR (`carnivore` AND `reptile`)\n     * var meatEatingMammalsAndReptiles = node.findByTag(["carnivore", "mammal"], ["carnivore", "reptile"]);\n     */\n    findByTag(...args: any[]): GraphNode[];\n    /**\n     * Get the first node found in the graph with the name. The search is depth first.\n     *\n     * @param {string} name - The name of the graph.\n     * @returns {GraphNode|null} The first node to be found matching the supplied name. Returns\n     * null if no node is found.\n     */\n    findByName(name: string): GraphNode | null;\n    /**\n     * Get the first node found in the graph by its full path in the graph. The full path has this\n     * form \'parent/child/sub-child\'. The search is depth first.\n     *\n     * @param {string|string[]} path - The full path of the {@link GraphNode} as either a string or\n     * array of {@link GraphNode} names.\n     * @returns {GraphNode|null} The first node to be found matching the supplied path. Returns\n     * null if no node is found.\n     * @example\n     * // String form\n     * var grandchild = this.entity.findByPath(\'child/grandchild\');\n     * @example\n     * // Array form\n     * var grandchild = this.entity.findByPath([\'child\', \'grandchild\']);\n     */\n    findByPath(path: string | string[]): GraphNode | null;\n    /**\n     * Executes a provided function once on this graph node and all of its descendants.\n     *\n     * @param {ForEachNodeCallback} callback - The function to execute on the graph node and each\n     * descendant.\n     * @param {object} [thisArg] - Optional value to use as this when executing callback function.\n     * @example\n     * // Log the path and name of each node in descendant tree starting with "parent"\n     * parent.forEach(function (node) {\n     *     console.log(node.path + "/" + node.name);\n     * });\n     */\n    forEach(callback: ForEachNodeCallback, thisArg?: object): void;\n    /**\n     * Check if node is descendant of another node.\n     *\n     * @param {GraphNode} node - Potential ancestor of node.\n     * @returns {boolean} If node is descendant of another node.\n     * @example\n     * if (roof.isDescendantOf(house)) {\n     *     // roof is descendant of house entity\n     * }\n     */\n    isDescendantOf(node: GraphNode): boolean;\n    /**\n     * Check if node is ancestor for another node.\n     *\n     * @param {GraphNode} node - Potential descendant of node.\n     * @returns {boolean} If node is ancestor for another node.\n     * @example\n     * if (body.isAncestorOf(foot)) {\n     *     // foot is within body\'s hierarchy\n     * }\n     */\n    isAncestorOf(node: GraphNode): boolean;\n    /**\n     * Get the world space rotation for the specified GraphNode in Euler angle form. The rotation\n     * is returned as euler angles in a {@link Vec3}. The value returned by this function should be\n     * considered read-only. In order to set the world-space rotation of the graph node, use\n     * {@link GraphNode#setEulerAngles}.\n     *\n     * @returns {Vec3} The world space rotation of the graph node in Euler angle form.\n     * @example\n     * var angles = this.entity.getEulerAngles();\n     * angles.y = 180; // rotate the entity around Y by 180 degrees\n     * this.entity.setEulerAngles(angles);\n     */\n    getEulerAngles(): Vec3;\n    /**\n     * Get the rotation in local space for the specified GraphNode. The rotation is returned as\n     * euler angles in a {@link Vec3}. The returned vector should be considered read-only. To\n     * update the local rotation, use {@link GraphNode#setLocalEulerAngles}.\n     *\n     * @returns {Vec3} The local space rotation of the graph node as euler angles in XYZ order.\n     * @example\n     * var angles = this.entity.getLocalEulerAngles();\n     * angles.y = 180;\n     * this.entity.setLocalEulerAngles(angles);\n     */\n    getLocalEulerAngles(): Vec3;\n    /**\n     * Get the position in local space for the specified GraphNode. The position is returned as a\n     * {@link Vec3}. The returned vector should be considered read-only. To update the local\n     * position, use {@link GraphNode#setLocalPosition}.\n     *\n     * @returns {Vec3} The local space position of the graph node.\n     * @example\n     * var position = this.entity.getLocalPosition();\n     * position.x += 1; // move the entity 1 unit along x.\n     * this.entity.setLocalPosition(position);\n     */\n    getLocalPosition(): Vec3;\n    /**\n     * Get the rotation in local space for the specified GraphNode. The rotation is returned as a\n     * {@link Quat}. The returned quaternion should be considered read-only. To update the local\n     * rotation, use {@link GraphNode#setLocalRotation}.\n     *\n     * @returns {Quat} The local space rotation of the graph node as a quaternion.\n     * @example\n     * var rotation = this.entity.getLocalRotation();\n     */\n    getLocalRotation(): Quat;\n    /**\n     * Get the scale in local space for the specified GraphNode. The scale is returned as a\n     * {@link Vec3}. The returned vector should be considered read-only. To update the local scale,\n     * use {@link GraphNode#setLocalScale}.\n     *\n     * @returns {Vec3} The local space scale of the graph node.\n     * @example\n     * var scale = this.entity.getLocalScale();\n     * scale.x = 100;\n     * this.entity.setLocalScale(scale);\n     */\n    getLocalScale(): Vec3;\n    /**\n     * Get the local transform matrix for this graph node. This matrix is the transform relative to\n     * the node\'s parent\'s world transformation matrix.\n     *\n     * @returns {Mat4} The node\'s local transformation matrix.\n     * @example\n     * var transform = this.entity.getLocalTransform();\n     */\n    getLocalTransform(): Mat4;\n    /**\n     * Get the world space position for the specified GraphNode. The position is returned as a\n     * {@link Vec3}. The value returned by this function should be considered read-only. In order\n     * to set the world-space position of the graph node, use {@link GraphNode#setPosition}.\n     *\n     * @returns {Vec3} The world space position of the graph node.\n     * @example\n     * var position = this.entity.getPosition();\n     * position.x = 10;\n     * this.entity.setPosition(position);\n     */\n    getPosition(): Vec3;\n    /**\n     * Get the world space rotation for the specified GraphNode. The rotation is returned as a\n     * {@link Quat}. The value returned by this function should be considered read-only. In order\n     * to set the world-space rotation of the graph node, use {@link GraphNode#setRotation}.\n     *\n     * @returns {Quat} The world space rotation of the graph node as a quaternion.\n     * @example\n     * var rotation = this.entity.getRotation();\n     */\n    getRotation(): Quat;\n    /**\n     * Get the world space scale for the specified GraphNode. The returned value will only be\n     * correct for graph nodes that have a non-skewed world transform (a skew can be introduced by\n     * the compounding of rotations and scales higher in the graph node hierarchy). The scale is\n     * returned as a {@link Vec3}. The value returned by this function should be considered\n     * read-only. Note that it is not possible to set the world space scale of a graph node\n     * directly.\n     *\n     * @returns {Vec3} The world space scale of the graph node.\n     * @example\n     * var scale = this.entity.getScale();\n     * @ignore\n     */\n    getScale(): Vec3;\n    /**\n     * Get the world transformation matrix for this graph node.\n     *\n     * @returns {Mat4} The node\'s world transformation matrix.\n     * @example\n     * var transform = this.entity.getWorldTransform();\n     */\n    getWorldTransform(): Mat4;\n    /**\n     * Remove graph node from current parent and add as child to new parent.\n     *\n     * @param {GraphNode} parent - New parent to attach graph node to.\n     * @param {number} [index] - The child index where the child node should be placed.\n     */\n    reparent(parent: GraphNode, index?: number): void;\n    /**\n     * Sets the local-space rotation of the specified graph node using euler angles. Eulers are\n     * interpreted in XYZ order. Eulers must be specified in degrees. This function has two valid\n     * signatures: you can either pass a 3D vector or 3 numbers to specify the local-space euler\n     * rotation.\n     *\n     * @param {Vec3|number} x - 3-dimensional vector holding eulers or rotation around local-space\n     * x-axis in degrees.\n     * @param {number} [y] - Rotation around local-space y-axis in degrees.\n     * @param {number} [z] - Rotation around local-space z-axis in degrees.\n     * @example\n     * // Set rotation of 90 degrees around y-axis via 3 numbers\n     * this.entity.setLocalEulerAngles(0, 90, 0);\n     * @example\n     * // Set rotation of 90 degrees around y-axis via a vector\n     * var angles = new pc.Vec3(0, 90, 0);\n     * this.entity.setLocalEulerAngles(angles);\n     */\n    setLocalEulerAngles(x: Vec3 | number, y?: number, z?: number): void;\n    /**\n     * Sets the local-space position of the specified graph node. This function has two valid\n     * signatures: you can either pass a 3D vector or 3 numbers to specify the local-space\n     * position.\n     *\n     * @param {Vec3|number} x - 3-dimensional vector holding local-space position or\n     * x-coordinate of local-space position.\n     * @param {number} [y] - Y-coordinate of local-space position.\n     * @param {number} [z] - Z-coordinate of local-space position.\n     * @example\n     * // Set via 3 numbers\n     * this.entity.setLocalPosition(0, 10, 0);\n     * @example\n     * // Set via vector\n     * var pos = new pc.Vec3(0, 10, 0);\n     * this.entity.setLocalPosition(pos);\n     */\n    setLocalPosition(x: Vec3 | number, y?: number, z?: number): void;\n    /**\n     * Sets the local-space rotation of the specified graph node. This function has two valid\n     * signatures: you can either pass a quaternion or 3 numbers to specify the local-space\n     * rotation.\n     *\n     * @param {Quat|number} x - Quaternion holding local-space rotation or x-component of\n     * local-space quaternion rotation.\n     * @param {number} [y] - Y-component of local-space quaternion rotation.\n     * @param {number} [z] - Z-component of local-space quaternion rotation.\n     * @param {number} [w] - W-component of local-space quaternion rotation.\n     * @example\n     * // Set via 4 numbers\n     * this.entity.setLocalRotation(0, 0, 0, 1);\n     * @example\n     * // Set via quaternion\n     * var q = pc.Quat();\n     * this.entity.setLocalRotation(q);\n     */\n    setLocalRotation(x: Quat | number, y?: number, z?: number, w?: number): void;\n    /**\n     * Sets the local-space scale factor of the specified graph node. This function has two valid\n     * signatures: you can either pass a 3D vector or 3 numbers to specify the local-space scale.\n     *\n     * @param {Vec3|number} x - 3-dimensional vector holding local-space scale or x-coordinate\n     * of local-space scale.\n     * @param {number} [y] - Y-coordinate of local-space scale.\n     * @param {number} [z] - Z-coordinate of local-space scale.\n     * @example\n     * // Set via 3 numbers\n     * this.entity.setLocalScale(10, 10, 10);\n     * @example\n     * // Set via vector\n     * var scale = new pc.Vec3(10, 10, 10);\n     * this.entity.setLocalScale(scale);\n     */\n    setLocalScale(x: Vec3 | number, y?: number, z?: number): void;\n    /** @private */\n    private _dirtifyLocal;\n    /** @private */\n    private _unfreezeParentToRoot;\n    /** @private */\n    private _dirtifyWorld;\n    /** @private */\n    private _dirtifyWorldInternal;\n    /**\n     * Sets the world-space position of the specified graph node. This function has two valid\n     * signatures: you can either pass a 3D vector or 3 numbers to specify the world-space\n     * position.\n     *\n     * @param {Vec3|number} x - 3-dimensional vector holding world-space position or\n     * x-coordinate of world-space position.\n     * @param {number} [y] - Y-coordinate of world-space position.\n     * @param {number} [z] - Z-coordinate of world-space position.\n     * @example\n     * // Set via 3 numbers\n     * this.entity.setPosition(0, 10, 0);\n     * @example\n     * // Set via vector\n     * var position = new pc.Vec3(0, 10, 0);\n     * this.entity.setPosition(position);\n     */\n    setPosition(x: Vec3 | number, y?: number, z?: number): void;\n    /**\n     * Sets the world-space rotation of the specified graph node. This function has two valid\n     * signatures: you can either pass a quaternion or 3 numbers to specify the world-space\n     * rotation.\n     *\n     * @param {Quat|number} x - Quaternion holding world-space rotation or x-component of\n     * world-space quaternion rotation.\n     * @param {number} [y] - Y-component of world-space quaternion rotation.\n     * @param {number} [z] - Z-component of world-space quaternion rotation.\n     * @param {number} [w] - W-component of world-space quaternion rotation.\n     * @example\n     * // Set via 4 numbers\n     * this.entity.setRotation(0, 0, 0, 1);\n     * @example\n     * // Set via quaternion\n     * var q = pc.Quat();\n     * this.entity.setRotation(q);\n     */\n    setRotation(x: Quat | number, y?: number, z?: number, w?: number): void;\n    /**\n     * Sets the world-space rotation of the specified graph node using euler angles. Eulers are\n     * interpreted in XYZ order. Eulers must be specified in degrees. This function has two valid\n     * signatures: you can either pass a 3D vector or 3 numbers to specify the world-space euler\n     * rotation.\n     *\n     * @param {Vec3|number} x - 3-dimensional vector holding eulers or rotation around world-space\n     * x-axis in degrees.\n     * @param {number} [y] - Rotation around world-space y-axis in degrees.\n     * @param {number} [z] - Rotation around world-space z-axis in degrees.\n     * @example\n     * // Set rotation of 90 degrees around world-space y-axis via 3 numbers\n     * this.entity.setEulerAngles(0, 90, 0);\n     * @example\n     * // Set rotation of 90 degrees around world-space y-axis via a vector\n     * var angles = new pc.Vec3(0, 90, 0);\n     * this.entity.setEulerAngles(angles);\n     */\n    setEulerAngles(x: Vec3 | number, y?: number, z?: number): void;\n    /**\n     * Add a new child to the child list and update the parent value of the child node.\n     *\n     * @param {GraphNode} node - The new child to add.\n     * @example\n     * var e = new pc.Entity(app);\n     * this.entity.addChild(e);\n     */\n    addChild(node: GraphNode): void;\n    /**\n     * Add a child to this node, maintaining the child\'s transform in world space.\n     *\n     * @param {GraphNode} node - The child to add.\n     * @example\n     * var e = new pc.Entity(app);\n     * this.entity.addChildAndSaveTransform(e);\n     * @ignore\n     */\n    addChildAndSaveTransform(node: GraphNode): void;\n    /**\n     * Insert a new child to the child list at the specified index and update the parent value of\n     * the child node.\n     *\n     * @param {GraphNode} node - The new child to insert.\n     * @param {number} index - The index in the child list of the parent where the new node will be\n     * inserted.\n     * @example\n     * var e = new pc.Entity(app);\n     * this.entity.insertChild(e, 1);\n     */\n    insertChild(node: GraphNode, index: number): void;\n    /**\n     * @param {GraphNode} node - The node being inserted.\n     * @private\n     */\n    private _debugInsertChild;\n    /**\n     * Fires an event on all children of the node. The event `name` is fired on the first (root)\n     * node only. The event `nameHierarchy` is fired for all children.\n     *\n     * @param {string} name - The name of the event to fire on the root.\n     * @param {string} nameHierarchy - The name of the event to fire for all descendants.\n     * @param {GraphNode} parent - The parent of the node being added/removed from the hierarchy.\n     * @private\n     */\n    private _fireOnHierarchy;\n    /**\n     * Called when a node is inserted into a node\'s child list.\n     *\n     * @param {GraphNode} node - The node that was inserted.\n     * @private\n     */\n    private _onInsertChild;\n    /**\n     * Recurse the hierarchy and update the graph depth at each node.\n     *\n     * @private\n     */\n    private _updateGraphDepth;\n    /**\n     * Remove the node from the child list and update the parent value of the child.\n     *\n     * @param {GraphNode} child - The node to remove.\n     * @example\n     * var child = this.entity.children[0];\n     * this.entity.removeChild(child);\n     */\n    removeChild(child: GraphNode): void;\n    _sync(): void;\n    /**\n     * Updates the world transformation matrices at this node and all of its descendants.\n     *\n     * @ignore\n     */\n    syncHierarchy(): void;\n    /**\n     * Reorients the graph node so that the negative z-axis points towards the target. This\n     * function has two valid signatures. Either pass 3D vectors for the look at coordinate and up\n     * vector, or pass numbers to represent the vectors.\n     *\n     * @param {Vec3|number} x - If passing a 3D vector, this is the world-space coordinate to look at.\n     * Otherwise, it is the x-component of the world-space coordinate to look at.\n     * @param {Vec3|number} [y] - If passing a 3D vector, this is the world-space up vector for look at\n     * transform. Otherwise, it is the y-component of the world-space coordinate to look at.\n     * @param {number} [z] - Z-component of the world-space coordinate to look at.\n     * @param {number} [ux=0] - X-component of the up vector for the look at transform.\n     * @param {number} [uy=1] - Y-component of the up vector for the look at transform.\n     * @param {number} [uz=0] - Z-component of the up vector for the look at transform.\n     * @example\n     * // Look at another entity, using the (default) positive y-axis for up\n     * var position = otherEntity.getPosition();\n     * this.entity.lookAt(position);\n     * @example\n     * // Look at another entity, using the negative world y-axis for up\n     * var position = otherEntity.getPosition();\n     * this.entity.lookAt(position, pc.Vec3.DOWN);\n     * @example\n     * // Look at the world space origin, using the (default) positive y-axis for up\n     * this.entity.lookAt(0, 0, 0);\n     * @example\n     * // Look at world-space coordinate [10, 10, 10], using the negative world y-axis for up\n     * this.entity.lookAt(10, 10, 10, 0, -1, 0);\n     */\n    lookAt(x: Vec3 | number, y?: Vec3 | number, z?: number, ux?: number, uy?: number, uz?: number): void;\n    /**\n     * Translates the graph node in world-space by the specified translation vector. This function\n     * has two valid signatures: you can either pass a 3D vector or 3 numbers to specify the\n     * world-space translation.\n     *\n     * @param {Vec3|number} x - 3-dimensional vector holding world-space translation or\n     * x-coordinate of world-space translation.\n     * @param {number} [y] - Y-coordinate of world-space translation.\n     * @param {number} [z] - Z-coordinate of world-space translation.\n     * @example\n     * // Translate via 3 numbers\n     * this.entity.translate(10, 0, 0);\n     * @example\n     * // Translate via vector\n     * var t = new pc.Vec3(10, 0, 0);\n     * this.entity.translate(t);\n     */\n    translate(x: Vec3 | number, y?: number, z?: number): void;\n    /**\n     * Translates the graph node in local-space by the specified translation vector. This function\n     * has two valid signatures: you can either pass a 3D vector or 3 numbers to specify the\n     * local-space translation.\n     *\n     * @param {Vec3|number} x - 3-dimensional vector holding local-space translation or\n     * x-coordinate of local-space translation.\n     * @param {number} [y] - Y-coordinate of local-space translation.\n     * @param {number} [z] - Z-coordinate of local-space translation.\n     * @example\n     * // Translate via 3 numbers\n     * this.entity.translateLocal(10, 0, 0);\n     * @example\n     * // Translate via vector\n     * var t = new pc.Vec3(10, 0, 0);\n     * this.entity.translateLocal(t);\n     */\n    translateLocal(x: Vec3 | number, y?: number, z?: number): void;\n    /**\n     * Rotates the graph node in world-space by the specified Euler angles. Eulers are specified in\n     * degrees in XYZ order. This function has two valid signatures: you can either pass a 3D\n     * vector or 3 numbers to specify the world-space rotation.\n     *\n     * @param {Vec3|number} x - 3-dimensional vector holding world-space rotation or\n     * rotation around world-space x-axis in degrees.\n     * @param {number} [y] - Rotation around world-space y-axis in degrees.\n     * @param {number} [z] - Rotation around world-space z-axis in degrees.\n     * @example\n     * // Rotate via 3 numbers\n     * this.entity.rotate(0, 90, 0);\n     * @example\n     * // Rotate via vector\n     * var r = new pc.Vec3(0, 90, 0);\n     * this.entity.rotate(r);\n     */\n    rotate(x: Vec3 | number, y?: number, z?: number): void;\n    /**\n     * Rotates the graph node in local-space by the specified Euler angles. Eulers are specified in\n     * degrees in XYZ order. This function has two valid signatures: you can either pass a 3D\n     * vector or 3 numbers to specify the local-space rotation.\n     *\n     * @param {Vec3|number} x - 3-dimensional vector holding local-space rotation or\n     * rotation around local-space x-axis in degrees.\n     * @param {number} [y] - Rotation around local-space y-axis in degrees.\n     * @param {number} [z] - Rotation around local-space z-axis in degrees.\n     * @example\n     * // Rotate via 3 numbers\n     * this.entity.rotateLocal(0, 90, 0);\n     * @example\n     * // Rotate via vector\n     * var r = new pc.Vec3(0, 90, 0);\n     * this.entity.rotateLocal(r);\n     */\n    rotateLocal(x: Vec3 | number, y?: number, z?: number): void;\n}\n\n\n\n/**\n * A skin instance is responsible for generating the matrix palette that is used to skin vertices\n * from object space to world space.\n */\ndeclare class SkinInstance {\n    /**\n     * Create a new SkinInstance instance.\n     *\n     * @param {Skin} skin - The skin that will provide the inverse bind pose matrices to generate\n     * the final matrix palette.\n     */\n    constructor(skin: Skin);\n    /**\n     * An array of nodes representing each bone in this skin instance.\n     *\n     * @type {GraphNode[]}\n     */\n    bones: GraphNode[];\n    _dirty: boolean;\n    _rootBone: any;\n    _skinUpdateIndex: number;\n    _updateBeforeCull: boolean;\n    set rootBone(arg: any);\n    get rootBone(): any;\n    init(device: any, numBones: any): void;\n    boneTexture: Texture;\n    matrixPalette: Uint8Array | Uint16Array | Float32Array;\n    destroy(): void;\n    resolve(rootBone: any, entity: any): void;\n    initSkin(skin: any): void;\n    skin: any;\n    matrices: any[];\n    uploadBones(device: any): void;\n    _updateMatrices(rootNode: any, skinUpdateIndex: any): void;\n    updateMatrices(rootNode: any, skinUpdateIndex: any): void;\n    updateMatrixPalette(rootNode: any, skinUpdateIndex: any): void;\n}\n\n/**\n * A Morph Target (also known as Blend Shape) contains deformation data to apply to existing mesh.\n * Multiple morph targets can be blended together on a mesh. This is useful for effects that are\n * hard to achieve with conventional animation and skinning.\n */\ndeclare class MorphTarget {\n    /**\n     * Create a new MorphTarget instance.\n     *\n     * @param {object} options - Object for passing optional arguments.\n     * @param {ArrayBuffer} options.deltaPositions - An array of 3-dimensional vertex position\n     * offsets.\n     * @param {number} options.deltaPositionsType - A format to store position offsets inside\n     * {@link VertexBuffer}. Defaults to {@link TYPE_FLOAT32} if not provided.\n     * @param {ArrayBuffer} [options.deltaNormals] - An array of 3-dimensional vertex normal\n     * offsets.\n     * @param {number} options.deltaNormalsType - A format to store normal offsets inside\n     * {@link VertexBuffer}. Defaults to {@link TYPE_FLOAT32} if not provided.\n     * @param {string} [options.name] - Name.\n     * @param {BoundingBox} [options.aabb] - Bounding box. Will be automatically generated, if\n     * undefined.\n     * @param {number} [options.defaultWeight] - Default blend weight to use for this morph target.\n     */\n    constructor(options: {\n        deltaPositions: ArrayBuffer;\n        deltaPositionsType: number;\n        deltaNormals?: ArrayBuffer;\n        deltaNormalsType: number;\n        name?: string;\n        aabb?: BoundingBox;\n        defaultWeight?: number;\n    }, ...args: any[]);\n    options: {\n        deltaPositions: ArrayBuffer;\n        deltaPositionsType: number;\n        deltaNormals?: ArrayBuffer;\n        deltaNormalsType: number;\n        name?: string;\n        aabb?: BoundingBox;\n        defaultWeight?: number;\n    };\n    _name: string;\n    _defaultWeight: number;\n    aabb: BoundingBox;\n    deltaPositions: ArrayBuffer;\n    /**\n     * The name of the morph target.\n     *\n     * @type {string}\n     */\n    get name(): string;\n    /**\n     * The default weight of the morph target.\n     *\n     * @type {number}\n     */\n    get defaultWeight(): number;\n    get morphPositions(): boolean;\n    get morphNormals(): boolean;\n    _postInit(): void;\n    _initVertexBuffers(graphicsDevice: any): void;\n    _vertexBufferPositions: VertexBuffer;\n    _vertexBufferNormals: VertexBuffer;\n    _createVertexBuffer(device: any, data: any, dataType?: number): VertexBuffer;\n    _setTexture(name: any, texture: any): void;\n    destroy(): void;\n    texturePositions: any;\n    textureNormals: any;\n}\n\n/**\n * Base class that implements reference counting for objects.\n *\n * @ignore\n */\ndeclare class RefCountedObject {\n    /**\n     * @type {number}\n     * @private\n     */\n    private _refCount;\n    /**\n     * Increments the reference counter.\n     */\n    incRefCount(): void;\n    /**\n     * Decrements the reference counter.\n     */\n    decRefCount(): void;\n    /**\n     * The current reference count.\n     *\n     * @type {number}\n     */\n    get refCount(): number;\n}\n\n\n\n/**\n * Contains a list of {@link MorphTarget}, a combined delta AABB and some associated data.\n */\ndeclare class Morph extends RefCountedObject {\n    static FORMAT_FLOAT: number;\n    static FORMAT_HALF_FLOAT: number;\n    /**\n     * Create a new Morph instance.\n     *\n     * @param {MorphTarget[]} targets - A list of morph targets.\n     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this morph\n     * target. If it is not provided, a device is obtained from the {@link Application}.\n     */\n    constructor(targets: MorphTarget[], graphicsDevice: GraphicsDevice);\n    device: any;\n    _targets: MorphTarget[];\n    _renderTextureFormat: number;\n    _textureFormat: number;\n    _useTextureMorph: boolean;\n    get morphPositions(): boolean;\n    get morphNormals(): boolean;\n    get maxActiveTargets(): number;\n    get useTextureMorph(): boolean;\n    _init(): void;\n    _initTextureBased(): boolean;\n    morphTextureWidth: number;\n    morphTextureHeight: number;\n    vertexBufferIds: VertexBuffer;\n    /**\n     * Frees video memory allocated by this object.\n     */\n    destroy(): void;\n    /**\n     * The array of morph targets.\n     *\n     * @type {MorphTarget[]}\n     */\n    get targets(): MorphTarget[];\n    _updateMorphFlags(): void;\n    _morphPositions: boolean;\n    _morphNormals: boolean;\n    _calculateAabb(): void;\n    aabb: BoundingBox;\n    _createTexture(name: any, format: any, pixelData: any): Texture;\n}\n\n\n/**\n * An instance of {@link Morph}. Contains weights to assign to every {@link MorphTarget}, manages\n * selection of active morph targets.\n */\ndeclare class MorphInstance {\n    /**\n     * Create a new MorphInstance instance.\n     *\n     * @param {Morph} morph - The {@link Morph} to instance.\n     */\n    constructor(morph: Morph);\n    /**\n     * The morph with its targets, which is being instanced.\n     *\n     * @type {Morph}\n     */\n    morph: Morph;\n    device: any;\n    /**\n     * The mesh instance this morph instance controls the morphing of.\n     *\n     * @type {MeshInstance}\n     */\n    meshInstance: MeshInstance;\n    _weights: any[];\n    _activeTargets: any[];\n    shaderCache: {};\n    maxSubmitCount: any;\n    _shaderMorphWeights: Float32Array;\n    rtPositions: RenderTarget;\n    rtNormals: RenderTarget;\n    _textureParams: Float32Array;\n    morphFactor: any;\n    zeroTextures: boolean;\n    _shaderMorphWeightsA: Float32Array;\n    _shaderMorphWeightsB: Float32Array;\n    _activeVertexBuffers: any[];\n    /**\n     * Frees video memory allocated by this object.\n     */\n    destroy(): void;\n    shader: any;\n    texturePositions: any;\n    textureNormals: any;\n    /**\n     * Clones a MorphInstance. The returned clone uses the same {@link Morph} and weights are set\n     * to defaults.\n     *\n     * @returns {MorphInstance} A clone of the specified MorphInstance.\n     */\n    clone(): MorphInstance;\n    /**\n     * Gets current weight of the specified morph target.\n     *\n     * @param {number} index - An index of morph target.\n     * @returns {number} Weight.\n     */\n    getWeight(index: number): number;\n    /**\n     * Sets weight of the specified morph target.\n     *\n     * @param {number} index - An index of morph target.\n     * @param {number} weight - Weight.\n     */\n    setWeight(index: number, weight: number): void;\n    _dirty: boolean;\n    /**\n     * Generate fragment shader to blend a number of textures using specified weights.\n     *\n     * @param {number} numTextures - Number of textures to blend.\n     * @returns {string} Fragment shader.\n     * @private\n     */\n    private _getFragmentShader;\n    /**\n     * Create complete shader for texture based morphing.\n     *\n     * @param {number} count - Number of textures to blend.\n     * @returns {Shader} Shader.\n     * @private\n     */\n    private _getShader;\n    _updateTextureRenderTarget(renderTarget: any, srcTextureName: any): void;\n    _updateTextureMorph(): void;\n    _updateVertexMorph(): void;\n    /**\n     * Selects active morph targets and prepares morph for rendering. Called automatically by\n     * renderer.\n     */\n    update(): void;\n}\n\n\n\n/**\n * A graphical primitive. The mesh is defined by a {@link VertexBuffer} and an optional\n * {@link IndexBuffer}. It also contains a primitive definition which controls the type of the\n * primitive and the portion of the vertex or index buffer to use.\n *\n * ## Mesh APIs\n * There are two ways a mesh can be generated or updated.\n *\n * ### Simple Mesh API\n * {@link Mesh} class provides interfaces such as {@link Mesh#setPositions} and {@link Mesh#setUvs}\n * that provide a simple way to provide vertex and index data for the Mesh, and hiding the\n * complexity of creating the {@link VertexFormat}. This is the recommended interface to use.\n *\n * A simple example which creates a Mesh with 3 vertices, containing position coordinates only, to\n * form a single triangle.\n *\n * ```javascript\n * var mesh = new pc.Mesh(device);\n * var positions = [\n *     0, 0, 0, // pos 0\n *     1, 0, 0, // pos 1\n *     1, 1, 0  // pos 2\n * ];\n * mesh.setPositions(positions);\n * mesh.update();\n * ```\n *\n * An example which creates a Mesh with 4 vertices, containing position and uv coordinates in\n * channel 0, and an index buffer to form two triangles. Float32Array is used for positions and uvs.\n *\n * ```javascript\n * var mesh = new pc.Mesh(device);\n * var positions = new Float32Array([\n *     0, 0, 0, // pos 0\n *     1, 0, 0, // pos 1\n *     1, 1, 0, // pos 2\n *     0, 1, 0  // pos 3\n * ]);\n * var uvs = new Float32Array([\n *     0, 0, // uv 0\n *     1, 0, // uv 1\n *     1, 1, // uv 2\n *     0, 1  // uv 3\n * ]);\n * var indices = [\n *     0, 1, 2, // triangle 0\n *     0, 2, 3  // triangle 1\n * ];\n * mesh.setPositions(positions);\n * mesh.setUvs(0, uvs);\n * mesh.setIndices(indices);\n * mesh.update();\n * ```\n *\n * This example demonstrates that vertex attributes such as position and normals, and also indices\n * can be provided using Arrays ([]) and also Typed Arrays (Float32Array and similar). Note that\n * typed arrays have higher performance, and are generally recommended for per-frame operations or\n * larger meshes, but their construction using new operator is costly operation. If you only need\n * to operate on a small number of vertices or indices, consider using Arrays to avoid the overhead\n * associated with allocating Typed Arrays.\n *\n * Follow these links for more complex examples showing the functionality.\n *\n * - {@link http://playcanvas.github.io/#graphics/mesh-decals}\n * - {@link http://playcanvas.github.io/#graphics/mesh-deformation}\n * - {@link http://playcanvas.github.io/#graphics/mesh-generation}\n * - {@link http://playcanvas.github.io/#graphics/point-cloud-simulation}\n *\n * ### Update Vertex and Index buffers\n * This allows greater flexibility, but is more complex to use. It allows more advanced setups, for\n * example sharing a Vertex or Index Buffer between multiple meshes. See {@link VertexBuffer},\n * {@link IndexBuffer} and {@link VertexFormat} for details.\n */\ndeclare class Mesh extends RefCountedObject {\n    /**\n     * Create a new Mesh instance.\n     *\n     * @param {GraphicsDevice} [graphicsDevice] - The graphics device used to manage this mesh. If\n     * it is not provided, a device is obtained from the {@link Application}.\n     */\n    constructor(graphicsDevice?: GraphicsDevice);\n    id: number;\n    device: any;\n    /**\n     * The vertex buffer holding the vertex data of the mesh.\n     *\n     * @type {VertexBuffer}\n     */\n    vertexBuffer: VertexBuffer;\n    /**\n     * An array of index buffers. For unindexed meshes, this array can be empty. The first\n     * index buffer in the array is used by {@link MeshInstance}s with a renderStyle property\n     * set to {@link RENDERSTYLE_SOLID}. The second index buffer in the array is used if\n     * renderStyle is set to {@link RENDERSTYLE_WIREFRAME}.\n     *\n     * @type {IndexBuffer[]}\n     */\n    indexBuffer: IndexBuffer[];\n    /**\n     * Array of primitive objects defining how vertex (and index) data in the mesh should be\n     * interpreted by the graphics device.\n     *\n     * - `type` is the type of primitive to render. Can be:\n     *\n     *   - {@link PRIMITIVE_POINTS}\n     *   - {@link PRIMITIVE_LINES}\n     *   - {@link PRIMITIVE_LINELOOP}\n     *   - {@link PRIMITIVE_LINESTRIP}\n     *   - {@link PRIMITIVE_TRIANGLES}\n     *   - {@link PRIMITIVE_TRISTRIP}\n     *   - {@link PRIMITIVE_TRIFAN}\n     *\n     * - `base` is the offset of the first index or vertex to dispatch in the draw call.\n     * - `count` is the number of indices or vertices to dispatch in the draw call.\n     * - `indexed` specifies whether to interpret the primitive as indexed, thereby using the\n     * currently set index buffer.\n     *\n     * @type {Array.<{type: number, base: number, count: number, indexed: boolean|undefined}>}\n     */\n    primitive: {\n        type: number;\n        base: number;\n        count: number;\n        indexed: boolean | undefined;\n    }[];\n    /**\n     * The skin data (if any) that drives skinned mesh animations for this mesh.\n     *\n     * @type {Skin|null}\n     */\n    skin: Skin | null;\n    _morph: any;\n    _geometryData: GeometryData;\n    _aabb: BoundingBox;\n    boneAabb: any[];\n    /**\n     * The morph data (if any) that drives morph target animations for this mesh.\n     *\n     * @type {Morph|null}\n     */\n    set morph(arg: any);\n    get morph(): any;\n    /**\n     * The axis-aligned bounding box for the object space vertices of this mesh.\n     *\n     * @type {BoundingBox}\n     */\n    set aabb(arg: BoundingBox);\n    get aabb(): BoundingBox;\n    /**\n     * Destroys {@link VertexBuffer} and {@link IndexBuffer} associate with the mesh. This is\n     * normally called by {@link Model#destroy} and does not need to be called manually.\n     */\n    destroy(): void;\n    _destroyIndexBuffer(index: any): void;\n    _initBoneAabbs(morphTargets: any): void;\n    boneUsed: any[];\n    _initGeometryData(): void;\n    /**\n     * Clears the mesh of existing vertices and indices and resets the {@link VertexFormat}\n     * associated with the mesh. This call is typically followed by calls to methods such as\n     * {@link Mesh#setPositions}, {@link Mesh#setVertexStream} or {@link Mesh#setIndices} and\n     * finally {@link Mesh#update} to rebuild the mesh, allowing different {@link VertexFormat}.\n     *\n     * @param {boolean} [verticesDynamic] - Indicates the {@link VertexBuffer} should be created\n     * with {@link BUFFER_DYNAMIC} usage. If not specified, {@link BUFFER_STATIC} is used.\n     * @param {boolean} [indicesDynamic] - Indicates the {@link IndexBuffer} should be created with\n     * {@link BUFFER_DYNAMIC} usage. If not specified, {@link BUFFER_STATIC} is used.\n     * @param {number} [maxVertices] - A {@link VertexBuffer} will be allocated with at least\n     * maxVertices, allowing additional vertices to be added to it without the allocation. If no\n     * value is provided, a size to fit the provided vertices will be allocated.\n     * @param {number} [maxIndices] - An {@link IndexBuffer} will be allocated with at least\n     * maxIndices, allowing additional indices to be added to it without the allocation. If no\n     * value is provided, a size to fit the provided indices will be allocated.\n     */\n    clear(verticesDynamic?: boolean, indicesDynamic?: boolean, maxVertices?: number, maxIndices?: number): void;\n    /**\n     * Sets the vertex data for any supported semantic.\n     *\n     * @param {string} semantic - The meaning of the vertex element. For supported semantics, see\n     * SEMANTIC_* in {@link VertexFormat}.\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - Vertex\n     * data for the specified semantic.\n     * @param {number} componentCount - The number of values that form a single Vertex element. For\n     * example when setting a 3D position represented by 3 numbers per vertex, number 3 should be\n     * specified.\n     * @param {number} [numVertices] - The number of vertices to be used from data array. If not\n     * provided, the whole data array is used. This allows to use only part of the data array.\n     * @param {number} [dataType] - The format of data when stored in the {@link VertexBuffer}, see\n     * TYPE_* in {@link VertexFormat}. When not specified, {@link TYPE_FLOAT32} is used.\n     * @param {boolean} [dataTypeNormalize] - If true, vertex attribute data will be mapped from a\n     * 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data is left\n     * unchanged. If this property is unspecified, false is assumed.\n     */\n    setVertexStream(semantic: string, data: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount: number, numVertices?: number, dataType?: number, dataTypeNormalize?: boolean): void;\n    /**\n     * Gets the vertex data corresponding to a semantic.\n     *\n     * @param {string} semantic - The semantic of the vertex element to get. For supported\n     * semantics, see SEMANTIC_* in {@link VertexFormat}.\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - An\n     * array to populate with the vertex data. When typed array is supplied, enough space needs to\n     * be reserved, otherwise only partial data is copied.\n     * @returns {number} Returns the number of vertices populated.\n     */\n    getVertexStream(semantic: string, data: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;\n    /**\n     * Sets the vertex positions array. Vertices are stored using {@link TYPE_FLOAT32} format.\n     *\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} positions - Vertex\n     * data containing positions.\n     * @param {number} [componentCount] - The number of values that form a single position element.\n     * Defaults to 3 if not specified, corresponding to x, y and z coordinates.\n     * @param {number} [numVertices] - The number of vertices to be used from data array. If not\n     * provided, the whole data array is used. This allows to use only part of the data array.\n     */\n    setPositions(positions: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount?: number, numVertices?: number): void;\n    /**\n     * Sets the vertex normals array. Normals are stored using {@link TYPE_FLOAT32} format.\n     *\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} normals - Vertex\n     * data containing normals.\n     * @param {number} [componentCount] - The number of values that form a single normal element.\n     * Defaults to 3 if not specified, corresponding to x, y and z direction.\n     * @param {number} [numVertices] - The number of vertices to be used from data array. If not\n     * provided, the whole data array is used. This allows to use only part of the data array.\n     */\n    setNormals(normals: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount?: number, numVertices?: number): void;\n    /**\n     * Sets the vertex uv array. Uvs are stored using {@link TYPE_FLOAT32} format.\n     *\n     * @param {number} channel - The uv channel in [0..7] range.\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} uvs - Vertex\n     * data containing uv-coordinates.\n     * @param {number} [componentCount] - The number of values that form a single uv element.\n     * Defaults to 2 if not specified, corresponding to u and v coordinates.\n     * @param {number} [numVertices] - The number of vertices to be used from data array. If not\n     * provided, the whole data array is used. This allows to use only part of the data array.\n     */\n    setUvs(channel: number, uvs: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount?: number, numVertices?: number): void;\n    /**\n     * Sets the vertex color array. Colors are stored using {@link TYPE_FLOAT32} format, which is\n     * useful for HDR colors.\n     *\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} colors - Vertex\n     * data containing colors.\n     * @param {number} [componentCount] - The number of values that form a single color element.\n     * Defaults to 4 if not specified, corresponding to r, g, b and a.\n     * @param {number} [numVertices] - The number of vertices to be used from data array. If not\n     * provided, the whole data array is used. This allows to use only part of the data array.\n     */\n    setColors(colors: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount?: number, numVertices?: number): void;\n    /**\n     * Sets the vertex color array. Colors are stored using {@link TYPE_UINT8} format, which is\n     * useful for LDR colors. Values in the array are expected in [0..255] range, and are mapped to\n     * [0..1] range in the shader.\n     *\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} colors - Vertex\n     * data containing colors. The array is expected to contain 4 components per vertex,\n     * corresponding to r, g, b and a.\n     * @param {number} [numVertices] - The number of vertices to be used from data array. If not\n     * provided, the whole data array is used. This allows to use only part of the data array.\n     */\n    setColors32(colors: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, numVertices?: number): void;\n    /**\n     * Sets the index array. Indices are stored using 16-bit format by default, unless more than\n     * 65535 vertices are specified, in which case 32-bit format is used.\n     *\n     * @param {number[]|Uint8Array|Uint16Array|Uint32Array} indices - The array of indices that\n     * define primitives (lines, triangles, etc.).\n     * @param {number} [numIndices] - The number of indices to be used from data array. If not\n     * provided, the whole data array is used. This allows to use only part of the data array.\n     */\n    setIndices(indices: number[] | Uint8Array | Uint16Array | Uint32Array, numIndices?: number): void;\n    /**\n     * Gets the vertex positions data.\n     *\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} positions - An\n     * array to populate with the vertex data. When typed array is supplied, enough space needs to\n     * be reserved, otherwise only partial data is copied.\n     * @returns {number} Returns the number of vertices populated.\n     */\n    getPositions(positions: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;\n    /**\n     * Gets the vertex normals data.\n     *\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} normals - An\n     * array to populate with the vertex data. When typed array is supplied, enough space needs to\n     * be reserved, otherwise only partial data is copied.\n     * @returns {number} Returns the number of vertices populated.\n     */\n    getNormals(normals: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;\n    /**\n     * Gets the vertex uv data.\n     *\n     * @param {number} channel - The uv channel in [0..7] range.\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} uvs - An\n     * array to populate with the vertex data. When typed array is supplied, enough space needs to\n     * be reserved, otherwise only partial data is copied.\n     * @returns {number} Returns the number of vertices populated.\n     */\n    getUvs(channel: number, uvs: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;\n    /**\n     * Gets the vertex color data.\n     *\n     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} colors - An\n     * array to populate with the vertex data. When typed array is supplied, enough space needs to\n     * be reserved, otherwise only partial data is copied.\n     * @returns {number} Returns the number of vertices populated.\n     */\n    getColors(colors: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;\n    /**\n     * Gets the index data.\n     *\n     * @param {number[]|Uint8Array|Uint16Array|Uint32Array} indices - An array to populate with the\n     * index data. When a typed array is supplied, enough space needs to be reserved, otherwise\n     * only partial data is copied.\n     * @returns {number} Returns the number of indices populated.\n     */\n    getIndices(indices: number[] | Uint8Array | Uint16Array | Uint32Array): number;\n    /**\n     * Applies any changes to vertex stream and indices to mesh. This allocates or reallocates\n     * {@link vertexBuffer} or {@link IndexBuffer} to fit all provided vertices and indices, and\n     * fills them with data.\n     *\n     * @param {number} [primitiveType] - The type of primitive to render.  Can be:\n     *\n     * - {@link PRIMITIVE_POINTS}\n     * - {@link PRIMITIVE_LINES}\n     * - {@link PRIMITIVE_LINELOOP}\n     * - {@link PRIMITIVE_LINESTRIP}\n     * - {@link PRIMITIVE_TRIANGLES}\n     * - {@link PRIMITIVE_TRISTRIP}\n     * - {@link PRIMITIVE_TRIFAN}\n     *\n     * Defaults to {@link PRIMITIVE_TRIANGLES} if unspecified.\n     * @param {boolean} [updateBoundingBox] - True to update bounding box. Bounding box is updated\n     * only if positions were set since last time update was called, and componentCount for\n     * position was 3, otherwise bounding box is not updated. See {@link Mesh#setPositions}.\n     * Defaults to true if unspecified. Set this to false to avoid update of the bounding box and\n     * use aabb property to set it instead.\n     */\n    update(primitiveType?: number, updateBoundingBox?: boolean): void;\n    _buildVertexFormat(vertexCount: any): VertexFormat;\n    _updateVertexBuffer(): void;\n    _updateIndexBuffer(): void;\n    prepareRenderState(renderStyle: any): void;\n    updateRenderStates(): void;\n    generateWireframe(): void;\n}\n\ndeclare class GeometryData {\n    static DEFAULT_COMPONENTS_POSITION: number;\n    static DEFAULT_COMPONENTS_NORMAL: number;\n    static DEFAULT_COMPONENTS_UV: number;\n    static DEFAULT_COMPONENTS_COLORS: number;\n    initDefaults(): void;\n    recreate: boolean;\n    verticesUsage: number;\n    indicesUsage: number;\n    maxVertices: number;\n    maxIndices: number;\n    vertexCount: any;\n    indexCount: number;\n    vertexStreamsUpdated: boolean;\n    indexStreamUpdated: boolean;\n    vertexStreamDictionary: {};\n    indices: any;\n    _changeVertexCount(count: any, semantic: any): void;\n}\n\n\n/**\n * A material determines how a particular mesh instance is rendered. It specifies the shader and\n * render state that is set before the mesh instance is submitted to the graphics device.\n *\n * @property {number} alphaTest The alpha test reference value to control which fragments are\n * written to the currently active render target based on alpha value. All fragments with an alpha\n * value of less than the alphaTest reference value will be discarded. alphaTest defaults to 0 (all\n * fragments pass).\n * @property {boolean} alphaToCoverage Enables or disables alpha to coverage (WebGL2 only). When\n * enabled, and if hardware anti-aliasing is on, limited order-independent transparency can be\n * achieved. Quality depends on the number of MSAA samples of the current render target.\n * It can nicely soften edges of otherwise sharp alpha cutouts, but isn\'t recommended for large\n * area semi-transparent surfaces. Note, that you don\'t need to enable blending to make alpha to\n * coverage work. It will work without it, just like alphaTest.\n * @property {boolean} alphaWrite If true, the alpha component of fragments generated by the shader\n * of this material is written to the color buffer of the currently active render target. If false,\n * the alpha component will not be written. Defaults to true.\n * @property {number} blendType Controls how primitives are blended when being written to the\n * currently active render target. Can be:\n *\n * - {@link BLEND_SUBTRACTIVE}: Subtract the color of the source fragment from the destination\n * fragment and write the result to the frame buffer.\n * - {@link BLEND_ADDITIVE}: Add the color of the source fragment to the destination fragment and\n * write the result to the frame buffer.\n * - {@link BLEND_NORMAL}: Enable simple translucency for materials such as glass. This is\n * equivalent to enabling a source blend mode of {@link BLENDMODE_SRC_ALPHA} and a destination\n * blend mode of {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.\n * - {@link BLEND_NONE}: Disable blending.\n * - {@link BLEND_PREMULTIPLIED}: Similar to {@link BLEND_NORMAL} expect the source fragment is\n * assumed to have already been multiplied by the source alpha value.\n * - {@link BLEND_MULTIPLICATIVE}: Multiply the color of the source fragment by the color of the\n * destination fragment and write the result to the frame buffer.\n * - {@link BLEND_ADDITIVEALPHA}: Same as {@link BLEND_ADDITIVE} except the source RGB is\n * multiplied by the source alpha.\n * - {@link BLEND_MULTIPLICATIVE2X}: Multiplies colors and doubles the result.\n * - {@link BLEND_SCREEN}: Softer version of additive.\n * - {@link BLEND_MIN}: Minimum color. Check app.graphicsDevice.extBlendMinmax for support.\n * - {@link BLEND_MAX}: Maximum color. Check app.graphicsDevice.extBlendMinmax for support.\n *\n * Defaults to {@link BLEND_NONE}.\n * @property {boolean} blueWrite If true, the blue component of fragments generated by the shader\n * of this material is written to the color buffer of the currently active render target. If false,\n * the blue component will not be written. Defaults to true.\n * @property {number} cull Controls how triangles are culled based on their face direction with\n * respect to the viewpoint. Can be:\n *\n * - {@link CULLFACE_NONE}: Do not cull triangles based on face direction.\n * - {@link CULLFACE_BACK}: Cull the back faces of triangles (do not render triangles facing away\n * from the view point).\n * - {@link CULLFACE_FRONT}: Cull the front faces of triangles (do not render triangles facing\n * towards the view point).\n * - {@link CULLFACE_FRONTANDBACK}: Cull both front and back faces (triangles will not be\n * rendered).\n *\n * Defaults to {@link CULLFACE_BACK}.\n * @property {boolean} depthTest If true, fragments generated by the shader of this material are\n * only written to the current render target if they pass the depth test. If false, fragments\n * generated by the shader of this material are written to the current render target regardless of\n * what is in the depth buffer. Defaults to true.\n * @property {number} depthFunc Controls how the depth of new fragments is compared against the\n * current depth contained in the depth buffer. Can be:\n *\n * - {@link FUNC_NEVER}: don\'t draw\n * - {@link FUNC_LESS}: draw if new depth < depth buffer\n * - {@link FUNC_EQUAL}: draw if new depth == depth buffer\n * - {@link FUNC_LESSEQUAL}: draw if new depth <= depth buffer\n * - {@link FUNC_GREATER}: draw if new depth > depth buffer\n * - {@link FUNC_NOTEQUAL}: draw if new depth != depth buffer\n * - {@link FUNC_GREATEREQUAL}: draw if new depth >= depth buffer\n * - {@link FUNC_ALWAYS}: always draw\n *\n * Defaults to {@link FUNC_LESSEQUAL}.\n * @property {boolean} depthWrite If true, fragments generated by the shader of this material write\n * a depth value to the depth buffer of the currently active render target. If false, no depth\n * value is written. Defaults to true.\n * @property {boolean} greenWrite If true, the green component of fragments generated by the shader\n * of this material is written to the color buffer of the currently active render target. If false,\n * the green component will not be written. Defaults to true.\n * @property {string} name The name of the material.\n * @property {boolean} redWrite If true, the red component of fragments generated by the shader of\n * this material is written to the color buffer of the currently active render target. If false,\n * the red component will not be written. Defaults to true.\n * @property {Shader|null} shader The shader used by this material to render mesh instances\n * (default is null).\n * @property {StencilParameters|null} stencilFront Stencil parameters for front faces (default is\n * null).\n * @property {StencilParameters|null} stencilBack Stencil parameters for back faces (default is\n * null).\n * @property {number} depthBias Offsets the output depth buffer value. Useful for decals to prevent\n * z-fighting.\n * @property {number} slopeDepthBias Same as {@link Material#depthBias}, but also depends on the\n * slope of the triangle relative to the camera.\n */\ndeclare class Material {\n    name: string;\n    id: number;\n    _shader: any;\n    variants: {};\n    parameters: {};\n    alphaTest: number;\n    alphaToCoverage: boolean;\n    blend: boolean;\n    blendSrc: number;\n    blendDst: number;\n    blendEquation: number;\n    separateAlphaBlend: boolean;\n    blendSrcAlpha: number;\n    blendDstAlpha: number;\n    blendAlphaEquation: number;\n    cull: number;\n    depthTest: boolean;\n    depthFunc: number;\n    depthWrite: boolean;\n    stencilFront: any;\n    stencilBack: any;\n    depthBias: number;\n    slopeDepthBias: number;\n    redWrite: boolean;\n    greenWrite: boolean;\n    blueWrite: boolean;\n    alphaWrite: boolean;\n    meshInstances: any[];\n    _shaderVersion: number;\n    _scene: any;\n    _dirtyBlend: boolean;\n    dirty: boolean;\n    set shader(arg: any);\n    get shader(): any;\n    get transparent(): boolean;\n    set blendType(arg: number);\n    get blendType(): number;\n    /**\n     * Copy a material.\n     *\n     * @param {Material} source - The material to copy.\n     * @returns {Material} The destination material.\n     */\n    copy(source: Material): Material;\n    /**\n     * Clone a material.\n     *\n     * @returns {this} A newly cloned material.\n     */\n    clone(): this;\n    _updateMeshInstanceKeys(): void;\n    updateUniforms(device: any, scene: any): void;\n    updateShader(device: any, scene: any, objDefs: any, staticLightList: any, pass: any, sortedLights: any): void;\n    /**\n     * Applies any changes made to the material\'s properties.\n     */\n    update(): void;\n    clearParameters(): void;\n    getParameters(): {};\n    clearVariants(): void;\n    /**\n     * Retrieves the specified shader parameter from a material.\n     *\n     * @param {string} name - The name of the parameter to query.\n     * @returns {object} The named parameter.\n     */\n    getParameter(name: string): object;\n    /**\n     * Sets a shader parameter on a material.\n     *\n     * @param {string} name - The name of the parameter to set.\n     * @param {number|number[]|Float32Array|Texture} data - The value for the specified parameter.\n     */\n    setParameter(name: string, data: number | number[] | Float32Array | Texture): void;\n    /**\n     * Deletes a shader parameter on a material.\n     *\n     * @param {string} name - The name of the parameter to delete.\n     */\n    deleteParameter(name: string): void;\n    setParameters(device: any, names: any): void;\n    /**\n     * Removes this material from the scene and possibly frees up memory from its shaders (if there\n     * are no other materials using it).\n     */\n    destroy(): void;\n    addMeshInstanceRef(meshInstance: any): void;\n    removeMeshInstanceRef(meshInstance: any): void;\n}\n\n\n\n\n\ndeclare class Command {\n    constructor(layer: any, blendType: any, command: any);\n    _key: number[];\n    command: any;\n    set key(arg: number);\n    get key(): number;\n}\n/**\n * Callback used by {@link Layer} to calculate the "sort distance" for a {@link MeshInstance},\n * which determines its place in the render order.\n *\n * @callback CalculateSortDistanceCallback\n * @param {MeshInstance} meshInstance - The mesh instance.\n * @param {Vec3} cameraPosition - The position of the camera.\n * @param {Vec3} cameraForward - The forward vector of the camera.\n */\n/**\n * An instance of a {@link Mesh}. A single mesh can be referenced by many mesh instances that can\n * have different transforms and materials.\n */\ndeclare class MeshInstance {\n    static lightmapParamNames: string[];\n    static _prepareRenderStyleForArray(meshInstances: any, renderStyle: any): void;\n    /**\n     * Create a new MeshInstance instance.\n     *\n     * @param {Mesh} mesh - The graphics mesh to instance.\n     * @param {Material} material - The material to use for this mesh instance.\n     * @param {GraphNode} [node] - The graph node defining the transform for this instance. This\n     * parameter is optional when used with {@link RenderComponent} and will use the node the\n     * component is attached to.\n     * @example\n     * // Create a mesh instance pointing to a 1x1x1 \'cube\' mesh\n     * var mesh = pc.createBox(graphicsDevice);\n     * var material = new pc.StandardMaterial();\n     *\n     * var meshInstance = new pc.MeshInstance(mesh, material);\n     *\n     * var entity = new pc.Entity();\n     * entity.addComponent(\'render\', {\n     *     meshInstances: [meshInstance]\n     * });\n     *\n     * // Add the entity to the scene hierarchy\n     * this.app.scene.root.addChild(entity);\n     */\n    constructor(mesh: Mesh, material: Material, node?: GraphNode);\n    /**\n     * @type {Material}\n     * @private\n     */\n    private _material;\n    _key: number[];\n    _shader: any[];\n    isStatic: boolean;\n    _staticLightList: any;\n    _staticSource: any;\n    /**\n     * The graph node defining the transform for this instance.\n     *\n     * @type {GraphNode}\n     */\n    node: GraphNode;\n    _mesh: Mesh;\n    /**\n     * The material used by this mesh instance.\n     *\n     * @type {Material}\n     */\n    set material(arg: Material);\n    get material(): Material;\n    _shaderDefs: number;\n    _lightHash: number;\n    /**\n     * Enable rendering for this mesh instance. Use visible property to enable/disable\n     * rendering without overhead of removing from scene. But note that the mesh instance is\n     * still in the hierarchy and still in the draw call list.\n     *\n     * @type {boolean}\n     */\n    visible: boolean;\n    set layer(arg: any);\n    get layer(): any;\n    /** @private */\n    private _renderStyle;\n    castShadow: boolean;\n    _receiveShadow: boolean;\n    _screenSpace: boolean;\n    _noDepthDrawGl1: boolean;\n    /**\n     * Controls whether the mesh instance can be culled by frustum culling\n     * ({@link CameraComponent#frustumCulling}).\n     *\n     * @type {boolean}\n     */\n    cull: boolean;\n    /**\n     * True if the mesh instance is pickable by the {@link Picker}. Defaults to true.\n     *\n     * @type {boolean}\n     * @ignore\n     */\n    pick: boolean;\n    _updateAabb: boolean;\n    _updateAabbFunc: any;\n    _calculateSortDistance: any;\n    /**\n     * @type {SkinInstance}\n     * @private\n     */\n    private _skinInstance;\n    /**\n     * @type {MorphInstance}\n     * @private\n     */\n    private _morphInstance;\n    instancingData: InstancingData;\n    /**\n     * @type {BoundingBox}\n     * @private\n     */\n    private _customAabb;\n    /**\n     * The world space axis-aligned bounding box for this mesh instance.\n     *\n     * @type {BoundingBox}\n     */\n    set aabb(arg: any);\n    get aabb(): any;\n    _aabbVer: number;\n    /**\n     * Use this value to affect rendering order of mesh instances. Only used when mesh\n     * instances are added to a {@link Layer} with {@link Layer#opaqueSortMode} or\n     * {@link Layer#transparentSortMode} (depending on the material) set to\n     * {@link SORTMODE_MANUAL}.\n     *\n     * @type {number}\n     */\n    drawOrder: number;\n    /**\n     * Read this value in {@link Layer#onPostCull} to determine if the object is actually going\n     * to be rendered.\n     *\n     * @type {boolean}\n     */\n    visibleThisFrame: boolean;\n    isVisibleFunc: any;\n    parameters: {};\n    stencilFront: any;\n    stencilBack: any;\n    flipFaces: boolean;\n    /**\n     * The render style of the mesh instance. Can be:\n     *\n     * - {@link RENDERSTYLE_SOLID}\n     * - {@link RENDERSTYLE_WIREFRAME}\n     * - {@link RENDERSTYLE_POINTS}\n     *\n     * Defaults to {@link RENDERSTYLE_SOLID}.\n     *\n     * @type {number}\n     */\n    set renderStyle(arg: number);\n    get renderStyle(): number;\n    /**\n     * The graphics mesh being instanced.\n     *\n     * @type {Mesh}\n     */\n    set mesh(arg: Mesh);\n    get mesh(): Mesh;\n    _aabb: any;\n    _layer: any;\n    /**\n     * In some circumstances mesh instances are sorted by a distance calculation to determine their\n     * rendering order. Set this callback to override the default distance calculation, which gives\n     * the dot product of the camera forward vector and the vector between the camera position and\n     * the center of the mesh instance\'s axis-aligned bounding box. This option can be particularly\n     * useful for rendering transparent meshes in a better order than default.\n     *\n     * @type {CalculateSortDistanceCallback}\n     */\n    set calculateSortDistance(arg: any);\n    get calculateSortDistance(): any;\n    set receiveShadow(arg: boolean);\n    get receiveShadow(): boolean;\n    /**\n     * The skin instance managing skinning of this mesh instance, or null if skinning is not used.\n     *\n     * @type {SkinInstance}\n     */\n    set skinInstance(arg: SkinInstance);\n    get skinInstance(): SkinInstance;\n    /**\n     * The morph instance managing morphing of this mesh instance, or null if morphing is not used.\n     *\n     * @type {MorphInstance}\n     */\n    set morphInstance(arg: MorphInstance);\n    get morphInstance(): MorphInstance;\n    set screenSpace(arg: boolean);\n    get screenSpace(): boolean;\n    set key(arg: number);\n    get key(): number;\n    /**\n     * Mask controlling which {@link LightComponent}s light this mesh instance, which\n     * {@link CameraComponent} sees it and in which {@link Layer} it is rendered. Defaults to 1.\n     *\n     * @type {number}\n     */\n    set mask(arg: number);\n    get mask(): number;\n    /**\n     * Number of instances when using hardware instancing to render the mesh.\n     *\n     * @type {number}\n     */\n    set instancingCount(arg: number);\n    get instancingCount(): number;\n    destroy(): void;\n    _isVisible(camera: any): any;\n    updateKey(): void;\n    /**\n     * Sets up {@link MeshInstance} to be rendered using Hardware Instancing.\n     *\n     * @param {VertexBuffer|null} vertexBuffer - Vertex buffer to hold per-instance vertex data\n     * (usually world matrices). Pass null to turn off hardware instancing.\n     */\n    setInstancing(vertexBuffer: VertexBuffer | null): void;\n    clearParameters(): void;\n    getParameters(): {};\n    /**\n     * Retrieves the specified shader parameter from a mesh instance.\n     *\n     * @param {string} name - The name of the parameter to query.\n     * @returns {object} The named parameter.\n     */\n    getParameter(name: string): object;\n    /**\n     * Sets a shader parameter on a mesh instance. Note that this parameter will take precedence\n     * over parameter of the same name if set on Material this mesh instance uses for rendering.\n     *\n     * @param {string} name - The name of the parameter to set.\n     * @param {number|number[]|Texture} data - The value for the specified parameter.\n     * @param {number} [passFlags] - Mask describing which passes the material should be included\n     * in.\n     */\n    setParameter(name: string, data: number | number[] | Texture, passFlags?: number): void;\n    setRealtimeLightmap(name: any, texture: any): void;\n    /**\n     * Deletes a shader parameter on a mesh instance.\n     *\n     * @param {string} name - The name of the parameter to delete.\n     */\n    deleteParameter(name: string): void;\n    setParameters(device: any, passFlag: any): void;\n    setLightmapped(value: any): void;\n    setCustomAabb(aabb: any): void;\n    _setupSkinUpdate(): void;\n}\n\n/**\n * Internal data structure used to store data used by hardware instancing.\n *\n * @ignore\n */\ndeclare class InstancingData {\n    /**\n     * @param {number} numObjects - The number of objects instanced.\n     */\n    constructor(numObjects: number);\n    /** @type {VertexBuffer|null} */\n    vertexBuffer: VertexBuffer | null;\n    count: number;\n}\n\n/**\n * Attach a TouchDevice to an element and it will receive and fire events when the element is\n * touched. See also {@link Touch} and {@link TouchEvent}.\n *\n * @augments EventHandler\n */\ndeclare class TouchDevice extends EventHandler {\n    /**\n     * Create a new touch device and attach it to an element.\n     *\n     * @param {Element} element - The element to attach listen for events on.\n     */\n    constructor(element: Element);\n    _element: Element;\n    _startHandler: any;\n    _endHandler: any;\n    _moveHandler: any;\n    _cancelHandler: any;\n    /**\n     * Attach a device to an element in the DOM. If the device is already attached to an element\n     * this method will detach it first.\n     *\n     * @param {Element} element - The element to attach to.\n     */\n    attach(element: Element): void;\n    /**\n     * Detach a device from the element it is attached to.\n     */\n    detach(): void;\n    _handleTouchStart(e: any): void;\n    _handleTouchEnd(e: any): void;\n    _handleTouchMove(e: any): void;\n    _handleTouchCancel(e: any): void;\n}\n\n/**\n * Callback used by {@link MouseenablePointerLock } and {@link ApplicationdisablePointerLock }.\n */\nexport type LockMouseCallback = () => any;\n/**\n * @event\n * @name Mouse#mousemove\n * @description Fired when the mouse is moved.\n * @param {MouseEvent} event - The MouseEvent object.\n */\n/**\n * @event\n * @name Mouse#mousedown\n * @description Fired when a mouse button is pressed.\n * @param {MouseEvent} event - The MouseEvent object.\n */\n/**\n * @event\n * @name Mouse#mouseup\n * @description Fired when a mouse button is released.\n * @param {MouseEvent} event - The MouseEvent object.\n */\n/**\n * @event\n * @name Mouse#mousewheel\n * @description Fired when a mouse wheel is moved.\n * @param {MouseEvent} event - The MouseEvent object.\n */\n/**\n * Callback used by {@link Mouse#enablePointerLock} and {@link Application#disablePointerLock}.\n *\n * @callback LockMouseCallback\n */\n/**\n * A Mouse Device, bound to a DOM Element.\n *\n * @augments EventHandler\n */\ndeclare class Mouse extends EventHandler {\n    /**\n     * Check if the mouse pointer has been locked, using {@link Mouse#enabledPointerLock}.\n     *\n     * @returns {boolean} True if locked.\n     */\n    static isPointerLocked(): boolean;\n    /**\n     * Create a new Mouse instance.\n     *\n     * @param {Element} [element] - The Element that the mouse events are attached to.\n     */\n    constructor(element?: Element);\n    _lastX: number;\n    _lastY: number;\n    _buttons: boolean[];\n    _lastbuttons: boolean[];\n    _upHandler: any;\n    _downHandler: any;\n    _moveHandler: any;\n    _wheelHandler: any;\n    _contextMenuHandler: (event: any) => void;\n    _target: Element;\n    _attached: boolean;\n    /**\n     * Attach mouse events to an Element.\n     *\n     * @param {Element} element - The DOM element to attach the mouse to.\n     */\n    attach(element: Element): void;\n    /**\n     * Remove mouse events from the element that it is attached to.\n     */\n    detach(): void;\n    /**\n     * Disable the context menu usually activated with right-click.\n     */\n    disableContextMenu(): void;\n    /**\n     * Enable the context menu usually activated with right-click. This option is active by\n     * default.\n     */\n    enableContextMenu(): void;\n    /**\n     * Request that the browser hides the mouse cursor and locks the mouse to the element. Allowing\n     * raw access to mouse movement input without risking the mouse exiting the element. Notes:\n     *\n     * - In some browsers this will only work when the browser is running in fullscreen mode. See\n     * {@link Application#enableFullscreen}\n     * - Enabling pointer lock can only be initiated by a user action e.g. in the event handler for\n     * a mouse or keyboard input.\n     *\n     * @param {LockMouseCallback} [success] - Function called if the request for mouse lock is\n     * successful.\n     * @param {LockMouseCallback} [error] - Function called if the request for mouse lock is\n     * unsuccessful.\n     */\n    enablePointerLock(success?: LockMouseCallback, error?: LockMouseCallback): void;\n    /**\n     * Return control of the mouse cursor to the user.\n     *\n     * @param {LockMouseCallback} [success] - Function called when the mouse lock is disabled.\n     */\n    disablePointerLock(success?: LockMouseCallback): void;\n    /**\n     * Update method, should be called once per frame.\n     */\n    update(): void;\n    /**\n     * Returns true if the mouse button is currently pressed.\n     *\n     * @param {number} button - The mouse button to test. Can be:\n     *\n     * - {@link MOUSEBUTTON_LEFT}\n     * - {@link MOUSEBUTTON_MIDDLE}\n     * - {@link MOUSEBUTTON_RIGHT}\n     *\n     * @returns {boolean} True if the mouse button is current pressed.\n     */\n    isPressed(button: number): boolean;\n    /**\n     * Returns true if the mouse button was pressed this frame (since the last call to update).\n     *\n     * @param {number} button - The mouse button to test. Can be:\n     *\n     * - {@link MOUSEBUTTON_LEFT}\n     * - {@link MOUSEBUTTON_MIDDLE}\n     * - {@link MOUSEBUTTON_RIGHT}\n     *\n     * @returns {boolean} True if the mouse button was pressed since the last update.\n     */\n    wasPressed(button: number): boolean;\n    /**\n     * Returns true if the mouse button was released this frame (since the last call to update).\n     *\n     * @param {number} button - The mouse button to test. Can be:\n     *\n     * - {@link MOUSEBUTTON_LEFT}\n     * - {@link MOUSEBUTTON_MIDDLE}\n     * - {@link MOUSEBUTTON_RIGHT}\n     *\n     * @returns {boolean} True if the mouse button was released since the last update.\n     */\n    wasReleased(button: number): boolean;\n    _handleUp(event: any): void;\n    _handleDown(event: any): void;\n    _handleMove(event: any): void;\n    _handleWheel(event: any): void;\n    _getTargetCoords(event: any): {\n        x: number;\n        y: number;\n    };\n}\n\n/**\n * @event\n * @name Keyboard#keydown\n * @description Event fired when a key is pressed.\n * @param {KeyboardEvent} event - The Keyboard event object. Note, this event is only valid for the current callback.\n * @example\n * var onKeyDown = function (e) {\n *     if (e.key === pc.KEY_SPACE) {\n *         // space key pressed\n *     }\n *     e.event.preventDefault(); // Use original browser event to prevent browser action.\n * };\n * app.keyboard.on("keydown", onKeyDown, this);\n */\n/**\n * @event\n * @name Keyboard#keyup\n * @description Event fired when a key is released.\n * @param {KeyboardEvent} event - The Keyboard event object. Note, this event is only valid for the current callback.\n * @example\n * var onKeyUp = function (e) {\n *     if (e.key === pc.KEY_SPACE) {\n *         // space key released\n *     }\n *     e.event.preventDefault(); // Use original browser event to prevent browser action.\n * };\n * app.keyboard.on("keyup", onKeyUp, this);\n */\n/**\n * A Keyboard device bound to an Element. Allows you to detect the state of the key presses. Note\n * that the Keyboard object must be attached to an Element before it can detect any key presses.\n *\n * @augments EventHandler\n */\ndeclare class Keyboard extends EventHandler {\n    /**\n     * Create a new Keyboard instance.\n     *\n     * @param {Element|Window} [element] - Element to attach Keyboard to. Note that elements like\n     * &lt;div&gt; can\'t accept focus by default. To use keyboard events on an element like this it\n     * must have a value of \'tabindex\' e.g. tabindex="0". See\n     * [here](http://www.w3.org/WAI/GL/WCAG20/WD-WCAG20-TECHS/SCR29.html) for more details.\n     * @param {object} [options] - Optional options object.\n     * @param {boolean} [options.preventDefault] - Call preventDefault() in key event handlers.\n     * This stops the default action of the event occurring. e.g. Ctrl+T will not open a new\n     * browser tab.\n     * @param {boolean} [options.stopPropagation] - Call stopPropagation() in key event handlers.\n     * This stops the event bubbling up the DOM so no parent handlers will be notified of the\n     * event.\n     * @example\n     * // attach keyboard listeners to the window\n     * var keyboard = new pc.Keyboard(window);\n     */\n    constructor(element?: Element | Window, options?: {\n        preventDefault?: boolean;\n        stopPropagation?: boolean;\n    });\n    _element: Element | Window;\n    _keyDownHandler: any;\n    _keyUpHandler: any;\n    _keyPressHandler: any;\n    _visibilityChangeHandler: any;\n    _windowBlurHandler: any;\n    _keymap: {};\n    _lastmap: {};\n    preventDefault: boolean;\n    stopPropagation: boolean;\n    /**\n     * Attach the keyboard event handlers to an Element.\n     *\n     * @param {Element|Window} element - The element to listen for keyboard events on.\n     */\n    attach(element: Element | Window): void;\n    /**\n     * Detach the keyboard event handlers from the element it is attached to.\n     */\n    detach(): void;\n    /**\n     * Convert a key code into a key identifier.\n     *\n     * @param {number} keyCode - The key code.\n     * @returns {string} The key identifier.\n     * @private\n     */\n    private toKeyIdentifier;\n    /**\n     * Process the browser keydown event.\n     *\n     * @param {globalThis.KeyboardEvent} event - The browser keyboard event.\n     * @private\n     */\n    private _handleKeyDown;\n    /**\n     * Process the browser keyup event.\n     *\n     * @param {globalThis.KeyboardEvent} event - The browser keyboard event.\n     * @private\n     */\n    private _handleKeyUp;\n    /**\n     * Process the browser keypress event.\n     *\n     * @param {globalThis.KeyboardEvent} event - The browser keyboard event.\n     * @private\n     */\n    private _handleKeyPress;\n    /**\n     * Handle the browser visibilitychange event.\n     *\n     * @private\n     */\n    private _handleVisibilityChange;\n    /**\n     * Handle the browser blur event.\n     *\n     * @private\n     */\n    private _handleWindowBlur;\n    /**\n     * Called once per frame to update internal state.\n     *\n     * @ignore\n     */\n    update(): void;\n    /**\n     * Return true if the key is currently down.\n     *\n     * @param {number} key - The keyCode of the key to test. See the KEY_* constants.\n     * @returns {boolean} True if the key was pressed, false if not.\n     */\n    isPressed(key: number): boolean;\n    /**\n     * Returns true if the key was pressed since the last update.\n     *\n     * @param {number} key - The keyCode of the key to test. See the KEY_* constants.\n     * @returns {boolean} True if the key was pressed.\n     */\n    wasPressed(key: number): boolean;\n    /**\n     * Returns true if the key was released since the last update.\n     *\n     * @param {number} key - The keyCode of the key to test. See the KEY_* constants.\n     * @returns {boolean} True if the key was pressed.\n     */\n    wasReleased(key: number): boolean;\n}\n\n/**\n * Input handler for accessing GamePad input.\n */\ndeclare class GamePads {\n    gamepadsSupported: boolean;\n    current: any[];\n    previous: any[];\n    deadZone: number;\n    /**\n     * Update the current and previous state of the gamepads. This must be called every frame for\n     * `wasPressed` to work.\n     */\n    update(): void;\n    /**\n     * Poll for the latest data from the gamepad API.\n     *\n     * @param {object[]} [pads] - An optional array used to receive the gamepads mapping. This\n     * array will be returned by this function.\n     * @returns {object[]} An array of gamepads and mappings for the model of gamepad that is\n     * attached.\n     * @example\n     * var gamepads = new pc.GamePads();\n     * var pads = gamepads.poll();\n     */\n    poll(pads?: object[]): object[];\n    getMap(pad: any): any;\n    /**\n     * Returns true if the button on the pad requested is pressed.\n     *\n     * @param {number} index - The index of the pad to check, use constants {@link PAD_1},\n     * {@link PAD_2}, etc.\n     * @param {number} button - The button to test, use constants {@link PAD_FACE_1}, etc.\n     * @returns {boolean} True if the button is pressed.\n     */\n    isPressed(index: number, button: number): boolean;\n    /**\n     * Returns true if the button was pressed since the last frame.\n     *\n     * @param {number} index - The index of the pad to check, use constants {@link PAD_1},\n     * {@link PAD_2}, etc.\n     * @param {number} button - The button to test, use constants {@link PAD_FACE_1}, etc.\n     * @returns {boolean} True if the button was pressed since the last frame.\n     */\n    wasPressed(index: number, button: number): boolean;\n    /**\n     * Returns true if the button was released since the last frame.\n     *\n     * @param {number} index - The index of the pad to check, use constants {@link PAD_1},\n     * {@link PAD_2}, etc.\n     * @param {number} button - The button to test, use constants {@link PAD_FACE_1}, etc.\n     * @returns {boolean} True if the button was released since the last frame.\n     */\n    wasReleased(index: number, button: number): boolean;\n    /**\n     * Get the value of one of the analogue axes of the pad.\n     *\n     * @param {number} index - The index of the pad to check, use constants {@link PAD_1},\n     * {@link PAD_2}, etc.\n     * @param {number} axes - The axes to get the value of, use constants {@link PAD_L_STICK_X},\n     * etc.\n     * @returns {number} The value of the axis between -1 and 1.\n     */\n    getAxis(index: number, axes: number): number;\n}\n\n\n\n/** @typedef {import(\'./system.js\').ComponentSystem} ComponentSystem */\n/** @typedef {import(\'../entity.js\').Entity} Entity */\n/**\n * Components are used to attach functionality on a {@link Entity}. Components can receive update\n * events each frame, and expose properties to the PlayCanvas Editor.\n *\n * @property {boolean} enabled Enables or disables the component.\n * @augments EventHandler\n */\ndeclare class Component extends EventHandler {\n    static _buildAccessors(obj: any, schema: any): void;\n    /**\n     * Base constructor for a Component.\n     *\n     * @param {ComponentSystem} system - The ComponentSystem used to create this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: ComponentSystem, entity: Entity);\n\n    set enabled(arg: boolean);\n    get enabled(): boolean;\n\n    /**\n     * The ComponentSystem used to create this Component.\n     *\n     * @type {ComponentSystem}\n     * @ignore\n     */\n    system: ComponentSystem;\n    /**\n     * The Entity that this Component is attached to.\n     *\n     * @type {Entity}\n     * @ignore\n     */\n    entity: Entity;\n    buildAccessors(schema: any): void;\n    onSetEnabled(name: any, oldValue: any, newValue: any): void;\n    onEnable(): void;\n    onDisable(): void;\n    onPostStateChange(): void;\n    /**\n     * Access the component data directly. Usually you should access the data properties via the\n     * individual properties as modifying this data directly will not fire \'set\' events.\n     *\n     * @type {*}\n     * @ignore\n     */\n    get data(): any;\n}\n\n\n\n\n/** @typedef {import(\'../app-base.js\').Application} Application */\n/** @typedef {import(\'./component.js\').Component} Component */\n/** @typedef {import(\'../entity.js\').Entity} Entity */\n/**\n * Component Systems contain the logic and functionality to update all Components of a particular\n * type.\n *\n * @augments EventHandler\n */\ndeclare class ComponentSystem extends EventHandler {\n    /**\n     * Create a new ComponentSystem instance.\n     *\n     * @param {Application} app - The application managing this system.\n     */\n    constructor(app: Application);\n    app: Application;\n    store: {};\n    schema: any[];\n    /**\n     * Create new {@link Component} and component data instances and attach them to the entity.\n     *\n     * @param {Entity} entity - The Entity to attach this component to.\n     * @param {object} [data] - The source data with which to create the component.\n     * @returns {Component} Returns a Component of type defined by the component system.\n     * @example\n     * var entity = new pc.Entity(app);\n     * app.systems.model.addComponent(entity, { type: \'box\' });\n     * // entity.model is now set to a pc.ModelComponent\n     * @ignore\n     */\n    addComponent(entity: Entity, data?: object): Component;\n    /**\n     * Remove the {@link Component} from the entity and delete the associated component data.\n     *\n     * @param {Entity} entity - The entity to remove the component from.\n     * @example\n     * app.systems.model.removeComponent(entity);\n     * // entity.model === undefined\n     * @ignore\n     */\n    removeComponent(entity: Entity): void;\n    /**\n     * Create a clone of component. This creates a copy of all component data variables.\n     *\n     * @param {Entity} entity - The entity to clone the component from.\n     * @param {Entity} clone - The entity to clone the component into.\n     * @returns {Component} The newly cloned component.\n     * @ignore\n     */\n    cloneComponent(entity: Entity, clone: Entity): Component;\n    /**\n     * Called during {@link ComponentSystem#addComponent} to initialize the component data in the\n     * store. This can be overridden by derived Component Systems and either called by the derived\n     * System or replaced entirely.\n     *\n     * @param {Component} component - The component being initialized.\n     * @param {object} data - The data block used to initialize the component.\n     * @param {string[]|object[]} properties - The array of property descriptors for the component.\n     * A descriptor can be either a plain property name, or an object specifying the name and type.\n     * @ignore\n     */\n    initializeComponentData(component: Component, data: object, properties: string[] | object[]): void;\n    /**\n     * Searches the component schema for properties that match the specified type.\n     *\n     * @param {string} type - The type to search for.\n     * @returns {string[]|object[]} An array of property descriptors matching the specified type.\n     * @ignore\n     */\n    getPropertiesOfType(type: string): string[] | object[];\n    destroy(): void;\n}\n\ndeclare class SpriteComponentData {\n    enabled: boolean;\n}\n\n/**\n * Manages creation of {@link SpriteComponent}s.\n *\n * @augments ComponentSystem\n */\ndeclare class SpriteComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof SpriteComponent;\n    DataType: typeof SpriteComponentData;\n    schema: string[];\n    _defaultTexture: Texture;\n    _defaultMaterial: any;\n    _default9SlicedMaterialSlicedMode: any;\n    _default9SlicedMaterialTiledMode: any;\n    set defaultMaterial(arg: any);\n    get defaultMaterial(): any;\n    set default9SlicedMaterialSlicedMode(arg: any);\n    get default9SlicedMaterialSlicedMode(): any;\n    set default9SlicedMaterialTiledMode(arg: any);\n    get default9SlicedMaterialTiledMode(): any;\n    initializeComponentData(component: any, data: any, properties: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    onUpdate(dt: any): void;\n    onBeforeRemove(entity: any, component: any): void;\n}\n\ndeclare class TagsCache {\n    constructor(key?: any);\n    _index: {};\n    _key: any;\n    addItem(item: any): void;\n    removeItem(item: any): void;\n    add(tag: any, item: any): void;\n    remove(tag: any, item: any): void;\n    find(args: any): any[];\n}\n\n\n/**\n * Callback used by {@link AssetRegistryfilter } to filter assets.\n */\nexport type FilterAssetCallback = (asset: Asset) => boolean;\n/**\n * Callback used by {@link AssetRegistryloadFromUrl } and called when an asset is loaded (or an\n * error occurs).\n */\nexport type LoadAssetCallback = (err: string | null, asset?: Asset) => any;\n/** @typedef {import(\'../resources/loader.js\').ResourceLoader} ResourceLoader */\n/**\n * Callback used by {@link AssetRegistry#filter} to filter assets.\n *\n * @callback FilterAssetCallback\n * @param {Asset} asset - The current asset to filter.\n * @returns {boolean} Return `true` to include asset to result list.\n */\n/**\n * Callback used by {@link AssetRegistry#loadFromUrl} and called when an asset is loaded (or an\n * error occurs).\n *\n * @callback LoadAssetCallback\n * @param {string|null} err - The error message is null if no errors were encountered.\n * @param {Asset} [asset] - The loaded asset if no errors were encountered.\n */\n/**\n * Container for all assets that are available to this application. Note that PlayCanvas scripts\n * are provided with an AssetRegistry instance as `app.assets`.\n *\n * @augments EventHandler\n */\ndeclare class AssetRegistry extends EventHandler {\n    /**\n     * Create an instance of an AssetRegistry.\n     *\n     * @param {ResourceLoader} loader - The ResourceLoader used to load the asset files.\n     */\n    constructor(loader: ResourceLoader);\n    _loader: ResourceLoader;\n    _assets: any[];\n    _cache: {};\n    _names: {};\n    _tags: TagsCache;\n    _urls: {};\n    /**\n     * A URL prefix that will be added to all asset loading requests.\n     *\n     * @type {string}\n     */\n    prefix: string;\n    /**\n     * @event\n     * @name AssetRegistry#load\n     * @description Fired when an asset completes loading.\n     * @param {Asset} asset - The asset that has just loaded.\n     * @example\n     * app.assets.on("load", function (asset) {\n     *     console.log("asset loaded: " + asset.name);\n     * });\n     */\n    /**\n     * @event\n     * @name AssetRegistry#load:[id]\n     * @description Fired when an asset completes loading.\n     * @param {Asset} asset - The asset that has just loaded.\n     * @example\n     * var id = 123456;\n     * var asset = app.assets.get(id);\n     * app.assets.on("load:" + id, function (asset) {\n     *     console.log("asset loaded: " + asset.name);\n     * });\n     * app.assets.load(asset);\n     */\n    /**\n     * @event\n     * @name AssetRegistry#load:url:[url]\n     * @description Fired when an asset completes loading.\n     * @param {Asset} asset - The asset that has just loaded.\n     * @example\n     * var id = 123456;\n     * var asset = app.assets.get(id);\n     * app.assets.on("load:url:" + asset.file.url, function (asset) {\n     *     console.log("asset loaded: " + asset.name);\n     * });\n     * app.assets.load(asset);\n     */\n    /**\n     * @event\n     * @name AssetRegistry#add\n     * @description Fired when an asset is added to the registry.\n     * @param {Asset} asset - The asset that was added.\n     * @example\n     * app.assets.on("add", function (asset) {\n     *     console.log("New asset added: " + asset.name);\n     * });\n     */\n    /**\n     * @event\n     * @name AssetRegistry#add:[id]\n     * @description Fired when an asset is added to the registry.\n     * @param {Asset} asset - The asset that was added.\n     * @example\n     * var id = 123456;\n     * app.assets.on("add:" + id, function (asset) {\n     *     console.log("Asset 123456 loaded");\n     * });\n     */\n    /**\n     * @event\n     * @name AssetRegistry#add:url:[url]\n     * @description Fired when an asset is added to the registry.\n     * @param {Asset} asset - The asset that was added.\n     */\n    /**\n     * @event\n     * @name AssetRegistry#remove\n     * @description Fired when an asset is removed from the registry.\n     * @param {Asset} asset - The asset that was removed.\n     * @example\n     * app.assets.on("remove", function (asset) {\n     *     console.log("Asset removed: " + asset.name);\n     * });\n     */\n    /**\n     * @event\n     * @name AssetRegistry#remove:[id]\n     * @description Fired when an asset is removed from the registry.\n     * @param {Asset} asset - The asset that was removed.\n     * @example\n     * var id = 123456;\n     * app.assets.on("remove:" + id, function (asset) {\n     *     console.log("Asset removed: " + asset.name);\n     * });\n     */\n    /**\n     * @event\n     * @name AssetRegistry#remove:url:[url]\n     * @description Fired when an asset is removed from the registry.\n     * @param {Asset} asset - The asset that was removed.\n     */\n    /**\n     * @event\n     * @name AssetRegistry#error\n     * @description Fired when an error occurs during asset loading.\n     * @param {string} err - The error message.\n     * @param {Asset} asset - The asset that generated the error.\n     * @example\n     * var id = 123456;\n     * var asset = app.assets.get(id);\n     * app.assets.on("error", function (err, asset) {\n     *     console.error(err);\n     * });\n     * app.assets.load(asset);\n     */\n    /**\n     * @event\n     * @name AssetRegistry#error:[id]\n     * @description Fired when an error occurs during asset loading.\n     * @param {Asset} asset - The asset that generated the error.\n     * @example\n     * var id = 123456;\n     * var asset = app.assets.get(id);\n     * app.assets.on("error:" + id, function (err, asset) {\n     *     console.error(err);\n     * });\n     * app.assets.load(asset);\n     */\n    /**\n     * Create a filtered list of assets from the registry.\n     *\n     * @param {object} filters - Properties to filter on, currently supports: \'preload: true|false\'.\n     * @returns {Asset[]} The filtered list of assets.\n     */\n    list(filters: object): Asset[];\n    /**\n     * Add an asset to the registry.\n     *\n     * @param {Asset} asset - The asset to add.\n     * @example\n     * var asset = new pc.Asset("My Asset", "texture", {\n     *     url: "../path/to/image.jpg"\n     * });\n     * app.assets.add(asset);\n     */\n    add(asset: Asset): void;\n    /**\n     * Remove an asset from the registry.\n     *\n     * @param {Asset} asset - The asset to remove.\n     * @returns {boolean} True if the asset was successfully removed and false otherwise.\n     * @example\n     * var asset = app.assets.get(100);\n     * app.assets.remove(asset);\n     */\n    remove(asset: Asset): boolean;\n    /**\n     * Retrieve an asset from the registry by its id field.\n     *\n     * @param {number} id - The id of the asset to get.\n     * @returns {Asset} The asset.\n     * @example\n     * var asset = app.assets.get(100);\n     */\n    get(id: number): Asset;\n    /**\n     * Retrieve an asset from the registry by its file\'s URL field.\n     *\n     * @param {string} url - The url of the asset to get.\n     * @returns {Asset} The asset.\n     * @example\n     * var asset = app.assets.getByUrl("../path/to/image.jpg");\n     */\n    getByUrl(url: string): Asset;\n    /**\n     * Load the asset\'s file from a remote source. Listen for "load" events on the asset to find\n     * out when it is loaded.\n     *\n     * @param {Asset} asset - The asset to load.\n     * @example\n     * // load some assets\n     * var assetsToLoad = [\n     *     app.assets.find("My Asset"),\n     *     app.assets.find("Another Asset")\n     * ];\n     * var count = 0;\n     * assetsToLoad.forEach(function (assetToLoad) {\n     *     assetToLoad.ready(function (asset) {\n     *         count++;\n     *         if (count === assetsToLoad.length) {\n     *             // done\n     *         }\n     *     });\n     *     app.assets.load(assetToLoad);\n     * });\n     */\n    load(asset: Asset): void;\n    /**\n     * Use this to load and create an asset if you don\'t have assets created. Usually you would\n     * only use this if you are not integrated with the PlayCanvas Editor.\n     *\n     * @param {string} url - The url to load.\n     * @param {string} type - The type of asset to load.\n     * @param {LoadAssetCallback} callback - Function called when asset is loaded, passed (err,\n     * asset), where err is null if no errors were encountered.\n     * @example\n     * app.assets.loadFromUrl("../path/to/texture.jpg", "texture", function (err, asset) {\n     *     var texture = asset.resource;\n     * });\n     */\n    loadFromUrl(url: string, type: string, callback: LoadAssetCallback): void;\n    /**\n     * Use this to load and create an asset when both the URL and filename are required. For\n     * example, use this function when loading BLOB assets, where the URL does not adequately\n     * identify the file.\n     *\n     * @param {string} url - The url to load.\n     * @param {string} filename - The filename of the asset to load.\n     * @param {string} type - The type of asset to load.\n     * @param {LoadAssetCallback} callback - Function called when asset is loaded, passed (err,\n     * asset), where err is null if no errors were encountered.\n     * @example\n     * var file = magicallyAttainAFile();\n     * app.assets.loadFromUrlAndFilename(URL.createObjectURL(file), "texture.png", "texture", function (err, asset) {\n     *     var texture = asset.resource;\n     * });\n     */\n    loadFromUrlAndFilename(url: string, filename: string, type: string, callback: LoadAssetCallback): void;\n    loadFromUrlError: any;\n    _loadModel(modelAsset: any, continuation: any): void;\n    _loadMaterials(modelAsset: any, mapping: any, callback: any): void;\n    _loadTextures(materialAsset: any, callback: any): void;\n    /**\n     * Return all Assets with the specified name and type found in the registry.\n     *\n     * @param {string} name - The name of the Assets to find.\n     * @param {string} [type] - The type of the Assets to find.\n     * @returns {Asset[]} A list of all Assets found.\n     * @example\n     * var assets = app.assets.findAll("myTextureAsset", "texture");\n     * console.log("Found " + assets.length + " assets called " + name);\n     */\n    findAll(name: string, type?: string): Asset[];\n    _onTagAdd(tag: any, asset: any): void;\n    _onTagRemove(tag: any, asset: any): void;\n    /**\n     * Return all Assets that satisfy the search query. Query can be simply a string, or comma\n     * separated strings, to have inclusive results of assets that match at least one query. A\n     * query that consists of an array of tags can be used to match assets that have each tag of\n     * array.\n     *\n     * @param {...*} query - Name of a tag or array of tags.\n     * @returns {Asset[]} A list of all Assets matched query.\n     * @example\n     * var assets = app.assets.findByTag("level-1");\n     * // returns all assets that tagged by `level-1`\n     * @example\n     * var assets = app.assets.findByTag("level-1", "level-2");\n     * // returns all assets that tagged by `level-1` OR `level-2`\n     * @example\n     * var assets = app.assets.findByTag(["level-1", "monster"]);\n     * // returns all assets that tagged by `level-1` AND `monster`\n     * @example\n     * var assets = app.assets.findByTag(["level-1", "monster"], ["level-2", "monster"]);\n     * // returns all assets that tagged by (`level-1` AND `monster`) OR (`level-2` AND `monster`)\n     */\n    findByTag(...args: any[]): Asset[];\n    /**\n     * Return all Assets that satisfy a filter callback.\n     *\n     * @param {FilterAssetCallback} callback - The callback function that is used to filter assets.\n     * Return `true` to include an asset in the returned array.\n     * @returns {Asset[]} A list of all Assets found.\n     * @example\n     * var assets = app.assets.filter(function (asset) {\n     *     return asset.name.indexOf(\'monster\') !== -1;\n     * });\n     * console.log("Found " + assets.length + " assets, where names contains \'monster\'");\n     */\n    filter(callback: FilterAssetCallback): Asset[];\n    /**\n     * Return the first Asset with the specified name and type found in the registry.\n     *\n     * @param {string} name - The name of the Asset to find.\n     * @param {string} [type] - The type of the Asset to find.\n     * @returns {Asset|null} A single Asset or null if no Asset is found.\n     * @example\n     * var asset = app.assets.find("myTextureAsset", "texture");\n     */\n    find(name: string, type?: string): Asset | null;\n}\n\n\n\n/**\n * Callback used by {@link ResourceHandlerload } when a resource is loaded (or an error occurs).\n */\nexport type ResourceHandlerCallback = (err: string | null, response?: any) => any;\n/** @typedef {import(\'../asset/asset.js\').Asset} Asset */\n/** @typedef {import(\'../asset/asset-registry.js\').AssetRegistry} AssetRegistry */\n/**\n * Callback used by {@link ResourceHandler#load} when a resource is loaded (or an error occurs).\n *\n * @callback ResourceHandlerCallback\n * @param {string|null} err - The error message in the case where the load fails.\n * @param {*} [response] - The raw data that has been successfully loaded.\n */\n/**\n * @interface\n * @name ResourceHandler\n * @description Interface for ResourceHandlers used by {@link ResourceLoader}.\n */\ninterface ResourceHandler {\n    /**\n     * @function\n     * @name ResourceHandler#load\n     * @description Load a resource from a remote URL. When loaded (or failed),\n     * use the callback to return an the raw resource data (or error).\n     * @param {string|object} url - Either the URL of the resource to load or a structure containing the\n     * load and original URL.\n     * @param {string} [url.load] - The URL to be used for loading the resource.\n     * @param {string} [url.original] - The original URL to be used for identifying the resource\n     * format. This is necessary when loading, for example from blob.\n     * @param {ResourceHandlerCallback} callback - The callback used when the resource is loaded or an error occurs.\n     * @param {Asset} [asset] - Optional asset that is passed by ResourceLoader.\n     */\n    load(url: string | object, callback: ResourceHandlerCallback, asset?: Asset): void;\n    /**\n     * @function\n     * @name ResourceHandler#open\n     * @description Convert raw resource data into a resource instance. E.g. Take 3D model format JSON and return a {@link Model}.\n     * @param {string} url - The URL of the resource to open.\n     * @param {*} data - The raw resource data passed by callback from {@link ResourceHandler#load}.\n     * @param {Asset} [asset] - Optional asset that is passed by ResourceLoader.\n     * @returns {*} The parsed resource data.\n     */\n    open(url: string, data: any, asset?: Asset): any;\n    /**\n     * @function\n     * @name ResourceHandler#[patch]\n     * @description Optional function to perform any operations on a resource, that requires a dependency on its asset data\n     * or any other asset data.\n     * @param {Asset} asset - The asset to patch.\n     * @param {AssetRegistry} assets - The asset registry.\n     */\n    patch?(asset: Asset, assets: AssetRegistry): void;\n}\n\n\n\n\n\n/**\n * Callback used by {@link ResourceLoaderload } when a resource is loaded (or an error occurs).\n */\nexport type ResourceLoaderCallback = (err: string | null, resource?: any) => any;\n/** @typedef {import(\'../asset/asset.js\').Asset} Asset */\n/** @typedef {import(\'../asset/asset-registry.js\').AssetRegistry} AssetRegistry */\n/** @typedef {import(\'../framework/app-base.js\').Application} Application */\n/** @typedef {import(\'./handler.js\').ResourceHandler} ResourceHandler */\n/**\n * Callback used by {@link ResourceLoader#load} when a resource is loaded (or an error occurs).\n *\n * @callback ResourceLoaderCallback\n * @param {string|null} err - The error message in the case where the load fails.\n * @param {*} [resource] - The resource that has been successfully loaded.\n */\n/**\n * Load resource data, potentially from remote sources. Caches resource on load to prevent multiple\n * requests. Add ResourceHandlers to handle different types of resources.\n */\ndeclare class ResourceLoader {\n    /**\n     * Create a new ResourceLoader instance.\n     *\n     * @param {Application} app - The application.\n     */\n    constructor(app: Application);\n    _handlers: {};\n    _requests: {};\n    _cache: {};\n    _app: Application;\n    /**\n     * Add a {@link ResourceHandler} for a resource type. Handler should support at least `load()`\n     * and `open()`. Handlers can optionally support patch(asset, assets) to handle dependencies on\n     * other assets.\n     *\n     * @param {string} type - The name of the resource type that the handler will be registered\n     * with. Can be:\n     *\n     * - {@link ASSET_ANIMATION}\n     * - {@link ASSET_AUDIO}\n     * - {@link ASSET_IMAGE}\n     * - {@link ASSET_JSON}\n     * - {@link ASSET_MODEL}\n     * - {@link ASSET_MATERIAL}\n     * - {@link ASSET_TEXT}\n     * - {@link ASSET_TEXTURE}\n     * - {@link ASSET_CUBEMAP}\n     * - {@link ASSET_SHADER}\n     * - {@link ASSET_CSS}\n     * - {@link ASSET_HTML}\n     * - {@link ASSET_SCRIPT}\n     * - {@link ASSET_CONTAINER}\n     *\n     * @param {ResourceHandler} handler - An instance of a resource handler supporting at least\n     * `load()` and `open()`.\n     * @example\n     * var loader = new ResourceLoader();\n     * loader.addHandler("json", new pc.JsonHandler());\n     */\n    addHandler(type: string, handler: ResourceHandler): void;\n    /**\n     * Remove a {@link ResourceHandler} for a resource type.\n     *\n     * @param {string} type - The name of the type that the handler will be removed.\n     */\n    removeHandler(type: string): void;\n    /**\n     * Get a {@link ResourceHandler} for a resource type.\n     *\n     * @param {string} type - The name of the resource type that the handler is registered with.\n     * @returns {ResourceHandler} The registered handler.\n     */\n    getHandler(type: string): ResourceHandler;\n    /**\n     * Make a request for a resource from a remote URL. Parse the returned data using the handler\n     * for the specified type. When loaded and parsed, use the callback to return an instance of\n     * the resource.\n     *\n     * @param {string} url - The URL of the resource to load.\n     * @param {string} type - The type of resource expected.\n     * @param {ResourceLoaderCallback} callback - The callback used when the resource is loaded or\n     * an error occurs. Passed (err, resource) where err is null if there are no errors.\n     * @param {Asset} [asset] - Optional asset that is passed into handler\n     * @example\n     * app.loader.load("../path/to/texture.png", "texture", function (err, texture) {\n     *     // use texture here\n     * });\n     */\n    load(url: string, type: string, callback: ResourceLoaderCallback, asset?: Asset): void;\n    _loadNull(handler: any, callback: any, asset: any): void;\n    _onSuccess(key: any, result: any, extra: any): void;\n    _onFailure(key: any, err: any): void;\n    /**\n     * Convert raw resource data into a resource instance. E.g. Take 3D model format JSON and\n     * return a {@link Model}.\n     *\n     * @param {string} type - The type of resource.\n     * @param {*} data - The raw resource data.\n     * @returns {*} The parsed resource data.\n     */\n    open(type: string, data: any): any;\n    /**\n     * Perform any operations on a resource, that requires a dependency on its asset data or any\n     * other asset data.\n     *\n     * @param {Asset} asset - The asset to patch.\n     * @param {AssetRegistry} assets - The asset registry.\n     */\n    patch(asset: Asset, assets: AssetRegistry): void;\n    /**\n     * Remove resource from cache.\n     *\n     * @param {string} url - The URL of the resource.\n     * @param {string} type - The type of resource.\n     */\n    clearCache(url: string, type: string): void;\n    /**\n     * Check cache for resource from a URL. If present, return the cached value.\n     *\n     * @param {string} url - The URL of the resource to get from the cache.\n     * @param {string} type - The type of the resource.\n     * @returns {*} The resource loaded from the cache.\n     */\n    getFromCache(url: string, type: string): any;\n    /**\n     * Enables retrying of failed requests when loading assets.\n     *\n     * @param {number} maxRetries - The maximum number of times to retry loading an asset. Defaults\n     * to 5.\n     * @ignore\n     */\n    enableRetry(maxRetries?: number): void;\n    /**\n     * Disables retrying of failed requests when loading assets.\n     *\n     * @ignore\n     */\n    disableRetry(): void;\n    /**\n     * Destroys the resource loader.\n     */\n    destroy(): void;\n}\n\n\n\n/**\n * Callback used by {@link Assetready } and called when an asset is ready.\n */\nexport type AssetReadyCallback = (asset: Asset) => any;\n/**\n * Callback used by {@link Asset#ready} and called when an asset is ready.\n *\n * @callback AssetReadyCallback\n * @param {Asset} asset - The ready asset.\n */\n/**\n * An asset record of a file or data resource that can be loaded by the engine. The asset contains\n * four important fields:\n *\n * - `file`: contains the details of a file (filename, url) which contains the resource data, e.g.\n * an image file for a texture asset.\n * - `data`: contains a JSON blob which contains either the resource data for the asset (e.g.\n * material data) or additional data for the file (e.g. material mappings for a model).\n * - `options`: contains a JSON blob with handler-specific load options.\n * - `resource`: contains the final resource when it is loaded. (e.g. a {@link StandardMaterial} or\n * a {@link Texture}).\n *\n * See the {@link AssetRegistry} for details on loading resources from assets.\n *\n * @augments EventHandler\n */\ndeclare class Asset extends EventHandler {\n    /**\n     * Helper function to resolve asset file data and return the contents as an ArrayBuffer. If the\n     * asset file contents are present, that is returned. Otherwise the file data is be downloaded\n     * via http.\n     *\n     * @param {string} loadUrl - The URL as passed into the handler\n     * @param {ResourceLoaderCallback} callback - The callback function to receive results.\n     * @param {Asset} [asset] - The asset\n     * @param {number} maxRetries - Number of retries if http download is required\n     * @ignore\n     */\n    static fetchArrayBuffer(loadUrl: string, callback: ResourceLoaderCallback, asset?: Asset, maxRetries?: number): void;\n    /**\n     * Create a new Asset record. Generally, Assets are created in the loading process and you\n     * won\'t need to create them by hand.\n     *\n     * @param {string} name - A non-unique but human-readable name which can be later used to\n     * retrieve the asset.\n     * @param {string} type - Type of asset. One of ["animation", "audio", "binary", "container",\n     * "cubemap", "css", "font", "json", "html", "material", "model", "script", "shader", "sprite",\n     * "template", text", "texture"]\n     * @param {object} [file] - Details about the file the asset is made from. At the least must\n     * contain the \'url\' field. For assets that don\'t contain file data use null.\n     * @param {string} [file.url] - The URL of the resource file that contains the asset data.\n     * @param {string} [file.filename] - The filename of the resource file or null if no filename\n     * was set (e.g from using {@link AssetRegistry#loadFromUrl}).\n     * @param {number} [file.size] - The size of the resource file or null if no size was set\n     * (e.g. from using {@link AssetRegistry#loadFromUrl}).\n     * @param {string} [file.hash] - The MD5 hash of the resource file data and the Asset data\n     * field or null if hash was set (e.g from using {@link AssetRegistry#loadFromUrl}).\n     * @param {ArrayBuffer} [file.contents] - Optional file contents. This is faster than wrapping\n     * the data in a (base64 encoded) blob. Currently only used by container assets.\n     * @param {object} [data] - JSON object with additional data about the asset. (e.g. for texture\n     * and model assets) or contains the asset data itself (e.g. in the case of materials).\n     * @param {object} [options] - The asset handler options. For container options see\n     * {@link ContainerHandler}.\n     * @param {boolean} [options.crossOrigin] - For use with texture resources. For\n     * browser-supported image formats only, enable cross origin.\n     * @example\n     * var asset = new pc.Asset("a texture", "texture", {\n     *     url: "http://example.com/my/assets/here/texture.png"\n     * });\n     */\n    constructor(name: string, type: string, file?: {\n        url?: string;\n        filename?: string;\n        size?: number;\n        hash?: string;\n        contents?: ArrayBuffer;\n    }, data?: object, options?: {\n        crossOrigin?: boolean;\n    });\n    _id: number;\n    /**\n     * The name of the asset.\n     *\n     * @type {string}\n     */\n    name: string;\n    /**\n     * The type of the asset. One of ["animation", "audio", "binary", "container", "cubemap",\n     * "css", "font", "json", "html", "material", "model", "render", "script", "shader", "sprite",\n     * "template", "text", "texture"]\n     *\n     * @type {("animation"|"audio"|"binary"|"container"|"cubemap"|"css"|"font"|"json"|"html"|"material"|"model"|"render"|"script"|"shader"|"sprite"|"template"|"text"|"texture")}\n     */\n    type: ("animation" | "audio" | "binary" | "container" | "cubemap" | "css" | "font" | "json" | "html" | "material" | "model" | "render" | "script" | "shader" | "sprite" | "template" | "text" | "texture");\n    /**\n     * Asset tags. Enables finding of assets by tags using the {@link AssetRegistry#findByTag} method.\n     *\n     * @type {Tags}\n     */\n    tags: Tags;\n    _preload: boolean;\n    _file: any;\n    _data: any;\n    /**\n     * Optional JSON data that contains the asset handler options.\n     *\n     * @type {object}\n     */\n    options: object;\n    _resources: any[];\n    _i18n: {};\n    /**\n     * True if the asset has finished attempting to load the resource. It is not guaranteed\n     * that the resources are available as there could have been a network error.\n     *\n     * @type {boolean}\n     */\n    loaded: boolean;\n    /**\n     * True if the resource is currently being loaded.\n     *\n     * @type {boolean}\n     */\n    loading: boolean;\n    /**\n     * The asset registry that this Asset belongs to.\n     *\n     * @type {AssetRegistry}\n     */\n    registry: AssetRegistry;\n    /**\n     * The file details or null if no file.\n     *\n     * @type {object}\n     */\n    set file(arg: any);\n    get file(): any;\n    /**\n     * The asset id.\n     *\n     * @type {number}\n     */\n    set id(arg: number);\n    get id(): number;\n    /**\n     * Optional JSON data that contains either the complete resource data. (e.g. in the case of a\n     * material) or additional data (e.g. in the case of a model it contains mappings from mesh to\n     * material).\n     *\n     * @type {object}\n     */\n    set data(arg: any);\n    get data(): any;\n    /**\n     * A reference to the resource when the asset is loaded. e.g. a {@link Texture} or a {@link Model}.\n     *\n     * @type {object}\n     */\n    set resource(arg: any);\n    get resource(): any;\n    /**\n     * A reference to the resources of the asset when it\'s loaded. An asset can hold more runtime\n     * resources than one e.g. cubemaps.\n     *\n     * @type {object[]}\n     */\n    set resources(arg: any[]);\n    get resources(): any[];\n    /**\n     * If true the asset will be loaded during the preload phase of application set up.\n     *\n     * @type {boolean}\n     */\n    set preload(arg: boolean);\n    get preload(): boolean;\n    set loadFaces(arg: any);\n    get loadFaces(): any;\n    _loadFaces: any;\n    /**\n     * @event\n     * @name Asset#load\n     * @description Fired when the asset has completed loading.\n     * @param {Asset} asset - The asset that was loaded.\n     */\n    /**\n     * @event\n     * @name Asset#unload\n     * @description Fired just before the asset unloads the resource. This allows for the opportunity to prepare for an asset that will be unloaded. E.g. Changing the texture of a model to a default before the one it was using is unloaded.\n     * @param {Asset} asset - The asset that is due to be unloaded.\n     */\n    /**\n     * @event\n     * @name Asset#remove\n     * @description Fired when the asset is removed from the asset registry.\n     * @param {Asset} asset - The asset that was removed.\n     */\n    /**\n     * @event\n     * @name Asset#error\n     * @description Fired if the asset encounters an error while loading.\n     * @param {string} err - The error message.\n     * @param {Asset} asset - The asset that generated the error.\n     */\n    /**\n     * @event\n     * @name Asset#change\n     * @description Fired when one of the asset properties `file`, `data`, `resource` or `resources` is changed.\n     * @param {Asset} asset - The asset that was loaded.\n     * @param {string} property - The name of the property that changed.\n     * @param {*} value - The new property value.\n     * @param {*} oldValue - The old property value.\n     */\n    /**\n     * @event\n     * @name Asset#add:localized\n     * @description Fired when we add a new localized asset id to the asset.\n     * @param {string} locale - The locale.\n     * @param {number} assetId - The asset id we added.\n     */\n    /**\n     * @event\n     * @name Asset#remove:localized\n     * @description Fired when we remove a localized asset id from the asset.\n     * @param {string} locale - The locale.\n     * @param {number} assetId - The asset id we removed.\n     */\n    /**\n     * Return the URL required to fetch the file for this asset.\n     *\n     * @returns {string|null} The URL. Returns null if the asset has no associated file.\n     * @example\n     * var assets = app.assets.find("My Image", "texture");\n     * var img = "&lt;img src=\'" + assets[0].getFileUrl() + "\'&gt;";\n     */\n    getFileUrl(): string | null;\n    /**\n     * Construct an asset URL from this asset\'s location and a relative path. If the relativePath\n     * is a blob or Base64 URI, then return that instead.\n     *\n     * @param {string} relativePath - The relative path to be concatenated to this asset\'s base url.\n     * @returns {string} Resulting URL of the asset.\n     * @ignore\n     */\n    getAbsoluteUrl(relativePath: string): string;\n    /**\n     * Returns the asset id of the asset that corresponds to the specified locale.\n     *\n     * @param {string} locale - The desired locale e.g. Ar-AR.\n     * @returns {number} An asset id or null if there is no asset specified for the desired locale.\n     * @ignore\n     */\n    getLocalizedAssetId(locale: string): number;\n    /**\n     * Adds a replacement asset id for the specified locale. When the locale in\n     * {@link Application#i18n} changes then references to this asset will be replaced with the\n     * specified asset id. (Currently only supported by the {@link ElementComponent}).\n     *\n     * @param {string} locale - The locale e.g. Ar-AR.\n     * @param {number} assetId - The asset id.\n     * @ignore\n     */\n    addLocalizedAssetId(locale: string, assetId: number): void;\n    /**\n     * Removes a localized asset.\n     *\n     * @param {string} locale - The locale e.g. Ar-AR.\n     * @ignore\n     */\n    removeLocalizedAssetId(locale: string): void;\n    /**\n     * Take a callback which is called as soon as the asset is loaded. If the asset is already\n     * loaded the callback is called straight away.\n     *\n     * @param {AssetReadyCallback} callback - The function called when the asset is ready. Passed\n     * the (asset) arguments.\n     * @param {object} [scope] - Scope object to use when calling the callback.\n     * @example\n     * var asset = app.assets.find("My Asset");\n     * asset.ready(function (asset) {\n     *   // asset loaded\n     * });\n     * app.assets.load(asset);\n     */\n    ready(callback: AssetReadyCallback, scope?: object): void;\n    reload(): void;\n    /**\n     * Destroys the associated resource and marks asset as unloaded.\n     *\n     * @example\n     * var asset = app.assets.find("My Asset");\n     * asset.unload();\n     * // asset.resource is null\n     */\n    unload(): void;\n}\n\n/**\n * Representation of an RGBA color.\n */\ndeclare class Color {\n    /**\n     * A constant color set to black [0, 0, 0, 1].\n     *\n     * @type {Color}\n     * @readonly\n     */\n    static readonly BLACK: Color;\n    /**\n     * A constant color set to blue [0, 0, 1, 1].\n     *\n     * @type {Color}\n     * @readonly\n     */\n    static readonly BLUE: Color;\n    /**\n     * A constant color set to cyan [0, 1, 1, 1].\n     *\n     * @type {Color}\n     * @readonly\n     */\n    static readonly CYAN: Color;\n    /**\n     * A constant color set to gray [0.5, 0.5, 0.5, 1].\n     *\n     * @type {Color}\n     * @readonly\n     */\n    static readonly GRAY: Color;\n    /**\n     * A constant color set to green [0, 1, 0, 1].\n     *\n     * @type {Color}\n     * @readonly\n     */\n    static readonly GREEN: Color;\n    /**\n     * A constant color set to magenta [1, 0, 1, 1].\n     *\n     * @type {Color}\n     * @readonly\n     */\n    static readonly MAGENTA: Color;\n    /**\n     * A constant color set to red [1, 0, 0, 1].\n     *\n     * @type {Color}\n     * @readonly\n     */\n    static readonly RED: Color;\n    /**\n     * A constant color set to white [1, 1, 1, 1].\n     *\n     * @type {Color}\n     * @readonly\n     */\n    static readonly WHITE: Color;\n    /**\n     * A constant color set to yellow [1, 1, 0, 1].\n     *\n     * @type {Color}\n     * @readonly\n     */\n    static readonly YELLOW: Color;\n    /**\n     * Create a new Color object.\n     *\n     * @param {number|number[]} [r] - The value of the red component (0-1). Defaults to 0. If r is\n     * an array of length 3 or 4, the array will be used to populate all components.\n     * @param {number} [g] - The value of the green component (0-1). Defaults to 0.\n     * @param {number} [b] - The value of the blue component (0-1). Defaults to 0.\n     * @param {number} [a] - The value of the alpha component (0-1). Defaults to 1.\n     */\n    constructor(r?: number | number[], g?: number, b?: number, a?: number);\n    /**\n     * The red component of the color.\n     *\n     * @type {number}\n     */\n    r: number;\n    /**\n     * The green component of the color.\n     *\n     * @type {number}\n     */\n    g: number;\n    /**\n     * The blue component of the color.\n     *\n     * @type {number}\n     */\n    b: number;\n    /**\n     * The alpha component of the color.\n     *\n     * @type {number}\n     */\n    a: number;\n    /**\n     * Returns a clone of the specified color.\n     *\n     * @returns {Color} A duplicate color object.\n     */\n    clone(): Color;\n    /**\n     * Copies the contents of a source color to a destination color.\n     *\n     * @param {Color} rhs - A color to copy to the specified color.\n     * @returns {Color} Self for chaining.\n     * @example\n     * var src = new pc.Color(1, 0, 0, 1);\n     * var dst = new pc.Color();\n     *\n     * dst.copy(src);\n     *\n     * console.log("The two colors are " + (dst.equals(src) ? "equal" : "different"));\n     */\n    copy(rhs: Color): Color;\n    /**\n     * Reports whether two colors are equal.\n     *\n     * @param {Color} rhs - The color to compare to the specified color.\n     * @returns {boolean} True if the colors are equal and false otherwise.\n     * @example\n     * var a = new pc.Color(1, 0, 0, 1);\n     * var b = new pc.Color(1, 1, 0, 1);\n     * console.log("The two colors are " + (a.equals(b) ? "equal" : "different"));\n     */\n    equals(rhs: Color): boolean;\n    /**\n     * Assign values to the color components, including alpha.\n     *\n     * @param {number} r - The value for red (0-1).\n     * @param {number} g - The value for blue (0-1).\n     * @param {number} b - The value for green (0-1).\n     * @param {number} [a] - The value for the alpha (0-1), defaults to 1.\n     * @returns {Color} Self for chaining.\n     */\n    set(r: number, g: number, b: number, a?: number): Color;\n    /**\n     * Returns the result of a linear interpolation between two specified colors.\n     *\n     * @param {Color} lhs - The color to interpolate from.\n     * @param {Color} rhs - The color to interpolate to.\n     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,\n     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this\n     * range, the linear interpolant will occur on a ray extrapolated from this line.\n     * @returns {Color} Self for chaining.\n     * @example\n     * var a = new pc.Color(0, 0, 0);\n     * var b = new pc.Color(1, 1, 0.5);\n     * var r = new pc.Color();\n     *\n     * r.lerp(a, b, 0);   // r is equal to a\n     * r.lerp(a, b, 0.5); // r is 0.5, 0.5, 0.25\n     * r.lerp(a, b, 1);   // r is equal to b\n     */\n    lerp(lhs: Color, rhs: Color, alpha: number): Color;\n    /**\n     * Set the values of the color from a string representation \'#11223344\' or \'#112233\'.\n     *\n     * @param {string} hex - A string representation in the format \'#RRGGBBAA\' or \'#RRGGBB\'. Where\n     * RR, GG, BB, AA are red, green, blue and alpha values. This is the same format used in\n     * HTML/CSS.\n     * @returns {Color} Self for chaining.\n     */\n    fromString(hex: string): Color;\n    /**\n     * Converts the color to string form. The format is \'#RRGGBBAA\', where RR, GG, BB, AA are the\n     * red, green, blue and alpha values. When the alpha value is not included (the default), this\n     * is the same format as used in HTML/CSS.\n     *\n     * @param {boolean} alpha - If true, the output string will include the alpha value.\n     * @returns {string} The color in string form.\n     * @example\n     * var c = new pc.Color(1, 1, 1);\n     * // Outputs #ffffffff\n     * console.log(c.toString());\n     */\n    toString(alpha: boolean): string;\n}\n\n/**\n * A 2-dimensional vector.\n */\ndeclare class Vec2 {\n    /**\n     * Calculates the angle between two Vec2\'s in radians.\n     *\n     * @param {Vec2} lhs - The first vector operand for the calculation.\n     * @param {Vec2} rhs - The second vector operand for the calculation.\n     * @returns {number} The calculated angle in radians.\n     * @ignore\n     */\n    static angleRad(lhs: Vec2, rhs: Vec2): number;\n    /**\n     * A constant vector set to [0, 0].\n     *\n     * @type {Vec2}\n     * @readonly\n     */\n    static readonly ZERO: Vec2;\n    /**\n     * A constant vector set to [1, 1].\n     *\n     * @type {Vec2}\n     * @readonly\n     */\n    static readonly ONE: Vec2;\n    /**\n     * A constant vector set to [0, 1].\n     *\n     * @type {Vec2}\n     * @readonly\n     */\n    static readonly UP: Vec2;\n    /**\n     * A constant vector set to [0, -1].\n     *\n     * @type {Vec2}\n     * @readonly\n     */\n    static readonly DOWN: Vec2;\n    /**\n     * A constant vector set to [1, 0].\n     *\n     * @type {Vec2}\n     * @readonly\n     */\n    static readonly RIGHT: Vec2;\n    /**\n     * A constant vector set to [-1, 0].\n     *\n     * @type {Vec2}\n     * @readonly\n     */\n    static readonly LEFT: Vec2;\n    /**\n     * Create a new Vec2 instance.\n     *\n     * @param {number|number[]} [x] - The x value. Defaults to 0. If x is an array of length 2, the\n     * array will be used to populate all components.\n     * @param {number} [y] - The y value. Defaults to 0.\n     * @example\n     * var v = new pc.Vec2(1, 2);\n     */\n    constructor(x?: number | number[], y?: number);\n    /**\n     * The first component of the vector.\n     *\n     * @type {number}\n     */\n    x: number;\n    /**\n     * The second component of the vector.\n     *\n     * @type {number}\n     */\n    y: number;\n    /**\n     * Adds a 2-dimensional vector to another in place.\n     *\n     * @param {Vec2} rhs - The vector to add to the specified vector.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(10, 10);\n     * var b = new pc.Vec2(20, 20);\n     *\n     * a.add(b);\n     *\n     * // Outputs [30, 30]\n     * console.log("The result of the addition is: " + a.toString());\n     */\n    add(rhs: Vec2): Vec2;\n    /**\n     * Adds two 2-dimensional vectors together and returns the result.\n     *\n     * @param {Vec2} lhs - The first vector operand for the addition.\n     * @param {Vec2} rhs - The second vector operand for the addition.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(10, 10);\n     * var b = new pc.Vec2(20, 20);\n     * var r = new pc.Vec2();\n     *\n     * r.add2(a, b);\n     * // Outputs [30, 30]\n     *\n     * console.log("The result of the addition is: " + r.toString());\n     */\n    add2(lhs: Vec2, rhs: Vec2): Vec2;\n    /**\n     * Adds a number to each element of a vector.\n     *\n     * @param {number} scalar - The number to add.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var vec = new pc.Vec2(3, 4);\n     *\n     * vec.addScalar(2);\n     *\n     * // Outputs [5, 6]\n     * console.log("The result of the addition is: " + vec.toString());\n     */\n    addScalar(scalar: number): Vec2;\n    /**\n     * Returns an identical copy of the specified 2-dimensional vector.\n     *\n     * @returns {Vec2} A 2-dimensional vector containing the result of the cloning.\n     * @example\n     * var v = new pc.Vec2(10, 20);\n     * var vclone = v.clone();\n     * console.log("The result of the cloning is: " + vclone.toString());\n     */\n    clone(): Vec2;\n    /**\n     * Copies the contents of a source 2-dimensional vector to a destination 2-dimensional vector.\n     *\n     * @param {Vec2} rhs - A vector to copy to the specified vector.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var src = new pc.Vec2(10, 20);\n     * var dst = new pc.Vec2();\n     *\n     * dst.copy(src);\n     *\n     * console.log("The two vectors are " + (dst.equals(src) ? "equal" : "different"));\n     */\n    copy(rhs: Vec2): Vec2;\n    /**\n     * Returns the result of a cross product operation performed on the two specified 2-dimensional\n     * vectors.\n     *\n     * @param {Vec2} rhs - The second 2-dimensional vector operand of the cross product.\n     * @returns {number} The cross product of the two vectors.\n     * @example\n     * var right = new pc.Vec2(1, 0);\n     * var up = new pc.Vec2(0, 1);\n     * var crossProduct = right.cross(up);\n     *\n     * // Prints 1\n     * console.log("The result of the cross product is: " + crossProduct);\n     */\n    cross(rhs: Vec2): number;\n    /**\n     * Returns the distance between the two specified 2-dimensional vectors.\n     *\n     * @param {Vec2} rhs - The second 2-dimensional vector to test.\n     * @returns {number} The distance between the two vectors.\n     * @example\n     * var v1 = new pc.Vec2(5, 10);\n     * var v2 = new pc.Vec2(10, 20);\n     * var d = v1.distance(v2);\n     * console.log("The distance between v1 and v2 is: " + d);\n     */\n    distance(rhs: Vec2): number;\n    /**\n     * Divides a 2-dimensional vector by another in place.\n     *\n     * @param {Vec2} rhs - The vector to divide the specified vector by.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(4, 9);\n     * var b = new pc.Vec2(2, 3);\n     *\n     * a.div(b);\n     *\n     * // Outputs [2, 3]\n     * console.log("The result of the division is: " + a.toString());\n     */\n    div(rhs: Vec2): Vec2;\n    /**\n     * Divides one 2-dimensional vector by another and writes the result to the specified vector.\n     *\n     * @param {Vec2} lhs - The dividend vector (the vector being divided).\n     * @param {Vec2} rhs - The divisor vector (the vector dividing the dividend).\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(4, 9);\n     * var b = new pc.Vec2(2, 3);\n     * var r = new pc.Vec2();\n     *\n     * r.div2(a, b);\n     * // Outputs [2, 3]\n     *\n     * console.log("The result of the division is: " + r.toString());\n     */\n    div2(lhs: Vec2, rhs: Vec2): Vec2;\n    /**\n     * Divides each element of a vector by a number.\n     *\n     * @param {number} scalar - The number to divide by.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var vec = new pc.Vec2(3, 6);\n     *\n     * vec.divScalar(3);\n     *\n     * // Outputs [1, 2]\n     * console.log("The result of the division is: " + vec.toString());\n     */\n    divScalar(scalar: number): Vec2;\n    /**\n     * Returns the result of a dot product operation performed on the two specified 2-dimensional\n     * vectors.\n     *\n     * @param {Vec2} rhs - The second 2-dimensional vector operand of the dot product.\n     * @returns {number} The result of the dot product operation.\n     * @example\n     * var v1 = new pc.Vec2(5, 10);\n     * var v2 = new pc.Vec2(10, 20);\n     * var v1dotv2 = v1.dot(v2);\n     * console.log("The result of the dot product is: " + v1dotv2);\n     */\n    dot(rhs: Vec2): number;\n    /**\n     * Reports whether two vectors are equal.\n     *\n     * @param {Vec2} rhs - The vector to compare to the specified vector.\n     * @returns {boolean} True if the vectors are equal and false otherwise.\n     * @example\n     * var a = new pc.Vec2(1, 2);\n     * var b = new pc.Vec2(4, 5);\n     * console.log("The two vectors are " + (a.equals(b) ? "equal" : "different"));\n     */\n    equals(rhs: Vec2): boolean;\n    /**\n     * Returns the magnitude of the specified 2-dimensional vector.\n     *\n     * @returns {number} The magnitude of the specified 2-dimensional vector.\n     * @example\n     * var vec = new pc.Vec2(3, 4);\n     * var len = vec.length();\n     * // Outputs 5\n     * console.log("The length of the vector is: " + len);\n     */\n    length(): number;\n    /**\n     * Returns the magnitude squared of the specified 2-dimensional vector.\n     *\n     * @returns {number} The magnitude of the specified 2-dimensional vector.\n     * @example\n     * var vec = new pc.Vec2(3, 4);\n     * var len = vec.lengthSq();\n     * // Outputs 25\n     * console.log("The length squared of the vector is: " + len);\n     */\n    lengthSq(): number;\n    /**\n     * Returns the result of a linear interpolation between two specified 2-dimensional vectors.\n     *\n     * @param {Vec2} lhs - The 2-dimensional to interpolate from.\n     * @param {Vec2} rhs - The 2-dimensional to interpolate to.\n     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,\n     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this\n     * range, the linear interpolant will occur on a ray extrapolated from this line.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(0, 0);\n     * var b = new pc.Vec2(10, 10);\n     * var r = new pc.Vec2();\n     *\n     * r.lerp(a, b, 0);   // r is equal to a\n     * r.lerp(a, b, 0.5); // r is 5, 5\n     * r.lerp(a, b, 1);   // r is equal to b\n     */\n    lerp(lhs: Vec2, rhs: Vec2, alpha: number): Vec2;\n    /**\n     * Multiplies a 2-dimensional vector to another in place.\n     *\n     * @param {Vec2} rhs - The 2-dimensional vector used as the second multiplicand of the operation.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(2, 3);\n     * var b = new pc.Vec2(4, 5);\n     *\n     * a.mul(b);\n     *\n     * // Outputs 8, 15\n     * console.log("The result of the multiplication is: " + a.toString());\n     */\n    mul(rhs: Vec2): Vec2;\n    /**\n     * Returns the result of multiplying the specified 2-dimensional vectors together.\n     *\n     * @param {Vec2} lhs - The 2-dimensional vector used as the first multiplicand of the operation.\n     * @param {Vec2} rhs - The 2-dimensional vector used as the second multiplicand of the operation.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(2, 3);\n     * var b = new pc.Vec2(4, 5);\n     * var r = new pc.Vec2();\n     *\n     * r.mul2(a, b);\n     *\n     * // Outputs 8, 15\n     * console.log("The result of the multiplication is: " + r.toString());\n     */\n    mul2(lhs: Vec2, rhs: Vec2): Vec2;\n    /**\n     * Multiplies each element of a vector by a number.\n     *\n     * @param {number} scalar - The number to multiply by.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var vec = new pc.Vec2(3, 6);\n     *\n     * vec.mulScalar(3);\n     *\n     * // Outputs [9, 18]\n     * console.log("The result of the multiplication is: " + vec.toString());\n     */\n    mulScalar(scalar: number): Vec2;\n    /**\n     * Returns this 2-dimensional vector converted to a unit vector in place. If the vector has a\n     * length of zero, the vector\'s elements will be set to zero.\n     *\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var v = new pc.Vec2(25, 0);\n     *\n     * v.normalize();\n     *\n     * // Outputs 1, 0\n     * console.log("The result of the vector normalization is: " + v.toString());\n     */\n    normalize(): Vec2;\n    /**\n     * Each element is set to the largest integer less than or equal to its value.\n     *\n     * @returns {Vec2} Self for chaining.\n     */\n    floor(): Vec2;\n    /**\n     * Each element is rounded up to the next largest integer.\n     *\n     * @returns {Vec2} Self for chaining.\n     */\n    ceil(): Vec2;\n    /**\n     * Each element is rounded up or down to the nearest integer.\n     *\n     * @returns {Vec2} Self for chaining.\n     */\n    round(): Vec2;\n    /**\n     * Each element is assigned a value from rhs parameter if it is smaller.\n     *\n     * @param {Vec2} rhs - The 2-dimensional vector used as the source of elements to compare to.\n     * @returns {Vec2} Self for chaining.\n     */\n    min(rhs: Vec2): Vec2;\n    /**\n     * Each element is assigned a value from rhs parameter if it is larger.\n     *\n     * @param {Vec2} rhs - The 2-dimensional vector used as the source of elements to compare to.\n     * @returns {Vec2} Self for chaining.\n     */\n    max(rhs: Vec2): Vec2;\n    /**\n     * Sets the specified 2-dimensional vector to the supplied numerical values.\n     *\n     * @param {number} x - The value to set on the first component of the vector.\n     * @param {number} y - The value to set on the second component of the vector.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var v = new pc.Vec2();\n     * v.set(5, 10);\n     *\n     * // Outputs 5, 10\n     * console.log("The result of the vector set is: " + v.toString());\n     */\n    set(x: number, y: number): Vec2;\n    /**\n     * Subtracts a 2-dimensional vector from another in place.\n     *\n     * @param {Vec2} rhs - The vector to add to the specified vector.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(10, 10);\n     * var b = new pc.Vec2(20, 20);\n     *\n     * a.sub(b);\n     *\n     * // Outputs [-10, -10]\n     * console.log("The result of the subtraction is: " + a.toString());\n     */\n    sub(rhs: Vec2): Vec2;\n    /**\n     * Subtracts two 2-dimensional vectors from one another and returns the result.\n     *\n     * @param {Vec2} lhs - The first vector operand for the addition.\n     * @param {Vec2} rhs - The second vector operand for the addition.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(10, 10);\n     * var b = new pc.Vec2(20, 20);\n     * var r = new pc.Vec2();\n     *\n     * r.sub2(a, b);\n     *\n     * // Outputs [-10, -10]\n     * console.log("The result of the subtraction is: " + r.toString());\n     */\n    sub2(lhs: Vec2, rhs: Vec2): Vec2;\n    /**\n     * Subtracts a number from each element of a vector.\n     *\n     * @param {number} scalar - The number to subtract.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var vec = new pc.Vec2(3, 4);\n     *\n     * vec.subScalar(2);\n     *\n     * // Outputs [1, 2]\n     * console.log("The result of the subtraction is: " + vec.toString());\n     */\n    subScalar(scalar: number): Vec2;\n    /**\n     * Converts the vector to string form.\n     *\n     * @returns {string} The vector in string form.\n     * @example\n     * var v = new pc.Vec2(20, 10);\n     * // Outputs [20, 10]\n     * console.log(v.toString());\n     */\n    toString(): string;\n}\n\n\n/** @typedef {import(\'./graph-node.js\').GraphNode} GraphNode */\n/**\n * A model is a graphical object that can be added to or removed from a scene. It contains a\n * hierarchy and any number of mesh instances.\n */\ndeclare class Model {\n    /**\n     * The root node of the model\'s graph node hierarchy.\n     *\n     * @type {GraphNode}\n     */\n    graph: GraphNode;\n    /**\n     * An array of MeshInstances contained in this model.\n     *\n     * @type {MeshInstance[]}\n     */\n    meshInstances: MeshInstance[];\n    /**\n     * An array of SkinInstances contained in this model.\n     *\n     * @type {SkinInstance[]}\n     */\n    skinInstances: SkinInstance[];\n    /**\n     * An array of MorphInstances contained in this model.\n     *\n     * @type {MorphInstance[]}\n     */\n    morphInstances: MorphInstance[];\n    cameras: any[];\n    lights: any[];\n    _shadersVersion: number;\n    _immutable: boolean;\n    getGraph(): GraphNode;\n    setGraph(graph: any): void;\n    getCameras(): any[];\n    setCameras(cameras: any): void;\n    getLights(): any[];\n    setLights(lights: any): void;\n    getMaterials(): Material[];\n    /**\n     * Clones a model. The returned model has a newly created hierarchy and mesh instances, but\n     * meshes are shared between the clone and the specified model.\n     *\n     * @returns {Model} A clone of the specified model.\n     * @example\n     * var clonedModel = model.clone();\n     */\n    clone(): Model;\n    /**\n     * Destroys skinning texture and possibly deletes vertex/index buffers of a model. Mesh is\n     * reference-counted, so buffers are only deleted if all models with referencing mesh instances\n     * were deleted. That means all in-scene models + the "base" one (asset.resource) which is\n     * created when the model is parsed. It is recommended to use asset.unload() instead, which\n     * will also remove the model from the scene.\n     */\n    destroy(): void;\n    /**\n     * Generates the necessary internal data for a model to be renderable as wireframe. Once this\n     * function has been called, any mesh instance in the model can have its renderStyle property\n     * set to {@link RENDERSTYLE_WIREFRAME}.\n     *\n     * @example\n     * model.generateWireframe();\n     * for (var i = 0; i < model.meshInstances.length; i++) {\n     *     model.meshInstances[i].renderStyle = pc.RENDERSTYLE_WIREFRAME;\n     * }\n     */\n    generateWireframe(): void;\n}\n\n\n\n/** @typedef {import(\'../math/vec2.js\').Vec2} Vec2 */\n/** @typedef {import(\'../math/vec4.js\').Vec4} Vec4 */\n/** @typedef {import(\'../graphics/texture.js\').Texture} Texture */\n/**\n * A TextureAtlas contains a number of frames from a texture. Each frame defines a region in a\n * texture. The TextureAtlas is referenced by {@link Sprite}s.\n *\n * @augments EventHandler\n */\ndeclare class TextureAtlas extends EventHandler {\n    /**\n     * @type {Texture}\n     * @private\n     */\n    private _texture;\n    /**\n     * @type {object}\n     * @private\n     */\n    private _frames;\n    /**\n     * The texture used by the atlas.\n     *\n     * @type {Texture}\n     */\n    set texture(arg: Texture);\n    get texture(): Texture;\n    /**\n     * Contains frames which define portions of the texture atlas.\n     *\n     * @type {object}\n     */\n    set frames(arg: any);\n    get frames(): any;\n    /**\n     * Set a new frame in the texture atlas.\n     *\n     * @param {string} key - The key of the frame.\n     * @param {object} data - The properties of the frame.\n     * @param {Vec4} data.rect - The u, v, width, height properties of the frame in pixels.\n     * @param {Vec2} data.pivot - The pivot of the frame - values are between 0-1.\n     * @param {Vec4} data.border - The border of the frame for 9-slicing. Values are ordered as\n     * follows: left, bottom, right, top border in pixels.\n     * @example\n     * atlas.setFrame(\'1\', {\n     *     rect: new pc.Vec4(0, 0, 128, 128),\n     *     pivot: new pc.Vec2(0.5, 0.5),\n     *     border: new pc.Vec4(5, 5, 5, 5)\n     * });\n     */\n    setFrame(key: string, data: {\n        rect: Vec4;\n        pivot: Vec2;\n        border: Vec4;\n    }): void;\n    /**\n     * Removes a frame from the texture atlas.\n     *\n     * @param {string} key - The key of the frame.\n     * @example\n     * atlas.removeFrame(\'1\');\n     */\n    removeFrame(key: string): void;\n    /**\n     * Free up the underlying texture owned by the atlas.\n     */\n    destroy(): void;\n}\n\n\n\n/**\n * A Sprite contains references to one or more frames of a {@link TextureAtlas}. It can be used by\n * the {@link SpriteComponent} or the {@link ElementComponent} to render a single frame or a sprite\n * animation.\n *\n * @augments EventHandler\n */\ndeclare class Sprite extends EventHandler {\n    /**\n     * Create a new Sprite instance.\n     *\n     * @param {GraphicsDevice} device - The graphics device of the application.\n     * @param {object} [options] - Options for creating the Sprite.\n     * @param {number} [options.pixelsPerUnit] - The number of pixels that map to one PlayCanvas\n     * unit. Defaults to 1.\n     * @param {number} [options.renderMode] - The rendering mode of the sprite. Can be:\n     *\n     * - {@link SPRITE_RENDERMODE_SIMPLE}\n     * - {@link SPRITE_RENDERMODE_SLICED}\n     * - {@link SPRITE_RENDERMODE_TILED}\n     *\n     * Defaults to {@link SPRITE_RENDERMODE_SIMPLE}.\n     * @param {TextureAtlas} [options.atlas] - The texture atlas. Defaults to null.\n     * @param {string[]} [options.frameKeys] - The keys of the frames in the sprite atlas that this\n     * sprite is using. Defaults to null.\n     */\n    constructor(device: GraphicsDevice, options?: {\n        pixelsPerUnit?: number;\n        renderMode?: number;\n        atlas?: TextureAtlas;\n        frameKeys?: string[];\n    });\n    _device: GraphicsDevice;\n    _pixelsPerUnit: number;\n    _renderMode: number;\n    _atlas: TextureAtlas;\n    _frameKeys: string[];\n    _meshes: any[];\n    _updatingProperties: boolean;\n    _meshesDirty: boolean;\n    /**\n     * The keys of the frames in the sprite atlas that this sprite is using.\n     *\n     * @type {string[]}\n     */\n    set frameKeys(arg: string[]);\n    get frameKeys(): string[];\n    /**\n     * The texture atlas.\n     *\n     * @type {TextureAtlas}\n     */\n    set atlas(arg: TextureAtlas);\n    get atlas(): TextureAtlas;\n    /**\n     * The number of pixels that map to one PlayCanvas unit.\n     *\n     * @type {number}\n     */\n    set pixelsPerUnit(arg: number);\n    get pixelsPerUnit(): number;\n    /**\n     * The rendering mode of the sprite. Can be:\n     *\n     * - {@link SPRITE_RENDERMODE_SIMPLE}\n     * - {@link SPRITE_RENDERMODE_SLICED}\n     * - {@link SPRITE_RENDERMODE_TILED}\n     *\n     * @type {number}\n     */\n    set renderMode(arg: number);\n    get renderMode(): number;\n    /**\n     * An array that contains a mesh for each frame.\n     *\n     * @type {Mesh[]}\n     */\n    get meshes(): Mesh[];\n    _createMeshes(): void;\n    _createSimpleMesh(frame: any): Mesh;\n    _create9SliceMesh(): Mesh;\n    _onSetFrames(frames: any): void;\n    _onFrameChanged(frameKey: any, frame: any): void;\n    _onFrameRemoved(frameKey: any): void;\n    startUpdate(): void;\n    endUpdate(): void;\n    /**\n     * Free up the meshes created by the sprite.\n     */\n    destroy(): void;\n}\n\n\n/** @typedef {import(\'../../../scene/sprite.js\').Sprite} Sprite */\n/** @typedef {import(\'./component.js\').SpriteComponent} SpriteComponent */\n/**\n * Handles playing of sprite animations and loading of relevant sprite assets.\n *\n * @augments EventHandler\n */\ndeclare class SpriteAnimationClip extends EventHandler {\n    /**\n     * Create a new SpriteAnimationClip instance.\n     *\n     * @param {SpriteComponent} component - The sprite component managing this clip.\n     * @param {object} data - Data for the new animation clip.\n     * @param {number} [data.fps] - Frames per second for the animation clip.\n     * @param {boolean} [data.loop] - Whether to loop the animation clip.\n     * @param {string} [data.name] - The name of the new animation clip.\n     * @param {number} [data.spriteAsset] - The id of the sprite asset that this clip will play.\n     */\n    constructor(component: SpriteComponent, data: {\n        fps?: number;\n        loop?: boolean;\n        name?: string;\n        spriteAsset?: number;\n    });\n    _component: SpriteComponent;\n    _frame: number;\n    _sprite: any;\n    _spriteAsset: any;\n    /**\n     * The id of the sprite asset used to play the animation.\n     *\n     * @type {number}\n     */\n    set spriteAsset(arg: any);\n    get spriteAsset(): any;\n    name: string;\n    fps: number;\n    loop: boolean;\n    _playing: boolean;\n    _paused: boolean;\n    _time: number;\n    /**\n     * The total duration of the animation in seconds.\n     *\n     * @type {number}\n     */\n    get duration(): number;\n    /**\n     * The index of the frame of the {@link Sprite} currently being rendered.\n     *\n     * @type {number}\n     */\n    set frame(arg: number);\n    get frame(): number;\n    /**\n     * Whether the animation is currently paused.\n     *\n     * @type {boolean}\n     */\n    get isPaused(): boolean;\n    /**\n     * Whether the animation is currently playing.\n     *\n     * @type {boolean}\n     */\n    get isPlaying(): boolean;\n    /**\n     * The current sprite used to play the animation.\n     *\n     * @type {Sprite}\n     */\n    set sprite(arg: any);\n    get sprite(): any;\n    /**\n     * The current time of the animation in seconds.\n     *\n     * @type {number}\n     */\n    set time(arg: number);\n    get time(): number;\n    _onSpriteAssetAdded(asset: any): void;\n    _bindSpriteAsset(asset: any): void;\n    _unbindSpriteAsset(asset: any): void;\n    _onSpriteAssetLoad(asset: any): void;\n    _onTextureAtlasLoad(atlasAsset: any): void;\n    _onSpriteAssetRemove(asset: any): void;\n    _onSpriteMeshesChange(): void;\n    _onSpritePpuChanged(): void;\n    /**\n     * Advances the animation, looping if necessary.\n     *\n     * @param {number} dt - The delta time.\n     * @private\n     */\n    private _update;\n    _setTime(value: any): void;\n    _setFrame(value: any): void;\n    _destroy(): void;\n    /**\n     * Plays the animation. If it\'s already playing then this does nothing.\n     */\n    play(): void;\n    /**\n     * Pauses the animation.\n     */\n    pause(): void;\n    /**\n     * Resumes the paused animation.\n     */\n    resume(): void;\n    /**\n     * Stops the animation and resets the animation to the first frame.\n     */\n    stop(): void;\n}\n\n\n\n\n/**\n * Enables an Entity to render a simple static sprite or sprite animations.\n *\n * @augments Component\n */\ndeclare class SpriteComponent extends Component {\n    /**\n     * Create a new SpriteComponent instance.\n     *\n     * @param {SpriteComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: SpriteComponentSystem, entity: Entity);\n    _type: string;\n    _material: any;\n    _color: Color;\n    _colorUniform: Float32Array;\n    _speed: number;\n    _flipX: boolean;\n    _flipY: boolean;\n    _width: number;\n    _height: number;\n    _drawOrder: number;\n    _layers: number[];\n    _outerScale: Vec2;\n    _outerScaleUniform: Float32Array;\n    _innerOffset: Vec4;\n    _innerOffsetUniform: Float32Array;\n    _atlasRect: Vec4;\n    _atlasRectUniform: Float32Array;\n    _batchGroupId: number;\n    _batchGroup: any;\n    _node: GraphNode;\n    _model: Model;\n    _meshInstance: MeshInstance;\n    _updateAabbFunc: any;\n    _addedModel: boolean;\n    _autoPlayClip: any;\n    /**\n     * Dictionary of sprite animation clips.\n     *\n     * @type {Object.<string, SpriteAnimationClip>}\n     * @private\n     */\n    private _clips;\n    _defaultClip: SpriteAnimationClip;\n    /**\n     * The sprite animation clip currently playing.\n     *\n     * @type {SpriteAnimationClip}\n     * @private\n     */\n    private _currentClip;\n    /**\n     * The type of the SpriteComponent. Can be:\n     *\n     * - {@link SPRITETYPE_SIMPLE}: The component renders a single frame from a sprite asset.\n     * - {@link SPRITETYPE_ANIMATED}: The component can play sprite animation clips.\n     *\n     * Defaults to {@link SPRITETYPE_SIMPLE}.\n     *\n     * @type {string}\n     */\n    set type(arg: string);\n    get type(): string;\n    /**\n     * The frame counter of the sprite. Specifies which frame from the current sprite asset to\n     * render.\n     *\n     * @type {number}\n     */\n    set frame(arg: number);\n    get frame(): number;\n    /**\n     * The asset id or the {@link Asset} of the sprite to render. Only works for\n     * {@link SPRITETYPE_SIMPLE} sprites.\n     *\n     * @type {number|Asset}\n     */\n    set spriteAsset(arg: any);\n    get spriteAsset(): any;\n    /**\n     * The current sprite.\n     *\n     * @type {Sprite}\n     */\n    set sprite(arg: any);\n    get sprite(): any;\n    set material(arg: any);\n    get material(): any;\n    /**\n     * The color tint of the sprite.\n     *\n     * @type {Color}\n     */\n    set color(arg: Color);\n    get color(): Color;\n    /**\n     * The opacity of the sprite.\n     *\n     * @type {number}\n     */\n    set opacity(arg: number);\n    get opacity(): number;\n    /**\n     * A dictionary that contains {@link SpriteAnimationClip}s.\n     *\n     * @type {Object.<string, SpriteAnimationClip>}\n     */\n    set clips(arg: {\n        [x: string]: SpriteAnimationClip;\n    });\n    get clips(): {\n        [x: string]: SpriteAnimationClip;\n    };\n    /**\n     * The current clip being played.\n     *\n     * @type {SpriteAnimationClip}\n     */\n    get currentClip(): SpriteAnimationClip;\n    /**\n     * A global speed modifier used when playing sprite animation clips.\n     *\n     * @type {number}\n     */\n    set speed(arg: number);\n    get speed(): number;\n    /**\n     * Flip the X axis when rendering a sprite.\n     *\n     * @type {boolean}\n     */\n    set flipX(arg: boolean);\n    get flipX(): boolean;\n    /**\n     * Flip the Y axis when rendering a sprite.\n     *\n     * @type {boolean}\n     */\n    set flipY(arg: boolean);\n    get flipY(): boolean;\n    /**\n     * The width of the sprite when rendering using 9-Slicing. The width and height are only used\n     * when the render mode of the sprite asset is Sliced or Tiled.\n     *\n     * @type {number}\n     */\n    set width(arg: number);\n    get width(): number;\n    /**\n     * The height of the sprite when rendering using 9-Slicing. The width and height are only used\n     * when the render mode of the sprite asset is Sliced or Tiled.\n     *\n     * @type {number}\n     */\n    set height(arg: number);\n    get height(): number;\n    /**\n     * Assign sprite to a specific batch group (see {@link BatchGroup}). Default is -1 (no group).\n     *\n     * @type {number}\n     */\n    set batchGroupId(arg: number);\n    get batchGroupId(): number;\n    /**\n     * The name of the clip to play automatically when the component is enabled and the clip exists.\n     *\n     * @type {string}\n     */\n    set autoPlayClip(arg: any);\n    get autoPlayClip(): any;\n    /**\n     * The draw order of the component. A higher value means that the component will be rendered on\n     * top of other components in the same layer. This is not used unless the layer\'s sort order is\n     * set to {@link SORTMODE_MANUAL}.\n     *\n     * @type {number}\n     */\n    set drawOrder(arg: number);\n    get drawOrder(): number;\n    /**\n     * An array of layer IDs ({@link Layer#id}) to which this sprite should belong.\n     *\n     * @type {number[]}\n     */\n    set layers(arg: number[]);\n    get layers(): number[];\n    get aabb(): any;\n    onDestroy(): void;\n    _showModel(): void;\n    _hideModel(): void;\n    _showFrame(frame: any): void;\n    _updateTransform(): void;\n    _updateAabb(aabb: any): any;\n    _tryAutoPlay(): void;\n    _onLayersChanged(oldComp: any, newComp: any): void;\n    _onLayerAdded(layer: any): void;\n    _onLayerRemoved(layer: any): void;\n    removeModelFromLayers(): void;\n    /**\n     * Creates and adds a new {@link SpriteAnimationClip} to the component\'s clips.\n     *\n     * @param {object} data - Data for the new animation clip.\n     * @param {string} [data.name] - The name of the new animation clip.\n     * @param {number} [data.fps] - Frames per second for the animation clip.\n     * @param {boolean} [data.loop] - Whether to loop the animation clip.\n     * @param {number|Asset} [data.spriteAsset] - The asset id or the {@link Asset} of the sprite\n     * that this clip will play.\n     * @returns {SpriteAnimationClip} The new clip that was added.\n     */\n    addClip(data: {\n        name?: string;\n        fps?: number;\n        loop?: boolean;\n        spriteAsset?: number | Asset;\n    }): SpriteAnimationClip;\n    /**\n     * Removes a clip by name.\n     *\n     * @param {string} name - The name of the animation clip to remove.\n     */\n    removeClip(name: string): void;\n    /**\n     * Get an animation clip by name.\n     *\n     * @param {string} name - The name of the clip.\n     * @returns {SpriteAnimationClip} The clip.\n     */\n    clip(name: string): SpriteAnimationClip;\n    /**\n     * Plays a sprite animation clip by name. If the animation clip is already playing then this\n     * will do nothing.\n     *\n     * @param {string} name - The name of the clip to play.\n     * @returns {SpriteAnimationClip} The clip that started playing.\n     */\n    play(name: string): SpriteAnimationClip;\n    /**\n     * Pauses the current animation clip.\n     */\n    pause(): void;\n    /**\n     * Resumes the current paused animation clip.\n     */\n    resume(): void;\n    /**\n     * Stops the current animation clip and resets it to the first frame.\n     */\n    stop(): void;\n}\n\n\n/** @typedef {import(\'./manager.js\').SoundManager} SoundManager */\n/**\n * Represents an audio listener - used internally.\n *\n * @ignore\n */\ndeclare class Listener {\n    /**\n     * Create a new listener instance.\n     *\n     * @param {SoundManager} manager - The sound manager.\n     */\n    constructor(manager: SoundManager);\n    /**\n     * @type {SoundManager}\n     * @private\n     */\n    private _manager;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private position;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private velocity;\n    /**\n     * @type {Mat4}\n     * @private\n     */\n    private orientation;\n    /**\n     * Get the position of the listener.\n     *\n     * @returns {Vec3} The position of the listener.\n     */\n    getPosition(): Vec3;\n    /**\n     * Set the position of the listener.\n     *\n     * @param {Vec3} position - The new position of the listener.\n     */\n    setPosition(position: Vec3): void;\n    /**\n     * Get the velocity of the listener.\n     *\n     * @returns {Vec3} The velocity of the listener.\n     * @deprecated\n     */\n    getVelocity(): Vec3;\n    /**\n     * Set the velocity of the listener.\n     *\n     * @param {Vec3} velocity - The new velocity of the listener.\n     * @deprecated\n     */\n    setVelocity(velocity: Vec3): void;\n    /**\n     * Set the orientation matrix of the listener.\n     *\n     * @param {Mat4} orientation - The new orientation matrix of the listener.\n     */\n    setOrientation(orientation: Mat4): void;\n    /**\n     * Get the orientation matrix of the listener.\n     *\n     * @returns {Mat4} The orientation matrix of the listener.\n     */\n    getOrientation(): Mat4;\n    /**\n     * Get the listener.\n     *\n     * @type {AudioListener|null}\n     */\n    get listener(): AudioListener;\n}\n\n/**\n * The SoundManager is used to load and play audio. It also applies system-wide settings like\n * global volume, suspend and resume.\n *\n * @augments EventHandler\n */\ndeclare class SoundManager extends EventHandler {\n    /**\n     * Create a new SoundManager instance.\n     *\n     * @param {object} [options] - Options options object.\n     * @param {boolean} [options.forceWebAudioApi] - Always use the Web Audio API, even if check\n     * indicates that it is not available.\n     */\n    constructor(options?: {\n        forceWebAudioApi?: boolean;\n    });\n    /**\n     * @type {AudioContext}\n     * @private\n     */\n    private _context;\n    /**\n     * The current state of the underlying AudioContext.\n     *\n     * @type {string}\n     * @private\n     */\n    private _state;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _forceWebAudioApi;\n    _resumeContext: any;\n    _resumeContextAttached: boolean;\n    _unlock: any;\n    _unlockAttached: boolean;\n    listener: Listener;\n    _volume: number;\n    suspended: boolean;\n    /**\n     * Global volume for the manager. All {@link SoundInstance}s will scale their volume with this\n     * volume. Valid between [0, 1].\n     *\n     * @type {number}\n     */\n    set volume(arg: number);\n    get volume(): number;\n    /**\n     * Get the Web Audio API context.\n     *\n     * @type {AudioContext}\n     * @ignore\n     */\n    get context(): AudioContext;\n    suspend(): void;\n    resume(): void;\n    destroy(): void;\n    /**\n     * Create a new {@link Channel} and begin playback of the sound.\n     *\n     * @param {Sound} sound - The Sound object to play.\n     * @param {object} options - Optional options object.\n     * @param {number} [options.volume] - The volume to playback at, between 0 and 1.\n     * @param {boolean} [options.loop] - Whether to loop the sound when it reaches the end.\n     * @returns {Channel} The channel playing the sound.\n     * @private\n     */\n    private playSound;\n    /**\n     * Create a new {@link Channel3d} and begin playback of the sound at the position specified.\n     *\n     * @param {Sound} sound - The Sound object to play.\n     * @param {Vec3} position - The position of the sound in 3D space.\n     * @param {object} options - Optional options object.\n     * @param {number} [options.volume] - The volume to playback at, between 0 and 1.\n     * @param {boolean} [options.loop] - Whether to loop the sound when it reaches the end.\n     * @returns {Channel3d} The 3D channel playing the sound.\n     * @private\n     */\n    private playSound3d;\n    /**\n     * Attempt to resume the AudioContext, but safely handle failure scenarios.\n     * When the browser window loses focus (i.e. switching tab, hiding the app on mobile, etc),\n     * the AudioContext state will be set to \'interrupted\' (on iOS Safari) or \'suspended\' (on other\n     * browsers), and \'resume\' must be expliclty called. However, the Auto-Play policy might block\n     * the AudioContext from running - in those cases, we need to add the interaction listeners,\n     * making the AudioContext be resumed later.\n     *\n     * @private\n     */\n    private _safelyResumeContext;\n    /**\n     * Add the necessary Window EventListeners for resuming the AudioContext to comply with auto-play policies.\n     * For more info, https://developers.google.com/web/updates/2018/11/web-audio-autoplay.\n     *\n     * @private\n     */\n    private _addAudioContextUserInteractionListeners;\n}\n\ndeclare class SoundComponentData {\n    enabled: boolean;\n}\n\n\n\n/**\n * Manages creation of {@link SoundComponent}s.\n *\n * @augments ComponentSystem\n */\ndeclare class SoundComponentSystem extends ComponentSystem {\n    /**\n     * Create a SoundComponentSystem.\n     *\n     * @param {Application} app - The Application.\n     * @param {SoundManager} manager - The sound manager.\n     */\n    constructor(app: Application, manager: SoundManager);\n    id: string;\n    ComponentType: typeof SoundComponent;\n    DataType: typeof SoundComponentData;\n    schema: string[];\n    /**\n     * Gets / sets the sound manager.\n     *\n     * @type {SoundManager}\n     */\n    manager: SoundManager;\n    /**\n     * Sets / gets the volume for the entire Sound system. All sounds will have their volume\n     * multiplied by this value. Valid between [0, 1].\n     *\n     * @type {number}\n     */\n    set volume(arg: number);\n    get volume(): number;\n    /**\n     * Gets the AudioContext currently used by the sound manager. Requires Web Audio API support.\n     * Returns null if the device does not support the Web Audio API.\n     *\n     * @type {AudioContext|null}\n     */\n    get context(): AudioContext;\n    initializeComponentData(component: any, data: any, properties: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    onUpdate(dt: any): void;\n    onBeforeRemove(entity: any, component: any): void;\n}\n\n/**\n * Represents the resource of an audio asset.\n */\ndeclare class Sound {\n    /**\n     * Create a new Sound instance.\n     *\n     * @param {HTMLAudioElement|AudioBuffer} resource - If the Web Audio API is supported, pass an\n     * AudioBuffer object, otherwise an Audio object.\n     */\n    constructor(resource: HTMLAudioElement | AudioBuffer);\n    /**\n     * If the Web Audio API is not supported this contains the audio data.\n     *\n     * @type {HTMLAudioElement}\n     */\n    audio: HTMLAudioElement;\n    /**\n     * If the Web Audio API is supported this contains the audio data.\n     *\n     * @type {AudioBuffer}\n     */\n    buffer: AudioBuffer;\n    /**\n     * Gets the duration of the sound. If the sound is not loaded it returns 0.\n     *\n     * @type {number}\n     */\n    get duration(): number;\n}\n\n\n\n/**\n * A SoundInstance plays a {@link Sound}.\n *\n * @augments EventHandler\n */\ndeclare class SoundInstance extends EventHandler {\n    /**\n     * Create a new SoundInstance instance.\n     *\n     * @param {SoundManager} manager - The sound manager.\n     * @param {Sound} sound - The sound to play.\n     * @param {object} options - Options for the instance.\n     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.\n     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.\n     * @param {boolean} [options.loop=false] - Whether the sound should loop when it reaches the\n     * end or not.\n     * @param {number} [options.startTime=0] - The time from which the playback will start in\n     * seconds. Default is 0 to start at the beginning.\n     * @param {number} [options.duration=0] - The total time after the startTime in seconds when\n     * playback will stop or restart if loop is true.\n     * @param {Function} [options.onPlay=null] - Function called when the instance starts playing.\n     * @param {Function} [options.onPause=null] - Function called when the instance is paused.\n     * @param {Function} [options.onResume=null] - Function called when the instance is resumed.\n     * @param {Function} [options.onStop=null] - Function called when the instance is stopped.\n     * @param {Function} [options.onEnd=null] - Function called when the instance ends.\n     */\n    constructor(manager: SoundManager, sound: Sound, options: {\n        volume?: number;\n        pitch?: number;\n        loop?: boolean;\n        startTime?: number;\n        duration?: number;\n        onPlay?: Function;\n        onPause?: Function;\n        onResume?: Function;\n        onStop?: Function;\n        onEnd?: Function;\n    });\n    /**\n     * Gets the source that plays the sound resource. If the Web Audio API is not supported the\n     * type of source is [Audio](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio).\n     * Source is only available after calling play.\n     *\n     * @type {AudioBufferSourceNode}\n     */\n    source: AudioBufferSourceNode;\n    /**\n     * @type {SoundManager}\n     * @private\n     */\n    private _manager;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _volume;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _pitch;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _loop;\n    /**\n     * @type {Sound}\n     * @private\n     */\n    private _sound;\n    /**\n     * Start at \'stopped\'.\n     *\n     * @type {number}\n     * @private\n     */\n    private _state;\n    /**\n     * True if the manager was suspended.\n     *\n     * @type {boolean}\n     * @private\n     */\n    private _suspended;\n    /**\n     * True if we want to suspend the event handled to the \'onended\' event.\n     *\n     * @type {boolean}\n     * @private\n     */\n    private _suspendEndEvent;\n    /**\n     * True if we want to suspend firing instance events.\n     *\n     * @type {boolean}\n     * @private\n     */\n    private _suspendInstanceEvents;\n    /**\n     * If true then the instance will start playing its source when its created.\n     *\n     * @type {boolean}\n     * @private\n     */\n    private _playWhenLoaded;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _startTime;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _duration;\n    /**\n     * @type {number|null}\n     * @private\n     */\n    private _startOffset;\n    /** @private */\n    private _onPlayCallback;\n    /** @private */\n    private _onPauseCallback;\n    /** @private */\n    private _onResumeCallback;\n    /** @private */\n    private _onStopCallback;\n    /** @private */\n    private _onEndCallback;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _startedAt;\n    /**\n     * Manually keep track of the playback position because the Web Audio API does not\n     * provide a way to do this accurately if the playbackRate is not 1.\n     *\n     * @type {number}\n     * @private\n     */\n    private _currentTime;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _currentOffset;\n    /**\n     * The input node is the one that is connected to the source.\n     *\n     * @type {AudioNode|null}\n     * @private\n     */\n    private _inputNode;\n    /**\n     * The connected node is the one that is connected to the destination (speakers). Any\n     * external nodes will be connected to this node.\n     *\n     * @type {AudioNode|null}\n     * @private\n     */\n    private _connectorNode;\n    /**\n     * The first external node set by a user.\n     *\n     * @type {AudioNode|null}\n     * @private\n     */\n    private _firstNode;\n    /**\n     * The last external node set by a user.\n     *\n     * @type {AudioNode|null}\n     * @private\n     */\n    private _lastNode;\n    /** @private */\n    private _endedHandler;\n    /** @private */\n    private _isReady;\n    /** @private */\n    private _loadedMetadataHandler;\n    /** @private */\n    private _timeUpdateHandler;\n    /**\n     * Gets or sets the current time of the sound that is playing. If the value provided is bigger\n     * than the duration of the instance it will wrap from the beginning.\n     *\n     * @type {number}\n     */\n    set currentTime(arg: number);\n    get currentTime(): number;\n    /**\n     * The duration of the sound that the instance will play starting from startTime.\n     *\n     * @type {number}\n     */\n    set duration(arg: number);\n    get duration(): number;\n    /**\n     * Returns true if the instance is currently paused.\n     *\n     * @type {boolean}\n     */\n    get isPaused(): boolean;\n    /**\n     * Returns true if the instance is currently playing.\n     *\n     * @type {boolean}\n     */\n    get isPlaying(): boolean;\n    /**\n     * Returns true if the instance is currently stopped.\n     *\n     * @type {boolean}\n     */\n    get isStopped(): boolean;\n    /**\n     * Returns true if the instance is currently suspended because the window is not focused.\n     *\n     * @type {boolean}\n     */\n    get isSuspended(): boolean;\n    /**\n     * If true the instance will restart when it finishes playing.\n     *\n     * @type {boolean}\n     */\n    set loop(arg: boolean);\n    get loop(): boolean;\n    /**\n     * The pitch modifier to play the sound with. Must be larger than 0.01.\n     *\n     * @type {number}\n     */\n    set pitch(arg: number);\n    get pitch(): number;\n    /**\n     * The sound resource that the instance will play.\n     *\n     * @type {Sound}\n     */\n    set sound(arg: Sound);\n    get sound(): Sound;\n    /**\n     * The start time from which the sound will start playing.\n     *\n     * @type {number}\n     */\n    set startTime(arg: number);\n    get startTime(): number;\n    /**\n     * The volume modifier to play the sound with. In range 0-1.\n     *\n     * @type {number}\n     */\n    set volume(arg: number);\n    get volume(): number;\n    /** @private */\n    private _onPlay;\n    /** @private */\n    private _onPause;\n    /** @private */\n    private _onResume;\n    /** @private */\n    private _onStop;\n    /** @private */\n    private _onEnded;\n    /**\n     * Handle the manager\'s \'volumechange\' event.\n     *\n     * @private\n     */\n    private _onManagerVolumeChange;\n    /**\n     * Handle the manager\'s \'suspend\' event.\n     *\n     * @private\n     */\n    private _onManagerSuspend;\n    /**\n     * Handle the manager\'s \'resume\' event.\n     *\n     * @private\n     */\n    private _onManagerResume;\n    /**\n     * Creates internal audio nodes and connects them.\n     *\n     * @private\n     */\n    private _initializeNodes;\n    gain: GainNode;\n    /**\n     * Begins playback of sound. If the sound is not loaded this will return false. If the sound is\n     * already playing this will restart the sound.\n     *\n     * @returns {boolean} True if the sound was started.\n     */\n    play(): boolean;\n    /**\n     * Pauses playback of sound. Call resume() to resume playback from the same position.\n     *\n     * @returns {boolean} Returns true if the sound was paused.\n     */\n    pause(): boolean;\n    /**\n     * Resumes playback of the sound. Playback resumes at the point that the audio was paused.\n     *\n     * @returns {boolean} Returns true if the sound was resumed.\n     */\n    resume(): boolean;\n    /**\n     * Stops playback of sound. Calling play() again will restart playback from the beginning of\n     * the sound.\n     *\n     * @returns {boolean} Returns true if the sound was stopped.\n     */\n    stop(): boolean;\n    /**\n     * Connects external Web Audio API nodes. You need to pass the first node of the node graph\n     * that you created externally and the last node of that graph. The first node will be\n     * connected to the audio source and the last node will be connected to the destination of the\n     * AudioContext (e.g. speakers). Requires Web Audio API support.\n     *\n     * @param {AudioNode} firstNode - The first node that will be connected to the audio source of sound instances.\n     * @param {AudioNode} [lastNode] - The last node that will be connected to the destination of the AudioContext.\n     * If unspecified then the firstNode will be connected to the destination instead.\n     * @example\n     * var context = app.systems.sound.context;\n     * var analyzer = context.createAnalyzer();\n     * var distortion = context.createWaveShaper();\n     * var filter = context.createBiquadFilter();\n     * analyzer.connect(distortion);\n     * distortion.connect(filter);\n     * instance.setExternalNodes(analyzer, filter);\n     */\n    setExternalNodes(firstNode: AudioNode, lastNode?: AudioNode): void;\n    /**\n     * Clears any external nodes set by {@link SoundInstance#setExternalNodes}.\n     */\n    clearExternalNodes(): void;\n    /**\n     * Gets any external nodes set by {@link SoundInstance#setExternalNodes}.\n     *\n     * @returns {AudioNode[]} Returns an array that contains the two nodes set by\n     * {@link SoundInstance#setExternalNodes}.\n     */\n    getExternalNodes(): AudioNode[];\n    /**\n     * Creates the source for the instance.\n     *\n     * @returns {AudioBufferSourceNode|null} Returns the created source or null if the sound\n     * instance has no {@link Sound} associated with it.\n     * @private\n     */\n    private _createSource;\n    /**\n     * Sets the current time taking into account the time the instance started playing, the current\n     * pitch and the current time offset.\n     *\n     * @private\n     */\n    private _updateCurrentTime;\n    /**\n     * Handle the manager\'s \'destroy\' event.\n     *\n     * @private\n     */\n    private _onManagerDestroy;\n}\n\n\n/**\n * The SoundSlot controls playback of an audio asset.\n *\n * @augments EventHandler\n */\ndeclare class SoundSlot extends EventHandler {\n    /**\n     * Create a new SoundSlot.\n     *\n     * @param {SoundComponent} component - The Component that created this slot.\n     * @param {string} [name] - The name of the slot. Defaults to \'Untitled\'.\n     * @param {object} [options] - Settings for the slot.\n     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.\n     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.\n     * @param {boolean} [options.loop=false] - If true the sound will restart when it reaches the\n     * end.\n     * @param {number} [options.startTime=0] - The start time from which the sound will start\n     * playing.\n     * @param {number} [options.duration=null] - The duration of the sound that the slot will play\n     * starting from startTime.\n     * @param {boolean} [options.overlap=false] - If true then sounds played from slot will be\n     * played independently of each other. Otherwise the slot will first stop the current sound\n     * before starting the new one.\n     * @param {boolean} [options.autoPlay=false] - If true the slot will start playing as soon as\n     * its audio asset is loaded.\n     * @param {number} [options.asset=null] - The asset id of the audio asset that is going to be\n     * played by this slot.\n     */\n    constructor(component: SoundComponent, name?: string, options?: {\n        volume?: number;\n        pitch?: number;\n        loop?: boolean;\n        startTime?: number;\n        duration?: number;\n        overlap?: boolean;\n        autoPlay?: boolean;\n        asset?: number;\n    });\n    /**\n     * The name of the slot.\n     *\n     * @type {string}\n     */\n    name: string;\n    /**\n     * An array that contains all the {@link SoundInstance}s currently being played by the slot.\n     *\n     * @type {SoundInstance[]}\n     */\n    instances: SoundInstance[];\n    _component: SoundComponent;\n    _assets: AssetRegistry;\n    _manager: any;\n    _volume: number;\n    _pitch: number;\n    _loop: boolean;\n    _duration: number;\n    _startTime: number;\n    _overlap: boolean;\n    _autoPlay: boolean;\n    _firstNode: AudioNode;\n    _lastNode: AudioNode;\n    _asset: number;\n    _onInstancePlayHandler: any;\n    _onInstancePauseHandler: any;\n    _onInstanceResumeHandler: any;\n    _onInstanceStopHandler: any;\n    _onInstanceEndHandler: any;\n    /**\n     * Plays a sound. If {@link SoundSlot#overlap} is true the new sound instance will be played\n     * independently of any other instances already playing. Otherwise existing sound instances\n     * will stop before playing the new sound.\n     *\n     * @returns {SoundInstance} The new sound instance.\n     */\n    play(): SoundInstance;\n    /**\n     * Pauses all sound instances. To continue playback call {@link SoundSlot#resume}.\n     *\n     * @returns {boolean} True if the sound instances paused successfully, false otherwise.\n     */\n    pause(): boolean;\n    /**\n     * Resumes playback of all paused sound instances.\n     *\n     * @returns {boolean} True if any instances were resumed.\n     */\n    resume(): boolean;\n    /**\n     * Stops playback of all sound instances.\n     *\n     * @returns {boolean} True if any instances were stopped.\n     */\n    stop(): boolean;\n    /**\n     * Loads the asset assigned to this slot.\n     */\n    load(): void;\n    /**\n     * Connect external Web Audio API nodes. Any sound played by this slot will automatically\n     * attach the specified nodes to the source that plays the sound. You need to pass the first\n     * node of the node graph that you created externally and the last node of that graph. The\n     * first node will be connected to the audio source and the last node will be connected to the\n     * destination of the AudioContext (e.g. speakers).\n     *\n     * @param {AudioNode} firstNode - The first node that will be connected to the audio source of\n     * sound instances.\n     * @param {AudioNode} [lastNode] - The last node that will be connected to the destination of\n     * the AudioContext. If unspecified then the firstNode will be connected to the destination\n     * instead.\n     * @example\n     * var context = app.systems.sound.context;\n     * var analyzer = context.createAnalyzer();\n     * var distortion = context.createWaveShaper();\n     * var filter = context.createBiquadFilter();\n     * analyzer.connect(distortion);\n     * distortion.connect(filter);\n     * slot.setExternalNodes(analyzer, filter);\n     */\n    setExternalNodes(firstNode: AudioNode, lastNode?: AudioNode): void;\n    /**\n     * Clears any external nodes set by {@link SoundSlot#setExternalNodes}.\n     */\n    clearExternalNodes(): void;\n    /**\n     * Gets an array that contains the two external nodes set by {@link SoundSlot#setExternalNodes}.\n     *\n     * @returns {AudioNode[]} An array of 2 elements that contains the first and last nodes set by\n     * {@link SoundSlot#setExternalNodes}.\n     */\n    getExternalNodes(): AudioNode[];\n    /**\n     * Reports whether an asset is set on this slot.\n     *\n     * @returns {boolean} Returns true if the slot has an asset assigned.\n     * @private\n     */\n    private _hasAsset;\n    /**\n     * Creates a new {@link SoundInstance} with the properties of the slot.\n     *\n     * @returns {SoundInstance} The new instance.\n     * @private\n     */\n    private _createInstance;\n    _onInstancePlay(instance: any): void;\n    _onInstancePause(instance: any): void;\n    _onInstanceResume(instance: any): void;\n    _onInstanceStop(instance: any): void;\n    _onInstanceEnd(instance: any): void;\n    _onAssetAdd(asset: any): void;\n    _onAssetLoad(asset: any): void;\n    _onAssetRemoved(asset: any): void;\n    updatePosition(position: any): void;\n    /**\n     * The asset id.\n     *\n     * @type {number|null}\n     */\n    set asset(arg: number);\n    get asset(): number;\n    /**\n     * If true the slot will begin playing as soon as it is loaded.\n     *\n     * @type {boolean}\n     */\n    set autoPlay(arg: boolean);\n    get autoPlay(): boolean;\n    /**\n     * The duration of the sound that the slot will play starting from startTime.\n     *\n     * @type {number}\n     */\n    set duration(arg: number);\n    get duration(): number;\n    /**\n     * Returns true if the asset of the slot is loaded.\n     *\n     * @type {boolean}\n     */\n    get isLoaded(): boolean;\n    /**\n     * Returns true if the slot is currently paused.\n     *\n     * @type {boolean}\n     */\n    get isPaused(): boolean;\n    /**\n     * Returns true if the slot is currently playing.\n     *\n     * @type {boolean}\n     */\n    get isPlaying(): boolean;\n    /**\n     * Returns true if the slot is currently stopped.\n     *\n     * @type {boolean}\n     */\n    get isStopped(): boolean;\n    /**\n     * If true the slot will restart when it finishes playing.\n     *\n     * @type {boolean}\n     */\n    set loop(arg: boolean);\n    get loop(): boolean;\n    /**\n     * If true then sounds played from slot will be played independently of each other. Otherwise\n     * the slot will first stop the current sound before starting the new one.\n     *\n     * @type {boolean}\n     */\n    set overlap(arg: boolean);\n    get overlap(): boolean;\n    /**\n     * The pitch modifier to play the sound with. Must be larger than 0.01.\n     *\n     * @type {number}\n     */\n    set pitch(arg: number);\n    get pitch(): number;\n    /**\n     * The start time from which the sound will start playing.\n     *\n     * @type {number}\n     */\n    set startTime(arg: number);\n    get startTime(): number;\n    /**\n     * The volume modifier to play the sound with. In range 0-1.\n     *\n     * @type {number}\n     */\n    set volume(arg: number);\n    get volume(): number;\n}\n\n\n\n\n/** @typedef {import(\'../../entity.js\').Entity} Entity */\n/** @typedef {import(\'../../../sound/instance.js\').SoundInstance} SoundInstance */\n/** @typedef {import(\'./system.js\').SoundComponentSystem} SoundComponentSystem */\n/**\n * The Sound Component controls playback of {@link Sound}s.\n *\n * @augments Component\n */\ndeclare class SoundComponent extends Component {\n    /**\n     * Create a new Sound Component.\n     *\n     * @param {SoundComponentSystem} system - The ComponentSystem that created this component.\n     * @param {Entity} entity - The entity that the Component is attached to.\n     */\n    constructor(system: SoundComponentSystem, entity: Entity);\n    /** @private */\n    private _volume;\n    /** @private */\n    private _pitch;\n    /** @private */\n    private _positional;\n    /** @private */\n    private _refDistance;\n    /** @private */\n    private _maxDistance;\n    /** @private */\n    private _rollOffFactor;\n    /** @private */\n    private _distanceModel;\n    /**\n     * @type {Object.<string, SoundSlot>}\n     * @private\n     */\n    private _slots;\n    /** @private */\n    private _playingBeforeDisable;\n    /**\n     * Update the specified property on all sound instances.\n     *\n     * @param {string} property - The name of the SoundInstance property to update.\n     * @param {string|number} value - The value to set the property to.\n     * @param {boolean} isFactor - True if the value is a factor of the slot property or false\n     * if it is an absolute value.\n     * @private\n     */\n    private _updateSoundInstances;\n    /**\n     * Determines which algorithm to use to reduce the volume of the sound as it moves away from\n     * the listener. Can be:\n     *\n     * - {@link DISTANCE_LINEAR}\n     * - {@link DISTANCE_INVERSE}\n     * - {@link DISTANCE_EXPONENTIAL}\n     *\n     * Defaults to {@link DISTANCE_LINEAR}.\n     *\n     * @type {string}\n     */\n    set distanceModel(arg: string);\n    get distanceModel(): string;\n    /**\n     * The maximum distance from the listener at which audio falloff stops. Note the volume of the\n     * audio is not 0 after this distance, but just doesn\'t fall off anymore. Defaults to 10000.\n     *\n     * @type {number}\n     */\n    set maxDistance(arg: number);\n    get maxDistance(): number;\n    /**\n     * The reference distance for reducing volume as the sound source moves further from the\n     * listener. Defaults to 1.\n     *\n     * @type {number}\n     */\n    set refDistance(arg: number);\n    get refDistance(): number;\n    /**\n     * The factor used in the falloff equation. Defaults to 1.\n     *\n     * @type {number}\n     */\n    set rollOffFactor(arg: number);\n    get rollOffFactor(): number;\n    /**\n     * The pitch modifier to play the audio with. Must be larger than 0.01. Defaults to 1.\n     *\n     * @type {number}\n     */\n    set pitch(arg: number);\n    get pitch(): number;\n    /**\n     * The volume modifier to play the audio with. In range 0-1. Defaults to 1.\n     *\n     * @type {number}\n     */\n    set volume(arg: number);\n    get volume(): number;\n    /**\n     * If true the audio will play back at the location of the Entity in space, so the audio will\n     * be affected by the position of the {@link AudioListenerComponent}. Defaults to true.\n     *\n     * @type {boolean}\n     */\n    set positional(arg: boolean);\n    get positional(): boolean;\n    /**\n     * A dictionary that contains the {@link SoundSlot}s managed by this SoundComponent.\n     *\n     * @type {Object.<string, SoundSlot>}\n     */\n    set slots(arg: {\n        [x: string]: SoundSlot;\n    });\n    get slots(): {\n        [x: string]: SoundSlot;\n    };\n    onRemove(): void;\n    /**\n     * Creates a new {@link SoundSlot} with the specified name.\n     *\n     * @param {string} name - The name of the slot.\n     * @param {object} [options] - Settings for the slot.\n     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.\n     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.\n     * @param {boolean} [options.loop=false] - If true the sound will restart when it reaches the end.\n     * @param {number} [options.startTime=0] - The start time from which the sound will start playing.\n     * @param {number} [options.duration=null] - The duration of the sound that the slot will play\n     * starting from startTime.\n     * @param {boolean} [options.overlap=false] - If true then sounds played from slot will be\n     * played independently of each other. Otherwise the slot will first stop the current sound\n     * before starting the new one.\n     * @param {boolean} [options.autoPlay=false] - If true the slot will start playing as soon as\n     * its audio asset is loaded.\n     * @param {number} [options.asset=null] - The asset id of the audio asset that is going to be\n     * played by this slot.\n     * @returns {SoundSlot|null} The new slot or null if the slot already exists.\n     * @example\n     * // get an asset by id\n     * var asset = app.assets.get(10);\n     * // add a slot\n     * this.entity.sound.addSlot(\'beep\', {\n     *     asset: asset\n     * });\n     * // play\n     * this.entity.sound.play(\'beep\');\n     */\n    addSlot(name: string, options?: {\n        volume?: number;\n        pitch?: number;\n        loop?: boolean;\n        startTime?: number;\n        duration?: number;\n        overlap?: boolean;\n        autoPlay?: boolean;\n        asset?: number;\n    }): SoundSlot | null;\n    /**\n     * Removes the {@link SoundSlot} with the specified name.\n     *\n     * @param {string} name - The name of the slot.\n     * @example\n     * // remove a slot called \'beep\'\n     * this.entity.sound.removeSlot(\'beep\');\n     */\n    removeSlot(name: string): void;\n    /**\n     * Returns the slot with the specified name.\n     *\n     * @param {string} name - The name of the slot.\n     * @returns {SoundSlot|undefined} The slot.\n     * @example\n     * // get a slot and set its volume\n     * this.entity.sound.slot(\'beep\').volume = 0.5;\n     *\n     */\n    slot(name: string): SoundSlot | undefined;\n    /**\n     * Begins playing the sound slot with the specified name. The slot will restart playing if it\n     * is already playing unless the overlap field is true in which case a new sound will be\n     * created and played.\n     *\n     * @param {string} name - The name of the {@link SoundSlot} to play.\n     * @returns {SoundInstance|null} The sound instance that will be played. Returns null if the\n     * component or its parent entity is disabled or if the SoundComponent has no slot with the\n     * specified name.\n     * @example\n     * // get asset by id\n     * var asset = app.assets.get(10);\n     * // create a slot and play it\n     * this.entity.sound.addSlot(\'beep\', {\n     *     asset: asset\n     * });\n     * this.entity.sound.play(\'beep\');\n     */\n    play(name: string): SoundInstance | null;\n    /**\n     * Pauses playback of the slot with the specified name. If the name is undefined then all slots\n     * currently played will be paused. The slots can be resumed by calling {@link SoundComponent#resume}.\n     *\n     * @param {string} [name] - The name of the slot to pause. Leave undefined to pause everything.\n     * @example\n     * // pause all sounds\n     * this.entity.sound.pause();\n     * // pause a specific sound\n     * this.entity.sound.pause(\'beep\');\n     */\n    pause(name?: string): void;\n    /**\n     * Resumes playback of the sound slot with the specified name if it\'s paused. If no name is\n     * specified all slots will be resumed.\n     *\n     * @param {string} [name] - The name of the slot to resume. Leave undefined to resume everything.\n     * @example\n     * // resume all sounds\n     * this.entity.sound.resume();\n     * // resume a specific sound\n     * this.entity.sound.resume(\'beep\');\n     */\n    resume(name?: string): void;\n    /**\n     * Stops playback of the sound slot with the specified name if it\'s paused. If no name is\n     * specified all slots will be stopped.\n     *\n     * @param {string} [name] - The name of the slot to stop. Leave undefined to stop everything.\n     * @example\n     * // stop all sounds\n     * this.entity.sound.stop();\n     * // stop a specific sound\n     * this.entity.sound.stop(\'beep\');\n     */\n    stop(name?: string): void;\n}\n\ndeclare class ScrollViewComponentData {\n    enabled: boolean;\n}\n\n/**\n * Manages creation of {@link ScrollViewComponent}s.\n *\n * @augments ComponentSystem\n */\ndeclare class ScrollViewComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof ScrollViewComponent;\n    DataType: typeof ScrollViewComponentData;\n    schema: {\n        name: string;\n        type: string;\n    }[];\n    initializeComponentData(component: any, data: any, properties: any): void;\n    onUpdate(dt: any): void;\n    _onRemoveComponent(entity: any, component: any): void;\n}\n\n/**\n * An EntityReference can be used in scenarios where a component has one or more properties that\n * refer to entities in the scene graph. Using an EntityReference simplifies the job of dealing\n * with the presence or non-presence of the underlying entity and its components, especially when\n * it comes to dealing with the runtime addition or removal of components, and addition/removal of\n * associated event listeners.\n *\n * ## Usage Scenario ##\n *\n * Imagine that you\'re creating a Checkbox component, which has a reference to an entity\n * representing the checkmark/tickmark that is rendered in the Checkbox. The reference is modeled\n * as an entity guid property on the Checkbox component, called simply \'checkmark\'. We have to\n * implement a basic piece of functionality whereby when the \'checkmark\' entity reference is set,\n * the Checkbox component must toggle the tint of an ImageElementComponent present on the checkmark\n * entity to indicate whether the Checkbox is currently in the active or inactive state.\n *\n * Without using an EntityReference, the Checkbox component must implement some or all of the\n * following:\n *\n * - Listen for its \'checkmark\' property being set to a valid guid, and retrieve a reference to the\n *   entity associated with this guid whenever it changes (i.e. via `app.root.findByGuid()`).\n * - Once a valid entity is received, check to see whether it has already has an\n *   ImageElementComponent or not:\n *   - If it has one, proceed to set the tint of the ImageElementComponent based on whether the\n *     Checkbox is currently active or inactive.\n *   - If it doesn\'t have one, add a listener to wait for the addition of an ImageElementComponent,\n *     and then apply the tint once one becomes present.\n * - If the checkmark entity is then reassigned (such as if the user reassigns the field in the\n *   editor, or if this is done at runtime via a script), a well-behaved Checkbox component must\n *   also undo the tinting so that no lasting effect is applied to the old entity.\n * - If the checkmark entity\'s ImageElementComponent is removed and then another\n *   ImageElementComponent is added, the Checkbox component must handle this in order to re-apply\n *   the tint.\n * - To prevent memory leaks, the Checkbox component must also make sure to correctly remove\n *   listeners in each of the following scenarios:\n *   - Destruction of the Checkbox component.\n *   - Reassignment of the checkmark entity.\n *   - Removal of the ImageElementComponent.\n * - It must also be careful not to double-add listeners in any of the above code paths, to avoid\n *   various forms of undesirable behavior.\n *\n * If the Checkbox component becomes more complicated and has multiple entity reference properties,\n * all of the above must be done correctly for each entity. Similarly, if it depends on multiple\n * different component types being present on the entities it has references to, it must correctly\n * handle the presence and non-presence of each of these components in the various possible\n * sequences of addition and removal. In addition to generating a lot of boilerplate, it\'s also\n * very easy for subtle mistakes to be made that lead to memory leaks, null reference errors or\n * visual bugs.\n *\n * By using an EntityReference, all of the above can be reduced to the following:\n *\n * ```javascript\n * function CheckboxComponent() {\n *    this._checkmarkReference = new pc.EntityReference(this, \'checkmark\', {\n *        \'element#gain\': this._onCheckmarkImageElementGain,\n *        \'element#lose\': this._onCheckmarkImageElementLose\n *    });\n * }\n * ```\n *\n * Using the above code snippet, the `_onCheckmarkImageElementGain()` listener will be called\n * in either of the following scenarios:\n *\n * 1. A checkmark entity is assigned and already has an ElementComponent.\n * 2. A checkmark entity is assigned that does not have an ElementComponent, but one is added\n * later.\n *\n * Similarly, the `_onCheckmarkImageElementLose()` listener will be called in either of the\n * following scenarios:\n *\n * 1. An ElementComponent is removed from the checkmark entity.\n * 2. The checkmark entity is re-assigned (i.e. to another entity), or nullified. In this\n * scenario the callback will only be called if the entity actually had an ElementComponent.\n *\n * ## Event String Format ##\n *\n * The event string (i.e. "element#gain" in the above examples) is of the format\n * `sourceName#eventName`, and is defined as follows:\n *\n * - `sourceName`: May be any component name, or the special string "entity", which refers to the\n * entity itself.\n * - `eventName`: May be the name of any event dispatched by the relevant component or entity, as\n * well as the special strings "gain" or "lose".\n *\n * Some examples are as follows:\n *\n * ```javascript\n * "entity#destroy"    // Called when the entity managed by the entity reference is destroyed.\n * "element#set:width" // Called when the width of an ElementComponent is set.\n * ```\n *\n * When the entity reference changes to another entity (or null) the set:entity event is fired.\n *\n * ## Ownership and Destruction ##\n *\n * The lifetime of an ElementReference is tied to the parent component that instantiated it. This\n * coupling is indicated by the provision of the `this` keyword to the ElementReference\'s\n * constructor in the above examples (i.e. `new pc.EntityReference(this, ...`).\n *\n * Any event listeners managed by the ElementReference are automatically cleaned up when the parent\n * component is removed or the parent component\'s entity is destroyed – as such you should never\n * have to worry about dangling listeners.\n *\n * Additionally, any callbacks listed in the event config will automatically be called in the scope\n * of the parent component – you should never have to worry about manually calling\n * `Function.bind()`.\n *\n * @augments EventHandler\n * @ignore\n */\ndeclare class EntityReference extends EventHandler {\n    /**\n     * Helper class used for managing component properties that represent entity references.\n     *\n     * @param {Component} parentComponent - A reference to the parent component that owns this\n     * entity reference.\n     * @param {string} entityPropertyName - The name of the component property that contains the\n     * entity guid.\n     * @param {object<string, Function>} [eventConfig] - A map of event listener configurations.\n     */\n    constructor(parentComponent: Component, entityPropertyName: string, eventConfig: any);\n    _parentComponent: Component;\n    _entityPropertyName: string;\n    _entity: Entity;\n    _app: Application;\n    _configureEventListeners(externalEventConfig: any, internalEventConfig: any): void;\n    _eventListenerConfigs: {\n        id: string;\n        sourceName: string;\n        eventName: string;\n        callback: any;\n        scope: any;\n    }[];\n    _listenerStatusFlags: {};\n    _gainListeners: {};\n    _loseListeners: {};\n    _parseEventListenerConfig(eventConfig: any, prefix: any, scope: any): {\n        id: string;\n        sourceName: string;\n        eventName: string;\n        callback: any;\n        scope: any;\n    }[];\n    _toggleLifecycleListeners(onOrOff: any): void;\n    _onSetEntity(name: any, oldValue: any, newValue: any): void;\n    /**\n     * Must be called from the parent component\'s onEnable() method in order for entity references\n     * to be correctly resolved when {@link Entity#clone} is called.\n     *\n     * @private\n     */\n    private onParentComponentEnable;\n    _onSceneLoaded(): void;\n    _updateEntityReference(): void;\n    _onBeforeEntityChange(): void;\n    _onAfterEntityChange(): void;\n    _onComponentAdd(entity: any, component: any): void;\n    _onComponentRemove(entity: any, component: any): void;\n    _callAllGainOrLoseListeners(listenerMap: any): void;\n    _callGainOrLoseListener(componentName: any, listenerMap: any): void;\n    _toggleEntityListeners(onOrOff: any, isDestroying: any): void;\n    _toggleComponentListeners(onOrOff: any, componentName: any, isDestroying: any): void;\n    _safeToggleListener(onOrOff: any, config: any, isDestroying: any): void;\n    _getEventSource(sourceName: any, isDestroying: any): any;\n    _onEntityDestroy(entity: any): void;\n    _onParentComponentRemove(entity: any, component: any): void;\n    /**\n     * Convenience method indicating whether the entity exists and has a component of the provided\n     * type.\n     *\n     * @param {string} componentName - Name of the component.\n     * @returns {boolean} True if the entity exists and has a component of the provided type.\n     */\n    hasComponent(componentName: string): boolean;\n    /**\n     * A reference to the entity, if present.\n     *\n     * @type {Entity}\n     */\n    get entity(): Entity;\n}\n\ndeclare class ElementComponentData {\n    enabled: boolean;\n}\n\ndeclare class StandardMaterialOptionsBuilder {\n    _mapXForms: any[];\n    updateMinRef(options: any, device: any, scene: any, stdMat: any, objDefs: any, staticLightList: any, pass: any, sortedLights: any): void;\n    updateRef(options: any, device: any, scene: any, stdMat: any, objDefs: any, staticLightList: any, pass: any, sortedLights: any): void;\n    _updateSharedOptions(options: any, scene: any, stdMat: any, objDefs: any, pass: any): void;\n    _updateUVOptions(options: any, stdMat: any, objDefs: any, minimalOptions: any): void;\n    _updateMinOptions(options: any, stdMat: any): void;\n    _updateMaterialOptions(options: any, stdMat: any): void;\n    _updateEnvOptions(options: any, device: any, stdMat: any, scene: any): void;\n    _updateLightOptions(options: any, stdMat: any, objDefs: any, sortedLights: any, staticLightList: any): void;\n    _updateTexOptions(options: any, stdMat: any, p: any, hasUv0: any, hasUv1: any, hasVcolor: any, minimalOptions: any): any;\n    _collectLights(lType: any, lights: any, lightsFiltered: any, mask: any, staticLightList: any): void;\n    _getMapTransformID(xform: any, uv: any): any;\n}\n\n\n\n/**\n * Callback used by {@link StandardMaterialonUpdateShader }.\n */\nexport type UpdateShaderCallback = (options: any) => any;\n/**\n * Callback used by {@link StandardMaterial#onUpdateShader}.\n *\n * @callback UpdateShaderCallback\n * @param {*} options - An object with shader generator settings (based on current material and\n * scene properties), that you can change and then return. Properties of the object passed into\n * this function are documented in {@link StandardMaterial#onUpdateShader}.\n * @returns {*} Returned settings will be used by the shader.\n */\n/**\n * A Standard material is the main, general purpose material that is most often used for rendering.\n * It can approximate a wide variety of surface types and can simulate dynamic reflected light.\n * Most maps can use 3 types of input values in any combination: constant (color or number), mesh\n * vertex colors and a texture. All enabled inputs are multiplied together.\n *\n * @property {Color} ambient The ambient color of the material. This color value is 3-component\n * (RGB), where each component is between 0 and 1.\n * @property {Color} diffuse The diffuse color of the material. This color value is 3-component\n * (RGB), where each component is between 0 and 1. Defines basic surface color (aka albedo).\n * @property {boolean} diffuseTint Multiply main (primary) diffuse map and/or diffuse vertex color\n * by the constant diffuse value.\n * @property {Texture|null} diffuseMap The main (primary) diffuse map of the material (default is\n * null).\n * @property {number} diffuseMapUv Main (primary) diffuse map UV channel.\n * @property {Vec2} diffuseMapTiling Controls the 2D tiling of the main (primary) diffuse map.\n * @property {Vec2} diffuseMapOffset Controls the 2D offset of the main (primary) diffuse map. Each\n * component is between 0 and 1.\n * @property {number} diffuseMapRotation Controls the 2D rotation (in degrees) of the main\n * (primary) diffuse map.\n * @property {string} diffuseMapChannel Color channels of the main (primary) diffuse map to use.\n * Can be "r", "g", "b", "a", "rgb" or any swizzled combination.\n * @property {boolean} diffuseVertexColor Use mesh vertex colors for diffuse. If diffuseMap or are\n * diffuseTint are set, they\'ll be multiplied by vertex colors.\n * @property {string} diffuseVertexColorChannel Vertex color channels to use for diffuse. Can be\n * "r", "g", "b", "a", "rgb" or any swizzled combination.\n * @property {Texture|null} diffuseDetailMap The detail (secondary) diffuse map of the material\n * (default is null). Will only be used if main (primary) diffuse map is non-null.\n * @property {number} diffuseDetailMapUv Detail (secondary) diffuse map UV channel.\n * @property {Vec2} diffuseDetailMapTiling Controls the 2D tiling of the detail (secondary) diffuse\n * map.\n * @property {Vec2} diffuseDetailMapOffset Controls the 2D offset of the detail (secondary) diffuse\n * map. Each component is between 0 and 1.\n * @property {number} diffuseDetailMapRotation Controls the 2D rotation (in degrees) of the main\n * (secondary) diffuse map.\n * @property {string} diffuseDetailMapChannel Color channels of the detail (secondary) diffuse map\n * to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.\n * @property {string} diffuseDetailMode Determines how the main (primary) and detail (secondary)\n * diffuse maps are blended together. Can be:\n *\n * - {@link DETAILMODE_MUL}: Multiply together the primary and secondary colors.\n * - {@link DETAILMODE_ADD}: Add together the primary and secondary colors.\n * - {@link DETAILMODE_SCREEN}: Softer version of {@link DETAILMODE_ADD}.\n * - {@link DETAILMODE_OVERLAY}: Multiplies or screens the colors, depending on the primary color.\n * - {@link DETAILMODE_MIN}: Select whichever of the primary and secondary colors is darker,\n * component-wise.\n * - {@link DETAILMODE_MAX}: Select whichever of the primary and secondary colors is lighter,\n * component-wise.\n *\n * Defaults to {@link DETAILMODE_MUL}.\n * @property {Color} specular The specular color of the material. This color value is 3-component\n * (RGB), where each component is between 0 and 1. Defines surface reflection/specular color.\n * Affects specular intensity and tint.\n * @property {boolean} specularTint Multiply specular map and/or specular vertex color by the\n * constant specular value.\n * @property {Texture|null} specularMap The specular map of the material (default is null).\n * @property {number} specularMapUv Specular map UV channel.\n * @property {Vec2} specularMapTiling Controls the 2D tiling of the specular map.\n * @property {Vec2} specularMapOffset Controls the 2D offset of the specular map. Each component is\n * between 0 and 1.\n * @property {number} specularMapRotation Controls the 2D rotation (in degrees) of the specular map.\n * @property {string} specularMapChannel Color channels of the specular map to use. Can be "r", "g",\n * "b", "a", "rgb" or any swizzled combination.\n * @property {boolean} specularVertexColor Use mesh vertex colors for specular. If specularMap or\n * are specularTint are set, they\'ll be multiplied by vertex colors.\n * @property {string} specularVertexColorChannel Vertex color channels to use for specular. Can be\n * "r", "g", "b", "a", "rgb" or any swizzled combination.\n * @property {boolean} enableGGXSpecular Enables GGX specular. Also enables\n * {@link StandardMaterial#anisotropy}  parameter to set material anisotropy.\n * @property {number} anisotropy Defines amount of anisotropy. Requires\n * {@link StandardMaterial#enableGGXSpecular} is set to true.\n *\n * - When anisotropy == 0, specular is isotropic.\n * - When anisotropy < 0, anisotropy direction aligns with the tangent, and specular anisotropy\n * increases as the anisotropy value decreases to minimum of -1.\n * - When anisotropy > 0, anisotropy direction aligns with the bi-normal, and specular anisotropy\n * increases as anisotropy value increases to maximum of 1.\n *\n * @property {number} clearCoat Defines intensity of clear coat layer from 0 to 1. Clear coat layer\n * is disabled when clearCoat == 0. Default value is 0 (disabled).\n * @property {Texture|null} clearCoatMap Monochrome clear coat intensity map (default is null). If\n * specified, will be multiplied by normalized \'clearCoat\' value and/or vertex colors.\n * @property {number} clearCoatMapUv Clear coat intensity map UV channel.\n * @property {Vec2} clearCoatMapTiling Controls the 2D tiling of the clear coat intensity map.\n * @property {Vec2} clearCoatMapOffset Controls the 2D offset of the clear coat intensity map. Each\n * component is between 0 and 1.\n * @property {number} clearCoatMapRotation Controls the 2D rotation (in degrees) of the clear coat\n * intensity map.\n * @property {string} clearCoatMapChannel Color channel of the clear coat intensity map to use. Can\n * be "r", "g", "b" or "a".\n * @property {boolean} clearCoatVertexColor Use mesh vertex colors for clear coat intensity. If\n * clearCoatMap is set, it\'ll be multiplied by vertex colors.\n * @property {string} clearCoatVertexColorChannel Vertex color channel to use for clear coat\n * intensity. Can be "r", "g", "b" or "a".\n * @property {number} clearCoatGlossiness Defines the clear coat glossiness of the clear coat layer\n * from 0 (rough) to 1 (mirror).\n * @property {Texture|null} clearCoatGlossMap Monochrome clear coat glossiness map (default is\n * null). If specified, will be multiplied by normalized \'clearCoatGlossiness\' value and/or vertex\n * colors.\n * @property {number} clearCoatGlossMapUv Clear coat gloss map UV channel.\n * @property {Vec2} clearCoatGlossMapTiling Controls the 2D tiling of the clear coat gloss map.\n * @property {Vec2} clearCoatGlossMapOffset Controls the 2D offset of the clear coat gloss map.\n * Each component is between 0 and 1.\n * @property {number} clearCoatGlossMapRotation Controls the 2D rotation (in degrees) of the clear\n * coat gloss map.\n * @property {string} clearCoatGlossMapChannel Color channel of the clear coat gloss map to use.\n * Can be "r", "g", "b" or "a".\n * @property {boolean} clearCoatGlossVertexColor Use mesh vertex colors for clear coat glossiness.\n * If clearCoatGlossMap is set, it\'ll be multiplied by vertex colors.\n * @property {string} clearCoatGlossVertexColorChannel Vertex color channel to use for clear coat\n * glossiness. Can be "r", "g", "b" or "a".\n * @property {Texture|null} clearCoatNormalMap The clear coat normal map of the material (default\n * is null). The texture must contains normalized, tangent space normals.\n * @property {number} clearCoatNormalMapUv Clear coat normal map UV channel.\n * @property {Vec2} clearCoatNormalMapTiling Controls the 2D tiling of the main clear coat normal\n * map.\n * @property {Vec2} clearCoatNormalMapOffset Controls the 2D offset of the main clear coat normal\n * map. Each component is between 0 and 1.\n * @property {number} clearCoatNormalMapRotation Controls the 2D rotation (in degrees) of the main\n * clear coat map.\n * @property {number} clearCoatBumpiness The bumpiness of the clear coat layer. This value scales\n * the assigned main clear coat normal map. It should be normally between 0 (no bump mapping) and 1\n * (full bump mapping), but can be set to e.g. 2 to give even more pronounced bump effect.\n * @property {boolean} useMetalness Use metalness properties instead of specular. When enabled,\n * diffuse colors also affect specular instead of the dedicated specular map. This can be used as\n * alternative to specular color to save space. With metaless == 0, the pixel is assumed to be\n * dielectric, and diffuse color is used as normal. With metaless == 1, the pixel is fully\n * metallic, and diffuse color is used as specular color instead.\n * @property {number} metalness Defines how much the surface is metallic. From 0 (dielectric) to 1\n * (metal).\n * @property {Texture|null} metalnessMap Monochrome metalness map (default is null).\n * @property {number} metalnessMapUv Metalness map UV channel.\n * @property {Vec2} metalnessMapTiling Controls the 2D tiling of the metalness map.\n * @property {Vec2} metalnessMapOffset Controls the 2D offset of the metalness map. Each component\n * is between 0 and 1.\n * @property {number} metalnessMapRotation Controls the 2D rotation (in degrees) of the metalness\n * map.\n * @property {string} metalnessMapChannel Color channel of the metalness map to use. Can be "r",\n * "g", "b" or "a".\n * @property {boolean} metalnessVertexColor Use mesh vertex colors for metalness. If metalnessMap\n * is set, it\'ll be multiplied by vertex colors.\n * @property {string} metalnessVertexColorChannel Vertex color channel to use for metalness. Can be\n * "r", "g", "b" or "a".\n * @property {number} shininess Defines glossiness of the material from 0 (rough) to 100 (shiny\n * mirror). A higher shininess value results in a more focused specular highlight. Glossiness map/\n * vertex colors are always multiplied by this value (normalized to 0 - 1 range), or it is used\n * directly as constant output.\n * @property {Texture|null} glossMap Glossiness map (default is null). If specified, will be\n * multiplied by normalized \'shininess\' value and/or vertex colors.\n * @property {number} glossMapUv Gloss map UV channel.\n * @property {string} glossMapChannel Color channel of the gloss map to use. Can be "r", "g", "b"\n * or "a".\n * @property {Vec2} glossMapTiling Controls the 2D tiling of the gloss map.\n * @property {Vec2} glossMapOffset Controls the 2D offset of the gloss map. Each component is\n * between 0 and 1.\n * @property {number} glossMapRotation Controls the 2D rotation (in degrees) of the gloss map.\n * @property {boolean} glossVertexColor Use mesh vertex colors for glossiness. If glossMap is set,\n * it\'ll be multiplied by vertex colors.\n * @property {string} glossVertexColorChannel Vertex color channel to use for glossiness. Can be\n * "r", "g", "b" or "a".\n * @property {number} refraction Defines the visibility of refraction. Material can refract the\n * same cube map as used for reflections.\n * @property {number} refractionIndex Defines the index of refraction, i.e. The amount of\n * distortion. The value is calculated as (outerIor / surfaceIor), where inputs are measured\n * indices of refraction, the one around the object and the one of its own surface. In most\n * situations outer medium is air, so outerIor will be approximately 1. Then you only need to do\n * (1.0 / surfaceIor).\n * @property {Color} emissive The emissive color of the material. This color value is 3-component\n * (RGB), where each component is between 0 and 1.\n * @property {boolean} emissiveTint Multiply emissive map and/or emissive vertex color by the\n * constant emissive value.\n * @property {Texture|null} emissiveMap The emissive map of the material (default is null). Can be\n * HDR.\n * @property {number} emissiveIntensity Emissive color multiplier.\n * @property {number} emissiveMapUv Emissive map UV channel.\n * @property {Vec2} emissiveMapTiling Controls the 2D tiling of the emissive map.\n * @property {Vec2} emissiveMapOffset Controls the 2D offset of the emissive map. Each component is\n * between 0 and 1.\n * @property {number} emissiveMapRotation Controls the 2D rotation (in degrees) of the emissive\n * map.\n * @property {string} emissiveMapChannel Color channels of the emissive map to use. Can be "r",\n * "g", "b", "a", "rgb" or any swizzled combination.\n * @property {boolean} emissiveVertexColor Use mesh vertex colors for emission. If emissiveMap or\n * emissiveTint are set, they\'ll be multiplied by vertex colors.\n * @property {string} emissiveVertexColorChannel Vertex color channels to use for emission. Can be\n * "r", "g", "b", "a", "rgb" or any swizzled combination.\n * @property {number} opacity The opacity of the material. This value can be between 0 and 1, where\n * 0 is fully transparent and 1 is fully opaque. If you want the material to be semi-transparent\n * you also need to set the {@link Material#blendType} to {@link BLEND_NORMAL},\n * {@link BLEND_ADDITIVE} or any other mode. Also note that for most semi-transparent objects you\n * want {@link Material#depthWrite} to be false, otherwise they can fully occlude objects behind\n * them.\n * @property {Texture|null} opacityMap The opacity map of the material (default is null).\n * @property {number} opacityMapUv Opacity map UV channel.\n * @property {string} opacityMapChannel Color channel of the opacity map to use. Can be "r", "g",\n * "b" or "a".\n * @property {Vec2} opacityMapTiling Controls the 2D tiling of the opacity map.\n * @property {Vec2} opacityMapOffset Controls the 2D offset of the opacity map. Each component is\n * between 0 and 1.\n * @property {number} opacityMapRotation Controls the 2D rotation (in degrees) of the opacity map.\n * @property {boolean} opacityVertexColor Use mesh vertex colors for opacity. If opacityMap is set,\n * it\'ll be multiplied by vertex colors.\n * @property {string} opacityVertexColorChannel Vertex color channels to use for opacity. Can be\n * "r", "g", "b" or "a".\n * @property {boolean} opacityFadesSpecular used to specify whether specular and reflections are\n * faded out using {@link StandardMaterial#opacity}. Default is true. When set to false use\n * {@link Material#alphaFade} to fade out materials.\n * @property {number} alphaFade used to fade out materials when\n * {@link StandardMaterial#opacityFadesSpecular} is set to false.\n * @property {Texture|null} normalMap The main (primary) normal map of the material (default is\n * null). The texture must contains normalized, tangent space normals.\n * @property {number} normalMapUv Main (primary) normal map UV channel.\n * @property {Vec2} normalMapTiling Controls the 2D tiling of the main (primary) normal map.\n * @property {Vec2} normalMapOffset Controls the 2D offset of the main (primary) normal map. Each\n * component is between 0 and 1.\n * @property {number} normalMapRotation Controls the 2D rotation (in degrees) of the main (primary)\n * normal map.\n * @property {number} bumpiness The bumpiness of the material. This value scales the assigned main\n * (primary) normal map. It should be normally between 0 (no bump mapping) and 1 (full bump\n * mapping), but can be set to e.g. 2 to give even more pronounced bump effect.\n * @property {Texture|null} normalDetailMap The detail (secondary) normal map of the material\n * (default is null). Will only be used if main (primary) normal map is non-null.\n * @property {number} normalDetailMapUv Detail (secondary) normal map UV channel.\n * @property {Vec2} normalDetailMapTiling Controls the 2D tiling of the detail (secondary) normal\n * map.\n * @property {Vec2} normalDetailMapOffset Controls the 2D offset of the detail (secondary) normal\n * map. Each component is between 0 and 1.\n * @property {number} normalDetailMapRotation Controls the 2D rotation (in degrees) of the detail\n * (secondary) normal map.\n * @property {number} normalDetailMapBumpiness The bumpiness of the material. This value scales the\n * assigned detail (secondary) normal map. It should be normally between 0 (no bump mapping) and 1\n * (full bump mapping), but can be set to e.g. 2 to give even more pronounced bump effect.\n * @property {Texture|null} heightMap The height map of the material (default is null). Used for a\n * view-dependent parallax effect. The texture must represent the height of the surface where\n * darker pixels are lower and lighter pixels are higher. It is recommended to use it together with\n * a normal map.\n * @property {number} heightMapUv Height map UV channel.\n * @property {string} heightMapChannel Color channel of the height map to use. Can be "r", "g", "b"\n * or "a".\n * @property {Vec2} heightMapTiling Controls the 2D tiling of the height map.\n * @property {Vec2} heightMapOffset Controls the 2D offset of the height map. Each component is\n * between 0 and 1.\n * @property {number} heightMapRotation Controls the 2D rotation (in degrees) of the height map.\n * @property {number} heightMapFactor Height map multiplier. Affects the strength of the parallax\n * effect.\n * @property {Texture|null} sphereMap The spherical environment map of the material (default is\n * null). Affects reflections.\n * @property {Texture|null} cubeMap The cubic environment map of the material (default is null).\n * Overrides sphereMap. Affects reflections. If cubemap is prefiltered, will also affect ambient\n * color.\n * @property {number} cubeMapProjection The type of projection applied to the cubeMap property:\n * - {@link CUBEPROJ_NONE}: The cube map is treated as if it is infinitely far away.\n * - {@link CUBEPROJ_BOX}: Box-projection based on a world space axis-aligned bounding box.\n * Defaults to {@link CUBEPROJ_NONE}.\n * @property {BoundingBox} cubeMapProjectionBox The world space axis-aligned bounding box defining\n * the box-projection used for the cubeMap property. Only used when cubeMapProjection is set to\n * {@link CUBEPROJ_BOX}.\n * @property {number} reflectivity Environment map intensity.\n * @property {Texture|null} lightMap A custom lightmap of the material (default is null). Lightmaps\n * are textures that contain pre-rendered lighting. Can be HDR.\n * @property {number} lightMapUv Lightmap UV channel\n * @property {string} lightMapChannel Color channels of the lightmap to use. Can be "r", "g", "b",\n * "a", "rgb" or any swizzled combination.\n * @property {Vec2} lightMapTiling Controls the 2D tiling of the lightmap.\n * @property {Vec2} lightMapOffset Controls the 2D offset of the lightmap. Each component is\n * between 0 and 1.\n * @property {number} lightMapRotation Controls the 2D rotation (in degrees) of the lightmap.\n * @property {boolean} lightVertexColor Use baked vertex lighting. If lightMap is set, it\'ll be\n * multiplied by vertex colors.\n * @property {string} lightVertexColorChannel Vertex color channels to use for baked lighting. Can\n * be "r", "g", "b", "a", "rgb" or any swizzled combination.\n * @property {boolean} ambientTint Enables scene ambient multiplication by material ambient color.\n * @property {Texture|null} aoMap Baked ambient occlusion (AO) map (default is null). Modulates\n * ambient color.\n * @property {number} aoMapUv AO map UV channel\n * @property {string} aoMapChannel Color channel of the AO map to use. Can be "r", "g", "b" or "a".\n * @property {Vec2} aoMapTiling Controls the 2D tiling of the AO map.\n * @property {Vec2} aoMapOffset Controls the 2D offset of the AO map. Each component is between 0\n * and 1.\n * @property {number} aoMapRotation Controls the 2D rotation (in degrees) of the AO map.\n * @property {boolean} aoVertexColor Use mesh vertex colors for AO. If aoMap is set, it\'ll be\n * multiplied by vertex colors.\n * @property {string} aoVertexColorChannel Vertex color channels to use for AO. Can be "r", "g",\n * "b" or "a".\n * @property {number} occludeSpecular Uses ambient occlusion to darken specular/reflection. It\'s a\n * hack, because real specular occlusion is view-dependent. However, it can be better than nothing.\n *\n * - {@link SPECOCC_NONE}: No specular occlusion\n * - {@link SPECOCC_AO}: Use AO directly to occlude specular.\n * - {@link SPECOCC_GLOSSDEPENDENT}: Modify AO based on material glossiness/view angle to occlude\n * specular.\n *\n * @property {number} occludeSpecularIntensity Controls visibility of specular occlusion.\n * @property {boolean} occludeDirect Tells if AO should darken directional lighting. Defaults to\n * false.\n * @property {boolean} specularAntialias Enables Toksvig AA for mipmapped normal maps with\n * specular.\n * @property {boolean} conserveEnergy Defines how diffuse and specular components are combined when\n * Fresnel is on. It is recommended that you leave this option enabled, although you may want to\n * disable it in case when all reflection comes only from a few light sources, and you don\'t use an\n * environment map, therefore having mostly black reflection.\n * @property {number} shadingModel Defines the shading model.\n * - {@link SPECULAR_PHONG}: Phong without energy conservation. You should only use it as a\n * backwards compatibility with older projects.\n * - {@link SPECULAR_BLINN}: Energy-conserving Blinn-Phong.\n * @property {number} fresnelModel Defines the formula used for Fresnel effect.\n * As a side-effect, enabling any Fresnel model changes the way diffuse and reflection components\n * are combined. When Fresnel is off, legacy non energy-conserving combining is used. When it is\n * on, combining behavior is defined by conserveEnergy parameter.\n *\n * - {@link FRESNEL_NONE}: No Fresnel.\n * - {@link FRESNEL_SCHLICK}: Schlick\'s approximation of Fresnel (recommended). Parameterized by\n * specular color.\n *\n * @property {boolean} useFog Apply fogging (as configured in scene settings)\n * @property {boolean} useLighting Apply lighting\n * @property {boolean} useSkybox Apply scene skybox as prefiltered environment map\n * @property {boolean} useGammaTonemap Apply gamma correction and tonemapping (as configured in\n * scene settings).\n * @property {boolean} pixelSnap Align vertices to pixel coordinates when rendering. Useful for\n * pixel perfect 2D graphics.\n * @property {boolean} twoSidedLighting Calculate proper normals (and therefore lighting) on\n * backfaces.\n * @property {UpdateShaderCallback} onUpdateShader A custom function that will be called after all\n * shader generator properties are collected and before shader code is generated. This function\n * will receive an object with shader generator settings (based on current material and scene\n * properties), that you can change and then return. Returned value will be used instead. This is\n * mostly useful when rendering the same set of objects, but with different shader variations based\n * on the same material. For example, you may wish to render a depth or normal pass using textures\n * assigned to the material, a reflection pass with simpler shaders and so on. Properties of the\n * object passed into this function are:\n *\n * - pass: value of {@link Layer#shaderPass} of the Layer being rendered.\n * - chunks: Object containing custom shader chunks that will replace default ones.\n * - customFragmentShader: Completely replace fragment shader with this code.\n * - forceUv1: if UV1 (second set of texture coordinates) is required in the shader. Will be\n * declared as "vUv1" and passed to the fragment shader.\n * - fog: the type of fog being applied in the shader. See {@link Scene#fog} for the list of\n * possible values.\n * - gamma: the type of gamma correction being applied in the shader. See\n * {@link Scene#gammaCorrection} for the list of possible values.\n * - toneMap: the type of tone mapping being applied in the shader. See {@link Scene#toneMapping}\n * for the list of possible values.\n * - ambientTint: the value of {@link StandardMaterial#ambientTint}.\n * - specularAntialias: the value of {@link StandardMaterial#specularAntialias}.\n * - conserveEnergy: the value of {@link StandardMaterial#conserveEnergy}.\n * - occludeSpecular: the value of {@link StandardMaterial#occludeSpecular}.\n * - occludeDirect: the value of {@link StandardMaterial#occludeDirect}.\n * - shadingModel: the value of {@link StandardMaterial#shadingModel}.\n * - fresnelModel: the value of {@link StandardMaterial#fresnelModel}.\n * - cubeMapProjection: the value of {@link StandardMaterial#cubeMapProjection}.\n * - useMetalness: the value of {@link StandardMaterial#useMetalness}.\n * - blendType: the value of {@link Material#blendType}.\n * - twoSidedLighting: the value of {@link Material#twoSidedLighting}.\n * - diffuseTint: defines if {@link StandardMaterial#diffuse} constant should affect diffuse color.\n * - specularTint: defines if {@link StandardMaterial#specular} constant should affect specular\n * color.\n * - metalnessTint: defines if {@link StandardMaterial#metalness} constant should affect metalness\n * value.\n * - glossTint: defines if {@link StandardMaterial#shininess} constant should affect glossiness\n * value.\n * - emissiveTint: defines if {@link StandardMaterial#emissive} constant should affect emission\n * value.\n * - opacityTint: defines if {@link StandardMaterial#opacity} constant should affect opacity value.\n * - occludeSpecularFloat: defines if {@link StandardMaterial#occludeSpecularIntensity} constant\n * should affect specular occlusion.\n * - alphaTest: enable alpha testing. See {@link Material#alphaTest}.\n * - alphaToCoverage: enable alpha to coverage. See {@link Material#alphaToCoverage}.\n * - opacityFadesSpecular: enable specular fade. See {@link Material#opacityFadesSpecular}.\n * - alphaFade: fade value. See {@link Material#alphaFade}.\n * - sphereMap: if {@link StandardMaterial#sphereMap} is used.\n * - cubeMap: if {@link StandardMaterial#cubeMap} is used.\n * - ambientSH: if ambient spherical harmonics are used. Ambient SH replace prefiltered cubemap\n * ambient on certain platform (mostly Android) for performance reasons.\n * - useSpecular: if any specular or reflections are needed at all.\n * - fixSeams: if cubemaps require seam fixing (see {@link Texture#options.fixCubemapSeams}).\n * - emissiveFormat: how emissiveMap must be sampled. This value is based on\n * {@link Texture#options.rgbm} and {@link Texture#options.format}. Possible values are:\n *   - 0: sRGB texture\n *   - 1: RGBM-encoded HDR texture\n *   - 2: Simple read (no conversion from sRGB)\n * - lightMapFormat: how lightMap must be sampled. This value is based on\n * {@link Texture#options.rgbm} and {@link Texture#options.format}. Possible values are:\n *   - 0: sRGB texture\n *   - 1: RGBM-encoded HDR texture\n *   - 2: Simple read (no conversion from sRGB)\n * - useRgbm: if decodeRGBM() function is needed in the shader at all.\n * - packedNormal: if normal map contains X in RGB, Y in Alpha, and Z must be reconstructed.\n * - forceFragmentPrecision: Override fragment shader numeric precision. Can be "lowp", "mediump",\n * "highp" or null to use default.\n * - fastTbn: Use slightly cheaper normal mapping code (skip tangent space normalization). Can look\n * buggy sometimes.\n * - refraction: if refraction is used.\n * - skyboxIntensity: if reflected skybox intensity should be modulated.\n * - useCubeMapRotation: if cube map rotation is enabled.\n * - useInstancing: if hardware instancing compatible shader should be generated. Transform is read\n * from per-instance {@link VertexBuffer} instead of shader\'s uniforms.\n * - useMorphPosition: if morphing code should be generated to morph positions.\n * - useMorphNormal: if morphing code should be generated to morph normals.\n * - reflectionSource: one of "envAtlas", "cubeMap", "sphereMap"\n * - reflectionEncoding: one of null, "rgbm", "rgbe", "linear", "srgb"\n * - ambientSource: one of "ambientSH", "envAtlas", "constant"\n * - ambientEncoding: one of null, "rgbm", "rgbe", "linear", "srgb"\n * @augments Material\n */\ndeclare class StandardMaterial extends Material {\n    static TEXTURE_PARAMETERS: any[];\n    static CUBEMAP_PARAMETERS: any[];\n    _dirtyShader: boolean;\n    _assetReferences: {};\n    _activeParams: Set<any>;\n    _activeLightingParams: Set<any>;\n    shaderOptBuilder: StandardMaterialOptionsBuilder;\n    reset(): void;\n\n    set alphaFade(arg: boolean);\n    get alphaFade(): boolean;\n\n    set ambient(arg: Color);\n    get ambient(): Color;\n\n    set ambientTint(arg: boolean);\n    get ambientTint(): boolean;\n\n    set anisotropy(arg: number);\n    get anisotropy(): number;\n\n    set aoMap(arg: Texture);\n    get aoMap(): Texture;\n\n    set aoMapChannel(arg: string);\n    get aoMapChannel(): string;\n\n    set aoMapOffset(arg: Vec2);\n    get aoMapOffset(): Vec2;\n\n    set aoMapRotation(arg: number);\n    get aoMapRotation(): number;\n\n    set aoMapTiling(arg: Vec2);\n    get aoMapTiling(): Vec2;\n\n    set aoMapUv(arg: number);\n    get aoMapUv(): number;\n\n    set aoVertexColor(arg: boolean);\n    get aoVertexColor(): boolean;\n\n    set aoVertexColorChannel(arg: string);\n    get aoVertexColorChannel(): string;\n\n    set bumpiness(arg: number);\n    get bumpiness(): number;\n\n    set clearCoat(arg: number);\n    get clearCoat(): number;\n\n    set clearCoatBumpiness(arg: number);\n    get clearCoatBumpiness(): number;\n\n    set clearCoatGlossMap(arg: Texture);\n    get clearCoatGlossMap(): Texture;\n\n    set clearCoatGlossMapChannel(arg: string);\n    get clearCoatGlossMapChannel(): string;\n\n    set clearCoatGlossMapOffset(arg: Vec2);\n    get clearCoatGlossMapOffset(): Vec2;\n\n    set clearCoatGlossMapRotation(arg: number);\n    get clearCoatGlossMapRotation(): number;\n\n    set clearCoatGlossMapTiling(arg: Vec2);\n    get clearCoatGlossMapTiling(): Vec2;\n\n    set clearCoatGlossMapUv(arg: number);\n    get clearCoatGlossMapUv(): number;\n\n    set clearCoatGlossVertexColor(arg: boolean);\n    get clearCoatGlossVertexColor(): boolean;\n\n    set clearCoatGlossVertexColorChannel(arg: string);\n    get clearCoatGlossVertexColorChannel(): string;\n\n    set clearCoatGlossiness(arg: number);\n    get clearCoatGlossiness(): number;\n\n    set clearCoatMap(arg: Texture);\n    get clearCoatMap(): Texture;\n\n    set clearCoatMapChannel(arg: string);\n    get clearCoatMapChannel(): string;\n\n    set clearCoatMapOffset(arg: Vec2);\n    get clearCoatMapOffset(): Vec2;\n\n    set clearCoatMapRotation(arg: number);\n    get clearCoatMapRotation(): number;\n\n    set clearCoatMapTiling(arg: Vec2);\n    get clearCoatMapTiling(): Vec2;\n\n    set clearCoatMapUv(arg: number);\n    get clearCoatMapUv(): number;\n\n    set clearCoatNormalMap(arg: Texture);\n    get clearCoatNormalMap(): Texture;\n\n    set clearCoatNormalMapOffset(arg: Vec2);\n    get clearCoatNormalMapOffset(): Vec2;\n\n    set clearCoatNormalMapRotation(arg: number);\n    get clearCoatNormalMapRotation(): number;\n\n    set clearCoatNormalMapTiling(arg: Vec2);\n    get clearCoatNormalMapTiling(): Vec2;\n\n    set clearCoatNormalMapUv(arg: number);\n    get clearCoatNormalMapUv(): number;\n\n    set clearCoatVertexColor(arg: boolean);\n    get clearCoatVertexColor(): boolean;\n\n    set clearCoatVertexColorChannel(arg: string);\n    get clearCoatVertexColorChannel(): string;\n\n    set conserveEnergy(arg: boolean);\n    get conserveEnergy(): boolean;\n\n    set cubeMap(arg: Texture);\n    get cubeMap(): Texture;\n\n    set cubeMapProjection(arg: number);\n    get cubeMapProjection(): number;\n\n    set cubeMapProjectionBox(arg: BoundingBox);\n    get cubeMapProjectionBox(): BoundingBox;\n\n    set diffuse(arg: Color);\n    get diffuse(): Color;\n\n    set diffuseDetailMap(arg: Texture);\n    get diffuseDetailMap(): Texture;\n\n    set diffuseDetailMapChannel(arg: string);\n    get diffuseDetailMapChannel(): string;\n\n    set diffuseDetailMapOffset(arg: Vec2);\n    get diffuseDetailMapOffset(): Vec2;\n\n    set diffuseDetailMapRotation(arg: number);\n    get diffuseDetailMapRotation(): number;\n\n    set diffuseDetailMapTiling(arg: Vec2);\n    get diffuseDetailMapTiling(): Vec2;\n\n    set diffuseDetailMapUv(arg: number);\n    get diffuseDetailMapUv(): number;\n\n    set diffuseDetailMode(arg: string);\n    get diffuseDetailMode(): string;\n\n    set diffuseMap(arg: Texture);\n    get diffuseMap(): Texture;\n\n    set diffuseMapChannel(arg: string);\n    get diffuseMapChannel(): string;\n\n    set diffuseMapOffset(arg: Vec2);\n    get diffuseMapOffset(): Vec2;\n\n    set diffuseMapRotation(arg: number);\n    get diffuseMapRotation(): number;\n\n    set diffuseMapTiling(arg: Vec2);\n    get diffuseMapTiling(): Vec2;\n\n    set diffuseMapUv(arg: number);\n    get diffuseMapUv(): number;\n\n    set diffuseTint(arg: boolean);\n    get diffuseTint(): boolean;\n\n    set diffuseVertexColor(arg: boolean);\n    get diffuseVertexColor(): boolean;\n\n    set diffuseVertexColorChannel(arg: string);\n    get diffuseVertexColorChannel(): string;\n\n    set emissive(arg: Color);\n    get emissive(): Color;\n\n    set emissiveIntensity(arg: number);\n    get emissiveIntensity(): number;\n\n    set emissiveMap(arg: Texture);\n    get emissiveMap(): Texture;\n\n    set emissiveMapChannel(arg: string);\n    get emissiveMapChannel(): string;\n\n    set emissiveMapOffset(arg: Vec2);\n    get emissiveMapOffset(): Vec2;\n\n    set emissiveMapRotation(arg: number);\n    get emissiveMapRotation(): number;\n\n    set emissiveMapTiling(arg: Vec2);\n    get emissiveMapTiling(): Vec2;\n\n    set emissiveMapUv(arg: number);\n    get emissiveMapUv(): number;\n\n    set emissiveTint(arg: boolean);\n    get emissiveTint(): boolean;\n\n    set emissiveVertexColor(arg: boolean);\n    get emissiveVertexColor(): boolean;\n\n    set emissiveVertexColorChannel(arg: string);\n    get emissiveVertexColorChannel(): string;\n\n    set enableGGXSpecular(arg: boolean);\n    get enableGGXSpecular(): boolean;\n\n    set fresnelModel(arg: number);\n    get fresnelModel(): number;\n\n    set glossMap(arg: Texture);\n    get glossMap(): Texture;\n\n    set glossMapChannel(arg: string);\n    get glossMapChannel(): string;\n\n    set glossMapOffset(arg: Vec2);\n    get glossMapOffset(): Vec2;\n\n    set glossMapRotation(arg: number);\n    get glossMapRotation(): number;\n\n    set glossMapTiling(arg: Vec2);\n    get glossMapTiling(): Vec2;\n\n    set glossMapUv(arg: number);\n    get glossMapUv(): number;\n\n    set glossVertexColor(arg: boolean);\n    get glossVertexColor(): boolean;\n\n    set glossVertexColorChannel(arg: string);\n    get glossVertexColorChannel(): string;\n\n    set heightMap(arg: Texture);\n    get heightMap(): Texture;\n\n    set heightMapChannel(arg: string);\n    get heightMapChannel(): string;\n\n    set heightMapFactor(arg: number);\n    get heightMapFactor(): number;\n\n    set heightMapOffset(arg: Vec2);\n    get heightMapOffset(): Vec2;\n\n    set heightMapRotation(arg: number);\n    get heightMapRotation(): number;\n\n    set heightMapTiling(arg: Vec2);\n    get heightMapTiling(): Vec2;\n\n    set heightMapUv(arg: number);\n    get heightMapUv(): number;\n\n    set lightMap(arg: Texture);\n    get lightMap(): Texture;\n\n    set lightMapChannel(arg: string);\n    get lightMapChannel(): string;\n\n    set lightMapOffset(arg: Vec2);\n    get lightMapOffset(): Vec2;\n\n    set lightMapRotation(arg: number);\n    get lightMapRotation(): number;\n\n    set lightMapTiling(arg: Vec2);\n    get lightMapTiling(): Vec2;\n\n    set lightMapUv(arg: number);\n    get lightMapUv(): number;\n\n    set lightVertexColor(arg: boolean);\n    get lightVertexColor(): boolean;\n\n    set lightVertexColorChannel(arg: string);\n    get lightVertexColorChannel(): string;\n\n    set metalness(arg: number);\n    get metalness(): number;\n\n    set metalnessMap(arg: Texture);\n    get metalnessMap(): Texture;\n\n    set metalnessMapChannel(arg: string);\n    get metalnessMapChannel(): string;\n\n    set metalnessMapOffset(arg: Vec2);\n    get metalnessMapOffset(): Vec2;\n\n    set metalnessMapRotation(arg: number);\n    get metalnessMapRotation(): number;\n\n    set metalnessMapTiling(arg: Vec2);\n    get metalnessMapTiling(): Vec2;\n\n    set metalnessMapUv(arg: number);\n    get metalnessMapUv(): number;\n\n    set metalnessVertexColor(arg: boolean);\n    get metalnessVertexColor(): boolean;\n\n    set metalnessVertexColorChannel(arg: string);\n    get metalnessVertexColorChannel(): string;\n\n    set normalDetailMap(arg: Texture);\n    get normalDetailMap(): Texture;\n\n    set normalDetailMapBumpiness(arg: number);\n    get normalDetailMapBumpiness(): number;\n\n    set normalDetailMapOffset(arg: Vec2);\n    get normalDetailMapOffset(): Vec2;\n\n    set normalDetailMapRotation(arg: number);\n    get normalDetailMapRotation(): number;\n\n    set normalDetailMapTiling(arg: Vec2);\n    get normalDetailMapTiling(): Vec2;\n\n    set normalDetailMapUv(arg: number);\n    get normalDetailMapUv(): number;\n\n    set normalMap(arg: Texture);\n    get normalMap(): Texture;\n\n    set normalMapOffset(arg: Vec2);\n    get normalMapOffset(): Vec2;\n\n    set normalMapRotation(arg: number);\n    get normalMapRotation(): number;\n\n    set normalMapTiling(arg: Vec2);\n    get normalMapTiling(): Vec2;\n\n    set normalMapUv(arg: number);\n    get normalMapUv(): number;\n\n    set occludeDirect(arg: number);\n    get occludeDirect(): number;\n\n    set occludeSpecular(arg: number);\n    get occludeSpecular(): number;\n\n    set occludeSpecularIntensity(arg: number);\n    get occludeSpecularIntensity(): number;\n\n    set onUpdateShader(arg: UpdateShaderCallback);\n    get onUpdateShader(): UpdateShaderCallback;\n\n    set opacity(arg: number);\n    get opacity(): number;\n\n    set opacityFadesSpecular(arg: boolean);\n    get opacityFadesSpecular(): boolean;\n\n    set opacityMap(arg: Texture);\n    get opacityMap(): Texture;\n\n    set opacityMapChannel(arg: string);\n    get opacityMapChannel(): string;\n\n    set opacityMapOffset(arg: Vec2);\n    get opacityMapOffset(): Vec2;\n\n    set opacityMapRotation(arg: number);\n    get opacityMapRotation(): number;\n\n    set opacityMapTiling(arg: Vec2);\n    get opacityMapTiling(): Vec2;\n\n    set opacityMapUv(arg: number);\n    get opacityMapUv(): number;\n\n    set opacityVertexColor(arg: boolean);\n    get opacityVertexColor(): boolean;\n\n    set opacityVertexColorChannel(arg: string);\n    get opacityVertexColorChannel(): string;\n\n    set pixelSnap(arg: boolean);\n    get pixelSnap(): boolean;\n\n    set reflectivity(arg: number);\n    get reflectivity(): number;\n\n    set refraction(arg: number);\n    get refraction(): number;\n\n    set refractionIndex(arg: number);\n    get refractionIndex(): number;\n\n    set shadingModel(arg: number);\n    get shadingModel(): number;\n\n    set shininess(arg: number);\n    get shininess(): number;\n\n    set specular(arg: Color);\n    get specular(): Color;\n\n    set specularAntialias(arg: boolean);\n    get specularAntialias(): boolean;\n\n    set specularMap(arg: Texture);\n    get specularMap(): Texture;\n\n    set specularMapChannel(arg: string);\n    get specularMapChannel(): string;\n\n    set specularMapOffset(arg: Vec2);\n    get specularMapOffset(): Vec2;\n\n    set specularMapRotation(arg: number);\n    get specularMapRotation(): number;\n\n    set specularMapTiling(arg: Vec2);\n    get specularMapTiling(): Vec2;\n\n    set specularMapUv(arg: number);\n    get specularMapUv(): number;\n\n    set specularTint(arg: boolean);\n    get specularTint(): boolean;\n\n    set specularVertexColor(arg: boolean);\n    get specularVertexColor(): boolean;\n\n    set specularVertexColorChannel(arg: string);\n    get specularVertexColorChannel(): string;\n\n    set sphereMap(arg: Texture);\n    get sphereMap(): Texture;\n\n    set twoSidedLighting(arg: boolean);\n    get twoSidedLighting(): boolean;\n\n    set useFog(arg: boolean);\n    get useFog(): boolean;\n\n    set useGammaTonemap(arg: boolean);\n    get useGammaTonemap(): boolean;\n\n    set useLighting(arg: boolean);\n    get useLighting(): boolean;\n\n    set useMetalness(arg: boolean);\n    get useMetalness(): boolean;\n\n    set useSkybox(arg: boolean);\n    get useSkybox(): boolean;\n\n    /**\n     * @type {Object.<string, string>}\n     * @private\n     */\n    private _chunks;\n    _uniformCache: {};\n    /**\n     * Object containing custom shader chunks that will replace default ones.\n     *\n     * @type {Object.<string, string>}\n     */\n    set chunks(arg: {\n        [x: string]: string;\n    });\n    get chunks(): {\n        [x: string]: string;\n    };\n    /**\n     * Copy a `StandardMaterial`.\n     *\n     * @param {StandardMaterial} source - The material to copy from.\n     * @returns {StandardMaterial} The destination material.\n     */\n    copy(source: StandardMaterial): StandardMaterial;\n    _setParameter(name: any, value: any): void;\n    _setParameters(parameters: any): void;\n    _processParameters(paramsName: any): void;\n    _updateMap(p: any): void;\n    _allocUniform(name: any, allocFunc: any): any;\n    getUniform(name: any, device: any, scene: any): any;\n    updateEnvUniforms(device: any, scene: any): void;\n}\n\n/**\n * Manages creation of {@link ElementComponent}s.\n *\n * @augments ComponentSystem\n */\ndeclare class ElementComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof ElementComponent;\n    DataType: typeof ElementComponentData;\n    schema: string[];\n    _unicodeConverter: any;\n    _rtlReorder: any;\n    _defaultTexture: Texture;\n    defaultImageMaterial: StandardMaterial;\n    defaultImage9SlicedMaterial: StandardMaterial;\n    defaultImage9TiledMaterial: StandardMaterial;\n    defaultImageMaskMaterial: StandardMaterial;\n    defaultImage9SlicedMaskMaterial: StandardMaterial;\n    defaultImage9TiledMaskMaterial: StandardMaterial;\n    defaultScreenSpaceImageMaterial: StandardMaterial;\n    defaultScreenSpaceImage9SlicedMaterial: StandardMaterial;\n    defaultScreenSpaceImage9TiledMaterial: StandardMaterial;\n    defaultScreenSpaceImageMask9SlicedMaterial: StandardMaterial;\n    defaultScreenSpaceImageMask9TiledMaterial: StandardMaterial;\n    defaultScreenSpaceImageMaskMaterial: StandardMaterial;\n    defaultTextMaterial: StandardMaterial;\n    defaultBitmapTextMaterial: StandardMaterial;\n    defaultScreenSpaceTextMaterial: StandardMaterial;\n    defaultScreenSpaceBitmapTextMaterial: StandardMaterial;\n    defaultImageMaterials: any[];\n    initializeComponentData(component: any, data: any, properties: any): void;\n    onRemoveComponent(entity: any, component: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    getTextElementMaterial(screenSpace: any, msdf: any): StandardMaterial;\n    _createBaseImageMaterial(): StandardMaterial;\n    getImageElementMaterial(screenSpace: any, mask: any, nineSliced: any, nineSliceTiled: any): StandardMaterial;\n    registerUnicodeConverter(func: any): void;\n    registerRtlReorder(func: any): void;\n    getUnicodeConverter(): any;\n    getRtlReorder(): any;\n}\n\n\n/** @typedef {import(\'../graphics/texture.js\').Texture} Texture */\n/**\n * Represents the resource of a font asset.\n */\ndeclare class Font {\n    /**\n     * Create a new Font instance.\n     *\n     * @param {Texture[]} textures - The font textures.\n     * @param {object} data - The font data.\n     */\n    constructor(textures: Texture[], data: object);\n    type: any;\n    em: number;\n    /**\n     * The font textures.\n     *\n     * @type {Texture[]}\n     */\n    textures: Texture[];\n    /**\n     * The font intensity.\n     *\n     * @type {number}\n     */\n    intensity: number;\n    _data: any;\n    set data(arg: any);\n    get data(): any;\n}\n\n\n/**\n * Represents the resource of a canvas font asset.\n *\n * @augments EventHandler\n * @ignore\n */\ndeclare class CanvasFont extends EventHandler {\n    /**\n     * Create a new CanvasFont instance.\n     *\n     * @param {Application} app - The application.\n     * @param {object} options - The font options.\n     * @param {string} [options.fontName] - The name of the font. CSS font names are supported.\n     * Defaults to \'Arial\'.\n     * @param {string} [options.fontWeight] - The weight of the font, e.g. \'normal\', \'bold\'.\n     * Defaults to \'normal\'.\n     * @param {number} [options.fontSize] - The font size in pixels. Defaults to 32.\n     * @param {Color} [options.color] - The font color.Defaults to white.\n     * @param {number} [options.width] - The width of each texture atlas. Defaults to 512.\n     * @param {number} [options.height] - The height of each texture atlas. Defaults to 512.\n     * @param {number} [options.padding] - Amount of glyph padding in pixels that is added to each\n     * glyph in the atlas. Defaults to 0.\n     */\n    constructor(app: Application, options?: {\n        fontName?: string;\n        fontWeight?: string;\n        fontSize?: number;\n        color?: Color;\n        width?: number;\n        height?: number;\n        padding?: number;\n    });\n    type: string;\n    app: Application;\n    intensity: number;\n    fontWeight: string;\n    fontSize: number;\n    glyphSize: number;\n    fontName: string;\n    color: Color;\n    padding: number;\n    textures: Texture[];\n    chars: string;\n    data: {};\n    /**\n     * Render the necessary textures for all characters in a string to be used for the canvas font.\n     *\n     * @param {string} text - The list of characters to render into the texture atlas.\n     */\n    createTextures(text: string): void;\n    /**\n     * Update the list of characters to include in the atlas to include those provided and\n     * re-render the texture atlas to include all the characters that have been supplied so far.\n     *\n     * @param {string} text - The list of characters to add to the texture atlas.\n     */\n    updateTextures(text: string): void;\n    /**\n     * Destroys the font. This also destroys the textures owned by the font.\n     */\n    destroy(): void;\n    /**\n     * @param {HTMLCanvasElement} canvas - The canvas used to render the font.\n     * @param {string} clearColor - The color to clear the canvas with.\n     * @returns {CanvasRenderingContext2D} - A 2D rendering contxt.\n     * @private\n     */\n    private _getAndClearContext;\n    /**\n     * @param {Color} color - The color to covert.\n     * @param {boolean} alpha - Whether to include the alpha channel.\n     * @returns {string} The hex string for the color.\n     * @private\n     */\n    private _colorToRgbString;\n    /**\n     * @param {CanvasRenderingContext2D} context - The canvas 2D context.\n     * @param {string} char - The character to render.\n     * @param {number} x - The x position to render the character at.\n     * @param {number} y - The y position to render the character at.\n     * @param {number} color - The color to render the character in.\n     * @ignore\n     */\n    renderCharacter(context: CanvasRenderingContext2D, char: string, x: number, y: number, color: number): void;\n    /**\n     * Renders an array of characters into one or more textures atlases.\n     *\n     * @param {string[]} charsArray - The list of characters to render.\n     * @private\n     */\n    private _renderAtlas;\n    /**\n     * @param {string[]} chars - A list of characters.\n     * @param {string} fontName - The font name.\n     * @param {number} width - The width of the texture atlas.\n     * @param {number} height - The height of the texture atlas.\n     * @returns {object} The font JSON object.\n     * @private\n     */\n    private _createJson;\n    /**\n     * @param {object} json - Font data.\n     * @param {string} char - The character to add.\n     * @param {number} charCode - The code point number of the character to add.\n     * @param {number} x - The x position of the character.\n     * @param {number} y - The y position of the character.\n     * @param {number} w - The width of the character.\n     * @param {number} h - The height of the character.\n     * @param {number} xoffset - The x offset of the character.\n     * @param {number} yoffset - The y offset of the character.\n     * @param {number} xadvance - The x advance of the character.\n     * @param {number} mapNum - The map number of the character.\n     * @param {number} mapW - The width of the map.\n     * @param {number} mapH - The height of the map.\n     * @private\n     */\n    private _addChar;\n    /**\n     * Take a unicode string and produce the set of characters used to create that string.\n     * e.g. "abcabcabc" -> [\'a\', \'b\', \'c\']\n     *\n     * @param {string} text - The unicode string to process.\n     * @returns {string[]} The set of characters used to create the string.\n     * @private\n     */\n    private _normalizeCharsSet;\n    /**\n     * Calculate some metrics that aren\'t available via the browser API, notably character height\n     * and descent size.\n     *\n     * @param {string} text - The text to measure.\n     * @returns {{ascent: number, descent: number, height: number}} The metrics of the text.\n     * @private\n     */\n    private _getTextMetrics;\n}\n\ndeclare class ImageElement {\n    constructor(element: any);\n    _element: any;\n    _entity: any;\n    _system: any;\n    _textureAsset: any;\n    _texture: any;\n    _materialAsset: any;\n    _material: any;\n    _spriteAsset: any;\n    _sprite: any;\n    _spriteFrame: number;\n    _pixelsPerUnit: any;\n    _rect: Vec4;\n    _mask: boolean;\n    _maskRef: number;\n    _outerScale: Vec2;\n    _outerScaleUniform: Float32Array;\n    _innerOffset: Vec4;\n    _innerOffsetUniform: Float32Array;\n    _atlasRect: Vec4;\n    _atlasRectUniform: Float32Array;\n    _defaultMesh: Mesh;\n    _renderable: ImageRenderable;\n    _color: Color;\n    _colorUniform: Float32Array;\n    _updateAabbFunc: any;\n    destroy(): void;\n    set textureAsset(arg: any);\n    get textureAsset(): any;\n    set spriteAsset(arg: any);\n    get spriteAsset(): any;\n    set materialAsset(arg: any);\n    get materialAsset(): any;\n    _onResolutionChange(res: any): void;\n    _onParentResizeOrPivotChange(): void;\n    _onScreenSpaceChange(value: any): void;\n    _onScreenChange(screen: any, previous: any): void;\n    _onDrawOrderChange(order: any): void;\n    _hasUserMaterial(): boolean;\n    _use9Slicing(): boolean;\n    _updateMaterial(screenSpace: any): void;\n    _createMesh(): Mesh;\n    _updateMesh(mesh: any): void;\n    _meshDirty: boolean;\n    _updateSprite(): void;\n    set mesh(arg: any);\n    get mesh(): any;\n    _updateAabb(aabb: any): any;\n    _toggleMask(): void;\n    _onMaterialLoad(asset: any): void;\n    set material(arg: any);\n    get material(): any;\n    _onMaterialAdded(asset: any): void;\n    _bindMaterialAsset(asset: any): void;\n    _unbindMaterialAsset(asset: any): void;\n    _onMaterialChange(): void;\n    _onMaterialRemove(): void;\n    _onTextureAdded(asset: any): void;\n    _bindTextureAsset(asset: any): void;\n    _unbindTextureAsset(asset: any): void;\n    _onTextureLoad(asset: any): void;\n    set texture(arg: any);\n    get texture(): any;\n    _onTextureChange(asset: any): void;\n    _onTextureRemove(asset: any): void;\n    _onSpriteAssetAdded(asset: any): void;\n    _bindSpriteAsset(asset: any): void;\n    _unbindSpriteAsset(asset: any): void;\n    _onSpriteAssetLoad(asset: any): void;\n    set sprite(arg: any);\n    get sprite(): any;\n    _onSpriteAssetChange(asset: any): void;\n    _onSpriteAssetRemove(asset: any): void;\n    _bindSprite(sprite: any): void;\n    _unbindSprite(sprite: any): void;\n    _onSpriteMeshesChange(): void;\n    _onSpritePpuChange(): void;\n    _onAtlasTextureChange(): void;\n    _onTextureAtlasLoad(atlasAsset: any): void;\n    onEnable(): void;\n    onDisable(): void;\n    _setStencil(stencilParams: any): void;\n    set color(arg: Color);\n    get color(): Color;\n    set opacity(arg: number);\n    get opacity(): number;\n    set rect(arg: Vec4);\n    get rect(): Vec4;\n    set spriteFrame(arg: number);\n    get spriteFrame(): number;\n    set mask(arg: boolean);\n    get mask(): boolean;\n    set pixelsPerUnit(arg: any);\n    get pixelsPerUnit(): any;\n    get aabb(): any;\n}\n\ndeclare class ImageRenderable {\n    constructor(entity: any, mesh: any, material: any);\n    _entity: any;\n    _element: any;\n    model: Model;\n    node: GraphNode;\n    mesh: any;\n    meshInstance: MeshInstance;\n    _meshDirty: boolean;\n    unmaskMeshInstance: MeshInstance;\n    destroy(): void;\n    setMesh(mesh: any): void;\n    setMask(mask: any): void;\n    setMaterial(material: any): void;\n    setParameter(name: any, value: any): void;\n    deleteParameter(name: any): void;\n    setUnmaskDrawOrder(): void;\n    setDrawOrder(drawOrder: any): void;\n    setCull(cull: any): void;\n    setScreenSpace(screenSpace: any): void;\n    setLayer(layer: any): void;\n    forceUpdateAabb(mask: any): void;\n    setAabbFunc(fn: any): void;\n}\n\ndeclare class LocalizedAsset extends EventHandler {\n    constructor(app: any);\n    _app: any;\n    _autoLoad: boolean;\n    _disableLocalization: boolean;\n    _defaultAsset: any;\n    _localizedAsset: any;\n    set defaultAsset(arg: any);\n    get defaultAsset(): any;\n    set localizedAsset(arg: any);\n    get localizedAsset(): any;\n    set autoLoad(arg: boolean);\n    get autoLoad(): boolean;\n    set disableLocalization(arg: boolean);\n    get disableLocalization(): boolean;\n    _bindDefaultAsset(): void;\n    _unbindDefaultAsset(): void;\n    _onDefaultAssetAdd(asset: any): void;\n    _onDefaultAssetRemove(asset: any): void;\n    _bindLocalizedAsset(): void;\n    _unbindLocalizedAsset(): void;\n    _onLocalizedAssetAdd(asset: any): void;\n    _onLocalizedAssetLoad(asset: any): void;\n    _onLocalizedAssetChange(asset: any, name: any, newValue: any, oldValue: any): void;\n    _onLocalizedAssetRemove(asset: any): void;\n    _onLocaleAdd(locale: any, assetId: any): void;\n    _onLocaleRemove(locale: any, assetId: any): void;\n    _onSetLocale(locale: any): void;\n    destroy(): void;\n}\n\ndeclare class TextElement {\n    constructor(element: any);\n    _element: any;\n    _system: any;\n    _entity: any;\n    _text: string;\n    _symbols: any[];\n    _colorPalette: any[];\n    _symbolColors: any[];\n    _i18nKey: any;\n    _fontAsset: LocalizedAsset;\n    _font: any;\n    _color: Color;\n    _colorUniform: Float32Array;\n    _spacing: number;\n    _fontSize: number;\n    _fontMinY: number;\n    _fontMaxY: number;\n    _originalFontSize: number;\n    _maxFontSize: number;\n    _minFontSize: number;\n    _autoFitWidth: boolean;\n    _autoFitHeight: boolean;\n    _maxLines: number;\n    _lineHeight: number;\n    _scaledLineHeight: number;\n    _wrapLines: boolean;\n    _drawOrder: number;\n    _alignment: Vec2;\n    _autoWidth: boolean;\n    _autoHeight: boolean;\n    width: number;\n    height: number;\n    _node: GraphNode;\n    _model: Model;\n    _meshInfo: any[];\n    _material: any;\n    _aabbDirty: boolean;\n    _aabb: BoundingBox;\n    _noResize: boolean;\n    _currentMaterialType: any;\n    _maskedMaterialSrc: any;\n    _rtlReorder: boolean;\n    _unicodeConverter: boolean;\n    _rtl: boolean;\n    _outlineColor: Color;\n    _outlineColorUniform: Float32Array;\n    _outlineThicknessScale: number;\n    _outlineThickness: number;\n    _shadowColor: Color;\n    _shadowColorUniform: Float32Array;\n    _shadowOffsetScale: number;\n    _shadowOffset: Vec2;\n    _shadowOffsetUniform: Float32Array;\n    _enableMarkup: boolean;\n    _rangeStart: number;\n    _rangeEnd: number;\n    destroy(): void;\n    set font(arg: any);\n    get font(): any;\n    _onParentResize(width: any, height: any): void;\n    _onScreenChange(screen: any): void;\n    _onScreenSpaceChange(value: any): void;\n    _onDrawOrderChange(order: any): void;\n    _onPivotChange(pivot: any): void;\n    _onLocaleSet(locale: any): void;\n    _onLocalizationData(locale: any, messages: any): void;\n    _resetLocalizedText(): void;\n    _setText(text: any): void;\n    _updateText(text: any): void;\n    _removeMeshInstance(meshInstance: any): void;\n    _setMaterial(material: any): void;\n    _updateMaterial(screenSpace: any): void;\n    _isWordBoundary(char: any): boolean;\n    _isValidNextChar(nextchar: any): boolean;\n    _isNextCJKBoundary(char: any, nextchar: any): boolean;\n    _isNextCJKWholeWord(nextchar: any): boolean;\n    _updateMeshes(): void;\n    _lineWidths: any[];\n    _lineContents: any[];\n    set autoWidth(arg: boolean);\n    get autoWidth(): boolean;\n    set autoHeight(arg: boolean);\n    get autoHeight(): boolean;\n    _onFontRender(): void;\n    _onFontLoad(asset: any): void;\n    _onFontChange(asset: any, name: any, _new: any, _old: any): void;\n    _onFontRemove(asset: any): void;\n    _setTextureParams(mi: any, texture: any): void;\n    _getPxRange(font: any): number;\n    _getUv(char: any): any;\n    onEnable(): void;\n    onDisable(): void;\n    _setStencil(stencilParams: any): void;\n    _shouldAutoFitWidth(): boolean;\n    _shouldAutoFitHeight(): boolean;\n    _shouldAutoFit(): boolean;\n    _calculateCharsPerTexture(symbolIndex: any): {};\n    _updateRenderRange(): void;\n    set text(arg: string);\n    get text(): string;\n    set key(arg: any);\n    get key(): any;\n    set color(arg: Color);\n    get color(): Color;\n    set opacity(arg: number);\n    get opacity(): number;\n    set lineHeight(arg: number);\n    get lineHeight(): number;\n    set wrapLines(arg: boolean);\n    get wrapLines(): boolean;\n    get lines(): any[];\n    set spacing(arg: number);\n    get spacing(): number;\n    set fontSize(arg: number);\n    get fontSize(): number;\n    set fontAsset(arg: any);\n    get fontAsset(): any;\n    set alignment(arg: Vec2);\n    get alignment(): Vec2;\n    set rtlReorder(arg: boolean);\n    get rtlReorder(): boolean;\n    set unicodeConverter(arg: boolean);\n    get unicodeConverter(): boolean;\n    get aabb(): BoundingBox;\n    set outlineColor(arg: Color);\n    get outlineColor(): Color;\n    set outlineThickness(arg: number);\n    get outlineThickness(): number;\n    set shadowColor(arg: Color);\n    get shadowColor(): Color;\n    set shadowOffset(arg: Vec2);\n    get shadowOffset(): Vec2;\n    set minFontSize(arg: number);\n    get minFontSize(): number;\n    set maxFontSize(arg: number);\n    get maxFontSize(): number;\n    set autoFitWidth(arg: boolean);\n    get autoFitWidth(): boolean;\n    set autoFitHeight(arg: boolean);\n    get autoFitHeight(): boolean;\n    set maxLines(arg: number);\n    get maxLines(): number;\n    set enableMarkup(arg: boolean);\n    get enableMarkup(): boolean;\n    get symbols(): any[];\n    get symbolColors(): any[];\n    get rtl(): boolean;\n    set rangeStart(arg: number);\n    get rangeStart(): number;\n    set rangeEnd(arg: number);\n    get rangeEnd(): number;\n}\n\n\n\n\n\n\n\n\n/**\n * ElementComponents are used to construct user interfaces. An ElementComponent\'s [type](#type)\n * property can be configured in 3 main ways: as a text element, as an image element or as a group\n * element. If the ElementComponent has a {@link ScreenComponent} ancestor in the hierarchy, it\n * will be transformed with respect to the coordinate system of the screen. If there is no\n * {@link ScreenComponent} ancestor, the ElementComponent will be transformed like any other\n * entity.\n *\n * You should never need to use the ElementComponent constructor. To add an ElementComponent to a\n * {@link Entity}, use {@link Entity#addComponent}:\n *\n * ```javascript\n * // Add an element component to an entity with the default options\n * let entity = pc.Entity();\n * entity.addComponent("element"); // This defaults to a \'group\' element\n * ```\n *\n * To create a simple text-based element:\n *\n * ```javascript\n * entity.addComponent("element", {\n *     anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5), // centered anchor\n *     fontAsset: fontAsset,\n *     fontSize: 128,\n *     pivot: new pc.Vec2(0.5, 0.5),            // centered pivot\n *     text: "Hello World!",\n *     type: pc.ELEMENTTYPE_TEXT\n * });\n * ```\n *\n * Once the ElementComponent is added to the entity, you can set and get any of its properties:\n *\n * ```javascript\n * entity.element.color = pc.Color.RED; // Set the element\'s color to red\n *\n * console.log(entity.element.color);   // Get the element\'s color and print it\n * ```\n *\n * Relevant \'Engine-only\' examples:\n * - [Basic text rendering](http://playcanvas.github.io/#user-interface/text-basic)\n * - [Rendering text outlines](http://playcanvas.github.io/#user-interface/text-outline)\n * - [Adding drop shadows to text](http://playcanvas.github.io/#user-interface/text-drop-shadow)\n * - [Coloring text with markup](http://playcanvas.github.io/#user-interface/text-markup)\n * - [Wrapping text](http://playcanvas.github.io/#user-interface/text-wrap)\n * - [Typewriter text](http://playcanvas.github.io/#user-interface/text-typewriter)\n *\n * @property {Color} color The color of the image for {@link ELEMENTTYPE_IMAGE} types or the color\n * of the text for {@link ELEMENTTYPE_TEXT} types.\n * @property {number} opacity The opacity of the image for {@link ELEMENTTYPE_IMAGE} types or the\n * text for {@link ELEMENTTYPE_TEXT} types.\n * @property {Color} outlineColor The text outline effect color and opacity. Only works for\n * {@link ELEMENTTYPE_TEXT} types.\n * @property {number} outlineThickness The width of the text outline effect. Only works for\n * {@link ELEMENTTYPE_TEXT} types.\n * @property {Color} shadowColor The text shadow effect color and opacity. Only works for\n * {@link ELEMENTTYPE_TEXT} types.\n * @property {Vec2} shadowOffset The text shadow effect shift amount from original text. Only works\n * for {@link ELEMENTTYPE_TEXT} types.\n * @property {boolean} autoWidth Automatically set the width of the component to be the same as the\n * textWidth. Only works for {@link ELEMENTTYPE_TEXT} types.\n * @property {boolean} autoHeight Automatically set the height of the component to be the same as\n * the textHeight. Only works for {@link ELEMENTTYPE_TEXT} types.\n * @property {number} fontAsset The id of the font asset used for rendering the text. Only works\n * for {@link ELEMENTTYPE_TEXT} types.\n * @property {Font} font The font used for rendering the text. Only works for\n * {@link ELEMENTTYPE_TEXT} types.\n * @property {number} fontSize The size of the font. Only works for {@link ELEMENTTYPE_TEXT} types.\n * @property {boolean} autoFitWidth When true the font size and line height will scale so that the\n * text fits inside the width of the Element. The font size will be scaled between minFontSize and\n * maxFontSize. The value of autoFitWidth will be ignored if autoWidth is true.\n * @property {boolean} autoFitHeight When true the font size and line height will scale so that the\n * text fits inside the height of the Element. The font size will be scaled between minFontSize and\n * maxFontSize. The value of autoFitHeight will be ignored if autoHeight is true.\n * @property {number} minFontSize The minimum size that the font can scale to when autoFitWidth or\n * autoFitHeight are true.\n * @property {number} maxFontSize The maximum size that the font can scale to when autoFitWidth or\n * autoFitHeight are true.\n * @property {number} spacing The spacing between the letters of the text. Only works for\n * {@link ELEMENTTYPE_TEXT} types.\n * @property {number} lineHeight The height of each line of text. Only works for\n * {@link ELEMENTTYPE_TEXT} types.\n * @property {boolean} wrapLines Whether to automatically wrap lines based on the element width.\n * Only works for {@link ELEMENTTYPE_TEXT} types, and when autoWidth is set to false.\n * @property {number} maxLines The maximum number of lines that the Element can wrap to. Any\n * leftover text will be appended to the last line. Set this to null to allow unlimited lines.\n * @property {Vec2} alignment The horizontal and vertical alignment of the text. Values range from\n * 0 to 1 where [0,0] is the bottom left and [1,1] is the top right.  Only works for\n * {@link ELEMENTTYPE_TEXT} types.\n * @property {string} text The text to render. Only works for {@link ELEMENTTYPE_TEXT} types.\n * @property {string} key The localization key to use to get the localized text from\n * {@link Application#i18n}. Only works for {@link ELEMENTTYPE_TEXT} types.\n * @property {number} textureAsset The id of the texture asset to render. Only works for\n * {@link ELEMENTTYPE_IMAGE} types.\n * @property {Texture} texture The texture to render. Only works for {@link ELEMENTTYPE_IMAGE}\n * types.\n * @property {number} spriteAsset The id of the sprite asset to render. Only works for\n * {@link ELEMENTTYPE_IMAGE} types which can render either a texture or a sprite.\n * @property {Sprite} sprite The sprite to render. Only works for {@link ELEMENTTYPE_IMAGE} types\n * which can render either a texture or a sprite.\n * @property {number} spriteFrame The frame of the sprite to render. Only works for\n * {@link ELEMENTTYPE_IMAGE} types who have a sprite assigned.\n * @property {number} pixelsPerUnit The number of pixels that map to one PlayCanvas unit. Only\n * works for {@link ELEMENTTYPE_IMAGE} types who have a sliced sprite assigned.\n * @property {number} materialAsset The id of the material asset to use when rendering an image.\n * Only works for {@link ELEMENTTYPE_IMAGE} types.\n * @property {Material} material The material to use when rendering an image. Only works for\n * {@link ELEMENTTYPE_IMAGE} types.\n * @property {Vec4} rect Specifies which region of the texture to use in order to render an image.\n * Values range from 0 to 1 and indicate u, v, width, height. Only works for\n * {@link ELEMENTTYPE_IMAGE} types.\n * @property {boolean} rtlReorder Reorder the text for RTL languages using a function registered\n * by `app.systems.element.registerUnicodeConverter`.\n * @property {boolean} unicodeConverter Convert unicode characters using a function registered by\n * `app.systems.element.registerUnicodeConverter`.\n * @property {boolean} enableMarkup Flag for enabling markup processing. Only works for\n * {@link ELEMENTTYPE_TEXT} types. The only supported tag is `[color]` with a hex color value. e.g.\n * `[color="#ff0000"]red text[/color]`\n * @property {number} rangeStart Index of the first character to render. Only works for\n * {@link ELEMENTTYPE_TEXT} types.\n * @property {number} rangeEnd Index of the last character to render. Only works for\n * {@link ELEMENTTYPE_TEXT} types.\n * @property {boolean} mask Switch Image Element into a mask. Masks do not render into the scene,\n * but instead limit child elements to only be rendered where this element is rendered.\n * @augments Component\n */\ndeclare class ElementComponent extends Component {\n    /**\n     * Create a new ElementComponent instance.\n     *\n     * @param {ElementComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: ElementComponentSystem, entity: Entity);\n\n    set alignment(arg: Vec2);\n    get alignment(): Vec2;\n\n    set autoFitHeight(arg: boolean);\n    get autoFitHeight(): boolean;\n\n    set autoFitWidth(arg: boolean);\n    get autoFitWidth(): boolean;\n\n    set autoHeight(arg: boolean);\n    get autoHeight(): boolean;\n\n    set autoWidth(arg: boolean);\n    get autoWidth(): boolean;\n\n    set color(arg: Color);\n    get color(): Color;\n\n    set enableMarkup(arg: boolean);\n    get enableMarkup(): boolean;\n\n    set font(arg: Font|CanvasFont);\n    get font(): Font|CanvasFont;\n\n    set fontAsset(arg: number);\n    get fontAsset(): number;\n\n    set fontSize(arg: number);\n    get fontSize(): number;\n\n    set key(arg: string);\n    get key(): string;\n\n    set lineHeight(arg: number);\n    get lineHeight(): number;\n\n    set mask(arg: boolean);\n    get mask(): boolean;\n\n    set material(arg: Material);\n    get material(): Material;\n\n    set materialAsset(arg: number);\n    get materialAsset(): number;\n\n    set maxFontSize(arg: number);\n    get maxFontSize(): number;\n\n    set maxLines(arg: number);\n    get maxLines(): number;\n\n    set minFontSize(arg: number);\n    get minFontSize(): number;\n\n    set opacity(arg: number);\n    get opacity(): number;\n\n    set outlineColor(arg: Color);\n    get outlineColor(): Color;\n\n    set outlineThickness(arg: number);\n    get outlineThickness(): number;\n\n    set pixelsPerUnit(arg: number);\n    get pixelsPerUnit(): number;\n\n    set rangeEnd(arg: number);\n    get rangeEnd(): number;\n\n    set rangeStart(arg: number);\n    get rangeStart(): number;\n\n    set rect(arg: Vec4);\n    get rect(): Vec4;\n\n    set rtlReorder(arg: boolean);\n    get rtlReorder(): boolean;\n\n    set shadowColor(arg: Color);\n    get shadowColor(): Color;\n\n    set shadowOffset(arg: number);\n    get shadowOffset(): number;\n\n    set spacing(arg: number);\n    get spacing(): number;\n\n    set sprite(arg: Sprite);\n    get sprite(): Sprite;\n\n    set spriteAsset(arg: number);\n    get spriteAsset(): number;\n\n    set spriteFrame(arg: number);\n    get spriteFrame(): number;\n\n    set text(arg: string);\n    get text(): string;\n\n    set texture(arg: Texture);\n    get texture(): Texture;\n\n    set textureAsset(arg: number);\n    get textureAsset(): number;\n\n    set unicodeConverter(arg: boolean);\n    get unicodeConverter(): boolean;\n\n    set wrapLines(arg: boolean);\n    get wrapLines(): boolean;\n\n    _beingInitialized: boolean;\n    _anchor: Vec4;\n    _localAnchor: Vec4;\n    _pivot: Vec2;\n    _width: number;\n    _calculatedWidth: number;\n    _height: number;\n    _calculatedHeight: number;\n    _margin: Vec4;\n    _modelTransform: Mat4;\n    _screenToWorld: Mat4;\n    _anchorTransform: Mat4;\n    _anchorDirty: boolean;\n    _parentWorldTransform: Mat4;\n    _screenTransform: Mat4;\n    _screenCorners: Vec3[];\n    _canvasCorners: Vec2[];\n    _worldCorners: Vec3[];\n    _cornersDirty: boolean;\n    _canvasCornersDirty: boolean;\n    _worldCornersDirty: boolean;\n    /**\n     * The Entity with a {@link ScreenComponent} that this component belongs to. This is\n     * automatically set when the component is a child of a ScreenComponent.\n     *\n     * @type {Entity|null}\n     */\n    screen: Entity | null;\n    _type: string;\n    _image: ImageElement;\n    _text: TextElement;\n    _group: any;\n    _drawOrder: number;\n    _useInput: boolean;\n    _layers: number[];\n    _addedModels: any[];\n    _batchGroupId: number;\n    _batchGroup: any;\n    _offsetReadAt: number;\n    _maskOffset: number;\n    _maskedBy: any;\n    get _absLeft(): number;\n    get _absRight(): number;\n    get _absTop(): number;\n    get _absBottom(): number;\n    get _hasSplitAnchorsX(): boolean;\n    get _hasSplitAnchorsY(): boolean;\n    get aabb(): any;\n    /**\n     * Specifies where the left, bottom, right and top edges of the component are anchored relative\n     * to its parent. Each value ranges from 0 to 1. e.g. a value of [0, 0, 0, 0] means that the\n     * element will be anchored to the bottom left of its parent. A value of [1, 1, 1, 1] means it\n     * will be anchored to the top right. A split anchor is when the left-right or top-bottom pairs\n     * of the anchor are not equal. In that case the component will be resized to cover that entire\n     * area. e.g. a value of [0, 0, 1, 1] will make the component resize exactly as its parent.\n     *\n     * @type {Vec4}\n     */\n    set anchor(arg: Vec4);\n    get anchor(): Vec4;\n    /**\n     * Assign element to a specific batch group (see {@link BatchGroup}). Default is -1 (no group).\n     *\n     * @type {number}\n     */\n    set batchGroupId(arg: number);\n    get batchGroupId(): number;\n    /**\n     * The distance from the bottom edge of the anchor. Can be used in combination with a split\n     * anchor to make the component\'s top edge always be \'top\' units away from the top.\n     *\n     * @type {number}\n     */\n    set bottom(arg: number);\n    get bottom(): number;\n    /**\n     * The width at which the element will be rendered. In most cases this will be the same as\n     * `width`. However, in some cases the engine may calculate a different width for the element,\n     * such as when the element is under the control of a {@link LayoutGroupComponent}. In these\n     * scenarios, `calculatedWidth` may be smaller or larger than the width that was set in the\n     * editor.\n     *\n     * @type {number}\n     */\n    set calculatedWidth(arg: number);\n    get calculatedWidth(): number;\n    /**\n     * The height at which the element will be rendered. In most cases this will be the same as\n     * `height`. However, in some cases the engine may calculate a different height for the element,\n     * such as when the element is under the control of a {@link LayoutGroupComponent}. In these\n     * scenarios, `calculatedHeight` may be smaller or larger than the height that was set in the\n     * editor.\n     *\n     * @type {number}\n     */\n    set calculatedHeight(arg: number);\n    get calculatedHeight(): number;\n    /**\n     * An array of 4 {@link Vec2}s that represent the bottom left, bottom right, top right and top\n     * left corners of the component in canvas pixels. Only works for screen space element\n     * components.\n     *\n     * @type {Vec2[]}\n     */\n    get canvasCorners(): Vec2[];\n    /**\n     * The draw order of the component. A higher value means that the component will be rendered on\n     * top of other components.\n     *\n     * @type {number}\n     */\n    set drawOrder(arg: number);\n    get drawOrder(): number;\n    /**\n     * The height of the element as set in the editor. Note that in some cases this may not reflect\n     * the true height at which the element is rendered, such as when the element is under the\n     * control of a {@link LayoutGroupComponent}. See `calculatedHeight` in order to ensure you are\n     * reading the true height at which the element will be rendered.\n     *\n     * @type {number}\n     */\n    set height(arg: number);\n    get height(): number;\n    /**\n     * An array of layer IDs ({@link Layer#id}) to which this element should belong. Don\'t push,\n     * pop, splice or modify this array, if you want to change it - set a new one instead.\n     *\n     * @type {number[]}\n     */\n    set layers(arg: number[]);\n    get layers(): number[];\n    /**\n     * The distance from the left edge of the anchor. Can be used in combination with a split\n     * anchor to make the component\'s left edge always be \'left\' units away from the left.\n     *\n     * @type {number}\n     */\n    set left(arg: number);\n    get left(): number;\n    /**\n     * The distance from the left, bottom, right and top edges of the anchor. For example if we are\n     * using a split anchor like [0,0,1,1] and the margin is [0,0,0,0] then the component will be\n     * the same width and height as its parent.\n     *\n     * @type {Vec4}\n     */\n    set margin(arg: Vec4);\n    get margin(): Vec4;\n    /**\n     * Get the entity that is currently masking this element.\n     *\n     * @type {Entity}\n     * @private\n     */\n    private get maskedBy();\n    /**\n     * The position of the pivot of the component relative to its anchor. Each value ranges from 0\n     * to 1 where [0,0] is the bottom left and [1,1] is the top right.\n     *\n     * @type {Vec2}\n     */\n    set pivot(arg: Vec2);\n    get pivot(): Vec2;\n    /**\n     * The distance from the right edge of the anchor. Can be used in combination with a split\n     * anchor to make the component\'s right edge always be \'right\' units away from the right.\n     *\n     * @type {number}\n     */\n    set right(arg: number);\n    get right(): number;\n    /**\n     * An array of 4 {@link Vec3}s that represent the bottom left, bottom right, top right and top\n     * left corners of the component relative to its parent {@link ScreenComponent}.\n     *\n     * @type {Vec3[]}\n     */\n    get screenCorners(): Vec3[];\n    /**\n     * The width of the text rendered by the component. Only works for {@link ELEMENTTYPE_TEXT} types.\n     *\n     * @type {number}\n     */\n    get textWidth(): number;\n    /**\n     * The height of the text rendered by the component. Only works for {@link ELEMENTTYPE_TEXT} types.\n     *\n     * @type {number}\n     */\n    get textHeight(): number;\n    /**\n     * The distance from the top edge of the anchor. Can be used in combination with a split anchor\n     * to make the component\'s bottom edge always be \'bottom\' units away from the bottom.\n     *\n     * @type {number}\n     */\n    set top(arg: number);\n    get top(): number;\n    /**\n     * The type of the ElementComponent. Can be:\n     *\n     * - {@link ELEMENTTYPE_GROUP}: The component can be used as a layout mechanism to create groups of\n     * ElementComponents e.g. panels.\n     * - {@link ELEMENTTYPE_IMAGE}: The component will render an image\n     * - {@link ELEMENTTYPE_TEXT}: The component will render text\n     *\n     * @type {string}\n     */\n    set type(arg: string);\n    get type(): string;\n    /**\n     * If true then the component will receive Mouse or Touch input events.\n     *\n     * @type {boolean}\n     */\n    set useInput(arg: boolean);\n    get useInput(): boolean;\n    /**\n     * The width of the element as set in the editor. Note that in some cases this may not reflect\n     * the true width at which the element is rendered, such as when the element is under the\n     * control of a {@link LayoutGroupComponent}. See `calculatedWidth` in order to ensure you are\n     * reading the true width at which the element will be rendered.\n     *\n     * @type {number}\n     */\n    set width(arg: number);\n    get width(): number;\n    /**\n     * An array of 4 {@link Vec3}s that represent the bottom left, bottom right, top right and top\n     * left corners of the component in world space. Only works for 3D element components.\n     *\n     * @type {Vec3[]}\n     */\n    get worldCorners(): Vec3[];\n    _patch(): void;\n    _unpatch(): void;\n    _setPosition(x: any, y: any, z: any): any;\n    _setLocalPosition(x: any, y: any, z: any): void;\n    _sync(): any;\n    _dirtyLocal: boolean;\n    _dirtyWorld: boolean;\n    _onInsert(parent: any): void;\n    _dirtifyMask(): void;\n    _onPrerender(): void;\n    _bindScreen(screen: any): void;\n    _unbindScreen(screen: any): void;\n    _updateScreen(screen: any): void;\n    syncMask(depth: any): void;\n    _setMaskedBy(mask: any): void;\n    _updateMask(currentMask: any, depth: any): void;\n    _parseUpToScreen(): {\n        screen: any;\n        mask: any;\n    };\n    _onScreenResize(res: any): void;\n    _onScreenSpaceChange(): void;\n    _onScreenRemove(): void;\n    _calculateLocalAnchors(): void;\n    getOffsetPosition(x: any, y: any): Vec3;\n    onLayersChanged(oldComp: any, newComp: any): void;\n    onLayerAdded(layer: any): void;\n    onLayerRemoved(layer: any): void;\n    onRemove(): void;\n    _calculateSize(propagateCalculatedWidth: any, propagateCalculatedHeight: any): void;\n    _sizeDirty: boolean;\n    _setWidth(w: any): void;\n    _setHeight(h: any): void;\n    _setCalculatedWidth(value: any, updateMargins: any): void;\n    _setCalculatedHeight(value: any, updateMargins: any): void;\n    _flagChildrenAsDirty(): void;\n    addModelToLayers(model: any): void;\n    removeModelFromLayers(model: any): void;\n    getMaskOffset(): number;\n    isVisibleForCamera(camera: any): boolean;\n    _isScreenSpace(): boolean;\n    _isScreenCulled(): boolean;\n}\n\n/**\n * Helper class that makes it easy to create Elements that can be dragged by the mouse or touch.\n *\n * @augments EventHandler\n */\ndeclare class ElementDragHelper extends EventHandler {\n    /**\n     * Create a new ElementDragHelper instance.\n     *\n     * @param {ElementComponent} element - The Element that should become draggable.\n     * @param {string} [axis] - Optional axis to constrain to, either \'x\', \'y\' or null.\n     */\n    constructor(element: ElementComponent, axis?: string);\n    _element: ElementComponent;\n    _app: Application;\n    _axis: string;\n    _enabled: boolean;\n    _dragScale: Vec3;\n    _dragStartMousePosition: Vec3;\n    _dragStartHandlePosition: Vec3;\n    _deltaMousePosition: Vec3;\n    _deltaHandlePosition: Vec3;\n    _isDragging: boolean;\n    _toggleLifecycleListeners(onOrOff: any): void;\n    _toggleDragListeners(onOrOff: any): void;\n    _handleMouseUpOrTouchEnd: any;\n    _hasDragListeners: boolean;\n    _onMouseDownOrTouchStart(event: any): void;\n    _dragCamera: any;\n    _onMouseUpOrTouchEnd(): void;\n    _screenToLocal(event: any): Vec3;\n    _determineInputPosition(event: any): void;\n    _chooseRayOriginAndDirection(): void;\n    _calculateDragScale(): void;\n    _onMove(event: any): void;\n    destroy(): void;\n    set enabled(arg: boolean);\n    get enabled(): boolean;\n    get isDragging(): boolean;\n}\n\n\n\n/**\n * A ScrollViewComponent enables a group of entities to behave like a masked scrolling area, with\n * optional horizontal and vertical scroll bars.\n *\n * @property {boolean} horizontal Whether to enable horizontal scrolling.\n * @property {boolean} vertical Whether to enable vertical scrolling.\n * @property {number} scrollMode Specifies how the scroll view should behave when the user scrolls\n * past the end of the content. Modes are defined as follows:\n *\n * - {@link SCROLL_MODE_CLAMP}: Content does not scroll any further than its bounds.\n * - {@link SCROLL_MODE_BOUNCE}: Content scrolls past its bounds and then gently bounces back.\n * - {@link SCROLL_MODE_INFINITE}: Content can scroll forever.\n *\n * @property {number} bounceAmount Controls how far the content should move before bouncing back.\n * @property {number} friction Controls how freely the content should move if thrown, i.e. By\n * flicking on a phone or by flinging the scroll wheel on a mouse. A value of 1 means that content\n * will stop immediately; 0 means that content will continue moving forever (or until the bounds of\n * the content are reached, depending on the scrollMode).\n * @property {boolean} useMouseWheel Whether to use mouse wheel for scrolling (horizontally and\n * vertically).\n * @property {Vec2} mouseWheelSensitivity Mouse wheel horizontal and vertical sensitivity. Only\n * used if useMouseWheel is set. Setting a direction to 0 will disable mouse wheel scrolling in\n * that direction. 1 is a default sensitivity that is considered to feel good. The values can be\n * set higher or lower than 1 to tune the sensitivity. Defaults to [1, 1].\n * @property {number} horizontalScrollbarVisibility Controls whether the horizontal scrollbar\n * should be visible all the time, or only visible when the content exceeds the size of the\n * viewport.\n * @property {number} verticalScrollbarVisibility Controls whether the vertical scrollbar should be\n * visible all the time, or only visible when the content exceeds the size of the viewport.\n * @property {Entity} viewportEntity The entity to be used as the masked viewport area, within\n * which the content will scroll. This entity must have an ElementGroup component.\n * @property {Entity} contentEntity The entity which contains the scrolling content itself. This\n * entity must have an Element component.\n * @property {Entity} horizontalScrollbarEntity The entity to be used as the vertical scrollbar.\n * This entity must have a Scrollbar component.\n * @property {Entity} verticalScrollbarEntity The entity to be used as the vertical scrollbar. This\n * entity must have a Scrollbar component.\n * @augments Component\n */\ndeclare class ScrollViewComponent extends Component {\n    /**\n     * Create a new ScrollViewComponent.\n     *\n     * @param {ScrollViewComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: ScrollViewComponentSystem, entity: Entity);\n\n    set bounceAmount(arg: number);\n    get bounceAmount(): number;\n\n    set contentEntity(arg: Entity);\n    get contentEntity(): Entity;\n\n    set friction(arg: number);\n    get friction(): number;\n\n    set horizontal(arg: boolean);\n    get horizontal(): boolean;\n\n    set horizontalScrollbarEntity(arg: Entity);\n    get horizontalScrollbarEntity(): Entity;\n\n    set horizontalScrollbarVisibility(arg: number);\n    get horizontalScrollbarVisibility(): number;\n\n    set mouseWheelSensitivity(arg: Vec2);\n    get mouseWheelSensitivity(): Vec2;\n\n    set scrollMode(arg: number);\n    get scrollMode(): number;\n\n    set useMouseWheel(arg: boolean);\n    get useMouseWheel(): boolean;\n\n    set vertical(arg: boolean);\n    get vertical(): boolean;\n\n    set verticalScrollbarEntity(arg: Entity);\n    get verticalScrollbarEntity(): Entity;\n\n    set verticalScrollbarVisibility(arg: number);\n    get verticalScrollbarVisibility(): number;\n\n    set viewportEntity(arg: Entity);\n    get viewportEntity(): Entity;\n\n    _viewportReference: EntityReference;\n    _contentReference: EntityReference;\n    _scrollbarUpdateFlags: {};\n    _scrollbarReferences: {};\n    _prevContentSizes: {};\n    _scroll: Vec2;\n    _velocity: Vec3;\n    _dragStartPosition: Vec3;\n    _disabledContentInput: boolean;\n    _disabledContentInputEntities: any[];\n    _toggleLifecycleListeners(onOrOff: any, system: any): void;\n    _toggleElementListeners(onOrOff: any): void;\n    _hasElementListeners: boolean;\n    _onElementComponentAdd(entity: any): void;\n    _onElementComponentRemove(entity: any): void;\n    _onViewportElementGain(): void;\n    _onContentElementGain(): void;\n    _contentDragHelper: ElementDragHelper;\n    _onContentElementLose(): void;\n    _onContentDragStart(): void;\n    _onContentDragEnd(): void;\n    _prevContentDragPosition: any;\n    _onContentDragMove(position: any): void;\n    _wasDragged: boolean;\n    _onSetContentOrViewportSize(): void;\n    _onSetHorizontalScrollbarValue(scrollValueX: any): void;\n    _onSetVerticalScrollbarValue(scrollValueY: any): void;\n    _onSetHorizontalScrollingEnabled(): void;\n    _onSetVerticalScrollingEnabled(): void;\n    _onHorizontalScrollbarGain(): void;\n    _onVerticalScrollbarGain(): void;\n    _onSetScroll(x: any, y: any, resetVelocity: any): void;\n    _updateAxis(scrollValue: any, axis: any, orientation: any): boolean;\n    _determineNewScrollValue(scrollValue: any, axis: any, orientation: any): any;\n    _syncAll(): void;\n    _syncContentPosition(orientation: any): void;\n    _syncScrollbarPosition(orientation: any): void;\n    _syncScrollbarEnabledState(orientation: any): void;\n    _contentIsLargerThanViewport(orientation: any): boolean;\n    _contentPositionToScrollValue(contentPosition: any): Vec2;\n    _getMaxOffset(orientation: any, contentSize: any): number;\n    _getMaxScrollValue(orientation: any): 1 | 0;\n    _getScrollbarHandleSize(axis: any, orientation: any): number;\n    _getViewportSize(orientation: any): any;\n    _getContentSize(orientation: any): any;\n    _getSize(orientation: any, entityReference: any): any;\n    _getScrollingEnabled(orientation: any): any;\n    _getScrollbarVisibility(orientation: any): any;\n    _getSign(orientation: any): 1 | -1;\n    _getAxis(orientation: any): "x" | "y";\n    _getCalculatedDimension(orientation: any): "calculatedWidth" | "calculatedHeight";\n    _destroyDragHelper(): void;\n    onUpdate(): void;\n    _updateVelocity(): void;\n    _hasOvershoot(axis: any, orientation: any): boolean;\n    _toOvershoot(scrollValue: any, orientation: any): any;\n    _setVelocityFromOvershoot(scrollValue: any, axis: any, orientation: any): void;\n    _setVelocityFromContentPositionDelta(position: any): void;\n    _setScrollFromContentPosition(position: any): void;\n    _applyScrollValueTension(scrollValue: any): any;\n    _isDragging(): boolean;\n    _setScrollbarComponentsEnabled(enabled: any): void;\n    _setContentDraggingEnabled(enabled: any): void;\n    _onMouseWheel(event: any): void;\n    set scroll(arg: Vec2);\n    get scroll(): Vec2;\n    _enableContentInput(): void;\n    _disableContentInput(): void;\n    onRemove(): void;\n}\n\ndeclare class ScrollbarComponentData {\n    enabled: boolean;\n}\n\n/**\n * Manages creation of {@link ScrollbarComponent}s.\n *\n * @augments ComponentSystem\n */\ndeclare class ScrollbarComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof ScrollbarComponent;\n    DataType: typeof ScrollbarComponentData;\n    schema: {\n        name: string;\n        type: string;\n    }[];\n    initializeComponentData(component: any, data: any, properties: any): void;\n    _onRemoveComponent(entity: any, component: any): void;\n}\n\n\n\n/** @typedef {import(\'../../entity.js\').Entity} Entity */\n/** @typedef {import(\'./system.js\').ScrollbarComponentSystem} ScrollbarComponentSystem */\n/**\n * A ScrollbarComponent enables a group of entities to behave like a draggable scrollbar.\n *\n * @property {number} orientation Whether the scrollbar moves horizontally or vertically. Can be:\n *\n * - {@link ORIENTATION_HORIZONTAL}: The scrollbar animates in the horizontal axis.\n * - {@link ORIENTATION_VERTICAL}: The scrollbar animates in the vertical axis.\n *\n * Defaults to {@link ORIENTATION_HORIZONTAL}.\n * @property {number} value The current position value of the scrollbar, in the range 0 to 1.\n * Defaults to 0.\n * @property {number} handleSize The size of the handle relative to the size of the track, in the\n * range 0 to 1. For a vertical scrollbar, a value of 1 means that the handle will take up the full\n * height of the track.\n * @property {Entity} handleEntity The entity to be used as the scrollbar handle. This entity must\n * have a Scrollbar component.\n * @augments Component\n */\ndeclare class ScrollbarComponent extends Component {\n    /**\n     * Create a new ScrollbarComponent.\n     *\n     * @param {ScrollbarComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: ScrollbarComponentSystem, entity: Entity);\n\n    set handleEntity(arg: Entity);\n    get handleEntity(): Entity;\n\n    set handleSize(arg: number);\n    get handleSize(): number;\n\n    set orientation(arg: number);\n    get orientation(): number;\n\n    _handleReference: EntityReference;\n    _toggleLifecycleListeners(onOrOff: any): void;\n    _onHandleElementGain(): void;\n    _handleDragHelper: ElementDragHelper;\n    _onHandleElementLose(): void;\n    _onHandleDrag(position: any): void;\n    value: number;\n    _onSetValue(name: any, oldValue: any, newValue: any): void;\n    _onSetHandleSize(name: any, oldValue: any, newValue: any): void;\n    _onSetHandleAlignment(): void;\n    _onSetOrientation(name: any, oldValue: any, newValue: any): void;\n    _updateHandlePositionAndSize(): void;\n    _handlePositionToScrollValue(handlePosition: any): number;\n    _scrollValueToHandlePosition(value: any): number;\n    _getUsableTrackLength(): number;\n    _getTrackLength(): number;\n    _getHandleLength(): number;\n    _getHandlePosition(): number;\n    _getSign(): 1 | -1;\n    _getAxis(): "x" | "y";\n    _getDimension(): "height" | "width";\n    _getOppositeDimension(): "height" | "width";\n    _destroyDragHelper(): void;\n    _setHandleDraggingEnabled(enabled: any): void;\n    onRemove(): void;\n}\n\ndeclare class ScriptComponentData {\n    enabled: boolean;\n}\n\n/**\n * Allows scripts to be attached to an Entity and executed.\n *\n * @augments ComponentSystem\n */\ndeclare class ScriptComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof ScriptComponent;\n    DataType: typeof ScriptComponentData;\n    _components: SortedLoopArray;\n    _enabledComponents: SortedLoopArray;\n    preloading: boolean;\n    initializeComponentData(component: any, data: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    _resetExecutionOrder(): void;\n    _callComponentMethod(components: any, name: any, dt: any): void;\n    _onInitialize(): void;\n    _onPostInitialize(): void;\n    _onUpdate(dt: any): void;\n    _onPostUpdate(dt: any): void;\n    _addComponentToEnabled(component: any): void;\n    _removeComponentFromEnabled(component: any): void;\n    _onBeforeRemove(entity: any, component: any): void;\n}\n\n/**\n * Container of Script Attribute definitions. Implements an interface to add/remove attributes and\n * store their definition for a {@link ScriptType}. Note: An instance of ScriptAttributes is\n * created automatically by each {@link ScriptType}.\n */\ndeclare class ScriptAttributes {\n    static reservedNames: Set<string>;\n    /**\n     * Create a new ScriptAttributes instance.\n     *\n     * @param {typeof ScriptType} scriptType - Script Type that attributes relate to.\n     */\n    constructor(scriptType: typeof ScriptType);\n    scriptType: typeof ScriptType;\n    index: {};\n    /**\n     * Add Attribute.\n     *\n     * @param {string} name - Name of an attribute.\n     * @param {object} args - Object with Arguments for an attribute.\n     * @param {("boolean"|"number"|"string"|"json"|"asset"|"entity"|"rgb"|"rgba"|"vec2"|"vec3"|"vec4"|"curve")} args.type - Type\n     * of an attribute value.  Can be:\n     *\n     * - "asset"\n     * - "boolean"\n     * - "curve"\n     * - "entity"\n     * - "json"\n     * - "number"\n     * - "rgb"\n     * - "rgba"\n     * - "string"\n     * - "vec2"\n     * - "vec3"\n     * - "vec4"\n     *\n     * @param {*} [args.default] - Default attribute value.\n     * @param {string} [args.title] - Title for Editor\'s for field UI.\n     * @param {string} [args.description] - Description for Editor\'s for field UI.\n     * @param {string|string[]} [args.placeholder] - Placeholder for Editor\'s for field UI.\n     * For multi-field types, such as vec2, vec3, and others use array of strings.\n     * @param {boolean} [args.array] - If attribute can hold single or multiple values.\n     * @param {number} [args.size] - If attribute is array, maximum number of values can be set.\n     * @param {number} [args.min] - Minimum value for type \'number\', if max and min defined, slider\n     * will be rendered in Editor\'s UI.\n     * @param {number} [args.max] - Maximum value for type \'number\', if max and min defined, slider\n     * will be rendered in Editor\'s UI.\n     * @param {number} [args.precision] - Level of precision for field type \'number\' with floating\n     * values.\n     * @param {number} [args.step] - Step value for type \'number\'. The amount used to increment the\n     * value when using the arrow keys in the Editor\'s UI.\n     * @param {string} [args.assetType] - Name of asset type to be used in \'asset\' type attribute\n     * picker in Editor\'s UI, defaults to \'*\' (all).\n     * @param {string[]} [args.curves] - List of names for Curves for field type \'curve\'.\n     * @param {string} [args.color] - String of color channels for Curves for field type \'curve\',\n     * can be any combination of `rgba` characters. Defining this property will render Gradient in\n     * Editor\'s field UI.\n     * @param {object[]} [args.enum] - List of fixed choices for field, defined as array of objects,\n     * where key in object is a title of an option.\n     * @param {object[]} [args.schema] - List of attributes for type \'json\'. Each attribute\n     * description is an object with the same properties as regular script attributes but with an\n     * added \'name\' field to specify the name of each attribute in the JSON.\n     * @example\n     * PlayerController.attributes.add(\'fullName\', {\n     *     type: \'string\'\n     * });\n     * @example\n     * PlayerController.attributes.add(\'speed\', {\n     *     type: \'number\',\n     *     title: \'Speed\',\n     *     placeholder: \'km/h\',\n     *     default: 22.2\n     * });\n     * @example\n     * PlayerController.attributes.add(\'resolution\', {\n     *     type: \'number\',\n     *     default: 32,\n     *     enum: [\n     *         { \'32x32\': 32 },\n     *         { \'64x64\': 64 },\n     *         { \'128x128\': 128 }\n     *     ]\n     * });\n     * @example\n     * PlayerController.attributes.add(\'config\', {\n     *     type: \'json\',\n     *     schema: [{\n     *         name: \'speed\',\n     *         type: \'number\',\n     *         title: \'Speed\',\n     *         placeholder: \'km/h\',\n     *         default: 22.2\n     *     }, {\n     *         name: \'resolution\',\n     *         type: \'number\',\n     *         default: 32,\n     *         enum: [\n     *             { \'32x32\': 32 },\n     *             { \'64x64\': 64 },\n     *             { \'128x128\': 128 }\n     *         ]\n     *     }]\n     * });\n     */\n    add(name: string, args: {\n        type: ("boolean" | "number" | "string" | "json" | "asset" | "entity" | "rgb" | "rgba" | "vec2" | "vec3" | "vec4" | "curve");\n        default?: any;\n        title?: string;\n        description?: string;\n        placeholder?: string | string[];\n        array?: boolean;\n        size?: number;\n        min?: number;\n        max?: number;\n        precision?: number;\n        step?: number;\n        assetType?: string;\n        curves?: string[];\n        color?: string;\n        enum?: object[];\n        schema?: object[];\n    }): void;\n    /**\n     * Remove Attribute.\n     *\n     * @param {string} name - Name of an attribute.\n     * @returns {boolean} True if removed or false if not defined.\n     * @example\n     * PlayerController.attributes.remove(\'fullName\');\n     */\n    remove(name: string): boolean;\n    /**\n     * Detect if Attribute is added.\n     *\n     * @param {string} name - Name of an attribute.\n     * @returns {boolean} True if Attribute is defined.\n     * @example\n     * if (PlayerController.attributes.has(\'fullName\')) {\n     *     // attribute fullName is defined\n     * }\n     */\n    has(name: string): boolean;\n    /**\n     * Get object with attribute arguments. Note: Changing argument properties will not affect\n     * existing Script Instances.\n     *\n     * @param {string} name - Name of an attribute.\n     * @returns {?object} Arguments with attribute properties.\n     * @example\n     * // changing default value for an attribute \'fullName\'\n     * var attr = PlayerController.attributes.get(\'fullName\');\n     * if (attr) attr.default = \'Unknown\';\n     */\n    get(name: string): object | null;\n}\n\n\n\n/**\n * Represents the type of a script. It is returned by {@link createScript}. Also referred to as\n * Script Type.\n *\n * The type is to be extended using its JavaScript prototype. There is a list of methods that will\n * be executed by the engine on instances of this type, such as:\n *\n * - `initialize`\n * - `postInitialize`\n * - `update`\n * - `postUpdate`\n * - `swap`\n *\n * `initialize` and `postInitialize` - are called (if defined) when a script is about to run for\n * the first time - `postInitialize` will run after all `initialize` methods are executed in the\n * same tick or enabling chain of actions.\n *\n * `update` and `postUpdate` - are called (if defined) for enabled (running state) scripts on each\n * tick.\n *\n * `swap` - is called when a ScriptType that already exists in the registry gets redefined. If the\n * new ScriptType has a `swap` method in its prototype, then it will be executed to perform hot-\n * reload at runtime.\n *\n * @augments EventHandler\n */\ndeclare class ScriptType extends EventHandler {\n    /**\n     * Name of a Script Type.\n     *\n     * @type {string}\n     * @private\n     */\n    private static __name;\n    /**\n     * @param {*} constructorFn - The constructor function of the script type.\n     * @returns {string} The script name.\n     * @private\n     */\n    private static __getScriptName;\n    /**\n     * Name of a Script Type.\n     *\n     * @type {string|null}\n     */\n    static get scriptName(): string;\n    /**\n     * The interface to define attributes for Script Types. Refer to {@link ScriptAttributes}.\n     *\n     * @type {ScriptAttributes}\n     * @example\n     * var PlayerController = pc.createScript(\'playerController\');\n     *\n     * PlayerController.attributes.add(\'speed\', {\n     *     type: \'number\',\n     *     title: \'Speed\',\n     *     placeholder: \'km/h\',\n     *     default: 22.2\n     * });\n     */\n    static get attributes(): ScriptAttributes;\n    /**\n     * Shorthand function to extend Script Type prototype with list of methods.\n     *\n     * @param {object} methods - Object with methods, where key - is name of method, and value - is function.\n     * @example\n     * var PlayerController = pc.createScript(\'playerController\');\n     *\n     * PlayerController.extend({\n     *     initialize: function () {\n     *         // called once on initialize\n     *     },\n     *     update: function (dt) {\n     *         // called each tick\n     *     }\n     * });\n     */\n    static extend(methods: object): void;\n    /**\n     * Create a new ScriptType instance.\n     *\n     * @param {object} args - The input arguments object.\n     * @param {Application} args.app - The {@link Application} that is running the script.\n     * @param {Entity} args.entity - The {@link Entity} that the script is attached to.\n     */\n    constructor(args: {\n        app: Application;\n        entity: Entity;\n    });\n    /**\n     * The {@link Application} that the instance of this type belongs to.\n     *\n     * @type {Application}\n     */\n    app: Application;\n    /**\n     * The {@link Entity} that the instance of this type belongs to.\n     *\n     * @type {Entity}\n     */\n    entity: Entity;\n    /** @private */\n    private _enabled;\n    /** @private */\n    private _enabledOld;\n    /** @private */\n    private _initialized;\n    /** @private */\n    private _postInitialized;\n    /** @private */\n    private __destroyed;\n    /** @private */\n    private __attributes;\n    /** @private */\n    private __attributesRaw;\n    /** @private */\n    private __scriptType;\n    /**\n     * The order in the script component that the methods of this script instance will run\n     * relative to other script instances in the component.\n     *\n     * @type {number}\n     * @private\n     */\n    private __executionOrder;\n    /**\n     * True if the instance of this type is in running state. False when script is not running,\n     * because the Entity or any of its parents are disabled or the {@link ScriptComponent} is\n     * disabled or the Script Instance is disabled. When disabled no update methods will be called\n     * on each tick. initialize and postInitialize methods will run once when the script instance\n     * is in `enabled` state during app tick.\n     *\n     * @type {boolean}\n     */\n    set enabled(arg: boolean);\n    get enabled(): boolean;\n\n    /**\n     * Called when script is about to run for the first time.\n     */\n    initialize?(): void;\n    /**\n     * Called after all initialize methods are executed in the same tick or enabling chain of actions.\n     */\n    postInitialize?(): void;\n    /**\n     * Called for enabled (running state) scripts on each tick.\n     * @param dt - The delta time in seconds since the last frame.\n     */\n    update?(dt: number): void;\n    /**\n     * Called for enabled (running state) scripts on each tick, after update.\n     * @param dt - The delta time in seconds since the last frame.\n     */\n    postUpdate?(dt: number): void;\n    /**\n     * Called when a ScriptType that already exists in the registry gets redefined. If the new\n     * ScriptType has a `swap` method in its prototype, then it will be executed to perform\n     * hot-reload at runtime.\n     * @param old - Old instance of the scriptType to copy data to the new instance.\n     */\n    swap?(old: ScriptType): void;\n\n    /**\n     * @param {{entity: Entity, app: Application}} args - The entity and app.\n     * @private\n     */\n    private initScriptType;\n    /**\n     * @param {boolean} force - Set to true to force initialization of the attributes.\n     * @private\n     */\n    private __initializeAttributes;\n}\n\n\n/** @typedef {import(\'./system.js\').ScriptComponentSystem} ScriptComponentSystem */\n/**\n * The ScriptComponent allows you to extend the functionality of an Entity by attaching your own\n * Script Types defined in JavaScript files to be executed with access to the Entity. For more\n * details on scripting see [Scripting](https://developer.playcanvas.com/user-manual/scripting/).\n *\n * @augments Component\n */\ndeclare class ScriptComponent extends Component {\n    static scriptMethods: {\n        initialize: string;\n        postInitialize: string;\n        update: string;\n        postUpdate: string;\n        swap: string;\n    };\n    /**\n     * Create a new ScriptComponent instance.\n     *\n     * @param {ScriptComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: ScriptComponentSystem, entity: Entity);\n    /**\n     * Holds all script instances for this component.\n     *\n     * @type {ScriptType[]}\n     * @private\n     */\n    private _scripts;\n    _updateList: SortedLoopArray;\n    _postUpdateList: SortedLoopArray;\n    _scriptsIndex: {};\n    _destroyedScripts: any[];\n    _destroyed: boolean;\n    _scriptsData: ScriptType[];\n    _oldState: boolean;\n    _enabled: boolean;\n    _beingEnabled: boolean;\n    _isLoopingThroughScripts: boolean;\n    _executionOrder: number;\n    set enabled(arg: boolean);\n    get enabled(): boolean;\n    /**\n     * An array of all script instances attached to an entity. This array is read-only and should\n     * not be modified by developer.\n     *\n     * @type {ScriptType[]}\n     */\n    set scripts(arg: ScriptType[]);\n    get scripts(): ScriptType[];\n    _beginLooping(): boolean;\n    _endLooping(wasLoopingBefore: any): void;\n    _onSetEnabled(prop: any, old: any, value: any): void;\n    _checkState(): void;\n    _onBeforeRemove(): void;\n    _removeDestroyedScripts(): void;\n    _onInitializeAttributes(): void;\n    _scriptMethod(script: any, method: any, arg: any): void;\n    _onInitialize(): void;\n    _onPostInitialize(): void;\n    _onUpdate(dt: any): void;\n    _onPostUpdate(dt: any): void;\n    /**\n     * Inserts script instance into the scripts array at the specified index. Also inserts the\n     * script into the update list if it has an update method and the post update list if it has a\n     * postUpdate method.\n     *\n     * @param {object} scriptInstance - The script instance.\n     * @param {number} index - The index where to insert the script at. If -1, append it at the end.\n     * @param {number} scriptsLength - The length of the scripts array.\n     * @private\n     */\n    private _insertScriptInstance;\n    _removeScriptInstance(scriptInstance: any): number;\n    _resetExecutionOrder(startIndex: any, scriptsLength: any): void;\n    _resolveEntityScriptAttribute(attribute: any, attributeName: any, oldValue: any, useGuid: any, newAttributes: any, duplicatedIdsMap: any): void;\n    /**\n     * Detect if script is attached to an entity.\n     *\n     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.\n     * @returns {boolean} If script is attached to an entity.\n     * @example\n     * if (entity.script.has(\'playerController\')) {\n     *     // entity has script\n     * }\n     */\n    has(nameOrType: string | typeof ScriptType): boolean;\n    /**\n     * Get a script instance (if attached).\n     *\n     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.\n     * @returns {ScriptType|null} If script is attached, the instance is returned. Otherwise null\n     * is returned.\n     * @example\n     * var controller = entity.script.get(\'playerController\');\n     */\n    get(nameOrType: string | typeof ScriptType): ScriptType | null;\n    /**\n     * Create a script instance and attach to an entity script component.\n     *\n     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.\n     * @param {object} [args] - Object with arguments for a script.\n     * @param {boolean} [args.enabled] - If script instance is enabled after creation. Defaults to\n     * true.\n     * @param {object} [args.attributes] - Object with values for attributes (if any), where key is\n     * name of an attribute.\n     * @param {boolean} [args.preloading] - If script instance is created during preload. If true,\n     * script and attributes must be initialized manually. Defaults to false.\n     * @param {number} [args.ind] - The index where to insert the script instance at. Defaults to\n     * -1, which means append it at the end.\n     * @returns {ScriptType|null} Returns an instance of a {@link ScriptType} if successfully attached\n     * to an entity, or null if it failed because a script with a same name has already been added\n     * or if the {@link ScriptType} cannot be found by name in the {@link ScriptRegistry}.\n     * @example\n     * entity.script.create(\'playerController\', {\n     *     attributes: {\n     *         speed: 4\n     *     }\n     * });\n     */\n    create(nameOrType: string | typeof ScriptType, args?: {\n        enabled?: boolean;\n        attributes?: object;\n        preloading?: boolean;\n        ind?: number;\n    }): ScriptType | null;\n    /**\n     * Destroy the script instance that is attached to an entity.\n     *\n     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.\n     * @returns {boolean} If it was successfully destroyed.\n     * @example\n     * entity.script.destroy(\'playerController\');\n     */\n    destroy(nameOrType: string | typeof ScriptType): boolean;\n    /**\n     * Swap the script instance.\n     *\n     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.\n     * @returns {boolean} If it was successfully swapped.\n     * @private\n     */\n    private swap;\n    /**\n     * When an entity is cloned and it has entity script attributes that point to other entities in\n     * the same subtree that is cloned, then we want the new script attributes to point at the\n     * cloned entities. This method remaps the script attributes for this entity and it assumes\n     * that this entity is the result of the clone operation.\n     *\n     * @param {ScriptComponent} oldScriptComponent - The source script component that belongs to\n     * the entity that was being cloned.\n     * @param {object} duplicatedIdsMap - A dictionary with guid-entity values that contains the\n     * entities that were cloned.\n     * @private\n     */\n    private resolveDuplicatedEntityReferenceProperties;\n    /**\n     * Move script instance to different position to alter update order of scripts within entity.\n     *\n     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.\n     * @param {number} ind - New position index.\n     * @returns {boolean} If it was successfully moved.\n     * @example\n     * entity.script.move(\'playerController\', 0);\n     */\n    move(nameOrType: string | typeof ScriptType, ind: number): boolean;\n}\n\ndeclare class ScreenComponentData {\n    enabled: boolean;\n}\n\n/**\n * Manages creation of {@link ScreenComponent}s.\n *\n * @augments ComponentSystem\n */\ndeclare class ScreenComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof ScreenComponent;\n    DataType: typeof ScreenComponentData;\n    schema: string[];\n    windowResolution: Vec2;\n    _drawOrderSyncQueue: IndexedList;\n    initializeComponentData(component: any, data: any, properties: any): void;\n    _onUpdate(dt: any): void;\n    _onResize(width: any, height: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    onRemoveComponent(entity: any, component: any): void;\n    processDrawOrderSyncQueue(): void;\n    queueDrawOrderSync(id: any, fn: any, scope: any): void;\n}\n\n\n/**\n * A ScreenComponent enables the Entity to render child {@link ElementComponent}s using anchors and\n * positions in the ScreenComponent\'s space.\n *\n * @augments Component\n */\ndeclare class ScreenComponent extends Component {\n    /**\n     * Create a new ScreenComponent.\n     *\n     * @param {ScreenComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: ScreenComponentSystem, entity: Entity);\n    _resolution: Vec2;\n    _referenceResolution: Vec2;\n    _scaleMode: string;\n    scale: number;\n    _scaleBlend: number;\n    _priority: number;\n    _screenSpace: boolean;\n    /**\n     * If true then elements inside this screen will be not be rendered when outside of the\n     * screen (only valid when screenSpace is true).\n     *\n     * @type {boolean}\n     */\n    cull: boolean;\n    _screenMatrix: Mat4;\n    _elements: Set<any>;\n    /**\n     * Set the drawOrder of each child {@link ElementComponent} so that ElementComponents which are\n     * last in the hierarchy are rendered on top. Draw Order sync is queued and will be updated by\n     * the next update loop.\n     */\n    syncDrawOrder(): void;\n    _recurseDrawOrderSync(e: any, i: any): any;\n    _processDrawOrderSync(): void;\n    _calcProjectionMatrix(): void;\n    _updateScale(): void;\n    _calcScale(resolution: any, referenceResolution: any): number;\n    _onResize(width: any, height: any): void;\n    /**\n     * The width and height of the ScreenComponent. When screenSpace is true the resolution will\n     * always be equal to {@link GraphicsDevice#width} x {@link GraphicsDevice#height}.\n     *\n     * @type {Vec2}\n     */\n    set resolution(arg: Vec2);\n    get resolution(): Vec2;\n    _bindElement(element: any): void;\n    _unbindElement(element: any): void;\n    onRemove(): void;\n    /**\n     * The resolution that the ScreenComponent is designed for. This is only taken into account\n     * when screenSpace is true and scaleMode is {@link SCALEMODE_BLEND}. If the actual resolution\n     * is different then the ScreenComponent will be scaled according to the scaleBlend value.\n     *\n     * @type {Vec2}\n     */\n    set referenceResolution(arg: Vec2);\n    get referenceResolution(): Vec2;\n    /**\n     * If true then the ScreenComponent will render its child {@link ElementComponent}s in screen\n     * space instead of world space. Enable this to create 2D user interfaces.\n     *\n     * @type {boolean}\n     */\n    set screenSpace(arg: boolean);\n    get screenSpace(): boolean;\n    /**\n     * Can either be {@link SCALEMODE_NONE} or {@link SCALEMODE_BLEND}. See the description of\n     * referenceResolution for more information.\n     *\n     * @type {string}\n     */\n    set scaleMode(arg: string);\n    get scaleMode(): string;\n    /**\n     * A value between 0 and 1 that is used when scaleMode is equal to {@link SCALEMODE_BLEND}.\n     * Scales the ScreenComponent with width as a reference (when value is 0), the height as a\n     * reference (when value is 1) or anything in between.\n     *\n     * @type {number}\n     */\n    set scaleBlend(arg: number);\n    get scaleBlend(): number;\n    /**\n     * Priority determines the order in which screens components are rendered. Priority is set into\n     * the top 8 bits of the drawOrder property in an element.\n     *\n     * @type {number}\n     * @private\n     */\n    private set priority(arg);\n    private get priority();\n}\n\ndeclare class RigidBodyComponentData {\n    enabled: boolean;\n}\n\ndeclare class ObjectPool {\n    constructor(constructorFunc: any, size: any);\n    _constructor: any;\n    _pool: any[];\n    _count: number;\n    _resize(size: any): void;\n    allocate(): any;\n    freeAll(): void;\n}\n\n\n/**\n * Object holding the result of a contact between two Entities.\n */\ndeclare class ContactPoint {\n    /**\n     * Create a new ContactPoint instance.\n     *\n     * @param {Vec3} [localPoint] - The point on the entity where the contact occurred, relative to\n     * the entity.\n     * @param {Vec3} [localPointOther] - The point on the other entity where the contact occurred,\n     * relative to the other entity.\n     * @param {Vec3} [point] - The point on the entity where the contact occurred, in world space.\n     * @param {Vec3} [pointOther] - The point on the other entity where the contact occurred, in\n     * world space.\n     * @param {Vec3} [normal] - The normal vector of the contact on the other entity, in world\n     * space.\n     * @param {number} [impulse] - The total accumulated impulse applied by the constraint solver\n     * during the last sub-step. Describes how hard two objects collide. Defaults to 0.\n     * @hideconstructor\n     */\n    constructor(localPoint?: Vec3, localPointOther?: Vec3, point?: Vec3, pointOther?: Vec3, normal?: Vec3, impulse?: number);\n    /**\n     * The point on the entity where the contact occurred, relative to the entity.\n     *\n     * @type {Vec3}\n     */\n    localPoint: Vec3;\n    /**\n     * The point on the other entity where the contact occurred, relative to the other entity.\n     *\n     * @type {Vec3}\n     */\n    localPointOther: Vec3;\n    /**\n     * The point on the entity where the contact occurred, in world space.\n     *\n     * @type {Vec3}\n     */\n    point: Vec3;\n    /**\n     * The point on the other entity where the contact occurred, in world space.\n     *\n     * @type {Vec3}\n     */\n    pointOther: Vec3;\n    /**\n     * The normal vector of the contact on the other entity, in world space.\n     *\n     * @type {Vec3}\n     */\n    normal: Vec3;\n    /**\n     * The total accumulated impulse applied by the constraint solver during the last sub-step.\n     * Describes how hard two objects collide.\n     *\n     * @type {number}\n     */\n    impulse: number;\n}\n/**\n * Object holding the result of a contact between two Entities.\n */\ndeclare class ContactResult {\n    /**\n     * Create a new ContactResult instance.\n     *\n     * @param {Entity} other - The entity that was involved in the contact with this entity.\n     * @param {ContactPoint[]} contacts - An array of ContactPoints with the other entity.\n     * @hideconstructor\n     */\n    constructor(other: Entity, contacts: ContactPoint[]);\n    /**\n     * The entity that was involved in the contact with this entity.\n     *\n     * @type {Entity}\n     */\n    other: Entity;\n    /**\n     * An array of ContactPoints with the other entity.\n     *\n     * @type {ContactPoint[]}\n     */\n    contacts: ContactPoint[];\n}\n/**\n * Object holding the result of a successful raycast hit.\n */\ndeclare class RaycastResult {\n    /**\n     * Create a new RaycastResult instance.\n     *\n     * @param {Entity} entity - The entity that was hit.\n     * @param {Vec3} point - The point at which the ray hit the entity in world space.\n     * @param {Vec3} normal - The normal vector of the surface where the ray hit in world space.\n     * @hideconstructor\n     */\n    constructor(entity: Entity, point: Vec3, normal: Vec3);\n    /**\n     * The entity that was hit.\n     *\n     * @type {Entity}\n     */\n    entity: Entity;\n    /**\n     * The point at which the ray hit the entity in world space.\n     *\n     * @type {Vec3}\n     */\n    point: Vec3;\n    /**\n     * The normal vector of the surface where the ray hit in world space.\n     *\n     * @type {Vec3}\n     */\n    normal: Vec3;\n}\n/**\n * The RigidBodyComponentSystem maintains the dynamics world for simulating rigid bodies, it also\n * controls global values for the world such as gravity. Note: The RigidBodyComponentSystem is only\n * valid if 3D Physics is enabled in your application. You can enable this in the application\n * settings for your project.\n *\n * @augments ComponentSystem\n */\ndeclare class RigidBodyComponentSystem extends ComponentSystem {\n    /**\n     * @type {number}\n     * @ignore\n     */\n    maxSubSteps: number;\n    /**\n     * @type {number}\n     * @ignore\n     */\n    fixedTimeStep: number;\n    /**\n     * The world space vector representing global gravity in the physics simulation. Defaults to\n     * [0, -9.81, 0] which is an approximation of the gravitational force on Earth.\n     *\n     * @type {Vec3}\n     */\n    gravity: Vec3;\n    /**\n     * @type {RigidBodyComponent[]}\n     * @private\n     */\n    private _dynamic;\n    /**\n     * @type {RigidBodyComponent[]}\n     * @private\n     */\n    private _kinematic;\n    /**\n     * @type {RigidBodyComponent[]}\n     * @private\n     */\n    private _triggers;\n    /**\n     * @type {RigidBodyComponent[]}\n     * @private\n     */\n    private _compounds;\n    id: string;\n    _stats: {\n        fps: number;\n        ms: number;\n        dt: number;\n        updateStart: number;\n        updateTime: number;\n        renderStart: number;\n        renderTime: number;\n        physicsStart: number;\n        physicsTime: number;\n        cullTime: number;\n        sortTime: number; /**\n         * Create a new RaycastResult instance.\n         *\n         * @param {Entity} entity - The entity that was hit.\n         * @param {Vec3} point - The point at which the ray hit the entity in world space.\n         * @param {Vec3} normal - The normal vector of the surface where the ray hit in world space.\n         * @hideconstructor\n         */\n        skinTime: number;\n        morphTime: number;\n        instancingTime: number;\n        triangles: number;\n        otherPrimitives: number;\n        shaders: number;\n        materials: number;\n        cameras: number;\n        shadowMapUpdates: number;\n        shadowMapTime: number;\n        depthMapTime: number;\n        forwardTime: number;\n        lightClustersTime: number;\n        lightClusters: number;\n        _timeToCountFrames: number;\n        _fpsAccum: number;\n    };\n    ComponentType: typeof RigidBodyComponent;\n    DataType: typeof RigidBodyComponentData;\n    contactPointPool: ObjectPool;\n    contactResultPool: ObjectPool;\n    singleContactResultPool: ObjectPool;\n    schema: string[];\n    collisions: {};\n    frameCollisions: {};\n    onLibraryLoaded(): void;\n    collisionConfiguration: any;\n    dispatcher: any;\n    overlappingPairCache: any;\n    solver: any;\n    dynamicsWorld: any;\n    initializeComponentData(component: any, data: any, properties: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    onBeforeRemove(entity: any, component: any): void;\n    onRemove(entity: any, component: any): void;\n    addBody(body: any, group: any, mask: any): void;\n    removeBody(body: any): void;\n    createBody(mass: any, shape: any, transform: any): any;\n    destroyBody(body: any): void;\n    /**\n     * Raycast the world and return the first entity the ray hits. Fire a ray into the world from\n     * start to end, if the ray hits an entity with a collision component, it returns a\n     * {@link RaycastResult}, otherwise returns null.\n     *\n     * @param {Vec3} start - The world space point where the ray starts.\n     * @param {Vec3} end - The world space point where the ray ends.\n     * @returns {RaycastResult} The result of the raycasting or null if there was no hit.\n     */\n    raycastFirst(start: Vec3, end: Vec3, ...args: any[]): RaycastResult;\n    /**\n     * Raycast the world and return all entities the ray hits. It returns an array of\n     * {@link RaycastResult}, one for each hit. If no hits are detected, the returned array will be\n     * of length 0.\n     *\n     * @param {Vec3} start - The world space point where the ray starts.\n     * @param {Vec3} end - The world space point where the ray ends.\n     * @returns {RaycastResult[]} An array of raycast hit results (0 length if there were no hits).\n     */\n    raycastAll(start: Vec3, end: Vec3): RaycastResult[];\n    /**\n     * Stores a collision between the entity and other in the contacts map and returns true if it\n     * is a new collision.\n     *\n     * @param {Entity} entity - The entity.\n     * @param {Entity} other - The entity that collides with the first entity.\n     * @returns {boolean} True if this is a new collision, false otherwise.\n     * @private\n     */\n    private _storeCollision;\n    _createContactPointFromAmmo(contactPoint: any): any;\n    _createReverseContactPointFromAmmo(contactPoint: any): any;\n    _createSingleContactResult(a: any, b: any, contactPoint: any): any;\n    _createContactResult(other: any, contacts: any): any;\n    /**\n     * Removes collisions that no longer exist from the collisions list and fires collisionend\n     * events to the related entities.\n     *\n     * @private\n     */\n    private _cleanOldCollisions;\n    /**\n     * Returns true if the entity has a contact event attached and false otherwise.\n     *\n     * @param {object} entity - Entity to test.\n     * @returns {boolean} True if the entity has a contact and false otherwise.\n     * @private\n     */\n    private _hasContactEvent;\n    /**\n     * Checks for collisions and fires collision events.\n     *\n     * @param {number} world - The pointer to the dynamics world that invoked this callback.\n     * @param {number} timeStep - The amount of simulation time processed in the last simulation tick.\n     * @private\n     */\n    private _checkForCollisions;\n    onUpdate(dt: any): void;\n}\n/**\n * Object holding the result of a contact between two rigid bodies.\n */\ndeclare class SingleContactResult {\n    /**\n     * Create a new SingleContactResult instance.\n     *\n     * @param {Entity} a - The first entity involved in the contact.\n     * @param {Entity} b - The second entity involved in the contact.\n     * @param {ContactPoint} contactPoint - The contact point between the two entities.\n     * @hideconstructor\n     */\n    constructor(a: Entity, b: Entity, contactPoint: ContactPoint, ...args: any[]);\n    /**\n     * The first entity involved in the contact.\n     *\n     * @type {Entity}\n     */\n    a: Entity;\n    /**\n     * The second entity involved in the contact.\n     *\n     * @type {Entity}\n     */\n    b: Entity;\n    /**\n     * The total accumulated impulse applied by the constraint solver during the last\n     * sub-step. Describes how hard two bodies collided.\n     *\n     * @type {number}\n     */\n    impulse: number;\n    /**\n     * The point on Entity A where the contact occurred, relative to A.\n     *\n     * @type {Vec3}\n     */\n    localPointA: Vec3;\n    /**\n     * The point on Entity B where the contact occurred, relative to B.\n     *\n     * @type {Vec3}\n     */\n    localPointB: Vec3;\n    /**\n     * The point on Entity A where the contact occurred, in world space.\n     *\n     * @type {Vec3}\n     */\n    pointA: Vec3;\n    /**\n     * The point on Entity B where the contact occurred, in world space.\n     *\n     * @type {Vec3}\n     */\n    pointB: Vec3;\n    /**\n     * The normal vector of the contact on Entity B, in world space.\n     *\n     * @type {Vec3}\n     */\n    normal: Vec3;\n}\n\n\n\n/**\n * The rigidbody component, when combined with a {@link CollisionComponent}, allows your entities\n * to be simulated using realistic physics. A rigidbody component will fall under gravity and\n * collide with other rigid bodies. Using scripts, you can apply forces and impulses to rigid\n * bodies.\n *\n * You should never need to use the RigidBodyComponent constructor. To add an RigidBodyComponent to\n * a {@link Entity}, use {@link Entity#addComponent}:\n *\n * ```javascript\n * // Create a static 1x1x1 box-shaped rigid body\n * const entity = pc.Entity();\n * entity.addComponent("rigidbody"); // With no options specified, this defaults to a \'static\' body\n * entity.addComponent("collision"); // With no options specified, this defaults to a 1x1x1 box shape\n * ```\n *\n * To create a dynamic sphere with mass of 10, do:\n *\n * ```javascript\n * const entity = pc.Entity();\n * entity.addComponent("rigidbody", {\n *     type: pc.BODYTYPE_DYNAMIC,\n *     mass: 10\n * });\n * entity.addComponent("collision", {\n *     type: "sphere"\n * });\n * ```\n *\n * Relevant \'Engine-only\' examples:\n *\n * - [Falling shapes](http://playcanvas.github.io/#physics/falling-shapes)\n * - [Vehicle physics](http://playcanvas.github.io/#physics/vehicle)\n *\n * @augments Component\n */\ndeclare class RigidBodyComponent extends Component {\n    static onLibraryLoaded(): void;\n    /**\n     * Create a new RigidBodyComponent instance.\n     *\n     * @param {RigidBodyComponentSystem} system - The ComponentSystem that created this component.\n     * @param {Entity} entity - The entity this component is attached to.\n     */\n    constructor(system: RigidBodyComponentSystem, entity: Entity);\n    _angularDamping: number;\n    _angularFactor: Vec3;\n    _angularVelocity: Vec3;\n    _body: any;\n    _friction: number;\n    _group: number;\n    _linearDamping: number;\n    _linearFactor: Vec3;\n    _linearVelocity: Vec3;\n    _mask: number;\n    _mass: number;\n    _restitution: number;\n    _rollingFriction: number;\n    _simulationEnabled: boolean;\n    _type: string;\n    /**\n     * Controls the rate at which a body loses angular velocity over time.\n     *\n     * @type {number}\n     */\n    set angularDamping(arg: number);\n    get angularDamping(): number;\n    /**\n     * Scaling factor for angular movement of the body in each axis. Only valid for rigid bodies of\n     * type {@link BODYTYPE_DYNAMIC}. Defaults to 1 in all axes (body can freely rotate).\n     *\n     * @type {Vec3}\n     */\n    set angularFactor(arg: Vec3);\n    get angularFactor(): Vec3;\n    /**\n     * Defines the rotational speed of the body around each world axis.\n     *\n     * @type {Vec3}\n     */\n    set angularVelocity(arg: Vec3);\n    get angularVelocity(): Vec3;\n    set body(arg: any);\n    get body(): any;\n    /**\n     * The friction value used when contacts occur between two bodies. A higher value indicates\n     * more friction. Should be set in the range 0 to 1. Defaults to 0.5.\n     *\n     * @type {number}\n     */\n    set friction(arg: number);\n    get friction(): number;\n    /**\n     * The collision group this body belongs to. Combine the group and the mask to prevent bodies\n     * colliding with each other. Defaults to 1.\n     *\n     * @type {number}\n     */\n    set group(arg: number);\n    get group(): number;\n    /**\n     * Controls the rate at which a body loses linear velocity over time. Defaults to 0.\n     *\n     * @type {number}\n     */\n    set linearDamping(arg: number);\n    get linearDamping(): number;\n    /**\n     * Scaling factor for linear movement of the body in each axis. Only valid for rigid bodies of\n     * type {@link BODYTYPE_DYNAMIC}. Defaults to 1 in all axes (body can freely move).\n     *\n     * @type {Vec3}\n     */\n    set linearFactor(arg: Vec3);\n    get linearFactor(): Vec3;\n    /**\n     * Defines the speed of the body in a given direction.\n     *\n     * @type {Vec3}\n     */\n    set linearVelocity(arg: Vec3);\n    get linearVelocity(): Vec3;\n    /**\n     * The collision mask sets which groups this body collides with. It is a bitfield of 16 bits,\n     * the first 8 bits are reserved for engine use. Defaults to 65535.\n     *\n     * @type {number}\n     */\n    set mask(arg: number);\n    get mask(): number;\n    /**\n     * The mass of the body. This is only relevant for {@link BODYTYPE_DYNAMIC} bodies, other types\n     * have infinite mass. Defaults to 1.\n     *\n     * @type {number}\n     */\n    set mass(arg: number);\n    get mass(): number;\n    /**\n     * Influences the amount of energy lost when two rigid bodies collide. The calculation\n     * multiplies the restitution values for both colliding bodies. A multiplied value of 0 means\n     * that all energy is lost in the collision while a value of 1 means that no energy is lost.\n     * Should be set in the range 0 to 1. Defaults to 0.\n     *\n     * @type {number}\n     */\n    set restitution(arg: number);\n    get restitution(): number;\n    /**\n     * Sets a torsional friction orthogonal to the contact point. Defaults to 0.\n     *\n     * @type {number}\n     */\n    set rollingFriction(arg: number);\n    get rollingFriction(): number;\n    /**\n     * The rigid body type determines how the body is simulated. Can be:\n     *\n     * - {@link BODYTYPE_STATIC}: infinite mass and cannot move.\n     * - {@link BODYTYPE_DYNAMIC}: simulated according to applied forces.\n     * - {@link BODYTYPE_KINEMATIC}: infinite mass and does not respond to forces (can only be\n     * moved by setting the position and rotation of component\'s {@link Entity}).\n     *\n     * Defaults to {@link BODYTYPE_STATIC}.\n     *\n     * @type {string}\n     */\n    set type(arg: string);\n    get type(): string;\n    /**\n     * If the Entity has a Collision shape attached then create a rigid body using this shape. This\n     * method destroys the existing body.\n     *\n     * @private\n     */\n    private createBody;\n    /**\n     * Returns true if the rigid body is currently actively being simulated. I.e. Not \'sleeping\'.\n     *\n     * @returns {boolean} True if the body is active.\n     */\n    isActive(): boolean;\n    /**\n     * Forcibly activate the rigid body simulation. Only affects rigid bodies of type\n     * {@link BODYTYPE_DYNAMIC}.\n     */\n    activate(): void;\n    enableSimulation(): void;\n    disableSimulation(): void;\n    /**\n     * Apply an force to the body at a point. By default, the force is applied at the origin of the\n     * body. However, the force can be applied at an offset this point by specifying a world space\n     * vector from the body\'s origin to the point of application. This function has two valid\n     * signatures. You can either specify the force (and optional relative point) via 3D-vector or\n     * numbers.\n     *\n     * @param {Vec3|number} x - A 3-dimensional vector representing the force in world-space or\n     * the x-component of the force in world-space.\n     * @param {Vec3|number} [y] - An optional 3-dimensional vector representing the relative point\n     * at which to apply the impulse in world-space or the y-component of the force in world-space.\n     * @param {number} [z] - The z-component of the force in world-space.\n     * @param {number} [px] - The x-component of a world-space offset from the body\'s position\n     * where the force is applied.\n     * @param {number} [py] - The y-component of a world-space offset from the body\'s position\n     * where the force is applied.\n     * @param {number} [pz] - The z-component of a world-space offset from the body\'s position\n     * where the force is applied.\n     * @example\n     * // Apply an approximation of gravity at the body\'s center\n     * this.entity.rigidbody.applyForce(0, -10, 0);\n     * @example\n     * // Apply an approximation of gravity at 1 unit down the world Z from the center of the body\n     * this.entity.rigidbody.applyForce(0, -10, 0, 0, 0, 1);\n     * @example\n     * // Apply a force at the body\'s center\n     * // Calculate a force vector pointing in the world space direction of the entity\n     * var force = this.entity.forward.clone().mulScalar(100);\n     *\n     * // Apply the force\n     * this.entity.rigidbody.applyForce(force);\n     * @example\n     * // Apply a force at some relative offset from the body\'s center\n     * // Calculate a force vector pointing in the world space direction of the entity\n     * var force = this.entity.forward.clone().mulScalar(100);\n     *\n     * // Calculate the world space relative offset\n     * var relativePos = new pc.Vec3();\n     * var childEntity = this.entity.findByName(\'Engine\');\n     * relativePos.sub2(childEntity.getPosition(), this.entity.getPosition());\n     *\n     * // Apply the force\n     * this.entity.rigidbody.applyForce(force, relativePos);\n     */\n    applyForce(...args: any[]): void;\n    /**\n     * Apply torque (rotational force) to the body. This function has two valid signatures. You can\n     * either specify the torque force with a 3D-vector or with 3 numbers.\n     *\n     * @param {Vec3|number} x - A 3-dimensional vector representing the torque force in world-space\n     * or the x-component of the torque force in world-space.\n     * @param {number} [y] - The y-component of the torque force in world-space.\n     * @param {number} [z] - The z-component of the torque force in world-space.\n     * @example\n     * // Apply via vector\n     * var torque = new pc.Vec3(0, 10, 0);\n     * entity.rigidbody.applyTorque(torque);\n     * @example\n     * // Apply via numbers\n     * entity.rigidbody.applyTorque(0, 10, 0);\n     */\n    applyTorque(...args: any[]): void;\n    /**\n     * Apply an impulse (instantaneous change of velocity) to the body at a point. This function\n     * has two valid signatures. You can either specify the impulse (and optional relative point)\n     * via 3D-vector or numbers.\n     *\n     * @param {Vec3|number} x - A 3-dimensional vector representing the impulse in world-space or\n     * the x-component of the impulse in world-space.\n     * @param {Vec3|number} [y] - An optional 3-dimensional vector representing the relative point\n     * at which to apply the impulse in the local-space of the entity or the y-component of the\n     * impulse to apply in world-space.\n     * @param {number} [z] - The z-component of the impulse to apply in world-space.\n     * @param {number} [px=0] - The x-component of the point at which to apply the impulse in the\n     * local-space of the entity.\n     * @param {number} [py=0] - The y-component of the point at which to apply the impulse in the\n     * local-space of the entity.\n     * @param {number} [pz=0] - The z-component of the point at which to apply the impulse in the\n     * local-space of the entity.\n     * @example\n     * // Apply an impulse along the world-space positive y-axis at the entity\'s position.\n     * var impulse = new pc.Vec3(0, 10, 0);\n     * entity.rigidbody.applyImpulse(impulse);\n     * @example\n     * // Apply an impulse along the world-space positive y-axis at 1 unit down the positive\n     * // z-axis of the entity\'s local-space.\n     * var impulse = new pc.Vec3(0, 10, 0);\n     * var relativePoint = new pc.Vec3(0, 0, 1);\n     * entity.rigidbody.applyImpulse(impulse, relativePoint);\n     * @example\n     * // Apply an impulse along the world-space positive y-axis at the entity\'s position.\n     * entity.rigidbody.applyImpulse(0, 10, 0);\n     * @example\n     * // Apply an impulse along the world-space positive y-axis at 1 unit down the positive\n     * // z-axis of the entity\'s local-space.\n     * entity.rigidbody.applyImpulse(0, 10, 0, 0, 0, 1);\n     */\n    applyImpulse(...args: any[]): void;\n    /**\n     * Apply a torque impulse (rotational force applied instantaneously) to the body. This function\n     * has two valid signatures. You can either specify the torque force with a 3D-vector or with 3\n     * numbers.\n     *\n     * @param {Vec3|number} x - A 3-dimensional vector representing the torque impulse in\n     * world-space or the x-component of the torque impulse in world-space.\n     * @param {number} [y] - The y-component of the torque impulse in world-space.\n     * @param {number} [z] - The z-component of the torque impulse in world-space.\n     * @example\n     * // Apply via vector\n     * var torque = new pc.Vec3(0, 10, 0);\n     * entity.rigidbody.applyTorqueImpulse(torque);\n     * @example\n     * // Apply via numbers\n     * entity.rigidbody.applyTorqueImpulse(0, 10, 0);\n     */\n    applyTorqueImpulse(...args: any[]): void;\n    /**\n     * Returns true if the rigid body is of type {@link BODYTYPE_STATIC}.\n     *\n     * @returns {boolean} True if static.\n     */\n    isStatic(): boolean;\n    /**\n     * Returns true if the rigid body is of type {@link BODYTYPE_STATIC} or {@link BODYTYPE_KINEMATIC}.\n     *\n     * @returns {boolean} True if static or kinematic.\n     */\n    isStaticOrKinematic(): boolean;\n    /**\n     * Returns true if the rigid body is of type {@link BODYTYPE_KINEMATIC}.\n     *\n     * @returns {boolean} True if kinematic.\n     */\n    isKinematic(): boolean;\n    /**\n     * Writes an entity transform into an Ammo.btTransform but ignoring scale.\n     *\n     * @param {object} transform - The ammo transform to write the entity transform to.\n     * @private\n     */\n    private _getEntityTransform;\n    /**\n     * Set the rigid body transform to be the same as the Entity transform. This must be called\n     * after any Entity transformation functions (e.g. {@link Entity#setPosition}) are called in\n     * order to update the rigid body to match the Entity.\n     *\n     * @private\n     */\n    private syncEntityToBody;\n    /**\n     * Sets an entity\'s transform to match that of the world transformation matrix of a dynamic\n     * rigid body\'s motion state.\n     *\n     * @private\n     */\n    private _updateDynamic;\n    /**\n     * Writes the entity\'s world transformation matrix into the motion state of a kinematic body.\n     *\n     * @private\n     */\n    private _updateKinematic;\n    /**\n     * Teleport an entity to a new world-space position, optionally setting orientation. This\n     * function should only be called for rigid bodies that are dynamic. This function has three\n     * valid signatures. The first takes a 3-dimensional vector for the position and an optional\n     * 3-dimensional vector for Euler rotation. The second takes a 3-dimensional vector for the\n     * position and an optional quaternion for rotation. The third takes 3 numbers for the position\n     * and an optional 3 numbers for Euler rotation.\n     *\n     * @param {Vec3|number} x - A 3-dimensional vector holding the new position or the new position\n     * x-coordinate.\n     * @param {Vec3|Quat|number} y - A 3-dimensional vector or quaternion holding the new rotation\n     * or the new position y-coordinate.\n     * @param {number} [z] - The new position z-coordinate.\n     * @param {number} [rx] - The new Euler x-angle value.\n     * @param {number} [ry] - The new Euler y-angle value.\n     * @param {number} [rz] - The new Euler z-angle value.\n     * @example\n     * // Teleport the entity to the origin\n     * entity.rigidbody.teleport(pc.Vec3.ZERO);\n     * @example\n     * // Teleport the entity to the origin\n     * entity.rigidbody.teleport(0, 0, 0);\n     * @example\n     * // Teleport the entity to world-space coordinate [1, 2, 3] and reset orientation\n     * var position = new pc.Vec3(1, 2, 3);\n     * entity.rigidbody.teleport(position, pc.Vec3.ZERO);\n     * @example\n     * // Teleport the entity to world-space coordinate [1, 2, 3] and reset orientation\n     * entity.rigidbody.teleport(1, 2, 3, 0, 0, 0);\n     */\n    teleport(...args: any[]): void;\n}\n\ndeclare class RenderComponentData {\n    enabled: boolean;\n    rootBone: any;\n}\n\n/**\n * Allows an Entity to render a mesh or a primitive shape like a box, capsule, sphere, cylinder,\n * cone etc.\n *\n * @augments ComponentSystem\n */\ndeclare class RenderComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof RenderComponent;\n    DataType: typeof RenderComponentData;\n    schema: (string | {\n        name: string;\n        type: string;\n    })[];\n    defaultMaterial: StandardMaterial;\n    initializeComponentData(component: any, _data: any, properties: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    onRemove(entity: any, component: any): void;\n}\n\n\n\n/** @typedef {import(\'../../../scene/materials/material.js\').Material} Material */\n/** @typedef {import(\'../../../shape/bounding-box.js\').BoundingBox} BoundingBox */\n/** @typedef {import(\'../../entity.js\').Entity} Entity */\n/** @typedef {import(\'./system.js\').RenderComponentSystem} RenderComponentSystem */\n/**\n * Enables an Entity to render a {@link Mesh} or a primitive shape. This component attaches\n * {@link MeshInstance} geometry to the Entity.\n *\n * @property {Entity} rootBone A reference to the entity to be used as the root bone for any\n * skinned meshes that are rendered by this component.\n * @augments Component\n */\ndeclare class RenderComponent extends Component {\n    /**\n     * Create a new RenderComponent.\n     *\n     * @param {RenderComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: RenderComponentSystem, entity: Entity);\n    /** @private */\n    private _type;\n    /** @private */\n    private _castShadows;\n    /** @private */\n    private _receiveShadows;\n    /** @private */\n    private _castShadowsLightmap;\n    /** @private */\n    private _lightmapped;\n    /** @private */\n    private _lightmapSizeMultiplier;\n    /** @private */\n    private _isStatic;\n    /** @private */\n    private _batchGroupId;\n    /** @private */\n    private _layers;\n    /** @private */\n    private _renderStyle;\n    /**\n     * @type {MeshInstance[]}\n     * @private\n     */\n    private _meshInstances;\n    /**\n     * @type {BoundingBox|null}\n     * @private\n     */\n    private _customAabb;\n    /**\n     * Used by lightmapper.\n     *\n     * @type {{x: number, y: number, z: number, uv: number}|null}\n     * @ignore\n     */\n    _area: {\n        x: number;\n        y: number;\n        z: number;\n        uv: number;\n    } | null;\n    /**\n     * @type {AssetReference}\n     * @private\n     */\n    private _assetReference;\n    /**\n     * @type {AssetReference[]}\n     * @private\n     */\n    private _materialReferences;\n    /**\n     * Material used to render meshes other than asset type. It gets priority when set to\n     * something else than defaultMaterial, otherwise materialASsets[0] is used.\n     *\n     * @type {Material}\n     * @private\n     */\n    private _material;\n    /**\n     * @type {EntityReference}\n     * @private\n     */\n    private _rootBone;\n    /**\n     * Set rendering of all {@link MeshInstance}s to the specified render style. Can be:\n     *\n     * - {@link RENDERSTYLE_SOLID}\n     * - {@link RENDERSTYLE_WIREFRAME}\n     * - {@link RENDERSTYLE_POINTS}\n     *\n     * Defaults to {@link RENDERSTYLE_SOLID}.\n     *\n     * @type {number}\n     */\n    set renderStyle(arg: number);\n    get renderStyle(): number;\n    /**\n     * If set, the object space bounding box is used as a bounding box for visibility culling of\n     * attached mesh instances. This is an optimization, allowing oversized bounding box to be\n     * specified for skinned characters in order to avoid per frame bounding box computations based\n     * on bone positions.\n     *\n     * @type {BoundingBox}\n     */\n    set customAabb(arg: BoundingBox);\n    get customAabb(): BoundingBox;\n    /**\n     * The type of the render. Can be one of the following:\n     *\n     * - "asset": The component will render a render asset\n     * - "box": The component will render a box (1 unit in each dimension)\n     * - "capsule": The component will render a capsule (radius 0.5, height 2)\n     * - "cone": The component will render a cone (radius 0.5, height 1)\n     * - "cylinder": The component will render a cylinder (radius 0.5, height 1)\n     * - "plane": The component will render a plane (1 unit in each dimension)\n     * - "sphere": The component will render a sphere (radius 0.5)\n     *\n     * @type {string}\n     */\n    set type(arg: string);\n    get type(): string;\n    /**\n     * An array of meshInstances contained in the component. If meshes are not set or loaded for\n     * component it will return null.\n     *\n     * @type {MeshInstance[]}\n     */\n    set meshInstances(arg: MeshInstance[]);\n    get meshInstances(): MeshInstance[];\n    /**\n     * If true, the meshes will be lightmapped after using lightmapper.bake().\n     *\n     * @type {boolean}\n     */\n    set lightmapped(arg: boolean);\n    get lightmapped(): boolean;\n    /**\n     * If true, attached meshes will cast shadows for lights that have shadow casting enabled.\n     *\n     * @type {boolean}\n     */\n    set castShadows(arg: boolean);\n    get castShadows(): boolean;\n    /**\n     * If true, shadows will be cast on attached meshes.\n     *\n     * @type {boolean}\n     */\n    set receiveShadows(arg: boolean);\n    get receiveShadows(): boolean;\n    /**\n     * If true, the meshes will cast shadows when rendering lightmaps.\n     *\n     * @type {boolean}\n     */\n    set castShadowsLightmap(arg: boolean);\n    get castShadowsLightmap(): boolean;\n    /**\n     * Lightmap resolution multiplier.\n     *\n     * @type {number}\n     */\n    set lightmapSizeMultiplier(arg: number);\n    get lightmapSizeMultiplier(): number;\n    /**\n     * Mark meshes as non-movable (optimization).\n     *\n     * @type {boolean}\n     */\n    set isStatic(arg: boolean);\n    get isStatic(): boolean;\n    /**\n     * An array of layer IDs ({@link Layer#id}) to which the meshes should belong. Don\'t push, pop,\n     * splice or modify this array, if you want to change it - set a new one instead.\n     *\n     * @type {number[]}\n     */\n    set layers(arg: number[]);\n    get layers(): number[];\n    /**\n     * Assign meshes to a specific batch group (see {@link BatchGroup}). Default is -1 (no group).\n     *\n     * @type {number}\n     */\n    set batchGroupId(arg: number);\n    get batchGroupId(): number;\n    /**\n     * The material {@link Material} that will be used to render the meshes (not used on renders of\n     * type \'asset\').\n     *\n     * @type {Material}\n     */\n    set material(arg: Material);\n    get material(): Material;\n    /**\n     * The material assets that will be used to render the meshes. Each material corresponds to the\n     * respective mesh instance.\n     *\n     * @type {Asset[]|number[]}\n     */\n    set materialAssets(arg: any[]);\n    get materialAssets(): any[];\n    /**\n     * The render asset for the render component (only applies to type \'asset\') - can also be an\n     * asset id.\n     *\n     * @type {Asset|number}\n     */\n    set asset(arg: any);\n    get asset(): any;\n    /**\n     * Assign asset id to the component, without updating the component with the new asset.\n     * This can be used to assign the asset id to already fully created component.\n     *\n     * @param {Asset|number} asset - The render asset or asset id to assign.\n     * @ignore\n     */\n    assignAsset(asset: Asset | number): void;\n    /**\n     * @param {Entity} entity - The entity set as the root bone.\n     * @private\n     */\n    private _onSetRootBone;\n    /** @private */\n    private _onRootBoneChanged;\n    /** @private */\n    private destroyMeshInstances;\n    /** @private */\n    private addToLayers;\n    removeFromLayers(): void;\n    /** @private */\n    private onRemoveChild;\n    /** @private */\n    private onInsertChild;\n    onRemove(): void;\n    materialAsset: any;\n    onLayersChanged(oldComp: any, newComp: any): void;\n    onLayerAdded(layer: any): void;\n    onLayerRemoved(layer: any): void;\n    /**\n     * Stop rendering {@link MeshInstance}s without removing them from the scene hierarchy. This\n     * method sets the {@link MeshInstance#visible} property of every MeshInstance to false. Note,\n     * this does not remove the mesh instances from the scene hierarchy or draw call list. So the\n     * render component still incurs some CPU overhead.\n     */\n    hide(): void;\n    /**\n     * Enable rendering of the component\'s {@link MeshInstance}s if hidden using\n     * {@link RenderComponent#hide}. This method sets the {@link MeshInstance#visible} property on\n     * all mesh instances to true.\n     */\n    show(): void;\n    _onRenderAssetAdded(): void;\n    _onRenderAssetLoad(): void;\n    _onSetMeshes(meshes: any): void;\n    _clearSkinInstances(): void;\n    _cloneSkinInstances(): void;\n    _cloneMeshes(meshes: any): void;\n    _onRenderAssetUnload(): void;\n    _onRenderAssetRemove(): void;\n    _onMaterialAdded(index: any, component: any, asset: any): void;\n    _updateMainMaterial(index: any, material: any): void;\n    _onMaterialLoad(index: any, component: any, asset: any): void;\n    _onMaterialRemove(index: any, component: any, asset: any): void;\n    _onMaterialUnload(index: any, component: any, asset: any): void;\n    resolveDuplicatedEntityReferenceProperties(oldRender: any, duplicatedIdsMap: any): void;\n    rootBone: any;\n}\n\ndeclare class ParticleSystemComponentData {\n    numParticles: number;\n    rate: number;\n    rate2: any;\n    startAngle: number;\n    startAngle2: any;\n    lifetime: number;\n    emitterExtents: Vec3;\n    emitterExtentsInner: Vec3;\n    emitterRadius: number;\n    emitterRadiusInner: number;\n    emitterShape: number;\n    initialVelocity: number;\n    wrapBounds: Vec3;\n    localSpace: boolean;\n    screenSpace: boolean;\n    colorMap: any;\n    colorMapAsset: any;\n    normalMap: any;\n    normalMapAsset: any;\n    loop: boolean;\n    preWarm: boolean;\n    sort: number;\n    mode: number;\n    scene: any;\n    lighting: boolean;\n    halfLambert: boolean;\n    intensity: number;\n    stretch: number;\n    alignToMotion: boolean;\n    depthSoftening: number;\n    meshAsset: any;\n    mesh: any;\n    depthWrite: boolean;\n    noFog: boolean;\n    orientation: number;\n    particleNormal: Vec3;\n    animTilesX: number;\n    animTilesY: number;\n    animStartFrame: number;\n    animNumFrames: number;\n    animNumAnimations: number;\n    animIndex: number;\n    randomizeAnimIndex: boolean;\n    animSpeed: number;\n    animLoop: boolean;\n    scaleGraph: any;\n    scaleGraph2: any;\n    colorGraph: any;\n    colorGraph2: any;\n    alphaGraph: any;\n    alphaGraph2: any;\n    localVelocityGraph: any;\n    localVelocityGraph2: any;\n    velocityGraph: any;\n    velocityGraph2: any;\n    rotationSpeedGraph: any;\n    rotationSpeedGraph2: any;\n    radialSpeedGraph: any;\n    radialSpeedGraph2: any;\n    blendType: number;\n    enabled: boolean;\n    paused: boolean;\n    autoPlay: boolean;\n    layers: number[];\n}\n\n/**\n * Allows an Entity to render a particle system.\n *\n * @augments ComponentSystem\n */\ndeclare class ParticleSystemComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof ParticleSystemComponent;\n    DataType: typeof ParticleSystemComponentData;\n    schema: string[];\n    propertyTypes: {\n        emitterExtents: string;\n        emitterExtentsInner: string;\n        particleNormal: string;\n        wrapBounds: string;\n        localVelocityGraph: string;\n        localVelocityGraph2: string;\n        velocityGraph: string;\n        velocityGraph2: string;\n        colorGraph: string;\n        colorGraph2: string;\n        alphaGraph: string;\n        alphaGraph2: string;\n        rotationSpeedGraph: string;\n        rotationSpeedGraph2: string;\n        radialSpeedGraph: string;\n        radialSpeedGraph2: string;\n        scaleGraph: string;\n        scaleGraph2: string;\n    };\n    initializeComponentData(component: any, _data: any, properties: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    onUpdate(dt: any): void;\n    onBeforeRemove(entity: any, component: any): void;\n}\n\n/**\n * A curve is a collection of keys (time/value pairs). The shape of the curve is defined by its\n * type that specifies an interpolation scheme for the keys.\n */\ndeclare class Curve {\n    /**\n     * Creates a new Curve instance.\n     *\n     * @param {number[]} [data] - An array of keys (pairs of numbers with the time first and value\n     * second).\n     * @example\n     * var curve = new pc.Curve([\n     *     0, 0,        // At 0 time, value of 0\n     *     0.33, 2,     // At 0.33 time, value of 2\n     *     0.66, 2.6,   // At 0.66 time, value of 2.6\n     *     1, 3         // At 1 time, value of 3\n     * ]);\n     */\n    constructor(data?: number[]);\n    keys: number[][];\n    /**\n     * The curve interpolation scheme. Can be:\n     *\n     * - {@link CURVE_LINEAR}\n     * - {@link CURVE_SMOOTHSTEP}\n     * - {@link CURVE_SPLINE}\n     * - {@link CURVE_STEP}\n     *\n     * Defaults to {@link CURVE_SMOOTHSTEP}.\n     *\n     * @type {number}\n     */\n    type: number;\n    /**\n     * Controls how {@link CURVE_SPLINE} tangents are calculated. Valid range is between 0 and\n     * 1 where 0 results in a non-smooth curve (equivalent to linear interpolation) and 1\n     * results in a very smooth curve. Use 0.5 for a Catmull-rom spline.\n     *\n     * @type {number}\n     */\n    tension: number;\n    /**\n     * @type {CurveEvaluator}\n     * @private\n     */\n    private _eval;\n    /**\n     * Get the number of keys in the curve.\n     *\n     * @type {number}\n     */\n    get length(): number;\n    /**\n     * Add a new key to the curve.\n     *\n     * @param {number} time - Time to add new key.\n     * @param {number} value - Value of new key.\n     * @returns {number[]} [time, value] pair.\n     */\n    add(time: number, value: number): number[];\n    /**\n     * Return a specific key.\n     *\n     * @param {number} index - The index of the key to return.\n     * @returns {number[]} The key at the specified index.\n     */\n    get(index: number): number[];\n    /**\n     * Sort keys by time.\n     */\n    sort(): void;\n    /**\n     * Returns the interpolated value of the curve at specified time.\n     *\n     * @param {number} time - The time at which to calculate the value.\n     * @returns {number} The interpolated value.\n     */\n    value(time: number): number;\n    closest(time: any): number[];\n    /**\n     * Returns a clone of the specified curve object.\n     *\n     * @returns {Curve} A clone of the specified curve.\n     */\n    clone(): Curve;\n    /**\n     * Sample the curve at regular intervals over the range [0..1].\n     *\n     * @param {number} precision - The number of samples to return.\n     * @returns {Float32Array} The set of quantized values.\n     * @ignore\n     */\n    quantize(precision: number): Float32Array;\n    /**\n     * Sample the curve at regular intervals over the range [0..1] and clamp the resulting samples\n     * to [min..max].\n     *\n     * @param {number} precision - The number of samples to return.\n     * @param {number} min - The minimum output value.\n     * @param {number} max - The maximum output value.\n     * @returns {Float32Array} The set of quantized values.\n     * @ignore\n     */\n    quantizeClamped(precision: number, min: number, max: number): Float32Array;\n}\n\n/**\n * A curve set is a collection of curves.\n */\ndeclare class CurveSet {\n    /**\n     * Creates a new CurveSet instance.\n     *\n     * @param {Array<number[]>} curveKeys - An array of arrays of keys (pairs of numbers with the\n     * time first and value second).\n     * @example\n     * var curveSet = new pc.CurveSet([\n     *     [\n     *         0, 0,        // At 0 time, value of 0\n     *         0.33, 2,     // At 0.33 time, value of 2\n     *         0.66, 2.6,   // At 0.66 time, value of 2.6\n     *         1, 3         // At 1 time, value of 3\n     *     ],\n     *     [\n     *         0, 34,\n     *         0.33, 35,\n     *         0.66, 36,\n     *         1, 37\n     *     ]\n     * ]);\n     */\n    constructor(...args: any[]);\n    curves: Curve[];\n    /**\n     * @type {number}\n     * @private\n     */\n    private _type;\n    /**\n     * The number of curves in the curve set.\n     *\n     * @type {number}\n     */\n    get length(): number;\n    /**\n     * The interpolation scheme applied to all curves in the curve set. Can be:\n     *\n     * - {@link CURVE_LINEAR}\n     * - {@link CURVE_SMOOTHSTEP}\n     * - {@link CURVE_SPLINE}\n     * - {@link CURVE_STEP}\n     *\n     * Defaults to {@link CURVE_SMOOTHSTEP}.\n     *\n     * @type {number}\n     */\n    set type(arg: number);\n    get type(): number;\n    /**\n     * Return a specific curve in the curve set.\n     *\n     * @param {number} index - The index of the curve to return.\n     * @returns {Curve} The curve at the specified index.\n     */\n    get(index: number): Curve;\n    /**\n     * Returns the interpolated value of all curves in the curve set at the specified time.\n     *\n     * @param {number} time - The time at which to calculate the value.\n     * @param {number[]} [result] - The interpolated curve values at the specified time. If this\n     * parameter is not supplied, the function allocates a new array internally to return the\n     * result.\n     * @returns {number[]} The interpolated curve values at the specified time.\n     */\n    value(time: number, result?: number[]): number[];\n    /**\n     * Returns a clone of the specified curve set object.\n     *\n     * @returns {CurveSet} A clone of the specified curve set.\n     */\n    clone(): CurveSet;\n    /**\n     * Sample the curveset at regular intervals over the range [0..1].\n     *\n     * @param {number} precision - The number of samples to return.\n     * @returns {Float32Array} The set of quantized values.\n     * @ignore\n     */\n    quantize(precision: number): Float32Array;\n    /**\n     * Sample the curveset at regular intervals over the range [0..1] and clamp the result to min\n     * and max.\n     *\n     * @param {number} precision - The number of samples to return.\n     * @param {number} min - The minimum output value.\n     * @param {number} max - The maximum output value.\n     * @returns {Float32Array} The set of quantized values.\n     * @ignore\n     */\n    quantizeClamped(precision: number, min: number, max: number): Float32Array;\n}\n\ndeclare class ParticleGPUUpdater {\n    constructor(emitter: any, gd: any);\n    _emitter: any;\n    frameRandomUniform: Float32Array;\n    emitterPosUniform: Float32Array;\n    emitterScaleUniform: Float32Array;\n    worldBoundsMulUniform: Float32Array;\n    worldBoundsAddUniform: Float32Array;\n    inBoundsSizeUniform: Float32Array;\n    inBoundsCenterUniform: Float32Array;\n    constantParticleTexIN: any;\n    constantParticleTexOUT: any;\n    constantEmitterPos: any;\n    constantEmitterScale: any;\n    constantSpawnBounds: any;\n    constantSpawnPosInnerRatio: any;\n    constantSpawnBoundsSphere: any;\n    constantSpawnBoundsSphereInnerRatio: any;\n    constantInitialVelocity: any;\n    constantFrameRandom: any;\n    constantDelta: any;\n    constantRate: any;\n    constantRateDiv: any;\n    constantLifetime: any;\n    constantGraphSampleSize: any;\n    constantGraphNumSamples: any;\n    constantInternalTex0: any;\n    constantInternalTex1: any;\n    constantInternalTex2: any;\n    constantInternalTex3: any;\n    constantEmitterMatrix: any;\n    constantEmitterMatrixInv: any;\n    constantNumParticles: any;\n    constantNumParticlesPot: any;\n    constantLocalVelocityDivMult: any;\n    constantVelocityDivMult: any;\n    constantRotSpeedDivMult: any;\n    constantSeed: any;\n    constantStartAngle: any;\n    constantStartAngle2: any;\n    constantOutBoundsMul: any;\n    constantOutBoundsAdd: any;\n    constantInBoundsSize: any;\n    constantInBoundsCenter: any;\n    constantMaxVel: any;\n    constantFaceTangent: any;\n    constantFaceBinorm: any;\n    _setInputBounds(): void;\n    randomize(): void;\n    update(device: any, spawnMatrix: any, extentsInnerRatioUniform: any, delta: any, isOnStop: any): void;\n}\n\ndeclare class ParticleCPUUpdater {\n    constructor(emitter: any);\n    _emitter: any;\n    calcSpawnPosition(particleTex: any, spawnMatrix: any, extentsInnerRatioUniform: any, emitterPos: any, i: any): void;\n    update(data: any, vbToSort: any, particleTex: any, spawnMatrix: any, extentsInnerRatioUniform: any, emitterPos: any, delta: any, isOnStop: any): void;\n}\n\ndeclare class ParticleEmitter {\n    constructor(graphicsDevice: any, options: any);\n    graphicsDevice: any;\n    precision: number;\n    _addTimeTime: number;\n    numParticles: any;\n    _gpuUpdater: ParticleGPUUpdater;\n    _cpuUpdater: ParticleCPUUpdater;\n    constantLightCube: any;\n    emitterPosUniform: Float32Array;\n    wrapBoundsUniform: Float32Array;\n    emitterScaleUniform: Float32Array;\n    lightCube: Float32Array;\n    lightCubeDir: any[];\n    animTilesParams: Float32Array;\n    animParams: Float32Array;\n    animIndexParams: Float32Array;\n    internalTex0: Texture;\n    internalTex1: Texture;\n    internalTex2: Texture;\n    colorParam: Texture;\n    vbToSort: any[];\n    vbOld: Float32Array;\n    particleDistance: Float32Array;\n    camera: any;\n    swapTex: boolean;\n    useMesh: boolean;\n    useCpu: boolean;\n    pack8: boolean;\n    localBounds: BoundingBox;\n    worldBoundsNoTrail: BoundingBox;\n    worldBoundsTrail: BoundingBox[];\n    worldBounds: BoundingBox;\n    worldBoundsSize: Vec3;\n    prevWorldBoundsSize: Vec3;\n    prevWorldBoundsCenter: Vec3;\n    prevEmitterExtents: any;\n    prevEmitterRadius: any;\n    worldBoundsMul: Vec3;\n    worldBoundsAdd: Vec3;\n    timeToSwitchBounds: number;\n    shaderParticleUpdateRespawn: Shader;\n    shaderParticleUpdateNoRespawn: Shader;\n    shaderParticleUpdateOnStop: Shader;\n    numParticleVerts: number;\n    numParticleIndices: number;\n    material: Material;\n    meshInstance: MeshInstance;\n    drawOrder: number;\n    seed: number;\n    fixedTimeStep: number;\n    maxSubSteps: number;\n    simTime: number;\n    simTimeTotal: number;\n    beenReset: boolean;\n    _layer: any;\n    get defaultParamTexture(): any;\n    onChangeCamera(): void;\n    calculateBoundsMad(): void;\n    calculateWorldBounds(): void;\n    resetWorldBounds(): void;\n    calculateLocalBounds(): void;\n    rebuild(): void;\n    colorMap: any;\n    spawnBounds: any;\n    numParticlesPot: number;\n    particleTex: Float32Array;\n    particleTexStart: any;\n    particleTexIN: Texture;\n    particleTexOUT: Texture;\n    rtParticleTexIN: RenderTarget;\n    rtParticleTexOUT: RenderTarget;\n    _isAnimated(): any;\n    rebuildGraphs(): void;\n    qLocalVelocity: any;\n    qVelocity: any;\n    qColor: any;\n    qRotSpeed: any;\n    qScale: any;\n    qAlpha: any;\n    qRadialSpeed: any;\n    qLocalVelocity2: any;\n    qVelocity2: any;\n    qColor2: any;\n    qRotSpeed2: any;\n    qScale2: any;\n    qAlpha2: any;\n    qRadialSpeed2: any;\n    localVelocityUMax: Float32Array;\n    velocityUMax: Float32Array;\n    colorUMax: Float32Array;\n    rotSpeedUMax: number[];\n    scaleUMax: number[];\n    alphaUMax: number[];\n    radialSpeedUMax: number[];\n    qLocalVelocityDiv: Float32Array;\n    qVelocityDiv: Float32Array;\n    qColorDiv: Float32Array;\n    qRotSpeedDiv: Float32Array;\n    qScaleDiv: Float32Array;\n    qAlphaDiv: Float32Array;\n    qRadialSpeedDiv: Float32Array;\n    maxVel: number;\n    internalTex3: Texture;\n    _initializeTextures(): void;\n    regenShader(): void;\n    normalOption: number;\n    resetMaterial(): void;\n    _compParticleFaceParams(): void;\n    _allocate(numParticles: any): void;\n    vertexBuffer: VertexBuffer;\n    indexBuffer: IndexBuffer;\n    vbCPU: Float32Array;\n    reset(): void;\n    loop: any;\n    prewarm(time: any): void;\n    resetTime(): void;\n    endTime: number;\n    finishFrame(): void;\n    addTime(delta: any, isOnStop: any): void;\n    _destroyResources(): void;\n    destroy(): void;\n}\n\n\n\n\n\n\n/**\n * Used to simulate particles and produce renderable particle mesh on either CPU or GPU. GPU\n * simulation is generally much faster than its CPU counterpart, because it avoids slow CPU-GPU\n * synchronization and takes advantage of many GPU cores. However, it requires client to support\n * reasonable uniform count, reading from multiple textures in vertex shader and OES_texture_float\n * extension, including rendering into float textures. Most mobile devices fail to satisfy these\n * requirements, so it\'s not recommended to simulate thousands of particles on them. GPU version\n * also can\'t sort particles, so enabling sorting forces CPU mode too. Particle rotation is\n * specified by a single angle parameter: default billboard particles rotate around camera facing\n * axis, while mesh particles rotate around 2 different view-independent axes. Most of the\n * simulation parameters are specified with {@link Curve} or {@link CurveSet}. Curves are\n * interpolated based on each particle\'s lifetime, therefore parameters are able to change over\n * time. Most of the curve parameters can also be specified by 2 minimum/maximum curves, this way\n * each particle will pick a random value in-between.\n *\n * @property {boolean} autoPlay Controls whether the particle system plays automatically on\n * creation. If set to false, it is necessary to call {@link ParticleSystemComponent#play} for the\n * particle system to play. Defaults to true.\n * @property {boolean} loop Enables or disables respawning of particles.\n * @property {boolean} preWarm If enabled, the particle system will be initialized as though it had\n * already completed a full cycle. This only works with looping particle systems.\n * @property {boolean} lighting If enabled, particles will be lit by ambient and directional\n * lights.\n * @property {boolean} halfLambert Enabling Half Lambert lighting avoids particles looking too flat\n * in shadowed areas. It is a completely non-physical lighting model but can give more pleasing\n * visual results.\n * @property {boolean} alignToMotion Orient particles in their direction of motion.\n * @property {boolean} depthWrite If enabled, the particles will write to the depth buffer. If\n * disabled, the depth buffer is left unchanged and particles will be guaranteed to overwrite one\n * another in the order in which they are rendered.\n * @property {boolean} noFog Disable fogging.\n * @property {boolean} localSpace Binds particles to emitter transformation rather then world\n * space.\n * @property {boolean} screenSpace Renders particles in 2D screen space. This needs to be set when\n * particle system is part of hierarchy with {@link ScreenComponent} as its ancestor, and allows\n * particle system to integrate with the rendering of {@link ElementComponent}s. Note that an\n * entity with ParticleSystem component cannot be parented directly to {@link ScreenComponent}, but\n * has to be a child of a {@link ElementComponent}, for example {@link LayoutGroupComponent}.\n * @property {number} numParticles Maximum number of simulated particles.\n * @property {number} rate Minimal interval in seconds between particle births.\n * @property {number} rate2 Maximal interval in seconds between particle births.\n * @property {number} startAngle Minimal initial Euler angle of a particle.\n * @property {number} startAngle2 Maximal initial Euler angle of a particle.\n * @property {number} lifetime The length of time in seconds between a particle\'s birth and its\n * death.\n * @property {number} stretch A value in world units that controls the amount by which particles\n * are stretched based on their velocity. Particles are stretched from their center towards their\n * previous position.\n * @property {number} intensity Color multiplier.\n * @property {boolean} animLoop Controls whether the sprite sheet animation plays once or loops\n * continuously.\n * @property {number} animTilesX Number of horizontal tiles in the sprite sheet.\n * @property {number} animTilesY Number of vertical tiles in the sprite sheet.\n * @property {number} animNumAnimations Number of sprite sheet animations contained within the\n * current sprite sheet. The number of animations multiplied by number of frames should be a value\n * less than animTilesX multiplied by animTilesY.\n * @property {number} animNumFrames Number of sprite sheet frames in the current sprite sheet\n * animation. The number of animations multiplied by number of frames should be a value less than\n * animTilesX multiplied by animTilesY.\n * @property {number} animStartFrame The sprite sheet frame that the animation should begin playing\n * from. Indexed from the start of the current animation.\n * @property {number} animIndex When animNumAnimations is greater than 1, the sprite sheet\n * animation index determines which animation the particle system should play.\n * @property {number} randomizeAnimIndex Each particle emitted by the system will play a random\n * animation from the sprite sheet, up to animNumAnimations.\n * @property {number} animSpeed Sprite sheet animation speed. 1 = particle lifetime, 2 = twice\n * during lifetime etc...\n * @property {number} depthSoftening Controls fading of particles near their intersections with\n * scene geometry. This effect, when it\'s non-zero, requires scene depth map to be rendered.\n * Multiple depth-dependent effects can share the same map, but if you only use it for particles,\n * bear in mind that it can double engine draw calls.\n * @property {number} initialVelocity Defines magnitude of the initial emitter velocity. Direction\n * is given by emitter shape.\n * @property {Vec3} emitterExtents (Only for EMITTERSHAPE_BOX) The extents of a local space\n * bounding box within which particles are spawned at random positions.\n * @property {Vec3} emitterExtentsInner (Only for EMITTERSHAPE_BOX) The exception of extents of a\n * local space bounding box within which particles are not spawned. Aligned to the center of\n * EmitterExtents.\n * @property {number} emitterRadius (Only for EMITTERSHAPE_SPHERE) The radius within which\n * particles are spawned at random positions.\n * @property {number} emitterRadiusInner (Only for EMITTERSHAPE_SPHERE) The inner radius within\n * which particles are not spawned.\n * @property {Vec3} wrapBounds The half extents of a world space box volume centered on the owner\n * entity\'s position. If a particle crosses the boundary of one side of the volume, it teleports to\n * the opposite side.\n * @property {Asset} colorMapAsset The {@link Asset} used to set the colorMap.\n * @property {Asset} normalMapAsset The {@link Asset} used to set the normalMap.\n * @property {Asset} meshAsset The {@link Asset} used to set the mesh.\n * @property {Asset} renderAsset The Render {@link Asset} used to set the mesh.\n * @property {Texture} colorMap The color map texture to apply to all particles in the system. If\n * no texture is assigned, a default spot texture is used.\n * @property {Texture} normalMap The normal map texture to apply to all particles in the system. If\n * no texture is assigned, an approximate spherical normal is calculated for each vertex.\n * @property {number} emitterShape Shape of the emitter. Defines the bounds inside which particles\n * are spawned. Also affects the direction of initial velocity.\n *\n * - {@link EMITTERSHAPE_BOX}: Box shape parameterized by emitterExtents. Initial velocity is\n * directed towards local Z axis.\n * - {@link EMITTERSHAPE_SPHERE}: Sphere shape parameterized by emitterRadius. Initial velocity is\n * directed outwards from the center.\n *\n * @property {number} sort Sorting mode. Forces CPU simulation, so be careful.\n *\n * - {@link PARTICLESORT_NONE}: No sorting, particles are drawn in arbitrary order. Can be\n * simulated on GPU.\n * - {@link PARTICLESORT_DISTANCE}: Sorting based on distance to the camera. CPU only.\n * - {@link PARTICLESORT_NEWER_FIRST}: Newer particles are drawn first. CPU only.\n * - {@link PARTICLESORT_OLDER_FIRST}: Older particles are drawn first. CPU only.\n *\n * @property {Mesh} mesh Triangular mesh to be used as a particle. Only first vertex/index buffer\n * is used. Vertex buffer must contain local position at first 3 floats of each vertex.\n * @property {number} blend Controls how particles are blended when being written to the currently\n * active render target. Can be:\n *\n * - {@link BLEND_SUBTRACTIVE}: Subtract the color of the source fragment from the destination\n * fragment and write the result to the frame buffer.\n * - {@link BLEND_ADDITIVE}: Add the color of the source fragment to the destination fragment and\n * write the result to the frame buffer.\n * - {@link BLEND_NORMAL}: Enable simple translucency for materials such as glass. This is\n * equivalent to enabling a source blend mode of {@link BLENDMODE_SRC_ALPHA} and a destination\n * blend mode of {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.\n * - {@link BLEND_NONE}: Disable blending.\n * - {@link BLEND_PREMULTIPLIED}: Similar to {@link BLEND_NORMAL} expect the source fragment is\n * assumed to have already been multiplied by the source alpha value.\n * - {@link BLEND_MULTIPLICATIVE}: Multiply the color of the source fragment by the color of the\n * destination fragment and write the result to the frame buffer.\n * - {@link BLEND_ADDITIVEALPHA}: Same as {@link BLEND_ADDITIVE} except the source RGB is\n * multiplied by the source alpha.\n *\n * @property {number} orientation Sorting mode. Forces CPU simulation, so be careful.\n *\n * - {@link PARTICLEORIENTATION_SCREEN}: Particles are facing camera.\n * - {@link PARTICLEORIENTATION_WORLD}: User defines world space normal (particleNormal) to set\n * planes orientation.\n * - {@link PARTICLEORIENTATION_EMITTER}: Similar to previous, but the normal is affected by\n * emitter (entity) transformation.\n *\n * @property {Vec3} particleNormal (Only for PARTICLEORIENTATION_WORLD and\n * PARTICLEORIENTATION_EMITTER) The exception of extents of a local space bounding box within which\n * particles are not spawned. Aligned to the center of EmitterExtents.\n * @property {CurveSet} localVelocityGraph Velocity relative to emitter over lifetime.\n * @property {CurveSet} localVelocityGraph2 If not null, particles pick random values between\n * localVelocityGraph and localVelocityGraph2.\n * @property {CurveSet} velocityGraph World-space velocity over lifetime.\n * @property {CurveSet} velocityGraph2 If not null, particles pick random values between\n * velocityGraph and velocityGraph2.\n * @property {CurveSet} colorGraph Color over lifetime.\n * @property {Curve} rotationSpeedGraph Rotation speed over lifetime.\n * @property {Curve} rotationSpeedGraph2 If not null, particles pick random values between\n * rotationSpeedGraph and rotationSpeedGraph2.\n * @property {Curve} radialSpeedGraph Radial speed over lifetime, velocity vector points from\n * emitter origin to particle pos.\n * @property {Curve} radialSpeedGraph2 If not null, particles pick random values between\n * radialSpeedGraph and radialSpeedGraph2.\n * @property {Curve} scaleGraph Scale over lifetime.\n * @property {Curve} scaleGraph2 If not null, particles pick random values between scaleGraph and\n * scaleGraph2.\n * @property {Curve} alphaGraph Alpha over lifetime.\n * @property {Curve} alphaGraph2 If not null, particles pick random values between alphaGraph and\n * alphaGraph2.\n * @property {number[]} layers An array of layer IDs ({@link Layer#id}) to which this particle\n * system should belong. Don\'t push/pop/splice or modify this array, if you want to change it - set\n * a new one instead.\n * @augments Component\n */\ndeclare class ParticleSystemComponent extends Component {\n    /**\n     * Create a new ParticleSystemComponent.\n     *\n     * @param {ParticleSystemComponentSystem} system - The ComponentSystem that created this\n     * Component.\n     * @param {Entity} entity - The Entity this Component is attached to.\n     */\n    constructor(system: ParticleSystemComponentSystem, entity: Entity);\n\n    set alignToMotion(arg: boolean);\n    get alignToMotion(): boolean;\n\n    set alphaGraph(arg: Curve);\n    get alphaGraph(): Curve;\n\n    set alphaGraph2(arg: Curve);\n    get alphaGraph2(): Curve;\n\n    set animIndex(arg: number);\n    get animIndex(): number;\n\n    set animLoop(arg: boolean);\n    get animLoop(): boolean;\n\n    set animNumAnimations(arg: number);\n    get animNumAnimations(): number;\n\n    set animNumFrames(arg: number);\n    get animNumFrames(): number;\n\n    set animSpeed(arg: number);\n    get animSpeed(): number;\n\n    set animStartFrame(arg: number);\n    get animStartFrame(): number;\n\n    set animTilesX(arg: number);\n    get animTilesX(): number;\n\n    set animTilesY(arg: number);\n    get animTilesY(): number;\n\n    set autoPlay(arg: boolean);\n    get autoPlay(): boolean;\n\n    set blend(arg: number);\n    get blend(): number;\n\n    set colorGraph(arg: CurveSet);\n    get colorGraph(): CurveSet;\n\n    set colorMapAsset(arg: Asset);\n    get colorMapAsset(): Asset;\n\n    set depthSoftening(arg: number);\n    get depthSoftening(): number;\n\n    set depthWrite(arg: boolean);\n    get depthWrite(): boolean;\n\n    set emitterExtents(arg: Vec3);\n    get emitterExtents(): Vec3;\n\n    set emitterExtentsInner(arg: Vec3);\n    get emitterExtentsInner(): Vec3;\n\n    set emitterRadius(arg: number);\n    get emitterRadius(): number;\n\n    set emitterRadiusInner(arg: number);\n    get emitterRadiusInner(): number;\n\n    set emitterShape(arg: number);\n    get emitterShape(): number;\n\n    set halfLambert(arg: boolean);\n    get halfLambert(): boolean;\n\n    set initialVelocity(arg: number);\n    get initialVelocity(): number;\n\n    set intensity(arg: number);\n    get intensity(): number;\n\n    set layers(arg: number[]);\n    get layers(): number[];\n\n    set lifetime(arg: number);\n    get lifetime(): number;\n\n    set lighting(arg: boolean);\n    get lighting(): boolean;\n\n    set localSpace(arg: boolean);\n    get localSpace(): boolean;\n\n    set localVelocityGraph(arg: CurveSet);\n    get localVelocityGraph(): CurveSet;\n\n    set localVelocityGraph2(arg: CurveSet);\n    get localVelocityGraph2(): CurveSet;\n\n    set loop(arg: boolean);\n    get loop(): boolean;\n\n    set noFog(arg: boolean);\n    get noFog(): boolean;\n\n    set normalMapAsset(arg: Asset);\n    get normalMapAsset(): Asset;\n\n    set numParticles(arg: number);\n    get numParticles(): number;\n\n    set orientation(arg: number);\n    get orientation(): number;\n\n    set particleNormal(arg: Vec3);\n    get particleNormal(): Vec3;\n\n    set preWarm(arg: boolean);\n    get preWarm(): boolean;\n\n    set radialSpeedGraph(arg: Curve);\n    get radialSpeedGraph(): Curve;\n\n    set radialSpeedGraph2(arg: Curve);\n    get radialSpeedGraph2(): Curve;\n\n    set randomizeAnimIndex(arg: number);\n    get randomizeAnimIndex(): number;\n\n    set rate(arg: number);\n    get rate(): number;\n\n    set rate2(arg: number);\n    get rate2(): number;\n\n    set renderAsset(arg: Asset);\n    get renderAsset(): Asset;\n\n    set rotationSpeedGraph(arg: Curve);\n    get rotationSpeedGraph(): Curve;\n\n    set rotationSpeedGraph2(arg: Curve);\n    get rotationSpeedGraph2(): Curve;\n\n    set scaleGraph(arg: Curve);\n    get scaleGraph(): Curve;\n\n    set scaleGraph2(arg: Curve);\n    get scaleGraph2(): Curve;\n\n    set screenSpace(arg: boolean);\n    get screenSpace(): boolean;\n\n    set sort(arg: number);\n    get sort(): number;\n\n    set startAngle(arg: number);\n    get startAngle(): number;\n\n    set startAngle2(arg: number);\n    get startAngle2(): number;\n\n    set stretch(arg: number);\n    get stretch(): number;\n\n    set velocityGraph(arg: CurveSet);\n    get velocityGraph(): CurveSet;\n\n    set velocityGraph2(arg: CurveSet);\n    get velocityGraph2(): CurveSet;\n\n    set wrapBounds(arg: Vec3);\n    get wrapBounds(): Vec3;\n\n    /** @private */\n    private _requestedDepth;\n    /** @private */\n    private _drawOrder;\n    set drawOrder(arg: number);\n    get drawOrder(): number;\n    addMeshInstanceToLayers(): void;\n    removeMeshInstanceFromLayers(): void;\n    onSetLayers(name: any, oldValue: any, newValue: any): void;\n    onLayersChanged(oldComp: any, newComp: any): void;\n    onLayerAdded(layer: any): void;\n    onLayerRemoved(layer: any): void;\n    _bindColorMapAsset(asset: any): void;\n    _unbindColorMapAsset(asset: any): void;\n    _onColorMapAssetLoad(asset: any): void;\n    colorMap: any;\n    _onColorMapAssetUnload(asset: any): void;\n    _onColorMapAssetRemove(asset: any): void;\n    _onColorMapAssetChange(asset: any): void;\n    onSetColorMapAsset(name: any, oldValue: any, newValue: any): void;\n    _bindNormalMapAsset(asset: any): void;\n    _unbindNormalMapAsset(asset: any): void;\n    _onNormalMapAssetLoad(asset: any): void;\n    normalMap: any;\n    _onNormalMapAssetUnload(asset: any): void;\n    _onNormalMapAssetRemove(asset: any): void;\n    _onNormalMapAssetChange(asset: any): void;\n    onSetNormalMapAsset(name: any, oldValue: any, newValue: any): void;\n    _bindMeshAsset(asset: any): void;\n    _unbindMeshAsset(asset: any): void;\n    _onMeshAssetLoad(asset: any): void;\n    _onMeshAssetUnload(asset: any): void;\n    mesh: any;\n    _onMeshAssetRemove(asset: any): void;\n    _onMeshAssetChange(asset: any): void;\n    onSetMeshAsset(name: any, oldValue: any, newValue: any): void;\n    onSetMesh(name: any, oldValue: any, newValue: any): void;\n    meshAsset: any;\n    _onMeshChanged(mesh: any): void;\n    onSetRenderAsset(name: any, oldValue: any, newValue: any): void;\n    _bindRenderAsset(asset: any): void;\n    _unbindRenderAsset(asset: any): void;\n    _onRenderAssetLoad(asset: any): void;\n    _onRenderAssetUnload(asset: any): void;\n    _onRenderAssetRemove(asset: any): void;\n    _onRenderChanged(render: any): void;\n    _onRenderSetMeshes(meshes: any): void;\n    onSetLoop(name: any, oldValue: any, newValue: any): void;\n    onSetBlendType(name: any, oldValue: any, newValue: any): void;\n    _requestDepth(): void;\n    _releaseDepth(): void;\n    onSetDepthSoftening(name: any, oldValue: any, newValue: any): void;\n    onSetSimpleProperty(name: any, oldValue: any, newValue: any): void;\n    onSetComplexProperty(name: any, oldValue: any, newValue: any): void;\n    onSetGraphProperty(name: any, oldValue: any, newValue: any): void;\n    emitter: ParticleEmitter;\n    onBeforeRemove(): void;\n    \n    /**\n     * Resets particle state, doesn\'t affect playing.\n     */\n    reset(): void;\n    /**\n     * Disables the emission of new particles, lets existing to finish their simulation.\n     */\n    stop(): void;\n    /**\n     * Freezes the simulation.\n     */\n    pause(): void;\n    /**\n     * Unfreezes the simulation.\n     */\n    unpause(): void;\n    /**\n     * Enables/unfreezes the simulation.\n     */\n    play(): void;\n    /**\n     * Checks if simulation is in progress.\n     *\n     * @returns {boolean} True if the particle system is currently playing and false otherwise.\n     */\n    isPlaying(): boolean;\n    /**\n     * Rebuilds all data used by this particle system.\n     *\n     * @private\n     */\n    private rebuild;\n}\n\ndeclare class ModelComponentData {\n    enabled: boolean;\n}\n\n/**\n * Allows an Entity to render a model or a primitive shape like a box, capsule, sphere, cylinder,\n * cone etc.\n *\n * @augments ComponentSystem\n */\ndeclare class ModelComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof ModelComponent;\n    DataType: typeof ModelComponentData;\n    schema: string[];\n    defaultMaterial: StandardMaterial;\n    initializeComponentData(component: any, _data: any, properties: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    onRemove(entity: any, component: any): void;\n}\n\n/**\n * A light.\n *\n * @ignore\n */\ndeclare class Light {\n    constructor(graphicsDevice: any);\n    device: any;\n    id: number;\n    _type: number;\n    _color: Color;\n    _intensity: number;\n    _castShadows: boolean;\n    _enabled: boolean;\n    mask: number;\n    isStatic: boolean;\n    key: number;\n    bakeDir: boolean;\n    bakeNumSamples: number;\n    bakeArea: number;\n    attenuationStart: number;\n    attenuationEnd: number;\n    _falloffMode: number;\n    _shadowType: number;\n    _vsmBlurSize: number;\n    vsmBlurMode: number;\n    vsmBias: number;\n    _cookie: any;\n    cookieIntensity: number;\n    _cookieFalloff: boolean;\n    _cookieChannel: string;\n    _cookieTransform: any;\n    _cookieTransformUniform: Float32Array;\n    _cookieOffset: any;\n    _cookieOffsetUniform: Float32Array;\n    _cookieTransformSet: boolean;\n    _cookieOffsetSet: boolean;\n    _innerConeAngle: number;\n    _outerConeAngle: number;\n    cascades: any;\n    _shadowMatrixPalette: Float32Array;\n    _shadowCascadeDistances: Float32Array;\n    set numCascades(arg: any);\n    get numCascades(): any;\n    cascadeDistribution: number;\n    _shape: number;\n    _finalColor: Float32Array;\n    _linearFinalColor: Float32Array;\n    _position: Vec3;\n    _direction: Vec3;\n    _innerConeAngleCos: number;\n    _outerConeAngleCos: number;\n    _shadowMap: any;\n    _shadowRenderParams: any[];\n    shadowDistance: number;\n    _shadowResolution: number;\n    shadowBias: number;\n    _normalOffsetBias: number;\n    shadowUpdateMode: number;\n    _isVsm: boolean;\n    _isPcf: boolean;\n    _cookieMatrix: Mat4;\n    _atlasViewport: Vec4;\n    atlasViewportAllocated: boolean;\n    atlasVersion: number;\n    atlasSlotIndex: number;\n    atlasSlotUpdated: boolean;\n    _scene: any;\n    _node: any;\n    _renderData: any[];\n    visibleThisFrame: boolean;\n    maxScreenSize: number;\n    destroy(): void;\n    set shadowMap(arg: any);\n    get shadowMap(): any;\n    get numShadowFaces(): any;\n    set type(arg: number);\n    get type(): number;\n    set shadowType(arg: number);\n    get shadowType(): number;\n    set shape(arg: number);\n    get shape(): number;\n    set enabled(arg: boolean);\n    get enabled(): boolean;\n    set castShadows(arg: boolean);\n    get castShadows(): boolean;\n    set shadowResolution(arg: number);\n    get shadowResolution(): number;\n    set vsmBlurSize(arg: number);\n    get vsmBlurSize(): number;\n    set normalOffsetBias(arg: number);\n    get normalOffsetBias(): number;\n    set falloffMode(arg: number);\n    get falloffMode(): number;\n    set innerConeAngle(arg: number);\n    get innerConeAngle(): number;\n    set outerConeAngle(arg: number);\n    get outerConeAngle(): number;\n    set intensity(arg: number);\n    get intensity(): number;\n    get cookieMatrix(): Mat4;\n    get atlasViewport(): Vec4;\n    set cookie(arg: any);\n    get cookie(): any;\n    set cookieFalloff(arg: boolean);\n    get cookieFalloff(): boolean;\n    set cookieChannel(arg: string);\n    get cookieChannel(): string;\n    set cookieTransform(arg: any);\n    get cookieTransform(): any;\n    set cookieOffset(arg: any);\n    get cookieOffset(): any;\n    beginFrame(): void;\n    _destroyShadowMap(): void;\n    getRenderData(camera: any, face: any): any;\n    /**\n     * Duplicates a light node but does not \'deep copy\' the hierarchy.\n     *\n     * @returns {Light} A cloned Light.\n     */\n    clone(): Light;\n    _getUniformBiasValues(lightRenderData: any): {\n        bias: number;\n        normalBias: number;\n    };\n    getColor(): Color;\n    getBoundingSphere(sphere: any): void;\n    getBoundingBox(box: any): void;\n    _updateFinalColor(): void;\n    setColor(...args: any[]): void;\n    updateShadow(): void;\n    layersDirty(): void;\n    updateKey(): void;\n}\n\ndeclare class LightComponentData {\n}\n\n/**\n * A Light Component is used to dynamically light the scene.\n *\n * @augments ComponentSystem\n */\ndeclare class LightComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof LightComponent;\n    DataType: typeof LightComponentData;\n    initializeComponentData(component: any, _data: any): void;\n    _onRemoveComponent(entity: any, component: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    changeType(component: any, oldValue: any, newValue: any): void;\n}\n\n\n\n\n/**\n * The Light Component enables the Entity to light the scene. There are three types of light:\n * directional, omni and spot. Directional lights are global in that they are considered to be\n * infinitely far away and light the entire scene. Omni and spot lights are local in that they have\n * a position and a range. A spot light is a specialization of an omni light where light is emitted\n * in a cone rather than in all directions. Lights also have the ability to cast shadows to add\n * realism to your scenes.\n *\n * ```javascript\n * // Add a pc.LightComponent to an entity\n * var entity = new pc.Entity();\n * entity.addComponent(\'light\', {\n *     type: "omni",\n *     color: new pc.Color(1, 0, 0),\n *     range: 10\n * });\n *\n * // Get the pc.LightComponent on an entity\n * var lightComponent = entity.light;\n *\n * // Update a property on a light component\n * entity.light.range = 20;\n * ```\n *\n * @property {string} type The type of light. Can be:\n *\n * - "directional": A light that is infinitely far away and lights the entire scene from one\n * direction.\n * - "omni": An omni-directional light that illuminates in all directions from the light source.\n * - "spot": An omni-directional light but is bounded by a cone.\n *\n * Defaults to "directional".\n * @property {Color} color The Color of the light. The alpha component of the color is ignored.\n * Defaults to white (1, 1, 1).\n * @property {number} intensity The brightness of the light. Defaults to 1.\n * @property {number} shape The light source shape. Can be:\n *\n * - {@link pc.LIGHTSHAPE_PUNCTUAL}: Infinitesimally small point.\n * - {@link pc.LIGHTSHAPE_RECT}: Rectangle shape.\n * - {@link pc.LIGHTSHAPE_DISK}: Disk shape.\n * - {@link pc.LIGHTSHAPE_SPHERE}: Sphere shape.\n *\n * Defaults to pc.LIGHTSHAPE_PUNCTUAL.\n * @property {boolean} castShadows If enabled the light will cast shadows. Defaults to false.\n * @property {number} shadowDistance The distance from the viewpoint beyond which shadows are no\n * longer rendered. Affects directional lights only. Defaults to 40.\n * @property {number} shadowResolution The size of the texture used for the shadow map. Valid sizes\n * are 64, 128, 256, 512, 1024, 2048. Defaults to 1024.\n * @property {number} shadowBias The depth bias for tuning the appearance of the shadow mapping\n * generated by this light. Valid range is 0 to 1. Defaults to 0.05.\n * @property {number} numCascades Number of shadow cascades. Can be 1, 2, 3 or 4. Defaults to 1,\n * representing no cascades.\n * @property {number} cascadeDistribution The distribution of subdivision of the camera frustum for\n * individual shadow cascades. Only used if {@link LightComponent#numCascades} is larger than 1.\n * Can be a value in range of 0 and 1. Value of 0 represents a linear distribution, value of 1\n * represents a logarithmic distribution. Defaults to 0.5. Larger value increases the resolution of\n * the shadows in the near distance.\n * @property {number} normalOffsetBias Normal offset depth bias. Valid range is 0 to 1. Defaults to\n * 0.\n * @property {number} range The range of the light. Affects omni and spot lights only. Defaults to\n * 10.\n * @property {number} innerConeAngle The angle at which the spotlight cone starts to fade off. The\n * angle is specified in degrees. Affects spot lights only. Defaults to 40.\n * @property {number} outerConeAngle The angle at which the spotlight cone has faded to nothing.\n * The angle is specified in degrees. Affects spot lights only. Defaults to 45.\n * @property {number} falloffMode Controls the rate at which a light attenuates from its position.\n * Can be:\n *\n * - {@link LIGHTFALLOFF_LINEAR}: Linear.\n * - {@link LIGHTFALLOFF_INVERSESQUARED}: Inverse squared.\n *\n * Affects omni and spot lights only. Defaults to {@link LIGHTFALLOFF_LINEAR}.\n * @property {number} mask Defines a mask to determine which {@link MeshInstance}s are lit by this\n * light. Defaults to 1.\n * @property {boolean} affectDynamic If enabled the light will affect non-lightmapped objects.\n * @property {boolean} affectLightmapped If enabled the light will affect lightmapped objects.\n * @property {boolean} bake If enabled the light will be rendered into lightmaps.\n * @property {number} bakeNumSamples If bake is true, this specifies the number of samples used to\n * bake this light into the lightmap. Defaults to 1. Maximum value is 255.\n * @property {number} bakeArea If bake is true and the light type is {@link LIGHTTYPE_DIRECTIONAL},\n * this specifies the penumbra angle in degrees, allowing a soft shadow boundary. Defaults to 0.\n * @property {boolean} bakeDir If enabled and bake=true, the light\'s direction will contribute to\n * directional lightmaps. Be aware, that directional lightmap is an approximation and can only hold\n * single direction per pixel. Intersecting multiple lights with bakeDir=true may lead to incorrect\n * look of specular/bump-mapping in the area of intersection. The error is not always visible\n * though, and highly scene-dependent.\n * @property {number} shadowUpdateMode Tells the renderer how often shadows must be updated for\n * this light. Can be:\n *\n * - {@link SHADOWUPDATE_NONE}: Don\'t render shadows.\n * - {@link SHADOWUPDATE_THISFRAME}: Render shadows only once (then automatically switches to\n * {@link SHADOWUPDATE_NONE}.\n * - {@link SHADOWUPDATE_REALTIME}: Render shadows every frame (default).\n * @property {number} shadowType Type of shadows being rendered by this light. Options:\n *\n * - {@link SHADOW_PCF3}: Render depth (color-packed on WebGL 1.0), can be used for PCF 3x3\n * sampling.\n * - {@link SHADOW_VSM8}: Render packed variance shadow map. All shadow receivers must also cast\n * shadows for this mode to work correctly.\n * - {@link SHADOW_VSM16}: Render 16-bit exponential variance shadow map. Requires\n * OES_texture_half_float extension. Falls back to {@link SHADOW_VSM8}, if not supported.\n * - {@link SHADOW_VSM32}: Render 32-bit exponential variance shadow map. Requires\n * OES_texture_float extension. Falls back to {@link SHADOW_VSM16}, if not supported.\n * - {@link SHADOW_PCF5}: Render depth buffer only, can be used for hardware-accelerated PCF 5x5\n * sampling. Requires WebGL2. Falls back to {@link SHADOW_PCF3} on WebGL 1.0.\n * @property {number} vsmBlurMode Blurring mode for variance shadow maps. Can be:\n *\n * - {@link BLUR_BOX}: Box filter.\n * - {@link BLUR_GAUSSIAN}: Gaussian filter. May look smoother than box, but requires more samples.\n * @property {number} vsmBlurSize Number of samples used for blurring a variance shadow map. Only\n * uneven numbers work, even are incremented. Minimum value is 1, maximum is 25. Defaults to 11.\n * @property {number} cookieAsset Asset that has texture that will be assigned to cookie internally\n * once asset resource is available.\n * @property {Texture} cookie Projection texture. Must be 2D for spot and cubemap for omni light\n * (ignored if incorrect type is used).\n * @property {number} cookieIntensity Projection texture intensity (default is 1).\n * @property {boolean} cookieFalloff Toggle normal spotlight falloff when projection texture is\n * used. When set to false, spotlight will work like a pure texture projector (only fading with\n * distance). Default is false.\n * @property {string} cookieChannel Color channels of the projection texture to use. Can be "r",\n * "g", "b", "a", "rgb".\n * @property {number} cookieAngle Angle for spotlight cookie rotation.\n * @property {Vec2} cookieScale Spotlight cookie scale.\n * @property {Vec2} cookieOffset Spotlight cookie position offset.\n * @property {boolean} isStatic Mark light as non-movable (optimization).\n * @property {number[]} layers An array of layer IDs ({@link Layer#id}) to which this light should\n * belong. Don\'t push/pop/splice or modify this array, if you want to change it - set a new one\n * instead.\n * @augments Component\n */\ndeclare class LightComponent extends Component {\n    /**\n     * Creates a new LightComponent instance.\n     *\n     * @param {LightComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: LightComponentSystem, entity: Entity);\n\n    set affectDynamic(arg: boolean);\n    get affectDynamic(): boolean;\n\n    set affectLightmapped(arg: boolean);\n    get affectLightmapped(): boolean;\n\n    set bake(arg: boolean);\n    get bake(): boolean;\n\n    set bakeArea(arg: number);\n    get bakeArea(): number;\n\n    set bakeDir(arg: boolean);\n    get bakeDir(): boolean;\n\n    set bakeNumSamples(arg: number);\n    get bakeNumSamples(): number;\n\n    set cascadeDistribution(arg: number);\n    get cascadeDistribution(): number;\n\n    set castShadows(arg: boolean);\n    get castShadows(): boolean;\n\n    set color(arg: Color);\n    get color(): Color;\n\n    set cookieAngle(arg: number);\n    get cookieAngle(): number;\n\n    set cookieChannel(arg: string);\n    get cookieChannel(): string;\n\n    set cookieFalloff(arg: boolean);\n    get cookieFalloff(): boolean;\n\n    set cookieIntensity(arg: number);\n    get cookieIntensity(): number;\n\n    set cookieOffset(arg: Vec2);\n    get cookieOffset(): Vec2;\n\n    set cookieScale(arg: Vec2);\n    get cookieScale(): Vec2;\n\n    set falloffMode(arg: number);\n    get falloffMode(): number;\n\n    set innerConeAngle(arg: number);\n    get innerConeAngle(): number;\n\n    set intensity(arg: number);\n    get intensity(): number;\n\n    set isStatic(arg: boolean);\n    get isStatic(): boolean;\n\n    set layers(arg: number[]);\n    get layers(): number[];\n\n    set mask(arg: number);\n    get mask(): number;\n\n    set normalOffsetBias(arg: number);\n    get normalOffsetBias(): number;\n\n    set numCascades(arg: number);\n    get numCascades(): number;\n\n    set outerConeAngle(arg: number);\n    get outerConeAngle(): number;\n\n    set range(arg: number);\n    get range(): number;\n\n    set shadowBias(arg: number);\n    get shadowBias(): number;\n\n    set shadowDistance(arg: number);\n    get shadowDistance(): number;\n\n    set shadowResolution(arg: number);\n    get shadowResolution(): number;\n\n    set shadowType(arg: number);\n    get shadowType(): number;\n\n    set shadowUpdateMode(arg: number);\n    get shadowUpdateMode(): number;\n\n    set shape(arg: number);\n    get shape(): number;\n\n    set type(arg: string);\n    get type(): string;\n\n    set vsmBlurMode(arg: number);\n    get vsmBlurMode(): number;\n\n    set vsmBlurSize(arg: number);\n    get vsmBlurSize(): number;\n\n    _cookieAsset: any;\n    _cookieAssetId: any;\n    _cookieAssetAdd: boolean;\n    _cookieMatrix: any;\n    addLightToLayers(): void;\n    removeLightFromLayers(): void;\n    onLayersChanged(oldComp: any, newComp: any): void;\n    onLayerAdded(layer: any): void;\n    onLayerRemoved(layer: any): void;\n    refreshProperties(): void;\n    updateShadow(): void;\n    onCookieAssetSet(): void;\n    onCookieAssetAdd(asset: any): void;\n    onCookieAssetLoad(): void;\n    cookie: any;\n    onCookieAssetRemove(): void;\n    onRemove(): void;\n    cookieAsset: any;\n}\n\n\n\n\n\n\n/**\n * A Layer represents a renderable subset of the scene. It can contain a list of mesh instances,\n * lights and cameras, their render settings and also defines custom callbacks before, after or\n * during rendering. Layers are organized inside {@link LayerComposition} in a desired order.\n */\ndeclare class Layer {\n    /**\n     * Create a new Layer instance.\n     *\n     * @param {object} options - Object for passing optional arguments. These arguments are the\n     * same as properties of the Layer.\n     */\n    constructor(options?: object);\n    /**\n     * A unique ID of the layer. Layer IDs are stored inside {@link ModelComponent#layers},\n     * {@link RenderComponent#layers}, {@link CameraComponent#layers},\n     * {@link LightComponent#layers} and {@link ElementComponent#layers} instead of names.\n     * Can be used in {@link LayerComposition#getLayerById}.\n     *\n     * @type {number}\n     */\n    id: number;\n    /**\n     * Name of the layer. Can be used in {@link LayerComposition#getLayerByName}.\n     *\n     * @type {string}\n     */\n    name: string;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _enabled;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _refCounter;\n    /**\n     * Defines the method used for sorting opaque (that is, not semi-transparent) mesh\n     * instances before rendering. Can be:\n     *\n     * - {@link SORTMODE_NONE}\n     * - {@link SORTMODE_MANUAL}\n     * - {@link SORTMODE_MATERIALMESH}\n     * - {@link SORTMODE_BACK2FRONT}\n     * - {@link SORTMODE_FRONT2BACK}\n     *\n     * Defaults to {@link SORTMODE_MATERIALMESH}.\n     *\n     * @type {number}\n     */\n    opaqueSortMode: number;\n    /**\n     * Defines the method used for sorting semi-transparent mesh instances before rendering. Can be:\n     *\n     * - {@link SORTMODE_NONE}\n     * - {@link SORTMODE_MANUAL}\n     * - {@link SORTMODE_MATERIALMESH}\n     * - {@link SORTMODE_BACK2FRONT}\n     * - {@link SORTMODE_FRONT2BACK}\n     *\n     * Defaults to {@link SORTMODE_BACK2FRONT}.\n     *\n     * @type {number}\n     */\n    transparentSortMode: number;\n    /**\n     * @type {RenderTarget}\n     * @ignore\n     */\n    set renderTarget(arg: RenderTarget);\n    get renderTarget(): RenderTarget;\n    /**\n     * A type of shader to use during rendering. Possible values are:\n     *\n     * - {@link SHADER_FORWARD}\n     * - {@link SHADER_FORWARDHDR}\n     * - {@link SHADER_DEPTH}\n     * - Your own custom value. Should be in 19 - 31 range. Use {@link StandardMaterial#onUpdateShader}\n     * to apply shader modifications based on this value.\n     *\n     * Defaults to {@link SHADER_FORWARD}.\n     *\n     * @type {number}\n     */\n    shaderPass: number;\n    /**\n     * Tells that this layer is simple and needs to just render a bunch of mesh instances\n     * without lighting, skinning and morphing (faster). Used for UI and Gizmo layers (the\n     * layer doesn\'t use lights, shadows, culling, etc).\n     *\n     * @type {boolean}\n     */\n    passThrough: boolean;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _clearColorBuffer;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _clearDepthBuffer;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _clearStencilBuffer;\n    /**\n     * Custom function that is called before visibility culling is performed for this layer.\n     * Useful, for example, if you want to modify camera projection while still using the same\n     * camera and make frustum culling work correctly with it (see\n     * {@link CameraComponent#calculateTransform} and {@link CameraComponent#calculateProjection}).\n     * This function will receive camera index as the only argument. You can get the actual\n     * camera being used by looking up {@link LayerComposition#cameras} with this index.\n     *\n     * @type {Function}\n     */\n    onPreCull: Function;\n    /**\n     * Custom function that is called before this layer is rendered. Useful, for example, for\n     * reacting on screen size changes. This function is called before the first occurrence of\n     * this layer in {@link LayerComposition}. It will receive camera index as the only\n     * argument. You can get the actual camera being used by looking up\n     * {@link LayerComposition#cameras} with this index.\n     *\n     * @type {Function}\n     */\n    onPreRender: Function;\n    /**\n     * Custom function that is called before opaque mesh instances (not semi-transparent) in\n     * this layer are rendered. This function will receive camera index as the only argument.\n     * You can get the actual camera being used by looking up {@link LayerComposition#cameras}\n     * with this index.\n     *\n     * @type {Function}\n     */\n    onPreRenderOpaque: Function;\n    /**\n     * Custom function that is called before semi-transparent mesh instances in this layer are\n     * rendered. This function will receive camera index as the only argument. You can get the\n     * actual camera being used by looking up {@link LayerComposition#cameras} with this index.\n     *\n     * @type {Function}\n     */\n    onPreRenderTransparent: Function;\n    /**\n     * Custom function that is called after visibility culling is performed for this layer.\n     * Useful for reverting changes done in {@link Layer#onPreCull} and determining final mesh\n     * instance visibility (see {@link MeshInstance#visibleThisFrame}). This function will\n     * receive camera index as the only argument. You can get the actual camera being used by\n     * looking up {@link LayerComposition#cameras} with this index.\n     *\n     * @type {Function}\n     */\n    onPostCull: Function;\n    /**\n     * Custom function that is called after this layer is rendered. Useful to revert changes\n     * made in {@link Layer#onPreRender} or performing some processing on\n     * {@link Layer#renderTarget}. This function is called after the last occurrence of this\n     * layer in {@link LayerComposition}. It will receive camera index as the only argument.\n     * You can get the actual camera being used by looking up {@link LayerComposition#cameras}\n     * with this index.\n     *\n     * @type {Function}\n     */\n    onPostRender: Function;\n    /**\n     * Custom function that is called after opaque mesh instances (not semi-transparent) in\n     * this layer are rendered. This function will receive camera index as the only argument.\n     * You can get the actual camera being used by looking up {@link LayerComposition#cameras}\n     * with this index.\n     *\n     * @type {Function}\n     */\n    onPostRenderOpaque: Function;\n    /**\n     * Custom function that is called after semi-transparent mesh instances in this layer are\n     * rendered. This function will receive camera index as the only argument. You can get the\n     * actual camera being used by looking up {@link LayerComposition#cameras} with this index.\n     *\n     * @type {Function}\n     */\n    onPostRenderTransparent: Function;\n    /**\n     * Custom function that is called before every mesh instance in this layer is rendered. It\n     * is not recommended to set this function when rendering many objects every frame due to\n     * performance reasons.\n     *\n     * @type {Function}\n     */\n    onDrawCall: Function;\n    /**\n     * Custom function that is called after the layer has been enabled. This happens when:\n     *\n     * - The layer is created with {@link Layer#enabled} set to true (which is the default value).\n     * - {@link Layer#enabled} was changed from false to true\n     * - {@link Layer#incrementCounter} was called and incremented the counter above zero.\n     *\n     * Useful for allocating resources this layer will use (e.g. creating render targets).\n     *\n     * @type {Function}\n     */\n    onEnable: Function;\n    /**\n     * Custom function that is called after the layer has been disabled. This happens when:\n     *\n     * - {@link Layer#enabled} was changed from true to false\n     * - {@link Layer#decrementCounter} was called and set the counter to zero.\n     *\n     * @type {Function}\n     */\n    onDisable: Function;\n    /**\n     * Make this layer render the same mesh instances that another layer does instead of having\n     * its own mesh instance list. Both layers must share cameras. Frustum culling is only\n     * performed for one layer. Useful for rendering multiple passes using different shaders.\n     *\n     * @type {Layer}\n     */\n    layerReference: Layer;\n    /**\n     * @type {InstanceList}\n     * @private\n     */\n    private instances;\n    /**\n     * Visibility bit mask that interacts with {@link MeshInstance#mask}. Especially useful\n     * when combined with layerReference, allowing for the filtering of some objects, while\n     * sharing their list and culling.\n     *\n     * @type {number}\n     */\n    cullingMask: number;\n    /**\n     * @type {MeshInstance[]}\n     * @ignore\n     */\n    opaqueMeshInstances: MeshInstance[];\n    /**\n     * @type {MeshInstance[]}\n     * @ignore\n     */\n    transparentMeshInstances: MeshInstance[];\n    /**\n     * @type {MeshInstance[]}\n     * @ignore\n     */\n    shadowCasters: MeshInstance[];\n    /**\n     * @type {Function|null}\n     * @ignore\n     */\n    customSortCallback: Function | null;\n    /**\n     * @type {Function|null}\n     * @ignore\n     */\n    customCalculateSortValues: Function | null;\n    /**\n     * @type {Light[]}\n     * @private\n     */\n    private _lights;\n    /**\n     * @type {Set<Light>}\n     * @private\n     */\n    private _lightsSet;\n    /**\n     * Set of light used by clustered lighting (omni and spot, but no directional).\n     *\n     * @type {Set<Light>}\n     * @private\n     */\n    private _clusteredLightsSet;\n    /**\n     * Lights separated by light type.\n     *\n     * @type {Light[][]}\n     * @ignore\n     */\n    _splitLights: Light[][];\n    /**\n     * @type {CameraComponent[]}\n     * @ignore\n     */\n    cameras: CameraComponent[];\n    _dirty: boolean;\n    _dirtyLights: boolean;\n    _dirtyCameras: boolean;\n    _lightHash: number;\n    _staticLightHash: number;\n    _needsStaticPrepare: boolean;\n    _staticPrepareDone: boolean;\n    skipRenderAfter: number;\n    _skipRenderCounter: number;\n    _renderTime: number;\n    _forwardDrawCalls: number;\n    _shadowDrawCalls: number;\n    _shaderVersion: number;\n    /**\n     * @type {Float32Array}\n     * @ignore\n     */\n    _lightCube: Float32Array;\n    /**\n     * @type {RenderTarget}\n     * @private\n     */\n    private _renderTarget;\n    /**\n     * Enable the layer. Disabled layers are skipped. Defaults to true.\n     *\n     * @type {boolean}\n     */\n    set enabled(arg: boolean);\n    get enabled(): boolean;\n    set clearColor(arg: any);\n    get clearColor(): any;\n    /**\n     * If true, the camera will clear the color buffer when it renders this layer.\n     *\n     * @type {boolean}\n     */\n    set clearColorBuffer(arg: boolean);\n    get clearColorBuffer(): boolean;\n    /**\n     * If true, the camera will clear the depth buffer when it renders this layer.\n     *\n     * @type {boolean}\n     */\n    set clearDepthBuffer(arg: boolean);\n    get clearDepthBuffer(): boolean;\n    /**\n     * If true, the camera will clear the stencil buffer when it renders this layer.\n     *\n     * @type {boolean}\n     */\n    set clearStencilBuffer(arg: boolean);\n    get clearStencilBuffer(): boolean;\n    /**\n     * Returns lights used by clustered lighting in a set.\n     *\n     * @type {Set<Light>}\n     * @ignore\n     */\n    get clusteredLightsSet(): Set<Light>;\n    /**\n     * Increments the usage counter of this layer. By default, layers are created with counter set\n     * to 1 (if {@link Layer.enabled} is true) or 0 (if it was false). Incrementing the counter\n     * from 0 to 1 will enable the layer and call {@link Layer.onEnable}. Use this function to\n     * "subscribe" multiple effects to the same layer. For example, if the layer is used to render\n     * a reflection texture which is used by 2 mirrors, then each mirror can call this function\n     * when visible and {@link Layer.decrementCounter} if invisible. In such case the reflection\n     * texture won\'t be updated, when there is nothing to use it, saving performance.\n     *\n     * @private\n     */\n    private incrementCounter;\n    /**\n     * Decrements the usage counter of this layer. Decrementing the counter from 1 to 0 will\n     * disable the layer and call {@link Layer.onDisable}. See {@link Layer#incrementCounter} for\n     * more details.\n     *\n     * @private\n     */\n    private decrementCounter;\n    /**\n     * Adds an array of mesh instances to this layer.\n     *1\n     *\n     * @param {MeshInstance[]} meshInstances - Array of {@link MeshInstance}.\n     * @param {boolean} [skipShadowCasters] - Set it to true if you don\'t want these mesh instances\n     * to cast shadows in this layer.\n     */\n    addMeshInstances(meshInstances: MeshInstance[], skipShadowCasters?: boolean): void;\n    /**\n     * Internal function to remove a mesh instance from an array.\n     *\n     * @param {MeshInstance} m - Mesh instance to remove.\n     * @param {MeshInstance[]} arr - Array of mesh instances to remove from.\n     * @private\n     */\n    private removeMeshInstanceFromArray;\n    /**\n     * Removes multiple mesh instances from this layer.\n     *\n     * @param {MeshInstance[]} meshInstances - Array of {@link MeshInstance}. If they were added to\n     * this layer, they will be removed.\n     * @param {boolean} [skipShadowCasters] - Set it to true if you want to still cast shadows from\n     * removed mesh instances or if they never did cast shadows before.\n     */\n    removeMeshInstances(meshInstances: MeshInstance[], skipShadowCasters?: boolean): void;\n    /**\n     * Removes all mesh instances from this layer.\n     *\n     * @param {boolean} [skipShadowCasters] - Set it to true if you want to still cast shadows from\n     * removed mesh instances or if they never did cast shadows before.\n     */\n    clearMeshInstances(skipShadowCasters?: boolean): void;\n    /**\n     * Adds a light to this layer.\n     *\n     * @param {LightComponent} light - A {@link LightComponent}.\n     */\n    addLight(light: LightComponent): void;\n    /**\n     * Removes a light from this layer.\n     *\n     * @param {LightComponent} light - A {@link LightComponent}.\n     */\n    removeLight(light: LightComponent): void;\n    /**\n     * Removes all lights from this layer.\n     */\n    clearLights(): void;\n    /**\n     * Adds an array of mesh instances to this layer, but only as shadow casters (they will not be\n     * rendered anywhere, but only cast shadows on other objects).\n     *\n     * @param {MeshInstance[]} meshInstances - Array of {@link MeshInstance}.\n     */\n    addShadowCasters(meshInstances: MeshInstance[]): void;\n    /**\n     * Removes multiple mesh instances from the shadow casters list of this layer, meaning they\n     * will stop casting shadows.\n     *\n     * @param {MeshInstance[]} meshInstances - Array of {@link MeshInstance}. If they were added to\n     * this layer, they will be removed.\n     */\n    removeShadowCasters(meshInstances: MeshInstance[]): void;\n    /** @private */\n    private _generateLightHash;\n    /**\n     * Adds a camera to this layer.\n     *\n     * @param {CameraComponent} camera - A {@link CameraComponent}.\n     */\n    addCamera(camera: CameraComponent): void;\n    /**\n     * Removes a camera from this layer.\n     *\n     * @param {CameraComponent} camera - A {@link CameraComponent}.\n     */\n    removeCamera(camera: CameraComponent): void;\n    /**\n     * Removes all cameras from this layer.\n     */\n    clearCameras(): void;\n    /**\n     * @param {MeshInstance[]} drawCalls - Array of mesh instances.\n     * @param {number} drawCallsCount - Number of mesh instances.\n     * @param {Vec3} camPos - Camera position.\n     * @param {Vec3} camFwd - Camera forward vector.\n     * @private\n     */\n    private _calculateSortDistances;\n    /**\n     * @param {boolean} transparent - True if transparent sorting should be used.\n     * @param {GraphNode} cameraNode - Graph node that the camera is attached to.\n     * @param {number} cameraPass - Camera pass.\n     * @ignore\n     */\n    _sortVisible(transparent: boolean, cameraNode: GraphNode, cameraPass: number): void;\n}\n\ndeclare class LightsBuffer {\n    static FORMAT_FLOAT: number;\n    static FORMAT_8BIT: number;\n    static lightTextureFormat: number;\n    static shaderDefines: string;\n    static initShaderDefines(): void;\n    static buildShaderDefines(object: any, prefix: any): string;\n    static init(device: any): void;\n    static createTexture(device: any, width: any, height: any, format: any, name: any): Texture;\n    constructor(device: any);\n    device: any;\n    cookiesEnabled: boolean;\n    shadowsEnabled: boolean;\n    areaLightsEnabled: boolean;\n    maxLights: number;\n    lights8: Uint8ClampedArray;\n    lightsTexture8: Texture;\n    _lightsTexture8Id: any;\n    lightsFloat: Float32Array;\n    lightsTextureFloat: Texture;\n    _lightsTextureFloatId: any;\n    _lightsTextureInvSizeId: any;\n    _lightsTextureInvSizeData: Float32Array;\n    invMaxColorValue: number;\n    invMaxAttenuation: number;\n    boundsMin: Vec3;\n    boundsDelta: Vec3;\n    destroy(): void;\n    setCompressionRanges(maxAttenuation: any, maxColorValue: any): void;\n    setBounds(min: any, delta: any): void;\n    uploadTextures(): void;\n    updateUniforms(): void;\n    getSpotDirection(direction: any, spot: any): void;\n    getLightAreaSizes(light: any): Float32Array;\n    addLightDataFlags(data8: any, index: any, light: any, isSpot: any, castShadows: any): void;\n    addLightDataColor(data8: any, index: any, light: any, gammaCorrection: any, isCookie: any): void;\n    addLightDataSpotAngles(data8: any, index: any, light: any): void;\n    addLightDataShadowBias(data8: any, index: any, light: any): void;\n    addLightDataPositionRange(data8: any, index: any, light: any, pos: any): void;\n    addLightDataSpotDirection(data8: any, index: any, light: any): void;\n    addLightDataLightProjMatrix(data8: any, index: any, lightProjectionMatrix: any): void;\n    addLightDataCookies(data8: any, index: any, light: any): void;\n    addLightAtlasViewport(data8: any, index: any, atlasViewport: any): void;\n    addLightAreaSizes(data8: any, index: any, light: any): void;\n    addLightData(light: any, lightIndex: any, gammaCorrection: any): void;\n}\n\ndeclare class WorldClusters {\n    constructor(device: any);\n    device: any;\n    name: string;\n    reportCount: number;\n    boundsMin: Vec3;\n    boundsMax: Vec3;\n    boundsDelta: Vec3;\n    _cells: Vec3;\n    _cellsLimit: Vec3;\n    set cells(arg: Vec3);\n    get cells(): Vec3;\n    _maxCellLightCount: number;\n    _pixelsPerCellCount: number;\n    set maxCellLightCount(arg: number);\n    get maxCellLightCount(): number;\n    _maxAttenuation: number;\n    _maxColorValue: number;\n    _usedLights: ClusterLight[];\n    lightsBuffer: LightsBuffer;\n    _cellsDirty: boolean;\n    destroy(): void;\n    releaseClusterTexture(): void;\n    clusterTexture: Texture;\n    registerUniforms(device: any): void;\n    _clusterWorldTextureId: any;\n    _clusterPixelsPerCellId: any;\n    _clusterTextureSizeId: any;\n    _clusterTextureSizeData: Float32Array;\n    _clusterBoundsMinId: any;\n    _clusterBoundsMinData: Float32Array;\n    _clusterBoundsDeltaId: any;\n    _clusterBoundsDeltaData: Float32Array;\n    _clusterCellsCountByBoundsSizeId: any;\n    _clusterCellsCountByBoundsSizeData: Float32Array;\n    _clusterCellsDotId: any;\n    _clusterCellsDotData: Float32Array;\n    _clusterCellsMaxId: any;\n    _clusterCellsMaxData: Float32Array;\n    _clusterCompressionLimit0Id: any;\n    _clusterCompressionLimit0Data: Float32Array;\n    updateParams(lightingParams: any): void;\n    updateCells(): void;\n    clusters: Uint8ClampedArray;\n    counts: Int32Array;\n    uploadTextures(): void;\n    updateUniforms(): void;\n    evalLightCellMinMax(clusteredLight: any, min: any, max: any): void;\n    collectLights(lights: any): void;\n    evaluateBounds(): void;\n    evaluateCompressionLimits(gammaCorrection: any): void;\n    updateClusters(gammaCorrection: any): void;\n    update(lights: any, gammaCorrection: any, lightingParams: any): void;\n    activate(): void;\n}\n\ndeclare class ClusterLight {\n    light: any;\n    min: Vec3;\n    max: Vec3;\n}\n\n\n\n/**\n * Layer Composition is a collection of {@link Layer} that is fed to {@link Scene#layers} to define\n * rendering order.\n *\n * @augments EventHandler\n */\ndeclare class LayerComposition extends EventHandler {\n    /**\n     * Create a new layer composition.\n     *\n     * @param {string} [name] - Optional non-unique name of the layer composition. Defaults to\n     * "Untitled" if not specified.\n     */\n    constructor(name?: string);\n    name: string;\n    logRenderActions: boolean;\n    /**\n     * A read-only array of {@link Layer} sorted in the order they will be rendered.\n     *\n     * @type {Layer[]}\n     */\n    layerList: Layer[];\n    /**\n     * A read-only array of boolean values, matching {@link Layer#layerList}. True means only\n     * semi-transparent objects are rendered, and false means opaque.\n     *\n     * @type {boolean[]}\n     */\n    subLayerList: boolean[];\n    /**\n     * A read-only array of boolean values, matching {@link Layer#layerList}. True means the\n     * layer is rendered, false means it\'s skipped.\n     *\n     * @type {boolean[]}\n     */\n    subLayerEnabled: boolean[];\n    _opaqueOrder: {};\n    _transparentOrder: {};\n    _dirty: boolean;\n    _dirtyBlend: boolean;\n    _dirtyLights: boolean;\n    _dirtyCameras: boolean;\n    _meshInstances: any[];\n    _meshInstancesSet: Set<any>;\n    _lights: any[];\n    _lightsMap: Map<any, any>;\n    _lightCompositionData: any[];\n    _splitLights: any[][];\n    /**\n     * A read-only array of {@link CameraComponent} that can be used during rendering. e.g.\n     * Inside {@link Layer#onPreCull}, {@link Layer#onPostCull}, {@link Layer#onPreRender},\n     * {@link Layer#onPostRender}.\n     *\n     * @type {CameraComponent[]}\n     */\n    cameras: CameraComponent[];\n    _renderActions: any[];\n    _worldClusters: any[];\n    _emptyWorldClusters: WorldClusters;\n    destroy(): void;\n    getEmptyWorldClusters(device: any): WorldClusters;\n    _splitLightsArray(target: any): void;\n    _update(device: any, clusteredLightingEnabled?: boolean): number;\n    updateShadowCasters(): void;\n    updateLights(): void;\n    findCompatibleCluster(layer: any, renderActionCount: any): any;\n    allocateLightClusters(device: any): void;\n    addRenderAction(renderActions: any, renderActionIndex: any, layer: any, layerIndex: any, cameraIndex: any, cameraFirstRenderAction: any, postProcessMarked: any): any;\n    propagateRenderTarget(startIndex: any, fromCamera: any): void;\n    _logRenderActions(): void;\n    _isLayerAdded(layer: any): boolean;\n    _isSublayerAdded(layer: any, transparent: any): boolean;\n    /**\n     * Adds a layer (both opaque and semi-transparent parts) to the end of the {@link Layer#layerList}.\n     *\n     * @param {Layer} layer - A {@link Layer} to add.\n     */\n    push(layer: Layer): void;\n    /**\n     * Inserts a layer (both opaque and semi-transparent parts) at the chosen index in the\n     * {@link Layer#layerList}.\n     *\n     * @param {Layer} layer - A {@link Layer} to add.\n     * @param {number} index - Insertion position.\n     */\n    insert(layer: Layer, index: number): void;\n    /**\n     * Removes a layer (both opaque and semi-transparent parts) from {@link Layer#layerList}.\n     *\n     * @param {Layer} layer - A {@link Layer} to remove.\n     */\n    remove(layer: Layer): void;\n    /**\n     * Adds part of the layer with opaque (non semi-transparent) objects to the end of the\n     * {@link Layer#layerList}.\n     *\n     * @param {Layer} layer - A {@link Layer} to add.\n     */\n    pushOpaque(layer: Layer): void;\n    /**\n     * Inserts an opaque part of the layer (non semi-transparent mesh instances) at the chosen\n     * index in the {@link Layer#layerList}.\n     *\n     * @param {Layer} layer - A {@link Layer} to add.\n     * @param {number} index - Insertion position.\n     */\n    insertOpaque(layer: Layer, index: number): void;\n    /**\n     * Removes an opaque part of the layer (non semi-transparent mesh instances) from\n     * {@link Layer#layerList}.\n     *\n     * @param {Layer} layer - A {@link Layer} to remove.\n     */\n    removeOpaque(layer: Layer): void;\n    /**\n     * Adds part of the layer with semi-transparent objects to the end of the {@link Layer#layerList}.\n     *\n     * @param {Layer} layer - A {@link Layer} to add.\n     */\n    pushTransparent(layer: Layer): void;\n    /**\n     * Inserts a semi-transparent part of the layer at the chosen index in the {@link Layer#layerList}.\n     *\n     * @param {Layer} layer - A {@link Layer} to add.\n     * @param {number} index - Insertion position.\n     */\n    insertTransparent(layer: Layer, index: number): void;\n    /**\n     * Removes a transparent part of the layer from {@link Layer#layerList}.\n     *\n     * @param {Layer} layer - A {@link Layer} to remove.\n     */\n    removeTransparent(layer: Layer): void;\n    _getSublayerIndex(layer: any, transparent: any): number;\n    /**\n     * Gets index of the opaque part of the supplied layer in the {@link Layer#layerList}.\n     *\n     * @param {Layer} layer - A {@link Layer} to find index of.\n     * @returns {number} The index of the opaque part of the specified layer.\n     */\n    getOpaqueIndex(layer: Layer): number;\n    /**\n     * Gets index of the semi-transparent part of the supplied layer in the {@link Layer#layerList}.\n     *\n     * @param {Layer} layer - A {@link Layer} to find index of.\n     * @returns {number} The index of the semi-transparent part of the specified layer.\n     */\n    getTransparentIndex(layer: Layer): number;\n    /**\n     * Finds a layer inside this composition by its ID. Null is returned, if nothing is found.\n     *\n     * @param {number} id - An ID of the layer to find.\n     * @returns {Layer|null} The layer corresponding to the specified ID. Returns null if layer is\n     * not found.\n     */\n    getLayerById(id: number): Layer | null;\n    /**\n     * Finds a layer inside this composition by its name. Null is returned, if nothing is found.\n     *\n     * @param {string} name - The name of the layer to find.\n     * @returns {Layer|null} The layer corresponding to the specified name. Returns null if layer\n     * is not found.\n     */\n    getLayerByName(name: string): Layer | null;\n    _updateOpaqueOrder(startIndex: any, endIndex: any): void;\n    _updateTransparentOrder(startIndex: any, endIndex: any): void;\n    _sortLayersDescending(layersA: any, layersB: any, order: any): number;\n    /**\n     * Used to determine which array of layers has any transparent sublayer that is on top of all\n     * the transparent sublayers in the other array.\n     *\n     * @param {number[]} layersA - IDs of layers.\n     * @param {number[]} layersB - IDs of layers.\n     * @returns {number} Returns a negative number if any of the transparent sublayers in layersA\n     * is on top of all the transparent sublayers in layersB, or a positive number if any of the\n     * transparent sublayers in layersB is on top of all the transparent sublayers in layersA, or 0\n     * otherwise.\n     * @private\n     */\n    private sortTransparentLayers;\n    /**\n     * Used to determine which array of layers has any opaque sublayer that is on top of all the\n     * opaque sublayers in the other array.\n     *\n     * @param {number[]} layersA - IDs of layers.\n     * @param {number[]} layersB - IDs of layers.\n     * @returns {number} Returns a negative number if any of the opaque sublayers in layersA is on\n     * top of all the opaque sublayers in layersB, or a positive number if any of the opaque\n     * sublayers in layersB is on top of all the opaque sublayers in layersA, or 0 otherwise.\n     * @private\n     */\n    private sortOpaqueLayers;\n}\n\n\n\n/** @typedef {import(\'../../../scene/composition/layer-composition.js\').LayerComposition} LayerComposition */\n/** @typedef {import(\'../../../scene/materials/material.js\').Material} Material */\n/** @typedef {import(\'../../../shape/bounding-box.js\').BoundingBox} BoundingBox */\n/** @typedef {import(\'../../entity.js\').Entity} Entity */\n/** @typedef {import(\'./system.js\').ModelComponentSystem} ModelComponentSystem */\n/**\n * Enables an Entity to render a model or a primitive shape. This Component attaches additional\n * model geometry in to the scene graph below the Entity.\n *\n * @augments Component\n */\ndeclare class ModelComponent extends Component {\n    /**\n     * Create a new ModelComponent instance.\n     *\n     * @param {ModelComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: ModelComponentSystem, entity: Entity);\n    /**\n     * @type {string}\n     * @private\n     */\n    private _type;\n    /**\n     * @type {Asset|number|null}\n     * @private\n     */\n    private _asset;\n    /**\n     * @type {Model|null}\n     * @private\n     */\n    private _model;\n    /**\n     * @type {Object.<string, number>}\n     * @private\n     */\n    private _mapping;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _castShadows;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _receiveShadows;\n    /**\n     * @type {Asset|number|null}\n     * @private\n     */\n    private _materialAsset;\n    /**\n     * @type {Material}\n     * @private\n     */\n    private _material;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _castShadowsLightmap;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _lightmapped;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _lightmapSizeMultiplier;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _isStatic;\n    /**\n     * @type {number[]}\n     * @private\n     */\n    private _layers;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _batchGroupId;\n    /**\n     * @type {BoundingBox|null}\n     * @private\n     */\n    private _customAabb;\n    _area: any;\n    _materialEvents: any;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _clonedModel;\n    _batchGroup: any;\n    /**\n     * An array of meshInstances contained in the component\'s model. If model is not set or loaded\n     * for component it will return null.\n     *\n     * @type {MeshInstance[]|null}\n     */\n    set meshInstances(arg: MeshInstance[]);\n    get meshInstances(): MeshInstance[];\n    /**\n     * If set, the object space bounding box is used as a bounding box for visibility culling of\n     * attached mesh instances. This is an optimization, allowing oversized bounding box to be\n     * specified for skinned characters in order to avoid per frame bounding box computations based\n     * on bone positions.\n     *\n     * @type {BoundingBox|null}\n     */\n    set customAabb(arg: BoundingBox);\n    get customAabb(): BoundingBox;\n    /**\n     * The type of the model. Can be:\n     *\n     * - "asset": The component will render a model asset\n     * - "box": The component will render a box (1 unit in each dimension)\n     * - "capsule": The component will render a capsule (radius 0.5, height 2)\n     * - "cone": The component will render a cone (radius 0.5, height 1)\n     * - "cylinder": The component will render a cylinder (radius 0.5, height 1)\n     * - "plane": The component will render a plane (1 unit in each dimension)\n     * - "sphere": The component will render a sphere (radius 0.5)\n     *\n     * @type {string}\n     */\n    set type(arg: string);\n    get type(): string;\n    /**\n     * The model that is added to the scene graph. It can be not set or loaded, so will return null.\n     *\n     * @type {Model}\n     */\n    set model(arg: Model);\n    get model(): Model;\n    /**\n     * The asset for the model (only applies to models of type \'asset\') can also be an asset id.\n     *\n     * @type {Asset|number|null}\n     */\n    set asset(arg: number | Asset);\n    get asset(): number | Asset;\n    /**\n     * If true, this model will be lightmapped after using lightmapper.bake().\n     *\n     * @type {boolean}\n     */\n    set lightmapped(arg: boolean);\n    get lightmapped(): boolean;\n    /**\n     * A dictionary that holds material overrides for each mesh instance. Only applies to model\n     * components of type \'asset\'. The mapping contains pairs of mesh instance index - material\n     * asset id.\n     *\n     * @type {Object.<string, number>}\n     */\n    set mapping(arg: {\n        [x: string]: number;\n    });\n    get mapping(): {\n        [x: string]: number;\n    };\n    /**\n     * If true, this model will cast shadows for lights that have shadow casting enabled.\n     *\n     * @type {boolean}\n     */\n    set castShadows(arg: boolean);\n    get castShadows(): boolean;\n    /**\n     * If true, shadows will be cast on this model.\n     *\n     * @type {boolean}\n     */\n    set receiveShadows(arg: boolean);\n    get receiveShadows(): boolean;\n    /**\n     * If true, this model will cast shadows when rendering lightmaps.\n     *\n     * @type {boolean}\n     */\n    set castShadowsLightmap(arg: boolean);\n    get castShadowsLightmap(): boolean;\n    /**\n     * Lightmap resolution multiplier.\n     *\n     * @type {number}\n     */\n    set lightmapSizeMultiplier(arg: number);\n    get lightmapSizeMultiplier(): number;\n    /**\n     * Mark model as non-movable (optimization).\n     *\n     * @type {boolean}\n     */\n    set isStatic(arg: boolean);\n    get isStatic(): boolean;\n    /**\n     * An array of layer IDs ({@link Layer#id}) to which this model should belong. Don\'t push, pop,\n     * splice or modify this array, if you want to change it - set a new one instead.\n     *\n     * @type {number[]}\n     */\n    set layers(arg: number[]);\n    get layers(): number[];\n    /**\n     * Assign model to a specific batch group (see {@link BatchGroup}). Default is -1 (no group).\n     *\n     * @type {number}\n     */\n    set batchGroupId(arg: number);\n    get batchGroupId(): number;\n    /**\n     * The material {@link Asset} that will be used to render the model (not used on models of type\n     * \'asset\').\n     *\n     * @type {Asset|number|null}\n     */\n    set materialAsset(arg: number | Asset);\n    get materialAsset(): number | Asset;\n    /**\n     * The material {@link Material} that will be used to render the model (not used on models of\n     * type \'asset\').\n     *\n     * @type {Material}\n     */\n    set material(arg: Material);\n    get material(): Material;\n    addModelToLayers(): void;\n    removeModelFromLayers(): void;\n    onRemoveChild(): void;\n    onInsertChild(): void;\n    onRemove(): void;\n    /**\n     * @param {LayerComposition} oldComp - The old layer composition.\n     * @param {LayerComposition} newComp - The new layer composition.\n     * @private\n     */\n    private onLayersChanged;\n    /**\n     * @param {Layer} layer - The layer that was added.\n     * @private\n     */\n    private onLayerAdded;\n    /**\n     * @param {Layer} layer - The layer that was removed.\n     * @private\n     */\n    private onLayerRemoved;\n    /**\n     * @param {number} index - The index of the mesh instance.\n     * @param {string} event - The event name.\n     * @param {number} id - The asset id.\n     * @param {*} handler - The handler function to be bound to the specified event.\n     * @private\n     */\n    private _setMaterialEvent;\n    /** @private */\n    private _unsetMaterialEvents;\n    /**\n     * @param {string} idOrPath - The asset id or path.\n     * @returns {Asset|null} The asset.\n     * @private\n     */\n    private _getAssetByIdOrPath;\n    /**\n     * @param {string} path - The path of the model asset.\n     * @returns {string|null} The model asset URL or null if the asset is not in the registry.\n     * @private\n     */\n    private _getMaterialAssetUrl;\n    /**\n     * @param {Asset} materialAsset -The material asset to load.\n     * @param {MeshInstance} meshInstance - The mesh instance to assign the material to.\n     * @param {number} index - The index of the mesh instance.\n     * @private\n     */\n    private _loadAndSetMeshInstanceMaterial;\n    /**\n     * Stop rendering model without removing it from the scene hierarchy. This method sets the\n     * {@link MeshInstance#visible} property of every MeshInstance in the model to false Note, this\n     * does not remove the model or mesh instances from the scene hierarchy or draw call list. So\n     * the model component still incurs some CPU overhead.\n     *\n     * @example\n     * this.timer = 0;\n     * this.visible = true;\n     * // ...\n     * // blink model every 0.1 seconds\n     * this.timer += dt;\n     * if (this.timer > 0.1) {\n     *     if (!this.visible) {\n     *         this.entity.model.show();\n     *         this.visible = true;\n     *     } else {\n     *         this.entity.model.hide();\n     *         this.visible = false;\n     *     }\n     *     this.timer = 0;\n     * }\n     */\n    hide(): void;\n    /**\n     * Enable rendering of the model if hidden using {@link ModelComponent#hide}. This method sets\n     * all the {@link MeshInstance#visible} property on all mesh instances to true.\n     */\n    show(): void;\n    /**\n     * @param {Asset} asset - The material asset to bind events to.\n     * @private\n     */\n    private _bindMaterialAsset;\n    /**\n     * @param {Asset} asset - The material asset to unbind events from.\n     * @private\n     */\n    private _unbindMaterialAsset;\n    /**\n     * @param {Asset} asset - The material asset on which an asset add event has been fired.\n     * @private\n     */\n    private _onMaterialAssetAdd;\n    /**\n     * @param {Asset} asset - The material asset on which an asset load event has been fired.\n     * @private\n     */\n    private _onMaterialAssetLoad;\n    /**\n     * @param {Asset} asset - The material asset on which an asset unload event has been fired.\n     * @private\n     */\n    private _onMaterialAssetUnload;\n    /**\n     * @param {Asset} asset - The material asset on which an asset remove event has been fired.\n     * @private\n     */\n    private _onMaterialAssetRemove;\n    /**\n     * @param {Asset} asset - The material asset on which an asset change event has been fired.\n     * @private\n     */\n    private _onMaterialAssetChange;\n    /**\n     * @param {Asset} asset - The model asset to bind events to.\n     * @private\n     */\n    private _bindModelAsset;\n    /**\n     * @param {Asset} asset - The model asset to unbind events from.\n     * @private\n     */\n    private _unbindModelAsset;\n    /**\n     * @param {Asset} asset - The model asset on which an asset add event has been fired.\n     * @private\n     */\n    private _onModelAssetAdded;\n    /**\n     * @param {Asset} asset - The model asset on which an asset load event has been fired.\n     * @private\n     */\n    private _onModelAssetLoad;\n    /**\n     * @param {Asset} asset - The model asset on which an asset unload event has been fired.\n     * @private\n     */\n    private _onModelAssetUnload;\n    /**\n     * @param {Asset} asset - The model asset on which an asset change event has been fired.\n     * @param {string} attr - The attribute that was changed.\n     * @param {*} _new - The new value of the attribute.\n     * @param {*} _old - The old value of the attribute.\n     * @private\n     */\n    private _onModelAssetChange;\n    /**\n     * @param {Asset} asset - The model asset on which an asset remove event has been fired.\n     * @private\n     */\n    private _onModelAssetRemove;\n    /**\n     * @param {Material} material - The material to be set.\n     * @private\n     */\n    private _setMaterial;\n}\n\ndeclare class LayoutGroupComponentData {\n    enabled: boolean;\n}\n\n/**\n * Manages creation of {@link LayoutGroupComponent}s.\n *\n * @augments ComponentSystem\n */\ndeclare class LayoutGroupComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof LayoutGroupComponent;\n    DataType: typeof LayoutGroupComponentData;\n    schema: string[];\n    _reflowQueue: any[];\n    initializeComponentData(component: any, data: any, properties: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    scheduleReflow(component: any): void;\n    _onPostUpdate(): void;\n    _processReflowQueue(): void;\n    _onRemoveComponent(entity: any, component: any): void;\n}\n\n\n\n/**\n * A LayoutGroupComponent enables the Entity to position and scale child {@link ElementComponent}s\n * according to configurable layout rules.\n *\n * @augments Component\n */\ndeclare class LayoutGroupComponent extends Component {\n    /**\n     * Create a new LayoutGroupComponent instance.\n     *\n     * @param {LayoutGroupComponentSystem} system - The ComponentSystem that created this\n     * Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: LayoutGroupComponentSystem, entity: Entity);\n    /** @private */\n    private _orientation;\n    /** @private */\n    private _reverseX;\n    /** @private */\n    private _reverseY;\n    /** @private */\n    private _alignment;\n    /** @private */\n    private _padding;\n    /** @private */\n    private _spacing;\n    /** @private */\n    private _widthFitting;\n    /** @private */\n    private _heightFitting;\n    /** @private */\n    private _wrap;\n    /** @private */\n    private _layoutCalculator;\n    /**\n     * Whether the layout should run horizontally or vertically. Can be:\n     *\n     * - {@link ORIENTATION_HORIZONTAL}\n     * - {@link ORIENTATION_VERTICAL}\n     *\n     * Defaults to {@link ORIENTATION_HORIZONTAL}.\n     *\n     * @type {number}\n     */\n    set orientation(arg: number);\n    get orientation(): number;\n    /**\n     * Reverses the order of children along the x axis. Defaults to false.\n     *\n     * @type {boolean}\n     */\n    set reverseX(arg: boolean);\n    get reverseX(): boolean;\n    /**\n     * Reverses the order of children along the y axis. Defaults to true.\n     *\n     * @type {boolean}\n     */\n    set reverseY(arg: boolean);\n    get reverseY(): boolean;\n    /**\n     * Specifies the horizontal and vertical alignment of child elements. Values range from 0 to 1\n     * where [0, 0] is the bottom left and [1, 1] is the top right. Defaults to [0, 1].\n     *\n     * @type {Vec2}\n     */\n    set alignment(arg: Vec2);\n    get alignment(): Vec2;\n    /**\n     * Padding to be applied inside the container before positioning any children. Specified as\n     * left, bottom, right and top values. Defaults to [0, 0, 0, 0] (no padding).\n     *\n     * @type {Vec4}\n     */\n    set padding(arg: Vec4);\n    get padding(): Vec4;\n    /**\n     * Spacing to be applied between each child element. Defaults to [0, 0] (no spacing).\n     *\n     * @type {Vec2}\n     */\n    set spacing(arg: Vec2);\n    get spacing(): Vec2;\n    /**\n     * Fitting logic to be applied when positioning and scaling child elements. Can be:\n     *\n     * - {@link FITTING_NONE}: Child elements will be rendered at their natural size.\n     * - {@link FITTING_STRETCH}: When the natural size of all child elements does not fill the width\n     * of the container, children will be stretched to fit. The rules for how each child will be\n     * stretched are outlined below:\n     *   1. Sum the {@link LayoutChildComponent#fitWidthProportion} values of each child and normalize\n     * so that all values sum to 1.\n     *   2. Apply the natural width of each child.\n     *   3. If there is space remaining in the container, distribute it to each child based on the\n     * normalized {@link LayoutChildComponent#fitWidthProportion} values, but do not exceed the\n     * {@link LayoutChildComponent#maxWidth} of each child.\n     * - {@link FITTING_SHRINK}: When the natural size of all child elements overflows the width of the\n     * container, children will be shrunk to fit. The rules for how each child will be stretched are\n     * outlined below:\n     *   1. Sum the {@link LayoutChildComponent#fitWidthProportion} values of each child and normalize\n     * so that all values sum to 1.\n     *   2. Apply the natural width of each child.\n     *   3. If the new total width of all children exceeds the available space of the container, reduce\n     * each child\'s width proportionally based on the normalized {@link\n     * LayoutChildComponent#fitWidthProportion} values, but do not exceed the {@link\n     * LayoutChildComponent#minWidth} of each child.\n     * - {@link FITTING_BOTH}: Applies both STRETCH and SHRINK logic as necessary.\n     *\n     * Defaults to {@link FITTING_NONE}.\n     *\n     * @type {number}\n     */\n    set widthFitting(arg: number);\n    get widthFitting(): number;\n    /**\n     * Identical to {@link LayoutGroupComponent#widthFitting} but for the Y axis. Defaults to\n     * {@link FITTING_NONE}.\n     *\n     * @type {number}\n     */\n    set heightFitting(arg: number);\n    get heightFitting(): number;\n    /**\n     * Whether or not to wrap children onto a new row/column when the size of the container is\n     * exceeded. Defaults to false, which means that children will be be rendered in a single row\n     * (horizontal orientation) or column (vertical orientation). Note that setting wrap to true\n     * makes it impossible for the {@link FITTING_BOTH} fitting mode to operate in any logical\n     * manner. For this reason, when wrap is true, a {@link LayoutGroupComponent#widthFitting} or\n     * {@link LayoutGroupComponent#heightFitting} mode of {@link FITTING_BOTH} will be coerced to\n     * {@link FITTING_STRETCH}.\n     *\n     * @type {boolean}\n     */\n    set wrap(arg: boolean);\n    get wrap(): boolean;\n    _isSelfOrChild(entity: any): boolean;\n    _listenForReflowEvents(target: any, onOff: any): void;\n    _onElementOrLayoutComponentAdd(entity: any): void;\n    _onElementOrLayoutComponentRemove(entity: any): void;\n    _onChildInsert(child: any): void;\n    _onChildRemove(child: any): void;\n    _scheduleReflow(): void;\n    reflow(): void;\n    _isPerformingReflow: boolean;\n    onRemove(): void;\n}\n\ndeclare class LayoutChildComponentData {\n    enabled: boolean;\n}\n\n/**\n * Manages creation of {@link LayoutChildComponent}s.\n *\n * @augments ComponentSystem\n */\ndeclare class LayoutChildComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof LayoutChildComponent;\n    DataType: typeof LayoutChildComponentData;\n    schema: string[];\n    initializeComponentData(component: any, data: any, properties: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n}\n\n\n\n/** @typedef {import(\'../../entity.js\').Entity} Entity */\n/** @typedef {import(\'./system.js\').LayoutChildComponentSystem} LayoutChildComponentSystem */\n/**\n * A LayoutChildComponent enables the Entity to control the sizing applied to it by its parent\n * {@link LayoutGroupComponent}.\n *\n * @augments Component\n */\ndeclare class LayoutChildComponent extends Component {\n    /**\n     * Create a new LayoutChildComponent.\n     *\n     * @param {LayoutChildComponentSystem} system - The ComponentSystem that created this\n     * Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: LayoutChildComponentSystem, entity: Entity);\n    /** @private */\n    private _minWidth;\n    /** @private */\n    private _minHeight;\n    /** @private */\n    private _maxWidth;\n    /** @private */\n    private _maxHeight;\n    /** @private */\n    private _fitWidthProportion;\n    /** @private */\n    private _fitHeightProportion;\n    /** @private */\n    private _excludeFromLayout;\n    /**\n     * The minimum width the element should be rendered at.\n     *\n     * @type {number}\n     */\n    set minWidth(arg: number);\n    get minWidth(): number;\n    /**\n     * The minimum height the element should be rendered at.\n     *\n     * @type {number}\n     */\n    set minHeight(arg: number);\n    get minHeight(): number;\n    /**\n     * The maximum width the element should be rendered at.\n     *\n     * @type {number|null}\n     */\n    set maxWidth(arg: any);\n    get maxWidth(): any;\n    /**\n     * The maximum height the element should be rendered at.\n     *\n     * @type {number|null}\n     */\n    set maxHeight(arg: any);\n    get maxHeight(): any;\n    /**\n     * The amount of additional horizontal space that the element should take up, if necessary to\n     * satisfy a Stretch/Shrink fitting calculation. This is specified as a proportion, taking into\n     * account the proportion values of other siblings.\n     *\n     * @type {number}\n     */\n    set fitWidthProportion(arg: number);\n    get fitWidthProportion(): number;\n    /**\n     * The amount of additional vertical space that the element should take up, if necessary to\n     * satisfy a Stretch/Shrink fitting calculation. This is specified as a proportion, taking into\n     * account the proportion values of other siblings.\n     *\n     * @type {number}\n     */\n    set fitHeightProportion(arg: number);\n    get fitHeightProportion(): number;\n    /**\n     * If set to true, the child will be excluded from all layout calculations.\n     *\n     * @type {boolean}\n     */\n    set excludeFromLayout(arg: boolean);\n    get excludeFromLayout(): boolean;\n}\n\ndeclare class CollisionComponentData {\n    enabled: boolean;\n    type: string;\n    halfExtents: Vec3;\n    radius: number;\n    axis: number;\n    height: number;\n    asset: any;\n    renderAsset: any;\n    shape: any;\n    model: any;\n    render: any;\n    initialized: boolean;\n}\n\n/**\n * Manages creation of {@link CollisionComponent}s.\n *\n * @augments ComponentSystem\n */\ndeclare class CollisionComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof CollisionComponent;\n    DataType: typeof CollisionComponentData;\n    schema: string[];\n    implementations: {};\n    _triMeshCache: {};\n    initializeComponentData(component: any, _data: any, properties: any): void;\n    _createImplementation(type: any): any;\n    _getImplementation(entity: any): any;\n    cloneComponent(entity: any, clone: any): any;\n    onBeforeRemove(entity: any, component: any): void;\n    onRemove(entity: any, data: any): void;\n    updateCompoundChildTransform(entity: any): void;\n    _removeCompoundChild(collision: any, shape: any): void;\n    onTransformChanged(component: any, position: any, rotation: any, scale: any): void;\n    changeType(component: any, previousType: any, newType: any): void;\n    recreatePhysicalShapes(component: any): void;\n    _calculateNodeRelativeTransform(node: any, relative: any): void;\n    _getNodeScaling(node: any): any;\n    _getNodeTransform(node: any, relative: any): any;\n}\n\n\n\n\n\n/** @typedef {import(\'../../../math/vec3.js\').Vec3} Vec3 */\n/** @typedef {import(\'../../../scene/model.js\').Model} Model */\n/** @typedef {import(\'../../entity.js\').Entity} Entity */\n/** @typedef {import(\'./system.js\').CollisionComponentSystem} CollisionComponentSystem */\n/**\n * A collision volume. Use this in conjunction with a {@link RigidBodyComponent} to make a\n * collision volume that can be simulated using the physics engine.\n *\n * If the {@link Entity} does not have a {@link RigidBodyComponent} then this collision volume will\n * act as a trigger volume. When an entity with a dynamic or kinematic body enters or leaves an\n * entity with a trigger volume, both entities will receive trigger events.\n *\n * The following table shows all the events that can be fired between two Entities:\n *\n * |                                       | Rigid Body (Static)                                                   | Rigid Body (Dynamic or Kinematic)                                     | Trigger Volume                                      |\n * | ------------------------------------- | --------------------------------------------------------------------- | --------------------------------------------------------------------- | --------------------------------------------------- |\n * | **Rigid Body (Static)**               |                                                                       | <ul><li>contact</li><li>collisionstart</li><li>collisionend</li></ul> |                                                     |\n * | **Rigid Body (Dynamic or Kinematic)** | <ul><li>contact</li><li>collisionstart</li><li>collisionend</li></ul> | <ul><li>contact</li><li>collisionstart</li><li>collisionend</li></ul> | <ul><li>triggerenter</li><li>triggerleave</li></ul> |\n * | **Trigger Volume**                    |                                                                       | <ul><li>triggerenter</li><li>triggerleave</li></ul>                   |                                                     |\n *\n * @property {string} type The type of the collision volume. Can be:\n *\n * - "box": A box-shaped collision volume.\n * - "capsule": A capsule-shaped collision volume.\n * - "compound": A compound shape. Any descendant entities with a collision component\n * of type box, capsule, cone, cylinder or sphere will be combined into a single, rigid\n * shape.\n * - "cone": A cone-shaped collision volume.\n * - "cylinder": A cylinder-shaped collision volume.\n * - "mesh": A collision volume that uses a model asset as its shape.\n * - "sphere": A sphere-shaped collision volume.\n *\n * Defaults to "box".\n * @property {Vec3} halfExtents The half-extents of the box-shaped collision volume in the x, y and\n * z axes. Defaults to [0.5, 0.5, 0.5].\n * @property {number} radius The radius of the sphere, capsule, cylinder or cone-shaped collision\n * volumes. Defaults to 0.5.\n * @property {number} axis The local space axis with which the capsule, cylinder or cone-shaped\n * collision volume\'s length is aligned. 0 for X, 1 for Y and 2 for Z. Defaults to 1 (Y-axis).\n * @property {number} height The total height of the capsule, cylinder or cone-shaped collision\n * volume from tip to tip. Defaults to 2.\n * @property {Asset|number} asset The asset for the model of the mesh collision volume - can also\n * be an asset id. Defaults to null.\n * @property {Asset|number} renderAsset The render asset of the mesh collision volume - can also be\n * an asset id. Defaults to null. If not set then the asset property will be checked instead.\n * @property {Model} model The model that is added to the scene graph for the mesh collision\n * volume.\n * @augments Component\n */\ndeclare class CollisionComponent extends Component {\n    /**\n     * Create a new CollisionComponent.\n     *\n     * @param {CollisionComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: CollisionComponentSystem, entity: Entity);\n\n    set axis(arg: number);\n    get axis(): number;\n\n    set halfExtents(arg: Vec3);\n    get halfExtents(): Vec3;\n\n    set height(arg: number);\n    get height(): number;\n\n    set model(arg: Model|null);\n    get model(): Model|null;\n\n    set radius(arg: number);\n    get radius(): number;\n\n    set type(arg: string);\n    get type(): string;\n\n    /** @private */\n    private _compoundParent;\n    /**\n     * @event\n     * @name CollisionComponent#contact\n     * @description The \'contact\' event is fired when a contact occurs between two rigid bodies.\n     * @param {ContactResult} result - Details of the contact between the two rigid bodies.\n     */\n    /**\n     * @event\n     * @name CollisionComponent#collisionstart\n     * @description The \'collisionstart\' event is fired when two rigid bodies start touching.\n     * @param {ContactResult} result - Details of the contact between the two Entities.\n     */\n    /**\n     * @event\n     * @name CollisionComponent#collisionend\n     * @description The \'collisionend\' event is fired two rigid-bodies stop touching.\n     * @param {Entity} other - The {@link Entity} that stopped touching this collision volume.\n     */\n    /**\n     * @event\n     * @name CollisionComponent#triggerenter\n     * @description The \'triggerenter\' event is fired when a rigid body enters a trigger volume.\n     * a {@link RigidBodyComponent} attached.\n     * @param {Entity} other - The {@link Entity} that entered this collision volume.\n     */\n    /**\n     * @event\n     * @name CollisionComponent#triggerleave\n     * @description The \'triggerleave\' event is fired when a rigid body exits a trigger volume.\n     * a {@link RigidBodyComponent} attached.\n     * @param {Entity} other - The {@link Entity} that exited this collision volume.\n     */\n    /**\n     * @param {string} name - Property name.\n     * @param {*} oldValue - Previous value of the property.\n     * @param {*} newValue - New value of the property.\n     * @private\n     */\n    private onSetType;\n    /**\n     * @param {string} name - Property name.\n     * @param {*} oldValue - Previous value of the property.\n     * @param {*} newValue - New value of the property.\n     * @private\n     */\n    private onSetHalfExtents;\n    /**\n     * @param {string} name - Property name.\n     * @param {*} oldValue - Previous value of the property.\n     * @param {*} newValue - New value of the property.\n     * @private\n     */\n    private onSetRadius;\n    /**\n     * @param {string} name - Property name.\n     * @param {*} oldValue - Previous value of the property.\n     * @param {*} newValue - New value of the property.\n     * @private\n     */\n    private onSetHeight;\n    /**\n     * @param {string} name - Property name.\n     * @param {*} oldValue - Previous value of the property.\n     * @param {*} newValue - New value of the property.\n     * @private\n     */\n    private onSetAxis;\n    /**\n     * @param {string} name - Property name.\n     * @param {*} oldValue - Previous value of the property.\n     * @param {*} newValue - New value of the property.\n     * @private\n     */\n    private onSetAsset;\n    /**\n     * @param {string} name - Property name.\n     * @param {*} oldValue - Previous value of the property.\n     * @param {*} newValue - New value of the property.\n     * @private\n     */\n    private onSetRenderAsset;\n    /**\n     * @param {string} name - Property name.\n     * @param {*} oldValue - Previous value of the property.\n     * @param {*} newValue - New value of the property.\n     * @private\n     */\n    private onSetModel;\n    /**\n     * @param {string} name - Property name.\n     * @param {*} oldValue - Previous value of the property.\n     * @param {*} newValue - New value of the property.\n     * @private\n     */\n    private onSetRender;\n    /**\n     * @param {Asset} asset - Asset that was removed.\n     * @private\n     */\n    private onAssetRemoved;\n    asset: any;\n    /**\n     * @param {Asset} asset - Asset that was removed.\n     * @private\n     */\n    private onRenderAssetRemoved;\n    renderAsset: any;\n    /**\n     * @param {*} shape - Ammo shape.\n     * @returns {number|null} The shape\'s index in the child array of the compound shape.\n     * @private\n     */\n    private _getCompoundChildShapeIndex;\n    /**\n     * @param {GraphNode} parent - The parent node.\n     * @private\n     */\n    private _onInsert;\n    /** @private */\n    private _updateCompound;\n    /** @private */\n    private onBeforeRemove;\n}\n\ndeclare class ButtonComponentData {\n    enabled: boolean;\n    active: boolean;\n    imageEntity: any;\n    hitPadding: Vec4;\n    transitionMode: number;\n    hoverTint: Color;\n    pressedTint: Color;\n    inactiveTint: Color;\n    fadeDuration: number;\n    hoverSpriteAsset: any;\n    hoverSpriteFrame: number;\n    pressedSpriteAsset: any;\n    pressedSpriteFrame: number;\n    inactiveSpriteAsset: any;\n    inactiveSpriteFrame: number;\n}\n\n/**\n * Manages creation of {@link ButtonComponent}s.\n *\n * @augments ComponentSystem\n */\ndeclare class ButtonComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof ButtonComponent;\n    DataType: typeof ButtonComponentData;\n    schema: (string | {\n        name: string;\n        type: string;\n    })[];\n    initializeComponentData(component: any, data: any, properties: any): void;\n    onUpdate(dt: any): void;\n    _onRemoveComponent(entity: any, component: any): void;\n}\n\n\n\n\n\n/**\n * A ButtonComponent enables a group of entities to behave like a button, with different visual\n * states for hover and press interactions.\n *\n * @property {boolean} active If set to false, the button will be visible but will not respond to hover or touch interactions.\n * @property {Entity} imageEntity A reference to the entity to be used as the button background. The entity must have an ImageElement component.\n * @property {Vec4} hitPadding Padding to be used in hit-test calculations. Can be used to expand the bounding box so that the button is easier to tap.\n * @property {number} transitionMode Controls how the button responds when the user hovers over it/presses it.\n * @property {Color} hoverTint Color to be used on the button image when the user hovers over it.\n * @property {Color} pressedTint Color to be used on the button image when the user presses it.\n * @property {Color} inactiveTint Color to be used on the button image when the button is not interactive.\n * @property {number} fadeDuration Duration to be used when fading between tints, in milliseconds.\n * @property {Asset} hoverSpriteAsset Sprite to be used as the button image when the user hovers over it.\n * @property {number} hoverSpriteFrame Frame to be used from the hover sprite.\n * @property {Asset} pressedSpriteAsset Sprite to be used as the button image when the user presses it.\n * @property {number} pressedSpriteFrame Frame to be used from the pressed sprite.\n * @property {Asset} inactiveSpriteAsset Sprite to be used as the button image when the button is not interactive.\n * @property {number} inactiveSpriteFrame Frame to be used from the inactive sprite.\n * @augments Component\n */\ndeclare class ButtonComponent extends Component {\n    /**\n     * Create a new ButtonComponent instance.\n     *\n     * @param {ButtonComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: ButtonComponentSystem, entity: Entity);\n\n    set active(arg: boolean);\n    get active(): boolean;\n\n    set fadeDuration(arg: number);\n    get fadeDuration(): number;\n\n    set hitPadding(arg: Vec4);\n    get hitPadding(): Vec4;\n\n    set hoverSpriteAsset(arg: Asset);\n    get hoverSpriteAsset(): Asset;\n\n    set hoverSpriteFrame(arg: number);\n    get hoverSpriteFrame(): number;\n\n    set hoverTint(arg: Color);\n    get hoverTint(): Color;\n\n    set imageEntity(arg: Entity);\n    get imageEntity(): Entity;\n\n    set inactiveSpriteAsset(arg: Asset);\n    get inactiveSpriteAsset(): Asset;\n\n    set inactiveSpriteFrame(arg: number);\n    get inactiveSpriteFrame(): number;\n\n    set inactiveTint(arg: Color);\n    get inactiveTint(): Color;\n\n    set pressedSpriteAsset(arg: Asset);\n    get pressedSpriteAsset(): Asset;\n\n    set pressedSpriteFrame(arg: number);\n    get pressedSpriteFrame(): number;\n\n    set pressedTint(arg: Color);\n    get pressedTint(): Color;\n\n    set transitionMode(arg: number);\n    get transitionMode(): number;\n\n    _visualState: string;\n    _isHovering: boolean;\n    _hoveringCounter: number;\n    _isPressed: boolean;\n    _defaultTint: Color;\n    _defaultSpriteAsset: any;\n    _defaultSpriteFrame: number;\n    _imageReference: EntityReference;\n    _toggleLifecycleListeners(onOrOff: any, system: any): void;\n    _onSetActive(name: any, oldValue: any, newValue: any): void;\n    _onSetTransitionMode(name: any, oldValue: any, newValue: any): void;\n    _onSetTransitionValue(name: any, oldValue: any, newValue: any): void;\n    _onElementComponentRemove(entity: any): void;\n    _onElementComponentAdd(entity: any): void;\n    _onImageElementLose(): void;\n    _onImageElementGain(): void;\n    _toggleHitElementListeners(onOrOff: any): void;\n    _hasHitElementListeners: boolean;\n    _storeDefaultVisualState(): void;\n    _storeDefaultColor(color: any): void;\n    _storeDefaultOpacity(opacity: any): void;\n    _storeDefaultSpriteAsset(spriteAsset: any): void;\n    _storeDefaultSpriteFrame(spriteFrame: any): void;\n    _onSetColor(color: any): void;\n    _onSetOpacity(opacity: any): void;\n    _onSetSpriteAsset(spriteAsset: any): void;\n    _onSetSpriteFrame(spriteFrame: any): void;\n    _onMouseEnter(event: any): void;\n    _onMouseLeave(event: any): void;\n    _onMouseDown(event: any): void;\n    _onMouseUp(event: any): void;\n    _onTouchStart(event: any): void;\n    _onTouchEnd(event: any): void;\n    _onTouchLeave(event: any): void;\n    _onTouchCancel(event: any): void;\n    _onSelectStart(event: any): void;\n    _onSelectEnd(event: any): void;\n    _onSelectEnter(event: any): void;\n    _onSelectLeave(event: any): void;\n    _onClick(event: any): void;\n    _fireIfActive(name: any, event: any): void;\n    _updateVisualState(force: any): void;\n    _forceReapplyVisualState(): void;\n    _resetToDefaultVisualState(transitionMode: any): void;\n    _determineVisualState(): string;\n    _applySprite(spriteAsset: any, spriteFrame: any): void;\n    _isApplyingSprite: boolean;\n    _applyTint(tintColor: any): void;\n    _applyTintImmediately(tintColor: any): void;\n    _isApplyingTint: boolean;\n    _applyTintWithTween(tintColor: any): void;\n    _tweenInfo: {\n        startTime: number;\n        from: Color;\n        to: any;\n        lerpColor: Color;\n    };\n    _updateTintTween(): void;\n    _cancelTween(): void;\n    onUpdate(): void;\n    onRemove(): void;\n}\n\ndeclare class AudioListenerComponentData {\n    enabled: boolean;\n}\n\n\n\n/**\n * Component System for adding and removing {@link AudioComponent} objects to Entities.\n *\n * @augments ComponentSystem\n */\ndeclare class AudioListenerComponentSystem extends ComponentSystem {\n    /**\n     * Create a new AudioListenerComponentSystem instance.\n     *\n     * @param {Application} app - The application managing this system.\n     * @param {SoundManager} manager - A sound manager instance.\n     */\n    constructor(app: Application, manager: SoundManager);\n    id: string;\n    ComponentType: typeof AudioListenerComponent;\n    DataType: typeof AudioListenerComponentData;\n    schema: string[];\n    manager: SoundManager;\n    current: any;\n    initializeComponentData(component: any, data: any, properties: any): void;\n    onUpdate(dt: any): void;\n}\n\n\n\n/** @typedef {import(\'../../entity.js\').Entity} Entity */\n/** @typedef {import(\'./system.js\').AudioListenerComponentSystem} AudioListenerComponentSystem */\n/**\n * Represents the audio listener in the 3D world, so that 3D positioned audio sources are heard\n * correctly.\n *\n * @augments Component\n */\ndeclare class AudioListenerComponent extends Component {\n    /**\n     * Create a new AudioListenerComponent instance.\n     *\n     * @param {AudioListenerComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: AudioListenerComponentSystem, entity: Entity);\n    setCurrentListener(): void;\n}\n\ndeclare class AnimationComponentData {\n    assets: any[];\n    speed: number;\n    loop: boolean;\n    activate: boolean;\n    enabled: boolean;\n    animations: {};\n    model: any;\n    prevAnim: any;\n    currAnim: any;\n    blending: boolean;\n    blend: number;\n    blendSpeed: number;\n    playing: boolean;\n    skeleton: any;\n    fromSkel: any;\n    toSkel: any;\n    animEvaluator: any;\n}\n\n/**\n * The AnimationComponentSystem manages creating and deleting AnimationComponents.\n *\n * @augments ComponentSystem\n */\ndeclare class AnimationComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof AnimationComponent;\n    DataType: typeof AnimationComponentData;\n    schema: string[];\n    initializeComponentData(component: any, data: any, properties: any): void;\n    cloneComponent(entity: any, clone: any): any;\n    onBeforeRemove(entity: any, component: any): void;\n    onUpdate(dt: any): void;\n}\n\n\n\n\n/** @typedef {import(\'../../../scene/model.js\').Model} Model */\n/** @typedef {import(\'../../entity.js\').Entity} Entity */\n/** @typedef {import(\'./system.js\').AnimationComponentSystem} AnimationComponentSystem */\n/**\n * The Animation Component allows an Entity to playback animations on models.\n *\n * @property {number} speed Speed multiplier for animation play back speed. 1.0 is playback at normal speed, 0.0 pauses the animation.\n * @property {boolean} loop If true the animation will restart from the beginning when it reaches the end.\n * @property {boolean} activate If true the first animation asset will begin playing when the scene is loaded.\n * @property {Asset[]|number[]} assets The array of animation assets - can also be an array of asset ids.\n * @property {Skeleton|null} skeleton Get the skeleton for the current model; unless model is from glTF/glb, then skeleton is null. [read only]\n * @property {object<string, Animation>} animations Get or Set dictionary of animations by name.\n * @augments Component\n */\ndeclare class AnimationComponent extends Component {\n    /**\n     * Create a new AnimationComponent instance.\n     *\n     * @param {AnimationComponentSystem} system - The {@link ComponentSystem} that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: AnimationComponentSystem, entity: Entity);\n\n    set activate(arg: boolean);\n    get activate(): boolean;\n\n    set assets(arg: any[]);\n    get assets(): any[];\n\n    set loop(arg: boolean);\n    get loop(): boolean;\n\n    set skeleton(arg: any);\n    get skeleton(): any;\n\n    set speed(arg: number);\n    get speed(): number;\n\n    /**\n     * @type {Object.<string, string>}\n     * @ignore\n     */\n    animationsIndex: {\n        [x: string]: string;\n    };\n    /**\n     * Get or Set the current time position (in seconds) of the animation.\n     *\n     * @type {number}\n     */\n    set currentTime(arg: any);\n    get currentTime(): any;\n    /**\n     * Get the duration in seconds of the current animation.\n     *\n     * @type {number}\n     */\n    get duration(): number;\n    /**\n     * Start playing an animation.\n     *\n     * @param {string} name - The name of the animation asset to begin playing.\n     * @param {number} [blendTime] - The time in seconds to blend from the current\n     * animation state to the start of the animation being set. Defaults to 0.\n     */\n    play(name: string, blendTime?: number): void;\n    /**\n     * Return an animation.\n     *\n     * @param {string} name - The name of the animation asset.\n     * @returns {Animation} An Animation.\n     */\n    getAnimation(name: string): Animation;\n    /**\n     * Set the model driven by this animation component.\n     *\n     * @param {Model} model - The model to set.\n     * @ignore\n     */\n    setModel(model: Model): void;\n    /** @private */\n    private _resetAnimationController;\n    /** @private */\n    private _createAnimationController;\n    /**\n     * @param {number[]} ids - Array of animation asset ids.\n     * @private\n     */\n    private loadAnimationAssets;\n    animations: any;\n    /**\n     * Handle asset change events.\n     *\n     * @param {Asset} asset - The asset that changed.\n     * @param {string} attribute - The name of the asset attribute that changed. Can be \'data\',\n     * \'file\', \'resource\' or \'resources\'.\n     * @param {*} newValue - The new value of the specified asset property.\n     * @param {*} oldValue - The old value of the specified asset property.\n     * @private\n     */\n    private onAssetChanged;\n    /**\n     * @param {Asset} asset - The asset that was removed.\n     * @private\n     */\n    private onAssetRemoved;\n    /** @private */\n    private _stopCurrentAnimation;\n    onSetAnimations(name: any, oldValue: any, newValue: any): void;\n    onSetAssets(name: any, oldValue: any, newValue: any): void;\n    onSetLoop(name: any, oldValue: any, newValue: any): void;\n    onBeforeRemove(): void;\n}\n\ndeclare class AnimComponentData {\n    enabled: boolean;\n}\n\n/**\n * The AnimComponentSystem manages creating and deleting AnimComponents.\n *\n * @augments ComponentSystem\n */\ndeclare class AnimComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof AnimComponent;\n    DataType: typeof AnimComponentData;\n    schema: string[];\n    initializeComponentData(component: any, data: any, properties: any): void;\n    onAnimationUpdate(dt: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    onBeforeRemove(entity: any, component: any): void;\n}\n\n\n\n/** @typedef {import(\'./component.js\').AnimComponent} AnimComponent */\n/** @typedef {import(\'../../../asset/asset.js\').Asset} Asset */\n/**\n * The Anim Component Layer allows managers a single layer of the animation state graph.\n */\ndeclare class AnimComponentLayer {\n    /**\n     * Create a new AnimComponentLayer instance.\n     *\n     * @param {string} name - The name of the layer.\n     * @param {object} controller - The controller to manage this layers animations.\n     * @param {AnimComponent} component - The component that this layer is a member of.\n     * @param {number} [weight] - The weight of this layer. Defaults to 1.\n     * @param {string} [blendType] - The blend type of this layer. Defaults to {@link ANIM_LAYER_OVERWRITE}.\n     * @param {boolean} [normalizedWeight] - Whether the weight of this layer should be normalized using the total weight of all layers.\n     */\n    constructor(name: string, controller: object, component: AnimComponent, weight?: number, blendType?: string, normalizedWeight?: boolean);\n    _name: string;\n    _controller: any;\n    _component: AnimComponent;\n    _weight: number;\n    _blendType: string;\n    _normalizedWeight: boolean;\n    _mask: any;\n    _blendTime: number;\n    _blendTimeElapsed: number;\n    _startingWeight: number;\n    _targetWeight: number;\n    /**\n     * Returns the name of the layer.\n     *\n     * @type {string}\n     */\n    get name(): string;\n    /**\n     * Whether this layer is currently playing.\n     *\n     * @type {string}\n     */\n    set playing(arg: any);\n    get playing(): any;\n    /**\n     * Returns true if a state graph has been loaded and all states in the graph have been assigned\n     * animation tracks.\n     *\n     * @type {string}\n     */\n    get playable(): string;\n    /**\n     * Returns the currently active state name.\n     *\n     * @type {string}\n     */\n    get activeState(): string;\n    /**\n     * Returns the previously active state name.\n     *\n     * @type {string}\n     */\n    get previousState(): string;\n    /**\n     * Returns the currently active states progress as a value normalized by the states animation\n     * duration. Looped animations will return values greater than 1.\n     *\n     * @type {number}\n     */\n    get activeStateProgress(): number;\n    /**\n     * Returns the currently active states duration.\n     *\n     * @type {number}\n     */\n    get activeStateDuration(): number;\n    /**\n     * The active states time in seconds.\n     *\n     * @type {number}\n     */\n    set activeStateCurrentTime(arg: any);\n    get activeStateCurrentTime(): any;\n    /**\n     * Returns whether the anim component layer is currently transitioning between states.\n     *\n     * @type {boolean}\n     */\n    get transitioning(): boolean;\n    /**\n     * If the anim component layer is currently transitioning between states, returns the progress.\n     * Otherwise returns null.\n     *\n     * @type {number|null}\n     */\n    get transitionProgress(): number;\n    /**\n     * Lists all available states in this layers state graph.\n     *\n     * @type {string[]}\n     */\n    get states(): string[];\n    /**\n     * The blending weight of this layer. Used when calculating the value of properties that are\n     * animated by more than one layer.\n     *\n     * @type {number}\n     */\n    set weight(arg: number);\n    get weight(): number;\n    set blendType(arg: string);\n    get blendType(): string;\n    /**\n     * A mask of bones which should be animated or ignored by this layer.\n     *\n     * @type {object}\n     * @example\n     * entity.anim.baseLayer.mask = {\n     *     // include the spine of the current model and all of its children\n     *     "path/to/spine": {\n     *         children: true\n     *     },\n     *     // include the hip of the current model but not all of its children\n     *     "path/to/hip": true\n     * };\n     */\n    set mask(arg: any);\n    get mask(): any;\n    /**\n     * Start playing the animation in the current state.\n     *\n     * @param {string} [name] - If provided, will begin playing from the start of the state with\n     * this name.\n     */\n    play(name?: string): void;\n    /**\n     * Pause the animation in the current state.\n     */\n    pause(): void;\n    /**\n     * Reset the animation component to its initial state, including all parameters. The system\n     * will be paused.\n     */\n    reset(): void;\n    /**\n     * Rebind any animations in the layer to the currently present components and model of the anim\n     * components entity.\n     */\n    rebind(): void;\n    update(dt: any): void;\n    /**\n     * Blend from the current weight value to the provided weight value over a given amount of time.\n     *\n     * @param {number} weight - The new weight value to blend to.\n     * @param {number} time - The duration of the blend in seconds.\n     */\n    blendToWeight(weight: number, time: number): void;\n    /**\n     * Add a mask to this layer.\n     *\n     * @param {object} [mask] - The mask to assign to the layer. If not provided the current mask\n     * in the layer will be removed.\n     * @example\n     * entity.anim.baseLayer.assignMask({\n     *     // include the spine of the current model and all of its children\n     *     "path/to/spine": {\n     *         children: true\n     *     },\n     *     // include the hip of the current model but not all of its children\n     *     "path/to/hip": true\n     * });\n     * @ignore\n     */\n    assignMask(mask?: object): void;\n    /**\n     * Assigns an animation track to a state or blend tree node in the current graph. If a state\n     * for the given nodePath doesn\'t exist, it will be created. If all states nodes are linked and\n     * the {@link AnimComponent#activate} value was set to true then the component will begin\n     * playing.\n     *\n     * @param {string} nodePath - Either the state name or the path to a blend tree node that this\n     * animation should be associated with. Each section of a blend tree path is split using a\n     * period (`.`) therefore state names should not include this character (e.g "MyStateName" or\n     * "MyStateName.BlendTreeNode").\n     * @param {object} animTrack - The animation track that will be assigned to this state and\n     * played whenever this state is active.\n     * @param {number} [speed] - Update the speed of the state you are assigning an animation to.\n     * Defaults to 1.\n     * @param {boolean} [loop] - Update the loop property of the state you are assigning an\n     * animation to. Defaults to true.\n     */\n    assignAnimation(nodePath: string, animTrack: object, speed?: number, loop?: boolean): void;\n    /**\n     * Removes animations from a node in the loaded state graph.\n     *\n     * @param {string} nodeName - The name of the node that should have its animation tracks removed.\n     */\n    removeNodeAnimations(nodeName: string): void;\n    /**\n     * Returns the asset that is associated with the given state.\n     *\n     * @param {string} stateName - The name of the state to get the asset for.\n     * @returns {Asset} The asset associated with the given state.\n     */\n    getAnimationAsset(stateName: string): Asset;\n    /**\n     * Transition to any state in the current layers graph. Transitions can be instant or take an\n     * optional blend time.\n     *\n     * @param {string} to - The state that this transition will transition to.\n     * @param {number} [time] - The duration of the transition in seconds. Defaults to 0.\n     * @param {number} [transitionOffset] - If provided, the destination state will begin playing\n     * its animation at this time. Given in normalized time, based on the states duration & must be\n     * between 0 and 1. Defaults to null.\n     */\n    transition(to: string, time?: number, transitionOffset?: number): void;\n}\n\n\n/** @typedef {import(\'./system.js\').AnimComponentSystem} AnimComponentSystem */\n/**\n * The Anim Component allows an Entity to playback animations on models and entity properties.\n *\n * @augments Component\n */\ndeclare class AnimComponent extends Component {\n    /**\n     * Create a new AnimComponent instance.\n     *\n     * @param {AnimComponentSystem} system - The {@link ComponentSystem} that created this\n     * Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: AnimComponentSystem, entity: Entity);\n    _stateGraphAsset: any;\n    _animationAssets: {};\n    _speed: number;\n    _activate: boolean;\n    _playing: boolean;\n    _rootBone: any;\n    _stateGraph: any;\n    _layers: any[];\n    _layerIndices: {};\n    _parameters: {};\n    _targets: {};\n    _consumedTriggers: Set<any>;\n    _normalizeWeights: boolean;\n    set stateGraphAsset(arg: any);\n    get stateGraphAsset(): any;\n    /**\n     * If true the animation component will normalize the weights of its layers by their sum total.\n     *\n     * @type {boolean}\n     */\n    set normalizeWeights(arg: boolean);\n    get normalizeWeights(): boolean;\n    set animationAssets(arg: {});\n    get animationAssets(): {};\n    /**\n     * Speed multiplier for animation play back speed. 1.0 is playback at normal speed, 0.0 pauses\n     * the animation.\n     *\n     * @type {number}\n     */\n    set speed(arg: number);\n    get speed(): number;\n    /**\n     * If true the first animation will begin playing when the scene is loaded.\n     *\n     * @type {boolean}\n     */\n    set activate(arg: boolean);\n    get activate(): boolean;\n    /**\n     * Plays or pauses all animations in the component.\n     *\n     * @type {boolean}\n     */\n    set playing(arg: boolean);\n    get playing(): boolean;\n    /**\n     * The entity that this anim component should use as the root of the animation hierarchy.\n     *\n     * @type {Entity}\n     */\n    set rootBone(arg: any);\n    get rootBone(): any;\n    set stateGraph(arg: any);\n    get stateGraph(): any;\n    /**\n     * Returns the animation layers available in this anim component.\n     *\n     * @type {AnimComponentLayer[]}\n     */\n    get layers(): AnimComponentLayer[];\n    set layerIndices(arg: {});\n    get layerIndices(): {};\n    set parameters(arg: {});\n    get parameters(): {};\n    set targets(arg: {});\n    get targets(): {};\n    /**\n     * Returns whether all component layers are currently playable.\n     *\n     * @type {boolean}\n     */\n    get playable(): boolean;\n    /**\n     * Returns the base layer of the state graph.\n     *\n     * @type {AnimComponentLayer|null}\n     */\n    get baseLayer(): AnimComponentLayer;\n    _onStateGraphAssetChangeEvent(asset: any): void;\n    dirtifyTargets(): void;\n    _addLayer({ name, states, transitions, weight, mask, blendType }: {\n        name: any;\n        states: any;\n        transitions: any;\n        weight: any;\n        mask: any;\n        blendType: any;\n    }): any;\n    /**\n     * Adds a new anim component layer to the anim component.\n     *\n     * @param {string} name - The name of the layer to create.\n     * @param {number} [weight] - The blending weight of the layer. Defaults to 1.\n     * @param {object[]} [mask] - A list of paths to bones in the model which should be animated in\n     * this layer. If omitted the full model is used. Defaults to null.\n     * @param {string} [blendType] - Defines how properties animated by this layer blend with\n     * animations of those properties in previous layers. Defaults to pc.ANIM_LAYER_OVERWRITE.\n     * @returns {AnimComponentLayer} The created anim component layer.\n     */\n    addLayer(name: string, weight?: number, mask?: object[], blendType?: string): AnimComponentLayer;\n    /**\n     * Initializes component animation controllers using the provided state graph.\n     *\n     * @param {object} stateGraph - The state graph asset to load into the component. Contains the\n     * states, transitions and parameters used to define a complete animation controller.\n     * @example\n     * entity.anim.loadStateGraph({\n     *     "layers": [\n     *         {\n     *             "name": layerName,\n     *             "states": [\n     *                 {\n     *                     "name": "START",\n     *                     "speed": 1\n     *                 },\n     *                 {\n     *                     "name": "Initial State",\n     *                     "speed": speed,\n     *                     "loop": loop,\n     *                     "defaultState": true\n     *                 }\n     *             ],\n     *             "transitions": [\n     *                 {\n     *                     "from": "START",\n     *                     "to": "Initial State"\n     *                 }\n     *             ]\n     *         }\n     *     ],\n     *     "parameters": {}\n     * });\n     */\n    loadStateGraph(stateGraph: object): void;\n    setupAnimationAssets(): void;\n    loadAnimationAssets(): void;\n    onAnimationAssetLoaded(layerName: any, stateName: any, asset: any): void;\n    /**\n     * Removes all layers from the anim component.\n     */\n    removeStateGraph(): void;\n    /**\n     * Reset all of the components layers and parameters to their initial states. If a layer was\n     * playing before it will continue playing.\n     */\n    reset(): void;\n    unbind(): void;\n    /**\n     * Rebind all of the components layers.\n     */\n    rebind(): void;\n    /**\n     * Finds a {@link AnimComponentLayer} in this component.\n     *\n     * @param {string} name - The name of the anim component layer to find.\n     * @returns {AnimComponentLayer} Layer.\n     */\n    findAnimationLayer(name: string): AnimComponentLayer;\n    addAnimationState(nodeName: any, animTrack: any, speed?: number, loop?: boolean, layerName?: string): void;\n    /**\n     * Associates an animation with a state or blend tree node in the loaded state graph. If all\n     * states are linked and the {@link AnimComponent#activate} value was set to true then the\n     * component will begin playing. If no state graph is loaded, a default state graph will be\n     * created with a single state based on the provided nodePath parameter.\n     *\n     * @param {string} nodePath - Either the state name or the path to a blend tree node that this\n     * animation should be associated with. Each section of a blend tree path is split using a\n     * period (`.`) therefore state names should not include this character (e.g "MyStateName" or\n     * "MyStateName.BlendTreeNode").\n     * @param {object} animTrack - The animation track that will be assigned to this state and\n     * played whenever this state is active.\n     * @param {string} [layerName] - The name of the anim component layer to update. If omitted the\n     * default layer is used. If no state graph has been previously loaded this parameter is\n     * ignored.\n     * @param {number} [speed] - Update the speed of the state you are assigning an animation to.\n     * Defaults to 1.\n     * @param {boolean} [loop] - Update the loop property of the state you are assigning an\n     * animation to. Defaults to true.\n     */\n    assignAnimation(nodePath: string, animTrack: object, layerName?: string, speed?: number, loop?: boolean): void;\n    /**\n     * Removes animations from a node in the loaded state graph.\n     *\n     * @param {string} nodeName - The name of the node that should have its animation tracks removed.\n     * @param {string} [layerName] - The name of the anim component layer to update. If omitted the\n     * default layer is used.\n     */\n    removeNodeAnimations(nodeName: string, layerName?: string): void;\n    getParameterValue(name: any, type: any): any;\n    setParameterValue(name: any, type: any, value: any): void;\n    /**\n     * Returns a float parameter value by name.\n     *\n     * @param {string} name - The name of the float to return the value of.\n     * @returns {number} A float.\n     */\n    getFloat(name: string): number;\n    /**\n     * Sets the value of a float parameter that was defined in the animation components state graph.\n     *\n     * @param {string} name - The name of the parameter to set.\n     * @param {number} value - The new float value to set this parameter to.\n     */\n    setFloat(name: string, value: number): void;\n    /**\n     * Returns an integer parameter value by name.\n     *\n     * @param {string} name - The name of the integer to return the value of.\n     * @returns {number} An integer.\n     */\n    getInteger(name: string): number;\n    /**\n     * Sets the value of an integer parameter that was defined in the animation components state\n     * graph.\n     *\n     * @param {string} name - The name of the parameter to set.\n     * @param {number} value - The new integer value to set this parameter to.\n     */\n    setInteger(name: string, value: number): void;\n    /**\n     * Returns a boolean parameter value by name.\n     *\n     * @param {string} name - The name of the boolean to return the value of.\n     * @returns {boolean} A boolean.\n     */\n    getBoolean(name: string): boolean;\n    /**\n     * Sets the value of a boolean parameter that was defined in the animation components state\n     * graph.\n     *\n     * @param {string} name - The name of the parameter to set.\n     * @param {boolean} value - The new boolean value to set this parameter to.\n     */\n    setBoolean(name: string, value: boolean): void;\n    /**\n     * Returns a trigger parameter value by name.\n     *\n     * @param {string} name - The name of the trigger to return the value of.\n     * @returns {boolean} A boolean.\n     */\n    getTrigger(name: string): boolean;\n    /**\n     * Sets the value of a trigger parameter that was defined in the animation components state\n     * graph to true.\n     *\n     * @param {string} name - The name of the parameter to set.\n     * @param {boolean} [singleFrame] - If true, this trigger will be set back to false at the end\n     * of the animation update. Defaults to false.\n     */\n    setTrigger(name: string, singleFrame?: boolean): void;\n    /**\n     * Resets the value of a trigger parameter that was defined in the animation components state\n     * graph to false.\n     *\n     * @param {string} name - The name of the parameter to set.\n     */\n    resetTrigger(name: string): void;\n    onBeforeRemove(): void;\n    update(dt: any): void;\n    resolveDuplicatedEntityReferenceProperties(oldAnim: any, duplicatedIdsMap: any): void;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The Entity is the core primitive of a PlayCanvas game. Generally speaking an object in your game\n * will consist of an {@link Entity}, and a set of {@link Component}s which are managed by their\n * respective {@link ComponentSystem}s. One of those components maybe a {@link ScriptComponent}\n * which allows you to write custom code to attach to your Entity.\n *\n * The Entity uniquely identifies the object and also provides a transform for position and\n * orientation which it inherits from {@link GraphNode} so can be added into the scene graph. The\n * Component and ComponentSystem provide the logic to give an Entity a specific type of behavior.\n * e.g. the ability to render a model or play a sound. Components are specific to an instance of an\n * Entity and are attached (e.g. `this.entity.model`) ComponentSystems allow access to all Entities\n * and Components and are attached to the {@link Application}.\n *\n * @augments GraphNode\n */\ndeclare class Entity extends GraphNode {\n    /**\n     * Create a new Entity.\n     *\n     * @param {string} [name] - The non-unique name of the entity, default is "Untitled".\n     * @param {Application} [app] - The application the entity belongs to, default is the current application.\n     * @example\n     * var entity = new pc.Entity();\n     *\n     * // Add a Component to the Entity\n     * entity.addComponent("camera", {\n     *     fov: 45,\n     *     nearClip: 1,\n     *     farClip: 10000\n     * });\n     *\n     * // Add the Entity into the scene graph\n     * app.root.addChild(entity);\n     *\n     * // Move the entity\n     * entity.translate(10, 0, 0);\n     *\n     * // Or translate it by setting its position directly\n     * var p = entity.getPosition();\n     * entity.setPosition(p.x + 10, p.y, p.z);\n     *\n     * // Change the entity\'s rotation in local space\n     * var e = entity.getLocalEulerAngles();\n     * entity.setLocalEulerAngles(e.x, e.y + 90, e.z);\n     *\n     * // Or use rotateLocal\n     * entity.rotateLocal(0, 90, 0);\n     */\n    constructor(name?: string, app?: Application);\n    /**\n     * Gets the {@link AnimComponent} attached to this entity.\n     *\n     * @type {AnimComponent|undefined}\n     * @readonly\n     */\n    readonly anim: AnimComponent | undefined;\n    /**\n     * Gets the {@link AnimationComponent} attached to this entity.\n     *\n     * @type {AnimationComponent|undefined}\n     * @readonly\n     */\n    readonly animation: AnimationComponent | undefined;\n    /**\n     * Gets the {@link AudioListenerComponent} attached to this entity.\n     *\n     * @type {AudioListenerComponent|undefined}\n     * @readonly\n     */\n    readonly audiolistener: AudioListenerComponent | undefined;\n    /**\n     * Gets the {@link ButtonComponent} attached to this entity.\n     *\n     * @type {ButtonComponent|undefined}\n     * @readonly\n     */\n    readonly button: ButtonComponent | undefined;\n    /**\n     * Gets the {@link CameraComponent} attached to this entity.\n     *\n     * @type {CameraComponent|undefined}\n     * @readonly\n     */\n    readonly camera: CameraComponent | undefined;\n    /**\n     * Gets the {@link CollisionComponent} attached to this entity.\n     *\n     * @type {CollisionComponent|undefined}\n     * @readonly\n     */\n    readonly collision: CollisionComponent | undefined;\n    /**\n     * Gets the {@link ElementComponent} attached to this entity.\n     *\n     * @type {ElementComponent|undefined}\n     * @readonly\n     */\n    readonly element: ElementComponent | undefined;\n    /**\n     * Gets the {@link LayoutChildComponent} attached to this entity.\n     *\n     * @type {LayoutChildComponent|undefined}\n     * @readonly\n     */\n    readonly layoutchild: LayoutChildComponent | undefined;\n    /**\n     * Gets the {@link LayoutGroupComponent} attached to this entity.\n     *\n     * @type {LayoutGroupComponent|undefined}\n     * @readonly\n     */\n    readonly layoutgroup: LayoutGroupComponent | undefined;\n    /**\n     * Gets the {@link LightComponent} attached to this entity.\n     *\n     * @type {LightComponent|undefined}\n     * @readonly\n     */\n    readonly light: LightComponent | undefined;\n    /**\n     * Gets the {@link ModelComponent} attached to this entity.\n     *\n     * @type {ModelComponent|undefined}\n     * @readonly\n     */\n    readonly model: ModelComponent | undefined;\n    /**\n     * Gets the {@link ParticleSystemComponent} attached to this entity.\n     *\n     * @type {ParticleSystemComponent|undefined}\n     * @readonly\n     */\n    readonly particlesystem: ParticleSystemComponent | undefined;\n    /**\n     * Gets the {@link RenderComponent} attached to this entity.\n     *\n     * @type {RenderComponent|undefined}\n     * @readonly\n     */\n    readonly render: RenderComponent | undefined;\n    /**\n     * Gets the {@link RigidBodyComponent} attached to this entity.\n     *\n     * @type {RigidBodyComponent|undefined}\n     * @readonly\n     */\n    readonly rigidbody: RigidBodyComponent | undefined;\n    /**\n     * Gets the {@link ScreenComponent} attached to this entity.\n     *\n     * @type {ScreenComponent|undefined}\n     * @readonly\n     */\n    readonly screen: ScreenComponent | undefined;\n    /**\n     * Gets the {@link ScriptComponent} attached to this entity.\n     *\n     * @type {ScriptComponent|undefined}\n     * @readonly\n     */\n    readonly script: ScriptComponent | undefined;\n    /**\n     * Gets the {@link ScrollbarComponent} attached to this entity.\n     *\n     * @type {ScrollbarComponent|undefined}\n     * @readonly\n     */\n    readonly scrollbar: ScrollbarComponent | undefined;\n    /**\n     * Gets the {@link ScrollViewComponent} attached to this entity.\n     *\n     * @type {ScrollViewComponent|undefined}\n     * @readonly\n     */\n    readonly scrollview: ScrollViewComponent | undefined;\n    /**\n     * Gets the {@link SoundComponent} attached to this entity.\n     *\n     * @type {SoundComponent|undefined}\n     * @readonly\n     */\n    readonly sound: SoundComponent | undefined;\n    /**\n     * Gets the {@link SpriteComponent} attached to this entity.\n     *\n     * @type {SpriteComponent|undefined}\n     * @readonly\n     */\n    readonly sprite: SpriteComponent | undefined;\n    /**\n     * Component storage.\n     *\n     * @type {Object.<string, Component>}\n     * @ignore\n     */\n    c: {\n        [x: string]: Component;\n    };\n    /**\n     * @type {Application}\n     * @private\n     */\n    private _app;\n    /**\n     * Used by component systems to speed up destruction.\n     *\n     * @type {boolean}\n     * @ignore\n     */\n    _destroying: boolean;\n    /**\n     * @type {string|null}\n     * @private\n     */\n    private _guid;\n    /**\n     * Used to differentiate between the entities of a template root instance, which have it set to\n     * true, and the cloned instance entities (set to false).\n     *\n     * @type {boolean}\n     * @ignore\n     */\n    _template: boolean;\n    /**\n     * Create a new component and add it to the entity. Use this to add functionality to the entity\n     * like rendering a model, playing sounds and so on.\n     *\n     * @param {string} type - The name of the component to add. Valid strings are:\n     *\n     * - "anim" - see {@link AnimComponent}\n     * - "animation" - see {@link AnimationComponent}\n     * - "audiolistener" - see {@link AudioListenerComponent}\n     * - "button" - see {@link ButtonComponent}\n     * - "camera" - see {@link CameraComponent}\n     * - "collision" - see {@link CollisionComponent}\n     * - "element" - see {@link ElementComponent}\n     * - "layoutchild" - see {@link LayoutChildComponent}\n     * - "layoutgroup" - see {@link LayoutGroupComponent}\n     * - "light" - see {@link LightComponent}\n     * - "model" - see {@link ModelComponent}\n     * - "particlesystem" - see {@link ParticleSystemComponent}\n     * - "render" - see {@link RenderComponent}\n     * - "rigidbody" - see {@link RigidBodyComponent}\n     * - "screen" - see {@link ScreenComponent}\n     * - "script" - see {@link ScriptComponent}\n     * - "scrollbar" - see {@link ScrollbarComponent}\n     * - "scrollview" - see {@link ScrollViewComponent}\n     * - "sound" - see {@link SoundComponent}\n     * - "sprite" - see {@link SpriteComponent}\n     *\n     * @param {object} [data] - The initialization data for the specific component type. Refer to\n     * each specific component\'s API reference page for details on valid values for this parameter.\n     * @returns {Component|null} The new Component that was attached to the entity or null if there\n     * was an error.\n     * @example\n     * var entity = new pc.Entity();\n     *\n     * // Add a light component with default properties\n     * entity.addComponent("light");\n     *\n     * // Add a camera component with some specified properties\n     * entity.addComponent("camera", {\n     *     fov: 45,\n     *     clearColor: new pc.Color(1, 0, 0)\n     * });\n     */\n    addComponent(type: string, data?: object): Component | null;\n    /**\n     * Remove a component from the Entity.\n     *\n     * @param {string} type - The name of the Component type.\n     * @example\n     * var entity = new pc.Entity();\n     * entity.addComponent("light"); // add new light component\n     *\n     * entity.removeComponent("light"); // remove light component\n     */\n    removeComponent(type: string): void;\n    /**\n     * Search the entity and all of its descendants for the first component of specified type.\n     *\n     * @param {string} type - The name of the component type to retrieve.\n     * @returns {Component} A component of specified type, if the entity or any of its descendants\n     * has one. Returns undefined otherwise.\n     * @example\n     * // Get the first found light component in the hierarchy tree that starts with this entity\n     * var light = entity.findComponent("light");\n     */\n    findComponent(type: string): Component;\n    /**\n     * Search the entity and all of its descendants for all components of specified type.\n     *\n     * @param {string} type - The name of the component type to retrieve.\n     * @returns {Component[]} All components of specified type in the entity or any of its\n     * descendants. Returns empty array if none found.\n     * @example\n     * // Get all light components in the hierarchy tree that starts with this entity\n     * var lights = entity.findComponents("light");\n     */\n    findComponents(type: string): Component[];\n    /**\n     * Get the GUID value for this Entity.\n     *\n     * @returns {string} The GUID of the Entity.\n     * @ignore\n     */\n    getGuid(): string;\n    /**\n     * Set the GUID value for this Entity. Note that it is unlikely that you should need to change\n     * the GUID value of an Entity at run-time. Doing so will corrupt the graph this Entity is in.\n     *\n     * @param {string} guid - The GUID to assign to the Entity.\n     * @ignore\n     */\n    setGuid(guid: string): void;\n    /** @private */\n    private _onHierarchyStatePostChanged;\n    /**\n     * Find a descendant of this entity with the GUID.\n     *\n     * @param {string} guid - The GUID to search for.\n     * @returns {Entity|null} The entity with the matching GUID or null if no entity is found.\n     */\n    findByGuid(guid: string): Entity | null;\n    /**\n     * Remove all components from the Entity and detach it from the Entity hierarchy. Then\n     * recursively destroy all ancestor Entities.\n     *\n     * @example\n     * var firstChild = this.entity.children[0];\n     * firstChild.destroy(); // delete child, all components and remove from hierarchy\n     */\n    destroy(): void;\n    /**\n     * @param {Object.<string, Entity>} duplicatedIdsMap - A map of original entity GUIDs to cloned\n     * entities.\n     * @returns {Entity} A new Entity which is a deep copy of the original.\n     * @private\n     */\n    private _cloneRecursively;\n}\n\n\n/** @typedef {import(\'./xr-manager.js\').XrManager} XrManager */\n/**\n * Depth Sensing provides depth information which is reconstructed using the underlying AR system.\n * It provides the ability to query depth values (CPU path) or access a depth texture (GPU path).\n * Depth information can be used (not limited to) for reconstructing real world geometry, virtual\n * object placement, occlusion of virtual objects by real world geometry and more.\n *\n * ```javascript\n * // CPU path\n * var depthSensing = app.xr.depthSensing;\n * if (depthSensing.available) {\n *     // get depth in the middle of the screen, value is in meters\n *     var depth = depthSensing.getDepth(depthSensing.width / 2, depthSensing.height / 2);\n * }\n * ```\n *\n * ```javascript\n * // GPU path, attaching texture to material\n * material.diffuseMap = depthSensing.texture;\n * material.setParameter(\'matrix_depth_uv\', depthSensing.uvMatrix.data);\n * material.setParameter(\'depth_raw_to_meters\', depthSensing.rawValueToMeters);\n * material.update();\n *\n * // update UV transformation matrix on depth texture resize\n * depthSensing.on(\'resize\', function () {\n *     material.setParameter(\'matrix_depth_uv\', depthSensing.uvMatrix.data);\n *     material.setParameter(\'depth_raw_to_meters\', depthSensing.rawValueToMeters);\n * });\n * ```\n *\n * ```javascript\n * // GLSL shader to unpack depth texture\n * varying vec2 vUv0;\n *\n * uniform sampler2D texture_depthSensingMap;\n * uniform mat4 matrix_depth_uv;\n * uniform float depth_raw_to_meters;\n *\n * void main(void) {\n *     // transform UVs using depth matrix\n *     vec2 texCoord = (matrix_depth_uv * vec4(vUv0.xy, 0.0, 1.0)).xy;\n *\n *     // get luminance alpha components from depth texture\n *     vec2 packedDepth = texture2D(texture_depthSensingMap, texCoord).ra;\n *\n *     // unpack into single value in millimeters\n *     float depth = dot(packedDepth, vec2(255.0, 256.0 * 255.0)) * depth_raw_to_meters; // m\n *\n *     // normalize: 0m to 8m distance\n *     depth = min(depth / 8.0, 1.0); // 0..1 = 0..8\n *\n *     // paint scene from black to white based on distance\n *     gl_FragColor = vec4(depth, depth, depth, 1.0);\n * }\n * ```\n *\n * @augments EventHandler\n */\ndeclare class XrDepthSensing extends EventHandler {\n    /**\n     * Create a new XrDepthSensing instance.\n     *\n     * @param {XrManager} manager - WebXR Manager.\n     * @hideconstructor\n     */\n    constructor(manager: XrManager);\n    /**\n     * @type {XrManager}\n     * @private\n     */\n    private _manager;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _available;\n    /**\n     * @type {XRCPUDepthInformation|null}\n     * @private\n     */\n    private _depthInfoCpu;\n    /**\n     * @type {XRCPUDepthInformation|null}\n     * @private\n     */\n    private _depthInfoGpu;\n    /**\n     * @type {string|null}\n     * @private\n     */\n    private _usage;\n    /**\n     * @type {string|null}\n     * @private\n     */\n    private _dataFormat;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _matrixDirty;\n    /**\n     * @type {Mat4}\n     * @private\n     */\n    private _matrix;\n    /**\n     * @type {Uint8Array}\n     * @private\n     */\n    private _emptyBuffer;\n    /**\n     * @type {Uint8Array|null}\n     * @private\n     */\n    private _depthBuffer;\n    /**\n     * @type {Texture}\n     * @private\n     */\n    private _texture;\n    /**\n     * @event\n     * @name XrDepthSensing#available\n     * @description Fired when depth sensing data becomes available.\n     */\n    /**\n     * @event\n     * @name XrDepthSensing#unavailable\n     * @description Fired when depth sensing data becomes unavailable.\n     */\n    /**\n     * @event\n     * @name XrDepthSensing#resize\n     * @description Fired when the depth sensing texture been resized. The {@link XrDepthSensing#uvMatrix} needs to be updated for relevant shaders.\n     * @param {number} width - The new width of the depth texture in pixels.\n     * @param {number} height - The new height of the depth texture in pixels.\n     * @example\n     * depthSensing.on(\'resize\', function () {\n     *     material.setParameter(\'matrix_depth_uv\', depthSensing.uvMatrix);\n     * });\n     */\n    /** @private */\n    private _onSessionStart;\n    /** @private */\n    private _onSessionEnd;\n    /** @private */\n    private _updateTexture;\n    /**\n     * @param {*} frame - XRFrame from requestAnimationFrame callback.\n     * @param {*} view - First XRView of viewer XRPose.\n     * @ignore\n     */\n    update(frame: any, view: any): void;\n    /**\n     * Get depth value from depth information in meters. UV is in range of 0..1, with origin in\n     * top-left corner of a texture.\n     *\n     * @param {number} u - U coordinate of pixel in depth texture, which is in range from 0.0 to\n     * 1.0 (left to right).\n     * @param {number} v - V coordinate of pixel in depth texture, which is in range from 0.0 to\n     * 1.0 (top to bottom).\n     * @returns {number|null} Depth in meters or null if depth information is currently not\n     * available.\n     * @example\n     * var depth = app.xr.depthSensing.getDepth(u, v);\n     * if (depth !== null) {\n     *     // depth in meters\n     * }\n     */\n    getDepth(u: number, v: number): number | null;\n    /**\n     * True if Depth Sensing is supported.\n     *\n     * @type {boolean}\n     */\n    get supported(): boolean;\n    /**\n     * True if depth sensing information is available.\n     *\n     * @type {boolean}\n     * @example\n     * if (app.xr.depthSensing.available) {\n     *     var depth = app.xr.depthSensing.getDepth(x, y);\n     * }\n     */\n    get available(): boolean;\n    /**\n     * Whether the usage is CPU or GPU.\n     *\n     * @type {string}\n     * @ignore\n     */\n    get usage(): string;\n    /**\n     * The depth sensing data format.\n     *\n     * @type {string}\n     * @ignore\n     */\n    get dataFormat(): string;\n    /**\n     * Width of depth texture or 0 if not available.\n     *\n     * @type {number}\n     */\n    get width(): number;\n    /**\n     * Height of depth texture or 0 if not available.\n     *\n     * @type {number}\n     */\n    get height(): number;\n    /**\n     * Texture that contains packed depth information. The format of this texture is\n     * {@link PIXELFORMAT_L8_A8}. It is UV transformed based on the underlying AR system which can\n     * be normalized using {@link XrDepthSensing#uvMatrix}.\n     *\n     * @type {Texture}\n     * @example\n     * material.diffuseMap = depthSensing.texture;\n     * @example\n     * // GLSL shader to unpack depth texture\n     * varying vec2 vUv0;\n     *\n     * uniform sampler2D texture_depthSensingMap;\n     * uniform mat4 matrix_depth_uv;\n     * uniform float depth_raw_to_meters;\n     *\n     * void main(void) {\n     *     // transform UVs using depth matrix\n     *     vec2 texCoord = (matrix_depth_uv * vec4(vUv0.xy, 0.0, 1.0)).xy;\n     *\n     *     // get luminance alpha components from depth texture\n     *     vec2 packedDepth = texture2D(texture_depthSensingMap, texCoord).ra;\n     *\n     *     // unpack into single value in millimeters\n     *     float depth = dot(packedDepth, vec2(255.0, 256.0 * 255.0)) * depth_raw_to_meters; // m\n     *\n     *     // normalize: 0m to 8m distance\n     *     depth = min(depth / 8.0, 1.0); // 0..1 = 0m..8m\n     *\n     *     // paint scene from black to white based on distance\n     *     gl_FragColor = vec4(depth, depth, depth, 1.0);\n     * }\n     */\n    get texture(): Texture;\n    /**\n     * 4x4 matrix that should be used to transform depth texture UVs to normalized UVs in a shader.\n     * It is updated when the depth texture is resized. Refer to {@link XrDepthSensing#resize}.\n     *\n     * @type {Mat4}\n     * @example\n     * material.setParameter(\'matrix_depth_uv\', depthSensing.uvMatrix.data);\n     */\n    get uvMatrix(): Mat4;\n    /**\n     * Multiply this coefficient number by raw depth value to get depth in meters.\n     *\n     * @type {number}\n     * @example\n     * material.setParameter(\'depth_raw_to_meters\', depthSensing.rawValueToMeters);\n     */\n    get rawValueToMeters(): number;\n}\n\n\n/** @typedef {import(\'./xr-manager.js\').XrManager} XrManager */\n/**\n * DOM Overlay provides the ability to use DOM elements as an overlay in a WebXR AR session. It\n * requires that the root DOM element is provided for session start. That way, input source select\n * events are first tested against DOM Elements and then propagated down to the XR Session. If this\n * propagation is not desirable, use the `beforexrselect` event on a DOM element and the\n * `preventDefault` function to stop propagation.\n *\n * ```javascript```\n * app.xr.domOverlay.root = element;\n * app.xr.start(camera, pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR);\n * ```\n *\n * ```javascript\n * // Disable input source firing `select` event when some descendant element of DOM overlay root\n * // is touched/clicked. This is useful when the user interacts with UI elements and there should\n * // not be `select` events behind UI.\n * someElement.addEventListener(\'beforexrselect\', function (evt) {\n *     evt.preventDefault();\n * });\n * ```\n */\ndeclare class XrDomOverlay {\n    /**\n     * DOM Overlay provides the ability to use DOM elements as an overlay in a WebXR AR session. It\n     * requires that the root DOM element is provided for session start. That way, input source\n     * select events are first tested against DOM Elements and then propagated down to the XR\n     * Session. If this propagation is not desirable, use the `beforexrselect` event on a DOM\n     * element and the `preventDefault` function to stop propagation.\n     *\n     * @param {XrManager} manager - WebXR Manager.\n     * @hideconstructor\n     */\n    constructor(manager: XrManager);\n    /**\n     * @type {XrManager}\n     * @private\n     */\n    private _manager;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _supported;\n    /**\n     * @type {Element|null}\n     * @private\n     */\n    private _root;\n    /**\n     * True if DOM Overlay is supported.\n     *\n     * @type {boolean}\n     */\n    get supported(): boolean;\n    /**\n     * True if DOM Overlay is available. It can only be available if it is supported, during a\n     * valid WebXR session and if a valid root element is provided.\n     *\n     * @type {boolean}\n     */\n    get available(): boolean;\n    /**\n     * State of the DOM Overlay, which defines how the root DOM element is rendered. Possible\n     * options:\n     *\n     * - screen: Screen - indicates that the DOM element is covering whole physical screen,\n     * matching XR viewports.\n     * - floating: Floating - indicates that the underlying platform renders the DOM element as\n     * floating in space, which can move during the WebXR session or allow the application to move\n     * the element.\n     * - head-locked: Head Locked - indicates that the DOM element follows the user\'s head movement\n     * consistently, appearing similar to a helmet heads-up display.\n     *\n     * @type {string|null}\n     */\n    get state(): string;\n    /**\n     * The DOM element to be used as the root for DOM Overlay. Can be changed only outside of an\n     * active WebXR session.\n     *\n     * @type {Element|null}\n     * @example\n     * app.xr.domOverlay.root = element;\n     * app.xr.start(camera, pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR);\n     */\n    set root(arg: Element);\n    get root(): Element;\n}\n\n\n/**\n * Represents XR hit test source, which provides access to hit results of real world geometry from\n * AR session.\n *\n * @augments EventHandler\n */\ndeclare class XrHitTestSource extends EventHandler {\n    /**\n     * Create a new XrHitTestSource instance.\n     *\n     * @param {XrManager} manager - WebXR Manager.\n     * @param {*} xrHitTestSource - XRHitTestSource object that is created by WebXR API.\n     * @param {boolean} transient - True if XRHitTestSource created for input source profile.\n     * @hideconstructor\n     */\n    constructor(manager: XrManager, xrHitTestSource: any, transient: boolean);\n    /**\n     * @type {XrManager}\n     * @private\n     */\n    private manager;\n    /**\n     * @type {XRHitTestSource}\n     * @private\n     */\n    private _xrHitTestSource;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _transient;\n    /**\n     * @event\n     * @name XrHitTestSource#remove\n     * @description Fired when {@link XrHitTestSource} is removed.\n     * @example\n     * hitTestSource.once(\'remove\', function () {\n     *     // hit test source has been removed\n     * });\n     */\n    /**\n     * @event\n     * @name XrHitTestSource#result\n     * @description Fired when hit test source receives new results. It provides transform information that tries to match real world picked geometry.\n     * @param {Vec3} position - Position of hit test.\n     * @param {Quat} rotation - Rotation of hit test.\n     * @param {XrInputSource|null} inputSource - If is transient hit test source, then it will provide related input source.\n     * @example\n     * hitTestSource.on(\'result\', function (position, rotation, inputSource) {\n     *     target.setPosition(position);\n     *     target.setRotation(rotation);\n     * });\n     */\n    /**\n     * Stop and remove hit test source.\n     */\n    remove(): void;\n    /** @ignore */\n    onStop(): void;\n    /**\n     * @param {*} frame - XRFrame from requestAnimationFrame callback.\n     * @ignore\n     */\n    update(frame: any): void;\n    /**\n     * @param {XRTransientInputHitTestResult[]} results - Hit test results.\n     * @param {XRHitTestSource} inputSource - Input source.\n     * @private\n     */\n    private updateHitResults;\n}\n\n\n\n/**\n * Callback used by {@link XrHitTeststart } and {@link XrHitTeststartForInputSource }.\n */\nexport type XrHitTestStartCallback = (err: Error | null, hitTestSource: XrHitTestSource | null) => any;\n/** @typedef {import(\'./xr-manager.js\').XrManager} XrManager */\n/** @typedef {import(\'../shape/ray.js\').Ray} Ray */\n/**\n * Callback used by {@link XrHitTest#start} and {@link XrHitTest#startForInputSource}.\n *\n * @callback XrHitTestStartCallback\n * @param {Error|null} err - The Error object if failed to create hit test source or null.\n * @param {XrHitTestSource|null} hitTestSource - Object that provides access to hit results against\n * real world geometry.\n */\n/**\n * Hit Test provides ability to get position and rotation of ray intersecting point with\n * representation of real world geometry by underlying AR system.\n *\n * @augments EventHandler\n */\ndeclare class XrHitTest extends EventHandler {\n    /**\n     * Create a new XrHitTest instance.\n     *\n     * @param {XrManager} manager - WebXR Manager.\n     * @hideconstructor\n     */\n    constructor(manager: XrManager);\n    /**\n     * @type {XrManager}\n     * @private\n     */\n    private manager;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _supported;\n    /**\n     * @type {XRSession}\n     * @private\n     */\n    private _session;\n    /**\n     * List of active {@link XrHitTestSource}.\n     *\n     * @type {XrHitTestSource[]}\n     */\n    sources: XrHitTestSource[];\n    /**\n     * @event\n     * @name XrHitTest#add\n     * @description Fired when new {@link XrHitTestSource} is added to the list.\n     * @param {XrHitTestSource} hitTestSource - Hit test source that has been added.\n     * @example\n     * app.xr.hitTest.on(\'add\', function (hitTestSource) {\n     *     // new hit test source is added\n     * });\n     */\n    /**\n     * @event\n     * @name XrHitTest#remove\n     * @description Fired when {@link XrHitTestSource} is removed to the list.\n     * @param {XrHitTestSource} hitTestSource - Hit test source that has been removed.\n     * @example\n     * app.xr.hitTest.on(\'remove\', function (hitTestSource) {\n     *     // hit test source is removed\n     * });\n     */\n    /**\n     * @event\n     * @name XrHitTest#result\n     * @description Fired when hit test source receives new results. It provides transform information that tries to match real world picked geometry.\n     * @param {XrHitTestSource} hitTestSource - Hit test source that produced the hit result.\n     * @param {Vec3} position - Position of hit test.\n     * @param {Quat} rotation - Rotation of hit test.\n     * @param {XrInputSource|null} inputSource - If is transient hit test source, then it will provide related input source.\n     * @example\n     * app.xr.hitTest.on(\'result\', function (hitTestSource, position, rotation, inputSource) {\n     *     target.setPosition(position);\n     *     target.setRotation(rotation);\n     * });\n     */\n    /**\n     * @event\n     * @name XrHitTest#error\n     * @param {Error} error - Error object related to failure of creating hit test source.\n     * @description Fired when failed create hit test source.\n     */\n    /** @private */\n    private _onSessionStart;\n    /** @private */\n    private _onSessionEnd;\n    /**\n     * Checks if hit testing is available.\n     *\n     * @param {Function} callback - Error callback.\n     * @param {*} fireError - Event handler on while to fire error event.\n     * @returns {boolean} True if hit test is available.\n     * @private\n     */\n    private isAvailable;\n    /**\n     * Attempts to start hit test with provided reference space.\n     *\n     * @param {object} [options] - Optional object for passing arguments.\n     * @param {string} [options.spaceType] - Reference space type. Defaults to\n     * {@link XRSPACE_VIEWER}. Can be one of the following:\n     *\n     * - {@link XRSPACE_VIEWER}: Viewer - hit test will be facing relative to viewers space.\n     * - {@link XRSPACE_LOCAL}: Local - represents a tracking space with a native origin near the\n     * viewer at the time of creation.\n     * - {@link XRSPACE_LOCALFLOOR}: Local Floor - represents a tracking space with a native origin\n     * at the floor in a safe position for the user to stand. The y axis equals 0 at floor level.\n     * Floor level value might be estimated by the underlying platform.\n     * - {@link XRSPACE_BOUNDEDFLOOR}: Bounded Floor - represents a tracking space with its native\n     * origin at the floor, where the user is expected to move within a pre-established boundary.\n     * - {@link XRSPACE_UNBOUNDED}: Unbounded - represents a tracking space where the user is\n     * expected to move freely around their environment, potentially long distances from their\n     * starting point.\n     *\n     * @param {string} [options.profile] - if hit test source meant to match input source instead\n     * of reference space, then name of profile of the {@link XrInputSource} should be provided.\n     * @param {string[]} [options.entityTypes] - Optional list of underlying entity types against\n     * which hit tests will be performed. Defaults to [ {@link XRTRACKABLE_PLANE} ]. Can be any\n     * combination of the following:\n     *\n     * - {@link XRTRACKABLE_POINT}: Point - indicates that the hit test results will be computed\n     * based on the feature points detected by the underlying Augmented Reality system.\n     * - {@link XRTRACKABLE_PLANE}: Plane - indicates that the hit test results will be computed\n     * based on the planes detected by the underlying Augmented Reality system.\n     * - {@link XRTRACKABLE_MESH}: Mesh - indicates that the hit test results will be computed\n     * based on the meshes detected by the underlying Augmented Reality system.\n     *\n     * @param {Ray} [options.offsetRay] - Optional ray by which hit test ray can be offset.\n     * @param {XrHitTestStartCallback} [options.callback] - Optional callback function called once\n     * hit test source is created or failed.\n     * @example\n     * app.xr.hitTest.start({\n     *     spaceType: pc.XRSPACE_VIEWER,\n     *     callback: function (err, hitTestSource) {\n     *         if (err) return;\n     *         hitTestSource.on(\'result\', function (position, rotation) {\n     *             // position and rotation of hit test result\n     *             // based on Ray facing forward from the Viewer reference space\n     *         });\n     *     }\n     * });\n     * @example\n     * var ray = new pc.Ray(new pc.Vec3(0, 0, 0), new pc.Vec3(0, -1, 0));\n     * app.xr.hitTest.start({\n     *     spaceType: pc.XRSPACE_LOCAL,\n     *     offsetRay: ray,\n     *     callback: function (err, hitTestSource) {\n     *         // hit test source that will sample real world geometry straight down\n     *         // from the position where AR session started\n     *     }\n     * });\n     * @example\n     * app.xr.hitTest.start({\n     *     profile: \'generic-touchscreen\',\n     *     callback: function (err, hitTestSource) {\n     *         if (err) return;\n     *         hitTestSource.on(\'result\', function (position, rotation, inputSource) {\n     *             // position and rotation of hit test result\n     *             // that will be created from touch on mobile devices\n     *         });\n     *     }\n     * });\n     */\n    start(options?: {\n        spaceType?: string;\n        profile?: string;\n        entityTypes?: string[];\n        offsetRay?: Ray;\n        callback?: XrHitTestStartCallback;\n    }): void;\n    /**\n     * @param {XRHitTestSource} xrHitTestSource - Hit test source.\n     * @param {boolean} transient - True if hit test source is created from transient input source.\n     * @param {Function} callback - Callback called once hit test source is created.\n     * @private\n     */\n    private _onHitTestSource;\n    /**\n     * @param {*} frame - XRFrame from requestAnimationFrame callback.\n     * @ignore\n     */\n    update(frame: any): void;\n    /**\n     * True if AR Hit Test is supported.\n     *\n     * @type {boolean}\n     */\n    get supported(): boolean;\n}\n\n/**\n * The tracked image interface that is created by the Image Tracking system and is provided as a\n * list from {@link XrImageTracking#images}. It contains information about the tracking state as\n * well as the position and rotation of the tracked image.\n *\n * @augments EventHandler\n */\ndeclare class XrTrackedImage extends EventHandler {\n    /**\n     * The tracked image interface that is created by the Image Tracking system and is provided as\n     * a list from {@link XrImageTracking#images}. It contains information about the tracking state\n     * as well as the position and rotation of the tracked image.\n     *\n     * @param {HTMLCanvasElement|HTMLImageElement|SVGImageElement|HTMLVideoElement|Blob|ImageData|ImageBitmap} image - Image\n     * that is matching the real world image as closely as possible. Resolution of images should be\n     * at least 300x300. High resolution does NOT improve tracking performance. Color of image is\n     * irrelevant, so grayscale images can be used. Images with too many geometric features or\n     * repeating patterns will reduce tracking stability.\n     * @param {number} width - Width (in meters) of image in real world. Providing this value as\n     * close to the real value will improve tracking quality.\n     * @hideconstructor\n     */\n    constructor(image: HTMLCanvasElement | HTMLImageElement | SVGImageElement | HTMLVideoElement | Blob | ImageData | ImageBitmap, width: number);\n    /**\n     * @type {HTMLCanvasElement|HTMLImageElement|SVGImageElement|HTMLVideoElement|Blob|ImageData|ImageBitmap}\n     * @private\n     */\n    private _image;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _width;\n    /**\n     * @type {ImageBitmap|null}\n     * @private\n     */\n    private _bitmap;\n    /**\n     * @type {number}\n     * @ignore\n     */\n    _measuredWidth: number;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _trackable;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _tracking;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _emulated;\n    /**\n     * @type {*}\n     * @ignore\n     */\n    _pose: any;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private _position;\n    /**\n     * @type {Quat}\n     * @private\n     */\n    private _rotation;\n    /**\n     * Image that is used for tracking.\n     *\n     * @type {HTMLCanvasElement|HTMLImageElement|SVGImageElement|HTMLVideoElement|Blob|ImageData|ImageBitmap}\n     */\n    get image(): Blob | ImageBitmap | HTMLCanvasElement | HTMLImageElement | SVGImageElement | HTMLVideoElement | ImageData;\n    /**\n     * Width that is provided to assist tracking performance. This property can be updated only\n     * when the AR session is not running.\n     *\n     * @type {number}\n     */\n    set width(arg: number);\n    get width(): number;\n    /**\n     * True if image is trackable. A too small resolution or invalid images can be untrackable by\n     * the underlying AR system.\n     *\n     * @type {boolean}\n     */\n    get trackable(): boolean;\n    /**\n     * True if image is in tracking state and being tracked in real world by the underlying AR\n     * system.\n     *\n     * @type {boolean}\n     */\n    get tracking(): boolean;\n    /**\n     * True if image was recently tracked but currently is not actively tracked due to inability of\n     * identifying the image by the underlying AR system. Position and rotation will be based on\n     * the previously known transformation assuming the tracked image has not moved.\n     *\n     * @type {boolean}\n     */\n    get emulated(): boolean;\n    /**\n     * @event\n     * @name XrTrackedImage#tracked\n     * @description Fired when image becomes actively tracked.\n     */\n    /**\n     * @event\n     * @name XrTrackedImage#untracked\n     * @description Fired when image is no more actively tracked.\n     */\n    /**\n     * @returns {Promise<ImageBitmap>} Promise that resolves to an image bitmap.\n     * @ignore\n     */\n    prepare(): Promise<ImageBitmap>;\n    /**\n     * Destroys the tracked image.\n     *\n     * @ignore\n     */\n    destroy(): void;\n    /**\n     * Get the position of the tracked image. The position is the most recent one based on the\n     * tracked image state.\n     *\n     * @returns {Vec3} Position in world space.\n     * @example\n     * // update entity position to match tracked image position\n     * entity.setPosition(trackedImage.getPosition());\n     */\n    getPosition(): Vec3;\n    /**\n     * Get the rotation of the tracked image. The rotation is the most recent based on the tracked\n     * image state.\n     *\n     * @returns {Quat} Rotation in world space.\n     * @example\n     * // update entity rotation to match tracked image rotation\n     * entity.setRotation(trackedImage.getRotation());\n     */\n    getRotation(): Quat;\n}\n\n\n/** @typedef {import(\'./xr-manager.js\').XrManager} XrManager */\n/**\n * Image Tracking provides the ability to track real world images by provided image samples and\n * their estimated sizes.\n *\n * @augments EventHandler\n */\ndeclare class XrImageTracking extends EventHandler {\n    /**\n     * Image Tracking provides the ability to track real world images by provided image samples and\n     * their estimate sizes.\n     *\n     * @param {XrManager} manager - WebXR Manager.\n     * @hideconstructor\n     */\n    constructor(manager: XrManager);\n    /**\n     * @type {XrManager}\n     * @private\n     */\n    private _manager;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _supported;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _available;\n    /**\n     * @type {XrTrackedImage[]}\n     * @private\n     */\n    private _images;\n    /**\n     * @event\n     * @name XrImageTracking#error\n     * @param {Error} error - Error object related to a failure of image tracking.\n     * @description Fired when the XR session is started, but image tracking failed to process the\n     * provided images.\n     */\n    /**\n     * Add an image for image tracking. A width can also be provided to help the underlying system\n     * estimate the appropriate transformation. Modifying the tracked images list is only possible\n     * before an AR session is started.\n     *\n     * @param {HTMLCanvasElement|HTMLImageElement|SVGImageElement|HTMLVideoElement|Blob|ImageData|ImageBitmap} image - Image\n     * that is matching real world image as close as possible. Resolution of images should be at\n     * least 300x300. High resolution does NOT improve tracking performance. Color of image is\n     * irrelevant, so grayscale images can be used. Images with too many geometric features or\n     * repeating patterns will reduce tracking stability.\n     * @param {number} width - Width (in meters) of image in the real world. Providing this value\n     * as close to the real value will improve tracking quality.\n     * @returns {XrTrackedImage|null} Tracked image object that will contain tracking information.\n     * Returns null if image tracking is not supported or if the XR manager is not active.\n     * @example\n     * // image with width of 20cm (0.2m)\n     * app.xr.imageTracking.add(bookCoverImg, 0.2);\n     */\n    add(image: HTMLCanvasElement | HTMLImageElement | SVGImageElement | HTMLVideoElement | Blob | ImageData | ImageBitmap, width: number): XrTrackedImage | null;\n    /**\n     * Remove an image from image tracking.\n     *\n     * @param {XrTrackedImage} trackedImage - Tracked image to be removed. Modifying the tracked\n     * images list is only possible before an AR session is started.\n     */\n    remove(trackedImage: XrTrackedImage): void;\n    /** @private */\n    private _onSessionStart;\n    /** @private */\n    private _onSessionEnd;\n    /**\n     * @param {Function} callback - Function to call when all images have been prepared as image\n     * bitmaps.\n     * @ignore\n     */\n    prepareImages(callback: Function): void;\n    /**\n     * @param {*} frame - XRFrame from requestAnimationFrame callback.\n     * @ignore\n     */\n    update(frame: any): void;\n    /**\n     * True if Image Tracking is supported.\n     *\n     * @type {boolean}\n     */\n    get supported(): boolean;\n    /**\n     * True if Image Tracking is available. This property will be false if no images were provided\n     * for the AR session or there was an error processing the provided images.\n     *\n     * @type {boolean}\n     */\n    get available(): boolean;\n    /**\n     * List of {@link XrTrackedImage} that contain tracking information.\n     *\n     * @type {XrTrackedImage[]}\n     */\n    get images(): XrTrackedImage[];\n}\n\n\n/**\n * Detected Plane instance that provides position, rotation and polygon points. Plane is a subject\n * to change during its lifetime.\n */\ndeclare class XrPlane extends EventHandler {\n    /**\n     * Create a new XrPlane instance.\n     *\n     * @param {XrPlaneDetection} planeDetection - Plane detection system.\n     * @param {*} xrPlane - XRPlane that is instantiated by WebXR system.\n     * @hideconstructor\n     */\n    constructor(planeDetection: XrPlaneDetection, xrPlane: any);\n    /**\n     * @type {number}\n     * @private\n     */\n    private _id;\n    /**\n     * @type {XrPlaneDetection}\n     * @private\n     */\n    private _planeDetection;\n    /**\n     * @type {XRPlane}\n     * @private\n     */\n    private _xrPlane;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _lastChangedTime;\n    /**\n     * @type {string}\n     * @private\n     */\n    private _orientation;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private _position;\n    /**\n     * @type {Quat}\n     * @private\n     */\n    private _rotation;\n    /**\n     * @event\n     * @name XrPlane#remove\n     * @description Fired when {@link XrPlane} is removed.\n     * @example\n     * plane.once(\'remove\', function () {\n     *     // plane is not available anymore\n     * });\n     */\n    /**\n     * @event\n     * @name XrPlane#change\n     * @description Fired when {@link XrPlane} attributes such as: orientation and/or points have been changed. Position and rotation can change at any time without triggering a `change` event.\n     * @example\n     * plane.on(\'change\', function () {\n     *     // plane has been changed\n     * });\n     */\n    /** @ignore */\n    destroy(): void;\n    /**\n     * @param {*} frame - XRFrame from requestAnimationFrame callback.\n     * @ignore\n     */\n    update(frame: any): void;\n    /**\n     * Get the world space position of a plane.\n     *\n     * @returns {Vec3} The world space position of a plane.\n     */\n    getPosition(): Vec3;\n    /**\n     * Get the world space rotation of a plane.\n     *\n     * @returns {Quat} The world space rotation of a plane.\n     */\n    getRotation(): Quat;\n    /**\n     * Unique identifier of a plane.\n     *\n     * @type {number}\n     */\n    get id(): number;\n    /**\n     * Plane\'s specific orientation (horizontal or vertical) or null if orientation is anything else.\n     *\n     * @type {string|null}\n     */\n    get orientation(): string;\n    /**\n     * Array of DOMPointReadOnly objects. DOMPointReadOnly is an object with `x y z` properties\n     * that defines a local point of a plane\'s polygon.\n     *\n     * @type {object[]}\n     * @example\n     * // prepare reusable objects\n     * var vecA = new pc.Vec3();\n     * var vecB = new pc.Vec3();\n     * var color = new pc.Color(1, 1, 1);\n     *\n     * // update Mat4 to plane position and rotation\n     * transform.setTRS(plane.getPosition(), plane.getRotation(), pc.Vec3.ONE);\n     *\n     * // draw lines between points\n     * for (var i = 0; i < plane.points.length; i++) {\n     *     vecA.copy(plane.points[i]);\n     *     vecB.copy(plane.points[(i + 1) % plane.points.length]);\n     *\n     *     // transform from planes local to world coords\n     *     transform.transformPoint(vecA, vecA);\n     *     transform.transformPoint(vecB, vecB);\n     *\n     *     // render line\n     *     app.drawLine(vecA, vecB, color);\n     * }\n     */\n    get points(): any[];\n}\n\n\n/** @typedef {import(\'./xr-manager.js\').XrManager} XrManager */\n/**\n * Plane Detection provides the ability to detect real world surfaces based on estimations of the\n * underlying AR system.\n *\n * ```javascript\n * // start session with plane detection enabled\n * app.xr.start(camera, pc.XRTYPE_VR, pc.XRSPACE_LOCALFLOOR, {\n *     planeDetection: true\n * });\n * ```\n *\n * ```javascript\n * app.xr.planeDetection.on(\'add\', function (plane) {\n *     // new plane been added\n * });\n * ```\n */\ndeclare class XrPlaneDetection extends EventHandler {\n    /**\n     * Create a new XrPlaneDetection instance.\n     *\n     * @param {XrManager} manager - WebXR Manager.\n     * @hideconstructor\n     */\n    constructor(manager: XrManager);\n    /**\n     * @type {XrManager}\n     * @private\n     */\n    private _manager;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _supported;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _available;\n    /**\n     * @type {Map<XRPlane, XrPlane>}\n     * @private\n     */\n    private _planesIndex;\n    /**\n     * @type {XrPlane[]|null}\n     * @private\n     */\n    private _planes;\n    /**\n     * @event\n     * @name XrPlaneDetection#available\n     * @description Fired when plane detection becomes available.\n     */\n    /**\n     * @event\n     * @name XrPlaneDetection#unavailable\n     * @description Fired when plane detection becomes unavailable.\n     */\n    /**\n     * @event\n     * @name XrPlaneDetection#add\n     * @description Fired when new {@link XrPlane} is added to the list.\n     * @param {XrPlane} plane - Plane that has been added.\n     * @example\n     * app.xr.planeDetection.on(\'add\', function (plane) {\n     *     // new plane is added\n     * });\n     */\n    /**\n     * @event\n     * @name XrPlaneDetection#remove\n     * @description Fired when a {@link XrPlane} is removed from the list.\n     * @param {XrPlane} plane - Plane that has been removed.\n     * @example\n     * app.xr.planeDetection.on(\'remove\', function (plane) {\n     *     // new plane is removed\n     * });\n     */\n    /** @private */\n    private _onSessionEnd;\n    /**\n     * @param {*} frame - XRFrame from requestAnimationFrame callback.\n     * @ignore\n     */\n    update(frame: any): void;\n    /**\n     * True if Plane Detection is supported.\n     *\n     * @type {boolean}\n     */\n    get supported(): boolean;\n    /**\n     * True if Plane Detection is available. This property can be set to true only during a running\n     * session.\n     *\n     * @type {boolean}\n     */\n    get available(): boolean;\n    /**\n     * Array of {@link XrPlane} instances that contain individual plane information, or null if\n     * plane detection is not available.\n     *\n     * @type {XrPlane[]|null}\n     */\n    get planes(): XrPlane[];\n}\n\n\n/** @typedef {import(\'./xr-manager.js\').XrManager} XrManager */\n/**\n * Provides access to input sources for WebXR.\n *\n * @augments EventHandler\n */\ndeclare class XrInput extends EventHandler {\n    /**\n     * Create a new XrInput instance.\n     *\n     * @param {XrManager} manager - WebXR Manager.\n     * @hideconstructor\n     */\n    constructor(manager: XrManager);\n    /**\n     * @type {XrManager}\n     * @private\n     */\n    private manager;\n    /**\n     * @type {XrInputSource[]}\n     * @private\n     */\n    private _inputSources;\n    /**\n     * @type {Function}\n     * @private\n     */\n    private _onInputSourcesChangeEvt;\n    /**\n     * @event\n     * @name XrInput#add\n     * @description Fired when new {@link XrInputSource} is added to the list.\n     * @param {XrInputSource} inputSource - Input source that has been added.\n     * @example\n     * app.xr.input.on(\'add\', function (inputSource) {\n     *     // new input source is added\n     * });\n     */\n    /**\n     * @event\n     * @name XrInput#remove\n     * @description Fired when {@link XrInputSource} is removed to the list.\n     * @param {XrInputSource} inputSource - Input source that has been removed.\n     * @example\n     * app.xr.input.on(\'remove\', function (inputSource) {\n     *     // input source is removed\n     * });\n     */\n    /**\n     * @event\n     * @name XrInput#select\n     * @description Fired when {@link XrInputSource} has triggered primary action. This could be pressing a trigger button, or touching a screen.\n     * @param {XrInputSource} inputSource - Input source that triggered select event.\n     * @param {object} evt - XRInputSourceEvent event data from WebXR API.\n     * @example\n     * var ray = new pc.Ray();\n     * app.xr.input.on(\'select\', function (inputSource, evt) {\n     *     ray.set(inputSource.getOrigin(), inputSource.getDirection());\n     *     if (obj.intersectsRay(ray)) {\n     *         // selected an object with input source\n     *     }\n     * });\n     */\n    /**\n     * @event\n     * @name XrInput#selectstart\n     * @description Fired when {@link XrInputSource} has started to trigger primary action.\n     * @param {XrInputSource} inputSource - Input source that triggered selectstart event.\n     * @param {object} evt - XRInputSourceEvent event data from WebXR API.\n     */\n    /**\n     * @event\n     * @name XrInput#selectend\n     * @description Fired when {@link XrInputSource} has ended triggerring primary action.\n     * @param {XrInputSource} inputSource - Input source that triggered selectend event.\n     * @param {object} evt - XRInputSourceEvent event data from WebXR API.\n     */\n    /**\n     * @event\n     * @name XrInput#squeeze\n     * @description Fired when {@link XrInputSource} has triggered squeeze action. This is associated with "grabbing" action on the controllers.\n     * @param {XrInputSource} inputSource - Input source that triggered squeeze event.\n     * @param {object} evt - XRInputSourceEvent event data from WebXR API.\n     */\n    /**\n     * @event\n     * @name XrInput#squeezestart\n     * @description Fired when {@link XrInputSource} has started to trigger sqeeze action.\n     * @param {XrInputSource} inputSource - Input source that triggered squeezestart event.\n     * @param {object} evt - XRInputSourceEvent event data from WebXR API.\n     * @example\n     * app.xr.input.on(\'squeezestart\', function (inputSource, evt) {\n     *     if (obj.containsPoint(inputSource.getPosition())) {\n     *         // grabbed an object\n     *     }\n     * });\n     */\n    /**\n     * @event\n     * @name XrInput#squeezeend\n     * @description Fired when {@link XrInputSource} has ended triggerring sqeeze action.\n     * @param {XrInputSource} inputSource - Input source that triggered squeezeend event.\n     * @param {object} evt - XRInputSourceEvent event data from WebXR API.\n     */\n    /** @private */\n    private _onSessionStart;\n    /** @private */\n    private _onSessionEnd;\n    /**\n     * @param {XRInputSourcesChangeEvent} evt - WebXR input sources change event.\n     * @private\n     */\n    private _onInputSourcesChange;\n    /**\n     * @param {XRInputSource} xrInputSource - Input source to search for.\n     * @returns {XrInputSource|null} The input source that matches the given WebXR input source or\n     * null if no match is found.\n     * @private\n     */\n    private _getByInputSource;\n    /**\n     * @param {XRInputSource} xrInputSource - Input source to add.\n     * @private\n     */\n    private _addInputSource;\n    /**\n     * @param {XRInputSource} xrInputSource - Input source to remove.\n     * @private\n     */\n    private _removeInputSource;\n    /**\n     * @param {*} frame - XRFrame from requestAnimationFrame callback.\n     * @ignore\n     */\n    update(frame: any): void;\n    /**\n     * List of active {@link XrInputSource} instances.\n     *\n     * @type {XrInputSource[]}\n     */\n    get inputSources(): XrInputSource[];\n}\n\n\n/**\n * Light Estimation provides illumination data from the real world, which is estimated by the\n * underlying AR system. It provides a reflection Cube Map, that represents the reflection\n * estimation from the viewer position. A more simplified approximation of light is provided by L2\n * Spherical Harmonics data. And the most simple level of light estimation is the most prominent\n * directional light, its rotation, intensity and color.\n *\n * @augments EventHandler\n */\ndeclare class XrLightEstimation extends EventHandler {\n    /**\n     * Create a new XrLightEstimation instance.\n     *\n     * @param {XrManager} manager - WebXR Manager.\n     * @hideconstructor\n     */\n    constructor(manager: XrManager);\n    /**\n     * @type {XrManager}\n     * @private\n     */\n    private _manager;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _supported;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _available;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _lightProbeRequested;\n    /**\n     * @type {XRLightProbe|null}\n     * @private\n     */\n    private _lightProbe;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _intensity;\n    /**\n     * @type {Quat}\n     * @private\n     */\n    private _rotation;\n    /**\n     * @type {Color}\n     * @private\n     */\n    private _color;\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    private _sphericalHarmonics;\n    /**\n     * @event\n     * @name XrLightEstimation#available\n     * @description Fired when light estimation data becomes available.\n     */\n    /**\n     * @event\n     * @name XrLightEstimation#error\n     * @param {Error} error - Error object related to failure of light estimation start.\n     * @description Fired when light estimation has failed to start.\n     * @example\n     * app.xr.lightEstimation.on(\'error\', function (ex) {\n     *     // has failed to start\n     * });\n     */\n    /** @private */\n    private _onSessionStart;\n    /** @private */\n    private _onSessionEnd;\n    /**\n     * Start estimation of illumination data. Availability of such data will come later and an\n     * `available` event will be fired. If it failed to start estimation, an `error` event will be\n     * fired.\n     *\n     * @example\n     * app.xr.on(\'start\', function () {\n     *     if (app.xr.lightEstimation.supported) {\n     *         app.xr.lightEstimation.start();\n     *     }\n     * });\n     */\n    start(): void;\n    /**\n     * End estimation of illumination data.\n     */\n    end(): void;\n    /**\n     * @param {*} frame - XRFrame from requestAnimationFrame callback.\n     * @ignore\n     */\n    update(frame: any): void;\n    /**\n     * True if Light Estimation is supported. This information is available only during an active AR\n     * session.\n     *\n     * @type {boolean}\n     */\n    get supported(): boolean;\n    /**\n     * True if estimated light information is available.\n     *\n     * @type {boolean}\n     * @example\n     * if (app.xr.lightEstimation.available) {\n     *     entity.light.intensity = app.xr.lightEstimation.intensity;\n     * }\n     */\n    get available(): boolean;\n    /**\n     * Intensity of what is estimated to be the most prominent directional light. Or null if data\n     * is not available.\n     *\n     * @type {number|null}\n     */\n    get intensity(): number;\n    /**\n     * Color of what is estimated to be the most prominent directional light. Or null if data is\n     * not available.\n     *\n     * @type {Color|null}\n     */\n    get color(): Color;\n    /**\n     * Rotation of what is estimated to be the most prominent directional light. Or null if data is\n     * not available.\n     *\n     * @type {Quat|null}\n     */\n    get rotation(): Quat;\n    /**\n     * Spherical harmonics coefficients of what is estimated to be the most prominent directional\n     * light. Or null if data is not available.\n     *\n     * @type {Float32Array|null}\n     * @ignore\n     */\n    get sphericalHarmonics(): Float32Array;\n}\n\n\n\n/**\n * Callback used by {@link XrManagerendXr } and {@link XrManagerstartXr }.\n */\nexport type XrErrorCallback = (err: Error | null) => any;\n/** @typedef {import(\'../framework/components/camera/component.js\').CameraComponent} CameraComponent */\n/** @typedef {import(\'../framework/app-base.js\').Application} Application */\n/** @typedef {import(\'../framework/entity.js\').Entity} Entity */\n/**\n * Callback used by {@link XrManager#endXr} and {@link XrManager#startXr}.\n *\n * @callback XrErrorCallback\n * @param {Error|null} err - The Error object or null if operation was successful.\n */\n/**\n * Manage and update XR session and its states.\n *\n * @augments EventHandler\n */\ndeclare class XrManager extends EventHandler {\n    /**\n     * Create a new XrManager instance.\n     *\n     * @param {Application} app - The main application.\n     * @hideconstructor\n     */\n    constructor(app: Application);\n    /**\n     * @type {Application}\n     * @ignore\n     */\n    app: Application;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _supported;\n    /**\n     * @type {Object.<string, boolean>}\n     * @private\n     */\n    private _available;\n    /**\n     * @type {string|null}\n     * @private\n     */\n    private _type;\n    /**\n     * @type {string|null}\n     * @private\n     */\n    private _spaceType;\n    /**\n     * @type {XRSession|null}\n     * @private\n     */\n    private _session;\n    /**\n     * @type {XRWebGLLayer|null}\n     * @private\n     */\n    private _baseLayer;\n    /**\n     * @type {XRReferenceSpace|null}\n     * @private\n     */\n    private _referenceSpace;\n    /**\n     * Provides access to depth sensing capabilities.\n     *\n     * @type {XrDepthSensing}\n     * @ignore\n     */\n    depthSensing: XrDepthSensing;\n    /**\n     * Provides access to DOM overlay capabilities.\n     *\n     * @type {XrDomOverlay}\n     * @ignore\n     */\n    domOverlay: XrDomOverlay;\n    /**\n     * Provides the ability to perform hit tests on the representation of real world geometry\n     * of the underlying AR system.\n     *\n     * @type {XrHitTest}\n     */\n    hitTest: XrHitTest;\n    /**\n     * Provides access to image tracking capabilities.\n     *\n     * @type {XrImageTracking}\n     * @ignore\n     */\n    imageTracking: XrImageTracking;\n    /**\n     * Provides access to plane detection capabilities.\n     *\n     * @type {XrPlaneDetection}\n     * @ignore\n     */\n    planeDetection: XrPlaneDetection;\n    /**\n     * Provides access to Input Sources.\n     *\n     * @type {XrInput}\n     */\n    input: XrInput;\n    /**\n     * Provides access to light estimation capabilities.\n     *\n     * @type {XrLightEstimation}\n     * @ignore\n     */\n    lightEstimation: XrLightEstimation;\n    /**\n     * @type {CameraComponent}\n     * @private\n     */\n    private _camera;\n    /**\n     * @type {Array<*>}\n     * @ignore\n     */\n    views: Array<any>;\n    /**\n     * @type {Array<*>}\n     * @ignore\n     */\n    viewsPool: Array<any>;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private _localPosition;\n    /**\n     * @type {Quat}\n     * @private\n     */\n    private _localRotation;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _depthNear;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _depthFar;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _width;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _height;\n    /**\n     * @event\n     * @name XrManager#available\n     * @description Fired when availability of specific XR type is changed.\n     * @param {string} type - The session type that has changed availability.\n     * @param {boolean} available - True if specified session type is now available.\n     * @example\n     * app.xr.on(\'available\', function (type, available) {\n     *     console.log(\'"\' + type + \'" XR session is now \' + (available ? \'available\' : \'unavailable\'));\n     * });\n     */\n    /**\n     * @event\n     * @name XrManager#available:[type]\n     * @description Fired when availability of specific XR type is changed.\n     * @param {boolean} available - True if specified session type is now available.\n     * @example\n     * app.xr.on(\'available:\' + pc.XRTYPE_VR, function (available) {\n     *     console.log(\'Immersive VR session is now \' + (available ? \'available\' : \'unavailable\'));\n     * });\n     */\n    /**\n     * @event\n     * @name XrManager#start\n     * @description Fired when XR session is started.\n     * @example\n     * app.xr.on(\'start\', function () {\n     *     // XR session has started\n     * });\n     */\n    /**\n     * @event\n     * @name XrManager#end\n     * @description Fired when XR session is ended.\n     * @example\n     * app.xr.on(\'end\', function () {\n     *     // XR session has ended\n     * });\n     */\n    /**\n     * @event\n     * @name XrManager#update\n     * @param {object} frame - [XRFrame](https://developer.mozilla.org/en-US/docs/Web/API/XRFrame) object that can be used for interfacing directly with WebXR APIs.\n     * @description Fired when XR session is updated, providing relevant XRFrame object.\n     * @example\n     * app.xr.on(\'update\', function (frame) {\n     *\n     * });\n     */\n    /**\n     * @event\n     * @name XrManager#error\n     * @param {Error} error - Error object related to failure of session start or check of session type support.\n     * @description Fired when XR session is failed to start or failed to check for session type support.\n     * @example\n     * app.xr.on(\'error\', function (ex) {\n     *     // XR session has failed to start, or failed to check for session type support\n     * });\n     */\n    /**\n     * Attempts to start XR session for provided {@link CameraComponent} and optionally fires\n     * callback when session is created or failed to create. Integrated XR APIs need to be enabled\n     * by providing relevant options.\n     *\n     * @param {CameraComponent} camera - It will be used to render XR session and manipulated based\n     * on pose tracking.\n     * @param {string} type - Session type. Can be one of the following:\n     *\n     * - {@link XRTYPE_INLINE}: Inline - always available type of session. It has limited features\n     * availability and is rendered into HTML element.\n     * - {@link XRTYPE_VR}: Immersive VR - session that provides exclusive access to VR device with\n     * best available tracking features.\n     * - {@link XRTYPE_AR}: Immersive AR - session that provides exclusive access to VR/AR device\n     * that is intended to be blended with real-world environment.\n     *\n     * @param {string} spaceType - Reference space type. Can be one of the following:\n     *\n     * - {@link XRSPACE_VIEWER}: Viewer - always supported space with some basic tracking\n     * capabilities.\n     * - {@link XRSPACE_LOCAL}: Local - represents a tracking space with a native origin near the\n     * viewer at the time of creation. It is meant for seated or basic local XR sessions.\n     * - {@link XRSPACE_LOCALFLOOR}: Local Floor - represents a tracking space with a native origin\n     * at the floor in a safe position for the user to stand. The y axis equals 0 at floor level.\n     * Floor level value might be estimated by the underlying platform. It is meant for seated or\n     * basic local XR sessions.\n     * - {@link XRSPACE_BOUNDEDFLOOR}: Bounded Floor - represents a tracking space with its native\n     * origin at the floor, where the user is expected to move within a pre-established boundary.\n     * - {@link XRSPACE_UNBOUNDED}: Unbounded - represents a tracking space where the user is\n     * expected to move freely around their environment, potentially long distances from their\n     * starting point.\n     *\n     * @param {object} [options] - Object with additional options for XR session initialization.\n     * @param {string[]} [options.optionalFeatures] - Optional features for XRSession start. It is\n     * used for getting access to additional WebXR spec extensions.\n     * @param {boolean} [options.imageTracking] - Set to true to attempt to enable\n     * {@link XrImageTracking}.\n     * @param {boolean} [options.planeDetection] - Set to true to attempt to enable\n     * {@link XrPlaneDetection}.\n     * @param {XrErrorCallback} [options.callback] - Optional callback function called once session\n     * is started. The callback has one argument Error - it is null if successfully started XR\n     * session.\n     * @param {object} [options.depthSensing] - Optional object with depth sensing parameters to\n     * attempt to enable {@link XrDepthSensing}.\n     * @param {string} [options.depthSensing.usagePreference] - Optional usage preference for depth\n     * sensing, can be \'cpu-optimized\' or \'gpu-optimized\' (XRDEPTHSENSINGUSAGE_*), defaults to\n     * \'cpu-optimized\'. Most preferred and supported will be chosen by the underlying depth sensing\n     * system.\n     * @param {string} [options.depthSensing.dataFormatPreference] - Optional data format\n     * preference for depth sensing, can be \'luminance-alpha\' or \'float32\'\n     * (XRDEPTHSENSINGFORMAT_*), defaults to \'luminance-alpha\'. Most preferred and supported will\n     * be chosen by the underlying depth sensing system.\n     * @example\n     * button.on(\'click\', function () {\n     *     app.xr.start(camera, pc.XRTYPE_VR, pc.XRSPACE_LOCALFLOOR);\n     * });\n     * @example\n     * button.on(\'click\', function () {\n     *     app.xr.start(camera, pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR, {\n     *         depthSensing: { }\n     *     });\n     * });\n     */\n    start(camera: CameraComponent, type: string, spaceType: string, options?: {\n        optionalFeatures?: string[];\n        imageTracking?: boolean;\n        planeDetection?: boolean;\n        callback?: XrErrorCallback;\n        depthSensing?: {\n            usagePreference?: string;\n            dataFormatPreference?: string;\n        };\n    }): void;\n    /**\n     * @param {string} type - Session type.\n     * @param {string} spaceType - Reference space type.\n     * @param {*} options - Session options.\n     * @param {XrErrorCallback} callback - Error callback.\n     * @private\n     */\n    private _onStartOptionsReady;\n    /**\n     * Attempts to end XR session and optionally fires callback when session is ended or failed to\n     * end.\n     *\n     * @param {XrErrorCallback} [callback] - Optional callback function called once session is\n     * started. The callback has one argument Error - it is null if successfully started XR\n     * session.\n     * @example\n     * app.keyboard.on(\'keydown\', function (evt) {\n     *     if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n     *         app.xr.end();\n     *     }\n     * });\n     */\n    end(callback?: XrErrorCallback): void;\n    /**\n     * Check if specific type of session is available.\n     *\n     * @param {string} type - Session type. Can be one of the following:\n     *\n     * - {@link XRTYPE_INLINE}: Inline - always available type of session. It has limited features\n     * availability and is rendered into HTML element.\n     * - {@link XRTYPE_VR}: Immersive VR - session that provides exclusive access to VR device with\n     * best available tracking features.\n     * - {@link XRTYPE_AR}: Immersive AR - session that provides exclusive access to VR/AR device\n     * that is intended to be blended with real-world environment.\n     *\n     * @example\n     * if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n     *     // VR is available\n     * }\n     * @returns {boolean} True if specified session type is available.\n     */\n    isAvailable(type: string): boolean;\n    /** @private */\n    private _deviceAvailabilityCheck;\n    /**\n     * @param {string} type - Session type.\n     * @private\n     */\n    private _sessionSupportCheck;\n    /**\n     * @param {XRSession} session - XR session.\n     * @param {string} spaceType - Space type to request for the session.\n     * @param {Function} callback - Callback to call when session is started.\n     * @private\n     */\n    private _onSessionStart;\n    /**\n     * @param {number} near - Near plane distance.\n     * @param {number} far - Far plane distance.\n     * @private\n     */\n    private _setClipPlanes;\n    /**\n     * @param {*} frame - XRFrame from requestAnimationFrame callback.\n     * @ignore\n     */\n    update(frame: any): void;\n    /**\n     * True if XR is supported.\n     *\n     * @type {boolean}\n     */\n    get supported(): boolean;\n    /**\n     * True if XR session is running.\n     *\n     * @type {boolean}\n     */\n    get active(): boolean;\n    /**\n     * Returns type of currently running XR session or null if no session is running. Can be any of\n     * XRTYPE_*.\n     *\n     * @type {string|null}\n     */\n    get type(): string;\n    /**\n     * Returns reference space type of currently running XR session or null if no session is\n     * running. Can be any of XRSPACE_*.\n     *\n     * @type {string|null}\n     */\n    get spaceType(): string;\n    /**\n     * Provides access to XRSession of WebXR.\n     *\n     * @type {object|null}\n     */\n    get session(): any;\n    /**\n     * Active camera for which XR session is running or null.\n     *\n     * @type {Entity|null}\n     */\n    get camera(): Entity;\n    /**\n     * Indicates whether WebXR content is currently visible to the user, and if it is, whether it\'s\n     * the primary focus. Can be \'hidden\', \'visible\' or \'visible-blurred\'.\n     *\n     * @type {string}\n     * @ignore\n     */\n    get visibilityState(): string;\n}\n\n\n/** @typedef {import(\'./xr-hand.js\').XrHand} XrHand */\n/** @typedef {import(\'./xr-joint.js\').XrJoint} XrJoint */\n/**\n * Represents finger with related joints and index.\n */\ndeclare class XrFinger {\n    /**\n     * Create a new XrFinger instance.\n     *\n     * @param {number} index - Index of a finger.\n     * @param {XrHand} hand - Hand that finger relates to.\n     * @hideconstructor\n     */\n    constructor(index: number, hand: XrHand);\n    /**\n     * @type {number}\n     * @private\n     */\n    private _index;\n    /**\n     * @type {XrHand}\n     * @private\n     */\n    private _hand;\n    /**\n     * @type {XrJoint[]}\n     * @private\n     */\n    private _joints;\n    /**\n     * @type {XrJoint|null}\n     * @private\n     */\n    private _tip;\n    /**\n     * Index of a finger, numeration is: thumb, index, middle, ring, little.\n     *\n     * @type {number}\n     */\n    get index(): number;\n    /**\n     * Hand that finger relates to.\n     *\n     * @type {XrHand}\n     */\n    get hand(): XrHand;\n    /**\n     * List of joints that relates to this finger, starting from joint closest to wrist all the way\n     * to the tip of a finger.\n     *\n     * @type {XrJoint[]}\n     */\n    get joints(): XrJoint[];\n    /**\n     * Tip of a finger, or null if not available.\n     *\n     * @type {XrJoint|null}\n     */\n    get tip(): XrJoint;\n}\n\n\n\n/**\n * Represents the joint of a finger.\n */\ndeclare class XrJoint {\n    /**\n     * Create an XrJoint instance.\n     *\n     * @param {number} index - Index of a joint within a finger.\n     * @param {string} id - Id of a joint based on WebXR Hand Input Specs.\n     * @param {XrHand} hand - Hand that joint relates to.\n     * @param {XrFinger} [finger] - Finger that joint is related to, can be null in case of wrist.\n     * joint.\n     * @hideconstructor\n     */\n    constructor(index: number, id: string, hand: XrHand, finger?: XrFinger);\n    /**\n     * @type {number}\n     * @private\n     */\n    private _index;\n    /**\n     * @type {string}\n     * @private\n     */\n    private _id;\n    /**\n     * @type {XrHand}\n     * @private\n     */\n    private _hand;\n    /**\n     * @type {XrFinger}\n     * @private\n     */\n    private _finger;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _wrist;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _tip;\n    /**\n     * @type {number}\n     * @private\n     */\n    private _radius;\n    /**\n     * @type {Mat4}\n     * @private\n     */\n    private _localTransform;\n    /**\n     * @type {Mat4}\n     * @private\n     */\n    private _worldTransform;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private _localPosition;\n    /**\n     * @type {Quat}\n     * @private\n     */\n    private _localRotation;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private _position;\n    /**\n     * @type {Quat}\n     * @private\n     */\n    private _rotation;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _dirtyLocal;\n    /**\n     * @param {*} pose - XRJointPose of this joint.\n     * @ignore\n     */\n    update(pose: any): void;\n    /** @private */\n    private _updateTransforms;\n    /**\n     * Get the world space position of a joint.\n     *\n     * @returns {Vec3} The world space position of a joint.\n     */\n    getPosition(): Vec3;\n    /**\n     * Get the world space rotation of a joint.\n     *\n     * @returns {Quat} The world space rotation of a joint.\n     */\n    getRotation(): Quat;\n    /**\n     * Index of a joint within a finger, starting from 0 (root of a finger) all the way to tip of\n     * the finger.\n     *\n     * @type {number}\n     */\n    get index(): number;\n    /**\n     * Hand that joint relates to.\n     *\n     * @type {XrHand}\n     */\n    get hand(): XrHand;\n    /**\n     * Finger that joint relates to.\n     *\n     * @type {XrFinger|null}\n     */\n    get finger(): XrFinger;\n    /**\n     * True if joint is a wrist.\n     *\n     * @type {boolean}\n     */\n    get wrist(): boolean;\n    /**\n     * True if joint is a tip of a finger.\n     *\n     * @type {boolean}\n     */\n    get tip(): boolean;\n    /**\n     * The radius of a joint, which is a distance from joint to the edge of a skin.\n     *\n     * @type {number}\n     */\n    get radius(): number;\n}\n\n\n/**\n * Represents a hand with fingers and joints.\n *\n * @augments EventHandler\n */\ndeclare class XrHand extends EventHandler {\n    /**\n     * Represents a hand with fingers and joints.\n     *\n     * @param {XrInputSource} inputSource - Input Source that hand is related to.\n     * @hideconstructor\n     */\n    constructor(inputSource: XrInputSource);\n    /**\n     * @type {XrManager}\n     * @private\n     */\n    private _manager;\n    /**\n     * @type {XrInputSource}\n     * @private\n     */\n    private _inputSource;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _tracking;\n    /**\n     * @type {XrFinger[]}\n     * @private\n     */\n    private _fingers;\n    /**\n     * @type {XrJoint[]}\n     * @private\n     */\n    private _joints;\n    /**\n     * @type {Object.<string, XrJoint>}\n     * @private\n     */\n    private _jointsById;\n    /**\n     * @type {XrJoint[]}\n     * @private\n     */\n    private _tips;\n    /**\n     * @type {XrJoint|null}\n     * @private\n     */\n    private _wrist;\n    /**\n     * @event\n     * @name XrHand#tracking\n     * @description Fired when tracking becomes available.\n     */\n    /**\n     * @event\n     * @name XrHand#trackinglost\n     * @description Fired when tracking is lost.\n     */\n    /**\n     * @param {*} frame - XRFrame from requestAnimationFrame callback.\n     * @ignore\n     */\n    update(frame: any): void;\n    /**\n     * @param {number} index - Finger index.\n     * @returns {boolean} True if finger is closed and false otherwise.\n     * @private\n     */\n    private _fingerIsClosed;\n    /**\n     * Returns joint by XRHand id from list in specs: https://immersive-web.github.io/webxr-hand-input/.\n     *\n     * @param {string} id - Id of a joint based on specs ID\'s in XRHand: https://immersive-web.github.io/webxr-hand-input/.\n     * @returns {XrJoint|null} Joint or null if not available.\n     */\n    getJointById(id: string): XrJoint | null;\n    /**\n     * List of fingers of a hand.\n     *\n     * @type {XrFinger[]}\n     */\n    get fingers(): XrFinger[];\n    /**\n     * List of joints of hand.\n     *\n     * @type {XrJoint[]}\n     */\n    get joints(): XrJoint[];\n    /**\n     * List of joints that are fingertips.\n     *\n     * @type {XrJoint[]}\n     */\n    get tips(): XrJoint[];\n    /**\n     * Wrist of a hand, or null if it is not available by WebXR underlying system.\n     *\n     * @type {XrJoint|null}\n     */\n    get wrist(): XrJoint;\n    /**\n     * True if tracking is available, otherwise tracking might be lost.\n     *\n     * @type {boolean}\n     */\n    get tracking(): boolean;\n}\n\n\n\n/**\n * Represents XR input source, which is any input mechanism which allows the user to perform\n * targeted actions in the same virtual space as the viewer. Example XR input sources include, but\n * are not limited to, handheld controllers, optically tracked hands, and gaze-based input methods\n * that operate on the viewer\'s pose.\n *\n * @augments EventHandler\n */\ndeclare class XrInputSource extends EventHandler {\n    /**\n     * Create a new XrInputSource instance.\n     *\n     * @param {XrManager} manager - WebXR Manager.\n     * @param {*} xrInputSource - [XRInputSource](https://developer.mozilla.org/en-US/docs/Web/API/XRInputSource)\n     * object that is created by WebXR API.\n     * @hideconstructor\n     */\n    constructor(manager: XrManager, xrInputSource: any);\n    /**\n     * @type {number}\n     * @private\n     */\n    private _id;\n    /**\n     * @type {XrManager}\n     * @private\n     */\n    private _manager;\n    /**\n     * @type {XRInputSource}\n     * @private\n     */\n    private _xrInputSource;\n    /**\n     * @type {Ray}\n     * @private\n     */\n    private _ray;\n    /**\n     * @type {Ray}\n     * @private\n     */\n    private _rayLocal;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _grip;\n    /**\n     * @type {XrHand}\n     * @private\n     */\n    private _hand;\n    /**\n     * @type {Mat4|null}\n     * @private\n     */\n    private _localTransform;\n    /**\n     * @type {Mat4|null}\n     * @private\n     */\n    private _worldTransform;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private _position;\n    /**\n     * @type {Quat}\n     * @private\n     */\n    private _rotation;\n    /**\n     * @type {Mat4|null}\n     * @private\n     */\n    private _localPosition;\n    /**\n     * @type {Mat4|null}\n     * @private\n     */\n    private _localRotation;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _dirtyLocal;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _dirtyRay;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _selecting;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _squeezing;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    private _elementInput;\n    /**\n     * @type {Entity|null}\n     * @private\n     */\n    private _elementEntity;\n    /**\n     * @type {XrHitTestSource[]}\n     * @private\n     */\n    private _hitTestSources;\n    /**\n     * Unique number associated with instance of input source. Same physical devices when\n     * reconnected will not share this ID.\n     *\n     * @type {number}\n     */\n    get id(): number;\n    /**\n     * XRInputSource object that is associated with this input source.\n     *\n     * @type {object}\n     */\n    get inputSource(): any;\n    /**\n     * Type of ray Input Device is based on. Can be one of the following:\n     *\n     * - {@link XRTARGETRAY_GAZE}: Gaze - indicates the target ray will originate at the viewer and\n     * follow the direction it is facing. This is commonly referred to as a "gaze input" device in\n     * the context of head-mounted displays.\n     * - {@link XRTARGETRAY_SCREEN}: Screen - indicates that the input source was an interaction\n     * with the canvas element associated with an inline session\'s output context, such as a mouse\n     * click or touch event.\n     * - {@link XRTARGETRAY_POINTER}: Tracked Pointer - indicates that the target ray originates\n     * from either a handheld device or other hand-tracking mechanism and represents that the user\n     * is using their hands or the held device for pointing.\n     *\n     * @type {string}\n     */\n    get targetRayMode(): string;\n    /**\n     * Describes which hand input source is associated with. Can be one of the following:\n     *\n     * - {@link XRHAND_NONE}: None - input source is not meant to be held in hands.\n     * - {@link XRHAND_LEFT}: Left - indicates that input source is meant to be held in left hand.\n     * - {@link XRHAND_RIGHT}: Right - indicates that input source is meant to be held in right\n     * hand.\n     *\n     * @type {string}\n     */\n    get handedness(): string;\n    /**\n     * List of input profile names indicating both the preferred visual representation and behavior\n     * of the input source.\n     *\n     * @type {string[]}\n     */\n    get profiles(): string[];\n    /**\n     * If input source can be held, then it will have node with its world transformation, that can\n     * be used to position and rotate virtual joysticks based on it.\n     *\n     * @type {boolean}\n     */\n    get grip(): boolean;\n    /**\n     * If input source is a tracked hand, then it will point to {@link XrHand} otherwise it is\n     * null.\n     *\n     * @type {XrHand|null}\n     */\n    get hand(): XrHand;\n    /**\n     * If input source has buttons, triggers, thumbstick or touchpad, then this object provides\n     * access to its states.\n     *\n     * @type {Gamepad|null}\n     */\n    get gamepad(): Gamepad;\n    /**\n     * True if input source is in active primary action between selectstart and selectend events.\n     *\n     * @type {boolean}\n     */\n    get selecting(): boolean;\n    /**\n     * True if input source is in active squeeze action between squeezestart and squeezeend events.\n     *\n     * @type {boolean}\n     */\n    get squeezing(): boolean;\n    /**\n     * Set to true to allow input source to interact with Element components. Defaults to true.\n     *\n     * @type {boolean}\n     */\n    set elementInput(arg: boolean);\n    get elementInput(): boolean;\n    /**\n     * If {@link XrInputSource#elementInput} is true, this property will hold entity with Element\n     * component at which this input source is hovering, or null if not hovering over any element.\n     *\n     * @type {Entity|null}\n     */\n    get elementEntity(): Entity;\n    /**\n     * List of active {@link XrHitTestSource} instances created by this input source.\n     *\n     * @type {XrHitTestSource[]}\n     */\n    get hitTestSources(): XrHitTestSource[];\n    /**\n     * @event\n     * @name XrInputSource#remove\n     * @description Fired when {@link XrInputSource} is removed.\n     * @example\n     * inputSource.once(\'remove\', function () {\n     *     // input source is not available anymore\n     * });\n     */\n    /**\n     * @event\n     * @name XrInputSource#select\n     * @description Fired when input source has triggered primary action. This could be pressing a trigger button, or touching a screen.\n     * @param {object} evt - XRInputSourceEvent event data from WebXR API.\n     * @example\n     * var ray = new pc.Ray();\n     * inputSource.on(\'select\', function (evt) {\n     *     ray.set(inputSource.getOrigin(), inputSource.getDirection());\n     *     if (obj.intersectsRay(ray)) {\n     *         // selected an object with input source\n     *     }\n     * });\n     */\n    /**\n     * @event\n     * @name XrInputSource#selectstart\n     * @description Fired when input source has started to trigger primary action.\n     * @param {object} evt - XRInputSourceEvent event data from WebXR API.\n     */\n    /**\n     * @event\n     * @name XrInputSource#selectend\n     * @description Fired when input source has ended triggering primary action.\n     * @param {object} evt - XRInputSourceEvent event data from WebXR API.\n     */\n    /**\n     * @event\n     * @name XrInputSource#squeeze\n     * @description Fired when input source has triggered squeeze action. This is associated with "grabbing" action on the controllers.\n     * @param {object} evt - XRInputSourceEvent event data from WebXR API.\n     */\n    /**\n     * @event\n     * @name XrInputSource#squeezestart\n     * @description Fired when input source has started to trigger squeeze action.\n     * @param {object} evt - XRInputSourceEvent event data from WebXR API.\n     * @example\n     * inputSource.on(\'squeezestart\', function (evt) {\n     *     if (obj.containsPoint(inputSource.getPosition())) {\n     *         // grabbed an object\n     *     }\n     * });\n     */\n    /**\n     * @event\n     * @name XrInputSource#squeezeend\n     * @description Fired when input source has ended triggering squeeze action.\n     * @param {object} evt - XRInputSourceEvent event data from WebXR API.\n     */\n    /**\n     * @event\n     * @name XrInputSource#hittest:add\n     * @description Fired when new {@link XrHitTestSource} is added to the input source.\n     * @param {XrHitTestSource} hitTestSource - Hit test source that has been added.\n     * @example\n     * inputSource.on(\'hittest:add\', function (hitTestSource) {\n     *     // new hit test source is added\n     * });\n     */\n    /**\n     * @event\n     * @name XrInputSource#hittest:remove\n     * @description Fired when {@link XrHitTestSource} is removed to the the input source.\n     * @param {XrHitTestSource} hitTestSource - Hit test source that has been removed.\n     * @example\n     * inputSource.on(\'remove\', function (hitTestSource) {\n     *     // hit test source is removed\n     * });\n     */\n    /**\n     * @event\n     * @name XrInputSource#hittest:result\n     * @description Fired when hit test source receives new results. It provides transform information that tries to match real world picked geometry.\n     * @param {XrHitTestSource} hitTestSource - Hit test source that produced the hit result.\n     * @param {Vec3} position - Position of hit test.\n     * @param {Quat} rotation - Rotation of hit test.\n     * @example\n     * inputSource.on(\'hittest:result\', function (hitTestSource, position, rotation) {\n     *     target.setPosition(position);\n     *     target.setRotation(rotation);\n     * });\n     */\n    /**\n     * @param {*} frame - XRFrame from requestAnimationFrame callback.\n     * @ignore\n     */\n    update(frame: any): void;\n    /** @private */\n    private _updateTransforms;\n    /** @private */\n    private _updateRayTransforms;\n    /**\n     * Get the world space position of input source if it is handheld ({@link XrInputSource#grip}\n     * is true). Otherwise it will return null.\n     *\n     * @returns {Vec3|null} The world space position of handheld input source.\n     */\n    getPosition(): Vec3 | null;\n    /**\n     * Get the local space position of input source if it is handheld ({@link XrInputSource#grip}\n     * is true). Local space is relative to parent of the XR camera. Otherwise it will return null.\n     *\n     * @returns {Vec3|null} The world space position of handheld input source.\n     */\n    getLocalPosition(): Vec3 | null;\n    /**\n     * Get the world space rotation of input source if it is handheld ({@link XrInputSource#grip}\n     * is true). Otherwise it will return null.\n     *\n     * @returns {Quat|null} The world space rotation of handheld input source.\n     */\n    getRotation(): Quat | null;\n    /**\n     * Get the local space rotation of input source if it is handheld ({@link XrInputSource#grip}\n     * is true). Local space is relative to parent of the XR camera. Otherwise it will return null.\n     *\n     * @returns {Vec3|null} The world space rotation of handheld input source.\n     */\n    getLocalRotation(): Vec3 | null;\n    /**\n     * Get the world space origin of input source ray.\n     *\n     * @returns {Vec3} The world space origin of input source ray.\n     */\n    getOrigin(): Vec3;\n    /**\n     * Get the world space direction of input source ray.\n     *\n     * @returns {Vec3} The world space direction of input source ray.\n     */\n    getDirection(): Vec3;\n    /**\n     * Attempts to start hit test source based on this input source.\n     *\n     * @param {object} [options] - Object for passing optional arguments.\n     * @param {string[]} [options.entityTypes] - Optional list of underlying entity types against\n     * which hit tests will be performed. Defaults to [ {@link XRTRACKABLE_PLANE} ]. Can be any\n     * combination of the following:\n     *\n     * - {@link XRTRACKABLE_POINT}: Point - indicates that the hit test results will be computed\n     * based on the feature points detected by the underlying Augmented Reality system.\n     * - {@link XRTRACKABLE_PLANE}: Plane - indicates that the hit test results will be computed\n     * based on the planes detected by the underlying Augmented Reality system.\n     * - {@link XRTRACKABLE_MESH}: Mesh - indicates that the hit test results will be computed\n     * based on the meshes detected by the underlying Augmented Reality system.\n     *\n     * @param {Ray} [options.offsetRay] - Optional ray by which hit test ray can be offset.\n     * @param {XrHitTestStartCallback} [options.callback] - Optional callback function called once\n     * hit test source is created or failed.\n     * @example\n     * app.xr.input.on(\'add\', function (inputSource) {\n     *     inputSource.hitTestStart({\n     *         callback: function (err, hitTestSource) {\n     *             if (err) return;\n     *             hitTestSource.on(\'result\', function (position, rotation) {\n     *                 // position and rotation of hit test result\n     *                 // that will be created from touch on mobile devices\n     *             });\n     *         }\n     *     });\n     * });\n     */\n    hitTestStart(options?: {\n        entityTypes?: string[];\n        offsetRay?: Ray;\n        callback?: XrHitTestStartCallback;\n    }): void;\n    /**\n     * @param {XrHitTestSource} hitTestSource - Hit test source to be added.\n     * @private\n     */\n    private onHitTestSourceAdd;\n    /**\n     * @param {XrHitTestSource} hitTestSource - Hit test source to be removed.\n     * @private\n     */\n    private onHitTestSourceRemove;\n}\n\n\n\n\n/**\n * Handles mouse and touch events for {@link ElementComponent}s. When input events occur on an\n * ElementComponent this fires the appropriate events on the ElementComponent.\n */\ndeclare class ElementInput {\n    /**\n     * Create a new ElementInput instance.\n     *\n     * @param {Element} domElement - The DOM element.\n     * @param {object} [options] - Optional arguments.\n     * @param {boolean} [options.useMouse] - Whether to allow mouse input. Defaults to true.\n     * @param {boolean} [options.useTouch] - Whether to allow touch input. Defaults to true.\n     * @param {boolean} [options.useXr] - Whether to allow XR input sources. Defaults to true.\n     */\n    constructor(domElement: Element, options?: {\n        useMouse?: boolean;\n        useTouch?: boolean;\n        useXr?: boolean;\n    });\n    _app: any;\n    _attached: boolean;\n    _target: Element;\n    _enabled: boolean;\n    _lastX: number;\n    _lastY: number;\n    _upHandler: any;\n    _downHandler: any;\n    _moveHandler: any;\n    _wheelHandler: any;\n    _touchstartHandler: any;\n    _touchendHandler: any;\n    _touchcancelHandler: any;\n    _touchmoveHandler: any;\n    _sortHandler: any;\n    _elements: any[];\n    _hoveredElement: any;\n    _pressedElement: any;\n    _touchedElements: {};\n    _touchesForWhichTouchLeaveHasFired: {};\n    _selectedElements: {};\n    _selectedPressedElements: {};\n    _useMouse: boolean;\n    _useTouch: boolean;\n    _useXr: boolean;\n    _selectEventsAttached: boolean;\n    _clickedEntities: {};\n    set enabled(arg: boolean);\n    get enabled(): boolean;\n    set app(arg: any);\n    get app(): any;\n    /**\n     * Attach mouse and touch events to a DOM element.\n     *\n     * @param {Element} domElement - The DOM element.\n     */\n    attach(domElement: Element): void;\n    attachSelectEvents(): void;\n    /**\n     * Remove mouse and touch events from the DOM element that it is attached to.\n     */\n    detach(): void;\n    /**\n     * Add a {@link ElementComponent} to the internal list of ElementComponents that are being\n     * checked for input.\n     *\n     * @param {ElementComponent} element - The ElementComponent.\n     */\n    addElement(element: ElementComponent): void;\n    /**\n     * Remove a {@link ElementComponent} from the internal list of ElementComponents that are being\n     * checked for input.\n     *\n     * @param {ElementComponent} element - The ElementComponent.\n     */\n    removeElement(element: ElementComponent): void;\n    _handleUp(event: any): void;\n    _handleDown(event: any): void;\n    _handleMove(event: any): void;\n    _handleWheel(event: any): void;\n    _determineTouchedElements(event: any): {};\n    _handleTouchStart(event: any): void;\n    _handleTouchEnd(event: any): void;\n    _handleTouchMove(event: any): void;\n    _onElementMouseEvent(eventType: any, event: any): void;\n    _onXrStart(): void;\n    _onXrEnd(): void;\n    _onXrUpdate(): void;\n    _onXrInputRemove(inputSource: any): void;\n    _onSelectStart(inputSource: any, event: any): void;\n    _onSelectEnd(inputSource: any, event: any): void;\n    _onElementSelectEvent(eventType: any, inputSource: any, event: any): void;\n    _fireEvent(name: any, evt: any): void;\n    _calcMouseCoords(event: any): void;\n    _calcTouchCoords(touch: any): {\n        x: number;\n        y: number;\n    };\n    _sortElements(a: any, b: any): any;\n    _getTargetElement(camera: any, x: any, y: any): any;\n    _getTargetElementByRay(ray: any, camera: any): any;\n    _buildHitCorners(element: any, screenOrWorldCorners: any, scaleX: any, scaleY: any, scaleZ: any): any;\n    _calculateScaleToScreen(element: any): Vec3;\n    _calculateScaleToWorld(element: any): Vec3;\n    _calculateRayScreen(x: any, y: any, camera: any, ray: any): boolean;\n    _calculateRay3d(x: any, y: any, camera: any, ray: any): boolean;\n    _checkElement(ray: any, element: any, screen: any): number;\n}\n/**\n * Represents an input event fired on a {@link ElementComponent}. When an event is raised on an\n * ElementComponent it bubbles up to its parent ElementComponents unless we call stopPropagation().\n */\ndeclare class ElementInputEvent {\n    /**\n     * Create a new ElementInputEvent instance.\n     *\n     * @param {MouseEvent|TouchEvent} event - The MouseEvent or TouchEvent that was originally\n     * raised.\n     * @param {ElementComponent} element - The ElementComponent that this event was originally\n     * raised on.\n     * @param {CameraComponent} camera - The CameraComponent that this event was originally raised\n     * via.\n     */\n    constructor(event: MouseEvent | TouchEvent, element: ElementComponent, camera: CameraComponent);\n    /**\n     * The MouseEvent or TouchEvent that was originally raised.\n     *\n     * @type {MouseEvent|TouchEvent}\n     */\n    event: MouseEvent | TouchEvent;\n    /**\n     * The ElementComponent that this event was originally raised on.\n     *\n     * @type {ElementComponent}\n     */\n    element: ElementComponent;\n    /**\n     * The CameraComponent that this event was originally raised via.\n     *\n     * @type {CameraComponent}\n     */\n    camera: CameraComponent;\n    _stopPropagation: boolean;\n    /**\n     * Stop propagation of the event to parent {@link ElementComponent}s. This also stops\n     * propagation of the event to other event listeners of the original DOM Event.\n     */\n    stopPropagation(): void;\n}\n/**\n * Represents a Mouse event fired on a {@link ElementComponent}.\n *\n * @augments ElementInputEvent\n */\ndeclare class ElementMouseEvent extends ElementInputEvent {\n    /**\n     * Create an instance of an ElementMouseEvent.\n     *\n     * @param {MouseEvent} event - The MouseEvent that was originally raised.\n     * @param {ElementComponent} element - The ElementComponent that this event was originally\n     * raised on.\n     * @param {CameraComponent} camera - The CameraComponent that this event was originally raised\n     * via.\n     * @param {number} x - The x coordinate.\n     * @param {number} y - The y coordinate.\n     * @param {number} lastX - The last x coordinate.\n     * @param {number} lastY - The last y coordinate.\n     */\n    constructor(event: MouseEvent, element: ElementComponent, camera: CameraComponent, x: number, y: number, lastX: number, lastY: number);\n    x: number;\n    y: number;\n    /**\n     * Whether the ctrl key was pressed.\n     *\n     * @type {boolean}\n     */\n    ctrlKey: boolean;\n    /**\n     * Whether the alt key was pressed.\n     *\n     * @type {boolean}\n     */\n    altKey: boolean;\n    /**\n     * Whether the shift key was pressed.\n     *\n     * @type {boolean}\n     */\n    shiftKey: boolean;\n    /**\n     * Whether the meta key was pressed.\n     *\n     * @type {boolean}\n     */\n    metaKey: boolean;\n    /**\n     * The mouse button.\n     *\n     * @type {number}\n     */\n    button: number;\n    /**\n     * The amount of horizontal movement of the cursor.\n     *\n     * @type {number}\n     */\n    dx: number;\n    /**\n     * The amount of vertical movement of the cursor.\n     *\n     * @type {number}\n     */\n    dy: number;\n    /**\n     * The amount of the wheel movement.\n     *\n     * @type {number}\n     */\n    wheelDelta: number;\n}\n/**\n * Represents a XRInputSourceEvent fired on a {@link ElementComponent}.\n *\n * @augments ElementInputEvent\n */\ndeclare class ElementSelectEvent extends ElementInputEvent {\n    /**\n     * Create an instance of a ElementSelectEvent.\n     *\n     * @param {object} event - The XRInputSourceEvent that was originally raised.\n     * @param {ElementComponent} element - The ElementComponent that this event was originally\n     * raised on.\n     * @param {CameraComponent} camera - The CameraComponent that this event was originally raised\n     * via.\n     * @param {XrInputSource} inputSource - The XR input source that this event was originally\n     * raised from.\n     */\n    constructor(event: object, element: ElementComponent, camera: CameraComponent, inputSource: XrInputSource);\n    /**\n     * The XR input source that this event was originally raised from.\n     *\n     * @type {XrInputSource}\n     */\n    inputSource: XrInputSource;\n}\n/**\n * Represents a TouchEvent fired on a {@link ElementComponent}.\n *\n * @augments ElementInputEvent\n */\ndeclare class ElementTouchEvent extends ElementInputEvent {\n    /**\n     * Create an instance of an ElementTouchEvent.\n     *\n     * @param {TouchEvent} event - The TouchEvent that was originally raised.\n     * @param {ElementComponent} element - The ElementComponent that this event was originally\n     * raised on.\n     * @param {CameraComponent} camera - The CameraComponent that this event was originally raised\n     * via.\n     * @param {number} x - The x coordinate of the touch that triggered the event.\n     * @param {number} y - The y coordinate of the touch that triggered the event.\n     * @param {Touch} touch - The touch object that triggered the event.\n     */\n    constructor(event: TouchEvent, element: ElementComponent, camera: CameraComponent, x: number, y: number, touch: Touch);\n    /**\n     * The Touch objects representing all current points of contact with the surface,\n     * regardless of target or changed status.\n     *\n     * @type {Touch[]}\n     */\n    touches: Touch[];\n    /**\n     * The Touch objects representing individual points of contact whose states changed between\n     * the previous touch event and this one.\n     *\n     * @type {Touch[]}\n     */\n    changedTouches: Touch[];\n    x: number;\n    y: number;\n    /**\n     * The touch object that triggered the event.\n     *\n     * @type {Touch}\n     */\n    touch: Touch;\n}\n\n\n/** @typedef {import(\'../graphics/graphics-device.js\').GraphicsDevice} GraphicsDevice */\n/**\n * Records performance-related statistics related to the application.\n *\n * @ignore\n */\ndeclare class ApplicationStats {\n    /**\n     * Create a new ApplicationStats instance.\n     *\n     * @param {GraphicsDevice} device - The graphics device.\n     */\n    constructor(device: GraphicsDevice);\n    frame: {\n        fps: number;\n        ms: number;\n        dt: number;\n        updateStart: number;\n        updateTime: number;\n        renderStart: number;\n        renderTime: number;\n        physicsStart: number;\n        physicsTime: number;\n        cullTime: number;\n        sortTime: number;\n        skinTime: number;\n        morphTime: number;\n        instancingTime: number;\n        triangles: number;\n        otherPrimitives: number;\n        shaders: number;\n        materials: number;\n        cameras: number;\n        shadowMapUpdates: number;\n        shadowMapTime: number;\n        depthMapTime: number;\n        forwardTime: number;\n        lightClustersTime: number;\n        lightClusters: number;\n        _timeToCountFrames: number;\n        _fpsAccum: number;\n    };\n    drawCalls: {\n        forward: number;\n        depth: number;\n        shadow: number;\n        immediate: number;\n        misc: number;\n        total: number;\n        skinned: number;\n        instanced: number;\n        removedByInstancing: number;\n    };\n    misc: {\n        renderTargetCreationTime: number;\n    };\n    particles: {\n        updatesPerFrame: number;\n        _updatesPerFrame: number;\n        frameTime: number;\n        _frameTime: number;\n    };\n    shaders: {\n        vsCompiled: number;\n        fsCompiled: number;\n        linked: number;\n        materialShaders: number;\n        compileTime: number;\n    };\n    vram: {\n        texShadow: number;\n        texAsset: number;\n        texLightmap: number;\n        tex: number;\n        vb: number;\n        ib: number;\n    };\n    get scene(): any;\n    get lightmapper(): any;\n    get batcher(): any;\n}\n\n\n/** @typedef {import(\'./mat4.js\').Mat4} Mat4 */\n/**\n * A 3x3 matrix.\n */\ndeclare class Mat3 {\n    /**\n     * A constant matrix set to the identity.\n     *\n     * @type {Mat3}\n     * @readonly\n     */\n    static readonly IDENTITY: Mat3;\n    /**\n     * A constant matrix with all elements set to 0.\n     *\n     * @type {Mat3}\n     * @readonly\n     */\n    static readonly ZERO: Mat3;\n    /**\n     * Matrix elements in the form of a flat array.\n     *\n     * @type {Float32Array}\n     */\n    data: Float32Array;\n    /**\n     * Creates a duplicate of the specified matrix.\n     *\n     * @returns {Mat3} A duplicate matrix.\n     * @example\n     * var src = new pc.Mat3().translate(10, 20, 30);\n     * var dst = src.clone();\n     * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));\n     */\n    clone(): Mat3;\n    /**\n     * Copies the contents of a source 3x3 matrix to a destination 3x3 matrix.\n     *\n     * @param {Mat3} rhs - A 3x3 matrix to be copied.\n     * @returns {Mat3} Self for chaining.\n     * @example\n     * var src = new pc.Mat3().translate(10, 20, 30);\n     * var dst = new pc.Mat3();\n     * dst.copy(src);\n     * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));\n     */\n    copy(rhs: Mat3): Mat3;\n    /**\n     * Copies the contents of a source array[9] to a destination 3x3 matrix.\n     *\n     * @param {number[]} src - An array[9] to be copied.\n     * @returns {Mat3} Self for chaining.\n     * @example\n     * var dst = new pc.Mat3();\n     * dst.set([0, 1, 2, 3, 4, 5, 6, 7, 8]);\n     */\n    set(src: number[]): Mat3;\n    /**\n     * Reports whether two matrices are equal.\n     *\n     * @param {Mat3} rhs - The other matrix.\n     * @returns {boolean} True if the matrices are equal and false otherwise.\n     * @example\n     * var a = new pc.Mat3().translate(10, 20, 30);\n     * var b = new pc.Mat3();\n     * console.log("The two matrices are " + (a.equals(b) ? "equal" : "different"));\n     */\n    equals(rhs: Mat3): boolean;\n    /**\n     * Reports whether the specified matrix is the identity matrix.\n     *\n     * @returns {boolean} True if the matrix is identity and false otherwise.\n     * @example\n     * var m = new pc.Mat3();\n     * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));\n     */\n    isIdentity(): boolean;\n    /**\n     * Sets the matrix to the identity matrix.\n     *\n     * @returns {Mat3} Self for chaining.\n     * @example\n     * m.setIdentity();\n     * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));\n     */\n    setIdentity(): Mat3;\n    /**\n     * Converts the matrix to string form.\n     *\n     * @returns {string} The matrix in string form.\n     * @example\n     * var m = new pc.Mat3();\n     * // Outputs [1, 0, 0, 0, 1, 0, 0, 0, 1]\n     * console.log(m.toString());\n     */\n    toString(): string;\n    /**\n     * Generates the transpose of the specified 3x3 matrix.\n     *\n     * @returns {Mat3} Self for chaining.\n     * @example\n     * var m = new pc.Mat3();\n     *\n     * // Transpose in place\n     * m.transpose();\n     */\n    transpose(): Mat3;\n    /**\n     * Converts the specified 4x4 matrix to a Mat3.\n     *\n     * @param {Mat4} m - The 4x4 matrix to convert.\n     * @returns {Mat3} Self for chaining.\n     */\n    setFromMat4(m: Mat4): Mat3;\n    /**\n     * Transforms a 3-dimensional vector by a 3x3 matrix.\n     *\n     * @param {Vec3} vec - The 3-dimensional vector to be transformed.\n     * @param {Vec3} [res] - An optional 3-dimensional vector to receive the result of the\n     * transformation.\n     * @returns {Vec3} The input vector v transformed by the current instance.\n     */\n    transformVector(vec: Vec3, res?: Vec3): Vec3;\n}\n\ndeclare class LightingParams {\n    constructor(supportsAreaLights: any, maxTextureSize: any, dirtyLightsFnc: any);\n    _maxTextureSize: any;\n    _supportsAreaLights: any;\n    _dirtyLightsFnc: any;\n    _areaLightsEnabled: boolean;\n    _cells: Vec3;\n    _maxLightsPerCell: number;\n    _shadowsEnabled: boolean;\n    _shadowType: number;\n    _shadowAtlasResolution: number;\n    _cookiesEnabled: boolean;\n    _cookieAtlasResolution: number;\n    atlasSplit: any;\n    debugLayer: any;\n    set cells(arg: Vec3);\n    get cells(): Vec3;\n    set maxLightsPerCell(arg: number);\n    get maxLightsPerCell(): number;\n    set cookieAtlasResolution(arg: number);\n    get cookieAtlasResolution(): number;\n    set shadowAtlasResolution(arg: number);\n    get shadowAtlasResolution(): number;\n    set shadowType(arg: number);\n    get shadowType(): number;\n    set cookiesEnabled(arg: boolean);\n    get cookiesEnabled(): boolean;\n    set areaLightsEnabled(arg: boolean);\n    get areaLightsEnabled(): boolean;\n    set shadowsEnabled(arg: boolean);\n    get shadowsEnabled(): boolean;\n}\n\n\n/** @typedef {import(\'../../graphics/texture.js\').Texture} Texture */\n/**\n * A BasicMaterial is for rendering unlit geometry, either using a constant color or a color map\n * modulated with a color.\n *\n * @augments Material\n */\ndeclare class BasicMaterial extends Material {\n    /**\n     * The flat color of the material (RGBA, where each component is 0 to 1).\n     *\n     * @type {Color}\n     */\n    color: Color;\n    colorUniform: Float32Array;\n    /**\n     * The color map of the material (default is null). If specified, the color map is\n     * modulated by the color property.\n     *\n     * @type {Texture|null}\n     */\n    colorMap: Texture | null;\n    vertexColors: boolean;\n    /**\n     * Copy a `BasicMaterial`.\n     *\n     * @param {BasicMaterial} source - The material to copy from.\n     * @returns {BasicMaterial} The destination material.\n     */\n    copy(source: BasicMaterial): BasicMaterial;\n}\n\ndeclare class Immediate {\n    static getTextureVS(): string;\n    constructor(device: any);\n    device: any;\n    quadMesh: Mesh;\n    textureShader: Shader;\n    depthTextureShader: Shader;\n    cubeLocalPos: any;\n    cubeWorldPos: any;\n    batchesMap: Map<any, any>;\n    allBatches: Set<any>;\n    updatedLayers: Set<any>;\n    _materialDepth: BasicMaterial;\n    _materialNoDepth: BasicMaterial;\n    layerMeshInstances: Map<any, any>;\n    createMaterial(depthTest: any): BasicMaterial;\n    get materialDepth(): BasicMaterial;\n    get materialNoDepth(): BasicMaterial;\n    getBatch(layer: any, depthTest: any): any;\n    getTextureShader(): Shader;\n    getDepthTextureShader(): Shader;\n    getQuadMesh(): Mesh;\n    drawMesh(material: any, matrix: any, mesh: any, meshInstance: any, layer: any): void;\n    drawWireAlignedBox(min: any, max: any, color: any, depthTest: any, layer: any): void;\n    drawWireSphere(center: any, radius: any, color: any, numSegments: any, depthTest: any, layer: any): void;\n    getGraphNode(matrix: any): GraphNode;\n    onPreRenderLayer(layer: any, visibleList: any, transparent: any): void;\n    onPostRender(): void;\n}\n\n\n\n\n/** @typedef {import(\'../framework/entity.js\').Entity} Entity */\n/** @typedef {import(\'../graphics/graphics-device.js\').GraphicsDevice} GraphicsDevice */\n/** @typedef {import(\'../graphics/texture.js\').Texture} Texture */\n/** @typedef {import(\'./composition/layer-composition.js\').LayerComposition} LayerComposition */\n/** @typedef {import(\'./layer.js\').Layer} Layer */\n/**\n * A scene is graphical representation of an environment. It manages the scene hierarchy, all\n * graphical objects, lights, and scene-wide properties.\n *\n * @augments EventHandler\n */\ndeclare class Scene extends EventHandler {\n    /**\n     * Create a new Scene instance.\n     *\n     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this scene.\n     * @hideconstructor\n     */\n    constructor(graphicsDevice: GraphicsDevice);\n    /**\n     * If enabled, the ambient lighting will be baked into lightmaps. This will be either the\n     * {@link Scene#skybox} if set up, otherwise {@link Scene#ambientLight}. Defaults to false.\n     *\n     * @type {boolean}\n     */\n    ambientBake: boolean;\n    /**\n     * If {@link Scene#ambientBake} is true, this specifies the brightness of ambient occlusion.\n     * Typical range is -1 to 1. Defaults to 0, representing no change to brightness.\n     *\n     * @type {number}\n     */\n    ambientBakeOcclusionBrightness: number;\n    /**\n     * If {@link Scene#ambientBake} is true, this specifies the contrast of ambient occlusion.\n     * Typical range is -1 to 1. Defaults to 0, representing no change to contrast.\n     *\n     * @type {number}\n     */\n    ambientBakeOcclusionContrast: number;\n    /**\n     * The color of the scene\'s ambient light. Defaults to black (0, 0, 0).\n     *\n     * @type {Color}\n     */\n    ambientLight: Color;\n    /**\n     * The exposure value tweaks the overall brightness of the scene. Defaults to 1.\n     *\n     * @type {number}\n     */\n    exposure: number;\n    /**\n     * The color of the fog (if enabled). Defaults to black (0, 0, 0).\n     *\n     * @type {Color}\n     */\n    fogColor: Color;\n    /**\n     * The density of the fog (if enabled). This property is only valid if the fog property is set\n     * to {@link FOG_EXP} or {@link FOG_EXP2}. Defaults to 0.\n     *\n     * @type {number}\n     */\n    fogDensity: number;\n    /**\n     * The distance from the viewpoint where linear fog reaches its maximum. This property is only\n     * valid if the fog property is set to {@link FOG_LINEAR}. Defaults to 1000.\n     *\n     * @type {number}\n     */\n    fogEnd: number;\n    /**\n     * The distance from the viewpoint where linear fog begins. This property is only valid if the\n     * fog property is set to {@link FOG_LINEAR}. Defaults to 1.\n     *\n     * @type {number}\n     */\n    fogStart: number;\n    /**\n     * The lightmap resolution multiplier. Defaults to 1.\n     *\n     * @type {number}\n     */\n    lightmapSizeMultiplier: number;\n    /**\n     * The maximum lightmap resolution. Defaults to 2048.\n     *\n     * @type {number}\n     */\n    lightmapMaxResolution: number;\n    /**\n     * The lightmap baking mode. Can be:\n     *\n     * - {@link BAKE_COLOR}: single color lightmap\n     * - {@link BAKE_COLORDIR}: single color lightmap + dominant light direction (used for bump or\n     * specular). Only lights with bakeDir=true will be used for generating the dominant light\n     * direction.\n     *\n     * Defaults to {@link BAKE_COLORDIR}.\n     *\n     * @type {number}\n     */\n    lightmapMode: number;\n    /**\n     * Enables bilateral filter on runtime baked color lightmaps, which removes the noise and\n     * banding while preserving the edges. Defaults to false. Note that the filtering takes place\n     * in the image space of the lightmap, and it does not filter across lightmap UV space seams,\n     * often making the seams more visible. It\'s important to balance the strength of the filter\n     * with number of samples used for lightmap baking to limit the visible artifacts.\n     *\n     * @type {boolean}\n     */\n    lightmapFilterEnabled: boolean;\n    /**\n     * The root entity of the scene, which is usually the only child to the {@link Application}\n     * root entity.\n     *\n     * @type {Entity}\n     */\n    root: Entity;\n    device: any;\n    _gravity: Vec3;\n    /**\n     * @type {LayerComposition}\n     * @private\n     */\n    private _layers;\n    _fog: string;\n    _gammaCorrection: number;\n    _toneMapping: number;\n    /**\n     * The skybox cubemap as set by user (gets used when skyboxMip === 0)\n     *\n     * @type {Texture}\n     * @private\n     */\n    private _skyboxCubeMap;\n    /**\n     * Array of 6 prefiltered lighting data cubemaps.\n     *\n     * @type {Texture[]}\n     * @private\n     */\n    private _prefilteredCubemaps;\n    /**\n     * Environment lighting atlas\n     *\n     * @type {Texture}\n     * @private\n     */\n    private _envAtlas;\n    _internalEnvAtlas: any;\n    skyboxModel: Model;\n    _skyboxIntensity: number;\n    _skyboxMip: number;\n    _skyboxRotation: Quat;\n    _skyboxRotationMat3: Mat3;\n    _skyboxRotationMat4: Mat4;\n    _ambientBakeNumSamples: number;\n    _ambientBakeSpherePart: number;\n    _lightmapFilterRange: number;\n    _lightmapFilterSmoothness: number;\n    _clusteredLightingEnabled: boolean;\n    _lightingParams: LightingParams;\n    _stats: {\n        meshInstances: number;\n        lights: number;\n        dynamicLights: number;\n        bakedLights: number;\n        lastStaticPrepareFullTime: number;\n        lastStaticPrepareSearchTime: number;\n        lastStaticPrepareWriteTime: number;\n        lastStaticPrepareTriAabbTime: number;\n        lastStaticPrepareCombineTime: number;\n        updateShadersTime: number;\n    };\n    /**\n     * This flag indicates changes were made to the scene which may require recompilation of\n     * shaders that reference global settings.\n     *\n     * @type {boolean}\n     * @private\n     */\n    private updateShaders;\n    _shaderVersion: number;\n    _statsUpdated: boolean;\n    _models: any[];\n    immediate: Immediate;\n    /**\n     * Returns the default layer used by the immediate drawing functions.\n     *\n     * @type {Layer}\n     * @private\n     */\n    private get defaultDrawLayer();\n    /**\n     * If {@link Scene#ambientBake} is true, this specifies the number of samples used to bake the\n     * ambient light into the lightmap. Defaults to 1. Maximum value is 255.\n     *\n     * @type {number}\n     */\n    set ambientBakeNumSamples(arg: number);\n    get ambientBakeNumSamples(): number;\n    /**\n     * If {@link Scene#ambientBake} is true, this specifies a part of the sphere which represents\n     * the source of ambient light. The valid range is 0..1, representing a part of the sphere from\n     * top to the bottom. A value of 0.5 represents the upper hemisphere. A value of 1 represents a\n     * full sphere. Defaults to 0.4, which is a smaller upper hemisphere as this requires fewer\n     * samples to bake.\n     *\n     * @type {number}\n     */\n    set ambientBakeSpherePart(arg: number);\n    get ambientBakeSpherePart(): number;\n    set clusteredLightingEnabled(arg: boolean);\n    get clusteredLightingEnabled(): boolean;\n    /**\n     * List of all active composition mesh instances. Only for backwards compatibility.\n     * TODO: BatchManager is using it - perhaps that could be refactored\n     *\n     * @type {MeshInstance[]}\n     * @private\n     */\n    private set drawCalls(arg);\n    private get drawCalls();\n    /**\n     * The environment lighting atlas.\n     *\n     * @type {Texture}\n     */\n    set envAtlas(arg: Texture);\n    get envAtlas(): Texture;\n    /**\n     * The type of fog used by the scene. Can be:\n     *\n     * - {@link FOG_NONE}\n     * - {@link FOG_LINEAR}\n     * - {@link FOG_EXP}\n     * - {@link FOG_EXP2}\n     *\n     * Defaults to {@link FOG_NONE}.\n     *\n     * @type {string}\n     */\n    set fog(arg: string);\n    get fog(): string;\n    /**\n     * The gamma correction to apply when rendering the scene. Can be:\n     *\n     * - {@link GAMMA_NONE}\n     * - {@link GAMMA_SRGB}\n     *\n     * Defaults to {@link GAMMA_SRGB}.\n     *\n     * @type {number}\n     */\n    set gammaCorrection(arg: number);\n    get gammaCorrection(): number;\n    /**\n     * A {@link LayerComposition} that defines rendering order of this scene.\n     *\n     * @type {LayerComposition}\n     */\n    set layers(arg: LayerComposition);\n    get layers(): LayerComposition;\n    get lighting(): LightingParams;\n    /**\n     * A range parameter of the bilateral filter. It\'s used when {@link Scene#lightmapFilterEnabled}\n     * is enabled. Larger value applies more widespread blur. This needs to be a positive non-zero\n     * value. Defaults to 10.\n     *\n     * @type {number}\n     */\n    set lightmapFilterRange(arg: number);\n    get lightmapFilterRange(): number;\n    /**\n     * A spatial parameter of the bilateral filter. It\'s used when {@link Scene#lightmapFilterEnabled}\n     * is enabled. Larger value blurs less similar colors. This needs to be a positive non-zero\n     * value. Defaults to 0.2.\n     *\n     * @type {number}\n     */\n    set lightmapFilterSmoothness(arg: number);\n    get lightmapFilterSmoothness(): number;\n    /**\n     * Set of 6 prefiltered cubemaps.\n     *\n     * @type {Texture[]}\n     */\n    set prefilteredCubemaps(arg: Texture[]);\n    get prefilteredCubemaps(): Texture[];\n    /**\n     * The base cubemap texture used as the scene\'s skybox, if mip level is 0. Defaults to null.\n     *\n     * @type {Texture}\n     */\n    set skybox(arg: Texture);\n    get skybox(): Texture;\n    /**\n     * Multiplier for skybox intensity. Defaults to 1.\n     *\n     * @type {number}\n     */\n    set skyboxIntensity(arg: number);\n    get skyboxIntensity(): number;\n    /**\n     * The mip level of the skybox to be displayed. Only valid for prefiltered cubemap skyboxes.\n     * Defaults to 0 (base level).\n     *\n     * @type {number}\n     */\n    set skyboxMip(arg: number);\n    get skyboxMip(): number;\n    /**\n     * The rotation of the skybox to be displayed. Defaults to {@link Quat.IDENTITY}.\n     *\n     * @type {Quat}\n     */\n    set skyboxRotation(arg: Quat);\n    get skyboxRotation(): Quat;\n    /**\n     * The tonemapping transform to apply when writing fragments to the frame buffer. Can be:\n     *\n     * - {@link TONEMAP_LINEAR}\n     * - {@link TONEMAP_FILMIC}\n     * - {@link TONEMAP_HEJL}\n     * - {@link TONEMAP_ACES}\n     *\n     * Defaults to {@link TONEMAP_LINEAR}.\n     *\n     * @type {number}\n     */\n    set toneMapping(arg: number);\n    get toneMapping(): number;\n    destroy(): void;\n    drawLine(start: any, end: any, color?: Color, depthTest?: boolean, layer?: Layer): void;\n    drawLines(positions: any, colors: any, depthTest?: boolean, layer?: Layer): void;\n    drawLineArrays(positions: any, colors: any, depthTest?: boolean, layer?: Layer): void;\n    applySettings(settings: any): void;\n    _getSkyboxTex(): Texture;\n    _updateSkybox(device: any): void;\n    skyLayer: Layer;\n    _resetSkyboxModel(): void;\n    /**\n     * Sets the cubemap for the scene skybox.\n     *\n     * @param {Texture[]} [cubemaps] - An array of cubemaps corresponding to the skybox at\n     * different mip levels. If undefined, scene will remove skybox. Cubemap array should be of\n     * size 7, with the first element (index 0) corresponding to the base cubemap (mip level 0)\n     * with original resolution. Each remaining element (index 1-6) corresponds to a fixed\n     * prefiltered resolution (128x128, 64x64, 32x32, 16x16, 8x8, 4x4).\n     */\n    setSkybox(cubemaps?: Texture[]): void;\n    addModel(model: any): void;\n    addShadowCaster(model: any): void;\n    removeModel(model: any): void;\n    removeShadowCasters(model: any): void;\n    containsModel(model: any): boolean;\n    getModels(model: any): any[];\n}\n\n\n\n/** @typedef {import(\'../asset/asset.js\').Asset} Asset */\n/** @typedef {import(\'../asset/asset-registry.js\').AssetRegistry} AssetRegistry */\n/**\n * Keeps track of which assets are in bundles and loads files from bundles.\n *\n * @ignore\n */\ndeclare class BundleRegistry {\n    /**\n     * Create a new BundleRegistry instance.\n     *\n     * @param {AssetRegistry} assets - The asset registry.\n     */\n    constructor(assets: AssetRegistry);\n    _assets: AssetRegistry;\n    _bundleAssets: {};\n    _assetsInBundles: {};\n    _urlsInBundles: {};\n    _fileRequests: {};\n    _onAssetAdded(asset: any): void;\n    _registerBundleEventListeners(bundleAssetId: any): void;\n    _unregisterBundleEventListeners(bundleAssetId: any): void;\n    _indexAssetInBundle(assetId: any, bundleAsset: any): void;\n    _indexAssetFileUrls(asset: any): void;\n    _getAssetFileUrls(asset: any): any[];\n    _normalizeUrl(url: any): any;\n    _onAssetRemoved(asset: any): void;\n    _onBundleLoaded(bundleAsset: any): void;\n    _onBundleError(err: any, bundleAsset: any): void;\n    _findLoadedOrLoadingBundleForUrl(url: any): any;\n    /**\n     * Lists all of the available bundles that reference the specified asset id.\n     *\n     * @param {Asset} asset - The asset.\n     * @returns {Asset[]} An array of bundle assets or null if the asset is not in any bundle.\n     */\n    listBundlesForAsset(asset: Asset): Asset[];\n    /**\n     * Lists all of the available bundles. This includes bundles that are not loaded.\n     *\n     * @returns {Asset[]} An array of bundle assets.\n     */\n    list(): Asset[];\n    /**\n     * Returns true if there is a bundle that contains the specified URL.\n     *\n     * @param {string} url - The url.\n     * @returns {boolean} True or false.\n     */\n    hasUrl(url: string): boolean;\n    /**\n     * Returns true if there is a bundle that contains the specified URL and that bundle is either\n     * loaded or currently being loaded.\n     *\n     * @param {string} url - The url.\n     * @returns {boolean} True or false.\n     */\n    canLoadUrl(url: string): boolean;\n    /**\n     * Loads the specified file URL from a bundle that is either loaded or currently being loaded.\n     *\n     * @param {string} url - The URL. Make sure you are using a relative URL that does not contain\n     * any query parameters.\n     * @param {Function} callback - The callback is called when the file has been loaded or if an\n     * error occurs. The callback expects the first argument to be the error message (if any) and\n     * the second argument is the file blob URL.\n     * @example\n     * var url = asset.getFileUrl().split(\'?\')[0]; // get normalized asset URL\n     * this.app.bundles.loadFile(url, function (err, blobUrl) {\n     *     // do something with the blob URL\n     * });\n     */\n    loadUrl(url: string, callback: Function): void;\n    /**\n     * Destroys the registry, and releases its resources. Does not unload bundle assets as these\n     * should be unloaded by the {@link AssetRegistry}.\n     */\n    destroy(): void;\n}\n\n\n/** @typedef {import(\'../framework/app-base.js\').Application} Application */\n/**\n * Container for all {@link ScriptType}s that are available to this application. Note that\n * PlayCanvas scripts can access the Script Registry from inside the application with\n * {@link Application#scripts}.\n *\n * @augments EventHandler\n */\ndeclare class ScriptRegistry extends EventHandler {\n    /**\n     * Create a new ScriptRegistry instance.\n     *\n     * @param {Application} app - Application to attach registry to.\n     */\n    constructor(app: Application);\n    app: Application;\n    _scripts: {};\n    _list: any[];\n    destroy(): void;\n    /**\n     * Add {@link ScriptType} to registry. Note: when {@link createScript} is called, it will add\n     * the {@link ScriptType} to the registry automatically. If a script already exists in\n     * registry, and the new script has a `swap` method defined, it will perform code hot swapping\n     * automatically in async manner.\n     *\n     * @param {typeof ScriptType} script - Script Type that is created using {@link createScript}.\n     * @returns {boolean} True if added for the first time or false if script already exists.\n     * @example\n     * var PlayerController = pc.createScript(\'playerController\');\n     * // playerController Script Type will be added to pc.ScriptRegistry automatically\n     * console.log(app.scripts.has(\'playerController\')); // outputs true\n     */\n    add(script: typeof ScriptType): boolean;\n    /**\n     * Remove {@link ScriptType}.\n     *\n     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.\n     * @returns {boolean} True if removed or False if already not in registry.\n     * @example\n     * app.scripts.remove(\'playerController\');\n     */\n    remove(nameOrType: string | typeof ScriptType): boolean;\n    /**\n     * Get {@link ScriptType} by name.\n     *\n     * @param {string} name - Name of a {@link ScriptType}.\n     * @returns {typeof ScriptType} The Script Type if it exists in the registry or null otherwise.\n     * @example\n     * var PlayerController = app.scripts.get(\'playerController\');\n     */\n    get(name: string): typeof ScriptType;\n    /**\n     * Check if a {@link ScriptType} with the specified name is in the registry.\n     *\n     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.\n     * @returns {boolean} True if {@link ScriptType} is in registry.\n     * @example\n     * if (app.scripts.has(\'playerController\')) {\n     *     // playerController is in pc.ScriptRegistry\n     * }\n     */\n    has(nameOrType: string | typeof ScriptType): boolean;\n    /**\n     * Get list of all {@link ScriptType}s from registry.\n     *\n     * @returns {Array<typeof ScriptType>} list of all {@link ScriptType}s in registry.\n     * @example\n     * // logs array of all Script Type names available in registry\n     * console.log(app.scripts.list().map(function (o) {\n     *     return o.name;\n     * }));\n     */\n    list(): Array<typeof ScriptType>;\n}\n\ndeclare class I18nParser {\n    _validate(data: any): void;\n    parse(data: any): any;\n}\n\n\n/**\n * Handles localization. Responsible for loading localization assets and returning translations for\n * a certain key. Can also handle plural forms. To override its default behavior define a different\n * implementation for {@link I18n#getText} and {@link I18n#getPluralText}.\n *\n * @augments EventHandler\n */\ndeclare class I18n extends EventHandler {\n    /**\n     * Returns the first available locale based on the desired locale specified. First tries to\n     * find the desired locale and then tries to find an alternative locale based on the language.\n     *\n     * @param {string} desiredLocale - The desired locale e.g. en-US.\n     * @param {object} availableLocales - A dictionary where each key is an available locale.\n     * @returns {string} The locale found or if no locale is available returns the default en-US\n     * locale.\n     * @example\n     * // With a defined dictionary of locales\n     * var availableLocales = { en: \'en-US\', fr: \'fr-FR\' };\n     * var locale = pc.I18n.getText(\'en-US\', availableLocales);\n     * // returns \'en\'\n     * @ignore\n     */\n    static findAvailableLocale(desiredLocale: string, availableLocales: object): string;\n    /**\n     * Create a new I18n instance.\n     *\n     * @param {Application} app - The application.\n     */\n    constructor(app: Application);\n    /**\n     * The current locale for example "en-US". Changing the locale will raise an event which will\n     * cause localized Text Elements to change language to the new locale.\n     *\n     * @type {string}\n     */\n    set locale(arg: any);\n    get locale(): any;\n    _translations: {};\n    _availableLangs: {};\n    _app: Application;\n    _assets: any[];\n    _parser: I18nParser;\n    /**\n     * An array of asset ids or assets that contain localization data in the expected format. I18n\n     * will automatically load translations from these assets as the assets are loaded and it will\n     * also automatically unload translations if the assets get removed or unloaded at runtime.\n     *\n     * @type {number[]|Asset[]}\n     */\n    set assets(arg: any[]);\n    get assets(): any[];\n    _locale: any;\n    _lang: any;\n    _pluralFn: any;\n    /**\n     * Returns the first available locale based on the desired locale specified. First tries to\n     * find the desired locale in the loaded translations and then tries to find an alternative\n     * locale based on the language.\n     *\n     * @param {string} desiredLocale - The desired locale e.g. en-US.\n     * @returns {string} The locale found or if no locale is available returns the default en-US\n     * locale.\n     * @example\n     * var locale = this.app.i18n.getText(\'en-US\');\n     */\n    findAvailableLocale(desiredLocale: string): string;\n    /**\n     * Returns the translation for the specified key and locale. If the locale is not specified it\n     * will use the current locale.\n     *\n     * @param {string} key - The localization key.\n     * @param {string} [locale] - The desired locale.\n     * @returns {string} The translated text. If no translations are found at all for the locale\n     * then it will return the en-US translation. If no translation exists for that key then it will\n     * return the localization key.\n     * @example\n     * var localized = this.app.i18n.getText(\'localization-key\');\n     * var localizedFrench = this.app.i18n.getText(\'localization-key\', \'fr-FR\');\n     */\n    getText(key: string, locale?: string): string;\n    /**\n     * Returns the pluralized translation for the specified key, number n and locale. If the locale\n     * is not specified it will use the current locale.\n     *\n     * @param {string} key - The localization key.\n     * @param {number} n - The number used to determine which plural form to use. E.g. For the\n     * phrase "5 Apples" n equals 5.\n     * @param {string} [locale] - The desired locale.\n     * @returns {string} The translated text. If no translations are found at all for the locale\n     * then it will return the en-US translation. If no translation exists for that key then it\n     * will return the localization key.\n     * @example\n     * // manually replace {number} in the resulting translation with our number\n     * var localized = this.app.i18n.getPluralText(\'{number} apples\', number).replace("{number}", number);\n     */\n    getPluralText(key: string, n: number, locale?: string): string;\n    /**\n     * Adds localization data. If the locale and key for a translation already exists it will be\n     * overwritten.\n     *\n     * @param {object} data - The localization data. See example for the expected format of the\n     * data.\n     * @example\n     * this.app.i18n.addData({\n     *     header: {\n     *         version: 1\n     *     },\n     *     data: [{\n     *         info: {\n     *             locale: \'en-US\'\n     *         },\n     *         messages: {\n     *             "key": "translation",\n     *             // The number of plural forms depends on the locale. See the manual for more information.\n     *             "plural_key": ["one item", "more than one items"]\n     *         }\n     *     }, {\n     *         info: {\n     *             locale: \'fr-FR\'\n     *         },\n     *         messages: {\n     *             // ...\n     *         }\n     *     }]\n     * });\n     */\n    addData(data: object): void;\n    /**\n     * Removes localization data.\n     *\n     * @param {object} data - The localization data. The data is expected to be in the same format\n     * as {@link I18n#addData}.\n     */\n    removeData(data: object): void;\n    /**\n     * Frees up memory.\n     */\n    destroy(): void;\n    _findFallbackLocale(locale: any, lang: any): any;\n    _onAssetAdd(asset: any): void;\n    _onAssetLoad(asset: any): void;\n    _onAssetChange(asset: any): void;\n    _onAssetRemove(asset: any): void;\n    _onAssetUnload(asset: any): void;\n}\n\n/**\n * Item to be stored in the {@link SceneRegistry}.\n */\ndeclare class SceneRegistryItem {\n    /**\n     * Creates a new SceneRegistryItem instance.\n     *\n     * @param {string} name - The name of the scene.\n     * @param {string} url - The url of the scene file.\n     */\n    constructor(name: string, url: string);\n    /**\n     * The name of the scene.\n     *\n     * @type {string}\n     */\n    name: string;\n    /**\n     * The url of the scene file.\n     *\n     * @type {string}\n     */\n    url: string;\n    data: any;\n    _loading: boolean;\n    _onLoadedCallbacks: any[];\n    /**\n     * Returns true if the scene data has loaded.\n     *\n     * @type {boolean}\n     */\n    get loaded(): boolean;\n    /**\n     * Returns true if the scene data is still being loaded.\n     *\n     * @type {boolean}\n     */\n    get loading(): boolean;\n}\n\n\n\n/**\n * Callback used by {@link SceneRegistryloadSceneHierarchy }.\n */\nexport type LoadHierarchyCallback = (err: string | null, entity?: Entity) => any;\n/**\n * Callback used by {@link SceneRegistryloadSceneSettings }.\n */\nexport type LoadSettingsCallback = (err: string | null) => any;\n/**\n * Callback used by {@link SceneRegistryloadScene }.\n */\nexport type LoadSceneCallback = (err: string | null, entity?: Entity) => any;\n/**\n * Callback used by {@link SceneRegistryloadSceneData }.\n */\nexport type LoadSceneDataCallback = (err: string | null, sceneItem?: SceneRegistryItem) => any;\n/** @typedef {import(\'./app-base.js\').Application} Application */\n/** @typedef {import(\'./entity.js\').Entity} Entity */\n/**\n * Callback used by {@link SceneRegistry#loadSceneHierarchy}.\n *\n * @callback LoadHierarchyCallback\n * @param {string|null} err - The error message in the case where the loading or parsing fails.\n * @param {Entity} [entity] - The loaded root entity if no errors were encountered.\n */\n/**\n * Callback used by {@link SceneRegistry#loadSceneSettings}.\n *\n * @callback LoadSettingsCallback\n * @param {string|null} err - The error message in the case where the loading or parsing fails.\n */\n/**\n * Callback used by {@link SceneRegistry#loadScene}.\n *\n * @callback LoadSceneCallback\n * @param {string|null} err - The error message in the case where the loading or parsing fails.\n * @param {Entity} [entity] - The loaded root entity if no errors were encountered.\n */\n/**\n * Callback used by {@link SceneRegistry#loadSceneData}.\n *\n * @callback LoadSceneDataCallback\n * @param {string|null} err - The error message in the case where the loading or parsing fails.\n * @param {SceneRegistryItem} [sceneItem] - The scene registry item if no errors were encountered.\n */\n/**\n * Container for storing and loading of scenes. An instance of the registry is created on the\n * {@link Application} object as {@link Application#scenes}.\n */\ndeclare class SceneRegistry {\n    /**\n     * Create a new SceneRegistry instance.\n     *\n     * @param {Application} app - The application.\n     */\n    constructor(app: Application);\n    _app: Application;\n    _list: any[];\n    _index: {};\n    _urlIndex: {};\n    destroy(): void;\n    /**\n     * Return the list of scene.\n     *\n     * @returns {SceneRegistryItem[]} All items in the registry.\n     */\n    list(): SceneRegistryItem[];\n    /**\n     * Add a new item to the scene registry.\n     *\n     * @param {string} name - The name of the scene.\n     * @param {string} url -  The url of the scene file.\n     * @returns {boolean} Returns true if the scene was successfully added to the registry, false otherwise.\n     */\n    add(name: string, url: string): boolean;\n    /**\n     * Find a Scene by name and return the {@link SceneRegistryItem}.\n     *\n     * @param {string} name - The name of the scene.\n     * @returns {SceneRegistryItem|null} The stored data about a scene or null if no scene with\n     * that name exists.\n     */\n    find(name: string): SceneRegistryItem | null;\n    /**\n     * Find a scene by the URL and return the {@link SceneRegistryItem}.\n     *\n     * @param {string} url - The URL to search by.\n     * @returns {SceneRegistryItem|null} The stored data about a scene or null if no scene with\n     * that URL exists.\n     */\n    findByUrl(url: string): SceneRegistryItem | null;\n    /**\n     * Remove an item from the scene registry.\n     *\n     * @param {string} name - The name of the scene.\n     */\n    remove(name: string): void;\n    _loadSceneData(sceneItem: any, storeInCache: any, callback: any): void;\n    /**\n     * Loads and stores the scene data to reduce the number of the network requests when the same\n     * scenes are loaded multiple times. Can also be used to load data before calling\n     * {@link SceneRegistry#loadSceneHierarchy} and {@link SceneRegistry#loadSceneSettings} to make\n     * scene loading quicker for the user.\n     *\n     * @param {SceneRegistryItem | string} sceneItem - The scene item (which can be found with\n     * {@link SceneRegistry#find} or URL of the scene file. Usually this will be "scene_id.json".\n     * @param {LoadSceneDataCallback} callback - The function to call after loading,\n     * passed (err, sceneItem) where err is null if no errors occurred.\n     * @example\n     * var sceneItem = app.scenes.find("Scene Name");\n     * app.scenes.loadSceneData(sceneItem, function (err, sceneItem) {\n     *     if (err) {\n     *         // error\n     *     }\n     * });\n     */\n    loadSceneData(sceneItem: SceneRegistryItem | string, callback: LoadSceneDataCallback): void;\n    /**\n     * Unloads scene data that has been loaded previously using {@link SceneRegistry#loadSceneData}.\n     *\n     * @param {SceneRegistryItem | string} sceneItem - The scene item (which can be found with\n     * {@link SceneRegistry#find} or URL of the scene file. Usually this will be "scene_id.json".\n     * @example\n     * var sceneItem = app.scenes.find("Scene Name");\n     * app.scenes.unloadSceneData(sceneItem);\n     */\n    unloadSceneData(sceneItem: SceneRegistryItem | string): void;\n    /**\n     * Load a scene file, create and initialize the Entity hierarchy and add the hierarchy to the\n     * application root Entity.\n     *\n     * @param {SceneRegistryItem | string} sceneItem - The scene item (which can be found with\n     * {@link SceneRegistry#find} or URL of the scene file. Usually this will be "scene_id.json".\n     * @param {LoadHierarchyCallback} callback - The function to call after loading,\n     * passed (err, entity) where err is null if no errors occurred.\n     * @example\n     * var sceneItem = app.scenes.find("Scene Name");\n     * app.scenes.loadSceneHierarchy(sceneItem, function (err, entity) {\n     *     if (!err) {\n     *         var e = app.root.find("My New Entity");\n     *     } else {\n     *         // error\n     *     }\n     * });\n     */\n    loadSceneHierarchy(sceneItem: SceneRegistryItem | string, callback: LoadHierarchyCallback): void;\n    /**\n     * Load a scene file and apply the scene settings to the current scene.\n     *\n     * @param {SceneRegistryItem | string} sceneItem - The scene item (which can be found with\n     * {@link SceneRegistry#find} or URL of the scene file. Usually this will be "scene_id.json".\n     * @param {LoadSettingsCallback} callback - The function called after the settings\n     * are applied. Passed (err) where err is null if no error occurred.\n     * @example\n     * var sceneItem = app.scenes.find("Scene Name");\n     * app.scenes.loadSceneHierarchy(sceneItem, function (err, entity) {\n     *     if (!err) {\n     *         var e = app.root.find("My New Entity");\n     *     } else {\n     *         // error\n     *     }\n     * });\n     */\n    loadSceneSettings(sceneItem: SceneRegistryItem | string, callback: LoadSettingsCallback): void;\n    /**\n     * Load the scene hierarchy and scene settings. This is an internal method used by the\n     * {@link Application}.\n     *\n     * @param {string} url - The URL of the scene file.\n     * @param {LoadSceneCallback} callback - The function called after the settings are\n     * applied. Passed (err, scene) where err is null if no error occurred and scene is the\n     * {@link Scene}.\n     */\n    loadScene(url: string, callback: LoadSceneCallback): void;\n}\n\ndeclare class SceneDepth {\n    constructor(application: any);\n    application: any;\n    device: any;\n    clearOptions: {\n        flags: number;\n        color?: undefined;\n        depth?: undefined;\n    } | {\n        color: number[];\n        depth: number;\n        flags: number;\n    };\n    layer: Layer;\n    allocateTexture(device: any, name: any, format: any): Texture;\n    allocateRenderTarget(renderTarget: any, device: any, name: any, format: any, isDepth: any): any;\n    releaseRenderTarget(rt: any): void;\n    initWebGl2(): void;\n    initWebGl1(): void;\n    init(): void;\n    patch(layer: any): void;\n}\n\ndeclare class ShadowMap {\n    static getShadowFormat(device: any, shadowType: any): number;\n    static getShadowFiltering(device: any, shadowType: any): number;\n    static create(device: any, light: any): ShadowMap;\n    static createAtlas(device: any, resolution: any, shadowType: any): ShadowMap;\n    static create2dMap(device: any, size: any, shadowType: any): ShadowMap;\n    static createCubemap(device: any, size: any): ShadowMap;\n    constructor(texture: any, targets: any);\n    texture: any;\n    cached: boolean;\n    renderTargets: any;\n    destroy(): void;\n}\n\ndeclare class LightTextureAtlas {\n    constructor(device: any);\n    device: any;\n    version: number;\n    shadowAtlasResolution: number;\n    shadowAtlas: ShadowMap;\n    shadowEdgePixels: number;\n    cookieAtlasResolution: number;\n    cookieAtlas: Texture;\n    cookieRenderTarget: RenderTarget;\n    slots: any[];\n    atlasSplit: any[];\n    cubeSlotsOffsets: Vec2[];\n    scissorVec: Vec4;\n    destroy(): void;\n    destroyShadowAtlas(): void;\n    destroyCookieAtlas(): void;\n    allocateShadowAtlas(resolution: any): void;\n    allocateCookieAtlas(resolution: any): void;\n    allocateUniforms(): void;\n    _shadowAtlasTextureId: any;\n    _shadowAtlasParamsId: any;\n    _shadowAtlasParams: Float32Array;\n    _cookieAtlasTextureId: any;\n    updateUniforms(): void;\n    subdivide(numLights: any, lightingParams: any): void;\n    collectLights(spotLights: any, omniLights: any, lightingParams: any): any[];\n    setupSlot(light: any, rect: any): void;\n    assignSlot(light: any, slotIndex: any, slotReassigned: any): void;\n    update(spotLights: any, omniLights: any, lightingParams: any): void;\n}\n\n\n\n/**\n * A frustum is a shape that defines the viewing space of a camera. It can be used to determine\n * visibility of points and bounding spheres. Typically, you would not create a Frustum shape\n * directly, but instead query {@link CameraComponent#frustum}.\n */\ndeclare class Frustum {\n    static getPoints(camera: any, near: any, far: any): Vec3[];\n    planes: any[][];\n    /**\n     * Updates the frustum shape based on the supplied 4x4 matrix.\n     *\n     * @param {Mat4} matrix - The matrix describing the shape of the frustum.\n     * @example\n     * // Create a perspective projection matrix\n     * var projMat = pc.Mat4();\n     * projMat.setPerspective(45, 16 / 9, 1, 1000);\n     *\n     * // Create a frustum shape that is represented by the matrix\n     * var frustum = new pc.Frustum();\n     * frustum.setFromMat4(projMat);\n     */\n    setFromMat4(matrix: Mat4): void;\n    /**\n     * Tests whether a point is inside the frustum. Note that points lying in a frustum plane are\n     * considered to be outside the frustum.\n     *\n     * @param {Vec3} point - The point to test.\n     * @returns {boolean} True if the point is inside the frustum, false otherwise.\n     */\n    containsPoint(point: Vec3): boolean;\n    /**\n     * Tests whether a bounding sphere intersects the frustum. If the sphere is outside the\n     * frustum, zero is returned. If the sphere intersects the frustum, 1 is returned. If the\n     * sphere is completely inside the frustum, 2 is returned. Note that a sphere touching a\n     * frustum plane from the outside is considered to be outside the frustum.\n     *\n     * @param {BoundingSphere} sphere - The sphere to test.\n     * @returns {number} 0 if the bounding sphere is outside the frustum, 1 if it intersects the\n     * frustum and 2 if it is contained by the frustum.\n     */\n    containsSphere(sphere: BoundingSphere): number;\n}\n\n/**\n * A camera.\n *\n * @ignore\n */\ndeclare class Camera {\n    _aspectRatio: number;\n    _aspectRatioMode: number;\n    _calculateProjection: any;\n    _calculateTransform: any;\n    _clearColor: Color;\n    _clearColorBuffer: boolean;\n    _clearDepth: number;\n    _clearDepthBuffer: boolean;\n    _clearStencil: number;\n    _clearStencilBuffer: boolean;\n    _cullingMask: number;\n    _cullFaces: boolean;\n    _farClip: number;\n    _flipFaces: boolean;\n    _fov: number;\n    _frustumCulling: boolean;\n    _horizontalFov: boolean;\n    _layers: number[];\n    _nearClip: number;\n    _node: any;\n    _orthoHeight: number;\n    _projection: number;\n    _rect: Vec4;\n    _renderTarget: any;\n    _scissorRect: Vec4;\n    _scissorRectClear: boolean;\n    _vrDisplay: any;\n    _projMat: Mat4;\n    _projMatDirty: boolean;\n    _projMatSkybox: Mat4;\n    _viewMat: Mat4;\n    _viewMatDirty: boolean;\n    _viewProjMat: Mat4;\n    _viewProjMatDirty: boolean;\n    frustum: Frustum;\n    set aspectRatio(arg: number);\n    get aspectRatio(): number;\n    set aspectRatioMode(arg: number);\n    get aspectRatioMode(): number;\n    set calculateProjection(arg: any);\n    get calculateProjection(): any;\n    set calculateTransform(arg: any);\n    get calculateTransform(): any;\n    set clearColor(arg: Color);\n    get clearColor(): Color;\n    set clearColorBuffer(arg: boolean);\n    get clearColorBuffer(): boolean;\n    set clearDepth(arg: number);\n    get clearDepth(): number;\n    set clearDepthBuffer(arg: boolean);\n    get clearDepthBuffer(): boolean;\n    set clearStencil(arg: number);\n    get clearStencil(): number;\n    set clearStencilBuffer(arg: boolean);\n    get clearStencilBuffer(): boolean;\n    set cullingMask(arg: number);\n    get cullingMask(): number;\n    set cullFaces(arg: boolean);\n    get cullFaces(): boolean;\n    set farClip(arg: number);\n    get farClip(): number;\n    set flipFaces(arg: boolean);\n    get flipFaces(): boolean;\n    set fov(arg: number);\n    get fov(): number;\n    set frustumCulling(arg: boolean);\n    get frustumCulling(): boolean;\n    set horizontalFov(arg: boolean);\n    get horizontalFov(): boolean;\n    set layers(arg: number[]);\n    get layers(): number[];\n    set nearClip(arg: number);\n    get nearClip(): number;\n    set node(arg: any);\n    get node(): any;\n    set orthoHeight(arg: number);\n    get orthoHeight(): number;\n    set projection(arg: number);\n    get projection(): number;\n    get projectionMatrix(): Mat4;\n    set rect(arg: Vec4);\n    get rect(): Vec4;\n    set renderTarget(arg: any);\n    get renderTarget(): any;\n    set scissorRect(arg: Vec4);\n    get scissorRect(): Vec4;\n    get viewMatrix(): Mat4;\n    set vrDisplay(arg: any);\n    get vrDisplay(): any;\n    /**\n     * Creates a duplicate of the camera.\n     *\n     * @returns {Camera} A cloned Camera.\n     */\n    clone(): Camera;\n    /**\n     * Copies one camera to another.\n     *\n     * @param {Camera} other - Camera to copy.\n     * @returns {Camera} Self for chaining.\n     */\n    copy(other: Camera): Camera;\n    _updateViewProjMat(): void;\n    /**\n     * Convert a point from 3D world space to 2D canvas pixel space.\n     *\n     * @param {Vec3} worldCoord - The world space coordinate to transform.\n     * @param {number} cw - The width of PlayCanvas\' canvas element.\n     * @param {number} ch - The height of PlayCanvas\' canvas element.\n     * @param {Vec3} [screenCoord] - 3D vector to receive screen coordinate result.\n     * @returns {Vec3} The screen space coordinate.\n     */\n    worldToScreen(worldCoord: Vec3, cw: number, ch: number, screenCoord?: Vec3): Vec3;\n    /**\n     * Convert a point from 2D canvas pixel space to 3D world space.\n     *\n     * @param {number} x - X coordinate on PlayCanvas\' canvas element.\n     * @param {number} y - Y coordinate on PlayCanvas\' canvas element.\n     * @param {number} z - The distance from the camera in world space to create the new point.\n     * @param {number} cw - The width of PlayCanvas\' canvas element.\n     * @param {number} ch - The height of PlayCanvas\' canvas element.\n     * @param {Vec3} [worldCoord] - 3D vector to receive world coordinate result.\n     * @returns {Vec3} The world space coordinate.\n     */\n    screenToWorld(x: number, y: number, z: number, cw: number, ch: number, worldCoord?: Vec3): Vec3;\n    _evaluateProjectionMatrix(): void;\n    getProjectionMatrixSkybox(): Mat4;\n    getScreenSize(sphere: any): number;\n}\n\ndeclare class ShadowMapCache {\n    shadowMapCache: Map<any, any>;\n    destroy(): void;\n    clear(): void;\n    getKey(light: any): string;\n    get(device: any, light: any): any;\n    add(light: any, shadowMap: any): void;\n}\n\ndeclare class ShadowRenderer {\n    static createShadowCamera(device: any, shadowType: any, type: any, face: any): Camera;\n    static setShadowCameraSettings(shadowCam: any, device: any, shadowType: any, type: any, isClustered: any): void;\n    constructor(forwardRenderer: any, lightTextureAtlas: any);\n    device: any;\n    forwardRenderer: any;\n    lightTextureAtlas: any;\n    polygonOffsetId: any;\n    polygonOffset: Float32Array;\n    sourceId: any;\n    pixelOffsetId: any;\n    weightId: any;\n    blurVsmShaderCode: any[];\n    blurPackedVsmShaderCode: string[];\n    blurVsmShader: {}[];\n    blurPackedVsmShader: {}[];\n    blurVsmWeights: {};\n    shadowMapLightRadiusId: any;\n    shadowMapCache: ShadowMapCache;\n    destroy(): void;\n    cullShadowCasters(meshInstances: any, visible: any, camera: any): void;\n    cullLocal(light: any, drawCalls: any): void;\n    generateSplitDistances(light: any, nearDist: any, farDist: any): void;\n    cullDirectional(light: any, drawCalls: any, camera: any): void;\n    setupRenderState(device: any, light: any): void;\n    restoreRenderState(device: any): void;\n    dispatchUniforms(light: any, shadowCam: any, lightRenderData: any, face: any): void;\n    submitCasters(visibleCasters: any, light: any): void;\n    render(light: any, camera: any): void;\n    getVsmBlurShader(isVsm8: any, blurMode: any, filterSize: any): any;\n    applyVsmBlur(light: any, camera: any): void;\n}\n\ndeclare class CookieRenderer {\n    static createTexture(device: any, resolution: any): Texture;\n    static _invViewProjMatrices: any;\n    constructor(device: any, lightTextureAtlas: any);\n    device: any;\n    lightTextureAtlas: any;\n    blitShader2d: any;\n    blitShaderCube: any;\n    blitTextureId: any;\n    invViewProjId: any;\n    destroy(): void;\n    getShader(shader: any, fragment: any): any;\n    get shader2d(): any;\n    get shaderCube(): any;\n    initInvViewProjMatrices(): void;\n    render(light: any, renderTarget: any): void;\n}\n\n\n/**\n * The forward renderer renders {@link Scene}s.\n */\ndeclare class ForwardRenderer {\n    static skipRenderCamera: any;\n    static _skipRenderCounter: number;\n    static skipRenderAfter: number;\n    /**\n     * Create a new ForwardRenderer instance.\n     *\n     * @param {GraphicsDevice} graphicsDevice - The graphics device used by the renderer.\n     * @hideconstructor\n     */\n    constructor(graphicsDevice: GraphicsDevice);\n    device: GraphicsDevice;\n    scene: any;\n    _shadowDrawCalls: number;\n    _forwardDrawCalls: number;\n    _skinDrawCalls: number;\n    _numDrawCallsCulled: number;\n    _instancedDrawCalls: number;\n    _camerasRendered: number;\n    _materialSwitches: number;\n    _shadowMapUpdates: number;\n    _shadowMapTime: number;\n    _depthMapTime: number;\n    _forwardTime: number;\n    _cullTime: number;\n    _sortTime: number;\n    _skinTime: number;\n    _morphTime: number;\n    _layerCompositionUpdateTime: number;\n    _lightClustersTime: number;\n    _lightClusters: number;\n    library: ProgramLibrary;\n    lightTextureAtlas: LightTextureAtlas;\n    _shadowRenderer: ShadowRenderer;\n    _cookieRenderer: CookieRenderer;\n    projId: ScopeId;\n    projSkyboxId: ScopeId;\n    viewId: ScopeId;\n    viewId3: ScopeId;\n    viewInvId: ScopeId;\n    viewProjId: ScopeId;\n    viewPos: Float32Array;\n    viewPosId: ScopeId;\n    nearClipId: ScopeId;\n    farClipId: ScopeId;\n    cameraParamsId: ScopeId;\n    tbnBasis: ScopeId;\n    fogColorId: ScopeId;\n    fogStartId: ScopeId;\n    fogEndId: ScopeId;\n    fogDensityId: ScopeId;\n    modelMatrixId: ScopeId;\n    normalMatrixId: ScopeId;\n    poseMatrixId: ScopeId;\n    boneTextureId: ScopeId;\n    boneTextureSizeId: ScopeId;\n    morphWeightsA: ScopeId;\n    morphWeightsB: ScopeId;\n    morphPositionTex: ScopeId;\n    morphNormalTex: ScopeId;\n    morphTexParams: ScopeId;\n    alphaTestId: ScopeId;\n    opacityMapId: ScopeId;\n    ambientId: ScopeId;\n    exposureId: ScopeId;\n    skyboxIntensityId: ScopeId;\n    lightColorId: any[];\n    lightDir: any[];\n    lightDirId: any[];\n    lightShadowMapId: any[];\n    lightShadowMatrixId: any[];\n    lightShadowParamsId: any[];\n    lightRadiusId: any[];\n    lightPos: any[];\n    lightPosId: any[];\n    lightWidth: any[];\n    lightWidthId: any[];\n    lightHeight: any[];\n    lightHeightId: any[];\n    lightInAngleId: any[];\n    lightOutAngleId: any[];\n    lightCookieId: any[];\n    lightCookieIntId: any[];\n    lightCookieMatrixId: any[];\n    lightCookieOffsetId: any[];\n    shadowMatrixPaletteId: any[];\n    shadowCascadeDistancesId: any[];\n    shadowCascadeCountId: any[];\n    depthMapId: ScopeId;\n    screenSizeId: ScopeId;\n    _screenSize: Float32Array;\n    twoSidedLightingNegScaleFactorId: ScopeId;\n    fogColor: Float32Array;\n    ambientColor: Float32Array;\n    cameraParams: Float32Array;\n    destroy(): void;\n    sortCompare(drawCallA: any, drawCallB: any): number;\n    sortCompareMesh(drawCallA: any, drawCallB: any): number;\n    depthSortCompare(drawCallA: any, drawCallB: any): number;\n    updateCameraFrustum(camera: any): void;\n    setCamera(camera: any, target: any, clear: any): void;\n    clearView(camera: any, target: any, clear: any, forceWrite: any, options: any): void;\n    dispatchGlobalLights(scene: any): void;\n    _resolveLight(scope: any, i: any): void;\n    setLTCDirectionalLight(wtm: any, cnt: any, dir: any, campos: any, far: any): void;\n    dispatchDirectLights(dirs: any, scene: any, mask: any, camera: any): number;\n    setLTCPositionalLight(wtm: any, cnt: any): void;\n    dispatchOmniLight(scene: any, scope: any, omni: any, cnt: any): void;\n    dispatchSpotLight(scene: any, scope: any, spot: any, cnt: any): void;\n    dispatchLocalLights(sortedLights: any, scene: any, mask: any, usedDirLights: any, staticLightList: any): void;\n    cull(camera: any, drawCalls: any, visibleList: any): number;\n    cullLights(camera: any, lights: any): void;\n    updateCpuSkinMatrices(drawCalls: any): void;\n    updateGpuSkinMatrices(drawCalls: any): void;\n    updateMorphing(drawCalls: any): void;\n    setBaseConstants(device: any, material: any): void;\n    setSkinning(device: any, meshInstance: any, material: any): void;\n    drawInstance(device: any, meshInstance: any, mesh: any, style: any, normal: any): void;\n    drawInstance2(device: any, meshInstance: any, mesh: any, style: any): void;\n    renderShadows(lights: any, camera: any): void;\n    renderCookies(lights: any): void;\n    updateShader(meshInstance: any, objDefs: any, staticLightList: any, pass: any, sortedLights: any): void;\n    setCullMode(cullFaces: any, flip: any, drawCall: any): void;\n    setVertexBuffers(device: any, mesh: any): void;\n    setMorphing(device: any, morphInstance: any): void;\n    dispatchViewPos(position: any): void;\n    renderForwardPrepareMaterials(camera: any, drawCalls: any, drawCallsCount: any, sortedLights: any, cullingMask: any, layer: any, pass: any): {\n        drawCalls: any[];\n        isNewMaterial: any[];\n        lightMaskChanged: any[];\n    };\n    renderForward(camera: any, allDrawCalls: any, allDrawCallsCount: any, sortedLights: any, pass: any, cullingMask: any, drawCallback: any, layer: any, flipFaces: any): void;\n    updateShaders(drawCalls: any, onlyLitShaders: any): void;\n    beginFrame(comp: any, lightsChanged: any): void;\n    beginLayers(comp: any): void;\n    gpuUpdate(drawCalls: any): void;\n    setSceneConstants(): void;\n    updateLightStats(comp: any, compUpdatedFlags: any): void;\n    cullShadowmaps(comp: any): void;\n    cullComposition(comp: any): void;\n    updateLightTextureAtlas(comp: any): void;\n    updateClusters(comp: any): void;\n    renderComposition(comp: any): void;\n}\n\ndeclare class LightmapFilters {\n    constructor(device: any);\n    device: any;\n    shaderDilate: Shader;\n    constantTexSource: any;\n    constantPixelOffset: any;\n    pixelOffset: Float32Array;\n    shaderDenoise: Shader;\n    sigmas: Float32Array;\n    constantSigmas: any;\n    kernel: any;\n    setSourceTexture(texture: any): void;\n    prepare(textureWidth: any, textureHeight: any): void;\n    prepareDenoise(filterRange: any, filterSmoothness: any): void;\n    constantKernel: any;\n    bZnorm: any;\n    evaluateDenoiseUniforms(filterRange: any, filterSmoothness: any): void;\n}\n\n\n\n\n\n\n/**\n * The lightmapper is used to bake scene lights into textures.\n */\ndeclare class Lightmapper {\n    /**\n     * Create a new Lightmapper instance.\n     *\n     * @param {GraphicsDevice} device - The graphics device used by the lightmapper.\n     * @param {Entity} root - The root entity of the scene.\n     * @param {Scene} scene - The scene to lightmap.\n     * @param {ForwardRenderer} renderer - The renderer.\n     * @param {AssetRegistry} assets - Registry of assets to lightmap.\n     * @hideconstructor\n     */\n    constructor(device: GraphicsDevice, root: Entity, scene: Scene, renderer: ForwardRenderer, assets: AssetRegistry);\n    device: GraphicsDevice;\n    root: Entity;\n    scene: Scene;\n    renderer: ForwardRenderer;\n    assets: AssetRegistry;\n    shadowMapCache: ShadowMapCache;\n    _tempSet: Set<any>;\n    _initCalled: boolean;\n    passMaterials: any[];\n    ambientAOMaterial: StandardMaterial;\n    fog: string;\n    ambientLight: Color;\n    renderTargets: Map<any, any>;\n    stats: {\n        renderPasses: number;\n        lightmapCount: number;\n        totalRenderTime: number;\n        forwardTime: number;\n        fboTime: number;\n        shadowMapTime: number;\n        compileTime: number;\n        shadersLinked: number;\n    };\n    destroy(): void;\n    blackTex: Texture;\n    initBake(device: any): void;\n    lightmapFilters: LightmapFilters;\n    constantBakeDir: any;\n    materials: any[];\n    camera: Camera;\n    lightingParams: LightingParams;\n    worldClusters: WorldClusters;\n    finishBake(bakeNodes: any): void;\n    createMaterialForPass(device: any, scene: any, pass: any, addAmbient: any): StandardMaterial;\n    createMaterials(device: any, scene: any, passCount: any): void;\n    createTexture(size: any, type: any, name: any): Texture;\n    collectModels(node: any, bakeNodes: any, allNodes: any): void;\n    prepareShadowCasters(nodes: any): any[];\n    updateTransforms(nodes: any): void;\n    calculateLightmapSize(node: any): number;\n    setLightmapping(nodes: any, value: any, passCount: any, shaderDefs: any): void;\n    /**\n     * Generates and applies the lightmaps.\n     *\n     * @param {Entity[]|null} nodes - An array of entities (with model or render components) to\n     * render lightmaps for. If not supplied, the entire scene will be baked.\n     * @param {number} [mode] - Baking mode. Can be:\n     *\n     * - {@link BAKE_COLOR}: single color lightmap\n     * - {@link BAKE_COLORDIR}: single color lightmap + dominant light direction (used for\n     * bump/specular)\n     *\n     * Only lights with bakeDir=true will be used for generating the dominant light direction.\n     * Defaults to {@link BAKE_COLORDIR}.\n     */\n    bake(nodes: Entity[] | null, mode?: number): void;\n    allocateTextures(bakeNodes: any, passCount: any): void;\n    prepareLightsToBake(layerComposition: any, allLights: any, bakeLights: any): void;\n    restoreLights(allLights: any): void;\n    setupScene(): void;\n    revertStatic: boolean;\n    restoreScene(): void;\n    computeNodeBounds(meshInstances: any): BoundingBox;\n    computeNodesBounds(nodes: any): void;\n    computeBounds(meshInstances: any): BoundingBox;\n    backupMaterials(meshInstances: any): void;\n    restoreMaterials(meshInstances: any): void;\n    lightCameraPrepare(device: any, bakeLight: any): any;\n    lightCameraPrepareAndCull(bakeLight: any, bakeNode: any, shadowCam: any, casterBounds: any): boolean;\n    setupLightArray(lightArray: any, light: any): void;\n    renderShadowMap(shadowMapRendered: any, casters: any, lightArray: any, bakeLight: any): boolean;\n    postprocessTextures(device: any, bakeNodes: any, passCount: any): void;\n    bakeInternal(passCount: any, bakeNodes: any, allNodes: any): void;\n}\n\n/**\n * Holds mesh batching settings and a unique id. Created via {@link BatchManager#addGroup}.\n *\n * @property {boolean} dynamic Whether objects within this batch group should support transforming\n * at runtime.\n * @property {number} maxAabbSize Maximum size of any dimension of a bounding box around batched\n * objects. {@link BatchManager#prepare} will split objects into local groups based on this size.\n * @property {number} id Unique id. Can be assigned to model and element components.\n * @property {string} name Name of the group.\n * @property {number[]} [layers] Layer ID array. Default is [{@link LAYERID_WORLD}]. The whole\n * batch group will belong to these layers. Layers of source models will be ignored.\n */\ndeclare class BatchGroup {\n    static MODEL: string;\n    static ELEMENT: string;\n    static SPRITE: string;\n    static RENDER: string;\n    /**\n     * Create a new BatchGroup instance.\n     *\n     * @param {number} id - Unique id. Can be assigned to model and element components.\n     * @param {string} name - The name of the group.\n     * @param {boolean} dynamic - Whether objects within this batch group should support\n     * transforming at runtime.\n     * @param {number} maxAabbSize - Maximum size of any dimension of a bounding box around batched\n     * objects. {@link BatchManager#prepare} will split objects into local groups based on this\n     * size.\n     * @param {number[]} [layers] - Layer ID array. Default is [{@link LAYERID_WORLD}]. The whole\n     * batch group will belong to these layers. Layers of source models will be ignored.\n     */\n    constructor(id: number, name: string, dynamic: boolean, maxAabbSize: number, layers?: number[]);\n    dynamic: boolean;\n    maxAabbSize: number;\n    id: number;\n    name: string;\n    layers: number[];\n    _ui: boolean;\n    _sprite: boolean;\n    _obj: {\n        model: any[];\n        element: any[];\n        sprite: any[];\n        render: any[];\n    };\n}\n\n\n/** @typedef {import(\'../mesh-instance.js\').MeshInstance} MeshInstance */\n/**\n * Holds information about batched mesh instances. Created in {@link BatchManager#create}.\n *\n * @property {MeshInstance[]} origMeshInstances An array of original mesh instances, from which\n * this batch was generated.\n * @property {MeshInstance} meshInstance A single combined mesh instance, the result of batching.\n * @property {boolean} dynamic Whether this batch is dynamic (supports transforming mesh instances\n * at runtime).\n * @property {number} [batchGroupId] Link this batch to a specific batch group. This is done\n * automatically with default batches.\n */\ndeclare class Batch {\n    /**\n     * Create a new Batch instance.\n     *\n     * @param {MeshInstance[]} meshInstances - The mesh instances to be batched.\n     * @param {boolean} dynamic - Whether this batch is dynamic (supports transforming mesh instances at runtime).\n     * @param {number} batchGroupId - Link this batch to a specific batch group. This is done automatically with default batches.\n     */\n    constructor(meshInstances: MeshInstance[], dynamic: boolean, batchGroupId: number);\n    origMeshInstances: MeshInstance[];\n    _aabb: BoundingBox;\n    meshInstance: any;\n    dynamic: boolean;\n    batchGroupId: number;\n    destroy(scene: any, layers: any): void;\n    addToLayers(scene: any, layers: any): void;\n    removeFromLayers(scene: any, layers: any): void;\n    updateBoundingBox(): void;\n}\n\n\n\n\n/**\n * Glues many mesh instances into a single one for better performance.\n */\ndeclare class BatchManager {\n    /**\n     * Create a new BatchManager instance.\n     *\n     * @param {GraphicsDevice} device - The graphics device used by the batch manager.\n     * @param {Entity} root - The entity under which batched models are added.\n     * @param {Scene} scene - The scene that the batch manager affects.\n     */\n    constructor(device: GraphicsDevice, root: Entity, scene: Scene);\n    device: GraphicsDevice;\n    rootNode: Entity;\n    scene: Scene;\n    _init: boolean;\n    _batchGroups: {};\n    _batchGroupCounter: number;\n    _batchList: any[];\n    _dirtyGroups: any[];\n    _stats: {\n        createTime: number;\n        updateLastFrameTime: number;\n    };\n    destroy(): void;\n    /**\n     * Adds new global batch group.\n     *\n     * @param {string} name - Custom name.\n     * @param {boolean} dynamic - Is this batch group dynamic? Will these objects move/rotate/scale\n     * after being batched?\n     * @param {number} maxAabbSize - Maximum size of any dimension of a bounding box around batched\n     * objects.\n     * {@link BatchManager#prepare} will split objects into local groups based on this size.\n     * @param {number} [id] - Optional custom unique id for the group (will be generated\n     * automatically otherwise).\n     * @param {number[]} [layers] - Optional layer ID array. Default is [{@link LAYERID_WORLD}].\n     * The whole batch group will belong to these layers. Layers of source models will be ignored.\n     * @returns {BatchGroup} Group object.\n     */\n    addGroup(name: string, dynamic: boolean, maxAabbSize: number, id?: number, layers?: number[]): BatchGroup;\n    /**\n     * Remove global batch group by id. Note, this traverses the entire scene graph and clears the\n     * batch group id from all components.\n     *\n     * @param {number} id - Batch Group ID.\n     */\n    removeGroup(id: number): void;\n    /**\n     * Mark a specific batch group as dirty. Dirty groups are re-batched before the next frame is\n     * rendered. Note, re-batching a group is a potentially expensive operation.\n     *\n     * @param {number} id - Batch Group ID to mark as dirty.\n     */\n    markGroupDirty(id: number): void;\n    /**\n     * Retrieves a {@link BatchGroup} object with a corresponding name, if it exists, or null\n     * otherwise.\n     *\n     * @param {string} name - Name.\n     * @returns {BatchGroup|null} The batch group matching the name or null if not found.\n     */\n    getGroupByName(name: string): BatchGroup | null;\n    /**\n     * Return a list of all {@link Batch} objects that belong to the Batch Group supplied.\n     *\n     * @param {number} batchGroupId - The id of the batch group.\n     * @returns {Batch[]} A list of batches that are used to render the batch group.\n     * @private\n     */\n    private getBatches;\n    _removeModelsFromBatchGroup(node: any, id: any): void;\n    insert(type: any, groupId: any, node: any): void;\n    remove(type: any, groupId: any, node: any): void;\n    _extractRender(node: any, arr: any, group: any, groupMeshInstances: any): any;\n    _extractModel(node: any, arr: any, group: any, groupMeshInstances: any): any;\n    _extractElement(node: any, arr: any, group: any): void;\n    _collectAndRemoveMeshInstances(groupMeshInstances: any, groupIds: any): void;\n    /**\n     * Destroys all batches and creates new based on scene models. Hides original models. Called by\n     * engine automatically on app start, and if batchGroupIds on models are changed.\n     *\n     * @param {number[]} [groupIds] - Optional array of batch group IDs to update. Otherwise all\n     * groups are updated.\n     */\n    generate(groupIds?: number[]): void;\n    /**\n     * Takes a list of mesh instances to be batched and sorts them into lists one for each draw\n     * call. The input list will be split, if:\n     *\n     * - Mesh instances use different materials.\n     * - Mesh instances have different parameters (e.g. lightmaps or static lights).\n     * - Mesh instances have different shader defines (shadow receiving, being aligned to screen\n     * space, etc).\n     * - Too many vertices for a single batch (65535 is maximum).\n     * - Too many instances for a single batch (hardware-dependent, expect 128 on low-end and 1024\n     * on high-end).\n     * - Bounding box of a batch is larger than maxAabbSize in any dimension.\n     *\n     * @param {MeshInstance[]} meshInstances - Input list of mesh instances\n     * @param {boolean} dynamic - Are we preparing for a dynamic batch? Instance count will matter\n     * then (otherwise not).\n     * @param {number} maxAabbSize - Maximum size of any dimension of a bounding box around batched\n     * objects.\n     * @param {boolean} translucent - Are we batching UI elements or sprites\n     * This is useful to keep a balance between the number of draw calls and the number of drawn\n     * triangles, because smaller batches can be hidden when not visible in camera.\n     * @returns {MeshInstance[][]} An array of arrays of mesh instances, each valid to pass to\n     * {@link BatchManager#create}.\n     */\n    prepare(meshInstances: MeshInstance[], dynamic: boolean, maxAabbSize: number, translucent: boolean): MeshInstance[][];\n    collectBatchedMeshData(meshInstances: any, dynamic: any): {\n        streams: {};\n        batchNumVerts: number;\n        batchNumIndices: number;\n        material: any;\n    };\n    /**\n     * Takes a mesh instance list that has been prepared by {@link BatchManager#prepare}, and\n     * returns a {@link Batch} object. This method assumes that all mesh instances provided can be\n     * rendered in a single draw call.\n     *\n     * @param {MeshInstance[]} meshInstances - Input list of mesh instances.\n     * @param {boolean} dynamic - Is it a static or dynamic batch? Will objects be transformed\n     * after batching?\n     * @param {number} [batchGroupId] - Link this batch to a specific batch group. This is done\n     * automatically with default batches.\n     * @returns {Batch} The resulting batch object.\n     */\n    create(meshInstances: MeshInstance[], dynamic: boolean, batchGroupId?: number): Batch;\n    transformVS: string;\n    skinTexVS: any;\n    skinConstVS: any;\n    vertexFormats: {};\n    /**\n     * Updates bounding boxes for all dynamic batches. Called automatically.\n     *\n     * @private\n     */\n    private updateAll;\n    /**\n     * Clones a batch. This method doesn\'t rebuild batch geometry, but only creates a new model and\n     * batch objects, linked to different source mesh instances.\n     *\n     * @param {Batch} batch - A batch object.\n     * @param {MeshInstance[]} clonedMeshInstances - New mesh instances.\n     * @returns {Batch} New batch object.\n     */\n    clone(batch: Batch, clonedMeshInstances: MeshInstance[]): Batch;\n    /**\n     * Removes the batch model from all layers and destroys it.\n     *\n     * @param {Batch} batch - A batch object.\n     * @private\n     */\n    private destroyBatch;\n}\n\n\n/**\n * Callback used by {@link VrDisplayrequestPresent } and {@link VrDisplayexitPresent }.\n */\nexport type VrDisplayCallback = (err: string | null) => any;\n/**\n * Callback used by {@link VrDisplayrequestAnimationFrame }.\n */\nexport type VrFrameCallback = () => any;\n/** @typedef {import(\'../framework/app-base.js\').Application} Application */\n/**\n * Callback used by {@link VrDisplay#requestPresent} and {@link VrDisplay#exitPresent}.\n *\n * @callback VrDisplayCallback\n * @param {string|null} err - The error message if presenting fails, or null if the call succeeds.\n * @ignore\n */\n/**\n * Callback used by {@link VrDisplay#requestAnimationFrame}.\n *\n * @callback VrFrameCallback\n * @ignore\n */\n/**\n * Represents a single Display for VR content. This could be a Head Mounted display that can\n * present content on a separate screen or a phone which can display content full screen on the\n * same screen. This object contains the native `navigator.VRDisplay` object from the WebVR API.\n *\n * @augments EventHandler\n * @deprecated\n * @ignore\n */\ndeclare class VrDisplay extends EventHandler {\n    /**\n     * Create a new VrDisplay instance.\n     *\n     * @param {Application} app - The application outputting to this VR display.\n     * @param {*} display - The native VRDisplay object from the WebVR API.\n     */\n    constructor(app: Application, display: any);\n    /**\n     * An identifier for this distinct VRDisplay.\n     *\n     * @type {number}\n     */\n    id: number;\n    /**\n     * The native VRDisplay object from the WebVR API.\n     *\n     * @type {*}\n     */\n    display: any;\n    /**\n     * True if this display is currently presenting VR content.\n     *\n     * @type {boolean}\n     */\n    presenting: boolean;\n    _app: Application;\n    _device: GraphicsDevice;\n    _frameData: any;\n    _camera: any;\n    sitToStandInv: Mat4;\n    leftView: Mat4;\n    leftProj: Mat4;\n    leftViewInv: Mat4;\n    leftPos: Vec3;\n    rightView: Mat4;\n    rightProj: Mat4;\n    rightViewInv: Mat4;\n    rightPos: Vec3;\n    combinedPos: Vec3;\n    combinedView: Mat4;\n    combinedProj: Mat4;\n    combinedViewInv: Mat4;\n    combinedFov: number;\n    combinedAspect: number;\n    _presentChange: (event: any) => void;\n    /**\n     * Destroy this display object.\n     *\n     * @deprecated\n     */\n    destroy(): void;\n    /**\n     * Called once per frame to update the current status from the display. Usually called by {@link VrManager}.\n     *\n     * @deprecated\n     */\n    poll(): void;\n    /**\n     * Try to present full screen VR content on this display.\n     *\n     * @param {VrDisplayCallback} callback - Called when the request is completed. Callback takes a\n     * single argument (err) that is the error message return if presenting fails, or null if the\n     * call succeeds. Usually called by {@link CameraComponent#enterVr}.\n     * @deprecated\n     */\n    requestPresent(callback: VrDisplayCallback): void;\n    /**\n     * Try to stop presenting VR content on this display.\n     *\n     * @param {VrDisplayCallback} callback - Called when the request is completed. Callback takes a\n     * single argument (err) that is the error message return if presenting fails, or null if the\n     * call succeeds. Usually called by {@link CameraComponent#exitVr}.\n     * @deprecated\n     */\n    exitPresent(callback: VrDisplayCallback): void;\n    /**\n     * Used in the main application loop instead of the regular `window.requestAnimationFrame`.\n     * Usually only called from inside {@link Application}.\n     *\n     * @param {VrFrameCallback} fn - Function called when it is time to update the frame.\n     * @deprecated\n     */\n    requestAnimationFrame(fn: VrFrameCallback): void;\n    /**\n     * Called when animation update is complete and the frame is ready to be sent to the display.\n     * Usually only called from inside {@link Application}.\n     *\n     * @deprecated\n     */\n    submitFrame(): void;\n    /**\n     * Called to reset the pose of the {@link VrDisplay}. Treating its current pose as the\n     * origin/zero. This should only be called in \'sitting\' experiences.\n     *\n     * @deprecated\n     */\n    reset(): void;\n    /**\n     * Set the near and far depth plans of the display. This enables mapping of values in the\n     * render target depth attachment to scene coordinates.\n     *\n     * @param {number} n - The near depth distance.\n     * @param {number} f - The far depth distance.\n     * @deprecated\n     */\n    setClipPlanes(n: number, f: number): void;\n    /**\n     * Return the current frame data that is updated during polling.\n     *\n     * @returns {*} The frame data object.\n     * @deprecated\n     */\n    getFrameData(): any;\n    /**\n     * Returns the [VRDisplayCapabilities](https://w3c.github.io/webvr/#interface-vrdisplaycapabilities)\n     * object from the VRDisplay. This can be used to determine what features are available on this\n     * display.\n     *\n     * @type {*}\n     */\n    get capabilities(): any;\n}\n\n\n/** @typedef {import(\'../framework/app-base.js\').Application} Application */\n/**\n * Manage and update {@link VrDisplay}s that are attached to this device.\n *\n * @augments EventHandler\n * @deprecated\n * @ignore\n */\ndeclare class VrManager extends EventHandler {\n    /**\n     * @ignore\n     * @deprecated\n     * @event\n     * @name VrManager#displayconnect\n     * @description Fired when an VR display is connected.\n     * @param {VrDisplay} display - The {@link VrDisplay} that has just been connected.\n     * @example\n     * this.app.vr.on("displayconnect", function (display) {\n     *     // use `display` here\n     * });\n     */\n    /**\n     * @ignore\n     * @deprecated\n     * @event\n     * @name VrManager#displaydisconnect\n     * @description Fired when an VR display is disconnected.\n     * @param {VrDisplay} display - The {@link VrDisplay} that has just been disconnected.\n     * @example\n     * this.app.vr.on("displaydisconnect", function (display) {\n     *     // `display` is no longer connected\n     * });\n     */\n    /**\n     * Reports whether this device supports the WebVR API.\n     *\n     * @type {boolean}\n     * @deprecated\n     */\n    static isSupported: boolean;\n    /**\n     * Create a new VrManager instance.\n     *\n     * @param {Application} app - The main application.\n     */\n    constructor(app: Application);\n    /**\n     * displays The list of {@link VrDisplay}s that are attached to this device.\n     *\n     * @type {VrDisplay[]}\n     */\n    displays: VrDisplay[];\n    /**\n     * The default {@link VrDisplay} to be used. Usually the first in the `displays` list.\n     *\n     * @type {VrDisplay}\n     */\n    display: VrDisplay;\n    /**\n     * Reports whether this device supports the WebVR API.\n     *\n     * @type {boolean}\n     */\n    isSupported: boolean;\n    _index: {};\n    _app: Application;\n    _onDisplayConnect(e: any): void;\n    _onDisplayDisconnect(e: any): void;\n    _attach(): void;\n    _detach(): void;\n    /**\n     * Remove events and clear up manager.\n     *\n     * @deprecated\n     */\n    destroy(): void;\n    /**\n     * Called once per frame to poll all attached displays.\n     *\n     * @deprecated\n     */\n    poll(): void;\n    _getDisplays(callback: any): void;\n    _addDisplay(vrDisplay: any): void;\n}\n\n\n\n/** @typedef {import(\'../../entity.js\').Entity} Entity */\n/** @typedef {import(\'./system.js\').ZoneComponentSystem} ZoneComponentSystem */\n/**\n * The ZoneComponent allows you to define an area in world space of certain size. This can be used\n * in various ways, such as affecting audio reverb when {@link AudioListenerComponent} is within\n * zone. Or create culling system with portals between zones to hide whole indoor sections for\n * performance reasons. And many other possible options. Zones are building blocks and meant to be\n * used in many different ways.\n *\n * @augments Component\n * @ignore\n */\ndeclare class ZoneComponent extends Component {\n    /**\n     * Create a new ZoneComponent instance.\n     *\n     * @param {ZoneComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: ZoneComponentSystem, entity: Entity);\n    _oldState: boolean;\n    _size: Vec3;\n    /**\n     * The size of the axis-aligned box of this ZoneComponent.\n     *\n     * @type {Vec3}\n     */\n    set size(arg: Vec3);\n    get size(): Vec3;\n    _onSetEnabled(prop: any, old: any, value: any): void;\n    _checkState(): void;\n    _onBeforeRemove(): void;\n}\n\ndeclare class ZoneComponentData {\n    enabled: boolean;\n}\n\n/**\n * Creates and manages {@link ZoneComponent} instances.\n *\n * @augments ComponentSystem\n * @ignore\n */\ndeclare class ZoneComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof ZoneComponent;\n    DataType: typeof ZoneComponentData;\n    schema: string[];\n    initializeComponentData(component: any, data: any, properties: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    _onBeforeRemove(entity: any, component: any): void;\n}\n\n\n\n/**\n * The JointComponent adds a physics joint constraint linking two rigid bodies.\n *\n * @augments Component\n * @ignore\n */\ndeclare class JointComponent extends Component {\n    /**\n     * Create a new JointComponent instance.\n     *\n     * @param {JointComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: JointComponentSystem, entity: Entity);\n    _constraint: any;\n    _entityA: any;\n    _entityB: any;\n    _breakForce: number;\n    _enableCollision: boolean;\n    _linearMotionX: string;\n    _linearLimitsX: Vec2;\n    _linearSpringX: boolean;\n    _linearStiffnessX: number;\n    _linearDampingX: number;\n    _linearEquilibriumX: number;\n    _linearMotionY: string;\n    _linearLimitsY: Vec2;\n    _linearSpringY: boolean;\n    _linearStiffnessY: number;\n    _linearDampingY: number;\n    _linearEquilibriumY: number;\n    _linearMotionZ: string;\n    _linearLimitsZ: Vec2;\n    _linearSpringZ: boolean;\n    _linearStiffnessZ: number;\n    _linearDampingZ: number;\n    _linearEquilibriumZ: number;\n    _angularMotionX: string;\n    _angularLimitsX: Vec2;\n    _angularSpringX: boolean;\n    _angularStiffnessX: number;\n    _angularDampingX: number;\n    _angularEquilibriumX: number;\n    _angularMotionY: string;\n    _angularLimitsY: Vec2;\n    _angularSpringY: boolean;\n    _angularStiffnessY: number;\n    _angularDampingY: number;\n    _angularEquilibriumY: number;\n    _angularMotionZ: string;\n    _angularLimitsZ: Vec2;\n    _angularSpringZ: boolean;\n    _angularEquilibriumZ: number;\n    _angularDampingZ: number;\n    _angularStiffnessZ: number;\n    set entityA(arg: any);\n    get entityA(): any;\n    set entityB(arg: any);\n    get entityB(): any;\n    set breakForce(arg: number);\n    get breakForce(): number;\n    set enableCollision(arg: boolean);\n    get enableCollision(): boolean;\n    set angularLimitsX(arg: Vec2);\n    get angularLimitsX(): Vec2;\n    set angularMotionX(arg: string);\n    get angularMotionX(): string;\n    set angularLimitsY(arg: Vec2);\n    get angularLimitsY(): Vec2;\n    set angularMotionY(arg: string);\n    get angularMotionY(): string;\n    set angularLimitsZ(arg: Vec2);\n    get angularLimitsZ(): Vec2;\n    set angularMotionZ(arg: string);\n    get angularMotionZ(): string;\n    set linearLimitsX(arg: Vec2);\n    get linearLimitsX(): Vec2;\n    set linearMotionX(arg: string);\n    get linearMotionX(): string;\n    set linearLimitsY(arg: Vec2);\n    get linearLimitsY(): Vec2;\n    set linearMotionY(arg: string);\n    get linearMotionY(): string;\n    set linearLimitsZ(arg: Vec2);\n    get linearLimitsZ(): Vec2;\n    set linearMotionZ(arg: string);\n    get linearMotionZ(): string;\n    _convertTransform(pcTransform: any, ammoTransform: any): void;\n    _updateAngularLimits(): void;\n    _updateLinearLimits(): void;\n    _createConstraint(): void;\n    _destroyConstraint(): void;\n    initFromData(data: any): void;\n    _onSetEnabled(prop: any, old: any, value: any): void;\n    _onBeforeRemove(): void;\n}\n\ndeclare class JointComponentData {\n    enabled: boolean;\n}\n\n/**\n * Creates and manages physics joint components.\n *\n * @augments ComponentSystem\n * @ignore\n */\ndeclare class JointComponentSystem extends ComponentSystem {\n    id: string;\n    ComponentType: typeof JointComponent;\n    DataType: typeof JointComponentData;\n    schema: string[];\n    initializeComponentData(component: any, data: any, properties: any): void;\n}\n\n\n\n/** @typedef {import(\'./system.js\').AudioSourceComponentSystem} AudioSourceComponentSystem */\n/** @typedef {import(\'../../entity.js\').Entity} Entity */\n/**\n * The AudioSource Component controls playback of an audio sample. This class will be deprecated\n * in favor of {@link SoundComponent}.\n *\n * @property {Asset[]} assets The list of audio assets - can also be an array of asset ids.\n * @property {boolean} activate If true the audio will begin playing as soon as the scene is\n * loaded.\n * @property {number} volume The volume modifier to play the audio with. In range 0-1.\n * @property {number} pitch The pitch modifier to play the audio with. Must be larger than 0.01.\n * @property {boolean} loop If true the audio will restart when it finishes playing.\n * @property {boolean} 3d If true the audio will play back at the location of the entity in space,\n * so the audio will be affect by the position of the {@link AudioListenerComponent}.\n * @property {string} distanceModel Determines which algorithm to use to reduce the volume of the\n * audio as it moves away from the listener. Can be:\n *\n * - "linear"\n * - "inverse"\n * - "exponential"\n *\n * Default is "inverse".\n * @property {number} minDistance The minimum distance from the listener at which audio falloff\n * begins.\n * @property {number} maxDistance The maximum distance from the listener at which audio falloff\n * stops. Note the volume of the audio is not 0 after this distance, but just doesn\'t fall off\n * anymore.\n * @property {number} rollOffFactor The factor used in the falloff equation.\n * @augments Component\n * @ignore\n */\ndeclare class AudioSourceComponent extends Component {\n    /**\n     * Create a new AudioSource Component instance.\n     *\n     * @param {AudioSourceComponentSystem} system - The ComponentSystem that created\n     * this component.\n     * @param {Entity} entity - The entity that the Component is attached to.\n     */\n    constructor(system: AudioSourceComponentSystem, entity: Entity);\n    /**\n     * Begin playback of an audio asset in the component attached to an entity.\n     *\n     * @param {string} name - The name of the Asset to play.\n     */\n    play(name: string): void;\n    /**\n     * Pause playback of the audio that is playing on the Entity. Playback can be resumed by\n     * calling {@link AudioSourceComponent#unpause}.\n     */\n    pause(): void;\n    /**\n     * Resume playback of the audio if paused. Playback is resumed at the time it was paused.\n     */\n    unpause(): void;\n    /**\n     * Stop playback on an Entity. Playback can not be resumed after being stopped.\n     */\n    stop(): void;\n    channel: any;\n    onSetAssets(name: any, oldValue: any, newValue: any): void;\n    onAssetChanged(asset: any, attribute: any, newValue: any, oldValue: any): void;\n    onAssetRemoved(asset: any): void;\n    onSetLoop(name: any, oldValue: any, newValue: any): void;\n    onSetVolume(name: any, oldValue: any, newValue: any): void;\n    onSetPitch(name: any, oldValue: any, newValue: any): void;\n    onSetMaxDistance(name: any, oldValue: any, newValue: any): void;\n    onSetMinDistance(name: any, oldValue: any, newValue: any): void;\n    onSetRollOffFactor(name: any, oldValue: any, newValue: any): void;\n    onSetDistanceModel(name: any, oldValue: any, newValue: any): void;\n    onSet3d(name: any, oldValue: any, newValue: any): void;\n    loadAudioSourceAssets(ids: any): void;\n}\n\ndeclare class AudioSourceComponentData {\n    enabled: boolean;\n    assets: any[];\n    activate: boolean;\n    volume: number;\n    pitch: number;\n    loop: boolean;\n    \'3d\': boolean;\n    minDistance: number;\n    maxDistance: number;\n    rollOffFactor: number;\n    distanceModel: string;\n    paused: boolean;\n    sources: {};\n    currentSource: any;\n    channel: any;\n}\n\n\n\n/**\n * Controls playback of an audio sample. This class will be deprecated in favor of\n * {@link SoundComponentSystem}.\n *\n * @augments ComponentSystem\n * @ignore\n */\ndeclare class AudioSourceComponentSystem extends ComponentSystem {\n    /**\n     * Create a new AudioSourceComponentSystem instance.\n     *\n     * @param {Application} app - The application managing this system.\n     * @param {SoundManager} manager - A sound manager instance.\n     */\n    constructor(app: Application, manager: SoundManager);\n    id: string;\n    ComponentType: typeof AudioSourceComponent;\n    DataType: typeof AudioSourceComponentData;\n    schema: string[];\n    manager: SoundManager;\n    initialized: boolean;\n    initializeComponentData(component: any, data: any, properties: any): void;\n    onInitialize(root: any): void;\n    onUpdate(dt: any): void;\n    onRemove(entity: any, data: any): void;\n    /**\n     * Set the volume for the entire AudioSource system. All sources will have their volume\n     * multiplied by this value.\n     *\n     * @param {number} volume - The value to set the volume to. Valid from 0 to 1.\n     */\n    setVolume(volume: number): void;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** @typedef {import(\'./anim/system.js\').AnimComponentSystem} AnimComponentSystem */\n/** @typedef {import(\'./animation/system.js\').AnimationComponentSystem} AnimationComponentSystem */\n/** @typedef {import(\'./audio-listener/system.js\').AudioListenerComponentSystem} AudioListenerComponentSystem */\n/** @typedef {import(\'./audio-source/system.js\').AudioSourceComponentSystem} AudioSourceComponentSystem */\n/** @typedef {import(\'./button/system.js\').ButtonComponentSystem} ButtonComponentSystem */\n/** @typedef {import(\'./camera/system.js\').CameraComponentSystem} CameraComponentSystem */\n/** @typedef {import(\'./collision/system.js\').CollisionComponentSystem} CollisionComponentSystem */\n/** @typedef {import(\'./element/system.js\').ElementComponentSystem} ElementComponentSystem */\n/** @typedef {import(\'./joint/system.js\').JointComponentSystem} JointComponentSystem */\n/** @typedef {import(\'./layout-child/system.js\').LayoutChildComponentSystem} LayoutChildComponentSystem */\n/** @typedef {import(\'./layout-group/system.js\').LayoutGroupComponentSystem} LayoutGroupComponentSystem */\n/** @typedef {import(\'./light/system.js\').LightComponentSystem} LightComponentSystem */\n/** @typedef {import(\'./model/system.js\').ModelComponentSystem} ModelComponentSystem */\n/** @typedef {import(\'./particle-system/system.js\').ParticleSystemComponentSystem} ParticleSystemComponentSystem */\n/** @typedef {import(\'./render/system.js\').RenderComponentSystem} RenderComponentSystem */\n/** @typedef {import(\'./rigid-body/system.js\').RigidBodyComponentSystem} RigidBodyComponentSystem */\n/** @typedef {import(\'./screen/system.js\').ScreenComponentSystem} ScreenComponentSystem */\n/** @typedef {import(\'./script/system.js\').ScriptComponentSystem} ScriptComponentSystem */\n/** @typedef {import(\'./scrollbar/system.js\').ScrollbarComponentSystem} ScrollbarComponentSystem */\n/** @typedef {import(\'./scroll-view/system.js\').ScrollViewComponentSystem} ScrollViewComponentSystem */\n/** @typedef {import(\'./sound/system.js\').SoundComponentSystem} SoundComponentSystem */\n/** @typedef {import(\'./sprite/system.js\').SpriteComponentSystem} SpriteComponentSystem */\n/** @typedef {import(\'./zone/system.js\').ZoneComponentSystem} ZoneComponentSystem */\n/**\n * Store, access and delete instances of the various ComponentSystems.\n */\ndeclare class ComponentSystemRegistry extends EventHandler {\n    /**\n     * Gets the {@link AnimComponentSystem} from the registry.\n     *\n     * @type {AnimComponentSystem|undefined}\n     * @readonly\n     */\n    readonly anim: AnimComponentSystem | undefined;\n    /**\n     * Gets the {@link AnimationComponentSystem} from the registry.\n     *\n     * @type {AnimationComponentSystem|undefined}\n     * @readonly\n     */\n    readonly animation: AnimationComponentSystem | undefined;\n    /**\n     * Gets the {@link AudioListenerComponentSystem} from the registry.\n     *\n     * @type {AudioListenerComponentSystem|undefined}\n     * @readonly\n     */\n    readonly audiolistener: AudioListenerComponentSystem | undefined;\n    /**\n     * Gets the {@link AudioSourceComponentSystem} from the registry.\n     *\n     * @type {AudioSourceComponentSystem|undefined}\n     * @readonly\n     * @ignore\n     */\n    readonly audiosource: AudioSourceComponentSystem | undefined;\n    /**\n     * Gets the {@link ButtonComponentSystem} from the registry.\n     *\n     * @type {ButtonComponentSystem|undefined}\n     * @readonly\n     */\n    readonly button: ButtonComponentSystem | undefined;\n    /**\n     * Gets the {@link CameraComponentSystem} from the registry.\n     *\n     * @type {CameraComponentSystem|undefined}\n     * @readonly\n     */\n    readonly camera: CameraComponentSystem | undefined;\n    /**\n     * Gets the {@link CollisionComponentSystem} from the registry.\n     *\n     * @type {CollisionComponentSystem|undefined}\n     * @readonly\n     */\n    readonly collision: CollisionComponentSystem | undefined;\n    /**\n     * Gets the {@link ElementComponentSystem} from the registry.\n     *\n     * @type {ElementComponentSystem|undefined}\n     * @readonly\n     */\n    readonly element: ElementComponentSystem | undefined;\n    /**\n     * Gets the {@link JointComponentSystem} from the registry.\n     *\n     * @type {JointComponentSystem|undefined}\n     * @readonly\n     * @ignore\n     */\n    readonly joint: JointComponentSystem | undefined;\n    /**\n     * Gets the {@link LayoutChildComponentSystem} from the registry.\n     *\n     * @type {LayoutChildComponentSystem|undefined}\n     * @readonly\n     */\n    readonly layoutchild: LayoutChildComponentSystem | undefined;\n    /**\n     * Gets the {@link LayoutGroupComponentSystem} from the registry.\n     *\n     * @type {LayoutGroupComponentSystem|undefined}\n     * @readonly\n     */\n    readonly layoutgroup: LayoutGroupComponentSystem | undefined;\n    /**\n     * Gets the {@link LightComponentSystem} from the registry.\n     *\n     * @type {LightComponentSystem|undefined}\n     * @readonly\n     */\n    readonly light: LightComponentSystem | undefined;\n    /**\n     * Gets the {@link ModelComponentSystem} from the registry.\n     *\n     * @type {ModelComponentSystem|undefined}\n     * @readonly\n     */\n    readonly model: ModelComponentSystem | undefined;\n    /**\n     * Gets the {@link ParticleSystemComponentSystem} from the registry.\n     *\n     * @type {ParticleSystemComponentSystem|undefined}\n     * @readonly\n     */\n    readonly particlesystem: ParticleSystemComponentSystem | undefined;\n    /**\n     * Gets the {@link RenderComponentSystem} from the registry.\n     *\n     * @type {RenderComponentSystem|undefined}\n     * @readonly\n     */\n    readonly render: RenderComponentSystem | undefined;\n    /**\n     * Gets the {@link RigidBodyComponentSystem} from the registry.\n     *\n     * @type {RigidBodyComponentSystem|undefined}\n     * @readonly\n     */\n    readonly rigidbody: RigidBodyComponentSystem | undefined;\n    /**\n     * Gets the {@link ScreenComponentSystem} from the registry.\n     *\n     * @type {ScreenComponentSystem|undefined}\n     * @readonly\n     */\n    readonly screen: ScreenComponentSystem | undefined;\n    /**\n     * Gets the {@link ScriptComponentSystem} from the registry.\n     *\n     * @type {ScriptComponentSystem|undefined}\n     * @readonly\n     */\n    readonly script: ScriptComponentSystem | undefined;\n    /**\n     * Gets the {@link ScrollbarComponentSystem} from the registry.\n     *\n     * @type {ScrollbarComponentSystem|undefined}\n     * @readonly\n     */\n    readonly scrollbar: ScrollbarComponentSystem | undefined;\n    /**\n     * Gets the {@link ScrollViewComponentSystem} from the registry.\n     *\n     * @type {ScrollViewComponentSystem|undefined}\n     * @readonly\n     */\n    readonly scrollview: ScrollViewComponentSystem | undefined;\n    /**\n     * Gets the {@link SoundComponentSystem} from the registry.\n     *\n     * @type {SoundComponentSystem|undefined}\n     * @readonly\n     */\n    readonly sound: SoundComponentSystem | undefined;\n    /**\n     * Gets the {@link SpriteComponentSystem} from the registry.\n     *\n     * @type {SpriteComponentSystem|undefined}\n     * @readonly\n     */\n    readonly sprite: SpriteComponentSystem | undefined;\n    /**\n     * Gets the {@link ZoneComponentSystem} from the registry.\n     *\n     * @type {ZoneComponentSystem|undefined}\n     * @readonly\n     * @ignore\n     */\n    readonly zone: ZoneComponentSystem | undefined;\n    list: any[];\n    /**\n     * Add a component system to the registry.\n     *\n     * @param {object} system - The {@link ComponentSystem} instance.\n     * @ignore\n     */\n    add(system: object): void;\n    /**\n     * Remove a component system from the registry.\n     *\n     * @param {object} system - The {@link ComponentSystem} instance.\n     * @ignore\n     */\n    remove(system: object): void;\n    destroy(): void;\n}\n\n\n\n\n\n\n\n\n\n\n/**\n * Callback used by {@link Applicationconfigure } when configuration file is loaded and parsed (or\n * an error occurs).\n */\nexport type ConfigureAppCallback = (err: string | null) => any;\n/**\n * Callback used by {@link Applicationpreload } when all assets (marked as \'preload\') are loaded.\n */\nexport type PreloadAppCallback = () => any;\n/**\n * Callback used by {@link Application#configure} when configuration file is loaded and parsed (or\n * an error occurs).\n *\n * @callback ConfigureAppCallback\n * @param {string|null} err - The error message in the case where the loading or parsing fails.\n */\n/**\n * Callback used by {@link Application#preload} when all assets (marked as \'preload\') are loaded.\n *\n * @callback PreloadAppCallback\n */\ndeclare let app: any;\n/**\n * An Application represents and manages your PlayCanvas application. If you are developing using\n * the PlayCanvas Editor, the Application is created for you. You can access your Application\n * instance in your scripts. Below is a skeleton script which shows how you can access the\n * application \'app\' property inside the initialize and update functions:\n *\n * ```javascript\n * // Editor example: accessing the pc.Application from a script\n * var MyScript = pc.createScript(\'myScript\');\n *\n * MyScript.prototype.initialize = function() {\n *     // Every script instance has a property \'this.app\' accessible in the initialize...\n *     var app = this.app;\n * };\n *\n * MyScript.prototype.update = function(dt) {\n *     // ...and update functions.\n *     var app = this.app;\n * };\n * ```\n *\n * If you are using the Engine without the Editor, you have to create the application instance\n * manually.\n *\n * @augments EventHandler\n */\ndeclare class Application extends EventHandler {\n    /**\n     * @private\n     * @static\n     * @name app\n     * @type {Application|undefined}\n     * @description Gets the current application, if any.\n     */\n    private static _applications;\n    /**\n     * Get the current application. In the case where there are multiple running applications, the\n     * function can get an application based on a supplied canvas id. This function is particularly\n     * useful when the current Application is not readily available. For example, in the JavaScript\n     * console of the browser\'s developer tools.\n     *\n     * @param {string} [id] - If defined, the returned application should use the canvas which has\n     * this id. Otherwise current application will be returned.\n     * @returns {Application|undefined} The running application, if any.\n     * @example\n     * var app = pc.Application.getApplication();\n     */\n    static getApplication(id?: string): Application | undefined;\n    /**\n     * Create a new Application instance.\n     *\n     * @param {Element} canvas - The canvas element.\n     * @param {object} [options] - The options object to configure the Application.\n     * @param {ElementInput} [options.elementInput] - Input handler for {@link ElementComponent}s.\n     * @param {Keyboard} [options.keyboard] - Keyboard handler for input.\n     * @param {Mouse} [options.mouse] - Mouse handler for input.\n     * @param {TouchDevice} [options.touch] - TouchDevice handler for input.\n     * @param {GamePads} [options.gamepads] - Gamepad handler for input.\n     * @param {string} [options.scriptPrefix] - Prefix to apply to script urls before loading.\n     * @param {string} [options.assetPrefix] - Prefix to apply to asset urls before loading.\n     * @param {object} [options.graphicsDeviceOptions] - Options object that is passed into the\n     * {@link GraphicsDevice} constructor.\n     * @param {string[]} [options.scriptsOrder] - Scripts in order of loading first.\n     * @example\n     * // Engine-only example: create the application manually\n     * var app = new pc.Application(canvas, options);\n     *\n     * // Start the application\'s main loop\n     * app.start();\n     */\n    constructor(canvas: Element, options?: {\n        elementInput?: ElementInput;\n        keyboard?: Keyboard;\n        mouse?: Mouse;\n        touch?: TouchDevice;\n        gamepads?: GamePads;\n        scriptPrefix?: string;\n        assetPrefix?: string;\n        graphicsDeviceOptions?: object;\n        scriptsOrder?: string[];\n    });\n    /** @private */\n    private _destroyRequested;\n    /** @private */\n    private _inFrameUpdate;\n    /** @private */\n    private _time;\n    /**\n     * Scales the global time delta. Defaults to 1.\n     *\n     * @type {number}\n     * @example\n     * // Set the app to run at half speed\n     * this.app.timeScale = 0.5;\n     */\n    timeScale: number;\n    /**\n     * Clamps per-frame delta time to an upper bound. Useful since returning from a tab\n     * deactivation can generate huge values for dt, which can adversely affect game state.\n     * Defaults to 0.1 (seconds).\n     *\n     * @type {number}\n     * @example\n     * // Don\'t clamp inter-frame times of 200ms or less\n     * this.app.maxDeltaTime = 0.2;\n     */\n    maxDeltaTime: number;\n    /**\n     * The total number of frames the application has updated since start() was called.\n     *\n     * @type {number}\n     * @ignore\n     */\n    frame: number;\n    /**\n     * When true, the application\'s render function is called every frame. Setting autoRender\n     * to false is useful to applications where the rendered image may often be unchanged over\n     * time. This can heavily reduce the application\'s load on the CPU and GPU. Defaults to\n     * true.\n     *\n     * @type {boolean}\n     * @example\n     * // Disable rendering every frame and only render on a keydown event\n     * this.app.autoRender = false;\n     * this.app.keyboard.on(\'keydown\', function (event) {\n     *     this.app.renderNextFrame = true;\n     * }, this);\n     */\n    autoRender: boolean;\n    /**\n     * Set to true to render the scene on the next iteration of the main loop. This only has an\n     * effect if {@link Application#autoRender} is set to false. The value of renderNextFrame\n     * is set back to false again as soon as the scene has been rendered.\n     *\n     * @type {boolean}\n     * @example\n     * // Render the scene only while space key is pressed\n     * if (this.app.keyboard.isPressed(pc.KEY_SPACE)) {\n     *     this.app.renderNextFrame = true;\n     * }\n     */\n    renderNextFrame: boolean;\n    /**\n     * Enable if you want entity type script attributes to not be re-mapped when an entity is\n     * cloned.\n     *\n     * @type {boolean}\n     * @ignore\n     */\n    useLegacyScriptAttributeCloning: boolean;\n    _librariesLoaded: boolean;\n    _fillMode: string;\n    _resolutionMode: string;\n    _allowResize: boolean;\n    /**\n     * For backwards compatibility with scripts 1.0.\n     *\n     * @type {Application}\n     * @deprecated\n     * @ignore\n     */\n    context: Application;\n    /**\n     * The graphics device used by the application.\n     *\n     * @type {GraphicsDevice}\n     */\n    graphicsDevice: GraphicsDevice;\n    stats: ApplicationStats;\n    /**\n     * @type {SoundManager}\n     * @private\n     */\n    private _soundManager;\n    /**\n     * The resource loader.\n     *\n     * @type {ResourceLoader}\n     */\n    loader: ResourceLoader;\n    /**\n     * Stores all entities that have been created for this app by guid.\n     *\n     * @type {Object.<string, Entity>}\n     * @ignore\n     */\n    _entityIndex: {\n        [x: string]: Entity;\n    };\n    /**\n     * The scene managed by the application.\n     *\n     * @type {Scene}\n     * @example\n     * // Set the tone mapping property of the application\'s scene\n     * this.app.scene.toneMapping = pc.TONEMAP_FILMIC;\n     */\n    scene: Scene;\n    /**\n     * The root entity of the application.\n     *\n     * @type {Entity}\n     * @example\n     * // Return the first entity called \'Camera\' in a depth-first search of the scene hierarchy\n     * var camera = this.app.root.findByName(\'Camera\');\n     */\n    root: Entity;\n    /**\n     * The asset registry managed by the application.\n     *\n     * @type {AssetRegistry}\n     * @example\n     * // Search the asset registry for all assets with the tag \'vehicle\'\n     * var vehicleAssets = this.app.assets.findByTag(\'vehicle\');\n     */\n    assets: AssetRegistry;\n    /**\n     * @type {BundleRegistry}\n     * @ignore\n     */\n    bundles: BundleRegistry;\n    /**\n     * Set this to false if you want to run without using bundles. We set it to true only if\n     * TextDecoder is available because we currently rely on it for untarring.\n     *\n     * @type {boolean}\n     * @ignore\n     */\n    enableBundles: boolean;\n    scriptsOrder: string[];\n    /**\n     * The application\'s script registry.\n     *\n     * @type {ScriptRegistry}\n     */\n    scripts: ScriptRegistry;\n    /**\n     * Handles localization.\n     *\n     * @type {I18n}\n     */\n    i18n: I18n;\n    /**\n     * The scene registry managed by the application.\n     *\n     * @type {SceneRegistry}\n     * @example\n     * // Search the scene registry for a item with the name \'racetrack1\'\n     * var sceneItem = this.app.scenes.find(\'racetrack1\');\n     *\n     * // Load the scene using the item\'s url\n     * this.app.scenes.loadScene(sceneItem.url);\n     */\n    scenes: SceneRegistry;\n    defaultLayerWorld: Layer;\n    sceneDepth: SceneDepth;\n    defaultLayerDepth: Layer;\n    defaultLayerSkybox: Layer;\n    defaultLayerUi: Layer;\n    defaultLayerImmediate: Layer;\n    /**\n     * The forward renderer.\n     *\n     * @type {ForwardRenderer}\n     * @ignore\n     */\n    renderer: ForwardRenderer;\n    /**\n     * The run-time lightmapper.\n     *\n     * @type {Lightmapper}\n     */\n    lightmapper: Lightmapper;\n    /**\n     * The application\'s batch manager. The batch manager is used to merge mesh instances in\n     * the scene, which reduces the overall number of draw calls, thereby boosting performance.\n     *\n     * @type {BatchManager}\n     */\n    batcher: BatchManager;\n    /**\n     * The keyboard device.\n     *\n     * @type {Keyboard}\n     */\n    keyboard: Keyboard;\n    /**\n     * The mouse device.\n     *\n     * @type {Mouse}\n     */\n    mouse: Mouse;\n    /**\n     * Used to get touch events input.\n     *\n     * @type {TouchDevice}\n     */\n    touch: TouchDevice;\n    /**\n     * Used to access GamePad input.\n     *\n     * @type {GamePads}\n     */\n    gamepads: GamePads;\n    /**\n     * Used to handle input for {@link ElementComponent}s.\n     *\n     * @type {ElementInput}\n     */\n    elementInput: ElementInput;\n    /**\n     * @type {VrManager|null}\n     * @deprecated\n     * @ignore\n     */\n    vr: VrManager | null;\n    /**\n     * The XR Manager that provides ability to start VR/AR sessions.\n     *\n     * @type {XrManager}\n     * @example\n     * // check if VR is available\n     * if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n     *     // VR is available\n     * }\n     */\n    xr: XrManager;\n    /**\n     * @type {boolean}\n     * @ignore\n     */\n    _inTools: boolean;\n    /**\n     * @type {Asset|null}\n     * @private\n     */\n    private _skyboxAsset;\n    /**\n     * @type {string}\n     * @ignore\n     */\n    _scriptPrefix: string;\n    /**\n     * The application\'s component system registry. The Application constructor adds the\n     * following component systems to its component system registry:\n     *\n     * - anim ({@link AnimComponentSystem})\n     * - animation ({@link AnimationComponentSystem})\n     * - audiolistener ({@link AudioListenerComponentSystem})\n     * - button ({@link ButtonComponentSystem})\n     * - camera ({@link CameraComponentSystem})\n     * - collision ({@link CollisionComponentSystem})\n     * - element ({@link ElementComponentSystem})\n     * - layoutchild ({@link LayoutChildComponentSystem})\n     * - layoutgroup ({@link LayoutGroupComponentSystem})\n     * - light ({@link LightComponentSystem})\n     * - model ({@link ModelComponentSystem})\n     * - particlesystem ({@link ParticleSystemComponentSystem})\n     * - rigidbody ({@link RigidBodyComponentSystem})\n     * - render ({@link RenderComponentSystem})\n     * - screen ({@link ScreenComponentSystem})\n     * - script ({@link ScriptComponentSystem})\n     * - scrollbar ({@link ScrollbarComponentSystem})\n     * - scrollview ({@link ScrollViewComponentSystem})\n     * - sound ({@link SoundComponentSystem})\n     * - sprite ({@link SpriteComponentSystem})\n     *\n     * @type {ComponentSystemRegistry}\n     * @example\n     * // Set global gravity to zero\n     * this.app.systems.rigidbody.gravity.set(0, 0, 0);\n     * @example\n     * // Set the global sound volume to 50%\n     * this.app.systems.sound.volume = 0.5;\n     */\n    systems: ComponentSystemRegistry;\n    /** @private */\n    private _visibilityChangeHandler;\n    _hiddenAttr: string;\n    tick: Function;\n    /** @private */\n    private _initDefaultMaterial;\n    /**\n     * The current fill mode of the canvas. Can be:\n     *\n     * - {@link FILLMODE_NONE}: the canvas will always match the size provided.\n     * - {@link FILLMODE_FILL_WINDOW}: the canvas will simply fill the window, changing aspect ratio.\n     * - {@link FILLMODE_KEEP_ASPECT}: the canvas will grow to fill the window as best it can while\n     * maintaining the aspect ratio.\n     *\n     * @type {string}\n     */\n    get fillMode(): string;\n    /**\n     * The current resolution mode of the canvas, Can be:\n     *\n     * - {@link RESOLUTION_AUTO}: if width and height are not provided, canvas will be resized to\n     * match canvas client size.\n     * - {@link RESOLUTION_FIXED}: resolution of canvas will be fixed.\n     *\n     * @type {string}\n     */\n    get resolutionMode(): string;\n    /**\n     * Load the application configuration file and apply application properties and fill the asset\n     * registry.\n     *\n     * @param {string} url - The URL of the configuration file to load.\n     * @param {ConfigureAppCallback} callback - The Function called when the configuration file is\n     * loaded and parsed (or an error occurs).\n     */\n    configure(url: string, callback: ConfigureAppCallback): void;\n    /**\n     * Load all assets in the asset registry that are marked as \'preload\'.\n     *\n     * @param {PreloadAppCallback} callback - Function called when all assets are loaded.\n     */\n    preload(callback: PreloadAppCallback): void;\n    _preloadScripts(sceneData: any, callback: any): void;\n    _handleAreaLightDataProperty(prop: any): void;\n    _parseApplicationProperties(props: any, callback: any): void;\n    _width: any;\n    _height: any;\n    /**\n     * @param {string[]} urls - List of URLs to load.\n     * @param {Function} callback - Callback function.\n     * @private\n     */\n    private _loadLibraries;\n    /**\n     * Insert scene name/urls into the registry.\n     *\n     * @param {*} scenes - Scenes to add to the scene registry.\n     * @private\n     */\n    private _parseScenes;\n    /**\n     * Insert assets into registry.\n     *\n     * @param {*} assets - Assets to insert.\n     * @private\n     */\n    private _parseAssets;\n    /**\n     * @param {Scene} scene - The scene.\n     * @returns {Array} - The list of scripts that are referenced by the scene.\n     * @private\n     */\n    private _getScriptReferences;\n    /**\n     * Start the application. This function does the following:\n     *\n     * 1. Fires an event on the application named \'start\'\n     * 2. Calls initialize for all components on entities in the hierarchy\n     * 3. Fires an event on the application named \'initialize\'\n     * 4. Calls postInitialize for all components on entities in the hierarchy\n     * 5. Fires an event on the application named \'postinitialize\'\n     * 6. Starts executing the main loop of the application\n     *\n     * This function is called internally by PlayCanvas applications made in the Editor but you\n     * will need to call start yourself if you are using the engine stand-alone.\n     *\n     * @example\n     * app.start();\n     */\n    start(): void;\n    /**\n     * Update all input devices managed by the application.\n     *\n     * @param {number} dt - The time in seconds since the last update.\n     * @private\n     */\n    private inputUpdate;\n    /**\n     * Update the application. This function will call the update functions and then the postUpdate\n     * functions of all enabled components. It will then update the current state of all connected\n     * input devices. This function is called internally in the application\'s main loop and does\n     * not need to be called explicitly.\n     *\n     * @param {number} dt - The time delta in seconds since the last frame.\n     */\n    update(dt: number): void;\n    /**\n     * Render the application\'s scene. More specifically, the scene\'s {@link LayerComposition} is\n     * rendered by the application\'s {@link ForwardRenderer}. This function is called internally in\n     * the application\'s main loop and does not need to be called explicitly.\n     */\n    render(): void;\n    /**\n     * @param {number} now - The timestamp passed to the requestAnimationFrame callback.\n     * @param {number} dt - The time delta in seconds since the last frame. This is subject to the\n     * application\'s time scale and max delta values.\n     * @param {number} ms - The time in milliseconds since the last frame.\n     * @private\n     */\n    private _fillFrameStatsBasic;\n    /** @private */\n    private _fillFrameStats;\n    /**\n     * Controls how the canvas fills the window and resizes when the window changes.\n     *\n     * @param {string} mode - The mode to use when setting the size of the canvas. Can be:\n     *\n     * - {@link FILLMODE_NONE}: the canvas will always match the size provided.\n     * - {@link FILLMODE_FILL_WINDOW}: the canvas will simply fill the window, changing aspect ratio.\n     * - {@link FILLMODE_KEEP_ASPECT}: the canvas will grow to fill the window as best it can while\n     * maintaining the aspect ratio.\n     *\n     * @param {number} [width] - The width of the canvas (only used when mode is {@link FILLMODE_NONE}).\n     * @param {number} [height] - The height of the canvas (only used when mode is {@link FILLMODE_NONE}).\n     */\n    setCanvasFillMode(mode: string, width?: number, height?: number): void;\n    /**\n     * Change the resolution of the canvas, and set the way it behaves when the window is resized.\n     *\n     * @param {string} mode - The mode to use when setting the resolution. Can be:\n     *\n     * - {@link RESOLUTION_AUTO}: if width and height are not provided, canvas will be resized to\n     * match canvas client size.\n     * - {@link RESOLUTION_FIXED}: resolution of canvas will be fixed.\n     *\n     * @param {number} [width] - The horizontal resolution, optional in AUTO mode, if not provided\n     * canvas clientWidth is used.\n     * @param {number} [height] - The vertical resolution, optional in AUTO mode, if not provided\n     * canvas clientHeight is used.\n     */\n    setCanvasResolution(mode: string, width?: number, height?: number): void;\n    /**\n     * Queries the visibility of the window or tab in which the application is running.\n     *\n     * @returns {boolean} True if the application is not visible and false otherwise.\n     */\n    isHidden(): boolean;\n    /**\n     * Called when the visibility state of the current tab/window changes.\n     *\n     * @private\n     */\n    private onVisibilityChange;\n    /**\n     * Resize the application\'s canvas element in line with the current fill mode.\n     *\n     * - In {@link FILLMODE_KEEP_ASPECT} mode, the canvas will grow to fill the window as best it\n     * can while maintaining the aspect ratio.\n     * - In {@link FILLMODE_FILL_WINDOW} mode, the canvas will simply fill the window, changing\n     * aspect ratio.\n     * - In {@link FILLMODE_NONE} mode, the canvas will always match the size provided.\n     *\n     * @param {number} [width] - The width of the canvas. Only used if current fill mode is {@link FILLMODE_NONE}.\n     * @param {number} [height] - The height of the canvas. Only used if current fill mode is {@link FILLMODE_NONE}.\n     * @returns {object} A object containing the values calculated to use as width and height.\n     */\n    resizeCanvas(width?: number, height?: number): object;\n    /**\n     * Updates the {@link GraphicsDevice} canvas size to match the canvas size on the document\n     * page. It is recommended to call this function when the canvas size changes (e.g on window\n     * resize and orientation change events) so that the canvas resolution is immediately updated.\n     */\n    updateCanvasSize(): void;\n    /**\n     * Event handler called when all code libraries have been loaded. Code libraries are passed\n     * into the constructor of the Application and the application won\'t start running or load\n     * packs until all libraries have been loaded.\n     *\n     * @private\n     */\n    private onLibrariesLoaded;\n    /**\n     * Apply scene settings to the current scene. Useful when your scene settings are parsed or\n     * generated from a non-URL source.\n     *\n     * @param {object} settings - The scene settings to be applied.\n     * @param {object} settings.physics - The physics settings to be applied.\n     * @param {number[]} settings.physics.gravity - The world space vector representing global\n     * gravity in the physics simulation. Must be a fixed size array with three number elements,\n     * corresponding to each axis [ X, Y, Z ].\n     * @param {object} settings.render - The rendering settings to be applied.\n     * @param {number[]} settings.render.global_ambient - The color of the scene\'s ambient light.\n     * Must be a fixed size array with three number elements, corresponding to each color channel\n     * [ R, G, B ].\n     * @param {string} settings.render.fog - The type of fog used by the scene. Can be:\n     *\n     * - {@link FOG_NONE}\n     * - {@link FOG_LINEAR}\n     * - {@link FOG_EXP}\n     * - {@link FOG_EXP2}\n     *\n     * @param {number[]} settings.render.fog_color - The color of the fog (if enabled). Must be a\n     * fixed size array with three number elements, corresponding to each color channel [ R, G, B ].\n     * @param {number} settings.render.fog_density - The density of the fog (if enabled). This\n     * property is only valid if the fog property is set to {@link FOG_EXP} or {@link FOG_EXP2}.\n     * @param {number} settings.render.fog_start - The distance from the viewpoint where linear fog\n     * begins. This property is only valid if the fog property is set to {@link FOG_LINEAR}.\n     * @param {number} settings.render.fog_end - The distance from the viewpoint where linear fog\n     * reaches its maximum. This property is only valid if the fog property is set to {@link FOG_LINEAR}.\n     * @param {number} settings.render.gamma_correction - The gamma correction to apply when\n     * rendering the scene. Can be:\n     *\n     * - {@link GAMMA_NONE}\n     * - {@link GAMMA_SRGB}\n     *\n     * @param {number} settings.render.tonemapping - The tonemapping transform to apply when\n     * writing fragments to the frame buffer. Can be:\n     *\n     * - {@link TONEMAP_LINEAR}\n     * - {@link TONEMAP_FILMIC}\n     * - {@link TONEMAP_HEJL}\n     * - {@link TONEMAP_ACES}\n     *\n     * @param {number} settings.render.exposure - The exposure value tweaks the overall brightness\n     * of the scene.\n     * @param {number|null} [settings.render.skybox] - The asset ID of the cube map texture to be\n     * used as the scene\'s skybox. Defaults to null.\n     * @param {number} settings.render.skyboxIntensity - Multiplier for skybox intensity.\n     * @param {number} settings.render.skyboxMip - The mip level of the skybox to be displayed.\n     * Only valid for prefiltered cubemap skyboxes.\n     * @param {number[]} settings.render.skyboxRotation - Rotation of skybox.\n     * @param {number} settings.render.lightmapSizeMultiplier - The lightmap resolution multiplier.\n     * @param {number} settings.render.lightmapMaxResolution - The maximum lightmap resolution.\n     * @param {number} settings.render.lightmapMode - The lightmap baking mode. Can be:\n     *\n     * - {@link BAKE_COLOR}: single color lightmap\n     * - {@link BAKE_COLORDIR}: single color lightmap + dominant light direction (used for bump/specular)\n     *\n     * @param {boolean} settings.render.ambientBake - Enable baking ambient light into lightmaps.\n     * @param {number} settings.render.ambientBakeNumSamples - Number of samples to use when baking ambient light.\n     * @param {number} settings.render.ambientBakeSpherePart - How much of the sphere to include when baking ambient light.\n     * @param {number} settings.render.ambientBakeOcclusionBrightness - Brighness of the baked ambient occlusion.\n     * @param {number} settings.render.ambientBakeOcclusionContrast - Contrast of the baked ambient occlusion.\n     *\n     * Only lights with bakeDir=true will be used for generating the dominant light direction.\n     * @example\n     *\n     * var settings = {\n     *     physics: {\n     *         gravity: [0, -9.8, 0]\n     *     },\n     *     render: {\n     *         fog_end: 1000,\n     *         tonemapping: 0,\n     *         skybox: null,\n     *         fog_density: 0.01,\n     *         gamma_correction: 1,\n     *         exposure: 1,\n     *         fog_start: 1,\n     *         global_ambient: [0, 0, 0],\n     *         skyboxIntensity: 1,\n     *         skyboxRotation: [0, 0, 0],\n     *         fog_color: [0, 0, 0],\n     *         lightmapMode: 1,\n     *         fog: \'none\',\n     *         lightmapMaxResolution: 2048,\n     *         skyboxMip: 2,\n     *         lightmapSizeMultiplier: 16\n     *     }\n     * };\n     * app.applySceneSettings(settings);\n     */\n    applySceneSettings(settings: {\n        physics: {\n            gravity: number[];\n        };\n        render: {\n            global_ambient: number[];\n            fog: string;\n            fog_color: number[];\n            fog_density: number;\n            fog_start: number;\n            fog_end: number;\n            gamma_correction: number;\n            tonemapping: number;\n            exposure: number;\n            skybox?: number | null;\n            skyboxIntensity: number;\n            skyboxMip: number;\n            skyboxRotation: number[];\n            lightmapSizeMultiplier: number;\n            lightmapMaxResolution: number;\n            lightmapMode: number;\n            ambientBake: boolean;\n            ambientBakeNumSamples: number;\n            ambientBakeSpherePart: number;\n            ambientBakeOcclusionBrightness: number;\n            ambientBakeOcclusionContrast: number;\n        };\n    }): void;\n    /**\n     * Sets the area light LUT asset for this app.\n     *\n     * @param {Asset} asset - LUT asset of type `binary` to be set.\n     */\n    setAreaLightLuts(asset: Asset): void;\n    /**\n     * Sets the skybox asset to current scene, and subscribes to asset load/change events.\n     *\n     * @param {Asset} asset - Asset of type `skybox` to be set to, or null to remove skybox.\n     */\n    setSkybox(asset: Asset): void;\n    /**\n     * Create and assign a {@link VrManager} object to allow this application render in VR.\n     *\n     * @ignore\n     * @deprecated\n     */\n    enableVr(): void;\n    /**\n     * Destroy the {@link VrManager}.\n     *\n     * @ignore\n     * @deprecated\n     */\n    disableVr(): void;\n    /** @private */\n    private _firstBake;\n    /** @private */\n    private _firstBatch;\n    /**\n     * Provide an opportunity to modify the timestamp supplied by requestAnimationFrame.\n     *\n     * @param {number} timestamp - The timestamp supplied by requestAnimationFrame.\n     * @returns {number} The modified timestamp.\n     * @ignore\n     */\n    _processTimestamp(timestamp: number): number;\n    /**\n     * Draws a single line. Line start and end coordinates are specified in world-space. The line\n     * will be flat-shaded with the specified color.\n     *\n     * @param {Vec3} start - The start world-space coordinate of the line.\n     * @param {Vec3} end - The end world-space coordinate of the line.\n     * @param {Color} [color] - The color of the line. It defaults to white if not specified.\n     * @param {boolean} [depthTest] - Specifies if the line is depth tested against the depth\n     * buffer. Defaults to true.\n     * @param {Layer} [layer] - The layer to render the line into. Defaults to {@link LAYERID_IMMEDIATE}.\n     * @example\n     * // Render a 1-unit long white line\n     * var start = new pc.Vec3(0, 0, 0);\n     * var end = new pc.Vec3(1, 0, 0);\n     * app.drawLine(start, end);\n     * @example\n     * // Render a 1-unit long red line which is not depth tested and renders on top of other geometry\n     * var start = new pc.Vec3(0, 0, 0);\n     * var end = new pc.Vec3(1, 0, 0);\n     * app.drawLine(start, end, pc.Color.RED, false);\n     * @example\n     * // Render a 1-unit long white line into the world layer\n     * var start = new pc.Vec3(0, 0, 0);\n     * var end = new pc.Vec3(1, 0, 0);\n     * var worldLayer = app.scene.layers.getLayerById(pc.LAYERID_WORLD);\n     * app.drawLine(start, end, pc.Color.WHITE, true, worldLayer);\n     */\n    drawLine(start: Vec3, end: Vec3, color?: Color, depthTest?: boolean, layer?: Layer): void;\n    /**\n     * Renders an arbitrary number of discrete line segments. The lines are not connected by each\n     * subsequent point in the array. Instead, they are individual segments specified by two\n     * points. Therefore, the lengths of the supplied position and color arrays must be the same\n     * and also must be a multiple of 2. The colors of the ends of each line segment will be\n     * interpolated along the length of each line.\n     *\n     * @param {Vec3[]} positions - An array of points to draw lines between. The length of the\n     * array must be a multiple of 2.\n     * @param {Color[]} colors - An array of colors to color the lines. This must be the same\n     * length as the position array. The length of the array must also be a multiple of 2.\n     * @param {boolean} [depthTest] - Specifies if the lines are depth tested against the depth\n     * buffer. Defaults to true.\n     * @param {Layer} [layer] - The layer to render the lines into. Defaults to {@link LAYERID_IMMEDIATE}.\n     * @example\n     * // Render a single line, with unique colors for each point\n     * var start = new pc.Vec3(0, 0, 0);\n     * var end = new pc.Vec3(1, 0, 0);\n     * app.drawLines([start, end], [pc.Color.RED, pc.Color.WHITE]);\n     * @example\n     * // Render 2 discrete line segments\n     * var points = [\n     *     // Line 1\n     *     new pc.Vec3(0, 0, 0),\n     *     new pc.Vec3(1, 0, 0),\n     *     // Line 2\n     *     new pc.Vec3(1, 1, 0),\n     *     new pc.Vec3(1, 1, 1)\n     * ];\n     * var colors = [\n     *     // Line 1\n     *     pc.Color.RED,\n     *     pc.Color.YELLOW,\n     *     // Line 2\n     *     pc.Color.CYAN,\n     *     pc.Color.BLUE\n     * ];\n     * app.drawLines(points, colors);\n     */\n    drawLines(positions: Vec3[], colors: Color[], depthTest?: boolean, layer?: Layer): void;\n    /**\n     * Renders an arbitrary number of discrete line segments. The lines are not connected by each\n     * subsequent point in the array. Instead, they are individual segments specified by two\n     * points.\n     *\n     * @param {number[]} positions - An array of points to draw lines between. Each point is\n     * represented by 3 numbers - x, y and z coordinate.\n     * @param {number[]} colors - An array of colors to color the lines. This must be the same\n     * length as the position array. The length of the array must also be a multiple of 2.\n     * @param {boolean} [depthTest] - Specifies if the lines are depth tested against the depth\n     * buffer. Defaults to true.\n     * @param {Layer} [layer] - The layer to render the lines into. Defaults to {@link LAYERID_IMMEDIATE}.\n     * @example\n     * // Render 2 discrete line segments\n     * var points = [\n     *     // Line 1\n     *     0, 0, 0,\n     *     1, 0, 0,\n     *     // Line 2\n     *     1, 1, 0,\n     *     1, 1, 1\n     * ];\n     * var colors = [\n     *     // Line 1\n     *     1, 0, 0, 1,  // red\n     *     0, 1, 0, 1,  // green\n     *     // Line 2\n     *     0, 0, 1, 1,  // blue\n     *     1, 1, 1, 1   // white\n     * ];\n     * app.drawLineArrays(points, colors);\n     */\n    drawLineArrays(positions: number[], colors: number[], depthTest?: boolean, layer?: Layer): void;\n    /**\n     * Draws a wireframe sphere with center, radius and color.\n     *\n     * @param {Vec3} center - The center of the sphere.\n     * @param {number} radius - The radius of the sphere.\n     * @param {Color} [color] - The color of the sphere. It defaults to white if not specified.\n     * @param {number} [segments] - Number of line segments used to render the circles forming the\n     * sphere. Defaults to 20.\n     * @param {boolean} [depthTest] - Specifies if the sphere lines are depth tested against the\n     * depth buffer. Defaults to true.\n     * @param {Layer} [layer] - The layer to render the sphere into. Defaults to {@link LAYERID_IMMEDIATE}.\n     * @example\n     * // Render a red wire sphere with radius of 1\n     * var center = new pc.Vec3(0, 0, 0);\n     * app.drawWireSphere(center, 1.0, pc.Color.RED);\n     * @ignore\n     */\n    drawWireSphere(center: Vec3, radius: number, color?: Color, segments?: number, depthTest?: boolean, layer?: Layer): void;\n    /**\n     * Draws a wireframe axis aligned box specified by min and max points and color.\n     *\n     * @param {Vec3} minPoint - The min corner point of the box.\n     * @param {Vec3} maxPoint - The max corner point of the box.\n     * @param {Color} [color] - The color of the sphere. It defaults to white if not specified.\n     * @param {boolean} [depthTest] - Specifies if the sphere lines are depth tested against the\n     * depth buffer. Defaults to true.\n     * @param {Layer} [layer] - The layer to render the sphere into. Defaults to {@link LAYERID_IMMEDIATE}.\n     * @example\n     * // Render a red wire aligned box\n     * var min = new pc.Vec3(-1, -1, -1);\n     * var max = new pc.Vec3(1, 1, 1);\n     * app.drawWireAlignedBox(min, max, pc.Color.RED);\n     * @ignore\n     */\n    drawWireAlignedBox(minPoint: Vec3, maxPoint: Vec3, color?: Color, depthTest?: boolean, layer?: Layer): void;\n    /**\n     * Draw meshInstance at this frame\n     *\n     * @param {MeshInstance} meshInstance - The mesh instance to draw.\n     * @param {Layer} [layer] - The layer to render the mesh instance into. Defaults to\n     * {@link LAYERID_IMMEDIATE}.\n     * @ignore\n     */\n    drawMeshInstance(meshInstance: MeshInstance, layer?: Layer): void;\n    /**\n     * Draw mesh at this frame.\n     *\n     * @param {Mesh} mesh - The mesh to draw.\n     * @param {Material} material - The material to use to render the mesh.\n     * @param {Mat4} matrix - The matrix to use to render the mesh.\n     * @param {Layer} [layer] - The layer to render the mesh into. Defaults to {@link LAYERID_IMMEDIATE}.\n     * @ignore\n     */\n    drawMesh(mesh: Mesh, material: Material, matrix: Mat4, layer?: Layer): void;\n    /**\n     * Draw quad of size [-0.5, 0.5] at this frame.\n     *\n     * @param {Mat4} matrix - The matrix to use to render the quad.\n     * @param {Material} material - The material to use to render the quad.\n     * @param {Layer} [layer] - The layer to render the quad into. Defaults to {@link LAYERID_IMMEDIATE}.\n     * @ignore\n     */\n    drawQuad(matrix: Mat4, material: Material, layer?: Layer): void;\n    /**\n     * Draws a texture at [x, y] position on screen, with size [width, height]. The origin of the\n     * screen is top-left [0, 0]. Coordinates and sizes are in projected space (-1 .. 1).\n     *\n     * @param {number} x - The x coordinate on the screen of the top left corner of the texture.\n     * Should be in the range [-1, 1].\n     * @param {number} y - The y coordinate on the screen of the top left corner of the texture.\n     * Should be in the range [-1, 1].\n     * @param {number} width - The width of the rectangle of the rendered texture. Should be in the\n     * range [0, 2].\n     * @param {number} height - The height of the rectangle of the rendered texture. Should be in\n     * the range [0, 2].\n     * @param {Texture} texture - The texture to render.\n     * @param {Material} material - The material used when rendering the texture.\n     * @param {Layer} [layer] - The layer to render the texture into. Defaults to {@link LAYERID_IMMEDIATE}.\n     * @ignore\n     */\n    drawTexture(x: number, y: number, width: number, height: number, texture: Texture, material: Material, layer?: Layer): void;\n    /**\n     * Draws a depth texture at [x, y] position on screen, with size [width, height]. The origin of\n     * the screen is top-left [0, 0]. Coordinates and sizes are in projected space (-1 .. 1).\n     *\n     * @param {number} x - The x coordinate on the screen of the top left corner of the texture.\n     * Should be in the range [-1, 1].\n     * @param {number} y - The y coordinate on the screen of the top left corner of the texture.\n     * Should be in the range [-1, 1].\n     * @param {number} width - The width of the rectangle of the rendered texture. Should be in the\n     * range [0, 2].\n     * @param {number} height - The height of the rectangle of the rendered texture. Should be in\n     * the range [0, 2].\n     * @param {Layer} [layer] - The layer to render the texture into. Defaults to {@link LAYERID_IMMEDIATE}.\n     * @ignore\n     */\n    drawDepthTexture(x: number, y: number, width: number, height: number, layer?: Layer): void;\n    /**\n     * Destroys application and removes all event listeners at the end of the current engine frame\n     * update. However, if called outside of the engine frame update, calling destroy() will\n     * destroy the application immediately.\n     *\n     * @example\n     * app.destroy();\n     */\n    destroy(): void;\n    controller: any;\n    /**\n     * Get entity from the index by guid.\n     *\n     * @param {string} guid - The GUID to search for.\n     * @returns {Entity} The Entity with the GUID or null.\n     * @ignore\n     */\n    getEntityFromIndex(guid: string): Entity;\n    /**\n     * @param {Scene} scene - The scene.\n     * @private\n     */\n    private _registerSceneImmediate;\n}\n\ndeclare class CameraComponentData {\n    enabled: boolean;\n}\n\n/**\n * Used to add and remove {@link CameraComponent}s from Entities. It also holds an array of all\n * active cameras.\n *\n * @augments ComponentSystem\n */\ndeclare class CameraComponentSystem extends ComponentSystem {\n    /**\n     * Holds all the active camera components.\n     *\n     * @type {CameraComponent[]}\n     */\n    cameras: CameraComponent[];\n    id: string;\n    ComponentType: typeof CameraComponent;\n    DataType: typeof CameraComponentData;\n    schema: string[];\n    initializeComponentData(component: any, data: any, properties: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    onBeforeRemove(entity: any, component: any): void;\n    onUpdate(dt: any): void;\n    onAppPrerender(): void;\n    addCamera(camera: any): void;\n    removeCamera(camera: any): void;\n}\n\n\n\n\n\n\n\n\n\n/**\n * Callback used by {@link CameraComponentcalculateTransform } and {@link CameraComponentcalculateProjection }.\n */\nexport type CalculateMatrixCallback = (transformMatrix: Mat4, view: number) => any;\n/**\n * Callback used by {@link CameraComponent#calculateTransform} and {@link CameraComponent#calculateProjection}.\n *\n * @callback CalculateMatrixCallback\n * @param {Mat4} transformMatrix - Output of the function.\n * @param {number} view - Type of view. Can be {@link VIEW_CENTER}, {@link VIEW_LEFT} or {@link VIEW_RIGHT}. Left and right are only used in stereo rendering.\n */\n/**\n * Callback used by {@link CameraComponent#enterVr} and {@link CameraComponent#exitVr}.\n *\n * @callback VrCameraCallback\n * @param {string|null} err - On success it is null on failure it is the error message.\n */\n/**\n * The Camera Component enables an Entity to render the scene. A scene requires at least one\n * enabled camera component to be rendered. Note that multiple camera components can be enabled\n * simultaneously (for split-screen or offscreen rendering, for example).\n *\n * ```javascript\n * // Add a pc.CameraComponent to an entity\n * var entity = new pc.Entity();\n * entity.addComponent(\'camera\', {\n *     nearClip: 1,\n *     farClip: 100,\n *     fov: 55\n * });\n *\n * // Get the pc.CameraComponent on an entity\n * var cameraComponent = entity.camera;\n *\n * // Update a property on a camera component\n * entity.camera.nearClip = 2;\n * ```\n *\n * @property {number} projection The type of projection used to render the camera. Can be:\n *\n * - {@link PROJECTION_PERSPECTIVE}: A perspective projection. The camera frustum\n * resembles a truncated pyramid.\n * - {@link PROJECTION_ORTHOGRAPHIC}: An orthographic projection. The camera\n * frustum is a cuboid.\n *\n * Defaults to {@link PROJECTION_PERSPECTIVE}.\n * @property {number} aspectRatio The aspect ratio (width divided by height) of the camera. If\n * aspectRatioMode is {@link ASPECT_AUTO}, then this value will be automatically calculated every\n * frame, and you can only read it. If it\'s ASPECT_MANUAL, you can set the value.\n * @property {number} aspectRatioMode The aspect ratio mode of the camera. Can be:\n *\n * - {@link ASPECT_AUTO}: aspect ratio will be calculated from the current render\n * target\'s width divided by height.\n * - {@link ASPECT_MANUAL}: use the aspectRatio value.\n *\n * Defaults to {@link ASPECT_AUTO}.\n * @property {Color} clearColor The color used to clear the canvas to before the camera starts to\n * render. Defaults to [0.75, 0.75, 0.75, 1].\n * @property {number} farClip The distance from the camera after which no rendering will take\n * place. Defaults to 1000.\n * @property {number} fov The field of view of the camera in degrees. Usually this is the Y-axis\n * field of view, see {@link CameraComponent#horizontalFov}. Used for\n * {@link PROJECTION_PERSPECTIVE} cameras only. Defaults to 45.\n * @property {boolean} horizontalFov Set which axis to use for the Field of View calculation.\n * Defaults to false.\n * @property {number} nearClip The distance from the camera before which no rendering will take\n * place. Defaults to 0.1.\n * @property {number} orthoHeight The half-height of the orthographic view window (in the Y-axis).\n * Used for {@link PROJECTION_ORTHOGRAPHIC} cameras only. Defaults to 10.\n * @property {Vec4} scissorRect Clips all pixels which are not in the rectangle. The order of the\n * values is [x, y, width, height]. Defaults to [0, 0, 1, 1].\n * @property {boolean} frustumCulling Controls the culling of mesh instances against the camera\n * frustum, i.e. if objects outside of camera should be omitted from rendering. If false, all mesh\n * instances in the scene are rendered by the camera, regardless of visibility. Defaults to false.\n * @property {CalculateMatrixCallback} calculateTransform Custom function you can provide to\n * calculate the camera transformation matrix manually. Can be used for complex effects like\n * reflections. Function is called using component\'s scope. Arguments:\n *\n * - {@link Mat4} transformMatrix: output of the function.\n * - view: Type of view. Can be {@link VIEW_CENTER}, {@link VIEW_LEFT} or {@link VIEW_RIGHT}.\n *\n * Left and right are only used in stereo rendering.\n * @property {CalculateMatrixCallback} calculateProjection Custom function you can provide to\n * calculate the camera projection matrix manually. Can be used for complex effects like doing\n * oblique projection. Function is called using component\'s scope. Arguments:\n *\n * - {@link Mat4} transformMatrix: output of the function\n * - view: Type of view. Can be {@link VIEW_CENTER}, {@link VIEW_LEFT} or {@link VIEW_RIGHT}.\n *\n * Left and right are only used in stereo rendering.\n * @property {boolean} cullFaces If true the camera will take material.cull into account. Otherwise\n * both front and back faces will be rendered. Defaults to true.\n * @property {boolean} flipFaces If true the camera will invert front and back faces. Can be useful\n * for reflection rendering. Defaults to false.\n * @augments Component\n */\ndeclare class CameraComponent extends Component {\n    /**\n     * Create a new CameraComponent instance.\n     *\n     * @param {CameraComponentSystem} system - The ComponentSystem that created this Component.\n     * @param {Entity} entity - The Entity that this Component is attached to.\n     */\n    constructor(system: CameraComponentSystem, entity: Entity);\n\n    set aspectRatioMode(arg: number);\n    get aspectRatioMode(): number;\n\n    set calculateProjection(arg: CalculateMatrixCallback);\n    get calculateProjection(): CalculateMatrixCallback;\n\n    set calculateTransform(arg: CalculateMatrixCallback);\n    get calculateTransform(): CalculateMatrixCallback;\n\n    set clearColor(arg: Color);\n    get clearColor(): Color;\n\n    set cullFaces(arg: boolean);\n    get cullFaces(): boolean;\n\n    set farClip(arg: number);\n    get farClip(): number;\n\n    set flipFaces(arg: boolean);\n    get flipFaces(): boolean;\n\n    set fov(arg: number);\n    get fov(): number;\n\n    set frustumCulling(arg: boolean);\n    get frustumCulling(): boolean;\n\n    set horizontalFov(arg: boolean);\n    get horizontalFov(): boolean;\n\n    set nearClip(arg: number);\n    get nearClip(): number;\n\n    set orthoHeight(arg: number);\n    get orthoHeight(): number;\n\n    set projection(arg: number);\n    get projection(): number;\n\n    set scissorRect(arg: Vec4);\n    get scissorRect(): Vec4;\n\n    /**\n     * Custom function that is called when postprocessing should execute.\n     *\n     * @type {Function}\n     * @private\n     */\n    private onPostprocessing;\n    /**\n     * Custom function that is called before the camera renders the scene.\n     *\n     * @type {Function}\n     */\n    onPreRender: Function;\n    /**\n     * Custom function that is called after the camera renders the scene.\n     *\n     * @type {Function}\n     */\n    onPostRender: Function;\n    _camera: Camera;\n    _priority: number;\n    _disablePostEffectsLayer: number;\n    _postEffects: PostEffectQueue;\n    /**\n     * Queries the camera component\'s underlying Camera instance.\n     *\n     * @type {Camera}\n     * @private\n     */\n    private get camera();\n    /**\n     * If true the camera will clear the color buffer to the color set in clearColor. Defaults to true.\n     *\n     * @type {boolean}\n     */\n    set clearColorBuffer(arg: boolean);\n    get clearColorBuffer(): boolean;\n    /**\n     * If true the camera will clear the depth buffer. Defaults to true.\n     *\n     * @type {boolean}\n     */\n    set clearDepthBuffer(arg: boolean);\n    get clearDepthBuffer(): boolean;\n    /**\n     * If true the camera will clear the stencil buffer. Defaults to true.\n     *\n     * @type {boolean}\n     */\n    set clearStencilBuffer(arg: boolean);\n    get clearStencilBuffer(): boolean;\n    /**\n     * Layer ID of a layer on which the postprocessing of the camera stops being applied to.\n     * Defaults to LAYERID_UI, which causes post processing to not be applied to UI layer and any\n     * following layers for the camera. Set to undefined for post-processing to be applied to all\n     * layers of the camera.\n     *\n     * @type {number}\n     */\n    set disablePostEffectsLayer(arg: number);\n    get disablePostEffectsLayer(): number;\n    /**\n     * Queries the camera\'s frustum shape.\n     *\n     * @type {Frustum}\n     */\n    get frustum(): Frustum;\n    /**\n     * An array of layer IDs ({@link Layer#id}) to which this camera should belong. Don\'t push,\n     * pop, splice or modify this array, if you want to change it, set a new one instead. Defaults\n     * to [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE].\n     *\n     * @type {number[]}\n     */\n    set layers(arg: number[]);\n    get layers(): number[];\n    /**\n     * The post effects queue for this camera. Use this to add or remove post effects from the camera.\n     *\n     * @type {PostEffectQueue}\n     */\n    get postEffectsEnabled(): PostEffectQueue;\n    get postEffects(): PostEffectQueue;\n    /**\n     * Controls the order in which cameras are rendered. Cameras with smaller values for priority\n     * are rendered first. Defaults to 0.\n     *\n     * @type {number}\n     */\n    set priority(arg: number);\n    get priority(): number;\n    /**\n     * Queries the camera\'s projection matrix.\n     *\n     * @type {Mat4}\n     */\n    get projectionMatrix(): Mat4;\n    /**\n     * Controls where on the screen the camera will be rendered in normalized screen coordinates.\n     * Defaults to [0, 0, 1, 1].\n     *\n     * @type {Vec4}\n     */\n    set rect(arg: Vec4);\n    get rect(): Vec4;\n    /**\n     * Render target to which rendering of the cameras is performed. If not set, it will render\n     * simply to the screen.\n     *\n     * @type {RenderTarget}\n     */\n    set renderTarget(arg: any);\n    get renderTarget(): any;\n    /**\n     * Queries the camera\'s view matrix.\n     *\n     * @type {Mat4}\n     */\n    get viewMatrix(): Mat4;\n    dirtyLayerCompositionCameras(): void;\n    /**\n     * Convert a point from 2D screen space to 3D world space.\n     *\n     * @param {number} screenx - X coordinate on PlayCanvas\' canvas element. Should be in the range\n     * 0 to `canvas.offsetWidth` of the application\'s canvas element.\n     * @param {number} screeny - Y coordinate on PlayCanvas\' canvas element. Should be in the range\n     * 0 to `canvas.offsetHeight` of the application\'s canvas element.\n     * @param {number} cameraz - The distance from the camera in world space to create the new\n     * point.\n     * @param {Vec3} [worldCoord] - 3D vector to receive world coordinate result.\n     * @example\n     * // Get the start and end points of a 3D ray fired from a screen click position\n     * var start = entity.camera.screenToWorld(clickX, clickY, entity.camera.nearClip);\n     * var end = entity.camera.screenToWorld(clickX, clickY, entity.camera.farClip);\n     *\n     * // Use the ray coordinates to perform a raycast\n     * app.systems.rigidbody.raycastFirst(start, end, function (result) {\n     *     console.log("Entity " + result.entity.name + " was selected");\n     * });\n     * @returns {Vec3} The world space coordinate.\n     */\n    screenToWorld(screenx: number, screeny: number, cameraz: number, worldCoord?: Vec3): Vec3;\n    /**\n     * Convert a point from 3D world space to 2D screen space.\n     *\n     * @param {Vec3} worldCoord - The world space coordinate.\n     * @param {Vec3} [screenCoord] - 3D vector to receive screen coordinate result.\n     * @returns {Vec3} The screen space coordinate.\n     */\n    worldToScreen(worldCoord: Vec3, screenCoord?: Vec3): Vec3;\n    onAppPrerender(): void;\n    addCameraToLayers(): void;\n    removeCameraFromLayers(): void;\n    onLayersChanged(oldComp: any, newComp: any): void;\n    onLayerAdded(layer: any): void;\n    onLayerRemoved(layer: any): void;\n    onRemove(): void;\n    /**\n     * Calculates aspect ratio value for a given render target.\n     *\n     * @param {RenderTarget} [rt] - Optional render target. If unspecified, the backbuffer is used.\n     * @returns {number} The aspect ratio of the render target (or backbuffer).\n     */\n    calculateAspectRatio(rt?: RenderTarget): number;\n    /**\n     * Start rendering the frame for this camera.\n     *\n     * @param {RenderTarget} rt - Render target to which rendering will be performed. Will affect\n     * camera\'s aspect ratio, if aspectRatioMode is {@link ASPECT_AUTO}.\n     * @private\n     */\n    private frameBegin;\n    aspectRatio: number;\n    /**\n     * End rendering the frame for this camera.\n     *\n     * @private\n     */\n    private frameEnd;\n    /**\n     * @private\n     * @deprecated\n     * @function\n     * @name CameraComponent#enterVr\n     * @description Attempt to start presenting this camera to a {@link VrDisplay}.\n     * @param {VrCameraCallback} callback - Function called once to indicate success\n     * of failure. The callback takes one argument (err).\n     * On success it returns null on failure it returns the error message.\n     * @example\n     * // On an entity with a camera component\n     * this.entity.camera.enterVr(function (err) {\n     *     if (err) {\n     *         console.error(err);\n     *     } else {\n     *         // in VR!\n     *     }\n     * });\n     */\n    /**\n     * @private\n     * @deprecated\n     * @function\n     * @name CameraComponent#enterVr\n     * @variation 2\n     * @description Attempt to start presenting this camera to a {@link VrDisplay}.\n     * @param {VrDisplay} display - The VrDisplay to present. If not supplied this uses\n     * {@link VrManager#display} as the default.\n     * @param {VrCameraCallback} callback - Function called once to indicate success\n     * of failure. The callback takes one argument (err). On success it returns null on\n     * failure it returns the error message.\n     * @example\n     * // On an entity with a camera component\n     * this.entity.camera.enterVr(function (err) {\n     *     if (err) {\n     *         console.error(err);\n     *     } else {\n     *         // in VR!\n     *     }\n     * });\n     */\n    private enterVr;\n    /**\n     * Attempt to stop presenting this camera.\n     *\n     * @param {VrCameraCallback} callback - Function called once to indicate success of failure.\n     * The callback takes one argument (err). On success it returns null on failure it returns the\n     * error message.\n     * @example\n     * this.entity.camera.exitVr(function (err) {\n     *     if (err) {\n     *         console.error(err);\n     *     } else {\n     *         // exited successfully\n     *     }\n     * });\n     * @private\n     * @deprecated\n     */\n    private exitVr;\n    vrDisplay: any;\n    /**\n     * Attempt to start XR session with this camera.\n     *\n     * @param {string} type - The type of session. Can be one of the following:\n     *\n     * - {@link XRTYPE_INLINE}: Inline - always available type of session. It has limited feature\n     * availability and is rendered into HTML element.\n     * - {@link XRTYPE_VR}: Immersive VR - session that provides exclusive access to the VR device\n     * with the best available tracking features.\n     * - {@link XRTYPE_AR}: Immersive AR - session that provides exclusive access to the VR/AR\n     * device that is intended to be blended with the real-world environment.\n     *\n     * @param {string} spaceType - Reference space type. Can be one of the following:\n     *\n     * - {@link XRSPACE_VIEWER}: Viewer - always supported space with some basic tracking\n     * capabilities.\n     * - {@link XRSPACE_LOCAL}: Local - represents a tracking space with a native origin near the\n     * viewer at the time of creation. It is meant for seated or basic local XR sessions.\n     * - {@link XRSPACE_LOCALFLOOR}: Local Floor - represents a tracking space with a native origin\n     * at the floor in a safe position for the user to stand. The y-axis equals 0 at floor level.\n     * Floor level value might be estimated by the underlying platform. It is meant for seated or\n     * basic local XR sessions.\n     * - {@link XRSPACE_BOUNDEDFLOOR}: Bounded Floor - represents a tracking space with its native\n     * origin at the floor, where the user is expected to move within a pre-established boundary.\n     * - {@link XRSPACE_UNBOUNDED}: Unbounded - represents a tracking space where the user is\n     * expected to move freely around their environment, potentially long distances from their\n     * starting point.\n     *\n     * @param {object} [options] - Object with options for XR session initialization.\n     * @param {string[]} [options.optionalFeatures] - Optional features for XRSession start. It is\n     * used for getting access to additional WebXR spec extensions.\n     * @param {boolean} [options.imageTracking] - Set to true to attempt to enable {@link XrImageTracking}.\n     * @param {boolean} [options.planeDetection] - Set to true to attempt to enable {@link XrPlaneDetection}.\n     * @param {XrErrorCallback} [options.callback] - Optional callback function called once the\n     * session is started. The callback has one argument Error - it is null if the XR session\n     * started successfully.\n     * @param {object} [options.depthSensing] - Optional object with depth sensing parameters to\n     * attempt to enable {@link XrDepthSensing}.\n     * @param {string} [options.depthSensing.usagePreference] - Optional usage preference for depth\n     * sensing, can be \'cpu-optimized\' or \'gpu-optimized\' (XRDEPTHSENSINGUSAGE_*), defaults to\n     * \'cpu-optimized\'. Most preferred and supported will be chosen by the underlying depth sensing\n     * system.\n     * @param {string} [options.depthSensing.dataFormatPreference] - Optional data format\n     * preference for depth sensing. Can be \'luminance-alpha\' or \'float32\' (XRDEPTHSENSINGFORMAT_*),\n     * defaults to \'luminance-alpha\'. Most preferred and supported will be chosen by the underlying\n     * depth sensing system.\n     * @example\n     * // On an entity with a camera component\n     * this.entity.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n     *     callback: function (err) {\n     *         if (err) {\n     *             // failed to start XR session\n     *         } else {\n     *             // in XR\n     *         }\n     *     }\n     * });\n     */\n    startXr(type: string, spaceType: string, options?: {\n        optionalFeatures?: string[];\n        imageTracking?: boolean;\n        planeDetection?: boolean;\n        callback?: XrErrorCallback;\n        depthSensing?: {\n            usagePreference?: string;\n            dataFormatPreference?: string;\n        };\n    }): void;\n    /**\n     * Attempt to end XR session of this camera.\n     *\n     * @param {XrErrorCallback} [callback] - Optional callback function called once session is\n     * ended. The callback has one argument Error - it is null if successfully ended XR session.\n     * @example\n     * // On an entity with a camera component\n     * this.entity.camera.endXr(function (err) {\n     *     // not anymore in XR\n     * });\n     */\n    endXr(callback?: XrErrorCallback): void;\n    copy(source: any): void;\n}\n\n\n\n/**\n * Used to manage multiple post effects for a camera.\n */\ndeclare class PostEffectQueue {\n    /**\n     * Create a new PostEffectQueue instance.\n     *\n     * @param {Application} app - The application.\n     * @param {CameraComponent} camera - The camera component.\n     */\n    constructor(app: Application, camera: CameraComponent);\n    app: Application;\n    camera: CameraComponent;\n    /**\n     * Render target where the postprocessed image needs to be rendered to. Defaults to null\n     * which is main framebuffer.\n     *\n     * @type {RenderTarget}\n     * @ignore\n     */\n    destinationRenderTarget: RenderTarget;\n    /**\n     * All of the post effects in the queue.\n     *\n     * @type {PostEffect[]}\n     * @ignore\n     */\n    effects: PostEffect[];\n    /**\n     * If the queue is enabled it will render all of its effects, otherwise it will not render\n     * anything.\n     *\n     * @type {boolean}\n     * @ignore\n     */\n    enabled: boolean;\n    depthTarget: any;\n    renderTargetScale: number;\n    /**\n     * @type {number|null}\n     * @private\n     */\n    private resizeTimeout;\n    /**\n     * The time in milliseconds since the last resize.\n     *\n     * @type {number}\n     * @private\n     */\n    private resizeLast;\n    _resizeTimeoutCallback: () => void;\n    /**\n     * Allocate a color buffer texture.\n     *\n     * @param {number} format - The format of the color buffer.\n     * @param {string} name - The name of the color buffer.\n     * @returns {Texture} The color buffer texture.\n     * @private\n     */\n    private _allocateColorBuffer;\n    /**\n     * Creates a render target with the dimensions of the canvas, with an optional depth buffer.\n     *\n     * @param {boolean} useDepth - Set to true to create a render target with a depth buffer.\n     * @param {boolean} hdr - Use HDR render target format.\n     * @returns {RenderTarget} The render target.\n     * @private\n     */\n    private _createOffscreenTarget;\n    _resizeOffscreenTarget(rt: any): void;\n    _destroyOffscreenTarget(rt: any): void;\n    setRenderTargetScale(scale: any): void;\n    /**\n     * Adds a post effect to the queue. If the queue is disabled adding a post effect will\n     * automatically enable the queue.\n     *\n     * @param {PostEffect} effect - The post effect to add to the queue.\n     */\n    addEffect(effect: PostEffect): void;\n    _sourceTarget: any;\n    _newPostEffect: PostEffect;\n    /**\n     * Removes a post effect from the queue. If the queue becomes empty it will be disabled\n     * automatically.\n     *\n     * @param {PostEffect} effect - The post effect to remove.\n     */\n    removeEffect(effect: PostEffect): void;\n    _requestDepthMaps(): void;\n    _releaseDepthMaps(): void;\n    _requestDepthMap(): void;\n    _releaseDepthMap(): void;\n    /**\n     * Removes all the effects from the queue and disables it.\n     */\n    destroy(): void;\n    /**\n     * Enables the queue and all of its effects. If there are no effects then the queue will not be\n     * enabled.\n     */\n    enable(): void;\n    /**\n     * Disables the queue and all of its effects.\n     */\n    disable(): void;\n    /**\n     * Handler called when the application\'s canvas element is resized.\n     *\n     * @param {number} width - The new width of the canvas.\n     * @param {number} height - The new height of the canvas.\n     * @private\n     */\n    private _onCanvasResized;\n    resizeRenderTargets(): void;\n    onCameraRectChanged(name: any, oldValue: any, newValue: any): void;\n}\n\ndeclare class PostEffect {\n    constructor(effect: any, inputTarget: any);\n    effect: any;\n    inputTarget: any;\n    outputTarget: any;\n    name: any;\n}\n\ndeclare function partitionSkin(model: any, materialMappings: any, boneLimit: any): void;\n\n\n/**\n * Generates normal information from the specified positions and triangle indices. See\n * {@link createMesh}.\n *\n * @param {number[]} positions - An array of 3-dimensional vertex positions.\n * @param {number[]} indices - An array of triangle indices.\n * @returns {number[]} An array of 3-dimensional vertex normals.\n * @example\n * var normals = pc.calculateNormals(positions, indices);\n * var tangents = pc.calculateTangents(positions, normals, uvs, indices);\n * var mesh = pc.createMesh(positions, normals, tangents, uvs, indices);\n */\ndeclare function calculateNormals(positions: number[], indices: number[]): number[];\n/**\n * Generates tangent information from the specified positions, normals, texture coordinates and\n * triangle indices. See {@link createMesh}.\n *\n * @param {number[]} positions - An array of 3-dimensional vertex positions.\n * @param {number[]} normals - An array of 3-dimensional vertex normals.\n * @param {number[]} uvs - An array of 2-dimensional vertex texture coordinates.\n * @param {number[]} indices - An array of triangle indices.\n * @returns {number[]} An array of 3-dimensional vertex tangents.\n * @example\n * var tangents = pc.calculateTangents(positions, normals, uvs, indices);\n * var mesh = pc.createMesh(positions, normals, tangents, uvs, indices);\n */\ndeclare function calculateTangents(positions: number[], normals: number[], uvs: number[], indices: number[]): number[];\n/**\n * Creates a procedural box-shaped mesh.\n *\n * The size, shape and tesselation properties of the box can be controlled via function parameters.\n * By default, the function will create a box centered on the object space origin with a width,\n * length and height of 1.0 unit and 10 segments in either axis (50 triangles per face).\n *\n * Note that the box is created with UVs in the range of 0 to 1 on each face. Additionally, tangent\n * information is generated into the vertex buffer of the box\'s mesh.\n *\n * @param {GraphicsDevice} device - The graphics device used to manage the mesh.\n * @param {object} [opts] - An object that specifies optional inputs for the function as follows:\n * @param {Vec3} [opts.halfExtents] - The half dimensions of the box in each axis (defaults to\n * [0.5, 0.5, 0.5]).\n * @param {number} [opts.widthSegments] - The number of divisions along the X axis of the box\n * (defaults to 1).\n * @param {number} [opts.lengthSegments] - The number of divisions along the Z axis of the box\n * (defaults to 1).\n * @param {number} [opts.heightSegments] - The number of divisions along the Y axis of the box\n * (defaults to 1).\n * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).\n * @returns {Mesh} A new box-shaped mesh.\n */\ndeclare function createBox(device: GraphicsDevice, opts?: {\n    halfExtents?: Vec3;\n    widthSegments?: number;\n    lengthSegments?: number;\n    heightSegments?: number;\n    calculateTangents?: boolean;\n}): Mesh;\n/**\n * Creates a procedural capsule-shaped mesh.\n *\n * The size, shape and tesselation properties of the capsule can be controlled via function\n * parameters. By default, the function will create a capsule standing vertically centered on the\n * XZ-plane with a radius of 0.25, a height of 1.0, 1 height segment and 10 cap segments.\n *\n * Note that the capsule is created with UVs in the range of 0 to 1. Additionally, tangent\n * information is generated into the vertex buffer of the capsule\'s mesh.\n *\n * @param {GraphicsDevice} device - The graphics device used to manage the mesh.\n * @param {object} [opts] - An object that specifies optional inputs for the function as follows:\n * @param {number} [opts.radius] - The radius of the tube forming the body of the capsule (defaults\n * to 0.3).\n * @param {number} [opts.height] - The length of the body of the capsule from tip to tip (defaults\n * to 1.0).\n * @param {number} [opts.heightSegments] - The number of divisions along the tubular length of the\n * capsule (defaults to 1).\n * @param {number} [opts.sides] - The number of divisions around the tubular body of the capsule\n * (defaults to 20).\n * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).\n * @returns {Mesh} A new cylinder-shaped mesh.\n */\ndeclare function createCapsule(device: GraphicsDevice, opts?: {\n    radius?: number;\n    height?: number;\n    heightSegments?: number;\n    sides?: number;\n    calculateTangents?: boolean;\n}): Mesh;\n/**\n * Creates a procedural cone-shaped mesh.\n *\n * The size, shape and tesselation properties of the cone can be controlled via function\n * parameters. By default, the function will create a cone standing vertically centered on the\n * XZ-plane with a base radius of 0.5, a height of 1.0, 5 height segments and 20 cap segments.\n *\n * Note that the cone is created with UVs in the range of 0 to 1. Additionally, tangent information\n * is generated into the vertex buffer of the cone\'s mesh.\n *\n * @param {GraphicsDevice} device - The graphics device used to manage the mesh.\n * @param {object} [opts] - An object that specifies optional inputs for the function as follows:\n * @param {number} [opts.baseRadius] - The base radius of the cone (defaults to 0.5).\n * @param {number} [opts.peakRadius] - The peak radius of the cone (defaults to 0.0).\n * @param {number} [opts.height] - The length of the body of the cone (defaults to 1.0).\n * @param {number} [opts.heightSegments] - The number of divisions along the length of the cone\n * (defaults to 5).\n * @param {number} [opts.capSegments] - The number of divisions around the tubular body of the cone\n * (defaults to 18).\n * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).\n * @returns {Mesh} A new cone-shaped mesh.\n */\ndeclare function createCone(device: GraphicsDevice, opts?: {\n    baseRadius?: number;\n    peakRadius?: number;\n    height?: number;\n    heightSegments?: number;\n    capSegments?: number;\n    calculateTangents?: boolean;\n}): Mesh;\n/**\n * Creates a procedural cylinder-shaped mesh.\n *\n * The size, shape and tesselation properties of the cylinder can be controlled via function\n * parameters. By default, the function will create a cylinder standing vertically centered on the\n * XZ-plane with a radius of 0.5, a height of 1.0, 1 height segment and 20 cap segments.\n *\n * Note that the cylinder is created with UVs in the range of 0 to 1. Additionally, tangent\n * information is generated into the vertex buffer of the cylinder\'s mesh.\n *\n * @param {GraphicsDevice} device - The graphics device used to manage the mesh.\n * @param {object} [opts] - An object that specifies optional inputs for the function as follows:\n * @param {number} [opts.radius] - The radius of the tube forming the body of the cylinder (defaults to 0.5).\n * @param {number} [opts.height] - The length of the body of the cylinder (defaults to 1.0).\n * @param {number} [opts.heightSegments] - The number of divisions along the length of the cylinder (defaults to 5).\n * @param {number} [opts.capSegments] - The number of divisions around the tubular body of the cylinder (defaults to 20).\n * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).\n * @returns {Mesh} A new cylinder-shaped mesh.\n */\ndeclare function createCylinder(device: GraphicsDevice, opts?: {\n    radius?: number;\n    height?: number;\n    heightSegments?: number;\n    capSegments?: number;\n    calculateTangents?: boolean;\n}): Mesh;\n/**\n * Creates a new mesh object from the supplied vertex information and topology.\n *\n * @param {GraphicsDevice} device - The graphics device used to manage the mesh.\n * @param {number[]} positions - An array of 3-dimensional vertex positions.\n * @param {object} [opts] - An object that specifies optional inputs for the function as follows:\n * @param {number[]} [opts.normals] - An array of 3-dimensional vertex normals.\n * @param {number[]} [opts.tangents] - An array of 3-dimensional vertex tangents.\n * @param {number[]} [opts.colors] - An array of 4-dimensional vertex colors where each component\n * is an integer in the range 0 to 255.\n * @param {number[]} [opts.uvs] - An array of 2-dimensional vertex texture coordinates.\n * @param {number[]} [opts.uvs1] - Same as opts.uvs, but for additional UV set\n * @param {number[]} [opts.blendIndices] - An array of 4-dimensional bone indices where each\n * component is an integer in the range 0 to 255.\n * @param {number[]} [opts.blendWeights] - An array of 4-dimensional bone weights where each\n * component is in the range 0 to 1 and the sum of the weights should equal 1.\n * @param {number[]} [opts.indices] - An array of triangle indices.\n * @returns {Mesh} A new Mesh constructed from the supplied vertex and triangle data.\n * @example\n * // Create a simple, indexed triangle (with texture coordinates and vertex normals)\n * var mesh = pc.createMesh(graphicsDevice, [0, 0, 0, 1, 0, 0, 0, 1, 0], {\n *     normals: [0, 0, 1, 0, 0, 1, 0, 0, 1],\n *     uvs: [0, 0, 1, 0, 0, 1],\n *     indices: [0, 1, 2]\n * });\n */\ndeclare function createMesh(device: GraphicsDevice, positions: number[], opts?: {\n    normals?: number[];\n    tangents?: number[];\n    colors?: number[];\n    uvs?: number[];\n    uvs1?: number[];\n    blendIndices?: number[];\n    blendWeights?: number[];\n    indices?: number[];\n}): Mesh;\n/**\n * Creates a procedural plane-shaped mesh.\n *\n * The size and tesselation properties of the plane can be controlled via function parameters. By\n * default, the function will create a plane centered on the object space origin with a width and\n * length of 1.0 and 5 segments in either axis (50 triangles). The normal vector of the plane is\n * aligned along the positive Y axis.\n *\n * Note that the plane is created with UVs in the range of 0 to 1. Additionally, tangent\n * information is generated into the vertex buffer of the plane\'s mesh.\n *\n * @param {GraphicsDevice} device - The graphics device used to manage the mesh.\n * @param {object} [opts] - An object that specifies optional inputs for the function as follows:\n * @param {Vec2} [opts.halfExtents] - The half dimensions of the plane in the X and Z axes\n * (defaults to [0.5, 0.5]).\n * @param {number} [opts.widthSegments] - The number of divisions along the X axis of the plane\n * (defaults to 5).\n * @param {number} [opts.lengthSegments] - The number of divisions along the Z axis of the plane\n * (defaults to 5).\n * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).\n * @returns {Mesh} A new plane-shaped mesh.\n */\ndeclare function createPlane(device: GraphicsDevice, opts?: {\n    halfExtents?: Vec2;\n    widthSegments?: number;\n    lengthSegments?: number;\n    calculateTangents?: boolean;\n}): Mesh;\n/**\n * Creates a procedural sphere-shaped mesh.\n *\n * The size and tesselation properties of the sphere can be controlled via function parameters. By\n * default, the function will create a sphere centered on the object space origin with a radius of\n * 0.5 and 16 segments in both longitude and latitude.\n *\n * Note that the sphere is created with UVs in the range of 0 to 1. Additionally, tangent\n * information is generated into the vertex buffer of the sphere\'s mesh.\n *\n * @param {GraphicsDevice} device - The graphics device used to manage the mesh.\n * @param {object} [opts] - An object that specifies optional inputs for the function as follows:\n * @param {number} [opts.radius] - The radius of the sphere (defaults to 0.5).\n * @param {number} [opts.latitudeBands] - The number of divisions along the latitudinal axis of the\n * sphere (defaults to 16).\n * @param {number} [opts.longitudeBands] - The number of divisions along the longitudinal axis of\n * the sphere (defaults to 16).\n * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).\n * @returns {Mesh} A new sphere-shaped mesh.\n */\ndeclare function createSphere(device: GraphicsDevice, opts?: {\n    radius?: number;\n    latitudeBands?: number;\n    longitudeBands?: number;\n    calculateTangents?: boolean;\n}): Mesh;\n/**\n * Creates a procedural torus-shaped mesh.\n *\n * The size, shape and tesselation properties of the torus can be controlled via function\n * parameters. By default, the function will create a torus in the XZ-plane with a tube radius of\n * 0.2, a ring radius of 0.3, 20 segments and 30 sides.\n *\n * Note that the torus is created with UVs in the range of 0 to 1. Additionally, tangent\n * information is generated into the vertex buffer of the torus\'s mesh.\n *\n * @param {GraphicsDevice} device - The graphics device used to manage the mesh.\n * @param {object} [opts] - An object that specifies optional inputs for the function as follows:\n * @param {number} [opts.tubeRadius] - The radius of the tube forming the body of the torus\n * (defaults to 0.2).\n * @param {number} [opts.ringRadius] - The radius from the centre of the torus to the centre of the\n * tube (defaults to 0.3).\n * @param {number} [opts.segments] - The number of radial divisions forming cross-sections of the\n * torus ring (defaults to 20).\n * @param {number} [opts.sides] - The number of divisions around the tubular body of the torus ring\n * (defaults to 30).\n * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).\n * @returns {Mesh} A new torus-shaped mesh.\n */\ndeclare function createTorus(device: GraphicsDevice, opts?: {\n    tubeRadius?: number;\n    ringRadius?: number;\n    segments?: number;\n    sides?: number;\n    calculateTangents?: boolean;\n}): Mesh;\n\n\n\n\n\n/**\n * Picker object used to select mesh instances from screen coordinates.\n *\n * @property {number} width Width of the pick buffer in pixels (read-only).\n * @property {number} height Height of the pick buffer in pixels (read-only).\n * @property {RenderTarget} renderTarget The render target used by the picker internally\n * (read-only).\n */\ndeclare class Picker {\n    /**\n     * Create a new Picker instance.\n     *\n     * @param {Application} app - The application managing this picker instance.\n     * @param {number} width - The width of the pick buffer in pixels.\n     * @param {number} height - The height of the pick buffer in pixels.\n     */\n    constructor(app: Application, width: number, height: number);\n    app: Application;\n    device: GraphicsDevice;\n    pickColor: Float32Array;\n    mapping: any[];\n    cameraEntity: Entity;\n    layer: Layer;\n    layerComp: LayerComposition;\n    _renderTarget: any;\n    clearDepthCommand: Command;\n    width: number;\n    height: number;\n    /**\n     * Return the list of mesh instances selected by the specified rectangle in the previously\n     * prepared pick buffer.The rectangle using top-left coordinate system.\n     *\n     * @param {number} x - The left edge of the rectangle.\n     * @param {number} y - The top edge of the rectangle.\n     * @param {number} [width] - The width of the rectangle.\n     * @param {number} [height] - The height of the rectangle.\n     * @returns {MeshInstance[]} An array of mesh instances that are in the selection.\n     * @example\n     * // Get the selection at the point (10,20)\n     * var selection = picker.getSelection(10, 20);\n     * @example\n     * // Get all models in rectangle with corners at (10,20) and (20,40)\n     * var selection = picker.getSelection(10, 20, 10, 20);\n     */\n    getSelection(x: number, y: number, width?: number, height?: number): MeshInstance[];\n    allocateRenderTarget(): void;\n    renderTarget: RenderTarget;\n    releaseRenderTarget(): void;\n    initLayerComposition(): void;\n    /**\n     * Primes the pick buffer with a rendering of the specified models from the point of view of\n     * the supplied camera. Once the pick buffer has been prepared, {@link Picker#getSelection} can\n     * be called multiple times on the same picker object. Therefore, if the models or camera do\n     * not change in any way, {@link Picker#prepare} does not need to be called again.\n     *\n     * @param {CameraComponent} camera - The camera component used to render the scene.\n     * @param {Scene} scene - The scene containing the pickable mesh instances.\n     * @param {Layer[]} [layers] - Layers from which objects will be picked. If not supplied, all layers of the specified camera will be used.\n     */\n    prepare(camera: CameraComponent, scene: Scene, layers?: Layer[]): void;\n    updateCamera(srcCamera: any): void;\n    /**\n     * Sets the resolution of the pick buffer. The pick buffer resolution does not need to match\n     * the resolution of the corresponding frame buffer use for general rendering of the 3D scene.\n     * However, the lower the resolution of the pick buffer, the less accurate the selection\n     * results returned by {@link Picker#getSelection}. On the other hand, smaller pick buffers\n     * will yield greater performance, so there is a trade off.\n     *\n     * @param {number} width - The width of the pick buffer in pixels.\n     * @param {number} height - The height of the pick buffer in pixels.\n     */\n    resize(width: number, height: number): void;\n}\n\n/**\n * An animation is a sequence of keyframe arrays which map to the nodes of a skeletal hierarchy. It\n * controls how the nodes of the hierarchy are transformed over time.\n */\ndeclare class Animation$1 {\n    /**\n     * Human-readable name of the animation.\n     *\n     * @type {string}\n     */\n    name: string;\n    /**\n     * Duration of the animation in seconds.\n     *\n     * @type {number}\n     */\n    duration: number;\n    _nodes: any[];\n    _nodeDict: {};\n    /**\n     * Gets a {@link Node} by name.\n     *\n     * @param {string} name - The name of the {@link Node}.\n     * @returns {Node} The {@link Node} with the specified name.\n     */\n    getNode(name: string): Node$1;\n    /**\n     * Adds a node to the internal nodes array.\n     *\n     * @param {Node} node - The node to add.\n     */\n    addNode(node: Node$1): void;\n    /**\n     * A read-only property to get array of animation nodes.\n     *\n     * @type {Node[]}\n     */\n    get nodes(): Node$1[];\n}\ndeclare class Key {\n    constructor(time: any, position: any, rotation: any, scale: any);\n    time: any;\n    position: any;\n    rotation: any;\n    scale: any;\n}\n/**\n * A animation node has a name and contains an array of keyframes.\n */\ndeclare class Node$1 {\n    _name: string;\n    _keys: any[];\n}\n\n\n/**\n * Represents a skeleton used to play animations.\n */\ndeclare class Skeleton {\n    /**\n     * Create a new Skeleton instance.\n     *\n     * @param {GraphNode} graph - The root {@link GraphNode} of the skeleton.\n     */\n    constructor(graph: GraphNode);\n    /**\n     * Determines whether skeleton is looping its animation.\n     *\n     * @type {boolean}\n     */\n    looping: boolean;\n    /**\n     * @type {Animation}\n     * @private\n     */\n    private _animation;\n    _time: number;\n    _interpolatedKeys: any[];\n    _interpolatedKeyDict: {};\n    _currKeyIndices: {};\n    graph: GraphNode;\n    /**\n     * Animation currently assigned to skeleton.\n     *\n     * @type {Animation}\n     */\n    set animation(arg: Animation);\n    get animation(): Animation;\n    /**\n     * Current time of currently active animation in seconds. This value is between zero and the\n     * duration of the animation.\n     *\n     * @type {number}\n     */\n    set currentTime(arg: number);\n    get currentTime(): number;\n    /**\n     * Read-only property that returns number of nodes of a skeleton.\n     *\n     * @type {number}\n     */\n    get numNodes(): number;\n    /**\n     * Progresses the animation assigned to the specified skeleton by the supplied time delta. If\n     * the delta takes the animation passed its end point, if the skeleton is set to loop, the\n     * animation will continue from the beginning. Otherwise, the animation\'s current time will\n     * remain at its duration (i.e. the end).\n     *\n     * @param {number} delta - The time in seconds to progress the skeleton\'s animation.\n     */\n    addTime(delta: number): void;\n    /**\n     * Blends two skeletons together.\n     *\n     * @param {Skeleton} skel1 - Skeleton holding the first pose to be blended.\n     * @param {Skeleton} skel2 - Skeleton holding the second pose to be blended.\n     * @param {number} alpha - The value controlling the interpolation in relation to the two input\n     * skeletons. The value is in the range 0 to 1, 0 generating skel1, 1 generating skel2 and\n     * anything in between generating a spherical interpolation between the two.\n     */\n    blend(skel1: Skeleton, skel2: Skeleton, alpha: number): void;\n    /**\n     * Links a skeleton to a node hierarchy. The nodes animated skeleton are then subsequently used\n     * to drive the local transformation matrices of the node hierarchy.\n     *\n     * @param {GraphNode} graph - The root node of the graph that the skeleton is to drive.\n     */\n    setGraph(graph: GraphNode): void;\n    /**\n     * Synchronizes the currently linked node hierarchy with the current state of the skeleton.\n     * Internally, this function converts the interpolated keyframe at each node in the skeleton\n     * into the local transformation matrix at each corresponding node in the linked node\n     * hierarchy.\n     */\n    updateGraph(): void;\n}\n\n\n\n/** @typedef {import(\'../sound/sound.js\').Sound} Sound */\n/** @typedef {import(\'../sound/manager.js\').SoundManager} SoundManager */\n/**\n * A channel is created when the {@link SoundManager} begins playback of a {@link Sound}. Usually\n * created internally by {@link SoundManager#playSound} or {@link SoundManager#playSound3d}.\n * Developers usually won\'t have to create Channels manually.\n *\n * @ignore\n */\ndeclare class Channel {\n    /**\n     * Create a new Channel instance.\n     *\n     * @param {SoundManager} manager - The SoundManager instance.\n     * @param {Sound} sound - The sound to playback.\n     * @param {object} [options] - Optional options object.\n     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.\n     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.\n     * @param {boolean} [options.loop=false] - Whether the sound should loop when it reaches the\n     * end or not.\n     */\n    constructor(manager: SoundManager, sound: Sound, options?: {\n        volume?: number;\n        pitch?: number;\n        loop?: boolean;\n    });\n    volume: number;\n    loop: boolean;\n    pitch: number;\n    sound: Sound;\n    paused: boolean;\n    suspended: boolean;\n    manager: SoundManager;\n    source: Node;\n    startTime: number;\n    startOffset: number;\n    gain: GainNode;\n    /**\n     * Get the current value for the volume. Between 0 and 1.\n     *\n     * @returns {number} The volume of the channel.\n     */\n    getVolume(): number;\n    /**\n     * Get the current looping state of the Channel.\n     *\n     * @returns {boolean} The loop property for the channel.\n     */\n    getLoop(): boolean;\n    /**\n     * Enable/disable the loop property to make the sound restart from the beginning when it\n     * reaches the end.\n     *\n     * @param {boolean} loop - True to loop the sound, false otherwise.\n     */\n    setLoop(loop: boolean): void;\n    /**\n     * Get the current pitch of the Channel.\n     *\n     * @returns {number} The pitch of the channel.\n     */\n    getPitch(): number;\n    /**\n     * Handle the manager\'s \'volumechange\' event.\n     */\n    onManagerVolumeChange(): void;\n    /**\n     * Handle the manager\'s \'suspend\' event.\n     */\n    onManagerSuspend(): void;\n    /**\n     * Handle the manager\'s \'resume\' event.\n     */\n    onManagerResume(): void;\n    /**\n     * Begin playback of sound.\n     */\n    play(): void;\n    /**\n     * Pause playback of sound. Call unpause() to resume playback from the same position.\n     */\n    pause(): void;\n    /**\n     * Resume playback of the sound. Playback resumes at the point that the audio was paused.\n     */\n    unpause(): void;\n    /**\n     * Stop playback of sound. Calling play() again will restart playback from the beginning of the\n     * sound.\n     */\n    stop(): void;\n    /**\n     * Set the volume of playback between 0 and 1.\n     *\n     * @param {number} volume - The volume of the sound. Will be clamped between 0 and 1.\n     */\n    setVolume(volume: number): void;\n    setPitch(pitch: any): void;\n    isPlaying(): boolean;\n    getDuration(): any;\n    _createSource(): void;\n}\n\n/**\n * 3D audio channel.\n *\n * @ignore\n */\ndeclare class Channel3d extends Channel {\n    position: Vec3;\n    velocity: Vec3;\n    panner: PannerNode;\n    maxDistance: number;\n    minDistance: number;\n    rollOffFactor: number;\n    distanceModel: string;\n    getPosition(): Vec3;\n    setPosition(position: any): void;\n    getVelocity(): Vec3;\n    setVelocity(velocity: any): void;\n    getMaxDistance(): number;\n    setMaxDistance(max: any): void;\n    getMinDistance(): number;\n    setMinDistance(min: any): void;\n    getRollOffFactor(): number;\n    setRollOffFactor(factor: any): void;\n    getDistanceModel(): DistanceModelType;\n    setDistanceModel(distanceModel: any): void;\n}\n\n\n/** @typedef {import(\'./touch-device.js\').TouchDevice} TouchDevice */\n/**\n * Similar to {@link getTargetCoords} for the MouseEvents. This function takes a browser Touch\n * object and returns the coordinates of the touch relative to the target element.\n *\n * @param {globalThis.Touch} touch - The browser Touch object.\n * @returns {object} The coordinates of the touch relative to the touch.target element. In the\n * format {x, y}.\n */\ndeclare function getTouchTargetCoords(touch: globalThis.Touch): object;\n/**\n * A instance of a single point touch on a {@link TouchDevice}.\n */\ndeclare class Touch$1 {\n    /**\n     * Create a new Touch object from the browser Touch.\n     *\n     * @param {globalThis.Touch} touch - The browser Touch object.\n     */\n    constructor(touch: globalThis.Touch);\n    /**\n     * The identifier of the touch.\n     *\n     * @type {number}\n     */\n    id: number;\n    /**\n     * The x coordinate relative to the element that the TouchDevice is attached to.\n     *\n     * @type {number}\n     */\n    x: number;\n    /**\n     * The y coordinate relative to the element that the TouchDevice is attached to.\n     *\n     * @type {number}\n     */\n    y: number;\n    /**\n     * The target element of the touch event.\n     *\n     * @type {Element}\n     */\n    target: Element;\n    /**\n     * The original browser Touch object.\n     *\n     * @type {globalThis.Touch}\n     */\n    touch: globalThis.Touch;\n}\n/**\n * A Event corresponding to touchstart, touchend, touchmove or touchcancel. TouchEvent wraps the\n * standard browser event and provides lists of {@link Touch} objects.\n */\ndeclare class TouchEvent$1 {\n    /**\n     * Create a new TouchEvent instance. It is created from an existing browser event.\n     *\n     * @param {TouchDevice} device - The source device of the touch events.\n     * @param {globalThis.TouchEvent} event - The original browser TouchEvent.\n     */\n    constructor(device: TouchDevice, event: globalThis.TouchEvent);\n    /**\n     * The target Element that the event was fired from.\n     *\n     * @type {Element}\n     */\n    element: Element;\n    /**\n     * The original browser TouchEvent.\n     *\n     * @type {globalThis.TouchEvent}\n     */\n    event: globalThis.TouchEvent;\n    /**\n     * A list of all touches currently in contact with the device.\n     *\n     * @type {Touch[]}\n     */\n    touches: Touch$1[];\n    /**\n     * A list of touches that have changed since the last event.\n     *\n     * @type {Touch[]}\n     */\n    changedTouches: Touch$1[];\n    /**\n     * Get an event from one of the touch lists by the id. It is useful to access\n     * touches by their id so that you can be sure you are referencing the same\n     * touch.\n     *\n     * @param {number} id - The identifier of the touch.\n     * @param {Touch[]|null} list - An array of touches to search.\n     * @returns {Touch} The {@link Touch} object or null.\n     */\n    getTouchById(id: number, list: Touch$1[] | null): Touch$1;\n}\n\n\n/** @typedef {import(\'./game-pads.js\').GamePads} GamePads */\n/**\n * A general input handler which handles both mouse and keyboard input assigned to named actions.\n * This allows you to define input handlers separately to defining keyboard/mouse configurations.\n */\ndeclare class Controller {\n    /**\n     * Create a new instance of a Controller.\n     *\n     * @param {Element} [element] - Element to attach Controller to.\n     * @param {object} [options] - Optional arguments.\n     * @param {Keyboard} [options.keyboard] - A Keyboard object to use.\n     * @param {Mouse} [options.mouse] - A Mouse object to use.\n     * @param {GamePads} [options.gamepads] - A Gamepads object to use.\n     * @example\n     * var c = new pc.Controller(document);\n     *\n     * // Register the "fire" action and assign it to both the Enter key and the Spacebar.\n     * c.registerKeys("fire", [pc.KEY_ENTER, pc.KEY_SPACE]);\n     */\n    constructor(element?: Element, options?: {\n        keyboard?: Keyboard;\n        mouse?: Mouse;\n        gamepads?: GamePads;\n    });\n    _keyboard: Keyboard;\n    _mouse: Mouse;\n    _gamepads: GamePads;\n    _element: Element;\n    _actions: {};\n    _axes: {};\n    _axesValues: {};\n    /**\n     * Attach Controller to an Element. This is required before you can monitor for key/mouse\n     * inputs.\n     *\n     * @param {Element} element - The element to attach mouse and keyboard event handler too.\n     */\n    attach(element: Element): void;\n    /**\n     * Detach Controller from an Element. This should be done before the Controller is destroyed.\n     */\n    detach(): void;\n    /**\n     * Disable the context menu usually activated with the right mouse button.\n     */\n    disableContextMenu(): void;\n    /**\n     * Enable the context menu usually activated with the right mouse button. This is enabled by\n     * default.\n     */\n    enableContextMenu(): void;\n    /**\n     * Update the Keyboard and Mouse handlers.\n     *\n     * @param {object} dt - The time since the last frame.\n     */\n    update(dt: object): void;\n    /**\n     * Create or update a action which is enabled when the supplied keys are pressed.\n     *\n     * @param {string} action - The name of the action.\n     * @param {number[]} keys - A list of keycodes.\n     */\n    registerKeys(action: string, keys: number[]): void;\n    /**\n     * Create or update an action which is enabled when the supplied mouse button is pressed.\n     *\n     * @param {string} action - The name of the action.\n     * @param {number} button - The mouse button.\n     */\n    registerMouse(action: string, button: number): void;\n    /**\n     * Create or update an action which is enabled when the gamepad button is pressed.\n     *\n     * @param {string} action - The name of the action.\n     * @param {number} pad - The index of the pad to register (use {@link PAD_1}, etc).\n     * @param {number} button - The pad button.\n     */\n    registerPadButton(action: string, pad: number, button: number): void;\n    /**\n     * Register an action against a controller axis.\n     *\n     * @param {object} [options] - Optional options object.\n     * @param {number} [options.pad] - The index of the game pad to register for (use {@link PAD_1}, etc).\n     */\n    registerAxis(options?: {\n        pad?: number;\n    }): void;\n    /**\n     * Returns true if the current action is enabled.\n     *\n     * @param {string} actionName - The name of the action.\n     * @returns {boolean} True if the action is enabled.\n     */\n    isPressed(actionName: string): boolean;\n    /**\n     * Returns true if the action was enabled this since the last update.\n     *\n     * @param {string} actionName - The name of the action.\n     * @returns {boolean} True if the action was enabled this since the last update.\n     */\n    wasPressed(actionName: string): boolean;\n    getAxis(name: any): number;\n    _enableMouse(): void;\n    _enableKeyboard(): void;\n}\n\n\n/** @typedef {import(\'./keyboard.js\').Keyboard} Keyboard */\n/**\n * The KeyboardEvent is passed into all event callbacks from the {@link Keyboard}. It corresponds\n * to a key press or release.\n */\ndeclare class KeyboardEvent {\n    /**\n     * Create a new KeyboardEvent.\n     *\n     * @param {Keyboard} keyboard - The keyboard object which is firing the event.\n     * @param {globalThis.KeyboardEvent} event - The original browser event that was fired.\n     * @example\n     * var onKeyDown = function (e) {\n     *     if (e.key === pc.KEY_SPACE) {\n     *         // space key pressed\n     *     }\n     *     e.event.preventDefault(); // Use original browser event to prevent browser action.\n     * };\n     * app.keyboard.on("keydown", onKeyDown, this);\n     */\n    constructor(keyboard: Keyboard, event: globalThis.KeyboardEvent);\n    /**\n     * The keyCode of the key that has changed. See the KEY_* constants.\n     *\n     * @type {number}\n     */\n    key: number;\n    /**\n     * The element that fired the keyboard event.\n     *\n     * @type {Element}\n     */\n    element: Element;\n    /**\n     * The original browser event which was fired.\n     *\n     * @type {globalThis.KeyboardEvent}\n     */\n    event: globalThis.KeyboardEvent;\n}\n\n\n/**\n * MouseEvent object that is passed to events \'mousemove\', \'mouseup\', \'mousedown\' and \'mousewheel\'.\n */\ndeclare class MouseEvent$1 {\n    /**\n     * Create a new MouseEvent instance.\n     *\n     * @param {Mouse} mouse - The Mouse device that is firing this event.\n     * @param {globalThis.MouseEvent} event - The original browser event that fired.\n     */\n    constructor(mouse: Mouse, event: globalThis.MouseEvent);\n    /**\n     * The x coordinate of the mouse pointer relative to the element {@link Mouse} is\n     * attached to.\n     *\n     * @type {number}\n     */\n    x: number;\n    /**\n     * The y coordinate of the mouse pointer relative to the element {@link Mouse} is\n     * attached to.\n     *\n     * @type {number}\n     */\n    y: number;\n    /**\n     * A value representing the amount the mouse wheel has moved, only valid for\n     * {@link mousewheel} events.\n     *\n     * @type {number}\n     */\n    wheelDelta: number;\n    /**\n     * The change in x coordinate since the last mouse event.\n     *\n     * @type {number}\n     */\n    dx: number;\n    /**\n     * The change in y coordinate since the last mouse event.\n     *\n     * @type {number}\n     */\n    dy: number;\n    /**\n     * The mouse button associated with this event. Can be:\n     *\n     * - {@link MOUSEBUTTON_LEFT}\n     * - {@link MOUSEBUTTON_MIDDLE}\n     * - {@link MOUSEBUTTON_RIGHT}\n     *\n     * @type {number}\n     */\n    button: number;\n    buttons: boolean[];\n    /**\n     * The element that the mouse was fired from.\n     *\n     * @type {Element}\n     */\n    element: Element;\n    /**\n     * True if the ctrl key was pressed when this event was fired.\n     *\n     * @type {boolean}\n     */\n    ctrlKey: boolean;\n    /**\n     * True if the alt key was pressed when this event was fired.\n     *\n     * @type {boolean}\n     */\n    altKey: boolean;\n    /**\n     * True if the shift key was pressed when this event was fired.\n     *\n     * @type {boolean}\n     */\n    shiftKey: boolean;\n    /**\n     * True if the meta key was pressed when this event was fired.\n     *\n     * @type {boolean}\n     */\n    metaKey: boolean;\n    /**\n     * The original browser event.\n     *\n     * @type {globalThis.MouseEvent}\n     */\n    event: globalThis.MouseEvent;\n}\n\ndeclare function inherits(Self: any, Super: any): {\n    (arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any): void;\n    _super: any;\n    prototype: any;\n};\ndeclare function makeArray(arr: any): any;\ndeclare function UnsupportedBrowserError(message: any): void;\ndeclare class UnsupportedBrowserError {\n    constructor(message: any);\n    name: string;\n    message: any;\n}\ndeclare function ContextCreationError(message: any): void;\ndeclare class ContextCreationError {\n    constructor(message: any);\n    name: string;\n    message: any;\n}\ndeclare function basisSetDownloadConfig(glueUrl: any, wasmUrl: any, fallbackUrl: any): void;\ndeclare function prefilterCubemap(options: any): void;\ndeclare namespace log {\n    function write(text: any): void;\n    function open(): void;\n    function info(text: any): void;\n    function debug(text: any): void;\n    function error(text: any): void;\n    function warning(text: any): void;\n    function alert(text: any): void;\n    function assert(condition: any, text: any): void;\n}\ndeclare namespace time {\n    export { now };\n    export { Timer };\n}\ndeclare namespace shape {\n    export { BoundingBox as Aabb };\n    export { BoundingSphere as Sphere };\n    export { Plane };\n}\ndeclare const ELEMENTTYPE_INT8: number;\ndeclare const ELEMENTTYPE_UINT8: number;\ndeclare const ELEMENTTYPE_INT16: number;\ndeclare const ELEMENTTYPE_UINT16: number;\ndeclare const ELEMENTTYPE_INT32: number;\ndeclare const ELEMENTTYPE_UINT32: number;\ndeclare const ELEMENTTYPE_FLOAT32: number;\ndeclare namespace gfx {\n    export { ADDRESS_CLAMP_TO_EDGE };\n    export { ADDRESS_MIRRORED_REPEAT };\n    export { ADDRESS_REPEAT };\n    export { BLENDMODE_ZERO };\n    export { BLENDMODE_ONE };\n    export { BLENDMODE_SRC_COLOR };\n    export { BLENDMODE_ONE_MINUS_SRC_COLOR };\n    export { BLENDMODE_DST_COLOR };\n    export { BLENDMODE_ONE_MINUS_DST_COLOR };\n    export { BLENDMODE_SRC_ALPHA };\n    export { BLENDMODE_SRC_ALPHA_SATURATE };\n    export { BLENDMODE_ONE_MINUS_SRC_ALPHA };\n    export { BLENDMODE_DST_ALPHA };\n    export { BLENDMODE_ONE_MINUS_DST_ALPHA };\n    export { BUFFER_STATIC };\n    export { BUFFER_DYNAMIC };\n    export { BUFFER_STREAM };\n    export { CULLFACE_NONE };\n    export { CULLFACE_BACK };\n    export { CULLFACE_FRONT };\n    export { CULLFACE_FRONTANDBACK };\n    export { TYPE_INT8 as ELEMENTTYPE_INT8 };\n    export { TYPE_UINT8 as ELEMENTTYPE_UINT8 };\n    export { TYPE_INT16 as ELEMENTTYPE_INT16 };\n    export { TYPE_UINT16 as ELEMENTTYPE_UINT16 };\n    export { TYPE_INT32 as ELEMENTTYPE_INT32 };\n    export { TYPE_UINT32 as ELEMENTTYPE_UINT32 };\n    export { TYPE_FLOAT32 as ELEMENTTYPE_FLOAT32 };\n    export { FILTER_NEAREST };\n    export { FILTER_LINEAR };\n    export { FILTER_NEAREST_MIPMAP_NEAREST };\n    export { FILTER_NEAREST_MIPMAP_LINEAR };\n    export { FILTER_LINEAR_MIPMAP_NEAREST };\n    export { FILTER_LINEAR_MIPMAP_LINEAR };\n    export { INDEXFORMAT_UINT8 };\n    export { INDEXFORMAT_UINT16 };\n    export { INDEXFORMAT_UINT32 };\n    export { PIXELFORMAT_R5_G6_B5 };\n    export { PIXELFORMAT_R8_G8_B8 };\n    export { PIXELFORMAT_R8_G8_B8_A8 };\n    export { PRIMITIVE_POINTS };\n    export { PRIMITIVE_LINES };\n    export { PRIMITIVE_LINELOOP };\n    export { PRIMITIVE_LINESTRIP };\n    export { PRIMITIVE_TRIANGLES };\n    export { PRIMITIVE_TRISTRIP };\n    export { PRIMITIVE_TRIFAN };\n    export { SEMANTIC_POSITION };\n    export { SEMANTIC_NORMAL };\n    export { SEMANTIC_COLOR };\n    export { SEMANTIC_TEXCOORD };\n    export { SEMANTIC_TEXCOORD0 };\n    export { SEMANTIC_TEXCOORD1 };\n    export { SEMANTIC_ATTR0 };\n    export { SEMANTIC_ATTR1 };\n    export { SEMANTIC_ATTR2 };\n    export { SEMANTIC_ATTR3 };\n    export { TEXTURELOCK_READ };\n    export { TEXTURELOCK_WRITE };\n    export { drawQuadWithShader };\n    export { programlib };\n    export { shaderChunks };\n    export { ContextCreationError };\n    export { GraphicsDevice as Device };\n    export { IndexBuffer };\n    export { ProgramLibrary };\n    export { RenderTarget };\n    export { ScopeId };\n    export { Shader };\n    export { ShaderInput };\n    export { Texture };\n    export { UnsupportedBrowserError };\n    export { VertexBuffer };\n    export { VertexFormat };\n    export { VertexIterator };\n}\ndeclare namespace posteffect {\n    export { createFullscreenQuad };\n    export { drawFullscreenQuad };\n    export { PostEffect$1 as PostEffect };\n    export { PostEffectQueue };\n}\ndeclare const PhongMaterial: typeof StandardMaterial;\ndeclare namespace scene {\n    export { partitionSkin };\n    export namespace procedural {\n        export { calculateTangents };\n        export { createMesh };\n        export { createTorus };\n        export { createCylinder };\n        export { createCapsule };\n        export { createCone };\n        export { createSphere };\n        export { createPlane };\n        export { createBox };\n    }\n    export { BasicMaterial };\n    export { Command };\n    export { ForwardRenderer };\n    export { GraphNode };\n    export { Material };\n    export { Mesh };\n    export { MeshInstance };\n    export { Model };\n    export { ParticleEmitter };\n    export { StandardMaterial as PhongMaterial };\n    export { Picker };\n    export namespace Projection {\n        export { PROJECTION_ORTHOGRAPHIC as ORTHOGRAPHIC };\n        export { PROJECTION_PERSPECTIVE as PERSPECTIVE };\n    }\n    export { Scene };\n    export { Skin };\n    export { SkinInstance };\n}\ndeclare namespace anim {\n    export { Animation$1 as Animation };\n    export { Key };\n    export { Node$1 as Node };\n    export { Skeleton };\n}\ndeclare namespace audio {\n    export { SoundManager as AudioManager };\n    export { Channel };\n    export { Channel3d };\n    export { Listener };\n    export { Sound };\n}\ndeclare namespace asset {\n    const ASSET_ANIMATION: string;\n    const ASSET_AUDIO: string;\n    const ASSET_IMAGE: string;\n    const ASSET_JSON: string;\n    const ASSET_MODEL: string;\n    const ASSET_MATERIAL: string;\n    const ASSET_TEXT: string;\n    const ASSET_TEXTURE: string;\n    const ASSET_CUBEMAP: string;\n    const ASSET_SCRIPT: string;\n}\ndeclare namespace input {\n    export { getTouchTargetCoords };\n    export { Controller };\n    export { GamePads };\n    export { Keyboard };\n    export { KeyboardEvent };\n    export { Mouse };\n    export { MouseEvent$1 as MouseEvent };\n    export { Touch$1 as Touch };\n    export { TouchDevice };\n    export { TouchEvent$1 as TouchEvent };\n}\ndeclare const RIGIDBODY_TYPE_STATIC: string;\ndeclare const RIGIDBODY_TYPE_DYNAMIC: string;\ndeclare const RIGIDBODY_TYPE_KINEMATIC: string;\ndeclare const RIGIDBODY_CF_STATIC_OBJECT: 1;\ndeclare const RIGIDBODY_CF_KINEMATIC_OBJECT: 2;\ndeclare const RIGIDBODY_CF_NORESPONSE_OBJECT: 4;\ndeclare const RIGIDBODY_ACTIVE_TAG: 1;\ndeclare const RIGIDBODY_ISLAND_SLEEPING: 2;\ndeclare const RIGIDBODY_WANTS_DEACTIVATION: 3;\ndeclare const RIGIDBODY_DISABLE_DEACTIVATION: 4;\ndeclare const RIGIDBODY_DISABLE_SIMULATION: 5;\ndeclare namespace fw {\n    export { Application };\n    export { Component };\n    export { ComponentSystem };\n    export { Entity };\n    export namespace FillMode {\n        export { FILLMODE_NONE as NONE };\n        export { FILLMODE_FILL_WINDOW as FILL_WINDOW };\n        export { FILLMODE_KEEP_ASPECT as KEEP_ASPECT };\n    }\n    export namespace ResolutionMode {\n        export { RESOLUTION_AUTO as AUTO };\n        export { RESOLUTION_FIXED as FIXED };\n    }\n}\ndeclare class AssetListLoader extends EventHandler {\n    constructor(assetList: any, assetRegistry: any);\n    _assets: any;\n    _registry: any;\n    _loaded: boolean;\n    _count: number;\n    _total: number;\n    _failed: any[];\n    _waitingAssets: any[];\n    destroy(): void;\n    /**\n     * @private\n     * @function\n     * @name AssetListLoader#load\n     * @description Start loading asset list, call done() when all assets have loaded or failed to load.\n     * @param {Function} done - Callback called when all assets in the list are loaded. Passed (err, failed) where err is the undefined if no errors are encountered and failed contains a list of assets that failed to load.\n     * @param {object} [scope] - Scope to use when calling callback.\n     *\n     */\n    private load;\n    _callback: Function;\n    _scope: any;\n    /**\n     * @private\n     * @function\n     * @name AssetListLoader#ready\n     * @param {Function} done - Callback called when all assets in the list are loaded.\n     * @param {object} [scope] - Scope to use when calling callback.\n     */\n    private ready;\n    _loadingComplete(): void;\n    _onLoad(asset: any): void;\n    _onError(err: any, asset: any): void;\n    _onAddAsset(asset: any): void;\n    _waitForAsset(assetId: any): void;\n}\n\ndeclare namespace math {\n    const DEG_TO_RAD: number;\n    const RAD_TO_DEG: number;\n    function clamp(value: number, min: number, max: number): number;\n    function intToBytes24(i: number): number[];\n    function intToBytes32(i: number): number[];\n    function bytesToInt24(r: number, g: number, b: number): number;\n    function bytesToInt32(r: number, g: number, b: number, a: number): number;\n    function lerp(a: number, b: number, alpha: number): number;\n    function lerpAngle(a: number, b: number, alpha: number): number;\n    function powerOfTwo(x: number): boolean;\n    function nextPowerOfTwo(val: number): number;\n    function random(min: number, max: number): number;\n    function smoothstep(min: number, max: number, x: number): number;\n    function smootherstep(min: number, max: number, x: number): number;\n    function roundUp(numToRound: number, multiple: number): number;\n    function between(num: number, a: number, b: number, inclusive: boolean): boolean;\n}\n\n/**\n * Oriented Box.\n */\ndeclare class OrientedBox {\n    /**\n     * Create a new OrientedBox instance.\n     *\n     * @param {Mat4} [worldTransform] - Transform that has the orientation and position of the box.\n     * Scale is assumed to be one.\n     * @param {Vec3} [halfExtents] - Half the distance across the box in each local axis. The\n     * constructor takes a reference of this parameter.\n     */\n    constructor(worldTransform?: Mat4, halfExtents?: Vec3);\n    halfExtents: Vec3;\n    /**\n     * @type {Mat4}\n     * @private\n     */\n    private _modelTransform;\n    /**\n     * @type {Mat4}\n     * @private\n     */\n    private _worldTransform;\n    /**\n     * @type {BoundingBox}\n     * @private\n     */\n    private _aabb;\n    /**\n     * The world transform of the OBB.\n     *\n     * @type {Mat4}\n     */\n    set worldTransform(arg: Mat4);\n    get worldTransform(): Mat4;\n    /**\n     * Test if a ray intersects with the OBB.\n     *\n     * @param {Ray} ray - Ray to test against (direction must be normalized).\n     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied\n     * into here.\n     * @returns {boolean} True if there is an intersection.\n     */\n    intersectsRay(ray: Ray, point?: Vec3): boolean;\n    /**\n     * Test if a point is inside a OBB.\n     *\n     * @param {Vec3} point - Point to test.\n     * @returns {boolean} True if the point is inside the OBB and false otherwise.\n     */\n    containsPoint(point: Vec3): boolean;\n    /**\n     * Test if a Bounding Sphere is overlapping, enveloping, or inside this OBB.\n     *\n     * @param {BoundingSphere} sphere - Bounding Sphere to test.\n     * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping or inside this OBB\n     * and false otherwise.\n     */\n    intersectsBoundingSphere(sphere: BoundingSphere): boolean;\n}\n\ndeclare function shFromCubemap(device: any, source: any, dontFlipX: any): Float32Array;\n\n\n/**\n * This function reprojects textures between cubemap, equirectangular and octahedral formats. The\n * function can read and write textures with pixel data in RGBE, RGBM, linear and sRGB formats.\n * When specularPower is specified it will perform a phong-weighted convolution of the source (for\n * generating a gloss maps).\n *\n * @param {Texture} source - The source texture.\n * @param {Texture} target - The target texture.\n * @param {object} [options] - The options object.\n * @param {number} [options.specularPower] - Optional specular power. When specular power is\n * specified, the source is convolved by a phong-weighted kernel raised to the specified power.\n * Otherwise the function performs a standard resample.\n * @param {number} [options.numSamples] - Optional number of samples (default is 1024).\n * @param {number} [options.face] - Optional cubemap face to update (default is update all faces).\n * @param {string} [options.distribution] - Specify convolution distribution - \'none\', \'lambert\',\n * \'phong\', \'ggx\'. Default depends on specularPower.\n * @param {Vec4} [options.rect] - Optional viewport rectangle.\n * @param {number} [options.seamPixels] - Optional number of seam pixels to render\n */\ndeclare function reprojectTexture(source: Texture, target: Texture, options?: {\n    specularPower?: number;\n    numSamples?: number;\n    face?: number;\n    distribution?: string;\n    rect?: Vec4;\n    seamPixels?: number;\n}, ...args: any[]): void;\n\n/**\n * Helper functions to support prefiltering lighting data.\n *\n * @ignore\n */\ndeclare class EnvLighting {\n    /**\n     * Generate a skybox cubemap in the correct pixel format from the source texture.\n     *\n     * @param {Texture} source - The source texture. This is either a 2d texture in equirect format\n     * or a cubemap.\n     * @param {number} [size] - Size of the resulting texture. Otherwise use automatic sizing.\n     * @returns {Texture} The resulting cubemap.\n     */\n    static generateSkyboxCubemap(source: Texture, size?: number): Texture;\n    /**\n     * Create a texture in the format needed to precalculate lighting data.\n     *\n     * @param {Texture} source - The source texture. This is either a 2d texture in equirect format\n     * or a cubemap.\n     * @param {object} [options] - Specify generation options.\n     * @param {Texture} [options.target] - The target texture. If one is not provided then a\n     * new texture will be created and returned.\n     * @param {number} [options.size] - Size of the lighting source cubemap texture. Only used\n     * if target isn\'t specified. Defaults to 128.\n     * @returns {Texture} The resulting cubemap.\n     */\n    static generateLightingSource(source: Texture, options?: {\n        target?: Texture;\n        size?: number;\n    }): Texture;\n    /**\n     * Generate the environment lighting atlas containing prefiltered reflections and ambient.\n     *\n     * @param {Texture} source - The source lighting texture, generated by generateLightingSource.\n     * @param {object} [options] - Specify prefilter options.\n     * @param {Texture} [options.target] - The target texture. If one is not provided then a\n     * new texture will be created and returned.\n     * @param {number} [options.size] - Size of the target texture to create. Only used if\n     * target isn\'t specified. Defaults to 512.\n     * @param {number} [options.numReflectionSamples] - Number of samples to use when generating\n     * rough reflections. Defaults to 1024.\n     * @param {number} [options.numAmbientSamples] - Number of samples to use when generating ambient\n     * lighting. Defaults to 2048.\n     * @returns {Texture} The resulting atlas\n     */\n    static generateAtlas(source: Texture, options?: {\n        target?: Texture;\n        size?: number;\n        numReflectionSamples?: number;\n        numAmbientSamples?: number;\n    }): Texture;\n    /**\n     * Generate the environment lighting atlas from prefiltered cubemap data.\n     *\n     * @param {Texture[]} sources - Array of 6 prefiltered textures.\n     * @param {object} options - The options object\n     * @param {Texture} [options.target] - The target texture. If one is not provided then a\n     * new texture will be created and returned.\n     * @param {number} [options.size] - Size of the target texture to create. Only used if\n     * target isn\'t specified. Defaults to 512.\n     * @param {boolean} [options.legacyAmbient] - Enable generating legacy ambient lighting.\n     * Default is false.\n     * @param {number} [options.numSamples] - Number of samples to use when generating ambient\n     * lighting. Default is 2048.\n     * @returns {Texture} The resulting atlas texture.\n     */\n    static generatePrefilteredAtlas(sources: Texture[], options?: {\n        target?: Texture;\n        size?: number;\n        legacyAmbient?: boolean;\n        numSamples?: number;\n    }): Texture;\n}\n\n\n\n/** @typedef {import(\'./graphics-device.js\').GraphicsDevice} GraphicsDevice */\n/** @typedef {import(\'./shader.js\').Shader} Shader */\n/**\n * This object allows you to configure and use the transform feedback feature (WebGL2 only). How to\n * use:\n *\n * 1. First, check that you\'re on WebGL2, by looking at the `app.graphicsDevice.webgl2`` value.\n * 2. Define the outputs in your vertex shader. The syntax is `out vec3 out_vertex_position`,\n * note that there must be out_ in the name. You can then simply assign values to these outputs in\n * VS. The order and size of shader outputs must match the output buffer layout.\n * 3. Create the shader using `TransformFeedback.createShader(device, vsCode, yourShaderName)`.\n * 4. Create/acquire the input vertex buffer. Can be any VertexBuffer, either manually created, or\n * from a Mesh.\n * 5. Create the TransformFeedback object: `var tf = new TransformFeedback(inputBuffer)`. This\n * object will internally create an output buffer.\n * 6. Run the shader: `tf.process(shader)`. Shader will take the input buffer, process it and write\n * to the output buffer, then the input/output buffers will be automatically swapped, so you\'ll\n * immediately see the result.\n *\n * ```javascript\n * // *** shader asset ***\n * attribute vec3 vertex_position;\n * attribute vec3 vertex_normal;\n * attribute vec2 vertex_texCoord0;\n * out vec3 out_vertex_position;\n * out vec3 out_vertex_normal;\n * out vec2 out_vertex_texCoord0;\n * void main(void) {\n *     // read position and normal, write new position (push away)\n *     out_vertex_position = vertex_position + vertex_normal * 0.01;\n *     // pass other attributes unchanged\n *     out_vertex_normal = vertex_normal;\n *     out_vertex_texCoord0 = vertex_texCoord0;\n * }\n * ```\n *\n * ```javascript\n * // *** script asset ***\n * var TransformExample = pc.createScript(\'transformExample\');\n *\n * // attribute that references shader asset and material\n * TransformExample.attributes.add(\'shaderCode\', { type: \'asset\', assetType: \'shader\' });\n * TransformExample.attributes.add(\'material\', { type: \'asset\', assetType: \'material\' });\n *\n * TransformExample.prototype.initialize = function() {\n *     var device = this.app.graphicsDevice;\n *     var mesh = pc.createTorus(device, { tubeRadius: 0.01, ringRadius: 3 });\n *     var node = new pc.GraphNode();\n *     var meshInstance = new pc.MeshInstance(mesh, this.material.resource, node);\n *     var model = new pc.Model();\n *     model.graph = node;\n *     model.meshInstances = [ meshInstance ];\n *     this.app.scene.addModel(model);\n *\n *     // if webgl2 is not supported, TF is not available\n *     if (!device.webgl2) return;\n *     var inputBuffer = mesh.vertexBuffer;\n *     this.tf = new pc.TransformFeedback(inputBuffer);\n *     this.shader = pc.TransformFeedback.createShader(device, this.shaderCode.resource, "tfMoveUp");\n * };\n *\n * TransformExample.prototype.update = function(dt) {\n *     if (!this.app.graphicsDevice.webgl2) return;\n *     this.tf.process(this.shader);\n * };\n * ```\n */\ndeclare class TransformFeedback {\n    /**\n     * Creates a transform feedback ready vertex shader from code.\n     *\n     * @param {GraphicsDevice} graphicsDevice - The graphics device used by the renderer.\n     * @param {string} vsCode - Vertex shader code. Should contain output variables starting with "out_".\n     * @param {string} name - Unique name for caching the shader.\n     * @returns {Shader} A shader to use in the process() function.\n     */\n    static createShader(graphicsDevice: GraphicsDevice, vsCode: string, name: string): Shader;\n    /**\n     * Create a new TransformFeedback instance.\n     *\n     * @param {VertexBuffer} inputBuffer - The input vertex buffer.\n     * @param {number} [usage] - The optional usage type of the output vertex buffer. Can be:\n     *\n     * - {@link BUFFER_STATIC}\n     * - {@link BUFFER_DYNAMIC}\n     * - {@link BUFFER_STREAM}\n     * - {@link BUFFER_GPUDYNAMIC}\n     *\n     * Defaults to {@link BUFFER_GPUDYNAMIC} (which is recommended for continuous update).\n     */\n    constructor(inputBuffer: VertexBuffer, usage?: number);\n    device: GraphicsDevice;\n    _inputBuffer: VertexBuffer;\n    _outputBuffer: VertexBuffer;\n    /**\n     * Destroys the transform feedback helper object.\n     */\n    destroy(): void;\n    /**\n     * Runs the specified shader on the input buffer, writes results into the new buffer, then\n     * optionally swaps input/output.\n     *\n     * @param {Shader} shader - A vertex shader to run. Should be created with\n     * {@link TransformFeedback.createShader}.\n     * @param {boolean} [swap] - Swap input/output buffer data. Useful for continuous buffer\n     * processing. Default is true.\n     */\n    process(shader: Shader, swap?: boolean): void;\n    /**\n     * The current input buffer.\n     *\n     * @type {VertexBuffer}\n     */\n    get inputBuffer(): VertexBuffer;\n    /**\n     * The current output buffer.\n     *\n     * @type {VertexBuffer}\n     */\n    get outputBuffer(): VertexBuffer;\n}\n\n/**\n * A class used by the graphics device to handle the capture of the current framebuffer into a\n * texture to be used by following draw calls to implement refraction.\n *\n * @ignore\n */\ndeclare class GrabPass {\n    /**\n     * Create a new GrabPass instance.\n     *\n     * @param {GraphicsDevice} device - The graphics device used to manage this grab pass.\n     * @param {boolean} useAlpha - Whether the grab pass should have an alpha channel.\n     */\n    constructor(device: GraphicsDevice, useAlpha: boolean);\n    device: GraphicsDevice;\n    useAlpha: boolean;\n    useMipmaps: any;\n    texture: Texture;\n    renderTarget: RenderTarget;\n    textureId: any;\n    /**\n     * Release the grab pass resources.\n     */\n    destroy(): void;\n    /**\n     * Create the texture and render target used by the grab pass.\n     */\n    create(): void;\n    /**\n     * Resolve/copy the backbuffer into the grab pass render target.\n     *\n     * @returns {boolean} - Whether the grab pass was successfully resolved or not.\n     */\n    update(): boolean;\n    /**\n     * Generate mipmaps for the grab pass texture.\n     */\n    generateMipmaps(): void;\n    /**\n     * Grab a copy of the frame buffer to a texture and generate mipmaps for it.\n     *\n     * @returns {boolean} - Whether the grab pass was successfully updated or not.\n     */\n    prepareTexture(): boolean;\n}\n\n/**\n * A WebGL implementation of the Buffer.\n *\n * @ignore\n */\ndeclare class WebglBuffer {\n    bufferId: any;\n    destroy(device: any): void;\n    loseContext(): void;\n    unlock(device: any, usage: any, target: any, storage: any): void;\n}\n\n/**\n * A WebGL implementation of the VertexBuffer.\n *\n * @ignore\n */\ndeclare class WebglVertexBuffer extends WebglBuffer {\n    vao: any;\n    unlock(vertexBuffer: any): void;\n}\n\n/**\n * A WebGL implementation of the IndexBuffer.\n *\n * @ignore\n */\ndeclare class WebglIndexBuffer extends WebglBuffer {\n    constructor(indexBuffer: any);\n    glFormat: any;\n    unlock(indexBuffer: any): void;\n}\n\n\n\n/** @typedef {import(\'../graphics-device.js\').GraphicsDevice} GraphicsDevice */\n/** @typedef {import(\'../shader.js\').Shader} Shader */\n/**\n * A WebGL implementation of the Shader.\n *\n * @ignore\n */\ndeclare class WebglShader {\n    constructor(shader: any);\n    uniforms: any[];\n    samplers: any[];\n    attributes: any[];\n    glProgram: any;\n    glVertexShader: WebGLShader;\n    glFragmentShader: WebGLShader;\n    /**\n     * Free the WebGL resources associated with a shader.\n     *\n     * @param {Shader} shader - The shader to free.\n     */\n    destroy(shader: Shader): void;\n    /**\n     * Restore shader after the context has been obtained.\n     *\n     * @param {GraphicsDevice} device - The graphics device.\n     * @param {Shader} shader - The shader to restore.\n     */\n    restoreContext(device: GraphicsDevice, shader: Shader): void;\n    /**\n     * Compile and link a shader program.\n     *\n     * @param {GraphicsDevice} device - The graphics device.\n     * @param {Shader} shader - The shader to compile.\n     */\n    compileAndLink(device: GraphicsDevice, shader: Shader): void;\n    /**\n     * Compiles an individual shader.\n     *\n     * @param {string} src - The shader source code.\n     * @param {boolean} isVertexShader - True if the shader is a vertex shader, false if it is a\n     * fragment shader.\n     * @returns {WebGLShader} The compiled shader.\n     * @private\n     */\n    private _compileShaderSource;\n    /**\n     * Extract attribute and uniform information from a successfully linked shader.\n     *\n     * @param {GraphicsDevice} device - The graphics device.\n     * @param {Shader} shader - The shader to query.\n     * @returns {boolean} True if the shader was successfully queried and false otherwise.\n     */\n    postLink(device: GraphicsDevice, shader: Shader): boolean;\n    /**\n     * Check the compilation status of a shader.\n     *\n     * @param {GraphicsDevice} device - The graphics device.\n     * @param {Shader} shader - The shader to query.\n     * @param {WebGLShader} glShader - The WebGL shader.\n     * @param {string} source - The shader source code.\n     * @param {string} shaderType - The shader type. Can be \'vertex\' or \'fragment\'.\n     * @returns {boolean} True if the shader compiled successfully, false otherwise.\n     * @private\n     */\n    private _isCompiled;\n    /**\n     * Truncate the WebGL shader compilation log to just include the error line plus the 5 lines\n     * before and after it.\n     *\n     * @param {string} src - The shader source code.\n     * @param {string} infoLog - The info log returned from WebGL on a failed shader compilation.\n     * @returns {Array} An array where the first element is the 10 lines of code around the first\n     * detected error, and the second element an object storing the error messsage, line number and\n     * complete shader source.\n     * @private\n     */\n    private _processError;\n}\n\n/**\n * A WebGL implementation of the Texture.\n *\n * @ignore\n */\ndeclare class WebglTexture {\n    _glTexture: any;\n    _glTarget: any;\n    _glFormat: any;\n    _glInternalFormat: any;\n    _glPixelType: any;\n    destroy(device: any): void;\n    loseContext(): void;\n    initialize(device: any, texture: any): void;\n    upload(device: any, texture: any): void;\n}\n\n/**\n * A WebGL implementation of the RenderTarget.\n *\n * @ignore\n */\ndeclare class WebglRenderTarget {\n    _glFrameBuffer: any;\n    _glDepthBuffer: any;\n    _glResolveFrameBuffer: any;\n    _glMsaaColorBuffer: any;\n    _glMsaaDepthBuffer: any;\n    destroy(device: any): void;\n    init(device: any, target: any): void;\n    /**\n     * Checks the completeness status of the currently bound WebGLFramebuffer object.\n     *\n     * @private\n     */\n    private _checkFbo;\n    loseContext(): void;\n    resolve(device: any, target: any, color: any, depth: any): void;\n}\n\n\n\n\n/**\n * @event\n * @name GraphicsDevice#resizecanvas\n * @description The \'resizecanvas\' event is fired when the canvas is resized.\n * @param {number} width - The new width of the canvas in pixels.\n * @param {number} height - The new height of the canvas in pixels.\n */\n/**\n * The graphics device manages the underlying graphics context. It is responsible for submitting\n * render state changes and graphics primitives to the hardware. A graphics device is tied to a\n * specific canvas HTML element. It is valid to have more than one canvas element per page and\n * create a new graphics device against each.\n *\n * @augments GraphicsDevice\n */\ndeclare class WebglGraphicsDevice extends GraphicsDevice {\n    /**\n     * Creates a new WebglGraphicsDevice instance.\n     *\n     * @param {HTMLCanvasElement} canvas - The canvas to which the graphics device will render.\n     * @param {object} [options] - Options passed when creating the WebGL context.\n     * @param {boolean} [options.alpha=true] - Boolean that indicates if the canvas contains an\n     * alpha buffer.\n     * @param {boolean} [options.depth=true] - Boolean that indicates that the drawing buffer is\n     * requested to have a depth buffer of at least 16 bits.\n     * @param {boolean} [options.stencil=false] - Boolean that indicates that the drawing buffer is\n     * requested to have a stencil buffer of at least 8 bits.\n     * @param {boolean} [options.antialias=true] - Boolean that indicates whether or not to perform\n     * anti-aliasing if possible.\n     * @param {boolean} [options.premultipliedAlpha=true] - Boolean that indicates that the page\n     * compositor will assume the drawing buffer contains colors with pre-multiplied alpha.\n     * @param {boolean} [options.preserveDrawingBuffer=false] - If the value is true the buffers\n     * will not be cleared and will preserve their values until cleared or overwritten by the\n     * author.\n     * @param {\'default\'|\'high-performance\'|\'low-power\'} [options.powerPreference =\'default\'] - A\n     * hint to the user agent indicating what configuration of GPU is suitable for the WebGL\n     * context. Possible values are:\n     *\n     * - \'default\': Let the user agent decide which GPU configuration is most suitable. This is the\n     * default value.\n     * - \'high-performance\': Prioritizes rendering performance over power consumption.\n     * - \'low-power\': Prioritizes power saving over rendering performance.\n     *\n     * @param {boolean} [options.failIfMajorPerformanceCaveat=false] - Boolean that indicates if a\n     * context will be created if the system performance is low or if no hardware GPU is available.\n     * @param {boolean} [options.desynchronized=false] - Boolean that hints the user agent to\n     * reduce the latency by desynchronizing the canvas paint cycle from the event loop.\n     */\n    constructor(canvas: HTMLCanvasElement, options?: {\n        alpha?: boolean;\n        depth?: boolean;\n        stencil?: boolean;\n        antialias?: boolean;\n        premultipliedAlpha?: boolean;\n        preserveDrawingBuffer?: boolean;\n        powerPreference?: \'default\' | \'high-performance\' | \'low-power\';\n        failIfMajorPerformanceCaveat?: boolean;\n        desynchronized?: boolean;\n    });\n    /**\n     * The WebGL context managed by the graphics device. The type could also technically be\n     * `WebGLRenderingContext` if WebGL 2.0 is not available. But in order for IntelliSense to be\n     * able to function for all WebGL calls in the codebase, we specify `WebGL2RenderingContext`\n     * here instead.\n     *\n     * @type {WebGL2RenderingContext}\n     * @ignore\n     */\n    gl: WebGL2RenderingContext;\n    /**\n     * True if the WebGL context of this device is using the WebGL 2.0 API. If false, WebGL 1.0 is\n     * being used.\n     *\n     * @type {boolean}\n     * @ignore\n     */\n    webgl2: boolean;\n    defaultFramebuffer: any;\n    contextLost: boolean;\n    _contextLostHandler: (event: any) => void;\n    _contextRestoredHandler: () => void;\n    forceDisableMultisampling: boolean;\n    _tempEnableSafariTextureUnitWorkaround: boolean;\n    _tempMacChromeBlitFramebufferWorkaround: boolean;\n    defaultClearOptions: {\n        color: number[];\n        depth: number;\n        stencil: number;\n        flags: number;\n    };\n    glAddress: any[];\n    glBlendEquation: any[];\n    glBlendFunction: any[];\n    glComparison: any[];\n    glStencilOp: any[];\n    glClearFlag: any[];\n    glCull: any[];\n    glFilter: any[];\n    glPrimitive: any[];\n    glType: any[];\n    pcUniformType: {};\n    targetToSlot: {};\n    commitFunction: {}[];\n    supportsBoneTextures: boolean;\n    boneLimit: number;\n    constantTexSource: ScopeId;\n    textureBias: ScopeId;\n    supportsMorphTargetTexturesCore: boolean;\n    _textureFloatHighPrecision: boolean;\n    _textureHalfFloatUpdatable: boolean;\n    _spectorMarkers: any[];\n    _spectorCurrentMarker: string;\n    grabPassAvailable: boolean;\n    grabPass: GrabPass;\n    areaLightLutFormat: number;\n    createVertexBufferImpl(vertexBuffer: any, format: any): WebglVertexBuffer;\n    createIndexBufferImpl(indexBuffer: any): WebglIndexBuffer;\n    createShaderImpl(shader: any): WebglShader;\n    createTextureImpl(): WebglTexture;\n    createRenderTargetImpl(renderTarget: any): WebglRenderTarget;\n    updateMarker(): void;\n    pushMarker(name: any): void;\n    popMarker(): void;\n    /**\n     * Query the precision supported by ints and floats in vertex and fragment shaders. Note that\n     * getShaderPrecisionFormat is not guaranteed to be present (such as some instances of the\n     * default Android browser). In this case, assume highp is available.\n     *\n     * @returns {string} "highp", "mediump" or "lowp"\n     * @ignore\n     */\n    getPrecision(): string;\n    /**\n     * Initialize the extensions provided by the WebGL context.\n     *\n     * @ignore\n     */\n    initializeExtensions(): void;\n    extBlendMinmax: boolean | EXT_blend_minmax;\n    extDrawBuffers: boolean | EXT_blend_minmax;\n    extInstancing: boolean | EXT_blend_minmax;\n    extStandardDerivatives: boolean | EXT_blend_minmax;\n    extTextureFloat: boolean | EXT_blend_minmax;\n    extTextureHalfFloat: boolean | EXT_blend_minmax;\n    extTextureLod: boolean | EXT_blend_minmax;\n    extUintElement: boolean | EXT_blend_minmax;\n    extVertexArrayObject: boolean | EXT_blend_minmax;\n    extColorBufferFloat: EXT_blend_minmax;\n    extDisjointTimerQuery: EXT_blend_minmax;\n    extDepthTexture: boolean | WEBGL_depth_texture;\n    extDebugRendererInfo: EXT_blend_minmax;\n    extTextureFloatLinear: EXT_blend_minmax;\n    extTextureHalfFloatLinear: EXT_blend_minmax;\n    extFloatBlend: EXT_blend_minmax;\n    extTextureFilterAnisotropic: EXT_blend_minmax;\n    extCompressedTextureETC1: EXT_blend_minmax;\n    extCompressedTextureETC: EXT_blend_minmax;\n    extCompressedTexturePVRTC: EXT_blend_minmax;\n    extCompressedTextureS3TC: EXT_blend_minmax;\n    extCompressedTextureATC: EXT_blend_minmax;\n    extCompressedTextureASTC: EXT_blend_minmax;\n    extParallelShaderCompile: EXT_blend_minmax;\n    extColorBufferHalfFloat: EXT_blend_minmax;\n    /**\n     * Query the capabilities of the WebGL context.\n     *\n     * @ignore\n     */\n    initializeCapabilities(): void;\n    maxPrecision: string;\n    supportsMsaa: boolean;\n    supportsStencil: boolean;\n    maxRenderBufferSize: any;\n    maxTextures: any;\n    maxCombinedTextures: any;\n    maxVertexTextures: any;\n    vertexUniformsCount: any;\n    fragmentUniformsCount: any;\n    maxDrawBuffers: any;\n    maxColorAttachments: any;\n    unmaskedRenderer: any;\n    unmaskedVendor: any;\n    supportsGpuParticles: boolean;\n    samples: any;\n    maxSamples: any;\n    supportsAreaLights: boolean;\n    /**\n     * Set the initial render state on the WebGL context.\n     *\n     * @ignore\n     */\n    initializeRenderState(): void;\n    blending: any;\n    blendSrc: any;\n    blendDst: number;\n    blendSrcAlpha: number;\n    blendDstAlpha: number;\n    separateAlphaBlend: boolean;\n    blendEquation: any;\n    blendAlphaEquation: number;\n    separateAlphaEquation: boolean;\n    blendColor: Color;\n    writeRed: any;\n    writeGreen: boolean;\n    writeBlue: boolean;\n    writeAlpha: boolean;\n    cullMode: any;\n    depthTest: any;\n    depthFunc: any;\n    depthWrite: any;\n    stencil: any;\n    stencilFuncFront: any;\n    stencilFuncBack: any;\n    stencilRefFront: number;\n    stencilRefBack: number;\n    stencilMaskFront: number;\n    stencilMaskBack: number;\n    stencilFailFront: any;\n    stencilFailBack: any;\n    stencilZfailFront: number;\n    stencilZfailBack: number;\n    stencilZpassFront: number;\n    stencilZpassBack: number;\n    stencilWriteMaskFront: any;\n    stencilWriteMaskBack: any;\n    alphaToCoverage: any;\n    raster: any;\n    depthBiasEnabled: any;\n    clearDepth: any;\n    clearColor: Color;\n    clearStencil: any;\n    vx: any;\n    vy: number;\n    vw: number;\n    vh: number;\n    sx: any;\n    sy: number;\n    sw: number;\n    sh: number;\n    unpackFlipY: any;\n    unpackPremultiplyAlpha: any;\n    vertexShaderCache: {};\n    fragmentShaderCache: {};\n    _vaoMap: Map<any, any>;\n    boundVao: any;\n    activeFramebuffer: any;\n    feedback: WebGLTransformFeedback;\n    transformFeedbackBuffer: any;\n    textureUnit: any;\n    textureUnits: any[];\n    /**\n     * Called when the WebGL context was lost. It releases all context related resources.\n     *\n     * @ignore\n     */\n    loseContext(): void;\n    /**\n     * Called when the WebGL context is restored. It reinitializes all context related resources.\n     *\n     * @ignore\n     */\n    restoreContext(): void;\n    /**\n     * Set the active rectangle for rendering on the specified device.\n     *\n     * @param {number} x - The pixel space x-coordinate of the bottom left corner of the viewport.\n     * @param {number} y - The pixel space y-coordinate of the bottom left corner of the viewport.\n     * @param {number} w - The width of the viewport in pixels.\n     * @param {number} h - The height of the viewport in pixels.\n     */\n    setViewport(x: number, y: number, w: number, h: number): void;\n    /**\n     * Set the active scissor rectangle on the specified device.\n     *\n     * @param {number} x - The pixel space x-coordinate of the bottom left corner of the scissor rectangle.\n     * @param {number} y - The pixel space y-coordinate of the bottom left corner of the scissor rectangle.\n     * @param {number} w - The width of the scissor rectangle in pixels.\n     * @param {number} h - The height of the scissor rectangle in pixels.\n     */\n    setScissor(x: number, y: number, w: number, h: number): void;\n    /**\n     * Binds the specified framebuffer object.\n     *\n     * @param {WebGLFramebuffer} fb - The framebuffer to bind.\n     * @ignore\n     */\n    setFramebuffer(fb: WebGLFramebuffer): void;\n    /**\n     * Copies source render target into destination render target. Mostly used by post-effects.\n     *\n     * @param {RenderTarget} source - The source render target.\n     * @param {RenderTarget} [dest] - The destination render target. Defaults to frame buffer.\n     * @param {boolean} [color] - If true will copy the color buffer. Defaults to false.\n     * @param {boolean} [depth] - If true will copy the depth buffer. Defaults to false.\n     * @returns {boolean} True if the copy was successful, false otherwise.\n     */\n    copyRenderTarget(source: RenderTarget, dest?: RenderTarget, color?: boolean, depth?: boolean): boolean;\n    renderTarget: any;\n    /**\n     * Initialize render target before it can be used.\n     *\n     * @param {RenderTarget} target - The render target to be initialized.\n     * @ignore\n     */\n    initRenderTarget(target: RenderTarget): void;\n    /**\n     * Get copy shader for efficient rendering of fullscreen-quad with texture.\n     *\n     * @returns {Shader} The copy shader (based on `fullscreenQuadVS` and `outputTex2DPS` in\n     * `shaderChunks`).\n     * @ignore\n     */\n    getCopyShader(): Shader;\n    _copyShader: Shader;\n    /**\n     * Marks the beginning of a block of rendering. Internally, this function binds the render\n     * target currently set on the device. This function should be matched with a call to\n     * {@link GraphicsDevice#updateEnd}. Calls to {@link GraphicsDevice#updateBegin} and\n     * {@link GraphicsDevice#updateEnd} must not be nested.\n     */\n    updateBegin(): void;\n    /**\n     * Marks the end of a block of rendering. This function should be called after a matching call\n     * to {@link GraphicsDevice#updateBegin}. Calls to {@link GraphicsDevice#updateBegin} and\n     * {@link GraphicsDevice#updateEnd} must not be nested.\n     */\n    updateEnd(): void;\n    /**\n     * Updates a texture\'s vertical flip.\n     *\n     * @param {boolean} flipY - True to flip the texture vertically.\n     * @ignore\n     */\n    setUnpackFlipY(flipY: boolean): void;\n    /**\n     * Updates a texture to have its RGB channels premultiplied by its alpha channel or not.\n     *\n     * @param {boolean} premultiplyAlpha - True to premultiply the alpha channel against the RGB\n     * channels.\n     * @ignore\n     */\n    setUnpackPremultiplyAlpha(premultiplyAlpha: boolean): void;\n    /**\n     * Activate the specified texture unit.\n     *\n     * @param {number} textureUnit - The texture unit to activate.\n     * @ignore\n     */\n    activeTexture(textureUnit: number): void;\n    /**\n     * If the texture is not already bound on the currently active texture unit, bind it.\n     *\n     * @param {Texture} texture - The texture to bind.\n     * @ignore\n     */\n    bindTexture(texture: Texture): void;\n    /**\n     * If the texture is not bound on the specified texture unit, active the texture unit and bind\n     * the texture to it.\n     *\n     * @param {Texture} texture - The texture to bind.\n     * @param {number} textureUnit - The texture unit to activate and bind the texture to.\n     * @ignore\n     */\n    bindTextureOnUnit(texture: Texture, textureUnit: number): void;\n    /**\n     * Update the texture parameters for a given texture if they have changed.\n     *\n     * @param {Texture} texture - The texture to update.\n     * @ignore\n     */\n    setTextureParameters(texture: Texture): void;\n    /**\n     * Sets the specified texture on the specified texture unit.\n     *\n     * @param {Texture} texture - The texture to set.\n     * @param {number} textureUnit - The texture unit to set the texture on.\n     * @ignore\n     */\n    setTexture(texture: Texture, textureUnit: number): void;\n    createVertexArray(vertexBuffers: any): any;\n    setBuffers(): void;\n    /**\n     * Submits a graphical primitive to the hardware for immediate rendering.\n     *\n     * @param {object} primitive - Primitive object describing how to submit current vertex/index\n     * buffers.\n     * @param {number} primitive.type - The type of primitive to render. Can be:\n     *\n     * - {@link PRIMITIVE_POINTS}\n     * - {@link PRIMITIVE_LINES}\n     * - {@link PRIMITIVE_LINELOOP}\n     * - {@link PRIMITIVE_LINESTRIP}\n     * - {@link PRIMITIVE_TRIANGLES}\n     * - {@link PRIMITIVE_TRISTRIP}\n     * - {@link PRIMITIVE_TRIFAN}\n     *\n     * @param {number} primitive.base - The offset of the first index or vertex to dispatch in the\n     * draw call.\n     * @param {number} primitive.count - The number of indices or vertices to dispatch in the draw\n     * call.\n     * @param {boolean} [primitive.indexed] - True to interpret the primitive as indexed, thereby\n     * using the currently set index buffer and false otherwise.\n     * @param {number} [numInstances=1] - The number of instances to render when using\n     * ANGLE_instanced_arrays. Defaults to 1.\n     * @param {boolean} [keepBuffers] - Optionally keep the current set of vertex / index buffers /\n     * VAO. This is used when rendering of multiple views, for example under WebXR.\n     * @example\n     * // Render a single, unindexed triangle\n     * device.draw({\n     *     type: pc.PRIMITIVE_TRIANGLES,\n     *     base: 0,\n     *     count: 3,\n     *     indexed: false\n     * });\n     */\n    draw(primitive: {\n        type: number;\n        base: number;\n        count: number;\n        indexed?: boolean;\n    }, numInstances?: number, keepBuffers?: boolean): void;\n    /**\n     * Clears the frame buffer of the currently set render target.\n     *\n     * @param {object} [options] - Optional options object that controls the behavior of the clear\n     * operation defined as follows:\n     * @param {number[]} [options.color] - The color to clear the color buffer to in the range 0.0\n     * to 1.0 for each component.\n     * @param {number} [options.depth=1] - The depth value to clear the depth buffer to in the\n     * range 0.0 to 1.0.\n     * @param {number} [options.flags] - The buffers to clear (the types being color, depth and\n     * stencil). Can be any bitwise combination of:\n     *\n     * - {@link CLEARFLAG_COLOR}\n     * - {@link CLEARFLAG_DEPTH}\n     * - {@link CLEARFLAG_STENCIL}\n     *\n     * @param {number} [options.stencil=0] - The stencil value to clear the stencil buffer to. Defaults to 0.\n     * @example\n     * // Clear color buffer to black and depth buffer to 1.0\n     * device.clear();\n     *\n     * // Clear just the color buffer to red\n     * device.clear({\n     *     color: [1, 0, 0, 1],\n     *     flags: pc.CLEARFLAG_COLOR\n     * });\n     *\n     * // Clear color buffer to yellow and depth to 1.0\n     * device.clear({\n     *     color: [1, 1, 0, 1],\n     *     depth: 1,\n     *     flags: pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH\n     * });\n     */\n    clear(options?: {\n        color?: number[];\n        depth?: number;\n        flags?: number;\n        stencil?: number;\n    }): void;\n    /**\n     * Reads a block of pixels from a specified rectangle of the current color framebuffer into an\n     * ArrayBufferView object.\n     *\n     * @param {number} x - The x-coordinate of the rectangle\'s lower-left corner.\n     * @param {number} y - The y-coordinate of the rectangle\'s lower-left corner.\n     * @param {number} w - The width of the rectangle, in pixels.\n     * @param {number} h - The height of the rectangle, in pixels.\n     * @param {ArrayBufferView} pixels - The ArrayBufferView object that holds the returned pixel\n     * data.\n     * @ignore\n     */\n    readPixels(x: number, y: number, w: number, h: number, pixels: ArrayBufferView): void;\n    /**\n     * Set the depth value used when the depth buffer is cleared.\n     *\n     * @param {number} depth - The depth value to clear the depth buffer to in the range 0.0\n     * to 1.0.\n     * @ignore\n     */\n    setClearDepth(depth: number): void;\n    /**\n     * Set the clear color used when the frame buffer is cleared.\n     *\n     * @param {number} r - The red component of the color in the range 0.0 to 1.0.\n     * @param {number} g - The green component of the color in the range 0.0 to 1.0.\n     * @param {number} b - The blue component of the color in the range 0.0 to 1.0.\n     * @param {number} a - The alpha component of the color in the range 0.0 to 1.0.\n     * @ignore\n     */\n    setClearColor(r: number, g: number, b: number, a: number): void;\n    /**\n     * Set the stencil clear value used when the stencil buffer is cleared.\n     *\n     * @param {number} value - The stencil value to clear the stencil buffer to.\n     */\n    setClearStencil(value: number): void;\n    /**\n     * Queries whether depth testing is enabled.\n     *\n     * @returns {boolean} True if depth testing is enabled and false otherwise.\n     * @example\n     * var depthTest = device.getDepthTest();\n     * console.log(\'Depth testing is \' + depthTest ? \'enabled\' : \'disabled\');\n     */\n    getDepthTest(): boolean;\n    /**\n     * Enables or disables depth testing of fragments. Once this state is set, it persists until it\n     * is changed. By default, depth testing is enabled.\n     *\n     * @param {boolean} depthTest - True to enable depth testing and false otherwise.\n     * @example\n     * device.setDepthTest(true);\n     */\n    setDepthTest(depthTest: boolean): void;\n    /**\n     * Configures the depth test.\n     *\n     * @param {number} func - A function to compare a new depth value with an existing z-buffer\n     * value and decide if to write a pixel. Can be:\n     *\n     * - {@link FUNC_NEVER}: don\'t draw\n     * - {@link FUNC_LESS}: draw if new depth < depth buffer\n     * - {@link FUNC_EQUAL}: draw if new depth == depth buffer\n     * - {@link FUNC_LESSEQUAL}: draw if new depth <= depth buffer\n     * - {@link FUNC_GREATER}: draw if new depth > depth buffer\n     * - {@link FUNC_NOTEQUAL}: draw if new depth != depth buffer\n     * - {@link FUNC_GREATEREQUAL}: draw if new depth >= depth buffer\n     * - {@link FUNC_ALWAYS}: always draw\n     */\n    setDepthFunc(func: number): void;\n    /**\n     * Queries whether writes to the depth buffer are enabled.\n     *\n     * @returns {boolean} True if depth writing is enabled and false otherwise.\n     * @example\n     * var depthWrite = device.getDepthWrite();\n     * console.log(\'Depth writing is \' + depthWrite ? \'enabled\' : \'disabled\');\n     */\n    getDepthWrite(): boolean;\n    /**\n     * Enables or disables writes to the depth buffer. Once this state is set, it persists until it\n     * is changed. By default, depth writes are enabled.\n     *\n     * @param {boolean} writeDepth - True to enable depth writing and false otherwise.\n     * @example\n     * device.setDepthWrite(true);\n     */\n    setDepthWrite(writeDepth: boolean): void;\n    /**\n     * Enables or disables writes to the color buffer. Once this state is set, it persists until it\n     * is changed. By default, color writes are enabled for all color channels.\n     *\n     * @param {boolean} writeRed - True to enable writing of the red channel and false otherwise.\n     * @param {boolean} writeGreen - True to enable writing of the green channel and false otherwise.\n     * @param {boolean} writeBlue - True to enable writing of the blue channel and false otherwise.\n     * @param {boolean} writeAlpha - True to enable writing of the alpha channel and false otherwise.\n     * @example\n     * // Just write alpha into the frame buffer\n     * device.setColorWrite(false, false, false, true);\n     */\n    setColorWrite(writeRed: boolean, writeGreen: boolean, writeBlue: boolean, writeAlpha: boolean): void;\n    /**\n     * Enables or disables alpha to coverage (WebGL2 only).\n     *\n     * @param {boolean} state - True to enable alpha to coverage and false to disable it.\n     * @ignore\n     */\n    setAlphaToCoverage(state: boolean): void;\n    /**\n     * Sets the output vertex buffer. It will be written to by a shader with transform feedback\n     * varyings.\n     *\n     * @param {VertexBuffer} tf - The output vertex buffer.\n     * @ignore\n     */\n    setTransformFeedbackBuffer(tf: VertexBuffer): void;\n    /**\n     * Toggles the rasterization render state. Useful with transform feedback, when you only need\n     * to process the data without drawing.\n     *\n     * @param {boolean} on - True to enable rasterization and false to disable it.\n     * @ignore\n     */\n    setRaster(on: boolean): void;\n    /**\n     * Toggles the polygon offset render state.\n     *\n     * @param {boolean} on - True to enable polygon offset and false to disable it.\n     * @ignore\n     */\n    setDepthBias(on: boolean): void;\n    /**\n     * Specifies the scale factor and units to calculate depth values. The offset is added before\n     * the depth test is performed and before the value is written into the depth buffer.\n     *\n     * @param {number} constBias - The multiplier by which an implementation-specific value is\n     * multiplied with to create a constant depth offset.\n     * @param {number} slopeBias - The scale factor for the variable depth offset for each polygon.\n     * @ignore\n     */\n    setDepthBiasValues(constBias: number, slopeBias: number): void;\n    /**\n     * Queries whether blending is enabled.\n     *\n     * @returns {boolean} True if blending is enabled and false otherwise.\n     */\n    getBlending(): boolean;\n    /**\n     * Enables or disables blending.\n     *\n     * @param {boolean} blending - True to enable blending and false to disable it.\n     */\n    setBlending(blending: boolean): void;\n    /**\n     * Enables or disables stencil test.\n     *\n     * @param {boolean} enable - True to enable stencil test and false to disable it.\n     */\n    setStencilTest(enable: boolean): void;\n    /**\n     * Configures stencil test for both front and back faces.\n     *\n     * @param {number} func - A comparison function that decides if the pixel should be written,\n     * based on the current stencil buffer value, reference value, and mask value. Can be:\n     *\n     * - {@link FUNC_NEVER}: never pass\n     * - {@link FUNC_LESS}: pass if (ref & mask) < (stencil & mask)\n     * - {@link FUNC_EQUAL}: pass if (ref & mask) == (stencil & mask)\n     * - {@link FUNC_LESSEQUAL}: pass if (ref & mask) <= (stencil & mask)\n     * - {@link FUNC_GREATER}: pass if (ref & mask) > (stencil & mask)\n     * - {@link FUNC_NOTEQUAL}: pass if (ref & mask) != (stencil & mask)\n     * - {@link FUNC_GREATEREQUAL}: pass if (ref & mask) >= (stencil & mask)\n     * - {@link FUNC_ALWAYS}: always pass\n     *\n     * @param {number} ref - Reference value used in comparison.\n     * @param {number} mask - Mask applied to stencil buffer value and reference value before\n     * comparison.\n     */\n    setStencilFunc(func: number, ref: number, mask: number): void;\n    /**\n     * Configures stencil test for front faces.\n     *\n     * @param {number} func - A comparison function that decides if the pixel should be written,\n     * based on the current stencil buffer value, reference value, and mask value. Can be:\n     *\n     * - {@link FUNC_NEVER}: never pass\n     * - {@link FUNC_LESS}: pass if (ref & mask) < (stencil & mask)\n     * - {@link FUNC_EQUAL}: pass if (ref & mask) == (stencil & mask)\n     * - {@link FUNC_LESSEQUAL}: pass if (ref & mask) <= (stencil & mask)\n     * - {@link FUNC_GREATER}: pass if (ref & mask) > (stencil & mask)\n     * - {@link FUNC_NOTEQUAL}: pass if (ref & mask) != (stencil & mask)\n     * - {@link FUNC_GREATEREQUAL}: pass if (ref & mask) >= (stencil & mask)\n     * - {@link FUNC_ALWAYS}: always pass\n     *\n     * @param {number} ref - Reference value used in comparison.\n     * @param {number} mask - Mask applied to stencil buffer value and reference value before comparison.\n     */\n    setStencilFuncFront(func: number, ref: number, mask: number): void;\n    /**\n     * Configures stencil test for back faces.\n     *\n     * @param {number} func - A comparison function that decides if the pixel should be written,\n     * based on the current stencil buffer value, reference value, and mask value. Can be:\n     *\n     * - {@link FUNC_NEVER}: never pass\n     * - {@link FUNC_LESS}: pass if (ref & mask) < (stencil & mask)\n     * - {@link FUNC_EQUAL}: pass if (ref & mask) == (stencil & mask)\n     * - {@link FUNC_LESSEQUAL}: pass if (ref & mask) <= (stencil & mask)\n     * - {@link FUNC_GREATER}: pass if (ref & mask) > (stencil & mask)\n     * - {@link FUNC_NOTEQUAL}: pass if (ref & mask) != (stencil & mask)\n     * - {@link FUNC_GREATEREQUAL}: pass if (ref & mask) >= (stencil & mask)\n     * - {@link FUNC_ALWAYS}: always pass\n     *\n     * @param {number} ref - Reference value used in comparison.\n     * @param {number} mask - Mask applied to stencil buffer value and reference value before comparison.\n     */\n    setStencilFuncBack(func: number, ref: number, mask: number): void;\n    /**\n     * Configures how stencil buffer values should be modified based on the result of depth/stencil\n     * tests. Works for both front and back faces.\n     *\n     * @param {number} fail - Action to take if stencil test is failed. Can be:\n     *\n     * - {@link STENCILOP_KEEP}: don\'t change the stencil buffer value\n     * - {@link STENCILOP_ZERO}: set value to zero\n     * - {@link STENCILOP_REPLACE}: replace value with the reference value (see {@link GraphicsDevice#setStencilFunc})\n     * - {@link STENCILOP_INCREMENT}: increment the value\n     * - {@link STENCILOP_INCREMENTWRAP}: increment the value, but wrap it to zero when it\'s larger\n     * than a maximum representable value\n     * - {@link STENCILOP_DECREMENT}: decrement the value\n     * - {@link STENCILOP_DECREMENTWRAP}: decrement the value, but wrap it to a maximum\n     * representable value, if the current value is 0\n     * - {@link STENCILOP_INVERT}: invert the value bitwise\n     *\n     * @param {number} zfail - Action to take if depth test is failed.  Accepts the same values as\n     * `fail`.\n     * @param {number} zpass - Action to take if both depth and stencil test are passed. Accepts\n     * the same values as `fail`.\n     * @param {number} writeMask - A bit mask applied to the reference value, when written.\n     */\n    setStencilOperation(fail: number, zfail: number, zpass: number, writeMask: number): void;\n    /**\n     * Configures how stencil buffer values should be modified based on the result of depth/stencil\n     * tests. Works for front faces.\n     *\n     * @param {number} fail - Action to take if stencil test is failed. Can be:\n     *\n     * - {@link STENCILOP_KEEP}: don\'t change the stencil buffer value\n     * - {@link STENCILOP_ZERO}: set value to zero\n     * - {@link STENCILOP_REPLACE}: replace value with the reference value (see {@link GraphicsDevice#setStencilFunc})\n     * - {@link STENCILOP_INCREMENT}: increment the value\n     * - {@link STENCILOP_INCREMENTWRAP}: increment the value, but wrap it to zero when it\'s larger\n     * than a maximum representable value\n     * - {@link STENCILOP_DECREMENT}: decrement the value\n     * - {@link STENCILOP_DECREMENTWRAP}: decrement the value, but wrap it to a maximum\n     * representable value, if the current value is 0\n     * - {@link STENCILOP_INVERT}: invert the value bitwise\n     *\n     * @param {number} zfail - Action to take if depth test is failed.  Accepts the same values as\n     * `fail`.\n     * @param {number} zpass - Action to take if both depth and stencil test are passed.  Accepts\n     * the same values as `fail`.\n     * @param {number} writeMask - A bit mask applied to the reference value, when written.\n     */\n    setStencilOperationFront(fail: number, zfail: number, zpass: number, writeMask: number): void;\n    /**\n     * Configures how stencil buffer values should be modified based on the result of depth/stencil\n     * tests. Works for back faces.\n     *\n     * @param {number} fail - Action to take if stencil test is failed. Can be:\n     *\n     * - {@link STENCILOP_KEEP}: don\'t change the stencil buffer value\n     * - {@link STENCILOP_ZERO}: set value to zero\n     * - {@link STENCILOP_REPLACE}: replace value with the reference value (see {@link GraphicsDevice#setStencilFunc})\n     * - {@link STENCILOP_INCREMENT}: increment the value\n     * - {@link STENCILOP_INCREMENTWRAP}: increment the value, but wrap it to zero when it\'s larger\n     * than a maximum representable value\n     * - {@link STENCILOP_DECREMENT}: decrement the value\n     * - {@link STENCILOP_DECREMENTWRAP}: decrement the value, but wrap it to a maximum\n     * representable value, if the current value is 0\n     * - {@link STENCILOP_INVERT}: invert the value bitwise\n     *\n     * @param {number} zfail - Action to take if depth test is failed. Accepts the same values as\n     * `fail`.\n     * @param {number} zpass - Action to take if both depth and stencil test are passed. Accepts\n     * the same values as `fail`.\n     * @param {number} writeMask - A bit mask applied to the reference value, when written.\n     */\n    setStencilOperationBack(fail: number, zfail: number, zpass: number, writeMask: number): void;\n    /**\n     * Configures blending operations. Both source and destination blend modes can take the\n     * following values:\n     *\n     * - {@link BLENDMODE_ZERO}\n     * - {@link BLENDMODE_ONE}\n     * - {@link BLENDMODE_SRC_COLOR}\n     * - {@link BLENDMODE_ONE_MINUS_SRC_COLOR}\n     * - {@link BLENDMODE_DST_COLOR}\n     * - {@link BLENDMODE_ONE_MINUS_DST_COLOR}\n     * - {@link BLENDMODE_SRC_ALPHA}\n     * - {@link BLENDMODE_SRC_ALPHA_SATURATE}\n     * - {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}\n     * - {@link BLENDMODE_DST_ALPHA}\n     * - {@link BLENDMODE_ONE_MINUS_DST_ALPHA}\n     * - {@link BLENDMODE_CONSTANT_COLOR}\n     * - {@link BLENDMODE_ONE_MINUS_CONSTANT_COLOR}\n     * - {@link BLENDMODE_CONSTANT_ALPHA}\n     * - {@link BLENDMODE_ONE_MINUS_CONSTANT_ALPHA}\n     *\n     * @param {number} blendSrc - The source blend function.\n     * @param {number} blendDst - The destination blend function.\n     */\n    setBlendFunction(blendSrc: number, blendDst: number): void;\n    /**\n     * Configures blending operations. Both source and destination blend modes can take the\n     * following values:\n     *\n     * - {@link BLENDMODE_ZERO}\n     * - {@link BLENDMODE_ONE}\n     * - {@link BLENDMODE_SRC_COLOR}\n     * - {@link BLENDMODE_ONE_MINUS_SRC_COLOR}\n     * - {@link BLENDMODE_DST_COLOR}\n     * - {@link BLENDMODE_ONE_MINUS_DST_COLOR}\n     * - {@link BLENDMODE_SRC_ALPHA}\n     * - {@link BLENDMODE_SRC_ALPHA_SATURATE}\n     * - {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}\n     * - {@link BLENDMODE_DST_ALPHA}\n     * - {@link BLENDMODE_ONE_MINUS_DST_ALPHA}\n     *\n     * @param {number} blendSrc - The source blend function.\n     * @param {number} blendDst - The destination blend function.\n     * @param {number} blendSrcAlpha - The separate source blend function for the alpha channel.\n     * @param {number} blendDstAlpha - The separate destination blend function for the alpha channel.\n     */\n    setBlendFunctionSeparate(blendSrc: number, blendDst: number, blendSrcAlpha: number, blendDstAlpha: number): void;\n    /**\n     * Configures the blending equation. The default blend equation is {@link BLENDEQUATION_ADD}.\n     *\n     * @param {number} blendEquation - The blend equation. Can be:\n     *\n     * - {@link BLENDEQUATION_ADD}\n     * - {@link BLENDEQUATION_SUBTRACT}\n     * - {@link BLENDEQUATION_REVERSE_SUBTRACT}\n     * - {@link BLENDEQUATION_MIN}\n     * - {@link BLENDEQUATION_MAX}\n     *\n     * Note that MIN and MAX modes require either EXT_blend_minmax or WebGL2 to work (check\n     * device.extBlendMinmax).\n     */\n    setBlendEquation(blendEquation: number): void;\n    /**\n     * Configures the blending equation. The default blend equation is {@link BLENDEQUATION_ADD}.\n     *\n     * @param {number} blendEquation - The blend equation. Can be:\n     *\n     * - {@link BLENDEQUATION_ADD}\n     * - {@link BLENDEQUATION_SUBTRACT}\n     * - {@link BLENDEQUATION_REVERSE_SUBTRACT}\n     * - {@link BLENDEQUATION_MIN}\n     * - {@link BLENDEQUATION_MAX}\n     *\n     * Note that MIN and MAX modes require either EXT_blend_minmax or WebGL2 to work (check\n     * device.extBlendMinmax).\n     * @param {number} blendAlphaEquation - A separate blend equation for the alpha channel.\n     * Accepts same values as `blendEquation`.\n     */\n    setBlendEquationSeparate(blendEquation: number, blendAlphaEquation: number): void;\n    /**\n     * Set the source and destination blending factors.\n     *\n     * @param {number} r - The red component in the range of 0 to 1. Default value is 0.\n     * @param {number} g - The green component in the range of 0 to 1. Default value is 0.\n     * @param {number} b - The blue component in the range of 0 to 1. Default value is 0.\n     * @param {number} a - The alpha component in the range of 0 to 1. Default value is 0.\n     * @ignore\n     */\n    setBlendColor(r: number, g: number, b: number, a: number): void;\n    /**\n     * Controls how triangles are culled based on their face direction. The default cull mode is\n     * {@link CULLFACE_BACK}.\n     *\n     * @param {number} cullMode - The cull mode to set. Can be:\n     *\n     * - {@link CULLFACE_NONE}\n     * - {@link CULLFACE_BACK}\n     * - {@link CULLFACE_FRONT}\n     * - {@link CULLFACE_FRONTANDBACK}\n     */\n    setCullMode(cullMode: number): void;\n    cullFace: any;\n    /**\n     * Gets the current cull mode.\n     *\n     * @returns {number} The current cull mode.\n     * @ignore\n     */\n    getCullMode(): number;\n    /**\n     * Sets the current index buffer on the graphics device. On subsequent calls to\n     * {@link GraphicsDevice#draw}, the specified index buffer will be used to provide index data\n     * for any indexed primitives.\n     *\n     * @param {IndexBuffer} indexBuffer - The index buffer to assign to the device.\n     */\n    setIndexBuffer(indexBuffer: IndexBuffer): void;\n    /**\n     * Sets the current vertex buffer on the graphics device. On subsequent calls to\n     * {@link GraphicsDevice#draw}, the specified vertex buffer(s) will be used to provide vertex\n     * data for any primitives.\n     *\n     * @param {VertexBuffer} vertexBuffer - The vertex buffer to assign to the device.\n     */\n    setVertexBuffer(vertexBuffer: VertexBuffer): void;\n    /**\n     * Sets the active shader to be used during subsequent draw calls.\n     *\n     * @param {Shader} shader - The shader to set to assign to the device.\n     * @returns {boolean} True if the shader was successfully set, false otherwise.\n     */\n    setShader(shader: Shader): boolean;\n    attributesInvalidated: boolean;\n    /**\n     * Get the supported HDR pixel format.\n     * Note that for WebGL2, PIXELFORMAT_RGB16F and PIXELFORMAT_RGB32F are not renderable according to this:\n     * https://developer.mozilla.org/en-US/docs/Web/API/EXT_color_buffer_float\n     * For WebGL1, only PIXELFORMAT_RGBA16F and PIXELFORMAT_RGBA32F are tested for being renderable.\n     *\n     * @returns {number} The HDR pixel format.\n     * @ignore\n     */\n    getHdrFormat(): number;\n    /**\n     * Queries the maximum number of bones that can be referenced by a shader. The shader\n     * generators (programlib) use this number to specify the matrix array size of the uniform\n     * \'matrix_pose[0]\'. The value is calculated based on the number of available uniform vectors\n     * available after subtracting the number taken by a typical heavyweight shader. If a different\n     * number is required, it can be tuned via {@link GraphicsDevice#setBoneLimit}.\n     *\n     * @returns {number} The maximum number of bones that can be supported by the host hardware.\n     * @ignore\n     */\n    getBoneLimit(): number;\n    /**\n     * Specifies the maximum number of bones that the device can support on the current hardware.\n     * This function allows the default calculated value based on available vector uniforms to be\n     * overridden.\n     *\n     * @param {number} maxBones - The maximum number of bones supported by the host hardware.\n     * @ignore\n     */\n    setBoneLimit(maxBones: number): void;\n    /**\n     * Frees memory from all shaders ever allocated with this device.\n     *\n     * @ignore\n     */\n    clearShaderCache(): void;\n    /**\n     * Frees memory from all vertex array objects ever allocated with this device.\n     *\n     * @ignore\n     */\n    clearVertexArrayObjectCache(): void;\n    /**\n     * Removes a shader from the cache.\n     *\n     * @param {Shader} shader - The shader to remove from the cache.\n     * @ignore\n     */\n    removeShaderFromCache(shader: Shader): void;\n    /**\n     * Check if high precision floating-point textures are supported.\n     *\n     * @type {boolean}\n     */\n    get textureFloatHighPrecision(): boolean;\n    /**\n     * Check if texture with half float format can be updated with data.\n     *\n     * @type {boolean}\n     */\n    get textureHalfFloatUpdatable(): boolean;\n}\n\ndeclare class SkinBatchInstance extends SkinInstance {\n    constructor(device: any, nodes: any, rootNode: any);\n    device: any;\n    rootNode: any;\n    bones: any;\n}\n\n/**\n * Holds stencil test settings.\n *\n * @property {number} func Sets stencil test function. See {@link GraphicsDevice#setStencilFunc}.\n * @property {number} ref Sets stencil test reference value. See\n * {@link GraphicsDevice#setStencilFunc}.\n * @property {number} fail Sets operation to perform if stencil test is failed. See\n * {@link GraphicsDevice#setStencilOperation}.\n * @property {number} zfail Sets operation to perform if depth test is failed. See\n * {@link GraphicsDevice#setStencilOperation}.\n * @property {number} zpass Sets operation to perform if both stencil and depth test are passed.\n * See {@link GraphicsDevice#setStencilOperation}.\n * @property {number} readMask Sets stencil test reading mask. See\n * {@link GraphicsDevice#setStencilFunc}.\n * @property {number} writeMask Sets stencil test writing mask. See\n * {@link GraphicsDevice#setStencilOperation}.\n */\ndeclare class StencilParameters {\n    /**\n     * Create a new StencilParameters instance.\n     *\n     * @param {object} options - Options object to configure the stencil parameters.\n     */\n    constructor(options: object);\n    func: any;\n    ref: any;\n    readMask: any;\n    writeMask: any;\n    fail: any;\n    zfail: any;\n    zpass: any;\n    clone(): StencilParameters;\n}\n\n/**\n * Callback function that the {@link AnimEvaluator } uses to set final animation values. These\n * callbacks are stored in {@link AnimTarget } instances which are constructed by an\n * {@link AnimBinder }.\n */\ntype AnimSetter = (value: number[]) => any;\n/**\n * Callback function that the {@link AnimEvaluator} uses to set final animation values. These\n * callbacks are stored in {@link AnimTarget} instances which are constructed by an\n * {@link AnimBinder}.\n *\n * @callback AnimSetter\n * @param {number[]} value - Updated animation value.\n * @ignore\n */\n/**\n * Stores the information required by {@link AnimEvaluator} for updating a target value.\n *\n * @ignore\n */\ndeclare class AnimTarget {\n    /**\n     * Create a new AnimTarget instance.\n     *\n     * @param {AnimSetter} func - This function will be called when a new animation value is output\n     * by the {@link AnimEvaluator}.\n     * @param {\'vector\'|\'quaternion\'} type - The type of animation data this target expects.\n     * @param {number} components - The number of components on this target (this should ideally\n     * match the number of components found on all attached animation curves).\n     * @param {string} targetPath - The path to the target value.\n     */\n    constructor(func: AnimSetter, type: \'vector\' | \'quaternion\', components: number, targetPath: string);\n    _set: any;\n    _get: any;\n    _type: "quaternion" | "vector";\n    _components: number;\n    _targetPath: string;\n    _isTransform: boolean;\n    get set(): any;\n    get get(): any;\n    get type(): "quaternion" | "vector";\n    get components(): number;\n    get targetPath(): string;\n    get isTransform(): boolean;\n}\n\n\n/** @typedef {import(\'../evaluator/anim-target.js\').AnimTarget} AnimTarget */\n/**\n * This interface is used by {@link AnimEvaluator} to resolve unique animation target path strings\n * into instances of {@link AnimTarget}.\n *\n * @ignore\n */\ndeclare class AnimBinder {\n    static joinPath(pathSegments: any, character: any): any;\n    static splitPath(path: any, character: any): string[];\n    /**\n     * Converts a locator array into its string version.\n     *\n     * @param {string|Array} entityPath - The entity location in the scene defined as an array or\n     * string path.\n     * @param {string} component - The component of the entity the property is located under.\n     * @param {string|Array} propertyPath - The property location in the entity defined as an array\n     * or string path.\n     * @returns {string} The locator encoded as a string.\n     * @example\n     * // returns \'spotLight/light/color.r\'\n     * encode([\'spotLight\'], \'light\', [\'color\', \'r\']);\n     */\n    static encode(entityPath: string | any[], component: string, propertyPath: string | any[]): string;\n    /**\n     * Resolve the provided target path and return an instance of {@link AnimTarget} which will\n     * handle setting the value, or return null if no such target exists.\n     *\n     * @param {string} path - The animation curve path to resolve.\n     * @returns {AnimTarget|null} - Returns the target instance on success and null otherwise.\n     */\n    resolve(path: string): AnimTarget | null;\n    /**\n     * Called when the {@link AnimEvaluator} no longer has a curve driving the given key.\n     *\n     * @param {string} path - The animation curve path which is no longer driven.\n     */\n    unresolve(path: string): void;\n    /**\n     * Called by {@link AnimEvaluator} once a frame after animation updates are done.\n     *\n     * @param {number} deltaTime - Amount of time that passed in the current update.\n     */\n    update(deltaTime: number): void;\n}\n\n/**\n * Wraps a set of data used in animation.\n *\n * @ignore\n */\ndeclare class AnimData {\n    /**\n     * Create a new animation AnimData instance.\n     *\n     * @param {number} components - Specifies how many components make up an element of data. For\n     * example, specify 3 for a set of 3-dimensional vectors. The number of elements in data array\n     * must be a multiple of components.\n     * @param {Float32Array|number[]} data - The set of data.\n     */\n    constructor(components: number, data: Float32Array | number[]);\n    _components: number;\n    _data: number[] | Float32Array;\n    /**\n     * Gets the number of components that make up an element.\n     *\n     * @type {number}\n     */\n    get components(): number;\n    /**\n     * Gets the data.\n     *\n     * @type {Float32Array|number[]}\n     */\n    get data(): number[] | Float32Array;\n}\n\n/**\n * Animation curve links an input data set to an output data set and defines the interpolation\n * method to use.\n *\n * @ignore\n */\ndeclare class AnimCurve {\n    /**\n     * Create a new animation curve.\n     *\n     * @param {string[]} paths - Array of path strings identifying the targets of this curve, for\n     * example "rootNode.translation".\n     * @param {number} input - Index of the curve which specifies the key data.\n     * @param {number} output - Index of the curve which specifies the value data.\n     * @param {number} interpolation - The interpolation method to use. One of the following:\n     *\n     * - {@link INTERPOLATION_STEP}\n     * - {@link INTERPOLATION_LINEAR}\n     * - {@link INTERPOLATION_CUBIC}\n     */\n    constructor(paths: string[], input: number, output: number, interpolation: number);\n    _paths: string[];\n    _input: number;\n    _output: number;\n    _interpolation: number;\n    /**\n     * The list of paths which identify targets of this curve.\n     *\n     * @type {string[]}\n     */\n    get paths(): string[];\n    /**\n     * The index of the AnimTrack input which contains the key data for this curve.\n     *\n     * @type {number}\n     */\n    get input(): number;\n    /**\n     * The index of the AnimTrack input which contains the key data for this curve.\n     *\n     * @type {number}\n     */\n    get output(): number;\n    /**\n     * The interpolation method used by this curve.\n     *\n     * @type {number}\n     */\n    get interpolation(): number;\n}\n\n/**\n * AnimEvents stores a sorted array of animation events which should fire sequentially during the\n * playback of an pc.AnimTrack.\n */\ndeclare class AnimEvents {\n    /**\n     * Create a new AnimEvents instance.\n     *\n     * @param {object[]} events - An array of animation events.\n     * @example\n     * const events = new pc.AnimEvents([\n     *     {\n     *         name: \'my_event\',\n     *         time: 1.3, // given in seconds\n     *         // any additional properties added are optional and will be available in the EventHandler callback\'s event object\n     *         myProperty: \'test\',\n     *         myOtherProperty: true\n     *     }\n     * ]);\n     * animTrack.events = events;\n     */\n    constructor(events: object[]);\n    _events: any[];\n    get events(): any[];\n}\n\n\n\n/** @typedef {import(\'./anim-curve.js\').AnimCurve} AnimCurve */\n/** @typedef {import(\'./anim-data.js\').AnimData} AnimData */\n/**\n * An AnimTrack stores the curve data necessary to animate a set of target nodes. It can be linked\n * to the nodes it should animate using the {@link AnimComponent#assignAnimation} method.\n */\ndeclare class AnimTrack {\n    /**\n     * Create a new AnimTrack instance.\n     *\n     * @param {string} name - The track name.\n     * @param {number} duration - The duration of the track in seconds.\n     * @param {AnimData[]} inputs - List of curve key data.\n     * @param {AnimData[]} outputs - List of curve value data.\n     * @param {AnimCurve[]} curves - The list of curves.\n     * @param {AnimEvents} animEvents - A sequence of animation events.\n     * @hideconstructor\n     */\n    constructor(name: string, duration: number, inputs: AnimData[], outputs: AnimData[], curves: AnimCurve[], animEvents?: AnimEvents);\n    _name: string;\n    _duration: number;\n    _inputs: AnimData[];\n    _outputs: AnimData[];\n    _curves: AnimCurve[];\n    _animEvents: AnimEvents;\n    /**\n     * Gets the name of the AnimTrack.\n     *\n     * @type {string}\n     */\n    get name(): string;\n    /**\n     * Gets the duration of the AnimTrack.\n     *\n     * @type {number}\n     */\n    get duration(): number;\n    /**\n     * Gets the list of curve key data contained in the AnimTrack.\n     *\n     * @type {AnimData[]}\n     */\n    get inputs(): AnimData[];\n    /**\n     * Gets the list of curve values contained in the AnimTrack.\n     *\n     * @type {AnimData[]}\n     */\n    get outputs(): AnimData[];\n    /**\n     * Gets the list of curves contained in the AnimTrack.\n     *\n     * @type {AnimCurve[]}\n     */\n    get curves(): AnimCurve[];\n    /**\n     * The animation events that will fire during the playback of this anim track.\n     *\n     * @type {AnimEvents}\n     */\n    set events(arg: any[]);\n    get events(): any[];\n    eval(time: any, snapshot: any): void;\n}\n\n/**\n * Internal cache data for the evaluation of a single curve timeline.\n *\n * @ignore\n */\ndeclare class AnimCache {\n    _left: number;\n    _right: number;\n    _len: number;\n    _recip: number;\n    _p0: number;\n    _p1: number;\n    _t: number;\n    _hermite: {\n        valid: boolean;\n        p0: number;\n        m0: number;\n        p1: number;\n        m1: number;\n    };\n    update(time: any, input: any): void;\n    _findKey(time: any, input: any): number;\n    eval(result: any, interpolation: any, output: any): void;\n}\n\n\n/** @typedef {import(\'./anim-track.js\').AnimTrack} AnimTrack */\n/**\n * AnimSnapshot stores the state of an animation track at a particular time.\n *\n * @ignore\n */\ndeclare class AnimSnapshot {\n    /**\n     * Create a new animation snapshot.\n     *\n     * @param {AnimTrack} animTrack - The source track.\n     */\n    constructor(animTrack: AnimTrack);\n    _name: string;\n    _time: number;\n    _cache: AnimCache[];\n    _results: number[][];\n}\n\n\n/** @typedef {import(\'./anim-track.js\').AnimTrack} AnimTrack */\n/**\n * AnimClip wraps the running state of an animation track. It contains and update the animation\n * \'cursor\' and performs looping logic.\n *\n * @ignore\n */\ndeclare class AnimClip {\n    /**\n     * Create a new animation clip.\n     *\n     * @param {AnimTrack} track - The animation data.\n     * @param {number} time - The initial time of the clip.\n     * @param {number} speed - Speed of the animation playback.\n     * @param {boolean} playing - true if the clip is playing and false otherwise.\n     * @param {boolean} loop - Whether the clip should loop.\n     * @param {Function} eventHandler - The handler to call when an event is fired by the clip.\n     */\n    constructor(track: AnimTrack, time: number, speed: number, playing: boolean, loop: boolean, eventHandler: Function);\n    _name: string;\n    _track: AnimTrack;\n    _snapshot: AnimSnapshot;\n    _playing: boolean;\n    _time: number;\n    _speed: number;\n    _loop: boolean;\n    _blendWeight: number;\n    _blendOrder: number;\n    _eventHandler: Function;\n    _eventCursor: number;\n    set name(arg: string);\n    get name(): string;\n    get track(): AnimTrack;\n    get snapshot(): AnimSnapshot;\n    set time(arg: number);\n    get time(): number;\n    set speed(arg: number);\n    get speed(): number;\n    set loop(arg: boolean);\n    get loop(): boolean;\n    set blendWeight(arg: number);\n    get blendWeight(): number;\n    set blendOrder(arg: number);\n    get blendOrder(): number;\n    set eventCursor(arg: number);\n    get eventCursor(): number;\n    activeEventsForFrame(frameStartTime: any, frameEndTime: any): void;\n    _update(deltaTime: any): void;\n    play(): void;\n    stop(): void;\n    pause(): void;\n    resume(): void;\n    reset(): void;\n}\n\n\n\n/** @typedef {import(\'../binder/anim-binder.js\').AnimBinder} AnimBinder */\n/** @typedef {import(\'./anim-clip.js\').AnimClip} AnimClip */\n/**\n * AnimEvaluator blends multiple sets of animation clips together.\n *\n * @ignore\n */\ndeclare class AnimEvaluator {\n    static _dot(a: any, b: any): number;\n    static _normalize(a: any): void;\n    static _set(a: any, b: any, type: any): void;\n    static _blendVec(a: any, b: any, t: any, additive: any): void;\n    static _blendQuat(a: any, b: any, t: any, additive: any): void;\n    static _blend(a: any, b: any, t: any, type: any, additive: any): void;\n    static _stableSort(a: any, lessFunc: any): void;\n    /**\n     * Create a new animation evaluator.\n     *\n     * @param {AnimBinder} binder - interface resolves curve paths to instances of {@link AnimTarget}.\n     */\n    constructor(binder: AnimBinder);\n    _binder: AnimBinder;\n    _clips: any[];\n    _inputs: any[];\n    _outputs: any[];\n    _targets: {};\n    /**\n     * The list of animation clips.\n     *\n     * @type {AnimClip[]}\n     */\n    get clips(): AnimClip[];\n    /**\n     * Add a clip to the evaluator.\n     *\n     * @param {AnimClip} clip - The clip to add to the evaluator.\n     */\n    addClip(clip: AnimClip): void;\n    /**\n     * Remove a clip from the evaluator.\n     *\n     * @param {number} index - Index of the clip to remove.\n     */\n    removeClip(index: number): void;\n    /**\n     * Remove all clips from the evaluator.\n     */\n    removeClips(): void;\n    /**\n     * Returns the first clip which matches the given name, or null if no such clip was found.\n     *\n     * @param {string} name - Name of the clip to find.\n     * @returns {AnimClip|null} - The clip with the given name or null if no such clip was found.\n     */\n    findClip(name: string): AnimClip | null;\n    rebind(): void;\n    assignMask(mask: any): any;\n    /**\n     * Evaluator frame update function. All the attached {@link AnimClip}s are evaluated, blended\n     * and the results set on the {@link AnimTarget}.\n     *\n     * @param {number} deltaTime - The amount of time that has passed since the last update, in\n     * seconds.\n     */\n    update(deltaTime: number): void;\n}\n\n/**\n * Implementation of {@link AnimBinder} for animating a skeleton in the graph-node hierarchy.\n *\n * @implements {AnimBinder}\n * @ignore\n */\ndeclare class DefaultAnimBinder implements AnimBinder {\n    static createAnimTarget(func: any, type: any, valueCount: any, node: any, propertyPath: any, componentType: any): AnimTarget;\n    constructor(graph: any);\n    graph: any;\n    _mask: any;\n    nodes: {};\n    targetCache: {};\n    visitedFallbackGraphPaths: {};\n    nodeCounts: {};\n    activeNodes: any[];\n    handlers: {\n        localPosition: (node: any) => AnimTarget;\n        localRotation: (node: any) => AnimTarget;\n        localScale: (node: any) => AnimTarget;\n        weights: (node: any) => AnimTarget;\n        materialTexture: (node: any, textureName: any) => AnimTarget;\n    };\n    _isPathInMask: (path: any, checkMaskValue: any) => boolean;\n    _isPathActive(path: any): boolean;\n    findNode(path: any): any;\n    resolve(path: any): any;\n    unresolve(path: any): void;\n    update(deltaTime: any): void;\n    assignMask(mask: any): boolean;\n}\n\n/**\n * AnimTransitions represent connections in the controllers state graph between AnimStates. During\n * each frame, the controller tests to see if any of the AnimTransitions have the current AnimState\n * as their source (from) state. If so and the AnimTransitions parameter based conditions are met,\n * the controller will transition to the destination state.\n *\n * @ignore\n */\ndeclare class AnimTransition {\n    /**\n     * Create a new AnimTransition.\n     *\n     * @param {object} options - Options.\n     * @param {string} options.from - The state that this transition will exit from.\n     * @param {string} options.to - The state that this transition will transition to.\n     * @param {number} options.time - The duration of the transition in seconds. Defaults to 0.\n     * @param {number} options.priority - Used to sort all matching transitions in ascending order.\n     * The first transition in the list will be selected. Defaults to 0.\n     * @param {object[]} options.conditions - A list of conditions which must pass for this\n     * transition to be used. Defaults to [].\n     * @param {number} options.exitTime - If provided, this transition will only be active for the\n     * exact frame during which the source states progress passes the time specified. Given as a\n     * normalized value of the source states duration. Values less than 1 will be checked every\n     * animation loop. Defaults to null.\n     * @param {number} options.transitionOffset - If provided, the destination state will begin\n     * playing its animation at this time. Given in normalized time, based on the state\'s duration\n     * and must be between 0 and 1. Defaults to null.\n     * @param {string} options.interruptionSource - Defines whether another transition can\n     * interrupt this one and which of the current or previous states transitions can do so. One of\n     * pc.ANIM_INTERRUPTION_*. Defaults to pc.ANIM_INTERRUPTION_NONE.\n     */\n    constructor({ from, to, time, priority, conditions, exitTime, transitionOffset, interruptionSource }: {\n        from: string;\n        to: string;\n        time: number;\n        priority: number;\n        conditions: object[];\n        exitTime: number;\n        transitionOffset: number;\n        interruptionSource: string;\n    });\n    _from: string;\n    _to: string;\n    _time: number;\n    _priority: number;\n    _conditions: any[];\n    _exitTime: number;\n    _transitionOffset: number;\n    _interruptionSource: string;\n    get from(): string;\n    set to(arg: string);\n    get to(): string;\n    get time(): number;\n    get priority(): number;\n    get conditions(): any[];\n    get exitTime(): number;\n    get transitionOffset(): number;\n    get interruptionSource(): string;\n    get hasExitTime(): boolean;\n}\n\n\n\n/** @typedef {import(\'../../core/event-handler.js\').EventHandler} EventHandler */\n/** @typedef {import(\'../evaluator/anim-evaluator.js\').AnimEvaluator} AnimEvaluator */\n/**\n * The AnimController manages the animations for its entity, based on the provided state graph and\n * parameters. Its update method determines which state the controller should be in based on the\n * current time, parameters and available states / transitions. It also ensures the AnimEvaluator\n * is supplied with the correct animations, based on the currently active state.\n *\n * @ignore\n */\ndeclare class AnimController {\n    /**\n     * Create a new AnimController.\n     *\n     * @param {AnimEvaluator} animEvaluator - The animation evaluator used to blend all current\n     * playing animation keyframes and update the entities properties based on the current\n     * animation values.\n     * @param {object[]} states - The list of states used to form the controller state graph.\n     * @param {object[]} transitions - The list of transitions used to form the controller state\n     * graph.\n     * @param {object[]} parameters - The anim components parameters.\n     * @param {boolean} activate - Determines whether the anim controller should automatically play\n     * once all {@link AnimNodes} are assigned animations.\n     * @param {EventHandler} eventHandler - The event handler which should be notified with anim\n     * events.\n     * @param {Set} consumedTriggers - Used to set triggers back to their default state after they\n     * have been consumed by a transition.\n     */\n    constructor(animEvaluator: AnimEvaluator, states: object[], transitions: object[], parameters: object[], activate: boolean, eventHandler: EventHandler, consumedTriggers: Set<any>);\n    _animEvaluator: AnimEvaluator;\n    _states: {};\n    _stateNames: any[];\n    _eventHandler: EventHandler;\n    _consumedTriggers: Set<any>;\n    _transitions: AnimTransition[];\n    _findTransitionsFromStateCache: {};\n    _findTransitionsBetweenStatesCache: {};\n    _parameters: any[];\n    _previousStateName: any;\n    _activeStateName: string;\n    _playing: boolean;\n    _activate: boolean;\n    _currTransitionTime: number;\n    _totalTransitionTime: number;\n    _isTransitioning: boolean;\n    _transitionInterruptionSource: string;\n    _transitionPreviousStates: any[];\n    _timeInState: number;\n    _timeInStateBefore: number;\n    get animEvaluator(): AnimEvaluator;\n    set activeState(arg: any);\n    get activeState(): any;\n    get activeStateName(): string;\n    get activeStateAnimations(): any;\n    set previousState(arg: any);\n    get previousState(): any;\n    get previousStateName(): any;\n    get playable(): boolean;\n    set playing(arg: boolean);\n    get playing(): boolean;\n    get activeStateProgress(): number;\n    get activeStateDuration(): number;\n    set activeStateCurrentTime(arg: number);\n    get activeStateCurrentTime(): number;\n    get transitioning(): boolean;\n    get transitionProgress(): number;\n    get states(): any[];\n    assignMask(mask: any): any;\n    _findState(stateName: any): any;\n    _getActiveStateProgressForTime(time: any): number;\n    _findTransitionsFromState(stateName: any): any;\n    _findTransitionsBetweenStates(sourceStateName: any, destinationStateName: any): any;\n    _transitionHasConditionsMet(transition: any): boolean;\n    _findTransition(from: any, to: any): any;\n    updateStateFromTransition(transition: any): void;\n    _transitionToState(newStateName: any): void;\n    assignAnimation(pathString: any, animTrack: any, speed: any, loop: any): void;\n    removeNodeAnimations(nodeName: any): boolean;\n    play(stateName: any): void;\n    pause(): void;\n    reset(): void;\n    rebind(): void;\n    update(dt: any): void;\n    findParameter(name: any): any;\n}\n\n/**\n * An asset resource which represents an anim state graph. It can be loaded into an anim component using the {@link AnimComponent#loadStateGraph} method.\n *\n * ## Usage\n * Scripts can retrieve an AnimStateGraph instance from assets of type \'animstategraph\'. An AnimStateGraph can then be loaded into an anim component as follows:\n * ```javascript\n * const animStateGraph = app.assets.get(ASSET_ID).resource;\n * const entity = new pc.Entity();\n * entity.addComponent(\'anim\');\n * entity.anim.loadStateGraph(animStateGraph);\n * ```\n */\ndeclare class AnimStateGraph {\n    /**\n     * Create an AnimStateGraph instance from JSON data.\n     *\n     * @param {object} data - The JSON data to create the AnimStateGraph from.\n     * @hideconstructor\n     */\n    constructor(data: object);\n    _layers: any;\n    _parameters: {};\n    get parameters(): {};\n    get layers(): any;\n}\n\n\n\n/**\n * A SoundInstance3d plays a {@link Sound} in 3D.\n *\n * @augments SoundInstance\n */\ndeclare class SoundInstance3d extends SoundInstance {\n    /**\n     * Create a new SoundInstance3d instance.\n     *\n     * @param {SoundManager} manager - The sound manager.\n     * @param {Sound} sound - The sound to play.\n     * @param {object} options - Options for the instance.\n     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.\n     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.\n     * @param {boolean} [options.loop=false] - Whether the sound should loop when it reaches the\n     * end or not.\n     * @param {number} [options.startTime=0] - The time from which the playback will start. Default\n     * is 0 to start at the beginning.\n     * @param {number} [options.duration=null] - The total time after the startTime when playback\n     * will stop or restart if loop is true.\n     * @param {Vec3} [options.position=null] - The position of the sound in 3D space.\n     * @param {string} [options.distanceModel=DISTANCE_LINEAR] - Determines which algorithm to use\n     * to reduce the volume of the audio as it moves away from the listener. Can be:\n     *\n     * - {@link DISTANCE_LINEAR}\n     * - {@link DISTANCE_INVERSE}\n     * - {@link DISTANCE_EXPONENTIAL}\n     *\n     * Default is {@link DISTANCE_LINEAR}.\n     * @param {number} [options.refDistance=1] - The reference distance for reducing volume as the\n     * sound source moves further from the listener.\n     * @param {number} [options.maxDistance=10000] - The maximum distance from the listener at which\n     * audio falloff stops. Note the volume of the audio is not 0 after this distance, but just\n     * doesn\'t fall off anymore.\n     * @param {number} [options.rollOffFactor=1] - The factor used in the falloff equation.\n     */\n    constructor(manager: SoundManager, sound: Sound, options?: {\n        volume?: number;\n        pitch?: number;\n        loop?: boolean;\n        startTime?: number;\n        duration?: number;\n        position?: Vec3;\n        distanceModel?: string;\n        refDistance?: number;\n        maxDistance?: number;\n        rollOffFactor?: number;\n    });\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private _position;\n    /**\n     * @type {Vec3}\n     * @private\n     */\n    private _velocity;\n    /**\n     * The position of the sound in 3D space.\n     *\n     * @type {Vec3}\n     */\n    set position(arg: Vec3);\n    get position(): Vec3;\n    /**\n     * The maximum distance from the listener at which audio falloff stops. Note the volume of the\n     * audio is not 0 after this distance, but just doesn\'t fall off anymore.\n     *\n     * @type {number}\n     */\n    set maxDistance(arg: number);\n    get maxDistance(): number;\n    /**\n     * The reference distance for reducing volume as the sound source moves further from the\n     * listener.\n     *\n     * @type {number}\n     */\n    set refDistance(arg: number);\n    get refDistance(): number;\n    /**\n     * The factor used in the falloff equation.\n     *\n     * @type {number}\n     */\n    set rollOffFactor(arg: number);\n    get rollOffFactor(): number;\n    /**\n     * Determines which algorithm to use to reduce the volume of the audio as it moves away from\n     * the listener. Can be:\n     *\n     * - {@link DISTANCE_LINEAR}\n     * - {@link DISTANCE_INVERSE}\n     * - {@link DISTANCE_EXPONENTIAL}\n     *\n     * Default is {@link DISTANCE_LINEAR}.\n     *\n     * @type {string}\n     */\n    set distanceModel(arg: DistanceModelType);\n    get distanceModel(): DistanceModelType;\n    panner: PannerNode;\n    /**\n     * The velocity of the sound.\n     *\n     * @type {Vec3}\n     * @deprecated\n     * @ignore\n     */\n    set velocity(arg: Vec3);\n    get velocity(): Vec3;\n}\n\n/**\n * Represents the resource of a Bundle Asset, which contains an index that maps URLs to blob URLs.\n *\n * @ignore\n */\ndeclare class Bundle {\n    /**\n     * Create a new Bundle instance.\n     *\n     * @param {object[]} files - An array of objects that have a name field and contain a\n     * getBlobUrl() function.\n     */\n    constructor(files: object[]);\n    _blobUrls: {};\n    /**\n     * Returns true if the specified URL exists in the loaded bundle.\n     *\n     * @param {string} url - The original file URL. Make sure you have called decodeURIComponent on\n     * the URL first.\n     * @returns {boolean} True of false.\n     */\n    hasBlobUrl(url: string): boolean;\n    /**\n     * Returns a blob URL for the specified URL.\n     *\n     * @param {string} url - The original file URL. Make sure you have called decodeURIComponent on\n     * the URL first.\n     * @returns {string} A blob URL.\n     */\n    getBlobUrl(url: string): string;\n    /**\n     * Destroys the bundle and frees up blob URLs.\n     */\n    destroy(): void;\n}\n\n\n/** @typedef {import(\'./handler.js\').ResourceHandler} ResourceHandler */\n/**\n * Resource handler used for loading {@link AnimClip} resources.\n *\n * @implements {ResourceHandler}\n * @ignore\n */\ndeclare class AnimClipHandler implements ResourceHandler {\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): AnimTrack;\n    patch(asset: any, assets: any): void;\n}\n\n\n/** @typedef {import(\'./handler.js\').ResourceHandler} ResourceHandler */\n/**\n * Resource handler used for loading {@link AnimStateGraph} resources.\n *\n * @implements {ResourceHandler}\n * @ignore\n */\ndeclare class AnimStateGraphHandler implements ResourceHandler {\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): AnimStateGraph;\n    patch(asset: any, assets: any): void;\n}\n\n\n/** @typedef {import(\'./handler.js\').ResourceHandler} ResourceHandler */\n/**\n * Resource handler used for loading {@link Animation} resources.\n *\n * @implements {ResourceHandler}\n */\ndeclare class AnimationHandler implements ResourceHandler {\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): any;\n    patch(asset: any, assets: any): void;\n    _parseAnimationV3(data: any): Animation$1;\n    _parseAnimationV4(data: any): Animation$1;\n}\n\n\n\n/**\n * Resource handler used for loading {@link Sound} resources.\n *\n * @implements {ResourceHandler}\n */\ndeclare class AudioHandler implements ResourceHandler {\n    /**\n     * Create a new AudioHandler instance.\n     *\n     * @param {SoundManager} manager - The sound manager.\n     */\n    constructor(manager: SoundManager);\n    manager: SoundManager;\n    maxRetries: number;\n    _isSupported(url: any): boolean;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): any;\n    patch(asset: any, assets: any): void;\n    /**\n     * Loads an audio asset using an AudioContext by URL and calls success or error with the\n     * created resource or error respectively.\n     *\n     * @param {string} url - The url of the audio asset.\n     * @param {Function} success - Function to be called if the audio asset was loaded or if we\n     * just want to continue without errors even if the audio is not loaded.\n     * @param {Function} error - Function to be called if there was an error while loading the\n     * audio asset.\n     * @private\n     */\n    private _createSound;\n}\n\ndeclare class BinaryHandler {\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): any;\n    patch(asset: any, assets: any): void;\n}\n\n\n\n/** @typedef {import(\'../asset/asset-registry.js\').AssetRegistry} AssetRegistry */\n/** @typedef {import(\'./handler.js\').ResourceHandler} ResourceHandler */\n/**\n * Loads Bundle Assets.\n *\n * @implements {ResourceHandler}\n * @ignore\n */\ndeclare class BundleHandler implements ResourceHandler {\n    /**\n     * Create a new BundleHandler instance.\n     *\n     * @param {AssetRegistry} assets - The asset registry.\n     */\n    constructor(assets: AssetRegistry);\n    _assets: AssetRegistry;\n    _worker: any;\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    _untar(response: any, callback: any): void;\n    open(url: any, data: any): Bundle;\n    patch(asset: any, assets: any): void;\n}\n\n\n\n\n\n/** @typedef {import(\'../asset/asset-registry.js\').AssetRegistry} AssetRegistry */\n/** @typedef {import(\'../graphics/graphics-device.js\').GraphicsDevice} GraphicsDevice */\n/** @typedef {import(\'./handler.js\').ResourceHandler} ResourceHandler */\n/** @typedef {import(\'./loader.js\').ResourceLoader} ResourceLoader */\n/**\n * Resource handler used for loading cubemap {@link Texture} resources.\n *\n * @implements {ResourceHandler}\n */\ndeclare class CubemapHandler implements ResourceHandler {\n    /**\n     * Create a new CubemapHandler instance.\n     *\n     * @param {GraphicsDevice} device - The graphics device.\n     * @param {AssetRegistry} assets - The asset registry.\n     * @param {ResourceLoader} loader - The resource loader.\n     */\n    constructor(device: GraphicsDevice, assets: AssetRegistry, loader: ResourceLoader);\n    _device: GraphicsDevice;\n    _registry: AssetRegistry;\n    _loader: ResourceLoader;\n    load(url: any, callback: any, asset: any): void;\n    open(url: any, data: any, asset: any): any;\n    patch(asset: any, registry: any): void;\n    getAssetIds(cubemapAsset: any): any[];\n    compareAssetIds(assetIdA: any, assetIdB: any): boolean;\n    update(cubemapAsset: any, assetIds: any, assets: any): void;\n    cmpArrays(arr1: any, arr2: any): boolean;\n    resolveId(value: any): any;\n    loadAssets(cubemapAsset: any, callback: any): void;\n}\n\ndeclare class FolderHandler {\n    load(url: any, callback: any): void;\n    open(url: any, data: any): any;\n}\n\n\n\n/**\n * Resource handler used for loading {@link Font} resources.\n *\n * @implements {ResourceHandler}\n */\ndeclare class FontHandler implements ResourceHandler {\n    /**\n     * Create a new FontHandler instance.\n     *\n     * @param {ResourceLoader} loader - The resource loader.\n     */\n    constructor(loader: ResourceLoader);\n    _loader: ResourceLoader;\n    maxRetries: number;\n    load(url: any, callback: any, asset: any): void;\n    _loadTextures(url: any, data: any, callback: any): void;\n    open(url: any, data: any, asset: any): Font;\n    patch(asset: any, assets: any): void;\n}\n\ndeclare class HierarchyHandler {\n    constructor(app: any);\n    _app: any;\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): Entity;\n}\n\ndeclare class HtmlHandler {\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): any;\n    patch(asset: any, assets: any): void;\n}\n\ndeclare class JsonHandler {\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): any;\n    patch(asset: any, assets: any): void;\n}\n\ndeclare class StandardMaterialValidator {\n    removeInvalid: boolean;\n    valid: boolean;\n    enumValidators: {\n        occludeSpecular: (value: any) => boolean;\n        cull: (value: any) => boolean;\n        blendType: (value: any) => boolean;\n        depthFunc: (value: any) => boolean;\n        shadingModel: (value: any) => boolean;\n    };\n    setInvalid(key: any, data: any): void;\n    validate(data: any): boolean;\n    _createEnumValidator(values: any): (value: any) => boolean;\n}\n\n/**\n * Convert incoming JSON data into a {@link StandardMaterial}.\n *\n * @ignore\n */\ndeclare class JsonStandardMaterialParser {\n    _validator: StandardMaterialValidator;\n    parse(input: any): StandardMaterial;\n    /**\n     * Initialize material properties from the material data block e.g. Loading from server.\n     *\n     * @param {StandardMaterial} material - The material to be initialized.\n     * @param {object} data - The data block that is used to initialize.\n     */\n    initialize(material: StandardMaterial, data: object): void;\n    migrate(data: any): any;\n    _validate(data: any): any;\n}\n\n\n\n/**\n * Resource handler used for loading {@link Material} resources.\n *\n * @implements {ResourceHandler}\n */\ndeclare class MaterialHandler implements ResourceHandler {\n    /**\n     * Create a new MaterialHandler instance.\n     *\n     * @param {Application} app - The running {@link Application}.\n     */\n    constructor(app: Application);\n    _assets: AssetRegistry;\n    _device: GraphicsDevice;\n    _placeholderTextures: {};\n    _parser: JsonStandardMaterialParser;\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): StandardMaterial;\n    _createPlaceholders(): void;\n    patch(asset: any, assets: any): void;\n    _onAssetUnload(asset: any): void;\n    _assignTexture(parameterName: any, materialAsset: any, texture: any): void;\n    _getPlaceholderTexture(parameterName: any): any;\n    _assignPlaceholderTexture(parameterName: any, materialAsset: any): void;\n    _onTextureLoad(parameterName: any, materialAsset: any, textureAsset: any): void;\n    _onTextureAdd(parameterName: any, materialAsset: any, textureAsset: any): void;\n    _onTextureRemoveOrUnload(parameterName: any, materialAsset: any, textureAsset: any): void;\n    _assignCubemap(parameterName: any, materialAsset: any, textures: any): void;\n    _onCubemapLoad(parameterName: any, materialAsset: any, cubemapAsset: any): void;\n    _onCubemapAdd(parameterName: any, materialAsset: any, cubemapAsset: any): void;\n    _onCubemapRemoveOrUnload(parameterName: any, materialAsset: any, cubemapAsset: any): void;\n    _bindAndAssignAssets(materialAsset: any, assets: any): void;\n}\n\n\n\n/**\n * Callback used by {@link ModelHandleraddParser } to decide on which parser to use.\n */\nexport type AddParserCallback = (url: string, data: object) => boolean;\n/** @typedef {import(\'../graphics/graphics-device.js\').GraphicsDevice} GraphicsDevice */\n/** @typedef {import(\'./handler.js\').ResourceHandler} ResourceHandler */\n/**\n * Callback used by {@link ModelHandler#addParser} to decide on which parser to use.\n *\n * @callback AddParserCallback\n * @param {string} url - The resource url.\n * @param {object} data - The raw model data.\n * @returns {boolean} Return true if this parser should be used to parse the data into a\n * {@link Model}.\n */\n/**\n * Resource handler used for loading {@link Model} resources.\n *\n * @implements {ResourceHandler}\n */\ndeclare class ModelHandler implements ResourceHandler {\n    /**\n     * Create a new ModelHandler instance.\n     *\n     * @param {GraphicsDevice} device - The graphics device that will be rendering.\n     */\n    constructor(device: GraphicsDevice);\n    _device: GraphicsDevice;\n    _parsers: any[];\n    _defaultMaterial: StandardMaterial;\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): any;\n    patch(asset: any, assets: any): void;\n    /**\n     * Add a parser that converts raw data into a {@link Model}. Default parser is for JSON models.\n     *\n     * @param {object} parser - See JsonModelParser for example.\n     * @param {AddParserCallback} decider - Function that decides on which parser to use. Function\n     * should take (url, data) arguments and return true if this parser should be used to parse the\n     * data into a {@link Model}. The first parser to return true is used.\n     */\n    addParser(parser: object, decider: AddParserCallback): void;\n}\n\n/** @typedef {import(\'./mesh.js\').Mesh} Mesh */\n/**\n * @event\n * @private\n * @name Render#set:meshes\n * @description Fired when the meshes are set\n * @param {Mesh[]} meshes - The meshes\n */\n/**\n * A render contains an array of meshes that are referenced by a single hierarchy node in a GLB\n * model, and are accessible using {@link ContainerResource#renders} property. The render is the\n * resource of a Render Asset.\n *\n * @augments EventHandler\n * @ignore\n */\ndeclare class Render extends EventHandler {\n    /**\n     * Meshes are reference counted, and this class owns the references and is responsible for\n     * releasing the meshes when they are no longer referenced.\n     *\n     * @type {Mesh[]}\n     * @private\n     */\n    private _meshes;\n    /**\n     * The meshes that the render contains.\n     *\n     * @type {Mesh[]}\n     */\n    set meshes(arg: Mesh[]);\n    get meshes(): Mesh[];\n    destroy(): void;\n    decRefMeshes(): void;\n    incRefMeshes(): void;\n}\n\n\n\n/**\n * Resource handler used for loading {@link Render} resources.\n *\n * @implements {ResourceHandler}\n */\ndeclare class RenderHandler implements ResourceHandler {\n    /**\n     * Create a new RenderHandler instance.\n     *\n     * @param {AssetRegistry} assets - The asset registry.\n     */\n    constructor(assets: AssetRegistry);\n    _registry: AssetRegistry;\n    load(url: any, callback: any, asset: any): void;\n    open(url: any, data: any): Render;\n    patch(asset: any, registry: any): void;\n}\n\n\n\n/** @typedef {import(\'../framework/app-base.js\').Application} Application */\n/** @typedef {import(\'./handler.js\').ResourceHandler} ResourceHandler */\n/**\n * Resource handler for loading JavaScript files dynamically.  Two types of JavaScript files can be\n * loaded, PlayCanvas scripts which contain calls to {@link createScript}, or regular JavaScript\n * files, such as third-party libraries.\n *\n * @implements {ResourceHandler}\n */\ndeclare class ScriptHandler implements ResourceHandler {\n    static _types: any[];\n    static _push(Type: any): void;\n    /**\n     * Create a new ScriptHandler instance.\n     *\n     * @param {Application} app - The running {@link Application}.\n     */\n    constructor(app: Application);\n    _app: Application;\n    _scripts: {};\n    _cache: {};\n    load(url: any, callback: any): void;\n    open(url: any, data: any): any;\n    patch(asset: any, assets: any): void;\n    _loadScript(url: any, callback: any): void;\n}\n\n\n\n/** @typedef {import(\'../framework/app-base.js\').Application} Application */\n/** @typedef {import(\'./handler.js\').ResourceHandler} ResourceHandler */\n/**\n * Resource handler used for loading {@link Scene} resources.\n *\n * @implements {ResourceHandler}\n */\ndeclare class SceneHandler implements ResourceHandler {\n    /**\n     * Create a new SceneHandler instance.\n     *\n     * @param {Application} app - The running {@link Application}.\n     */\n    constructor(app: Application);\n    _app: Application;\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): Scene;\n    patch(asset: any, assets: any): void;\n}\n\ndeclare class SceneSettingsHandler {\n    constructor(app: any);\n    _app: any;\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): any;\n}\n\ndeclare class ShaderHandler {\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): any;\n    patch(asset: any, assets: any): void;\n}\n\n\n\n\n/**\n * Resource handler used for loading {@link Sprite} resources.\n *\n * @implements {ResourceHandler}\n */\ndeclare class SpriteHandler implements ResourceHandler {\n    /**\n     * Create a new SpriteHandler instance.\n     *\n     * @param {AssetRegistry} assets - The asset registry.\n     * @param {GraphicsDevice} device - The graphics device.\n     */\n    constructor(assets: AssetRegistry, device: GraphicsDevice);\n    _assets: AssetRegistry;\n    _device: GraphicsDevice;\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): Sprite;\n    patch(asset: any, assets: any): void;\n    _updateAtlas(asset: any): void;\n    _onAssetChange(asset: any, attribute: any, value: any, oldValue: any): void;\n}\n\n\n\n/** @typedef {import(\'../framework/app-base.js\').Application} Application */\n/** @typedef {import(\'../framework/entity.js\').Entity} Entity */\n/**\n * Create a Template resource from raw database data.\n */\ndeclare class Template {\n    /**\n     * Create a new Template instance.\n     *\n     * @param {Application} app - The application.\n     * @param {object} data - Asset data from the database.\n     */\n    constructor(app: Application, data: object);\n    _app: Application;\n    _data: any;\n    _templateRoot: Entity;\n    /**\n     * Create an instance of this template.\n     *\n     * @returns {Entity} The root entity of the created instance.\n     */\n    instantiate(): Entity;\n    _parseTemplate(): void;\n}\n\ndeclare class TemplateHandler {\n    constructor(app: any);\n    _app: any;\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): Template;\n}\n\ndeclare class TextHandler {\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): any;\n    patch(asset: any, assets: any): void;\n}\n\n\n\n/**\n * Resource handler used for loading {@link TextureAtlas} resources.\n *\n * @implements {ResourceHandler}\n */\ndeclare class TextureAtlasHandler implements ResourceHandler {\n    /**\n     * Create a new TextureAtlasHandler instance.\n     *\n     * @param {ResourceLoader} loader - The resource loader.\n     */\n    constructor(loader: ResourceLoader);\n    _loader: ResourceLoader;\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): TextureAtlas;\n    patch(asset: any, assets: any): void;\n    _onAssetChange(asset: any, attribute: any, value: any): void;\n}\n\n\n\n/** @typedef {import(\'./asset.js\').Asset} Asset */\n/** @typedef {import(\'./asset-registry.js\').AssetRegistry} AssetRegistry */\n/**\n * An object that manages the case where an object holds a reference to an asset and needs to be\n * notified when changes occur in the asset. e.g. notifications include load, add and remove\n * events.\n */\ndeclare class AssetReference {\n    /**\n     * Create a new AssetReference instance.\n     *\n     * @param {string} propertyName - The name of the property that the asset is stored under,\n     * passed into callbacks to enable updating.\n     * @param {Asset|object} parent - The parent object that contains the asset reference, passed\n     * into callbacks to enable updating. Currently an asset, but could be component or other.\n     * @param {AssetRegistry} registry - The asset registry that stores all assets.\n     * @param {object} callbacks - A set of functions called when the asset state changes: load,\n     * add, remove.\n     * @param {object} [callbacks.load] - The function called when the asset loads\n     * load(propertyName, parent, asset).\n     * @param {object} [callbacks.add] - The function called when the asset is added to the\n     * registry add(propertyName, parent, asset).\n     * @param {object} [callbacks.remove] - The function called when the asset is remove from the\n     * registry remove(propertyName, parent, asset).\n     * @param {object} [callbacks.unload] - The function called when the asset is unloaded\n     * unload(propertyName, parent, asset).\n     * @param {object} [scope] - The scope to call the callbacks in.\n     * @example\n     * var reference = new pc.AssetReference(\'textureAsset\', this, this.app.assets, {\n     *     load: this.onTextureAssetLoad,\n     *     add: this.onTextureAssetAdd,\n     *     remove: this.onTextureAssetRemove\n     * }, this);\n     * reference.id = this.textureAsset.id;\n     */\n    constructor(propertyName: string, parent: Asset | object, registry: AssetRegistry, callbacks: {\n        load?: object;\n        add?: object;\n        remove?: object;\n        unload?: object;\n    }, scope?: object);\n    propertyName: string;\n    parent: any;\n    _scope: any;\n    _registry: AssetRegistry;\n    /**\n     * Get or set the asset id which this references. One of either id or url must be set to\n     * initialize an asset reference.\n     *\n     * @type {number}\n     */\n    set id(arg: any);\n    get id(): any;\n    /**\n     * Get or set the asset url which this references. One of either id or url must be called to\n     * initialize an asset reference.\n     *\n     * @type {string}\n     */\n    set url(arg: any);\n    get url(): any;\n    asset: any;\n    _onAssetLoad: any;\n    _onAssetAdd: any;\n    _onAssetRemove: any;\n    _onAssetUnload: any;\n    _id: any;\n    _url: any;\n    _bind(): void;\n    _unbind(): void;\n    _onLoad(asset: any): void;\n    _onAdd(asset: any): void;\n    _onRemove(asset: any): void;\n    _onUnload(asset: any): void;\n}\n\ndeclare namespace script {\n    const legacy: boolean;\n}\n\n/**\n * Used to manage layout calculations for {@link LayoutGroupComponent}s.\n *\n * @ignore\n */\ndeclare class LayoutCalculator {\n    calculateLayout(elements: any, options: any): any;\n}\n\ndeclare class ScriptLegacyComponent extends Component {\n    constructor(system: any, entity: any);\n    send(name: any, functionName: any, ...args: any[]): any;\n    onSetScripts(name: any, oldValue: any, newValue: any): void;\n    _updateScriptAttributes(oldValue: any, newValue: any): boolean;\n    _loadFromCache(urls: any): boolean;\n    _loadScripts(urls: any): void;\n}\n\ndeclare class ScriptLegacyComponentData {\n    scripts: any[];\n    enabled: boolean;\n    instances: {};\n    _instances: {};\n    runInTools: boolean;\n    attributes: {};\n    initialized: boolean;\n    postInitialized: boolean;\n    areScriptsLoaded: boolean;\n}\n\ndeclare class ScriptLegacyComponentSystem extends ComponentSystem {\n    constructor(app: any);\n    id: string;\n    ComponentType: typeof ScriptLegacyComponent;\n    DataType: typeof ScriptLegacyComponentData;\n    schema: string[];\n    preloading: boolean;\n    instancesWithUpdate: any[];\n    instancesWithFixedUpdate: any[];\n    instancesWithPostUpdate: any[];\n    instancesWithToolsUpdate: any[];\n    initializeComponentData(component: any, data: any, properties: any): void;\n    cloneComponent(entity: any, clone: any): Component;\n    onBeforeRemove(entity: any, component: any): void;\n    onInitialize(root: any): void;\n    onPostInitialize(root: any): void;\n    _callInstancesMethod(script: any, method: any): void;\n    _initializeScriptComponent(script: any): void;\n    _enableScriptComponent(script: any): void;\n    _disableScriptComponent(script: any): void;\n    _destroyScriptComponent(script: any): void;\n    _postInitializeScriptComponent(script: any): void;\n    _updateInstances(method: any, updateList: any, dt: any): void;\n    onUpdate(dt: any): void;\n    onFixedUpdate(dt: any): void;\n    onPostUpdate(dt: any): void;\n    onToolsUpdate(dt: any): void;\n    broadcast(name: any, functionName: any, ...args: any[]): void;\n    _preRegisterInstance(entity: any, url: any, name: any, instance: any): void;\n    _registerInstances(entity: any): void;\n    _cloneAttributes(attributes: any): {};\n    _createAccessors(entity: any, instance: any): void;\n    _createAccessor(attribute: any, instance: any): void;\n    _updateAccessors(entity: any, instance: any): void;\n    _convertAttributeValue(attribute: any): void;\n}\n\ndeclare const apps: {};\ndeclare const common: {};\ndeclare const config: {};\ndeclare const data: {};\n/**\n * Merge the contents of two objects into a single object.\n *\n * @param {object} target - The target object of the merge.\n * @param {object} ex - The object that is merged with target.\n * @returns {object} The target object.\n * @example\n * var A = {\n *     a: function () {\n *         console.log(this.a);\n *     }\n * };\n * var B = {\n *     b: function () {\n *         console.log(this.b);\n *     }\n * };\n *\n * pc.extend(A, B);\n * A.a();\n * // logs "a"\n * A.b();\n * // logs "b"\n * @ignore\n */\ndeclare function extend(target: object, ex: object): object;\n/**\n * Return true if the Object is not undefined.\n *\n * @param {object} o - The Object to test.\n * @returns {boolean} True if the Object is not undefined.\n * @ignore\n */\ndeclare function isDefined(o: object): boolean;\ndeclare const revision: "__REVISION__";\n/**\n * Extended typeof() function, returns the type of the object.\n *\n * @param {object} obj - The object to get the type of.\n * @returns {string} The type string: "null", "undefined", "number", "string", "boolean", "array", "object", "function", "date", "regexp" or "float32array".\n * @ignore\n */\ndeclare function type(obj: object): string;\n/**\n * @name pc\n * @namespace\n * @description Root namespace for the PlayCanvas Engine.\n */\ndeclare const version: "__CURRENT_SDK_VERSION__";\n\n/**\n * Create a URI object from constituent parts.\n *\n * @param {object} options - Parts of the URI to build.\n * @param {string} [options.scheme] - The URI scheme (e.g. http).\n * @param {string} [options.authority] - The URI authority (e.g. `www.example.com`).\n * @param {string} [options.host] - Combination of scheme and authority (e.g. `http://www.example.com`).\n * @param {string} [options.path] - The URI path (e.g. /users/example).\n * @param {string} [options.hostpath] - Combination of scheme, authority and path (e.g. `http://www.example.com/users/example`).\n * @param {string} [options.query] - The query section, after the ?(e.g. `http://example.com?**key=value&another=123**`).\n * @param {string} [options.fragment] - The fragment section, after the # (e.g. `http://example.com#**fragment/data**`).\n * @returns {string} A URI string.\n * @ignore\n */\ndeclare function createURI(options: {\n    scheme?: string;\n    authority?: string;\n    host?: string;\n    path?: string;\n    hostpath?: string;\n    query?: string;\n    fragment?: string;\n}): string;\n/**\n * A URI object.\n *\n * @ignore\n */\ndeclare class URI {\n    /**\n     * Create a new URI instance.\n     *\n     * @param {string} uri - URI string.\n     */\n    constructor(uri: string);\n    /**\n     * The scheme. (e.g. http).\n     *\n     * @type {string}\n     */\n    scheme: string;\n    /**\n     * The authority. (e.g. `www.example.com`).\n     *\n     * @type {string}\n     */\n    authority: string;\n    /**\n     * The path. (e.g. /users/example).\n     *\n     * @type {string}\n     */\n    path: string;\n    /**\n     * The query, the section after a ?. (e.g. search=value).\n     *\n     * @type {string}\n     */\n    query: string;\n    /**\n     * The fragment, the section after a #.\n     *\n     * @type {string}\n     */\n    fragment: string;\n    /**\n     * Convert URI back to string.\n     *\n     * @returns {string} The URI as a string.\n     */\n    toString(): string;\n    /**\n     * Returns the query parameters as an Object.\n     *\n     * @returns {object} The URI\'s query parameters converted to an Object.\n     * @example\n     * var s = "http://example.com?a=1&b=2&c=3";\n     * var uri = new pc.URI(s);\n     * var q = uri.getQuery();\n     * console.log(q.a); // logs "1"\n     * console.log(q.b); // logs "2"\n     * console.log(q.c); // logs "3"\n     */\n    getQuery(): object;\n    /**\n     * Set the query section of the URI from a Object.\n     *\n     * @param {object} params - Key-Value pairs to encode into the query string.\n     * @example\n     * var s = "http://example.com";\n     * var uri = new pc.URI(s);\n     * uri.setQuery({\n     *     "a": 1,\n     *     "b": 2\n     * });\n     * console.log(uri.toString()); // logs "http://example.com?a=1&b=2\n     */\n    setQuery(params: object): void;\n}\n\n/**\n * Callback used by {@link Httpget }, {@link Httppost }, {@link Httpput }, {@link Httpdel }, and\n * {@link Httprequest }.\n */\nexport type HttpResponseCallback = (err: number | string | Error | null, response?: any) => any;\ndeclare const http: Http;\n/**\n * Callback used by {@link Http#get}, {@link Http#post}, {@link Http#put}, {@link Http#del}, and\n * {@link Http#request}.\n *\n * @callback HttpResponseCallback\n * @param {number|string|Error|null} err - The error code, message, or exception in the case where the request fails.\n * @param {*} [response] - The response data if no errors were encountered. (format depends on response type: text, Object, ArrayBuffer, XML).\n */\n/**\n * Used to send and receive HTTP requests.\n */\ndeclare class Http {\n    static ContentType: {\n        FORM_URLENCODED: string;\n        GIF: string;\n        JPEG: string;\n        DDS: string;\n        JSON: string;\n        PNG: string;\n        TEXT: string;\n        XML: string;\n        WAV: string;\n        OGG: string;\n        MP3: string;\n        MP4: string;\n        AAC: string;\n        BIN: string;\n        BASIS: string;\n        GLB: string;\n    };\n    static ResponseType: {\n        TEXT: string;\n        ARRAY_BUFFER: string;\n        BLOB: string;\n        DOCUMENT: string;\n        JSON: string;\n    };\n    static binaryExtensions: string[];\n    static retryDelay: number;\n    /**\n     * @function\n     * @name Http#get\n     * @description Perform an HTTP GET request to the given url.\n     * @param {string} url - The URL to make the request to.\n     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)\n     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and\n     * err is the error code.\n     * @example\n     * pc.http.get("http://example.com/", function (err, response) {\n     *     console.log(response);\n     * });\n     * @returns {XMLHttpRequest} The request object.\n     */\n    /**\n     * @function\n     * @name Http#get\n     * @variation 2\n     * @description Perform an HTTP GET request to the given url with additional options such as headers, retries, credentials, etc.\n     * @param {string} url - The URL to make the request to.\n     * @param {object} options - Additional options.\n     * @param {object} [options.headers] - HTTP headers to add to the request.\n     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.\n     * @param {boolean} [options.cache] - If false, then add a timestamp to the request to prevent caching.\n     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.\n     * @param {string} [options.responseType] - Override the response type.\n     * @param {Document|object} [options.postdata] - Data to send in the body of the request.\n     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If\n     * the Content-Type header is set to \'application/json\' then the postdata is JSON stringified.\n     * Otherwise, by default, the data is sent as form-urlencoded.\n     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.\n     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.\n     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.\n     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)\n     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and\n     * err is the error code.\n     * @example\n     * pc.http.get("http://example.com/", { "retry": true, "maxRetries": 5 }, function (err, response) {\n     *     console.log(response);\n     * });\n     * @returns {XMLHttpRequest} The request object.\n     */\n    get(url: string, options: {\n        headers?: object;\n        async?: boolean;\n        cache?: boolean;\n        withCredentials?: boolean;\n        responseType?: string;\n        postdata?: Document | object;\n        retry?: boolean;\n        maxRetries?: number;\n        maxRetryDelay?: number;\n    }, callback: HttpResponseCallback): XMLHttpRequest;\n    /**\n     * @function\n     * @name Http#post\n     * @description Perform an HTTP POST request to the given url.\n     * @param {string} url - The URL to make the request to.\n     * @param {object} data - Data to send in the body of the request.\n     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If\n     * the Content-Type header is set to \'application/json\' then the postdata is JSON stringified.\n     * Otherwise, by default, the data is sent as form-urlencoded.\n     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)\n     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and\n     * err is the error code.\n     * @example\n     * pc.http.post("http://example.com/", { "name": "Alix" }, function (err, response) {\n     *     console.log(response);\n     * });\n     * @returns {XMLHttpRequest} The request object.\n     */\n    /**\n     * @function\n     * @name Http#post\n     * @variation 2\n     * @description Perform an HTTP POST request to the given url with additional options such as headers, retries, credentials, etc.\n     * @param {string} url - The URL to make the request to.\n     * @param {object} data - Data to send in the body of the request.\n     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If\n     * the Content-Type header is set to \'application/json\' then the postdata is JSON stringified.\n     * Otherwise, by default, the data is sent as form-urlencoded.\n     * @param {object} options - Additional options.\n     * @param {object} [options.headers] - HTTP headers to add to the request.\n     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.\n     * @param {boolean} [options.cache] - If false, then add a timestamp to the request to prevent caching.\n     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.\n     * @param {string} [options.responseType] - Override the response type.\n     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.\n     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.\n     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.\n     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)\n     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and\n     * err is the error code.\n     * @example\n     * pc.http.post("http://example.com/", { "name": "Alix" }, { "retry": true, "maxRetries": 5 }, function (err, response) {\n     *     console.log(response);\n     * });\n     * @returns {XMLHttpRequest} The request object.\n     */\n    post(url: string, data: object, options: {\n        headers?: object;\n        async?: boolean;\n        cache?: boolean;\n        withCredentials?: boolean;\n        responseType?: string;\n        retry?: boolean;\n        maxRetries?: number;\n        maxRetryDelay?: number;\n    }, callback: HttpResponseCallback): XMLHttpRequest;\n    /**\n     * @function\n     * @name Http#put\n     * @description Perform an HTTP PUT request to the given url.\n     * @param {string} url - The URL to make the request to.\n     * @param {Document|object} data - Data to send in the body of the request.\n     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If\n     * the Content-Type header is set to \'application/json\' then the postdata is JSON stringified.\n     * Otherwise, by default, the data is sent as form-urlencoded.\n     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)\n     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and\n     * err is the error code.\n     * @example\n     * pc.http.put("http://example.com/", { "name": "Alix" }, function (err, response) {\n     *     console.log(response);\n     * });\n     * @returns {XMLHttpRequest} The request object.\n     */\n    /**\n     * @function\n     * @name Http#put\n     * @variation 2\n     * @description Perform an HTTP PUT request to the given url with additional options such as headers, retries, credentials, etc.\n     * @param {string} url - The URL to make the request to.\n     * @param {Document|object} data - Data to send in the body of the request.\n     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If\n     * the Content-Type header is set to \'application/json\' then the postdata is JSON stringified.\n     * Otherwise, by default, the data is sent as form-urlencoded.\n     * @param {object} options - Additional options.\n     * @param {object} [options.headers] - HTTP headers to add to the request.\n     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.\n     * @param {boolean} [options.cache] - If false, then add a timestamp to the request to prevent caching.\n     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.\n     * @param {string} [options.responseType] - Override the response type.\n     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.\n     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.\n     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.\n     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)\n     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and\n     * err is the error code.\n     * @example\n     * pc.http.put("http://example.com/", { "name": "Alix" }, { "retry": true, "maxRetries": 5 }, function (err, response) {\n     *     console.log(response);\n     * });\n     * @returns {XMLHttpRequest} The request object.\n     */\n    put(url: string, data: Document | object, options: {\n        headers?: object;\n        async?: boolean;\n        cache?: boolean;\n        withCredentials?: boolean;\n        responseType?: string;\n        retry?: boolean;\n        maxRetries?: number;\n        maxRetryDelay?: number;\n    }, callback: HttpResponseCallback): XMLHttpRequest;\n    /**\n     * @function\n     * @name Http#del\n     * @description Perform an HTTP DELETE request to the given url.\n     * @param {object} url - The URL to make the request to.\n     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)\n     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and\n     * err is the error code.\n     * @example\n     * pc.http.del("http://example.com/", function (err, response) {\n     *     console.log(response);\n     * });\n     * @returns {XMLHttpRequest} The request object.\n     */\n    /**\n     * @function\n     * @name Http#del\n     * @variation 2\n     * @description Perform an HTTP DELETE request to the given url with additional options such as headers, retries, credentials, etc.\n     * @param {object} url - The URL to make the request to.\n     * @param {object} options - Additional options.\n     * @param {object} [options.headers] - HTTP headers to add to the request.\n     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.\n     * @param {boolean} [options.cache] - If false, then add a timestamp to the request to prevent caching.\n     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.\n     * @param {string} [options.responseType] - Override the response type.\n     * @param {Document|object} [options.postdata] - Data to send in the body of the request.\n     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If\n     * the Content-Type header is set to \'application/json\' then the postdata is JSON stringified.\n     * Otherwise, by default, the data is sent as form-urlencoded.\n     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.\n     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.\n     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.\n     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)\n     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and\n     * err is the error code.\n     * @example\n     * pc.http.del("http://example.com/", { "retry": true, "maxRetries": 5 }, function (err, response) {\n     *     console.log(response);\n     * });\n     * @returns {XMLHttpRequest} The request object.\n     */\n    del(url: object, options: {\n        headers?: object;\n        async?: boolean;\n        cache?: boolean;\n        withCredentials?: boolean;\n        responseType?: string;\n        postdata?: Document | object;\n        retry?: boolean;\n        maxRetries?: number;\n        maxRetryDelay?: number;\n    }, callback: HttpResponseCallback): XMLHttpRequest;\n    /**\n     * @function\n     * @name Http#request\n     * @description Make a general purpose HTTP request.\n     * @param {string} method - The HTTP method "GET", "POST", "PUT", "DELETE".\n     * @param {string} url - The url to make the request to.\n     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)\n     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and\n     * err is the error code.\n     * @example\n     * pc.http.request("get", "http://example.com/", function (err, response) {\n     *     console.log(response);\n     * });\n     * @returns {XMLHttpRequest} The request object.\n     */\n    /**\n     * @function\n     * @name Http#request\n     * @variation 2\n     * @description Make a general purpose HTTP request with additional options such as headers, retries, credentials, etc.\n     * @param {string} method - The HTTP method "GET", "POST", "PUT", "DELETE".\n     * @param {string} url - The url to make the request to.\n     * @param {object} options - Additional options.\n     * @param {object} [options.headers] - HTTP headers to add to the request.\n     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.\n     * @param {boolean} [options.cache] - If false, then add a timestamp to the request to prevent caching.\n     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.\n     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.\n     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.\n     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.\n     * @param {string} [options.responseType] - Override the response type.\n     * @param {Document|object} [options.postdata] - Data to send in the body of the request.\n     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If\n     * the Content-Type header is set to \'application/json\' then the postdata is JSON stringified.\n     * Otherwise, by default, the data is sent as form-urlencoded.\n     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)\n     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and\n     * err is the error code.\n     * @example\n     * pc.http.request("get", "http://example.com/", { "retry": true, "maxRetries": 5 }, function (err, response) {\n     *     console.log(response);\n     * });\n     * @returns {XMLHttpRequest} The request object.\n     */\n    request(method: string, url: string, options: {\n        headers?: object;\n        async?: boolean;\n        cache?: boolean;\n        withCredentials?: boolean;\n        retry?: boolean;\n        maxRetries?: number;\n        maxRetryDelay?: number;\n        responseType?: string;\n        postdata?: Document | object;\n    }, callback: HttpResponseCallback): XMLHttpRequest;\n    _guessResponseType(url: any): string;\n    _isBinaryContentType(contentType: any): boolean;\n    _onReadyStateChange(method: any, url: any, options: any, xhr: any): void;\n    _onSuccess(method: any, url: any, options: any, xhr: any): void;\n    _onError(method: any, url: any, options: any, xhr: any): void;\n}\n\n\n/**\n * Initialize the Basis transcode worker.\n *\n * @param {object} [config] - The Basis configuration.\n * @param {string} [config.glueUrl] - URL of glue script.\n * @param {string} [config.wasmUrl] - URL of the wasm module.\n * @param {string} [config.fallbackUrl] - URL of the fallback script to use when wasm modules\n * aren\'t supported.\n * @param {boolean} [config.lazyInit] - Wait for first transcode request before initializing Basis\n * (default is false). Otherwise initialize Basis immediately.\n * @param {number} [config.numWorkers] - Number of workers to use for transcoding (default is 1).\n * While it is possible to improve transcode performance using multiple workers, this will likely\n * depend on the runtime platform. For example, desktop will likely benefit from more workers\n * compared to mobile. Also keep in mind that it takes time to initialize workers and increasing\n * this value could impact application startup time. Make sure to test your application performance\n * on all target platforms when changing this parameter.\n * @param {boolean} [config.eagerWorkers] - Use eager workers (default is true). When enabled, jobs\n * are assigned to workers immediately, independent of their work load. This can result in\n * unbalanced workloads, however there is no delay between jobs. If disabled, new jobs are assigned\n * to workers only when their previous job has completed. This will result in balanced workloads\n * across workers, however workers can be idle for a short time between jobs.\n * @param {string[]} [config.rgbPriority] - Array of texture compression formats in priority order\n * for textures without alpha. The supported compressed formats are: \'astc\', \'atc\', \'dxt\', \'etc1\',\n * \'etc2\', \'pvr\'.\n * @param {string[]} [config.rgbaPriority] - Array of texture compression formats in priority order\n * for textures with alpha. The supported compressed formats are: \'astc\', \'atc\', \'dxt\', \'etc1\',\n * \'etc2\', \'pvr\'.\n * @param {number} [config.maxRetries] - Number of http load retry attempts. Defaults to 5.\n */\ndeclare function basisInitialize(config?: {\n    glueUrl?: string;\n    wasmUrl?: string;\n    fallbackUrl?: string;\n    lazyInit?: boolean;\n    numWorkers?: number;\n    eagerWorkers?: boolean;\n    rgbPriority?: string[];\n    rgbaPriority?: string[];\n    maxRetries?: number;\n}): void;\n/**\n * Enqueue a blob of basis data for transcoding.\n *\n * @param {GraphicsDevice} device - The graphics device.\n * @param {string} url - URL of the basis file.\n * @param {object} data - The file data to transcode.\n * @param {Function} callback - Callback function to receive transcode result.\n * @param {object} [options] - Options structure\n * @param {boolean} [options.isGGGR] - Indicates this is a GGGR swizzled texture. Under some\n * circumstances the texture will be unswizzled during transcoding.\n * @param {boolean} [options.isKTX2] - Indicates the image is KTX2 format. Otherwise\n * basis format is assumed.\n * @returns {boolean} True if the basis worker was initialized and false otherwise.\n * @ignore\n */\ndeclare function basisTranscode(device: GraphicsDevice, url: string, data: object, callback: Function, options?: {\n    isGGGR?: boolean;\n    isKTX2?: boolean;\n}): boolean;\n\ndeclare class GlbParser {\n    static parseAsync(filename: any, urlBase: any, data: any, device: any, registry: any, options: any, callback: any): void;\n    static parse(filename: any, data: any, device: any, options: any): any;\n    constructor(device: any, assets: any, maxRetries: any);\n    _device: any;\n    _assets: any;\n    _defaultMaterial: StandardMaterial;\n    _maxRetries: any;\n    _getUrlWithoutParams(url: any): any;\n    load(url: any, callback: any, asset: any): void;\n    open(url: any, data: any, asset: any): any;\n    patch(asset: any, assets: any): void;\n}\n\n\n\n\n\n\n/** @typedef {import(\'../asset/asset-registry.js\').AssetRegistry} AssetRegistry */\n/** @typedef {import(\'../framework/entity.js\').Entity} Entity */\n/** @typedef {import(\'../graphics/graphics-device.js\').GraphicsDevice} GraphicsDevice */\n/** @typedef {import(\'./handler.js\').ResourceHandler} ResourceHandler */\n/** @typedef {import(\'./handler.js\').ResourceHandlerCallback} ResourceHandlerCallback */\n/**\n * @interface\n * @name ContainerResource\n * @description Container for a list of animations, textures, materials, renders and a model.\n */\ndeclare class ContainerResource {\n    /**\n     * Instantiates an entity with a model component.\n     *\n     * @param {object} [options] - The initialization data for the model component type\n     * {@link ModelComponent}.\n     * @returns {Entity} A single entity with a model component. Model component internally\n     * contains a hierarchy based on {@link GraphNode}.\n     * @example\n     * // load a glb file and instantiate an entity with a model component based on it\n     * app.assets.loadFromUrl("statue.glb", "container", function (err, asset) {\n     *     var entity = asset.resource.instantiateModelEntity({\n     *         castShadows: true\n     *     });\n     *     app.root.addChild(entity);\n     * });\n     */\n    instantiateModelEntity(options?: object): Entity;\n    /**\n     * Instantiates an entity with a render component.\n     *\n     * @param {object} [options] - The initialization data for the render component type\n     * {@link RenderComponent}.\n     * @returns {Entity} A hierarchy of entities with render components on entities containing\n     * renderable geometry.\n     * @example\n     * // load a glb file and instantiate an entity with a render component based on it\n     * app.assets.loadFromUrl("statue.glb", "container", function (err, asset) {\n     *     var entity = asset.resource.instantiateRenderEntity({\n     *         castShadows: true\n     *     });\n     *     app.root.addChild(entity);\n     *\n     *     // find all render components containing mesh instances, and change blend mode on their materials\n     *     var renders = entity.findComponents("render");\n     *     renders.forEach(function (render) {\n     *         render.meshInstances.forEach(function (meshInstance) {\n     *             meshInstance.material.blendType = pc.BLEND_MULTIPLICATIVE;\n     *             meshInstance.material.update();\n     *         });\n     *     });\n     * });\n     */\n    instantiateRenderEntity(options?: object): Entity;\n}\n/**\n * Loads files that contain multiple resources. For example glTF files can contain textures, models\n * and animations.\n *\n * For glTF files, the asset options object can be used to pass load time callbacks for handling\n * the various resources at different stages of loading. The table below lists the resource types\n * and the corresponding supported process functions.\n *\n * ```\n * |---------------------------------------------------------------------|\n * |  resource   |  preprocess |   process   |processAsync | postprocess |\n * |-------------+-------------+-------------+-------------+-------------|\n * | global      |      x      |             |             |      x      |\n * | node        |      x      |      x      |             |      x      |\n * | light       |      x      |      x      |             |      x      |\n * | camera      |      x      |      x      |             |      x      |\n * | animation   |      x      |             |             |      x      |\n * | material    |      x      |      x      |             |      x      |\n * | image       |      x      |             |      x      |      x      |\n * | texture     |      x      |             |      x      |      x      |\n * | buffer      |      x      |             |      x      |      x      |\n * | bufferView  |      x      |             |      x      |      x      |\n * |---------------------------------------------------------------------|\n * ```\n *\n * For example, to receive a texture preprocess callback:\n *\n * ```javascript\n * var containerAsset = new pc.Asset(filename, \'container\', { url: url, filename: filename }, null, {\n *     texture: {\n *         preprocess(gltfTexture) { console.log("texture preprocess"); }\n *     },\n * });\n * ```\n *\n * @implements {ResourceHandler}\n */\ndeclare class ContainerHandler implements ResourceHandler {\n    /**\n     * Create a new ContainerResource instance.\n     *\n     * @param {GraphicsDevice} device - The graphics device that will be rendering.\n     * @param {AssetRegistry} assets - The asset registry.\n     */\n    constructor(device: GraphicsDevice, assets: AssetRegistry);\n    glbParser: GlbParser;\n    parsers: {};\n    /**\n     * @param {string} url - The resource URL.\n     * @returns {string} The URL with query parameters removed.\n     * @private\n     */\n    private _getUrlWithoutParams;\n    /**\n     * @param {string} url - The resource URL.\n     * @returns {*} A suitable parser to parse the resource.\n     * @private\n     */\n    private _getParser;\n    /**\n     * @param {string|object} url - Either the URL of the resource to load or a structure\n     * containing the load and original URL.\n     * @param {string} [url.load] - The URL to be used for loading the resource.\n     * @param {string} [url.original] - The original URL to be used for identifying the resource\n     * format. This is necessary when loading, for example from blob.\n     * @param {ResourceHandlerCallback} callback - The callback used when the resource is loaded or\n     * an error occurs.\n     * @param {Asset} [asset] - Optional asset that is passed by ResourceLoader.\n     */\n    load(url: string | object, callback: ResourceHandlerCallback, asset?: Asset): void;\n    /**\n     * @param {string} url - The URL of the resource to open.\n     * @param {*} data - The raw resource data passed by callback from {@link ResourceHandler#load}.\n     * @param {Asset} [asset] - Optional asset that is passed by ResourceLoader.\n     * @returns {*} The parsed resource data.\n     */\n    open(url: string, data: any, asset?: Asset): any;\n    /**\n     * @param {Asset} asset - The asset to patch.\n     * @param {AssetRegistry} assets - The asset registry.\n     */\n    patch(asset: Asset, assets: AssetRegistry): void;\n}\n\n/**\n * Creates a &lt;style&gt; DOM element from a string that contains CSS.\n *\n * @param {string} cssString - A string that contains valid CSS.\n * @returns {Element} The style DOM element.\n * @example\n * var css = \'body {height: 100;}\';\n * var style = pc.createStyle(css);\n * document.head.appendChild(style);\n */\ndeclare function createStyle(cssString: string): Element;\ndeclare class CssHandler {\n    maxRetries: number;\n    load(url: any, callback: any): void;\n    open(url: any, data: any): any;\n    patch(asset: any, assets: any): void;\n}\n\n\n/** @typedef {import(\'../../texture.js\').TextureParser} TextureParser */\n/**\n * Parser for browser-supported image formats.\n *\n * @implements {TextureParser}\n * @ignore\n */\ndeclare class ImgParser implements TextureParser {\n    constructor(registry: any);\n    crossOrigin: string;\n    maxRetries: number;\n    useImageBitmap: boolean;\n    load(url: any, callback: any, asset: any): void;\n    open(url: any, data: any, device: any): Texture;\n    _loadImage(url: any, originalUrl: any, crossOrigin: any, callback: any): void;\n    _loadImageBitmap(url: any, originalUrl: any, crossOrigin: any, callback: any): void;\n}\n\n\n/** @typedef {import(\'../../texture.js\').TextureParser} TextureParser */\n/**\n * Legacy texture parser for dds files.\n *\n * @implements {TextureParser}\n * @ignore\n */\ndeclare class DdsParser implements TextureParser {\n    constructor(registry: any);\n    maxRetries: number;\n    load(url: any, callback: any, asset: any): void;\n    open(url: any, data: any, device: any): Texture;\n}\n\n\n/**\n * Texture parser for ktx files.\n *\n * @implements {TextureParser}\n * @ignore\n */\ndeclare class KtxParser implements TextureParser {\n    constructor(registry: any);\n    maxRetries: number;\n    load(url: any, callback: any, asset: any): void;\n    open(url: any, data: any, device: any): Texture;\n    parse(data: any): {\n        format: any;\n        width: number;\n        height: number;\n        levels: any[][];\n        cubemap: boolean;\n    };\n}\n\n\n/**\n * Texture parser for ktx2 files.\n *\n * @implements {TextureParser}\n * @ignore\n */\ndeclare class Ktx2Parser implements TextureParser {\n    constructor(registry: any, device: any);\n    maxRetries: number;\n    device: any;\n    load(url: any, callback: any, asset: any): void;\n    open(url: any, data: any, device: any): Texture;\n    parse(arraybuffer: any, url: any, callback: any, asset: any): any;\n}\n\n\n/** @typedef {import(\'../../texture.js\').TextureParser} TextureParser */\n/**\n * Parser for basis files.\n *\n * @implements {TextureParser}\n * @ignore\n */\ndeclare class BasisParser implements TextureParser {\n    constructor(registry: any, device: any);\n    device: any;\n    maxRetries: number;\n    load(url: any, callback: any, asset: any): void;\n    open(url: any, data: any, device: any): Texture;\n}\n\n\n/** @typedef {import(\'../../texture.js\').TextureParser} TextureParser */\n/**\n * Texture parser for hdr files.\n *\n * @implements {TextureParser}\n * @ignore\n */\ndeclare class HdrParser implements TextureParser {\n    constructor(registry: any);\n    maxRetries: number;\n    load(url: any, callback: any, asset: any): void;\n    open(url: any, data: any, device: any): Texture;\n    parse(data: any): {\n        width: number;\n        height: number;\n        levels: Uint8Array[];\n    };\n    _readPixels(readStream: any, width: any, height: any, flipY: any): Uint8Array;\n    _readPixelsFlat(readStream: any, width: any, height: any): Uint8Array;\n}\n\n\n\n\n\n\n\n/**\n * Resource handler used for loading 2D and 3D {@link Texture} resources.\n *\n * @implements {ResourceHandler}\n */\ndeclare class TextureHandler implements ResourceHandler {\n    /**\n     * Create a new TextureHandler instance.\n     *\n     * @param {GraphicsDevice} device - The graphics device.\n     * @param {AssetRegistry} assets - The asset registry.\n     * @param {ResourceLoader} loader - The resource loader.\n     */\n    constructor(device: GraphicsDevice, assets: AssetRegistry, loader: ResourceLoader);\n    _device: GraphicsDevice;\n    _assets: AssetRegistry;\n    _loader: ResourceLoader;\n    imgParser: ImgParser;\n    parsers: {\n        dds: DdsParser;\n        ktx: KtxParser;\n        ktx2: Ktx2Parser;\n        basis: BasisParser;\n        hdr: HdrParser;\n    };\n    set crossOrigin(arg: string);\n    get crossOrigin(): string;\n    set maxRetries(arg: number);\n    get maxRetries(): number;\n    _getUrlWithoutParams(url: any): any;\n    _getParser(url: any): any;\n    load(url: any, callback: any, asset: any): void;\n    open(url: any, data: any, asset: any): any;\n    patch(asset: any, assets: any): void;\n}\n/**\n * @interface\n * @name TextureParser\n * @description Interface to a texture parser. Implementations of this interface handle the loading\n * and opening of texture assets.\n */\ndeclare class TextureParser {\n    /**\n     * @function\n     * @name TextureParser#load\n     * @description Load the texture from the remote URL. When loaded (or failed),\n     * use the callback to return an the raw resource data (or error).\n     * @param {object} url - The URL of the resource to load.\n     * @param {string} url.load - The URL to use for loading the resource.\n     * @param {string} url.original - The original URL useful for identifying the resource type.\n     * @param {ResourceHandlerCallback} callback - The callback used when the resource is loaded or an error occurs.\n     * @param {Asset} [asset] - Optional asset that is passed by ResourceLoader.\n     */\n    load(url: {\n        load: string;\n        original: string;\n    }, callback: ResourceHandlerCallback, asset?: Asset): void;\n    /**\n     * @function\n     * @name TextureParser#open\n     * @description Convert raw resource data into a resource instance. E.g. Take 3D model format JSON and return a {@link Model}.\n     * @param {string} url - The URL of the resource to open.\n     * @param {*} data - The raw resource data passed by callback from {@link ResourceHandler#load}.\n     * @param {GraphicsDevice} device - The graphics device.\n     * @returns {Texture} The parsed resource data.\n     */\n    open(url: string, data: any, device: GraphicsDevice): Texture;\n}\n\n/**\n * Create and register a new {@link ScriptType}. It returns new class type (constructor function),\n * which is auto-registered to {@link ScriptRegistry} using its name. This is the main interface to\n * create Script Types, to define custom logic using JavaScript, that is used to create interaction\n * for entities.\n *\n * @param {string} name - Unique Name of a Script Type. If a Script Type with the same name has\n * already been registered and the new one has a `swap` method defined in its prototype, then it\n * will perform hot swapping of existing Script Instances on entities using this new Script Type.\n * Note: There is a reserved list of names that cannot be used, such as list below as well as some\n * starting from `_` (underscore): system, entity, create, destroy, swap, move, scripts, onEnable,\n * onDisable, onPostStateChange, has, on, off, fire, once, hasEvent.\n * @param {Application} [app] - Optional application handler, to choose which {@link ScriptRegistry}\n * to add a script to. By default it will use `Application.getApplication()` to get current\n * {@link Application}.\n * @returns {typeof ScriptType|null} A class type (constructor function) that inherits {@link ScriptType},\n * which the developer is meant to further extend by adding attributes and prototype methods.\n * Returns null if there was an error.\n * @example\n * var Turning = pc.createScript(\'turn\');\n *\n * // define `speed` attribute that is available in Editor UI\n * Turning.attributes.add(\'speed\', {\n *     type: \'number\',\n *     default: 180,\n *     placeholder: \'deg/s\'\n * });\n *\n * // runs every tick\n * Turning.prototype.update = function (dt) {\n *     this.entity.rotate(0, this.speed * dt, 0);\n * };\n */\ndeclare function createScript(name: string, app?: Application): typeof ScriptType | null;\ndeclare namespace createScript {\n    export { reservedAttributes };\n}\n/**\n * Register a existing class type as a Script Type to {@link ScriptRegistry}. Useful when defining\n * a ES6 script class that extends {@link ScriptType} (see example).\n *\n * @param {typeof ScriptType} script - The existing class type (constructor function) to be\n * registered as a Script Type. Class must extend {@link ScriptType} (see example). Please note: A\n * class created using {@link createScript} is auto-registered, and should therefore not be pass\n * into {@link registerScript} (which would result in swapping out all related script instances).\n * @param {string} [name] - Optional unique name of the Script Type. By default it will use the\n * same name as the existing class. If a Script Type with the same name has already been registered\n * and the new one has a `swap` method defined in its prototype, then it will perform hot swapping\n * of existing Script Instances on entities using this new Script Type. Note: There is a reserved\n * list of names that cannot be used, such as list below as well as some starting from `_`\n * (underscore): system, entity, create, destroy, swap, move, scripts, onEnable, onDisable,\n * onPostStateChange, has, on, off, fire, once, hasEvent.\n * @param {Application} [app] - Optional application handler, to choose which {@link ScriptRegistry}\n * to register the script type to. By default it will use `Application.getApplication()` to get\n * current {@link Application}.\n * @example\n * // define a ES6 script class\n * class PlayerController extends pc.ScriptType {\n *\n *     initialize() {\n *         // called once on initialize\n *     }\n *\n *     update(dt) {\n *         // called each tick\n *     }\n * }\n *\n * // register the class as a script\n * pc.registerScript(PlayerController);\n *\n * // declare script attributes (Must be after pc.registerScript())\n * PlayerController.attributes.add(\'attribute1\', {type: \'number\'});\n */\ndeclare function registerScript(script: typeof ScriptType, name?: string, app?: Application): void;\n\ndeclare const reservedAttributes: {};\n\nexport { ABSOLUTE_URL, ACTION_GAMEPAD, ACTION_KEYBOARD, ACTION_MOUSE, ADDRESS_CLAMP_TO_EDGE, ADDRESS_MIRRORED_REPEAT, ADDRESS_REPEAT, ANIM_BLEND_1D, ANIM_BLEND_2D_CARTESIAN, ANIM_BLEND_2D_DIRECTIONAL, ANIM_BLEND_DIRECT, ANIM_CONTROL_STATES, ANIM_EQUAL_TO, ANIM_GREATER_THAN, ANIM_GREATER_THAN_EQUAL_TO, ANIM_INTERRUPTION_NEXT, ANIM_INTERRUPTION_NEXT_PREV, ANIM_INTERRUPTION_NONE, ANIM_INTERRUPTION_PREV, ANIM_INTERRUPTION_PREV_NEXT, ANIM_LAYER_ADDITIVE, ANIM_LAYER_OVERWRITE, ANIM_LESS_THAN, ANIM_LESS_THAN_EQUAL_TO, ANIM_NOT_EQUAL_TO, ANIM_PARAMETER_BOOLEAN, ANIM_PARAMETER_FLOAT, ANIM_PARAMETER_INTEGER, ANIM_PARAMETER_TRIGGER, ANIM_STATE_ANY, ANIM_STATE_END, ANIM_STATE_START, ASPECT_AUTO, ASPECT_MANUAL, ASSET_ANIMATION, ASSET_AUDIO, ASSET_CONTAINER, ASSET_CSS, ASSET_CUBEMAP, ASSET_HTML, ASSET_IMAGE, ASSET_JSON, ASSET_MATERIAL, ASSET_MODEL, ASSET_SCRIPT, ASSET_SHADER, ASSET_TEXT, ASSET_TEXTURE, AXIS_KEY, AXIS_MOUSE_X, AXIS_MOUSE_Y, AXIS_PAD_L_X, AXIS_PAD_L_Y, AXIS_PAD_R_X, AXIS_PAD_R_Y, AnimBinder, AnimClip, AnimClipHandler, AnimComponent, AnimComponentLayer, AnimComponentSystem, AnimController, AnimCurve, AnimData, AnimEvaluator, AnimEvents, AnimSnapshot, AnimStateGraph, AnimStateGraphHandler, AnimTarget, AnimTrack, Animation$1 as Animation, AnimationComponent, AnimationComponentSystem, AnimationHandler, Application, Asset, AssetListLoader, AssetReference, AssetRegistry, AudioHandler, AudioListenerComponent, AudioListenerComponentSystem, AudioSourceComponent, AudioSourceComponentSystem, BAKE_COLOR, BAKE_COLORDIR, BLENDEQUATION_ADD, BLENDEQUATION_MAX, BLENDEQUATION_MIN, BLENDEQUATION_REVERSE_SUBTRACT, BLENDEQUATION_SUBTRACT, BLENDMODE_CONSTANT_ALPHA, BLENDMODE_CONSTANT_COLOR, BLENDMODE_DST_ALPHA, BLENDMODE_DST_COLOR, BLENDMODE_ONE, BLENDMODE_ONE_MINUS_CONSTANT_ALPHA, BLENDMODE_ONE_MINUS_CONSTANT_COLOR, BLENDMODE_ONE_MINUS_DST_ALPHA, BLENDMODE_ONE_MINUS_DST_COLOR, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_COLOR, BLENDMODE_SRC_ALPHA, BLENDMODE_SRC_ALPHA_SATURATE, BLENDMODE_SRC_COLOR, BLENDMODE_ZERO, BLEND_ADDITIVE, BLEND_ADDITIVEALPHA, BLEND_MAX, BLEND_MIN, BLEND_MULTIPLICATIVE, BLEND_MULTIPLICATIVE2X, BLEND_NONE, BLEND_NORMAL, BLEND_PREMULTIPLIED, BLEND_SCREEN, BLEND_SUBTRACTIVE, BLUR_BOX, BLUR_GAUSSIAN, BODYFLAG_KINEMATIC_OBJECT, BODYFLAG_NORESPONSE_OBJECT, BODYFLAG_STATIC_OBJECT, BODYGROUP_DEFAULT, BODYGROUP_DYNAMIC, BODYGROUP_ENGINE_1, BODYGROUP_ENGINE_2, BODYGROUP_ENGINE_3, BODYGROUP_KINEMATIC, BODYGROUP_NONE, BODYGROUP_STATIC, BODYGROUP_TRIGGER, BODYGROUP_USER_1, BODYGROUP_USER_2, BODYGROUP_USER_3, BODYGROUP_USER_4, BODYGROUP_USER_5, BODYGROUP_USER_6, BODYGROUP_USER_7, BODYGROUP_USER_8, BODYMASK_ALL, BODYMASK_NONE, BODYMASK_NOT_STATIC, BODYMASK_NOT_STATIC_KINEMATIC, BODYMASK_STATIC, BODYSTATE_ACTIVE_TAG, BODYSTATE_DISABLE_DEACTIVATION, BODYSTATE_DISABLE_SIMULATION, BODYSTATE_ISLAND_SLEEPING, BODYSTATE_WANTS_DEACTIVATION, BODYTYPE_DYNAMIC, BODYTYPE_KINEMATIC, BODYTYPE_STATIC, BUFFER_DYNAMIC, BUFFER_GPUDYNAMIC, BUFFER_STATIC, BUFFER_STREAM, BUTTON_TRANSITION_MODE_SPRITE_CHANGE, BUTTON_TRANSITION_MODE_TINT, BasicMaterial, Batch, BatchGroup, BatchManager, BinaryHandler, BoundingBox, BoundingSphere, Bundle, BundleHandler, BundleRegistry, ButtonComponent, ButtonComponentSystem, CLEARFLAG_COLOR, CLEARFLAG_DEPTH, CLEARFLAG_STENCIL, COMPUPDATED_BLEND, COMPUPDATED_CAMERAS, COMPUPDATED_INSTANCES, COMPUPDATED_LIGHTS, CUBEFACE_NEGX, CUBEFACE_NEGY, CUBEFACE_NEGZ, CUBEFACE_POSX, CUBEFACE_POSY, CUBEFACE_POSZ, CUBEPROJ_BOX, CUBEPROJ_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK, CULLFACE_NONE, CURVE_CARDINAL, CURVE_CATMULL, CURVE_LINEAR, CURVE_SMOOTHSTEP, CURVE_SPLINE, CURVE_STEP, Camera, CameraComponent, CameraComponentSystem, CanvasFont, CollisionComponent, CollisionComponentSystem, Color, Command, Component, ComponentSystem, ComponentSystemRegistry, ContactPoint, ContactResult, ContainerHandler, ContainerResource, ContextCreationError, Controller, CssHandler, CubemapHandler, Curve, CurveSet, DETAILMODE_ADD, DETAILMODE_MAX, DETAILMODE_MIN, DETAILMODE_MUL, DETAILMODE_OVERLAY, DETAILMODE_SCREEN, DISTANCE_EXPONENTIAL, DISTANCE_INVERSE, DISTANCE_LINEAR, DefaultAnimBinder, ELEMENTTYPE_FLOAT32, ELEMENTTYPE_GROUP, ELEMENTTYPE_IMAGE, ELEMENTTYPE_INT16, ELEMENTTYPE_INT32, ELEMENTTYPE_INT8, ELEMENTTYPE_TEXT, ELEMENTTYPE_UINT16, ELEMENTTYPE_UINT32, ELEMENTTYPE_UINT8, EMITTERSHAPE_BOX, EMITTERSHAPE_SPHERE, EVENT_KEYDOWN, EVENT_KEYUP, EVENT_MOUSEDOWN, EVENT_MOUSEMOVE, EVENT_MOUSEUP, EVENT_MOUSEWHEEL, EVENT_SELECT, EVENT_SELECTEND, EVENT_SELECTSTART, EVENT_TOUCHCANCEL, EVENT_TOUCHEND, EVENT_TOUCHMOVE, EVENT_TOUCHSTART, ElementComponent, ElementComponentSystem, ElementDragHelper, ElementInput, ElementInputEvent, ElementMouseEvent, ElementSelectEvent, ElementTouchEvent, Entity, EntityReference, EnvLighting, EventHandler, FILLMODE_FILL_WINDOW, FILLMODE_KEEP_ASPECT, FILLMODE_NONE, FILTER_LINEAR, FILTER_LINEAR_MIPMAP_LINEAR, FILTER_LINEAR_MIPMAP_NEAREST, FILTER_NEAREST, FILTER_NEAREST_MIPMAP_LINEAR, FILTER_NEAREST_MIPMAP_NEAREST, FITTING_BOTH, FITTING_NONE, FITTING_SHRINK, FITTING_STRETCH, FOG_EXP, FOG_EXP2, FOG_LINEAR, FOG_NONE, FONT_BITMAP, FONT_MSDF, FRESNEL_NONE, FRESNEL_SCHLICK, FUNC_ALWAYS, FUNC_EQUAL, FUNC_GREATER, FUNC_GREATEREQUAL, FUNC_LESS, FUNC_LESSEQUAL, FUNC_NEVER, FUNC_NOTEQUAL, FolderHandler, Font, FontHandler, ForwardRenderer, Frustum, GAMMA_NONE, GAMMA_SRGB, GAMMA_SRGBFAST, GAMMA_SRGBHDR, GamePads, GraphNode, GraphicsDevice, HierarchyHandler, HtmlHandler, Http, I18n, INDEXFORMAT_UINT16, INDEXFORMAT_UINT32, INDEXFORMAT_UINT8, INTERPOLATION_CUBIC, INTERPOLATION_LINEAR, INTERPOLATION_STEP, ImageElement, IndexBuffer, IndexedList, JointComponent, JointComponentSystem, JsonHandler, JsonStandardMaterialParser, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_A, KEY_ADD, KEY_ALT, KEY_B, KEY_BACKSPACE, KEY_BACK_SLASH, KEY_C, KEY_CAPS_LOCK, KEY_CLOSE_BRACKET, KEY_COMMA, KEY_CONTEXT_MENU, KEY_CONTROL, KEY_D, KEY_DECIMAL, KEY_DELETE, KEY_DIVIDE, KEY_DOWN, KEY_E, KEY_END, KEY_ENTER, KEY_EQUAL, KEY_ESCAPE, KEY_F, KEY_F1, KEY_F10, KEY_F11, KEY_F12, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_G, KEY_H, KEY_HOME, KEY_I, KEY_INSERT, KEY_J, KEY_K, KEY_L, KEY_LEFT, KEY_M, KEY_META, KEY_MULTIPLY, KEY_N, KEY_NUMPAD_0, KEY_NUMPAD_1, KEY_NUMPAD_2, KEY_NUMPAD_3, KEY_NUMPAD_4, KEY_NUMPAD_5, KEY_NUMPAD_6, KEY_NUMPAD_7, KEY_NUMPAD_8, KEY_NUMPAD_9, KEY_O, KEY_OPEN_BRACKET, KEY_P, KEY_PAGE_DOWN, KEY_PAGE_UP, KEY_PAUSE, KEY_PERIOD, KEY_PRINT_SCREEN, KEY_Q, KEY_R, KEY_RETURN, KEY_RIGHT, KEY_S, KEY_SEMICOLON, KEY_SEPARATOR, KEY_SHIFT, KEY_SLASH, KEY_SPACE, KEY_SUBTRACT, KEY_T, KEY_TAB, KEY_U, KEY_UP, KEY_V, KEY_W, KEY_WINDOWS, KEY_X, KEY_Y, KEY_Z, Key, Keyboard, KeyboardEvent, LAYERID_DEPTH, LAYERID_IMMEDIATE, LAYERID_SKYBOX, LAYERID_UI, LAYERID_WORLD, LAYER_FX, LAYER_GIZMO, LAYER_HUD, LAYER_WORLD, LIGHTFALLOFF_INVERSESQUARED, LIGHTFALLOFF_LINEAR, LIGHTSHAPE_DISK, LIGHTSHAPE_PUNCTUAL, LIGHTSHAPE_RECT, LIGHTSHAPE_SPHERE, LIGHTTYPE_DIRECTIONAL, LIGHTTYPE_OMNI, LIGHTTYPE_POINT, LIGHTTYPE_SPOT, LINEBATCH_GIZMO, LINEBATCH_OVERLAY, LINEBATCH_WORLD, Layer, LayerComposition, LayoutCalculator, LayoutChildComponent, LayoutChildComponentSystem, LayoutGroupComponent, LayoutGroupComponentSystem, Light, LightComponent, LightComponentSystem, LightingParams, Lightmapper, LocalizedAsset, MASK_AFFECT_DYNAMIC, MASK_AFFECT_LIGHTMAPPED, MASK_BAKE, MOTION_FREE, MOTION_LIMITED, MOTION_LOCKED, MOUSEBUTTON_LEFT, MOUSEBUTTON_MIDDLE, MOUSEBUTTON_NONE, MOUSEBUTTON_RIGHT, Mat3, Mat4, Material, MaterialHandler, Mesh, MeshInstance, Model, ModelComponent, ModelComponentSystem, ModelHandler, Morph, MorphInstance, MorphTarget, Mouse, MouseEvent$1 as MouseEvent, Node$1 as Node, ORIENTATION_HORIZONTAL, ORIENTATION_VERTICAL, OrientedBox, PAD_1, PAD_2, PAD_3, PAD_4, PAD_DOWN, PAD_FACE_1, PAD_FACE_2, PAD_FACE_3, PAD_FACE_4, PAD_LEFT, PAD_L_SHOULDER_1, PAD_L_SHOULDER_2, PAD_L_STICK_BUTTON, PAD_L_STICK_X, PAD_L_STICK_Y, PAD_RIGHT, PAD_R_SHOULDER_1, PAD_R_SHOULDER_2, PAD_R_STICK_BUTTON, PAD_R_STICK_X, PAD_R_STICK_Y, PAD_SELECT, PAD_START, PAD_UP, PAD_VENDOR, PARTICLEMODE_CPU, PARTICLEMODE_GPU, PARTICLEORIENTATION_EMITTER, PARTICLEORIENTATION_SCREEN, PARTICLEORIENTATION_WORLD, PARTICLESORT_DISTANCE, PARTICLESORT_NEWER_FIRST, PARTICLESORT_NONE, PARTICLESORT_OLDER_FIRST, PIXELFORMAT_111110F, PIXELFORMAT_A8, PIXELFORMAT_ASTC_4x4, PIXELFORMAT_ATC_RGB, PIXELFORMAT_ATC_RGBA, PIXELFORMAT_DEPTH, PIXELFORMAT_DEPTHSTENCIL, PIXELFORMAT_DXT1, PIXELFORMAT_DXT3, PIXELFORMAT_DXT5, PIXELFORMAT_ETC1, PIXELFORMAT_ETC2_RGB, PIXELFORMAT_ETC2_RGBA, PIXELFORMAT_L8, PIXELFORMAT_L8_A8, PIXELFORMAT_PVRTC_2BPP_RGBA_1, PIXELFORMAT_PVRTC_2BPP_RGB_1, PIXELFORMAT_PVRTC_4BPP_RGBA_1, PIXELFORMAT_PVRTC_4BPP_RGB_1, PIXELFORMAT_R32F, PIXELFORMAT_R4_G4_B4_A4, PIXELFORMAT_R5_G5_B5_A1, PIXELFORMAT_R5_G6_B5, PIXELFORMAT_R8_G8_B8, PIXELFORMAT_R8_G8_B8_A8, PIXELFORMAT_RGB16F, PIXELFORMAT_RGB32F, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_SRGB, PIXELFORMAT_SRGBA, PRIMITIVE_LINELOOP, PRIMITIVE_LINES, PRIMITIVE_LINESTRIP, PRIMITIVE_POINTS, PRIMITIVE_TRIANGLES, PRIMITIVE_TRIFAN, PRIMITIVE_TRISTRIP, PROJECTION_ORTHOGRAPHIC, PROJECTION_PERSPECTIVE, ParticleEmitter, ParticleSystemComponent, ParticleSystemComponentSystem, PhongMaterial, Picker, Plane, PostEffect$1 as PostEffect, PostEffectQueue, ProgramLibrary, Quat, RENDERSTYLE_POINTS, RENDERSTYLE_SOLID, RENDERSTYLE_WIREFRAME, RESOLUTION_AUTO, RESOLUTION_FIXED, RIGIDBODY_ACTIVE_TAG, RIGIDBODY_CF_KINEMATIC_OBJECT, RIGIDBODY_CF_NORESPONSE_OBJECT, RIGIDBODY_CF_STATIC_OBJECT, RIGIDBODY_DISABLE_DEACTIVATION, RIGIDBODY_DISABLE_SIMULATION, RIGIDBODY_ISLAND_SLEEPING, RIGIDBODY_TYPE_DYNAMIC, RIGIDBODY_TYPE_KINEMATIC, RIGIDBODY_TYPE_STATIC, RIGIDBODY_WANTS_DEACTIVATION, Ray, RaycastResult, ReadStream, RenderComponent, RenderComponentSystem, RenderHandler, RenderTarget, ResourceHandler, ResourceLoader, RigidBodyComponent, RigidBodyComponentSystem, SCALEMODE_BLEND, SCALEMODE_NONE, SCROLLBAR_VISIBILITY_SHOW_ALWAYS, SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED, SCROLL_MODE_BOUNCE, SCROLL_MODE_CLAMP, SCROLL_MODE_INFINITE, SEMANTIC_ATTR, SEMANTIC_ATTR0, SEMANTIC_ATTR1, SEMANTIC_ATTR10, SEMANTIC_ATTR11, SEMANTIC_ATTR12, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15, SEMANTIC_ATTR2, SEMANTIC_ATTR3, SEMANTIC_ATTR4, SEMANTIC_ATTR5, SEMANTIC_ATTR6, SEMANTIC_ATTR7, SEMANTIC_ATTR8, SEMANTIC_ATTR9, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_COLOR, SEMANTIC_NORMAL, SEMANTIC_POSITION, SEMANTIC_TANGENT, SEMANTIC_TEXCOORD, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_TEXCOORD2, SEMANTIC_TEXCOORD3, SEMANTIC_TEXCOORD4, SEMANTIC_TEXCOORD5, SEMANTIC_TEXCOORD6, SEMANTIC_TEXCOORD7, SHADERDEF_DIRLM, SHADERDEF_INSTANCING, SHADERDEF_LM, SHADERDEF_LMAMBIENT, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_TEXTURE_BASED, SHADERDEF_NOSHADOW, SHADERDEF_SCREENSPACE, SHADERDEF_SKIN, SHADERDEF_TANGENTS, SHADERDEF_UV0, SHADERDEF_UV1, SHADERDEF_VCOLOR, SHADERTAG_MATERIAL, SHADER_DEPTH, SHADER_FORWARD, SHADER_FORWARDHDR, SHADER_PICK, SHADER_SHADOW, SHADOWUPDATE_NONE, SHADOWUPDATE_REALTIME, SHADOWUPDATE_THISFRAME, SHADOW_COUNT, SHADOW_DEPTH, SHADOW_PCF1, SHADOW_PCF3, SHADOW_PCF5, SHADOW_VSM16, SHADOW_VSM32, SHADOW_VSM8, SORTKEY_DEPTH, SORTKEY_FORWARD, SORTMODE_BACK2FRONT, SORTMODE_CUSTOM, SORTMODE_FRONT2BACK, SORTMODE_MANUAL, SORTMODE_MATERIALMESH, SORTMODE_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT, SPECOCC_NONE, SPECULAR_BLINN, SPECULAR_PHONG, SPRITETYPE_ANIMATED, SPRITETYPE_SIMPLE, SPRITE_RENDERMODE_SIMPLE, SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED, STENCILOP_DECREMENT, STENCILOP_DECREMENTWRAP, STENCILOP_INCREMENT, STENCILOP_INCREMENTWRAP, STENCILOP_INVERT, STENCILOP_KEEP, STENCILOP_REPLACE, STENCILOP_ZERO, Scene, SceneHandler, SceneRegistry, SceneRegistryItem, SceneSettingsHandler, ScopeId, ScopeSpace, ScreenComponent, ScreenComponentSystem, ScriptAttributes, ScriptComponent, ScriptComponentSystem, ScriptHandler, ScriptLegacyComponent, ScriptLegacyComponentSystem, ScriptRegistry, ScriptType, ScrollViewComponent, ScrollViewComponentSystem, ScrollbarComponent, ScrollbarComponentSystem, Shader, ShaderHandler, SingleContactResult, Skeleton, Skin, SkinBatchInstance, SkinInstance, SortedLoopArray, Sound, SoundComponent, SoundComponentSystem, SoundInstance, SoundInstance3d, SoundManager, SoundSlot, Sprite, SpriteAnimationClip, SpriteComponent, SpriteComponentSystem, SpriteHandler, StandardMaterial as StandardMaterial, StencilParameters, TEXHINT_ASSET, TEXHINT_LIGHTMAP, TEXHINT_NONE, TEXHINT_SHADOWMAP, TEXTURELOCK_READ, TEXTURELOCK_WRITE, TEXTUREPROJECTION_CUBE, TEXTUREPROJECTION_EQUIRECT, TEXTUREPROJECTION_NONE, TEXTUREPROJECTION_OCTAHEDRAL, TEXTURETYPE_DEFAULT, TEXTURETYPE_RGBE, TEXTURETYPE_RGBM, TEXTURETYPE_SWIZZLEGGGR, TONEMAP_ACES, TONEMAP_ACES2, TONEMAP_FILMIC, TONEMAP_HEJL, TONEMAP_LINEAR, TYPE_FLOAT32, TYPE_INT16, TYPE_INT32, TYPE_INT8, TYPE_UINT16, TYPE_UINT32, TYPE_UINT8, Tags, Template, TemplateHandler, TextElement, TextHandler, Texture, TextureAtlas, TextureAtlasHandler, TextureHandler, TextureParser, Timer, Touch$1 as Touch, TouchDevice, TouchEvent$1 as TouchEvent, TransformFeedback, UNIFORMTYPE_BOOL, UNIFORMTYPE_BVEC2, UNIFORMTYPE_BVEC3, UNIFORMTYPE_BVEC4, UNIFORMTYPE_FLOAT, UNIFORMTYPE_FLOATARRAY, UNIFORMTYPE_INT, UNIFORMTYPE_IVEC2, UNIFORMTYPE_IVEC3, UNIFORMTYPE_IVEC4, UNIFORMTYPE_MAT2, UNIFORMTYPE_MAT3, UNIFORMTYPE_MAT4, UNIFORMTYPE_TEXTURE2D, UNIFORMTYPE_TEXTURE2D_SHADOW, UNIFORMTYPE_TEXTURE3D, UNIFORMTYPE_TEXTURECUBE, UNIFORMTYPE_TEXTURECUBE_SHADOW, UNIFORMTYPE_VEC2, UNIFORMTYPE_VEC2ARRAY, UNIFORMTYPE_VEC3, UNIFORMTYPE_VEC3ARRAY, UNIFORMTYPE_VEC4, UNIFORMTYPE_VEC4ARRAY, URI, UnsupportedBrowserError, VIEW_CENTER, VIEW_LEFT, VIEW_RIGHT, Vec2, Vec3, Vec4, VertexBuffer, VertexFormat, VertexIterator, VrDisplay, VrManager, WebglGraphicsDevice, WorldClusters, XRDEPTHSENSINGFORMAT_F32, XRDEPTHSENSINGFORMAT_L8A8, XRDEPTHSENSINGUSAGE_CPU, XRDEPTHSENSINGUSAGE_GPU, XRHAND_LEFT, XRHAND_NONE, XRHAND_RIGHT, XRSPACE_BOUNDEDFLOOR, XRSPACE_LOCAL, XRSPACE_LOCALFLOOR, XRSPACE_UNBOUNDED, XRSPACE_VIEWER, XRTARGETRAY_GAZE, XRTARGETRAY_POINTER, XRTARGETRAY_SCREEN, XRTRACKABLE_MESH, XRTRACKABLE_PLANE, XRTRACKABLE_POINT, XRTYPE_AR, XRTYPE_INLINE, XRTYPE_VR, XrDepthSensing, XrDomOverlay, XrHitTest, XrHitTestSource, XrImageTracking, XrInput, XrInputSource, XrLightEstimation, XrManager, XrPlane, XrPlaneDetection, XrTrackedImage, ZoneComponent, ZoneComponentSystem, anim, app, apps, asset, audio, basisInitialize, basisSetDownloadConfig, basisTranscode, calculateNormals, calculateTangents, common, config, createBox, createCapsule, createCone, createCylinder, createMesh, createPlane, createScript, createSphere, createStyle, createTorus, createURI, data, drawFullscreenQuad, drawQuadWithShader, drawTexture, events, extend, fw, getTouchTargetCoords, gfx, guid, http, inherits, input, isDefined, log, makeArray, math, now, path, platform, posteffect, prefilterCubemap, programlib, registerScript, reprojectTexture, revision, scene, script, semanticToLocation, shFromCubemap, shaderChunks, shadowTypeToString, shape, string, time, type, typedArrayIndexFormats, typedArrayIndexFormatsByteSize, typedArrayToType, typedArrayTypes, typedArrayTypesByteSize, version };\nexport as namespace pc;\n';var Pk,kk=e=>{const t=": void {",n=(e=(e=e.includes(t)?e.substring(e.indexOf(t)+t.length):e.substring(e.indexOf("{")+1)).substring(0,e.lastIndexOf("}"))).indexOf("const app"),a=n+e.substring(n,e.length-1).indexOf(";"),i=e.substring(n,a+1);return e=e.replace(i,"")},Dk={json:"json",shader:null,javascript:"javascript",typescript:"typescript"},Ok=function(t){var n,a,i=JSON.parse(JSON.stringify(t.files)),s=e.exports.useState(0),r=s[0],o=s[1],l=function(e){o(e),null==Pk||Pk.setScrollPosition({scrollTop:0,scrollLeft:0}),document.querySelectorAll("#codePane .tabs-container .pcui-button").forEach((function(t,n){e===n?t.classList.add("selected"):t.classList.remove("selected")}))};return e.exports.useEffect((function(){var e=document.getElementById("codePane");e.classList.add("multiple-files"),i[r]||o(t.useTypeScript?1:0),t.useTypeScript&&0===r?l(1):t.useTypeScript||1!==r||l(0),e.ui.on("resize",(function(){localStorage.setItem("codePaneStyle",e.getAttribute("style"))}));var n=localStorage.getItem("codePaneStyle");(n&&e.setAttribute("style",n),window.toggleEvent)||(e.querySelector(".panel-toggle").addEventListener("click",(function(){e.classList.toggle("collapsed"),localStorage.setItem("codePaneCollapsed",e.classList.contains("collapsed")?"true":"false")})),window.toggleEvent=!0)})),N.createElement(Lp,{headerText:"CODE",id:"codePane",class:"true"===localStorage.getItem("codePaneCollapsed")?"collapsed":null,resizable:"left",resizeMax:2e3},N.createElement("div",{className:"panel-toggle",id:"codePane-panel-toggle"}),N.createElement(Ah,{class:"tabs-wrapper"},N.createElement(Ah,{class:"code-editor-menu-container"},N.createElement(AR,{id:"play-button",enabled:!t.lintErrors,icon:"E304",text:"",ref:t.playButtonRef}),N.createElement(AR,{id:"language-button",text:t.useTypeScript?"JS":"TS",ref:t.languageButtonRef}),N.createElement(AR,{icon:"E259",text:"",onClick:function(){var e="#/"===location.hash?"misc/hello-world":location.hash.replace("#/","");window.open("https://github.com/playcanvas/engine/blob/dev/examples/src/examples/".concat(e,".tsx"))}})),N.createElement(Ah,{class:"tabs-container"},t.files.map((function(e,n){var a=t.useTypeScript&&0===n||!t.useTypeScript&&1===n;return N.createElement(AR,{key:n,id:"code-editor-file-tab-".concat(n),hidden:a,text:-1===e.name.indexOf(".")?"".concat(e.name,".").concat(e.type):e.name,class:n===r?"selected":"",onClick:function(){return l(n)}})})))),N.createElement(Rk,{language:Dk[null===(n=i[r])||void 0===n?void 0:n.type],value:null===(a=i[r])||void 0===a?void 0:a.text,beforeMount:function(e){e.languages.typescript.typescriptDefaults.addExtraLib(Ik,"@playcanvas/playcanvas.d.ts"),e.languages.typescript.javascriptDefaults.addExtraLib(Ik,"@playcanvas/playcanvas.d.ts")},onMount:function(e){Pk=e},onChange:function(e){var n;i[r].text=e,t.setFiles(i),n=t.useTypeScript?i[1].text:i[0].text,window.localStorage.setItem(window.location.hash.replace("#",""),kk(n))},onValidate:function(e){0===e.filter((function(e){return e.severity>1})).length?t.setLintErrors(!1):t.setLintErrors(!0)},options:{scrollbar:{horizontal:"visible"}}}))},Fk=function(t){var n=null,a=null,i=function(){a&&document.querySelector("iframe").contentDocument.removeEventListener("mousemove",a),document.querySelector("#canvas-container").classList.toggle("fullscreen");var e=document.querySelector("#appInner");e.classList.toggle("fullscreen"),document.querySelector("iframe").contentDocument.getElementById("appInner").classList.toggle("fullscreen"),e.classList.contains("fullscreen")&&(a=function(){e.classList.add("active"),n&&window.clearTimeout(n),n=setTimeout((function(){e.classList.remove("active")}),2e3)},document.querySelector("iframe").contentDocument.addEventListener("mousemove",a))};return e.exports.useEffect((function(){var e=function(e){27===e.keyCode&&document.querySelector("#canvas-container").classList.contains("fullscreen")&&i()};document.querySelector("iframe").contentDocument.addEventListener("keydown",e),document.addEventListener("keydown",e)})),N.createElement(Ah,{id:"menu"},N.createElement(Ah,{id:"menu-buttons"},N.createElement("img",{id:"playcanvas-icon",src:"https://playcanvas.com/viewer/static/playcanvas-logo.png",onClick:function(){window.open("https://github.com/playcanvas/engine")}}),N.createElement(AR,{icon:"E256",text:"",onClick:function(){var e=encodeURI("Check out this @playcanvas engine example! ".concat(location.href.replace("#/","")));window.open("https://twitter.com/intent/tweet?text=".concat(e))}}),N.createElement(AR,{icon:"E149",id:"showMiniStatsButton",class:"selected",text:"",onClick:function(){document.getElementById("showMiniStatsButton").classList.toggle("selected"),t.setShowMiniStats(document.getElementById("showMiniStatsButton").classList.contains("selected"))}}),N.createElement(AR,{icon:"E127",text:"",id:"fullscreen-button",onClick:i})))};!function(e){if(!e||!window)return;const t=document.createElement("style");t.setAttribute("type","text/css"),t.innerHTML=e,document.head.appendChild(t)}("@keyframes animation-spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n.pcui-spinner {\n  display: inline-block;\n  margin: 6px;\n  vertical-align: middle;\n}\n.pcui-spinner > path {\n  animation-name: animation-spin;\n  animation-duration: 750ms;\n  animation-iteration-count: infinite;\n  animation-timing-function: linear;\n  transform-origin: center;\n}\n.pcui-spinner.pcui-error > path {\n  animation: none;\n  fill: #ff2020;\n}\n.pcui-spinner.pcui-error > path.pcui-spinner-highlight {\n  fill: #ff7777;\n}");class Nk extends xh{constructor(e){let t=null;(e=Object.assign({type:Nk.TYPE_SMALL_THICK},e)).type===Nk.TYPE_SMALL_THICK&&(t=function(e,t){const n=t||document.createElementNS("http://www.w3.org/2000/svg","svg");return n.classList.add("spin"),n.setAttribute("width",e),n.setAttribute("height",e),n.setAttribute("viewBox","0 0 14 14"),n.setAttribute("fill","none"),n.innerHTML='<path d="M7 14C3.13871 14 0 10.8613 0 7C0 3.13871 3.13871 0 7 0C10.8613 0 14 3.13871 14 7C14 10.8613 10.8613 14 7 14ZM7 2.25806C4.38064 2.25806 2.25806 4.38064 2.25806 7C2.25806 9.61935 4.38064 11.7419 7 11.7419C9.61935 11.7419 11.7419 9.61935 11.7419 7C11.7419 4.38064 9.61935 2.25806 7 2.25806Z" fill="#773417"/><path class="pcui-spinner-highlight" d="M7 14V11.7419C9.61935 11.7419 11.7419 9.61935 11.7419 7H14C14 10.8613 10.8613 14 7 14Z" fill="#FF6600"/>',n}(e.size||12,e.dom)),super(t,e),this.class.add("pcui-spinner")}}Nk.TYPE_SMALL_THICK="small-thick";var Vk=function(e){oh(n,Sh);var t=ph(n);function n(e){var a;return ah(this,n),(a=t.call(this,e)).elementClass=Nk,a}return sh(n,[{key:"render",value:function(){return N.createElement("svg",{ref:this.attachElement})}}]),n}();Vk.propTypes={size:nd.number},Vk.ctor=Nk,Vk.defaultProps={size:12};var Bk=function(t){var n=e.exports.useState({showParameters:!1,showCode:!0,collapsed:window.top.innerWidth<601}),a=n[0],i=n[1];return e.exports.useEffect((function(){window.top.innerWidth<601&&(document.getElementById("controlPanel-controls").ui.hidden=!0),0===window.top.location.hash.indexOf("#/iframe")&&(document.getElementById("controlPanel").ui.hidden=!0)})),N.createElement(Lp,{id:"controlPanel",class:[window.top.innerWidth>600&&!t.controls?"empty":"null",window.top.innerWidth<601?"mobile":null],resizable:"top",headerText:window.top.innerWidth<601?t.controls?"CODE & CONTROLS":"CODE":"CONTROLS",collapsible:!0,collapsed:a.collapsed},window.top.innerWidth<601&&t.controls&&N.createElement(Ah,{id:"controlPanel-tabs",class:"tabs-container"},N.createElement(AR,{text:"CODE",id:"codeButton",class:a.showCode?"selected":null,onClick:function(){document.getElementById("codeButton").classList.contains("selected")||(i({showParameters:!1,showCode:!0,collapsed:!1}),document.getElementById("paramButton").classList.toggle("selected"),document.getElementById("codeButton").classList.toggle("selected"),document.getElementById("controlPanel-controls").classList.add("pcui-hidden"))}}),N.createElement(AR,{text:"PARAMETERS",class:a.showParameters?"selected":null,id:"paramButton",onClick:function(){document.getElementById("paramButton").classList.contains("selected")||(i({showParameters:!0,showCode:!1,collapsed:!1}),document.getElementById("paramButton").classList.toggle("selected"),document.getElementById("codeButton").classList.toggle("selected"),document.getElementById("controlPanel-controls").classList.remove("pcui-hidden"))}})),N.createElement(Ah,{id:"controlPanel-controls"},t.controls),window.top.innerWidth<601&&a.showCode&&N.createElement(Rk,{options:{readOnly:!0},defaultLanguage:"typescript",value:t.files?t.files[0].text:""}))},Uk=function(e){var t=IP.paths[e.path].example.prototype.controls?IP.paths[e.path].example.prototype.controls(window.observerData).props.children:null;return t?N.createElement(Bk,{controls:t,files:e.files}):null},zk=function(e){function t(t){var n=e.call(this,t)||this;return n.state={exampleLoaded:!1},window.addEventListener("exampleLoad",(function(){n.setState({exampleLoaded:!0})})),n}return oR(t,e),t.prototype.componentDidUpdate=function(e){e.path!==this.props.path&&this.setState({exampleLoaded:!1})},t.prototype.render=function(){return N.createElement(N.Fragment,null,this.state.exampleLoaded&&N.createElement(Uk,lR({},this.props)))},t}(e.exports.Component),Gk=function(e){var t="withRouter("+(e.displayName||e.name)+")",n=function(t){var n=t.wrappedComponentRef,a=Gd(t,["wrappedComponentRef"]);return N.createElement(sp.Consumer,null,(function(t){return t||cd(!1),N.createElement(e,ad({},a,t,{ref:n}))}))};return n.displayName=t,n.WrappedComponent=e,np(n,e)}(function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return oR(t,e),t.prototype.componentDidMount=function(){window.localStorage.removeItem(this.path),this.props.setFiles(this.defaultFiles)},t.prototype.shouldComponentUpdate=function(e){return this.props.match.params.category!==e.match.params.category||this.props.match.params.example!==e.match.params.example},t.prototype.componentDidUpdate=function(){window.localStorage.removeItem(this.path),this.props.setFiles(this.defaultFiles)},Object.defineProperty(t.prototype,"defaultFiles",{get:function(){return IP.paths[this.path].files},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"path",{get:function(){return"/".concat(this.props.match.params.category,"/").concat(this.props.match.params.example)},enumerable:!1,configurable:!0}),t.prototype.render=function(){var e="/iframe".concat(this.path);return N.createElement(Ah,{id:"canvas-container"},N.createElement(Vk,{size:50}),N.createElement("iframe",{id:"exampleIframe",key:e,src:e}),N.createElement(zk,{path:this.path,files:this.props.files}))},t}(e.exports.Component));eh.render(N.createElement((function(){var t=e.exports.useState([{name:"example.ts",text:""}]),n=t[0],a=t[1],i=e.exports.useState(!1),s=i[0],r=i[1],o=e.exports.useState("true"===localStorage.getItem("useTypeScript")),l=o[0],c=o[1],h=e.exports.createRef(),d=e.exports.createRef();return e.exports.useEffect((function(){h.current&&(h.current.element.unbind(),h.current.element.on("click",(function(){document.getElementById("exampleIframe").contentWindow.location.reload()}))),d.current&&(d.current.element.unbind(),d.current.element.on("click",(function(){localStorage.setItem("useTypeScript",l?"false":"true"),c(!l)})))})),N.createElement("div",{id:"appInner"},N.createElement(yp,null,N.createElement(gp,null,N.createElement(fp,{exact:!0,path:"/"},N.createElement(dp,{to:"/misc/hello-world"})),N.createElement(fp,{path:"/:category/:example"},N.createElement(kP,null),N.createElement(Ah,{id:"main-view-wrapper"},N.createElement(Fk,{useTypeScript:l,setShowMiniStats:function(e){window._showMiniStats=e}}),N.createElement(Ah,{id:"main-view"},N.createElement(Ok,{lintErrors:s,setLintErrors:r,playButtonRef:h,languageButtonRef:d,useTypeScript:l,files:n,setFiles:a}),N.createElement(Gk,{files:n,setFiles:a,useTypeScript:l})))))))}),null),document.getElementById("app"));
