import{SEMANTIC_POSITION as e,SEMANTIC_ATTR12 as t,SEMANTIC_ATTR13 as i,SEMANTIC_ATTR14 as n,SEMANTIC_ATTR15 as o,SEMANTIC_NORMAL as s,SEMANTIC_TANGENT as a,SEMANTIC_COLOR as r,SEMANTIC_ATTR8 as l,SEMANTIC_ATTR9 as c,SEMANTIC_ATTR10 as d,SEMANTIC_ATTR11 as h,SEMANTIC_BLENDWEIGHT as u,SEMANTIC_BLENDINDICES as g,PIXELFORMAT_R8_G8_B8_A8 as f,SHADERTAG_MATERIAL as p,SEMANTIC_TEXCOORD0 as S,SEMANTIC_TEXCOORD1 as m}from"../../constants.js";import{shaderChunks as _}from"../chunks/chunks.js";import{ChunkUtils as v}from"../chunk-utils.js";import{SPRITE_RENDERMODE_SLICED as P,SPRITE_RENDERMODE_TILED as b,LIGHTTYPE_SPOT as C,LIGHTSHAPE_SPHERE as L,LIGHTSHAPE_DISK as w,LIGHTSHAPE_RECT as M,SHADER_DEPTH as D,SHADOW_VSM32 as A,SHADOW_PCF3 as E,LIGHTTYPE_OMNI as T,SHADOW_VSM8 as N,LIGHTTYPE_DIRECTIONAL as x,SHADOW_PCF5 as F,LIGHTSHAPE_PUNCTUAL as y,FRESNEL_SCHLICK as W,SPECOCC_GLOSSDEPENDENT as R,SPECOCC_AO as O,SHADOW_VSM16 as V,SPECULAR_PHONG as k,shadowTypeToString as G,LIGHTFALLOFF_LINEAR as I,BLEND_NORMAL as $,BLEND_PREMULTIPLIED as B,BLEND_ADDITIVEALPHA as H,SHADER_PICK as U}from"../../../scene/constants.js";import{LightsBuffer as j}from"../../../scene/lighting/lights-buffer.js";import{ShaderPass as X}from"../../../scene/shader-pass.js";import{skinCode as z,vertexIntro as q,fragmentIntro as Q,begin as Y,end as Z,gammaCode as K,tonemapCode as J,fogCode as ee}from"./common.js";import"../../../core/tracing.js";const te={vertex_normal:s,vertex_tangent:a,vertex_texCoord0:S,vertex_texCoord1:m,vertex_color:r,vertex_boneWeights:u,vertex_boneIndices:g},ie={vVertexColor:"vec4",vPositionW:"vec3",vNormalV:"vec3",vNormalW:"vec3",vTangentW:"vec3",vBinormalW:"vec3",vObjectSpaceUpW:"vec3",vUv0:"vec2",vUv1:"vec2"};class ne{constructor(t,i){if(this.device=t,this.options=i,this.attributes={vertex_position:e},i.chunks){this.chunks={};const e=i.chunks;for(const t in _)if(e.hasOwnProperty(t)){const i=e[t];for(const e in te)te.hasOwnProperty(e)&&i.indexOf(e)>=0&&(this.attributes[e]=te[e]);this.chunks[t]=i}else this.chunks[t]=_[t]}else this.chunks=_;this.lighting=i.lights.length>0||!!i.dirLightMap||!!i.clusteredLightingEnabled,this.reflections=!!i.reflectionSource,i.useSpecular||(i.specularMap=i.glossMap=null),this.shadowPass=X.isShadow(i.pass),this.needsNormal=this.lighting||this.reflections||i.useSpecular||i.ambientSH||i.heightMap||i.enableGGXSpecular||i.clusteredLightingEnabled&&!this.shadowPass||i.clearCoatNormalMap,this.needsSceneColor=i.useDynamicRefraction,this.needsScreenSize=i.useDynamicRefraction,this.needsTransforms=i.useDynamicRefraction,this.varyings="",this.vshader=null,this.frontendDecl=null,this.frontendCode=null,this.frontendFunc=null,this.lightingUv=null,this.defines=[],this.fshader=null}_vsAddBaseCode(e,t,i){return e+=t.baseVS,i.nineSlicedMode!==P&&i.nineSlicedMode!==b||(e+=t.baseNineSlicedVS),e}_vsAddTransformCode(e,t,i,n){return e+=this.chunks.transformVS}_setMapTransform(e,t,i,n){const o=i+100*n;if(!e[3][o]){const s=`texture_${t}MapTransform`;e[0]+=`uniform vec3 ${s}0;\n`,e[0]+=`uniform vec3 ${s}1;\n`,e[1]+=`varying vec2 vUV${n}_${i};\n`,e[2]+=`   vUV${n}_${i} = vec2(dot(vec3(uv${n}, 1), ${s}0), dot(vec3(uv${n}, 1), ${s}1));\n`,e[3][o]=!0}return e}_fsGetBaseCode(){const e=this.options,t=this.chunks;let i=this.chunks.basePS;return e.nineSlicedMode===P?i+=t.baseNineSlicedPS:e.nineSlicedMode===b&&(i+=t.baseNineSlicedTiledPS),i}_fsGetStartCode(e,t,i,n){let o=i.startPS;return n.nineSlicedMode===P?o+=i.startNineSlicedPS:n.nineSlicedMode===b&&(o+=i.startNineSlicedTiledPS),o}_directionalShadowMapProjection(e,t,i,n,o){let s="";return e.numCascades>1&&(s+=`getShadowCascadeMatrix(light${n}_shadowMatrixPalette, light${n}_shadowCascadeDistances, light${n}_shadowCascadeCount);\n`,t=`(cascadeShadowMat, ${i});\n`),s+=o+t,s+=`fadeShadow(light${n}_shadowCascadeDistances);\n`,s}_nonPointShadowMapProjection(e,t,i,n,o){const s=`(${i}, ${n});\n`;return!t._normalOffsetBias||t._isVsm?t._type===C?t._isPcf&&(e.webgl2||e.extStandardDerivatives)?"       getShadowCoordPerspZbuffer"+s:"       getShadowCoordPersp"+s:this._directionalShadowMapProjection(t,s,n,o,"getShadowCoordOrtho"):t._type===C?t._isPcf&&(e.webgl2||e.extStandardDerivatives)?"       getShadowCoordPerspZbufferNormalOffset"+s:"       getShadowCoordPerspNormalOffset"+s:this._directionalShadowMapProjection(t,s,n,o,"getShadowCoordOrthoNormalOffset")}_getLightSourceShapeString(e){switch(e){case M:return"Rect";case w:return"Disk";case L:return"Sphere";default:return""}}generateVertexShader(e,f,p){const S=this.device,m=this.options,_=this.chunks;let v="",P="";v=this._vsAddBaseCode(v,_,m),P+="   vPositionW    = getWorldPosition();\n",this.options.pass===D&&(v+="varying float vDepth;\n",v+="#ifndef VIEWMATRIX\n",v+="#define VIEWMATRIX\n",v+="uniform mat4 matrix_view;\n",v+="#endif\n",v+="#ifndef CAMERAPLANES\n",v+="#define CAMERAPLANES\n",v+="uniform vec4 camera_params;\n\n",v+="#endif\n",P+="    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n"),this.options.useInstancing&&(this.attributes.instance_line1=t,this.attributes.instance_line2=i,this.attributes.instance_line3=n,this.attributes.instance_line4=o,v+=_.instancingVS),this.needsNormal&&(this.attributes.vertex_normal=s,P+="   vNormalW = getNormal();\n","sphereMap"===m.reflectionSource&&S.fragmentUniformsCount<=16&&(v+=_.viewNormalVS,P+="   vNormalV    = getViewNormal();\n"),m.hasTangents&&(m.heightMap||m.normalMap||m.enableGGXSpecular)?(this.attributes.vertex_tangent=a,v+=_.tangentBinormalVS,P+="   vTangentW   = getTangent();\n",P+="   vBinormalW  = getBinormal();\n"):m.enableGGXSpecular&&(v+=_.tangentBinormalVS,P+="   vObjectSpaceUpW  = getObjectSpaceUp();\n"));for(let t=0;t<2;t++)e[t]&&(this.attributes["vertex_texCoord"+t]="TEXCOORD"+t,v+=_["uv"+t+"VS"],P+="   vec2 uv"+t+" = getUv"+t+"();\n"),f[t]&&(P+="   vUv"+t+" = uv"+t+";\n");const b=[v,this.varyings,P,[]];p.forEach((e=>{this._setMapTransform(b,e.name,e.id,e.uv)})),v=b[0],this.varyings=b[1],P=b[2],m.vertexColors&&(this.attributes.vertex_color=r,P+="   vVertexColor = vertex_color;\n"),m.msdf&&m.msdfTextAttribute&&(this.attributes.vertex_outlineParameters=l,this.attributes.vertex_shadowParameters=c,P+="    unpackMsdfParams();\n",v+=_.msdfVS),(m.useMorphPosition||m.useMorphNormal)&&(m.useMorphTextureBased?(v+="#define MORPHING_TEXTURE_BASED\n",m.useMorphPosition&&(v+="#define MORPHING_TEXTURE_BASED_POSITION\n"),m.useMorphNormal&&(v+="#define MORPHING_TEXTURE_BASED_NORMAL\n"),this.attributes.morph_vertex_id=o,v+="attribute float morph_vertex_id;\n"):(v+="#define MORPHING\n",m.useMorphPosition?(this.attributes.morph_pos0=l,this.attributes.morph_pos1=c,this.attributes.morph_pos2=d,this.attributes.morph_pos3=h,v+="#define MORPHING_POS03\n",v+="attribute vec3 morph_pos0;\n",v+="attribute vec3 morph_pos1;\n",v+="attribute vec3 morph_pos2;\n",v+="attribute vec3 morph_pos3;\n"):m.useMorphNormal&&(this.attributes.morph_nrm0=l,this.attributes.morph_nrm1=c,this.attributes.morph_nrm2=d,this.attributes.morph_nrm3=h,v+="#define MORPHING_NRM03\n",v+="attribute vec3 morph_nrm0;\n",v+="attribute vec3 morph_nrm1;\n",v+="attribute vec3 morph_nrm2;\n",v+="attribute vec3 morph_nrm3;\n"),m.useMorphNormal?(this.attributes.morph_nrm4=t,this.attributes.morph_nrm5=i,this.attributes.morph_nrm6=n,this.attributes.morph_nrm7=o,v+="#define MORPHING_NRM47\n",v+="attribute vec3 morph_nrm4;\n",v+="attribute vec3 morph_nrm5;\n",v+="attribute vec3 morph_nrm6;\n",v+="attribute vec3 morph_nrm7;\n"):(this.attributes.morph_pos4=t,this.attributes.morph_pos5=i,this.attributes.morph_pos6=n,this.attributes.morph_pos7=o,v+="#define MORPHING_POS47\n",v+="attribute vec3 morph_pos4;\n",v+="attribute vec3 morph_pos5;\n",v+="attribute vec3 morph_pos6;\n",v+="attribute vec3 morph_pos7;\n"))),m.skin?(this.attributes.vertex_boneWeights=u,this.attributes.vertex_boneIndices=g,v+=z(S,_),v+="#define SKIN\n"):m.useInstancing&&(v+="#define INSTANCING\n"),m.screenSpace&&(v+="#define SCREENSPACE\n"),m.pixelSnap&&(v+="#define PIXELSNAP\n"),v=this._vsAddTransformCode(v,S,_,m),this.needsNormal&&(v+=_.normalVS),v+="\n",v+=_.startVS,v+=P,v+=_.endVS,v+="}",Object.keys(ie).forEach((e=>{v.indexOf(e)>=0&&(this.varyings+=`varying ${ie[e]} ${e};\n`)}));const C=q(S,"LitShader",this.options.pass,_.extensionVS);this.vshader=C+this.varyings+v}_fsGetBeginCode(){const e=this.device,t=this.chunks,i=this.options.forceFragmentPrecision;let n=Q(e,"LitShader",this.options.pass,t.extensionPS,i);for(let e=0;e<this.defines.length;e++)n+=`#define ${this.defines[e]}\n`;return n}_fsGetPickPassCode(){let e=this._fsGetBeginCode();return e+="uniform vec4 uColor;\n",e+=this.varyings,e+=this.frontendDecl,e+=this.frontendCode,e+=Y(),e+=this.frontendFunc,e+="    gl_FragColor = uColor;\n",e+=Z(),e}_fsGetDepthPassCode(){const e=this.chunks;let t=this._fsGetBeginCode();return t+="varying float vDepth;\n",t+=this.varyings,t+=e.packDepthPS,t+=this.frontendDecl,t+=this.frontendCode,t+=Y(),t+=this.frontendFunc,t+="    gl_FragColor = packFloat(vDepth);\n",t+=Z(),t}_fsGetShadowPassCode(){const e=this.device,t=this.options,i=this.chunks,n=this.varyings,o=X.toLightType(t.pass),s=X.toShadowType(t.pass);let a=this._fsGetBeginCode();e.extStandardDerivatives&&!e.webgl2&&(a+="uniform vec2 polygonOffset;\n"),s===A?e.textureFloatHighPrecision?a+="#define VSM_EXPONENT 15.0\n\n":a+="#define VSM_EXPONENT 5.54\n\n":s===V&&(a+="#define VSM_EXPONENT 5.54\n\n"),o!==x&&(a+="uniform vec3 view_position;\n",a+="uniform float light_radius;\n"),a+=n,a+=this.frontendDecl,a+=this.frontendCode,s!==E||e.webgl2&&o!==T?s===N&&(a+="vec2 encodeFloatRG( float v ) {\n",a+="    vec2 enc = vec2(1.0, 255.0) * v;\n",a+="    enc = fract(enc);\n",a+="    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n",a+="    return enc;\n",a+="}\n\n"):a+=i.packDepthPS,a+=Y(),a+=this.frontendFunc;const r=s===N||s===V||s===A,l=!e.webgl2&&e.extStandardDerivatives;return a+=o===T||r&&o!==x?"    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n":"    float depth = gl_FragCoord.z;\n",l&&(a+="    float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n",a+="    depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n"),s!==E||e.webgl2&&(o!==T||t.clusteredLightingEnabled)?s===E||s===F?(a+="    gl_FragColor = vec4(1.0);\n",t.clusteredLightingEnabled&&o===T&&e.webgl2&&(a+="    gl_FragDepth = depth;\n")):a+=s===N?"    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n":i.storeEVSMPS:a+="    gl_FragColor = packFloat(depth);\n",a+=Z(),a}_fsGetLitPassCode(){const e=this.device,t=this.options,i=this.chunks;let n="";!1===t.opacityFadesSpecular&&(n+="uniform float material_alphaFade;\n"),t.useSpecular&&(this.defines.push("LIT_SPECULAR"),this.reflections&&this.defines.push("LIT_REFLECTIONS"),t.clearCoat&&this.defines.push("LIT_CLEARCOAT"),t.fresnelModel>0&&this.defines.push("LIT_SPECULAR_FRESNEL"),t.conserveEnergy&&this.defines.push("LIT_CONSERVE_ENERGY"),t.sheen&&this.defines.push("LIT_SHEEN"),t.iridescence&&this.defines.push("LIT_IRIDESCENCE"));const o=[];let s=0,a=!1,r=!1,l=!1,c=t.lights.some((function(e){return e._shape&&e._shape!==y}));t.clusteredLightingEnabled&&t.clusteredLightingAreaLightsEnabled&&(c=!0);let d="highp";e.areaLightLutFormat===f&&(n+="#define AREA_R8_G8_B8_A8_LUTS\n",d="lowp"),(c||t.clusteredLightingEnabled)&&(n+="#define AREA_LIGHTS\n",n+=`uniform ${d} sampler2D areaLightsLutTex1;\n`,n+=`uniform ${d} sampler2D areaLightsLutTex2;\n`);for(let i=0;i<t.lights.length;i++){const d=t.lights[i],h=d._type;if(t.clusteredLightingEnabled&&h!==x)continue;const u=c&&d._shape?d._shape:y;n+="uniform vec3 light"+i+"_color;\n",h===x?n+="uniform vec3 light"+i+"_direction;\n":(n+="uniform vec3 light"+i+"_position;\n",n+="uniform float light"+i+"_radius;\n",h===C&&(n+="uniform vec3 light"+i+"_direction;\n",n+="uniform float light"+i+"_innerConeAngle;\n",n+="uniform float light"+i+"_outerConeAngle;\n")),u!==y&&(h===x&&(n+="uniform vec3 light"+i+"_position;\n"),n+="uniform vec3 light"+i+"_halfWidth;\n",n+="uniform vec3 light"+i+"_halfHeight;\n"),d.castShadows&&!t.noShadow&&(n+="uniform mat4 light"+i+"_shadowMatrix;\n",n+="uniform float light"+i+"_shadowIntensity;\n",h===x&&(n+="uniform mat4 light"+i+"_shadowMatrixPalette[4];\n",n+="uniform float light"+i+"_shadowCascadeDistances[4];\n",n+="uniform float light"+i+"_shadowCascadeCount;\n"),h!==x?n+="uniform vec4 light"+i+"_shadowParams;\n":(a=!0,n+="uniform vec3 light"+i+"_shadowParams;\n"),h===T?n+="uniform samplerCube light"+i+"_shadowMap;\n":d._isPcf&&e.webgl2?n+="uniform sampler2DShadow light"+i+"_shadowMap;\n":n+="uniform sampler2D light"+i+"_shadowMap;\n",s++,o[d._shadowType]=!0,d._isVsm&&(r=!0),d._isPcf&&(e.webgl2||e.extStandardDerivatives)&&h===C&&(l=!0)),d._cookie&&(d._cookie._cubemap?h===T&&(n+="uniform samplerCube light"+i+"_cookie;\n",n+="uniform float light"+i+"_cookieIntensity;\n",d.castShadows&&!t.noShadow||(n+="uniform mat4 light"+i+"_shadowMatrix;\n")):h===C&&(n+="uniform sampler2D light"+i+"_cookie;\n",n+="uniform float light"+i+"_cookieIntensity;\n",d.castShadows&&!t.noShadow||(n+="uniform mat4 light"+i+"_shadowMatrix;\n"),d._cookieTransform&&(n+="uniform vec4 light"+i+"_cookieMatrix;\n",n+="uniform vec2 light"+i+"_cookieOffset;\n")))}n+="\n";const h=this.needsNormal&&(t.normalMap||t.clearCoatNormalMap||t.enableGGXSpecular&&!t.heightMap);h&&(t.hasTangents?n+=t.fastTbn?i.TBNfastPS:i.TBNPS:e.extStandardDerivatives&&(t.normalMap||t.clearCoatNormalMap)?n+=i.TBNderivativePS.replace(/\$UV/g,this.lightingUv):n+=i.TBNObjectSpacePS),n+=i.sphericalPS,n+=i.decodePS,n+=K(t.gamma,i),n+=J(t.toneMap,i),n+=ee(t.fog,i),n+=this.frontendCode,t.useCubeMapRotation&&(n+="#define CUBEMAP_ROTATION\n"),this.needsNormal&&(n+=i.cubeMapRotatePS,n+=t.cubeMapProjection>0?i.cubeMapProjectBoxPS:i.cubeMapProjectNonePS,n+=t.skyboxIntensity?i.envMultiplyPS:i.envConstPS),(this.lighting&&t.useSpecular||this.reflections)&&(t.useMetalness&&(n+=i.metalnessModulatePS),t.fresnelModel===W&&(n+=i.fresnelSchlickPS),t.iridescence&&(n+=i.iridescenceDiffractionPS));const u=t.aoMap||t.aoVertexColor;if(u)switch(n+=i.aoDiffuseOccPS,t.occludeSpecular){case O:n+=t.occludeSpecularFloat?i.aoSpecOccSimplePS:i.aoSpecOccConstSimplePS;break;case R:n+=t.occludeSpecularFloat?i.aoSpecOccPS:i.aoSpecOccConstPS}if("envAtlasHQ"===t.reflectionSource)n+=t.fixSeams?i.fixCubemapSeamsStretchPS:i.fixCubemapSeamsNonePS,n+=i.envAtlasPS,n+=i.reflectionEnvHQPS.replace(/\$DECODE/g,v.decodeFunc(t.reflectionEncoding));else if("envAtlas"===t.reflectionSource)n+=i.envAtlasPS,n+=i.reflectionEnvPS.replace(/\$DECODE/g,v.decodeFunc(t.reflectionEncoding));else if("cubeMap"===t.reflectionSource)n+=t.fixSeams?i.fixCubemapSeamsStretchPS:i.fixCubemapSeamsNonePS,n+=i.reflectionCubePS.replace(/\$DECODE/g,v.decodeFunc(t.reflectionEncoding));else if("sphereMap"===t.reflectionSource){n+=(e.fragmentUniformsCount>16?i.reflectionSpherePS:i.reflectionSphereLowPS).replace(/\$DECODE/g,v.decodeFunc(t.reflectionEncoding))}this.reflections&&(t.clearCoat&&(n+=i.reflectionCCPS),t.sheen&&(n+=i.reflectionSheenPS)),t.refraction&&(t.useDynamicRefraction?n+=i.refractionDynamicPS:this.reflections&&(n+=i.refractionCubePS)),t.sheen&&(n+=i.lightSheenPS),t.clusteredLightingEnabled&&(n+=i.clusteredLightUtilsPS,t.clusteredLightingCookiesEnabled&&(n+=i.clusteredLightCookiesPS),t.clusteredLightingShadowsEnabled&&!t.noShadow&&(o[E]=!0,o[F]=!0),l=!0),(s>0||t.clusteredLightingEnabled)&&(a&&(n+=i.shadowCascadesPS),o[E]&&(n+=i.shadowStandardPS),o[F]&&e.webgl2&&(n+=i.shadowStandardGL2PS),r&&(n+=i.shadowVSM_commonPS,o[N]&&(n+=i.shadowVSM8PS),o[V]&&(n+=e.extTextureHalfFloatLinear?i.shadowEVSMPS.replace(/\$/g,"16"):i.shadowEVSMnPS.replace(/\$/g,"16")),o[A]&&(n+=e.extTextureFloatLinear?i.shadowEVSMPS.replace(/\$/g,"32"):i.shadowEVSMnPS.replace(/\$/g,"32"))),e.webgl2||e.extStandardDerivatives||(n+=i.biasConstPS),n+=i.shadowCoordPS+i.shadowCommonPS,l&&(n+=i.shadowCoordPerspZbufferPS)),t.enableGGXSpecular&&(n+="uniform float material_anisotropy;\n"),this.lighting&&(n+=i.lightDiffuseLambertPS,(c||t.clusteredLightingEnabled)&&(n+=i.ltc)),n+="\n";let g=!1;t.useSpecular&&(this.lighting&&(n+=t.shadingModel===k?i.lightSpecularPhongPS:t.enableGGXSpecular?i.lightSpecularAnisoGGXPS:i.lightSpecularBlinnPS),t.fresnelModel||this.reflections||t.diffuseMap||(n+="    uniform vec3 material_ambient;\n",n+="#define LIT_OLD_AMBIENT",g=!0)),n+=i.combinePS,(t.lightMap||t.lightVertexColor)&&(n+=t.useSpecular&&t.dirLightMap?i.lightmapDirAddPS:i.lightmapAddPS);const p=!t.lightMap&&!t.lightVertexColor||t.lightMapWithoutAmbient;p&&("ambientSH"===t.ambientSource?n+=i.ambientSHPS:"envAtlas"===t.ambientSource?("envAtlas"!==t.reflectionSource&&"envAtlasHQ"!==t.reflectionSource&&(n+=i.envAtlasPS),n+=i.ambientEnvPS.replace(/\$DECODE/g,v.decodeFunc(t.ambientEncoding))):n+=i.ambientConstantPS),t.ambientTint&&!g&&(n+="uniform vec3 material_ambient;\n"),t.msdf&&(t.msdfTextAttribute||(n+="\n#define UNIFORM_TEXT_PARAMETERS"),n+=i.msdfPS),this.needsNormal&&(n+=i.viewDirPS,t.useSpecular&&(n+=t.enableGGXSpecular?i.reflDirAnisoPS:i.reflDirPS));let S,m=!1,_=!1,P=!1,b=!1,L=!1;if(t.clusteredLightingEnabled&&this.lighting&&(b=!0,m=!0,_=!0,L=!0,n+=i.floatUnpackingPS,t.lightMaskDynamic&&(n+="\n#define CLUSTER_MESH_DYNAMIC_LIGHTS"),t.clusteredLightingCookiesEnabled&&(n+="\n#define CLUSTER_COOKIES"),t.clusteredLightingShadowsEnabled&&!t.noShadow&&(n+="\n#define CLUSTER_SHADOWS",n+="\n#define CLUSTER_SHADOW_TYPE_"+G[t.clusteredLightingShadowType]),t.clusteredLightingAreaLightsEnabled&&(n+="\n#define CLUSTER_AREALIGHTS"),n+=j.shaderDefines,t.clusteredLightingShadowsEnabled&&!t.noShadow&&(n+=i.clusteredLightShadowsPS),n+=i.clusteredLightPS),t.twoSidedLighting&&(n+="uniform float twoSidedLightingNegScaleFactor;\n"),n+=this._fsGetStartCode(n,e,i,t),this.needsNormal&&(t.twoSidedLighting?n+="    dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);\n":n+="    dVertexNormalW = normalize(vNormalW);\n",(t.heightMap||t.normalMap)&&t.hasTangents&&(t.twoSidedLighting?(n+="    dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;\n",n+="    dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;\n"):(n+="    dTangentW = vTangentW;\n",n+="    dBinormalW = vBinormalW;\n")),n+="    getViewDir();\n",h&&(n+="    getTBN();\n")),n+=this.frontendFunc,this.needsNormal&&(t.useSpecular&&(n+="    getReflDir();\n"),t.clearCoat&&(n+="    ccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\n")),(this.lighting&&t.useSpecular||this.reflections)&&(t.useMetalness&&(n+="    getMetalnessModulate();\n"),t.iridescence&&(n+="    getIridescence(saturate(dot(dViewDirW, dNormalW)));\n")),p&&(n+="    addAmbient();\n",t.separateAmbient&&(n+="\n                    vec3 dAmbientLight = dDiffuseLight;\n                    dDiffuseLight = vec3(0);\n                ")),t.ambientTint&&!g&&(n+="    dDiffuseLight *= material_ambient;\n"),u&&!t.occludeDirect&&(n+="    occludeDiffuse();\n"),(t.lightMap||t.lightVertexColor)&&(n+="    addLightMap();\n"),this.lighting||this.reflections){this.reflections&&(t.clearCoat&&(n+="    addReflectionCC();\n",t.fresnelModel>0?(n+="    ccFresnel = getFresnelCC(dot(dViewDirW, ccNormalW), ccGlossiness);\n",n+="    ccReflection.rgb *= ccFresnel;\n"):n+="    ccFresnel = 0.0;\n"),t.useSpecularityFactor&&(n+="    ccReflection.rgb *= dSpecularityFactor;\n"),t.sheen&&(n+="    addReflectionSheen();\n"),n+="    addReflection();\n",t.fresnelModel>0?n+="    dReflection.rgb *= getFresnel(dot(dViewDirW, dNormalW), dSpecularity);\n":n+="    dReflection.rgb *= dSpecularity;\n",t.useSpecularityFactor&&(n+="    dReflection.rgb *= dSpecularityFactor;\n")),c&&(n+="    dSpecularLight *= dSpecularity;\n",t.useSpecular&&(n+="    calcLTCLightValues();\n"));for(let i=0;i<t.lights.length;i++){const o=t.lights[i],s=o._type;if(t.clusteredLightingEnabled&&s!==x)continue;S=!1;const a=c&&o._shape?o.shape:y,r=c&&o._shape?this._getLightSourceShapeString(a):"";if(a!==y&&(n+="    calc"+r+"LightValues(light"+i+"_position, light"+i+"_halfWidth, light"+i+"_halfHeight);\n"),s===x?(n+="    dLightDirNormW = light"+i+"_direction;\n",n+="    dAtten = 1.0;\n"):(o._cookie&&(s!==C||o._cookie._cubemap?s===T&&o._cookie._cubemap&&(L=!0,S=!0):(L=!0,S=!0)),n+="    getLightDirPoint(light"+i+"_position);\n",m=!0,S&&(n+=s===C?"    dAtten3 = getCookie2D"+(o._cookieFalloff?"":"Clip")+(o._cookieTransform?"Xform":"")+"(light"+i+"_cookie, light"+i+"_shadowMatrix, light"+i+"_cookieIntensity"+(o._cookieTransform?", light"+i+"_cookieMatrix, light"+i+"_cookieOffset":"")+")."+o._cookieChannel+";\n":"    dAtten3 = getCookieCube(light"+i+"_cookie, light"+i+"_shadowMatrix, light"+i+"_cookieIntensity)."+o._cookieChannel+";\n"),a===y?o._falloffMode===I?(n+="    dAtten = getFalloffLinear(light"+i+"_radius);\n",_=!0):(n+="    dAtten = getFalloffInvSquared(light"+i+"_radius);\n",P=!0):(n+="    dAtten = getFalloffWindow(light"+i+"_radius);\n",P=!0),n+="    if (dAtten > 0.00001) {\n",s===C&&(S&&!o._cookieFalloff||(n+="    dAtten *= getSpotEffect(light"+i+"_direction, light"+i+"_innerConeAngle, light"+i+"_outerConeAngle);\n",b=!0))),n+=a!==y?s===x?"    dAttenD = getLightDiffuse();\n":"    dAttenD = get"+r+"LightDiffuse() * 16.0;\n":"    dAtten *= getLightDiffuse();\n",o.castShadows&&!t.noShadow){let a,r=null;if(o._shadowType===N?(r="VSM8",a="0.0"):o._shadowType===V?(r="VSM16",a="5.54"):o._shadowType===A?(r="VSM32",a=e.textureFloatHighPrecision?"15.0":"5.54"):r=o._shadowType===F?"PCF5x5":"PCF3x3",null!==r)if(s===T){const e="(light"+i+"_shadowMap, light"+i+"_shadowParams);\n";o._normalOffsetBias&&(n+="    normalOffsetPointShadow(light"+i+"_shadowParams);\n"),n+=`    float shadow${i} = getShadowPoint${r}${e}`,n+=`    dAtten *= mix(1.0, shadow${i}, light${i}_shadowIntensity);\n`}else{const l=`light${i}_shadowMatrix`,c=`light${i}_shadowParams`;n+=this._nonPointShadowMapProjection(e,t.lights[i],l,c,i),s===C&&(r="Spot"+r),n+=`    float shadow${i} = getShadow${r}(light${i}_shadowMap, light${i}_shadowParams${o._isVsm?", "+a:""});\n`,n+=`    dAtten *= mix(1.0, shadow${i}, light${i}_shadowIntensity);\n`}}if(a!==y?t.conserveEnergy&&t.useSpecular?n+="    dDiffuseLight += mix((dAttenD * dAtten) * light"+i+"_color"+(S?" * dAtten3":"")+", vec3(0), dLTCSpecFres);\n":n+="    dDiffuseLight += (dAttenD * dAtten) * light"+i+"_color"+(S?" * dAtten3":"")+";\n":c&&t.conserveEnergy&&t.useSpecular?n+="    dDiffuseLight += mix(dAtten * light"+i+"_color"+(S?" * dAtten3":"")+", vec3(0), dSpecularity);\n":n+="    dDiffuseLight += dAtten * light"+i+"_color"+(S?" * dAtten3":"")+";\n",t.useSpecular&&(n+="    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);\n"),a!==y)t.clearCoat&&(n+="    ccSpecularLight += ccLTCSpecFres * get"+r+"LightSpecularCC() * dAtten * light"+i+"_color"+(S?" * dAtten3":"")+";\n"),t.useSpecular&&(n+="    dSpecularLight += dLTCSpecFres * get"+r+"LightSpecular() * dAtten * light"+i+"_color"+(S?" * dAtten3":"")+";\n");else{var w=!1;s===x&&t.fresnelModel>0&&(w=!0),t.clearCoat&&(n+="    ccSpecularLight += getLightSpecularCC(dHalfDirW) * dAtten * light"+i+"_color",n+=S?" * dAtten3":"",n+=w?" * getFresnelCC(dot(dViewDirW, dHalfDirW), ccGlossiness)":"",n+=";\n"),t.sheen&&(n+="    sSpecularLight += getLightSpecularSheen(dHalfDirW) * dAtten * light"+i+"_color",n+=S?" * dAtten3":"",n+=";\n"),t.useSpecular&&(n+="    dSpecularLight += getLightSpecular(dHalfDirW) * dAtten * light"+i+"_color",n+=S?" * dAtten3":"",n+=w?" * getFresnel(dot(dViewDirW, dHalfDirW), dSpecularity)":"",n+=";\n")}s!==x&&(n+="    }\n"),n+="\n"}t.clusteredLightingEnabled&&this.lighting&&(_=!0,P=!0,m=!0,n+="    addClusteredLights();\n"),c&&(t.clearCoat&&(n+="    ccSpecularity = 1.0;\n"),t.useSpecular&&(n+="    dSpecularity = vec3(1);\n")),t.refraction&&(n+="    addRefraction();\n")}n+="\n",u&&(t.occludeDirect&&(n+="    occludeDiffuse();\n"),t.occludeSpecular!==O&&t.occludeSpecular!==R||(n+="    occludeSpecular();\n")),t.useSpecularityFactor&&(n+="    dSpecularLight *= dSpecularityFactor;\n"),!1===t.opacityFadesSpecular&&(t.blendType!==$&&t.blendType!==B||(n+="float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));\n",n+="#ifdef LIT_CLEARCOAT\n specLum += dot(ccSpecularLight * ccSpecularity + ccReflection.rgb * ccSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif\n",n+="dAlpha = clamp(dAlpha + gammaCorrectInput(specLum), 0.0, 1.0);\n"),n+="dAlpha *= material_alphaFade;\n"),n+=i.endPS,t.blendType===$||t.blendType===H||t.alphaToCoverage?n+=i.outputAlphaPS:t.blendType===B?n+=i.outputAlphaPremulPS:n+=i.outputAlphaOpaquePS,t.msdf&&(n+="    gl_FragColor = applyMsdf(gl_FragColor);\n"),n+="\n",n+=Z(),m&&(n=i.lightDirPointPS+n),_&&(n=i.falloffLinearPS+n),P&&(n=i.falloffInvSquaredPS+n),b&&(n=i.spotPS+n),L&&!t.clusteredLightingEnabled&&(n=i.cookiePS+n);let M="";n.includes("dReflection")&&(M+="vec4 dReflection;\n"),n.includes("dTBN")&&(M+="mat3 dTBN;\n"),n.includes("dVertexNormalW")&&(M+="vec3 dVertexNormalW;\n"),n.includes("dTangentW")&&(M+="vec3 dTangentW;\n"),n.includes("dBinormalW")&&(M+="vec3 dBinormalW;\n"),n.includes("dViewDirW")&&(M+="vec3 dViewDirW;\n"),n.includes("dReflDirW")&&(M+="vec3 dReflDirW;\n"),n.includes("dHalfDirW")&&(M+="vec3 dHalfDirW;\n"),n.includes("dDiffuseLight")&&(M+="vec3 dDiffuseLight;\n"),n.includes("dSpecularLight")&&(M+="vec3 dSpecularLight;\n"),n.includes("dLightDirNormW")&&(M+="vec3 dLightDirNormW;\n"),n.includes("dLightDirW")&&(M+="vec3 dLightDirW;\n"),n.includes("dLightPosW")&&(M+="vec3 dLightPosW;\n"),n.includes("dShadowCoord")&&(M+="vec3 dShadowCoord;\n"),n.includes("dAtten")&&(M+="float dAtten;\n"),n.includes("dAttenD")&&(M+="float dAttenD;\n"),n.includes("dAtten3")&&(M+="vec3 dAtten3;\n"),n.includes("dMsdf")&&(M+="vec4 dMsdf;\n"),n.includes("ccFresnel")&&(M+="float ccFresnel;\n"),n.includes("ccReflection")&&(M+="vec3 ccReflection;\n"),n.includes("ccReflDirW")&&(M+="vec3 ccReflDirW;\n"),n.includes("ccSpecularLight")&&(M+="vec3 ccSpecularLight;\n"),n.includes("ccSpecularityNoFres")&&(M+="float ccSpecularityNoFres;\n"),n.includes("sSpecularLight")&&(M+="vec3 sSpecularLight;\n"),n.includes("sReflection")&&(M+="vec3 sReflection;\n");return this._fsGetBeginCode()+this.varyings+this._fsGetBaseCode()+(t.detailModes?i.detailModesPS:"")+M+this.frontendDecl+n}generateFragmentShader(e,t,i,n){const o=this.options;this.frontendDecl=e,this.frontendCode=t,this.frontendFunc=i,this.lightingUv=n,o.pass===U?this.fshader=this._fsGetPickPassCode():o.pass===D?this.fshader=this._fsGetDepthPassCode():this.shadowPass?this.fshader=this._fsGetShadowPassCode():o.customFragmentShader?this.fshader=this._fsGetBeginCode()+o.customFragmentShader:this.fshader=this._fsGetLitPassCode()}getDefinition(){const e={attributes:this.attributes,vshader:this.vshader,fshader:this.fshader};return X.isForward(this.options.pass)&&(e.tag=p),e}}export{ne as LitShader};
