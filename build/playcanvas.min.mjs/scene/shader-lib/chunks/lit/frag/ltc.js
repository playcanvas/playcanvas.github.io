var t='\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nmat3 transposeMat3( const in mat3 m ) {\n\t\tmat3 tmp;\n\t\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\t\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\t\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\t\treturn tmp;\n}\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\t\tconst float LUT_SIZE = 64.0;\n\t\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\t\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\t\tfloat dotNV = saturate( dot( N, V ) );\n\t\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\t\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\t\tuv = uv * LUT_SCALE + LUT_BIAS;\n\t\treturn uv;\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\t\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t\t// An approximation of the form factor of a horizon-clipped rectangle.\n\t\tfloat l = length( f );\n\t\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\t\tfloat x = dot( v1, v2 );\n\t\tfloat y = abs( x );\n\t\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\t\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\t\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\t\tfloat v = a / b;\n\t\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\t\treturn cross( v1, v2 ) * theta_sintheta;\n}\n\nstruct Coords {\n\t\tvec3 coord0;\n\t\tvec3 coord1;\n\t\tvec3 coord2;\n\t\tvec3 coord3;\n};\n\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\n\t\t// bail if point is on back side of plane of light\n\t\t// assumes ccw winding order of light vertices\n\t\tvec3 v1 = rectCoords.coord1 - rectCoords.coord0;\n\t\tvec3 v2 = rectCoords.coord3 - rectCoords.coord0;\n\t\t\n\t\tvec3 lightNormal = cross( v1, v2 );\n\t\t// if( dot( lightNormal, P - rectCoords.coord0 ) < 0.0 ) return 0.0;\n\t\tfloat factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\n\n\t\t// construct orthonormal basis around N\n\t\tvec3 T1, T2;\n\t\tT1 = normalize( V - N * dot( V, N ) );\n\t\tT2 =  factor * cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\t\t// compute transform\n\t\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\t\t// transform rect\n\t\tvec3 coords[ 4 ];\n\t\tcoords[ 0 ] = mat * ( rectCoords.coord0 - P );\n\t\tcoords[ 1 ] = mat * ( rectCoords.coord1 - P );\n\t\tcoords[ 2 ] = mat * ( rectCoords.coord2 - P );\n\t\tcoords[ 3 ] = mat * ( rectCoords.coord3 - P );\n\t\t// project rect onto sphere\n\t\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\t\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\t\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\t\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\t\t// calculate vector form factor\n\t\tvec3 vectorFormFactor = vec3( 0.0 );\n\t\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\t\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\t\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\t\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\t\t// adjust for horizon clipping\n\t\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n\t\treturn result;\n}\n\nCoords dLTCCoords;\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\t\tCoords coords;\n\t\tcoords.coord0 = lightPos + halfWidth - halfHeight;\n\t\tcoords.coord1 = lightPos - halfWidth - halfHeight;\n\t\tcoords.coord2 = lightPos - halfWidth + halfHeight;\n\t\tcoords.coord3 = lightPos + halfWidth + halfHeight;\n\t\treturn coords;\n}\n\nfloat dSphereRadius;\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\t\t// used for simple sphere light falloff\n\t\t// also, the code only handles a spherical light, it cannot be non-uniformly scaled in world space, and so we enforce it here\n\t\tdSphereRadius = max(length(halfWidth), length(halfHeight));\n\n\t\t// Billboard the 2d light quad to reflection vector, as it\'s used for specular. This allows us to use disk math for the sphere.\n\t\tvec3 f = reflect(normalize(lightPos - view_position), vNormalW);\n\t\tvec3 w = normalize(cross(f, halfHeight));\n\t\tvec3 h = normalize(cross(f, w));\n\n\t\treturn getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\n}\n\n// used for LTC LUT texture lookup\nvec2 dLTCUV;\n#ifdef LIT_CLEARCOAT\nvec2 ccLTCUV;\n#endif\nvec2 getLTCLightUV(float gloss, vec3 worldNormal, vec3 viewDir)\n{\n\t\tfloat roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);\n\t\treturn LTC_Uv( worldNormal, viewDir, roughness );\n}\n\n//used for energy conservation and to modulate specular\nvec3 dLTCSpecFres;\n#ifdef LIT_CLEARCOAT\nvec3 ccLTCSpecFres;\n#endif\nvec3 getLTCLightSpecFres(vec2 uv, vec3 specularity)\n{\n\t\tvec4 t2 = texture2DLodEXT(areaLightsLutTex2, uv, 0.0);\n\n\t\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\t\tt2 *= vec4(0.693103,1,1,1);\n\t\tt2 += vec4(0.306897,0,0,0);\n\t\t#endif\n\n\t\treturn specularity * t2.x + ( vec3( 1.0 ) - specularity) * t2.y;\n}\n\nvoid calcLTCLightValues(float gloss, vec3 worldNormal, vec3 viewDir, vec3 specularity, float clearcoatGloss, vec3 clearcoatWorldNormal, float clearcoatSpecularity)\n{\n\t\tdLTCUV = getLTCLightUV(gloss, worldNormal, viewDir);\n\t\tdLTCSpecFres = getLTCLightSpecFres(dLTCUV, specularity); \n\n#ifdef LIT_CLEARCOAT\n\t\tccLTCUV = getLTCLightUV(clearcoatGloss, clearcoatWorldNormal, viewDir);\n\t\tccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(clearcoatSpecularity));\n#endif\n}\n\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\t\tdLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\n}\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\t\tcalcRectLightValues(lightPos, halfWidth, halfHeight);\n}\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\t\tdLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\n}\n\n// An extended version of the implementation from\n// "How to solve a cubic equation, revisited"\n// http://momentsingraphics.de/?p=105\nvec3 SolveCubic(vec4 Coefficient)\n{\n\t\tfloat pi = 3.14159;\n\t\t// Normalize the polynomial\n\t\tCoefficient.xyz /= Coefficient.w;\n\t\t// Divide middle coefficients by three\n\t\tCoefficient.yz /= 3.0;\n\n\t\tfloat A = Coefficient.w;\n\t\tfloat B = Coefficient.z;\n\t\tfloat C = Coefficient.y;\n\t\tfloat D = Coefficient.x;\n\n\t\t// Compute the Hessian and the discriminant\n\t\tvec3 Delta = vec3(\n\t\t\t\t-Coefficient.z * Coefficient.z + Coefficient.y,\n\t\t\t\t-Coefficient.y * Coefficient.z + Coefficient.x,\n\t\t\t\tdot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\n\t\t);\n\n\t\tfloat Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\n\n\t\tvec3 RootsA, RootsD;\n\n\t\tvec2 xlc, xsc;\n\n\t\t// Algorithm A\n\t\t{\n\t\t\t\tfloat A_a = 1.0;\n\t\t\t\tfloat C_a = Delta.x;\n\t\t\t\tfloat D_a = -2.0 * B * Delta.x + Delta.y;\n\n\t\t\t\t// Take the cubic root of a normalized complex number\n\t\t\t\tfloat Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\n\n\t\t\t\tfloat x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\n\t\t\t\tfloat x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\n\n\t\t\t\tfloat xl;\n\t\t\t\tif ((x_1a + x_3a) > 2.0 * B)\n\t\t\t\t\t\txl = x_1a;\n\t\t\t\telse\n\t\t\t\t\t\txl = x_3a;\n\n\t\t\t\txlc = vec2(xl - B, A);\n\t\t}\n\n\t\t// Algorithm D\n\t\t{\n\t\t\t\tfloat A_d = D;\n\t\t\t\tfloat C_d = Delta.z;\n\t\t\t\tfloat D_d = -D * Delta.y + 2.0 * C * Delta.z;\n\n\t\t\t\t// Take the cubic root of a normalized complex number\n\t\t\t\tfloat Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\n\n\t\t\t\tfloat x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\n\t\t\t\tfloat x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\n\n\t\t\t\tfloat xs;\n\t\t\t\tif (x_1d + x_3d < 2.0 * C)\n\t\t\t\t\t\txs = x_1d;\n\t\t\t\telse\n\t\t\t\t\t\txs = x_3d;\n\n\t\t\t\txsc = vec2(-D, xs + C);\n\t\t}\n\n\t\tfloat E =  xlc.y * xsc.y;\n\t\tfloat F = -xlc.x * xsc.y - xlc.y * xsc.x;\n\t\tfloat G =  xlc.x * xsc.x;\n\n\t\tvec2 xmc = vec2(C * F - B * G, -B * F + C * E);\n\n\t\tvec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\n\n\t\tif (Root.x < Root.y && Root.x < Root.z)\n\t\t\t\tRoot.xyz = Root.yxz;\n\t\telse if (Root.z < Root.x && Root.z < Root.y)\n\t\t\t\tRoot.xyz = Root.xzy;\n\n\t\treturn Root;\n}\n\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\n{\n\t\t// construct orthonormal basis around N\n\t\tvec3 T1, T2;\n\t\tT1 = normalize(V - N * dot(V, N));\n\t\tT2 = cross(N, T1);\n\n\t\t// rotate area light in (T1, T2, N) basis\n\t\t//mat3 R = transpose(mat3(T1, T2, N));\n\t\tmat3 R = transposeMat3( mat3( T1, T2, N ) );\n\t\t// polygon (allocate 5 vertices for clipping)\n\t\tvec3 L_[ 3 ];\n\t\tL_[ 0 ] = R * ( points.coord0 - P );\n\t\tL_[ 1 ] = R * ( points.coord1 - P );\n\t\tL_[ 2 ] = R * ( points.coord2 - P );\n\n\t\tvec3 Lo_i = vec3(0);\n\n\t\t// init ellipse\n\t\tvec3 C  = 0.5 * (L_[0] + L_[2]);\n\t\tvec3 V1 = 0.5 * (L_[1] - L_[2]);\n\t\tvec3 V2 = 0.5 * (L_[1] - L_[0]);\n\n\t\tC  = Minv * C;\n\t\tV1 = Minv * V1;\n\t\tV2 = Minv * V2;\n\n\t\t//if(dot(cross(V1, V2), C) > 0.0)\n\t\t//    return 0.0;\n\n\t\t// compute eigenvectors of ellipse\n\t\tfloat a, b;\n\t\tfloat d11 = dot(V1, V1);\n\t\tfloat d22 = dot(V2, V2);\n\t\tfloat d12 = dot(V1, V2);\n\t\tif (abs(d12) / sqrt(d11 * d22) > 0.0001)\n\t\t{\n\t\t\t\tfloat tr = d11 + d22;\n\t\t\t\tfloat det = -d12 * d12 + d11 * d22;\n\n\t\t\t\t// use sqrt matrix to solve for eigenvalues\n\t\t\t\tdet = sqrt(det);\n\t\t\t\tfloat u = 0.5 * sqrt(tr - 2.0 * det);\n\t\t\t\tfloat v = 0.5 * sqrt(tr + 2.0 * det);\n\t\t\t\tfloat e_max = (u + v) * (u + v);\n\t\t\t\tfloat e_min = (u - v) * (u - v);\n\n\t\t\t\tvec3 V1_, V2_;\n\n\t\t\t\tif (d11 > d22)\n\t\t\t\t{\n\t\t\t\t\t\tV1_ = d12 * V1 + (e_max - d11) * V2;\n\t\t\t\t\t\tV2_ = d12 * V1 + (e_min - d11) * V2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\tV1_ = d12*V2 + (e_max - d22)*V1;\n\t\t\t\t\t\tV2_ = d12*V2 + (e_min - d22)*V1;\n\t\t\t\t}\n\n\t\t\t\ta = 1.0 / e_max;\n\t\t\t\tb = 1.0 / e_min;\n\t\t\t\tV1 = normalize(V1_);\n\t\t\t\tV2 = normalize(V2_);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\ta = 1.0 / dot(V1, V1);\n\t\t\t\tb = 1.0 / dot(V2, V2);\n\t\t\t\tV1 *= sqrt(a);\n\t\t\t\tV2 *= sqrt(b);\n\t\t}\n\n\t\tvec3 V3 = cross(V1, V2);\n\t\tif (dot(C, V3) < 0.0)\n\t\t\t\tV3 *= -1.0;\n\n\t\tfloat L  = dot(V3, C);\n\t\tfloat x0 = dot(V1, C) / L;\n\t\tfloat y0 = dot(V2, C) / L;\n\n\t\tfloat E1 = inversesqrt(a);\n\t\tfloat E2 = inversesqrt(b);\n\n\t\ta *= L * L;\n\t\tb *= L * L;\n\n\t\tfloat c0 = a * b;\n\t\tfloat c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\n\t\tfloat c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\n\t\tfloat c3 = 1.0;\n\n\t\tvec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\n\t\tfloat e1 = roots.x;\n\t\tfloat e2 = roots.y;\n\t\tfloat e3 = roots.z;\n\n\t\tvec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\n\n\t\tmat3 rotate = mat3(V1, V2, V3);\n\n\t\tavgDir = rotate * avgDir;\n\t\tavgDir = normalize(avgDir);\n\n\t\tfloat L1 = sqrt(-e2 / e3);\n\t\tfloat L2 = sqrt(-e2 / e1);\n\n\t\tfloat formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));\n\t\t\n\t\tconst float LUT_SIZE = 64.0;\n\t\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\t\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\n\t\t// use tabulated horizon-clipped sphere\n\t\tvec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\n\t\tuv = uv*LUT_SCALE + LUT_BIAS;\n\n\t\tfloat scale = texture2DLodEXT(areaLightsLutTex2, uv, 0.0).w;\n\n\t\treturn formFactor*scale;\n}\n\nfloat getRectLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\t\treturn LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\n\nfloat getDiskLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\t\treturn LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\n\nfloat getSphereLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\t\t// NB: this could be improved further with distance based wrap lighting\n\t\tfloat falloff = dSphereRadius / (dot(lightDir, lightDir) + dSphereRadius);\n\t\treturn getLightDiffuse(worldNormal, viewDir, lightDir, lightDirNorm) * falloff;\n}\n\nmat3 getLTCLightInvMat(vec2 uv)\n{\n\t\tvec4 t1 = texture2DLodEXT(areaLightsLutTex1, uv, 0.0);\n\n\t\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\t\tt1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);\n\t\tt1 += vec4(0.0, -0.2976, -0.01381, 0.0);\n\t\t#endif\n\n\t\treturn mat3(\n\t\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\t\tvec3(    0, 1,    0 ),\n\t\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n}\n\nfloat calcRectLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {\n\t\tmat3 mInv = getLTCLightInvMat(uv);\n\t\treturn LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );\n}\n\nfloat getRectLightSpecular(vec3 worldNormal, vec3 viewDir) {\n\t\treturn calcRectLightSpecular(worldNormal, viewDir, dLTCUV);\n}\n\nfloat calcDiskLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {\n\t\tmat3 mInv = getLTCLightInvMat(uv);\n\t\treturn LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );\n}\n\nfloat getDiskLightSpecular(vec3 worldNormal, vec3 viewDir) {\n\t\treturn calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);\n}\n\nfloat getSphereLightSpecular(vec3 worldNormal, vec3 viewDir) {\n\t\treturn calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);\n}\n';export{t as default};
