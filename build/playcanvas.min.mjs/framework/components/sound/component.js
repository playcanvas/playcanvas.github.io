import"../../../core/debug.js";import{DISTANCE_LINEAR as t}from"../../../platform/audio/constants.js";import{Component as s}from"../component.js";import{SoundSlot as e}from"./slot.js";class o extends s{constructor(s,e){super(s,e),this._volume=1,this._pitch=1,this._positional=!0,this._refDistance=1,this._maxDistance=1e4,this._rollOffFactor=1,this._distanceModel=t,this._slots={},this._playingBeforeDisable={}}_updateSoundInstances(t,s,e){const o=this._slots;for(const n in o){const i=o[n];if(!i.overlap){const o=i.instances;for(let n=0,r=o.length;n<r;n++)o[n][t]=e?i[t]*s:s}}}set distanceModel(t){this._distanceModel=t,this._updateSoundInstances("distanceModel",t,!1)}get distanceModel(){return this._distanceModel}set maxDistance(t){this._maxDistance=t,this._updateSoundInstances("maxDistance",t,!1)}get maxDistance(){return this._maxDistance}set refDistance(t){this._refDistance=t,this._updateSoundInstances("refDistance",t,!1)}get refDistance(){return this._refDistance}set rollOffFactor(t){this._rollOffFactor=t,this._updateSoundInstances("rollOffFactor",t,!1)}get rollOffFactor(){return this._rollOffFactor}set pitch(t){this._pitch=t,this._updateSoundInstances("pitch",t,!0)}get pitch(){return this._pitch}set volume(t){this._volume=t,this._updateSoundInstances("volume",t,!0)}get volume(){return this._volume}set positional(t){this._positional=t;const s=this._slots;for(const t in s){const e=s[t];if(!e.overlap){const t=e.instances;for(let s=t.length-1;s>=0;s--){const o=t[s].isPlaying||t[s].isSuspended,n=t[s].currentTime;o&&t[s].stop();const i=e._createInstance();o&&(i.play(),i.currentTime=n),t.push(i)}}}}get positional(){return this._positional}set slots(t){const s=this._slots;if(s)for(const t in s)s[t].stop();const o={};for(const s in t)t[s]instanceof e?o[t[s].name]=t[s]:t[s].name&&(o[t[s].name]=new e(this,t[s].name,t[s]));this._slots=o,this.enabled&&this.entity.enabled&&this.onEnable()}get slots(){return this._slots}onEnable(){if(this.system._inTools)return;const t=this._slots,s=this._playingBeforeDisable;for(const e in t){const o=t[e];o.autoPlay&&o.isStopped?o.play():s[e]?o.resume():o.isLoaded||o.load()}}onDisable(){const t=this._slots,s={};for(const e in t)t[e].overlap||t[e].isPlaying&&(t[e].pause(),s[e]=!0);this._playingBeforeDisable=s}onRemove(){this.off()}addSlot(t,s){const o=this._slots;if(o[t])return null;const n=new e(this,t,s);return o[t]=n,n.autoPlay&&this.enabled&&this.entity.enabled&&n.play(),n}removeSlot(t){const s=this._slots;s[t]&&(s[t].stop(),delete s[t])}slot(t){return this._slots[t]}_getSlotProperty(t,s){if(!this.enabled||!this.entity.enabled)return;const e=this._slots[t];return e?e[s]:void 0}isPlaying(t){return this._getSlotProperty(t,"isPlaying")||!1}isLoaded(t){return this._getSlotProperty(t,"isLoaded")||!1}isPaused(t){return this._getSlotProperty(t,"isPaused")||!1}isStopped(t){return this._getSlotProperty(t,"isStopped")||!1}play(t){if(!this.enabled||!this.entity.enabled)return null;const s=this._slots[t];return s?s.play():null}pause(t){const s=this._slots;if(t){const e=s[t];if(!e)return;e.pause()}else for(const t in s)s[t].pause()}resume(t){const s=this._slots;if(t){const e=s[t];if(!e)return;e.isPaused&&e.resume()}else for(const t in s)s[t].resume()}stop(t){const s=this._slots;if(t){const e=s[t];if(!e)return;e.stop()}else for(const t in s)s[t].stop()}}export{o as SoundComponent};
