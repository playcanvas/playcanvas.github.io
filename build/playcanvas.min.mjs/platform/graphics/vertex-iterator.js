import"../../core/debug.js";import{typedArrayTypes as t}from"./constants.js";function r(t){this.array[this.index]=t}function e(t,r){this.array[this.index]=t,this.array[this.index+1]=r}function s(t,r,e){this.array[this.index]=t,this.array[this.index+1]=r,this.array[this.index+2]=e}function i(t,r,e,s){this.array[this.index]=t,this.array[this.index+1]=r,this.array[this.index+2]=e,this.array[this.index+3]=s}function a(t,r,e){this.array[t]=r[e]}function n(t,r,e){this.array[t]=r[e],this.array[t+1]=r[e+1]}function h(t,r,e){this.array[t]=r[e],this.array[t+1]=r[e+1],this.array[t+2]=r[e+2]}function o(t,r,e){this.array[t]=r[e],this.array[t+1]=r[e+1],this.array[t+2]=r[e+2],this.array[t+3]=r[e+3]}function y(t,r,e){r[e]=this.array[t]}function f(t,r,e){r[e]=this.array[t],r[e+1]=this.array[t+1]}function c(t,r,e){r[e]=this.array[t],r[e+1]=this.array[t+1],r[e+2]=this.array[t+2]}function u(t,r,e){r[e]=this.array[t],r[e+1]=this.array[t+1],r[e+2]=this.array[t+2],r[e+3]=this.array[t+3]}class m{constructor(m,l,d){switch(this.index=0,this.numComponents=l.numComponents,d.interleaved?this.array=new t[l.dataType](m,l.offset):this.array=new t[l.dataType](m,l.offset,d.vertexCount*l.numComponents),this.stride=l.stride/this.array.constructor.BYTES_PER_ELEMENT,l.numComponents){case 1:this.set=r,this.getToArray=y,this.setFromArray=a;break;case 2:this.set=e,this.getToArray=f,this.setFromArray=n;break;case 3:this.set=s,this.getToArray=c,this.setFromArray=h;break;case 4:this.set=i,this.getToArray=u,this.setFromArray=o}}get(t){return this.array[this.index+t]}set(t,r,e,s){}getToArray(t,r,e){}setFromArray(t,r,e){}}class l{constructor(t){this.vertexBuffer=t,this.vertexFormatSize=t.getFormat().size,this.buffer=this.vertexBuffer.lock(),this.accessors=[],this.element={};const r=this.vertexBuffer.getFormat();for(let t=0;t<r.elements.length;t++){const e=r.elements[t];this.accessors[t]=new m(this.buffer,e,r),this.element[e.name]=this.accessors[t]}}next(t=1){let r=0;const e=this.accessors,s=this.accessors.length;for(;r<s;){const s=e[r++];s.index+=t*s.stride}}end(){this.vertexBuffer.unlock()}writeData(t,r,e){const s=this.element[t];if(s){e>this.vertexBuffer.numVertices&&(e=this.vertexBuffer.numVertices);const t=s.numComponents;if(this.vertexBuffer.getFormat().interleaved){let i=0;for(let a=0;a<e;a++)s.setFromArray(i,r,a*t),i+=s.stride}else if(r.length>e*t){const i=e*t;if(ArrayBuffer.isView(r))r=r.subarray(0,i),s.array.set(r);else for(let t=0;t<i;t++)s.array[t]=r[t]}else s.array.set(r)}}readData(t,r){const e=this.element[t];let s=0;if(e){let t;s=this.vertexBuffer.numVertices;const i=e.numComponents;if(this.vertexBuffer.getFormat().interleaved){Array.isArray(r)&&(r.length=0),e.index=0;let a=0;for(t=0;t<s;t++)e.getToArray(a,r,t*i),a+=e.stride}else if(ArrayBuffer.isView(r))r.set(e.array);else{r.length=0;const a=s*i;for(t=0;t<a;t++)r[t]=e.array[t]}}return s}}export{l as VertexIterator,m as VertexIteratorAccessor};
