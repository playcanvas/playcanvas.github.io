/**
 * @license
 * PlayCanvas Engine v1.63.0-dev revision 9f3635a4e (DEBUG PROFILER)
 * Copyright 2011-2023 PlayCanvas Ltd. All rights reserved.
 */
import { Debug } from '../core/debug.js';
import { RefCountedObject } from '../core/ref-counted-object.js';
import { Vec3 } from '../core/math/vec3.js';
import { FloatPacking } from '../core/math/float-packing.js';
import { BoundingBox } from '../core/shape/bounding-box.js';
import { Texture } from '../platform/graphics/texture.js';
import { VertexBuffer } from '../platform/graphics/vertex-buffer.js';
import { VertexFormat } from '../platform/graphics/vertex-format.js';
import { PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGB32F, BUFFER_STATIC, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE, SEMANTIC_ATTR15, TYPE_FLOAT32 } from '../platform/graphics/constants.js';
import { GraphicsDeviceAccess } from '../platform/graphics/graphics-device-access.js';

// value added to floats which are used as ints on the shader side to avoid values being rounded to one less occasionally
const _floatRounding = 0.2;
const defaultOptions = {
  preferHighPrecision: false
};

/**
 * Contains a list of {@link MorphTarget}, a combined delta AABB and some associated data.
 */
class Morph extends RefCountedObject {
  /** @type {BoundingBox} */

  /** @type {boolean} */

  /**
   * Create a new Morph instance.
   *
   * @param {import('./morph-target.js').MorphTarget[]} targets - A list of morph targets.
   * @param {import('../platform/graphics/graphics-device.js').GraphicsDevice} graphicsDevice -
   * The graphics device used to manage this morph target.
   * @param {object} options - Object for passing optional arguments.
   * @param {boolean} options.preferHighPrecision - True if high precision storage should be
   * prefered. This is faster to create and allows higher precision, but takes more memory and
   * might be slower to render. Defaults to false.
   */
  constructor(targets, graphicsDevice, options = defaultOptions) {
    super();
    this._aabb = void 0;
    this.preferHighPrecision = void 0;
    Debug.assertDeprecated(graphicsDevice, "Morph constructor takes a GraphicsDevice as a parameter, and it was not provided.");
    this.device = graphicsDevice || GraphicsDeviceAccess.get();
    this.preferHighPrecision = options.preferHighPrecision;

    // validation
    targets.forEach(target => Debug.assert(!target.used, 'The target specified has already been used to create a Morph, use its clone instead.'));
    this._targets = targets.slice();

    // default to texture based morphing if available
    const device = this.device;
    if (device.supportsMorphTargetTexturesCore) {
      // renderable format
      const renderableHalf = device.extTextureHalfFloat && device.textureHalfFloatRenderable ? PIXELFORMAT_RGBA16F : undefined;
      const renderableFloat = device.extTextureFloat && device.textureFloatRenderable ? PIXELFORMAT_RGBA32F : undefined;
      this._renderTextureFormat = this.preferHighPrecision ? renderableFloat != null ? renderableFloat : renderableHalf : renderableHalf != null ? renderableHalf : renderableFloat;

      // texture format
      const textureHalf = device.extTextureHalfFloat && device.textureHalfFloatUpdatable ? PIXELFORMAT_RGBA16F : undefined;
      const textureFloat = device.extTextureFloat ? PIXELFORMAT_RGB32F : undefined;
      this._textureFormat = this.preferHighPrecision ? textureFloat != null ? textureFloat : textureHalf : textureHalf != null ? textureHalf : textureFloat;

      // if both available, enable texture morphing
      if (this._renderTextureFormat !== undefined && this._textureFormat !== undefined) {
        this._useTextureMorph = true;
      }
    }
    this._init();
    this._updateMorphFlags();
  }
  get aabb() {
    // lazy evaluation, which allows us to skip this completely if customAABB is used
    if (!this._aabb) {
      // calculate min and max expansion size
      // Note: This represents average case, where most morph targets expand the mesh within the same area. It does not
      // represent the stacked worst case scenario where all morphs could be enabled at the same time, as this can result
      // in a very large aabb. In cases like this, the users should specify customAabb for Model/Render component.
      const min = new Vec3();
      const max = new Vec3();
      for (let i = 0; i < this._targets.length; i++) {
        const targetAabb = this._targets[i].aabb;
        min.min(targetAabb.getMin());
        max.max(targetAabb.getMax());
      }
      this._aabb = new BoundingBox();
      this._aabb.setMinMax(min, max);
    }
    return this._aabb;
  }
  get morphPositions() {
    return this._morphPositions;
  }
  get morphNormals() {
    return this._morphNormals;
  }
  get maxActiveTargets() {
    // no limit when texture morph based
    if (this._useTextureMorph) return this._targets.length;
    return this._morphPositions && this._morphNormals ? 4 : 8;
  }
  get useTextureMorph() {
    return this._useTextureMorph;
  }
  _init() {
    // try to init texture based morphing
    if (this._useTextureMorph) {
      this._useTextureMorph = this._initTextureBased();
    }

    // if texture morphing is not set up, use attribute based morphing
    if (!this._useTextureMorph) {
      for (let i = 0; i < this._targets.length; i++) {
        this._targets[i]._initVertexBuffers(this.device);
      }
    }

    // finalize init
    for (let i = 0; i < this._targets.length; i++) {
      this._targets[i]._postInit();
    }
  }
  _findSparseSet(deltaArrays, ids, usedDataIndices) {
    let freeIndex = 1; // reserve slot 0 for zero delta
    const dataCount = deltaArrays[0].length;
    for (let v = 0; v < dataCount; v += 3) {
      // find if vertex is morphed by any target
      let vertexUsed = false;
      for (let i = 0; i < deltaArrays.length; i++) {
        const data = deltaArrays[i];

        // if non-zero delta
        if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {
          vertexUsed = true;
          break;
        }
      }
      if (vertexUsed) {
        ids.push(freeIndex + _floatRounding);
        usedDataIndices.push(v / 3);
        freeIndex++;
      } else {
        // non morphed vertices would be all mapped to pixel 0 of texture
        ids.push(0 + _floatRounding);
      }
    }
    return freeIndex;
  }
  _initTextureBased() {
    // collect all source delta arrays to find sparse set of vertices
    const deltaArrays = [],
      deltaInfos = [];
    for (let i = 0; i < this._targets.length; i++) {
      const target = this._targets[i];
      if (target.options.deltaPositions) {
        deltaArrays.push(target.options.deltaPositions);
        deltaInfos.push({
          target: target,
          name: 'texturePositions'
        });
      }
      if (target.options.deltaNormals) {
        deltaArrays.push(target.options.deltaNormals);
        deltaInfos.push({
          target: target,
          name: 'textureNormals'
        });
      }
    }

    // find sparse set for all target deltas into usedDataIndices and build vertex id buffer
    const ids = [],
      usedDataIndices = [];
    const freeIndex = this._findSparseSet(deltaArrays, ids, usedDataIndices);

    // max texture size: vertexBufferIds is stored in float32 format, giving us 2^24 range, so can address 4096 texture at maximum
    // TODO: on webgl2 we could store this in uint32 format and remove this limit
    const maxTextureSize = Math.min(this.device.maxTextureSize, 4096);

    // texture size for freeIndex pixels - roughly square
    let morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
    morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
    const morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);

    // if data cannot fit into max size texture, fail this set up
    if (morphTextureHeight > maxTextureSize) {
      return false;
    }
    this.morphTextureWidth = morphTextureWidth;
    this.morphTextureHeight = morphTextureHeight;

    // texture format based vars
    let halfFloat = false;
    let numComponents = 3; // RGB32 is used
    const float2Half = FloatPacking.float2Half;
    if (this._textureFormat === PIXELFORMAT_RGBA16F) {
      halfFloat = true;
      numComponents = 4; // RGBA16 is used, RGB16 does not work
    }

    // create textures
    const textures = [];
    for (let i = 0; i < deltaArrays.length; i++) {
      textures.push(this._createTexture('MorphTarget', this._textureFormat));
    }

    // build texture for each delta array, all textures are the same size
    for (let i = 0; i < deltaArrays.length; i++) {
      const data = deltaArrays[i];
      const texture = textures[i];
      const textureData = texture.lock();

      // copy full arrays into sparse arrays and convert format (skip 0th pixel - used by non-morphed vertices)
      if (halfFloat) {
        for (let v = 0; v < usedDataIndices.length; v++) {
          const index = usedDataIndices[v] * 3;
          const dstIndex = v * numComponents + numComponents;
          textureData[dstIndex] = float2Half(data[index]);
          textureData[dstIndex + 1] = float2Half(data[index + 1]);
          textureData[dstIndex + 2] = float2Half(data[index + 2]);
        }
      } else {
        for (let v = 0; v < usedDataIndices.length; v++) {
          const index = usedDataIndices[v] * 3;
          const dstIndex = v * numComponents + numComponents;
          textureData[dstIndex] = data[index];
          textureData[dstIndex + 1] = data[index + 1];
          textureData[dstIndex + 2] = data[index + 2];
        }
      }

      // assign texture to target
      texture.unlock();
      const target = deltaInfos[i].target;
      target._setTexture(deltaInfos[i].name, texture);
    }

    // create vertex stream with vertex_id used to map vertex to texture
    const formatDesc = [{
      semantic: SEMANTIC_ATTR15,
      components: 1,
      type: TYPE_FLOAT32
    }];
    this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc), ids.length, BUFFER_STATIC, new Float32Array(ids));
    return true;
  }

  /**
   * Frees video memory allocated by this object.
   */
  destroy() {
    var _this$vertexBufferIds;
    (_this$vertexBufferIds = this.vertexBufferIds) == null ? void 0 : _this$vertexBufferIds.destroy();
    this.vertexBufferIds = null;
    for (let i = 0; i < this._targets.length; i++) {
      this._targets[i].destroy();
    }
    this._targets.length = 0;
  }

  /**
   * The array of morph targets.
   *
   * @type {import('./morph-target.js').MorphTarget[]}
   */
  get targets() {
    return this._targets;
  }
  _updateMorphFlags() {
    // find out if this morph needs to morph positions and normals
    this._morphPositions = false;
    this._morphNormals = false;
    for (let i = 0; i < this._targets.length; i++) {
      const target = this._targets[i];
      if (target.morphPositions) {
        this._morphPositions = true;
      }
      if (target.morphNormals) {
        this._morphNormals = true;
      }
    }
  }

  // creates texture. Used to create both source morph target data, as well as render target used to morph these into, positions and normals
  _createTexture(name, format) {
    return new Texture(this.device, {
      width: this.morphTextureWidth,
      height: this.morphTextureHeight,
      format: format,
      cubemap: false,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      name: name
    });
  }
}

export { Morph };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9ycGguanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zY2VuZS9tb3JwaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWJ1ZyB9IGZyb20gJy4uL2NvcmUvZGVidWcuanMnO1xuaW1wb3J0IHsgUmVmQ291bnRlZE9iamVjdCB9IGZyb20gJy4uL2NvcmUvcmVmLWNvdW50ZWQtb2JqZWN0LmpzJztcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuLi9jb3JlL21hdGgvdmVjMy5qcyc7XG5pbXBvcnQgeyBGbG9hdFBhY2tpbmcgfSBmcm9tICcuLi9jb3JlL21hdGgvZmxvYXQtcGFja2luZy5qcyc7XG5pbXBvcnQgeyBCb3VuZGluZ0JveCB9IGZyb20gJy4uL2NvcmUvc2hhcGUvYm91bmRpbmctYm94LmpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi9wbGF0Zm9ybS9ncmFwaGljcy90ZXh0dXJlLmpzJztcbmltcG9ydCB7IFZlcnRleEJ1ZmZlciB9IGZyb20gJy4uL3BsYXRmb3JtL2dyYXBoaWNzL3ZlcnRleC1idWZmZXIuanMnO1xuaW1wb3J0IHsgVmVydGV4Rm9ybWF0IH0gZnJvbSAnLi4vcGxhdGZvcm0vZ3JhcGhpY3MvdmVydGV4LWZvcm1hdC5qcyc7XG5cbmltcG9ydCB7XG4gICAgQlVGRkVSX1NUQVRJQywgVFlQRV9GTE9BVDMyLCBTRU1BTlRJQ19BVFRSMTUsIEFERFJFU1NfQ0xBTVBfVE9fRURHRSwgRklMVEVSX05FQVJFU1QsXG4gICAgUElYRUxGT1JNQVRfUkdCQTE2RiwgUElYRUxGT1JNQVRfUkdCMzJGLCBQSVhFTEZPUk1BVF9SR0JBMzJGXG59IGZyb20gJy4uL3BsYXRmb3JtL2dyYXBoaWNzL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBHcmFwaGljc0RldmljZUFjY2VzcyB9IGZyb20gJy4uL3BsYXRmb3JtL2dyYXBoaWNzL2dyYXBoaWNzLWRldmljZS1hY2Nlc3MuanMnO1xuXG4vLyB2YWx1ZSBhZGRlZCB0byBmbG9hdHMgd2hpY2ggYXJlIHVzZWQgYXMgaW50cyBvbiB0aGUgc2hhZGVyIHNpZGUgdG8gYXZvaWQgdmFsdWVzIGJlaW5nIHJvdW5kZWQgdG8gb25lIGxlc3Mgb2NjYXNpb25hbGx5XG5jb25zdCBfZmxvYXRSb3VuZGluZyA9IDAuMjtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcHJlZmVySGlnaFByZWNpc2lvbjogZmFsc2Vcbn07XG5cbi8qKlxuICogQ29udGFpbnMgYSBsaXN0IG9mIHtAbGluayBNb3JwaFRhcmdldH0sIGEgY29tYmluZWQgZGVsdGEgQUFCQiBhbmQgc29tZSBhc3NvY2lhdGVkIGRhdGEuXG4gKi9cbmNsYXNzIE1vcnBoIGV4dGVuZHMgUmVmQ291bnRlZE9iamVjdCB7XG4gICAgLyoqIEB0eXBlIHtCb3VuZGluZ0JveH0gKi9cbiAgICBfYWFiYjtcblxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICBwcmVmZXJIaWdoUHJlY2lzaW9uO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE1vcnBoIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4vbW9ycGgtdGFyZ2V0LmpzJykuTW9ycGhUYXJnZXRbXX0gdGFyZ2V0cyAtIEEgbGlzdCBvZiBtb3JwaCB0YXJnZXRzLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9wbGF0Zm9ybS9ncmFwaGljcy9ncmFwaGljcy1kZXZpY2UuanMnKS5HcmFwaGljc0RldmljZX0gZ3JhcGhpY3NEZXZpY2UgLVxuICAgICAqIFRoZSBncmFwaGljcyBkZXZpY2UgdXNlZCB0byBtYW5hZ2UgdGhpcyBtb3JwaCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBPYmplY3QgZm9yIHBhc3Npbmcgb3B0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5wcmVmZXJIaWdoUHJlY2lzaW9uIC0gVHJ1ZSBpZiBoaWdoIHByZWNpc2lvbiBzdG9yYWdlIHNob3VsZCBiZVxuICAgICAqIHByZWZlcmVkLiBUaGlzIGlzIGZhc3RlciB0byBjcmVhdGUgYW5kIGFsbG93cyBoaWdoZXIgcHJlY2lzaW9uLCBidXQgdGFrZXMgbW9yZSBtZW1vcnkgYW5kXG4gICAgICogbWlnaHQgYmUgc2xvd2VyIHRvIHJlbmRlci4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0cywgZ3JhcGhpY3NEZXZpY2UsIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIERlYnVnLmFzc2VydERlcHJlY2F0ZWQoZ3JhcGhpY3NEZXZpY2UsIFwiTW9ycGggY29uc3RydWN0b3IgdGFrZXMgYSBHcmFwaGljc0RldmljZSBhcyBhIHBhcmFtZXRlciwgYW5kIGl0IHdhcyBub3QgcHJvdmlkZWQuXCIpO1xuICAgICAgICB0aGlzLmRldmljZSA9IGdyYXBoaWNzRGV2aWNlIHx8IEdyYXBoaWNzRGV2aWNlQWNjZXNzLmdldCgpO1xuXG4gICAgICAgIHRoaXMucHJlZmVySGlnaFByZWNpc2lvbiA9IG9wdGlvbnMucHJlZmVySGlnaFByZWNpc2lvbjtcblxuICAgICAgICAvLyB2YWxpZGF0aW9uXG4gICAgICAgIHRhcmdldHMuZm9yRWFjaCh0YXJnZXQgPT4gRGVidWcuYXNzZXJ0KCF0YXJnZXQudXNlZCwgJ1RoZSB0YXJnZXQgc3BlY2lmaWVkIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCB0byBjcmVhdGUgYSBNb3JwaCwgdXNlIGl0cyBjbG9uZSBpbnN0ZWFkLicpKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0cyA9IHRhcmdldHMuc2xpY2UoKTtcblxuICAgICAgICAvLyBkZWZhdWx0IHRvIHRleHR1cmUgYmFzZWQgbW9ycGhpbmcgaWYgYXZhaWxhYmxlXG4gICAgICAgIGNvbnN0IGRldmljZSA9IHRoaXMuZGV2aWNlO1xuICAgICAgICBpZiAoZGV2aWNlLnN1cHBvcnRzTW9ycGhUYXJnZXRUZXh0dXJlc0NvcmUpIHtcblxuICAgICAgICAgICAgLy8gcmVuZGVyYWJsZSBmb3JtYXRcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmFibGVIYWxmID0gKGRldmljZS5leHRUZXh0dXJlSGFsZkZsb2F0ICYmIGRldmljZS50ZXh0dXJlSGFsZkZsb2F0UmVuZGVyYWJsZSkgPyBQSVhFTEZPUk1BVF9SR0JBMTZGIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyYWJsZUZsb2F0ID0gKGRldmljZS5leHRUZXh0dXJlRmxvYXQgJiYgZGV2aWNlLnRleHR1cmVGbG9hdFJlbmRlcmFibGUpID8gUElYRUxGT1JNQVRfUkdCQTMyRiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVGb3JtYXQgPSB0aGlzLnByZWZlckhpZ2hQcmVjaXNpb24gP1xuICAgICAgICAgICAgICAgIChyZW5kZXJhYmxlRmxvYXQgPz8gcmVuZGVyYWJsZUhhbGYpIDogKHJlbmRlcmFibGVIYWxmID8/IHJlbmRlcmFibGVGbG9hdCk7XG5cbiAgICAgICAgICAgIC8vIHRleHR1cmUgZm9ybWF0XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlSGFsZiA9IChkZXZpY2UuZXh0VGV4dHVyZUhhbGZGbG9hdCAmJiBkZXZpY2UudGV4dHVyZUhhbGZGbG9hdFVwZGF0YWJsZSkgPyBQSVhFTEZPUk1BVF9SR0JBMTZGIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZUZsb2F0ID0gZGV2aWNlLmV4dFRleHR1cmVGbG9hdCA/IFBJWEVMRk9STUFUX1JHQjMyRiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVGb3JtYXQgPSB0aGlzLnByZWZlckhpZ2hQcmVjaXNpb24gP1xuICAgICAgICAgICAgICAgICh0ZXh0dXJlRmxvYXQgPz8gdGV4dHVyZUhhbGYpIDogKHRleHR1cmVIYWxmID8/IHRleHR1cmVGbG9hdCk7XG5cbiAgICAgICAgICAgIC8vIGlmIGJvdGggYXZhaWxhYmxlLCBlbmFibGUgdGV4dHVyZSBtb3JwaGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmVGb3JtYXQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl90ZXh0dXJlRm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91c2VUZXh0dXJlTW9ycGggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVNb3JwaEZsYWdzKCk7XG4gICAgfVxuXG4gICAgZ2V0IGFhYmIoKSB7XG5cbiAgICAgICAgLy8gbGF6eSBldmFsdWF0aW9uLCB3aGljaCBhbGxvd3MgdXMgdG8gc2tpcCB0aGlzIGNvbXBsZXRlbHkgaWYgY3VzdG9tQUFCQiBpcyB1c2VkXG4gICAgICAgIGlmICghdGhpcy5fYWFiYikge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG1pbiBhbmQgbWF4IGV4cGFuc2lvbiBzaXplXG4gICAgICAgICAgICAvLyBOb3RlOiBUaGlzIHJlcHJlc2VudHMgYXZlcmFnZSBjYXNlLCB3aGVyZSBtb3N0IG1vcnBoIHRhcmdldHMgZXhwYW5kIHRoZSBtZXNoIHdpdGhpbiB0aGUgc2FtZSBhcmVhLiBJdCBkb2VzIG5vdFxuICAgICAgICAgICAgLy8gcmVwcmVzZW50IHRoZSBzdGFja2VkIHdvcnN0IGNhc2Ugc2NlbmFyaW8gd2hlcmUgYWxsIG1vcnBocyBjb3VsZCBiZSBlbmFibGVkIGF0IHRoZSBzYW1lIHRpbWUsIGFzIHRoaXMgY2FuIHJlc3VsdFxuICAgICAgICAgICAgLy8gaW4gYSB2ZXJ5IGxhcmdlIGFhYmIuIEluIGNhc2VzIGxpa2UgdGhpcywgdGhlIHVzZXJzIHNob3VsZCBzcGVjaWZ5IGN1c3RvbUFhYmIgZm9yIE1vZGVsL1JlbmRlciBjb21wb25lbnQuXG4gICAgICAgICAgICBjb25zdCBtaW4gPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEFhYmIgPSB0aGlzLl90YXJnZXRzW2ldLmFhYmI7XG4gICAgICAgICAgICAgICAgbWluLm1pbih0YXJnZXRBYWJiLmdldE1pbigpKTtcbiAgICAgICAgICAgICAgICBtYXgubWF4KHRhcmdldEFhYmIuZ2V0TWF4KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hYWJiID0gbmV3IEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICB0aGlzLl9hYWJiLnNldE1pbk1heChtaW4sIG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fYWFiYjtcbiAgICB9XG5cbiAgICBnZXQgbW9ycGhQb3NpdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb3JwaFBvc2l0aW9ucztcbiAgICB9XG5cbiAgICBnZXQgbW9ycGhOb3JtYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9ycGhOb3JtYWxzO1xuICAgIH1cblxuICAgIGdldCBtYXhBY3RpdmVUYXJnZXRzKCkge1xuXG4gICAgICAgIC8vIG5vIGxpbWl0IHdoZW4gdGV4dHVyZSBtb3JwaCBiYXNlZFxuICAgICAgICBpZiAodGhpcy5fdXNlVGV4dHVyZU1vcnBoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldHMubGVuZ3RoO1xuXG4gICAgICAgIHJldHVybiAodGhpcy5fbW9ycGhQb3NpdGlvbnMgJiYgdGhpcy5fbW9ycGhOb3JtYWxzKSA/IDQgOiA4O1xuICAgIH1cblxuICAgIGdldCB1c2VUZXh0dXJlTW9ycGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91c2VUZXh0dXJlTW9ycGg7XG4gICAgfVxuXG4gICAgX2luaXQoKSB7XG5cbiAgICAgICAgLy8gdHJ5IHRvIGluaXQgdGV4dHVyZSBiYXNlZCBtb3JwaGluZ1xuICAgICAgICBpZiAodGhpcy5fdXNlVGV4dHVyZU1vcnBoKSB7XG4gICAgICAgICAgICB0aGlzLl91c2VUZXh0dXJlTW9ycGggPSB0aGlzLl9pbml0VGV4dHVyZUJhc2VkKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0ZXh0dXJlIG1vcnBoaW5nIGlzIG5vdCBzZXQgdXAsIHVzZSBhdHRyaWJ1dGUgYmFzZWQgbW9ycGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLl91c2VUZXh0dXJlTW9ycGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldHNbaV0uX2luaXRWZXJ0ZXhCdWZmZXJzKHRoaXMuZGV2aWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsaXplIGluaXRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRzW2ldLl9wb3N0SW5pdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2ZpbmRTcGFyc2VTZXQoZGVsdGFBcnJheXMsIGlkcywgdXNlZERhdGFJbmRpY2VzKSB7XG5cbiAgICAgICAgbGV0IGZyZWVJbmRleCA9IDE7ICAvLyByZXNlcnZlIHNsb3QgMCBmb3IgemVybyBkZWx0YVxuICAgICAgICBjb25zdCBkYXRhQ291bnQgPSBkZWx0YUFycmF5c1swXS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgZGF0YUNvdW50OyB2ICs9IDMpIHtcblxuICAgICAgICAgICAgLy8gZmluZCBpZiB2ZXJ0ZXggaXMgbW9ycGhlZCBieSBhbnkgdGFyZ2V0XG4gICAgICAgICAgICBsZXQgdmVydGV4VXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWx0YUFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBkZWx0YUFycmF5c1tpXTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIG5vbi16ZXJvIGRlbHRhXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbdl0gIT09IDAgfHwgZGF0YVt2ICsgMV0gIT09IDAgfHwgZGF0YVt2ICsgMl0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4VXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZlcnRleFVzZWQpIHtcbiAgICAgICAgICAgICAgICBpZHMucHVzaChmcmVlSW5kZXggKyBfZmxvYXRSb3VuZGluZyk7XG4gICAgICAgICAgICAgICAgdXNlZERhdGFJbmRpY2VzLnB1c2godiAvIDMpO1xuICAgICAgICAgICAgICAgIGZyZWVJbmRleCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub24gbW9ycGhlZCB2ZXJ0aWNlcyB3b3VsZCBiZSBhbGwgbWFwcGVkIHRvIHBpeGVsIDAgb2YgdGV4dHVyZVxuICAgICAgICAgICAgICAgIGlkcy5wdXNoKDAgKyBfZmxvYXRSb3VuZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJlZUluZGV4O1xuICAgIH1cblxuICAgIF9pbml0VGV4dHVyZUJhc2VkKCkge1xuICAgICAgICAvLyBjb2xsZWN0IGFsbCBzb3VyY2UgZGVsdGEgYXJyYXlzIHRvIGZpbmQgc3BhcnNlIHNldCBvZiB2ZXJ0aWNlc1xuICAgICAgICBjb25zdCBkZWx0YUFycmF5cyA9IFtdLCBkZWx0YUluZm9zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1tpXTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQub3B0aW9ucy5kZWx0YVBvc2l0aW9ucykge1xuICAgICAgICAgICAgICAgIGRlbHRhQXJyYXlzLnB1c2godGFyZ2V0Lm9wdGlvbnMuZGVsdGFQb3NpdGlvbnMpO1xuICAgICAgICAgICAgICAgIGRlbHRhSW5mb3MucHVzaCh7IHRhcmdldDogdGFyZ2V0LCBuYW1lOiAndGV4dHVyZVBvc2l0aW9ucycgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm9wdGlvbnMuZGVsdGFOb3JtYWxzKSB7XG4gICAgICAgICAgICAgICAgZGVsdGFBcnJheXMucHVzaCh0YXJnZXQub3B0aW9ucy5kZWx0YU5vcm1hbHMpO1xuICAgICAgICAgICAgICAgIGRlbHRhSW5mb3MucHVzaCh7IHRhcmdldDogdGFyZ2V0LCBuYW1lOiAndGV4dHVyZU5vcm1hbHMnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBzcGFyc2Ugc2V0IGZvciBhbGwgdGFyZ2V0IGRlbHRhcyBpbnRvIHVzZWREYXRhSW5kaWNlcyBhbmQgYnVpbGQgdmVydGV4IGlkIGJ1ZmZlclxuICAgICAgICBjb25zdCBpZHMgPSBbXSwgdXNlZERhdGFJbmRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IGZyZWVJbmRleCA9IHRoaXMuX2ZpbmRTcGFyc2VTZXQoZGVsdGFBcnJheXMsIGlkcywgdXNlZERhdGFJbmRpY2VzKTtcblxuICAgICAgICAvLyBtYXggdGV4dHVyZSBzaXplOiB2ZXJ0ZXhCdWZmZXJJZHMgaXMgc3RvcmVkIGluIGZsb2F0MzIgZm9ybWF0LCBnaXZpbmcgdXMgMl4yNCByYW5nZSwgc28gY2FuIGFkZHJlc3MgNDA5NiB0ZXh0dXJlIGF0IG1heGltdW1cbiAgICAgICAgLy8gVE9ETzogb24gd2ViZ2wyIHdlIGNvdWxkIHN0b3JlIHRoaXMgaW4gdWludDMyIGZvcm1hdCBhbmQgcmVtb3ZlIHRoaXMgbGltaXRcbiAgICAgICAgY29uc3QgbWF4VGV4dHVyZVNpemUgPSBNYXRoLm1pbih0aGlzLmRldmljZS5tYXhUZXh0dXJlU2l6ZSwgNDA5Nik7XG5cbiAgICAgICAgLy8gdGV4dHVyZSBzaXplIGZvciBmcmVlSW5kZXggcGl4ZWxzIC0gcm91Z2hseSBzcXVhcmVcbiAgICAgICAgbGV0IG1vcnBoVGV4dHVyZVdpZHRoID0gTWF0aC5jZWlsKE1hdGguc3FydChmcmVlSW5kZXgpKTtcbiAgICAgICAgbW9ycGhUZXh0dXJlV2lkdGggPSBNYXRoLm1pbihtb3JwaFRleHR1cmVXaWR0aCwgbWF4VGV4dHVyZVNpemUpO1xuICAgICAgICBjb25zdCBtb3JwaFRleHR1cmVIZWlnaHQgPSBNYXRoLmNlaWwoZnJlZUluZGV4IC8gbW9ycGhUZXh0dXJlV2lkdGgpO1xuXG4gICAgICAgIC8vIGlmIGRhdGEgY2Fubm90IGZpdCBpbnRvIG1heCBzaXplIHRleHR1cmUsIGZhaWwgdGhpcyBzZXQgdXBcbiAgICAgICAgaWYgKG1vcnBoVGV4dHVyZUhlaWdodCA+IG1heFRleHR1cmVTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vcnBoVGV4dHVyZVdpZHRoID0gbW9ycGhUZXh0dXJlV2lkdGg7XG4gICAgICAgIHRoaXMubW9ycGhUZXh0dXJlSGVpZ2h0ID0gbW9ycGhUZXh0dXJlSGVpZ2h0O1xuXG4gICAgICAgIC8vIHRleHR1cmUgZm9ybWF0IGJhc2VkIHZhcnNcbiAgICAgICAgbGV0IGhhbGZGbG9hdCA9IGZhbHNlO1xuICAgICAgICBsZXQgbnVtQ29tcG9uZW50cyA9IDM7ICAvLyBSR0IzMiBpcyB1c2VkXG4gICAgICAgIGNvbnN0IGZsb2F0MkhhbGYgPSBGbG9hdFBhY2tpbmcuZmxvYXQySGFsZjtcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmVGb3JtYXQgPT09IFBJWEVMRk9STUFUX1JHQkExNkYpIHtcbiAgICAgICAgICAgIGhhbGZGbG9hdCA9IHRydWU7XG4gICAgICAgICAgICBudW1Db21wb25lbnRzID0gNDsgIC8vIFJHQkExNiBpcyB1c2VkLCBSR0IxNiBkb2VzIG5vdCB3b3JrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgdGV4dHVyZXNcbiAgICAgICAgY29uc3QgdGV4dHVyZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWx0YUFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGV4dHVyZXMucHVzaCh0aGlzLl9jcmVhdGVUZXh0dXJlKCdNb3JwaFRhcmdldCcsIHRoaXMuX3RleHR1cmVGb3JtYXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJ1aWxkIHRleHR1cmUgZm9yIGVhY2ggZGVsdGEgYXJyYXksIGFsbCB0ZXh0dXJlcyBhcmUgdGhlIHNhbWUgc2l6ZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbHRhQXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZGVsdGFBcnJheXNbaV07XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGV4dHVyZXNbaV07XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlRGF0YSA9IHRleHR1cmUubG9jaygpO1xuXG4gICAgICAgICAgICAvLyBjb3B5IGZ1bGwgYXJyYXlzIGludG8gc3BhcnNlIGFycmF5cyBhbmQgY29udmVydCBmb3JtYXQgKHNraXAgMHRoIHBpeGVsIC0gdXNlZCBieSBub24tbW9ycGhlZCB2ZXJ0aWNlcylcbiAgICAgICAgICAgIGlmIChoYWxmRmxvYXQpIHtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdXNlZERhdGFJbmRpY2VzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdXNlZERhdGFJbmRpY2VzW3ZdICogMztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHN0SW5kZXggPSB2ICogbnVtQ29tcG9uZW50cyArIG51bUNvbXBvbmVudHM7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVEYXRhW2RzdEluZGV4XSA9IGZsb2F0MkhhbGYoZGF0YVtpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlRGF0YVtkc3RJbmRleCArIDFdID0gZmxvYXQySGFsZihkYXRhW2luZGV4ICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlRGF0YVtkc3RJbmRleCArIDJdID0gZmxvYXQySGFsZihkYXRhW2luZGV4ICsgMl0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdXNlZERhdGFJbmRpY2VzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdXNlZERhdGFJbmRpY2VzW3ZdICogMztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHN0SW5kZXggPSB2ICogbnVtQ29tcG9uZW50cyArIG51bUNvbXBvbmVudHM7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVEYXRhW2RzdEluZGV4XSA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlRGF0YVtkc3RJbmRleCArIDFdID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlRGF0YVtkc3RJbmRleCArIDJdID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXNzaWduIHRleHR1cmUgdG8gdGFyZ2V0XG4gICAgICAgICAgICB0ZXh0dXJlLnVubG9jaygpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZGVsdGFJbmZvc1tpXS50YXJnZXQ7XG4gICAgICAgICAgICB0YXJnZXQuX3NldFRleHR1cmUoZGVsdGFJbmZvc1tpXS5uYW1lLCB0ZXh0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSB2ZXJ0ZXggc3RyZWFtIHdpdGggdmVydGV4X2lkIHVzZWQgdG8gbWFwIHZlcnRleCB0byB0ZXh0dXJlXG4gICAgICAgIGNvbnN0IGZvcm1hdERlc2MgPSBbeyBzZW1hbnRpYzogU0VNQU5USUNfQVRUUjE1LCBjb21wb25lbnRzOiAxLCB0eXBlOiBUWVBFX0ZMT0FUMzIgfV07XG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVySWRzID0gbmV3IFZlcnRleEJ1ZmZlcih0aGlzLmRldmljZSwgbmV3IFZlcnRleEZvcm1hdCh0aGlzLmRldmljZSwgZm9ybWF0RGVzYyksIGlkcy5sZW5ndGgsIEJVRkZFUl9TVEFUSUMsIG5ldyBGbG9hdDMyQXJyYXkoaWRzKSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnJlZXMgdmlkZW8gbWVtb3J5IGFsbG9jYXRlZCBieSB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcklkcz8uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcklkcyA9IG51bGw7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YXJnZXRzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFycmF5IG9mIG1vcnBoIHRhcmdldHMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCcuL21vcnBoLXRhcmdldC5qcycpLk1vcnBoVGFyZ2V0W119XG4gICAgICovXG4gICAgZ2V0IHRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXRzO1xuICAgIH1cblxuICAgIF91cGRhdGVNb3JwaEZsYWdzKCkge1xuXG4gICAgICAgIC8vIGZpbmQgb3V0IGlmIHRoaXMgbW9ycGggbmVlZHMgdG8gbW9ycGggcG9zaXRpb25zIGFuZCBub3JtYWxzXG4gICAgICAgIHRoaXMuX21vcnBoUG9zaXRpb25zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21vcnBoTm9ybWFscyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3RhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3RhcmdldHNbaV07XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm1vcnBoUG9zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9ycGhQb3NpdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldC5tb3JwaE5vcm1hbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3JwaE5vcm1hbHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlcyB0ZXh0dXJlLiBVc2VkIHRvIGNyZWF0ZSBib3RoIHNvdXJjZSBtb3JwaCB0YXJnZXQgZGF0YSwgYXMgd2VsbCBhcyByZW5kZXIgdGFyZ2V0IHVzZWQgdG8gbW9ycGggdGhlc2UgaW50bywgcG9zaXRpb25zIGFuZCBub3JtYWxzXG4gICAgX2NyZWF0ZVRleHR1cmUobmFtZSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZSh0aGlzLmRldmljZSwge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMubW9ycGhUZXh0dXJlV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMubW9ycGhUZXh0dXJlSGVpZ2h0LFxuICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICAgICAgICBjdWJlbWFwOiBmYWxzZSxcbiAgICAgICAgICAgIG1pcG1hcHM6IGZhbHNlLFxuICAgICAgICAgICAgbWluRmlsdGVyOiBGSUxURVJfTkVBUkVTVCxcbiAgICAgICAgICAgIG1hZ0ZpbHRlcjogRklMVEVSX05FQVJFU1QsXG4gICAgICAgICAgICBhZGRyZXNzVTogQUREUkVTU19DTEFNUF9UT19FREdFLFxuICAgICAgICAgICAgYWRkcmVzc1Y6IEFERFJFU1NfQ0xBTVBfVE9fRURHRSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBNb3JwaCB9O1xuIl0sIm5hbWVzIjpbIl9mbG9hdFJvdW5kaW5nIiwiZGVmYXVsdE9wdGlvbnMiLCJwcmVmZXJIaWdoUHJlY2lzaW9uIiwiTW9ycGgiLCJSZWZDb3VudGVkT2JqZWN0IiwiY29uc3RydWN0b3IiLCJ0YXJnZXRzIiwiZ3JhcGhpY3NEZXZpY2UiLCJvcHRpb25zIiwiX2FhYmIiLCJEZWJ1ZyIsImFzc2VydERlcHJlY2F0ZWQiLCJkZXZpY2UiLCJHcmFwaGljc0RldmljZUFjY2VzcyIsImdldCIsImZvckVhY2giLCJ0YXJnZXQiLCJhc3NlcnQiLCJ1c2VkIiwiX3RhcmdldHMiLCJzbGljZSIsInN1cHBvcnRzTW9ycGhUYXJnZXRUZXh0dXJlc0NvcmUiLCJyZW5kZXJhYmxlSGFsZiIsImV4dFRleHR1cmVIYWxmRmxvYXQiLCJ0ZXh0dXJlSGFsZkZsb2F0UmVuZGVyYWJsZSIsIlBJWEVMRk9STUFUX1JHQkExNkYiLCJ1bmRlZmluZWQiLCJyZW5kZXJhYmxlRmxvYXQiLCJleHRUZXh0dXJlRmxvYXQiLCJ0ZXh0dXJlRmxvYXRSZW5kZXJhYmxlIiwiUElYRUxGT1JNQVRfUkdCQTMyRiIsIl9yZW5kZXJUZXh0dXJlRm9ybWF0IiwidGV4dHVyZUhhbGYiLCJ0ZXh0dXJlSGFsZkZsb2F0VXBkYXRhYmxlIiwidGV4dHVyZUZsb2F0IiwiUElYRUxGT1JNQVRfUkdCMzJGIiwiX3RleHR1cmVGb3JtYXQiLCJfdXNlVGV4dHVyZU1vcnBoIiwiX2luaXQiLCJfdXBkYXRlTW9ycGhGbGFncyIsImFhYmIiLCJtaW4iLCJWZWMzIiwibWF4IiwiaSIsImxlbmd0aCIsInRhcmdldEFhYmIiLCJnZXRNaW4iLCJnZXRNYXgiLCJCb3VuZGluZ0JveCIsInNldE1pbk1heCIsIm1vcnBoUG9zaXRpb25zIiwiX21vcnBoUG9zaXRpb25zIiwibW9ycGhOb3JtYWxzIiwiX21vcnBoTm9ybWFscyIsIm1heEFjdGl2ZVRhcmdldHMiLCJ1c2VUZXh0dXJlTW9ycGgiLCJfaW5pdFRleHR1cmVCYXNlZCIsIl9pbml0VmVydGV4QnVmZmVycyIsIl9wb3N0SW5pdCIsIl9maW5kU3BhcnNlU2V0IiwiZGVsdGFBcnJheXMiLCJpZHMiLCJ1c2VkRGF0YUluZGljZXMiLCJmcmVlSW5kZXgiLCJkYXRhQ291bnQiLCJ2IiwidmVydGV4VXNlZCIsImRhdGEiLCJwdXNoIiwiZGVsdGFJbmZvcyIsImRlbHRhUG9zaXRpb25zIiwibmFtZSIsImRlbHRhTm9ybWFscyIsIm1heFRleHR1cmVTaXplIiwiTWF0aCIsIm1vcnBoVGV4dHVyZVdpZHRoIiwiY2VpbCIsInNxcnQiLCJtb3JwaFRleHR1cmVIZWlnaHQiLCJoYWxmRmxvYXQiLCJudW1Db21wb25lbnRzIiwiZmxvYXQySGFsZiIsIkZsb2F0UGFja2luZyIsInRleHR1cmVzIiwiX2NyZWF0ZVRleHR1cmUiLCJ0ZXh0dXJlIiwidGV4dHVyZURhdGEiLCJsb2NrIiwiaW5kZXgiLCJkc3RJbmRleCIsInVubG9jayIsIl9zZXRUZXh0dXJlIiwiZm9ybWF0RGVzYyIsInNlbWFudGljIiwiU0VNQU5USUNfQVRUUjE1IiwiY29tcG9uZW50cyIsInR5cGUiLCJUWVBFX0ZMT0FUMzIiLCJ2ZXJ0ZXhCdWZmZXJJZHMiLCJWZXJ0ZXhCdWZmZXIiLCJWZXJ0ZXhGb3JtYXQiLCJCVUZGRVJfU1RBVElDIiwiRmxvYXQzMkFycmF5IiwiZGVzdHJveSIsIl90aGlzJHZlcnRleEJ1ZmZlcklkcyIsImZvcm1hdCIsIlRleHR1cmUiLCJ3aWR0aCIsImhlaWdodCIsImN1YmVtYXAiLCJtaXBtYXBzIiwibWluRmlsdGVyIiwiRklMVEVSX05FQVJFU1QiLCJtYWdGaWx0ZXIiLCJhZGRyZXNzVSIsIkFERFJFU1NfQ0xBTVBfVE9fRURHRSIsImFkZHJlc3NWIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQSxNQUFNQSxjQUFjLEdBQUcsR0FBRyxDQUFBO0FBRTFCLE1BQU1DLGNBQWMsR0FBRztBQUNuQkMsRUFBQUEsbUJBQW1CLEVBQUUsS0FBQTtBQUN6QixDQUFDLENBQUE7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsS0FBSyxTQUFTQyxnQkFBZ0IsQ0FBQztBQUNqQzs7QUFHQTs7QUFHQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLFdBQVdBLENBQUNDLE9BQU8sRUFBRUMsY0FBYyxFQUFFQyxPQUFPLEdBQUdQLGNBQWMsRUFBRTtBQUMzRCxJQUFBLEtBQUssRUFBRSxDQUFBO0FBQUMsSUFBQSxJQUFBLENBakJaUSxLQUFLLEdBQUEsS0FBQSxDQUFBLENBQUE7QUFBQSxJQUFBLElBQUEsQ0FHTFAsbUJBQW1CLEdBQUEsS0FBQSxDQUFBLENBQUE7QUFnQmZRLElBQUFBLEtBQUssQ0FBQ0MsZ0JBQWdCLENBQUNKLGNBQWMsRUFBRSxtRkFBbUYsQ0FBQyxDQUFBO0lBQzNILElBQUksQ0FBQ0ssTUFBTSxHQUFHTCxjQUFjLElBQUlNLG9CQUFvQixDQUFDQyxHQUFHLEVBQUUsQ0FBQTtBQUUxRCxJQUFBLElBQUksQ0FBQ1osbUJBQW1CLEdBQUdNLE9BQU8sQ0FBQ04sbUJBQW1CLENBQUE7O0FBRXREO0FBQ0FJLElBQUFBLE9BQU8sQ0FBQ1MsT0FBTyxDQUFDQyxNQUFNLElBQUlOLEtBQUssQ0FBQ08sTUFBTSxDQUFDLENBQUNELE1BQU0sQ0FBQ0UsSUFBSSxFQUFFLHNGQUFzRixDQUFDLENBQUMsQ0FBQTtBQUM3SSxJQUFBLElBQUksQ0FBQ0MsUUFBUSxHQUFHYixPQUFPLENBQUNjLEtBQUssRUFBRSxDQUFBOztBQUUvQjtBQUNBLElBQUEsTUFBTVIsTUFB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
