var t="\nfloat VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\t\tfloat pixelSize = 1.0 / resolution;\n\t\ttexCoords -= vec2(pixelSize);\n\t\tvec3 s00 = texture2D(tex, texCoords).xyz;\n\t\tvec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n\t\tvec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n\t\tvec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n\t\tvec2 fr = fract(texCoords * resolution);\n\t\tvec3 h0 = mix(s00, s10, fr.x);\n\t\tvec3 h1 = mix(s01, s11, fr.x);\n\t\tvec3 moments = mix(h0, h1, fr.y);\n\t\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\n\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowCoord, vec3 shadowParams, float exponent, vec3 lightDir) {\n\t\treturn VSM$(shadowMap, shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);\n}\n\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\t\treturn VSM$(shadowMap, shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";export{t as default};
