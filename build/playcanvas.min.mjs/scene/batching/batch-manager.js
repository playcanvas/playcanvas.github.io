import"../../core/time.js";import"../../core/tracing.js";import{Vec3 as e}from"../../math/vec3.js";import{Mat3 as t}from"../../math/mat3.js";import{BoundingBox as s}from"../../shape/bounding-box.js";import{PRIMITIVE_TRIFAN as n,SEMANTIC_BLENDINDICES as r,TYPE_FLOAT32 as i,typedArrayTypes as o,typedArrayTypesByteSize as a,SEMANTIC_POSITION as h,SEMANTIC_NORMAL as c,SEMANTIC_TANGENT as l,typedArrayIndexFormats as m,PRIMITIVE_TRIANGLES as u}from"../../graphics/constants.js";import{shaderChunks as d}from"../../graphics/program-lib/chunks/chunks.js";import{SPRITE_RENDERMODE_SIMPLE as p}from"../constants.js";import{Mesh as f}from"../mesh.js";import{MeshInstance as _}from"../mesh-instance.js";import{Batch as b}from"./batch.js";import{BatchGroup as g}from"./batch-group.js";import{SkinBatchInstance as I}from"./skin-batch-instance.js";function y(e,t){if(e&&!t)return!1;if(!e&&t)return!1;if((e=e.data)===(t=t.data))return!0;if(e instanceof Float32Array&&t instanceof Float32Array){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}return!1}function x(e,t){for(const s in e)if(e.hasOwnProperty(s)&&!y(e[s],t[s]))return!1;for(const s in t)if(t.hasOwnProperty(s)&&!y(t[s],e[s]))return!1;return!0}function G(e,t){for(let s=0;s<e.length;s++)if(t.indexOf(e[s])<0)return!1;for(let s=0;s<t.length;s++)if(e.indexOf(t[s])<0)return!1;return!0}const v=new t,w=new e,L=new e,S=new e;function B(e){const t=e.node.worldTransform;return t.getX(w),t.getY(L),t.getZ(S),w.cross(w,L),w.dot(S)>=0?1:-1}class M{constructor(e,t,s){this.device=e,this.rootNode=t,this.scene=s,this._init=!1,this._batchGroups={},this._batchGroupCounter=0,this._batchList=[],this._dirtyGroups=[]}destroy(){this.device=null,this.rootNode=null,this.scene=null,this._batchGroups={},this._batchList=[],this._dirtyGroups=[]}addGroup(e,t,s,n,r){if(void 0===n&&(n=this._batchGroupCounter,this._batchGroupCounter++),this._batchGroups[n])return;const i=new g(n,e,t,s,r);return this._batchGroups[n]=i,i}removeGroup(e){if(!this._batchGroups[e])return;const t=[];for(let s=0;s<this._batchList.length;s++)this._batchList[s].batchGroupId===e?this.destroyBatch(this._batchList[s]):t.push(this._batchList[s]);this._batchList=t,this._removeModelsFromBatchGroup(this.rootNode,e),delete this._batchGroups[e]}markGroupDirty(e){this._dirtyGroups.indexOf(e)<0&&this._dirtyGroups.push(e)}getGroupByName(e){const t=this._batchGroups;for(const s in t)if(t.hasOwnProperty(s)&&t[s].name===e)return t[s];return null}getBatches(e){const t=[],s=this._batchList.length;for(let n=0;n<s;n++){const s=this._batchList[n];s.batchGroupId===e&&t.push(s)}return t}_removeModelsFromBatchGroup(e,t){if(e.enabled){e.model&&e.model.batchGroupId===t&&(e.model.batchGroupId=-1),e.render&&e.render.batchGroupId===t&&(e.render.batchGroupId=-1),e.element&&e.element.batchGroupId===t&&(e.element.batchGroupId=-1),e.sprite&&e.sprite.batchGroupId===t&&(e.sprite.batchGroupId=-1);for(let s=0;s<e._children.length;s++)this._removeModelsFromBatchGroup(e._children[s],t)}}insert(e,t,s){const n=this._batchGroups[t];n&&n._obj[e].indexOf(s)<0&&(n._obj[e].push(s),this.markGroupDirty(t))}remove(e,t,s){const n=this._batchGroups[t];if(n){const r=n._obj[e].indexOf(s);r>=0&&(n._obj[e].splice(r,1),this.markGroupDirty(t))}}_extractRender(e,t,s,n){if(e.render){if(e.render.isStatic){const s=this.scene.drawCalls,n=e.render.meshInstances;for(let e=0;e<s.length;e++)s[e]._staticSource&&(n.indexOf(s[e]._staticSource)<0||t.push(s[e]));for(let e=0;e<n.length;e++)s.indexOf(n[e])>=0&&t.push(n[e])}else t=n[e.render.batchGroupId]=t.concat(e.render.meshInstances);e.render.removeFromLayers()}return t}_extractModel(e,t,s,n){if(e.model&&e.model.model){if(e.model.isStatic){const s=this.scene.drawCalls,n=e.model.meshInstances;for(let e=0;e<s.length;e++)s[e]._staticSource&&(n.indexOf(s[e]._staticSource)<0||t.push(s[e]));for(let e=0;e<n.length;e++)s.indexOf(n[e])>=0&&t.push(n[e])}else t=n[e.model.batchGroupId]=t.concat(e.model.meshInstances);e.model.removeModelFromLayers()}return t}_extractElement(e,t,s){if(!e.element)return;let n=!1;e.element._text&&e.element._text._model.meshInstances.length>0?(t.push(e.element._text._model.meshInstances[0]),e.element.removeModelFromLayers(e.element._text._model),n=!0):e.element._image&&(t.push(e.element._image._renderable.meshInstance),e.element.removeModelFromLayers(e.element._image._renderable.model),e.element._image._renderable.unmaskMeshInstance&&(t.push(e.element._image._renderable.unmaskMeshInstance),e.element._image._renderable.unmaskMeshInstance.stencilFront&&e.element._image._renderable.unmaskMeshInstance.stencilBack||(e.element._dirtifyMask(),e.element._onPrerender())),n=!0),n&&(s._ui=!0)}_collectAndRemoveMeshInstances(e,t){for(let s=0;s<t.length;s++){const n=t[s],r=this._batchGroups[n];if(!r)continue;let i=e[n];i||(i=e[n]=[]);for(let t=0;t<r._obj.model.length;t++)i=this._extractModel(r._obj.model[t],i,r,e);for(let t=0;t<r._obj.render.length;t++)i=this._extractRender(r._obj.render[t],i,r,e);for(let e=0;e<r._obj.element.length;e++)this._extractElement(r._obj.element[e],i,r);for(let e=0;e<r._obj.sprite.length;e++){const t=r._obj.sprite[e];t.sprite&&t.sprite._meshInstance&&(r.dynamic||t.sprite.sprite._renderMode===p)&&(i.push(t.sprite._meshInstance),t.sprite.removeModelFromLayers(),r._sprite=!0,t.sprite._batchGroup=r)}}}generate(e){const t={};e||(e=Object.keys(this._batchGroups));const s=[];for(let t=0;t<this._batchList.length;t++)e.indexOf(this._batchList[t].batchGroupId)<0?s.push(this._batchList[t]):this.destroyBatch(this._batchList[t]);if(this._batchList=s,this._collectAndRemoveMeshInstances(t,e),e===this._dirtyGroups)this._dirtyGroups.length=0;else{const t=[];for(let s=0;s<this._dirtyGroups.length;s++)e.indexOf(this._dirtyGroups[s])<0&&t.push(this._dirtyGroups[s]);this._dirtyGroups=t}let n,r,i,o;for(const e in t)if(t.hasOwnProperty(e)&&(n=t[e],i=this._batchGroups[e],i)){r=this.prepare(n,i.dynamic,i.maxAabbSize,i._ui||i._sprite);for(let t=0;t<r.length;t++)o=this.create(r[t],i.dynamic,parseInt(e,10)),o&&o.addToLayers(this.scene,i.layers)}}prepare(e,t,n=Number.POSITIVE_INFINITY,r){if(0===e.length)return[];const i=.5*n,o=this.device.supportsBoneTextures?1024:this.device.boneLimit,a=this.device.extUintElement?4294967295:65535,h=new s,c=new s;let l,m=null;const u=[];let d=0;r&&e.sort((function(e,t){return e.drawOrder-t.drawOrder}));let p,f=e;const _=r?function(e){m?m.add(e.aabb):m=e.aabb.clone(),p.push(e)}:function(e){p.push(e)};for(;f.length>0;){u[d]=[f[0]],p=[];const e=f[0].material,s=f[0].layer,n=f[0]._shaderDefs,b=f[0].parameters,g=f[0].stencilFront,I=f[0]._staticLightList;let y=f[0].mesh.vertexBuffer.getNumVertices();const v=f[0].drawOrder;h.copy(f[0].aabb);const w=B(f[0]),L=f[0].mesh.vertexBuffer.format.batchingHash,S=f[0].mesh.primitive[0].indexed;m=null;for(let M=1;M<f.length;M++){const k=f[M];if(t&&u[d].length>=o){p=p.concat(f.slice(M));break}if(e!==k.material||s!==k.layer||L!==k.mesh.vertexBuffer.format.batchingHash||S!==k.mesh.primitive[0].indexed||n!==k._shaderDefs||y+k.mesh.vertexBuffer.getNumVertices()>a){_(k);continue}if(c.copy(h),c.add(k.aabb),c.halfExtents.x>i||c.halfExtents.y>i||c.halfExtents.z>i){_(k);continue}if(g&&(!(l=k.stencilFront)||g.func!==l.func||g.zpass!==l.zpass)){_(k);continue}if(w!==B(k)){_(k);continue}if(!x(b,k.parameters)){_(k);continue}const j=k._staticLightList;if(I&&j){if(!G(I,j)){_(k);continue}}else if(I||j){_(k);continue}r&&m&&m.intersects(k.aabb)&&k.drawOrder!==v?_(k):(h.add(k.aabb),y+=k.mesh.vertexBuffer.getNumVertices(),u[d].push(k))}d++,f=p}return u}collectBatchedMeshData(e,t){let s=null,o=0,a=0,h=null;for(let c=0;c<e.length;c++)if(e[c].visible){const l=e[c].mesh;if(o+=l.vertexBuffer.numVertices,a+=l.primitive[0].indexed?l.primitive[0].count:l.primitive[0].type===n&&4===l.primitive[0].count?6:0,!s){h=e[c].material,s={};const n=l.vertexBuffer.format.elements;for(let e=0;e<n.length;e++){s[n[e].name]={numComponents:n[e].numComponents,dataType:n[e].dataType,normalize:n[e].normalize,count:0}}t&&(s[r]={numComponents:1,dataType:i,normalize:!1,count:0})}}return{streams:s,batchNumVerts:o,batchNumIndices:a,material:h}}create(t,s,i){if(!this._init){const e="#define BONE_LIMIT "+this.device.getBoneLimit()+"\n";this.transformVS=e+"#define DYNAMICBATCH\n"+d.transformVS,this.skinTexVS=d.skinBatchTexVS,this.skinConstVS=d.skinBatchConstVS,this.vertexFormats={},this._init=!0}let p,g,y,x=null,G=null;const w=this.collectBatchedMeshData(t,s);if(w.streams){const d=w.streams;let L=w.material;const S=w.batchNumVerts,M=w.batchNumIndices;let k,j,O;G=new b(t,s,i),this._batchList.push(G);let V,T=0,C=0;const F=new e,N=new(S<=65535?Uint16Array:Uint32Array)(M);for(p in d)x=d[p],x.typeArrayType=o[x.dataType],x.elementByteSize=a[x.dataType],x.buffer=new x.typeArrayType(S*x.numComponents);for(let e=0;e<t.length;e++)if(t[e].visible){for(p in g=t[e].mesh,y=g.vertexBuffer.numVertices,s||(V=t[e].node.getWorldTransform()),d)if(p!==r){x=d[p];const e=new x.typeArrayType(x.buffer.buffer,x.elementByteSize*x.count),t=g.getVertexStream(p,e)*x.numComponents;if(x.count+=t,!s&&x.numComponents>=3)if(p===h)for(let s=0;s<t;s+=x.numComponents)F.set(e[s],e[s+1],e[s+2]),V.transformPoint(F,F),e[s]=F.x,e[s+1]=F.y,e[s+2]=F.z;else if(p===c||p===l){V.invertTo3x3(v),v.transpose();for(let s=0;s<t;s+=x.numComponents)F.set(e[s],e[s+1],e[s+2]),v.transformVector(F,F),e[s]=F.x,e[s+1]=F.y,e[s+2]=F.z}}if(s){x=d[r];for(let t=0;t<y;t++)x.buffer[x.count++]=e}if(g.primitive[0].indexed){k=g.primitive[0].base,j=g.primitive[0].count;const e=g.indexBuffer[0].getFormat();O=new m[e](g.indexBuffer[0].storage)}else{if(g.primitive[0].type!==n||4!==g.primitive[0].count){j=0;continue}k=0,j=6,O=[0,1,3,2,3,1]}for(let e=0;e<j;e++)N[e+C]=O[k+e]+T;C+=j,T+=y}for(p in g=new f(this.device),d)x=d[p],g.setVertexStream(p,x.buffer,x.numComponents,void 0,x.dataType,x.normalize);N.length>0&&g.setIndices(N),g.update(u,!1),s&&(L=L.clone(),L.chunks.transformVS=this.transformVS,L.chunks.skinTexVS=this.skinTexVS,L.chunks.skinConstVS=this.skinConstVS,L.update());const A=new _(g,L,this.rootNode);A.castShadow=G.origMeshInstances[0].castShadow,A.parameters=G.origMeshInstances[0].parameters,A.isStatic=G.origMeshInstances[0].isStatic,A.layer=G.origMeshInstances[0].layer,A._staticLightList=G.origMeshInstances[0]._staticLightList,A._shaderDefs=G.origMeshInstances[0]._shaderDefs,A.cull=G.origMeshInstances[0].cull;const z=this._batchGroups[i];if(z&&z._ui&&(A.cull=!1),s){const e=[];for(let t=0;t<G.origMeshInstances.length;t++)e.push(G.origMeshInstances[t].node);A.skinInstance=new I(this.device,e,this.rootNode)}A._updateAabb=!1,A.drawOrder=G.origMeshInstances[0].drawOrder,A.stencilFront=G.origMeshInstances[0].stencilFront,A.stencilBack=G.origMeshInstances[0].stencilBack,A.flipFaces=B(G.origMeshInstances[0])<0,A.castShadow=G.origMeshInstances[0].castShadow,G.meshInstance=A,G.updateBoundingBox()}return G}updateAll(){this._dirtyGroups.length>0&&this.generate(this._dirtyGroups);for(let e=0;e<this._batchList.length;e++)this._batchList[e].dynamic&&this._batchList[e].updateBoundingBox()}clone(e,t){const s=new b(t,e.dynamic,e.batchGroupId);this._batchList.push(s);const n=[];for(let e=0;e<t.length;e++)n.push(t[e].node);return s.meshInstance=new _(e.meshInstance.mesh,e.meshInstance.material,e.meshInstance.node),s.meshInstance._updateAabb=!1,s.meshInstance.parameters=t[0].parameters,s.meshInstance.isStatic=t[0].isStatic,s.meshInstance.cull=t[0].cull,s.meshInstance.layer=t[0].layer,s.meshInstance._staticLightList=t[0]._staticLightList,e.dynamic&&(s.meshInstance.skinInstance=new I(this.device,n,this.rootNode)),s.meshInstance.castShadow=e.meshInstance.castShadow,s.meshInstance._shader=e.meshInstance._shader.slice(),s.meshInstance.castShadow=e.meshInstance.castShadow,s}destroyBatch(e){e.destroy(this.scene,this._batchGroups[e.batchGroupId].layers)}}export{M as BatchManager};
