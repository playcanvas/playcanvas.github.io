import"../../core/debug.js";import{typedArrayIndexFormatsByteSize as t,BUFFER_STATIC as e,INDEXFORMAT_UINT32 as s,INDEXFORMAT_UINT16 as i}from"./constants.js";let r=0;class n{constructor(s,i,n,h=e,a){this.device=s,this.format=i,this.numIndices=n,this.usage=h,this.id=r++,this.impl=s.createIndexBufferImpl(this);const o=t[i];this.bytesPerIndex=o,this.numBytes=this.numIndices*o,a?this.setData(a):this.storage=new ArrayBuffer(this.numBytes),this.adjustVramSizeTracking(s._vram,this.numBytes),this.device.buffers.push(this)}destroy(){const t=this.device,e=t.buffers.indexOf(this);-1!==e&&t.buffers.splice(e,1),this.device.indexBuffer===this&&(this.device.indexBuffer=null),this.impl.initialized&&(this.impl.destroy(t),this.adjustVramSizeTracking(t._vram,-this.storage.byteLength))}adjustVramSizeTracking(t,e){t.ib+=e}loseContext(){this.impl.loseContext()}getFormat(){return this.format}getNumIndices(){return this.numIndices}lock(){return this.storage}unlock(){this.impl.unlock(this)}setData(t){return t.byteLength===this.numBytes&&(this.storage=t,this.unlock(),!0)}_lockTypedArray(){const t=this.lock();return this.format===s?new Uint32Array(t):this.format===i?new Uint16Array(t):new Uint8Array(t)}writeData(t,e){const s=this._lockTypedArray();if(t.length>e)if(ArrayBuffer.isView(t))t=t.subarray(0,e),s.set(t);else for(let i=0;i<e;i++)s[i]=t[i];else s.set(t);this.unlock()}readData(t){const e=this._lockTypedArray(),s=this.numIndices;if(ArrayBuffer.isView(t))t.set(e);else{t.length=0;for(let i=0;i<s;i++)t[i]=e[i]}return s}}export{n as IndexBuffer};
