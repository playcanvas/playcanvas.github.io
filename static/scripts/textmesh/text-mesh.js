const BEZIER_STEP_SIZE=3,EPSILON=1e-6,p=new pc.Vec2,p1=new pc.Vec2,p2=new pc.Vec2,vTemp1=new pc.Vec2,vTemp2=new pc.Vec2,vTemp3=new pc.Vec2,vTemp4=new pc.Vec2,vTemp5=new pc.Vec2,vTemp6=new pc.Vec2;class Polygon{constructor(){this.points=[],this.children=[],this.area=0}moveTo(t,e){this.points.push(new pc.Vec2(t,e))}lineTo(t,e){this.points.push(new pc.Vec2(t,e))}close(){let t=this.points[this.points.length-1];this.points.forEach((e=>{this.area+=.5*t.cross(e),t=e}))}conicTo(t,e,s,i,a=10){p.set(t,e),p1.set(s,i);const n=this.points[this.points.length-1],r=n.distance(p1)+p1.distance(p),h=Math.max(2,Math.min(a,r/3));for(let t=1;t<=h;t++){const e=t/h;vTemp1.lerp(n,p1,e),vTemp2.lerp(p1,p,e),vTemp3.lerp(vTemp1,vTemp2,e),this.points.push(vTemp3.clone())}}cubicTo(t,e,s,i,a,n,r=10){p.set(t,e),p1.set(s,i),p2.set(a,n);const h=this.points[this.points.length-1],c=h.distance(p1)+p1.distance(p2)+p2.distance(p),o=Math.max(2,Math.min(r,c/3));for(let t=1;t<=o;t++){const e=t/o;vTemp1.lerp(h,p1,e),vTemp2.lerp(p1,p2,e),vTemp3.lerp(p2,p,e),vTemp4.lerp(vTemp1,vTemp2,e),vTemp5.lerp(vTemp2,vTemp3,e),vTemp6.lerp(vTemp4,vTemp5,e),this.points.push(vTemp6.clone())}}inside(t){let e=0,s=this.points[this.points.length-1];return this.points.forEach((i=>{const a=s.y<i.y?s:i,n=s.y<i.y?i:s;a.y<t.y+EPSILON&&n.y>t.y+EPSILON&&(n.x-a.x)*(t.y-a.y)>(t.x-a.x)*(n.y-a.y)&&(e+=1),s=i})),e%2!=0}}var TextMesh=pc.createScript("textMesh");TextMesh.attributes.add("font",{type:"asset",assetType:"binary",title:"Font",description:"TTF file used as the basis for this 3D text"}),TextMesh.attributes.add("text",{type:"string",title:"Text",description:"The text string to render as a 3D mesh"}),TextMesh.attributes.add("alignment",{type:"number",default:0,enum:[{Left:0},{Center:1},{Right:2}],title:"Alignment",description:"Controls whether the text is centered or left or right justified"}),TextMesh.attributes.add("characterSize",{type:"number",default:1,title:"Character Size",description:"The world space (maximum) height of each character"}),TextMesh.attributes.add("characterSpacing",{type:"number",min:0,default:0,title:"Character Spacing",description:"Additional spacing between each character"}),TextMesh.attributes.add("kerning",{type:"number",min:0,max:1,default:1,title:"Kerning",description:"Scales character pair kerning value so 0 is no kerning and 1 is full kerning"}),TextMesh.attributes.add("depth",{type:"number",default:1,title:"Depth",description:"Depth of the extrusion applied to the text"}),TextMesh.attributes.add("maxCurveSteps",{type:"number",default:10,title:"Max Curve Steps",description:"Maximum number of divisions applied to bezier based path in a font outline"}),TextMesh.attributes.add("renderStyle",{type:"number",default:0,enum:[{Solid:0},{Wireframe:1}],title:"Render Style",description:"Controls whether the text is rendered as solid or wireframe"}),TextMesh.attributes.add("material",{type:"asset",assetType:"material",title:"Material",description:"The material to apply to the 3D text mesh"}),TextMesh.prototype.initialize=function(){this.characters=[],this.fontData=null,this.font&&(this.fontData=opentype.parse(this.font.resource),this.createText()),this.on("attr",(function(t,e,s){e!==s&&("font"===t&&(this.font?this.fontData=opentype.parse(this.font.resource):(this.fontData=null,this.destroyCharacters())),this.fontData&&this.createText())}))},TextMesh.prototype.parseCommands=function(t){var e=[];t.forEach((({type:t,x:s,y:i,x1:a,y1:n,x2:r,y2:h})=>{switch(t){case"M":e.push(new Polygon),e[e.length-1].moveTo(s,i);break;case"L":e[e.length-1].moveTo(s,i);break;case"C":e[e.length-1].cubicTo(s,i,a,n,r,h,this.maxCurveSteps);break;case"Q":e[e.length-1].conicTo(s,i,a,n,this.maxCurveSteps);break;case"Z":e[e.length-1].close()}})),e.sort(((t,e)=>Math.abs(e.area)-Math.abs(t.area)));const s=[];for(let t=0;t<e.length;++t){let i=null;for(let s=t-1;s>=0;--s)if(e[s].inside(e[t].points[0])&&e[t].area*e[s].area<0){i=e[s];break}i?i.children.push(e[t]):s.push(e[t])}const i=e.reduce(((t,e)=>t+e.points.length),0),a=new Float32Array(2*i);let n=0;const r=[];s.forEach((function t(e){const s=[],i=[];e.points.forEach((({x:t,y:e})=>s.push(t,e))),e.children.forEach((e=>{e.children.forEach(t),i.push(s.length/2),e.points.forEach((({x:t,y:e})=>s.push(t,e)))})),a.set(s,2*n),earcut(s,i).forEach((t=>r.push(t+n))),n+=s.length/2}));const h=this.characterSize/this.fontData.unitsPerEm,c=[];for(let t=0;t<a.length;t+=2)c.push(a[t]*h,a[t+1]*h,this.depth);for(let t=0;t<a.length;t+=2)c.push(a[t]*h,a[t+1]*h,0);const p=r.length;for(let t=0;t<p;t+=3)r.push(r[t+2]+n,r[t+1]+n,r[t]+n);e.forEach((t=>{for(let e=0;e<t.points.length-1;e++){const s=c.length/3,i=t.points[e],a=t.points[e+1];c.push(i.x*h,i.y*h,this.depth,a.x*h,a.y*h,this.depth,i.x*h,i.y*h,0,a.x*h,a.y*h,0),r.push(s,s+1,s+2,s+1,s+3,s+2)}}));const o=pc.calculateNormals(c,r);return{vertices:c,normals:o,indices:r}},TextMesh.prototype.calculateWidth=function(){const t=this.fontData,e=this.characterSize/t.unitsPerEm;let s=0;for(var i=0;i<this.text.length;i++){const r=this.text.charAt(i);if(s+=t.charToGlyph(r).advanceWidth*e,i<this.text.length-1){s+=this.characterSpacing;var a=t.charToGlyph(r),n=t.charToGlyph(this.text.charAt(i+1));s+=t.getKerningValue(a,n)*this.kerning*e}}return s},TextMesh.prototype.destroyCharacters=function(){this.characters.forEach((function(t){t.destroy()})),this.characters.length=0},TextMesh.prototype.createText=function(){this.destroyCharacters();const t=this.fontData,e=this.characterSize/t.unitsPerEm;var s=this.calculateWidth(),i=0;switch(this.alignment){case 0:break;case 1:i=.5*-s;break;case 2:i=-s}for(var a=this.material?this.material.resource:new pc.StandardMaterial,n=0;n<this.text.length;n++){var r=this.text.charAt(n),h=t.charToGlyph(r),c=this.parseCommands(h.path.commands);if(c.vertices.length>0){var p=this.app.graphicsDevice,o=new pc.Mesh(p);o.setPositions(c.vertices),o.setNormals(c.normals),o.setIndices(c.indices),o.update(pc.PRIMITIVE_TRIANGLES);var l=new pc.MeshInstance(o,a),d=new pc.Entity(r);d.addComponent("render",{meshInstances:[l],renderStyle:this.renderStyle}),this.entity.addChild(d),d.setLocalPosition(i,0,0),this.characters.push(d)}if(n<this.text.length-1){var u=t.charToGlyph(this.text.charAt(n+1));i+=t.getKerningValue(h,u)*this.kerning*e}i+=h.advanceWidth*e+this.characterSpacing}};