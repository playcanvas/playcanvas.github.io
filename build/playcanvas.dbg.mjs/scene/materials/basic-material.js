/**
 * @license
 * PlayCanvas Engine v1.63.0-dev revision 9f3635a4e (DEBUG PROFILER)
 * Copyright 2011-2023 PlayCanvas Ltd. All rights reserved.
 */
import { Debug } from '../../core/debug.js';
import { Color } from '../../core/math/color.js';
import { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';
import { SHADERDEF_SKIN, SHADERDEF_SCREENSPACE, SHADERDEF_INSTANCING, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_TEXTURE_BASED } from '../constants.js';
import { getProgramLibrary } from '../shader-lib/get-program-library.js';
import { basic } from '../shader-lib/programs/basic.js';
import { Material } from './material.js';

/**
 * A BasicMaterial is for rendering unlit geometry, either using a constant color or a color map
 * modulated with a color.
 *
 * @augments Material
 */
class BasicMaterial extends Material {
  /**
   * Create a new BasicMaterial instance.
   *
   * @example
   * // Create a new Basic material
   * var material = new pc.BasicMaterial();
   *
   * // Set the material to have a texture map that is multiplied by a red color
   * material.color.set(1, 0, 0);
   * material.colorMap = diffuseMap;
   *
   * // Notify the material that it has been modified
   * material.update();
   */
  constructor() {
    super();

    /**
     * The flat color of the material (RGBA, where each component is 0 to 1).
     *
     * @type {Color}
     */
    this.color = new Color(1, 1, 1, 1);
    this.colorUniform = new Float32Array(4);

    /**
     * The color map of the material (default is null). If specified, the color map is
     * modulated by the color property.
     *
     * @type {import('../../platform/graphics/texture.js').Texture|null}
     */
    this.colorMap = null;
    this.vertexColors = false;
  }

  /**
   * Copy a `BasicMaterial`.
   *
   * @param {BasicMaterial} source - The material to copy from.
   * @returns {BasicMaterial} The destination material.
   */
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.colorMap = source.colorMap;
    this.vertexColors = source.vertexColors;
    return this;
  }
  updateUniforms(device, scene) {
    this.clearParameters();
    this.colorUniform[0] = this.color.r;
    this.colorUniform[1] = this.color.g;
    this.colorUniform[2] = this.color.b;
    this.colorUniform[3] = this.color.a;
    this.setParameter('uColor', this.colorUniform);
    if (this.colorMap) {
      this.setParameter('texture_diffuseMap', this.colorMap);
    }
  }
  getShaderVariant(device, scene, objDefs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat, vertexFormat) {
    // Note: this is deprecated function Editor and possibly other projects use: they define
    // updateShader callback on their BasicMaterial, so we handle it here.
    if (this.updateShader) {
      Debug.deprecated('pc.BasicMaterial.updateShader is deprecated');
      this.updateShader(device, scene, objDefs, staticLightList, pass, sortedLights);
      return this.shader;
    }
    const options = {
      skin: objDefs && (objDefs & SHADERDEF_SKIN) !== 0,
      screenSpace: objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0,
      useInstancing: objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0,
      useMorphPosition: objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0,
      useMorphNormal: objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,
      useMorphTextureBased: objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0,
      alphaTest: this.alphaTest > 0,
      vertexColors: this.vertexColors,
      diffuseMap: !!this.colorMap,
      pass: pass
    };
    const processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat, vertexFormat);
    const library = getProgramLibrary(device);
    library.register('basic', basic);
    return library.getProgram('basic', options, processingOptions);
  }
}

export { BasicMaterial };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzaWMtbWF0ZXJpYWwuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9zY2VuZS9tYXRlcmlhbHMvYmFzaWMtbWF0ZXJpYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVidWcgfSBmcm9tICcuLi8uLi9jb3JlL2RlYnVnLmpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vY29yZS9tYXRoL2NvbG9yLmpzJztcblxuaW1wb3J0IHsgU2hhZGVyUHJvY2Vzc29yT3B0aW9ucyB9IGZyb20gJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL3NoYWRlci1wcm9jZXNzb3Itb3B0aW9ucy5qcyc7XG5cbmltcG9ydCB7XG4gICAgU0hBREVSREVGX0lOU1RBTkNJTkcsIFNIQURFUkRFRl9NT1JQSF9OT1JNQUwsIFNIQURFUkRFRl9NT1JQSF9QT1NJVElPTiwgU0hBREVSREVGX01PUlBIX1RFWFRVUkVfQkFTRUQsXG4gICAgU0hBREVSREVGX1NDUkVFTlNQQUNFLCBTSEFERVJERUZfU0tJTlxufSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZ2V0UHJvZ3JhbUxpYnJhcnkgfSBmcm9tICcuLi9zaGFkZXItbGliL2dldC1wcm9ncmFtLWxpYnJhcnkuanMnO1xuaW1wb3J0IHsgYmFzaWMgfSBmcm9tICcuLi9zaGFkZXItbGliL3Byb2dyYW1zL2Jhc2ljLmpzJztcbmltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi9tYXRlcmlhbC5qcyc7XG5cbi8qKlxuICogQSBCYXNpY01hdGVyaWFsIGlzIGZvciByZW5kZXJpbmcgdW5saXQgZ2VvbWV0cnksIGVpdGhlciB1c2luZyBhIGNvbnN0YW50IGNvbG9yIG9yIGEgY29sb3IgbWFwXG4gKiBtb2R1bGF0ZWQgd2l0aCBhIGNvbG9yLlxuICpcbiAqIEBhdWdtZW50cyBNYXRlcmlhbFxuICovXG5jbGFzcyBCYXNpY01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBCYXNpY01hdGVyaWFsIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgQmFzaWMgbWF0ZXJpYWxcbiAgICAgKiB2YXIgbWF0ZXJpYWwgPSBuZXcgcGMuQmFzaWNNYXRlcmlhbCgpO1xuICAgICAqXG4gICAgICogLy8gU2V0IHRoZSBtYXRlcmlhbCB0byBoYXZlIGEgdGV4dHVyZSBtYXAgdGhhdCBpcyBtdWx0aXBsaWVkIGJ5IGEgcmVkIGNvbG9yXG4gICAgICogbWF0ZXJpYWwuY29sb3Iuc2V0KDEsIDAsIDApO1xuICAgICAqIG1hdGVyaWFsLmNvbG9yTWFwID0gZGlmZnVzZU1hcDtcbiAgICAgKlxuICAgICAqIC8vIE5vdGlmeSB0aGUgbWF0ZXJpYWwgdGhhdCBpdCBoYXMgYmVlbiBtb2RpZmllZFxuICAgICAqIG1hdGVyaWFsLnVwZGF0ZSgpO1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmxhdCBjb2xvciBvZiB0aGUgbWF0ZXJpYWwgKFJHQkEsIHdoZXJlIGVhY2ggY29tcG9uZW50IGlzIDAgdG8gMSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtDb2xvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSk7XG4gICAgICAgIHRoaXMuY29sb3JVbmlmb3JtID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbG9yIG1hcCBvZiB0aGUgbWF0ZXJpYWwgKGRlZmF1bHQgaXMgbnVsbCkuIElmIHNwZWNpZmllZCwgdGhlIGNvbG9yIG1hcCBpc1xuICAgICAgICAgKiBtb2R1bGF0ZWQgYnkgdGhlIGNvbG9yIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy90ZXh0dXJlLmpzJykuVGV4dHVyZXxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xvck1hcCA9IG51bGw7XG4gICAgICAgIHRoaXMudmVydGV4Q29sb3JzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29weSBhIGBCYXNpY01hdGVyaWFsYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QmFzaWNNYXRlcmlhbH0gc291cmNlIC0gVGhlIG1hdGVyaWFsIHRvIGNvcHkgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7QmFzaWNNYXRlcmlhbH0gVGhlIGRlc3RpbmF0aW9uIG1hdGVyaWFsLlxuICAgICAqL1xuICAgIGNvcHkoc291cmNlKSB7XG4gICAgICAgIHN1cGVyLmNvcHkoc291cmNlKTtcblxuICAgICAgICB0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcbiAgICAgICAgdGhpcy5jb2xvck1hcCA9IHNvdXJjZS5jb2xvck1hcDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVwZGF0ZVVuaWZvcm1zKGRldmljZSwgc2NlbmUpIHtcbiAgICAgICAgdGhpcy5jbGVhclBhcmFtZXRlcnMoKTtcblxuICAgICAgICB0aGlzLmNvbG9yVW5pZm9ybVswXSA9IHRoaXMuY29sb3IucjtcbiAgICAgICAgdGhpcy5jb2xvclVuaWZvcm1bMV0gPSB0aGlzLmNvbG9yLmc7XG4gICAgICAgIHRoaXMuY29sb3JVbmlmb3JtWzJdID0gdGhpcy5jb2xvci5iO1xuICAgICAgICB0aGlzLmNvbG9yVW5pZm9ybVszXSA9IHRoaXMuY29sb3IuYTtcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXIoJ3VDb2xvcicsIHRoaXMuY29sb3JVbmlmb3JtKTtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JNYXApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKCd0ZXh0dXJlX2RpZmZ1c2VNYXAnLCB0aGlzLmNvbG9yTWFwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNoYWRlclZhcmlhbnQoZGV2aWNlLCBzY2VuZSwgb2JqRGVmcywgc3RhdGljTGlnaHRMaXN0LCBwYXNzLCBzb3J0ZWRMaWdodHMsIHZpZXdVbmlmb3JtRm9ybWF0LCB2aWV3QmluZEdyb3VwRm9ybWF0LCB2ZXJ0ZXhGb3JtYXQpIHtcblxuICAgICAgICAvLyBOb3RlOiB0aGlzIGlzIGRlcHJlY2F0ZWQgZnVuY3Rpb24gRWRpdG9yIGFuZCBwb3NzaWJseSBvdGhlciBwcm9qZWN0cyB1c2U6IHRoZXkgZGVmaW5lXG4gICAgICAgIC8vIHVwZGF0ZVNoYWRlciBjYWxsYmFjayBvbiB0aGVpciBCYXNpY01hdGVyaWFsLCBzbyB3ZSBoYW5kbGUgaXQgaGVyZS5cbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU2hhZGVyKSB7XG4gICAgICAgICAgICBEZWJ1Zy5kZXByZWNhdGVkKCdwYy5CYXNpY01hdGVyaWFsLnVwZGF0ZVNoYWRlciBpcyBkZXByZWNhdGVkJyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNoYWRlcihkZXZpY2UsIHNjZW5lLCBvYmpEZWZzLCBzdGF0aWNMaWdodExpc3QsIHBhc3MsIHNvcnRlZExpZ2h0cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkZXI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgc2tpbjogb2JqRGVmcyAmJiAob2JqRGVmcyAmIFNIQURFUkRFRl9TS0lOKSAhPT0gMCxcbiAgICAgICAgICAgIHNjcmVlblNwYWNlOiBvYmpEZWZzICYmIChvYmpEZWZzICYgU0hBREVSREVGX1NDUkVFTlNQQUNFKSAhPT0gMCxcbiAgICAgICAgICAgIHVzZUluc3RhbmNpbmc6IG9iakRlZnMgJiYgKG9iakRlZnMgJiBTSEFERVJERUZfSU5TVEFOQ0lORykgIT09IDAsXG4gICAgICAgICAgICB1c2VNb3JwaFBvc2l0aW9uOiBvYmpEZWZzICYmIChvYmpEZWZzICYgU0hBREVSREVGX01PUlBIX1BPU0lUSU9OKSAhPT0gMCxcbiAgICAgICAgICAgIHVzZU1vcnBoTm9ybWFsOiBvYmpEZWZzICYmIChvYmpEZWZzICYgU0hBREVSREVGX01PUlBIX05PUk1BTCkgIT09IDAsXG4gICAgICAgICAgICB1c2VNb3JwaFRleHR1cmVCYXNlZDogb2JqRGVmcyAmJiAob2JqRGVmcyAmIFNIQURFUkRFRl9NT1JQSF9URVhUVVJFX0JBU0VEKSAhPT0gMCxcblxuICAgICAgICAgICAgYWxwaGFUZXN0OiB0aGlzLmFscGhhVGVzdCA+IDAsXG4gICAgICAgICAgICB2ZXJ0ZXhDb2xvcnM6IHRoaXMudmVydGV4Q29sb3JzLFxuICAgICAgICAgICAgZGlmZnVzZU1hcDogISF0aGlzLmNvbG9yTWFwLFxuICAgICAgICAgICAgcGFzczogcGFzc1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NpbmdPcHRpb25zID0gbmV3IFNoYWRlclByb2Nlc3Nvck9wdGlvbnModmlld1VuaWZvcm1Gb3JtYXQsIHZpZXdCaW5kR3JvdXBGb3JtYXQsIHZlcnRleEZvcm1hdCk7XG5cbiAgICAgICAgY29uc3QgbGlicmFyeSA9IGdldFByb2dyYW1MaWJyYXJ5KGRldmljZSk7XG4gICAgICAgIGxpYnJhcnkucmVnaXN0ZXIoJ2Jhc2ljJywgYmFzaWMpO1xuXG4gICAgICAgIHJldHVybiBsaWJyYXJ5LmdldFByb2dyYW0oJ2Jhc2ljJywgb3B0aW9ucywgcHJvY2Vzc2luZ09wdGlvbnMpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQmFzaWNNYXRlcmlhbCB9O1xuIl0sIm5hbWVzIjpbIkJhc2ljTWF0ZXJpYWwiLCJNYXRlcmlhbCIsImNvbnN0cnVjdG9yIiwiY29sb3IiLCJDb2xvciIsImNvbG9yVW5pZm9ybSIsIkZsb2F0MzJBcnJheSIsImNvbG9yTWFwIiwidmVydGV4Q29sb3JzIiwiY29weSIsInNvdXJjZSIsInVwZGF0ZVVuaWZvcm1zIiwiZGV2aWNlIiwic2NlbmUiLCJjbGVhclBhcmFtZXRlcnMiLCJyIiwiZyIsImIiLCJhIiwic2V0UGFyYW1ldGVyIiwiZ2V0U2hhZGVyVmFyaWFudCIsIm9iakRlZnMiLCJzdGF0aWNMaWdodExpc3QiLCJwYXNzIiwic29ydGVkTGlnaHRzIiwidmlld1VuaWZvcm1Gb3JtYXQiLCJ2aWV3QmluZEdyb3VwRm9ybWF0IiwidmVydGV4Rm9ybWF0IiwidXBkYXRlU2hhZGVyIiwiRGVidWciLCJkZXByZWNhdGVkIiwic2hhZGVyIiwib3B0aW9ucyIsInNraW4iLCJTSEFERVJERUZfU0tJTiIsInNjcmVlblNwYWNlIiwiU0hBREVSREVGX1NDUkVFTlNQQUNFIiwidXNlSW5zdGFuY2luZyIsIlNIQURFUkRFRl9JTlNUQU5DSU5HIiwidXNlTW9ycGhQb3NpdGlvbiIsIlNIQURFUkRFRl9NT1JQSF9QT1NJVElPTiIsInVzZU1vcnBoTm9ybWFsIiwiU0hBREVSREVGX01PUlBIX05PUk1BTCIsInVzZU1vcnBoVGV4dHVyZUJhc2VkIiwiU0hBREVSREVGX01PUlBIX1RFWFRVUkVfQkFTRUQiLCJhbHBoYVRlc3QiLCJkaWZmdXNlTWFwIiwicHJvY2Vzc2luZ09wdGlvbnMiLCJTaGFkZXJQcm9jZXNzb3JPcHRpb25zIiwibGlicmFyeSIsImdldFByb2dyYW1MaWJyYXJ5IiwicmVnaXN0ZXIiLCJiYXNpYyIsImdldFByb2dyYW0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQSxhQUFhLFNBQVNDLFFBQVEsQ0FBQztBQUNqQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lDLEVBQUFBLFdBQVdBLEdBQUc7QUFDVixJQUFBLEtBQUssRUFBRSxDQUFBOztBQUVQO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDUSxJQUFBLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUlD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
