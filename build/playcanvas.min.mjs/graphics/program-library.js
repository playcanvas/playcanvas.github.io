import"../core/tracing.js";import{version as e,revision as t}from"../core/core.js";import{Shader as s}from"./shader.js";import{SHADER_FORWARD as i,SHADER_SHADOW as r,SHADER_DEPTH as n,SHADER_PICK as a}from"../scene/constants.js";import{StandardMaterial as o}from"../scene/materials/standard-material.js";import{ShaderPass as c}from"../scene/shader-pass.js";class h{constructor(e){this.processedCache=new Map,this._device=e,this._cache={},this._generators={},this._isClearingCache=!1,this._precached=!1,this._programsCollection=[],this._defaultStdMatOption={},this._defaultStdMatOptionMin={};const t=new o;t.shaderOptBuilder.updateRef(this._defaultStdMatOption,{},t,null,[],i,null),t.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin,{},t,null,[],r,null)}register(e,t){this.isRegistered(e)||(this._generators[e]=t)}unregister(e){this.isRegistered(e)&&delete this._generators[e]}isRegistered(e){return void 0!==this._generators[e]}generateShader(e,t,i,r){let n=this._cache[i];if(!n){let a;r.lights&&(a=r.lights,r.lights=a.map((function(e){const t=e.clone?e.clone():e;return t.key=e.key,t}))),this.storeNewProgram(t,r),r.lights&&(r.lights=a),this._precached;const o=this._device,c=e.createShaderDefinition(o,r);c.name=`${t}-pass:${r.pass}`,n=this._cache[i]=new s(o,c)}return n}getProgram(e,t,i){const r=this._generators[e];if(!r)return null;const n=r.generateKey(t),a=`${n}#${JSON.stringify(i)}`;let o=this.processedCache.get(a);if(!o){const c=this.generateShader(r,e,n,t).definition,h={attributes:c.attributes,vshader:c.vshader,fshader:c.fshader,processingOptions:i};o=new s(this._device,h),this.processedCache.set(a,o)}return o}storeNewProgram(e,t){let s={};if("standard"===e){const e=this._getDefaultStdMatOptions(t.pass);for(const i in t)(t.hasOwnProperty(i)&&e[i]!==t[i]||"pass"===i)&&(s[i]=t[i])}else s=t;this._programsCollection.push(JSON.stringify({name:e,options:s}))}dumpPrograms(){let s="let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n";s+="let shaders = [",this._programsCollection[0]&&(s+="\n\t"+this._programsCollection[0]);for(let e=1;e<this._programsCollection.length;++e)s+=",\n\t"+this._programsCollection[e];s+="\n];\n",s+="device.programLib.precompile(shaders);\n",s+='if (pc.version != "'+e+'" || pc.revision != "'+t+'")\n',s+='\tconsole.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");';const i=document.createElement("a");i.setAttribute("href","data:text/plain;charset=utf-8,"+encodeURIComponent(s)),i.setAttribute("download","precompile-shaders.js"),i.style.display="none",document.body.appendChild(i),i.click(),document.body.removeChild(i)}clearCache(){const e=this._cache;this._isClearingCache=!0;for(const t in e)e.hasOwnProperty(t)&&e[t].destroy();this._cache={},this._isClearingCache=!1}removeFromCache(e){if(this._isClearingCache)return;const t=this._cache;for(const s in t)if(t.hasOwnProperty(s)&&t[s]===e){delete t[s];break}}_getDefaultStdMatOptions(e){return e===n||e===a||c.isShadow(e)?this._defaultStdMatOptionMin:this._defaultStdMatOption}precompile(e){if(e){const t=new Array(e.length);for(let s=0;s<e.length;s++){if("standard"===e[s].name){const t=e[s].options,i=this._getDefaultStdMatOptions(t.pass);for(const e in i)i.hasOwnProperty(e)&&void 0===t[e]&&(t[e]=i[e])}t[s]=this.getProgram(e[s].name,e[s].options)}}this._precached=!0}}export{h as ProgramLibrary};
