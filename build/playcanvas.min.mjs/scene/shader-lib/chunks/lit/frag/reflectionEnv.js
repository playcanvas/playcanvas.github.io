var t="\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform float material_reflectivity;\n\n// calculate mip level for shiny reflection given equirect coords uv.\nfloat shinyMipLevel(vec2 uv) {\n\t\tvec2 dx = dFdx(uv);\n\t\tvec2 dy = dFdy(uv);\n\n\t\t// calculate second dF at 180 degrees\n\t\tvec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\n\t\tvec2 dx2 = dFdx(uv2);\n\t\tvec2 dy2 = dFdy(uv2);\n\n\t\t// calculate min of both sets of dF to handle discontinuity at the azim edge\n\t\tfloat maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\n\n\t\treturn clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);\n}\n\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\t\tvec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);\n\t\tvec2 uv = toSphericalUv(dir);\n\n\t\t// calculate roughness level\n\t\tfloat level = saturate(1.0 - gloss) * 5.0;\n\t\tfloat ilevel = floor(level);\n\n\t\t// accessing the shiny (top level) reflection - perform manual mipmap lookup\n\t\tfloat level2 = shinyMipLevel(uv * atlasSize);\n\t\tfloat ilevel2 = floor(level2);\n\n\t\tvec2 uv0, uv1;\n\t\tfloat weight;\n\t\tif (ilevel == 0.0) {\n\t\t\t\tuv0 = mapShinyUv(uv, ilevel2);\n\t\t\t\tuv1 = mapShinyUv(uv, ilevel2 + 1.0);\n\t\t\t\tweight = level2 - ilevel2;\n\t\t} else {\n\t\t\t\t// accessing rough reflection - just sample the same part twice\n\t\t\t\tuv0 = uv1 = mapRoughnessUv(uv, ilevel);\n\t\t\t\tweight = 0.0;\n\t\t}\n\n\t\tvec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));\n\t\tvec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));\n\t\tvec3 linear0 = mix(linearA, linearB, weight);\n\t\tvec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\n\t\treturn processEnvironment(mix(linear0, linear1, level - ilevel));\n}\n\nvoid addReflection(vec3 reflDir, float gloss) {   \n\t\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";export{t as default};
