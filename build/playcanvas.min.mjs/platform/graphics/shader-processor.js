import"../../core/tracing.js";import{uniformTypeToName as t,UNIFORM_BUFFER_DEFAULT_SLOT_NAME as e,SHADERSTAGE_VERTEX as s,SHADERSTAGE_FRAGMENT as r,BINDGROUP_MESH as n,semanticToLocation as a,TYPE_FLOAT32 as o,TEXTUREDIMENSION_2D as i,TEXTUREDIMENSION_3D as c,TEXTUREDIMENSION_CUBE as u,TEXTUREDIMENSION_2D_ARRAY as p,SAMPLETYPE_FLOAT as m,SAMPLETYPE_UNFILTERABLE_FLOAT as h,SAMPLETYPE_DEPTH as l,TYPE_INT8 as f,TYPE_INT16 as d,TYPE_INT32 as b}from"./constants.js";import{UniformFormat as g,UniformBufferFormat as y}from"./uniform-buffer-format.js";import{BindBufferFormat as w,BindTextureFormat as x,BindGroupFormat as S}from"./bind-group-format.js";const $=/[ \t]*(\battribute\b|\bvarying\b|\buniform\b)/g,v=/(\battribute\b|\bvarying\b|\bout\b|\buniform\b)[ \t]*([^;]+)([;]+)/g,D="@@@",E=/([\w-]+)\[(.*?)\]/,O=new Set(["highp","mediump","lowp"]),T=new Set(["sampler2DShadow","samplerCubeShadow"]),F={sampler2D:i,sampler3D:c,samplerCube:u,samplerCubeShadow:u,sampler2DShadow:i,sampler2DArray:p,sampler2DArrayShadow:p};class B{constructor(t,e){this.line=t;const s=t.trim().split(/\s+/);if(O.has(s[0])&&(this.precision=s.shift()),this.type=s.shift(),t.includes(","),t.includes("[")){const t=s.join(" "),r=E.exec(t);this.name=r[1],this.arraySize=Number(r[2]),isNaN(this.arraySize)&&(e.failed=!0)}else this.name=s.shift(),this.arraySize=0;this.isSampler=-1!==this.type.indexOf("sampler")}}class U{static run(t,e,s){const r=new Map,n=U.extract(e.vshader),a=U.extract(e.fshader),o=U.processAttributes(n.attributes,e.attributes,e.processingOptions),i=U.processVaryings(n.varyings,r,!0),c=U.processVaryings(a.varyings,r,!1),u=U.processOuts(a.outs),p=n.uniforms.concat(a.uniforms),m=Array.from(new Set(p)).map((t=>new B(t,s))),h=U.processUniforms(t,m,e.processingOptions,s),l=o+"\n"+i+"\n"+h.code,f=n.src.replace(D,l),d=c+"\n"+u+"\n"+h.code;return{vshader:f,fshader:a.src.replace(D,d),meshUniformBufferFormat:h.meshUniformBufferFormat,meshBindGroupFormat:h.meshBindGroupFormat}}static extract(t){const e=[],s=[],r=[],n=[];let a,o=`${D}\n`;for(;null!==(a=$.exec(t));){const i=a[1];switch(i){case"attribute":case"varying":case"uniform":case"out":{v.lastIndex=a.index;const c=v.exec(t);"attribute"===i?e.push(c[2]):"varying"===i?s.push(c[2]):"out"===i?r.push(c[2]):"uniform"===i&&n.push(c[2]),t=U.cutOut(t,a.index,v.lastIndex,o),$.lastIndex=a.index+o.length,o="";break}}}return{src:t,attributes:e,varyings:s,outs:r,uniforms:n}}static processUniforms(a,o,i,c){const u=[],p=[];o.forEach((t=>{t.isSampler?u.push(t):p.push(t)}));const f=[];p.forEach((e=>{if(!i.hasUniform(e.name)){const s=t.indexOf(e.type),r=new g(e.name,s,e.arraySize);f.push(r)}}));const d=f.length?new y(a,f):null,b=[];d&&b.push(new w(e,s|r));const $=[];u.forEach((t=>{if(!i.hasTexture(t.name)){let e=m;"highp"===t.precision&&(e=h),T.has(t.type)&&(e=l);const n=F[t.type];$.push(new x(t.name,s|r,n,e))}}));const v=new S(a,b,$);let D="";return i.uniformFormats.forEach(((t,e)=>{t&&(D+=t.getShaderDeclaration(e,0))})),d&&(D+=d.getShaderDeclaration(n,0)),i.bindGroupFormats.forEach(((t,e)=>{t&&(D+=t.getShaderDeclarationTextures(e))})),D+=v.getShaderDeclarationTextures(n),{code:D,meshUniformBufferFormat:d,meshBindGroupFormat:v}}static processVaryings(t,e,s){let r="";const n=s?"out":"in";return t.forEach(((t,a)=>{const o=U.splitToWords(t),i=o[0],c=o[1];s?e.set(c,a):a=e.get(c),r+=`layout(location = ${a}) ${n} ${i} ${c};\n`})),r}static processOuts(t){let e="";return t.forEach(((t,s)=>{e+=`layout(location = ${s}) out ${t};\n`})),e}static getTypeCount(t){const e=t.substring(t.length-1),s=parseInt(e,10);return isNaN(s)?1:s}static processAttributes(t,e,s){let r="";const n={};return t.forEach((t=>{const i=U.splitToWords(t);let c=i[0],u=i[1];if(e.hasOwnProperty(u)){const t=e[u],i=a[t];let p;n[i]=t;const m=s.getVertexElement(t);if(m){const t=m.dataType;if(t!==o){const e=U.getTypeCount(c),s=`_private_${u}`;p=`vec${e} ${u} = vec${e}(${s});\n`,u=s;const r=t===f||t===d||t===b;c=1===e?r?"int":"uint":r?`ivec${e}`:`uvec${e}`}}r+=`layout(location = ${i}) in ${c} ${u};\n`,p&&(r+=p)}})),r}static splitToWords(t){return(t=t.replace(/\s+/g," ").trim()).split(" ")}static cutOut(t,e,s,r){return t.substring(0,e)+r+t.substring(s)}}export{U as ShaderProcessor};
