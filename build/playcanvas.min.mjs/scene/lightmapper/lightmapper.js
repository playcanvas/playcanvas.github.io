import{now as e}from"../../core/time.js";import"../../core/tracing.js";import{math as t}from"../../core/math/math.js";import{Color as s}from"../../core/math/color.js";import{Vec3 as r}from"../../core/math/vec3.js";import{BoundingBox as a}from"../../core/shape/bounding-box.js";import{PIXELFORMAT_R8_G8_B8_A8 as i,TEXTURETYPE_RGBM as n,CHUNKAPI_1_55 as h,CULLFACE_NONE as o,FILTER_NEAREST as l,ADDRESS_CLAMP_TO_EDGE as c,FILTER_LINEAR as m,TEXTURETYPE_DEFAULT as d}from"../../platform/graphics/constants.js";import{shaderChunks as p}from"../shader-lib/chunks/chunks.js";import{shaderChunksLightmapper as g}from"../shader-lib/chunks/chunks-lightmapper.js";import{drawQuadWithShader as u}from"../../platform/graphics/simple-post-effect.js";import{RenderTarget as f}from"../../platform/graphics/render-target.js";import{Texture as b}from"../../platform/graphics/texture.js";import{MeshInstance as w}from"../mesh-instance.js";import{LightingParams as k}from"../lighting/lighting-params.js";import{WorldClusters as T}from"../lighting/world-clusters.js";import{PROJECTION_ORTHOGRAPHIC as S,MASK_AFFECT_LIGHTMAPPED as M,BAKE_COLORDIR as L,MASK_BAKE as _,LIGHTTYPE_DIRECTIONAL as x,SHADOWUPDATE_REALTIME as C,SHADOWUPDATE_THISFRAME as B,FOG_NONE as y,LIGHTTYPE_SPOT as P,PROJECTION_PERSPECTIVE as A,LIGHTTYPE_OMNI as j,SHADER_FORWARDHDR as v,SHADERDEF_LM as R,SHADERDEF_DIRLM as E,SHADERDEF_LMAMBIENT as F}from"../constants.js";import{Camera as D}from"../camera.js";import{GraphNode as z}from"../graph-node.js";import{StandardMaterial as I}from"../materials/standard-material.js";import{BakeLightSimple as O}from"./bake-light-simple.js";import{BakeLightAmbient as N}from"./bake-light-ambient.js";import{BakeMeshNode as V}from"./bake-mesh-node.js";import{LightmapCache as U}from"./lightmap-cache.js";import{LightmapFilters as $}from"./lightmap-filters.js";const q=new r;class W{constructor(e,t,r,a,i){this.device=e,this.root=t,this.scene=r,this.renderer=a,this.assets=i,this.shadowMapCache=a._shadowRenderer.shadowMapCache,this._tempSet=new Set,this._initCalled=!1,this.passMaterials=[],this.ambientAOMaterial=null,this.fog="",this.ambientLight=new s,this.renderTargets=new Map,this.stats={renderPasses:0,lightmapCount:0,totalRenderTime:0,forwardTime:0,fboTime:0,shadowMapTime:0,compileTime:0,shadersLinked:0}}destroy(){U.decRef(this.blackTex),this.blackTex=null,U.destroy(),this.device=null,this.root=null,this.scene=null,this.renderer=null,this.assets=null}initBake(e){if(!this._initCalled){this._initCalled=!0,this.lightmapFilters=new $(e),this.constantBakeDir=e.scope.resolve("bakeDir"),this.materials=[],this.blackTex=new b(this.device,{width:4,height:4,format:i,type:n,name:"lightmapBlack"}),U.incRef(this.blackTex);const t=new D;t.clearColor.set(0,0,0,0),t.clearColorBuffer=!0,t.clearDepthBuffer=!1,t.clearStencilBuffer=!1,t.frustumCulling=!1,t.projection=S,t.aspectRatio=1,t.node=new z,this.camera=t}if(this.scene.clusteredLightingEnabled){const t=new k(e.supportsAreaLights,e.maxTextureSize,(()=>{}));this.lightingParams=t;const s=this.scene.lighting;t.shadowsEnabled=s.shadowsEnabled,t.shadowAtlasResolution=s.shadowAtlasResolution,t.cookiesEnabled=s.cookiesEnabled,t.cookieAtlasResolution=s.cookieAtlasResolution,t.areaLightsEnabled=s.areaLightsEnabled,t.cells=new r(3,3,3),t.maxLightsPerCell=4,this.worldClusters=new T(e),this.worldClusters.name="ClusterLightmapper"}}finishBake(e){function t(e){U.decRef(e.colorBuffer),e.destroy()}this.materials=[],this.renderTargets.forEach((e=>{t(e)})),this.renderTargets.clear(),e.forEach((e=>{e.renderTargets.forEach((e=>{t(e)})),e.renderTargets.length=0})),this.ambientAOMaterial=null,this.worldClusters&&(this.worldClusters.destroy(),this.worldClusters=null)}createMaterialForPass(e,t,r,a){const i=new I;if(i.name=`lmMaterial-pass:${r}-ambient:${a}`,i.chunks.APIVersion=h,i.chunks.transformVS="#define UV1LAYOUT\n"+p.transformVS,0===r){let e=g.bakeLmEndPS;a?e=`\n                    dDiffuseLight = ((dDiffuseLight - 0.5) * max(${t.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;\n                    dDiffuseLight += vec3(${t.ambientBakeOcclusionBrightness.toFixed(1)});\n                    dDiffuseLight = saturate(dDiffuseLight);\n                    dDiffuseLight *= dAmbientLight;\n                `+e:(i.ambient=new s(0,0,0),i.ambientTint=!0),i.chunks.endPS=e,i.lightMap=this.blackTex}else i.chunks.basePS=p.basePS+"\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n",i.chunks.endPS=g.bakeDirLmEndPS;return i.chunks.outputAlphaPS="\n",i.chunks.outputAlphaOpaquePS="\n",i.chunks.outputAlphaPremulPS="\n",i.cull=o,i.forceUv1=!0,i.update(),i}createMaterials(e,t,s){for(let r=0;r<s;r++)this.passMaterials[r]||(this.passMaterials[r]=this.createMaterialForPass(e,t,r,!1));this.ambientAOMaterial||(this.ambientAOMaterial=this.createMaterialForPass(e,t,0,!0),this.ambientAOMaterial.onUpdateShader=function(e){return e.lightMapWithoutAmbient=!0,e.separateAmbient=!0,e})}createTexture(e,t,s){return new b(this.device,{width:e,height:e,format:i,mipmaps:!1,type:t,minFilter:l,magFilter:l,addressU:c,addressV:c,name:s})}collectModels(e,t,s){var r,a,i;if(!e.enabled)return;let n;if(null!=(r=e.model)&&r.model&&null!=(a=e.model)&&a.enabled&&(s&&s.push(new V(e)),e.model.lightmapped&&t&&(n=e.model.model.meshInstances)),null!=(i=e.render)&&i.enabled&&(s&&s.push(new V(e)),e.render.lightmapped&&t&&(n=e.render.meshInstances)),n){let s=!0;for(let e=0;e<n.length;e++)if(!n[e].mesh.vertexBuffer.format.hasUv1){s=!1;break}if(s){const s=[];for(let r=0;r<n.length;r++){const a=n[r].mesh;this._tempSet.has(a)?t.push(new V(e,[n[r]])):s.push(n[r]),this._tempSet.add(a)}this._tempSet.clear(),s.length>0&&t.push(new V(e,s))}}for(let r=0;r<e._children.length;r++)this.collectModels(e._children[r],t,s)}prepareShadowCasters(e){const t=[];for(let s=0;s<e.length;s++){const r=e[s].component;if(r.castShadows=r.castShadowsLightmap,r.castShadowsLightmap){const r=e[s].meshInstances;for(let e=0;e<r.length;e++)r[e].visibleThisFrame=!0,t.push(r[e])}}return t}updateTransforms(e){for(let t=0;t<e.length;t++){const s=e[t].meshInstances;for(let e=0;e<s.length;e++)s[e].node.getWorldTransform()}}calculateLightmapSize(e){let s;const r=this.scene.lightmapSizeMultiplier||16,a=q;let i,n;e.model?(n=e.model.lightmapSizeMultiplier,e.model.asset?(s=this.assets.get(e.model.asset).data,s.area&&(i=s.area)):e.model._area&&(s=e.model,s._area&&(i=s._area))):e.render&&(n=e.render.lightmapSizeMultiplier,"asset"!==e.render.type&&e.render._area&&(s=e.render,s._area&&(i=s._area)));const h={x:1,y:1,z:1,uv:1};i&&(h.x=i.x,h.y=i.y,h.z=i.z,h.uv=i.uv);const o=n||1;h.x*=o,h.y*=o,h.z*=o;const l=e.render||e.model,c=this.computeNodeBounds(l.meshInstances);a.copy(c.halfExtents);let m=h.x*a.y*a.z+h.y*a.x*a.z+h.z*a.x*a.y;m/=h.uv,m=Math.sqrt(m);return Math.min(t.nextPowerOfTwo(m*r),this.scene.lightmapMaxResolution||2048)}setLightmapping(e,t,s,r){for(let a=0;a<e.length;a++){const i=e[a],n=i.meshInstances;for(let e=0;e<n.length;e++){const a=n[e];if(a.setLightmapped(t),t){r&&(a._shaderDefs|=r),a.mask=M;for(let e=0;e<s;e++){const t=i.renderTargets[e].colorBuffer;t.minFilter=m,t.magFilter=m,a.setRealtimeLightmap(w.lightmapParamNames[e],t)}}}}}bake(t,s=L){const r=this.device,a=e();this.scene._updateSky(r),this.stats.renderPasses=0,this.stats.shadowMapTime=0,this.stats.forwardTime=0;const i=r._shaderStats.linked,n=r._renderTargetCreationTime,h=r._shaderStats.compileTime,o=[],l=[];if(t){for(let e=0;e<t.length;e++)this.collectModels(t[e],o,null);this.collectModels(this.root,null,l)}else this.collectModels(this.root,o,l);if(o.length>0){const e=s===L?2:1;this.setLightmapping(o,!1,e),this.initBake(r),this.bakeInternal(e,o,l);let t=R;s===L&&(t|=E),this.scene.ambientBake&&(t|=F),this.setLightmapping(o,!0,e,t),this.finishBake(o)}const c=e();this.stats.totalRenderTime=c-a,this.stats.shadersLinked=r._shaderStats.linked-i,this.stats.compileTime=r._shaderStats.compileTime-h,this.stats.fboTime=r._renderTargetCreationTime-n,this.stats.lightmapCount=o.length}allocateTextures(e,t){for(let s=0;s<e.length;s++){const r=e[s],a=this.calculateLightmapSize(r.node);for(let e=0;e<t;e++){const t=this.createTexture(a,d,"lightmapper_lightmap_"+s);U.incRef(t),r.renderTargets[e]=new f({colorBuffer:t,depth:!1})}if(!this.renderTargets.has(a)){const e=this.createTexture(a,d,"lightmapper_temp_lightmap_"+a);U.incRef(e),this.renderTargets.set(a,new f({colorBuffer:e,depth:!1}))}}}prepareLightsToBake(e,t,s){if(this.scene.ambientBake){const e=new N(this.scene);s.push(e)}const r=e._lights;for(let e=0;e<r.length;e++){const a=r[e],i=new O(this.scene,a);t.push(i),a.enabled&&0!=(a.mask&_)&&(a.isStatic=!1,a.mask=4294967295,a.shadowUpdateMode=a.type===x?C:B,s.push(i))}s.sort()}restoreLights(e){for(let t=0;t<e.length;t++)e[t].restore()}setupScene(){this.revertStatic=!1,this.scene._needsStaticPrepare&&(this.scene._needsStaticPrepare=!1,this.revertStatic=!0),this.fog=this.scene.fog,this.ambientLight.copy(this.scene.ambientLight),this.scene.fog=y,this.scene.ambientBake||this.scene.ambientLight.set(0,0,0),this.renderer.setSceneConstants()}restoreScene(){this.scene.fog=this.fog,this.scene.ambientLight.copy(this.ambientLight),this.revertStatic&&(this.scene._needsStaticPrepare=!0)}computeNodeBounds(e){const t=new a;if(e.length>0){t.copy(e[0].aabb);for(let s=1;s<e.length;s++)t.add(e[s].aabb)}return t}computeNodesBounds(e){for(let t=0;t<e.length;t++){const s=e[t].meshInstances;e[t].bounds=this.computeNodeBounds(s)}}computeBounds(e){const t=new a;for(let s=0;s<e.length;s++){t.copy(e[0].aabb);for(let s=1;s<e.length;s++)t.add(e[s].aabb)}return t}backupMaterials(e){for(let t=0;t<e.length;t++)this.materials[t]=e[t].material}restoreMaterials(e){for(let t=0;t<e.length;t++)e[t].material=this.materials[t]}lightCameraPrepare(e,t){const s=t.light;let r;if(s.type===P){r=s.getRenderData(null,0).shadowCamera,r._node.setPosition(s._node.getPosition()),r._node.setRotation(s._node.getRotation()),r._node.rotateLocal(-90,0,0),r.projection=A,r.nearClip=s.attenuationEnd/1e3,r.farClip=s.attenuationEnd,r.aspectRatio=1,r.fov=2*s._outerConeAngle,this.renderer.updateCameraFrustum(r)}return r}lightCameraPrepareAndCull(e,t,s,r){const a=e.light;let i=!0;if(a.type===x){q.copy(r.center),q.y+=r.halfExtents.y,this.camera.node.setPosition(q),this.camera.node.setEulerAngles(-90,0,0),this.camera.nearClip=0,this.camera.farClip=2*r.halfExtents.y;const e=Math.max(r.halfExtents.x,r.halfExtents.z);this.camera.orthoHeight=e}else e.lightBounds.intersects(t.bounds)||(i=!1);if(a.type===P){let e=!1;const r=t.meshInstances;for(let t=0;t<r.length;t++)if(r[t]._isVisible(s)){e=!0;break}e||(i=!1)}return i}setupLightArray(e,t){e[x].length=0,e[j].length=0,e[P].length=0,e[t.type][0]=t,t.visibleThisFrame=!0}renderShadowMap(e,t,s,r){const a=r.light;return!e&&a.castShadows&&(a.shadowMap||this.scene.clusteredLightingEnabled||(a.shadowMap=this.shadowMapCache.get(this.device,a)),a.type===x?this.renderer._shadowRenderer.cullDirectional(a,t,this.camera):this.renderer._shadowRenderer.cullLocal(a,t),this.renderer.renderShadows(s[a.type],this.camera)),!0}postprocessTextures(e,t,s){const r=this.lightmapFilters.shaderDilate,a=this.scene.lightmapFilterEnabled;a&&this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange,this.scene.lightmapFilterSmoothness);for(let i=0;i<t.length;i++){const n=t[i];for(let t=0;t<s;t++){const s=n.renderTargets[t],i=s.colorBuffer,h=this.renderTargets.get(i.width),o=h.colorBuffer;this.lightmapFilters.prepare(i.width,i.height);for(let n=0;n<1;n++){this.lightmapFilters.setSourceTexture(i);u(e,h,a&&0===t&&0===n?this.lightmapFilters.shaderDenoise:r),this.lightmapFilters.setSourceTexture(o),u(e,s,r)}}}}bakeInternal(e,t,s){const r=this.scene,a=this.device,i=r.clusteredLightingEnabled;this.createMaterials(a,r,e),this.setupScene(),r.layers._update(),this.computeNodesBounds(t),this.allocateTextures(t,e);const n=[],h=[];this.prepareLightsToBake(r.layers,n,h),this.updateTransforms(s);const o=this.prepareShadowCasters(s);this.renderer.updateCpuSkinMatrices(o),this.renderer.gpuUpdate(o);const l=this.computeBounds(o);let c,m,d,p;for(c=0;c<t.length;c++){for(d=t[c].meshInstances,m=0;m<d.length;m++)p=d[m],p.setLightmapped(!1),p.mask=_,p.setRealtimeLightmap(w.lightmapParamNames[0],p.material.lightMap?p.material.lightMap:this.blackTex),p.setRealtimeLightmap(w.lightmapParamNames[1],this.blackTex)}for(m=0;m<h.length;m++)h[m].light.enabled=!1;const g=[[],[],[]];let u,f,b=!1;for(c=0;c<h.length;c++){const s=h[c],n=s instanceof N;let k=s.numVirtualLights;e>1&&k>1&&s.light.bakeDir&&(k=1);for(let h=0;h<k;h++){k>1&&s.prepareVirtualLight(h,k),s.startBake();let c=!1;const T=this.lightCameraPrepare(a,s);for(f=0;f<t.length;f++){const S=t[f];d=S.meshInstances;if(this.lightCameraPrepareAndCull(s,S,T,l)){if(this.setupLightArray(g,s.light),i&&this.renderer.lightTextureAtlas.update(g[P],g[j],this.lightingParams),c=this.renderShadowMap(c,o,g,s),i){const e=g[P].concat(g[j]);this.worldClusters.update(e,this.scene.gammaCorrection,this.lightingParams)}for(this.backupMaterials(d),u=0;u<e&&!(u>0&&h>0)&&!(n&&u>0);u++){const e=S.renderTargets[u],t=S.renderTargets[u].colorBuffer.width,o=this.renderTargets.get(t),l=o.colorBuffer;0===u?b=r.updateShaders:b&&(r.updateShaders=!0);let c=this.passMaterials[u];if(n){h+1===k&&0===u&&(c=this.ambientAOMaterial)}for(m=0;m<d.length;m++)d[m].material=c;for(this.renderer.updateShaders(d),this.renderer.setCamera(this.camera,o,!0),1===u&&this.constantBakeDir.setValue(s.light.bakeDir?1:0),i&&this.worldClusters.activate(this.renderer.lightTextureAtlas),this.renderer._forwardTime=0,this.renderer._shadowMapTime=0,this.renderer.renderForward(this.camera,d,d.length,g,v),a.updateEnd(),S.renderTargets[u]=o,this.renderTargets.set(t,e),m=0;m<d.length;m++)p=d[m],p.setRealtimeLightmap(w.lightmapParamNames[u],l),p._shaderDefs|=R}this.restoreMaterials(d)}}s.endBake(this.shadowMapCache)}}for(this.postprocessTextures(a,t,e),f=0;f<s.length;f++)s[f].restore();this.restoreLights(n),this.restoreScene(),i||this.shadowMapCache.clear()}}export{W as Lightmapper};
