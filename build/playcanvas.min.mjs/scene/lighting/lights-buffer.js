import{Vec3 as t}from"../../core/math/vec3.js";import{ADDRESS_CLAMP_TO_EDGE as e,TEXTURETYPE_DEFAULT as i,FILTER_NEAREST as s,PIXELFORMAT_RGBA8 as a,PIXELFORMAT_RGBA32F as o}from"../../platform/graphics/constants.js";import{FloatPacking as h}from"../../core/math/float-packing.js";import{MASK_AFFECT_DYNAMIC as l,MASK_AFFECT_LIGHTMAPPED as T,LIGHTTYPE_SPOT as r,LIGHTSHAPE_PUNCTUAL as _}from"../constants.js";import{Texture as n}from"../../platform/graphics/texture.js";import{LightCamera as A}from"../renderer/light-camera.js";const g=new t,d=new Float32Array(6),O=new t(-.5,0,0),u=new t(0,0,.5),x={FLAGS:0,COLOR_A:1,COLOR_B:2,SPOT_ANGLES:3,SHADOW_BIAS:4,COOKIE_A:5,COOKIE_B:6,COUNT_ALWAYS:7,POSITION_X:7,POSITION_Y:8,POSITION_Z:9,RANGE:10,SPOT_DIRECTION_X:11,SPOT_DIRECTION_Y:12,SPOT_DIRECTION_Z:13,PROJ_MAT_00:14,ATLAS_VIEWPORT_A:14,PROJ_MAT_01:15,ATLAS_VIEWPORT_B:15,PROJ_MAT_02:16,PROJ_MAT_03:17,PROJ_MAT_10:18,PROJ_MAT_11:19,PROJ_MAT_12:20,PROJ_MAT_13:21,PROJ_MAT_20:22,PROJ_MAT_21:23,PROJ_MAT_22:24,PROJ_MAT_23:25,PROJ_MAT_30:26,PROJ_MAT_31:27,PROJ_MAT_32:28,PROJ_MAT_33:29,AREA_DATA_WIDTH_X:30,AREA_DATA_WIDTH_Y:31,AREA_DATA_WIDTH_Z:32,AREA_DATA_HEIGHT_X:33,AREA_DATA_HEIGHT_Y:34,AREA_DATA_HEIGHT_Z:35,COUNT:36},I={POSITION_RANGE:0,SPOT_DIRECTION:1,PROJ_MAT_0:2,ATLAS_VIEWPORT:2,PROJ_MAT_1:3,PROJ_MAT_2:4,PROJ_MAT_3:5,AREA_DATA_WIDTH:6,AREA_DATA_HEIGHT:7,COUNT:8};class R{static initShaderDefines(){const t=R.lightTextureFormat===R.FORMAT_FLOAT?"FLOAT":"8BIT";R.shaderDefines=`\n\t\t\t\t\t\t\n#define CLUSTER_TEXTURE_${t}\n\t\t\t\t\t\t${R.buildShaderDefines(x,"CLUSTER_TEXTURE_8_")}\n\t\t\t\t\t\t${R.buildShaderDefines(I,"CLUSTER_TEXTURE_F_")}\n\t\t\t\t`}static buildShaderDefines(t,e){let i="";const s=R.useTexelFetch?"":".5";return Object.keys(t).forEach((a=>{i+=`\n#define ${e}${a} ${t[a]}${s}`})),i}static init(t){R.lightTextureFormat=t.extTextureFloat&&t.maxTextures>8?R.FORMAT_FLOAT:R.FORMAT_8BIT,R.useTexelFetch=t.supportsTextureFetch,R.initShaderDefines()}static createTexture(t,a,o,h,l){return new n(t,{name:l,width:a,height:o,mipmaps:!1,format:h,addressU:e,addressV:e,type:i,magFilter:s,minFilter:s,anisotropy:1})}constructor(e){this.device=e,this.cookiesEnabled=!1,this.shadowsEnabled=!1,this.areaLightsEnabled=!1,this.maxLights=255;let i=x.COUNT_ALWAYS,s=0;R.lightTextureFormat===R.FORMAT_FLOAT?s=I.COUNT:i=x.COUNT,this.lights8=new Uint8ClampedArray(4*i*this.maxLights),this.lightsTexture8=R.createTexture(this.device,i,this.maxLights,a,"LightsTexture8"),this._lightsTexture8Id=this.device.scope.resolve("lightsTexture8"),s?(this.lightsFloat=new Float32Array(4*s*this.maxLights),this.lightsTextureFloat=R.createTexture(this.device,s,this.maxLights,o,"LightsTextureFloat"),this._lightsTextureFloatId=this.device.scope.resolve("lightsTextureFloat")):(this.lightsFloat=null,this.lightsTextureFloat=null,this._lightsTextureFloatId=void 0),this._lightsTextureInvSizeId=this.device.scope.resolve("lightsTextureInvSize"),this._lightsTextureInvSizeData=new Float32Array(4),this._lightsTextureInvSizeData[0]=s?1/this.lightsTextureFloat.width:0,this._lightsTextureInvSizeData[1]=s?1/this.lightsTextureFloat.height:0,this._lightsTextureInvSizeData[2]=1/this.lightsTexture8.width,this._lightsTextureInvSizeData[3]=1/this.lightsTexture8.height,this.invMaxColorValue=0,this.invMaxAttenuation=0,this.boundsMin=new t,this.boundsDelta=new t}destroy(){this.lightsTexture8&&(this.lightsTexture8.destroy(),this.lightsTexture8=null),this.lightsTextureFloat&&(this.lightsTextureFloat.destroy(),this.lightsTextureFloat=null)}setCompressionRanges(t,e){this.invMaxColorValue=1/e,this.invMaxAttenuation=1/t}setBounds(t,e){this.boundsMin.copy(t),this.boundsDelta.copy(e)}uploadTextures(){this.lightsTextureFloat&&(this.lightsTextureFloat.lock().set(this.lightsFloat),this.lightsTextureFloat.unlock()),this.lightsTexture8.lock().set(this.lights8),this.lightsTexture8.unlock()}updateUniforms(){this._lightsTexture8Id.setValue(this.lightsTexture8),R.lightTextureFormat===R.FORMAT_FLOAT&&this._lightsTextureFloatId.setValue(this.lightsTextureFloat),this._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData)}getSpotDirection(t,e){e._node.getWorldTransform().getY(t).mulScalar(-1),t.normalize()}getLightAreaSizes(t){const e=t._node.getWorldTransform();return e.transformVector(O,g),d[0]=g.x,d[1]=g.y,d[2]=g.z,e.transformVector(u,g),d[3]=g.x,d[4]=g.y,d[5]=g.z,d}addLightDataFlags(t,e,i,s,a,o){t[e+0]=s?255:0,t[e+1]=64*i._shape,t[e+2]=255*i._falloffMode,t[e+3]=a?255*o:0}addLightDataColor(t,e,i,s,a){const o=this.invMaxColorValue,r=s?i._linearFinalColor:i._finalColor;h.float2Bytes(r[0]*o,t,e+0,2),h.float2Bytes(r[1]*o,t,e+2,2),h.float2Bytes(r[2]*o,t,e+4,2),t[e+6]=a?255:0;const _=!!(i.mask&l),n=!!(i.mask&T);t[e+7]=_&&n?127:n?255:0}addLightDataSpotAngles(t,e,i){h.float2Bytes(.499999*i._innerConeAngleCos+.5,t,e+0,2),h.float2Bytes(.499999*i._outerConeAngleCos+.5,t,e+2,2)}addLightDataShadowBias(t,e,i){const s=i.getRenderData(null,0),a=i._getUniformBiasValues(s);h.float2BytesRange(a.bias,t,e,-1,20,2),h.float2Bytes(a.normalBias,t,e+2,2)}addLightDataPositionRange(t,e,i,s){const a=g.sub2(s,this.boundsMin).div(this.boundsDelta);h.float2Bytes(a.x,t,e+0,4),h.float2Bytes(a.y,t,e+4,4),h.float2Bytes(a.z,t,e+8,4),h.float2Bytes(i.attenuationEnd*this.invMaxAttenuation,t,e+12,4)}addLightDataSpotDirection(t,e,i){this.getSpotDirection(g,i),h.float2Bytes(.499999*g.x+.5,t,e+0,4),h.float2Bytes(.499999*g.y+.5,t,e+4,4),h.float2Bytes(.499999*g.z+.5,t,e+8,4)}addLightDataLightProjMatrix(t,e,i){const s=i.data;for(let i=0;i<12;i++)h.float2BytesRange(s[i],t,e+4*i,-2,2,4);for(let i=12;i<16;i++)h.float2MantissaExponent(s[i],t,e+4*i,4)}addLightDataCookies(t,e,i){const s="rgb"===i._cookieChannel;if(t[e+0]=Math.floor(255*i.cookieIntensity),t[e+1]=s?255:0,!s){const s=i._cookieChannel;t[e+4]="rrr"===s?255:0,t[e+5]="ggg"===s?255:0,t[e+6]="bbb"===s?255:0,t[e+7]="aaa"===s?255:0}}addLightAtlasViewport(t,e,i){h.float2Bytes(i.x,t,e+0,2),h.float2Bytes(i.y,t,e+2,2),h.float2Bytes(i.z/3,t,e+4,2)}addLightAreaSizes(t,e,i){const s=this.getLightAreaSizes(i);for(let i=0;i<6;i++)h.float2MantissaExponent(s[i],t,e+4*i,4)}addLightData(t,e,i){const s=t._type===r,a=t.atlasViewportAllocated,o=this.cookiesEnabled&&!!t._cookie&&a,h=this.areaLightsEnabled&&t.shape!==_,l=this.shadowsEnabled&&t.castShadows&&a,T=t._node.getPosition();let n=null,d=null;if(s)if(l){n=t.getRenderData(null,0).shadowMatrix}else o&&(n=A.evalSpotCookieMatrix(t));else(l||o)&&(d=t.atlasViewport);const O=this.lights8,u=e*this.lightsTexture8.width*4;if(this.addLightDataFlags(O,u+4*x.FLAGS,t,s,l,t.shadowIntensity),this.addLightDataColor(O,u+4*x.COLOR_A,t,i,o),s&&this.addLightDataSpotAngles(O,u+4*x.SPOT_ANGLES,t),t.castShadows&&this.addLightDataShadowBias(O,u+4*x.SHADOW_BIAS,t),o&&this.addLightDataCookies(O,u+4*x.COOKIE_A,t),R.lightTextureFormat===R.FORMAT_FLOAT){const i=this.lightsFloat,a=e*this.lightsTextureFloat.width*4;if(i[a+4*I.POSITION_RANGE+0]=T.x,i[a+4*I.POSITION_RANGE+1]=T.y,i[a+4*I.POSITION_RANGE+2]=T.z,i[a+4*I.POSITION_RANGE+3]=t.attenuationEnd,s&&(this.getSpotDirection(g,t),i[a+4*I.SPOT_DIRECTION+0]=g.x,i[a+4*I.SPOT_DIRECTION+1]=g.y,i[a+4*I.SPOT_DIRECTION+2]=g.z),n){const t=n.data;for(let e=0;e<16;e++)i[a+4*I.PROJ_MAT_0+e]=t[e]}if(d&&(i[a+4*I.ATLAS_VIEWPORT+0]=d.x,i[a+4*I.ATLAS_VIEWPORT+1]=d.y,i[a+4*I.ATLAS_VIEWPORT+2]=d.z/3),h){const e=this.getLightAreaSizes(t);i[a+4*I.AREA_DATA_WIDTH+0]=e[0],i[a+4*I.AREA_DATA_WIDTH+1]=e[1],i[a+4*I.AREA_DATA_WIDTH+2]=e[2],i[a+4*I.AREA_DATA_HEIGHT+0]=e[3],i[a+4*I.AREA_DATA_HEIGHT+1]=e[4],i[a+4*I.AREA_DATA_HEIGHT+2]=e[5]}}else this.addLightDataPositionRange(O,u+4*x.POSITION_X,t,T),s&&this.addLightDataSpotDirection(O,u+4*x.SPOT_DIRECTION_X,t),n&&this.addLightDataLightProjMatrix(O,u+4*x.PROJ_MAT_00,n),d&&this.addLightAtlasViewport(O,u+4*x.ATLAS_VIEWPORT_A,d),h&&this.addLightAreaSizes(O,u+4*x.AREA_DATA_WIDTH_X,t)}}R.FORMAT_FLOAT=0,R.FORMAT_8BIT=1,R.lightTextureFormat=R.FORMAT_8BIT,R.useTexelFetch=!1,R.shaderDefines="";export{R as LightsBuffer};
