import"../../../core/tracing.js";import{AnimTrack as t}from"../evaluator/anim-track.js";import{AnimBlendTree1D as i}from"./anim-blend-tree-1d.js";import{AnimBlendTreeCartesian2D as n}from"./anim-blend-tree-2d-cartesian.js";import{AnimBlendTreeDirectional2D as e}from"./anim-blend-tree-2d-directional.js";import{AnimBlendTreeDirect as a}from"./anim-blend-tree-direct.js";import{AnimNode as s}from"./anim-node.js";import{ANIM_BLEND_DIRECT as r,ANIM_BLEND_2D_DIRECTIONAL as o,ANIM_BLEND_2D_CARTESIAN as m,ANIM_BLEND_1D as h,ANIM_CONTROL_STATES as l}from"./constants.js";class d{constructor(t,i,n=1,e=!0,a){this._animations={},this._animationList=[],this._controller=t,this._name=i,this._speed=n,this._loop=e,this._hasAnimations=!1;const r=this._controller.findParameter.bind(this._controller);this._blendTree=a?this._createTree(a.type,this,null,i,1,a.parameter?[a.parameter]:a.parameters,a.children,a.syncAnimations,this._createTree,r):new s(this,null,i,1,n)}_createTree(t,s,l,d,c,_,u,p,g,f){switch(t){case h:return new i(s,l,d,c,_,u,p,g,f);case m:return new n(s,l,d,c,_,u,p,g,f);case o:return new e(s,l,d,c,_,u,p,g,f);case r:return new a(s,l,d,c,_,u,p,g,f)}}_getNodeFromPath(t){let i=this._blendTree;for(let n=1;n<t.length;n++)i=i.getChild(t[n]);return i}addAnimation(t,i){const n=t.join("."),e=this._animationList.findIndex((function(t){return t.path===n}));if(e>=0)this._animationList[e].animTrack=i;else{const n=this._getNodeFromPath(t);n.animTrack=i,this._animationList.push(n)}this._updateHasAnimations()}_updateHasAnimations(){this._hasAnimations=this._animationList.length>0&&this._animationList.every((i=>i.animTrack&&i.animTrack!==t.EMPTY))}get name(){return this._name}set animations(t){this._animationList=t,this._updateHasAnimations()}get animations(){return this._animationList}get hasAnimations(){return this._hasAnimations}set speed(t){this._speed=t}get speed(){return this._speed}set loop(t){this._loop=t}get loop(){return this._loop}get nodeCount(){return this._blendTree&&this._blendTree.constructor!==s?this._blendTree.getNodeCount():1}get playable(){return-1!==l.indexOf(this.name)||this.animations.length===this.nodeCount}get looping(){if(this.animations.length>0){const t=this.name+"."+this.animations[0].animTrack.name,i=this._controller.animEvaluator.findClip(t);if(i)return i.loop}return!1}get totalWeight(){let t=0;for(let i=0;i<this.animations.length;i++)t+=this.animations[i].weight;return t}get timelineDuration(){let t=0;for(let i=0;i<this.animations.length;i++){const n=this.animations[i];n.animTrack.duration>t&&(t=n.animTrack.duration)}return t}}export{d as AnimState};
