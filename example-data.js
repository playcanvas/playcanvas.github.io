const exampleData = {"animation":{"blend-trees-1d":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data: any): void {\n\n    const assets = {\n        'model': new pc.Asset('model', 'container', { url: '/static/assets/models/bitmoji.glb' }),\n        'idleAnim': new pc.Asset('idleAnim', 'container', { url: '/static/assets/animations/bitmoji/idle.glb' }),\n        'danceAnim': new pc.Asset('danceAnim', 'container', { url: '/static/assets/animations/bitmoji/win-dance.glb' }),\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'bloom': new pc.Asset('bloom', 'script', { url: '/static/scripts/posteffects/posteffect-bloom.js' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.AnimComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.AnimClipHandler,\n            // @ts-ignore\n            pc.AnimStateGraphHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // setup skydome\n            app.scene.exposure = 2;\n            app.scene.skyboxMip = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1)\n            });\n            cameraEntity.translate(0, 0.75, 3);\n\n            // add bloom postprocessing (this is ignored by the picker)\n            cameraEntity.addComponent(\"script\");\n            cameraEntity.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1,\n                    bloomThreshold: 0.7,\n                    blurAmount: 4\n                }\n            });\n            app.root.addChild(cameraEntity);\n\n            // Create an entity with a light component\n            const lightEntity = new pc.Entity();\n            lightEntity.addComponent(\"light\", {\n                castShadows: true,\n                intensity: 1.5,\n                normalOffsetBias: 0.02,\n                shadowType: pc.SHADOW_PCF5,\n                shadowDistance: 6,\n                shadowResolution: 2048,\n                shadowBias: 0.02\n            });\n            app.root.addChild(lightEntity);\n            lightEntity.setLocalEulerAngles(45, 30, 0);\n\n            // create an entity from the loaded model using the render component\n            const modelEntity = assets.model.resource.instantiateRenderEntity({\n                castShadows: true\n            });\n\n            // add an anim component to the entity\n            modelEntity.addComponent('anim', {\n                activate: true\n            });\n\n            // create an anim state graph\n            const animStateGraphData = {\n                \"layers\": [\n                    {\n                        \"name\": \"characterState\",\n                        \"states\": [\n                            {\n                                \"name\": \"START\"\n                            },\n                            {\n                                \"name\": \"Movement\",\n                                \"speed\": 1.0,\n                                \"loop\": true,\n                                \"blendTree\": {\n                                    \"type\": \"1D\",\n                                    \"parameter\": \"blend\",\n                                    \"children\": [\n                                        {\n                                            \"name\": \"Idle\",\n                                            \"point\": 0.0\n                                        },\n                                        {\n                                            \"name\": \"Dance\",\n                                            \"point\": 1.0,\n                                            \"speed\": 0.85\n                                        }\n                                    ]\n                                }\n                            }\n                        ],\n                        \"transitions\": [\n                            {\n                                \"from\": \"START\",\n                                \"to\": \"Movement\"\n                            }\n                        ]\n                    }\n                ],\n                \"parameters\": {\n                    \"blend\": {\n                        \"name\": \"blend\",\n                        \"type\": \"FLOAT\",\n                        \"value\": 0\n                    }\n                }\n            };\n\n            // load the state graph into the anim component\n            modelEntity.anim.loadStateGraph(animStateGraphData);\n\n            // load the state graph asset resource into the anim component\n            const characterStateLayer = modelEntity.anim.baseLayer;\n            characterStateLayer.assignAnimation('Movement.Idle', assets.idleAnim.resource.animations[0].resource);\n            characterStateLayer.assignAnimation('Movement.Dance', assets.danceAnim.resource.animations[0].resource);\n\n            app.root.addChild(modelEntity);\n\n            data.on('blend:set', (blend: number) => {\n                modelEntity.anim.setFloat('blend', blend);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    const assets = {\n        model: new pc.Asset(\"model\", \"container\", {\n            url: \"/static/assets/models/bitmoji.glb\",\n        }),\n        idleAnim: new pc.Asset(\"idleAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/idle.glb\",\n        }),\n        danceAnim: new pc.Asset(\"danceAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/win-dance.glb\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        bloom: new pc.Asset(\"bloom\", \"script\", {\n            url: \"/static/scripts/posteffects/posteffect-bloom.js\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.AnimComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.AnimClipHandler,\n            // @ts-ignore\n            pc.AnimStateGraphHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // setup skydome\n            app.scene.exposure = 2;\n            app.scene.skyboxMip = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1),\n            });\n\n            cameraEntity.translate(0, 0.75, 3);\n\n            // add bloom postprocessing (this is ignored by the picker)\n            cameraEntity.addComponent(\"script\");\n            cameraEntity.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1,\n                    bloomThreshold: 0.7,\n                    blurAmount: 4,\n                },\n            });\n\n            app.root.addChild(cameraEntity);\n\n            // Create an entity with a light component\n            const lightEntity = new pc.Entity();\n            lightEntity.addComponent(\"light\", {\n                castShadows: true,\n                intensity: 1.5,\n                normalOffsetBias: 0.02,\n                shadowType: pc.SHADOW_PCF5,\n                shadowDistance: 6,\n                shadowResolution: 2048,\n                shadowBias: 0.02,\n            });\n\n            app.root.addChild(lightEntity);\n            lightEntity.setLocalEulerAngles(45, 30, 0);\n\n            // create an entity from the loaded model using the render component\n            const modelEntity = assets.model.resource.instantiateRenderEntity({\n                castShadows: true,\n            });\n\n            // add an anim component to the entity\n            modelEntity.addComponent(\"anim\", {\n                activate: true,\n            });\n\n            // create an anim state graph\n            const animStateGraphData = {\n                layers: [\n                    {\n                        name: \"characterState\",\n                        states: [\n                            {\n                                name: \"START\",\n                            },\n\n                            {\n                                name: \"Movement\",\n                                speed: 1.0,\n                                loop: true,\n                                blendTree: {\n                                    type: \"1D\",\n                                    parameter: \"blend\",\n                                    children: [\n                                        {\n                                            name: \"Idle\",\n                                            point: 0.0,\n                                        },\n\n                                        {\n                                            name: \"Dance\",\n                                            point: 1.0,\n                                            speed: 0.85,\n                                        },\n                                    ],\n                                },\n                            },\n                        ],\n\n                        transitions: [\n                            {\n                                from: \"START\",\n                                to: \"Movement\",\n                            },\n                        ],\n                    },\n                ],\n\n                parameters: {\n                    blend: {\n                        name: \"blend\",\n                        type: \"FLOAT\",\n                        value: 0,\n                    },\n                },\n            };\n\n            // load the state graph into the anim component\n            modelEntity.anim.loadStateGraph(animStateGraphData);\n\n            // load the state graph asset resource into the anim component\n            const characterStateLayer = modelEntity.anim.baseLayer;\n            characterStateLayer.assignAnimation(\n                \"Movement.Idle\",\n                assets.idleAnim.resource.animations[0].resource\n            );\n            characterStateLayer.assignAnimation(\n                \"Movement.Dance\",\n                assets.danceAnim.resource.animations[0].resource\n            );\n\n            app.root.addChild(modelEntity);\n\n            data.on(\"blend:set\", (blend) => {\n                modelEntity.anim.setFloat(\"blend\", blend);\n            });\n        });\n    });\n}\n","nameSlug":"blend-trees-1d","categorySlug":"animation"},"blend-trees-2d-cartesian":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'model': new pc.Asset('model', 'container', { url: '/static/assets/models/bitmoji.glb' }),\n        'idleAnim': new pc.Asset('idleAnim', 'container', { url: '/static/assets/animations/bitmoji/idle.glb' }),\n        'walkAnim': new pc.Asset('idleAnim', 'container', { url: '/static/assets/animations/bitmoji/walk.glb' }),\n        'eagerAnim': new pc.Asset('idleAnim', 'container', { url: '/static/assets/animations/bitmoji/idle-eager.glb' }),\n        'danceAnim': new pc.Asset('danceAnim', 'container', { url: '/static/assets/animations/bitmoji/win-dance.glb' }),\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'bloom': new pc.Asset('bloom', 'script', { url: '/static/scripts/posteffects/posteffect-bloom.js' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.AnimComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.AnimClipHandler,\n            // @ts-ignore\n            pc.AnimStateGraphHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            // setup skydome\n            app.scene.exposure = 2;\n            app.scene.skyboxMip = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1)\n            });\n            cameraEntity.translate(0, 0.75, 3);\n            // add bloom postprocessing (this is ignored by the picker)\n            cameraEntity.addComponent(\"script\");\n            cameraEntity.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1,\n                    bloomThreshold: 0.7,\n                    blurAmount: 4\n                }\n            });\n            app.root.addChild(cameraEntity);\n\n            // Create an entity with a light component\n            const lightEntity = new pc.Entity();\n            lightEntity.addComponent(\"light\", {\n                castShadows: true,\n                intensity: 1.5,\n                normalOffsetBias: 0.02,\n                shadowType: pc.SHADOW_PCF5,\n                shadowDistance: 6,\n                shadowResolution: 2048,\n                shadowBias: 0.02\n            });\n            app.root.addChild(lightEntity);\n            lightEntity.setLocalEulerAngles(45, 30, 0);\n\n            // create an entity from the loaded model using the render component\n            const modelEntity = assets.model.resource.instantiateRenderEntity({\n                castShadows: true\n            });\n            modelEntity.name = 'model';\n\n            // add an anim component to the entity\n            modelEntity.addComponent('anim', {\n                activate: true\n            });\n\n            // create an anim state graph\n            const animStateGraphData = {\n                \"layers\": [\n                    {\n                        \"name\": \"base\",\n                        \"states\": [\n                            {\n                                \"name\": \"START\"\n                            },\n                            {\n                                \"name\": \"Emote\",\n                                \"speed\": 1.0,\n                                \"loop\": true,\n                                \"blendTree\": {\n                                    \"type\": pc.ANIM_BLEND_2D_CARTESIAN,\n                                    \"parameters\": [\"posX\", \"posY\"],\n                                    \"children\": [\n                                        {\n                                            \"name\": \"Idle\",\n                                            \"point\": [-0.5, 0.5]\n                                        },\n                                        {\n                                            \"name\": \"Eager\",\n                                            \"point\": [0.5, 0.5]\n                                        },\n                                        {\n                                            \"name\": \"Walk\",\n                                            \"point\": [0.5, -0.5]\n                                        },\n                                        {\n                                            \"name\": \"Dance\",\n                                            \"point\": [-0.5, -0.5]\n                                        }\n                                    ]\n                                }\n                            }\n                        ],\n                        \"transitions\": [\n                            {\n                                \"from\": \"START\",\n                                \"to\": \"Emote\"\n                            }\n                        ]\n                    }\n                ],\n                \"parameters\": {\n                    \"posX\": {\n                        \"name\": \"posX\",\n                        \"type\": \"FLOAT\",\n                        \"value\": -0.5\n                    },\n                    \"posY\": {\n                        \"name\": \"posY\",\n                        \"type\": \"FLOAT\",\n                        \"value\": 0.5\n                    }\n                }\n            };\n\n            // load the state graph into the anim component\n            modelEntity.anim.loadStateGraph(animStateGraphData);\n\n            // load the state graph asset resource into the anim component\n            const characterStateLayer = modelEntity.anim.baseLayer;\n            characterStateLayer.assignAnimation('Emote.Idle', assets.idleAnim.resource.animations[0].resource);\n            characterStateLayer.assignAnimation('Emote.Eager', assets.eagerAnim.resource.animations[0].resource);\n            characterStateLayer.assignAnimation('Emote.Dance', assets.danceAnim.resource.animations[0].resource);\n            characterStateLayer.assignAnimation('Emote.Walk', assets.walkAnim.resource.animations[0].resource);\n\n            app.root.addChild(modelEntity);\n\n            app.start();\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        model: new pc.Asset(\"model\", \"container\", {\n            url: \"/static/assets/models/bitmoji.glb\",\n        }),\n        idleAnim: new pc.Asset(\"idleAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/idle.glb\",\n        }),\n        walkAnim: new pc.Asset(\"idleAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/walk.glb\",\n        }),\n        eagerAnim: new pc.Asset(\"idleAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/idle-eager.glb\",\n        }),\n        danceAnim: new pc.Asset(\"danceAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/win-dance.glb\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        bloom: new pc.Asset(\"bloom\", \"script\", {\n            url: \"/static/scripts/posteffects/posteffect-bloom.js\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.AnimComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.AnimClipHandler,\n            // @ts-ignore\n            pc.AnimStateGraphHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            // setup skydome\n            app.scene.exposure = 2;\n            app.scene.skyboxMip = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1),\n            });\n\n            cameraEntity.translate(0, 0.75, 3);\n            // add bloom postprocessing (this is ignored by the picker)\n            cameraEntity.addComponent(\"script\");\n            cameraEntity.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1,\n                    bloomThreshold: 0.7,\n                    blurAmount: 4,\n                },\n            });\n\n            app.root.addChild(cameraEntity);\n\n            // Create an entity with a light component\n            const lightEntity = new pc.Entity();\n            lightEntity.addComponent(\"light\", {\n                castShadows: true,\n                intensity: 1.5,\n                normalOffsetBias: 0.02,\n                shadowType: pc.SHADOW_PCF5,\n                shadowDistance: 6,\n                shadowResolution: 2048,\n                shadowBias: 0.02,\n            });\n\n            app.root.addChild(lightEntity);\n            lightEntity.setLocalEulerAngles(45, 30, 0);\n\n            // create an entity from the loaded model using the render component\n            const modelEntity = assets.model.resource.instantiateRenderEntity({\n                castShadows: true,\n            });\n\n            modelEntity.name = \"model\";\n\n            // add an anim component to the entity\n            modelEntity.addComponent(\"anim\", {\n                activate: true,\n            });\n\n            // create an anim state graph\n            const animStateGraphData = {\n                layers: [\n                    {\n                        name: \"base\",\n                        states: [\n                            {\n                                name: \"START\",\n                            },\n\n                            {\n                                name: \"Emote\",\n                                speed: 1.0,\n                                loop: true,\n                                blendTree: {\n                                    type: pc.ANIM_BLEND_2D_CARTESIAN,\n                                    parameters: [\"posX\", \"posY\"],\n                                    children: [\n                                        {\n                                            name: \"Idle\",\n                                            point: [-0.5, 0.5],\n                                        },\n\n                                        {\n                                            name: \"Eager\",\n                                            point: [0.5, 0.5],\n                                        },\n\n                                        {\n                                            name: \"Walk\",\n                                            point: [0.5, -0.5],\n                                        },\n\n                                        {\n                                            name: \"Dance\",\n                                            point: [-0.5, -0.5],\n                                        },\n                                    ],\n                                },\n                            },\n                        ],\n\n                        transitions: [\n                            {\n                                from: \"START\",\n                                to: \"Emote\",\n                            },\n                        ],\n                    },\n                ],\n\n                parameters: {\n                    posX: {\n                        name: \"posX\",\n                        type: \"FLOAT\",\n                        value: -0.5,\n                    },\n\n                    posY: {\n                        name: \"posY\",\n                        type: \"FLOAT\",\n                        value: 0.5,\n                    },\n                },\n            };\n\n            // load the state graph into the anim component\n            modelEntity.anim.loadStateGraph(animStateGraphData);\n\n            // load the state graph asset resource into the anim component\n            const characterStateLayer = modelEntity.anim.baseLayer;\n            characterStateLayer.assignAnimation(\n                \"Emote.Idle\",\n                assets.idleAnim.resource.animations[0].resource\n            );\n            characterStateLayer.assignAnimation(\n                \"Emote.Eager\",\n                assets.eagerAnim.resource.animations[0].resource\n            );\n            characterStateLayer.assignAnimation(\n                \"Emote.Dance\",\n                assets.danceAnim.resource.animations[0].resource\n            );\n            characterStateLayer.assignAnimation(\n                \"Emote.Walk\",\n                assets.walkAnim.resource.animations[0].resource\n            );\n\n            app.root.addChild(modelEntity);\n\n            app.start();\n        });\n    });\n}\n","nameSlug":"blend-trees-2d-cartesian","categorySlug":"animation"},"blend-trees-2d-directional":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'model': new pc.Asset('model', 'container', { url: '/static/assets/models/bitmoji.glb' }),\n        'idleAnim': new pc.Asset('idleAnim', 'container', { url: '/static/assets/animations/bitmoji/idle.glb' }),\n        'walkAnim': new pc.Asset('idleAnim', 'container', { url: '/static/assets/animations/bitmoji/walk.glb' }),\n        'jogAnim': new pc.Asset('idleAnim', 'container', { url: '/static/assets/animations/bitmoji/run.glb' }),\n        'danceAnim': new pc.Asset('danceAnim', 'container', { url: '/static/assets/animations/bitmoji/win-dance.glb' }),\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'bloom': new pc.Asset('bloom', 'script', { url: '/static/scripts/posteffects/posteffect-bloom.js' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.AnimComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.AnimClipHandler,\n            // @ts-ignore\n            pc.AnimStateGraphHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n            // setup skydome\n            app.scene.exposure = 2;\n            app.scene.skyboxMip = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1)\n            });\n            cameraEntity.translate(0, 0.75, 3);\n            // add bloom postprocessing (this is ignored by the picker)\n            cameraEntity.addComponent(\"script\");\n            cameraEntity.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1,\n                    bloomThreshold: 0.7,\n                    blurAmount: 4\n                }\n            });\n            app.root.addChild(cameraEntity);\n\n            // Create an entity with a light component\n            const lightEntity = new pc.Entity();\n            lightEntity.addComponent(\"light\", {\n                castShadows: true,\n                intensity: 1.5,\n                normalOffsetBias: 0.02,\n                shadowType: pc.SHADOW_PCF5,\n                shadowDistance: 6,\n                shadowResolution: 2048,\n                shadowBias: 0.02\n            });\n            app.root.addChild(lightEntity);\n            lightEntity.setLocalEulerAngles(45, 30, 0);\n\n            // create an entity from the loaded model using the render component\n            const modelEntity = assets.model.resource.instantiateRenderEntity({\n                castShadows: true\n            });\n            modelEntity.name = 'model';\n\n            // add an anim component to the entity\n            modelEntity.addComponent('anim', {\n                activate: true\n            });\n\n            // create an anim state graph\n            const animStateGraphData = {\n                \"layers\": [\n                    {\n                        \"name\": \"locomotion\",\n                        \"states\": [\n                            {\n                                \"name\": \"START\"\n                            },\n                            {\n                                \"name\": \"Travel\",\n                                \"speed\": 1.0,\n                                \"loop\": true,\n                                \"blendTree\": {\n                                    \"type\": pc.ANIM_BLEND_2D_DIRECTIONAL,\n                                    \"syncDurations\": true,\n                                    \"parameters\": [\"posX\", \"posY\"],\n                                    \"children\": [\n                                        {\n                                            \"name\": \"Idle\",\n                                            \"point\": [0.0, 0.0]\n                                        },\n                                        {\n                                            \"speed\": -1,\n                                            \"name\": \"WalkBackwards\",\n                                            \"point\": [0.0, -0.5]\n                                        },\n                                        {\n                                            \"speed\": 1,\n                                            \"name\": \"Walk\",\n                                            \"point\": [0.0, 0.5]\n                                        },\n                                        {\n                                            \"speed\": 1,\n                                            \"name\": \"Jog\",\n                                            \"point\": [0.0, 1.0]\n                                        }\n                                    ]\n                                }\n                            }\n                        ],\n                        \"transitions\": [\n                            {\n                                \"from\": \"START\",\n                                \"to\": \"Travel\"\n                            }\n                        ]\n                    }\n                ],\n                \"parameters\": {\n                    \"posX\": {\n                        \"name\": \"posX\",\n                        \"type\": \"FLOAT\",\n                        \"value\": 0\n                    },\n                    \"posY\": {\n                        \"name\": \"posY\",\n                        \"type\": \"FLOAT\",\n                        \"value\": 0\n                    }\n                }\n            };\n\n            // load the state graph into the anim component\n            modelEntity.anim.loadStateGraph(animStateGraphData);\n\n            // load the state graph asset resource into the anim component\n            const locomotionLayer = modelEntity.anim.baseLayer;\n            locomotionLayer.assignAnimation('Travel.Idle', assets.idleAnim.resource.animations[0].resource);\n            locomotionLayer.assignAnimation('Travel.Walk', assets.walkAnim.resource.animations[0].resource);\n            locomotionLayer.assignAnimation('Travel.WalkBackwards', assets.walkAnim.resource.animations[0].resource);\n            locomotionLayer.assignAnimation('Travel.Jog', assets.jogAnim.resource.animations[0].resource);\n\n            app.root.addChild(modelEntity);\n\n            app.start();\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        model: new pc.Asset(\"model\", \"container\", {\n            url: \"/static/assets/models/bitmoji.glb\",\n        }),\n        idleAnim: new pc.Asset(\"idleAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/idle.glb\",\n        }),\n        walkAnim: new pc.Asset(\"idleAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/walk.glb\",\n        }),\n        jogAnim: new pc.Asset(\"idleAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/run.glb\",\n        }),\n        danceAnim: new pc.Asset(\"danceAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/win-dance.glb\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        bloom: new pc.Asset(\"bloom\", \"script\", {\n            url: \"/static/scripts/posteffects/posteffect-bloom.js\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.AnimComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.AnimClipHandler,\n            // @ts-ignore\n            pc.AnimStateGraphHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            // setup skydome\n            app.scene.exposure = 2;\n            app.scene.skyboxMip = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1),\n            });\n\n            cameraEntity.translate(0, 0.75, 3);\n            // add bloom postprocessing (this is ignored by the picker)\n            cameraEntity.addComponent(\"script\");\n            cameraEntity.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1,\n                    bloomThreshold: 0.7,\n                    blurAmount: 4,\n                },\n            });\n\n            app.root.addChild(cameraEntity);\n\n            // Create an entity with a light component\n            const lightEntity = new pc.Entity();\n            lightEntity.addComponent(\"light\", {\n                castShadows: true,\n                intensity: 1.5,\n                normalOffsetBias: 0.02,\n                shadowType: pc.SHADOW_PCF5,\n                shadowDistance: 6,\n                shadowResolution: 2048,\n                shadowBias: 0.02,\n            });\n\n            app.root.addChild(lightEntity);\n            lightEntity.setLocalEulerAngles(45, 30, 0);\n\n            // create an entity from the loaded model using the render component\n            const modelEntity = assets.model.resource.instantiateRenderEntity({\n                castShadows: true,\n            });\n\n            modelEntity.name = \"model\";\n\n            // add an anim component to the entity\n            modelEntity.addComponent(\"anim\", {\n                activate: true,\n            });\n\n            // create an anim state graph\n            const animStateGraphData = {\n                layers: [\n                    {\n                        name: \"locomotion\",\n                        states: [\n                            {\n                                name: \"START\",\n                            },\n\n                            {\n                                name: \"Travel\",\n                                speed: 1.0,\n                                loop: true,\n                                blendTree: {\n                                    type: pc.ANIM_BLEND_2D_DIRECTIONAL,\n                                    syncDurations: true,\n                                    parameters: [\"posX\", \"posY\"],\n                                    children: [\n                                        {\n                                            name: \"Idle\",\n                                            point: [0.0, 0.0],\n                                        },\n\n                                        {\n                                            speed: -1,\n                                            name: \"WalkBackwards\",\n                                            point: [0.0, -0.5],\n                                        },\n\n                                        {\n                                            speed: 1,\n                                            name: \"Walk\",\n                                            point: [0.0, 0.5],\n                                        },\n\n                                        {\n                                            speed: 1,\n                                            name: \"Jog\",\n                                            point: [0.0, 1.0],\n                                        },\n                                    ],\n                                },\n                            },\n                        ],\n\n                        transitions: [\n                            {\n                                from: \"START\",\n                                to: \"Travel\",\n                            },\n                        ],\n                    },\n                ],\n\n                parameters: {\n                    posX: {\n                        name: \"posX\",\n                        type: \"FLOAT\",\n                        value: 0,\n                    },\n\n                    posY: {\n                        name: \"posY\",\n                        type: \"FLOAT\",\n                        value: 0,\n                    },\n                },\n            };\n\n            // load the state graph into the anim component\n            modelEntity.anim.loadStateGraph(animStateGraphData);\n\n            // load the state graph asset resource into the anim component\n            const locomotionLayer = modelEntity.anim.baseLayer;\n            locomotionLayer.assignAnimation(\n                \"Travel.Idle\",\n                assets.idleAnim.resource.animations[0].resource\n            );\n            locomotionLayer.assignAnimation(\n                \"Travel.Walk\",\n                assets.walkAnim.resource.animations[0].resource\n            );\n            locomotionLayer.assignAnimation(\n                \"Travel.WalkBackwards\",\n                assets.walkAnim.resource.animations[0].resource\n            );\n            locomotionLayer.assignAnimation(\n                \"Travel.Jog\",\n                assets.jogAnim.resource.animations[0].resource\n            );\n\n            app.root.addChild(modelEntity);\n\n            app.start();\n        });\n    });\n}\n","nameSlug":"blend-trees-2d-directional","categorySlug":"animation"},"component-properties":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data: any): void {\n\n    const assets = {\n        'playcanvasGreyTexture': new pc.Asset('playcanvasGreyTexture', 'texture', { url: '/static/assets/textures/playcanvas-grey.png' })\n    };\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.AnimComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.AnimClipHandler,\n            // @ts-ignore\n            pc.AnimStateGraphHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n            // create the animation data for two static spot lights\n            const animClipStaticLightData = {\n                \"name\": \"staticLight\",\n                \"duration\": 1.0,\n                // curve keyframe inputs\n                \"inputs\": [\n                    [\n                        0.0\n                    ]\n                ],\n                // curve keyframe outputs\n                \"outputs\": [\n                    // a single RGBA color keyframe value of a green light\n                    {\n                        \"components\": 4,\n                        \"data\": [\n                            0.0, 1.0, 0.0, 1.0\n                        ]\n                    },\n                    // a single quaternion keyframe value with no rotation\n                    {\n                        \"components\": 4,\n                        \"data\": [\n                            0.0, 0.0, 0.0, 0.0\n                        ]\n                    }\n                ],\n                // the curves contained in the clip, each with the path to the property they animation, the index of\n                // their input and output keyframes and the method of interpolation to be used\n                \"curves\": [\n                    {\n                        \"path\": { entityPath: [\"lights\", \"spotLight1\"], component: \"light\", propertyPath: [\"color\"] },\n                        \"inputIndex\": 0,\n                        \"outputIndex\": 0,\n                        \"interpolation\": 1\n                    },\n                    {\n                        \"path\": { entityPath: [\"lights\", \"spotLight2\"], component: \"light\", propertyPath: [\"color\"] },\n                        \"inputIndex\": 0,\n                        \"outputIndex\": 0,\n                        \"interpolation\": 1\n                    },\n                    {\n                        \"path\": { entityPath: [\"lights\", \"spotLight1\"], component: \"entity\", propertyPath: [\"localEulerAngles\"] },\n                        \"inputIndex\": 0,\n                        \"outputIndex\": 1,\n                        \"interpolation\": 1\n                    },\n                    {\n                        \"path\": { entityPath: [\"lights\", \"spotLight2\"], component: \"entity\", propertyPath: [\"localEulerAngles\"] },\n                        \"inputIndex\": 0,\n                        \"outputIndex\": 1,\n                        \"interpolation\": 1\n                    }\n                ]\n            };\n\n            // create the animation data for two flashing spot lights\n            const animClipFlashingLightData = {\n                \"name\": \"flashingLight\",\n                \"duration\": 2.0,\n                // curve keyframe inputs\n                \"inputs\": [\n                    [\n                        0.0, 0.5, 1.0, 1.5, 2.0\n                    ],\n                    [\n                        0, 1, 2\n                    ]\n                ],\n                // curve keyframe outputs\n                \"outputs\": [\n                    //  keyframe outputs for a flashing red RGBA color\n                    {\n                        \"components\": 4,\n                        \"data\": [\n                            1.0, 0.0, 0.0, 1.0,\n                            0.4, 0.0, 0.0, 1.0,\n                            1.0, 0.0, 0.0, 1.0,\n                            0.4, 0.0, 0.0, 1.0,\n                            1.0, 0.0, 0.0, 1.0\n                        ]\n                    },\n                    //  keyframe outputs for a quaternion rotation\n                    {\n                        \"components\": 4,\n                        \"data\": [\n                            4.0, 0.0, 0.0, 0.0,\n                            4.0, 180.0, 0.0, 0.0,\n                            4.0, 0.0, 0.0, 0.0\n                        ]\n                    },\n                    //  keyframe outputs for a quaternion rotation\n                    {\n                        \"components\": 4,\n                        \"data\": [\n                            -4.0, 0.0, 0.0, 0.0,\n                            -4.0, 180.0, 0.0, 0.0,\n                            -4.0, 0.0, 0.0, 0.0\n                        ]\n                    }\n                ],\n                // the curves contained in the clip, each with the path to the property they animation, the index of\n                // their input and output keyframes and the method of interpolation to be used\n                \"curves\": [\n                    {\n                        \"path\": { entityPath: [\"lights\", \"spotLight1\"], component: \"light\", propertyPath: [\"color\"] },\n                        \"inputIndex\": 0,\n                        \"outputIndex\": 0,\n                        \"interpolation\": 1\n                    },\n                    {\n                        \"path\": { entityPath: [\"lights\", \"spotLight2\"], component: \"light\", propertyPath: [\"color\"] },\n                        \"inputIndex\": 0,\n                        \"outputIndex\": 0,\n                        \"interpolation\": 1\n                    },\n                    {\n                        \"path\": { entityPath: [\"lights\", \"spotLight1\"], component: \"entity\", propertyPath: [\"localEulerAngles\"] },\n                        \"inputIndex\": 1,\n                        \"outputIndex\": 1,\n                        \"interpolation\": 1\n                    },\n                    {\n                        \"path\": { entityPath: [\"lights\", \"spotLight2\"], component: \"entity\", propertyPath: [\"localEulerAngles\"] },\n                        \"inputIndex\": 1,\n                        \"outputIndex\": 2,\n                        \"interpolation\": 1\n                    }\n                ]\n            };\n\n            const animClipHandler = new pc.AnimClipHandler(app);\n            const animClipStaticLight = animClipHandler.open(undefined, animClipStaticLightData);\n            const animClipFlashingLight = animClipHandler.open(undefined, animClipFlashingLightData);\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.name = 'camera';\n            cameraEntity.addComponent(\"camera\", {\n                clearColor: new pc.Color(0, 0, 0.0)\n            });\n            cameraEntity.translateLocal(7, 10, 7);\n            cameraEntity.lookAt(0, 0, 0);\n\n            const boxEntity = new pc.Entity();\n            boxEntity.addComponent(\"render\", {\n                type: 'box'\n            });\n            boxEntity.name = 'model';\n            boxEntity.setPosition(0, 0.25, 0);\n            boxEntity.setLocalScale(0.5, 0.5, 0.5);\n            const material = new pc.StandardMaterial();\n            material.diffuseMap = assets.playcanvasGreyTexture.resource;\n            material.update();\n            boxEntity.render.meshInstances[0].material = material;\n\n            const planeEntity = new pc.Entity();\n            planeEntity.name = 'plane';\n            planeEntity.addComponent(\"render\", {\n                type: \"plane\"\n            });\n            planeEntity.setLocalScale(15, 1, 15);\n            planeEntity.setPosition(0, 0, 0);\n\n            // Create the animatible lights\n            const lightsEntity = new pc.Entity();\n            lightsEntity.name = 'lights';\n\n            const light1 = new pc.Entity();\n            light1.name = 'spotLight1';\n            light1.addComponent(\"light\", {\n                type: \"spot\",\n                color: new pc.Color(0.0, 0.0, 0.0, 1.0),\n                intensity: 1,\n                range: 15,\n                innerConeAngle: 5,\n                outerConeAngle: 10\n            });\n            light1.setPosition(0, 10, 0);\n\n            const light2 = new pc.Entity();\n            light2.name = 'spotLight2';\n            light2.addComponent(\"light\", {\n                type: \"spot\",\n                color: new pc.Color(0.0, 0.0, 0.0, 1.0),\n                intensity: 1,\n                range: 15,\n                innerConeAngle: 5,\n                outerConeAngle: 10\n            });\n            light2.setPosition(0, 10, 0);\n\n            // Add Entities into the scene hierarchy\n            app.root.addChild(cameraEntity);\n            lightsEntity.addChild(light1);\n            lightsEntity.addChild(light2);\n            app.root.addChild(lightsEntity);\n            app.root.addChild(boxEntity);\n            app.root.addChild(planeEntity);\n\n            // add the anim component to the lights entity\n            lightsEntity.addComponent(\"anim\", {\n                speed: 1.0,\n                activate: true\n            });\n\n            // assign animation clip asset resources to the appropriate states\n            lightsEntity.anim.assignAnimation('Static', animClipStaticLight);\n            lightsEntity.anim.assignAnimation('Flash', animClipFlashingLight);\n\n            app.start();\n\n            data.on('flash:set', () => {\n                if (lightsEntity.anim.baseLayer.activeState === 'Static') {\n                    lightsEntity.anim.baseLayer.transition('Flash', 0.5);\n                } else {\n                    lightsEntity.anim.baseLayer.transition('Static', 0.5);\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    const assets = {\n        playcanvasGreyTexture: new pc.Asset(\n            \"playcanvasGreyTexture\",\n            \"texture\",\n            { url: \"/static/assets/textures/playcanvas-grey.png\" }\n        ),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.AnimComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.AnimClipHandler,\n            // @ts-ignore\n            pc.AnimStateGraphHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            // create the animation data for two static spot lights\n            const animClipStaticLightData = {\n                name: \"staticLight\",\n                duration: 1.0,\n                // curve keyframe inputs\n                inputs: [[0.0]],\n\n                // curve keyframe outputs\n                outputs: [\n                    // a single RGBA color keyframe value of a green light\n                    {\n                        components: 4,\n                        data: [0.0, 1.0, 0.0, 1.0],\n                    },\n\n                    // a single quaternion keyframe value with no rotation\n                    {\n                        components: 4,\n                        data: [0.0, 0.0, 0.0, 0.0],\n                    },\n                ],\n\n                // the curves contained in the clip, each with the path to the property they animation, the index of\n                // their input and output keyframes and the method of interpolation to be used\n                curves: [\n                    {\n                        path: {\n                            entityPath: [\"lights\", \"spotLight1\"],\n                            component: \"light\",\n                            propertyPath: [\"color\"],\n                        },\n                        inputIndex: 0,\n                        outputIndex: 0,\n                        interpolation: 1,\n                    },\n\n                    {\n                        path: {\n                            entityPath: [\"lights\", \"spotLight2\"],\n                            component: \"light\",\n                            propertyPath: [\"color\"],\n                        },\n                        inputIndex: 0,\n                        outputIndex: 0,\n                        interpolation: 1,\n                    },\n\n                    {\n                        path: {\n                            entityPath: [\"lights\", \"spotLight1\"],\n                            component: \"entity\",\n                            propertyPath: [\"localEulerAngles\"],\n                        },\n                        inputIndex: 0,\n                        outputIndex: 1,\n                        interpolation: 1,\n                    },\n\n                    {\n                        path: {\n                            entityPath: [\"lights\", \"spotLight2\"],\n                            component: \"entity\",\n                            propertyPath: [\"localEulerAngles\"],\n                        },\n                        inputIndex: 0,\n                        outputIndex: 1,\n                        interpolation: 1,\n                    },\n                ],\n            };\n\n            // create the animation data for two flashing spot lights\n            const animClipFlashingLightData = {\n                name: \"flashingLight\",\n                duration: 2.0,\n                // curve keyframe inputs\n                inputs: [\n                    [0.0, 0.5, 1.0, 1.5, 2.0],\n\n                    [0, 1, 2],\n                ],\n\n                // curve keyframe outputs\n                outputs: [\n                    //  keyframe outputs for a flashing red RGBA color\n                    {\n                        components: 4,\n                        data: [\n                            1.0, 0.0, 0.0, 1.0, 0.4, 0.0, 0.0, 1.0, 1.0, 0.0,\n                            0.0, 1.0, 0.4, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0,\n                        ],\n                    },\n\n                    //  keyframe outputs for a quaternion rotation\n                    {\n                        components: 4,\n                        data: [\n                            4.0, 0.0, 0.0, 0.0, 4.0, 180.0, 0.0, 0.0, 4.0, 0.0,\n                            0.0, 0.0,\n                        ],\n                    },\n\n                    //  keyframe outputs for a quaternion rotation\n                    {\n                        components: 4,\n                        data: [\n                            -4.0, 0.0, 0.0, 0.0, -4.0, 180.0, 0.0, 0.0, -4.0,\n                            0.0, 0.0, 0.0,\n                        ],\n                    },\n                ],\n\n                // the curves contained in the clip, each with the path to the property they animation, the index of\n                // their input and output keyframes and the method of interpolation to be used\n                curves: [\n                    {\n                        path: {\n                            entityPath: [\"lights\", \"spotLight1\"],\n                            component: \"light\",\n                            propertyPath: [\"color\"],\n                        },\n                        inputIndex: 0,\n                        outputIndex: 0,\n                        interpolation: 1,\n                    },\n\n                    {\n                        path: {\n                            entityPath: [\"lights\", \"spotLight2\"],\n                            component: \"light\",\n                            propertyPath: [\"color\"],\n                        },\n                        inputIndex: 0,\n                        outputIndex: 0,\n                        interpolation: 1,\n                    },\n\n                    {\n                        path: {\n                            entityPath: [\"lights\", \"spotLight1\"],\n                            component: \"entity\",\n                            propertyPath: [\"localEulerAngles\"],\n                        },\n                        inputIndex: 1,\n                        outputIndex: 1,\n                        interpolation: 1,\n                    },\n\n                    {\n                        path: {\n                            entityPath: [\"lights\", \"spotLight2\"],\n                            component: \"entity\",\n                            propertyPath: [\"localEulerAngles\"],\n                        },\n                        inputIndex: 1,\n                        outputIndex: 2,\n                        interpolation: 1,\n                    },\n                ],\n            };\n\n            const animClipHandler = new pc.AnimClipHandler(app);\n            const animClipStaticLight = animClipHandler.open(\n                undefined,\n                animClipStaticLightData\n            );\n            const animClipFlashingLight = animClipHandler.open(\n                undefined,\n                animClipFlashingLightData\n            );\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.name = \"camera\";\n            cameraEntity.addComponent(\"camera\", {\n                clearColor: new pc.Color(0, 0, 0.0),\n            });\n\n            cameraEntity.translateLocal(7, 10, 7);\n            cameraEntity.lookAt(0, 0, 0);\n\n            const boxEntity = new pc.Entity();\n            boxEntity.addComponent(\"render\", {\n                type: \"box\",\n            });\n\n            boxEntity.name = \"model\";\n            boxEntity.setPosition(0, 0.25, 0);\n            boxEntity.setLocalScale(0.5, 0.5, 0.5);\n            const material = new pc.StandardMaterial();\n            material.diffuseMap = assets.playcanvasGreyTexture.resource;\n            material.update();\n            boxEntity.render.meshInstances[0].material = material;\n\n            const planeEntity = new pc.Entity();\n            planeEntity.name = \"plane\";\n            planeEntity.addComponent(\"render\", {\n                type: \"plane\",\n            });\n\n            planeEntity.setLocalScale(15, 1, 15);\n            planeEntity.setPosition(0, 0, 0);\n\n            // Create the animatible lights\n            const lightsEntity = new pc.Entity();\n            lightsEntity.name = \"lights\";\n\n            const light1 = new pc.Entity();\n            light1.name = \"spotLight1\";\n            light1.addComponent(\"light\", {\n                type: \"spot\",\n                color: new pc.Color(0.0, 0.0, 0.0, 1.0),\n                intensity: 1,\n                range: 15,\n                innerConeAngle: 5,\n                outerConeAngle: 10,\n            });\n\n            light1.setPosition(0, 10, 0);\n\n            const light2 = new pc.Entity();\n            light2.name = \"spotLight2\";\n            light2.addComponent(\"light\", {\n                type: \"spot\",\n                color: new pc.Color(0.0, 0.0, 0.0, 1.0),\n                intensity: 1,\n                range: 15,\n                innerConeAngle: 5,\n                outerConeAngle: 10,\n            });\n\n            light2.setPosition(0, 10, 0);\n\n            // Add Entities into the scene hierarchy\n            app.root.addChild(cameraEntity);\n            lightsEntity.addChild(light1);\n            lightsEntity.addChild(light2);\n            app.root.addChild(lightsEntity);\n            app.root.addChild(boxEntity);\n            app.root.addChild(planeEntity);\n\n            // add the anim component to the lights entity\n            lightsEntity.addComponent(\"anim\", {\n                speed: 1.0,\n                activate: true,\n            });\n\n            // assign animation clip asset resources to the appropriate states\n            lightsEntity.anim.assignAnimation(\"Static\", animClipStaticLight);\n            lightsEntity.anim.assignAnimation(\"Flash\", animClipFlashingLight);\n\n            app.start();\n\n            data.on(\"flash:set\", () => {\n                if (lightsEntity.anim.baseLayer.activeState === \"Static\") {\n                    lightsEntity.anim.baseLayer.transition(\"Flash\", 0.5);\n                } else {\n                    lightsEntity.anim.baseLayer.transition(\"Static\", 0.5);\n                }\n            });\n        });\n    });\n}\n","nameSlug":"component-properties","categorySlug":"animation"},"events":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'model': new pc.Asset('model', 'container', { url: '/static/assets/models/bitmoji.glb' }),\n        'walkAnim': new pc.Asset('walkAnim', 'container', { url: '/static/assets/animations/bitmoji/walk.glb' }),\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'bloom': new pc.Asset('bloom', 'script', { url: '/static/scripts/posteffects/posteffect-bloom.js' })\n    };\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.AnimComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.AnimClipHandler,\n            // @ts-ignore\n            pc.AnimStateGraphHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // setup skydome\n            app.scene.exposure = 2;\n            app.scene.skyboxMip = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxIntensity = 0.4;    // make it darker\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1)\n            });\n            cameraEntity.translate(0, 1, 0);\n\n            // add bloom postprocessing (this is ignored by the picker)\n            cameraEntity.addComponent(\"script\");\n            cameraEntity.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1,\n                    bloomThreshold: 0.7,\n                    blurAmount: 4\n                }\n            });\n            app.root.addChild(cameraEntity);\n\n            const boxes: any = {};\n            const highlightedBoxes: pc.Entity[] = [];\n\n            // create a floor made up of box models\n            for (let i = -5; i <= 5; i++) {\n                for (let j = -5; j <= 5; j++) {\n\n                    const material = new pc.StandardMaterial();\n                    material.diffuse = new pc.Color(0.7, 0.7, 0.7);\n                    material.gloss = 0.3;\n                    material.metalness = 0.2;\n                    material.useMetalness = true;\n                    material.update();\n\n                    const box = new pc.Entity();\n                    boxes[`${i}${j}`] = box;\n                    box.addComponent('render', {\n                        type: 'box',\n                        material: material\n                    });\n                    box.setPosition(i, -0.5, j);\n                    box.setLocalScale(0.95, 1, 0.95);\n                    app.root.addChild(box);\n                }\n            }\n\n            // light up a box at the given position with a random color using the emissive material property\n            const highlightBox = (pos: pc.Vec3) => {\n                const i = Math.floor(pos.x + 0.5);\n                const j = Math.floor(pos.z + 0.5);\n                const colorVec = new pc.Vec3(Math.random(), Math.random(), Math.random());\n                colorVec.mulScalar(1 / colorVec.length());\n                boxes[`${i}${j}`].render.material.emissive = new pc.Color(colorVec.x, colorVec.y, colorVec.z);\n                highlightedBoxes.push(boxes[`${i}${j}`]);\n            };\n\n            // create an entity from the loaded model using the render component\n            const modelEntity = assets.model.resource.instantiateRenderEntity({\n                castShadows: true\n            });\n\n            // add an anim component to the entity\n            modelEntity.addComponent('anim', {\n                activate: true\n            });\n            modelEntity.setLocalPosition(-3, 0, 0);\n\n            const modelEntityParent = new pc.Entity();\n            modelEntityParent.addChild(modelEntity);\n\n            app.root.addChild(modelEntityParent);\n\n            // rotate the model in a circle around the center of the scene\n            app.on('update', (dt: number) => {\n                modelEntityParent.rotate(0, 13.8 * dt, 0);\n            });\n\n            const walkTrack = assets.walkAnim.resource.animations[0].resource;\n\n            // Add two anim events to the walk animation, one for each foot step. These events should occur just as each foot touches the ground\n            walkTrack.events = new pc.AnimEvents([\n                {\n                    time: walkTrack.duration * 0.1,\n                    name: 'foot_step',\n                    bone: 'R_foot0002_bind_JNT'\n                },\n                {\n                    time: walkTrack.duration * 0.6,\n                    name: 'foot_step',\n                    bone: 'L_foot0002_bind_JNT'\n                }\n            ]);\n\n            // add the animation track to the anim component, with a defined speed\n            modelEntity.anim.assignAnimation('Walk', walkTrack, undefined, 0.62);\n\n            modelEntity.anim.on('foot_step', (event: any) => {\n                // highlight the box that is under the foot's bone position\n                highlightBox(modelEntity.findByName(event.bone).getPosition());\n            });\n\n            app.on('update', () => {\n                // on update, iterate over any currently highlighted boxes and reduce their emissive property\n                highlightedBoxes.forEach((box: pc.Entity) => {\n                    const material = box.render.material as pc.StandardMaterial;\n                    const emissive = material.emissive;\n                    emissive.lerp(emissive, pc.Color.BLACK, 0.08);\n                    material.update();\n                });\n                // remove old highlighted boxes from the update loop\n                while (highlightedBoxes.length > 5) {\n                    highlightedBoxes.shift();\n                }\n\n                // set the camera to follow the model\n                const modelPosition = modelEntity.getPosition().clone();\n                modelPosition.y = 0.5;\n                cameraEntity.lookAt(modelPosition);\n\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        model: new pc.Asset(\"model\", \"container\", {\n            url: \"/static/assets/models/bitmoji.glb\",\n        }),\n        walkAnim: new pc.Asset(\"walkAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/walk.glb\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        bloom: new pc.Asset(\"bloom\", \"script\", {\n            url: \"/static/scripts/posteffects/posteffect-bloom.js\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.AnimComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.AnimClipHandler,\n            // @ts-ignore\n            pc.AnimStateGraphHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // setup skydome\n            app.scene.exposure = 2;\n            app.scene.skyboxMip = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxIntensity = 0.4; // make it darker\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1),\n            });\n\n            cameraEntity.translate(0, 1, 0);\n\n            // add bloom postprocessing (this is ignored by the picker)\n            cameraEntity.addComponent(\"script\");\n            cameraEntity.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1,\n                    bloomThreshold: 0.7,\n                    blurAmount: 4,\n                },\n            });\n\n            app.root.addChild(cameraEntity);\n\n            const boxes = {};\n            const highlightedBoxes = [];\n\n            // create a floor made up of box models\n            for (let i = -5; i <= 5; i++) {\n                for (let j = -5; j <= 5; j++) {\n                    const material = new pc.StandardMaterial();\n                    material.diffuse = new pc.Color(0.7, 0.7, 0.7);\n                    material.gloss = 0.3;\n                    material.metalness = 0.2;\n                    material.useMetalness = true;\n                    material.update();\n\n                    const box = new pc.Entity();\n                    boxes[`${i}${j}`] = box;\n                    box.addComponent(\"render\", {\n                        type: \"box\",\n                        material: material,\n                    });\n\n                    box.setPosition(i, -0.5, j);\n                    box.setLocalScale(0.95, 1, 0.95);\n                    app.root.addChild(box);\n                }\n            }\n\n            // light up a box at the given position with a random color using the emissive material property\n            const highlightBox = (pos) => {\n                const i = Math.floor(pos.x + 0.5);\n                const j = Math.floor(pos.z + 0.5);\n                const colorVec = new pc.Vec3(\n                    Math.random(),\n                    Math.random(),\n                    Math.random()\n                );\n                colorVec.mulScalar(1 / colorVec.length());\n                boxes[`${i}${j}`].render.material.emissive = new pc.Color(\n                    colorVec.x,\n                    colorVec.y,\n                    colorVec.z\n                );\n                highlightedBoxes.push(boxes[`${i}${j}`]);\n            };\n\n            // create an entity from the loaded model using the render component\n            const modelEntity = assets.model.resource.instantiateRenderEntity({\n                castShadows: true,\n            });\n\n            // add an anim component to the entity\n            modelEntity.addComponent(\"anim\", {\n                activate: true,\n            });\n\n            modelEntity.setLocalPosition(-3, 0, 0);\n\n            const modelEntityParent = new pc.Entity();\n            modelEntityParent.addChild(modelEntity);\n\n            app.root.addChild(modelEntityParent);\n\n            // rotate the model in a circle around the center of the scene\n            app.on(\"update\", (dt) => {\n                modelEntityParent.rotate(0, 13.8 * dt, 0);\n            });\n\n            const walkTrack = assets.walkAnim.resource.animations[0].resource;\n\n            // Add two anim events to the walk animation, one for each foot step. These events should occur just as each foot touches the ground\n            walkTrack.events = new pc.AnimEvents([\n                {\n                    time: walkTrack.duration * 0.1,\n                    name: \"foot_step\",\n                    bone: \"R_foot0002_bind_JNT\",\n                },\n\n                {\n                    time: walkTrack.duration * 0.6,\n                    name: \"foot_step\",\n                    bone: \"L_foot0002_bind_JNT\",\n                },\n            ]);\n\n            // add the animation track to the anim component, with a defined speed\n            modelEntity.anim.assignAnimation(\n                \"Walk\",\n                walkTrack,\n                undefined,\n                0.62\n            );\n\n            modelEntity.anim.on(\"foot_step\", (event) => {\n                // highlight the box that is under the foot's bone position\n                highlightBox(modelEntity.findByName(event.bone).getPosition());\n            });\n\n            app.on(\"update\", () => {\n                // on update, iterate over any currently highlighted boxes and reduce their emissive property\n                highlightedBoxes.forEach((box) => {\n                    const material = box.render.material;\n                    const emissive = material.emissive;\n                    emissive.lerp(emissive, pc.Color.BLACK, 0.08);\n                    material.update();\n                });\n                // remove old highlighted boxes from the update loop\n                while (highlightedBoxes.length > 5) {\n                    highlightedBoxes.shift();\n                }\n\n                // set the camera to follow the model\n                const modelPosition = modelEntity.getPosition().clone();\n                modelPosition.y = 0.5;\n                cameraEntity.lookAt(modelPosition);\n            });\n        });\n    });\n}\n","nameSlug":"events","categorySlug":"animation"},"layer-masks":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data: any): void {\n\n    const assets = {\n        'model': new pc.Asset('model', 'container', { url: '/static/assets/models/bitmoji.glb' }),\n        'idleAnim': new pc.Asset('idleAnim', 'container', { url: '/static/assets/animations/bitmoji/idle.glb' }),\n        'idleEagerAnim': new pc.Asset('idleEagerAnim', 'container', { url: '/static/assets/animations/bitmoji/idle-eager.glb' }),\n        'walkAnim': new pc.Asset('walkAnim', 'container', { url: '/static/assets/animations/bitmoji/walk.glb' }),\n        'danceAnim': new pc.Asset('danceAnim', 'container', { url: '/static/assets/animations/bitmoji/win-dance.glb' }),\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'bloom': new pc.Asset('bloom', 'script', { url: '/static/scripts/posteffects/posteffect-bloom.js' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.AnimComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.AnimClipHandler,\n            // @ts-ignore\n            pc.AnimStateGraphHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            // setup data\n            data.set('fullBodyLayer', {\n                state: 'Idle',\n                blendType: pc.ANIM_LAYER_OVERWRITE\n            });\n            data.set('upperBodyLayer', {\n                state: 'Eager',\n                blendType: pc.ANIM_LAYER_ADDITIVE,\n                useMask: true\n            });\n            data.set('options', {\n                blend: 0.5,\n                skeleton: true\n            });\n\n            // setup skydome\n            app.scene.exposure = 2;\n            app.scene.skyboxMip = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1)\n            });\n            cameraEntity.translate(0, 0.75, 3);\n\n            // add bloom postprocessing (this is ignored by the picker)\n            cameraEntity.addComponent(\"script\");\n            cameraEntity.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1,\n                    bloomThreshold: 0.7,\n                    blurAmount: 4\n                }\n            });\n            app.root.addChild(cameraEntity);\n\n            // Create an entity with a light component\n            const lightEntity = new pc.Entity();\n            lightEntity.addComponent(\"light\", {\n                castShadows: true,\n                intensity: 1.5,\n                normalOffsetBias: 0.02,\n                shadowType: pc.SHADOW_PCF5,\n                shadowDistance: 6,\n                shadowResolution: 2048,\n                shadowBias: 0.02\n            });\n            app.root.addChild(lightEntity);\n            lightEntity.setLocalEulerAngles(45, 30, 0);\n\n            // create an entity from the loaded model using the render component\n            const modelEntity = assets.model.resource.instantiateRenderEntity({\n                castShadows: true\n            });\n            modelEntity.addComponent('anim', {\n                activate: true\n            });\n            app.root.addChild(modelEntity);\n\n            // retrieve the animation assets\n            const idleTrack = assets.idleAnim.resource.animations[0].resource;\n            const walkTrack = assets.walkAnim.resource.animations[0].resource;\n            const danceTrack = assets.danceAnim.resource.animations[0].resource;\n            const idleEagerTrack = assets.idleEagerAnim.resource.animations[0].resource;\n\n            // create the full body layer by assigning full body animations to the anim component\n            modelEntity.anim.assignAnimation('Idle', idleTrack);\n            modelEntity.anim.assignAnimation('Walk', walkTrack);\n\n            // set the default weight for the base layer\n            modelEntity.anim.baseLayer.weight = 1.0 - data.get('options.blend');\n\n            // create a mask for the upper body layer\n            const upperBodyMask = {\n                // set a path with the children property as true to include that path and all of its children in the mask\n                'RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT': {\n                    children: true\n                },\n                // set a path to true in the mask to include only that specific path\n                'RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT/C_Head': true\n            };\n\n            // create a new layer for the upper body, with additive layer blending\n            const upperBodyLayer = modelEntity.anim.addLayer('UpperBody', data.get('options.blend'), upperBodyMask, data.get('upperBodyLayer.blendType'));\n            upperBodyLayer.assignAnimation('Eager', idleEagerTrack);\n            upperBodyLayer.assignAnimation('Idle', idleTrack);\n            upperBodyLayer.assignAnimation('Dance', danceTrack);\n\n            // respond to changes in the data object made by the control panel\n            data.on('*:set', (path: string, value: any) => {\n                if (path === 'fullBodyLayer.state') {\n                    modelEntity.anim.baseLayer.transition(value, 0.4);\n                }\n                if (path === 'upperBodyLayer.state') {\n                    upperBodyLayer.transition(value, 0.4);\n                }\n                if (path === 'fullBodyLayer.blendType') {\n                    modelEntity.anim.baseLayer.blendType = value;\n                }\n                if (path === 'upperBodyLayer.blendType') {\n                    upperBodyLayer.blendType = value;\n                }\n                if (path === 'upperBodyLayer.useMask') {\n                    upperBodyLayer.mask = value ? {\n                        'RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT': {\n                            children: true\n                        }\n                    } : null;\n                }\n                if (path === 'options.blend') {\n                    modelEntity.anim.baseLayer.weight = 1.0 - value;\n                    upperBodyLayer.weight = value;\n                }\n            });\n\n            const drawSkeleton = (entity: pc.Entity, color: pc.Color) => {\n                entity.children.forEach((c: pc.Entity) => {\n                    const target = modelEntity.anim._targets[entity.path + '/graph/localPosition'];\n                    if (target) {\n                        app.drawLine(entity.getPosition(), c.getPosition(), new pc.Color(target.getWeight(0), 0, target.getWeight(1), 1), false);\n                    }\n                    drawSkeleton(c, color);\n                });\n            };\n\n            app.on('update', () => {\n                if (data.get('options.skeleton')) {\n                    drawSkeleton(modelEntity, new pc.Color(1, 0, 0, modelEntity.anim.baseLayer.weight * 0.5));\n                }\n            });\n\n            app.start();\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    const assets = {\n        model: new pc.Asset(\"model\", \"container\", {\n            url: \"/static/assets/models/bitmoji.glb\",\n        }),\n        idleAnim: new pc.Asset(\"idleAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/idle.glb\",\n        }),\n        idleEagerAnim: new pc.Asset(\"idleEagerAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/idle-eager.glb\",\n        }),\n        walkAnim: new pc.Asset(\"walkAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/walk.glb\",\n        }),\n        danceAnim: new pc.Asset(\"danceAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/win-dance.glb\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        bloom: new pc.Asset(\"bloom\", \"script\", {\n            url: \"/static/scripts/posteffects/posteffect-bloom.js\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.AnimComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.AnimClipHandler,\n            // @ts-ignore\n            pc.AnimStateGraphHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            // setup data\n            data.set(\"fullBodyLayer\", {\n                state: \"Idle\",\n                blendType: pc.ANIM_LAYER_OVERWRITE,\n            });\n\n            data.set(\"upperBodyLayer\", {\n                state: \"Eager\",\n                blendType: pc.ANIM_LAYER_ADDITIVE,\n                useMask: true,\n            });\n\n            data.set(\"options\", {\n                blend: 0.5,\n                skeleton: true,\n            });\n\n            // setup skydome\n            app.scene.exposure = 2;\n            app.scene.skyboxMip = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1),\n            });\n\n            cameraEntity.translate(0, 0.75, 3);\n\n            // add bloom postprocessing (this is ignored by the picker)\n            cameraEntity.addComponent(\"script\");\n            cameraEntity.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1,\n                    bloomThreshold: 0.7,\n                    blurAmount: 4,\n                },\n            });\n\n            app.root.addChild(cameraEntity);\n\n            // Create an entity with a light component\n            const lightEntity = new pc.Entity();\n            lightEntity.addComponent(\"light\", {\n                castShadows: true,\n                intensity: 1.5,\n                normalOffsetBias: 0.02,\n                shadowType: pc.SHADOW_PCF5,\n                shadowDistance: 6,\n                shadowResolution: 2048,\n                shadowBias: 0.02,\n            });\n\n            app.root.addChild(lightEntity);\n            lightEntity.setLocalEulerAngles(45, 30, 0);\n\n            // create an entity from the loaded model using the render component\n            const modelEntity = assets.model.resource.instantiateRenderEntity({\n                castShadows: true,\n            });\n\n            modelEntity.addComponent(\"anim\", {\n                activate: true,\n            });\n\n            app.root.addChild(modelEntity);\n\n            // retrieve the animation assets\n            const idleTrack = assets.idleAnim.resource.animations[0].resource;\n            const walkTrack = assets.walkAnim.resource.animations[0].resource;\n            const danceTrack = assets.danceAnim.resource.animations[0].resource;\n            const idleEagerTrack =\n                assets.idleEagerAnim.resource.animations[0].resource;\n\n            // create the full body layer by assigning full body animations to the anim component\n            modelEntity.anim.assignAnimation(\"Idle\", idleTrack);\n            modelEntity.anim.assignAnimation(\"Walk\", walkTrack);\n\n            // set the default weight for the base layer\n            modelEntity.anim.baseLayer.weight = 1.0 - data.get(\"options.blend\");\n\n            // create a mask for the upper body layer\n            const upperBodyMask = {\n                // set a path with the children property as true to include that path and all of its children in the mask\n                \"RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT\": {\n                    children: true,\n                },\n\n                // set a path to true in the mask to include only that specific path\n                \"RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT/C_Head\": true,\n            };\n\n            // create a new layer for the upper body, with additive layer blending\n            const upperBodyLayer = modelEntity.anim.addLayer(\n                \"UpperBody\",\n                data.get(\"options.blend\"),\n                upperBodyMask,\n                data.get(\"upperBodyLayer.blendType\")\n            );\n            upperBodyLayer.assignAnimation(\"Eager\", idleEagerTrack);\n            upperBodyLayer.assignAnimation(\"Idle\", idleTrack);\n            upperBodyLayer.assignAnimation(\"Dance\", danceTrack);\n\n            // respond to changes in the data object made by the control panel\n            data.on(\"*:set\", (path, value) => {\n                if (path === \"fullBodyLayer.state\") {\n                    modelEntity.anim.baseLayer.transition(value, 0.4);\n                }\n                if (path === \"upperBodyLayer.state\") {\n                    upperBodyLayer.transition(value, 0.4);\n                }\n                if (path === \"fullBodyLayer.blendType\") {\n                    modelEntity.anim.baseLayer.blendType = value;\n                }\n                if (path === \"upperBodyLayer.blendType\") {\n                    upperBodyLayer.blendType = value;\n                }\n                if (path === \"upperBodyLayer.useMask\") {\n                    upperBodyLayer.mask = value\n                        ? {\n                              \"RootNode/AVATAR/C_spine0001_bind_JNT/C_spine0002_bind_JNT\":\n                                  {\n                                      children: true,\n                                  },\n                          }\n                        : null;\n                }\n                if (path === \"options.blend\") {\n                    modelEntity.anim.baseLayer.weight = 1.0 - value;\n                    upperBodyLayer.weight = value;\n                }\n            });\n\n            const drawSkeleton = (entity, color) => {\n                entity.children.forEach((c) => {\n                    const target =\n                        modelEntity.anim._targets[\n                            entity.path + \"/graph/localPosition\"\n                        ];\n                    if (target) {\n                        app.drawLine(\n                            entity.getPosition(),\n                            c.getPosition(),\n                            new pc.Color(\n                                target.getWeight(0),\n                                0,\n                                target.getWeight(1),\n                                1\n                            ),\n                            false\n                        );\n                    }\n                    drawSkeleton(c, color);\n                });\n            };\n\n            app.on(\"update\", () => {\n                if (data.get(\"options.skeleton\")) {\n                    drawSkeleton(\n                        modelEntity,\n                        new pc.Color(\n                            1,\n                            0,\n                            0,\n                            modelEntity.anim.baseLayer.weight * 0.5\n                        )\n                    );\n                }\n            });\n\n            app.start();\n        });\n    });\n}\n","nameSlug":"layer-masks","categorySlug":"animation"},"locomotion":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data: any): void {\n\n    pc.WasmModule.setConfig('Ammo', {\n        glueUrl: '/static/lib/ammo/ammo.wasm.js',\n        wasmUrl: '/static/lib/ammo/ammo.wasm.wasm',\n        fallbackUrl: '/static/lib/ammo/ammo.js'\n    });\n\n    pc.WasmModule.getInstance('Ammo', run);\n\n    function run() {\n\n        const assets = {\n            'playcanvasGreyTexture': new pc.Asset('playcanvasGreyTexture', 'texture', { url: '/static/assets/textures/playcanvas-grey.png' }),\n            'model': new pc.Asset('model', 'container', { url: '/static/assets/models/bitmoji.glb' }),\n            'idleAnim': new pc.Asset('idleAnim', 'container', { url: '/static/assets/animations/bitmoji/idle.glb' }),\n            'walkAnim': new pc.Asset('walkAnim', 'container', { url: '/static/assets/animations/bitmoji/walk.glb' }),\n            'jogAnim': new pc.Asset('jogAnim', 'container', { url: '/static/assets/animations/bitmoji/run.glb' }),\n            'jumpAnim': new pc.Asset('jumpAnim', 'container', { url: '/static/assets/animations/bitmoji/jump-flip.glb' }),\n            helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        };\n\n        const gfxOptions = {\n            deviceTypes: [deviceType],\n            glslangUrl: '/static/lib/glslang/glslang.js',\n            twgslUrl: '/static/lib/twgsl/twgsl.js'\n        };\n\n        pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n            createOptions.mouse = new pc.Mouse(document.body);\n            createOptions.touch = new pc.TouchDevice(document.body);\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.RenderComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.LightComponentSystem,\n                // @ts-ignore\n                pc.ScriptComponentSystem,\n                // @ts-ignore\n                pc.AnimComponentSystem,\n                // @ts-ignore\n                pc.CollisionComponentSystem,\n                // @ts-ignore\n                pc.RigidBodyComponentSystem\n            ];\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.ContainerHandler,\n                // @ts-ignore\n                pc.ScriptHandler,\n                // @ts-ignore\n                pc.AnimClipHandler,\n                // @ts-ignore\n                pc.AnimStateGraphHandler\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n            assetListLoader.load(() => {\n\n                // setup skydome\n                app.scene.skyboxMip = 2;\n                app.scene.skyboxIntensity = 0.7;\n                app.scene.envAtlas = assets.helipad.resource;\n                app.scene.toneMapping = pc.TONEMAP_ACES;\n\n                // Create an Entity with a camera component\n                const cameraEntity = new pc.Entity();\n                cameraEntity.name = \"Camera\";\n                cameraEntity.addComponent(\"camera\", {\n                    clearColor: new pc.Color(0.1, 0.15, 0.2)\n                });\n\n                cameraEntity.translateLocal(0.5, 3, 8);\n                cameraEntity.rotateLocal(-30, 0, 0);\n                app.root.addChild(cameraEntity);\n\n                // Create an entity with a light component\n                const light = new pc.Entity();\n                light.addComponent(\"light\", {\n                    type: \"directional\",\n                    color: new pc.Color(1, 1, 1),\n                    castShadows: true,\n                    intensity: 2,\n                    shadowBias: 0.2,\n                    shadowDistance: 16,\n                    normalOffsetBias: 0.05,\n                    shadowResolution: 2048\n                });\n                light.setLocalEulerAngles(60, 30, 0);\n                app.root.addChild(light);\n\n                app.start();\n\n                const characterEntity = new pc.Entity();\n\n                // create an entity from the loaded model using the render component\n                const renderEntity = assets.model.resource.instantiateRenderEntity({\n                    castShadows: true\n                });\n\n                // assign the renderEntity as the child of character entity. All transforms of the\n                // renderEntity and its children are driven by the anim component.\n                // The characterEntity transform will be controlled by the Locomotion script.\n                characterEntity.addChild(renderEntity);\n\n                // add an anim component to the entity\n                characterEntity.addComponent('anim', {\n                    activate: true\n                });\n\n                // create an anim state graph\n                const animStateGraphData = {\n                    \"layers\": [\n                        {\n                            \"name\": \"locomotion\",\n                            \"states\": [\n                                {\n                                    \"name\": \"START\"\n                                },\n                                {\n                                    \"name\": \"Idle\",\n                                    \"speed\": 1.0\n                                },\n                                {\n                                    \"name\": \"Walk\",\n                                    \"speed\": 1.0\n                                },\n                                {\n                                    \"name\": \"Jump\",\n                                    \"speed\": 1\n                                },\n                                {\n                                    \"name\": \"Jog\",\n                                    \"speed\": 1.0\n                                },\n                                {\n                                    \"name\": \"END\"\n                                }\n                            ],\n                            \"transitions\": [\n                                {\n                                    \"from\": \"START\",\n                                    \"to\": \"Idle\",\n                                    \"time\": 0,\n                                    \"priority\": 0\n                                },\n                                {\n                                    \"from\": \"Idle\",\n                                    \"to\": \"Walk\",\n                                    \"time\": 0.1,\n                                    \"priority\": 0,\n                                    \"conditions\": [\n                                        {\n                                            \"parameterName\": \"speed\",\n                                            \"predicate\": pc.ANIM_GREATER_THAN,\n                                            \"value\": 0\n                                        }\n                                    ]\n                                },\n                                {\n                                    \"from\": \"ANY\",\n                                    \"to\": \"Jump\",\n                                    \"time\": 0.1,\n                                    \"priority\": 0,\n                                    \"conditions\": [\n                                        {\n                                            \"parameterName\": \"jump\",\n                                            \"predicate\": pc.ANIM_EQUAL_TO,\n                                            \"value\": true\n                                        }\n                                    ]\n                                },\n                                {\n                                    \"from\": \"Jump\",\n                                    \"to\": \"Idle\",\n                                    \"time\": 0.2,\n                                    \"priority\": 0,\n                                    \"exitTime\": 0.8\n                                },\n                                {\n                                    \"from\": \"Jump\",\n                                    \"to\": \"Walk\",\n                                    \"time\": 0.2,\n                                    \"priority\": 0,\n                                    \"exitTime\": 0.8\n                                },\n                                {\n                                    \"from\": \"Walk\",\n                                    \"to\": \"Idle\",\n                                    \"time\": 0.1,\n                                    \"priority\": 0,\n                                    \"conditions\": [\n                                        {\n                                            \"parameterName\": \"speed\",\n                                            \"predicate\": pc.ANIM_LESS_THAN_EQUAL_TO,\n                                            \"value\": 0\n                                        }\n                                    ]\n                                },\n                                {\n                                    \"from\": \"Walk\",\n                                    \"to\": \"Jog\",\n                                    \"time\": 0.1,\n                                    \"priority\": 0,\n                                    \"conditions\": [\n                                        {\n                                            \"parameterName\": \"speed\",\n                                            \"predicate\": pc.ANIM_GREATER_THAN,\n                                            \"value\": 1\n                                        }\n                                    ]\n                                },\n                                {\n                                    \"from\": \"Jog\",\n                                    \"to\": \"Walk\",\n                                    \"time\": 0.1,\n                                    \"priority\": 0,\n                                    \"conditions\": [\n                                        {\n                                            \"parameterName\": \"speed\",\n                                            \"predicate\": pc.ANIM_LESS_THAN,\n                                            \"value\": 2\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n                    ],\n                    \"parameters\": {\n                        \"speed\": {\n                            \"name\": \"speed\",\n                            \"type\": pc.ANIM_PARAMETER_INTEGER,\n                            \"value\": 0\n                        },\n                        \"jump\": {\n                            \"name\": \"jump\",\n                            \"type\": pc.ANIM_PARAMETER_TRIGGER,\n                            \"value\": false\n                        }\n                    }\n                };\n\n                // load the state graph into the anim component\n                characterEntity.anim.loadStateGraph(animStateGraphData);\n\n                // assign the loaded animation assets to each of the states present in the state graph\n                const locomotionLayer = characterEntity.anim.baseLayer;\n                locomotionLayer.assignAnimation('Idle', assets.idleAnim.resource.animations[0].resource);\n                locomotionLayer.assignAnimation('Walk', assets.walkAnim.resource.animations[0].resource);\n                locomotionLayer.assignAnimation('Jog', assets.jogAnim.resource.animations[0].resource);\n                locomotionLayer.assignAnimation('Jump', assets.jumpAnim.resource.animations[0].resource);\n\n                app.root.addChild(characterEntity);\n\n                const planeEntity = new pc.Entity();\n                planeEntity.name = 'Plane';\n                planeEntity.addComponent(\"render\", {\n                    type: \"plane\"\n                });\n                planeEntity.addComponent(\"collision\", {\n                    type: 'box',\n                    halfExtents: new pc.Vec3(7.5, 0, 7.5)\n                });\n                planeEntity.addComponent(\"rigidbody\", {\n                    type: 'static'\n                });\n                planeEntity.setLocalScale(15, 1, 15);\n                planeEntity.setPosition(0, 0, 0);\n                const material = new pc.StandardMaterial();\n                material.diffuseMap = assets.playcanvasGreyTexture.resource;\n                material.update();\n                planeEntity.render.meshInstances[0].material = material;\n                app.root.addChild(planeEntity);\n\n                data.on('jump', function () {\n                    const isJumping = characterEntity.anim.baseLayer.activeState === 'Jump';\n                    if (!isJumping) {\n                        characterEntity.anim.setTrigger('jump');\n                    }\n                });\n\n                // create a Locomotion script and initialize some variables\n                const Locomotion = pc.createScript('Locomotion');\n\n                let characterDirection;\n                let targetPosition: pc.Vec3;\n\n                // initialize code called once per entity\n                Locomotion.prototype.initialize = function () {\n                    characterDirection = new pc.Vec3(1, 0, 0);\n                    targetPosition = new pc.Vec3(2, 0, 2);\n                    document.addEventListener(\"mousedown\", this.onMouseDown);\n                };\n\n                // @ts-ignore engine-tsd\n                Locomotion.prototype.onMouseDown = function (event: any) {\n                    if (event.button !== 0) return;\n                    // Set the character target position to a position on the plane that the user has clicked\n                    const cameraEntity = app.root.findByName('Camera') as pc.Entity;\n                    const near = cameraEntity.camera.screenToWorld(event.x, event.y, cameraEntity.camera.nearClip);\n                    const far = cameraEntity.camera.screenToWorld(event.x, event.y, cameraEntity.camera.farClip);\n                    const result = app.systems.rigidbody.raycastFirst(far, near);\n                    if (result) {\n                        targetPosition = new pc.Vec3(result.point.x, 0, result.point.z);\n                        characterEntity.anim.setInteger('speed', data.get('jogToggle') ? 2 : 1);\n                    }\n                };\n\n                // defines how many units the character should move per second given its current animation state\n                function speedForState(state: any) {\n                    switch (state) {\n                        case 'Walk':\n                            return 1.0;\n                        case 'Jog':\n                            return 4.0;\n                        case 'Jump':\n                        case 'Idle':\n                        default:\n                            return 0.0;\n                    }\n                }\n\n                const currentPosition = new pc.Vec3(0, 0, 0);\n\n                // update code called every frame\n                Locomotion.prototype.update = function (dt: number) {\n                    if (characterEntity.anim.getInteger('speed')) {\n                        // Update position if target position is not the same as entity position. Base the movement speed on the current state\n                        // Move the character along X & Z axis based on click target position & make character face click direction\n                        let moveSpeed = speedForState(characterEntity.anim.baseLayer.activeState);\n                        if (characterEntity.anim.baseLayer.transitioning) {\n                            const prevMoveSpeed = speedForState(characterEntity.anim.baseLayer.previousState);\n                            const progress = characterEntity.anim.baseLayer.transitionProgress;\n                            moveSpeed = (prevMoveSpeed * (1.0 - progress)) + (moveSpeed * progress);\n                        }\n                        const distance = targetPosition.clone().sub(currentPosition);\n                        const direction = distance.clone().normalize();\n                        characterDirection = new pc.Vec3().sub(direction);\n                        const movement = direction.clone().mulScalar(dt * moveSpeed);\n                        if (movement.length() < distance.length()) {\n                            currentPosition.add(movement);\n                            characterEntity.setPosition(currentPosition);\n                            characterEntity.lookAt(characterEntity.getPosition().clone().add(characterDirection));\n                        } else {\n                            currentPosition.copy(targetPosition);\n                            characterEntity.setPosition(currentPosition);\n                            characterEntity.anim.setInteger('speed', 0);\n                        }\n                    }\n\n                };\n\n                characterEntity.addComponent(\"script\");\n                characterEntity.script.create('Locomotion', {});\n            });\n        });\n    }\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    pc.WasmModule.setConfig(\"Ammo\", {\n        glueUrl: \"/static/lib/ammo/ammo.wasm.js\",\n        wasmUrl: \"/static/lib/ammo/ammo.wasm.wasm\",\n        fallbackUrl: \"/static/lib/ammo/ammo.js\",\n    });\n\n    pc.WasmModule.getInstance(\"Ammo\", run);\n\n    function run() {\n        const assets = {\n            playcanvasGreyTexture: new pc.Asset(\n                \"playcanvasGreyTexture\",\n                \"texture\",\n                { url: \"/static/assets/textures/playcanvas-grey.png\" }\n            ),\n            model: new pc.Asset(\"model\", \"container\", {\n                url: \"/static/assets/models/bitmoji.glb\",\n            }),\n            idleAnim: new pc.Asset(\"idleAnim\", \"container\", {\n                url: \"/static/assets/animations/bitmoji/idle.glb\",\n            }),\n            walkAnim: new pc.Asset(\"walkAnim\", \"container\", {\n                url: \"/static/assets/animations/bitmoji/walk.glb\",\n            }),\n            jogAnim: new pc.Asset(\"jogAnim\", \"container\", {\n                url: \"/static/assets/animations/bitmoji/run.glb\",\n            }),\n            jumpAnim: new pc.Asset(\"jumpAnim\", \"container\", {\n                url: \"/static/assets/animations/bitmoji/jump-flip.glb\",\n            }),\n            helipad: new pc.Asset(\n                \"helipad-env-atlas\",\n                \"texture\",\n                { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n                { type: pc.TEXTURETYPE_RGBP }\n            ),\n        };\n\n        const gfxOptions = {\n            deviceTypes: [deviceType],\n            glslangUrl: \"/static/lib/glslang/glslang.js\",\n            twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n        };\n\n        pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n            createOptions.mouse = new pc.Mouse(document.body);\n            createOptions.touch = new pc.TouchDevice(document.body);\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.RenderComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.LightComponentSystem,\n                // @ts-ignore\n                pc.ScriptComponentSystem,\n                // @ts-ignore\n                pc.AnimComponentSystem,\n                // @ts-ignore\n                pc.CollisionComponentSystem,\n                // @ts-ignore\n                pc.RigidBodyComponentSystem,\n            ];\n\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.ContainerHandler,\n                // @ts-ignore\n                pc.ScriptHandler,\n                // @ts-ignore\n                pc.AnimClipHandler,\n                // @ts-ignore\n                pc.AnimStateGraphHandler,\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assetListLoader = new pc.AssetListLoader(\n                Object.values(assets),\n                app.assets\n            );\n            assetListLoader.load(() => {\n                // setup skydome\n                app.scene.skyboxMip = 2;\n                app.scene.skyboxIntensity = 0.7;\n                app.scene.envAtlas = assets.helipad.resource;\n                app.scene.toneMapping = pc.TONEMAP_ACES;\n\n                // Create an Entity with a camera component\n                const cameraEntity = new pc.Entity();\n                cameraEntity.name = \"Camera\";\n                cameraEntity.addComponent(\"camera\", {\n                    clearColor: new pc.Color(0.1, 0.15, 0.2),\n                });\n\n                cameraEntity.translateLocal(0.5, 3, 8);\n                cameraEntity.rotateLocal(-30, 0, 0);\n                app.root.addChild(cameraEntity);\n\n                // Create an entity with a light component\n                const light = new pc.Entity();\n                light.addComponent(\"light\", {\n                    type: \"directional\",\n                    color: new pc.Color(1, 1, 1),\n                    castShadows: true,\n                    intensity: 2,\n                    shadowBias: 0.2,\n                    shadowDistance: 16,\n                    normalOffsetBias: 0.05,\n                    shadowResolution: 2048,\n                });\n\n                light.setLocalEulerAngles(60, 30, 0);\n                app.root.addChild(light);\n\n                app.start();\n\n                const characterEntity = new pc.Entity();\n\n                // create an entity from the loaded model using the render component\n                const renderEntity =\n                    assets.model.resource.instantiateRenderEntity({\n                        castShadows: true,\n                    });\n\n                // assign the renderEntity as the child of character entity. All transforms of the\n                // renderEntity and its children are driven by the anim component.\n                // The characterEntity transform will be controlled by the Locomotion script.\n                characterEntity.addChild(renderEntity);\n\n                // add an anim component to the entity\n                characterEntity.addComponent(\"anim\", {\n                    activate: true,\n                });\n\n                // create an anim state graph\n                const animStateGraphData = {\n                    layers: [\n                        {\n                            name: \"locomotion\",\n                            states: [\n                                {\n                                    name: \"START\",\n                                },\n\n                                {\n                                    name: \"Idle\",\n                                    speed: 1.0,\n                                },\n\n                                {\n                                    name: \"Walk\",\n                                    speed: 1.0,\n                                },\n\n                                {\n                                    name: \"Jump\",\n                                    speed: 1,\n                                },\n\n                                {\n                                    name: \"Jog\",\n                                    speed: 1.0,\n                                },\n\n                                {\n                                    name: \"END\",\n                                },\n                            ],\n\n                            transitions: [\n                                {\n                                    from: \"START\",\n                                    to: \"Idle\",\n                                    time: 0,\n                                    priority: 0,\n                                },\n\n                                {\n                                    from: \"Idle\",\n                                    to: \"Walk\",\n                                    time: 0.1,\n                                    priority: 0,\n                                    conditions: [\n                                        {\n                                            parameterName: \"speed\",\n                                            predicate: pc.ANIM_GREATER_THAN,\n                                            value: 0,\n                                        },\n                                    ],\n                                },\n\n                                {\n                                    from: \"ANY\",\n                                    to: \"Jump\",\n                                    time: 0.1,\n                                    priority: 0,\n                                    conditions: [\n                                        {\n                                            parameterName: \"jump\",\n                                            predicate: pc.ANIM_EQUAL_TO,\n                                            value: true,\n                                        },\n                                    ],\n                                },\n\n                                {\n                                    from: \"Jump\",\n                                    to: \"Idle\",\n                                    time: 0.2,\n                                    priority: 0,\n                                    exitTime: 0.8,\n                                },\n\n                                {\n                                    from: \"Jump\",\n                                    to: \"Walk\",\n                                    time: 0.2,\n                                    priority: 0,\n                                    exitTime: 0.8,\n                                },\n\n                                {\n                                    from: \"Walk\",\n                                    to: \"Idle\",\n                                    time: 0.1,\n                                    priority: 0,\n                                    conditions: [\n                                        {\n                                            parameterName: \"speed\",\n                                            predicate:\n                                                pc.ANIM_LESS_THAN_EQUAL_TO,\n                                            value: 0,\n                                        },\n                                    ],\n                                },\n\n                                {\n                                    from: \"Walk\",\n                                    to: \"Jog\",\n                                    time: 0.1,\n                                    priority: 0,\n                                    conditions: [\n                                        {\n                                            parameterName: \"speed\",\n                                            predicate: pc.ANIM_GREATER_THAN,\n                                            value: 1,\n                                        },\n                                    ],\n                                },\n\n                                {\n                                    from: \"Jog\",\n                                    to: \"Walk\",\n                                    time: 0.1,\n                                    priority: 0,\n                                    conditions: [\n                                        {\n                                            parameterName: \"speed\",\n                                            predicate: pc.ANIM_LESS_THAN,\n                                            value: 2,\n                                        },\n                                    ],\n                                },\n                            ],\n                        },\n                    ],\n\n                    parameters: {\n                        speed: {\n                            name: \"speed\",\n                            type: pc.ANIM_PARAMETER_INTEGER,\n                            value: 0,\n                        },\n\n                        jump: {\n                            name: \"jump\",\n                            type: pc.ANIM_PARAMETER_TRIGGER,\n                            value: false,\n                        },\n                    },\n                };\n\n                // load the state graph into the anim component\n                characterEntity.anim.loadStateGraph(animStateGraphData);\n\n                // assign the loaded animation assets to each of the states present in the state graph\n                const locomotionLayer = characterEntity.anim.baseLayer;\n                locomotionLayer.assignAnimation(\n                    \"Idle\",\n                    assets.idleAnim.resource.animations[0].resource\n                );\n                locomotionLayer.assignAnimation(\n                    \"Walk\",\n                    assets.walkAnim.resource.animations[0].resource\n                );\n                locomotionLayer.assignAnimation(\n                    \"Jog\",\n                    assets.jogAnim.resource.animations[0].resource\n                );\n                locomotionLayer.assignAnimation(\n                    \"Jump\",\n                    assets.jumpAnim.resource.animations[0].resource\n                );\n\n                app.root.addChild(characterEntity);\n\n                const planeEntity = new pc.Entity();\n                planeEntity.name = \"Plane\";\n                planeEntity.addComponent(\"render\", {\n                    type: \"plane\",\n                });\n\n                planeEntity.addComponent(\"collision\", {\n                    type: \"box\",\n                    halfExtents: new pc.Vec3(7.5, 0, 7.5),\n                });\n\n                planeEntity.addComponent(\"rigidbody\", {\n                    type: \"static\",\n                });\n\n                planeEntity.setLocalScale(15, 1, 15);\n                planeEntity.setPosition(0, 0, 0);\n                const material = new pc.StandardMaterial();\n                material.diffuseMap = assets.playcanvasGreyTexture.resource;\n                material.update();\n                planeEntity.render.meshInstances[0].material = material;\n                app.root.addChild(planeEntity);\n\n                data.on(\"jump\", function () {\n                    const isJumping =\n                        characterEntity.anim.baseLayer.activeState === \"Jump\";\n                    if (!isJumping) {\n                        characterEntity.anim.setTrigger(\"jump\");\n                    }\n                });\n\n                // create a Locomotion script and initialize some variables\n                const Locomotion = pc.createScript(\"Locomotion\");\n\n                let characterDirection;\n                let targetPosition;\n\n                // initialize code called once per entity\n                Locomotion.prototype.initialize = function () {\n                    characterDirection = new pc.Vec3(1, 0, 0);\n                    targetPosition = new pc.Vec3(2, 0, 2);\n                    document.addEventListener(\"mousedown\", this.onMouseDown);\n                };\n\n                // @ts-ignore engine-tsd\n                Locomotion.prototype.onMouseDown = function (event) {\n                    if (event.button !== 0) return;\n                    // Set the character target position to a position on the plane that the user has clicked\n                    const cameraEntity = app.root.findByName(\"Camera\");\n                    const near = cameraEntity.camera.screenToWorld(\n                        event.x,\n                        event.y,\n                        cameraEntity.camera.nearClip\n                    );\n                    const far = cameraEntity.camera.screenToWorld(\n                        event.x,\n                        event.y,\n                        cameraEntity.camera.farClip\n                    );\n                    const result = app.systems.rigidbody.raycastFirst(\n                        far,\n                        near\n                    );\n                    if (result) {\n                        targetPosition = new pc.Vec3(\n                            result.point.x,\n                            0,\n                            result.point.z\n                        );\n                        characterEntity.anim.setInteger(\n                            \"speed\",\n                            data.get(\"jogToggle\") ? 2 : 1\n                        );\n                    }\n                };\n\n                // defines how many units the character should move per second given its current animation state\n                function speedForState(state) {\n                    switch (state) {\n                        case \"Walk\":\n                            return 1.0;\n                        case \"Jog\":\n                            return 4.0;\n                        case \"Jump\":\n                        case \"Idle\":\n                        default:\n                            return 0.0;\n                    }\n                }\n\n                const currentPosition = new pc.Vec3(0, 0, 0);\n\n                // update code called every frame\n                Locomotion.prototype.update = function (dt) {\n                    if (characterEntity.anim.getInteger(\"speed\")) {\n                        // Update position if target position is not the same as entity position. Base the movement speed on the current state\n                        // Move the character along X & Z axis based on click target position & make character face click direction\n                        let moveSpeed = speedForState(\n                            characterEntity.anim.baseLayer.activeState\n                        );\n                        if (characterEntity.anim.baseLayer.transitioning) {\n                            const prevMoveSpeed = speedForState(\n                                characterEntity.anim.baseLayer.previousState\n                            );\n                            const progress =\n                                characterEntity.anim.baseLayer\n                                    .transitionProgress;\n                            moveSpeed =\n                                prevMoveSpeed * (1.0 - progress) +\n                                moveSpeed * progress;\n                        }\n                        const distance = targetPosition\n                            .clone()\n                            .sub(currentPosition);\n                        const direction = distance.clone().normalize();\n                        characterDirection = new pc.Vec3().sub(direction);\n                        const movement = direction\n                            .clone()\n                            .mulScalar(dt * moveSpeed);\n                        if (movement.length() < distance.length()) {\n                            currentPosition.add(movement);\n                            characterEntity.setPosition(currentPosition);\n                            characterEntity.lookAt(\n                                characterEntity\n                                    .getPosition()\n                                    .clone()\n                                    .add(characterDirection)\n                            );\n                        } else {\n                            currentPosition.copy(targetPosition);\n                            characterEntity.setPosition(currentPosition);\n                            characterEntity.anim.setInteger(\"speed\", 0);\n                        }\n                    }\n                };\n\n                characterEntity.addComponent(\"script\");\n                characterEntity.script.create(\"Locomotion\", {});\n            });\n        });\n    }\n}\n","nameSlug":"locomotion","categorySlug":"animation"},"tween":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/arial.json' }),\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/animation/tween.js' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n            // @ts-ignore\n            pc.JsonHandler,\n            // @ts-ignore\n            pc.ScriptHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // Utility function to create a text element-based entity\n            const createText = function (fontAsset: pc.Asset, message: string, x: number, y: number, z: number, rot: number) {\n                const text = new pc.Entity();\n                text.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    fontAsset: fontAsset,\n                    fontSize: 0.5,\n                    pivot: [1, 0.5],\n                    text: message,\n                    type: pc.ELEMENTTYPE_TEXT\n                });\n                text.setLocalPosition(x, y, z);\n                text.setLocalEulerAngles(0, 0, rot);\n                app.root.addChild(text);\n            };\n\n            const easingFunctions = [\n                'Linear',\n                'Quadratic',\n                'Cubic',\n                'Quartic',\n                'Quintic',\n                'Sinusoidal',\n                'Exponential',\n                'Circular',\n                'Elastic',\n                'Back',\n                'Bounce'\n            ];\n            const points: Array<pc.Vec3> = [];\n            const colors: Array<pc.Color> = [];\n\n            for (let i = 0; i < easingFunctions.length; i++) {\n                // Create an entity with a sphere render component\n                const sphere = new pc.Entity();\n\n                sphere.addComponent(\"render\", {\n                    type: \"sphere\"\n                });\n                const material = sphere.render.material as pc.StandardMaterial;\n                material.diffuse.set(1, 0, 0);\n                material.specular.set(0.6, 0.6, 0.6);\n                material.gloss = 0.2;\n\n                sphere.addComponent(\"script\");\n                sphere.script.create(\"tween\", {\n                    attributes: {\n                        tweens: [{\n                            autoPlay: true, // Start this tween immediately\n                            delay: 0, // No delay on start\n                            duration: 1500, // 2 seconds\n                            easingFunction: i,\n                            easingType: 2, // InOut type\n                            end: new pc.Vec4(4, -i, 0, 0),\n                            path: 'localPosition', // Update the entity's local position\n                            repeat: -1, // Repeat infinitely\n                            repeatDelay: 0, // No delay between repeats\n                            start: new pc.Vec4(0, -i, 0, 0),\n                            yoyo: true // Ping pong between start and end values\n                        }]\n                    }\n                });\n\n                sphere.setLocalScale(0.8, 0.8, 0.8);\n                app.root.addChild(sphere);\n\n                // Add a line for the path of the sphere\n                points.push(new pc.Vec3(0, -i, 0), new pc.Vec3(4, -i, 0));\n                colors.push(pc.Color.WHITE, pc.Color.WHITE);\n\n                // Create a text label for the sphere\n                createText(assets.font, easingFunctions[i], -0.5, -i, 0, 0);\n            }\n\n            // Create an entity with a directional light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\"\n            });\n            light.setLocalEulerAngles(70, 30, 0);\n            app.root.addChild(light);\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5)\n            });\n            camera.translate(0.65, -5.5, 20);\n            app.root.addChild(camera);\n\n            app.on('update', function () {\n                app.drawLines(points, colors);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/arial.json\",\n        }),\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/animation/tween.js\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n            // @ts-ignore\n            pc.JsonHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // Utility function to create a text element-based entity\n            const createText = function (fontAsset, message, x, y, z, rot) {\n                const text = new pc.Entity();\n                text.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    fontAsset: fontAsset,\n                    fontSize: 0.5,\n                    pivot: [1, 0.5],\n                    text: message,\n                    type: pc.ELEMENTTYPE_TEXT,\n                });\n\n                text.setLocalPosition(x, y, z);\n                text.setLocalEulerAngles(0, 0, rot);\n                app.root.addChild(text);\n            };\n\n            const easingFunctions = [\n                \"Linear\",\n                \"Quadratic\",\n                \"Cubic\",\n                \"Quartic\",\n                \"Quintic\",\n                \"Sinusoidal\",\n                \"Exponential\",\n                \"Circular\",\n                \"Elastic\",\n                \"Back\",\n                \"Bounce\",\n            ];\n\n            const points = [];\n            const colors = [];\n\n            for (let i = 0; i < easingFunctions.length; i++) {\n                // Create an entity with a sphere render component\n                const sphere = new pc.Entity();\n\n                sphere.addComponent(\"render\", {\n                    type: \"sphere\",\n                });\n\n                const material = sphere.render.material;\n                material.diffuse.set(1, 0, 0);\n                material.specular.set(0.6, 0.6, 0.6);\n                material.gloss = 0.2;\n\n                sphere.addComponent(\"script\");\n                sphere.script.create(\"tween\", {\n                    attributes: {\n                        tweens: [\n                            {\n                                autoPlay: true, // Start this tween immediately\n                                delay: 0, // No delay on start\n                                duration: 1500, // 2 seconds\n                                easingFunction: i,\n                                easingType: 2, // InOut type\n                                end: new pc.Vec4(4, -i, 0, 0),\n                                path: \"localPosition\", // Update the entity's local position\n                                repeat: -1, // Repeat infinitely\n                                repeatDelay: 0, // No delay between repeats\n                                start: new pc.Vec4(0, -i, 0, 0),\n                                yoyo: true, // Ping pong between start and end values\n                            },\n                        ],\n                    },\n                });\n\n                sphere.setLocalScale(0.8, 0.8, 0.8);\n                app.root.addChild(sphere);\n\n                // Add a line for the path of the sphere\n                points.push(new pc.Vec3(0, -i, 0), new pc.Vec3(4, -i, 0));\n                colors.push(pc.Color.WHITE, pc.Color.WHITE);\n\n                // Create a text label for the sphere\n                createText(assets.font, easingFunctions[i], -0.5, -i, 0, 0);\n            }\n\n            // Create an entity with a directional light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n            });\n\n            light.setLocalEulerAngles(70, 30, 0);\n            app.root.addChild(light);\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n            });\n\n            camera.translate(0.65, -5.5, 20);\n            app.root.addChild(camera);\n\n            app.on(\"update\", function () {\n                app.drawLines(points, colors);\n            });\n        });\n    });\n}\n","nameSlug":"tween","categorySlug":"animation"}},"camera":{"first-person":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        gamepads: new pc.GamePads(),\n        keyboard: new pc.Keyboard(window)\n    });\n\n    const assets = {\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' }),\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/camera/first-person-camera.js' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n\n        pc.WasmModule.setConfig('Ammo', {\n            glueUrl: '/static/lib/ammo/ammo.wasm.js',\n            wasmUrl: '/static/lib/ammo/ammo.wasm.wasm',\n            fallbackUrl: '/static/lib/ammo/ammo.js'\n        });\n\n        pc.WasmModule.getInstance('Ammo', run);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n        function run() {\n            app.start();\n\n            // Create a physical floor\n            const floor = new pc.Entity();\n            floor.addComponent(\"collision\", {\n                type: \"box\",\n                halfExtents: new pc.Vec3(100, 0.5, 100)\n            });\n            floor.addComponent(\"rigidbody\", {\n                type: \"static\",\n                restitution: 0.5\n            });\n            floor.setLocalPosition(0, -0.5, 0);\n            app.root.addChild(floor);\n\n            const floorModel = new pc.Entity();\n            floorModel.addComponent(\"render\", {\n                type: \"plane\"\n            });\n            floorModel.setLocalPosition(0, 0.5, 0);\n            floorModel.setLocalScale(200, 1, 200);\n            floor.addChild(floorModel);\n\n            // Create a model entity and assign the statue model\n            const model = assets.statue.resource.instantiateRenderEntity({\n                castShadows: true\n            });\n            model.addComponent(\"collision\", {\n                type: \"mesh\",\n                asset: assets.statue.resource.model\n            });\n            model.addComponent(\"rigidbody\", {\n                type: \"static\",\n                restitution: 0.5\n            });\n            app.root.addChild(model);\n\n            // Create a camera that will be driven by the character controller\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n                farClip: 100,\n                fov: 65,\n                nearClip: 0.1\n            });\n            camera.setLocalPosition(0, 1, 0);\n\n            // Create a physical character controller\n            const characterController = new pc.Entity();\n            characterController.addComponent(\"collision\", {\n                axis: 0,\n                height: 2,\n                radius: 0.5,\n                type: \"capsule\"\n            });\n            characterController.addComponent(\"rigidbody\", {\n                angularDamping: 0,\n                angularFactor: pc.Vec3.ZERO,\n                friction: 0.3,\n                linearDamping: 0,\n                linearFactor: pc.Vec3.ONE,\n                mass: 80,\n                restitution: 0,\n                type: \"dynamic\"\n            });\n            characterController.addComponent(\"script\");\n            characterController.script.create(\"characterController\");\n            characterController.script.create(\"firstPersonCamera\", {\n                attributes: {\n                    camera: camera\n                }\n            });\n            characterController.script.create(\"gamePadInput\");\n            characterController.script.create(\"keyboardInput\");\n            characterController.script.create(\"mouseInput\");\n            characterController.script.create(\"touchInput\");\n            characterController.setLocalPosition(0, 1, 10);\n\n            // Add the character controller and camera to the hierarchy\n            app.root.addChild(characterController);\n            characterController.addChild(camera);\n\n            // Create a directional light\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                castShadows: true,\n                color: new pc.Color(1, 1, 1),\n                normalOffsetBias: 0.05,\n                shadowBias: 0.2,\n                shadowDistance: 40,\n                type: \"directional\",\n                shadowResolution: 2048\n            });\n            app.root.addChild(light);\n            light.setLocalEulerAngles(45, 30, 0);\n        }\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        gamepads: new pc.GamePads(),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    const assets = {\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/first-person-camera.js\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        pc.WasmModule.setConfig(\"Ammo\", {\n            glueUrl: \"/static/lib/ammo/ammo.wasm.js\",\n            wasmUrl: \"/static/lib/ammo/ammo.wasm.wasm\",\n            fallbackUrl: \"/static/lib/ammo/ammo.js\",\n        });\n\n        pc.WasmModule.getInstance(\"Ammo\", run);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n        function run() {\n            app.start();\n\n            // Create a physical floor\n            const floor = new pc.Entity();\n            floor.addComponent(\"collision\", {\n                type: \"box\",\n                halfExtents: new pc.Vec3(100, 0.5, 100),\n            });\n\n            floor.addComponent(\"rigidbody\", {\n                type: \"static\",\n                restitution: 0.5,\n            });\n\n            floor.setLocalPosition(0, -0.5, 0);\n            app.root.addChild(floor);\n\n            const floorModel = new pc.Entity();\n            floorModel.addComponent(\"render\", {\n                type: \"plane\",\n            });\n\n            floorModel.setLocalPosition(0, 0.5, 0);\n            floorModel.setLocalScale(200, 1, 200);\n            floor.addChild(floorModel);\n\n            // Create a model entity and assign the statue model\n            const model = assets.statue.resource.instantiateRenderEntity({\n                castShadows: true,\n            });\n\n            model.addComponent(\"collision\", {\n                type: \"mesh\",\n                asset: assets.statue.resource.model,\n            });\n\n            model.addComponent(\"rigidbody\", {\n                type: \"static\",\n                restitution: 0.5,\n            });\n\n            app.root.addChild(model);\n\n            // Create a camera that will be driven by the character controller\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n                farClip: 100,\n                fov: 65,\n                nearClip: 0.1,\n            });\n\n            camera.setLocalPosition(0, 1, 0);\n\n            // Create a physical character controller\n            const characterController = new pc.Entity();\n            characterController.addComponent(\"collision\", {\n                axis: 0,\n                height: 2,\n                radius: 0.5,\n                type: \"capsule\",\n            });\n\n            characterController.addComponent(\"rigidbody\", {\n                angularDamping: 0,\n                angularFactor: pc.Vec3.ZERO,\n                friction: 0.3,\n                linearDamping: 0,\n                linearFactor: pc.Vec3.ONE,\n                mass: 80,\n                restitution: 0,\n                type: \"dynamic\",\n            });\n\n            characterController.addComponent(\"script\");\n            characterController.script.create(\"characterController\");\n            characterController.script.create(\"firstPersonCamera\", {\n                attributes: {\n                    camera: camera,\n                },\n            });\n\n            characterController.script.create(\"gamePadInput\");\n            characterController.script.create(\"keyboardInput\");\n            characterController.script.create(\"mouseInput\");\n            characterController.script.create(\"touchInput\");\n            characterController.setLocalPosition(0, 1, 10);\n\n            // Add the character controller and camera to the hierarchy\n            app.root.addChild(characterController);\n            characterController.addChild(camera);\n\n            // Create a directional light\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                castShadows: true,\n                color: new pc.Color(1, 1, 1),\n                normalOffsetBias: 0.05,\n                shadowBias: 0.2,\n                shadowDistance: 40,\n                type: \"directional\",\n                shadowResolution: 2048,\n            });\n\n            app.root.addChild(light);\n            light.setLocalEulerAngles(45, 30, 0);\n        }\n    });\n}\n","nameSlug":"first-person","categorySlug":"camera"},"fly":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        keyboard: new pc.Keyboard(window)\n    });\n\n    const assets = {\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/camera/fly-camera.js' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        app.start();\n\n        // ***********    Helper functions    *******************\n\n        function createMaterial(color: pc.Color) {\n            const material = new pc.StandardMaterial();\n            material.diffuse = color;\n            // we need to call material.update when we change its properties\n            material.update();\n            return material;\n        }\n\n        function createBox(position: pc.Vec3, size: pc.Vec3, material: pc.Material) {\n            // create an entity and add a model component of type 'box'\n            const box = new pc.Entity();\n            box.addComponent(\"render\", {\n                type: \"box\",\n                material: material\n            });\n\n            // move the box\n            box.setLocalPosition(position);\n            box.setLocalScale(size);\n\n            // add the box to the hierarchy\n            app.root.addChild(box);\n        }\n\n        // ***********    Create Boxes    *******************\n\n        // create a few boxes in our scene\n        const red = createMaterial(pc.Color.RED);\n        for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < 2; j++) {\n                createBox(new pc.Vec3(i * 2, 0, j * 4), pc.Vec3.ONE, red);\n            }\n        }\n\n        // create a floor\n        const white = createMaterial(pc.Color.WHITE);\n        createBox(new pc.Vec3(0, -0.5, 0), new pc.Vec3(10, 0.1, 10), white);\n\n        // ***********    Create lights   *******************\n\n        // make our scene prettier by adding a directional light\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"omni\",\n            color: new pc.Color(1, 1, 1),\n            range: 100\n        });\n        light.setLocalPosition(0, 0, 2);\n\n        // add the light to the hierarchy\n        app.root.addChild(light);\n\n        // ***********    Create camera    *******************\n\n        // Create an Entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.5, 0.5, 0.8),\n            nearClip: 0.3,\n            farClip: 30\n        });\n\n        // add the fly camera script to the camera\n        camera.addComponent(\"script\");\n        camera.script.create(\"flyCamera\");\n\n        // add the camera to the hierarchy\n        app.root.addChild(camera);\n\n        // Move the camera a little further away\n        camera.translate(2, 0.8, 9);\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    const assets = {\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/fly-camera.js\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        app.start();\n\n        // ***********    Helper functions    *******************\n\n        function createMaterial(color) {\n            const material = new pc.StandardMaterial();\n            material.diffuse = color;\n            // we need to call material.update when we change its properties\n            material.update();\n            return material;\n        }\n\n        function createBox(position, size, material) {\n            // create an entity and add a model component of type 'box'\n            const box = new pc.Entity();\n            box.addComponent(\"render\", {\n                type: \"box\",\n                material: material,\n            });\n\n            // move the box\n            box.setLocalPosition(position);\n            box.setLocalScale(size);\n\n            // add the box to the hierarchy\n            app.root.addChild(box);\n        }\n\n        // ***********    Create Boxes    *******************\n\n        // create a few boxes in our scene\n        const red = createMaterial(pc.Color.RED);\n        for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < 2; j++) {\n                createBox(new pc.Vec3(i * 2, 0, j * 4), pc.Vec3.ONE, red);\n            }\n        }\n\n        // create a floor\n        const white = createMaterial(pc.Color.WHITE);\n        createBox(new pc.Vec3(0, -0.5, 0), new pc.Vec3(10, 0.1, 10), white);\n\n        // ***********    Create lights   *******************\n\n        // make our scene prettier by adding a directional light\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"omni\",\n            color: new pc.Color(1, 1, 1),\n            range: 100,\n        });\n\n        light.setLocalPosition(0, 0, 2);\n\n        // add the light to the hierarchy\n        app.root.addChild(light);\n\n        // ***********    Create camera    *******************\n\n        // Create an Entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.5, 0.5, 0.8),\n            nearClip: 0.3,\n            farClip: 30,\n        });\n\n        // add the fly camera script to the camera\n        camera.addComponent(\"script\");\n        camera.script.create(\"flyCamera\");\n\n        // add the camera to the hierarchy\n        app.root.addChild(camera);\n\n        // Move the camera a little further away\n        camera.translate(2, 0.8, 9);\n    });\n}\n","nameSlug":"fly","categorySlug":"camera"},"orbit":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body)\n    });\n\n    const assets = {\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' }),\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n\n        // Create an entity hierarchy representing the statue\n        const statueEntity = assets.statue.resource.instantiateRenderEntity();\n        statueEntity.setLocalScale(0.07, 0.07, 0.07);\n        statueEntity.setLocalPosition(0, -0.5, 0);\n        app.root.addChild(statueEntity);\n\n        // Create a camera with an orbit camera script\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.4, 0.45, 0.5)\n        });\n        camera.addComponent(\"script\");\n        camera.script.create(\"orbitCamera\", {\n            attributes: {\n                inertiaFactor: 0.2 // Override default of 0 (no inertia)\n            }\n        });\n        camera.script.create(\"orbitCameraInputMouse\");\n        camera.script.create(\"orbitCameraInputTouch\");\n        app.root.addChild(camera);\n\n        // Create a directional light\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\"\n        });\n        app.root.addChild(light);\n        light.setLocalEulerAngles(45, 30, 0);\n\n        app.start();\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n    });\n\n    const assets = {\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/orbit-camera.js\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        // Create an entity hierarchy representing the statue\n        const statueEntity = assets.statue.resource.instantiateRenderEntity();\n        statueEntity.setLocalScale(0.07, 0.07, 0.07);\n        statueEntity.setLocalPosition(0, -0.5, 0);\n        app.root.addChild(statueEntity);\n\n        // Create a camera with an orbit camera script\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.4, 0.45, 0.5),\n        });\n\n        camera.addComponent(\"script\");\n        camera.script.create(\"orbitCamera\", {\n            attributes: {\n                inertiaFactor: 0.2, // Override default of 0 (no inertia)\n            },\n        });\n\n        camera.script.create(\"orbitCameraInputMouse\");\n        camera.script.create(\"orbitCameraInputTouch\");\n        app.root.addChild(camera);\n\n        // Create a directional light\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\",\n        });\n\n        app.root.addChild(light);\n        light.setLocalEulerAngles(45, 30, 0);\n\n        app.start();\n    });\n}\n","nameSlug":"orbit","categorySlug":"camera"}},"graphics":{"area-lights":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'color': new pc.Asset('color', 'texture', { url: '/static/assets/textures/seaside-rocks01-color.jpg' }),\n        'normal': new pc.Asset('normal', 'texture', { url: '/static/assets/textures/seaside-rocks01-normal.jpg' }),\n        'gloss': new pc.Asset('gloss', 'texture', { url: '/static/assets/textures/seaside-rocks01-gloss.jpg' }),\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' }),\n        'luts': new pc.Asset('luts', 'json', { url: '/static/assets/json/area-light-luts.json' }),\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.JsonHandler,\n            // @ts-ignore\n            pc.CubemapHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            // helper function to create a primitive with shape type, position, scale, color\n            function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3, color: pc.Color, assetManifest: any) {\n\n                // create material of specified color\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                material.gloss = 0.8;\n                material.useMetalness = true;\n\n                if (assetManifest) {\n                    material.diffuseMap = assetManifest.color.resource;\n                    material.normalMap = assetManifest.normal.resource;\n                    material.glossMap = assetManifest.gloss.resource;\n                    material.metalness = 0.7;\n\n                    material.diffuseMapTiling.set(7, 7);\n                    material.normalMapTiling.set(7, 7);\n                    material.glossMapTiling.set(7, 7);\n                }\n\n                material.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent('render', {\n                    type: primitiveType,\n                    material: material\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // helper function to create area light including its visual representation in the world\n            function createAreaLight(type: string, shape: number, position: pc.Vec3, scale: number, color: pc.Color, intensity: number, shadows: boolean, range: number) {\n                const lightParent = new pc.Entity();\n                lightParent.translate(position);\n                app.root.addChild(lightParent);\n\n                const light = new pc.Entity();\n                light.addComponent(\"light\", {\n                    type: type,\n                    shape: shape,\n                    color: color,\n                    intensity: intensity,\n                    falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED,\n                    range: range,\n                    castShadows: shadows,\n                    innerConeAngle: 80,\n                    outerConeAngle: 85,\n                    shadowBias: 0.1,\n                    normalOffsetBias: 0.1,\n                    shadowResolution: 2048\n                });\n\n                light.setLocalScale(scale, scale, scale);\n                lightParent.addChild(light);\n\n                // emissive material that is the light source color\n                const brightMaterial = new pc.StandardMaterial();\n                brightMaterial.emissive = color;\n                brightMaterial.useLighting = false;\n                brightMaterial.cull = (shape === pc.LIGHTSHAPE_RECT) ? pc.CULLFACE_NONE : pc.CULLFACE_BACK;\n                brightMaterial.update();\n\n                const brightShape = new pc.Entity();\n                // primitive shape that matches light source shape\n                brightShape.addComponent(\"render\", {\n                    type: (shape === pc.LIGHTSHAPE_SPHERE) ? \"sphere\" : (shape === pc.LIGHTSHAPE_DISK) ? \"cone\" : \"plane\",\n                    material: brightMaterial,\n                    castShadows: type !== \"directional\"\n                });\n                brightShape.setLocalScale(((type === \"directional\") ? scale * range : scale), (shape === pc.LIGHTSHAPE_DISK) ? 0.001 : ((type === \"directional\") ? scale * range : scale), ((type === \"directional\") ? scale * range : scale));\n                lightParent.addChild(brightShape);\n\n                // add black primitive shape if not omni-directional or global directional\n                if (type === \"spot\") {\n                    // black material\n                    const blackMaterial = new pc.StandardMaterial();\n                    blackMaterial.diffuse = new pc.Color(0, 0, 0);\n                    blackMaterial.useLighting = false;\n                    blackMaterial.cull = (shape === pc.LIGHTSHAPE_RECT) ? pc.CULLFACE_NONE : pc.CULLFACE_BACK;\n                    blackMaterial.update();\n\n                    const blackShape = new pc.Entity();\n                    blackShape.addComponent(\"render\", {\n                        type: (shape === pc.LIGHTSHAPE_SPHERE) ? \"sphere\" : (shape === pc.LIGHTSHAPE_DISK) ? \"cone\" : \"plane\",\n                        material: blackMaterial\n                    });\n                    blackShape.setLocalPosition(0, 0.01 / scale, 0);\n                    blackShape.setLocalEulerAngles(-180, 0, 0);\n                    brightShape.addChild(blackShape);\n                }\n\n                return lightParent;\n            }\n\n            const far = 5000.0;\n\n            app.start();\n\n            // enable area lights which are disabled by default for clustered lighting\n            app.scene.lighting.areaLightsEnabled = true;\n\n            // set the loaded area light LUT data\n            const luts = assets.luts.resource;\n            app.setAreaLightLuts(luts.LTC_MAT_1, luts.LTC_MAT_2);\n\n            // set up some general scene rendering properties\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // setup skydome\n            app.scene.skyboxMip = 1;            // use top mipmap level of cubemap (full resolution)\n            app.scene.skyboxIntensity = 0.4;    // make it darker\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // create ground plane\n            createPrimitive(\"plane\", new pc.Vec3(0, 0, 0), new pc.Vec3(20, 20, 20), new pc.Color(0.3, 0.3, 0.3), assets);\n\n            // get the instance of the statue and set up with render component\n            const statue = assets.statue.resource.instantiateRenderEntity();\n            statue.setLocalScale(0.4, 0.4, 0.4);\n            app.root.addChild(statue);\n\n            // Create the camera, which renders entities\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.2, 0.2),\n                fov: 60,\n                farClip: 100000\n            });\n            app.root.addChild(camera);\n            camera.setLocalPosition(0, 2.5, 12);\n            camera.lookAt(0, 0, 0);\n\n            // Create lights with light source shape\n            const light1 = createAreaLight(\"spot\", pc.LIGHTSHAPE_RECT, new pc.Vec3(-3, 4, 0), 4, new pc.Color(1, 1, 1), 2, true, 10);\n            const light2 = createAreaLight(\"omni\", pc.LIGHTSHAPE_SPHERE, new pc.Vec3(5, 2, -2), 2, new pc.Color(1, 1, 0), 2, false, 10);\n            const light3 = createAreaLight(\"directional\", pc.LIGHTSHAPE_DISK, new pc.Vec3(0, 0, 0), 0.2, new pc.Color(0.7, 0.7, 1), 10, true, far);\n\n            // update things each frame\n            let time = 0;\n            app.on(\"update\", function (dt: number) {\n                time += dt;\n\n                const factor1 = (Math.sin(time) + 1) * 0.5;\n                const factor2 = (Math.sin(time * 0.6) + 1) * 0.5;\n                const factor3 = (Math.sin(time * 0.4) + 1) * 0.5;\n\n                if (light1) {\n                    light1.setLocalEulerAngles(pc.math.lerp(-90, 110, factor1), 0, 90);\n                    light1.setLocalPosition(-4, pc.math.lerp(2, 4, factor3), pc.math.lerp(-2, 2, factor2));\n                }\n\n                if (light2) {\n                    light2.setLocalPosition(5, pc.math.lerp(1, 3, factor1), pc.math.lerp(-2, 2, factor2));\n                }\n\n                if (light3) {\n                    light3.setLocalEulerAngles(pc.math.lerp(230, 310, factor2), pc.math.lerp(-30, 0, factor3), 90);\n\n                    const dir = light3.getWorldTransform().getY();\n                    const campos = camera.getPosition();\n\n                    light3.setPosition(campos.x + dir.x * far, campos.y + dir.y * far, campos.z + dir.z * far);\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        color: new pc.Asset(\"color\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-color.jpg\",\n        }),\n        normal: new pc.Asset(\"normal\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-normal.jpg\",\n        }),\n        gloss: new pc.Asset(\"gloss\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-gloss.jpg\",\n        }),\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n        luts: new pc.Asset(\"luts\", \"json\", {\n            url: \"/static/assets/json/area-light-luts.json\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.JsonHandler,\n            // @ts-ignore\n            pc.CubemapHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            // helper function to create a primitive with shape type, position, scale, color\n            function createPrimitive(\n                primitiveType,\n                position,\n                scale,\n                color,\n                assetManifest\n            ) {\n                // create material of specified color\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                material.gloss = 0.8;\n                material.useMetalness = true;\n\n                if (assetManifest) {\n                    material.diffuseMap = assetManifest.color.resource;\n                    material.normalMap = assetManifest.normal.resource;\n                    material.glossMap = assetManifest.gloss.resource;\n                    material.metalness = 0.7;\n\n                    material.diffuseMapTiling.set(7, 7);\n                    material.normalMapTiling.set(7, 7);\n                    material.glossMapTiling.set(7, 7);\n                }\n\n                material.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent(\"render\", {\n                    type: primitiveType,\n                    material: material,\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // helper function to create area light including its visual representation in the world\n            function createAreaLight(\n                type,\n                shape,\n                position,\n                scale,\n                color,\n                intensity,\n                shadows,\n                range\n            ) {\n                const lightParent = new pc.Entity();\n                lightParent.translate(position);\n                app.root.addChild(lightParent);\n\n                const light = new pc.Entity();\n                light.addComponent(\"light\", {\n                    type: type,\n                    shape: shape,\n                    color: color,\n                    intensity: intensity,\n                    falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED,\n                    range: range,\n                    castShadows: shadows,\n                    innerConeAngle: 80,\n                    outerConeAngle: 85,\n                    shadowBias: 0.1,\n                    normalOffsetBias: 0.1,\n                    shadowResolution: 2048,\n                });\n\n                light.setLocalScale(scale, scale, scale);\n                lightParent.addChild(light);\n\n                // emissive material that is the light source color\n                const brightMaterial = new pc.StandardMaterial();\n                brightMaterial.emissive = color;\n                brightMaterial.useLighting = false;\n                brightMaterial.cull =\n                    shape === pc.LIGHTSHAPE_RECT\n                        ? pc.CULLFACE_NONE\n                        : pc.CULLFACE_BACK;\n                brightMaterial.update();\n\n                const brightShape = new pc.Entity();\n                // primitive shape that matches light source shape\n                brightShape.addComponent(\"render\", {\n                    type:\n                        shape === pc.LIGHTSHAPE_SPHERE\n                            ? \"sphere\"\n                            : shape === pc.LIGHTSHAPE_DISK\n                            ? \"cone\"\n                            : \"plane\",\n                    material: brightMaterial,\n                    castShadows: type !== \"directional\",\n                });\n\n                brightShape.setLocalScale(\n                    type === \"directional\" ? scale * range : scale,\n                    shape === pc.LIGHTSHAPE_DISK\n                        ? 0.001\n                        : type === \"directional\"\n                        ? scale * range\n                        : scale,\n                    type === \"directional\" ? scale * range : scale\n                );\n                lightParent.addChild(brightShape);\n\n                // add black primitive shape if not omni-directional or global directional\n                if (type === \"spot\") {\n                    // black material\n                    const blackMaterial = new pc.StandardMaterial();\n                    blackMaterial.diffuse = new pc.Color(0, 0, 0);\n                    blackMaterial.useLighting = false;\n                    blackMaterial.cull =\n                        shape === pc.LIGHTSHAPE_RECT\n                            ? pc.CULLFACE_NONE\n                            : pc.CULLFACE_BACK;\n                    blackMaterial.update();\n\n                    const blackShape = new pc.Entity();\n                    blackShape.addComponent(\"render\", {\n                        type:\n                            shape === pc.LIGHTSHAPE_SPHERE\n                                ? \"sphere\"\n                                : shape === pc.LIGHTSHAPE_DISK\n                                ? \"cone\"\n                                : \"plane\",\n                        material: blackMaterial,\n                    });\n\n                    blackShape.setLocalPosition(0, 0.01 / scale, 0);\n                    blackShape.setLocalEulerAngles(-180, 0, 0);\n                    brightShape.addChild(blackShape);\n                }\n\n                return lightParent;\n            }\n\n            const far = 5000.0;\n\n            app.start();\n\n            // enable area lights which are disabled by default for clustered lighting\n            app.scene.lighting.areaLightsEnabled = true;\n\n            // set the loaded area light LUT data\n            const luts = assets.luts.resource;\n            app.setAreaLightLuts(luts.LTC_MAT_1, luts.LTC_MAT_2);\n\n            // set up some general scene rendering properties\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // setup skydome\n            app.scene.skyboxMip = 1; // use top mipmap level of cubemap (full resolution)\n            app.scene.skyboxIntensity = 0.4; // make it darker\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // create ground plane\n            createPrimitive(\n                \"plane\",\n                new pc.Vec3(0, 0, 0),\n                new pc.Vec3(20, 20, 20),\n                new pc.Color(0.3, 0.3, 0.3),\n                assets\n            );\n\n            // get the instance of the statue and set up with render component\n            const statue = assets.statue.resource.instantiateRenderEntity();\n            statue.setLocalScale(0.4, 0.4, 0.4);\n            app.root.addChild(statue);\n\n            // Create the camera, which renders entities\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.2, 0.2),\n                fov: 60,\n                farClip: 100000,\n            });\n\n            app.root.addChild(camera);\n            camera.setLocalPosition(0, 2.5, 12);\n            camera.lookAt(0, 0, 0);\n\n            // Create lights with light source shape\n            const light1 = createAreaLight(\n                \"spot\",\n                pc.LIGHTSHAPE_RECT,\n                new pc.Vec3(-3, 4, 0),\n                4,\n                new pc.Color(1, 1, 1),\n                2,\n                true,\n                10\n            );\n            const light2 = createAreaLight(\n                \"omni\",\n                pc.LIGHTSHAPE_SPHERE,\n                new pc.Vec3(5, 2, -2),\n                2,\n                new pc.Color(1, 1, 0),\n                2,\n                false,\n                10\n            );\n            const light3 = createAreaLight(\n                \"directional\",\n                pc.LIGHTSHAPE_DISK,\n                new pc.Vec3(0, 0, 0),\n                0.2,\n                new pc.Color(0.7, 0.7, 1),\n                10,\n                true,\n                far\n            );\n\n            // update things each frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                const factor1 = (Math.sin(time) + 1) * 0.5;\n                const factor2 = (Math.sin(time * 0.6) + 1) * 0.5;\n                const factor3 = (Math.sin(time * 0.4) + 1) * 0.5;\n\n                if (light1) {\n                    light1.setLocalEulerAngles(\n                        pc.math.lerp(-90, 110, factor1),\n                        0,\n                        90\n                    );\n                    light1.setLocalPosition(\n                        -4,\n                        pc.math.lerp(2, 4, factor3),\n                        pc.math.lerp(-2, 2, factor2)\n                    );\n                }\n\n                if (light2) {\n                    light2.setLocalPosition(\n                        5,\n                        pc.math.lerp(1, 3, factor1),\n                        pc.math.lerp(-2, 2, factor2)\n                    );\n                }\n\n                if (light3) {\n                    light3.setLocalEulerAngles(\n                        pc.math.lerp(230, 310, factor2),\n                        pc.math.lerp(-30, 0, factor3),\n                        90\n                    );\n\n                    const dir = light3.getWorldTransform().getY();\n                    const campos = camera.getPosition();\n\n                    light3.setPosition(\n                        campos.x + dir.x * far,\n                        campos.y + dir.y * far,\n                        campos.z + dir.z * far\n                    );\n                }\n            });\n        });\n    });\n}\n","nameSlug":"area-lights","categorySlug":"graphics"},"area-picker":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'bloom': new pc.Asset('bloom', 'script', { url: '/static/scripts/posteffects/posteffect-bloom.js' }),\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.TextureHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // setup skydome\n            app.scene.skyboxMip = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxIntensity = 0.1;\n\n            // use a quarter resolution for picker render target (faster but less precise - can miss small objects)\n            const pickerScale = 0.25;\n            let mouseX = 0, mouseY = 0;\n\n            // generate a box area with specified size of random primitives\n            const size = 30;\n            const halfSize = size * 0.5;\n            for (let i = 0; i < 300; i++) {\n                const shape = Math.random() < 0.5 ? \"cylinder\" : \"sphere\";\n                const position = new pc.Vec3(Math.random() * size - halfSize, Math.random() * size - halfSize, Math.random() * size - halfSize);\n                const scale = 1 + Math.random();\n                const entity = createPrimitive(shape, position, new pc.Vec3(scale, scale, scale));\n                app.root.addChild(entity);\n            }\n\n            // handle mouse move event and store current mouse position to use as a position to pick from the scene\n            new pc.Mouse(document.body).on(pc.EVENT_MOUSEMOVE, function (event: any) {\n                mouseX = event.x;\n                mouseY = event.y;\n            }, this);\n\n            // Create an instance of the picker class\n            // Lets use quarter of the resolution to improve performance - this will miss very small objects, but it's ok in our case\n            const picker = new pc.Picker(app, canvas.clientWidth * pickerScale, canvas.clientHeight * pickerScale);\n\n            // helper function to create a primitive with shape type, position, scale\n            function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3) {\n                // create material of random color\n                const material = new pc.StandardMaterial();\n                material.diffuse = new pc.Color(Math.random(), Math.random(), Math.random());\n                material.gloss = 0.6;\n                material.metalness = 0.4;\n                material.useMetalness = true;\n                material.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent('render', {\n                    type: primitiveType,\n                    material: material\n                });\n\n                // set position and scale\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n\n                return primitive;\n            }\n\n            // Create main camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1)\n            });\n\n            // add bloom postprocessing (this is ignored by the picker)\n            camera.addComponent(\"script\");\n            camera.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1,\n                    bloomThreshold: 0.7,\n                    blurAmount: 4\n                }\n            });\n            app.root.addChild(camera);\n\n            // function to draw a 2D rectangle in the screen space coordinates\n            function drawRectangle(x: number, y: number, w: number, h: number) {\n\n                const pink = new pc.Color(1, 0.02, 0.58);\n\n                // transform 4 2D screen points into world space\n                const pt0 = camera.camera.screenToWorld(x, y, 1);\n                const pt1 = camera.camera.screenToWorld(x + w, y, 1);\n                const pt2 = camera.camera.screenToWorld(x + w, y + h, 1);\n                const pt3 = camera.camera.screenToWorld(x, y + h, 1);\n\n                // and connect them using white lines\n                const points = [pt0, pt1,  pt1, pt2,  pt2, pt3,  pt3, pt0];\n                const colors = [pink, pink, pink, pink, pink, pink, pink, pink];\n                app.drawLines(points, colors);\n            }\n\n            // sets material emissive color to specified color\n            function highlightMaterial(material: pc.StandardMaterial, color: pc.Color) {\n                material.emissive = color;\n                material.update();\n            }\n\n            // array of highlighted materials\n            const highlights: pc.StandardMaterial[] = [];\n\n            // update each frame\n            let time = 0;\n            app.on(\"update\", function (dt: number) {\n\n                time += dt * 0.1;\n\n                // orbit the camera around\n                if (!camera) {\n                    return;\n                }\n\n                camera.setLocalPosition(40 * Math.sin(time), 0, 40 * Math.cos(time));\n                camera.lookAt(pc.Vec3.ZERO);\n\n                // turn all previously highlighted meshes to black at the start of the frame\n                for (let h = 0; h < highlights.length; h++) {\n                    highlightMaterial(highlights[h], pc.Color.BLACK);\n                }\n                highlights.length = 0;\n\n                // Make sure the picker is the right size, and prepare it, which renders meshes into its render target\n                if (picker) {\n                    picker.resize(canvas.clientWidth * pickerScale, canvas.clientHeight * pickerScale);\n                    picker.prepare(camera.camera, app.scene);\n                }\n\n                // areas we want to sample - two larger rectangles, one small square, and one pixel at a mouse position\n                // assign them different highlight colors as well\n                const areas = [\n                    {\n                        pos: new pc.Vec2(canvas.clientWidth * 0.3, canvas.clientHeight * 0.3),\n                        size: new pc.Vec2(100, 200),\n                        color: pc.Color.YELLOW\n                    },\n                    {\n                        pos: new pc.Vec2(canvas.clientWidth * 0.6, canvas.clientHeight * 0.7),\n                        size: new pc.Vec2(200, 20),\n                        color: pc.Color.CYAN\n                    },\n                    {\n                        pos: new pc.Vec2(canvas.clientWidth * 0.8, canvas.clientHeight * 0.3),\n                        size: new pc.Vec2(5, 5),\n                        color: pc.Color.MAGENTA\n                    },\n                    {\n                        // area based on mouse position\n                        pos: new pc.Vec2(mouseX, mouseY),\n                        size: new pc.Vec2(1, 1),\n                        color: pc.Color.RED\n                    }\n                ];\n\n                // process all areas\n                for (let a = 0; a < areas.length; a++) {\n                    const areaPos = areas[a].pos;\n                    const areaSize = areas[a].size;\n                    const color = areas[a].color;\n\n                    // display 2D rectangle around it\n                    drawRectangle(areaPos.x, areaPos.y, areaSize.x, areaSize.y);\n\n                    // get list of meshInstances inside the area from the picker\n                    // this scans the pixels inside the render target and maps the id value stored there into meshInstances\n                    const selection = picker.getSelection(areaPos.x * pickerScale, areaPos.y * pickerScale, areaSize.x * pickerScale, areaSize.y * pickerScale);\n\n                    // process all meshInstances it found - highlight them to appropriate color for the area\n                    for (let s = 0; s < selection.length; s++) {\n                        if (selection[s]) {\n                            const material = selection[s].material as pc.StandardMaterial;\n                            highlightMaterial(material, color);\n                            highlights.push(material);\n                        }\n                    }\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        bloom: new pc.Asset(\"bloom\", \"script\", {\n            url: \"/static/scripts/posteffects/posteffect-bloom.js\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.TextureHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // setup skydome\n            app.scene.skyboxMip = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxIntensity = 0.1;\n\n            // use a quarter resolution for picker render target (faster but less precise - can miss small objects)\n            const pickerScale = 0.25;\n            let mouseX = 0,\n                mouseY = 0;\n\n            // generate a box area with specified size of random primitives\n            const size = 30;\n            const halfSize = size * 0.5;\n            for (let i = 0; i < 300; i++) {\n                const shape = Math.random() < 0.5 ? \"cylinder\" : \"sphere\";\n                const position = new pc.Vec3(\n                    Math.random() * size - halfSize,\n                    Math.random() * size - halfSize,\n                    Math.random() * size - halfSize\n                );\n                const scale = 1 + Math.random();\n                const entity = createPrimitive(\n                    shape,\n                    position,\n                    new pc.Vec3(scale, scale, scale)\n                );\n                app.root.addChild(entity);\n            }\n\n            // handle mouse move event and store current mouse position to use as a position to pick from the scene\n            new pc.Mouse(document.body).on(\n                pc.EVENT_MOUSEMOVE,\n                function (event) {\n                    mouseX = event.x;\n                    mouseY = event.y;\n                },\n                this\n            );\n\n            // Create an instance of the picker class\n            // Lets use quarter of the resolution to improve performance - this will miss very small objects, but it's ok in our case\n            const picker = new pc.Picker(\n                app,\n                canvas.clientWidth * pickerScale,\n                canvas.clientHeight * pickerScale\n            );\n\n            // helper function to create a primitive with shape type, position, scale\n            function createPrimitive(primitiveType, position, scale) {\n                // create material of random color\n                const material = new pc.StandardMaterial();\n                material.diffuse = new pc.Color(\n                    Math.random(),\n                    Math.random(),\n                    Math.random()\n                );\n                material.gloss = 0.6;\n                material.metalness = 0.4;\n                material.useMetalness = true;\n                material.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent(\"render\", {\n                    type: primitiveType,\n                    material: material,\n                });\n\n                // set position and scale\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n\n                return primitive;\n            }\n\n            // Create main camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1),\n            });\n\n            // add bloom postprocessing (this is ignored by the picker)\n            camera.addComponent(\"script\");\n            camera.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1,\n                    bloomThreshold: 0.7,\n                    blurAmount: 4,\n                },\n            });\n\n            app.root.addChild(camera);\n\n            // function to draw a 2D rectangle in the screen space coordinates\n            function drawRectangle(x, y, w, h) {\n                const pink = new pc.Color(1, 0.02, 0.58);\n\n                // transform 4 2D screen points into world space\n                const pt0 = camera.camera.screenToWorld(x, y, 1);\n                const pt1 = camera.camera.screenToWorld(x + w, y, 1);\n                const pt2 = camera.camera.screenToWorld(x + w, y + h, 1);\n                const pt3 = camera.camera.screenToWorld(x, y + h, 1);\n\n                // and connect them using white lines\n                const points = [pt0, pt1, pt1, pt2, pt2, pt3, pt3, pt0];\n                const colors = [pink, pink, pink, pink, pink, pink, pink, pink];\n                app.drawLines(points, colors);\n            }\n\n            // sets material emissive color to specified color\n            function highlightMaterial(material, color) {\n                material.emissive = color;\n                material.update();\n            }\n\n            // array of highlighted materials\n            const highlights = [];\n\n            // update each frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt * 0.1;\n\n                // orbit the camera around\n                if (!camera) {\n                    return;\n                }\n\n                camera.setLocalPosition(\n                    40 * Math.sin(time),\n                    0,\n                    40 * Math.cos(time)\n                );\n                camera.lookAt(pc.Vec3.ZERO);\n\n                // turn all previously highlighted meshes to black at the start of the frame\n                for (let h = 0; h < highlights.length; h++) {\n                    highlightMaterial(highlights[h], pc.Color.BLACK);\n                }\n                highlights.length = 0;\n\n                // Make sure the picker is the right size, and prepare it, which renders meshes into its render target\n                if (picker) {\n                    picker.resize(\n                        canvas.clientWidth * pickerScale,\n                        canvas.clientHeight * pickerScale\n                    );\n                    picker.prepare(camera.camera, app.scene);\n                }\n\n                // areas we want to sample - two larger rectangles, one small square, and one pixel at a mouse position\n                // assign them different highlight colors as well\n                const areas = [\n                    {\n                        pos: new pc.Vec2(\n                            canvas.clientWidth * 0.3,\n                            canvas.clientHeight * 0.3\n                        ),\n                        size: new pc.Vec2(100, 200),\n                        color: pc.Color.YELLOW,\n                    },\n\n                    {\n                        pos: new pc.Vec2(\n                            canvas.clientWidth * 0.6,\n                            canvas.clientHeight * 0.7\n                        ),\n                        size: new pc.Vec2(200, 20),\n                        color: pc.Color.CYAN,\n                    },\n\n                    {\n                        pos: new pc.Vec2(\n                            canvas.clientWidth * 0.8,\n                            canvas.clientHeight * 0.3\n                        ),\n                        size: new pc.Vec2(5, 5),\n                        color: pc.Color.MAGENTA,\n                    },\n\n                    {\n                        // area based on mouse position\n                        pos: new pc.Vec2(mouseX, mouseY),\n                        size: new pc.Vec2(1, 1),\n                        color: pc.Color.RED,\n                    },\n                ];\n\n                // process all areas\n                for (let a = 0; a < areas.length; a++) {\n                    const areaPos = areas[a].pos;\n                    const areaSize = areas[a].size;\n                    const color = areas[a].color;\n\n                    // display 2D rectangle around it\n                    drawRectangle(areaPos.x, areaPos.y, areaSize.x, areaSize.y);\n\n                    // get list of meshInstances inside the area from the picker\n                    // this scans the pixels inside the render target and maps the id value stored there into meshInstances\n                    const selection = picker.getSelection(\n                        areaPos.x * pickerScale,\n                        areaPos.y * pickerScale,\n                        areaSize.x * pickerScale,\n                        areaSize.y * pickerScale\n                    );\n\n                    // process all meshInstances it found - highlight them to appropriate color for the area\n                    for (let s = 0; s < selection.length; s++) {\n                        if (selection[s]) {\n                            const material = selection[s].material;\n                            highlightMaterial(material, color);\n                            highlights.push(material);\n                        }\n                    }\n                }\n            });\n        });\n    });\n}\n","nameSlug":"area-picker","categorySlug":"graphics"},"asset-viewer":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data: any): void {\n\n    const assets = {\n        orbitCamera: new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' }),\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        dish: new pc.Asset('dish', 'container', { url: '/static/assets/models/IridescentDishWithOlives.glb' }),\n        mosquito: new pc.Asset('mosquito', 'container', { url: '/static/assets/models/MosquitoInAmber.glb' }),\n        sheen: new pc.Asset('sheen', 'container', { url: '/static/assets/models/SheenChair.glb' }),\n        lamp: new pc.Asset('lamp', 'container', { url: '/static/assets/models/StainedGlassLamp.glb' }),\n        font: new pc.Asset('font', 'font', { url: '/static/assets/fonts/arial.json' }),\n        checkerboard: new pc.Asset('checkerboard', 'texture', { url: '/static/assets/textures/checkboard.png' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.JsonHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // Depth layer is where the framebuffer is copied to a texture to be used in the following layers.\n            // Move the depth layer to take place after World and Skydome layers, to capture both of them.\n            const depthLayer = app.scene.layers.getLayerById(pc.LAYERID_DEPTH);\n            app.scene.layers.remove(depthLayer);\n            app.scene.layers.insertOpaque(depthLayer, 2);\n\n            const createText = (fontAsset: pc.Asset, message: string, x: number, z: number) => {\n                // Create a text element-based entity\n                const text = new pc.Entity();\n                text.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    fontAsset: fontAsset,\n                    fontSize: 0.2,\n                    pivot: [0.5, 0.5],\n                    text: message,\n                    type: pc.ELEMENTTYPE_TEXT\n                });\n                text.setLocalPosition(x, -0.9, z);\n                text.setLocalEulerAngles(-90, 0, 0);\n                app.root.addChild(text);\n            };\n\n            const createVisual = (resource: any, pos: pc.Vec3, scale: number) => {\n\n                const entity = resource.instantiateRenderEntity({\n                    castShadows: true\n                });\n                entity.setLocalScale(scale, scale, scale);\n                entity.setLocalPosition(pos);\n                app.root.addChild(entity);\n\n                return entity;\n            };\n\n            let currentAssetIndex = 0;\n\n            // create the scene by instantiating glbs\n            const mosquito = createVisual(assets.mosquito.resource, new pc.Vec3(0, 0.5, 0), 25);\n            createText(assets.font, \"KHR_materials_volume\\nKHR_materials_ior\\nKHR_materials_transmission\", 0, 2);\n\n            const dish = createVisual(assets.dish.resource, new pc.Vec3(-4, -0.5, 0), 9);\n            createText(assets.font, \"KHR_materials_specular\\nKHR_materials_volume\\nKHR_materials_ior\\nKHR_materials_transmission\", -4, 2);\n\n            const sheen1 = createVisual(assets.sheen.resource, new pc.Vec3(8, -1.0, 0), 4);\n            createText(assets.font, \"Mango Velvet\", 8, 1);\n\n            const sheen2 = createVisual(assets.sheen.resource, new pc.Vec3(4, -1.0, 0), 4);\n            assets.sheen.resource.applyMaterialVariant(sheen2, \"Peacock Velvet\");\n            createText(assets.font, \"KHR_materials_sheen\\nKHR_materials_variants\", 5.5, 2);\n            createText(assets.font, \"Peacock Velvet\", 4, 1);\n\n            const lamp = createVisual(assets.lamp.resource, new pc.Vec3(-8, -1.0, 0), 5);\n            createText(assets.font, \"Lamp on\", -8, 1);\n\n            const lamp2 = createVisual(assets.lamp.resource, new pc.Vec3(-11, -1.0, 0), 5);\n            assets.lamp.resource.applyMaterialVariant(lamp2, \"Lamp off\");\n            createText(assets.font, \"Lamp off\", -11, 1);\n            createText(assets.font, \"KHR_materials_transmission\\nKHR_materials_ior\\nKHR_materials_volume\\nKHR_materials_variants\\nKHR_materials_clearcoat\", -9.5, 2);\n\n            const assetList = [\n                lamp2, lamp, dish, mosquito, sheen2, sheen1\n            ];\n\n            const material = new pc.StandardMaterial();\n            material.diffuseMap = assets.checkerboard.resource;\n            material.diffuseMapTiling = new pc.Vec2(16, 6);\n            material.update();\n            const plane = new pc.Entity();\n            plane.addComponent('render', {\n                type: 'plane',\n                material: material\n            });\n            plane.setLocalScale(new pc.Vec3(25, 0, 10));\n            plane.setLocalPosition(0, -1.0, 0);\n            app.root.addChild(plane);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n            });\n            camera.setLocalPosition(0, 55, 160);\n\n            camera.camera.requestSceneColorMap(true);\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    distanceMin: 8,\n                    distanceMax: 50\n                }\n            });\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            const directionalLight = new pc.Entity();\n            directionalLight.addComponent(\"light\", {\n                type: \"directional\",\n                color: pc.Color.WHITE,\n                castShadows: true,\n                intensity: 1,\n                shadowBias: 0.2,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048\n            });\n            directionalLight.setEulerAngles(45, 180, 0);\n            app.root.addChild(directionalLight);\n\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.skyboxMip = 1;\n            app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(0, 70, 0);\n            app.scene.skyboxIntensity = 1.5;\n\n            window.addEventListener(\"touchstart\", (event) => {\n                const touch = event.touches[0];\n                const entity = data.get('selection.focusEntity');\n                let newEntity = entity;\n                if (touch.clientX <= canvas.width * 0.2) {\n                    newEntity = Math.max(0, entity - 1);\n                } else if (touch.clientX >= canvas.width * 0.8) {\n                    newEntity = Math.min(entity + 1, assetList.length);\n                }\n                if (entity !== newEntity) {\n                    data.set('selection.focusEntity', newEntity);\n                }\n            }, false);\n\n            function jumpToAsset(offset: number) {\n\n                // wrap around\n                const count = assetList.length - 1;\n                currentAssetIndex += offset;\n                if (currentAssetIndex < 0) currentAssetIndex = count;\n                if (currentAssetIndex > count) currentAssetIndex = 0;\n\n                const pos = assetList[currentAssetIndex].getLocalPosition();\n                const newPos = new pc.Vec3(0, 2.0, 6.0).add(pos);\n                camera.setLocalPosition(newPos);\n\n                // @ts-ignore engine-tsd\n                camera.script.orbitCamera.focusEntity = assetList[currentAssetIndex];\n            }\n\n            // focus on mosquito\n            jumpToAsset(3);\n\n            data.on('previous', function () {\n                jumpToAsset(-1);\n            });\n\n            // remove light button handler\n            data.on('next', function () {\n                jumpToAsset(1);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    const assets = {\n        orbitCamera: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/orbit-camera.js\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        dish: new pc.Asset(\"dish\", \"container\", {\n            url: \"/static/assets/models/IridescentDishWithOlives.glb\",\n        }),\n        mosquito: new pc.Asset(\"mosquito\", \"container\", {\n            url: \"/static/assets/models/MosquitoInAmber.glb\",\n        }),\n        sheen: new pc.Asset(\"sheen\", \"container\", {\n            url: \"/static/assets/models/SheenChair.glb\",\n        }),\n        lamp: new pc.Asset(\"lamp\", \"container\", {\n            url: \"/static/assets/models/StainedGlassLamp.glb\",\n        }),\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/arial.json\",\n        }),\n        checkerboard: new pc.Asset(\"checkerboard\", \"texture\", {\n            url: \"/static/assets/textures/checkboard.png\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.JsonHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // Depth layer is where the framebuffer is copied to a texture to be used in the following layers.\n            // Move the depth layer to take place after World and Skydome layers, to capture both of them.\n            const depthLayer = app.scene.layers.getLayerById(pc.LAYERID_DEPTH);\n            app.scene.layers.remove(depthLayer);\n            app.scene.layers.insertOpaque(depthLayer, 2);\n\n            const createText = (fontAsset, message, x, z) => {\n                // Create a text element-based entity\n                const text = new pc.Entity();\n                text.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    fontAsset: fontAsset,\n                    fontSize: 0.2,\n                    pivot: [0.5, 0.5],\n                    text: message,\n                    type: pc.ELEMENTTYPE_TEXT,\n                });\n\n                text.setLocalPosition(x, -0.9, z);\n                text.setLocalEulerAngles(-90, 0, 0);\n                app.root.addChild(text);\n            };\n\n            const createVisual = (resource, pos, scale) => {\n                const entity = resource.instantiateRenderEntity({\n                    castShadows: true,\n                });\n\n                entity.setLocalScale(scale, scale, scale);\n                entity.setLocalPosition(pos);\n                app.root.addChild(entity);\n\n                return entity;\n            };\n\n            let currentAssetIndex = 0;\n\n            // create the scene by instantiating glbs\n            const mosquito = createVisual(\n                assets.mosquito.resource,\n                new pc.Vec3(0, 0.5, 0),\n                25\n            );\n            createText(\n                assets.font,\n                \"KHR_materials_volume\\nKHR_materials_ior\\nKHR_materials_transmission\",\n                0,\n                2\n            );\n\n            const dish = createVisual(\n                assets.dish.resource,\n                new pc.Vec3(-4, -0.5, 0),\n                9\n            );\n            createText(\n                assets.font,\n                \"KHR_materials_specular\\nKHR_materials_volume\\nKHR_materials_ior\\nKHR_materials_transmission\",\n                -4,\n                2\n            );\n\n            const sheen1 = createVisual(\n                assets.sheen.resource,\n                new pc.Vec3(8, -1.0, 0),\n                4\n            );\n            createText(assets.font, \"Mango Velvet\", 8, 1);\n\n            const sheen2 = createVisual(\n                assets.sheen.resource,\n                new pc.Vec3(4, -1.0, 0),\n                4\n            );\n            assets.sheen.resource.applyMaterialVariant(\n                sheen2,\n                \"Peacock Velvet\"\n            );\n            createText(\n                assets.font,\n                \"KHR_materials_sheen\\nKHR_materials_variants\",\n                5.5,\n                2\n            );\n            createText(assets.font, \"Peacock Velvet\", 4, 1);\n\n            const lamp = createVisual(\n                assets.lamp.resource,\n                new pc.Vec3(-8, -1.0, 0),\n                5\n            );\n            createText(assets.font, \"Lamp on\", -8, 1);\n\n            const lamp2 = createVisual(\n                assets.lamp.resource,\n                new pc.Vec3(-11, -1.0, 0),\n                5\n            );\n            assets.lamp.resource.applyMaterialVariant(lamp2, \"Lamp off\");\n            createText(assets.font, \"Lamp off\", -11, 1);\n            createText(\n                assets.font,\n                \"KHR_materials_transmission\\nKHR_materials_ior\\nKHR_materials_volume\\nKHR_materials_variants\\nKHR_materials_clearcoat\",\n                -9.5,\n                2\n            );\n\n            const assetList = [lamp2, lamp, dish, mosquito, sheen2, sheen1];\n\n            const material = new pc.StandardMaterial();\n            material.diffuseMap = assets.checkerboard.resource;\n            material.diffuseMapTiling = new pc.Vec2(16, 6);\n            material.update();\n            const plane = new pc.Entity();\n            plane.addComponent(\"render\", {\n                type: \"plane\",\n                material: material,\n            });\n\n            plane.setLocalScale(new pc.Vec3(25, 0, 10));\n            plane.setLocalPosition(0, -1.0, 0);\n            app.root.addChild(plane);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {});\n\n            camera.setLocalPosition(0, 55, 160);\n\n            camera.camera.requestSceneColorMap(true);\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    distanceMin: 8,\n                    distanceMax: 50,\n                },\n            });\n\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            const directionalLight = new pc.Entity();\n            directionalLight.addComponent(\"light\", {\n                type: \"directional\",\n                color: pc.Color.WHITE,\n                castShadows: true,\n                intensity: 1,\n                shadowBias: 0.2,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048,\n            });\n\n            directionalLight.setEulerAngles(45, 180, 0);\n            app.root.addChild(directionalLight);\n\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.skyboxMip = 1;\n            app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(\n                0,\n                70,\n                0\n            );\n            app.scene.skyboxIntensity = 1.5;\n\n            window.addEventListener(\n                \"touchstart\",\n                (event) => {\n                    const touch = event.touches[0];\n                    const entity = data.get(\"selection.focusEntity\");\n                    let newEntity = entity;\n                    if (touch.clientX <= canvas.width * 0.2) {\n                        newEntity = Math.max(0, entity - 1);\n                    } else if (touch.clientX >= canvas.width * 0.8) {\n                        newEntity = Math.min(entity + 1, assetList.length);\n                    }\n                    if (entity !== newEntity) {\n                        data.set(\"selection.focusEntity\", newEntity);\n                    }\n                },\n                false\n            );\n\n            function jumpToAsset(offset) {\n                // wrap around\n                const count = assetList.length - 1;\n                currentAssetIndex += offset;\n                if (currentAssetIndex < 0) currentAssetIndex = count;\n                if (currentAssetIndex > count) currentAssetIndex = 0;\n\n                const pos = assetList[currentAssetIndex].getLocalPosition();\n                const newPos = new pc.Vec3(0, 2.0, 6.0).add(pos);\n                camera.setLocalPosition(newPos);\n\n                // @ts-ignore engine-tsd\n                camera.script.orbitCamera.focusEntity =\n                    assetList[currentAssetIndex];\n            }\n\n            // focus on mosquito\n            jumpToAsset(3);\n\n            data.on(\"previous\", function () {\n                jumpToAsset(-1);\n            });\n\n            // remove light button handler\n            data.on(\"next\", function () {\n                jumpToAsset(1);\n            });\n        });\n    });\n}\n","nameSlug":"asset-viewer","categorySlug":"graphics"},"batching-dynamic":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        // @ts-ignore\n        createOptions.batchManager = pc.BatchManager;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.start();\n\n        window.addEventListener(\"resize\", function () {\n            app.resizeCanvas(canvas.width, canvas.height);\n        });\n\n        // create two material\n        const material1 = new pc.StandardMaterial();\n        material1.diffuse = new pc.Color(1, 1, 0);\n        material1.gloss = 0.4;\n        material1.metalness = 0.5;\n        material1.useMetalness = true;\n        material1.update();\n\n        const material2 = new pc.StandardMaterial();\n        material2.diffuse = new pc.Color(0, 1, 1);\n        material2.gloss = 0.4;\n        material2.metalness = 0.5;\n        material2.useMetalness = true;\n        material2.update();\n\n        // create a single BatchGroup. Make it dynamic to allow batched meshes to be freely moved every frame.\n        const batchGroup = app.batcher.addGroup(\"Meshes\", true, 100);\n\n        // create various primitive instances using one of the two materials\n        const numInstances = 500;\n        const shapes = [\"box\", \"cone\", \"cylinder\", \"sphere\", \"capsule\"];\n        const entities: any = [];\n        for (let i = 0; i < numInstances; i++) {\n\n            // random shape\n            const shapeName = shapes[Math.floor(Math.random() * shapes.length)];\n\n            const entity = new pc.Entity();\n\n            // create render component\n            entity.addComponent(\"render\", {\n                type: shapeName,\n                material: Math.random() < 0.5 ? material1 : material2,\n                castShadows: true,\n\n                // add it to the batchGroup - this instructs engine to try and render these meshes in a small number of draw calls.\n                // there will be at least 2 draw calls, one for each material\n                batchGroupId: batchGroup.id\n            });\n\n            // add entity for rendering\n            app.root.addChild(entity);\n\n            // keep in the list to adjust positions each frame\n            entities.push(entity);\n        }\n\n        // Create an Entity for the ground\n        const ground = new pc.Entity();\n        ground.addComponent(\"render\", {\n            type: \"box\",\n            material: material2\n        });\n        ground.setLocalScale(150, 1, 150);\n        ground.setLocalPosition(0, -26, 0);\n        app.root.addChild(ground);\n\n        // Create an entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.2, 0.2, 0.2)\n        });\n        app.root.addChild(camera);\n\n        // Create an entity with a directional light component\n        // Add it as a child of a camera to rotate with the camera\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\",\n            castShadows: true,\n            shadowBias: 0.2,\n            normalOffsetBias: 0.06,\n            shadowDistance: 150\n        });\n        camera.addChild(light);\n        light.setLocalEulerAngles(15, 30, 0);\n\n        // Set an update function on the app's update event\n        let time = 0;\n        app.on(\"update\", function (dt: number) {\n            time += dt;\n\n            // move all entities along orbits\n            for (let i = 0; i < entities.length; i++) {\n                const radius = 5 + 20.0 * i / numInstances;\n                const speed = i / numInstances;\n                entities[i].setLocalPosition(radius * Math.sin(i + time * speed), radius * Math.cos(i + time * speed), radius * Math.cos(i + 2 * time * speed));\n                entities[i].lookAt(pc.Vec3.ZERO);\n            }\n\n            // orbit camera around\n            camera.setLocalPosition(70 * Math.sin(time), 0, 70 * Math.cos(time));\n            camera.lookAt(pc.Vec3.ZERO);\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        // @ts-ignore\n        createOptions.batchManager = pc.BatchManager;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.start();\n\n        window.addEventListener(\"resize\", function () {\n            app.resizeCanvas(canvas.width, canvas.height);\n        });\n\n        // create two material\n        const material1 = new pc.StandardMaterial();\n        material1.diffuse = new pc.Color(1, 1, 0);\n        material1.gloss = 0.4;\n        material1.metalness = 0.5;\n        material1.useMetalness = true;\n        material1.update();\n\n        const material2 = new pc.StandardMaterial();\n        material2.diffuse = new pc.Color(0, 1, 1);\n        material2.gloss = 0.4;\n        material2.metalness = 0.5;\n        material2.useMetalness = true;\n        material2.update();\n\n        // create a single BatchGroup. Make it dynamic to allow batched meshes to be freely moved every frame.\n        const batchGroup = app.batcher.addGroup(\"Meshes\", true, 100);\n\n        // create various primitive instances using one of the two materials\n        const numInstances = 500;\n        const shapes = [\"box\", \"cone\", \"cylinder\", \"sphere\", \"capsule\"];\n        const entities = [];\n        for (let i = 0; i < numInstances; i++) {\n            // random shape\n            const shapeName = shapes[Math.floor(Math.random() * shapes.length)];\n\n            const entity = new pc.Entity();\n\n            // create render component\n            entity.addComponent(\"render\", {\n                type: shapeName,\n                material: Math.random() < 0.5 ? material1 : material2,\n                castShadows: true,\n\n                // add it to the batchGroup - this instructs engine to try and render these meshes in a small number of draw calls.\n                // there will be at least 2 draw calls, one for each material\n                batchGroupId: batchGroup.id,\n            });\n\n            // add entity for rendering\n            app.root.addChild(entity);\n\n            // keep in the list to adjust positions each frame\n            entities.push(entity);\n        }\n\n        // Create an Entity for the ground\n        const ground = new pc.Entity();\n        ground.addComponent(\"render\", {\n            type: \"box\",\n            material: material2,\n        });\n\n        ground.setLocalScale(150, 1, 150);\n        ground.setLocalPosition(0, -26, 0);\n        app.root.addChild(ground);\n\n        // Create an entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.2, 0.2, 0.2),\n        });\n\n        app.root.addChild(camera);\n\n        // Create an entity with a directional light component\n        // Add it as a child of a camera to rotate with the camera\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\",\n            castShadows: true,\n            shadowBias: 0.2,\n            normalOffsetBias: 0.06,\n            shadowDistance: 150,\n        });\n\n        camera.addChild(light);\n        light.setLocalEulerAngles(15, 30, 0);\n\n        // Set an update function on the app's update event\n        let time = 0;\n        app.on(\"update\", function (dt) {\n            time += dt;\n\n            // move all entities along orbits\n            for (let i = 0; i < entities.length; i++) {\n                const radius = 5 + (20.0 * i) / numInstances;\n                const speed = i / numInstances;\n                entities[i].setLocalPosition(\n                    radius * Math.sin(i + time * speed),\n                    radius * Math.cos(i + time * speed),\n                    radius * Math.cos(i + 2 * time * speed)\n                );\n                entities[i].lookAt(pc.Vec3.ZERO);\n            }\n\n            // orbit camera around\n            camera.setLocalPosition(\n                70 * Math.sin(time),\n                0,\n                70 * Math.cos(time)\n            );\n            camera.lookAt(pc.Vec3.ZERO);\n        });\n    });\n}\n","nameSlug":"batching-dynamic","categorySlug":"graphics"},"clustered-area-lights":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data:any): void {\n\n    data.set('settings', {\n        material: {\n            gloss: 0.8,\n            metalness: 0.7\n        }\n    });\n\n    const assets = {\n        'bloom': new pc.Asset('bloom', 'script', { url: '/static/scripts/posteffects/posteffect-bloom.js' }),\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' }),\n        'color': new pc.Asset('color', 'texture', { url: '/static/assets/textures/seaside-rocks01-color.jpg' }),\n        'normal': new pc.Asset('normal', 'texture', { url: '/static/assets/textures/seaside-rocks01-normal.jpg' }),\n        'gloss': new pc.Asset('gloss', 'texture', { url: '/static/assets/textures/seaside-rocks01-gloss.jpg' }),\n        'luts': new pc.Asset('luts', 'json', { url: '/static/assets/json/area-light-luts.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.JsonHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // set up some general scene rendering properties\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // enabled clustered lighting. This is a temporary API and will change in the future\n            app.scene.clusteredLightingEnabled = true;\n\n            // adjust default clustered lighting parameters to handle many lights\n            const lighting = app.scene.lighting;\n\n            // 1) subdivide space with lights into this many cells\n            lighting.cells = new pc.Vec3(30, 2, 30);\n\n            // 2) and allow this many lights per cell\n            lighting.maxLightsPerCell = 20;\n\n            lighting.areaLightsEnabled = true;\n            lighting.shadowsEnabled = false;\n\n            // pure black material - used on back side of light objects\n            const blackMaterial = new pc.StandardMaterial();\n            blackMaterial.diffuse = new pc.Color(0, 0, 0);\n            blackMaterial.useLighting = false;\n            blackMaterial.update();\n\n            // ground material\n            const groundMaterial = new pc.StandardMaterial();\n            groundMaterial.diffuse = pc.Color.GRAY;\n            groundMaterial.gloss = 0.8;\n            groundMaterial.metalness = 0.7;\n            groundMaterial.useMetalness = true;\n\n            // helper function to create a primitive with shape type, position, scale, color\n            function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3, assetManifest: any) {\n\n                if (assetManifest) {\n                    groundMaterial.diffuseMap = assetManifest.color.resource;\n                    groundMaterial.normalMap = assetManifest.normal.resource;\n                    groundMaterial.glossMap = assetManifest.gloss.resource;\n\n                    groundMaterial.diffuseMapTiling.set(17, 17);\n                    groundMaterial.normalMapTiling.set(17, 17);\n                    groundMaterial.glossMapTiling.set(17, 17);\n                }\n\n                groundMaterial.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent('render', {\n                    type: primitiveType,\n                    material: groundMaterial\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // helper function to create area light including its visual representation in the world\n            function createAreaLight(type: string, shape: number, position: pc.Vec3, scale: pc.Vec3, color: pc.Color, intensity: number, range: number) {\n\n                const light = new pc.Entity();\n                light.addComponent(\"light\", {\n                    type: type,\n                    shape: shape,\n                    color: color,\n                    intensity: intensity,\n                    falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED,\n                    range: range,\n                    innerConeAngle: 88,\n                    outerConeAngle: 89\n                });\n\n                light.setLocalScale(scale);\n                light.setLocalPosition(position);\n                if (type === \"spot\") {\n                    light.rotate(-90, 0, 0);\n                }\n                app.root.addChild(light);\n\n                // emissive material that is the light source color\n                const brightMaterial = new pc.StandardMaterial();\n                brightMaterial.emissive = new pc.Color(color.r * 0.8, color.g * 0.8, color.b * 0.8);\n                brightMaterial.useLighting = false;\n                brightMaterial.update();\n\n                // primitive shape that matches light source shape\n                const lightPrimitive = (shape === pc.LIGHTSHAPE_SPHERE) ? \"sphere\" : (shape === pc.LIGHTSHAPE_DISK) ? \"cylinder\" : \"box\";\n\n                // primitive scale - flatten it to disk / rectangle\n                const primitiveScale = new pc.Vec3(1, shape !== pc.LIGHTSHAPE_SPHERE ? 0.001 : 1, 1);\n\n                // bright primitive representing the area light source\n                const brightShape = new pc.Entity();\n                brightShape.addComponent(\"render\", {\n                    type: lightPrimitive,\n                    material: brightMaterial\n                });\n                brightShape.setLocalScale(primitiveScale);\n                light.addChild(brightShape);\n\n                // black primitive representing the back of the light source which is not emitting light\n                if (type === \"spot\") {\n\n                    const blackShape = new pc.Entity();\n                    blackShape.addComponent(\"render\", {\n                        type: lightPrimitive,\n                        material: blackMaterial\n                    });\n                    blackShape.setLocalPosition(0, 0.004, 0);\n                    blackShape.setLocalEulerAngles(-180, 0, 0);\n                    blackShape.setLocalScale(primitiveScale);\n                    light.addChild(blackShape);\n                }\n\n                return light;\n            }\n\n            // set the loaded area light LUT data\n            const luts = assets.luts.resource;\n            app.setAreaLightLuts(luts.LTC_MAT_1, luts.LTC_MAT_2);\n\n            // set up some general scene rendering properties\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // create ground plane\n            const ground = createPrimitive(\"plane\", new pc.Vec3(0, 0, 0), new pc.Vec3(45, 1, 45), assets);\n\n            // Create the camera, which renders entities\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1),\n                fov: 60,\n                farClip: 1000\n            });\n            camera.setLocalPosition(3, 3, 12);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: ground,\n                    distanceMax: 60,\n                    frameOnStart: false\n                }\n            });\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // add bloom postprocessing\n            camera.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1.5,\n                    bloomThreshold: 0.6,\n                    blurAmount: 6\n                }\n            });\n\n            // generate a grid of area lights of sphere, disk and rect shapes\n            for (let x = -20; x <= 20; x += 5) {\n                for (let y = -20; y <= 20; y += 5) {\n                    const pos = new pc.Vec3(x, 0.6, y);\n                    const color = new pc.Color(0.3 + Math.random() * 0.7, 0.3 + Math.random() * 0.7, 0.3 + Math.random() * 0.7);\n                    const rand = Math.random();\n                    if (rand < 0.3) {\n                        createAreaLight(\"omni\", pc.LIGHTSHAPE_SPHERE, pos, new pc.Vec3(1.5, 1.5, 1.5), color, 2, 6);\n                    } else if (rand < 0.6) {\n                        createAreaLight(\"spot\", pc.LIGHTSHAPE_DISK, pos, new pc.Vec3(1.5, 1.5, 1.5), color, 2.5, 5);\n                    } else {\n                        createAreaLight(\"spot\", pc.LIGHTSHAPE_RECT, pos, new pc.Vec3(2, 1, 1), color, 2.5, 5);\n                    }\n                }\n            }\n\n            // handle HUD changes - update properties on the material\n            data.on('*:set', (path: string, value: any) => {\n                const pathArray = path.split('.');\n                if (pathArray[2] === \"gloss\") groundMaterial.gloss = value;\n                if (pathArray[2] === \"metalness\") groundMaterial.metalness = value;\n                groundMaterial.update();\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    data.set(\"settings\", {\n        material: {\n            gloss: 0.8,\n            metalness: 0.7,\n        },\n    });\n\n    const assets = {\n        bloom: new pc.Asset(\"bloom\", \"script\", {\n            url: \"/static/scripts/posteffects/posteffect-bloom.js\",\n        }),\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/orbit-camera.js\",\n        }),\n        color: new pc.Asset(\"color\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-color.jpg\",\n        }),\n        normal: new pc.Asset(\"normal\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-normal.jpg\",\n        }),\n        gloss: new pc.Asset(\"gloss\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-gloss.jpg\",\n        }),\n        luts: new pc.Asset(\"luts\", \"json\", {\n            url: \"/static/assets/json/area-light-luts.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.JsonHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // set up some general scene rendering properties\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // enabled clustered lighting. This is a temporary API and will change in the future\n            app.scene.clusteredLightingEnabled = true;\n\n            // adjust default clustered lighting parameters to handle many lights\n            const lighting = app.scene.lighting;\n\n            // 1) subdivide space with lights into this many cells\n            lighting.cells = new pc.Vec3(30, 2, 30);\n\n            // 2) and allow this many lights per cell\n            lighting.maxLightsPerCell = 20;\n\n            lighting.areaLightsEnabled = true;\n            lighting.shadowsEnabled = false;\n\n            // pure black material - used on back side of light objects\n            const blackMaterial = new pc.StandardMaterial();\n            blackMaterial.diffuse = new pc.Color(0, 0, 0);\n            blackMaterial.useLighting = false;\n            blackMaterial.update();\n\n            // ground material\n            const groundMaterial = new pc.StandardMaterial();\n            groundMaterial.diffuse = pc.Color.GRAY;\n            groundMaterial.gloss = 0.8;\n            groundMaterial.metalness = 0.7;\n            groundMaterial.useMetalness = true;\n\n            // helper function to create a primitive with shape type, position, scale, color\n            function createPrimitive(\n                primitiveType,\n                position,\n                scale,\n                assetManifest\n            ) {\n                if (assetManifest) {\n                    groundMaterial.diffuseMap = assetManifest.color.resource;\n                    groundMaterial.normalMap = assetManifest.normal.resource;\n                    groundMaterial.glossMap = assetManifest.gloss.resource;\n\n                    groundMaterial.diffuseMapTiling.set(17, 17);\n                    groundMaterial.normalMapTiling.set(17, 17);\n                    groundMaterial.glossMapTiling.set(17, 17);\n                }\n\n                groundMaterial.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent(\"render\", {\n                    type: primitiveType,\n                    material: groundMaterial,\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // helper function to create area light including its visual representation in the world\n            function createAreaLight(\n                type,\n                shape,\n                position,\n                scale,\n                color,\n                intensity,\n                range\n            ) {\n                const light = new pc.Entity();\n                light.addComponent(\"light\", {\n                    type: type,\n                    shape: shape,\n                    color: color,\n                    intensity: intensity,\n                    falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED,\n                    range: range,\n                    innerConeAngle: 88,\n                    outerConeAngle: 89,\n                });\n\n                light.setLocalScale(scale);\n                light.setLocalPosition(position);\n                if (type === \"spot\") {\n                    light.rotate(-90, 0, 0);\n                }\n                app.root.addChild(light);\n\n                // emissive material that is the light source color\n                const brightMaterial = new pc.StandardMaterial();\n                brightMaterial.emissive = new pc.Color(\n                    color.r * 0.8,\n                    color.g * 0.8,\n                    color.b * 0.8\n                );\n                brightMaterial.useLighting = false;\n                brightMaterial.update();\n\n                // primitive shape that matches light source shape\n                const lightPrimitive =\n                    shape === pc.LIGHTSHAPE_SPHERE\n                        ? \"sphere\"\n                        : shape === pc.LIGHTSHAPE_DISK\n                        ? \"cylinder\"\n                        : \"box\";\n\n                // primitive scale - flatten it to disk / rectangle\n                const primitiveScale = new pc.Vec3(\n                    1,\n                    shape !== pc.LIGHTSHAPE_SPHERE ? 0.001 : 1,\n                    1\n                );\n\n                // bright primitive representing the area light source\n                const brightShape = new pc.Entity();\n                brightShape.addComponent(\"render\", {\n                    type: lightPrimitive,\n                    material: brightMaterial,\n                });\n\n                brightShape.setLocalScale(primitiveScale);\n                light.addChild(brightShape);\n\n                // black primitive representing the back of the light source which is not emitting light\n                if (type === \"spot\") {\n                    const blackShape = new pc.Entity();\n                    blackShape.addComponent(\"render\", {\n                        type: lightPrimitive,\n                        material: blackMaterial,\n                    });\n\n                    blackShape.setLocalPosition(0, 0.004, 0);\n                    blackShape.setLocalEulerAngles(-180, 0, 0);\n                    blackShape.setLocalScale(primitiveScale);\n                    light.addChild(blackShape);\n                }\n\n                return light;\n            }\n\n            // set the loaded area light LUT data\n            const luts = assets.luts.resource;\n            app.setAreaLightLuts(luts.LTC_MAT_1, luts.LTC_MAT_2);\n\n            // set up some general scene rendering properties\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // create ground plane\n            const ground = createPrimitive(\n                \"plane\",\n                new pc.Vec3(0, 0, 0),\n                new pc.Vec3(45, 1, 45),\n                assets\n            );\n\n            // Create the camera, which renders entities\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1),\n                fov: 60,\n                farClip: 1000,\n            });\n\n            camera.setLocalPosition(3, 3, 12);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: ground,\n                    distanceMax: 60,\n                    frameOnStart: false,\n                },\n            });\n\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // add bloom postprocessing\n            camera.script.create(\"bloom\", {\n                attributes: {\n                    bloomIntensity: 1.5,\n                    bloomThreshold: 0.6,\n                    blurAmount: 6,\n                },\n            });\n\n            // generate a grid of area lights of sphere, disk and rect shapes\n            for (let x = -20; x <= 20; x += 5) {\n                for (let y = -20; y <= 20; y += 5) {\n                    const pos = new pc.Vec3(x, 0.6, y);\n                    const color = new pc.Color(\n                        0.3 + Math.random() * 0.7,\n                        0.3 + Math.random() * 0.7,\n                        0.3 + Math.random() * 0.7\n                    );\n                    const rand = Math.random();\n                    if (rand < 0.3) {\n                        createAreaLight(\n                            \"omni\",\n                            pc.LIGHTSHAPE_SPHERE,\n                            pos,\n                            new pc.Vec3(1.5, 1.5, 1.5),\n                            color,\n                            2,\n                            6\n                        );\n                    } else if (rand < 0.6) {\n                        createAreaLight(\n                            \"spot\",\n                            pc.LIGHTSHAPE_DISK,\n                            pos,\n                            new pc.Vec3(1.5, 1.5, 1.5),\n                            color,\n                            2.5,\n                            5\n                        );\n                    } else {\n                        createAreaLight(\n                            \"spot\",\n                            pc.LIGHTSHAPE_RECT,\n                            pos,\n                            new pc.Vec3(2, 1, 1),\n                            color,\n                            2.5,\n                            5\n                        );\n                    }\n                }\n            }\n\n            // handle HUD changes - update properties on the material\n            data.on(\"*:set\", (path, value) => {\n                const pathArray = path.split(\".\");\n                if (pathArray[2] === \"gloss\") groundMaterial.gloss = value;\n                if (pathArray[2] === \"metalness\")\n                    groundMaterial.metalness = value;\n                groundMaterial.update();\n            });\n        });\n    });\n}\n","nameSlug":"clustered-area-lights","categorySlug":"graphics"},"clustered-lighting":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' }),\n        'normal': new pc.Asset('normal', 'texture', { url: '/static/assets/textures/normal-map.png' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            const pointLightList: Array<pc.Entity> = [];\n            const spotLightList: Array<pc.Entity> = [];\n            let dirLight: pc.Entity = null;\n\n            // enabled clustered lighting. This is a temporary API and will change in the future\n            app.scene.clusteredLightingEnabled = true;\n\n            // adjust default clustered lighting parameters to handle many lights\n            const lighting = app.scene.lighting;\n\n            // 1) subdivide space with lights into this many cells\n            lighting.cells = new pc.Vec3(12, 16, 12);\n\n            // 2) and allow this many lights per cell\n            lighting.maxLightsPerCell = 48;\n\n            lighting.shadowsEnabled = false;\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // material with tiled normal map\n            let material = new pc.StandardMaterial();\n            material.normalMap = assets.normal.resource;\n            material.normalMapTiling.set(5, 5);\n            material.bumpiness = 1;\n\n            // enable specular\n            material.gloss = 0.5;\n            material.metalness = 0.3;\n            material.useMetalness = true;\n\n            material.update();\n\n            // ground plane\n            const ground = new pc.Entity();\n            ground.addComponent('render', {\n                type: \"plane\",\n                material: material\n            });\n            ground.setLocalScale(150, 150, 150);\n            app.root.addChild(ground);\n\n            // high polycount cylinder\n            const cylinderMesh = pc.createCylinder(app.graphicsDevice, { capSegments: 200 });\n            const cylinder = new pc.Entity();\n            cylinder.addComponent('render', {\n                material: material,\n                meshInstances: [new pc.MeshInstance(cylinderMesh, material)],\n                castShadows: true\n            });\n            app.root.addChild(cylinder);\n            cylinder.setLocalPosition(0, 50, 0);\n            cylinder.setLocalScale(50, 100, 50);\n\n            // create many omni lights that do not cast shadows\n            let count = 30;\n            for (let i = 0; i < count; i++) {\n                const color = new pc.Color(Math.random(), Math.random(), Math.random(), 1);\n                const lightPoint = new pc.Entity();\n                lightPoint.addComponent(\"light\", {\n                    type: \"omni\",\n                    color: color,\n                    range: 12,\n                    castShadows: false,\n                    falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED\n                });\n\n                // attach a render component with a small sphere to each light\n                const material = new pc.StandardMaterial();\n                material.emissive = color;\n                material.update();\n\n                lightPoint.addComponent('render', {\n                    type: \"sphere\",\n                    material: material,\n                    castShadows: true\n                });\n                lightPoint.setLocalScale(5, 5, 5);\n\n                // add it to the scene and also keep it in an array\n                app.root.addChild(lightPoint);\n                pointLightList.push(lightPoint);\n            }\n\n            // create many spot lights\n            count = 16;\n            for (let i = 0; i < count; i++) {\n                const color = new pc.Color(Math.random(), Math.random(), Math.random(), 1);\n                const lightSpot = new pc.Entity();\n                lightSpot.addComponent(\"light\", {\n                    type: \"spot\",\n                    color: color,\n                    innerConeAngle: 5,\n                    outerConeAngle: 6 + Math.random() * 40,\n                    range: 25,\n                    castShadows: false\n                });\n\n                // attach a render component with a small cone to each light\n                material = new pc.StandardMaterial();\n                material.emissive = color;\n                material.update();\n\n                lightSpot.addComponent('render', {\n                    type: \"cone\",\n                    material: material\n                });\n                lightSpot.setLocalScale(5, 5, 5);\n\n                lightSpot.setLocalPosition(100, 50, 70);\n                lightSpot.lookAt(new pc.Vec3(100, 60, 70));\n                app.root.addChild(lightSpot);\n                spotLightList.push(lightSpot);\n            }\n\n            // Create a single directional light which casts shadows\n            dirLight = new pc.Entity();\n            dirLight.addComponent(\"light\", {\n                type: \"directional\",\n                color: pc.Color.WHITE,\n                intensity: 0.15,\n                range: 300,\n                shadowDistance: 600,\n                castShadows: true,\n                shadowBias: 0.2,\n                normalOffsetBias: 0.05\n            });\n            app.root.addChild(dirLight);\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.05, 0.05, 0.05),\n                farClip: 500,\n                nearClip: 0.1\n            });\n            camera.setLocalPosition(140, 140, 140);\n            camera.lookAt(new pc.Vec3(0, 40, 0));\n\n            // add orbit camera script with mouse and touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: app.root,\n                    distanceMax: 400,\n                    frameOnStart: false\n                }\n            });\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // Set an update function on the app's update event\n            let time = 0;\n            app.on(\"update\", function (dt: number) {\n                time += dt;\n\n                // move lights along sin based waves around the cylinder\n                pointLightList.forEach(function (light, i) {\n                    const angle = (i / pointLightList.length) * Math.PI * 2;\n                    const y = Math.sin(time * 0.5 + 7 * angle) * 30 + 70;\n                    light.setLocalPosition(30 * Math.sin(angle), y, 30 * Math.cos(angle));\n                });\n\n                // rotate spot lights around\n                spotLightList.forEach(function (spotlight, i) {\n                    const angle = (i / spotLightList.length) * Math.PI * 2;\n                    spotlight.setLocalPosition(40 * Math.sin(time + angle), 5, 40 * Math.cos(time + angle));\n                    spotlight.lookAt(pc.Vec3.ZERO);\n                    spotlight.rotateLocal(90, 0, 0);\n                });\n\n                // rotate directional light\n                if (dirLight) {\n                    dirLight.setLocalEulerAngles(25, -30 * time, 0);\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/orbit-camera.js\",\n        }),\n        normal: new pc.Asset(\"normal\", \"texture\", {\n            url: \"/static/assets/textures/normal-map.png\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            const pointLightList = [];\n            const spotLightList = [];\n            let dirLight = null;\n\n            // enabled clustered lighting. This is a temporary API and will change in the future\n            app.scene.clusteredLightingEnabled = true;\n\n            // adjust default clustered lighting parameters to handle many lights\n            const lighting = app.scene.lighting;\n\n            // 1) subdivide space with lights into this many cells\n            lighting.cells = new pc.Vec3(12, 16, 12);\n\n            // 2) and allow this many lights per cell\n            lighting.maxLightsPerCell = 48;\n\n            lighting.shadowsEnabled = false;\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // material with tiled normal map\n            let material = new pc.StandardMaterial();\n            material.normalMap = assets.normal.resource;\n            material.normalMapTiling.set(5, 5);\n            material.bumpiness = 1;\n\n            // enable specular\n            material.gloss = 0.5;\n            material.metalness = 0.3;\n            material.useMetalness = true;\n\n            material.update();\n\n            // ground plane\n            const ground = new pc.Entity();\n            ground.addComponent(\"render\", {\n                type: \"plane\",\n                material: material,\n            });\n\n            ground.setLocalScale(150, 150, 150);\n            app.root.addChild(ground);\n\n            // high polycount cylinder\n            const cylinderMesh = pc.createCylinder(app.graphicsDevice, {\n                capSegments: 200,\n            });\n            const cylinder = new pc.Entity();\n            cylinder.addComponent(\"render\", {\n                material: material,\n                meshInstances: [new pc.MeshInstance(cylinderMesh, material)],\n                castShadows: true,\n            });\n\n            app.root.addChild(cylinder);\n            cylinder.setLocalPosition(0, 50, 0);\n            cylinder.setLocalScale(50, 100, 50);\n\n            // create many omni lights that do not cast shadows\n            let count = 30;\n            for (let i = 0; i < count; i++) {\n                const color = new pc.Color(\n                    Math.random(),\n                    Math.random(),\n                    Math.random(),\n                    1\n                );\n                const lightPoint = new pc.Entity();\n                lightPoint.addComponent(\"light\", {\n                    type: \"omni\",\n                    color: color,\n                    range: 12,\n                    castShadows: false,\n                    falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED,\n                });\n\n                // attach a render component with a small sphere to each light\n                const material = new pc.StandardMaterial();\n                material.emissive = color;\n                material.update();\n\n                lightPoint.addComponent(\"render\", {\n                    type: \"sphere\",\n                    material: material,\n                    castShadows: true,\n                });\n\n                lightPoint.setLocalScale(5, 5, 5);\n\n                // add it to the scene and also keep it in an array\n                app.root.addChild(lightPoint);\n                pointLightList.push(lightPoint);\n            }\n\n            // create many spot lights\n            count = 16;\n            for (let i = 0; i < count; i++) {\n                const color = new pc.Color(\n                    Math.random(),\n                    Math.random(),\n                    Math.random(),\n                    1\n                );\n                const lightSpot = new pc.Entity();\n                lightSpot.addComponent(\"light\", {\n                    type: \"spot\",\n                    color: color,\n                    innerConeAngle: 5,\n                    outerConeAngle: 6 + Math.random() * 40,\n                    range: 25,\n                    castShadows: false,\n                });\n\n                // attach a render component with a small cone to each light\n                material = new pc.StandardMaterial();\n                material.emissive = color;\n                material.update();\n\n                lightSpot.addComponent(\"render\", {\n                    type: \"cone\",\n                    material: material,\n                });\n\n                lightSpot.setLocalScale(5, 5, 5);\n\n                lightSpot.setLocalPosition(100, 50, 70);\n                lightSpot.lookAt(new pc.Vec3(100, 60, 70));\n                app.root.addChild(lightSpot);\n                spotLightList.push(lightSpot);\n            }\n\n            // Create a single directional light which casts shadows\n            dirLight = new pc.Entity();\n            dirLight.addComponent(\"light\", {\n                type: \"directional\",\n                color: pc.Color.WHITE,\n                intensity: 0.15,\n                range: 300,\n                shadowDistance: 600,\n                castShadows: true,\n                shadowBias: 0.2,\n                normalOffsetBias: 0.05,\n            });\n\n            app.root.addChild(dirLight);\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.05, 0.05, 0.05),\n                farClip: 500,\n                nearClip: 0.1,\n            });\n\n            camera.setLocalPosition(140, 140, 140);\n            camera.lookAt(new pc.Vec3(0, 40, 0));\n\n            // add orbit camera script with mouse and touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: app.root,\n                    distanceMax: 400,\n                    frameOnStart: false,\n                },\n            });\n\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // Set an update function on the app's update event\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // move lights along sin based waves around the cylinder\n                pointLightList.forEach(function (light, i) {\n                    const angle = (i / pointLightList.length) * Math.PI * 2;\n                    const y = Math.sin(time * 0.5 + 7 * angle) * 30 + 70;\n                    light.setLocalPosition(\n                        30 * Math.sin(angle),\n                        y,\n                        30 * Math.cos(angle)\n                    );\n                });\n\n                // rotate spot lights around\n                spotLightList.forEach(function (spotlight, i) {\n                    const angle = (i / spotLightList.length) * Math.PI * 2;\n                    spotlight.setLocalPosition(\n                        40 * Math.sin(time + angle),\n                        5,\n                        40 * Math.cos(time + angle)\n                    );\n                    spotlight.lookAt(pc.Vec3.ZERO);\n                    spotlight.rotateLocal(90, 0, 0);\n                });\n\n                // rotate directional light\n                if (dirLight) {\n                    dirLight.setLocalEulerAngles(25, -30 * time, 0);\n                }\n            });\n        });\n    });\n}\n","nameSlug":"clustered-lighting","categorySlug":"graphics"},"clustered-omni-shadows":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data: any): void {\n\n    const assets = {\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' }),\n        'normal': new pc.Asset('normal', 'texture', { url: '/static/assets/textures/normal-map.png' }),\n        \"xmas_negx\": new pc.Asset(\"xmas_negx\", \"texture\", { url: \"/static/assets/cubemaps/xmas_faces/xmas_negx.png\" }),\n        \"xmas_negy\": new pc.Asset(\"xmas_negy\", \"texture\", { url: \"/static/assets/cubemaps/xmas_faces/xmas_negy.png\" }),\n        \"xmas_negz\": new pc.Asset(\"xmas_negz\", \"texture\", { url: \"/static/assets/cubemaps/xmas_faces/xmas_negz.png\" }),\n        \"xmas_posx\": new pc.Asset(\"xmas_posx\", \"texture\", { url: \"/static/assets/cubemaps/xmas_faces/xmas_posx.png\" }),\n        \"xmas_posy\": new pc.Asset(\"xmas_posy\", \"texture\", { url: \"/static/assets/cubemaps/xmas_faces/xmas_posy.png\" }),\n        \"xmas_posz\": new pc.Asset(\"xmas_posz\", \"texture\", { url: \"/static/assets/cubemaps/xmas_faces/xmas_posz.png\" })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.CubemapHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // set up some general scene rendering properties\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            data.set('settings', {\n                shadowAtlasResolution: 1300,     // shadow map resolution storing all shadows\n                shadowType: pc.SHADOW_PCF3,      // shadow filter type\n                shadowsEnabled: true,\n                cookiesEnabled: true\n            });\n\n            // enabled clustered lighting. This is a temporary API and will change in the future\n            app.scene.clusteredLightingEnabled = true;\n\n            // adjust default clustered lighting parameters to handle many lights\n            const lighting = app.scene.lighting;\n\n            // 1) subdivide space with lights into this many cells\n            lighting.cells = new pc.Vec3(16, 12, 16);\n\n            // 2) and allow this many lights per cell\n            lighting.maxLightsPerCell = 12;\n\n            // enable clustered shadows (it's enabled by default as well)\n            lighting.shadowsEnabled = true;\n\n            // enable clustered cookies\n            lighting.cookiesEnabled = true;\n\n            // resolution of the shadow and cookie atlas\n            lighting.shadowAtlasResolution = data.get('settings.shadowAtlasResolution');\n            lighting.cookieAtlasResolution = 2048;\n\n            // helper function to create a 3d primitive including its material\n            function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3) {\n\n                // create a material\n                const material = new pc.StandardMaterial();\n                material.diffuse = new pc.Color(0.7, 0.7, 0.7);\n\n                // normal map\n                material.normalMap = assets.normal.resource;\n                material.normalMapTiling.set(5, 5);\n                material.bumpiness = 0.7;\n\n                // enable specular\n                material.gloss = 0.4;\n                material.metalness = 0.3;\n                material.useMetalness = true;\n\n                material.update();\n\n                // create the primitive using the material\n                const primitive = new pc.Entity();\n                primitive.addComponent('render', {\n                    type: primitiveType,\n                    material: material\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // create the ground plane from the boxes\n            createPrimitive(\"box\", new pc.Vec3(0, 0, 0), new pc.Vec3(800, 2, 800));\n            createPrimitive(\"box\", new pc.Vec3(0, 400, 0), new pc.Vec3(800, 2, 800));\n\n            // walls\n            createPrimitive(\"box\", new pc.Vec3(400, 200, 0), new pc.Vec3(2, 400, 800));\n            createPrimitive(\"box\", new pc.Vec3(-400, 200, 0), new pc.Vec3(2, 400, 800));\n            createPrimitive(\"box\", new pc.Vec3(0, 200, 400), new pc.Vec3(800, 400, 0));\n            createPrimitive(\"box\", new pc.Vec3(0, 200, -400), new pc.Vec3(800, 400, 0));\n\n            const numTowers = 7;\n            for (let i = 0; i < numTowers; i++) {\n                let scale = 25;\n                const fraction = i / numTowers * Math.PI * 2;\n                const radius = (i % 2) ? 340 : 210;\n                for (let y = 0; y <= 7; y++) {\n                    const prim = createPrimitive(\"box\", new pc.Vec3(radius * Math.sin(fraction), 2 + y * 25, radius * Math.cos(fraction)), new pc.Vec3(scale, scale, scale));\n                    prim.setLocalEulerAngles(Math.random() * 360, Math.random() * 360, Math.random() * 360);\n                }\n                scale -= 1.5;\n            }\n\n            // construct the cubemap asset for the omni light cookie texture\n            // Note: the textures array could contain 6 texture asset names to load instead as well\n            const cubemapAsset = new pc.Asset('xmas_cubemap', 'cubemap', null, {\n                textures: [\n                    assets.xmas_posx.id, assets.xmas_negx.id,\n                    assets.xmas_posy.id, assets.xmas_negy.id,\n                    assets.xmas_posz.id, assets.xmas_negz.id\n                ]\n            });\n            cubemapAsset.loadFaces = true;\n            app.assets.add(cubemapAsset);\n\n            const omniLights: Array<pc.Entity> = [];\n            const numLights = 10;\n            for (let i = 0; i < numLights; i++) {\n                const lightOmni = new pc.Entity(\"Omni\");\n                lightOmni.addComponent(\"light\", {\n                    type: \"omni\",\n                    color: pc.Color.WHITE,\n                    intensity: 10 / numLights,\n                    range: 350,\n                    castShadows: true,\n                    shadowBias: 0.2,\n                    normalOffsetBias: 0.2,\n\n                    // cookie texture\n                    cookieAsset: cubemapAsset,\n                    cookieChannel: \"rgb\"\n                });\n\n                // attach a render component with a small sphere to it\n                const material = new pc.StandardMaterial();\n                material.emissive = pc.Color.WHITE;\n                material.update();\n\n                lightOmni.addComponent('render', {\n                    type: \"sphere\",\n                    material: material,\n                    castShadows: false\n                });\n                lightOmni.setPosition(0, 120, 0);\n                lightOmni.setLocalScale(5, 5, 5);\n                app.root.addChild(lightOmni);\n\n                omniLights.push(lightOmni);\n            }\n\n            // create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                fov: 80,\n                clearColor: new pc.Color(0.1, 0.1, 0.1),\n                farClip: 1500\n            });\n\n            // and position it in the world\n            camera.setLocalPosition(300, 120, 25);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: app.root,\n                    distanceMax: 1200,\n                    frameOnStart: false\n                }\n            });\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // handle HUD changes - update properties on the scene\n            data.on('*:set', (path: string, value: any) => {\n                const pathArray = path.split('.');\n                // @ts-ignore\n                lighting[pathArray[1]] = value;\n            });\n\n            // Set an update function on the app's update event\n            let time = 0;\n            app.on(\"update\", function (dt: number) {\n                time += dt * 0.3;\n                const radius = 250;\n                for (let i = 0; i < omniLights.length; i++) {\n                    const fraction = i / omniLights.length * Math.PI * 2;\n                    omniLights[i].setPosition(radius * Math.sin(time + fraction), 190 + Math.sin(time + fraction) * 150, radius * Math.cos(time + fraction));\n                }\n\n                // display shadow texture (debug feature, only works when depth is stored as color, which is webgl1)\n                // app.drawTexture(-0.7, 0.7, 0.4, 0.4, app.renderer.lightTextureAtlas.shadowMap.texture);\n\n                // display cookie texture (debug feature)\n                // app.drawTexture(-0.7, 0.2, 0.4, 0.4, app.renderer.lightTextureAtlas.cookieAtlas);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    const assets = {\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/orbit-camera.js\",\n        }),\n        normal: new pc.Asset(\"normal\", \"texture\", {\n            url: \"/static/assets/textures/normal-map.png\",\n        }),\n        xmas_negx: new pc.Asset(\"xmas_negx\", \"texture\", {\n            url: \"/static/assets/cubemaps/xmas_faces/xmas_negx.png\",\n        }),\n        xmas_negy: new pc.Asset(\"xmas_negy\", \"texture\", {\n            url: \"/static/assets/cubemaps/xmas_faces/xmas_negy.png\",\n        }),\n        xmas_negz: new pc.Asset(\"xmas_negz\", \"texture\", {\n            url: \"/static/assets/cubemaps/xmas_faces/xmas_negz.png\",\n        }),\n        xmas_posx: new pc.Asset(\"xmas_posx\", \"texture\", {\n            url: \"/static/assets/cubemaps/xmas_faces/xmas_posx.png\",\n        }),\n        xmas_posy: new pc.Asset(\"xmas_posy\", \"texture\", {\n            url: \"/static/assets/cubemaps/xmas_faces/xmas_posy.png\",\n        }),\n        xmas_posz: new pc.Asset(\"xmas_posz\", \"texture\", {\n            url: \"/static/assets/cubemaps/xmas_faces/xmas_posz.png\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.CubemapHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // set up some general scene rendering properties\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            data.set(\"settings\", {\n                shadowAtlasResolution: 1300, // shadow map resolution storing all shadows\n                shadowType: pc.SHADOW_PCF3, // shadow filter type\n                shadowsEnabled: true,\n                cookiesEnabled: true,\n            });\n\n            // enabled clustered lighting. This is a temporary API and will change in the future\n            app.scene.clusteredLightingEnabled = true;\n\n            // adjust default clustered lighting parameters to handle many lights\n            const lighting = app.scene.lighting;\n\n            // 1) subdivide space with lights into this many cells\n            lighting.cells = new pc.Vec3(16, 12, 16);\n\n            // 2) and allow this many lights per cell\n            lighting.maxLightsPerCell = 12;\n\n            // enable clustered shadows (it's enabled by default as well)\n            lighting.shadowsEnabled = true;\n\n            // enable clustered cookies\n            lighting.cookiesEnabled = true;\n\n            // resolution of the shadow and cookie atlas\n            lighting.shadowAtlasResolution = data.get(\n                \"settings.shadowAtlasResolution\"\n            );\n            lighting.cookieAtlasResolution = 2048;\n\n            // helper function to create a 3d primitive including its material\n            function createPrimitive(primitiveType, position, scale) {\n                // create a material\n                const material = new pc.StandardMaterial();\n                material.diffuse = new pc.Color(0.7, 0.7, 0.7);\n\n                // normal map\n                material.normalMap = assets.normal.resource;\n                material.normalMapTiling.set(5, 5);\n                material.bumpiness = 0.7;\n\n                // enable specular\n                material.gloss = 0.4;\n                material.metalness = 0.3;\n                material.useMetalness = true;\n\n                material.update();\n\n                // create the primitive using the material\n                const primitive = new pc.Entity();\n                primitive.addComponent(\"render\", {\n                    type: primitiveType,\n                    material: material,\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // create the ground plane from the boxes\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(0, 0, 0),\n                new pc.Vec3(800, 2, 800)\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(0, 400, 0),\n                new pc.Vec3(800, 2, 800)\n            );\n\n            // walls\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(400, 200, 0),\n                new pc.Vec3(2, 400, 800)\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(-400, 200, 0),\n                new pc.Vec3(2, 400, 800)\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(0, 200, 400),\n                new pc.Vec3(800, 400, 0)\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(0, 200, -400),\n                new pc.Vec3(800, 400, 0)\n            );\n\n            const numTowers = 7;\n            for (let i = 0; i < numTowers; i++) {\n                let scale = 25;\n                const fraction = (i / numTowers) * Math.PI * 2;\n                const radius = i % 2 ? 340 : 210;\n                for (let y = 0; y <= 7; y++) {\n                    const prim = createPrimitive(\n                        \"box\",\n                        new pc.Vec3(\n                            radius * Math.sin(fraction),\n                            2 + y * 25,\n                            radius * Math.cos(fraction)\n                        ),\n                        new pc.Vec3(scale, scale, scale)\n                    );\n                    prim.setLocalEulerAngles(\n                        Math.random() * 360,\n                        Math.random() * 360,\n                        Math.random() * 360\n                    );\n                }\n                scale -= 1.5;\n            }\n\n            // construct the cubemap asset for the omni light cookie texture\n            // Note: the textures array could contain 6 texture asset names to load instead as well\n            const cubemapAsset = new pc.Asset(\"xmas_cubemap\", \"cubemap\", null, {\n                textures: [\n                    assets.xmas_posx.id,\n                    assets.xmas_negx.id,\n                    assets.xmas_posy.id,\n                    assets.xmas_negy.id,\n                    assets.xmas_posz.id,\n                    assets.xmas_negz.id,\n                ],\n            });\n\n            cubemapAsset.loadFaces = true;\n            app.assets.add(cubemapAsset);\n\n            const omniLights = [];\n            const numLights = 10;\n            for (let i = 0; i < numLights; i++) {\n                const lightOmni = new pc.Entity(\"Omni\");\n                lightOmni.addComponent(\"light\", {\n                    type: \"omni\",\n                    color: pc.Color.WHITE,\n                    intensity: 10 / numLights,\n                    range: 350,\n                    castShadows: true,\n                    shadowBias: 0.2,\n                    normalOffsetBias: 0.2,\n\n                    // cookie texture\n                    cookieAsset: cubemapAsset,\n                    cookieChannel: \"rgb\",\n                });\n\n                // attach a render component with a small sphere to it\n                const material = new pc.StandardMaterial();\n                material.emissive = pc.Color.WHITE;\n                material.update();\n\n                lightOmni.addComponent(\"render\", {\n                    type: \"sphere\",\n                    material: material,\n                    castShadows: false,\n                });\n\n                lightOmni.setPosition(0, 120, 0);\n                lightOmni.setLocalScale(5, 5, 5);\n                app.root.addChild(lightOmni);\n\n                omniLights.push(lightOmni);\n            }\n\n            // create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                fov: 80,\n                clearColor: new pc.Color(0.1, 0.1, 0.1),\n                farClip: 1500,\n            });\n\n            // and position it in the world\n            camera.setLocalPosition(300, 120, 25);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: app.root,\n                    distanceMax: 1200,\n                    frameOnStart: false,\n                },\n            });\n\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // handle HUD changes - update properties on the scene\n            data.on(\"*:set\", (path, value) => {\n                const pathArray = path.split(\".\");\n                // @ts-ignore\n                lighting[pathArray[1]] = value;\n            });\n\n            // Set an update function on the app's update event\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt * 0.3;\n                const radius = 250;\n                for (let i = 0; i < omniLights.length; i++) {\n                    const fraction = (i / omniLights.length) * Math.PI * 2;\n                    omniLights[i].setPosition(\n                        radius * Math.sin(time + fraction),\n                        190 + Math.sin(time + fraction) * 150,\n                        radius * Math.cos(time + fraction)\n                    );\n                }\n\n                // display shadow texture (debug feature, only works when depth is stored as color, which is webgl1)\n                // app.drawTexture(-0.7, 0.7, 0.4, 0.4, app.renderer.lightTextureAtlas.shadowMap.texture);\n\n                // display cookie texture (debug feature)\n                // app.drawTexture(-0.7, 0.2, 0.4, 0.4, app.renderer.lightTextureAtlas.cookieAtlas);\n            });\n        });\n    });\n}\n","nameSlug":"clustered-omni-shadows","categorySlug":"graphics"},"clustered-spot-shadows":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data: any): void {\n\n    const assets = {\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' }),\n        \"channels\": new pc.Asset(\"channels\", \"texture\", { url: \"/static/assets/textures/channels.png\" }),\n        \"heart\": new pc.Asset(\"heart\", \"texture\", { url: \"/static/assets/textures/heart.png\" }),\n        'normal': new pc.Asset('normal', 'texture', { url: '/static/assets/textures/normal-map.png' }),\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ScriptHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            data.set('settings', {\n                shadowAtlasResolution: 1024,     // shadow map resolution storing all shadows\n                shadowType: pc.SHADOW_PCF3,      // shadow filter type\n                shadowsEnabled: true,\n                cookiesEnabled: true,\n                shadowIntensity: 1,\n                numLights: 0,\n                debug: false,\n                debugAtlas: false,\n                splitOptions: 0,\n                static: false\n            });\n\n            // setup skydome as ambient light\n            app.scene.skyboxMip = 3;\n            app.scene.skyboxIntensity = 0.1;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // enabled clustered lighting. This is a temporary API and will change in the future\n            app.scene.clusteredLightingEnabled = true;\n\n            // adjust default clustered lighting parameters to handle many lights\n            const lighting = app.scene.lighting;\n\n            // 1) subdivide space with lights into this many cells\n            lighting.cells = new pc.Vec3(12, 4, 12);\n\n            // 2) and allow this many lights per cell\n            const maxLights = 24;\n            lighting.maxLightsPerCell = maxLights;\n\n            // enable clustered shadows (it's enabled by default as well)\n            lighting.shadowsEnabled = data.get('settings.shadowsEnabled');\n\n            // enable clustered cookies\n            lighting.cookiesEnabled = data.get('settings.cookiesEnabled');\n\n            // resolution of the shadow and cookie atlas\n            lighting.shadowAtlasResolution = data.get('settings.shadowAtlasResolution');\n            lighting.cookieAtlasResolution = 1500;\n\n            const splitOptions = [\n                null,               // automatic - split atlas each frame to give all required lights an equal size\n                [2, 1, 1, 2, 1],    // 7 shadows: split atlas to 2x2 (first number), and split created quarters to 1x1, 1x1, 2x2, 1x1\n                [3, 2],             // 12 shadows: split atlas to 3x3 (first number), and split one of the created parts to 2x2\n                [4]                 // 16 shadows: split atlas to 4x4\n            ];\n\n            // lights are static (not moving and so do not need to update shadows) or dynamic\n            let lightsStatic = false;\n\n            // debug rendering is enabled\n            let debugAtlas = false;\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // ground material\n            const groundMaterial = new pc.StandardMaterial();\n            groundMaterial.gloss = 0.55;\n            groundMaterial.metalness = 0.4;\n            groundMaterial.useMetalness = true;\n            groundMaterial.normalMap = assets.normal.resource;\n            groundMaterial.normalMapTiling.set(10, 10);\n            groundMaterial.bumpiness = 0.5;\n            groundMaterial.update();\n\n            // cube material\n            const cubeMaterial = new pc.StandardMaterial();\n            cubeMaterial.gloss = 0.55;\n            cubeMaterial.metalness = 0.4;\n            cubeMaterial.useMetalness = true;\n            cubeMaterial.normalMap = assets.normal.resource;\n            cubeMaterial.normalMapTiling.set(0.25, 0.25);\n            cubeMaterial.bumpiness = 0.5;\n            cubeMaterial.update();\n\n            // helper function to create a 3d primitive including its material\n            function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3, mat: pc.Material) {\n\n                // create the primitive using the material\n                const primitive = new pc.Entity();\n                primitive.addComponent('render', {\n                    type: primitiveType,\n                    castShadows: true,\n                    material: mat\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // create some visible geometry\n            const ground = createPrimitive(\"box\", new pc.Vec3(0, 0, 0), new pc.Vec3(500, 1, 500), groundMaterial);\n\n            const numTowers = 8;\n            for (let i = 0; i < numTowers; i++) {\n                let scale = 12;\n                const fraction = i / numTowers * Math.PI * 2;\n                const radius = 200;\n                const numCubes = 12;\n                for (let y = 0; y <= 10; y++) {\n                    const elevationRadius = radius * (1 - (y / numCubes));\n                    const pos = new pc.Vec3(elevationRadius * Math.sin(fraction), y * 6, elevationRadius * Math.cos(fraction));\n                    const prim = createPrimitive(\"box\", pos, new pc.Vec3(scale, scale, scale), cubeMaterial);\n                    prim.setLocalEulerAngles(Math.random() * 360, Math.random() * 360, Math.random() * 360);\n                }\n                scale -= 1.5;\n            }\n\n            const spotLightList: Array<pc.Entity> = [];\n            const cookieChannels = [\"r\", \"g\", \"b\", \"a\", \"rgb\"];\n\n            // helper function to create a light\n            function createLight(index: number) {\n                const intensity = 1.5;\n                const color = new pc.Color(intensity * Math.random(), intensity * Math.random(), intensity * Math.random(), 1);\n                const lightSpot = new pc.Entity(`Spot-${index}`);\n                const heartTexture = Math.random() < 0.5;\n                const cookieTexture = heartTexture ? assets.heart : assets.channels;\n                const cookieChannel = heartTexture ? \"a\" : cookieChannels[Math.floor(Math.random() * cookieChannels.length)];\n\n                lightSpot.addComponent(\"light\", {\n                    type: \"spot\",\n                    color: color,\n                    intensity: 3,\n                    innerConeAngle: 30,\n                    outerConeAngle: 35,\n                    range: 150,\n                    castShadows: true,\n                    shadowBias: 0.4,\n                    normalOffsetBias: 0.1,\n                    shadowResolution: 512,      // only used when clustering is off\n\n                    // when lights are static, only render shadows one time (or as needed when they use different atlas slot)\n                    shadowUpdateMode: lightsStatic ? pc.SHADOWUPDATE_THISFRAME : pc.SHADOWUPDATE_REALTIME,\n\n                    // cookie texture\n                    cookie: cookieTexture.resource,\n                    cookieChannel: cookieChannel,\n                    cookieIntensity: 0.5\n                });\n\n                // attach a render component with a small cone to each light\n                const material = new pc.StandardMaterial();\n                material.emissive = color;\n                material.update();\n\n                lightSpot.addComponent('render', {\n                    type: \"cone\",\n                    material: material,\n                    castShadows: false\n                });\n                lightSpot.setLocalScale(5, 5, 5);\n                app.root.addChild(lightSpot);\n                spotLightList.push(lightSpot);\n            }\n\n            // create many spot lights\n            const count = 10;\n            for (let i = 0; i < count; i++) {\n                createLight(i);\n            }\n            updateLightCount();\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.2, 0.2),\n                farClip: 2000,\n                nearClip: 1\n            });\n            app.root.addChild(camera);\n            camera.setLocalPosition(300 * Math.sin(0), 150, 300 * Math.cos(0));\n\n            // add orbit camera script with mouse and touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: ground,\n                    distanceMax: 1200,\n                    frameOnStart: false\n                }\n            });\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n\n            // handle HUD changes - update properties on the scene\n            data.on('*:set', (path: string, value: any) => {\n                const pathArray = path.split('.');\n                if (pathArray[1] === 'static') {\n\n                    lightsStatic = value;\n                    updateLightCount();\n\n                } else if (pathArray[1] === 'atlasSplit') {\n\n                    // assign atlas split option\n                    lighting.atlasSplit = splitOptions[value];\n\n                } else if (pathArray[1] === 'debug') {\n\n                    // debug rendering of lighting clusters on world layer\n                    lighting.debugLayer = value ? app.scene.layers.getLayerByName(\"World\").id : undefined;\n\n                } else if (pathArray[1] === 'debugAtlas') {\n\n                    // show debug atlas\n                    debugAtlas = value;\n                } else if (pathArray[1] === 'shadowIntensity') {\n                    for (let i = 0; i < spotLightList.length; i++) {\n                        spotLightList[i].light.shadowIntensity = value;\n                    }\n                } else {\n                    // @ts-ignore\n                    lighting[pathArray[1]] = value;\n                }\n            });\n\n            function updateLightCount() {\n\n                // update the number on HUD\n                data.set('settings.numLights', spotLightList.length);\n\n                // shadow update mode (need to force render shadow when we add / remove light, as they all move)\n                spotLightList.forEach((spot) => {\n                    spot.light.shadowUpdateMode = lightsStatic ? pc.SHADOWUPDATE_THISFRAME : pc.SHADOWUPDATE_REALTIME;\n                });\n            }\n\n            // add light button handler\n            data.on('add', function () {\n                if (spotLightList.length < maxLights) {\n                    createLight(spotLightList.length);\n                    updateLightCount();\n                }\n            });\n\n            // remove light button handler\n            data.on('remove', function () {\n                if (spotLightList.length) {\n                    const light = spotLightList.pop();\n                    app.root.removeChild(light);\n                    light.destroy();\n                    updateLightCount();\n                }\n            });\n\n            // Set an update function on the app's update event\n            let time = 0;\n            app.on(\"update\", function (dt: number) {\n\n                // don't move lights around when they're static\n                if (!lightsStatic) {\n                    time += dt * 0.15;\n                }\n\n                // rotate spot lights around\n                const lightPos = new pc.Vec3();\n                spotLightList.forEach(function (spotlight, i) {\n                    const angle = (i / spotLightList.length) * Math.PI * 2;\n                    const x = 130 * Math.sin(angle + time);\n                    const z = 130 * Math.cos(angle + time);\n                    lightPos.set(x, 100, z);\n                    spotlight.setLocalPosition(lightPos);\n\n                    lightPos.y = 0;\n                    spotlight.lookAt(lightPos, pc.Vec3.RIGHT);\n\n                    spotlight.rotateLocal(90, 0, 0);\n                });\n\n                // display shadow texture (debug feature, only works when depth is stored as color, which is webgl1)\n                // app.drawTexture(-0.7, 0.7, 0.4, 0.4, app.renderer.lightTextureAtlas.shadowAtlas.texture);\n\n                // display cookie texture (debug feature)\n                if (debugAtlas) {\n                    // @ts-ignore engine-tsd\n                    app.drawTexture(-0.7, 0.2, 0.4, 0.4, app.renderer.lightTextureAtlas.cookieAtlas);\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    const assets = {\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/orbit-camera.js\",\n        }),\n        channels: new pc.Asset(\"channels\", \"texture\", {\n            url: \"/static/assets/textures/channels.png\",\n        }),\n        heart: new pc.Asset(\"heart\", \"texture\", {\n            url: \"/static/assets/textures/heart.png\",\n        }),\n        normal: new pc.Asset(\"normal\", \"texture\", {\n            url: \"/static/assets/textures/normal-map.png\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            data.set(\"settings\", {\n                shadowAtlasResolution: 1024, // shadow map resolution storing all shadows\n                shadowType: pc.SHADOW_PCF3, // shadow filter type\n                shadowsEnabled: true,\n                cookiesEnabled: true,\n                shadowIntensity: 1,\n                numLights: 0,\n                debug: false,\n                debugAtlas: false,\n                splitOptions: 0,\n                static: false,\n            });\n\n            // setup skydome as ambient light\n            app.scene.skyboxMip = 3;\n            app.scene.skyboxIntensity = 0.1;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // enabled clustered lighting. This is a temporary API and will change in the future\n            app.scene.clusteredLightingEnabled = true;\n\n            // adjust default clustered lighting parameters to handle many lights\n            const lighting = app.scene.lighting;\n\n            // 1) subdivide space with lights into this many cells\n            lighting.cells = new pc.Vec3(12, 4, 12);\n\n            // 2) and allow this many lights per cell\n            const maxLights = 24;\n            lighting.maxLightsPerCell = maxLights;\n\n            // enable clustered shadows (it's enabled by default as well)\n            lighting.shadowsEnabled = data.get(\"settings.shadowsEnabled\");\n\n            // enable clustered cookies\n            lighting.cookiesEnabled = data.get(\"settings.cookiesEnabled\");\n\n            // resolution of the shadow and cookie atlas\n            lighting.shadowAtlasResolution = data.get(\n                \"settings.shadowAtlasResolution\"\n            );\n            lighting.cookieAtlasResolution = 1500;\n\n            const splitOptions = [\n                null, // automatic - split atlas each frame to give all required lights an equal size\n                [2, 1, 1, 2, 1], // 7 shadows: split atlas to 2x2 (first number), and split created quarters to 1x1, 1x1, 2x2, 1x1\n                [3, 2], // 12 shadows: split atlas to 3x3 (first number), and split one of the created parts to 2x2\n                [4], // 16 shadows: split atlas to 4x4\n            ];\n\n            // lights are static (not moving and so do not need to update shadows) or dynamic\n            let lightsStatic = false;\n\n            // debug rendering is enabled\n            let debugAtlas = false;\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // ground material\n            const groundMaterial = new pc.StandardMaterial();\n            groundMaterial.gloss = 0.55;\n            groundMaterial.metalness = 0.4;\n            groundMaterial.useMetalness = true;\n            groundMaterial.normalMap = assets.normal.resource;\n            groundMaterial.normalMapTiling.set(10, 10);\n            groundMaterial.bumpiness = 0.5;\n            groundMaterial.update();\n\n            // cube material\n            const cubeMaterial = new pc.StandardMaterial();\n            cubeMaterial.gloss = 0.55;\n            cubeMaterial.metalness = 0.4;\n            cubeMaterial.useMetalness = true;\n            cubeMaterial.normalMap = assets.normal.resource;\n            cubeMaterial.normalMapTiling.set(0.25, 0.25);\n            cubeMaterial.bumpiness = 0.5;\n            cubeMaterial.update();\n\n            // helper function to create a 3d primitive including its material\n            function createPrimitive(primitiveType, position, scale, mat) {\n                // create the primitive using the material\n                const primitive = new pc.Entity();\n                primitive.addComponent(\"render\", {\n                    type: primitiveType,\n                    castShadows: true,\n                    material: mat,\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // create some visible geometry\n            const ground = createPrimitive(\n                \"box\",\n                new pc.Vec3(0, 0, 0),\n                new pc.Vec3(500, 1, 500),\n                groundMaterial\n            );\n\n            const numTowers = 8;\n            for (let i = 0; i < numTowers; i++) {\n                let scale = 12;\n                const fraction = (i / numTowers) * Math.PI * 2;\n                const radius = 200;\n                const numCubes = 12;\n                for (let y = 0; y <= 10; y++) {\n                    const elevationRadius = radius * (1 - y / numCubes);\n                    const pos = new pc.Vec3(\n                        elevationRadius * Math.sin(fraction),\n                        y * 6,\n                        elevationRadius * Math.cos(fraction)\n                    );\n                    const prim = createPrimitive(\n                        \"box\",\n                        pos,\n                        new pc.Vec3(scale, scale, scale),\n                        cubeMaterial\n                    );\n                    prim.setLocalEulerAngles(\n                        Math.random() * 360,\n                        Math.random() * 360,\n                        Math.random() * 360\n                    );\n                }\n                scale -= 1.5;\n            }\n\n            const spotLightList = [];\n            const cookieChannels = [\"r\", \"g\", \"b\", \"a\", \"rgb\"];\n\n            // helper function to create a light\n            function createLight(index) {\n                const intensity = 1.5;\n                const color = new pc.Color(\n                    intensity * Math.random(),\n                    intensity * Math.random(),\n                    intensity * Math.random(),\n                    1\n                );\n                const lightSpot = new pc.Entity(`Spot-${index}`);\n                const heartTexture = Math.random() < 0.5;\n                const cookieTexture = heartTexture\n                    ? assets.heart\n                    : assets.channels;\n                const cookieChannel = heartTexture\n                    ? \"a\"\n                    : cookieChannels[\n                          Math.floor(Math.random() * cookieChannels.length)\n                      ];\n\n                lightSpot.addComponent(\"light\", {\n                    type: \"spot\",\n                    color: color,\n                    intensity: 3,\n                    innerConeAngle: 30,\n                    outerConeAngle: 35,\n                    range: 150,\n                    castShadows: true,\n                    shadowBias: 0.4,\n                    normalOffsetBias: 0.1,\n                    shadowResolution: 512, // only used when clustering is off\n\n                    // when lights are static, only render shadows one time (or as needed when they use different atlas slot)\n                    shadowUpdateMode: lightsStatic\n                        ? pc.SHADOWUPDATE_THISFRAME\n                        : pc.SHADOWUPDATE_REALTIME,\n\n                    // cookie texture\n                    cookie: cookieTexture.resource,\n                    cookieChannel: cookieChannel,\n                    cookieIntensity: 0.5,\n                });\n\n                // attach a render component with a small cone to each light\n                const material = new pc.StandardMaterial();\n                material.emissive = color;\n                material.update();\n\n                lightSpot.addComponent(\"render\", {\n                    type: \"cone\",\n                    material: material,\n                    castShadows: false,\n                });\n\n                lightSpot.setLocalScale(5, 5, 5);\n                app.root.addChild(lightSpot);\n                spotLightList.push(lightSpot);\n            }\n\n            // create many spot lights\n            const count = 10;\n            for (let i = 0; i < count; i++) {\n                createLight(i);\n            }\n            updateLightCount();\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.2, 0.2),\n                farClip: 2000,\n                nearClip: 1,\n            });\n\n            app.root.addChild(camera);\n            camera.setLocalPosition(300 * Math.sin(0), 150, 300 * Math.cos(0));\n\n            // add orbit camera script with mouse and touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: ground,\n                    distanceMax: 1200,\n                    frameOnStart: false,\n                },\n            });\n\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n\n            // handle HUD changes - update properties on the scene\n            data.on(\"*:set\", (path, value) => {\n                const pathArray = path.split(\".\");\n                if (pathArray[1] === \"static\") {\n                    lightsStatic = value;\n                    updateLightCount();\n                } else if (pathArray[1] === \"atlasSplit\") {\n                    // assign atlas split option\n                    lighting.atlasSplit = splitOptions[value];\n                } else if (pathArray[1] === \"debug\") {\n                    // debug rendering of lighting clusters on world layer\n                    lighting.debugLayer = value\n                        ? app.scene.layers.getLayerByName(\"World\").id\n                        : undefined;\n                } else if (pathArray[1] === \"debugAtlas\") {\n                    // show debug atlas\n                    debugAtlas = value;\n                } else if (pathArray[1] === \"shadowIntensity\") {\n                    for (let i = 0; i < spotLightList.length; i++) {\n                        spotLightList[i].light.shadowIntensity = value;\n                    }\n                } else {\n                    // @ts-ignore\n                    lighting[pathArray[1]] = value;\n                }\n            });\n\n            function updateLightCount() {\n                // update the number on HUD\n                data.set(\"settings.numLights\", spotLightList.length);\n\n                // shadow update mode (need to force render shadow when we add / remove light, as they all move)\n                spotLightList.forEach((spot) => {\n                    spot.light.shadowUpdateMode = lightsStatic\n                        ? pc.SHADOWUPDATE_THISFRAME\n                        : pc.SHADOWUPDATE_REALTIME;\n                });\n            }\n\n            // add light button handler\n            data.on(\"add\", function () {\n                if (spotLightList.length < maxLights) {\n                    createLight(spotLightList.length);\n                    updateLightCount();\n                }\n            });\n\n            // remove light button handler\n            data.on(\"remove\", function () {\n                if (spotLightList.length) {\n                    const light = spotLightList.pop();\n                    app.root.removeChild(light);\n                    light.destroy();\n                    updateLightCount();\n                }\n            });\n\n            // Set an update function on the app's update event\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                // don't move lights around when they're static\n                if (!lightsStatic) {\n                    time += dt * 0.15;\n                }\n\n                // rotate spot lights around\n                const lightPos = new pc.Vec3();\n                spotLightList.forEach(function (spotlight, i) {\n                    const angle = (i / spotLightList.length) * Math.PI * 2;\n                    const x = 130 * Math.sin(angle + time);\n                    const z = 130 * Math.cos(angle + time);\n                    lightPos.set(x, 100, z);\n                    spotlight.setLocalPosition(lightPos);\n\n                    lightPos.y = 0;\n                    spotlight.lookAt(lightPos, pc.Vec3.RIGHT);\n\n                    spotlight.rotateLocal(90, 0, 0);\n                });\n\n                // display shadow texture (debug feature, only works when depth is stored as color, which is webgl1)\n                // app.drawTexture(-0.7, 0.7, 0.4, 0.4, app.renderer.lightTextureAtlas.shadowAtlas.texture);\n\n                // display cookie texture (debug feature)\n                if (debugAtlas) {\n                    // @ts-ignore engine-tsd\n                    app.drawTexture(\n                        -0.7,\n                        0.2,\n                        0.4,\n                        0.4,\n                        app.renderer.lightTextureAtlas.cookieAtlas\n                    );\n                }\n            });\n        });\n    });\n}\n","nameSlug":"clustered-spot-shadows","categorySlug":"graphics"},"grab-pass":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, files: { 'shader.vert': string, 'shader.frag': string }): void {\n\n    const assets = {\n        'normal': new pc.Asset('normal', 'texture', { url: '/static/assets/textures/normal-map.png' }),\n        \"roughness\": new pc.Asset(\"roughness\", \"texture\", { url: \"/static/assets/textures/pc-gray.png\" }),\n        'helipad': new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // setup skydome\n            app.scene.skyboxMip = 0;\n            app.scene.exposure = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // Depth layer is where the framebuffer is copied to a texture to be used in the following layers.\n            // Move the depth layer to take place after World and Skydome layers, to capture both of them.\n            const depthLayer = app.scene.layers.getLayerById(pc.LAYERID_DEPTH);\n            app.scene.layers.remove(depthLayer);\n            app.scene.layers.insertOpaque(depthLayer, 2);\n\n            // helper function to create a primitive with shape type, position, scale, color\n            function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3, color: pc.Color) {\n                // create material of specified color\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                material.gloss = 0.6;\n                material.metalness = 0.4;\n                material.useMetalness = true;\n                material.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent('render', {\n                    type: primitiveType,\n                    material: material\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // create few primitives, keep their references to rotate them later\n            const primitives: any = [];\n            const count = 7;\n            const shapes = [\"box\", \"cone\", \"cylinder\", \"sphere\", \"capsule\"];\n            for (let i = 0; i < count; i++) {\n                const shapeName = shapes[Math.floor(Math.random() * shapes.length)];\n                const color = new pc.Color(Math.random(), Math.random(), Math.random());\n                const angle = 2 * Math.PI * i / count;\n                const pos = new pc.Vec3(12 * Math.sin(angle), 0, 12 * Math.cos(angle));\n                primitives.push(createPrimitive(shapeName, pos, new pc.Vec3(4, 8, 4), color));\n            }\n\n            // Create the camera, which renders entities\n            const camera = new pc.Entity(\"SceneCamera\");\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.2, 0.2)\n            });\n            app.root.addChild(camera);\n            camera.setLocalPosition(0, 10, 20);\n            camera.lookAt(pc.Vec3.ZERO);\n\n            // enable the camera to render the scene's color map.\n            camera.camera.requestSceneColorMap(true);\n\n            // create a primitive which uses refraction shader to distort the view behind it\n            const glass = createPrimitive(\"box\", new pc.Vec3(1, 3, 0), new pc.Vec3(10, 10, 10), new pc.Color(1, 1, 1));\n            glass.render.castShadows = false;\n            glass.render.receiveShadows = false;\n\n            const shader = pc.createShaderFromCode(app.graphicsDevice, files['shader.vert'], files['shader.frag'], 'myShader');\n\n            // reflection material using the shader\n            const refractionMaterial = new pc.Material();\n            refractionMaterial.shader = shader;\n            glass.render.material = refractionMaterial;\n\n            // set an offset map on the material\n            refractionMaterial.setParameter('uOffsetMap', assets.normal.resource);\n\n            // set roughness map\n            refractionMaterial.setParameter('uRoughnessMap', assets.roughness.resource);\n\n            // tint colors\n            refractionMaterial.setParameter('tints[0]', new Float32Array([\n                1, 0.7, 0.7,    // red\n                1, 1, 1,        // white\n                0.7, 0.7, 1,    // blue\n                1, 1, 1         // white\n            ]));\n\n            // transparency\n            refractionMaterial.blendType = pc.BLEND_NORMAL;\n            refractionMaterial.update();\n\n            // update things each frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // rotate the primitives\n                primitives.forEach((prim: pc.Entity) => {\n                    prim.rotate(0.3, 0.2, 0.1);\n                });\n\n                glass.rotate(-0.1, 0.1, -0.15);\n\n                // orbit the camera\n                camera.setLocalPosition(20 * Math.sin(time * 0.2), 7, 20 * Math.cos(time * 0.2));\n                camera.lookAt(new pc.Vec3(0, 2, 0));\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, files) {\n    const assets = {\n        normal: new pc.Asset(\"normal\", \"texture\", {\n            url: \"/static/assets/textures/normal-map.png\",\n        }),\n        roughness: new pc.Asset(\"roughness\", \"texture\", {\n            url: \"/static/assets/textures/pc-gray.png\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // setup skydome\n            app.scene.skyboxMip = 0;\n            app.scene.exposure = 2;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // Depth layer is where the framebuffer is copied to a texture to be used in the following layers.\n            // Move the depth layer to take place after World and Skydome layers, to capture both of them.\n            const depthLayer = app.scene.layers.getLayerById(pc.LAYERID_DEPTH);\n            app.scene.layers.remove(depthLayer);\n            app.scene.layers.insertOpaque(depthLayer, 2);\n\n            // helper function to create a primitive with shape type, position, scale, color\n            function createPrimitive(primitiveType, position, scale, color) {\n                // create material of specified color\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                material.gloss = 0.6;\n                material.metalness = 0.4;\n                material.useMetalness = true;\n                material.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent(\"render\", {\n                    type: primitiveType,\n                    material: material,\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // create few primitives, keep their references to rotate them later\n            const primitives = [];\n            const count = 7;\n            const shapes = [\"box\", \"cone\", \"cylinder\", \"sphere\", \"capsule\"];\n            for (let i = 0; i < count; i++) {\n                const shapeName =\n                    shapes[Math.floor(Math.random() * shapes.length)];\n                const color = new pc.Color(\n                    Math.random(),\n                    Math.random(),\n                    Math.random()\n                );\n                const angle = (2 * Math.PI * i) / count;\n                const pos = new pc.Vec3(\n                    12 * Math.sin(angle),\n                    0,\n                    12 * Math.cos(angle)\n                );\n                primitives.push(\n                    createPrimitive(shapeName, pos, new pc.Vec3(4, 8, 4), color)\n                );\n            }\n\n            // Create the camera, which renders entities\n            const camera = new pc.Entity(\"SceneCamera\");\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.2, 0.2),\n            });\n\n            app.root.addChild(camera);\n            camera.setLocalPosition(0, 10, 20);\n            camera.lookAt(pc.Vec3.ZERO);\n\n            // enable the camera to render the scene's color map.\n            camera.camera.requestSceneColorMap(true);\n\n            // create a primitive which uses refraction shader to distort the view behind it\n            const glass = createPrimitive(\n                \"box\",\n                new pc.Vec3(1, 3, 0),\n                new pc.Vec3(10, 10, 10),\n                new pc.Color(1, 1, 1)\n            );\n            glass.render.castShadows = false;\n            glass.render.receiveShadows = false;\n\n            const shader = pc.createShaderFromCode(\n                app.graphicsDevice,\n                files[\"shader.vert\"],\n                files[\"shader.frag\"],\n                \"myShader\"\n            );\n\n            // reflection material using the shader\n            const refractionMaterial = new pc.Material();\n            refractionMaterial.shader = shader;\n            glass.render.material = refractionMaterial;\n\n            // set an offset map on the material\n            refractionMaterial.setParameter(\n                \"uOffsetMap\",\n                assets.normal.resource\n            );\n\n            // set roughness map\n            refractionMaterial.setParameter(\n                \"uRoughnessMap\",\n                assets.roughness.resource\n            );\n\n            // tint colors\n            refractionMaterial.setParameter(\n                \"tints[0]\",\n                new Float32Array([\n                    1,\n                    0.7,\n                    0.7, // red\n                    1,\n                    1,\n                    1, // white\n                    0.7,\n                    0.7,\n                    1, // blue\n                    1,\n                    1,\n                    1, // white\n                ])\n            );\n\n            // transparency\n            refractionMaterial.blendType = pc.BLEND_NORMAL;\n            refractionMaterial.update();\n\n            // update things each frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // rotate the primitives\n                primitives.forEach((prim) => {\n                    prim.rotate(0.3, 0.2, 0.1);\n                });\n\n                glass.rotate(-0.1, 0.1, -0.15);\n\n                // orbit the camera\n                camera.setLocalPosition(\n                    20 * Math.sin(time * 0.2),\n                    7,\n                    20 * Math.cos(time * 0.2)\n                );\n                camera.lookAt(new pc.Vec3(0, 2, 0));\n            });\n        });\n    });\n}\n","nameSlug":"grab-pass","categorySlug":"graphics","files":{"shader.vert":"\n            attribute vec3 vertex_position;\n            attribute vec2 vertex_texCoord0;\n\n            uniform mat4 matrix_model;\n            uniform mat4 matrix_viewProjection;\n\n            varying vec2 texCoord;\n\n            void main(void)\n            {\n                // project the position\n                vec4 pos = matrix_model * vec4(vertex_position, 1.0);\n                gl_Position = matrix_viewProjection * pos;\n\n                texCoord = vertex_texCoord0;\n            }\n        ","shader.frag":"\n            // use the special uSceneColorMap texture, which is a built-in texture containing\n            // a copy of the color buffer at the point of capture, inside the Depth layer.\n            uniform sampler2D uSceneColorMap;\n\n            // normal map providing offsets\n            uniform sampler2D uOffsetMap;\n\n            // roughness map\n            uniform sampler2D uRoughnessMap;\n\n            // tint colors\n            uniform vec3 tints[4];\n\n            // engine built-in constant storing render target size in .xy and inverse size in .zw\n            uniform vec4 uScreenSize;\n\n            varying vec2 texCoord;\n\n            void main(void)\n            {\n                float roughness = 1.0 - texture2D(uRoughnessMap, texCoord).r;\n\n                // sample offset texture - used to add distortion to the sampled background\n                vec2 offset = texture2D(uOffsetMap, texCoord).rg;\n                offset = 2.0 * offset - 1.0;\n\n                // offset strength\n                offset *= (0.2 + roughness) * 0.015;\n\n                // get normalized uv coordinates for canvas\n                vec2 grabUv = gl_FragCoord.xy * uScreenSize.zw;\n\n                // roughness dictates which mipmap level gets used, in 0..4 range\n                float mipmap = roughness * 5.0;\n\n                // get background pixel color with distorted offset\n                vec3 grabColor = texture2DLodEXT(uSceneColorMap, grabUv + offset, mipmap).rgb;\n\n                // tint the material based on mipmap, on WebGL2 only, as WebGL1 does not support non-constant array indexing\n                // (note - this could be worked around by using a series of if statements in this case)\n                #ifdef GL2\n                    float tintIndex = clamp(mipmap, 0.0, 3.0);\n                    grabColor *= tints[int(tintIndex)];\n                #endif\n\n                // brighten the refracted texture a little bit\n                // brighten even more the rough parts of the glass\n                gl_FragColor = vec4(grabColor * 1.1, 1.0) + roughness * 0.09;\n            }\n        "}},"ground-fog":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, files: { 'shader.vert': string, 'shader.frag': string }, data: any): void {\n\n    const assets = {\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' }),\n        'terrain': new pc.Asset('terrain', 'container', { url: '/static/assets/models/terrain.glb' }),\n        'helipad': new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'texture': new pc.Asset('color', 'texture', { url: '/static/assets/textures/clouds.jpg' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js',\n\n        // WebGPU does not currently support antialiased depth resolve, disable it till we implement a shader resolve solution\n        antialias: false\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            data.set('data', {\n                softness: true\n            });\n\n            // setup skydome\n            app.scene.skyboxMip = 3;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(0, -70, 0);\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // disable skydome rendering\n            const skyLayer = app.scene.layers.getLayerById(pc.LAYERID_SKYBOX);\n            skyLayer.enabled = false;\n\n            // instantiate the terrain\n            const terrain = assets.terrain.resource.instantiateRenderEntity();\n            terrain.setLocalScale(30, 30, 30);\n            app.root.addChild(terrain);\n\n            // find a tree in the middle to use as a focus point\n            const tree = terrain.findOne(\"name\", \"Arbol 2.002\");\n\n            // create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(150 / 255, 213 / 255, 63 / 255),\n                farClip: 1000\n            });\n\n            // and position it in the world\n            camera.setLocalPosition(-200, 120, 225);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: tree,\n                    distanceMax: 600\n                }\n            });\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // enable the camera to render the scene's depth map.\n            camera.camera.requestSceneDepthMap(true);\n\n            // Create a directional light casting cascaded shadows\n            const dirLight = new pc.Entity();\n            dirLight.addComponent(\"light\", {\n                type: \"directional\",\n                color: pc.Color.WHITE,\n                shadowBias: 0.3,\n                normalOffsetBias: 0.2,\n                intensity: 1.0,\n\n                // enable shadow casting\n                castShadows: true,\n                shadowDistance: 1000,\n                shadowResolution: 2048,\n                shadowType: pc.SHADOW_PCF3\n            });\n            app.root.addChild(dirLight);\n            dirLight.setLocalEulerAngles(45, 350, 20);\n\n            // create a custom fog shader\n            // @ts-ignore\n            const vertex = `#define VERTEXSHADER\\n` + pc.shaderChunks.screenDepthPS + files['shader.vert'];\n            // @ts-ignore\n            const fragment = pc.shaderChunks.screenDepthPS + files['shader.frag'];\n            const shader = pc.createShaderFromCode(app.graphicsDevice, vertex, fragment, 'GroundFogShader');\n\n            // and set up a material using this shader\n            const material = new pc.Material();\n            material.shader = shader;\n            material.setParameter('uTexture', assets.texture.resource);\n            material.depthWrite = false;\n            material.depthWrite = false;\n            material.blendType = pc.BLEND_NORMAL;\n            material.update();\n\n            // create a subdivided plane mesh, to allow for vertex animation by the shader\n            const mesh = pc.createPlane(app.graphicsDevice, { widthSegments: 20, lengthSegments: 20 });\n            const meshInstance = new pc.MeshInstance(mesh, material);\n            const ground = new pc.Entity();\n            ground.addComponent(\"render\", {\n                meshInstances: [meshInstance],\n                material: material,\n                castShadows: false,\n                receiveShadows: false\n            });\n            ground.setLocalScale(500, 1, 500);\n            ground.setLocalPosition(0, 25, 0);\n            app.root.addChild(ground);\n\n            let firstFrame = true;\n            let currentTime = 0;\n            app.on(\"update\", function (dt) {\n\n                // on the first frame, when camera is updated, move it further away from the focus tree\n                if (firstFrame) {\n                    firstFrame = false;\n                    // @ts-ignore engine-tsd\n                    camera.script.orbitCamera.distance = 320;\n                }\n\n                // Update the time and pass it to shader\n                currentTime += dt;\n                material.setParameter('uTime', currentTime);\n\n                // based on sofness toggle, set shader parameter\n                material.setParameter('uSoftening', data.get('data.softness') ? 50 : 1000);\n\n                // debug rendering of the deptht texture in the corner\n                app.drawDepthTexture(0.7, -0.7, 0.5, 0.5);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, files, data) {\n    const assets = {\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/orbit-camera.js\",\n        }),\n        terrain: new pc.Asset(\"terrain\", \"container\", {\n            url: \"/static/assets/models/terrain.glb\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        texture: new pc.Asset(\"color\", \"texture\", {\n            url: \"/static/assets/textures/clouds.jpg\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n\n        // WebGPU does not currently support antialiased depth resolve, disable it till we implement a shader resolve solution\n        antialias: false,\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            data.set(\"data\", {\n                softness: true,\n            });\n\n            // setup skydome\n            app.scene.skyboxMip = 3;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(\n                0,\n                -70,\n                0\n            );\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // disable skydome rendering\n            const skyLayer = app.scene.layers.getLayerById(pc.LAYERID_SKYBOX);\n            skyLayer.enabled = false;\n\n            // instantiate the terrain\n            const terrain = assets.terrain.resource.instantiateRenderEntity();\n            terrain.setLocalScale(30, 30, 30);\n            app.root.addChild(terrain);\n\n            // find a tree in the middle to use as a focus point\n            const tree = terrain.findOne(\"name\", \"Arbol 2.002\");\n\n            // create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(150 / 255, 213 / 255, 63 / 255),\n                farClip: 1000,\n            });\n\n            // and position it in the world\n            camera.setLocalPosition(-200, 120, 225);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: tree,\n                    distanceMax: 600,\n                },\n            });\n\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // enable the camera to render the scene's depth map.\n            camera.camera.requestSceneDepthMap(true);\n\n            // Create a directional light casting cascaded shadows\n            const dirLight = new pc.Entity();\n            dirLight.addComponent(\"light\", {\n                type: \"directional\",\n                color: pc.Color.WHITE,\n                shadowBias: 0.3,\n                normalOffsetBias: 0.2,\n                intensity: 1.0,\n\n                // enable shadow casting\n                castShadows: true,\n                shadowDistance: 1000,\n                shadowResolution: 2048,\n                shadowType: pc.SHADOW_PCF3,\n            });\n\n            app.root.addChild(dirLight);\n            dirLight.setLocalEulerAngles(45, 350, 20);\n\n            // create a custom fog shader\n            // @ts-ignore\n            const vertex =\n                `#define VERTEXSHADER\\n` +\n                pc.shaderChunks.screenDepthPS +\n                files[\"shader.vert\"];\n            // @ts-ignore\n            const fragment =\n                pc.shaderChunks.screenDepthPS + files[\"shader.frag\"];\n            const shader = pc.createShaderFromCode(\n                app.graphicsDevice,\n                vertex,\n                fragment,\n                \"GroundFogShader\"\n            );\n\n            // and set up a material using this shader\n            const material = new pc.Material();\n            material.shader = shader;\n            material.setParameter(\"uTexture\", assets.texture.resource);\n            material.depthWrite = false;\n            material.depthWrite = false;\n            material.blendType = pc.BLEND_NORMAL;\n            material.update();\n\n            // create a subdivided plane mesh, to allow for vertex animation by the shader\n            const mesh = pc.createPlane(app.graphicsDevice, {\n                widthSegments: 20,\n                lengthSegments: 20,\n            });\n            const meshInstance = new pc.MeshInstance(mesh, material);\n            const ground = new pc.Entity();\n            ground.addComponent(\"render\", {\n                meshInstances: [meshInstance],\n                material: material,\n                castShadows: false,\n                receiveShadows: false,\n            });\n\n            ground.setLocalScale(500, 1, 500);\n            ground.setLocalPosition(0, 25, 0);\n            app.root.addChild(ground);\n\n            let firstFrame = true;\n            let currentTime = 0;\n            app.on(\"update\", function (dt) {\n                // on the first frame, when camera is updated, move it further away from the focus tree\n                if (firstFrame) {\n                    firstFrame = false;\n                    // @ts-ignore engine-tsd\n                    camera.script.orbitCamera.distance = 320;\n                }\n\n                // Update the time and pass it to shader\n                currentTime += dt;\n                material.setParameter(\"uTime\", currentTime);\n\n                // based on sofness toggle, set shader parameter\n                material.setParameter(\n                    \"uSoftening\",\n                    data.get(\"data.softness\") ? 50 : 1000\n                );\n\n                // debug rendering of the deptht texture in the corner\n                app.drawDepthTexture(0.7, -0.7, 0.5, 0.5);\n            });\n        });\n    });\n}\n","nameSlug":"ground-fog","categorySlug":"graphics","files":{"shader.vert":"\n            attribute vec3 vertex_position;\n            attribute vec2 vertex_texCoord0;\n\n            uniform mat4 matrix_model;\n            uniform mat4 matrix_viewProjection;\n            uniform float uTime;\n            uniform sampler2D uTexture;\n\n            varying vec2 texCoord0;\n            varying vec2 texCoord1;\n            varying vec2 texCoord2;\n            varying vec4 screenPos;\n            varying float depth;\n\n            void main(void)\n            {\n                // 3 scrolling texture coordinates with different direction and speed\n                texCoord0 = vertex_texCoord0 * 2.0 + vec2(uTime * 0.003, uTime * 0.01);\n                texCoord1 = vertex_texCoord0 * 1.5 + vec2(uTime * -0.02, uTime * 0.02);\n                texCoord2 = vertex_texCoord0 * 1.0 + vec2(uTime * 0.01, uTime * -0.003);\n\n                // sample the fog texture to have elevation for this vertex\n                vec2 offsetTexCoord = vertex_texCoord0 + vec2(uTime * 0.001, uTime * -0.0003);\n                float offset = texture2D(uTexture, offsetTexCoord).r;\n\n                // vertex in the world space\n                vec4 pos = matrix_model * vec4(vertex_position, 1.0);\n\n                // move it up based on the offset\n                pos.y += offset * 25.0;\n\n                // position in projected (screen) space\n                vec4 projPos = matrix_viewProjection * pos;\n                gl_Position = projPos;\n\n                // the linear depth of the vertex (in camera space)\n                depth = getLinearDepth(pos.xyz);\n\n                // screen fragment position, used to sample the depth texture\n                screenPos = projPos;\n            }\n        ","shader.frag":"\n            uniform sampler2D uTexture;\n            uniform float uSoftening;\n\n            varying vec2 texCoord0;\n            varying vec2 texCoord1;\n            varying vec2 texCoord2;\n            varying vec4 screenPos;\n            varying float depth;\n            \n            void main(void)\n            {\n                // sample the texture 3 times and compute average intensity of the fog\n                vec4 diffusTexture0 = texture2D (uTexture, texCoord0);\n                vec4 diffusTexture1 = texture2D (uTexture, texCoord1);\n                vec4 diffusTexture2 = texture2D (uTexture, texCoord2);\n                float alpha = 0.5 * (diffusTexture0.r + diffusTexture1.r + diffusTexture2.r);\n\n                // use built-in getGrabScreenPos function to convert screen position to grab texture uv coords\n                vec2 screenCoord = getGrabScreenPos(screenPos);\n\n                // read the depth from the depth buffer\n                float sceneDepth = getLinearScreenDepth(screenCoord) * camera_params.x;\n\n                // depth of the current fragment (on the fog plane)\n                float fragmentDepth = depth * camera_params.x;\n\n                // difference between these two depths is used to adjust the alpha, to fade out\n                // the fog near the geometry\n                float depthDiff = clamp(abs(fragmentDepth - sceneDepth) * uSoftening, 0.0, 1.0);\n                alpha *= smoothstep(0.0, 1.0, depthDiff);\n\n                // final color\n                vec3 fogColor = vec3(1.0, 1.0, 1.0);\n                gl_FragColor = vec4(fogColor, alpha);\n            }\n        "}},"hardware-instancing":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // setup skydome\n            app.scene.skyboxMip = 2;\n            app.scene.exposure = 0.3;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // set up some general scene rendering properties\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n            });\n            app.root.addChild(camera);\n\n            // Move the camera back to see the cubes\n            camera.translate(0, 0, 10);\n\n            // create standard material and enable instancing on it\n            const material = new pc.StandardMaterial();\n            material.onUpdateShader = function (options) {\n                options.litOptions.useInstancing = true;\n                return options;\n            };\n            material.gloss = 0.6;\n            material.metalness = 0.7;\n            material.useMetalness = true;\n            material.update();\n\n            // Create a Entity with a cylinder render component and the instancing material\n            const box = new pc.Entity(\"InstancingEntity\");\n            box.addComponent(\"render\", {\n                material: material,\n                type: \"cylinder\"\n            });\n\n            // add the box entity to the hierarchy\n            app.root.addChild(box);\n\n            if (app.graphicsDevice.supportsInstancing) {\n                // number of instances to render\n                const instanceCount = 1000;\n\n                // store matrices for individual instances into array\n                const matrices = new Float32Array(instanceCount * 16);\n                let matrixIndex = 0;\n\n                const radius = 5;\n                const pos = new pc.Vec3();\n                const rot = new pc.Quat();\n                const scl = new pc.Vec3();\n                const matrix = new pc.Mat4();\n\n                for (let i = 0; i < instanceCount; i++) {\n                    // generate random positions / scales and rotations\n                    pos.set(Math.random() * radius - radius * 0.5, Math.random() * radius - radius * 0.5, Math.random() * radius - radius * 0.5);\n                    scl.set(0.1 + Math.random() * 0.1, 0.1 + Math.random() * 0.3, 0.1 + Math.random() * 0.1);\n                    rot.setFromEulerAngles(i * 30, i * 50, i * 70);\n                    matrix.setTRS(pos, rot, scl);\n\n                    // copy matrix elements into array of floats\n                    for (let m = 0; m < 16; m++)\n                        matrices[matrixIndex++] = matrix.data[m];\n                }\n\n                // create static vertex buffer containing the matrices\n                const vertexBuffer = new pc.VertexBuffer(app.graphicsDevice, pc.VertexFormat.getDefaultInstancingFormat(app.graphicsDevice),\n                                                         instanceCount, pc.BUFFER_STATIC, matrices);\n\n                // initialize instancing using the vertex buffer on meshInstance of the created box\n                const boxMeshInst = box.render.meshInstances[0];\n                boxMeshInst.setInstancing(vertexBuffer);\n            }\n\n            // Set an update function on the app's update event\n            let angle = 0;\n            app.on(\"update\", function (dt) {\n                // orbit camera around\n                angle += dt * 0.2;\n                camera.setLocalPosition(8 * Math.sin(angle), 0, 8 * Math.cos(angle));\n                camera.lookAt(pc.Vec3.ZERO);\n            });\n        });\n    }).catch(console.error);\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions)\n        .then((device) => {\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.RenderComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n            ];\n\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assetListLoader = new pc.AssetListLoader(\n                Object.values(assets),\n                app.assets\n            );\n            assetListLoader.load(() => {\n                app.start();\n\n                // setup skydome\n                app.scene.skyboxMip = 2;\n                app.scene.exposure = 0.3;\n                app.scene.envAtlas = assets.helipad.resource;\n\n                // set up some general scene rendering properties\n                app.scene.toneMapping = pc.TONEMAP_ACES;\n\n                app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);\n\n                // Create an Entity with a camera component\n                const camera = new pc.Entity();\n                camera.addComponent(\"camera\", {});\n\n                app.root.addChild(camera);\n\n                // Move the camera back to see the cubes\n                camera.translate(0, 0, 10);\n\n                // create standard material and enable instancing on it\n                const material = new pc.StandardMaterial();\n                material.onUpdateShader = function (options) {\n                    options.litOptions.useInstancing = true;\n                    return options;\n                };\n                material.gloss = 0.6;\n                material.metalness = 0.7;\n                material.useMetalness = true;\n                material.update();\n\n                // Create a Entity with a cylinder render component and the instancing material\n                const box = new pc.Entity(\"InstancingEntity\");\n                box.addComponent(\"render\", {\n                    material: material,\n                    type: \"cylinder\",\n                });\n\n                // add the box entity to the hierarchy\n                app.root.addChild(box);\n\n                if (app.graphicsDevice.supportsInstancing) {\n                    // number of instances to render\n                    const instanceCount = 1000;\n\n                    // store matrices for individual instances into array\n                    const matrices = new Float32Array(instanceCount * 16);\n                    let matrixIndex = 0;\n\n                    const radius = 5;\n                    const pos = new pc.Vec3();\n                    const rot = new pc.Quat();\n                    const scl = new pc.Vec3();\n                    const matrix = new pc.Mat4();\n\n                    for (let i = 0; i < instanceCount; i++) {\n                        // generate random positions / scales and rotations\n                        pos.set(\n                            Math.random() * radius - radius * 0.5,\n                            Math.random() * radius - radius * 0.5,\n                            Math.random() * radius - radius * 0.5\n                        );\n                        scl.set(\n                            0.1 + Math.random() * 0.1,\n                            0.1 + Math.random() * 0.3,\n                            0.1 + Math.random() * 0.1\n                        );\n                        rot.setFromEulerAngles(i * 30, i * 50, i * 70);\n                        matrix.setTRS(pos, rot, scl);\n\n                        // copy matrix elements into array of floats\n                        for (let m = 0; m < 16; m++)\n                            matrices[matrixIndex++] = matrix.data[m];\n                    }\n\n                    // create static vertex buffer containing the matrices\n                    const vertexBuffer = new pc.VertexBuffer(\n                        app.graphicsDevice,\n                        pc.VertexFormat.getDefaultInstancingFormat(\n                            app.graphicsDevice\n                        ),\n                        instanceCount,\n                        pc.BUFFER_STATIC,\n                        matrices\n                    );\n\n                    // initialize instancing using the vertex buffer on meshInstance of the created box\n                    const boxMeshInst = box.render.meshInstances[0];\n                    boxMeshInst.setInstancing(vertexBuffer);\n                }\n\n                // Set an update function on the app's update event\n                let angle = 0;\n                app.on(\"update\", function (dt) {\n                    // orbit camera around\n                    angle += dt * 0.2;\n                    camera.setLocalPosition(\n                        8 * Math.sin(angle),\n                        0,\n                        8 * Math.cos(angle)\n                    );\n                    camera.lookAt(pc.Vec3.ZERO);\n                });\n            });\n        })\n        .catch(console.error);\n}\n","nameSlug":"hardware-instancing","categorySlug":"graphics"},"hierarchy":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.start();\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        // helper function to create a primitive with shape type, position, scale\n        function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3) {\n            // create material of random color\n            const material = new pc.StandardMaterial();\n            material.diffuse = new pc.Color(Math.random(), Math.random(), Math.random());\n            material.update();\n\n            // create primitive with a render component\n            const primitive = new pc.Entity();\n            primitive.addComponent('render', {\n                type: primitiveType,\n                material: material\n            });\n\n            // set position and scale\n            primitive.setLocalPosition(position);\n            primitive.setLocalScale(scale);\n\n            return primitive;\n        }\n\n        // list of all created entities\n        const entities: Array<pc.Entity> = [];\n\n        // helper recursive function to create a next layer of entities for a specified parent\n        function createChildren(parent: pc.Entity, gridSize: number, scale: number, scaleDelta: number, spacing: number, levels: number) {\n            if (levels >= 0) {\n                const offset = spacing * (gridSize - 1) * 0.5;\n                for (let x = 0; x < gridSize; x++) {\n                    for (let y = 0; y < gridSize; y++) {\n                        const shape = Math.random() < 0.5 ? \"box\" : \"sphere\";\n                        const position = new pc.Vec3(x * spacing - offset, spacing, y * spacing - offset);\n                        const entity = createPrimitive(shape, position, new pc.Vec3(scale, scale, scale));\n\n                        parent.addChild(entity);\n                        entities.push(entity);\n\n                        createChildren(entity, gridSize, scale - scaleDelta, scaleDelta, spacing * 0.7, levels - 1);\n                    }\n                }\n            }\n        }\n\n        // dummy root entity\n        const root = new pc.Entity();\n        app.root.addChild(root);\n\n        // generate hierarchy of children entities\n        const levels = 5;\n        const gridSize = 2;\n        const scale = 1.7;\n        const scaleDelta = 0.25;\n        const spacing = 7;\n        createChildren(root, gridSize, scale, scaleDelta, spacing, levels);\n        console.log(\"number of created entities: \" + entities.length);\n\n        // Create main camera\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.1, 0.1, 0.1)\n        });\n        camera.setLocalPosition(90 * Math.sin(0), 40, 90 * Math.cos(0));\n        camera.lookAt(new pc.Vec3(0, 5, 0));\n        app.root.addChild(camera);\n\n        // Create an Entity with a omni light component\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"omni\",\n            color: new pc.Color(1, 1, 1),\n            range: 150\n        });\n        light.translate(40, 60, 50);\n        app.root.addChild(light);\n\n        // update each frame\n        let time = 0;\n        app.on(\"update\", function (dt) {\n            time += dt;\n\n            // rotation quaternion changing with time\n            const rot = new pc.Quat();\n            rot.setFromEulerAngles(time * 5, time * 13, time * 6);\n\n            // apply it to all entities\n            for (let e = 0; e < entities.length; e++) {\n                entities[e].setLocalRotation(rot);\n            }\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.start();\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        // helper function to create a primitive with shape type, position, scale\n        function createPrimitive(primitiveType, position, scale) {\n            // create material of random color\n            const material = new pc.StandardMaterial();\n            material.diffuse = new pc.Color(\n                Math.random(),\n                Math.random(),\n                Math.random()\n            );\n            material.update();\n\n            // create primitive with a render component\n            const primitive = new pc.Entity();\n            primitive.addComponent(\"render\", {\n                type: primitiveType,\n                material: material,\n            });\n\n            // set position and scale\n            primitive.setLocalPosition(position);\n            primitive.setLocalScale(scale);\n\n            return primitive;\n        }\n\n        // list of all created entities\n        const entities = [];\n\n        // helper recursive function to create a next layer of entities for a specified parent\n        function createChildren(\n            parent,\n            gridSize,\n            scale,\n            scaleDelta,\n            spacing,\n            levels\n        ) {\n            if (levels >= 0) {\n                const offset = spacing * (gridSize - 1) * 0.5;\n                for (let x = 0; x < gridSize; x++) {\n                    for (let y = 0; y < gridSize; y++) {\n                        const shape = Math.random() < 0.5 ? \"box\" : \"sphere\";\n                        const position = new pc.Vec3(\n                            x * spacing - offset,\n                            spacing,\n                            y * spacing - offset\n                        );\n                        const entity = createPrimitive(\n                            shape,\n                            position,\n                            new pc.Vec3(scale, scale, scale)\n                        );\n\n                        parent.addChild(entity);\n                        entities.push(entity);\n\n                        createChildren(\n                            entity,\n                            gridSize,\n                            scale - scaleDelta,\n                            scaleDelta,\n                            spacing * 0.7,\n                            levels - 1\n                        );\n                    }\n                }\n            }\n        }\n\n        // dummy root entity\n        const root = new pc.Entity();\n        app.root.addChild(root);\n\n        // generate hierarchy of children entities\n        const levels = 5;\n        const gridSize = 2;\n        const scale = 1.7;\n        const scaleDelta = 0.25;\n        const spacing = 7;\n        createChildren(root, gridSize, scale, scaleDelta, spacing, levels);\n        console.log(\"number of created entities: \" + entities.length);\n\n        // Create main camera\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.1, 0.1, 0.1),\n        });\n\n        camera.setLocalPosition(90 * Math.sin(0), 40, 90 * Math.cos(0));\n        camera.lookAt(new pc.Vec3(0, 5, 0));\n        app.root.addChild(camera);\n\n        // Create an Entity with a omni light component\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"omni\",\n            color: new pc.Color(1, 1, 1),\n            range: 150,\n        });\n\n        light.translate(40, 60, 50);\n        app.root.addChild(light);\n\n        // update each frame\n        let time = 0;\n        app.on(\"update\", function (dt) {\n            time += dt;\n\n            // rotation quaternion changing with time\n            const rot = new pc.Quat();\n            rot.setFromEulerAngles(time * 5, time * 13, time * 6);\n\n            // apply it to all entities\n            for (let e = 0; e < entities.length; e++) {\n                entities[e].setLocalRotation(rot);\n            }\n        });\n    });\n}\n","nameSlug":"hierarchy","categorySlug":"graphics"},"layers":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.start();\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        // Create a new layer to put in front of everything\n        const layer = new pc.Layer({\n            name: \"Front Layer\"\n        });\n\n        // get the world layer index\n        const worldLayer = app.scene.layers.getLayerByName(\"World\");\n        const idx = app.scene.layers.getTransparentIndex(worldLayer);\n\n        // insert the new layer after the world layer\n        app.scene.layers.insert(layer, idx + 1);\n\n        // Create an Entity with a camera component\n        // Make sure it renders both World and Front Layer\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.4, 0.45, 0.5),\n            layers: [worldLayer.id, layer.id]\n        });\n        camera.translate(0, 0, 24);\n        app.root.addChild(camera);\n\n        // Create an Entity with a omni light component\n        // Make sure it lights both World and Front Layer\n        const light = new pc.Entity();\n        light.addComponent('light', {\n            type: 'omni',\n            color: new pc.Color(1, 1, 1),\n            range: 100,\n            layers: [worldLayer.id, layer.id]\n        });\n        light.translate(5, 0, 15);\n        app.root.addChild(light);\n\n        // red material is semi-transparent\n        const red = new pc.StandardMaterial();\n        red.diffuse.set(1, 0, 0);\n        red.blendType = pc.BLEND_NORMAL;\n        red.opacity = 0.5;\n        red.update();\n\n        // blue material does not test the existing depth buffer\n        const blue = new pc.StandardMaterial();\n        blue.diffuse.set(0, 0, 1);\n        blue.depthTest = false;\n        blue.update();\n\n        // red box is rendered first in World layer\n        const redBox = new pc.Entity();\n        redBox.addComponent('render', {\n            type: 'box',\n            material: red\n        });\n        redBox.setLocalScale(5, 5, 5);\n        app.root.addChild(redBox);\n\n        // blue box is rendered in the Front Layer which is after World\n        // because it does not test for depth\n        // and is in a later layer\n        // it is visible even though it should be inside the red box\n        const blueBox = new pc.Entity();\n        blueBox.addComponent('render', {\n            type: 'box',\n            material: blue,\n            layers: [layer.id] // try removing this line, the blue box will appear inside the red one\n        });\n        blueBox.setLocalScale(2.5, 2.5, 2.5);\n        app.root.addChild(blueBox);\n\n        app.on(\"update\", function (dt) {\n            if (redBox) {\n                redBox.rotate(0, 10 * dt, 0);\n            }\n            if (blueBox) {\n                blueBox.rotate(0, -10 * dt, 0);\n            }\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.start();\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        // Create a new layer to put in front of everything\n        const layer = new pc.Layer({\n            name: \"Front Layer\",\n        });\n\n        // get the world layer index\n        const worldLayer = app.scene.layers.getLayerByName(\"World\");\n        const idx = app.scene.layers.getTransparentIndex(worldLayer);\n\n        // insert the new layer after the world layer\n        app.scene.layers.insert(layer, idx + 1);\n\n        // Create an Entity with a camera component\n        // Make sure it renders both World and Front Layer\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.4, 0.45, 0.5),\n            layers: [worldLayer.id, layer.id],\n        });\n\n        camera.translate(0, 0, 24);\n        app.root.addChild(camera);\n\n        // Create an Entity with a omni light component\n        // Make sure it lights both World and Front Layer\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"omni\",\n            color: new pc.Color(1, 1, 1),\n            range: 100,\n            layers: [worldLayer.id, layer.id],\n        });\n\n        light.translate(5, 0, 15);\n        app.root.addChild(light);\n\n        // red material is semi-transparent\n        const red = new pc.StandardMaterial();\n        red.diffuse.set(1, 0, 0);\n        red.blendType = pc.BLEND_NORMAL;\n        red.opacity = 0.5;\n        red.update();\n\n        // blue material does not test the existing depth buffer\n        const blue = new pc.StandardMaterial();\n        blue.diffuse.set(0, 0, 1);\n        blue.depthTest = false;\n        blue.update();\n\n        // red box is rendered first in World layer\n        const redBox = new pc.Entity();\n        redBox.addComponent(\"render\", {\n            type: \"box\",\n            material: red,\n        });\n\n        redBox.setLocalScale(5, 5, 5);\n        app.root.addChild(redBox);\n\n        // blue box is rendered in the Front Layer which is after World\n        // because it does not test for depth\n        // and is in a later layer\n        // it is visible even though it should be inside the red box\n        const blueBox = new pc.Entity();\n        blueBox.addComponent(\"render\", {\n            type: \"box\",\n            material: blue,\n            layers: [layer.id], // try removing this line, the blue box will appear inside the red one\n        });\n        blueBox.setLocalScale(2.5, 2.5, 2.5);\n        app.root.addChild(blueBox);\n\n        app.on(\"update\", function (dt) {\n            if (redBox) {\n                redBox.rotate(0, 10 * dt, 0);\n            }\n            if (blueBox) {\n                blueBox.rotate(0, -10 * dt, 0);\n            }\n        });\n    });\n}\n","nameSlug":"layers","categorySlug":"graphics"},"light-physical-units":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data: any): void {\n\n    const assets = {\n        orbitCamera: new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' }),\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        lights: new pc.Asset('lights', 'container', { url: '/static/assets/models/Lights.glb' }),\n        sheen: new pc.Asset('sheen', 'container', { url: '/static/assets/models/SheenChair.glb' }),\n        color: new pc.Asset('color', 'texture', { url: '/static/assets/textures/seaside-rocks01-color.jpg' }),\n        normal: new pc.Asset('normal', 'texture', { url: '/static/assets/textures/seaside-rocks01-normal.jpg' }),\n        gloss: new pc.Asset('gloss', 'texture', { url: '/static/assets/textures/seaside-rocks01-gloss.jpg' }),\n        luts: new pc.Asset('luts', 'json', { url: '/static/assets/json/area-light-luts.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.keyboard = new pc.Keyboard(document.body);\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.JsonHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.skyboxMip = 1;\n            app.scene.ambientLight.set(1, 0, 0);\n            app.scene.ambientLuminance = 20000;\n\n            // enable area lights which are disabled by default for clustered lighting\n            app.scene.lighting.areaLightsEnabled = true;\n\n            // set the loaded area light LUT data\n            const luts = assets.luts.resource;\n            app.setAreaLightLuts(luts.LTC_MAT_1, luts.LTC_MAT_2);\n\n            const sheen1 = assets.sheen.resource.instantiateRenderEntity({\n                castShadows: true\n            });\n            sheen1.setLocalScale(new pc.Vec3(3, 3, 3));\n            sheen1.setLocalPosition(7, -1.0, 0);\n            app.root.addChild(sheen1);\n\n            const sheen2 = assets.sheen.resource.instantiateRenderEntity({\n                castShadows: true\n            });\n            sheen2.setLocalScale(new pc.Vec3(3, 3, 3));\n            sheen2.setLocalPosition(4, -1.0, 0);\n            assets.sheen.resource.applyMaterialVariant(sheen2, \"Peacock Velvet\");\n            app.root.addChild(sheen2);\n\n            const lights = assets.lights.resource.instantiateRenderEntity({\n                castShadows: true\n            });\n            // enable all lights from the glb\n            const lightComponents: Array<pc.LightComponent> = lights.findComponents(\"light\");\n            lightComponents.forEach((component) => {\n                component.enabled = true;\n            });\n            lights.setLocalPosition(10, 0, 0);\n            app.root.addChild(lights);\n\n            const material = new pc.StandardMaterial();\n            material.diffuseMap = assets.color.resource;\n            material.normalMap = assets.normal.resource;\n            material.gloss = 0.8;\n            material.glossMap = assets.gloss.resource;\n            material.metalness = 0.7;\n            material.useMetalness = true;\n\n            material.diffuseMapTiling.set(17, 17);\n            material.normalMapTiling.set(17, 17);\n            material.glossMapTiling.set(17, 17);\n            material.update();\n\n            const plane = new pc.Entity();\n            plane.addComponent('render', {\n                type: 'plane',\n                material: material\n            });\n            plane.setLocalScale(new pc.Vec3(100, 0, 100));\n            plane.setLocalPosition(0, -1.0, 0);\n            app.root.addChild(plane);\n\n\n            data.set('script', {\n                sun: {\n                    luminance: 100000\n                },\n                sky: {\n                    luminance: 20000\n                },\n                spot: {\n                    luminance: 200000,\n                    aperture: 45\n                },\n                point: {\n                    luminance: 100000\n                },\n                rect: {\n                    luminance: 200000\n                },\n                camera: {\n                    aperture: 16.0,\n                    shutter: 1000,\n                    sensitivity: 1000,\n                    animate: false\n                },\n                scene: {\n                    physicalUnits: true,\n                    sky: true\n                }\n            });\n\n            app.scene.physicalUnits = data.get('script.scene.physicalUnits');\n            app.scene.envAtlas = assets.helipad.resource;\n\n            app.scene.skyboxLuminance = data.get('script.sky.luminance');\n\n            const directionalLight = new pc.Entity();\n            directionalLight.addComponent(\"light\", {\n                type: \"directional\",\n                color: pc.Color.WHITE,\n                castShadows: true,\n                luminance: data.get('script.sun.luminance'),\n                shadowBias: 0.2,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048\n            });\n            directionalLight.setEulerAngles(45, 35, 0);\n            app.root.addChild(directionalLight);\n\n            const omniLight = new pc.Entity();\n            omniLight.addComponent(\"light\", {\n                type: \"omni\",\n                color: pc.Color.WHITE,\n                castShadows: false,\n                luminance: data.get('script.point.luminance'),\n                shadowBias: 0.2,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048\n            });\n            omniLight.setLocalPosition(0, 5, 0);\n            app.root.addChild(omniLight);\n\n            const spotLight = new pc.Entity();\n            spotLight.addComponent(\"light\", {\n                type: \"spot\",\n                color: pc.Color.WHITE,\n                castShadows: false,\n                luminance: data.get('script.spot.luminance'),\n                shadowBias: 0.2,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048,\n                outerConeAngle: data.get('script.spot.aperture'),\n                innerConeAngle: 0\n            });\n            spotLight.setEulerAngles(0, 0, 0);\n            spotLight.setLocalPosition(10, 5, 5);\n            app.root.addChild(spotLight);\n\n            const areaLight = new pc.Entity();\n            areaLight.addComponent(\"light\", {\n                type: \"spot\",\n                shape: pc.LIGHTSHAPE_RECT,\n                color: pc.Color.YELLOW,\n                range: 9999,\n                luminance: data.get('script.rect.luminance'),\n                falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED,\n                innerConeAngle: 80,\n                outerConeAngle: 85,\n                normalOffsetBias: 0.1\n            });\n            areaLight.setLocalScale(4, 1, 5);\n            areaLight.setEulerAngles(70, 180, 0);\n            areaLight.setLocalPosition(5, 3, -5);\n\n            // emissive material that is the light source color\n            const brightMaterial = new pc.StandardMaterial();\n            brightMaterial.emissive = pc.Color.YELLOW;\n            brightMaterial.emissiveIntensity = areaLight.light.luminance;\n            brightMaterial.useLighting = false;\n            brightMaterial.cull = pc.CULLFACE_NONE;\n            brightMaterial.update();\n\n            const brightShape = new pc.Entity();\n            // primitive shape that matches light source shape\n            brightShape.addComponent(\"render\", {\n                type: \"plane\",\n                material: brightMaterial,\n                castShadows: false\n            });\n            areaLight.addChild(brightShape);\n            app.root.addChild(areaLight);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n                aperture: data.get('script.camera.aperture'),\n                shutter: 1 / data.get('script.camera.shutter'),\n                sensitivity: data.get('script.camera.sensitivity')\n            });\n            camera.setLocalPosition(0, 5, 11);\n\n            camera.camera.requestSceneColorMap(true);\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: sheen1,\n                    distanceMin: 1,\n                    distanceMax: 400,\n                    frameOnStart: false\n                }\n            });\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            data.on('*:set', (path: string, value: any) => {\n                if (path === 'script.sun.luminance') {\n                    directionalLight.light.luminance = value;\n                } else if (path === 'script.sky.luminance') {\n                    app.scene.skyboxLuminance = value;\n                } else if (path === 'script.spot.luminance') {\n                    spotLight.light.luminance = value;\n                } else if (path === 'script.spot.aperture') {\n                    spotLight.light.outerConeAngle = value;\n                } else if (path === 'script.point.luminance') {\n                    omniLight.light.luminance = value;\n                } else if (path === 'script.rect.luminance') {\n                    areaLight.light.luminance = value;\n                    brightMaterial.emissiveIntensity = value;\n                    brightMaterial.update();\n                } else if (path === 'script.camera.aperture') {\n                    camera.camera.aperture = value;\n                } else if (path === 'script.camera.shutter') {\n                    camera.camera.shutter = 1 / value;\n                } else if (path === 'script.camera.sensitivity') {\n                    camera.camera.sensitivity = value;\n                } else if (path === 'script.scene.physicalUnits') {\n                    app.scene.physicalUnits = value;\n                } else if (path === 'script.scene.sky') {\n                    if (value) {\n                        app.scene.setSkybox(assets.helipad.resources);\n                    } else {\n                        app.scene.setSkybox(null);\n                    }\n                }\n            });\n\n            let resizeControlPanel = true;\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // resize control panel to fit the content better\n                if (resizeControlPanel) {\n                    const panel = window.top.document.getElementById('controlPanel');\n                    if (panel) {\n                        panel.style.width = '360px';\n                        resizeControlPanel = false;\n                    }\n                }\n\n                if (data.get('script.camera.animate')) {\n                    data.set('script.camera.aperture', 3 + (1 + Math.sin(time)) * 5.0);\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    const assets = {\n        orbitCamera: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/orbit-camera.js\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        lights: new pc.Asset(\"lights\", \"container\", {\n            url: \"/static/assets/models/Lights.glb\",\n        }),\n        sheen: new pc.Asset(\"sheen\", \"container\", {\n            url: \"/static/assets/models/SheenChair.glb\",\n        }),\n        color: new pc.Asset(\"color\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-color.jpg\",\n        }),\n        normal: new pc.Asset(\"normal\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-normal.jpg\",\n        }),\n        gloss: new pc.Asset(\"gloss\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-gloss.jpg\",\n        }),\n        luts: new pc.Asset(\"luts\", \"json\", {\n            url: \"/static/assets/json/area-light-luts.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.keyboard = new pc.Keyboard(document.body);\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.JsonHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.skyboxMip = 1;\n            app.scene.ambientLight.set(1, 0, 0);\n            app.scene.ambientLuminance = 20000;\n\n            // enable area lights which are disabled by default for clustered lighting\n            app.scene.lighting.areaLightsEnabled = true;\n\n            // set the loaded area light LUT data\n            const luts = assets.luts.resource;\n            app.setAreaLightLuts(luts.LTC_MAT_1, luts.LTC_MAT_2);\n\n            const sheen1 = assets.sheen.resource.instantiateRenderEntity({\n                castShadows: true,\n            });\n\n            sheen1.setLocalScale(new pc.Vec3(3, 3, 3));\n            sheen1.setLocalPosition(7, -1.0, 0);\n            app.root.addChild(sheen1);\n\n            const sheen2 = assets.sheen.resource.instantiateRenderEntity({\n                castShadows: true,\n            });\n\n            sheen2.setLocalScale(new pc.Vec3(3, 3, 3));\n            sheen2.setLocalPosition(4, -1.0, 0);\n            assets.sheen.resource.applyMaterialVariant(\n                sheen2,\n                \"Peacock Velvet\"\n            );\n            app.root.addChild(sheen2);\n\n            const lights = assets.lights.resource.instantiateRenderEntity({\n                castShadows: true,\n            });\n\n            // enable all lights from the glb\n            const lightComponents = lights.findComponents(\"light\");\n            lightComponents.forEach((component) => {\n                component.enabled = true;\n            });\n            lights.setLocalPosition(10, 0, 0);\n            app.root.addChild(lights);\n\n            const material = new pc.StandardMaterial();\n            material.diffuseMap = assets.color.resource;\n            material.normalMap = assets.normal.resource;\n            material.gloss = 0.8;\n            material.glossMap = assets.gloss.resource;\n            material.metalness = 0.7;\n            material.useMetalness = true;\n\n            material.diffuseMapTiling.set(17, 17);\n            material.normalMapTiling.set(17, 17);\n            material.glossMapTiling.set(17, 17);\n            material.update();\n\n            const plane = new pc.Entity();\n            plane.addComponent(\"render\", {\n                type: \"plane\",\n                material: material,\n            });\n\n            plane.setLocalScale(new pc.Vec3(100, 0, 100));\n            plane.setLocalPosition(0, -1.0, 0);\n            app.root.addChild(plane);\n\n            data.set(\"script\", {\n                sun: {\n                    luminance: 100000,\n                },\n\n                sky: {\n                    luminance: 20000,\n                },\n\n                spot: {\n                    luminance: 200000,\n                    aperture: 45,\n                },\n\n                point: {\n                    luminance: 100000,\n                },\n\n                rect: {\n                    luminance: 200000,\n                },\n\n                camera: {\n                    aperture: 16.0,\n                    shutter: 1000,\n                    sensitivity: 1000,\n                    animate: false,\n                },\n\n                scene: {\n                    physicalUnits: true,\n                    sky: true,\n                },\n            });\n\n            app.scene.physicalUnits = data.get(\"script.scene.physicalUnits\");\n            app.scene.envAtlas = assets.helipad.resource;\n\n            app.scene.skyboxLuminance = data.get(\"script.sky.luminance\");\n\n            const directionalLight = new pc.Entity();\n            directionalLight.addComponent(\"light\", {\n                type: \"directional\",\n                color: pc.Color.WHITE,\n                castShadows: true,\n                luminance: data.get(\"script.sun.luminance\"),\n                shadowBias: 0.2,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048,\n            });\n\n            directionalLight.setEulerAngles(45, 35, 0);\n            app.root.addChild(directionalLight);\n\n            const omniLight = new pc.Entity();\n            omniLight.addComponent(\"light\", {\n                type: \"omni\",\n                color: pc.Color.WHITE,\n                castShadows: false,\n                luminance: data.get(\"script.point.luminance\"),\n                shadowBias: 0.2,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048,\n            });\n\n            omniLight.setLocalPosition(0, 5, 0);\n            app.root.addChild(omniLight);\n\n            const spotLight = new pc.Entity();\n            spotLight.addComponent(\"light\", {\n                type: \"spot\",\n                color: pc.Color.WHITE,\n                castShadows: false,\n                luminance: data.get(\"script.spot.luminance\"),\n                shadowBias: 0.2,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048,\n                outerConeAngle: data.get(\"script.spot.aperture\"),\n                innerConeAngle: 0,\n            });\n\n            spotLight.setEulerAngles(0, 0, 0);\n            spotLight.setLocalPosition(10, 5, 5);\n            app.root.addChild(spotLight);\n\n            const areaLight = new pc.Entity();\n            areaLight.addComponent(\"light\", {\n                type: \"spot\",\n                shape: pc.LIGHTSHAPE_RECT,\n                color: pc.Color.YELLOW,\n                range: 9999,\n                luminance: data.get(\"script.rect.luminance\"),\n                falloffMode: pc.LIGHTFALLOFF_INVERSESQUARED,\n                innerConeAngle: 80,\n                outerConeAngle: 85,\n                normalOffsetBias: 0.1,\n            });\n\n            areaLight.setLocalScale(4, 1, 5);\n            areaLight.setEulerAngles(70, 180, 0);\n            areaLight.setLocalPosition(5, 3, -5);\n\n            // emissive material that is the light source color\n            const brightMaterial = new pc.StandardMaterial();\n            brightMaterial.emissive = pc.Color.YELLOW;\n            brightMaterial.emissiveIntensity = areaLight.light.luminance;\n            brightMaterial.useLighting = false;\n            brightMaterial.cull = pc.CULLFACE_NONE;\n            brightMaterial.update();\n\n            const brightShape = new pc.Entity();\n            // primitive shape that matches light source shape\n            brightShape.addComponent(\"render\", {\n                type: \"plane\",\n                material: brightMaterial,\n                castShadows: false,\n            });\n\n            areaLight.addChild(brightShape);\n            app.root.addChild(areaLight);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n                aperture: data.get(\"script.camera.aperture\"),\n                shutter: 1 / data.get(\"script.camera.shutter\"),\n                sensitivity: data.get(\"script.camera.sensitivity\"),\n            });\n\n            camera.setLocalPosition(0, 5, 11);\n\n            camera.camera.requestSceneColorMap(true);\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: sheen1,\n                    distanceMin: 1,\n                    distanceMax: 400,\n                    frameOnStart: false,\n                },\n            });\n\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            data.on(\"*:set\", (path, value) => {\n                if (path === \"script.sun.luminance\") {\n                    directionalLight.light.luminance = value;\n                } else if (path === \"script.sky.luminance\") {\n                    app.scene.skyboxLuminance = value;\n                } else if (path === \"script.spot.luminance\") {\n                    spotLight.light.luminance = value;\n                } else if (path === \"script.spot.aperture\") {\n                    spotLight.light.outerConeAngle = value;\n                } else if (path === \"script.point.luminance\") {\n                    omniLight.light.luminance = value;\n                } else if (path === \"script.rect.luminance\") {\n                    areaLight.light.luminance = value;\n                    brightMaterial.emissiveIntensity = value;\n                    brightMaterial.update();\n                } else if (path === \"script.camera.aperture\") {\n                    camera.camera.aperture = value;\n                } else if (path === \"script.camera.shutter\") {\n                    camera.camera.shutter = 1 / value;\n                } else if (path === \"script.camera.sensitivity\") {\n                    camera.camera.sensitivity = value;\n                } else if (path === \"script.scene.physicalUnits\") {\n                    app.scene.physicalUnits = value;\n                } else if (path === \"script.scene.sky\") {\n                    if (value) {\n                        app.scene.setSkybox(assets.helipad.resources);\n                    } else {\n                        app.scene.setSkybox(null);\n                    }\n                }\n            });\n\n            let resizeControlPanel = true;\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // resize control panel to fit the content better\n                if (resizeControlPanel) {\n                    const panel =\n                        window.top.document.getElementById(\"controlPanel\");\n                    if (panel) {\n                        panel.style.width = \"360px\";\n                        resizeControlPanel = false;\n                    }\n                }\n\n                if (data.get(\"script.camera.animate\")) {\n                    data.set(\n                        \"script.camera.aperture\",\n                        3 + (1 + Math.sin(time)) * 5.0\n                    );\n                }\n            });\n        });\n    });\n}\n","nameSlug":"light-physical-units","categorySlug":"graphics"},"lights-baked-a-o":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data: any): void {\n\n    const assets = {\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'house': new pc.Asset('house', 'container', { url: '/static/assets/models/house.glb' }),\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        // @ts-ignore\n        createOptions.lightmapper = pc.Lightmapper;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.CubemapHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // setup skydome - this is the main source of ambient light\n            app.scene.skyboxMip = 3;\n            app.scene.skyboxIntensity = 0.6;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // if skydome cubemap is disabled using HUD, a constant ambient color is used instead\n            app.scene.ambientLight = new pc.Color(0.1, 0.3, 0.4);\n\n            // instantiate the house model, which has unwrapped texture coordinates for lightmap in UV1\n            const house = assets.house.resource.instantiateRenderEntity();\n            house.setLocalScale(100, 100, 100);\n            app.root.addChild(house);\n\n            // change its materials to lightmapping\n            const renders: Array<pc.RenderComponent> = house.findComponents(\"render\");\n            renders.forEach((render) => {\n                render.castShadows = true;\n                render.castShadowsLightmap = true;\n                render.lightmapped = true;\n            });\n\n            // directional light\n            const lightDirectional = new pc.Entity(\"Directional\");\n            lightDirectional.addComponent(\"light\", {\n                type: \"directional\",\n                affectDynamic: true,\n                affectLightmapped: true,\n                castShadows: true,\n                normalOffsetBias: 0.05,\n                shadowBias: 0.2,\n                shadowDistance: 100,\n                shadowResolution: 2048,\n                shadowType: pc.SHADOW_PCF3,\n                color: new pc.Color(0.7, 0.7, 0.5),\n                intensity: 1.6\n            });\n            app.root.addChild(lightDirectional);\n            lightDirectional.setLocalEulerAngles(-55, 0, -30);\n\n            // Create an entity with a omni light component that is configured as a baked light\n            const lightOmni = new pc.Entity(\"Omni\");\n            lightOmni.addComponent(\"light\", {\n                type: \"omni\",\n                affectDynamic: false,\n                affectLightmapped: true,\n                bake: true,\n                castShadows: true,\n                normalOffsetBias: 0.05,\n                shadowBias: 0.2,\n                shadowDistance: 25,\n                shadowResolution: 512,\n                shadowType: pc.SHADOW_PCF3,\n                color: pc.Color.YELLOW,\n                range: 25,\n                intensity: 0.9\n            });\n            lightOmni.setLocalPosition(-4, 10, 5);\n            app.root.addChild(lightOmni);\n\n            // Create an entity with a spot light component that is configured as a baked light\n            const lightSpot = new pc.Entity(\"Spot\");\n            lightSpot.addComponent(\"light\", {\n                type: \"spot\",\n                affectDynamic: false,\n                affectLightmapped: true,\n                bake: true,\n                castShadows: true,\n                normalOffsetBias: 0.05,\n                shadowBias: 0.2,\n                shadowDistance: 50,\n                shadowResolution: 512,\n                shadowType: pc.SHADOW_PCF3,\n                color: pc.Color.RED,\n                range: 10,\n                intensity: 2.5\n            });\n            lightSpot.setLocalPosition(-5, 10, -7.5);\n            app.root.addChild(lightSpot);\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n                farClip: 100,\n                nearClip: 1\n            });\n            camera.setLocalPosition(40, 20, 40);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: house,\n                    distanceMax: 60\n                }\n            });\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // lightmap baking properties\n            const bakeType = pc.BAKE_COLOR;\n            app.scene.lightmapMode = bakeType;\n            app.scene.lightmapMaxResolution = 1024;\n\n            // multiplier for lightmap resolution\n            app.scene.lightmapSizeMultiplier = 512;\n\n            // bake when settings are changed only\n            let needBake = false;\n\n            // handle data changes from HUD to modify baking properties\n            data.on('*:set', (path: string, value: any) => {\n                let bakeSettingChanged = true;\n                const pathArray = path.split('.');\n\n                // ambient light\n                if (pathArray[1] === 'ambient') {\n                    if (pathArray[2] === 'cubemap') {\n                        // enable / disable cubemap\n                        app.scene.envAtlas = value ? assets.helipad.resource : null;\n                    } else if (pathArray[2] === 'hemisphere') {\n                        // switch between smaller upper hemisphere and full sphere\n                        app.scene.ambientBakeSpherePart = value ? 0.4 : 1;\n                    } else {\n                        // all other values are set directly on the scene\n                        // @ts-ignore engine-tsd\n                        app.scene[pathArray[2]] = value;\n                    }\n                } else if (pathArray[1] === 'directional') {\n                    // @ts-ignore engine-tsd\n                    lightDirectional.light[pathArray[2]] = value;\n                } else if (pathArray[1] === 'settings') {\n                    // @ts-ignore engine-tsd\n                    app.scene[pathArray[2]] = value;\n                } else if (pathArray[1] === 'other') {\n                    // @ts-ignore engine-tsd\n                    lightOmni.light[pathArray[2]] = value;\n                    // @ts-ignore engine-tsd\n                    lightSpot.light[pathArray[2]] = value;\n                } else {\n                    // don't rebake if stats change\n                    bakeSettingChanged = false;\n                }\n\n                // trigger bake on the next frame if relevant settings were changes\n                needBake ||= bakeSettingChanged;\n            });\n\n            // bake properties connected to the HUD\n            data.set('data', {\n                settings: {\n                    lightmapFilterEnabled: true,\n                    lightmapFilterRange: 10,\n                    lightmapFilterSmoothness: 0.2\n                },\n                ambient: {\n                    ambientBake: true,\n                    cubemap: true,\n                    hemisphere: true,\n                    ambientBakeNumSamples: 20,\n                    ambientBakeOcclusionContrast: -0.6,\n                    ambientBakeOcclusionBrightness: -0.5\n                },\n                directional: {\n                    enabled: true,\n                    bake: true,\n                    bakeNumSamples: 15,\n                    bakeArea: 10\n                },\n                other: {\n                    enabled: true\n                },\n                stats: {\n                    duration: ''\n                }\n            });\n\n            // Set an update function on the app's update event\n            app.on(\"update\", function (dt) {\n\n                // bake lightmaps when HUD properties change\n                if (needBake) {\n                    needBake = false;\n                    app.lightmapper.bake(null, bakeType);\n\n                    // update stats with the bake duration\n                    data.set('data.stats.duration', app.lightmapper.stats.totalRenderTime.toFixed(1) + 'ms');\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        house: new pc.Asset(\"house\", \"container\", {\n            url: \"/static/assets/models/house.glb\",\n        }),\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/orbit-camera.js\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        // @ts-ignore\n        createOptions.lightmapper = pc.Lightmapper;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.CubemapHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // setup skydome - this is the main source of ambient light\n            app.scene.skyboxMip = 3;\n            app.scene.skyboxIntensity = 0.6;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // if skydome cubemap is disabled using HUD, a constant ambient color is used instead\n            app.scene.ambientLight = new pc.Color(0.1, 0.3, 0.4);\n\n            // instantiate the house model, which has unwrapped texture coordinates for lightmap in UV1\n            const house = assets.house.resource.instantiateRenderEntity();\n            house.setLocalScale(100, 100, 100);\n            app.root.addChild(house);\n\n            // change its materials to lightmapping\n            const renders = house.findComponents(\"render\");\n            renders.forEach((render) => {\n                render.castShadows = true;\n                render.castShadowsLightmap = true;\n                render.lightmapped = true;\n            });\n\n            // directional light\n            const lightDirectional = new pc.Entity(\"Directional\");\n            lightDirectional.addComponent(\"light\", {\n                type: \"directional\",\n                affectDynamic: true,\n                affectLightmapped: true,\n                castShadows: true,\n                normalOffsetBias: 0.05,\n                shadowBias: 0.2,\n                shadowDistance: 100,\n                shadowResolution: 2048,\n                shadowType: pc.SHADOW_PCF3,\n                color: new pc.Color(0.7, 0.7, 0.5),\n                intensity: 1.6,\n            });\n\n            app.root.addChild(lightDirectional);\n            lightDirectional.setLocalEulerAngles(-55, 0, -30);\n\n            // Create an entity with a omni light component that is configured as a baked light\n            const lightOmni = new pc.Entity(\"Omni\");\n            lightOmni.addComponent(\"light\", {\n                type: \"omni\",\n                affectDynamic: false,\n                affectLightmapped: true,\n                bake: true,\n                castShadows: true,\n                normalOffsetBias: 0.05,\n                shadowBias: 0.2,\n                shadowDistance: 25,\n                shadowResolution: 512,\n                shadowType: pc.SHADOW_PCF3,\n                color: pc.Color.YELLOW,\n                range: 25,\n                intensity: 0.9,\n            });\n\n            lightOmni.setLocalPosition(-4, 10, 5);\n            app.root.addChild(lightOmni);\n\n            // Create an entity with a spot light component that is configured as a baked light\n            const lightSpot = new pc.Entity(\"Spot\");\n            lightSpot.addComponent(\"light\", {\n                type: \"spot\",\n                affectDynamic: false,\n                affectLightmapped: true,\n                bake: true,\n                castShadows: true,\n                normalOffsetBias: 0.05,\n                shadowBias: 0.2,\n                shadowDistance: 50,\n                shadowResolution: 512,\n                shadowType: pc.SHADOW_PCF3,\n                color: pc.Color.RED,\n                range: 10,\n                intensity: 2.5,\n            });\n\n            lightSpot.setLocalPosition(-5, 10, -7.5);\n            app.root.addChild(lightSpot);\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n                farClip: 100,\n                nearClip: 1,\n            });\n\n            camera.setLocalPosition(40, 20, 40);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: house,\n                    distanceMax: 60,\n                },\n            });\n\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // lightmap baking properties\n            const bakeType = pc.BAKE_COLOR;\n            app.scene.lightmapMode = bakeType;\n            app.scene.lightmapMaxResolution = 1024;\n\n            // multiplier for lightmap resolution\n            app.scene.lightmapSizeMultiplier = 512;\n\n            // bake when settings are changed only\n            let needBake = false;\n\n            // handle data changes from HUD to modify baking properties\n            data.on(\"*:set\", (path, value) => {\n                let bakeSettingChanged = true;\n                const pathArray = path.split(\".\");\n\n                // ambient light\n                if (pathArray[1] === \"ambient\") {\n                    if (pathArray[2] === \"cubemap\") {\n                        // enable / disable cubemap\n                        app.scene.envAtlas = value\n                            ? assets.helipad.resource\n                            : null;\n                    } else if (pathArray[2] === \"hemisphere\") {\n                        // switch between smaller upper hemisphere and full sphere\n                        app.scene.ambientBakeSpherePart = value ? 0.4 : 1;\n                    } else {\n                        // all other values are set directly on the scene\n                        // @ts-ignore engine-tsd\n                        app.scene[pathArray[2]] = value;\n                    }\n                } else if (pathArray[1] === \"directional\") {\n                    // @ts-ignore engine-tsd\n                    lightDirectional.light[pathArray[2]] = value;\n                } else if (pathArray[1] === \"settings\") {\n                    // @ts-ignore engine-tsd\n                    app.scene[pathArray[2]] = value;\n                } else if (pathArray[1] === \"other\") {\n                    // @ts-ignore engine-tsd\n                    lightOmni.light[pathArray[2]] = value;\n                    // @ts-ignore engine-tsd\n                    lightSpot.light[pathArray[2]] = value;\n                } else {\n                    // don't rebake if stats change\n                    bakeSettingChanged = false;\n                }\n\n                // trigger bake on the next frame if relevant settings were changes\n                needBake ||= bakeSettingChanged;\n            });\n\n            // bake properties connected to the HUD\n            data.set(\"data\", {\n                settings: {\n                    lightmapFilterEnabled: true,\n                    lightmapFilterRange: 10,\n                    lightmapFilterSmoothness: 0.2,\n                },\n\n                ambient: {\n                    ambientBake: true,\n                    cubemap: true,\n                    hemisphere: true,\n                    ambientBakeNumSamples: 20,\n                    ambientBakeOcclusionContrast: -0.6,\n                    ambientBakeOcclusionBrightness: -0.5,\n                },\n\n                directional: {\n                    enabled: true,\n                    bake: true,\n                    bakeNumSamples: 15,\n                    bakeArea: 10,\n                },\n\n                other: {\n                    enabled: true,\n                },\n\n                stats: {\n                    duration: \"\",\n                },\n            });\n\n            // Set an update function on the app's update event\n            app.on(\"update\", function (dt) {\n                // bake lightmaps when HUD properties change\n                if (needBake) {\n                    needBake = false;\n                    app.lightmapper.bake(null, bakeType);\n\n                    // update stats with the bake duration\n                    data.set(\n                        \"data.stats.duration\",\n                        app.lightmapper.stats.totalRenderTime.toFixed(1) + \"ms\"\n                    );\n                }\n            });\n        });\n    });\n}\n","nameSlug":"lights-baked-a-o","categorySlug":"graphics"},"lights-baked":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        // @ts-ignore\n        createOptions.lightmapper = pc.Lightmapper;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.start();\n\n        // create material used on the geometry\n        const material = new pc.StandardMaterial();\n        material.gloss = 0.6;\n        material.metalness = 0.4;\n        material.useMetalness = true;\n        material.update();\n\n        // All render component primitive shape types\n        const shapes = [\"box\", \"cone\", \"cylinder\", \"sphere\", \"capsule\", \"torus\"];\n\n        for (let i = 0; i < 40; i++) {\n            const shape = shapes[Math.floor(Math.random() * shapes.length)];\n\n            // Create an entity with a render component that is set up to be lightmapped with baked direct lighting\n            const entity = new pc.Entity();\n            entity.addComponent('render', {\n                castShadows: false,\n                castShadowsLightmap: true,\n                lightmapped: true,\n                type: shape,\n                material: material\n            });\n            app.root.addChild(entity);\n\n            // random orientation\n            entity.setLocalPosition(Math.random() * 10 - 5, Math.random() * 5, Math.random() * 10 - 5);\n        }\n\n        const ground = new pc.Entity();\n        ground.addComponent('render', {\n            castShadows: false,\n            castShadowsLightmap: false,\n            lightmapped: true,\n            type: \"plane\",\n            material: material\n        });\n        app.root.addChild(ground);\n        ground.setLocalPosition(0, -1, 0);\n        ground.setLocalScale(40, 40, 40);\n\n        // Create an entity with a directional light component that is configured as a baked light\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            affectDynamic: false,\n            affectLightmapped: true,\n            bake: true,\n            castShadows: true,\n            normalOffsetBias: 0.05,\n            shadowBias: 0.2,\n            shadowDistance: 50,\n            shadowResolution: 2048,\n            shadowType: pc.SHADOW_PCF3,\n            color: pc.Color.GREEN,\n            type: \"directional\"\n        });\n        app.root.addChild(light);\n        light.setLocalEulerAngles(45, 30, 0);\n\n        // Create an entity with an omni light component that is configured as a baked light\n        const lightPoint = new pc.Entity();\n        lightPoint.addComponent(\"light\", {\n            affectDynamic: false,\n            affectLightmapped: true,\n            bake: true,\n            castShadows: true,\n            normalOffsetBias: 0.05,\n            shadowBias: 0.2,\n            shadowDistance: 50,\n            shadowResolution: 512,\n            shadowType: pc.SHADOW_PCF3,\n            color: pc.Color.RED,\n            range: 100,\n            type: \"point\"\n        });\n        lightPoint.setLocalPosition(0, 2, 0);\n        app.root.addChild(lightPoint);\n\n        // Create an entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.4, 0.45, 0.5),\n            farClip: 100,\n            nearClip: 0.05\n        });\n        app.root.addChild(camera);\n\n        // lightmap baking properties\n        app.scene.lightmapMode = pc.BAKE_COLOR;\n        app.scene.lightmapMaxResolution = 2048;\n\n        // For baked lights, this property perhaps has the biggest impact on lightmap resolution:\n        app.scene.lightmapSizeMultiplier = 32;\n\n        // bake lightmaps\n        app.lightmapper.bake(null, pc.BAKE_COLORDIR);\n\n        // Set an update function on the app's update event\n        let time = 4;\n        app.on(\"update\", function (dt) {\n            time += dt;\n\n            // orbit camera\n            camera.setLocalPosition(20 * Math.sin(time * 0.4), 3, 6);\n            camera.lookAt(pc.Vec3.ZERO);\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        // @ts-ignore\n        createOptions.lightmapper = pc.Lightmapper;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.start();\n\n        // create material used on the geometry\n        const material = new pc.StandardMaterial();\n        material.gloss = 0.6;\n        material.metalness = 0.4;\n        material.useMetalness = true;\n        material.update();\n\n        // All render component primitive shape types\n        const shapes = [\n            \"box\",\n            \"cone\",\n            \"cylinder\",\n            \"sphere\",\n            \"capsule\",\n            \"torus\",\n        ];\n\n        for (let i = 0; i < 40; i++) {\n            const shape = shapes[Math.floor(Math.random() * shapes.length)];\n\n            // Create an entity with a render component that is set up to be lightmapped with baked direct lighting\n            const entity = new pc.Entity();\n            entity.addComponent(\"render\", {\n                castShadows: false,\n                castShadowsLightmap: true,\n                lightmapped: true,\n                type: shape,\n                material: material,\n            });\n\n            app.root.addChild(entity);\n\n            // random orientation\n            entity.setLocalPosition(\n                Math.random() * 10 - 5,\n                Math.random() * 5,\n                Math.random() * 10 - 5\n            );\n        }\n\n        const ground = new pc.Entity();\n        ground.addComponent(\"render\", {\n            castShadows: false,\n            castShadowsLightmap: false,\n            lightmapped: true,\n            type: \"plane\",\n            material: material,\n        });\n\n        app.root.addChild(ground);\n        ground.setLocalPosition(0, -1, 0);\n        ground.setLocalScale(40, 40, 40);\n\n        // Create an entity with a directional light component that is configured as a baked light\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            affectDynamic: false,\n            affectLightmapped: true,\n            bake: true,\n            castShadows: true,\n            normalOffsetBias: 0.05,\n            shadowBias: 0.2,\n            shadowDistance: 50,\n            shadowResolution: 2048,\n            shadowType: pc.SHADOW_PCF3,\n            color: pc.Color.GREEN,\n            type: \"directional\",\n        });\n\n        app.root.addChild(light);\n        light.setLocalEulerAngles(45, 30, 0);\n\n        // Create an entity with an omni light component that is configured as a baked light\n        const lightPoint = new pc.Entity();\n        lightPoint.addComponent(\"light\", {\n            affectDynamic: false,\n            affectLightmapped: true,\n            bake: true,\n            castShadows: true,\n            normalOffsetBias: 0.05,\n            shadowBias: 0.2,\n            shadowDistance: 50,\n            shadowResolution: 512,\n            shadowType: pc.SHADOW_PCF3,\n            color: pc.Color.RED,\n            range: 100,\n            type: \"point\",\n        });\n\n        lightPoint.setLocalPosition(0, 2, 0);\n        app.root.addChild(lightPoint);\n\n        // Create an entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.4, 0.45, 0.5),\n            farClip: 100,\n            nearClip: 0.05,\n        });\n\n        app.root.addChild(camera);\n\n        // lightmap baking properties\n        app.scene.lightmapMode = pc.BAKE_COLOR;\n        app.scene.lightmapMaxResolution = 2048;\n\n        // For baked lights, this property perhaps has the biggest impact on lightmap resolution:\n        app.scene.lightmapSizeMultiplier = 32;\n\n        // bake lightmaps\n        app.lightmapper.bake(null, pc.BAKE_COLORDIR);\n\n        // Set an update function on the app's update event\n        let time = 4;\n        app.on(\"update\", function (dt) {\n            time += dt;\n\n            // orbit camera\n            camera.setLocalPosition(20 * Math.sin(time * 0.4), 3, 6);\n            camera.lookAt(pc.Vec3.ZERO);\n        });\n    });\n}\n","nameSlug":"lights-baked","categorySlug":"graphics"},"lights":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data:any): void {\n    function createMaterial(colors: any) {\n        const material: any = new pc.StandardMaterial();\n        for (const param in colors) {\n            material[param] = colors[param];\n        }\n        material.update();\n        return material;\n    }\n\n    const assets = {\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' }),\n        \"heart\": new pc.Asset(\"heart\", \"texture\", { url: \"/static/assets/textures/heart.png\" }),\n        \"xmas_negx\": new pc.Asset(\"xmas_negx\", \"texture\", { url: \"/static/assets/cubemaps/xmas_faces/xmas_negx.png\" }),\n        \"xmas_negy\": new pc.Asset(\"xmas_negy\", \"texture\", { url: \"/static/assets/cubemaps/xmas_faces/xmas_negy.png\" }),\n        \"xmas_negz\": new pc.Asset(\"xmas_negz\", \"texture\", { url: \"/static/assets/cubemaps/xmas_faces/xmas_negz.png\" }),\n        \"xmas_posx\": new pc.Asset(\"xmas_posx\", \"texture\", { url: \"/static/assets/cubemaps/xmas_faces/xmas_posx.png\" }),\n        \"xmas_posy\": new pc.Asset(\"xmas_posy\", \"texture\", { url: \"/static/assets/cubemaps/xmas_faces/xmas_posy.png\" }),\n        \"xmas_posz\": new pc.Asset(\"xmas_posz\", \"texture\", { url: \"/static/assets/cubemaps/xmas_faces/xmas_posz.png\" })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.CubemapHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // enable cookies which are disabled by default for clustered lighting\n            app.scene.lighting.cookiesEnabled = true;\n\n            // ambient lighting\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // create an entity with the statue\n            const entity = assets.statue.resource.instantiateRenderEntity();\n\n            app.root.addChild(entity);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5)\n            });\n            camera.translate(0, 15, 35);\n            camera.rotate(-14, 0, 0);\n            app.root.addChild(camera);\n\n            // ground material\n            const material = createMaterial({\n                ambient: pc.Color.GRAY,\n                diffuse: pc.Color.GRAY\n            });\n\n            // Create an Entity for the ground\n            const ground = new pc.Entity();\n            ground.addComponent(\"render\", {\n                type: \"box\",\n                material: material\n            });\n            ground.setLocalScale(70, 1, 70);\n            ground.setLocalPosition(0, -0.5, 0);\n            app.root.addChild(ground);\n\n            // setup light data\n            data.set('lights', {\n                spot: {\n                    enabled: true,\n                    intensity: 0.8,\n                    cookieIntensity: 1,\n                    shadowIntensity: 1\n                },\n                omni: {\n                    enabled: true,\n                    intensity: 0.8,\n                    cookieIntensity: 1,\n                    shadowIntensity: 1\n                },\n                directional: {\n                    enabled: true,\n                    intensity: 0.8,\n                    shadowIntensity: 1\n                }\n            });\n\n            const lights: {[key: string]: pc.Entity } = {};\n\n            // Create an spot light\n            lights.spot = new pc.Entity();\n            lights.spot.addComponent(\"light\", {\n                ...{\n                    type: \"spot\",\n                    color: pc.Color.WHITE,\n                    innerConeAngle: 30,\n                    outerConeAngle: 31,\n                    range: 100,\n                    castShadows: true,\n                    shadowBias: 0.05,\n                    normalOffsetBias: 0.03,\n                    shadowResolution: 2048,\n                    // heart texture's alpha channel as a cookie texture\n                    cookie: assets.heart.resource,\n                    cookieChannel: \"a\"\n                },\n                ...data.get('lights.spot')\n            });\n\n            const cone = new pc.Entity();\n            cone.addComponent(\"render\", {\n                type: \"cone\",\n                castShadows: false,\n                material: createMaterial({ emissive: pc.Color.WHITE })\n            });\n            lights.spot.addChild(cone);\n            app.root.addChild(lights.spot);\n\n            // construct the cubemap asset for the omni light cookie texture\n            // Note: the textures array could contain 6 texture asset names to load instead as well\n            const cubemapAsset = new pc.Asset('xmas_cubemap', 'cubemap', null, {\n                textures: [\n                    assets.xmas_posx.id, assets.xmas_negx.id,\n                    assets.xmas_posy.id, assets.xmas_negy.id,\n                    assets.xmas_posz.id, assets.xmas_negz.id\n                ]\n            });\n            cubemapAsset.loadFaces = true;\n            app.assets.add(cubemapAsset);\n\n            // Create a omni light\n            lights.omni = new pc.Entity();\n            lights.omni.addComponent(\"light\", {\n                ...{\n                    type: \"omni\",\n                    color: pc.Color.YELLOW,\n                    castShadows: true,\n                    range: 111,\n                    cookieAsset: cubemapAsset,\n                    cookieChannel: \"rgb\"\n                },\n                ...data.get('lights.omni')\n            });\n            lights.omni.addComponent(\"render\", {\n                type: \"sphere\",\n                castShadows: false,\n                material: createMaterial({ diffuse: pc.Color.BLACK, emissive: pc.Color.YELLOW })\n            });\n            app.root.addChild(lights.omni);\n\n            // Create a directional light\n            lights.directional = new pc.Entity();\n            lights.directional.addComponent(\"light\", {\n                ...{\n                    type: \"directional\",\n                    color: pc.Color.CYAN,\n                    range: 100,\n                    shadowDistance: 50,\n                    castShadows: true,\n                    shadowBias: 0.1,\n                    normalOffsetBias: 0.2\n                },\n                ...data.get('lights.directional')\n            });\n            app.root.addChild(lights.directional);\n\n            // Allow user to toggle individual lights\n            app.keyboard.on(\"keydown\", function (e) {\n                // if the user is editing an input field, ignore key presses\n                if (e.element.constructor.name === 'HTMLInputElement') return;\n                switch (e.key) {\n                    case pc.KEY_1:\n                        data.set('lights.omni.enabled', !data.get('lights.omni.enabled'));\n                        break;\n                    case pc.KEY_2:\n                        data.set('lights.spot.enabled', !data.get('lights.spot.enabled'));\n                        break;\n                    case pc.KEY_3:\n                        data.set('lights.directional.enabled', !data.get('lights.directional.enabled'));\n                        break;\n                }\n            }, this);\n\n            // Simple update loop to rotate the light\n            let angleRad = 1;\n            app.on(\"update\", function (dt) {\n                angleRad += 0.3 * dt;\n                if (entity) {\n\n                    lights.spot.lookAt(new pc.Vec3(0, -5, 0));\n                    lights.spot.rotateLocal(90, 0, 0);\n                    lights.spot.setLocalPosition(15 * Math.sin(angleRad), 25, 15 * Math.cos(angleRad));\n\n                    lights.omni.setLocalPosition(5 * Math.sin(-2 * angleRad), 10, 5 * Math.cos(-2 * angleRad));\n                    lights.omni.rotate(0, 50 * dt, 0);\n\n                    lights.directional.setLocalEulerAngles(45, -60 * angleRad, 0);\n                }\n            });\n\n            data.on('*:set', (path: string, value: any) => {\n                const pathArray = path.split('.');\n                if (pathArray[2] === 'enabled') {\n                    lights[pathArray[1]].enabled = value;\n                } else {\n                    // @ts-ignore\n                    lights[pathArray[1]].light[pathArray[2]] = value;\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    function createMaterial(colors) {\n        const material = new pc.StandardMaterial();\n        for (const param in colors) {\n            material[param] = colors[param];\n        }\n        material.update();\n        return material;\n    }\n\n    const assets = {\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n        heart: new pc.Asset(\"heart\", \"texture\", {\n            url: \"/static/assets/textures/heart.png\",\n        }),\n        xmas_negx: new pc.Asset(\"xmas_negx\", \"texture\", {\n            url: \"/static/assets/cubemaps/xmas_faces/xmas_negx.png\",\n        }),\n        xmas_negy: new pc.Asset(\"xmas_negy\", \"texture\", {\n            url: \"/static/assets/cubemaps/xmas_faces/xmas_negy.png\",\n        }),\n        xmas_negz: new pc.Asset(\"xmas_negz\", \"texture\", {\n            url: \"/static/assets/cubemaps/xmas_faces/xmas_negz.png\",\n        }),\n        xmas_posx: new pc.Asset(\"xmas_posx\", \"texture\", {\n            url: \"/static/assets/cubemaps/xmas_faces/xmas_posx.png\",\n        }),\n        xmas_posy: new pc.Asset(\"xmas_posy\", \"texture\", {\n            url: \"/static/assets/cubemaps/xmas_faces/xmas_posy.png\",\n        }),\n        xmas_posz: new pc.Asset(\"xmas_posz\", \"texture\", {\n            url: \"/static/assets/cubemaps/xmas_faces/xmas_posz.png\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.CubemapHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // enable cookies which are disabled by default for clustered lighting\n            app.scene.lighting.cookiesEnabled = true;\n\n            // ambient lighting\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // create an entity with the statue\n            const entity = assets.statue.resource.instantiateRenderEntity();\n\n            app.root.addChild(entity);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n            });\n\n            camera.translate(0, 15, 35);\n            camera.rotate(-14, 0, 0);\n            app.root.addChild(camera);\n\n            // ground material\n            const material = createMaterial({\n                ambient: pc.Color.GRAY,\n                diffuse: pc.Color.GRAY,\n            });\n\n            // Create an Entity for the ground\n            const ground = new pc.Entity();\n            ground.addComponent(\"render\", {\n                type: \"box\",\n                material: material,\n            });\n\n            ground.setLocalScale(70, 1, 70);\n            ground.setLocalPosition(0, -0.5, 0);\n            app.root.addChild(ground);\n\n            // setup light data\n            data.set(\"lights\", {\n                spot: {\n                    enabled: true,\n                    intensity: 0.8,\n                    cookieIntensity: 1,\n                    shadowIntensity: 1,\n                },\n\n                omni: {\n                    enabled: true,\n                    intensity: 0.8,\n                    cookieIntensity: 1,\n                    shadowIntensity: 1,\n                },\n\n                directional: {\n                    enabled: true,\n                    intensity: 0.8,\n                    shadowIntensity: 1,\n                },\n            });\n\n            const lights = {};\n\n            // Create an spot light\n            lights.spot = new pc.Entity();\n            lights.spot.addComponent(\"light\", {\n                ...{\n                    type: \"spot\",\n                    color: pc.Color.WHITE,\n                    innerConeAngle: 30,\n                    outerConeAngle: 31,\n                    range: 100,\n                    castShadows: true,\n                    shadowBias: 0.05,\n                    normalOffsetBias: 0.03,\n                    shadowResolution: 2048,\n                    // heart texture's alpha channel as a cookie texture\n                    cookie: assets.heart.resource,\n                    cookieChannel: \"a\",\n                },\n\n                ...data.get(\"lights.spot\"),\n            });\n\n            const cone = new pc.Entity();\n            cone.addComponent(\"render\", {\n                type: \"cone\",\n                castShadows: false,\n                material: createMaterial({ emissive: pc.Color.WHITE }),\n            });\n\n            lights.spot.addChild(cone);\n            app.root.addChild(lights.spot);\n\n            // construct the cubemap asset for the omni light cookie texture\n            // Note: the textures array could contain 6 texture asset names to load instead as well\n            const cubemapAsset = new pc.Asset(\"xmas_cubemap\", \"cubemap\", null, {\n                textures: [\n                    assets.xmas_posx.id,\n                    assets.xmas_negx.id,\n                    assets.xmas_posy.id,\n                    assets.xmas_negy.id,\n                    assets.xmas_posz.id,\n                    assets.xmas_negz.id,\n                ],\n            });\n\n            cubemapAsset.loadFaces = true;\n            app.assets.add(cubemapAsset);\n\n            // Create a omni light\n            lights.omni = new pc.Entity();\n            lights.omni.addComponent(\"light\", {\n                ...{\n                    type: \"omni\",\n                    color: pc.Color.YELLOW,\n                    castShadows: true,\n                    range: 111,\n                    cookieAsset: cubemapAsset,\n                    cookieChannel: \"rgb\",\n                },\n\n                ...data.get(\"lights.omni\"),\n            });\n\n            lights.omni.addComponent(\"render\", {\n                type: \"sphere\",\n                castShadows: false,\n                material: createMaterial({\n                    diffuse: pc.Color.BLACK,\n                    emissive: pc.Color.YELLOW,\n                }),\n            });\n\n            app.root.addChild(lights.omni);\n\n            // Create a directional light\n            lights.directional = new pc.Entity();\n            lights.directional.addComponent(\"light\", {\n                ...{\n                    type: \"directional\",\n                    color: pc.Color.CYAN,\n                    range: 100,\n                    shadowDistance: 50,\n                    castShadows: true,\n                    shadowBias: 0.1,\n                    normalOffsetBias: 0.2,\n                },\n\n                ...data.get(\"lights.directional\"),\n            });\n\n            app.root.addChild(lights.directional);\n\n            // Allow user to toggle individual lights\n            app.keyboard.on(\n                \"keydown\",\n                function (e) {\n                    // if the user is editing an input field, ignore key presses\n                    if (e.element.constructor.name === \"HTMLInputElement\")\n                        return;\n                    switch (e.key) {\n                        case pc.KEY_1:\n                            data.set(\n                                \"lights.omni.enabled\",\n                                !data.get(\"lights.omni.enabled\")\n                            );\n                            break;\n                        case pc.KEY_2:\n                            data.set(\n                                \"lights.spot.enabled\",\n                                !data.get(\"lights.spot.enabled\")\n                            );\n                            break;\n                        case pc.KEY_3:\n                            data.set(\n                                \"lights.directional.enabled\",\n                                !data.get(\"lights.directional.enabled\")\n                            );\n                            break;\n                    }\n                },\n                this\n            );\n\n            // Simple update loop to rotate the light\n            let angleRad = 1;\n            app.on(\"update\", function (dt) {\n                angleRad += 0.3 * dt;\n                if (entity) {\n                    lights.spot.lookAt(new pc.Vec3(0, -5, 0));\n                    lights.spot.rotateLocal(90, 0, 0);\n                    lights.spot.setLocalPosition(\n                        15 * Math.sin(angleRad),\n                        25,\n                        15 * Math.cos(angleRad)\n                    );\n\n                    lights.omni.setLocalPosition(\n                        5 * Math.sin(-2 * angleRad),\n                        10,\n                        5 * Math.cos(-2 * angleRad)\n                    );\n                    lights.omni.rotate(0, 50 * dt, 0);\n\n                    lights.directional.setLocalEulerAngles(\n                        45,\n                        -60 * angleRad,\n                        0\n                    );\n                }\n            });\n\n            data.on(\"*:set\", (path, value) => {\n                const pathArray = path.split(\".\");\n                if (pathArray[2] === \"enabled\") {\n                    lights[pathArray[1]].enabled = value;\n                } else {\n                    // @ts-ignore\n                    lights[pathArray[1]].light[pathArray[2]] = value;\n                }\n            });\n        });\n    });\n}\n","nameSlug":"lights","categorySlug":"graphics"},"lines":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'helipad': new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // setup skydome\n            app.scene.skyboxMip = 2;\n            app.scene.exposure = 0.2;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(0, 30, 0);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1)\n            });\n            camera.setLocalPosition(80, 40, 80);\n            camera.lookAt(new pc.Vec3(0, -35, 0));\n            app.root.addChild(camera);\n\n            // Create a directional light\n            const directionallight = new pc.Entity();\n            directionallight.addComponent(\"light\", {\n                type: \"directional\",\n                color: pc.Color.WHITE,\n                castShadows: false\n            });\n            app.root.addChild(directionallight);\n\n            // create a circle of meshes\n            const meshes: Array<pc.Entity> = [];\n            const numMeshes = 10;\n            for (let i = 0; i < numMeshes; i++) {\n                const entity = new pc.Entity();\n                entity.setLocalScale(4, 4, 4);\n\n                // use material with random color\n                const material = new pc.StandardMaterial();\n                material.diffuse = new pc.Color(Math.random(), Math.random(), Math.random());\n                material.update();\n\n                // create render component\n                entity.addComponent(\"render\", {\n                    type: (i % 2 ? \"sphere\" : \"cylinder\"),\n                    material: material,\n                    receiveShadows: false\n                });\n\n                if (!(i % 2)) {\n                    entity.setLocalScale(3, 5, 3);\n                }\n\n                // add entity for rendering\n                app.root.addChild(entity);\n                meshes.push(entity);\n            }\n\n            // helper function to generate elevation of a point with [x, y] coordinates\n            function groundElevation(time: number, x: number, z: number) {\n                return Math.sin(time + 0.2 * x) * 2 + Math.cos(time * 0.2 + 0.5 * z + 0.2 * x);\n            }\n\n            // helper function to generate a color for 3d point by lerping between green and red color\n            // based on its y coordinate\n            function groundColor(color: pc.Color, point: pc.Vec3) {\n                color.lerp(pc.Color.GREEN, pc.Color.RED, pc.math.clamp((point.y + 3) * 0.25, 0, 1));\n            }\n\n            // Set an update function on the app's update event\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // generate grid of lines - store positions and colors as an arrays of numbers instead of\n                // Vec3s and Colors to improve performance\n                const positions = [];\n                const colors = [];\n\n                // temporary instances for calculations\n                const pt1 = new pc.Vec3();\n                const pt2 = new pc.Vec3();\n                const pt3 = new pc.Vec3();\n                const c1 = new pc.Color();\n                const c2 = new pc.Color();\n                const c3 = new pc.Color();\n\n                for (let x = 1; x < 60; x++) {\n                    for (let z = 1; z < 60; z++) {\n\n                        // generate 3 points: one start point, one along x and one along z axis\n                        pt1.set(x, groundElevation(time, x, z), z);\n                        pt2.set(x - 1, groundElevation(time, x - 1, z), z);\n                        pt3.set(x, groundElevation(time, x, z - 1), z - 1);\n\n                        // generate colors for the 3 points\n                        groundColor(c1, pt1);\n                        groundColor(c2, pt2);\n                        groundColor(c3, pt3);\n\n                        // add line connecting points along z axis\n                        if (x > 1) {\n                            positions.push(pt1.x, pt1.y, pt1.z, pt2.x, pt2.y, pt2.z);\n                            colors.push(c1.r, c1.g, c1.b, c1.a, c2.r, c2.g, c2.b, c2.a);\n                        }\n\n                        // add line connecting points along x axis\n                        if (z > 1) {\n                            positions.push(pt1.x, pt1.y, pt1.z, pt3.x, pt3.y, pt3.z);\n                            colors.push(c1.r, c1.g, c1.b, c1.a, c3.r, c3.g, c3.b, c3.a);\n                        }\n                    }\n                }\n\n                // submit the generated arrays of lines and colors for rendering\n                app.drawLineArrays(positions, colors);\n\n                // array of Vec3 and Color classes for different way to render lines\n                const grayLinePositions = [];\n                const grayLineColors = [];\n\n                // handle the array of meshes\n                for (let i = 0; i < numMeshes; i++) {\n\n                    // move them equally spaced out around in the circle\n                    const offset = i * Math.PI * 2 / numMeshes;\n                    const entity = meshes[i];\n                    entity.setLocalPosition(\n                        30 + 20 * Math.sin(time * 0.2 + offset),\n                        5 + 2 * Math.sin(time + 3 * i / numMeshes),\n                        30 + 20 * Math.cos(time * 0.2 + offset)\n                    );\n\n                    // rotate the meshes\n                    entity.rotate((i + 1) * dt, 4 * (i + 1) * dt, 6 * (i + 1) * dt);\n\n                    // draw a single magenta line from this mesh to the next mesh\n                    const nextEntity = meshes[(i + 1) % meshes.length];\n                    app.drawLine(entity.getPosition(), nextEntity.getPosition(), pc.Color.MAGENTA);\n\n                    // store positions and colors of lines connecting objects to a center point\n                    grayLinePositions.push(entity.getPosition(), new pc.Vec3(0, 10, 0));\n                    grayLineColors.push(pc.Color.GRAY, pc.Color.GRAY);\n                }\n\n                // render all gray lines\n                app.drawLines(grayLinePositions, grayLineColors);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // setup skydome\n            app.scene.skyboxMip = 2;\n            app.scene.exposure = 0.2;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(\n                0,\n                30,\n                0\n            );\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1),\n            });\n\n            camera.setLocalPosition(80, 40, 80);\n            camera.lookAt(new pc.Vec3(0, -35, 0));\n            app.root.addChild(camera);\n\n            // Create a directional light\n            const directionallight = new pc.Entity();\n            directionallight.addComponent(\"light\", {\n                type: \"directional\",\n                color: pc.Color.WHITE,\n                castShadows: false,\n            });\n\n            app.root.addChild(directionallight);\n\n            // create a circle of meshes\n            const meshes = [];\n            const numMeshes = 10;\n            for (let i = 0; i < numMeshes; i++) {\n                const entity = new pc.Entity();\n                entity.setLocalScale(4, 4, 4);\n\n                // use material with random color\n                const material = new pc.StandardMaterial();\n                material.diffuse = new pc.Color(\n                    Math.random(),\n                    Math.random(),\n                    Math.random()\n                );\n                material.update();\n\n                // create render component\n                entity.addComponent(\"render\", {\n                    type: i % 2 ? \"sphere\" : \"cylinder\",\n                    material: material,\n                    receiveShadows: false,\n                });\n\n                if (!(i % 2)) {\n                    entity.setLocalScale(3, 5, 3);\n                }\n\n                // add entity for rendering\n                app.root.addChild(entity);\n                meshes.push(entity);\n            }\n\n            // helper function to generate elevation of a point with [x, y] coordinates\n            function groundElevation(time, x, z) {\n                return (\n                    Math.sin(time + 0.2 * x) * 2 +\n                    Math.cos(time * 0.2 + 0.5 * z + 0.2 * x)\n                );\n            }\n\n            // helper function to generate a color for 3d point by lerping between green and red color\n            // based on its y coordinate\n            function groundColor(color, point) {\n                color.lerp(\n                    pc.Color.GREEN,\n                    pc.Color.RED,\n                    pc.math.clamp((point.y + 3) * 0.25, 0, 1)\n                );\n            }\n\n            // Set an update function on the app's update event\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // generate grid of lines - store positions and colors as an arrays of numbers instead of\n                // Vec3s and Colors to improve performance\n                const positions = [];\n                const colors = [];\n\n                // temporary instances for calculations\n                const pt1 = new pc.Vec3();\n                const pt2 = new pc.Vec3();\n                const pt3 = new pc.Vec3();\n                const c1 = new pc.Color();\n                const c2 = new pc.Color();\n                const c3 = new pc.Color();\n\n                for (let x = 1; x < 60; x++) {\n                    for (let z = 1; z < 60; z++) {\n                        // generate 3 points: one start point, one along x and one along z axis\n                        pt1.set(x, groundElevation(time, x, z), z);\n                        pt2.set(x - 1, groundElevation(time, x - 1, z), z);\n                        pt3.set(x, groundElevation(time, x, z - 1), z - 1);\n\n                        // generate colors for the 3 points\n                        groundColor(c1, pt1);\n                        groundColor(c2, pt2);\n                        groundColor(c3, pt3);\n\n                        // add line connecting points along z axis\n                        if (x > 1) {\n                            positions.push(\n                                pt1.x,\n                                pt1.y,\n                                pt1.z,\n                                pt2.x,\n                                pt2.y,\n                                pt2.z\n                            );\n                            colors.push(\n                                c1.r,\n                                c1.g,\n                                c1.b,\n                                c1.a,\n                                c2.r,\n                                c2.g,\n                                c2.b,\n                                c2.a\n                            );\n                        }\n\n                        // add line connecting points along x axis\n                        if (z > 1) {\n                            positions.push(\n                                pt1.x,\n                                pt1.y,\n                                pt1.z,\n                                pt3.x,\n                                pt3.y,\n                                pt3.z\n                            );\n                            colors.push(\n                                c1.r,\n                                c1.g,\n                                c1.b,\n                                c1.a,\n                                c3.r,\n                                c3.g,\n                                c3.b,\n                                c3.a\n                            );\n                        }\n                    }\n                }\n\n                // submit the generated arrays of lines and colors for rendering\n                app.drawLineArrays(positions, colors);\n\n                // array of Vec3 and Color classes for different way to render lines\n                const grayLinePositions = [];\n                const grayLineColors = [];\n\n                // handle the array of meshes\n                for (let i = 0; i < numMeshes; i++) {\n                    // move them equally spaced out around in the circle\n                    const offset = (i * Math.PI * 2) / numMeshes;\n                    const entity = meshes[i];\n                    entity.setLocalPosition(\n                        30 + 20 * Math.sin(time * 0.2 + offset),\n                        5 + 2 * Math.sin(time + (3 * i) / numMeshes),\n                        30 + 20 * Math.cos(time * 0.2 + offset)\n                    );\n\n                    // rotate the meshes\n                    entity.rotate(\n                        (i + 1) * dt,\n                        4 * (i + 1) * dt,\n                        6 * (i + 1) * dt\n                    );\n\n                    // draw a single magenta line from this mesh to the next mesh\n                    const nextEntity = meshes[(i + 1) % meshes.length];\n                    app.drawLine(\n                        entity.getPosition(),\n                        nextEntity.getPosition(),\n                        pc.Color.MAGENTA\n                    );\n\n                    // store positions and colors of lines connecting objects to a center point\n                    grayLinePositions.push(\n                        entity.getPosition(),\n                        new pc.Vec3(0, 10, 0)\n                    );\n                    grayLineColors.push(pc.Color.GRAY, pc.Color.GRAY);\n                }\n\n                // render all gray lines\n                app.drawLines(grayLinePositions, grayLineColors);\n            });\n        });\n    });\n}\n","nameSlug":"lines","categorySlug":"graphics"},"material-anisotropic":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/arial.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.skyboxMip = 1;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\");\n            camera.translate(0, 6, 6);\n            camera.rotate(-48, 0, 0);\n            app.root.addChild(camera);\n\n            // Create an entity with a directional light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\"\n            });\n            app.root.addChild(light);\n            const e = light.getLocalEulerAngles();\n            light.setLocalEulerAngles(e.x + 90, e.y - 75, e.z);\n\n            const NUM_SPHERES_X = 11;\n            const NUM_SPHERES_Z = 6;\n\n            const createSphere = function (x: number, y: number, z: number) {\n                const material = new pc.StandardMaterial();\n                material.metalness = 1.0;\n                material.gloss = z / (NUM_SPHERES_Z - 1);\n                material.useMetalness = true;\n                material.anisotropy = ((2 * x / (NUM_SPHERES_X - 1)) - 1.0) * -1.0;\n                material.enableGGXSpecular = true;\n                material.update();\n\n                const sphere = new pc.Entity();\n\n                sphere.addComponent(\"render\", {\n                    material: material,\n                    type: \"sphere\"\n                });\n                sphere.setLocalPosition(x - (NUM_SPHERES_X - 1) * 0.5, y, z - (NUM_SPHERES_Z - 1) * 0.5);\n                sphere.setLocalScale(0.7, 0.7, 0.7);\n                app.root.addChild(sphere);\n            };\n\n            const createText = function (fontAsset: pc.Asset, message: string, x: number, y: number, z: number, rotx: number, roty: number) {\n                // Create a text element-based entity\n                const text = new pc.Entity();\n                text.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    fontAsset: fontAsset,\n                    fontSize: 0.5,\n                    pivot: [0.5, 0.5],\n                    text: message,\n                    type: pc.ELEMENTTYPE_TEXT\n                });\n                text.setLocalPosition(x, y, z);\n                text.setLocalEulerAngles(rotx, roty, 0);\n                app.root.addChild(text);\n            };\n\n            for (let i = 0; i < NUM_SPHERES_Z; i++) {\n                for (let j = 0; j < NUM_SPHERES_X; j++) {\n                    createSphere(j, 0, i);\n                }\n            }\n\n            createText(assets.font, 'Anisotropy', 0, 0, ((NUM_SPHERES_Z + 1) * 0.5), -90, 0);\n            createText(assets.font, 'Roughness', -(NUM_SPHERES_X + 1) * 0.5, 0, 0, -90, 90);\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/arial.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.skyboxMip = 1;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\");\n            camera.translate(0, 6, 6);\n            camera.rotate(-48, 0, 0);\n            app.root.addChild(camera);\n\n            // Create an entity with a directional light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n            });\n\n            app.root.addChild(light);\n            const e = light.getLocalEulerAngles();\n            light.setLocalEulerAngles(e.x + 90, e.y - 75, e.z);\n\n            const NUM_SPHERES_X = 11;\n            const NUM_SPHERES_Z = 6;\n\n            const createSphere = function (x, y, z) {\n                const material = new pc.StandardMaterial();\n                material.metalness = 1.0;\n                material.gloss = z / (NUM_SPHERES_Z - 1);\n                material.useMetalness = true;\n                material.anisotropy =\n                    ((2 * x) / (NUM_SPHERES_X - 1) - 1.0) * -1.0;\n                material.enableGGXSpecular = true;\n                material.update();\n\n                const sphere = new pc.Entity();\n\n                sphere.addComponent(\"render\", {\n                    material: material,\n                    type: \"sphere\",\n                });\n\n                sphere.setLocalPosition(\n                    x - (NUM_SPHERES_X - 1) * 0.5,\n                    y,\n                    z - (NUM_SPHERES_Z - 1) * 0.5\n                );\n                sphere.setLocalScale(0.7, 0.7, 0.7);\n                app.root.addChild(sphere);\n            };\n\n            const createText = function (\n                fontAsset,\n                message,\n                x,\n                y,\n                z,\n                rotx,\n                roty\n            ) {\n                // Create a text element-based entity\n                const text = new pc.Entity();\n                text.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    fontAsset: fontAsset,\n                    fontSize: 0.5,\n                    pivot: [0.5, 0.5],\n                    text: message,\n                    type: pc.ELEMENTTYPE_TEXT,\n                });\n\n                text.setLocalPosition(x, y, z);\n                text.setLocalEulerAngles(rotx, roty, 0);\n                app.root.addChild(text);\n            };\n\n            for (let i = 0; i < NUM_SPHERES_Z; i++) {\n                for (let j = 0; j < NUM_SPHERES_X; j++) {\n                    createSphere(j, 0, i);\n                }\n            }\n\n            createText(\n                assets.font,\n                \"Anisotropy\",\n                0,\n                0,\n                (NUM_SPHERES_Z + 1) * 0.5,\n                -90,\n                0\n            );\n            createText(\n                assets.font,\n                \"Roughness\",\n                -(NUM_SPHERES_X + 1) * 0.5,\n                0,\n                0,\n                -90,\n                90\n            );\n        });\n    });\n}\n","nameSlug":"material-anisotropic","categorySlug":"graphics"},"material-basic":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/arial.json' }),\n        'rocks': new pc.Asset(\"rocks\", \"texture\", { url: \"/static/assets/textures/seaside-rocks01-diffuse-alpha.png\" })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1, 1)\n            });\n            camera.translate(2, 1, 8);\n            camera.lookAt(new pc.Vec3(0, -0.3, 0));\n            app.root.addChild(camera);\n\n            const NUM_BOXES = 5;\n\n            // alpha blend modes for individual rows\n            const blendModes = [\n                pc.BLEND_ADDITIVE,\n                pc.BLEND_SUBTRACTIVE,\n                pc.BLEND_SCREEN,\n                pc.BLEND_NORMAL,\n                pc.BLEND_NONE\n            ];\n\n            const createPrimitive = function (x: number, y: number, z: number) : pc.Entity {\n\n                // a basic material, which does not have support for lighting\n                const material = new pc.BasicMaterial();\n\n                // diffuse color\n                material.color.set(x, y, 1 - y);\n\n                // diffuse texture with alpha channel for transparency\n                material.colorMap = assets.rocks.resource;\n\n                // disable culling to see back faces as well\n                material.cull = pc.CULLFACE_NONE;\n\n                // set up alpha test value\n                material.alphaTest = x / NUM_BOXES - 0.1;\n\n                // alpha blend mode\n                material.blendType = blendModes[y];\n\n                const box = new pc.Entity();\n                box.addComponent(\"render\", {\n                    material: material,\n                    type: \"box\",\n\n                    // Note: basic material cannot currently cast shadows, disable it\n                    castShadows: false\n                });\n                box.setLocalPosition(x - (NUM_BOXES - 1) * 0.5, y - (NUM_BOXES - 1) * 0.5, z);\n                box.setLocalScale(0.7, 0.7, 0.7);\n                app.root.addChild(box);\n\n                return box;\n            };\n\n            const boxes: Array<pc.Entity> = [];\n            for (let i = 0; i < NUM_BOXES; i++) {\n                for (let j = 0; j < NUM_BOXES; j++) {\n                    boxes.push(createPrimitive(j, i, 0));\n                }\n            }\n\n            const createText = function (fontAsset: pc.Asset, message: string, x: number, y: number, z: number, rot: number) {\n                // Create a text element-based entity\n                const text = new pc.Entity();\n                text.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    fontAsset: fontAsset,\n                    fontSize: 0.5,\n                    pivot: [0.5, 0.5],\n                    text: message,\n                    type: pc.ELEMENTTYPE_TEXT\n                });\n                text.setLocalPosition(x, y, z);\n                text.setLocalEulerAngles(0, 0, rot);\n                app.root.addChild(text);\n            };\n\n            createText(assets.font, 'Alpha Test', 0, -(NUM_BOXES + 1) * 0.5, 0, 0);\n            createText(assets.font, 'Alpha Blend', -(NUM_BOXES + 1) * 0.5, 0, 0, 90);\n\n            // Set an update function on the app's update event\n            let time = 0;\n            const rot = new pc.Quat();\n            app.on(\"update\", function (dt: number) {\n                time += dt;\n\n                // rotate the boxes\n                rot.setFromEulerAngles(20 * time, 30 * time, 0);\n                boxes.forEach((box) => {\n                    box.setRotation(rot);\n                });\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/arial.json\",\n        }),\n        rocks: new pc.Asset(\"rocks\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-diffuse-alpha.png\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1, 1),\n            });\n\n            camera.translate(2, 1, 8);\n            camera.lookAt(new pc.Vec3(0, -0.3, 0));\n            app.root.addChild(camera);\n\n            const NUM_BOXES = 5;\n\n            // alpha blend modes for individual rows\n            const blendModes = [\n                pc.BLEND_ADDITIVE,\n                pc.BLEND_SUBTRACTIVE,\n                pc.BLEND_SCREEN,\n                pc.BLEND_NORMAL,\n                pc.BLEND_NONE,\n            ];\n\n            const createPrimitive = function (x, y, z) {\n                // a basic material, which does not have support for lighting\n                const material = new pc.BasicMaterial();\n\n                // diffuse color\n                material.color.set(x, y, 1 - y);\n\n                // diffuse texture with alpha channel for transparency\n                material.colorMap = assets.rocks.resource;\n\n                // disable culling to see back faces as well\n                material.cull = pc.CULLFACE_NONE;\n\n                // set up alpha test value\n                material.alphaTest = x / NUM_BOXES - 0.1;\n\n                // alpha blend mode\n                material.blendType = blendModes[y];\n\n                const box = new pc.Entity();\n                box.addComponent(\"render\", {\n                    material: material,\n                    type: \"box\",\n\n                    // Note: basic material cannot currently cast shadows, disable it\n                    castShadows: false,\n                });\n\n                box.setLocalPosition(\n                    x - (NUM_BOXES - 1) * 0.5,\n                    y - (NUM_BOXES - 1) * 0.5,\n                    z\n                );\n                box.setLocalScale(0.7, 0.7, 0.7);\n                app.root.addChild(box);\n\n                return box;\n            };\n\n            const boxes = [];\n            for (let i = 0; i < NUM_BOXES; i++) {\n                for (let j = 0; j < NUM_BOXES; j++) {\n                    boxes.push(createPrimitive(j, i, 0));\n                }\n            }\n\n            const createText = function (fontAsset, message, x, y, z, rot) {\n                // Create a text element-based entity\n                const text = new pc.Entity();\n                text.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    fontAsset: fontAsset,\n                    fontSize: 0.5,\n                    pivot: [0.5, 0.5],\n                    text: message,\n                    type: pc.ELEMENTTYPE_TEXT,\n                });\n\n                text.setLocalPosition(x, y, z);\n                text.setLocalEulerAngles(0, 0, rot);\n                app.root.addChild(text);\n            };\n\n            createText(\n                assets.font,\n                \"Alpha Test\",\n                0,\n                -(NUM_BOXES + 1) * 0.5,\n                0,\n                0\n            );\n            createText(\n                assets.font,\n                \"Alpha Blend\",\n                -(NUM_BOXES + 1) * 0.5,\n                0,\n                0,\n                90\n            );\n\n            // Set an update function on the app's update event\n            let time = 0;\n            const rot = new pc.Quat();\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // rotate the boxes\n                rot.setFromEulerAngles(20 * time, 30 * time, 0);\n                boxes.forEach((box) => {\n                    box.setRotation(rot);\n                });\n            });\n        });\n    });\n}\n","nameSlug":"material-basic","categorySlug":"graphics"},"material-clear-coat":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'normal': new pc.Asset('normal', 'texture', { url: '/static/assets/textures/flakes5n.png' }),\n        'diffuse': new pc.Asset('diffuse', 'texture', { url: '/static/assets/textures/flakes5c.png' }),\n        'other': new pc.Asset('other', 'texture', { url: '/static/assets/textures/flakes5o.png' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxMip = 1;\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\");\n            camera.translate(0, 0, 3);\n            app.root.addChild(camera);\n\n            // Create an entity with a directional light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n                color: new pc.Color(1, 0.8, 0.25)\n            });\n            app.root.addChild(light);\n            light.setLocalEulerAngles(85, -100, 0);\n\n            // function to create sphere\n            const createSphere = function (x: number, y: number, z: number, material: pc.Material) {\n                const sphere = new pc.Entity();\n\n                sphere.addComponent(\"render\", {\n                    material: material,\n                    type: \"sphere\"\n                });\n                sphere.setLocalPosition(x, y, z);\n                sphere.setLocalScale(0.7, 0.7, 0.7);\n                app.root.addChild(sphere);\n            };\n\n            const material = new pc.StandardMaterial();\n            material.diffuseMap = assets.diffuse.resource;\n            material.metalnessMap = assets.other.resource;\n            material.metalnessMapChannel = 'r';\n            material.glossMap = assets.other.resource;\n            material.glossMapChannel = 'g';\n            material.normalMap = assets.normal.resource;\n            material.diffuse = new pc.Color(0.6, 0.6, 0.9);\n            material.diffuseTint = true;\n            material.metalness = 1.0;\n            material.gloss = 0.9;\n            material.bumpiness = 0.7;\n            material.useMetalness = true;\n            material.update();\n\n            createSphere(-0.5, 0, 0, material);\n\n            const clearCoatMaterial = new pc.StandardMaterial();\n            clearCoatMaterial.diffuseMap = assets.diffuse.resource;\n            clearCoatMaterial.metalnessMap = assets.other.resource;\n            clearCoatMaterial.metalnessMapChannel = 'r';\n            clearCoatMaterial.glossMap = assets.other.resource;\n            clearCoatMaterial.glossMapChannel = 'g';\n            clearCoatMaterial.normalMap = assets.normal.resource;\n            clearCoatMaterial.diffuse = new pc.Color(0.6, 0.6, 0.9);\n            clearCoatMaterial.diffuseTint = true;\n            clearCoatMaterial.metalness = 1.0;\n            clearCoatMaterial.gloss = 0.9;\n            clearCoatMaterial.bumpiness = 0.7;\n            clearCoatMaterial.useMetalness = true;\n            clearCoatMaterial.clearCoat = 0.25;\n            clearCoatMaterial.clearCoatGloss = 0.9;\n            clearCoatMaterial.update();\n\n            createSphere(0.5, 0, 0, clearCoatMaterial);\n\n            // update things each frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                // rotate camera around the objects\n                time += dt;\n                camera.setLocalPosition(3 * Math.sin(time * 0.5), 0, 3 * Math.cos(time * 0.5));\n                camera.lookAt(pc.Vec3.ZERO);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        normal: new pc.Asset(\"normal\", \"texture\", {\n            url: \"/static/assets/textures/flakes5n.png\",\n        }),\n        diffuse: new pc.Asset(\"diffuse\", \"texture\", {\n            url: \"/static/assets/textures/flakes5c.png\",\n        }),\n        other: new pc.Asset(\"other\", \"texture\", {\n            url: \"/static/assets/textures/flakes5o.png\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxMip = 1;\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\");\n            camera.translate(0, 0, 3);\n            app.root.addChild(camera);\n\n            // Create an entity with a directional light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n                color: new pc.Color(1, 0.8, 0.25),\n            });\n\n            app.root.addChild(light);\n            light.setLocalEulerAngles(85, -100, 0);\n\n            // function to create sphere\n            const createSphere = function (x, y, z, material) {\n                const sphere = new pc.Entity();\n\n                sphere.addComponent(\"render\", {\n                    material: material,\n                    type: \"sphere\",\n                });\n\n                sphere.setLocalPosition(x, y, z);\n                sphere.setLocalScale(0.7, 0.7, 0.7);\n                app.root.addChild(sphere);\n            };\n\n            const material = new pc.StandardMaterial();\n            material.diffuseMap = assets.diffuse.resource;\n            material.metalnessMap = assets.other.resource;\n            material.metalnessMapChannel = \"r\";\n            material.glossMap = assets.other.resource;\n            material.glossMapChannel = \"g\";\n            material.normalMap = assets.normal.resource;\n            material.diffuse = new pc.Color(0.6, 0.6, 0.9);\n            material.diffuseTint = true;\n            material.metalness = 1.0;\n            material.gloss = 0.9;\n            material.bumpiness = 0.7;\n            material.useMetalness = true;\n            material.update();\n\n            createSphere(-0.5, 0, 0, material);\n\n            const clearCoatMaterial = new pc.StandardMaterial();\n            clearCoatMaterial.diffuseMap = assets.diffuse.resource;\n            clearCoatMaterial.metalnessMap = assets.other.resource;\n            clearCoatMaterial.metalnessMapChannel = \"r\";\n            clearCoatMaterial.glossMap = assets.other.resource;\n            clearCoatMaterial.glossMapChannel = \"g\";\n            clearCoatMaterial.normalMap = assets.normal.resource;\n            clearCoatMaterial.diffuse = new pc.Color(0.6, 0.6, 0.9);\n            clearCoatMaterial.diffuseTint = true;\n            clearCoatMaterial.metalness = 1.0;\n            clearCoatMaterial.gloss = 0.9;\n            clearCoatMaterial.bumpiness = 0.7;\n            clearCoatMaterial.useMetalness = true;\n            clearCoatMaterial.clearCoat = 0.25;\n            clearCoatMaterial.clearCoatGloss = 0.9;\n            clearCoatMaterial.update();\n\n            createSphere(0.5, 0, 0, clearCoatMaterial);\n\n            // update things each frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                // rotate camera around the objects\n                time += dt;\n                camera.setLocalPosition(\n                    3 * Math.sin(time * 0.5),\n                    0,\n                    3 * Math.cos(time * 0.5)\n                );\n                camera.lookAt(pc.Vec3.ZERO);\n            });\n        });\n    });\n}\n","nameSlug":"material-clear-coat","categorySlug":"graphics"},"material-physical":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/arial.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.skyboxMip = 1;\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\");\n            camera.translate(0, 0, 9);\n            app.root.addChild(camera);\n\n            const NUM_SPHERES = 5;\n\n            const createSphere = function (x: number, y: number, z: number) {\n                const material = new pc.StandardMaterial();\n                material.metalness = y / (NUM_SPHERES - 1);\n                material.gloss = x / (NUM_SPHERES - 1);\n                material.useMetalness = true;\n                material.update();\n\n                const sphere = new pc.Entity();\n                sphere.addComponent(\"render\", {\n                    material: material,\n                    type: \"sphere\"\n                });\n                sphere.setLocalPosition(x - (NUM_SPHERES - 1) * 0.5, y - (NUM_SPHERES - 1) * 0.5, z);\n                sphere.setLocalScale(0.9, 0.9, 0.9);\n                app.root.addChild(sphere);\n            };\n\n            const createText = function (fontAsset: pc.Asset, message: string, x: number, y: number, z: number, rot: number) {\n                // Create a text element-based entity\n                const text = new pc.Entity();\n                text.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    fontAsset: fontAsset,\n                    fontSize: 0.5,\n                    pivot: [0.5, 0.5],\n                    text: message,\n                    type: pc.ELEMENTTYPE_TEXT\n                });\n                text.setLocalPosition(x, y, z);\n                text.setLocalEulerAngles(0, 0, rot);\n                app.root.addChild(text);\n            };\n\n            for (let i = 0; i < NUM_SPHERES; i++) {\n                for (let j = 0; j < NUM_SPHERES; j++) {\n                    createSphere(j, i, 0);\n                }\n            }\n\n            createText(assets.font, 'Glossiness', 0, -(NUM_SPHERES + 1) * 0.5, 0, 0);\n            createText(assets.font, 'Metalness', -(NUM_SPHERES + 1) * 0.5, 0, 0, 90);\n\n            // rotate the skybox using mouse input\n            const mouse = new pc.Mouse(document.body);\n\n            let x = 0;\n            let y = 0;\n            const rot = new pc.Quat();\n\n            mouse.on('mousemove', function (event) {\n                if (event.buttons[pc.MOUSEBUTTON_LEFT]) {\n                    x += event.dx;\n                    y += event.dy;\n\n                    rot.setFromEulerAngles(0.2 * y, 0.2 * x, 0);\n                    app.scene.skyboxRotation = rot;\n                }\n            });\n        });\n    }).catch(console.error);\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/arial.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions)\n        .then((device) => {\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.RenderComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.ElementComponentSystem,\n            ];\n\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.FontHandler,\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assetListLoader = new pc.AssetListLoader(\n                Object.values(assets),\n                app.assets\n            );\n            assetListLoader.load(() => {\n                app.start();\n\n                app.scene.envAtlas = assets.helipad.resource;\n                app.scene.toneMapping = pc.TONEMAP_ACES;\n                app.scene.skyboxMip = 1;\n\n                // Create an entity with a camera component\n                const camera = new pc.Entity();\n                camera.addComponent(\"camera\");\n                camera.translate(0, 0, 9);\n                app.root.addChild(camera);\n\n                const NUM_SPHERES = 5;\n\n                const createSphere = function (x, y, z) {\n                    const material = new pc.StandardMaterial();\n                    material.metalness = y / (NUM_SPHERES - 1);\n                    material.gloss = x / (NUM_SPHERES - 1);\n                    material.useMetalness = true;\n                    material.update();\n\n                    const sphere = new pc.Entity();\n                    sphere.addComponent(\"render\", {\n                        material: material,\n                        type: \"sphere\",\n                    });\n\n                    sphere.setLocalPosition(\n                        x - (NUM_SPHERES - 1) * 0.5,\n                        y - (NUM_SPHERES - 1) * 0.5,\n                        z\n                    );\n                    sphere.setLocalScale(0.9, 0.9, 0.9);\n                    app.root.addChild(sphere);\n                };\n\n                const createText = function (fontAsset, message, x, y, z, rot) {\n                    // Create a text element-based entity\n                    const text = new pc.Entity();\n                    text.addComponent(\"element\", {\n                        anchor: [0.5, 0.5, 0.5, 0.5],\n                        fontAsset: fontAsset,\n                        fontSize: 0.5,\n                        pivot: [0.5, 0.5],\n                        text: message,\n                        type: pc.ELEMENTTYPE_TEXT,\n                    });\n\n                    text.setLocalPosition(x, y, z);\n                    text.setLocalEulerAngles(0, 0, rot);\n                    app.root.addChild(text);\n                };\n\n                for (let i = 0; i < NUM_SPHERES; i++) {\n                    for (let j = 0; j < NUM_SPHERES; j++) {\n                        createSphere(j, i, 0);\n                    }\n                }\n\n                createText(\n                    assets.font,\n                    \"Glossiness\",\n                    0,\n                    -(NUM_SPHERES + 1) * 0.5,\n                    0,\n                    0\n                );\n                createText(\n                    assets.font,\n                    \"Metalness\",\n                    -(NUM_SPHERES + 1) * 0.5,\n                    0,\n                    0,\n                    90\n                );\n\n                // rotate the skybox using mouse input\n                const mouse = new pc.Mouse(document.body);\n\n                let x = 0;\n                let y = 0;\n                const rot = new pc.Quat();\n\n                mouse.on(\"mousemove\", function (event) {\n                    if (event.buttons[pc.MOUSEBUTTON_LEFT]) {\n                        x += event.dx;\n                        y += event.dy;\n\n                        rot.setFromEulerAngles(0.2 * y, 0.2 * x, 0);\n                        app.scene.skyboxRotation = rot;\n                    }\n                });\n            });\n        })\n        .catch(console.error);\n}\n","nameSlug":"material-physical","categorySlug":"graphics"},"material-translucent-specular":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/arial.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxMip = 1;\n            app.scene.skyboxIntensity = 1;\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\");\n            camera.translate(0, 0, 8);\n            camera.rotate(0, 0, 0);\n            app.root.addChild(camera);\n\n            // Create an entities with a directional light components\n            for (let i = 0; i < 3; i++) {\n                const light = new pc.Entity();\n                light.addComponent(\"light\", {\n                    type: \"directional\"\n                });\n                app.root.addChild(light);\n                light.rotateLocal(60 + 10 * i, 30 + 90 * i, 0);\n            }\n\n            const NUM_SPHERES_X = 10;\n            const NUM_SPHERES_Z = 5;\n\n            const createSphere = function (x: number, y: number, z: number) {\n                const material = new pc.StandardMaterial();\n                material.diffuse = new pc.Color(0.7, 0.7, 0.7);\n                material.specular = new pc.Color(1, 1, 1);\n                material.metalness = 0.0;\n                material.gloss = ((z) / (NUM_SPHERES_Z - 1) * 0.5) + 0.5;\n                material.useMetalness = true;\n                material.blendType = pc.BLEND_NORMAL;\n                material.opacity = (x >= 5) ? ((x - 5) / 5 + 0.2) * ((x - 5) / 5 + 0.2) : (x / 5 + 0.2) * (x / 5 + 0.2);\n                material.opacityFadesSpecular = !(x >= 5);\n                material.alphaWrite = false;\n\n                material.update();\n\n                const sphere = new pc.Entity();\n\n                sphere.addComponent(\"render\", {\n                    material: material,\n                    type: \"sphere\"\n                });\n                sphere.setLocalPosition(x - (NUM_SPHERES_X - 1) * 0.5, z - (NUM_SPHERES_Z - 1) * 0.5, 0);\n                sphere.setLocalScale(0.7, 0.7, 0.7);\n                app.root.addChild(sphere);\n            };\n\n            const createText = function (fontAsset: pc.Asset, message: string, x: number, y: number, z: number, rotx: number, roty: number) {\n                // Create a text element-based entity\n                const text = new pc.Entity();\n                text.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    fontAsset: fontAsset,\n                    fontSize: 0.5,\n                    pivot: [0.5, 0.5],\n                    text: message,\n                    type: pc.ELEMENTTYPE_TEXT\n                });\n                text.setLocalPosition(x, y, z);\n                text.setLocalEulerAngles(rotx, roty, 0);\n                app.root.addChild(text);\n            };\n\n            for (let i = 0; i < NUM_SPHERES_Z; i++) {\n                for (let j = 0; j < NUM_SPHERES_X; j++) {\n                    createSphere(j, 0, i);\n                }\n            }\n\n            createText(assets.font, 'Spec Fade On', -NUM_SPHERES_X * 0.25, ((NUM_SPHERES_Z + 1) * -0.5), 0, -0, 0);\n            createText(assets.font, 'Spec Fade Off', NUM_SPHERES_X * 0.25, ((NUM_SPHERES_Z + 1) * -0.5), 0, -0, 0);\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/arial.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxMip = 1;\n            app.scene.skyboxIntensity = 1;\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\");\n            camera.translate(0, 0, 8);\n            camera.rotate(0, 0, 0);\n            app.root.addChild(camera);\n\n            // Create an entities with a directional light components\n            for (let i = 0; i < 3; i++) {\n                const light = new pc.Entity();\n                light.addComponent(\"light\", {\n                    type: \"directional\",\n                });\n\n                app.root.addChild(light);\n                light.rotateLocal(60 + 10 * i, 30 + 90 * i, 0);\n            }\n\n            const NUM_SPHERES_X = 10;\n            const NUM_SPHERES_Z = 5;\n\n            const createSphere = function (x, y, z) {\n                const material = new pc.StandardMaterial();\n                material.diffuse = new pc.Color(0.7, 0.7, 0.7);\n                material.specular = new pc.Color(1, 1, 1);\n                material.metalness = 0.0;\n                material.gloss = (z / (NUM_SPHERES_Z - 1)) * 0.5 + 0.5;\n                material.useMetalness = true;\n                material.blendType = pc.BLEND_NORMAL;\n                material.opacity =\n                    x >= 5\n                        ? ((x - 5) / 5 + 0.2) * ((x - 5) / 5 + 0.2)\n                        : (x / 5 + 0.2) * (x / 5 + 0.2);\n                material.opacityFadesSpecular = !(x >= 5);\n                material.alphaWrite = false;\n\n                material.update();\n\n                const sphere = new pc.Entity();\n\n                sphere.addComponent(\"render\", {\n                    material: material,\n                    type: \"sphere\",\n                });\n\n                sphere.setLocalPosition(\n                    x - (NUM_SPHERES_X - 1) * 0.5,\n                    z - (NUM_SPHERES_Z - 1) * 0.5,\n                    0\n                );\n                sphere.setLocalScale(0.7, 0.7, 0.7);\n                app.root.addChild(sphere);\n            };\n\n            const createText = function (\n                fontAsset,\n                message,\n                x,\n                y,\n                z,\n                rotx,\n                roty\n            ) {\n                // Create a text element-based entity\n                const text = new pc.Entity();\n                text.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    fontAsset: fontAsset,\n                    fontSize: 0.5,\n                    pivot: [0.5, 0.5],\n                    text: message,\n                    type: pc.ELEMENTTYPE_TEXT,\n                });\n\n                text.setLocalPosition(x, y, z);\n                text.setLocalEulerAngles(rotx, roty, 0);\n                app.root.addChild(text);\n            };\n\n            for (let i = 0; i < NUM_SPHERES_Z; i++) {\n                for (let j = 0; j < NUM_SPHERES_X; j++) {\n                    createSphere(j, 0, i);\n                }\n            }\n\n            createText(\n                assets.font,\n                \"Spec Fade On\",\n                -NUM_SPHERES_X * 0.25,\n                (NUM_SPHERES_Z + 1) * -0.5,\n                0,\n                -0,\n                0\n            );\n            createText(\n                assets.font,\n                \"Spec Fade Off\",\n                NUM_SPHERES_X * 0.25,\n                (NUM_SPHERES_Z + 1) * -0.5,\n                0,\n                -0,\n                0\n            );\n        });\n    });\n}\n","nameSlug":"material-translucent-specular","categorySlug":"graphics"},"mesh-decals":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'spark': new pc.Asset('spark', 'texture', { url: '/static/assets/textures/spark.png' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // create material for the plane\n            const planeMaterial = new pc.StandardMaterial();\n            planeMaterial.gloss = 0.6;\n            planeMaterial.metalness = 0.3;\n            planeMaterial.useMetalness = true;\n            planeMaterial.update();\n\n            // create plane primitive\n            const primitive = new pc.Entity();\n            primitive.addComponent('render', {\n                type: \"plane\",\n                material: planeMaterial\n            });\n\n            // set position and scale and add it to scene\n            primitive.setLocalScale(new pc.Vec3(20, 20, 20));\n            primitive.setLocalPosition(new pc.Vec3(0, -0.01, 0));\n            app.root.addChild(primitive);\n\n            // Create an Entity with a omni light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(0.2, 0.2, 0.2),\n                range: 30,\n                castShadows: true,\n                shadowBias: 0.1,\n                normalOffsetBias: 0.2\n            });\n            light.translate(0, 8, 0);\n            app.root.addChild(light);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.2, 0.2)\n            });\n\n            // Add the camera to the hierarchy\n            app.root.addChild(camera);\n\n            // Position the camera\n            camera.translate(0, 10, 20);\n            camera.lookAt(pc.Vec3.ZERO);\n\n            // Create bouncing ball model and add it to hierarchy\n            const ball = new pc.Entity();\n            ball.addComponent(\"render\", {\n                type: \"sphere\"\n            });\n            app.root.addChild(ball);\n\n            // Allocate space for decals. Each decal is a quad with 4 vertices\n            const numDecals = 500;\n            const numDecalVertices = 4 * numDecals;\n\n            // Allocate storage for vertex positions, vertex stores x, y and z\n            const positions = new Float32Array(3 * numDecalVertices);\n\n            // Allocate storage for colors, each vertex stores r, g, b and a\n            const colors = new Uint8ClampedArray(4 * numDecalVertices);\n\n            // Allocate storage for uvs, each vertex stores u and v. And fill them up to display whole texture\n            const uvs: any = [];\n            for (let i = 0; i < numDecals; i++)\n                uvs.push(0, 0, 0, 1, 1, 1, 1, 0);\n\n            // Allocate and generate indices. Each quad is representing using 2 triangles, and uses 4 vertices\n            const quadTriangles = [\n                0, 1, 2,\n                2, 3, 0\n            ];\n            const indices = new Uint16Array(6 * numDecals);\n            for (let i = 0; i < numDecals; i++) {\n                indices[6 * i + 0] = 4 * i + quadTriangles[0];\n                indices[6 * i + 1] = 4 * i + quadTriangles[1];\n                indices[6 * i + 2] = 4 * i + quadTriangles[2];\n                indices[6 * i + 3] = 4 * i + quadTriangles[3];\n                indices[6 * i + 4] = 4 * i + quadTriangles[4];\n                indices[6 * i + 5] = 4 * i + quadTriangles[5];\n            }\n\n            // Helper function to generate a decal with index i at position pos. It fills up information for all 4 vertices of a quad\n            function createDecal(i: number, pos: pc.Vec3) {\n\n                // random size and rotation angle\n                const size = 0.5 + Math.random();\n                let angle = Math.random() * Math.PI;\n\n                // random color\n                const r = Math.random() * 255;\n                const g = Math.random() * 255;\n                const b = Math.random() * 255;\n\n                for (let j = 0; j < 4; j++) {\n                    colors[i * 16 + j * 4 + 0] = r;\n                    colors[i * 16 + j * 4 + 1] = g;\n                    colors[i * 16 + j * 4 + 2] = b;\n                    colors[i * 16 + j * 4 + 3] = 0;    // alpha is not used by shader\n                }\n\n                // vertex positions to form a square quad with random rotation and size\n                positions[12 * i + 0] = pos.x + size * Math.sin(angle);\n                positions[12 * i + 1] = 0;\n                positions[12 * i + 2] = pos.z + size * Math.cos(angle); angle += Math.PI * 0.5;\n\n                positions[12 * i + 3] = pos.x + size * Math.sin(angle);\n                positions[12 * i + 4] = 0;\n                positions[12 * i + 5] = pos.z + size * Math.cos(angle); angle += Math.PI * 0.5;\n\n                positions[12 * i + 6] = pos.x + size * Math.sin(angle);\n                positions[12 * i + 7] = 0;\n                positions[12 * i + 8] = pos.z + size * Math.cos(angle); angle += Math.PI * 0.5;\n\n                positions[12 * i + 9] = pos.x + size * Math.sin(angle);\n                positions[12 * i + 10] = 0;\n                positions[12 * i + 11] = pos.z + size * Math.cos(angle); angle += Math.PI * 0.5;\n            }\n\n            // helper function to update required vertex streams\n            function updateMesh(mesh: pc.Mesh, updatePositions: any, updateColors: any, initAll?: boolean) {\n\n                // update positions when needed\n                if (updatePositions)\n                    mesh.setPositions(positions);\n\n                // update colors when needed\n                if (updateColors)\n                    mesh.setColors32(colors);\n\n                // update indices and uvs only one time, as they never change\n                if (initAll) {\n                    mesh.setIndices(indices);\n                    mesh.setUvs(0, uvs);\n                }\n\n                mesh.update(pc.PRIMITIVE_TRIANGLES);\n            }\n\n            // Create a mesh with dynamic vertex buffer and static index buffer\n            const mesh = new pc.Mesh(app.graphicsDevice);\n            mesh.clear(true, false);\n            updateMesh(mesh, true, true, true);\n\n            // create material\n            const material = new pc.StandardMaterial();\n            material.useLighting = false;      // turn off lighting - we use emissive texture only. Also, lighting needs normal maps which we don't generate\n            material.diffuse = new pc.Color(0, 0, 0);\n            material.emissiveVertexColor = true;\n            material.blendType = pc.BLEND_ADDITIVE;     // additive alpha blend\n            material.depthWrite = false;        // optimization - no need to write to depth buffer, as decals are part of the ground plane\n            material.emissiveMap = assets.spark.resource;\n            material.update();\n\n            // Create the mesh instance\n            const meshInstance = new pc.MeshInstance(mesh, material);\n\n            // Create Entity with a render component to render the mesh instance\n            const entity = new pc.Entity();\n            entity.addComponent(\"render\", {\n                type: 'asset',\n                meshInstances: [meshInstance],\n                castShadows: false\n            });\n            app.root.addChild(entity);\n\n            // Set an update function on the app's update event\n            let time = 0;\n            let decalIndex = 0;\n            app.on(\"update\", (dt: number) => {\n\n                const previousTime = time;\n                time += dt;\n\n                // Bounce the ball around in a circle with changing radius\n                const radius = Math.abs(Math.sin(time * 0.55) * 9);\n                const previousElevation = 2 * Math.cos(previousTime * 7);\n                const elevation = 2 * Math.cos(time * 7);\n                ball.setLocalPosition(new pc.Vec3(radius * Math.sin(time), 0.5 + Math.abs(elevation), radius * Math.cos(time)));\n\n                // When ball crossed the ground plane\n                let positionsUpdated = false;\n                let colorsUpdated = false;\n                if ((previousElevation < 0 && elevation >= 0) || (elevation < 0 && previousElevation >= 0)) {\n\n                    // create new decal at next index, and roll the index around if out of range\n                    createDecal(decalIndex, ball.getLocalPosition());\n                    decalIndex++;\n                    if (decalIndex >= numDecals)\n                        decalIndex = 0;\n\n                    // both position and color streams were updated\n                    positionsUpdated = true;\n                    colorsUpdated = true;\n                }\n\n                // fade out all vertex colors once a second\n                if (Math.round(time) != Math.round(previousTime)) {\n                    for (let i = 0; i < colors.length; i++)\n                        colors[i] -= 2;\n\n                    // colors were updated\n                    colorsUpdated = true;\n                }\n\n                // update mesh with the streams that were updated\n                updateMesh(mesh, positionsUpdated, colorsUpdated);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        spark: new pc.Asset(\"spark\", \"texture\", {\n            url: \"/static/assets/textures/spark.png\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // create material for the plane\n            const planeMaterial = new pc.StandardMaterial();\n            planeMaterial.gloss = 0.6;\n            planeMaterial.metalness = 0.3;\n            planeMaterial.useMetalness = true;\n            planeMaterial.update();\n\n            // create plane primitive\n            const primitive = new pc.Entity();\n            primitive.addComponent(\"render\", {\n                type: \"plane\",\n                material: planeMaterial,\n            });\n\n            // set position and scale and add it to scene\n            primitive.setLocalScale(new pc.Vec3(20, 20, 20));\n            primitive.setLocalPosition(new pc.Vec3(0, -0.01, 0));\n            app.root.addChild(primitive);\n\n            // Create an Entity with a omni light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(0.2, 0.2, 0.2),\n                range: 30,\n                castShadows: true,\n                shadowBias: 0.1,\n                normalOffsetBias: 0.2,\n            });\n\n            light.translate(0, 8, 0);\n            app.root.addChild(light);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.2, 0.2),\n            });\n\n            // Add the camera to the hierarchy\n            app.root.addChild(camera);\n\n            // Position the camera\n            camera.translate(0, 10, 20);\n            camera.lookAt(pc.Vec3.ZERO);\n\n            // Create bouncing ball model and add it to hierarchy\n            const ball = new pc.Entity();\n            ball.addComponent(\"render\", {\n                type: \"sphere\",\n            });\n\n            app.root.addChild(ball);\n\n            // Allocate space for decals. Each decal is a quad with 4 vertices\n            const numDecals = 500;\n            const numDecalVertices = 4 * numDecals;\n\n            // Allocate storage for vertex positions, vertex stores x, y and z\n            const positions = new Float32Array(3 * numDecalVertices);\n\n            // Allocate storage for colors, each vertex stores r, g, b and a\n            const colors = new Uint8ClampedArray(4 * numDecalVertices);\n\n            // Allocate storage for uvs, each vertex stores u and v. And fill them up to display whole texture\n            const uvs = [];\n            for (let i = 0; i < numDecals; i++)\n                uvs.push(0, 0, 0, 1, 1, 1, 1, 0);\n\n            // Allocate and generate indices. Each quad is representing using 2 triangles, and uses 4 vertices\n            const quadTriangles = [0, 1, 2, 2, 3, 0];\n\n            const indices = new Uint16Array(6 * numDecals);\n            for (let i = 0; i < numDecals; i++) {\n                indices[6 * i + 0] = 4 * i + quadTriangles[0];\n                indices[6 * i + 1] = 4 * i + quadTriangles[1];\n                indices[6 * i + 2] = 4 * i + quadTriangles[2];\n                indices[6 * i + 3] = 4 * i + quadTriangles[3];\n                indices[6 * i + 4] = 4 * i + quadTriangles[4];\n                indices[6 * i + 5] = 4 * i + quadTriangles[5];\n            }\n\n            // Helper function to generate a decal with index i at position pos. It fills up information for all 4 vertices of a quad\n            function createDecal(i, pos) {\n                // random size and rotation angle\n                const size = 0.5 + Math.random();\n                let angle = Math.random() * Math.PI;\n\n                // random color\n                const r = Math.random() * 255;\n                const g = Math.random() * 255;\n                const b = Math.random() * 255;\n\n                for (let j = 0; j < 4; j++) {\n                    colors[i * 16 + j * 4 + 0] = r;\n                    colors[i * 16 + j * 4 + 1] = g;\n                    colors[i * 16 + j * 4 + 2] = b;\n                    colors[i * 16 + j * 4 + 3] = 0; // alpha is not used by shader\n                }\n\n                // vertex positions to form a square quad with random rotation and size\n                positions[12 * i + 0] = pos.x + size * Math.sin(angle);\n                positions[12 * i + 1] = 0;\n                positions[12 * i + 2] = pos.z + size * Math.cos(angle);\n                angle += Math.PI * 0.5;\n\n                positions[12 * i + 3] = pos.x + size * Math.sin(angle);\n                positions[12 * i + 4] = 0;\n                positions[12 * i + 5] = pos.z + size * Math.cos(angle);\n                angle += Math.PI * 0.5;\n\n                positions[12 * i + 6] = pos.x + size * Math.sin(angle);\n                positions[12 * i + 7] = 0;\n                positions[12 * i + 8] = pos.z + size * Math.cos(angle);\n                angle += Math.PI * 0.5;\n\n                positions[12 * i + 9] = pos.x + size * Math.sin(angle);\n                positions[12 * i + 10] = 0;\n                positions[12 * i + 11] = pos.z + size * Math.cos(angle);\n                angle += Math.PI * 0.5;\n            }\n\n            // helper function to update required vertex streams\n            function updateMesh(mesh, updatePositions, updateColors, initAll) {\n                // update positions when needed\n                if (updatePositions) mesh.setPositions(positions);\n\n                // update colors when needed\n                if (updateColors) mesh.setColors32(colors);\n\n                // update indices and uvs only one time, as they never change\n                if (initAll) {\n                    mesh.setIndices(indices);\n                    mesh.setUvs(0, uvs);\n                }\n\n                mesh.update(pc.PRIMITIVE_TRIANGLES);\n            }\n\n            // Create a mesh with dynamic vertex buffer and static index buffer\n            const mesh = new pc.Mesh(app.graphicsDevice);\n            mesh.clear(true, false);\n            updateMesh(mesh, true, true, true);\n\n            // create material\n            const material = new pc.StandardMaterial();\n            material.useLighting = false; // turn off lighting - we use emissive texture only. Also, lighting needs normal maps which we don't generate\n            material.diffuse = new pc.Color(0, 0, 0);\n            material.emissiveVertexColor = true;\n            material.blendType = pc.BLEND_ADDITIVE; // additive alpha blend\n            material.depthWrite = false; // optimization - no need to write to depth buffer, as decals are part of the ground plane\n            material.emissiveMap = assets.spark.resource;\n            material.update();\n\n            // Create the mesh instance\n            const meshInstance = new pc.MeshInstance(mesh, material);\n\n            // Create Entity with a render component to render the mesh instance\n            const entity = new pc.Entity();\n            entity.addComponent(\"render\", {\n                type: \"asset\",\n                meshInstances: [meshInstance],\n                castShadows: false,\n            });\n\n            app.root.addChild(entity);\n\n            // Set an update function on the app's update event\n            let time = 0;\n            let decalIndex = 0;\n            app.on(\"update\", (dt) => {\n                const previousTime = time;\n                time += dt;\n\n                // Bounce the ball around in a circle with changing radius\n                const radius = Math.abs(Math.sin(time * 0.55) * 9);\n                const previousElevation = 2 * Math.cos(previousTime * 7);\n                const elevation = 2 * Math.cos(time * 7);\n                ball.setLocalPosition(\n                    new pc.Vec3(\n                        radius * Math.sin(time),\n                        0.5 + Math.abs(elevation),\n                        radius * Math.cos(time)\n                    )\n                );\n\n                // When ball crossed the ground plane\n                let positionsUpdated = false;\n                let colorsUpdated = false;\n                if (\n                    (previousElevation < 0 && elevation >= 0) ||\n                    (elevation < 0 && previousElevation >= 0)\n                ) {\n                    // create new decal at next index, and roll the index around if out of range\n                    createDecal(decalIndex, ball.getLocalPosition());\n                    decalIndex++;\n                    if (decalIndex >= numDecals) decalIndex = 0;\n\n                    // both position and color streams were updated\n                    positionsUpdated = true;\n                    colorsUpdated = true;\n                }\n\n                // fade out all vertex colors once a second\n                if (Math.round(time) != Math.round(previousTime)) {\n                    for (let i = 0; i < colors.length; i++) colors[i] -= 2;\n\n                    // colors were updated\n                    colorsUpdated = true;\n                }\n\n                // update mesh with the streams that were updated\n                updateMesh(mesh, positionsUpdated, colorsUpdated);\n            });\n        });\n    });\n}\n","nameSlug":"mesh-decals","categorySlug":"graphics"},"mesh-deformation":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' }),\n        'helipad': new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // setup skydome\n            app.scene.skyboxMip = 2;\n            app.scene.exposure = 1;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5)\n            });\n            camera.translate(0, 7, 24);\n            app.root.addChild(camera);\n\n            // create a hierarchy of entities with render components, representing the statue model\n            const entity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            // collect positions from all mesh instances to work on\n            const allMeshes: any = [];\n            const renders: Array<pc.RenderComponent> = entity.findComponents(\"render\");\n            renders.forEach((render) => {\n\n                // collect positions from all mesh instances on this render component\n                const meshInstances = render.meshInstances;\n                for (let i = 0; i < meshInstances.length; i++) {\n                    const meshInstance = meshInstances[i];\n\n                    // get positions from the mesh\n                    const mesh = meshInstance.mesh;\n                    const srcPositions: any = [];\n                    mesh.getPositions(srcPositions);\n\n                    // store it\n                    allMeshes.push({\n                        mesh: mesh,\n                        srcPositions: srcPositions\n                    });\n                }\n            });\n\n            // temporary work array of positions to avoid per frame allocations\n            const tempPositions: any = [];\n\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                if (entity) {\n\n                    // orbit the camera\n                    camera.setLocalPosition(25 * Math.sin(time * 0.2), 15, 25 * Math.cos(time * 0.2));\n                    camera.lookAt(new pc.Vec3(0, 7, 0));\n\n                    const strength = 50;\n\n                    // modify mesh positions on each frame\n                    for (let i = 0; i < allMeshes.length; i++) {\n                        tempPositions.length = 0;\n                        const srcPositions = allMeshes[i].srcPositions;\n\n                        // loop over all positions, and fill up tempPositions array with waved version of positions from srcPositions array\n                        // modify .x and .z components based on sin function, which uses .y component\n                        for (let k = 0; k < srcPositions.length; k += 3) {\n                            tempPositions[k] = srcPositions[k] + strength * Math.sin(time + srcPositions[k + 1] * 0.01);\n                            tempPositions[k + 1] = srcPositions[k + 1];\n                            tempPositions[k + 2] = srcPositions[k + 2] + strength * Math.sin(time + srcPositions[k + 1] * 0.01);\n                        }\n\n                        // set new positions on the mesh\n                        const mesh = allMeshes[i].mesh;\n                        mesh.setPositions(tempPositions);\n                        mesh.update();\n                    }\n                }\n            });\n        });\n    }).catch(console.error);\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions)\n        .then((device) => {\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.RenderComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.LightComponentSystem,\n            ];\n\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.ContainerHandler,\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assetListLoader = new pc.AssetListLoader(\n                Object.values(assets),\n                app.assets\n            );\n            assetListLoader.load(() => {\n                app.start();\n\n                // setup skydome\n                app.scene.skyboxMip = 2;\n                app.scene.exposure = 1;\n                app.scene.envAtlas = assets.helipad.resource;\n\n                // Create an Entity with a camera component\n                const camera = new pc.Entity();\n                camera.addComponent(\"camera\", {\n                    clearColor: new pc.Color(0.4, 0.45, 0.5),\n                });\n\n                camera.translate(0, 7, 24);\n                app.root.addChild(camera);\n\n                // create a hierarchy of entities with render components, representing the statue model\n                const entity = assets.statue.resource.instantiateRenderEntity();\n                app.root.addChild(entity);\n\n                // collect positions from all mesh instances to work on\n                const allMeshes = [];\n                const renders = entity.findComponents(\"render\");\n                renders.forEach((render) => {\n                    // collect positions from all mesh instances on this render component\n                    const meshInstances = render.meshInstances;\n                    for (let i = 0; i < meshInstances.length; i++) {\n                        const meshInstance = meshInstances[i];\n\n                        // get positions from the mesh\n                        const mesh = meshInstance.mesh;\n                        const srcPositions = [];\n                        mesh.getPositions(srcPositions);\n\n                        // store it\n                        allMeshes.push({\n                            mesh: mesh,\n                            srcPositions: srcPositions,\n                        });\n                    }\n                });\n\n                // temporary work array of positions to avoid per frame allocations\n                const tempPositions = [];\n\n                let time = 0;\n                app.on(\"update\", function (dt) {\n                    time += dt;\n\n                    if (entity) {\n                        // orbit the camera\n                        camera.setLocalPosition(\n                            25 * Math.sin(time * 0.2),\n                            15,\n                            25 * Math.cos(time * 0.2)\n                        );\n                        camera.lookAt(new pc.Vec3(0, 7, 0));\n\n                        const strength = 50;\n\n                        // modify mesh positions on each frame\n                        for (let i = 0; i < allMeshes.length; i++) {\n                            tempPositions.length = 0;\n                            const srcPositions = allMeshes[i].srcPositions;\n\n                            // loop over all positions, and fill up tempPositions array with waved version of positions from srcPositions array\n                            // modify .x and .z components based on sin function, which uses .y component\n                            for (let k = 0; k < srcPositions.length; k += 3) {\n                                tempPositions[k] =\n                                    srcPositions[k] +\n                                    strength *\n                                        Math.sin(\n                                            time + srcPositions[k + 1] * 0.01\n                                        );\n                                tempPositions[k + 1] = srcPositions[k + 1];\n                                tempPositions[k + 2] =\n                                    srcPositions[k + 2] +\n                                    strength *\n                                        Math.sin(\n                                            time + srcPositions[k + 1] * 0.01\n                                        );\n                            }\n\n                            // set new positions on the mesh\n                            const mesh = allMeshes[i].mesh;\n                            mesh.setPositions(tempPositions);\n                            mesh.update();\n                        }\n                    }\n                });\n            });\n        })\n        .catch(console.error);\n}\n","nameSlug":"mesh-deformation","categorySlug":"graphics"},"mesh-generation":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'playcanvasGrey': new pc.Asset('playcanvasGrey', 'texture', { url: '/static/assets/textures/playcanvas-grey.png' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);\n\n            // helper function to create a light\n            function createLight(color: pc.Color, scale: number) {\n\n                // Create an Entity with a omni light component, which is casting shadows (using rendering to cubemap)\n                const light = new pc.Entity();\n                light.addComponent(\"light\", {\n                    type: \"omni\",\n                    color: color,\n                    radius: 10,\n                    castShadows: false\n                });\n\n                // create material of specified color\n                const material = new pc.StandardMaterial();\n                material.emissive = color;\n                material.update();\n\n                // add sphere at the position of light\n                light.addComponent(\"render\", {\n                    type: \"sphere\",\n                    material: material\n                });\n\n                // Scale the sphere\n                light.setLocalScale(scale, scale, scale);\n\n                app.root.addChild(light);\n                return light;\n            }\n\n            // create 4 lights that will move in the scene and deform the mesh as well\n            const lights = [\n                { radius: 7, speed: 1.0, scale: 2.5, light: createLight(new pc.Color(0.3, 0.9, 0.6), 1.0) },\n                { radius: 3, speed: 1.2, scale: 3.0, light: createLight(new pc.Color(0.7, 0.2, 0.3), 1.3) },\n                { radius: 5, speed: -0.8, scale: 4.0, light: createLight(new pc.Color(0.2, 0.2, 0.9), 1.5) },\n                { radius: 4, speed: -0.3, scale: 5.5, light: createLight(new pc.Color(0.8, 0.9, 0.4), 1.7) }\n            ];\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.2, 0.2)\n            });\n\n            // Add the new Entity to the hierarchy\n            app.root.addChild(camera);\n\n            // Position the camera\n            camera.translate(0, 5, 20);\n            camera.lookAt(pc.Vec3.ZERO);\n\n            // Generate a 3D grid plane with world size of 20, and resolution of 60\n            const resolution = 60;\n            const extent = 20;\n            const scale = extent / resolution;\n\n            // Generate positions and uv coordinates for vertices, store them in Float32Arrays\n            const positions = new Float32Array(3 * resolution * resolution);\n            const uvs =  new Float32Array(2 * resolution * resolution);\n            let index = 0;\n            for (let x = 0; x < resolution; x++) {\n                for (let z = 0; z < resolution; z++) {\n                    positions[3 * index] = scale * (x - resolution * 0.5);\n                    positions[3 * index + 1] = 0;  // no elevation, flat grid\n                    positions[3 * index + 2] = scale * (z - resolution * 0.5);\n                    uvs[2 * index] = x / resolution;\n                    uvs[2 * index + 1] = 1 - z / resolution;\n                    index++;\n                }\n            }\n\n            // Generate array of indices to form triangle list - two triangles per grid square\n            const indexArray: any = [];\n            for (let x = 0; x < resolution - 1; x++) {\n                for (let y = 0; y < resolution - 1; y++) {\n                    indexArray.push(x * resolution + y + 1, (x + 1) * resolution + y, x * resolution + y,\n                                    (x + 1) * resolution + y, x * resolution + y + 1, (x + 1) * resolution + y + 1);\n                }\n            }\n\n            // helper function to update required vertex / index streams\n            function updateMesh(mesh: pc.Mesh, initAll?: boolean) {\n\n                // Set updated positions and normal each frame\n                mesh.setPositions(positions);\n                // @ts-ignore engine-tsd\n                mesh.setNormals(pc.calculateNormals(positions, indexArray));\n\n                // update mesh Uvs and Indices only one time, as they do not change each frame\n                if (initAll) {\n                    mesh.setUvs(0, uvs);\n                    mesh.setIndices(indexArray);\n                }\n\n                // Let mesh update Vertex and Index buffer as needed\n                mesh.update(pc.PRIMITIVE_TRIANGLES);\n            }\n\n            // Create a mesh with dynamic vertex buffer and static index buffer\n            const mesh = new pc.Mesh(app.graphicsDevice);\n            mesh.clear(true, false);\n            updateMesh(mesh, true);\n\n            // create material\n            const material = new pc.StandardMaterial();\n            material.diffuseMap = assets.playcanvasGrey.resource;\n            material.gloss = 0.5;\n            material.metalness = 0.3;\n            material.useMetalness = true;\n            material.update();\n\n            // Create the mesh instance\n            const meshInstance = new pc.MeshInstance(mesh, material);\n\n            // Create the entity with render component using meshInstances\n            const entity = new pc.Entity();\n            entity.addComponent(\"render\", {\n                meshInstances: [meshInstance]\n            });\n            app.root.addChild(entity);\n\n            // Set an update function on the app's update event\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // Move the lights along circles, also keep separate list of their position for faster update in next block of code\n                const lightPositions = [];\n                for (let l = 0; l < lights.length; l++) {\n                    const element = lights[l];\n                    const lightPos = new pc.Vec2(element.radius * Math.sin(time * element.speed), element.radius * Math.cos(time * element.speed));\n                    lightPositions.push(lightPos);\n                    element.light.setLocalPosition(lightPos.x, 3, lightPos.y);\n                }\n\n                // animate .y coordinate of grid vertices by moving them up when lights are close\n                let index = 0;\n                for (let x = 0; x < resolution; x++) {\n                    for (let z = 0; z < resolution; z++) {\n\n                        let elevation = 0;\n\n                        // Evaluate distance of grid vertex to each light position, and increase elevation if light is within the range\n                        for (let l = 0; l < lightPositions.length; l++) {\n                            const dx = positions[index] - lightPositions[l].x;\n                            const dz = positions[index + 2] - lightPositions[l].y;\n                            let dist = Math.sqrt(dx * dx + dz * dz);\n                            dist = pc.math.clamp(dist, 0, lights[l].scale);\n                            dist = pc.math.smoothstep(0, lights[l].scale, dist);\n                            elevation += (1 - dist);\n                        }\n\n                        // Store elevation in .y element\n                        positions[index + 1] = elevation;\n                        index += 3;\n                    }\n                }\n\n                // update the mesh\n                updateMesh(mesh);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        playcanvasGrey: new pc.Asset(\"playcanvasGrey\", \"texture\", {\n            url: \"/static/assets/textures/playcanvas-grey.png\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);\n\n            // helper function to create a light\n            function createLight(color, scale) {\n                // Create an Entity with a omni light component, which is casting shadows (using rendering to cubemap)\n                const light = new pc.Entity();\n                light.addComponent(\"light\", {\n                    type: \"omni\",\n                    color: color,\n                    radius: 10,\n                    castShadows: false,\n                });\n\n                // create material of specified color\n                const material = new pc.StandardMaterial();\n                material.emissive = color;\n                material.update();\n\n                // add sphere at the position of light\n                light.addComponent(\"render\", {\n                    type: \"sphere\",\n                    material: material,\n                });\n\n                // Scale the sphere\n                light.setLocalScale(scale, scale, scale);\n\n                app.root.addChild(light);\n                return light;\n            }\n\n            // create 4 lights that will move in the scene and deform the mesh as well\n            const lights = [\n                {\n                    radius: 7,\n                    speed: 1.0,\n                    scale: 2.5,\n                    light: createLight(new pc.Color(0.3, 0.9, 0.6), 1.0),\n                },\n                {\n                    radius: 3,\n                    speed: 1.2,\n                    scale: 3.0,\n                    light: createLight(new pc.Color(0.7, 0.2, 0.3), 1.3),\n                },\n                {\n                    radius: 5,\n                    speed: -0.8,\n                    scale: 4.0,\n                    light: createLight(new pc.Color(0.2, 0.2, 0.9), 1.5),\n                },\n                {\n                    radius: 4,\n                    speed: -0.3,\n                    scale: 5.5,\n                    light: createLight(new pc.Color(0.8, 0.9, 0.4), 1.7),\n                },\n            ];\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.2, 0.2),\n            });\n\n            // Add the new Entity to the hierarchy\n            app.root.addChild(camera);\n\n            // Position the camera\n            camera.translate(0, 5, 20);\n            camera.lookAt(pc.Vec3.ZERO);\n\n            // Generate a 3D grid plane with world size of 20, and resolution of 60\n            const resolution = 60;\n            const extent = 20;\n            const scale = extent / resolution;\n\n            // Generate positions and uv coordinates for vertices, store them in Float32Arrays\n            const positions = new Float32Array(3 * resolution * resolution);\n            const uvs = new Float32Array(2 * resolution * resolution);\n            let index = 0;\n            for (let x = 0; x < resolution; x++) {\n                for (let z = 0; z < resolution; z++) {\n                    positions[3 * index] = scale * (x - resolution * 0.5);\n                    positions[3 * index + 1] = 0; // no elevation, flat grid\n                    positions[3 * index + 2] = scale * (z - resolution * 0.5);\n                    uvs[2 * index] = x / resolution;\n                    uvs[2 * index + 1] = 1 - z / resolution;\n                    index++;\n                }\n            }\n\n            // Generate array of indices to form triangle list - two triangles per grid square\n            const indexArray = [];\n            for (let x = 0; x < resolution - 1; x++) {\n                for (let y = 0; y < resolution - 1; y++) {\n                    indexArray.push(\n                        x * resolution + y + 1,\n                        (x + 1) * resolution + y,\n                        x * resolution + y,\n                        (x + 1) * resolution + y,\n                        x * resolution + y + 1,\n                        (x + 1) * resolution + y + 1\n                    );\n                }\n            }\n\n            // helper function to update required vertex / index streams\n            function updateMesh(mesh, initAll) {\n                // Set updated positions and normal each frame\n                mesh.setPositions(positions);\n                // @ts-ignore engine-tsd\n                mesh.setNormals(pc.calculateNormals(positions, indexArray));\n\n                // update mesh Uvs and Indices only one time, as they do not change each frame\n                if (initAll) {\n                    mesh.setUvs(0, uvs);\n                    mesh.setIndices(indexArray);\n                }\n\n                // Let mesh update Vertex and Index buffer as needed\n                mesh.update(pc.PRIMITIVE_TRIANGLES);\n            }\n\n            // Create a mesh with dynamic vertex buffer and static index buffer\n            const mesh = new pc.Mesh(app.graphicsDevice);\n            mesh.clear(true, false);\n            updateMesh(mesh, true);\n\n            // create material\n            const material = new pc.StandardMaterial();\n            material.diffuseMap = assets.playcanvasGrey.resource;\n            material.gloss = 0.5;\n            material.metalness = 0.3;\n            material.useMetalness = true;\n            material.update();\n\n            // Create the mesh instance\n            const meshInstance = new pc.MeshInstance(mesh, material);\n\n            // Create the entity with render component using meshInstances\n            const entity = new pc.Entity();\n            entity.addComponent(\"render\", {\n                meshInstances: [meshInstance],\n            });\n\n            app.root.addChild(entity);\n\n            // Set an update function on the app's update event\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // Move the lights along circles, also keep separate list of their position for faster update in next block of code\n                const lightPositions = [];\n                for (let l = 0; l < lights.length; l++) {\n                    const element = lights[l];\n                    const lightPos = new pc.Vec2(\n                        element.radius * Math.sin(time * element.speed),\n                        element.radius * Math.cos(time * element.speed)\n                    );\n                    lightPositions.push(lightPos);\n                    element.light.setLocalPosition(lightPos.x, 3, lightPos.y);\n                }\n\n                // animate .y coordinate of grid vertices by moving them up when lights are close\n                let index = 0;\n                for (let x = 0; x < resolution; x++) {\n                    for (let z = 0; z < resolution; z++) {\n                        let elevation = 0;\n\n                        // Evaluate distance of grid vertex to each light position, and increase elevation if light is within the range\n                        for (let l = 0; l < lightPositions.length; l++) {\n                            const dx = positions[index] - lightPositions[l].x;\n                            const dz =\n                                positions[index + 2] - lightPositions[l].y;\n                            let dist = Math.sqrt(dx * dx + dz * dz);\n                            dist = pc.math.clamp(dist, 0, lights[l].scale);\n                            dist = pc.math.smoothstep(0, lights[l].scale, dist);\n                            elevation += 1 - dist;\n                        }\n\n                        // Store elevation in .y element\n                        positions[index + 1] = elevation;\n                        index += 3;\n                    }\n                }\n\n                // update the mesh\n                updateMesh(mesh);\n            });\n        });\n    });\n}\n","nameSlug":"mesh-generation","categorySlug":"graphics"},"mesh-morph-many":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // setup skydome\n            app.scene.skyboxMip = 2;\n            app.scene.exposure = 0.6;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // Create an entity with a directional light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n                castShadows: true,\n                shadowBias: 0.5,\n                shadowDistance: 25,\n                color: new pc.Color(0.5, 0.5, 0.5)\n            });\n            app.root.addChild(light);\n            light.setLocalEulerAngles(45, 45, 0);\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1)\n            });\n            app.root.addChild(camera);\n\n            // position the camera\n            camera.setLocalPosition(0, 4, 14);\n            camera.lookAt(pc.Vec3.ZERO);\n\n            // helper function to return the shortest distance from point [x, y, z] to a plane defined by [a, b, c] normal and constant d\n            const shortestDistance = function (x: number, y: number, z: number, a: number, b: number, c: number, d: number) {\n                d = Math.abs((a * x + b * y + c * z + d));\n                const e = Math.sqrt(a * a + b * b + c * c);\n                return d / e;\n            };\n\n            // helper function that creates a morph target from original positions, normals and indices, and a plane normal [nx, ny, nz]\n            const createMorphTarget = function (positions: string | any[], normals: any[], indices: any[], offset: number, nx: number, ny: number, nz: number) {\n\n                // modify vertices to separate array\n                const modifiedPositions = new Float32Array(positions.length);\n                let dist: number;\n                let i: number;\n                let displacement: number;\n                const limit = 0.2 + Math.random() * 0.5;\n                const range = 1 + 2 * Math.random();\n                for (i = 0; i < positions.length; i += 3) {\n                    // distance of the point to the specified plane\n                    dist = shortestDistance(positions[i], positions[i + 1], positions[i + 2], nx, ny, nz, offset);\n\n                    // modify distance to displacement amount - displace nearby points more than distant points\n                    displacement = pc.math.smoothstep(0, limit, dist);\n                    displacement = 1 - displacement;\n                    displacement *= range;\n\n                    // generate new position by extruding vertex along normal by displacement\n                    modifiedPositions[i] = positions[i] + normals[i] * displacement;\n                    modifiedPositions[i + 1] = positions[i + 1] + normals[i + 1] * displacement;\n                    modifiedPositions[i + 2] = positions[i + 2] + normals[i + 2] * displacement;\n                }\n\n                // generate normals based on modified positions and indices\n                // @ts-ignore engine-tsd\n                const modifiedNormals = new Float32Array(pc.calculateNormals(modifiedPositions, indices));\n\n                // generate delta positions and normals - as morph targets store delta between base position / normal and modified position / normal\n                for (i = 0; i < modifiedNormals.length; i++) {\n                    modifiedPositions[i] -= positions[i];\n                    modifiedNormals[i] -= normals[i];\n                }\n\n                // create a morph target\n                // @ts-ignore engine-tsd\n                return new pc.MorphTarget({\n                    deltaPositions: modifiedPositions,\n                    deltaNormals: modifiedNormals\n                });\n            };\n\n            // create the base mesh - a sphere, with higher amount of vertices / triangles\n            const mesh = pc.createCylinder(app.graphicsDevice, { height: 10, heightSegments: 200, capSegments: 100 });\n\n            // obtain base mesh vertex / index data\n            const srcPositions: Float32Array | number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array = [], srcNormals: Float32Array | number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array = [], indices: number[] | Uint8Array | Uint16Array | Uint32Array = [];\n            mesh.getPositions(srcPositions);\n            mesh.getNormals(srcNormals);\n            mesh.getIndices(indices);\n\n            // build morph targets by expanding a part of cylinder by the normal\n            const targets = [];\n            let startOffset = -4.5;\n            const endOffset = 4.5;\n            const count = 12;\n            const deltaOffset = (endOffset - startOffset) / (count - 1);\n            for (let o = 0; o < count; o++) {\n                targets.push(createMorphTarget(srcPositions, srcNormals, indices, startOffset, 0, 1, 0));\n                startOffset += deltaOffset;\n            }\n\n            // create a morph using these targets\n            mesh.morph = new pc.Morph(targets, app.graphicsDevice);\n\n            // material\n            const material = new pc.StandardMaterial();\n            material.gloss = 0.5;\n            material.metalness = 0.3;\n            material.useMetalness = true;\n            material.update();\n\n            // Create the mesh instance\n            const meshInstance = new pc.MeshInstance(mesh, material);\n\n            // add morph instance - this is where currently set weights are stored\n            const morphInstance = new pc.MorphInstance(mesh.morph);\n            meshInstance.morphInstance = morphInstance;\n\n            // Create Entity and add it to the scene\n            const entity = new pc.Entity();\n            entity.addComponent(\"render\", {\n                material: material,\n                meshInstances: [meshInstance]\n            });\n            entity.setLocalPosition(0, 0, 0);\n            app.root.addChild(entity);\n\n            // update function called once per frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // modify weights of all morph targets along sin curve with different frequency\n                for (let i = 0; i < targets.length; i++) {\n                    morphInstance.setWeight(i, Math.abs(Math.sin(time * 2 * (i + 5) / targets.length)));\n                }\n\n                // debug display the morph target textures blended together\n                if (morphInstance.texturePositions) {\n                    // @ts-ignore\n                    app.drawTexture(-0.7, -0.7, 0.4, 0.4, morphInstance.texturePositions);\n                }\n\n                if (morphInstance.textureNormals) {\n                    // @ts-ignore\n                    app.drawTexture(0.7, -0.7, 0.4, 0.4, morphInstance.textureNormals);\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // setup skydome\n            app.scene.skyboxMip = 2;\n            app.scene.exposure = 0.6;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            // Create an entity with a directional light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n                castShadows: true,\n                shadowBias: 0.5,\n                shadowDistance: 25,\n                color: new pc.Color(0.5, 0.5, 0.5),\n            });\n\n            app.root.addChild(light);\n            light.setLocalEulerAngles(45, 45, 0);\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.1, 0.1, 0.1),\n            });\n\n            app.root.addChild(camera);\n\n            // position the camera\n            camera.setLocalPosition(0, 4, 14);\n            camera.lookAt(pc.Vec3.ZERO);\n\n            // helper function to return the shortest distance from point [x, y, z] to a plane defined by [a, b, c] normal and constant d\n            const shortestDistance = function (x, y, z, a, b, c, d) {\n                d = Math.abs(a * x + b * y + c * z + d);\n                const e = Math.sqrt(a * a + b * b + c * c);\n                return d / e;\n            };\n\n            // helper function that creates a morph target from original positions, normals and indices, and a plane normal [nx, ny, nz]\n            const createMorphTarget = function (\n                positions,\n                normals,\n                indices,\n                offset,\n                nx,\n                ny,\n                nz\n            ) {\n                // modify vertices to separate array\n                const modifiedPositions = new Float32Array(positions.length);\n                let dist;\n                let i;\n                let displacement;\n                const limit = 0.2 + Math.random() * 0.5;\n                const range = 1 + 2 * Math.random();\n                for (i = 0; i < positions.length; i += 3) {\n                    // distance of the point to the specified plane\n                    dist = shortestDistance(\n                        positions[i],\n                        positions[i + 1],\n                        positions[i + 2],\n                        nx,\n                        ny,\n                        nz,\n                        offset\n                    );\n\n                    // modify distance to displacement amount - displace nearby points more than distant points\n                    displacement = pc.math.smoothstep(0, limit, dist);\n                    displacement = 1 - displacement;\n                    displacement *= range;\n\n                    // generate new position by extruding vertex along normal by displacement\n                    modifiedPositions[i] =\n                        positions[i] + normals[i] * displacement;\n                    modifiedPositions[i + 1] =\n                        positions[i + 1] + normals[i + 1] * displacement;\n                    modifiedPositions[i + 2] =\n                        positions[i + 2] + normals[i + 2] * displacement;\n                }\n\n                // generate normals based on modified positions and indices\n                // @ts-ignore engine-tsd\n                const modifiedNormals = new Float32Array(\n                    pc.calculateNormals(modifiedPositions, indices)\n                );\n\n                // generate delta positions and normals - as morph targets store delta between base position / normal and modified position / normal\n                for (i = 0; i < modifiedNormals.length; i++) {\n                    modifiedPositions[i] -= positions[i];\n                    modifiedNormals[i] -= normals[i];\n                }\n\n                // create a morph target\n                // @ts-ignore engine-tsd\n                return new pc.MorphTarget({\n                    deltaPositions: modifiedPositions,\n                    deltaNormals: modifiedNormals,\n                });\n            };\n\n            // create the base mesh - a sphere, with higher amount of vertices / triangles\n            const mesh = pc.createCylinder(app.graphicsDevice, {\n                height: 10,\n                heightSegments: 200,\n                capSegments: 100,\n            });\n\n            // obtain base mesh vertex / index data\n            const srcPositions = [],\n                srcNormals = [],\n                indices = [];\n            mesh.getPositions(srcPositions);\n            mesh.getNormals(srcNormals);\n            mesh.getIndices(indices);\n\n            // build morph targets by expanding a part of cylinder by the normal\n            const targets = [];\n            let startOffset = -4.5;\n            const endOffset = 4.5;\n            const count = 12;\n            const deltaOffset = (endOffset - startOffset) / (count - 1);\n            for (let o = 0; o < count; o++) {\n                targets.push(\n                    createMorphTarget(\n                        srcPositions,\n                        srcNormals,\n                        indices,\n                        startOffset,\n                        0,\n                        1,\n                        0\n                    )\n                );\n                startOffset += deltaOffset;\n            }\n\n            // create a morph using these targets\n            mesh.morph = new pc.Morph(targets, app.graphicsDevice);\n\n            // material\n            const material = new pc.StandardMaterial();\n            material.gloss = 0.5;\n            material.metalness = 0.3;\n            material.useMetalness = true;\n            material.update();\n\n            // Create the mesh instance\n            const meshInstance = new pc.MeshInstance(mesh, material);\n\n            // add morph instance - this is where currently set weights are stored\n            const morphInstance = new pc.MorphInstance(mesh.morph);\n            meshInstance.morphInstance = morphInstance;\n\n            // Create Entity and add it to the scene\n            const entity = new pc.Entity();\n            entity.addComponent(\"render\", {\n                material: material,\n                meshInstances: [meshInstance],\n            });\n\n            entity.setLocalPosition(0, 0, 0);\n            app.root.addChild(entity);\n\n            // update function called once per frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // modify weights of all morph targets along sin curve with different frequency\n                for (let i = 0; i < targets.length; i++) {\n                    morphInstance.setWeight(\n                        i,\n                        Math.abs(\n                            Math.sin((time * 2 * (i + 5)) / targets.length)\n                        )\n                    );\n                }\n\n                // debug display the morph target textures blended together\n                if (morphInstance.texturePositions) {\n                    // @ts-ignore\n                    app.drawTexture(\n                        -0.7,\n                        -0.7,\n                        0.4,\n                        0.4,\n                        morphInstance.texturePositions\n                    );\n                }\n\n                if (morphInstance.textureNormals) {\n                    // @ts-ignore\n                    app.drawTexture(\n                        0.7,\n                        -0.7,\n                        0.4,\n                        0.4,\n                        morphInstance.textureNormals\n                    );\n                }\n            });\n        });\n    });\n}\n","nameSlug":"mesh-morph-many","categorySlug":"graphics"},"mesh-morph":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // Create an entity with a directional light component\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\"\n        });\n        app.root.addChild(light);\n        light.setLocalEulerAngles(45, 30, 0);\n\n        // Create an entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.1, 0.1, 0.1)\n        });\n        app.root.addChild(camera);\n\n        // helper function to return the shortest distance from point [x, y, z] to a plane defined by [a, b, c] normal\n        const shortestDistance = function (x: number, y: number, z: number, a: number, b: number, c: number) {\n            const d = Math.abs(a * x + b * y + c * z);\n            const e = Math.sqrt(a * a + b * b + c * c);\n            return d / e;\n        };\n\n        // helper function that creates a morph target from original positions, normals and indices, and a plane normal [nx, ny, nz]\n        const createMorphTarget = function (positions: number[], normals: number[], indices: number[], nx: number, ny: number, nz: number) {\n\n            // modify vertices to separate array\n            const modifiedPositions = new Float32Array(positions.length);\n            let dist: number, i: number, displacement: number;\n            const limit = 0.2;\n            for (i = 0; i < positions.length; i += 3) {\n                // distance of the point to the specified plane\n                dist = shortestDistance(positions[i], positions[i + 1], positions[i + 2], nx, ny, nz);\n\n                // modify distance to displacement amount - displace nearby points more than distant points\n                displacement = pc.math.smoothstep(0, limit, dist);\n                displacement = 1 - displacement;\n\n                // generate new position by extruding vertex along normal by displacement\n                modifiedPositions[i] = positions[i] + normals[i] * displacement;\n                modifiedPositions[i + 1] = positions[i + 1] + normals[i + 1] * displacement;\n                modifiedPositions[i + 2] = positions[i + 2] + normals[i + 2] * displacement;\n            }\n\n            // generate normals based on modified positions and indices\n            // @ts-ignore engine-tsd\n            const modifiedNormals = new Float32Array(pc.calculateNormals(modifiedPositions, indices));\n\n            // generate delta positions and normals - as morph targets store delta between base position / normal and modified position / normal\n            for (i = 0; i < modifiedNormals.length; i++) {\n                modifiedPositions[i] -= positions[i];\n                modifiedNormals[i] -= normals[i];\n            }\n\n            // create a morph target\n            // @ts-ignore engine-tsd\n            return new pc.MorphTarget({\n                deltaPositions: modifiedPositions,\n                deltaNormals: modifiedNormals\n            });\n        };\n\n        const createMorphInstance = function (x: number, y: number, z: number) {\n            // create the base mesh - a sphere, with higher amount of vertices / triangles\n            const mesh = pc.createSphere(app.graphicsDevice, { latitudeBands: 200, longitudeBands: 200 });\n\n            // obtain base mesh vertex / index data\n            const srcPositions: number[] = [];\n            const srcNormals: number[] = [];\n            const indices: number[] = [];\n            mesh.getPositions(srcPositions);\n            mesh.getNormals(srcNormals);\n            mesh.getIndices(indices);\n\n            // build 3 targets by expanding a part of sphere along 3 planes, specified by the normal\n            const targets = [];\n            targets.push(createMorphTarget(srcPositions, srcNormals, indices, 1, 0, 0));\n            targets.push(createMorphTarget(srcPositions, srcNormals, indices, 0, 1, 0));\n            targets.push(createMorphTarget(srcPositions, srcNormals, indices, 0, 0, 1));\n\n            // create a morph using these 3 targets\n            mesh.morph = new pc.Morph(targets, app.graphicsDevice);\n\n            // Create the mesh instance\n            const material = new pc.StandardMaterial();\n            const meshInstance = new pc.MeshInstance(mesh, material);\n\n            // add morph instance - this is where currently set weights are stored\n            const morphInstance = new pc.MorphInstance(mesh.morph);\n            meshInstance.morphInstance = morphInstance;\n\n            // Create Entity and add it to the scene\n            const entity = new pc.Entity();\n            entity.setLocalPosition(x, y, z);\n            app.root.addChild(entity);\n\n            // Add a render component with meshInstance\n            entity.addComponent('render', {\n                material: material,\n                meshInstances: [meshInstance]\n            });\n\n            return morphInstance;\n        };\n\n        // create 3 morph instances\n        const morphInstances: pc.MorphInstance[] = [];\n        for (let k = 0; k < 3; k++) {\n            morphInstances.push(createMorphInstance(Math.random() * 6 - 3, Math.random() * 6 - 3, Math.random() * 6 - 3));\n        }\n\n        // update function called once per frame\n        let time = 0;\n        app.on(\"update\", function (dt) {\n            time += dt;\n\n            for (let m = 0; m < morphInstances.length; m++) {\n                // modify weights of all 3 morph targets along some sin curve with different frequency\n                morphInstances[m].setWeight(0, Math.abs(Math.sin(time + m)));\n                morphInstances[m].setWeight(1, Math.abs(Math.sin(time * 0.3 + m)));\n                morphInstances[m].setWeight(2, Math.abs(Math.sin(time * 0.7 + m)));\n            }\n\n            // orbit camera around\n            camera.setLocalPosition(16 * Math.sin(time * 0.2), 4, 16 * Math.cos(time * 0.2));\n            camera.lookAt(pc.Vec3.ZERO);\n\n            // debug display the morph target textures blended together\n            if (morphInstances[0].texturePositions) {\n                // @ts-ignore\n                app.drawTexture(-0.7, -0.7, 0.4, 0.4, morphInstances[0].texturePositions);\n            }\n\n            if (morphInstances[0].textureNormals) {\n                // @ts-ignore\n                app.drawTexture(0.7, -0.7, 0.4, 0.4, morphInstances[0].textureNormals);\n            }\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // Create an entity with a directional light component\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\",\n        });\n\n        app.root.addChild(light);\n        light.setLocalEulerAngles(45, 30, 0);\n\n        // Create an entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.1, 0.1, 0.1),\n        });\n\n        app.root.addChild(camera);\n\n        // helper function to return the shortest distance from point [x, y, z] to a plane defined by [a, b, c] normal\n        const shortestDistance = function (x, y, z, a, b, c) {\n            const d = Math.abs(a * x + b * y + c * z);\n            const e = Math.sqrt(a * a + b * b + c * c);\n            return d / e;\n        };\n\n        // helper function that creates a morph target from original positions, normals and indices, and a plane normal [nx, ny, nz]\n        const createMorphTarget = function (\n            positions,\n            normals,\n            indices,\n            nx,\n            ny,\n            nz\n        ) {\n            // modify vertices to separate array\n            const modifiedPositions = new Float32Array(positions.length);\n            let dist, i, displacement;\n            const limit = 0.2;\n            for (i = 0; i < positions.length; i += 3) {\n                // distance of the point to the specified plane\n                dist = shortestDistance(\n                    positions[i],\n                    positions[i + 1],\n                    positions[i + 2],\n                    nx,\n                    ny,\n                    nz\n                );\n\n                // modify distance to displacement amount - displace nearby points more than distant points\n                displacement = pc.math.smoothstep(0, limit, dist);\n                displacement = 1 - displacement;\n\n                // generate new position by extruding vertex along normal by displacement\n                modifiedPositions[i] = positions[i] + normals[i] * displacement;\n                modifiedPositions[i + 1] =\n                    positions[i + 1] + normals[i + 1] * displacement;\n                modifiedPositions[i + 2] =\n                    positions[i + 2] + normals[i + 2] * displacement;\n            }\n\n            // generate normals based on modified positions and indices\n            // @ts-ignore engine-tsd\n            const modifiedNormals = new Float32Array(\n                pc.calculateNormals(modifiedPositions, indices)\n            );\n\n            // generate delta positions and normals - as morph targets store delta between base position / normal and modified position / normal\n            for (i = 0; i < modifiedNormals.length; i++) {\n                modifiedPositions[i] -= positions[i];\n                modifiedNormals[i] -= normals[i];\n            }\n\n            // create a morph target\n            // @ts-ignore engine-tsd\n            return new pc.MorphTarget({\n                deltaPositions: modifiedPositions,\n                deltaNormals: modifiedNormals,\n            });\n        };\n\n        const createMorphInstance = function (x, y, z) {\n            // create the base mesh - a sphere, with higher amount of vertices / triangles\n            const mesh = pc.createSphere(app.graphicsDevice, {\n                latitudeBands: 200,\n                longitudeBands: 200,\n            });\n\n            // obtain base mesh vertex / index data\n            const srcPositions = [];\n            const srcNormals = [];\n            const indices = [];\n            mesh.getPositions(srcPositions);\n            mesh.getNormals(srcNormals);\n            mesh.getIndices(indices);\n\n            // build 3 targets by expanding a part of sphere along 3 planes, specified by the normal\n            const targets = [];\n            targets.push(\n                createMorphTarget(srcPositions, srcNormals, indices, 1, 0, 0)\n            );\n            targets.push(\n                createMorphTarget(srcPositions, srcNormals, indices, 0, 1, 0)\n            );\n            targets.push(\n                createMorphTarget(srcPositions, srcNormals, indices, 0, 0, 1)\n            );\n\n            // create a morph using these 3 targets\n            mesh.morph = new pc.Morph(targets, app.graphicsDevice);\n\n            // Create the mesh instance\n            const material = new pc.StandardMaterial();\n            const meshInstance = new pc.MeshInstance(mesh, material);\n\n            // add morph instance - this is where currently set weights are stored\n            const morphInstance = new pc.MorphInstance(mesh.morph);\n            meshInstance.morphInstance = morphInstance;\n\n            // Create Entity and add it to the scene\n            const entity = new pc.Entity();\n            entity.setLocalPosition(x, y, z);\n            app.root.addChild(entity);\n\n            // Add a render component with meshInstance\n            entity.addComponent(\"render\", {\n                material: material,\n                meshInstances: [meshInstance],\n            });\n\n            return morphInstance;\n        };\n\n        // create 3 morph instances\n        const morphInstances = [];\n        for (let k = 0; k < 3; k++) {\n            morphInstances.push(\n                createMorphInstance(\n                    Math.random() * 6 - 3,\n                    Math.random() * 6 - 3,\n                    Math.random() * 6 - 3\n                )\n            );\n        }\n\n        // update function called once per frame\n        let time = 0;\n        app.on(\"update\", function (dt) {\n            time += dt;\n\n            for (let m = 0; m < morphInstances.length; m++) {\n                // modify weights of all 3 morph targets along some sin curve with different frequency\n                morphInstances[m].setWeight(0, Math.abs(Math.sin(time + m)));\n                morphInstances[m].setWeight(\n                    1,\n                    Math.abs(Math.sin(time * 0.3 + m))\n                );\n                morphInstances[m].setWeight(\n                    2,\n                    Math.abs(Math.sin(time * 0.7 + m))\n                );\n            }\n\n            // orbit camera around\n            camera.setLocalPosition(\n                16 * Math.sin(time * 0.2),\n                4,\n                16 * Math.cos(time * 0.2)\n            );\n            camera.lookAt(pc.Vec3.ZERO);\n\n            // debug display the morph target textures blended together\n            if (morphInstances[0].texturePositions) {\n                // @ts-ignore\n                app.drawTexture(\n                    -0.7,\n                    -0.7,\n                    0.4,\n                    0.4,\n                    morphInstances[0].texturePositions\n                );\n            }\n\n            if (morphInstances[0].textureNormals) {\n                // @ts-ignore\n                app.drawTexture(\n                    0.7,\n                    -0.7,\n                    0.4,\n                    0.4,\n                    morphInstances[0].textureNormals\n                );\n            }\n        });\n    });\n}\n","nameSlug":"mesh-morph","categorySlug":"graphics"},"model-asset":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.ModelComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // create an entity with render assets\n            const entity = assets.statue.resource.instantiateModelEntity({\n                castShadows: true\n            });\n\n            app.root.addChild(entity);\n\n            // clone a small version of the entity\n            const clone = entity.clone();\n            clone.setLocalScale(0.2, 0.2, 0.2);\n            clone.setLocalPosition(-4, 12, 0);\n            app.root.addChild(clone);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5)\n            });\n            camera.translate(0, 7, 24);\n            app.root.addChild(camera);\n\n            // Create an Entity with a omni light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(1, 1, 1),\n                range: 100,\n                castShadows: true\n            });\n            light.translate(5, 0, 15);\n            app.root.addChild(light);\n\n            app.on(\"update\", function (dt) {\n                if (entity) {\n                    entity.rotate(0, 10 * dt, 0);\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.ModelComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // create an entity with render assets\n            const entity = assets.statue.resource.instantiateModelEntity({\n                castShadows: true,\n            });\n\n            app.root.addChild(entity);\n\n            // clone a small version of the entity\n            const clone = entity.clone();\n            clone.setLocalScale(0.2, 0.2, 0.2);\n            clone.setLocalPosition(-4, 12, 0);\n            app.root.addChild(clone);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n            });\n\n            camera.translate(0, 7, 24);\n            app.root.addChild(camera);\n\n            // Create an Entity with a omni light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(1, 1, 1),\n                range: 100,\n                castShadows: true,\n            });\n\n            light.translate(5, 0, 15);\n            app.root.addChild(light);\n\n            app.on(\"update\", function (dt) {\n                if (entity) {\n                    entity.rotate(0, 10 * dt, 0);\n                }\n            });\n        });\n    });\n}\n","nameSlug":"model-asset","categorySlug":"graphics"},"model-outline":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'outline': new pc.Asset('outline', 'script', { url: '/static/scripts/posteffects/posteffect-outline.js' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.ScriptHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // helper function to create a primitive with shape type, position, scale, color and layer\n            function createPrimitive(primitiveType: string, position: number | pc.Vec3, scale: number | pc.Vec3, color: pc.Color, layer: number[]) {\n                // create material of specified color\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                material.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent('render', {\n                    type: primitiveType,\n                    layers: layer,\n                    material: material\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // create texture and render target for rendering into, including depth buffer\n            function createRenderTarget() {\n                const texture = new pc.Texture(app.graphicsDevice, {\n                    name: 'OutlineObjects',\n                    width: app.graphicsDevice.width,\n                    height: app.graphicsDevice.height,\n                    format: pc.PIXELFORMAT_RGBA8,\n                    mipmaps: false,\n                    minFilter: pc.FILTER_LINEAR,\n                    magFilter: pc.FILTER_LINEAR\n                });\n                return new pc.RenderTarget({\n                    colorBuffer: texture,\n                    depth: true\n                });\n            }\n\n            let renderTarget = createRenderTarget();\n\n            // create a layer for rendering to texture, and add it to the beginning of layers to render into it first\n            const outlineLayer = new pc.Layer({ name: \"OutlineLayer\" });\n            app.scene.layers.insert(outlineLayer, 0);\n\n            // get world layer\n            const worldLayer = app.scene.layers.getLayerByName(\"World\");\n\n            // create ground plane and 3 primitives, visible in both layers\n            createPrimitive(\"plane\", new pc.Vec3(0, 0, 0), new pc.Vec3(20, 20, 20), new pc.Color(0.3, 0.5, 0.3), [worldLayer.id]);\n            createPrimitive(\"sphere\", new pc.Vec3(-2, 1, 0), new pc.Vec3(2, 2, 2), new pc.Color(1, 0, 0), [worldLayer.id]);\n            createPrimitive(\"box\", new pc.Vec3(2, 1, 0), new pc.Vec3(2, 2, 2), new pc.Color(1, 1, 0), [worldLayer.id, outlineLayer.id]);\n            createPrimitive(\"cone\", new pc.Vec3(0, 1, -2), new pc.Vec3(2, 2, 2), new pc.Color(0, 1, 1), [worldLayer.id]);\n\n            // Create main camera, which renders entities in world layer\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.2, 0.4),\n                layers: [worldLayer.id]\n            });\n            camera.translate(0, 20, 25);\n            camera.lookAt(pc.Vec3.ZERO);\n\n            // Create outline camera, which renders entities in outline layer into the render target\n            const outlineCamera = new pc.Entity();\n            outlineCamera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.0, 0.0, 0.0, 0.0),\n                layers: [outlineLayer.id],\n                renderTarget: renderTarget\n            });\n            app.root.addChild(outlineCamera);\n\n            // @ts-ignore engine-tsd\n            const outline = new OutlineEffect(app.graphicsDevice, 3);\n            outline.color = new pc.Color(0, 0.5, 1, 1);\n            outline.texture = renderTarget.colorBuffer;\n            camera.camera.postEffects.addEffect(outline);\n\n            app.root.addChild(camera);\n\n            // Create an Entity with a omni light component and add it to both layers\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(1, 1, 1),\n                range: 20,\n                castShadows: true,\n                shadowBias: 0.05,\n                normalOffsetBias: 0.03,\n                layers: [worldLayer.id]\n            });\n            light.translate(0, 2, 5);\n            app.root.addChild(light);\n\n            // handle canvas resize\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n\n                // re-create the render target for the outline camera\n                renderTarget.colorBuffer.destroy();\n                renderTarget.destroy();\n                renderTarget = createRenderTarget();\n                outlineCamera.camera.renderTarget = renderTarget;\n                outline.texture = renderTarget.colorBuffer;\n            });\n\n            // update things each frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // rotate the camera around the objects\n                camera.setLocalPosition(12 * Math.sin(time), 5, 12 * Math.cos(time));\n                camera.lookAt(pc.Vec3.ZERO);\n\n                // outline camera needs to match the main camera\n                outlineCamera.setLocalPosition(camera.getLocalPosition());\n                outlineCamera.setLocalRotation(camera.getLocalRotation());\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        outline: new pc.Asset(\"outline\", \"script\", {\n            url: \"/static/scripts/posteffects/posteffect-outline.js\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.ScriptHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // helper function to create a primitive with shape type, position, scale, color and layer\n            function createPrimitive(\n                primitiveType,\n                position,\n                scale,\n                color,\n                layer\n            ) {\n                // create material of specified color\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                material.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent(\"render\", {\n                    type: primitiveType,\n                    layers: layer,\n                    material: material,\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // create texture and render target for rendering into, including depth buffer\n            function createRenderTarget() {\n                const texture = new pc.Texture(app.graphicsDevice, {\n                    name: \"OutlineObjects\",\n                    width: app.graphicsDevice.width,\n                    height: app.graphicsDevice.height,\n                    format: pc.PIXELFORMAT_RGBA8,\n                    mipmaps: false,\n                    minFilter: pc.FILTER_LINEAR,\n                    magFilter: pc.FILTER_LINEAR,\n                });\n\n                return new pc.RenderTarget({\n                    colorBuffer: texture,\n                    depth: true,\n                });\n            }\n\n            let renderTarget = createRenderTarget();\n\n            // create a layer for rendering to texture, and add it to the beginning of layers to render into it first\n            const outlineLayer = new pc.Layer({ name: \"OutlineLayer\" });\n            app.scene.layers.insert(outlineLayer, 0);\n\n            // get world layer\n            const worldLayer = app.scene.layers.getLayerByName(\"World\");\n\n            // create ground plane and 3 primitives, visible in both layers\n            createPrimitive(\n                \"plane\",\n                new pc.Vec3(0, 0, 0),\n                new pc.Vec3(20, 20, 20),\n                new pc.Color(0.3, 0.5, 0.3),\n                [worldLayer.id]\n            );\n            createPrimitive(\n                \"sphere\",\n                new pc.Vec3(-2, 1, 0),\n                new pc.Vec3(2, 2, 2),\n                new pc.Color(1, 0, 0),\n                [worldLayer.id]\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(2, 1, 0),\n                new pc.Vec3(2, 2, 2),\n                new pc.Color(1, 1, 0),\n                [worldLayer.id, outlineLayer.id]\n            );\n            createPrimitive(\n                \"cone\",\n                new pc.Vec3(0, 1, -2),\n                new pc.Vec3(2, 2, 2),\n                new pc.Color(0, 1, 1),\n                [worldLayer.id]\n            );\n\n            // Create main camera, which renders entities in world layer\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.2, 0.4),\n                layers: [worldLayer.id],\n            });\n\n            camera.translate(0, 20, 25);\n            camera.lookAt(pc.Vec3.ZERO);\n\n            // Create outline camera, which renders entities in outline layer into the render target\n            const outlineCamera = new pc.Entity();\n            outlineCamera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.0, 0.0, 0.0, 0.0),\n                layers: [outlineLayer.id],\n                renderTarget: renderTarget,\n            });\n\n            app.root.addChild(outlineCamera);\n\n            // @ts-ignore engine-tsd\n            const outline = new OutlineEffect(app.graphicsDevice, 3);\n            outline.color = new pc.Color(0, 0.5, 1, 1);\n            outline.texture = renderTarget.colorBuffer;\n            camera.camera.postEffects.addEffect(outline);\n\n            app.root.addChild(camera);\n\n            // Create an Entity with a omni light component and add it to both layers\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(1, 1, 1),\n                range: 20,\n                castShadows: true,\n                shadowBias: 0.05,\n                normalOffsetBias: 0.03,\n                layers: [worldLayer.id],\n            });\n\n            light.translate(0, 2, 5);\n            app.root.addChild(light);\n\n            // handle canvas resize\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n\n                // re-create the render target for the outline camera\n                renderTarget.colorBuffer.destroy();\n                renderTarget.destroy();\n                renderTarget = createRenderTarget();\n                outlineCamera.camera.renderTarget = renderTarget;\n                outline.texture = renderTarget.colorBuffer;\n            });\n\n            // update things each frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // rotate the camera around the objects\n                camera.setLocalPosition(\n                    12 * Math.sin(time),\n                    5,\n                    12 * Math.cos(time)\n                );\n                camera.lookAt(pc.Vec3.ZERO);\n\n                // outline camera needs to match the main camera\n                outlineCamera.setLocalPosition(camera.getLocalPosition());\n                outlineCamera.setLocalRotation(camera.getLocalRotation());\n            });\n        });\n    });\n}\n","nameSlug":"model-outline","categorySlug":"graphics"},"model-textured-box":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'clouds': new pc.Asset('clouds', 'texture', { url: '/static/assets/textures/clouds.jpg' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // material with the diffuse texture\n            const material = new pc.StandardMaterial();\n            material.diffuseMap = assets.clouds.resource;\n            material.update();\n\n            // Create a Entity with a Box model component\n            const box = new pc.Entity();\n            box.addComponent(\"render\", {\n                type: \"box\",\n                material: material\n            });\n\n            // Create an Entity with a omni light component and a sphere model component.\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(1, 0, 0),\n                radius: 10\n            });\n            light.addComponent(\"render\", {\n                type: \"sphere\"\n            });\n            // Scale the sphere down to 0.1m\n            light.setLocalScale(0.1, 0.1, 0.1);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5)\n            });\n\n            // Add the new Entities to the hierarchy\n            app.root.addChild(box);\n            app.root.addChild(light);\n            app.root.addChild(camera);\n\n            // Move the camera 10m along the z-axis\n            camera.translate(0, 0, 10);\n\n            // Set an update function on the app's update event\n            let angle = 0;\n            app.on(\"update\", function (dt) {\n                angle += dt;\n                if (angle > 360) {\n                    angle = 0;\n                }\n\n                // Move the light in a circle\n                light.setLocalPosition(3 * Math.sin(angle), 0, 3 * Math.cos(angle));\n\n                // Rotate the box\n                box.setEulerAngles(angle * 2, angle * 4, angle * 8);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        clouds: new pc.Asset(\"clouds\", \"texture\", {\n            url: \"/static/assets/textures/clouds.jpg\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // material with the diffuse texture\n            const material = new pc.StandardMaterial();\n            material.diffuseMap = assets.clouds.resource;\n            material.update();\n\n            // Create a Entity with a Box model component\n            const box = new pc.Entity();\n            box.addComponent(\"render\", {\n                type: \"box\",\n                material: material,\n            });\n\n            // Create an Entity with a omni light component and a sphere model component.\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(1, 0, 0),\n                radius: 10,\n            });\n\n            light.addComponent(\"render\", {\n                type: \"sphere\",\n            });\n\n            // Scale the sphere down to 0.1m\n            light.setLocalScale(0.1, 0.1, 0.1);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n            });\n\n            // Add the new Entities to the hierarchy\n            app.root.addChild(box);\n            app.root.addChild(light);\n            app.root.addChild(camera);\n\n            // Move the camera 10m along the z-axis\n            camera.translate(0, 0, 10);\n\n            // Set an update function on the app's update event\n            let angle = 0;\n            app.on(\"update\", function (dt) {\n                angle += dt;\n                if (angle > 360) {\n                    angle = 0;\n                }\n\n                // Move the light in a circle\n                light.setLocalPosition(\n                    3 * Math.sin(angle),\n                    0,\n                    3 * Math.cos(angle)\n                );\n\n                // Rotate the box\n                box.setEulerAngles(angle * 2, angle * 4, angle * 8);\n            });\n        });\n    });\n}\n","nameSlug":"model-textured-box","categorySlug":"graphics"},"multi-view":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // set up and load draco module, as the glb we load is draco compressed\n    pc.WasmModule.setConfig('DracoDecoderModule', {\n        glueUrl: '/static/lib/draco/draco.wasm.js',\n        wasmUrl: '/static/lib/draco/draco.wasm.wasm',\n        fallbackUrl: '/static/lib/draco/draco.js'\n    });\n\n    pc.WasmModule.getInstance('DracoDecoderModule', demo);\n\n    function demo() {\n        const assets = {\n            'script': new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' }),\n            'helipad': new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n            'board': new pc.Asset('statue', 'container', { url: '/static/assets/models/chess-board.glb' })\n        };\n\n        const gfxOptions = {\n            deviceTypes: [deviceType],\n            glslangUrl: '/static/lib/glslang/glslang.js',\n            twgslUrl: '/static/lib/twgsl/twgsl.js'\n        };\n\n        pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n            createOptions.mouse = new pc.Mouse(document.body);\n            createOptions.touch = new pc.TouchDevice(document.body);\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.RenderComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.LightComponentSystem,\n                // @ts-ignore\n                pc.ScriptComponentSystem\n            ];\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.ContainerHandler,\n                // @ts-ignore\n                pc.ScriptHandler\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n            assetListLoader.load(() => {\n\n                app.start();\n\n                // get the instance of the chess board and set up with render component\n                const boardEntity = assets.board.resource.instantiateRenderEntity({\n                    castShadows: true,\n                    receiveShadows: true\n                });\n                app.root.addChild(boardEntity);\n\n                // Create left camera\n                const cameraLeft = new pc.Entity('LeftCamera');\n                cameraLeft.addComponent(\"camera\", {\n                    farClip: 500,\n                    rect: new pc.Vec4(0, 0, 0.5, 0.5)\n                });\n                app.root.addChild(cameraLeft);\n\n                // Create right orthographic camera\n                const cameraRight = new pc.Entity('RightCamera');\n                cameraRight.addComponent(\"camera\", {\n                    farClip: 500,\n                    rect: new pc.Vec4(0.5, 0, 0.5, 0.5),\n                    projection: pc.PROJECTION_ORTHOGRAPHIC,\n                    orthoHeight: 150\n                });\n                cameraRight.translate(0, 150, 0);\n                cameraRight.lookAt(pc.Vec3.ZERO, pc.Vec3.RIGHT);\n                app.root.addChild(cameraRight);\n\n                // Create top camera\n                const cameraTop = new pc.Entity('TopCamera');\n                cameraTop.addComponent(\"camera\", {\n                    farClip: 500,\n                    rect: new pc.Vec4(0, 0.5, 1, 0.5)\n                });\n                cameraTop.translate(-100, 75, 100);\n                cameraTop.lookAt(0, 7, 0);\n                app.root.addChild(cameraTop);\n\n                // add orbit camera script with a mouse and a touch support\n                cameraTop.addComponent(\"script\");\n                cameraTop.script.create(\"orbitCamera\", {\n                    attributes: {\n                        inertiaFactor: 0.2,\n                        focusEntity: app.root,\n                        distanceMax: 300,\n                        frameOnStart: false\n                    }\n                });\n                cameraTop.script.create(\"orbitCameraInputMouse\");\n                cameraTop.script.create(\"orbitCameraInputTouch\");\n\n                // Create a single directional light which casts shadows\n                const dirLight = new pc.Entity();\n                dirLight.addComponent(\"light\", {\n                    type: \"directional\",\n                    color: pc.Color.WHITE,\n                    intensity: 2,\n                    range: 500,\n                    shadowDistance: 500,\n                    castShadows: true,\n                    shadowBias: 0.2,\n                    normalOffsetBias: 0.05\n                });\n                app.root.addChild(dirLight);\n                dirLight.setLocalEulerAngles(45, 0, 30);\n\n                // set skybox - this DDS file was 'prefiltered' in the PlayCanvas Editor and then downloaded.\n                app.scene.envAtlas = assets.helipad.resource;\n                app.scene.toneMapping = pc.TONEMAP_ACES;\n                app.scene.skyboxMip = 1;\n\n                // update function called once per frame\n                let time = 0;\n                app.on(\"update\", function (dt) {\n                    time += dt;\n\n                    // orbit camera left around\n                    cameraLeft.setLocalPosition(100 * Math.sin(time * 0.2), 35, 100 * Math.cos(time * 0.2));\n                    cameraLeft.lookAt(pc.Vec3.ZERO);\n\n                    // zoom in and out the orthographic camera\n                    cameraRight.camera.orthoHeight = 90 + Math.sin(time * 0.3) * 60;\n                });\n            });\n        });\n    }\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // set up and load draco module, as the glb we load is draco compressed\n    pc.WasmModule.setConfig(\"DracoDecoderModule\", {\n        glueUrl: \"/static/lib/draco/draco.wasm.js\",\n        wasmUrl: \"/static/lib/draco/draco.wasm.wasm\",\n        fallbackUrl: \"/static/lib/draco/draco.js\",\n    });\n\n    pc.WasmModule.getInstance(\"DracoDecoderModule\", demo);\n\n    function demo() {\n        const assets = {\n            script: new pc.Asset(\"script\", \"script\", {\n                url: \"/static/scripts/camera/orbit-camera.js\",\n            }),\n            helipad: new pc.Asset(\n                \"helipad-env-atlas\",\n                \"texture\",\n                { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n                { type: pc.TEXTURETYPE_RGBP }\n            ),\n            board: new pc.Asset(\"statue\", \"container\", {\n                url: \"/static/assets/models/chess-board.glb\",\n            }),\n        };\n\n        const gfxOptions = {\n            deviceTypes: [deviceType],\n            glslangUrl: \"/static/lib/glslang/glslang.js\",\n            twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n        };\n\n        pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n            createOptions.mouse = new pc.Mouse(document.body);\n            createOptions.touch = new pc.TouchDevice(document.body);\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.RenderComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.LightComponentSystem,\n                // @ts-ignore\n                pc.ScriptComponentSystem,\n            ];\n\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.ContainerHandler,\n                // @ts-ignore\n                pc.ScriptHandler,\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assetListLoader = new pc.AssetListLoader(\n                Object.values(assets),\n                app.assets\n            );\n            assetListLoader.load(() => {\n                app.start();\n\n                // get the instance of the chess board and set up with render component\n                const boardEntity =\n                    assets.board.resource.instantiateRenderEntity({\n                        castShadows: true,\n                        receiveShadows: true,\n                    });\n\n                app.root.addChild(boardEntity);\n\n                // Create left camera\n                const cameraLeft = new pc.Entity(\"LeftCamera\");\n                cameraLeft.addComponent(\"camera\", {\n                    farClip: 500,\n                    rect: new pc.Vec4(0, 0, 0.5, 0.5),\n                });\n\n                app.root.addChild(cameraLeft);\n\n                // Create right orthographic camera\n                const cameraRight = new pc.Entity(\"RightCamera\");\n                cameraRight.addComponent(\"camera\", {\n                    farClip: 500,\n                    rect: new pc.Vec4(0.5, 0, 0.5, 0.5),\n                    projection: pc.PROJECTION_ORTHOGRAPHIC,\n                    orthoHeight: 150,\n                });\n\n                cameraRight.translate(0, 150, 0);\n                cameraRight.lookAt(pc.Vec3.ZERO, pc.Vec3.RIGHT);\n                app.root.addChild(cameraRight);\n\n                // Create top camera\n                const cameraTop = new pc.Entity(\"TopCamera\");\n                cameraTop.addComponent(\"camera\", {\n                    farClip: 500,\n                    rect: new pc.Vec4(0, 0.5, 1, 0.5),\n                });\n\n                cameraTop.translate(-100, 75, 100);\n                cameraTop.lookAt(0, 7, 0);\n                app.root.addChild(cameraTop);\n\n                // add orbit camera script with a mouse and a touch support\n                cameraTop.addComponent(\"script\");\n                cameraTop.script.create(\"orbitCamera\", {\n                    attributes: {\n                        inertiaFactor: 0.2,\n                        focusEntity: app.root,\n                        distanceMax: 300,\n                        frameOnStart: false,\n                    },\n                });\n\n                cameraTop.script.create(\"orbitCameraInputMouse\");\n                cameraTop.script.create(\"orbitCameraInputTouch\");\n\n                // Create a single directional light which casts shadows\n                const dirLight = new pc.Entity();\n                dirLight.addComponent(\"light\", {\n                    type: \"directional\",\n                    color: pc.Color.WHITE,\n                    intensity: 2,\n                    range: 500,\n                    shadowDistance: 500,\n                    castShadows: true,\n                    shadowBias: 0.2,\n                    normalOffsetBias: 0.05,\n                });\n\n                app.root.addChild(dirLight);\n                dirLight.setLocalEulerAngles(45, 0, 30);\n\n                // set skybox - this DDS file was 'prefiltered' in the PlayCanvas Editor and then downloaded.\n                app.scene.envAtlas = assets.helipad.resource;\n                app.scene.toneMapping = pc.TONEMAP_ACES;\n                app.scene.skyboxMip = 1;\n\n                // update function called once per frame\n                let time = 0;\n                app.on(\"update\", function (dt) {\n                    time += dt;\n\n                    // orbit camera left around\n                    cameraLeft.setLocalPosition(\n                        100 * Math.sin(time * 0.2),\n                        35,\n                        100 * Math.cos(time * 0.2)\n                    );\n                    cameraLeft.lookAt(pc.Vec3.ZERO);\n\n                    // zoom in and out the orthographic camera\n                    cameraRight.camera.orthoHeight =\n                        90 + Math.sin(time * 0.3) * 60;\n                });\n            });\n        });\n    }\n}\n","nameSlug":"multi-view","categorySlug":"graphics"},"paint-mesh":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, files: { 'shader.vert': string, 'shader.frag': string }): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas);\n\n    // load the textures\n    const assets = {\n        'helipad': new pc.Asset('helipad.dds', 'cubemap', { url: '/static/assets/cubemaps/helipad.dds' }, { type: pc.TEXTURETYPE_RGBM }),\n        'color': new pc.Asset('color', 'texture', { url: '/static/assets/textures/seaside-rocks01-color.jpg' }),\n        'decal': new pc.Asset('color', 'texture', { url: '/static/assets/textures/heart.png' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.scene.setSkybox(assets.helipad.resources);\n        app.scene.toneMapping = pc.TONEMAP_ACES;\n        app.scene.skyboxIntensity = 1;\n        app.scene.skyboxMip = 2;\n\n        // helper function to create high polygon version of a sphere and sets up an entity to allow it to be added to the scene\n        const createHighQualitySphere = function (material: pc.Material, layer: number[]) {\n\n            // Create Entity and add it to the scene\n            const entity = new pc.Entity(\"HighResSphere\");\n            app.root.addChild(entity);\n\n            // create hight resolution sphere\n            const mesh = pc.createSphere(app.graphicsDevice, { latitudeBands: 200, longitudeBands: 200 });\n\n            // Add a render component with the mesh\n            entity.addComponent('render', {\n                type: 'asset',\n                layers: layer,\n                meshInstances: [new pc.MeshInstance(mesh, material)]\n            });\n\n            return entity;\n        };\n\n        // We render decals to a texture, so create a render target for it. Note that the texture needs\n        // to be of renderable format here, and so it cannot be compressed.\n        const texture = assets.color.resource;\n        const renderTarget = new pc.RenderTarget({\n            colorBuffer: texture,\n            depth: false\n        });\n\n        // create a layer for rendering to decals\n        const decalLayer = new pc.Layer({ name: \"decalLayer\" });\n        app.scene.layers.insert(decalLayer, 0);\n\n        // Create a camera, which renders decals using a decalLayer, and renders before the main camera\n        // Note that this camera does not need its position set, as it's only used to trigger\n        // the rendering, but the camera matrix is not used for the rendering (our custom shader\n        // does not need it).\n        const decalCamera = new pc.Entity('DecalCamera');\n        decalCamera.addComponent(\"camera\", {\n            clearColorBuffer: false,\n            layers: [decalLayer.id],\n            renderTarget: renderTarget,\n            priority: -1\n        });\n        app.root.addChild(decalCamera);\n\n        // Create main camera, which renders entities in world layer - this is where we show mesh with decals\n        const camera = new pc.Entity('MainCamera');\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.1, 0.1, 0.1, 1)\n        });\n        camera.translate(20, 10, 40);\n        camera.lookAt(new pc.Vec3(0, -7, 0));\n        app.root.addChild(camera);\n\n        // material used on the sphere\n        const material = new pc.StandardMaterial();\n        material.diffuseMap = texture;\n        material.gloss = 0.6;\n        material.metalness = 0.4;\n        material.useMetalness = true;\n        material.update();\n\n        // sphere with the texture\n        const worldLayer = app.scene.layers.getLayerByName(\"World\");\n        const meshEntity = createHighQualitySphere(material, [worldLayer.id]);\n        meshEntity.setLocalScale(15, 15, 15);\n\n        // Create the shader definition and shader from the vertex and fragment shaders\n        const shaderDefinition = {\n            attributes: {\n                aPosition: pc.SEMANTIC_POSITION,\n                aUv0: pc.SEMANTIC_TEXCOORD0\n            },\n            vshader: files['shader.vert'],\n            fshader: files['shader.frag']\n        };\n        const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n        // Create a decal material with the new shader\n        const decalMaterial = new pc.Material();\n        decalMaterial.cull = pc.CULLFACE_NONE;\n        decalMaterial.shader = shader;\n        decalMaterial.blendType = pc.BLEND_NORMAL;\n        decalMaterial.setParameter('uDecalMap', assets.decal.resource);\n\n        // To render into uv space of the mesh, we need to render the mesh using our custom shader into\n        // the texture. In order to do this, we creates a new entity, containing the same mesh instances,\n        // but using our custom shader. We make it a child of the original entity, to use its transform.\n        const meshInstances = meshEntity.render.meshInstances.map((srcMeshInstance: pc.MeshInstance) => {\n            return new pc.MeshInstance(srcMeshInstance.mesh, decalMaterial);\n        });\n        const cloneEntity = new pc.Entity('cloneEntity');\n        cloneEntity.addComponent('render', {\n            meshInstances: meshInstances,\n            layers: [decalLayer.id],\n            castShadows: false,\n            receiveShadows: false\n        });\n        meshEntity.addChild(cloneEntity);\n\n        // Create an entity with a directional light component\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\",\n            intensity: 3\n        });\n        app.root.addChild(light);\n        light.setLocalEulerAngles(45, 90, 0);\n\n        // update things each frame\n        let time = 0;\n        let decalTime = 0;\n        const decalFrequency = 0.5;\n        app.on(\"update\", function (dt) {\n            time += dt * 0.7;\n\n            // a decal projection box is an orthographic projection from some position. We calculate position\n            // here to be in an orbit around the sphere. Draw a line showing the projection point and direction.\n            const decalProjectionPos = new pc.Vec3(8 * Math.cos(time), 8 * Math.cos(time * 0.3), 8 * Math.sin(time));\n            app.drawLine(decalProjectionPos, pc.Vec3.ZERO, pc.Color.WHITE);\n\n            // render recal every half a second\n            decalTime += dt;\n            if (decalTime > decalFrequency) {\n                decalTime -= decalFrequency;\n\n                // enable decal camera, which renders the decal\n                decalCamera.enabled = true;\n\n                // construct a view matrix, looking from the decal position to the center of the sphere\n                const viewMatrix = new pc.Mat4().setLookAt(decalProjectionPos, pc.Vec3.ZERO, pc.Vec3.UP);\n                viewMatrix.invert();\n\n                // ortographics projection matrix - this defines the size of the decal, but also its depth range (0..5)\n                const projMatrix = new pc.Mat4().setOrtho(-1, 1, -1, 1, 0, 5);\n\n                // final matrix is a combination of view and projection matrix. Make it available to the shader.\n                const viewProj = new pc.Mat4();\n                viewProj.mul2(projMatrix, viewMatrix);\n                decalMaterial.setParameter('matrix_decal_viewProj', viewProj.data);\n            } else {\n                // otherwise the decal camera is disabled\n                decalCamera.enabled = false;\n            }\n\n            // draw the texture we render decals to for demonstration purposes\n            // @ts-ignore engine-tsd\n            app.drawTexture(0, -0.6, 1.4, 0.6, texture);\n\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, files) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas);\n\n    // load the textures\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad.dds\",\n            \"cubemap\",\n            { url: \"/static/assets/cubemaps/helipad.dds\" },\n            { type: pc.TEXTURETYPE_RGBM }\n        ),\n        color: new pc.Asset(\"color\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-color.jpg\",\n        }),\n        decal: new pc.Asset(\"color\", \"texture\", {\n            url: \"/static/assets/textures/heart.png\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.scene.setSkybox(assets.helipad.resources);\n        app.scene.toneMapping = pc.TONEMAP_ACES;\n        app.scene.skyboxIntensity = 1;\n        app.scene.skyboxMip = 2;\n\n        // helper function to create high polygon version of a sphere and sets up an entity to allow it to be added to the scene\n        const createHighQualitySphere = function (material, layer) {\n            // Create Entity and add it to the scene\n            const entity = new pc.Entity(\"HighResSphere\");\n            app.root.addChild(entity);\n\n            // create hight resolution sphere\n            const mesh = pc.createSphere(app.graphicsDevice, {\n                latitudeBands: 200,\n                longitudeBands: 200,\n            });\n\n            // Add a render component with the mesh\n            entity.addComponent(\"render\", {\n                type: \"asset\",\n                layers: layer,\n                meshInstances: [new pc.MeshInstance(mesh, material)],\n            });\n\n            return entity;\n        };\n\n        // We render decals to a texture, so create a render target for it. Note that the texture needs\n        // to be of renderable format here, and so it cannot be compressed.\n        const texture = assets.color.resource;\n        const renderTarget = new pc.RenderTarget({\n            colorBuffer: texture,\n            depth: false,\n        });\n\n        // create a layer for rendering to decals\n        const decalLayer = new pc.Layer({ name: \"decalLayer\" });\n        app.scene.layers.insert(decalLayer, 0);\n\n        // Create a camera, which renders decals using a decalLayer, and renders before the main camera\n        // Note that this camera does not need its position set, as it's only used to trigger\n        // the rendering, but the camera matrix is not used for the rendering (our custom shader\n        // does not need it).\n        const decalCamera = new pc.Entity(\"DecalCamera\");\n        decalCamera.addComponent(\"camera\", {\n            clearColorBuffer: false,\n            layers: [decalLayer.id],\n            renderTarget: renderTarget,\n            priority: -1,\n        });\n\n        app.root.addChild(decalCamera);\n\n        // Create main camera, which renders entities in world layer - this is where we show mesh with decals\n        const camera = new pc.Entity(\"MainCamera\");\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.1, 0.1, 0.1, 1),\n        });\n\n        camera.translate(20, 10, 40);\n        camera.lookAt(new pc.Vec3(0, -7, 0));\n        app.root.addChild(camera);\n\n        // material used on the sphere\n        const material = new pc.StandardMaterial();\n        material.diffuseMap = texture;\n        material.gloss = 0.6;\n        material.metalness = 0.4;\n        material.useMetalness = true;\n        material.update();\n\n        // sphere with the texture\n        const worldLayer = app.scene.layers.getLayerByName(\"World\");\n        const meshEntity = createHighQualitySphere(material, [worldLayer.id]);\n        meshEntity.setLocalScale(15, 15, 15);\n\n        // Create the shader definition and shader from the vertex and fragment shaders\n        const shaderDefinition = {\n            attributes: {\n                aPosition: pc.SEMANTIC_POSITION,\n                aUv0: pc.SEMANTIC_TEXCOORD0,\n            },\n\n            vshader: files[\"shader.vert\"],\n            fshader: files[\"shader.frag\"],\n        };\n\n        const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n        // Create a decal material with the new shader\n        const decalMaterial = new pc.Material();\n        decalMaterial.cull = pc.CULLFACE_NONE;\n        decalMaterial.shader = shader;\n        decalMaterial.blendType = pc.BLEND_NORMAL;\n        decalMaterial.setParameter(\"uDecalMap\", assets.decal.resource);\n\n        // To render into uv space of the mesh, we need to render the mesh using our custom shader into\n        // the texture. In order to do this, we creates a new entity, containing the same mesh instances,\n        // but using our custom shader. We make it a child of the original entity, to use its transform.\n        const meshInstances = meshEntity.render.meshInstances.map(\n            (srcMeshInstance) => {\n                return new pc.MeshInstance(srcMeshInstance.mesh, decalMaterial);\n            }\n        );\n        const cloneEntity = new pc.Entity(\"cloneEntity\");\n        cloneEntity.addComponent(\"render\", {\n            meshInstances: meshInstances,\n            layers: [decalLayer.id],\n            castShadows: false,\n            receiveShadows: false,\n        });\n\n        meshEntity.addChild(cloneEntity);\n\n        // Create an entity with a directional light component\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\",\n            intensity: 3,\n        });\n\n        app.root.addChild(light);\n        light.setLocalEulerAngles(45, 90, 0);\n\n        // update things each frame\n        let time = 0;\n        let decalTime = 0;\n        const decalFrequency = 0.5;\n        app.on(\"update\", function (dt) {\n            time += dt * 0.7;\n\n            // a decal projection box is an orthographic projection from some position. We calculate position\n            // here to be in an orbit around the sphere. Draw a line showing the projection point and direction.\n            const decalProjectionPos = new pc.Vec3(\n                8 * Math.cos(time),\n                8 * Math.cos(time * 0.3),\n                8 * Math.sin(time)\n            );\n            app.drawLine(decalProjectionPos, pc.Vec3.ZERO, pc.Color.WHITE);\n\n            // render recal every half a second\n            decalTime += dt;\n            if (decalTime > decalFrequency) {\n                decalTime -= decalFrequency;\n\n                // enable decal camera, which renders the decal\n                decalCamera.enabled = true;\n\n                // construct a view matrix, looking from the decal position to the center of the sphere\n                const viewMatrix = new pc.Mat4().setLookAt(\n                    decalProjectionPos,\n                    pc.Vec3.ZERO,\n                    pc.Vec3.UP\n                );\n                viewMatrix.invert();\n\n                // ortographics projection matrix - this defines the size of the decal, but also its depth range (0..5)\n                const projMatrix = new pc.Mat4().setOrtho(-1, 1, -1, 1, 0, 5);\n\n                // final matrix is a combination of view and projection matrix. Make it available to the shader.\n                const viewProj = new pc.Mat4();\n                viewProj.mul2(projMatrix, viewMatrix);\n                decalMaterial.setParameter(\n                    \"matrix_decal_viewProj\",\n                    viewProj.data\n                );\n            } else {\n                // otherwise the decal camera is disabled\n                decalCamera.enabled = false;\n            }\n\n            // draw the texture we render decals to for demonstration purposes\n            // @ts-ignore engine-tsd\n            app.drawTexture(0, -0.6, 1.4, 0.6, texture);\n        });\n    });\n}\n","nameSlug":"paint-mesh","categorySlug":"graphics","files":{"shader.vert":"\n            // Attributes per vertex: position and uv\n            attribute vec4 aPosition;\n            attribute vec2 aUv0;\n        \n            // model matrix of the mesh\n            uniform mat4 matrix_model;\n\n            // decal view-projection matrix (orthographic)\n            uniform mat4 matrix_decal_viewProj;\n\n            // decal projected position to fragment program\n            varying vec4 decalPos;\n\n            void main(void)\n            {\n                // We render in texture space, so a position of this fragment is its uv-coordinates.\n                // Changes the range of uv coordinates from 0..1 to projection space -1 to 1.\n                gl_Position = vec4(aUv0.x * 2.0 - 1.0, aUv0.y * 2.0 - 1.0, 0, 1.0);\n\n                // transform the vertex position to world space and then to decal space, and pass it\n                // to the fragment shader to sample the decal texture\n                vec4 worldPos = matrix_model * aPosition;\n                decalPos = matrix_decal_viewProj * worldPos;\n            }","shader.frag":"\n            precision lowp float;\n            varying vec4 decalPos;\n            uniform sampler2D uDecalMap;\n\n            void main(void)\n            {\n                // decal space position from -1..1 range, to texture space range 0..1\n                vec4 p = decalPos * 0.5 + 0.5;\n \n                // if the position is outside out 0..1 projection box, ignore the pixel\n                if (p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0 || p.z < 0.0 || p.z > 1.0)\n                    discard;\n\n                gl_FragColor = texture2D(uDecalMap, p.xy);\n            }"}},"painter":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.ParticleSystemComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ScriptHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // helper function to create a primitive with shape type, position, scale, color and layer\n        function createPrimitive(primitiveType: string, position: number | pc.Vec3, scale: number | pc.Vec3, layer: number[], material: pc.StandardMaterial) {\n\n            // create primitive\n            const primitive = new pc.Entity();\n            primitive.addComponent('render', {\n                type: primitiveType,\n                layers: layer,\n                material: material,\n                castShadows: false,\n                receiveShadows: false\n            });\n\n            // set position and scale and add it to scene\n            primitive.setLocalPosition(position);\n            primitive.setLocalScale(scale);\n            app.root.addChild(primitive);\n\n            return primitive;\n        }\n\n        // create texture and render target for rendering into\n        const texture = new pc.Texture(app.graphicsDevice, {\n            width: 1024,\n            height: 1024,\n            format: pc.PIXELFORMAT_RGB8,\n            mipmaps: false,\n            minFilter: pc.FILTER_LINEAR,\n            magFilter: pc.FILTER_LINEAR\n        });\n        const renderTarget = new pc.RenderTarget({\n            colorBuffer: texture,\n            depth: false\n        });\n\n        // create a layer for rendering to texture, and add it to the beginning of layers to render into it first\n        const paintLayer = new pc.Layer({ name: \"paintLayer\" });\n        app.scene.layers.insert(paintLayer, 0);\n\n        // create a material we use for the paint brush - it uses emissive color to control its color, which is assigned later\n        const brushMaterial = new pc.StandardMaterial();\n        brushMaterial.emissiveTint = true;\n        brushMaterial.useLighting = false;\n        brushMaterial.update();\n\n        // we render multiple brush imprints each frame to make smooth lines, and set up pool to reuse them each frame\n        const brushes: any[] = [];\n        function getBrush() {\n            let brush: pc.Entity;\n            if (brushes.length === 0) {\n                // create new brush - use sphere primitive, but could use plane with a texture as well\n                // Note: plane would need to be rotated by -90 degrees along x-axis to face camera and be visible\n                brush = createPrimitive(\"sphere\", new pc.Vec3(2, 1, 0), new pc.Vec3(1, 1, 1), [paintLayer.id], brushMaterial);\n            } else {\n                // reuse already allocated brush\n                brush = brushes.pop();\n                brush.enabled = true;\n            }\n            return brush;\n        }\n\n        // Create orthographic camera, which renders brushes in paintLayer, and renders before the main camera\n        const paintCamera = new pc.Entity();\n        paintCamera.addComponent(\"camera\", {\n            clearColorBuffer: false,\n            projection: pc.PROJECTION_ORTHOGRAPHIC,\n            layers: [paintLayer.id],\n            renderTarget: renderTarget,\n            priority: -1\n        });\n\n        // make it look at the center of the render target, some distance away\n        paintCamera.setLocalPosition(0, 0, -10);\n        paintCamera.lookAt(pc.Vec3.ZERO);\n        app.root.addChild(paintCamera);\n\n        // Create main camera, which renders entities in world layer - this is where we show the render target on the box\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.2, 0.2, 0.2)\n        });\n        camera.translate(0, 0, 30);\n        camera.lookAt(pc.Vec3.ZERO);\n        app.root.addChild(camera);\n\n        // material used to add render target into the world\n        const material = new pc.StandardMaterial();\n        material.emissiveMap = texture;\n        material.useLighting = false;\n        material.update();\n\n        // create a box which we use to display rendered texture in the world layer\n        const worldLayer = app.scene.layers.getLayerByName(\"World\");\n        const box = createPrimitive(\"box\", new pc.Vec3(0, 0, 0), new pc.Vec3(15, 15, 15), [worldLayer.id], material);\n\n        let progress = 1;\n        let scale: number;\n        let startPos: pc.Vec3, endPos: pc.Vec3;\n        const pos = new pc.Vec3();\n        const usedBrushes: any[] = [];\n\n        // update things each frame\n        app.on(\"update\", function (dt) {\n\n            // if the last brush stroke is finished, generate new random one\n            if (progress >= 1) {\n                progress = 0;\n\n                // generate start and end position for the stroke\n                startPos = new pc.Vec3(Math.random() * 20 - 10, Math.random() * 20 - 10, 0);\n                endPos = new pc.Vec3(Math.random() * 20 - 10, Math.random() * 20 - 10, 0);\n\n                // random width (scale)\n                scale = 0.1 + Math.random();\n\n                // assign random color to the brush\n                brushMaterial.emissive = new pc.Color(Math.random(), Math.random(), Math.random());\n                brushMaterial.update();\n            }\n\n            // disable brushes from the previous frame and return them to the free pool\n            while (usedBrushes.length > 0) {\n                const brush = usedBrushes.pop();\n                brush.enabled = false;\n                brushes.push(brush);\n            }\n\n            // step along the brush line multiple times each frame to make the line smooth\n            const stepCount = 30;\n            const stepProgress = 0.005;\n\n            // in each step\n            for (let i = 0; i < stepCount; i++) {\n\n                // move position little bit\n                pos.lerp(startPos, endPos, progress);\n\n                // setup brush to be rendered this frame\n                const activeBrush = getBrush();\n                activeBrush.setLocalPosition(pos);\n                activeBrush.setLocalScale(scale, scale, scale);\n                usedBrushes.push(activeBrush);\n\n                // progress for the next step\n                progress += stepProgress;\n            }\n\n            // rotate the box in the world\n            box.rotate(5 * dt, 10 * dt, 15 * dt);\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.ParticleSystemComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // helper function to create a primitive with shape type, position, scale, color and layer\n        function createPrimitive(\n            primitiveType,\n            position,\n            scale,\n            layer,\n            material\n        ) {\n            // create primitive\n            const primitive = new pc.Entity();\n            primitive.addComponent(\"render\", {\n                type: primitiveType,\n                layers: layer,\n                material: material,\n                castShadows: false,\n                receiveShadows: false,\n            });\n\n            // set position and scale and add it to scene\n            primitive.setLocalPosition(position);\n            primitive.setLocalScale(scale);\n            app.root.addChild(primitive);\n\n            return primitive;\n        }\n\n        // create texture and render target for rendering into\n        const texture = new pc.Texture(app.graphicsDevice, {\n            width: 1024,\n            height: 1024,\n            format: pc.PIXELFORMAT_RGB8,\n            mipmaps: false,\n            minFilter: pc.FILTER_LINEAR,\n            magFilter: pc.FILTER_LINEAR,\n        });\n\n        const renderTarget = new pc.RenderTarget({\n            colorBuffer: texture,\n            depth: false,\n        });\n\n        // create a layer for rendering to texture, and add it to the beginning of layers to render into it first\n        const paintLayer = new pc.Layer({ name: \"paintLayer\" });\n        app.scene.layers.insert(paintLayer, 0);\n\n        // create a material we use for the paint brush - it uses emissive color to control its color, which is assigned later\n        const brushMaterial = new pc.StandardMaterial();\n        brushMaterial.emissiveTint = true;\n        brushMaterial.useLighting = false;\n        brushMaterial.update();\n\n        // we render multiple brush imprints each frame to make smooth lines, and set up pool to reuse them each frame\n        const brushes = [];\n        function getBrush() {\n            let brush;\n            if (brushes.length === 0) {\n                // create new brush - use sphere primitive, but could use plane with a texture as well\n                // Note: plane would need to be rotated by -90 degrees along x-axis to face camera and be visible\n                brush = createPrimitive(\n                    \"sphere\",\n                    new pc.Vec3(2, 1, 0),\n                    new pc.Vec3(1, 1, 1),\n                    [paintLayer.id],\n                    brushMaterial\n                );\n            } else {\n                // reuse already allocated brush\n                brush = brushes.pop();\n                brush.enabled = true;\n            }\n            return brush;\n        }\n\n        // Create orthographic camera, which renders brushes in paintLayer, and renders before the main camera\n        const paintCamera = new pc.Entity();\n        paintCamera.addComponent(\"camera\", {\n            clearColorBuffer: false,\n            projection: pc.PROJECTION_ORTHOGRAPHIC,\n            layers: [paintLayer.id],\n            renderTarget: renderTarget,\n            priority: -1,\n        });\n\n        // make it look at the center of the render target, some distance away\n        paintCamera.setLocalPosition(0, 0, -10);\n        paintCamera.lookAt(pc.Vec3.ZERO);\n        app.root.addChild(paintCamera);\n\n        // Create main camera, which renders entities in world layer - this is where we show the render target on the box\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.2, 0.2, 0.2),\n        });\n\n        camera.translate(0, 0, 30);\n        camera.lookAt(pc.Vec3.ZERO);\n        app.root.addChild(camera);\n\n        // material used to add render target into the world\n        const material = new pc.StandardMaterial();\n        material.emissiveMap = texture;\n        material.useLighting = false;\n        material.update();\n\n        // create a box which we use to display rendered texture in the world layer\n        const worldLayer = app.scene.layers.getLayerByName(\"World\");\n        const box = createPrimitive(\n            \"box\",\n            new pc.Vec3(0, 0, 0),\n            new pc.Vec3(15, 15, 15),\n            [worldLayer.id],\n            material\n        );\n\n        let progress = 1;\n        let scale;\n        let startPos, endPos;\n        const pos = new pc.Vec3();\n        const usedBrushes = [];\n\n        // update things each frame\n        app.on(\"update\", function (dt) {\n            // if the last brush stroke is finished, generate new random one\n            if (progress >= 1) {\n                progress = 0;\n\n                // generate start and end position for the stroke\n                startPos = new pc.Vec3(\n                    Math.random() * 20 - 10,\n                    Math.random() * 20 - 10,\n                    0\n                );\n                endPos = new pc.Vec3(\n                    Math.random() * 20 - 10,\n                    Math.random() * 20 - 10,\n                    0\n                );\n\n                // random width (scale)\n                scale = 0.1 + Math.random();\n\n                // assign random color to the brush\n                brushMaterial.emissive = new pc.Color(\n                    Math.random(),\n                    Math.random(),\n                    Math.random()\n                );\n                brushMaterial.update();\n            }\n\n            // disable brushes from the previous frame and return them to the free pool\n            while (usedBrushes.length > 0) {\n                const brush = usedBrushes.pop();\n                brush.enabled = false;\n                brushes.push(brush);\n            }\n\n            // step along the brush line multiple times each frame to make the line smooth\n            const stepCount = 30;\n            const stepProgress = 0.005;\n\n            // in each step\n            for (let i = 0; i < stepCount; i++) {\n                // move position little bit\n                pos.lerp(startPos, endPos, progress);\n\n                // setup brush to be rendered this frame\n                const activeBrush = getBrush();\n                activeBrush.setLocalPosition(pos);\n                activeBrush.setLocalScale(scale, scale, scale);\n                usedBrushes.push(activeBrush);\n\n                // progress for the next step\n                progress += stepProgress;\n            }\n\n            // rotate the box in the world\n            box.rotate(5 * dt, 10 * dt, 15 * dt);\n        });\n    });\n}\n","nameSlug":"painter","categorySlug":"graphics"},"particles-anim-index":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        'particlesNumbers': new pc.Asset('particlesNumbers', 'texture', { url: '/static/assets/textures/particles-numbers.png' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // Create an Entity with a camera component\n        const cameraEntity = new pc.Entity();\n        cameraEntity.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.75, 0.75, 0.75)\n        });\n        cameraEntity.rotateLocal(0, 0, 0);\n        cameraEntity.translateLocal(0, 0, 20);\n\n        // Create a directional light\n        const lightDirEntity = new pc.Entity();\n        lightDirEntity.addComponent(\"light\", {\n            type: \"directional\",\n            color: new pc.Color(1, 1, 1),\n            intensity: 1\n        });\n        lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n        // Create a screen to display the particle texture\n        const screenEntity = new pc.Entity();\n        screenEntity.addComponent(\"screen\", { resolution: new pc.Vec2(640, 480), screenSpace: true });\n        screenEntity.screen.scaleMode = \"blend\";\n        screenEntity.screen.referenceResolution = new pc.Vec2(1280, 720);\n\n        // Create a panel to display the full particle texture\n        const panel = new pc.Entity();\n        screenEntity.addChild(panel);\n\n        // Add Entities into the scene hierarchy\n        app.root.addChild(cameraEntity);\n        app.root.addChild(lightDirEntity);\n        app.root.addChild(screenEntity);\n\n        // Create entity for first particle system\n        const particleEntity1 = new pc.Entity();\n        app.root.addChild(particleEntity1);\n        particleEntity1.setLocalPosition(-3, 3, 0);\n\n        // Create entity for second particle system\n        const particleEntity2 = new pc.Entity();\n        app.root.addChild(particleEntity2);\n        particleEntity2.setLocalPosition(3, 3, 0);\n\n        // Create entity for third particle system\n        const particleEntity3 = new pc.Entity();\n        app.root.addChild(particleEntity3);\n        particleEntity3.setLocalPosition(-3, -3, 0);\n\n        // Create entity for fourth particle system\n        const particleEntity4 = new pc.Entity();\n        app.root.addChild(particleEntity4);\n        particleEntity4.setLocalPosition(3, -3, 0);\n\n        // when the texture is loaded add particlesystem components to particle entities\n\n        // gradually make sparks bigger\n        const scaleCurve = new pc.Curve(\n            [0, 0, 1, 1]\n        );\n\n        const particleSystemConfiguration = {\n            numParticles: 8,\n            lifetime: 4,\n            rate: 0.5,\n            colorMap: assets.particlesNumbers.resource,\n            initialVelocity: 0.25,\n            emitterShape: pc.EMITTERSHAPE_SPHERE,\n            emitterRadius: 0.1,\n            animLoop: true,\n            animTilesX: 4,\n            animTilesY: 4,\n            animSpeed: 1,\n            autoPlay: true,\n            scaleGraph: scaleCurve\n        };\n\n        let options;\n\n        options = Object.assign(particleSystemConfiguration, {\n            // states that each animation in the sprite sheet has 4 frames\n            animNumFrames: 4,\n            // set the animation index of the first particle system to 0\n            animIndex: 0\n        });\n        particleEntity1.addComponent(\"particlesystem\", options);\n\n        options = Object.assign(particleSystemConfiguration, {\n            // states that each animation in the sprite sheet has 4 frames\n            animNumFrames: 4,\n            // set the animation index of the second particle system to 1\n            animIndex: 1\n        });\n        particleEntity2.addComponent(\"particlesystem\", options);\n\n        options = Object.assign(particleSystemConfiguration, {\n            // states that each animation in the sprite sheet has 4 frames\n            animNumFrames: 4,\n            // set the animation index of the third particle system to 2\n            animIndex: 2\n        });\n        particleEntity3.addComponent(\"particlesystem\", options);\n\n        options = Object.assign(particleSystemConfiguration, {\n            // states that each animation in the sprite sheet has 4 frames\n            animNumFrames: 4,\n            // set the animation index of the fourth particle system to 3\n            animIndex: 3\n        });\n        particleEntity4.addComponent(\"particlesystem\", options);\n\n        // add the full particle texture to the panel\n        panel.addComponent('element', {\n            anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n            pivot: new pc.Vec2(0.5, 0.5),\n            width: 100,\n            height: 100,\n            type: \"image\",\n            textureAsset: assets.particlesNumbers\n        });\n\n        app.start();\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        particlesNumbers: new pc.Asset(\"particlesNumbers\", \"texture\", {\n            url: \"/static/assets/textures/particles-numbers.png\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // Create an Entity with a camera component\n        const cameraEntity = new pc.Entity();\n        cameraEntity.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.75, 0.75, 0.75),\n        });\n\n        cameraEntity.rotateLocal(0, 0, 0);\n        cameraEntity.translateLocal(0, 0, 20);\n\n        // Create a directional light\n        const lightDirEntity = new pc.Entity();\n        lightDirEntity.addComponent(\"light\", {\n            type: \"directional\",\n            color: new pc.Color(1, 1, 1),\n            intensity: 1,\n        });\n\n        lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n        // Create a screen to display the particle texture\n        const screenEntity = new pc.Entity();\n        screenEntity.addComponent(\"screen\", {\n            resolution: new pc.Vec2(640, 480),\n            screenSpace: true,\n        });\n        screenEntity.screen.scaleMode = \"blend\";\n        screenEntity.screen.referenceResolution = new pc.Vec2(1280, 720);\n\n        // Create a panel to display the full particle texture\n        const panel = new pc.Entity();\n        screenEntity.addChild(panel);\n\n        // Add Entities into the scene hierarchy\n        app.root.addChild(cameraEntity);\n        app.root.addChild(lightDirEntity);\n        app.root.addChild(screenEntity);\n\n        // Create entity for first particle system\n        const particleEntity1 = new pc.Entity();\n        app.root.addChild(particleEntity1);\n        particleEntity1.setLocalPosition(-3, 3, 0);\n\n        // Create entity for second particle system\n        const particleEntity2 = new pc.Entity();\n        app.root.addChild(particleEntity2);\n        particleEntity2.setLocalPosition(3, 3, 0);\n\n        // Create entity for third particle system\n        const particleEntity3 = new pc.Entity();\n        app.root.addChild(particleEntity3);\n        particleEntity3.setLocalPosition(-3, -3, 0);\n\n        // Create entity for fourth particle system\n        const particleEntity4 = new pc.Entity();\n        app.root.addChild(particleEntity4);\n        particleEntity4.setLocalPosition(3, -3, 0);\n\n        // when the texture is loaded add particlesystem components to particle entities\n\n        // gradually make sparks bigger\n        const scaleCurve = new pc.Curve([0, 0, 1, 1]);\n\n        const particleSystemConfiguration = {\n            numParticles: 8,\n            lifetime: 4,\n            rate: 0.5,\n            colorMap: assets.particlesNumbers.resource,\n            initialVelocity: 0.25,\n            emitterShape: pc.EMITTERSHAPE_SPHERE,\n            emitterRadius: 0.1,\n            animLoop: true,\n            animTilesX: 4,\n            animTilesY: 4,\n            animSpeed: 1,\n            autoPlay: true,\n            scaleGraph: scaleCurve,\n        };\n\n        let options;\n\n        options = Object.assign(particleSystemConfiguration, {\n            // states that each animation in the sprite sheet has 4 frames\n            animNumFrames: 4,\n            // set the animation index of the first particle system to 0\n            animIndex: 0,\n        });\n\n        particleEntity1.addComponent(\"particlesystem\", options);\n\n        options = Object.assign(particleSystemConfiguration, {\n            // states that each animation in the sprite sheet has 4 frames\n            animNumFrames: 4,\n            // set the animation index of the second particle system to 1\n            animIndex: 1,\n        });\n\n        particleEntity2.addComponent(\"particlesystem\", options);\n\n        options = Object.assign(particleSystemConfiguration, {\n            // states that each animation in the sprite sheet has 4 frames\n            animNumFrames: 4,\n            // set the animation index of the third particle system to 2\n            animIndex: 2,\n        });\n\n        particleEntity3.addComponent(\"particlesystem\", options);\n\n        options = Object.assign(particleSystemConfiguration, {\n            // states that each animation in the sprite sheet has 4 frames\n            animNumFrames: 4,\n            // set the animation index of the fourth particle system to 3\n            animIndex: 3,\n        });\n\n        particleEntity4.addComponent(\"particlesystem\", options);\n\n        // add the full particle texture to the panel\n        panel.addComponent(\"element\", {\n            anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n            pivot: new pc.Vec2(0.5, 0.5),\n            width: 100,\n            height: 100,\n            type: \"image\",\n            textureAsset: assets.particlesNumbers,\n        });\n\n        app.start();\n    });\n}\n","nameSlug":"particles-anim-index","categorySlug":"graphics"},"particles-random-sprites":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n\n    const assets = {\n        'particlesCoinsTexture': new pc.Asset('particlesCoinsTexture', 'texture', { url: '/static/assets/textures/particles-coins.png' }),\n        'particlesBonusTexture': new pc.Asset('particlesBonusTexture', 'texture', { url: '/static/assets/textures/particles-bonus.png' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n        // Create an Entity with a camera component\n        const cameraEntity = new pc.Entity();\n        cameraEntity.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.23, 0.5, 0.75)\n        });\n        cameraEntity.rotateLocal(0, 0, 0);\n        cameraEntity.translateLocal(0, 0, 20);\n\n        // Create a directional light\n        const lightDirEntity = new pc.Entity();\n        lightDirEntity.addComponent(\"light\", {\n            type: \"directional\",\n            color: new pc.Color(1, 1, 1),\n            intensity: 1\n        });\n        lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n        // Create a screen to display the particle systems textures\n        const screenEntity = new pc.Entity();\n        screenEntity.addComponent(\"screen\", { resolution: new pc.Vec2(640, 480), screenSpace: true });\n        screenEntity.screen.scaleMode = \"blend\";\n        screenEntity.screen.referenceResolution = new pc.Vec2(1280, 720);\n\n        // Create a panel to display the full particle textures\n        const panel = new pc.Entity();\n        screenEntity.addChild(panel);\n        const panel2 = new pc.Entity();\n        screenEntity.addChild(panel2);\n\n        // Add Entities into the scene hierarchy\n        app.root.addChild(cameraEntity);\n        app.root.addChild(lightDirEntity);\n        app.root.addChild(screenEntity);\n\n        // Create entity for first particle system\n        const particleEntity1 = new pc.Entity();\n        app.root.addChild(particleEntity1);\n        particleEntity1.setLocalPosition(-3, 3, 0);\n\n        // Create entity for second particle system\n        const particleEntity2 = new pc.Entity();\n        app.root.addChild(particleEntity2);\n        particleEntity2.setLocalPosition(3, 3, 0);\n\n        // gradually make particles bigger\n        const scaleCurve = new pc.Curve(\n            [0, 0.1, 1, 0.5]\n        );\n\n        // make particles fade in and out\n        const alphaCurve = new pc.Curve(\n            [0, 0, 0.5, 1, 1, 0]\n        );\n\n        const particleSystemConfiguration = function (asset: any, animTilesX: any, animTilesY: any) {\n            return {\n                numParticles: 32,\n                lifetime: 2,\n                rate: 0.2,\n                colorMap: asset.resource,\n                initialVelocity: 0.125,\n                emitterShape: pc.EMITTERSHAPE_SPHERE,\n                emitterRadius: 2.0,\n                animLoop: true,\n                animTilesX: animTilesX,\n                animTilesY: animTilesY,\n                animSpeed: 4,\n                autoPlay: true,\n                alphaGraph: alphaCurve,\n                scaleGraph: scaleCurve\n            };\n        };\n\n        // add particlesystem component to particle entity\n        particleEntity1.addComponent(\"particlesystem\", Object.assign(particleSystemConfiguration(assets.particlesCoinsTexture, 4, 6), {\n            // set the number of animations in the sprite sheet to 4\n            animNumAnimations: 4,\n            // set the number of frames in each animation to 6\n            animNumFrames: 6,\n            // set the particle system to randomly select a different animation for each particle\n            randomizeAnimIndex: true\n        }));\n\n        // display the full coin texture to the left of the panel\n        panel.addComponent('element', {\n            anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n            pivot: new pc.Vec2(1.75, 1.0),\n            width: 150,\n            height: 225,\n            type: \"image\",\n            textureAsset: assets.particlesCoinsTexture\n        });\n\n        // add particlesystem component to particle entity\n        particleEntity2.addComponent(\"particlesystem\", Object.assign(particleSystemConfiguration(assets.particlesBonusTexture, 4, 2), {\n            // set the number of animations in the sprite sheet to 7\n            animNumAnimations: 7,\n            // set the number of frames in each animation to 1\n            animNumFrames: 1,\n            // set the particle system to randomly select a different animation for each particle\n            randomizeAnimIndex: true\n        }));\n\n        // display the full bonus item texture to the left of the panel\n        panel2.addComponent('element', {\n            anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n            pivot: new pc.Vec2(-0.5, 1.0),\n            width: 200,\n            height: 100,\n            type: \"image\",\n            textureAsset: assets.particlesBonusTexture\n        });\n\n        app.start();\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    const assets = {\n        particlesCoinsTexture: new pc.Asset(\n            \"particlesCoinsTexture\",\n            \"texture\",\n            { url: \"/static/assets/textures/particles-coins.png\" }\n        ),\n        particlesBonusTexture: new pc.Asset(\n            \"particlesBonusTexture\",\n            \"texture\",\n            { url: \"/static/assets/textures/particles-bonus.png\" }\n        ),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        // Create an Entity with a camera component\n        const cameraEntity = new pc.Entity();\n        cameraEntity.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.23, 0.5, 0.75),\n        });\n\n        cameraEntity.rotateLocal(0, 0, 0);\n        cameraEntity.translateLocal(0, 0, 20);\n\n        // Create a directional light\n        const lightDirEntity = new pc.Entity();\n        lightDirEntity.addComponent(\"light\", {\n            type: \"directional\",\n            color: new pc.Color(1, 1, 1),\n            intensity: 1,\n        });\n\n        lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n        // Create a screen to display the particle systems textures\n        const screenEntity = new pc.Entity();\n        screenEntity.addComponent(\"screen\", {\n            resolution: new pc.Vec2(640, 480),\n            screenSpace: true,\n        });\n        screenEntity.screen.scaleMode = \"blend\";\n        screenEntity.screen.referenceResolution = new pc.Vec2(1280, 720);\n\n        // Create a panel to display the full particle textures\n        const panel = new pc.Entity();\n        screenEntity.addChild(panel);\n        const panel2 = new pc.Entity();\n        screenEntity.addChild(panel2);\n\n        // Add Entities into the scene hierarchy\n        app.root.addChild(cameraEntity);\n        app.root.addChild(lightDirEntity);\n        app.root.addChild(screenEntity);\n\n        // Create entity for first particle system\n        const particleEntity1 = new pc.Entity();\n        app.root.addChild(particleEntity1);\n        particleEntity1.setLocalPosition(-3, 3, 0);\n\n        // Create entity for second particle system\n        const particleEntity2 = new pc.Entity();\n        app.root.addChild(particleEntity2);\n        particleEntity2.setLocalPosition(3, 3, 0);\n\n        // gradually make particles bigger\n        const scaleCurve = new pc.Curve([0, 0.1, 1, 0.5]);\n\n        // make particles fade in and out\n        const alphaCurve = new pc.Curve([0, 0, 0.5, 1, 1, 0]);\n\n        const particleSystemConfiguration = function (\n            asset,\n            animTilesX,\n            animTilesY\n        ) {\n            return {\n                numParticles: 32,\n                lifetime: 2,\n                rate: 0.2,\n                colorMap: asset.resource,\n                initialVelocity: 0.125,\n                emitterShape: pc.EMITTERSHAPE_SPHERE,\n                emitterRadius: 2.0,\n                animLoop: true,\n                animTilesX: animTilesX,\n                animTilesY: animTilesY,\n                animSpeed: 4,\n                autoPlay: true,\n                alphaGraph: alphaCurve,\n                scaleGraph: scaleCurve,\n            };\n        };\n\n        // add particlesystem component to particle entity\n        particleEntity1.addComponent(\n            \"particlesystem\",\n            Object.assign(\n                particleSystemConfiguration(assets.particlesCoinsTexture, 4, 6),\n                {\n                    // set the number of animations in the sprite sheet to 4\n                    animNumAnimations: 4,\n                    // set the number of frames in each animation to 6\n                    animNumFrames: 6,\n                    // set the particle system to randomly select a different animation for each particle\n                    randomizeAnimIndex: true,\n                }\n            )\n        );\n\n        // display the full coin texture to the left of the panel\n        panel.addComponent(\"element\", {\n            anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n            pivot: new pc.Vec2(1.75, 1.0),\n            width: 150,\n            height: 225,\n            type: \"image\",\n            textureAsset: assets.particlesCoinsTexture,\n        });\n\n        // add particlesystem component to particle entity\n        particleEntity2.addComponent(\n            \"particlesystem\",\n            Object.assign(\n                particleSystemConfiguration(assets.particlesBonusTexture, 4, 2),\n                {\n                    // set the number of animations in the sprite sheet to 7\n                    animNumAnimations: 7,\n                    // set the number of frames in each animation to 1\n                    animNumFrames: 1,\n                    // set the particle system to randomly select a different animation for each particle\n                    randomizeAnimIndex: true,\n                }\n            )\n        );\n\n        // display the full bonus item texture to the left of the panel\n        panel2.addComponent(\"element\", {\n            anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n            pivot: new pc.Vec2(-0.5, 1.0),\n            width: 200,\n            height: 100,\n            type: \"image\",\n            textureAsset: assets.particlesBonusTexture,\n        });\n\n        app.start();\n    });\n}\n","nameSlug":"particles-random-sprites","categorySlug":"graphics"},"particles-snow":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        'snowflake': new pc.Asset('snowflake', 'texture', { url: '/static/assets/textures/snowflake.png' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // Create an Entity with a camera component\n        const cameraEntity = new pc.Entity();\n        cameraEntity.addComponent(\"camera\", {\n            clearColor: new pc.Color(0, 0, 0)\n        });\n        cameraEntity.rotateLocal(0, 0, 0);\n        cameraEntity.translateLocal(0, 0, 10);\n\n        // Create a directional light\n        const lightDirEntity = new pc.Entity();\n        lightDirEntity.addComponent(\"light\", {\n            type: \"directional\",\n            color: new pc.Color(1, 1, 1),\n            intensity: 1\n        });\n        lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n        // Add Entities into the scene hierarchy\n        app.root.addChild(cameraEntity);\n        app.root.addChild(lightDirEntity);\n\n\n        // set up random downwards velocity from -0.4 to -0.7\n        const velocityCurve = new pc.CurveSet([\n            [0, 0],     // x\n            [0, -0.7],  // y\n            [0, 0]      // z\n        ]);\n        const velocityCurve2 = new pc.CurveSet([\n            [0, 0],   // x\n            [0, -0.4], // y\n            [0, 0]    // z\n        ]);\n\n        // set up random rotation speed from -100 to 100 degrees per second\n        const rotCurve = new pc.Curve([0, 100]);\n        const rotCurve2 = new pc.Curve([0, -100]);\n\n        // scale is constant at 0.1\n        const scaleCurve = new pc.Curve([0, 0.1]);\n\n        // Create entity for particle system\n        const entity = new pc.Entity();\n        app.root.addChild(entity);\n        entity.setLocalPosition(0, 3, 0);\n\n        // load snowflake texture\n        app.assets.loadFromUrl('/static/assets/textures/snowflake.png', 'texture', function () {\n            // when texture is loaded add particlesystem component to entity\n            entity.addComponent(\"particlesystem\", {\n                numParticles: 100,\n                lifetime: 10,\n                rate: 0.1,\n                startAngle: 360,\n                startAngle2: -360,\n                emitterExtents: new pc.Vec3(5, 0, 0),\n                velocityGraph: velocityCurve,\n                velocityGraph2: velocityCurve2,\n                scaleGraph: scaleCurve,\n                rotationSpeedGraph: rotCurve,\n                rotationSpeedGraph2: rotCurve2,\n                colorMap: assets.snowflake.resource\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        snowflake: new pc.Asset(\"snowflake\", \"texture\", {\n            url: \"/static/assets/textures/snowflake.png\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // Create an Entity with a camera component\n        const cameraEntity = new pc.Entity();\n        cameraEntity.addComponent(\"camera\", {\n            clearColor: new pc.Color(0, 0, 0),\n        });\n\n        cameraEntity.rotateLocal(0, 0, 0);\n        cameraEntity.translateLocal(0, 0, 10);\n\n        // Create a directional light\n        const lightDirEntity = new pc.Entity();\n        lightDirEntity.addComponent(\"light\", {\n            type: \"directional\",\n            color: new pc.Color(1, 1, 1),\n            intensity: 1,\n        });\n\n        lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n        // Add Entities into the scene hierarchy\n        app.root.addChild(cameraEntity);\n        app.root.addChild(lightDirEntity);\n\n        // set up random downwards velocity from -0.4 to -0.7\n        const velocityCurve = new pc.CurveSet([\n            [0, 0], // x\n            [0, -0.7], // y\n            [0, 0], // z\n        ]);\n        const velocityCurve2 = new pc.CurveSet([\n            [0, 0], // x\n            [0, -0.4], // y\n            [0, 0], // z\n        ]);\n\n        // set up random rotation speed from -100 to 100 degrees per second\n        const rotCurve = new pc.Curve([0, 100]);\n        const rotCurve2 = new pc.Curve([0, -100]);\n\n        // scale is constant at 0.1\n        const scaleCurve = new pc.Curve([0, 0.1]);\n\n        // Create entity for particle system\n        const entity = new pc.Entity();\n        app.root.addChild(entity);\n        entity.setLocalPosition(0, 3, 0);\n\n        // load snowflake texture\n        app.assets.loadFromUrl(\n            \"/static/assets/textures/snowflake.png\",\n            \"texture\",\n            function () {\n                // when texture is loaded add particlesystem component to entity\n                entity.addComponent(\"particlesystem\", {\n                    numParticles: 100,\n                    lifetime: 10,\n                    rate: 0.1,\n                    startAngle: 360,\n                    startAngle2: -360,\n                    emitterExtents: new pc.Vec3(5, 0, 0),\n                    velocityGraph: velocityCurve,\n                    velocityGraph2: velocityCurve2,\n                    scaleGraph: scaleCurve,\n                    rotationSpeedGraph: rotCurve,\n                    rotationSpeedGraph2: rotCurve2,\n                    colorMap: assets.snowflake.resource,\n                });\n            }\n        );\n    });\n}\n","nameSlug":"particles-snow","categorySlug":"graphics"},"particles-spark":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        'spark': new pc.Asset('spark', 'texture', { url: '/static/assets/textures/spark.png' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // Create an Entity with a camera component\n        const cameraEntity = new pc.Entity();\n        cameraEntity.addComponent(\"camera\", {\n            clearColor: new pc.Color(0, 0, 0.05)\n        });\n        cameraEntity.rotateLocal(0, 0, 0);\n        cameraEntity.translateLocal(0, 0, 10);\n\n        // Create a directional light\n        const lightDirEntity = new pc.Entity();\n        lightDirEntity.addComponent(\"light\", {\n            type: \"directional\",\n            color: new pc.Color(1, 1, 1),\n            intensity: 1\n        });\n        lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n        // Add Entities into the scene hierarchy\n        app.root.addChild(cameraEntity);\n        app.root.addChild(lightDirEntity);\n\n\n        // Offset position\n        const localPosCurve = new pc.CurveSet([\n            [0, 0, 1, 4],\n            [0, 0, 1, 3],\n            [0, 0, 1, 0]\n        ]);\n        localPosCurve.type = pc.CURVE_LINEAR;\n\n        // make particles move in different directions\n        const localVelocityCurve = new pc.CurveSet([\n            [0, 0, 1, 8],\n            [0, 0, 1, 6],\n            [0, 0, 1, 0]\n        ]);\n        const localVelocityCurve2 = new pc.CurveSet([\n            [0, 0, 1, -8],\n            [0, 0, 1, -6],\n            [0, 0, 1, 0]\n        ]);\n\n        // increasing gravity\n        const worldVelocityCurve = new pc.CurveSet([\n            [0, 0],\n            [0, 0, 0.2, 6, 1, -48],\n            [0, 0]\n        ]);\n\n        // gradually make sparks bigger\n        const scaleCurve = new pc.Curve(\n            [0, 0, 0.5, 0.3, 0.8, 0.2, 1, 0.1]\n        );\n\n        // rotate sparks 360 degrees per second\n        const angleCurve = new pc.Curve(\n            [0, 360]\n        );\n\n        // color changes throughout lifetime\n        const colorCurve = new pc.CurveSet([\n            [0, 1, 0.25, 1, 0.375, 0.5, 0.5, 0],\n            [0, 0, 0.125, 0.25, 0.25, 0.5, 0.375, 0.75, 0.5, 1],\n            [0, 0, 1, 0]\n        ]);\n\n        // Create entity for particle system\n        const entity = new pc.Entity();\n        app.root.addChild(entity);\n        entity.setLocalPosition(0, 0, 0);\n\n        // when texture is loaded add particlesystem component to entity\n        entity.addComponent(\"particlesystem\", {\n            numParticles: 200,\n            lifetime: 2,\n            rate: 0.01,\n            scaleGraph: scaleCurve,\n            rotationSpeedGraph: angleCurve,\n            colorGraph: colorCurve,\n            colorMap: assets.spark.resource,\n            velocityGraph: worldVelocityCurve,\n            localVelocityGraph: localVelocityCurve,\n            localVelocityGraph2: localVelocityCurve2\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        spark: new pc.Asset(\"spark\", \"texture\", {\n            url: \"/static/assets/textures/spark.png\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // Create an Entity with a camera component\n        const cameraEntity = new pc.Entity();\n        cameraEntity.addComponent(\"camera\", {\n            clearColor: new pc.Color(0, 0, 0.05),\n        });\n\n        cameraEntity.rotateLocal(0, 0, 0);\n        cameraEntity.translateLocal(0, 0, 10);\n\n        // Create a directional light\n        const lightDirEntity = new pc.Entity();\n        lightDirEntity.addComponent(\"light\", {\n            type: \"directional\",\n            color: new pc.Color(1, 1, 1),\n            intensity: 1,\n        });\n\n        lightDirEntity.setLocalEulerAngles(45, 0, 0);\n\n        // Add Entities into the scene hierarchy\n        app.root.addChild(cameraEntity);\n        app.root.addChild(lightDirEntity);\n\n        // Offset position\n        const localPosCurve = new pc.CurveSet([\n            [0, 0, 1, 4],\n            [0, 0, 1, 3],\n            [0, 0, 1, 0],\n        ]);\n\n        localPosCurve.type = pc.CURVE_LINEAR;\n\n        // make particles move in different directions\n        const localVelocityCurve = new pc.CurveSet([\n            [0, 0, 1, 8],\n            [0, 0, 1, 6],\n            [0, 0, 1, 0],\n        ]);\n\n        const localVelocityCurve2 = new pc.CurveSet([\n            [0, 0, 1, -8],\n            [0, 0, 1, -6],\n            [0, 0, 1, 0],\n        ]);\n\n        // increasing gravity\n        const worldVelocityCurve = new pc.CurveSet([\n            [0, 0],\n            [0, 0, 0.2, 6, 1, -48],\n            [0, 0],\n        ]);\n\n        // gradually make sparks bigger\n        const scaleCurve = new pc.Curve([0, 0, 0.5, 0.3, 0.8, 0.2, 1, 0.1]);\n\n        // rotate sparks 360 degrees per second\n        const angleCurve = new pc.Curve([0, 360]);\n\n        // color changes throughout lifetime\n        const colorCurve = new pc.CurveSet([\n            [0, 1, 0.25, 1, 0.375, 0.5, 0.5, 0],\n            [0, 0, 0.125, 0.25, 0.25, 0.5, 0.375, 0.75, 0.5, 1],\n            [0, 0, 1, 0],\n        ]);\n\n        // Create entity for particle system\n        const entity = new pc.Entity();\n        app.root.addChild(entity);\n        entity.setLocalPosition(0, 0, 0);\n\n        // when texture is loaded add particlesystem component to entity\n        entity.addComponent(\"particlesystem\", {\n            numParticles: 200,\n            lifetime: 2,\n            rate: 0.01,\n            scaleGraph: scaleCurve,\n            rotationSpeedGraph: angleCurve,\n            colorGraph: colorCurve,\n            colorMap: assets.spark.resource,\n            velocityGraph: worldVelocityCurve,\n            localVelocityGraph: localVelocityCurve,\n            localVelocityGraph2: localVelocityCurve2,\n        });\n    });\n}\n","nameSlug":"particles-spark","categorySlug":"graphics"},"point-cloud-simulation":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, files: { 'shader.vert': string, 'shader.frag': string }): void {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0, 0, 0)\n    });\n\n    // Add entity into scene hierarchy\n    app.root.addChild(camera);\n\n    // allocate two buffers to store positions of particles\n    const maxNumPoints = 100000;\n    let visiblePoints = 10000;\n    const positions = new Float32Array(3 * maxNumPoints);\n    const oldPositions = new Float32Array(3 * maxNumPoints);\n\n    // generate random positions and old positions within small cube (delta between them represents velocity)\n    for (let i = 0; i < 3 * maxNumPoints; i++) {\n        positions[i] = Math.random() * 2 - 1;\n        oldPositions[i] = positions[i] + Math.random() * 0.04 - 0.01;\n    }\n\n    // helper function to update vertex of the mesh\n    function updateMesh(mesh: pc.Mesh) {\n\n        // Set current positions on mesh - this reallocates vertex buffer if more space is needed to test it.\n        // For best performance, we could preallocate enough space using mesh.Clear.\n        // Also turn off bounding box generation, as we set up large box manually\n        mesh.setPositions(positions, 3, visiblePoints);\n        mesh.update(pc.PRIMITIVE_POINTS, false);\n    }\n\n    // Create a mesh with dynamic vertex buffer (index buffer is not needed)\n    const mesh = new pc.Mesh(app.graphicsDevice);\n    mesh.clear(true);\n    updateMesh(mesh);\n\n    // set large bounding box so we don't need to update it each frame\n    mesh.aabb = new pc.BoundingBox(new pc.Vec3(0, 0, 0), new pc.Vec3(15, 15, 15));\n\n    // Create the shader from the vertex and fragment shaders\n    const shader = new pc.Shader(app.graphicsDevice, {\n        attributes: { aPosition: pc.SEMANTIC_POSITION },\n        vshader: files['shader.vert'],\n        fshader: files['shader.frag']\n    });\n\n    // Create a new material with the new shader and additive alpha blending\n    const material = new pc.Material();\n    material.shader = shader;\n    material.blendType = pc.BLEND_ADDITIVEALPHA;\n    material.depthWrite = false;\n\n    // Create the mesh instance\n    const meshInstance = new pc.MeshInstance(mesh, material);\n\n    // Create Entity to render the mesh instances using a render component\n    const entity = new pc.Entity();\n    entity.addComponent(\"render\", {\n        type: 'asset',\n        meshInstances: [meshInstance],\n        material: material,\n        castShadows: false\n    });\n    app.root.addChild(entity);\n\n    // Set an update function on the app's update event\n    let time = 0, previousTime;\n    app.on(\"update\", function (dt) {\n        previousTime = time;\n        time += dt;\n\n        // update particle positions using simple Verlet integration, and keep them inside a sphere boundary\n        let dist;\n        const pos = new pc.Vec3();\n        const old = new pc.Vec3();\n        const delta = new pc.Vec3();\n        const next = new pc.Vec3();\n        for (let i = 0; i < maxNumPoints; i++) {\n\n            // read positions from buffers\n            old.set(oldPositions[i * 3], oldPositions[i * 3 + 1], oldPositions[i * 3 + 2]);\n            pos.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);\n\n            // verlet integration to move them\n            delta.sub2(pos, old);\n            next.add2(pos, delta);\n\n            // boundary collision to keep them inside a sphere. If outside, simply move them in opposite direction\n            dist = next.length();\n            if (dist > 15)\n                next.copy(old);\n\n            // write out changed positions\n            positions[i * 3] = next.x;\n            positions[i * 3 + 1] = next.y;\n            positions[i * 3 + 2] = next.z;\n\n            oldPositions[i * 3] = pos.x;\n            oldPositions[i * 3 + 1] = pos.y;\n            oldPositions[i * 3 + 2] = pos.z;\n        }\n\n        // once a second change how many points are visible\n        if (Math.round(time) !== Math.round(previousTime))\n            visiblePoints = Math.floor(50000 + Math.random() * maxNumPoints - 50000);\n\n        // update mesh vertices\n        updateMesh(mesh);\n\n        // Rotate the camera around\n        const cameraTime = time * 0.2;\n        const cameraPos = new pc.Vec3(20 * Math.sin(cameraTime), 10, 20 * Math.cos(cameraTime));\n        camera.setLocalPosition(cameraPos);\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, files) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0, 0, 0),\n    });\n\n    // Add entity into scene hierarchy\n    app.root.addChild(camera);\n\n    // allocate two buffers to store positions of particles\n    const maxNumPoints = 100000;\n    let visiblePoints = 10000;\n    const positions = new Float32Array(3 * maxNumPoints);\n    const oldPositions = new Float32Array(3 * maxNumPoints);\n\n    // generate random positions and old positions within small cube (delta between them represents velocity)\n    for (let i = 0; i < 3 * maxNumPoints; i++) {\n        positions[i] = Math.random() * 2 - 1;\n        oldPositions[i] = positions[i] + Math.random() * 0.04 - 0.01;\n    }\n\n    // helper function to update vertex of the mesh\n    function updateMesh(mesh) {\n        // Set current positions on mesh - this reallocates vertex buffer if more space is needed to test it.\n        // For best performance, we could preallocate enough space using mesh.Clear.\n        // Also turn off bounding box generation, as we set up large box manually\n        mesh.setPositions(positions, 3, visiblePoints);\n        mesh.update(pc.PRIMITIVE_POINTS, false);\n    }\n\n    // Create a mesh with dynamic vertex buffer (index buffer is not needed)\n    const mesh = new pc.Mesh(app.graphicsDevice);\n    mesh.clear(true);\n    updateMesh(mesh);\n\n    // set large bounding box so we don't need to update it each frame\n    mesh.aabb = new pc.BoundingBox(\n        new pc.Vec3(0, 0, 0),\n        new pc.Vec3(15, 15, 15)\n    );\n\n    // Create the shader from the vertex and fragment shaders\n    const shader = new pc.Shader(app.graphicsDevice, {\n        attributes: { aPosition: pc.SEMANTIC_POSITION },\n        vshader: files[\"shader.vert\"],\n        fshader: files[\"shader.frag\"],\n    });\n\n    // Create a new material with the new shader and additive alpha blending\n    const material = new pc.Material();\n    material.shader = shader;\n    material.blendType = pc.BLEND_ADDITIVEALPHA;\n    material.depthWrite = false;\n\n    // Create the mesh instance\n    const meshInstance = new pc.MeshInstance(mesh, material);\n\n    // Create Entity to render the mesh instances using a render component\n    const entity = new pc.Entity();\n    entity.addComponent(\"render\", {\n        type: \"asset\",\n        meshInstances: [meshInstance],\n        material: material,\n        castShadows: false,\n    });\n\n    app.root.addChild(entity);\n\n    // Set an update function on the app's update event\n    let time = 0,\n        previousTime;\n    app.on(\"update\", function (dt) {\n        previousTime = time;\n        time += dt;\n\n        // update particle positions using simple Verlet integration, and keep them inside a sphere boundary\n        let dist;\n        const pos = new pc.Vec3();\n        const old = new pc.Vec3();\n        const delta = new pc.Vec3();\n        const next = new pc.Vec3();\n        for (let i = 0; i < maxNumPoints; i++) {\n            // read positions from buffers\n            old.set(\n                oldPositions[i * 3],\n                oldPositions[i * 3 + 1],\n                oldPositions[i * 3 + 2]\n            );\n            pos.set(\n                positions[i * 3],\n                positions[i * 3 + 1],\n                positions[i * 3 + 2]\n            );\n\n            // verlet integration to move them\n            delta.sub2(pos, old);\n            next.add2(pos, delta);\n\n            // boundary collision to keep them inside a sphere. If outside, simply move them in opposite direction\n            dist = next.length();\n            if (dist > 15) next.copy(old);\n\n            // write out changed positions\n            positions[i * 3] = next.x;\n            positions[i * 3 + 1] = next.y;\n            positions[i * 3 + 2] = next.z;\n\n            oldPositions[i * 3] = pos.x;\n            oldPositions[i * 3 + 1] = pos.y;\n            oldPositions[i * 3 + 2] = pos.z;\n        }\n\n        // once a second change how many points are visible\n        if (Math.round(time) !== Math.round(previousTime))\n            visiblePoints = Math.floor(\n                50000 + Math.random() * maxNumPoints - 50000\n            );\n\n        // update mesh vertices\n        updateMesh(mesh);\n\n        // Rotate the camera around\n        const cameraTime = time * 0.2;\n        const cameraPos = new pc.Vec3(\n            20 * Math.sin(cameraTime),\n            10,\n            20 * Math.cos(cameraTime)\n        );\n        camera.setLocalPosition(cameraPos);\n        camera.lookAt(pc.Vec3.ZERO);\n    });\n}\n","nameSlug":"point-cloud-simulation","categorySlug":"graphics","files":{"shader.vert":"\n// Attributes per vertex: position\nattribute vec4 aPosition;\n\nuniform mat4   matrix_viewProjection;\nuniform mat4   matrix_model;\n\n// position of the camera\nuniform vec3 view_position;\n\n// Color to fragment program\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    // Transform the geometry\n    mat4 modelViewProj = matrix_viewProjection * matrix_model;\n    gl_Position = modelViewProj * aPosition;\n\n    // vertex in world space\n    vec4 vertexWorld = matrix_model * aPosition;\n\n    // point sprite size depends on its distance to camera\n    float dist = 25.0 - length(vertexWorld.xyz - view_position);\n    gl_PointSize = clamp(dist * 2.0 - 1.0, 1.0, 15.0);\n\n    // color depends on position of particle\n    outColor = vec4(vertexWorld.y * 0.1, 0.1, vertexWorld.z * 0.1, 1);\n}","shader.frag":"\nprecision mediump float;\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    // color supplied by vertex shader\n    gl_FragColor = outColor;\n\n    // make point round instead of square - make pixels outside of the circle black, using provided gl_PointCoord\n    vec2 dist = gl_PointCoord.xy - vec2(0.5, 0.5);\n    gl_FragColor.a = 1.0 - smoothstep(0.4, 0.5, sqrt(dot(dist, dist)));\n\n}"}},"point-cloud":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, files: { 'shader.vert': string, 'shader.frag': string }): void {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // Create an Entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.1, 0.1, 0.1)\n        });\n        camera.translate(0, 7, 24);\n\n        // Add entity into scene hierarchy\n        app.root.addChild(camera);\n        app.start();\n\n        // Create a new Entity\n        const entity = assets.statue.resource.instantiateRenderEntity();\n        app.root.addChild(entity);\n\n        // Create the shader definition and shader from the vertex and fragment shaders\n        const shaderDefinition = {\n            attributes: {\n                aPosition: pc.SEMANTIC_POSITION\n            },\n            vshader: files['shader.vert'],\n            fshader: files['shader.frag']\n        };\n        const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n        // Create a new material with the new shader\n        const material = new pc.Material();\n        material.shader = shader;\n\n        // find all render components\n        const renderComponents = entity.findComponents('render');\n\n        // for all render components\n        renderComponents.forEach(function (render: any) {\n\n            // For all meshes in the render component, assign new material\n            render.meshInstances.forEach(function (meshInstance: pc.MeshInstance) {\n                meshInstance.material = material;\n            });\n\n            // set it to render as points\n            render.renderStyle = pc.RENDERSTYLE_POINTS;\n        });\n\n        let currentTime = 0;\n        app.on(\"update\", function (dt) {\n\n            // Update the time and pass it to shader\n            currentTime += dt;\n            material.setParameter('uTime', currentTime);\n\n            // Rotate the model\n            entity.rotate(0, 15 * dt, 0);\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, files) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // Create an Entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.1, 0.1, 0.1),\n        });\n\n        camera.translate(0, 7, 24);\n\n        // Add entity into scene hierarchy\n        app.root.addChild(camera);\n        app.start();\n\n        // Create a new Entity\n        const entity = assets.statue.resource.instantiateRenderEntity();\n        app.root.addChild(entity);\n\n        // Create the shader definition and shader from the vertex and fragment shaders\n        const shaderDefinition = {\n            attributes: {\n                aPosition: pc.SEMANTIC_POSITION,\n            },\n\n            vshader: files[\"shader.vert\"],\n            fshader: files[\"shader.frag\"],\n        };\n\n        const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n        // Create a new material with the new shader\n        const material = new pc.Material();\n        material.shader = shader;\n\n        // find all render components\n        const renderComponents = entity.findComponents(\"render\");\n\n        // for all render components\n        renderComponents.forEach(function (render) {\n            // For all meshes in the render component, assign new material\n            render.meshInstances.forEach(function (meshInstance) {\n                meshInstance.material = material;\n            });\n\n            // set it to render as points\n            render.renderStyle = pc.RENDERSTYLE_POINTS;\n        });\n\n        let currentTime = 0;\n        app.on(\"update\", function (dt) {\n            // Update the time and pass it to shader\n            currentTime += dt;\n            material.setParameter(\"uTime\", currentTime);\n\n            // Rotate the model\n            entity.rotate(0, 15 * dt, 0);\n        });\n    });\n}\n","nameSlug":"point-cloud","categorySlug":"graphics","files":{"shader.vert":"\n// Attributes per vertex: position\nattribute vec4 aPosition;\n\nuniform mat4   matrix_viewProjection;\nuniform mat4   matrix_model;\nuniform mat4   matrix_view;\n\n// time\nuniform float uTime;\n\n// Color to fragment program\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    // Transform the geometry\n    mat4 modelView = matrix_view * matrix_model;\n    mat4 modelViewProj = matrix_viewProjection * matrix_model;\n    gl_Position = modelViewProj * aPosition;\n\n    // vertex in world space\n    vec4 vertexWorld = matrix_model * aPosition;\n\n    // use sine way to generate intensity value based on time and also y-coordinate of model\n    float intensity = abs(sin(0.6 * vertexWorld.y + uTime * 1.0));\n\n    // intensity smoothly drops to zero for smaller values than 0.9\n    intensity = smoothstep(0.9, 1.0, intensity);\n\n    // point size depends on intensity\n    gl_PointSize = clamp(12.0 * intensity, 1.0, 64.0);\n\n    // color mixes red and yellow based on intensity\n    outColor = mix(vec4(1.0, 1.0, 0.0, 1.0), vec4(0.9, 0.0, 0.0, 1.0), intensity);\n}","shader.frag":"\nprecision lowp float;\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    // just output color supplied by vertex shader\n    gl_FragColor = outColor;\n}"}},"portal":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        keyboard: new pc.Keyboard(window)\n    });\n\n    const assets = {\n        'helipad.dds': new pc.Asset('helipad.dds', 'cubemap', { url: '/static/assets/cubemaps/helipad.dds' }, { type: pc.TEXTURETYPE_RGBM }),\n        'portal': new pc.Asset('portal', 'container', { url: '/static/assets/models/portal.glb' }),\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' }),\n        'bitmoji': new pc.Asset('bitmoji', 'container', { url: '/static/assets/models/bitmoji.glb' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.start();\n\n        // set skybox - this DDS file was 'prefiltered' in the PlayCanvas Editor and then downloaded.\n        app.scene.setSkybox(assets[\"helipad.dds\"].resources);\n        app.scene.toneMapping = pc.TONEMAP_ACES;\n        app.scene.skyboxMip = 1;\n        app.scene.skyboxIntensity = 0.7;\n\n        ////////////////////////////////\n        // Script to rotate the scene //\n        ////////////////////////////////\n        const Rotator = pc.createScript('rotator');\n\n        let t = 0;\n\n        Rotator.prototype.update = function (dt: number) {\n            t += dt;\n            this.entity.setEulerAngles(0, Math.sin(t) * 40, 0);\n        };\n\n        //////////////////////////////////////////////////\n        // Script to set up rendering the portal itself //\n        //////////////////////////////////////////////////\n        const Portal = pc.createScript('portal');\n\n        // initialize code called once per entity\n        Portal.prototype.initialize = function () {\n\n            // increment value in stencil (from 0 to 1) for stencil geometry\n            const stencil = new pc.StencilParameters({\n                zpass: pc.STENCILOP_INCREMENT\n            });\n\n            // set the stencil and other parameters on all materials\n            const renders: Array<pc.RenderComponent> = this.entity.findComponents(\"render\");\n            renders.forEach((render) => {\n                for (const meshInstance of render.meshInstances) {\n                    const mat = meshInstance.material;\n                    mat.stencilBack = mat.stencilFront = stencil;\n\n                    // We only want to write to the stencil buffer\n                    mat.depthWrite = false;\n                    mat.redWrite = mat.greenWrite = mat.blueWrite = mat.alphaWrite = false;\n                    mat.update();\n                }\n            });\n        };\n\n        /////////////////////////////////////////////////////////////////////////////\n        // Script to set stencil options for entities inside or outside the portal //\n        /////////////////////////////////////////////////////////////////////////////\n\n        const PortalGeometry = pc.createScript('portalGeometry');\n\n        PortalGeometry.attributes.add('inside', {\n            type: 'boolean',\n            default: true,\n            title: 'True indicating the geometry is inside the portal, false for outside'\n        });\n\n        PortalGeometry.prototype.initialize = function () {\n\n            // based on value in the stencil buffer (0 outside, 1 inside), either render\n            // the geometry when the value is equal, or not equal to zero.\n            const stencil = new pc.StencilParameters({\n                func: this.inside ? pc.FUNC_NOTEQUAL : pc.FUNC_EQUAL,\n                ref: 0\n            });\n\n            // set the stencil parameters on all materials\n            const renders: Array<pc.RenderComponent> = this.entity.findComponents(\"render\");\n            renders.forEach((render) => {\n                for (const meshInstance of render.meshInstances) {\n                    meshInstance.material.stencilBack = meshInstance.material.stencilFront = stencil;\n                }\n            });\n        };\n\n        /////////////////////////////////////////////////////////////////////////////\n\n        // find world layer - majority of objects render to this layer\n        const worldLayer = app.scene.layers.getLayerByName(\"World\");\n\n        // find skybox layer - to enable it for the camera\n        const skyboxLayer = app.scene.layers.getLayerByName(\"Skybox\");\n\n        // portal layer - this is where the portal geometry is written to the stencil\n        // buffer, and this needs to render first, so insert it before the world layer\n        const portalLayer = new pc.Layer({ name: \"Portal\" });\n        app.scene.layers.insert(portalLayer, 0);\n\n        // Create an Entity with a camera component\n        // this camera renders both world and portal layers\n        const camera = new pc.Entity();\n        camera.addComponent('camera', {\n            layers: [worldLayer.id, portalLayer.id, skyboxLayer.id]\n        });\n        camera.setLocalPosition(7, 5.5, 7.1);\n        camera.setLocalEulerAngles(-27, 45, 0);\n        app.root.addChild(camera);\n\n        // Create an Entity with a directional light component\n        const light = new pc.Entity();\n        light.addComponent('light', {\n            type: 'directional',\n            color: new pc.Color(1, 1, 1)\n        });\n        light.setEulerAngles(45, 35, 0);\n        app.root.addChild(light);\n\n        // Create a root for the graphical scene\n        const group = new pc.Entity();\n        group.addComponent('script');\n        group.script.create('rotator');\n        app.root.addChild(group);\n\n        // Create the portal entity - this plane is written to stencil buffer,\n        // which is then used to test for inside / outside. This needs to render\n        // before all elements requiring stencil buffer, so add to to a portalLayer.\n        // This is the plane that fills the inside of the portal geometry.\n        const portal = new pc.Entity(\"Portal\");\n        portal.addComponent('render', {\n            type: 'plane',\n            material: new pc.StandardMaterial(),\n            layers: [portalLayer.id]\n        });\n        portal.addComponent('script');\n        portal.script.create('portal'); // comment out this line to see the geometry\n        portal.setLocalPosition(0, 0.4, -0.3);\n        portal.setLocalEulerAngles(90, 0, 0);\n        portal.setLocalScale(3.7, 1, 6.7);\n        group.addChild(portal);\n\n        // Create the portal visual geometry\n        const portalEntity = assets.portal.resource.instantiateRenderEntity();\n        portalEntity.setLocalPosition(0, -3, 0);\n        portalEntity.setLocalScale(0.02, 0.02, 0.02);\n        group.addChild(portalEntity);\n\n        // Create a statue entity, whic is visible inside the portal only\n        const statue = assets.statue.resource.instantiateRenderEntity();\n        statue.addComponent('script');\n        statue.script.create('portalGeometry', {\n            attributes: {\n                inside: true\n            }\n        });\n        statue.setLocalPosition(0, -1, -2);\n        statue.setLocalScale(0.25, 0.25, 0.25);\n        group.addChild(statue);\n\n        // Create a bitmoji entity, whic is visible outside the portal only\n        const bitmoji = assets.bitmoji.resource.instantiateRenderEntity();\n        bitmoji.addComponent('script');\n        bitmoji.script.create('portalGeometry', {\n            attributes: {\n                inside: false\n            }\n        });\n        bitmoji.setLocalPosition(0, -1, -2);\n        bitmoji.setLocalScale(2.5, 2.5, 2.5);\n        group.addChild(bitmoji);\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {\n        keyboard: new pc.Keyboard(window),\n    });\n\n    const assets = {\n        \"helipad.dds\": new pc.Asset(\n            \"helipad.dds\",\n            \"cubemap\",\n            { url: \"/static/assets/cubemaps/helipad.dds\" },\n            { type: pc.TEXTURETYPE_RGBM }\n        ),\n        portal: new pc.Asset(\"portal\", \"container\", {\n            url: \"/static/assets/models/portal.glb\",\n        }),\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n        bitmoji: new pc.Asset(\"bitmoji\", \"container\", {\n            url: \"/static/assets/models/bitmoji.glb\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.start();\n\n        // set skybox - this DDS file was 'prefiltered' in the PlayCanvas Editor and then downloaded.\n        app.scene.setSkybox(assets[\"helipad.dds\"].resources);\n        app.scene.toneMapping = pc.TONEMAP_ACES;\n        app.scene.skyboxMip = 1;\n        app.scene.skyboxIntensity = 0.7;\n\n        ////////////////////////////////\n        // Script to rotate the scene //\n        ////////////////////////////////\n        const Rotator = pc.createScript(\"rotator\");\n\n        let t = 0;\n\n        Rotator.prototype.update = function (dt) {\n            t += dt;\n            this.entity.setEulerAngles(0, Math.sin(t) * 40, 0);\n        };\n\n        //////////////////////////////////////////////////\n        // Script to set up rendering the portal itself //\n        //////////////////////////////////////////////////\n        const Portal = pc.createScript(\"portal\");\n\n        // initialize code called once per entity\n        Portal.prototype.initialize = function () {\n            // increment value in stencil (from 0 to 1) for stencil geometry\n            const stencil = new pc.StencilParameters({\n                zpass: pc.STENCILOP_INCREMENT,\n            });\n\n            // set the stencil and other parameters on all materials\n            const renders = this.entity.findComponents(\"render\");\n            renders.forEach((render) => {\n                for (const meshInstance of render.meshInstances) {\n                    const mat = meshInstance.material;\n                    mat.stencilBack = mat.stencilFront = stencil;\n\n                    // We only want to write to the stencil buffer\n                    mat.depthWrite = false;\n                    mat.redWrite =\n                        mat.greenWrite =\n                        mat.blueWrite =\n                        mat.alphaWrite =\n                            false;\n                    mat.update();\n                }\n            });\n        };\n\n        /////////////////////////////////////////////////////////////////////////////\n        // Script to set stencil options for entities inside or outside the portal //\n        /////////////////////////////////////////////////////////////////////////////\n\n        const PortalGeometry = pc.createScript(\"portalGeometry\");\n\n        PortalGeometry.attributes.add(\"inside\", {\n            type: \"boolean\",\n            default: true,\n            title: \"True indicating the geometry is inside the portal, false for outside\",\n        });\n\n        PortalGeometry.prototype.initialize = function () {\n            // based on value in the stencil buffer (0 outside, 1 inside), either render\n            // the geometry when the value is equal, or not equal to zero.\n            const stencil = new pc.StencilParameters({\n                func: this.inside ? pc.FUNC_NOTEQUAL : pc.FUNC_EQUAL,\n                ref: 0,\n            });\n\n            // set the stencil parameters on all materials\n            const renders = this.entity.findComponents(\"render\");\n            renders.forEach((render) => {\n                for (const meshInstance of render.meshInstances) {\n                    meshInstance.material.stencilBack =\n                        meshInstance.material.stencilFront = stencil;\n                }\n            });\n        };\n\n        /////////////////////////////////////////////////////////////////////////////\n\n        // find world layer - majority of objects render to this layer\n        const worldLayer = app.scene.layers.getLayerByName(\"World\");\n\n        // find skybox layer - to enable it for the camera\n        const skyboxLayer = app.scene.layers.getLayerByName(\"Skybox\");\n\n        // portal layer - this is where the portal geometry is written to the stencil\n        // buffer, and this needs to render first, so insert it before the world layer\n        const portalLayer = new pc.Layer({ name: \"Portal\" });\n        app.scene.layers.insert(portalLayer, 0);\n\n        // Create an Entity with a camera component\n        // this camera renders both world and portal layers\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            layers: [worldLayer.id, portalLayer.id, skyboxLayer.id],\n        });\n\n        camera.setLocalPosition(7, 5.5, 7.1);\n        camera.setLocalEulerAngles(-27, 45, 0);\n        app.root.addChild(camera);\n\n        // Create an Entity with a directional light component\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\",\n            color: new pc.Color(1, 1, 1),\n        });\n\n        light.setEulerAngles(45, 35, 0);\n        app.root.addChild(light);\n\n        // Create a root for the graphical scene\n        const group = new pc.Entity();\n        group.addComponent(\"script\");\n        group.script.create(\"rotator\");\n        app.root.addChild(group);\n\n        // Create the portal entity - this plane is written to stencil buffer,\n        // which is then used to test for inside / outside. This needs to render\n        // before all elements requiring stencil buffer, so add to to a portalLayer.\n        // This is the plane that fills the inside of the portal geometry.\n        const portal = new pc.Entity(\"Portal\");\n        portal.addComponent(\"render\", {\n            type: \"plane\",\n            material: new pc.StandardMaterial(),\n            layers: [portalLayer.id],\n        });\n\n        portal.addComponent(\"script\");\n        portal.script.create(\"portal\"); // comment out this line to see the geometry\n        portal.setLocalPosition(0, 0.4, -0.3);\n        portal.setLocalEulerAngles(90, 0, 0);\n        portal.setLocalScale(3.7, 1, 6.7);\n        group.addChild(portal);\n\n        // Create the portal visual geometry\n        const portalEntity = assets.portal.resource.instantiateRenderEntity();\n        portalEntity.setLocalPosition(0, -3, 0);\n        portalEntity.setLocalScale(0.02, 0.02, 0.02);\n        group.addChild(portalEntity);\n\n        // Create a statue entity, whic is visible inside the portal only\n        const statue = assets.statue.resource.instantiateRenderEntity();\n        statue.addComponent(\"script\");\n        statue.script.create(\"portalGeometry\", {\n            attributes: {\n                inside: true,\n            },\n        });\n\n        statue.setLocalPosition(0, -1, -2);\n        statue.setLocalScale(0.25, 0.25, 0.25);\n        group.addChild(statue);\n\n        // Create a bitmoji entity, whic is visible outside the portal only\n        const bitmoji = assets.bitmoji.resource.instantiateRenderEntity();\n        bitmoji.addComponent(\"script\");\n        bitmoji.script.create(\"portalGeometry\", {\n            attributes: {\n                inside: false,\n            },\n        });\n\n        bitmoji.setLocalPosition(0, -1, -2);\n        bitmoji.setLocalScale(2.5, 2.5, 2.5);\n        group.addChild(bitmoji);\n    });\n}\n","nameSlug":"portal","categorySlug":"graphics"},"post-effects":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data: any): void {\n\n    // set up and load draco module, as the glb we load is draco compressed\n    pc.WasmModule.setConfig('DracoDecoderModule', {\n        glueUrl: '/static/lib/draco/draco.wasm.js',\n        wasmUrl: '/static/lib/draco/draco.wasm.wasm',\n        fallbackUrl: '/static/lib/draco/draco.js'\n    });\n\n    const assets = {\n        'board': new pc.Asset('statue', 'container', { url: '/static/assets/models/chess-board.glb' }),\n        'bloom': new pc.Asset('bloom', 'script', { url: '/static/scripts/posteffects/posteffect-bloom.js' }),\n        'bokeh': new pc.Asset('bokeh', 'script', { url: '/static/scripts/posteffects/posteffect-bokeh.js' }),\n        'sepia': new pc.Asset('sepia', 'script', { url: '/static/scripts/posteffects/posteffect-sepia.js' }),\n        'vignette': new pc.Asset('vignette', 'script', { url: '/static/scripts/posteffects/posteffect-vignette.js' }),\n        'ssao': new pc.Asset('ssao', 'script', { url: '/static/scripts/posteffects/posteffect-ssao.js' }),\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/arial.json' }),\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js',\n\n        // WebGPU does not currently support antialiased depth resolve, disable it till we implement a shader resolve solution\n        antialias: false\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // setup skydome\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxMip = 2;\n            app.scene.exposure = 1;\n\n            // helper function to create a 3d primitive including its material\n            function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3, brightness: number, allowEmissive = true) {\n\n                // create a material\n                const material = new pc.StandardMaterial();\n                material.gloss = 0.4;\n                material.metalness = 0.6;\n                material.useMetalness = true;\n                material.emissive = pc.Color.YELLOW;\n                material.update();\n\n                // create the primitive using the material\n                const primitive = new pc.Entity();\n                primitive.addComponent('render', {\n                    type: primitiveType,\n                    material: material,\n                    castShadows: false,\n                    receiveShadows: false\n                });\n\n                // set scale and add it to scene\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // get the instance of the chess board and set up with render component\n            const boardEntity = assets.board.resource.instantiateRenderEntity({\n                castShadows: true,\n                receiveShadows: true\n            });\n            app.root.addChild(boardEntity);\n\n            // create a sphere which represents the point of focus for the bokeh filter\n            const focusPrimitive = createPrimitive(\"sphere\", pc.Vec3.ZERO, new pc.Vec3(3, 3, 3), 1.5, false);\n\n            // add an omni light as a child of this sphere\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: pc.Color.YELLOW,\n                intensity: 2,\n                range: 150,\n                shadowDistance: 150,\n                castShadows: true\n            });\n            focusPrimitive.addChild(light);\n\n            // Create an Entity with a camera component, and attach postprocessing effects scripts on it\n            const camera: any = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n                farClip: 500\n            });\n            camera.addComponent(\"script\");\n            data.set('scripts', {\n                ssao: {\n                    enabled: true,\n                    radius: 5,\n                    samples: 16,\n                    brightness: 0,\n                    downscale: 1\n                },\n                bloom: {\n                    enabled: true,\n                    bloomIntensity: 0.8,\n                    bloomThreshold: 0.7,\n                    blurAmount: 15\n                },\n                sepia: {\n                    enabled: true,\n                    amount: 0.4\n                },\n                vignette: {\n                    enabled: true,\n                    darkness: 1,\n                    offset: 1.2\n                },\n                bokeh: {\n                    enabled: true,\n                    aperture: 0.1,\n                    maxBlur: 0.02\n                }\n            });\n\n            Object.keys(data.get('scripts')).forEach((key) => {\n                camera.script.create(key, {\n                    attributes: data.get(`scripts.${key}`)\n                });\n            });\n\n            // position the camera in the world\n            camera.setLocalPosition(0, 30, -60);\n            camera.lookAt(0, 0, 100);\n            app.root.addChild(camera);\n\n            // Allow user to toggle individual post effects\n            app.keyboard.on(\"keydown\", function (e: any) {\n                // if the user is editing an input field, ignore key presses\n                if (e.element.constructor.name === 'HTMLInputElement') return;\n                switch (e.key) {\n                    case pc.KEY_1:\n                        data.set('scripts.bloom.enabled', !data.get('scripts.bloom.enabled'));\n                        break;\n                    case pc.KEY_2:\n                        data.set('scripts.sepia.enabled', !data.get('scripts.sepia.enabled'));\n                        break;\n                    case pc.KEY_3:\n                        data.set('scripts.vignette.enabled', !data.get('scripts.vignette.enabled'));\n                        break;\n                    case pc.KEY_4:\n                        data.set('scripts.bokeh.enabled', !data.get('scripts.bokeh.enabled'));\n                        break;\n                    case pc.KEY_5:\n                        data.set('scripts.ssao.enabled', !data.get('scripts.ssao.enabled'));\n                        break;\n                    case pc.KEY_6:\n                        data.set('data.postProcessUI.enabled', !data.get('data.postProcessUI.enabled'));\n                        break;\n                }\n            }, this);\n\n            // Create a 2D screen to place UI on\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true\n            });\n            app.root.addChild(screen);\n\n            // create a text element to show which effects are enabled\n            const text = new pc.Entity();\n            text.addComponent(\"element\", {\n                anchor: new pc.Vec4(0.1, 0.1, 0.5, 0.5),\n                fontAsset: assets.font,\n                fontSize: 28,\n                pivot: new pc.Vec2(0.5, 0.1),\n                type: pc.ELEMENTTYPE_TEXT,\n                alignment: pc.Vec2.ZERO\n            });\n            screen.addChild(text);\n\n            // Display some UI text which the post processing can be tested against\n            text.element.text = 'Test UI Text';\n\n            // update things every frame\n            let angle = 0;\n            app.on(\"update\", function (dt: any) {\n                angle += dt;\n\n                // rotate the skydome\n                app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(0, angle * 20, 0);\n\n                // move the focus sphere in the world\n                const focusPosition = new pc.Vec3(0, 30, Math.sin(1 + angle * 0.3) * 90);\n                focusPrimitive.setPosition(focusPosition);\n\n                // set the focus distance to the bokeh effect\n                // - it's a negative distance between the camera and the focus sphere\n                camera.script.bokeh.focus = -focusPosition.sub(camera.getPosition()).length();\n\n                // orbit the camera around\n                camera.setLocalPosition(110 * Math.sin(angle * 0.2), 45, 110 * Math.cos(angle * 0.2));\n                focusPosition.y -= 20;\n                camera.lookAt(focusPosition);\n\n                // display the depth texture if it was rendered\n                if (data.get('scripts.bokeh.enabled') || data.get('scripts.ssao.enabled')) {\n                    // @ts-ignore engine-tsd\n                    app.drawDepthTexture(0.7, -0.7, 0.5, 0.5);\n                }\n            });\n\n            data.on('*:set', (path: string, value: any) => {\n                const pathArray = path.split('.');\n                if (pathArray[0] === 'scripts') {\n                    camera.script[pathArray[1]][pathArray[2]] = value;\n                } else {\n                    camera.camera.disablePostEffectsLayer = camera.camera.disablePostEffectsLayer === pc.LAYERID_UI ? undefined : pc.LAYERID_UI;\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    // set up and load draco module, as the glb we load is draco compressed\n    pc.WasmModule.setConfig(\"DracoDecoderModule\", {\n        glueUrl: \"/static/lib/draco/draco.wasm.js\",\n        wasmUrl: \"/static/lib/draco/draco.wasm.wasm\",\n        fallbackUrl: \"/static/lib/draco/draco.js\",\n    });\n\n    const assets = {\n        board: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/chess-board.glb\",\n        }),\n        bloom: new pc.Asset(\"bloom\", \"script\", {\n            url: \"/static/scripts/posteffects/posteffect-bloom.js\",\n        }),\n        bokeh: new pc.Asset(\"bokeh\", \"script\", {\n            url: \"/static/scripts/posteffects/posteffect-bokeh.js\",\n        }),\n        sepia: new pc.Asset(\"sepia\", \"script\", {\n            url: \"/static/scripts/posteffects/posteffect-sepia.js\",\n        }),\n        vignette: new pc.Asset(\"vignette\", \"script\", {\n            url: \"/static/scripts/posteffects/posteffect-vignette.js\",\n        }),\n        ssao: new pc.Asset(\"ssao\", \"script\", {\n            url: \"/static/scripts/posteffects/posteffect-ssao.js\",\n        }),\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/arial.json\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n\n        // WebGPU does not currently support antialiased depth resolve, disable it till we implement a shader resolve solution\n        antialias: false,\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // setup skydome\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxMip = 2;\n            app.scene.exposure = 1;\n\n            // helper function to create a 3d primitive including its material\n            function createPrimitive(\n                primitiveType,\n                position,\n                scale,\n                brightness,\n                allowEmissive = true\n            ) {\n                // create a material\n                const material = new pc.StandardMaterial();\n                material.gloss = 0.4;\n                material.metalness = 0.6;\n                material.useMetalness = true;\n                material.emissive = pc.Color.YELLOW;\n                material.update();\n\n                // create the primitive using the material\n                const primitive = new pc.Entity();\n                primitive.addComponent(\"render\", {\n                    type: primitiveType,\n                    material: material,\n                    castShadows: false,\n                    receiveShadows: false,\n                });\n\n                // set scale and add it to scene\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // get the instance of the chess board and set up with render component\n            const boardEntity = assets.board.resource.instantiateRenderEntity({\n                castShadows: true,\n                receiveShadows: true,\n            });\n\n            app.root.addChild(boardEntity);\n\n            // create a sphere which represents the point of focus for the bokeh filter\n            const focusPrimitive = createPrimitive(\n                \"sphere\",\n                pc.Vec3.ZERO,\n                new pc.Vec3(3, 3, 3),\n                1.5,\n                false\n            );\n\n            // add an omni light as a child of this sphere\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: pc.Color.YELLOW,\n                intensity: 2,\n                range: 150,\n                shadowDistance: 150,\n                castShadows: true,\n            });\n\n            focusPrimitive.addChild(light);\n\n            // Create an Entity with a camera component, and attach postprocessing effects scripts on it\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n                farClip: 500,\n            });\n\n            camera.addComponent(\"script\");\n            data.set(\"scripts\", {\n                ssao: {\n                    enabled: true,\n                    radius: 5,\n                    samples: 16,\n                    brightness: 0,\n                    downscale: 1,\n                },\n\n                bloom: {\n                    enabled: true,\n                    bloomIntensity: 0.8,\n                    bloomThreshold: 0.7,\n                    blurAmount: 15,\n                },\n\n                sepia: {\n                    enabled: true,\n                    amount: 0.4,\n                },\n\n                vignette: {\n                    enabled: true,\n                    darkness: 1,\n                    offset: 1.2,\n                },\n\n                bokeh: {\n                    enabled: true,\n                    aperture: 0.1,\n                    maxBlur: 0.02,\n                },\n            });\n\n            Object.keys(data.get(\"scripts\")).forEach((key) => {\n                camera.script.create(key, {\n                    attributes: data.get(`scripts.${key}`),\n                });\n            });\n\n            // position the camera in the world\n            camera.setLocalPosition(0, 30, -60);\n            camera.lookAt(0, 0, 100);\n            app.root.addChild(camera);\n\n            // Allow user to toggle individual post effects\n            app.keyboard.on(\n                \"keydown\",\n                function (e) {\n                    // if the user is editing an input field, ignore key presses\n                    if (e.element.constructor.name === \"HTMLInputElement\")\n                        return;\n                    switch (e.key) {\n                        case pc.KEY_1:\n                            data.set(\n                                \"scripts.bloom.enabled\",\n                                !data.get(\"scripts.bloom.enabled\")\n                            );\n                            break;\n                        case pc.KEY_2:\n                            data.set(\n                                \"scripts.sepia.enabled\",\n                                !data.get(\"scripts.sepia.enabled\")\n                            );\n                            break;\n                        case pc.KEY_3:\n                            data.set(\n                                \"scripts.vignette.enabled\",\n                                !data.get(\"scripts.vignette.enabled\")\n                            );\n                            break;\n                        case pc.KEY_4:\n                            data.set(\n                                \"scripts.bokeh.enabled\",\n                                !data.get(\"scripts.bokeh.enabled\")\n                            );\n                            break;\n                        case pc.KEY_5:\n                            data.set(\n                                \"scripts.ssao.enabled\",\n                                !data.get(\"scripts.ssao.enabled\")\n                            );\n                            break;\n                        case pc.KEY_6:\n                            data.set(\n                                \"data.postProcessUI.enabled\",\n                                !data.get(\"data.postProcessUI.enabled\")\n                            );\n                            break;\n                    }\n                },\n                this\n            );\n\n            // Create a 2D screen to place UI on\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true,\n            });\n\n            app.root.addChild(screen);\n\n            // create a text element to show which effects are enabled\n            const text = new pc.Entity();\n            text.addComponent(\"element\", {\n                anchor: new pc.Vec4(0.1, 0.1, 0.5, 0.5),\n                fontAsset: assets.font,\n                fontSize: 28,\n                pivot: new pc.Vec2(0.5, 0.1),\n                type: pc.ELEMENTTYPE_TEXT,\n                alignment: pc.Vec2.ZERO,\n            });\n\n            screen.addChild(text);\n\n            // Display some UI text which the post processing can be tested against\n            text.element.text = \"Test UI Text\";\n\n            // update things every frame\n            let angle = 0;\n            app.on(\"update\", function (dt) {\n                angle += dt;\n\n                // rotate the skydome\n                app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(\n                    0,\n                    angle * 20,\n                    0\n                );\n\n                // move the focus sphere in the world\n                const focusPosition = new pc.Vec3(\n                    0,\n                    30,\n                    Math.sin(1 + angle * 0.3) * 90\n                );\n                focusPrimitive.setPosition(focusPosition);\n\n                // set the focus distance to the bokeh effect\n                // - it's a negative distance between the camera and the focus sphere\n                camera.script.bokeh.focus = -focusPosition\n                    .sub(camera.getPosition())\n                    .length();\n\n                // orbit the camera around\n                camera.setLocalPosition(\n                    110 * Math.sin(angle * 0.2),\n                    45,\n                    110 * Math.cos(angle * 0.2)\n                );\n                focusPosition.y -= 20;\n                camera.lookAt(focusPosition);\n\n                // display the depth texture if it was rendered\n                if (\n                    data.get(\"scripts.bokeh.enabled\") ||\n                    data.get(\"scripts.ssao.enabled\")\n                ) {\n                    // @ts-ignore engine-tsd\n                    app.drawDepthTexture(0.7, -0.7, 0.5, 0.5);\n                }\n            });\n\n            data.on(\"*:set\", (path, value) => {\n                const pathArray = path.split(\".\");\n                if (pathArray[0] === \"scripts\") {\n                    camera.script[pathArray[1]][pathArray[2]] = value;\n                } else {\n                    camera.camera.disablePostEffectsLayer =\n                        camera.camera.disablePostEffectsLayer === pc.LAYERID_UI\n                            ? undefined\n                            : pc.LAYERID_UI;\n                }\n            });\n        });\n    });\n}\n","nameSlug":"post-effects","categorySlug":"graphics"},"reflection-box":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data: any): void {\n\n    const assets = {\n        'script1': new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' }),\n        'script2': new pc.Asset('script', 'script', { url: '/static/scripts/utils/cubemap-renderer.js' }),\n        'batmobile': new pc.Asset('batmobile', 'container', { url: '/static/assets/models/batmobile-armored.glb' }),\n        'normal': new pc.Asset('normal', 'texture', { url: '/static/assets/textures/normal-map.png' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            data.set('settings', {\n                updateFrequency: 10,\n                gloss: 0.8,\n                metalness: 0.9,\n                bumpiness: 0.2,\n                reflectivity: 0.5\n            });\n\n            // create a layer for object that do not render into reflection cubemap\n            const excludedLayer = new pc.Layer({ name: \"Excluded\" });\n            app.scene.layers.push(excludedLayer);\n\n            // get world layer\n            const worldLayer = app.scene.layers.getLayerByName(\"World\");\n\n            // create an envAtlas texture, which will hold a prefiltered lighting generated from the cubemap.\n            // This represents a reflection prefiltered for different levels of roughness\n            const envAtlas = new pc.Texture(app.graphicsDevice, {\n                width: 512,\n                height: 512,\n                format: pc.PIXELFORMAT_RGBA8,\n                type: pc.TEXTURETYPE_RGBM,\n                projection: pc.TEXTUREPROJECTION_EQUIRECT,\n                addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n                addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n                mipmaps: false\n            });\n\n            // material for the walls\n            const roomMaterial = new pc.StandardMaterial();\n            roomMaterial.useMetalness = true;\n            roomMaterial.diffuse = pc.Color.WHITE;\n            roomMaterial.normalMap = assets.normal.resource;\n            roomMaterial.normalMapTiling.set(5, 5);\n            roomMaterial.bumpiness = 0.1;\n            roomMaterial.gloss = 0.9;\n            roomMaterial.reflectivity = 0.3;\n            // @ts-ignore\n            roomMaterial.envAtlas = envAtlas; // use reflection from env atlas\n            roomMaterial.metalness = 0.5;\n\n            // the material uses box projected cubemap for reflections. Set its bounding box the the size of the room\n            // so that the reflections line up\n            roomMaterial.cubeMapProjection = pc.CUBEPROJ_BOX;\n            roomMaterial.cubeMapProjectionBox = new pc.BoundingBox(new pc.Vec3(0, 200, 0), new pc.Vec3(400, 200, 400));\n            roomMaterial.update();\n\n            // material for the magenta emissive beams\n            const emissiveMaterial = new pc.StandardMaterial();\n            emissiveMaterial.emissive = pc.Color.MAGENTA;\n            emissiveMaterial.diffuse = pc.Color.BLACK;\n            emissiveMaterial.update();\n\n            // material for the white sphere representing an omni light\n            const lightMaterial = new pc.StandardMaterial();\n            lightMaterial.emissive = pc.Color.WHITE;\n            lightMaterial.diffuse = pc.Color.BLACK;\n            lightMaterial.update();\n\n            // material for the reflective sphere in the center\n            const sphereMaterial = new pc.StandardMaterial();\n            sphereMaterial.useMetalness = true;\n            sphereMaterial.diffuse = pc.Color.WHITE;\n            sphereMaterial.normalMap = assets.normal.resource;\n            sphereMaterial.normalMapTiling.set(5, 5);\n            sphereMaterial.bumpiness = 0.7;\n            sphereMaterial.gloss = 0.3;\n            sphereMaterial.metalness = 0.7;\n            sphereMaterial.reflectivity = 0.3;\n            // @ts-ignore\n            sphereMaterial.envAtlas = envAtlas; // use reflection from env atlas\n            sphereMaterial.update();\n\n            let videoTexture : pc.Texture;\n            if (!app.graphicsDevice.isWebGPU) {\n                // set up video playback into a texture\n                videoTexture = new pc.Texture(app.graphicsDevice, {\n                    format: pc.PIXELFORMAT_RGB565,\n                    mipmaps: false,\n                    minFilter: pc.FILTER_LINEAR,\n                    magFilter: pc.FILTER_LINEAR,\n                    addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n                    addressV: pc.ADDRESS_CLAMP_TO_EDGE\n                });\n\n                // create a HTML element with the video\n                const video: HTMLVideoElement = document.createElement('video');\n                video.id = 'vid';\n                video.loop = true;\n                video.muted = true;\n                video.autoplay = true;\n                video.playsInline = true;\n                video.crossOrigin = \"anonymous\";\n                video.setAttribute('style', 'display: block; width: 1px; height: 1px; position: absolute; opacity: 0; z-index: -1000; top: 0px; pointer-events: none');\n                video.src = '/static/assets/video/SampleVideo_1280x720_1mb.mp4';\n                document.body.append(video);\n                video.addEventListener('canplaythrough', function () {\n                    videoTexture.setSource(video);\n                });\n            }\n\n            // materials used on the TV screen to display the video texture\n            const screenMaterial = new pc.StandardMaterial();\n            screenMaterial.useLighting = false;\n            screenMaterial.emissiveMap = videoTexture;\n            screenMaterial.update();\n\n            // helper function to create a 3d primitive including its material\n            function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3, material: pc.Material) {\n\n                // create the primitive using the material\n                const primitive = new pc.Entity();\n                primitive.addComponent('render', {\n                    type: primitiveType,\n                    material: material,\n                    layers: [worldLayer.id, excludedLayer.id],\n                    castShadows: false,\n                    receiveShadows: false\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n            }\n\n            // create the ground plane from the boxes\n            createPrimitive(\"box\", new pc.Vec3(0, 0, 0), new pc.Vec3(800, 2, 800), roomMaterial);\n            createPrimitive(\"box\", new pc.Vec3(0, 400, 0), new pc.Vec3(800, 2, 800), roomMaterial);\n\n            // walls\n            createPrimitive(\"box\", new pc.Vec3(400, 200, 0), new pc.Vec3(2, 400, 800), roomMaterial);\n            createPrimitive(\"box\", new pc.Vec3(-400, 200, 0), new pc.Vec3(2, 400, 800), roomMaterial);\n            createPrimitive(\"box\", new pc.Vec3(0, 200, -400), new pc.Vec3(800, 400, 0), roomMaterial);\n            createPrimitive(\"box\", new pc.Vec3(0, 200, 400), new pc.Vec3(800, 400, 0), roomMaterial);\n\n            // emissive pillars\n            createPrimitive(\"box\", new pc.Vec3(400, 200, -50), new pc.Vec3(20, 400, 20), emissiveMaterial);\n            createPrimitive(\"box\", new pc.Vec3(400, 200, 50), new pc.Vec3(20, 400, 20), emissiveMaterial);\n            createPrimitive(\"box\", new pc.Vec3(-400, 200, 50), new pc.Vec3(20, 400, 20), emissiveMaterial);\n            createPrimitive(\"box\", new pc.Vec3(-400, 200, -50), new pc.Vec3(20, 400, 20), emissiveMaterial);\n            createPrimitive(\"box\", new pc.Vec3(0, 400, 50), new pc.Vec3(800, 20, 20), emissiveMaterial);\n            createPrimitive(\"box\", new pc.Vec3(0, 400, -50), new pc.Vec3(800, 20, 20), emissiveMaterial);\n\n            // screen\n            createPrimitive(\"box\", new pc.Vec3(0, 200, 400), new pc.Vec3(500, 250, 5), screenMaterial);\n\n            // batmobile\n            const batmobileEntity: pc.Entity = assets.batmobile.resource.instantiateRenderEntity({\n                castShadows: false,\n                receiveShadows: false\n            });\n            batmobileEntity.setLocalScale(100, 100, 100);\n            batmobileEntity.rotateLocal(0, 0, 90);\n            app.root.addChild(batmobileEntity);\n\n            // apply shiny material to it\n            const renders: Array<pc.RenderComponent> = batmobileEntity.findComponents('render') as Array<pc.RenderComponent>;\n            renders.forEach((render) => {\n                for (let i = 0; i < render.meshInstances.length; i++) {\n                    const meshInstance = render.meshInstances[i];\n                    meshInstance.material = sphereMaterial;\n                }\n            });\n\n            // create an omni light white orbits the room to avoid it being completely dark\n            const lightOmni = new pc.Entity();\n            lightOmni.addComponent(\"light\", {\n                type: \"omni\",\n                layers: [excludedLayer.id], // add it to excluded layer, we don't want the light captured in the reflection\n                castShadows: false,\n                color: pc.Color.WHITE,\n                intensity: 0.2,\n                range: 1000\n            });\n\n            // add a white sphere to light so that we can see where it is. This sphere is excluded from the reflections.\n            lightOmni.addComponent(\"render\", {\n                type: \"sphere\",\n                layers: [excludedLayer.id],\n                material: lightMaterial,\n                castShadows: false,\n                receiveShadows: false\n            });\n            lightOmni.setLocalScale(20, 20, 20);\n            app.root.addChild(lightOmni);\n\n            // create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                fov: 100,\n                layers: [worldLayer.id, excludedLayer.id],\n                farClip: 1500\n            });\n            camera.setLocalPosition(270, 90, -260);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    distanceMax: 390,\n                    frameOnStart: false\n                }\n            });\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // create a probe object with cubemapRenderer script which takes care of rendering dynamic cubemap\n            const probe = new pc.Entity();\n            probe.addComponent('script');\n\n            // add camera component to the probe - this defines camera properties for cubemap rendering\n            probe.addComponent('camera', {\n\n                // optimization - no need to clear as all pixels get overwritten\n                clearColorBuffer: false,\n\n                // priority - render before world camera\n                priority: -1,\n\n                // only render meshes on the worldLayer (and not excluded layer)\n                layers: [worldLayer.id],\n\n                // disable as this is not a camera that renders cube map but only a container for properties for cube map rendering\n                enabled: false,\n\n                nearClip: 1,\n                farClip: 500\n            });\n\n            // Add a cubemap renderer script, which renders to a cubemap of size 128 with mipmaps, which is directly useable\n            // as a lighting source for envAtlas generation\n            // Position it in the center of the room.\n            probe.script.create('cubemapRenderer', {\n                attributes: {\n                    resolution: 128,\n                    mipmaps: true,\n                    depth: true\n                }\n            });\n            probe.setPosition(0, 200, 0);\n            app.root.addChild(probe);\n\n            // handle onCubemapPostRender event fired by the cubemapRenderer when all faces of the cubemap are done rendering\n            probe.on('onCubemapPostRender', () => {\n\n                // prefilter just rendered cubemap into envAtlas, so that it can be used for reflection during the rest of the frame\n                // @ts-ignore\n                pc.EnvLighting.generateAtlas(probe.script.cubemapRenderer.cubeMap, {\n                    target: envAtlas\n                });\n            });\n\n            // Set an update function on the app's update event\n            let time = 0;\n            let updateProbeCount = 1;\n            let updateVideo = true;\n            app.on(\"update\", function (dt: number) {\n                time += dt * 0.3;\n\n                // Update the video data to the texture every other frame\n                if (updateVideo && videoTexture) {\n                    videoTexture.upload();\n                }\n                updateVideo = !updateVideo;\n\n                // move the light around\n                lightOmni.setLocalPosition(300 * Math.sin(time), 300, 300 * Math.cos(time));\n\n                // update the reflection probe as needed\n                const updateFrequency = data.get('settings.updateFrequency');\n                updateProbeCount--;\n                if (updateFrequency === 0)\n                    updateProbeCount = 1;\n\n                if (updateProbeCount <= 0) {\n                    // enable probe rendering\n                    probe.enabled = true;\n                    updateProbeCount = updateFrequency;\n                } else {\n                    probe.enabled = false;\n                }\n\n                // update material properties based on settings\n                const gloss = data.get('settings.gloss');\n                const metalness = data.get('settings.metalness');\n                const bumpiness = data.get('settings.bumpiness');\n                const reflectivity = data.get('settings.reflectivity');\n\n                roomMaterial.gloss = gloss;\n                roomMaterial.metalness = metalness;\n                roomMaterial.bumpiness = bumpiness;\n                roomMaterial.reflectivity = reflectivity;\n                roomMaterial.update();\n\n                sphereMaterial.gloss = gloss;\n                sphereMaterial.metalness = metalness;\n                sphereMaterial.bumpiness = bumpiness;\n                sphereMaterial.reflectivity = reflectivity;\n                sphereMaterial.update();\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    const assets = {\n        script1: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/orbit-camera.js\",\n        }),\n        script2: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/utils/cubemap-renderer.js\",\n        }),\n        batmobile: new pc.Asset(\"batmobile\", \"container\", {\n            url: \"/static/assets/models/batmobile-armored.glb\",\n        }),\n        normal: new pc.Asset(\"normal\", \"texture\", {\n            url: \"/static/assets/textures/normal-map.png\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            data.set(\"settings\", {\n                updateFrequency: 10,\n                gloss: 0.8,\n                metalness: 0.9,\n                bumpiness: 0.2,\n                reflectivity: 0.5,\n            });\n\n            // create a layer for object that do not render into reflection cubemap\n            const excludedLayer = new pc.Layer({ name: \"Excluded\" });\n            app.scene.layers.push(excludedLayer);\n\n            // get world layer\n            const worldLayer = app.scene.layers.getLayerByName(\"World\");\n\n            // create an envAtlas texture, which will hold a prefiltered lighting generated from the cubemap.\n            // This represents a reflection prefiltered for different levels of roughness\n            const envAtlas = new pc.Texture(app.graphicsDevice, {\n                width: 512,\n                height: 512,\n                format: pc.PIXELFORMAT_RGBA8,\n                type: pc.TEXTURETYPE_RGBM,\n                projection: pc.TEXTUREPROJECTION_EQUIRECT,\n                addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n                addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n                mipmaps: false,\n            });\n\n            // material for the walls\n            const roomMaterial = new pc.StandardMaterial();\n            roomMaterial.useMetalness = true;\n            roomMaterial.diffuse = pc.Color.WHITE;\n            roomMaterial.normalMap = assets.normal.resource;\n            roomMaterial.normalMapTiling.set(5, 5);\n            roomMaterial.bumpiness = 0.1;\n            roomMaterial.gloss = 0.9;\n            roomMaterial.reflectivity = 0.3;\n            // @ts-ignore\n            roomMaterial.envAtlas = envAtlas; // use reflection from env atlas\n            roomMaterial.metalness = 0.5;\n\n            // the material uses box projected cubemap for reflections. Set its bounding box the the size of the room\n            // so that the reflections line up\n            roomMaterial.cubeMapProjection = pc.CUBEPROJ_BOX;\n            roomMaterial.cubeMapProjectionBox = new pc.BoundingBox(\n                new pc.Vec3(0, 200, 0),\n                new pc.Vec3(400, 200, 400)\n            );\n            roomMaterial.update();\n\n            // material for the magenta emissive beams\n            const emissiveMaterial = new pc.StandardMaterial();\n            emissiveMaterial.emissive = pc.Color.MAGENTA;\n            emissiveMaterial.diffuse = pc.Color.BLACK;\n            emissiveMaterial.update();\n\n            // material for the white sphere representing an omni light\n            const lightMaterial = new pc.StandardMaterial();\n            lightMaterial.emissive = pc.Color.WHITE;\n            lightMaterial.diffuse = pc.Color.BLACK;\n            lightMaterial.update();\n\n            // material for the reflective sphere in the center\n            const sphereMaterial = new pc.StandardMaterial();\n            sphereMaterial.useMetalness = true;\n            sphereMaterial.diffuse = pc.Color.WHITE;\n            sphereMaterial.normalMap = assets.normal.resource;\n            sphereMaterial.normalMapTiling.set(5, 5);\n            sphereMaterial.bumpiness = 0.7;\n            sphereMaterial.gloss = 0.3;\n            sphereMaterial.metalness = 0.7;\n            sphereMaterial.reflectivity = 0.3;\n            // @ts-ignore\n            sphereMaterial.envAtlas = envAtlas; // use reflection from env atlas\n            sphereMaterial.update();\n\n            let videoTexture;\n            if (!app.graphicsDevice.isWebGPU) {\n                // set up video playback into a texture\n                videoTexture = new pc.Texture(app.graphicsDevice, {\n                    format: pc.PIXELFORMAT_RGB565,\n                    mipmaps: false,\n                    minFilter: pc.FILTER_LINEAR,\n                    magFilter: pc.FILTER_LINEAR,\n                    addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n                    addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n                });\n\n                // create a HTML element with the video\n                const video = document.createElement(\"video\");\n                video.id = \"vid\";\n                video.loop = true;\n                video.muted = true;\n                video.autoplay = true;\n                video.playsInline = true;\n                video.crossOrigin = \"anonymous\";\n                video.setAttribute(\n                    \"style\",\n                    \"display: block; width: 1px; height: 1px; position: absolute; opacity: 0; z-index: -1000; top: 0px; pointer-events: none\"\n                );\n                video.src = \"/static/assets/video/SampleVideo_1280x720_1mb.mp4\";\n                document.body.append(video);\n                video.addEventListener(\"canplaythrough\", function () {\n                    videoTexture.setSource(video);\n                });\n            }\n\n            // materials used on the TV screen to display the video texture\n            const screenMaterial = new pc.StandardMaterial();\n            screenMaterial.useLighting = false;\n            screenMaterial.emissiveMap = videoTexture;\n            screenMaterial.update();\n\n            // helper function to create a 3d primitive including its material\n            function createPrimitive(primitiveType, position, scale, material) {\n                // create the primitive using the material\n                const primitive = new pc.Entity();\n                primitive.addComponent(\"render\", {\n                    type: primitiveType,\n                    material: material,\n                    layers: [worldLayer.id, excludedLayer.id],\n                    castShadows: false,\n                    receiveShadows: false,\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n            }\n\n            // create the ground plane from the boxes\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(0, 0, 0),\n                new pc.Vec3(800, 2, 800),\n                roomMaterial\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(0, 400, 0),\n                new pc.Vec3(800, 2, 800),\n                roomMaterial\n            );\n\n            // walls\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(400, 200, 0),\n                new pc.Vec3(2, 400, 800),\n                roomMaterial\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(-400, 200, 0),\n                new pc.Vec3(2, 400, 800),\n                roomMaterial\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(0, 200, -400),\n                new pc.Vec3(800, 400, 0),\n                roomMaterial\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(0, 200, 400),\n                new pc.Vec3(800, 400, 0),\n                roomMaterial\n            );\n\n            // emissive pillars\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(400, 200, -50),\n                new pc.Vec3(20, 400, 20),\n                emissiveMaterial\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(400, 200, 50),\n                new pc.Vec3(20, 400, 20),\n                emissiveMaterial\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(-400, 200, 50),\n                new pc.Vec3(20, 400, 20),\n                emissiveMaterial\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(-400, 200, -50),\n                new pc.Vec3(20, 400, 20),\n                emissiveMaterial\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(0, 400, 50),\n                new pc.Vec3(800, 20, 20),\n                emissiveMaterial\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(0, 400, -50),\n                new pc.Vec3(800, 20, 20),\n                emissiveMaterial\n            );\n\n            // screen\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(0, 200, 400),\n                new pc.Vec3(500, 250, 5),\n                screenMaterial\n            );\n\n            // batmobile\n            const batmobileEntity =\n                assets.batmobile.resource.instantiateRenderEntity({\n                    castShadows: false,\n                    receiveShadows: false,\n                });\n\n            batmobileEntity.setLocalScale(100, 100, 100);\n            batmobileEntity.rotateLocal(0, 0, 90);\n            app.root.addChild(batmobileEntity);\n\n            // apply shiny material to it\n            const renders = batmobileEntity.findComponents(\"render\");\n            renders.forEach((render) => {\n                for (let i = 0; i < render.meshInstances.length; i++) {\n                    const meshInstance = render.meshInstances[i];\n                    meshInstance.material = sphereMaterial;\n                }\n            });\n\n            // create an omni light white orbits the room to avoid it being completely dark\n            const lightOmni = new pc.Entity();\n            lightOmni.addComponent(\"light\", {\n                type: \"omni\",\n                layers: [excludedLayer.id], // add it to excluded layer, we don't want the light captured in the reflection\n                castShadows: false,\n                color: pc.Color.WHITE,\n                intensity: 0.2,\n                range: 1000,\n            });\n\n            // add a white sphere to light so that we can see where it is. This sphere is excluded from the reflections.\n            lightOmni.addComponent(\"render\", {\n                type: \"sphere\",\n                layers: [excludedLayer.id],\n                material: lightMaterial,\n                castShadows: false,\n                receiveShadows: false,\n            });\n\n            lightOmni.setLocalScale(20, 20, 20);\n            app.root.addChild(lightOmni);\n\n            // create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                fov: 100,\n                layers: [worldLayer.id, excludedLayer.id],\n                farClip: 1500,\n            });\n\n            camera.setLocalPosition(270, 90, -260);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    distanceMax: 390,\n                    frameOnStart: false,\n                },\n            });\n\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // create a probe object with cubemapRenderer script which takes care of rendering dynamic cubemap\n            const probe = new pc.Entity();\n            probe.addComponent(\"script\");\n\n            // add camera component to the probe - this defines camera properties for cubemap rendering\n            probe.addComponent(\"camera\", {\n                // optimization - no need to clear as all pixels get overwritten\n                clearColorBuffer: false,\n\n                // priority - render before world camera\n                priority: -1,\n\n                // only render meshes on the worldLayer (and not excluded layer)\n                layers: [worldLayer.id],\n\n                // disable as this is not a camera that renders cube map but only a container for properties for cube map rendering\n                enabled: false,\n\n                nearClip: 1,\n                farClip: 500,\n            });\n\n            // Add a cubemap renderer script, which renders to a cubemap of size 128 with mipmaps, which is directly useable\n            // as a lighting source for envAtlas generation\n            // Position it in the center of the room.\n            probe.script.create(\"cubemapRenderer\", {\n                attributes: {\n                    resolution: 128,\n                    mipmaps: true,\n                    depth: true,\n                },\n            });\n\n            probe.setPosition(0, 200, 0);\n            app.root.addChild(probe);\n\n            // handle onCubemapPostRender event fired by the cubemapRenderer when all faces of the cubemap are done rendering\n            probe.on(\"onCubemapPostRender\", () => {\n                // prefilter just rendered cubemap into envAtlas, so that it can be used for reflection during the rest of the frame\n                // @ts-ignore\n                pc.EnvLighting.generateAtlas(\n                    probe.script.cubemapRenderer.cubeMap,\n                    {\n                        target: envAtlas,\n                    }\n                );\n            });\n\n            // Set an update function on the app's update event\n            let time = 0;\n            let updateProbeCount = 1;\n            let updateVideo = true;\n            app.on(\"update\", function (dt) {\n                time += dt * 0.3;\n\n                // Update the video data to the texture every other frame\n                if (updateVideo && videoTexture) {\n                    videoTexture.upload();\n                }\n                updateVideo = !updateVideo;\n\n                // move the light around\n                lightOmni.setLocalPosition(\n                    300 * Math.sin(time),\n                    300,\n                    300 * Math.cos(time)\n                );\n\n                // update the reflection probe as needed\n                const updateFrequency = data.get(\"settings.updateFrequency\");\n                updateProbeCount--;\n                if (updateFrequency === 0) updateProbeCount = 1;\n\n                if (updateProbeCount <= 0) {\n                    // enable probe rendering\n                    probe.enabled = true;\n                    updateProbeCount = updateFrequency;\n                } else {\n                    probe.enabled = false;\n                }\n\n                // update material properties based on settings\n                const gloss = data.get(\"settings.gloss\");\n                const metalness = data.get(\"settings.metalness\");\n                const bumpiness = data.get(\"settings.bumpiness\");\n                const reflectivity = data.get(\"settings.reflectivity\");\n\n                roomMaterial.gloss = gloss;\n                roomMaterial.metalness = metalness;\n                roomMaterial.bumpiness = bumpiness;\n                roomMaterial.reflectivity = reflectivity;\n                roomMaterial.update();\n\n                sphereMaterial.gloss = gloss;\n                sphereMaterial.metalness = metalness;\n                sphereMaterial.bumpiness = bumpiness;\n                sphereMaterial.reflectivity = reflectivity;\n                sphereMaterial.update();\n            });\n        });\n    });\n}\n","nameSlug":"reflection-box","categorySlug":"graphics"},"reflection-cubemap":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/utils/cubemap-renderer.js' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ScriptHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // set up some general scene rendering properties\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // setup skydome\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxMip = 0;        // use top mipmap level of cubemap (full resolution)\n            app.scene.skyboxIntensity = 2;  // make it brighter\n\n            // helper function to create high polygon version of a sphere and sets up an entity to allow it to be added to the scene\n            const createHighQualitySphere = function (material: pc.Material, layer: number[]) {\n\n                // Create Entity and add it to the scene\n                const entity = new pc.Entity(\"ShinyBall\");\n                app.root.addChild(entity);\n\n                // create hight resolution sphere\n                const mesh = pc.createSphere(app.graphicsDevice, { latitudeBands: 200, longitudeBands: 200 });\n\n                // Add a render component with the mesh\n                entity.addComponent('render', {\n                    type: 'asset',\n                    layers: layer,\n                    meshInstances: [new pc.MeshInstance(mesh, material)]\n                });\n\n                return entity;\n            };\n\n            // helper function to create a primitive with shape type, position, scale, color and layer\n            function createPrimitive(primitiveType: string, position: number | pc.Vec3, scale: number | pc.Vec3, color: pc.Color, layer: number[]) {\n                // create material of specified color\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                material.gloss = 0.6;\n                material.metalness = 0.7;\n                material.useMetalness = true;\n                material.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent('render', {\n                    type: primitiveType,\n                    layers: layer,\n                    material: material\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // create a layer for object that do not render into texture\n            const excludedLayer = new pc.Layer({ name: \"Excluded\" });\n            app.scene.layers.push(excludedLayer);\n\n            // create material for the shiny ball\n            const shinyMat = new pc.StandardMaterial();\n\n            // create shiny ball mesh - this is on excluded layer as it does not render to cubemap\n            const shinyBall = createHighQualitySphere(shinyMat, [excludedLayer.id]);\n            shinyBall.setLocalPosition(0, 0, 0);\n            shinyBall.setLocalScale(10, 10, 10);\n\n            // get world and skybox layers\n            const worldLayer = app.scene.layers.getLayerByName(\"World\");\n            const skyboxLayer = app.scene.layers.getLayerByName(\"Skybox\");\n            const immediateLayer = app.scene.layers.getLayerByName(\"Immediate\");\n\n            // add camera component to shiny ball - this defines camera properties for cubemap rendering\n            shinyBall.addComponent('camera', {\n\n                // optimization - clear the surface even though all pixels are overwritten,\n                // as this has performance benefits on tiled architectures\n                clearColorBuffer: true,\n\n                // cubemap camera will render objects on world layer and also skybox\n                layers: [worldLayer.id, skyboxLayer.id],\n\n                // priority - render before world camera\n                priority: -1,\n\n                // disable as this is not a camera that renders cube map but only a container for properties for cube map rendering\n                enabled: false\n            });\n\n            // add cubemapRenderer script component which takes care of rendering dynamic cubemap\n            shinyBall.addComponent('script');\n            shinyBall.script.create('cubemapRenderer', {\n                attributes: {\n                    resolution: 256,\n                    mipmaps: true,\n                    depth: true\n                }\n            });\n\n            // finish set up of shiny material - make reflection a bit darker\n            shinyMat.diffuse = new pc.Color(0.6, 0.6, 0.6);\n\n            // use cubemap which is generated by cubemapRenderer instead of global skybox cubemap\n            shinyMat.useSkybox = false;\n            // @ts-ignore engine-tsd\n            shinyMat.cubeMap = shinyBall.script.cubemapRenderer.cubeMap;\n\n            // make it shiny without diffuse component\n            shinyMat.metalness = 1;\n            shinyMat.useMetalness = true;\n            shinyMat.update();\n\n            // create few random primitives in the world layer\n            const entities: pc.Entity[] = [];\n            const shapes = [\"box\", \"cone\", \"cylinder\", \"sphere\", \"capsule\"];\n            for (let i = 0; i < 6; i++) {\n                const shapeName = shapes[Math.floor(Math.random() * shapes.length)];\n                const color = new pc.Color(Math.random(), Math.random(), Math.random());\n                entities.push(createPrimitive(shapeName, pc.Vec3.ZERO, new pc.Vec3(3, 3, 3), color, [worldLayer.id]));\n            }\n\n            // create green plane as a base to cast shadows on\n            createPrimitive(\"plane\", new pc.Vec3(0, -8, 0), new pc.Vec3(20, 20, 20), new pc.Color(0.3, 0.5, 0.3), [worldLayer.id]);\n\n            // Create main camera, which renders entities in world, excluded and skybox layers\n            const camera = new pc.Entity(\"MainCamera\");\n            camera.addComponent(\"camera\", {\n                fov: 60,\n                layers: [worldLayer.id, excludedLayer.id, skyboxLayer.id, immediateLayer.id]\n            });\n            app.root.addChild(camera);\n\n            // Create an Entity with a directional light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n                color: pc.Color.YELLOW,\n                range: 40,\n                castShadows: true,\n                layers: [worldLayer.id],\n                shadowBias: 0.2,\n                shadowResolution: 1024,\n                normalOffsetBias: 0.05,\n                shadowDistance: 40\n            });\n            app.root.addChild(light);\n\n            // helper function to create a texture that can be used to project cubemap to\n            function createReprojectionTexture(projection: string, size: number) {\n                return new pc.Texture(app.graphicsDevice, {\n                    width: size,\n                    height: size,\n                    format: pc.PIXELFORMAT_RGB8,\n                    mipmaps: false,\n                    minFilter: pc.FILTER_LINEAR,\n                    magFilter: pc.FILTER_LINEAR,\n                    addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n                    addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n                    projection: projection\n                });\n            }\n\n            // create 2 uqirect and 2 octahedral textures\n            const textureEqui = createReprojectionTexture(pc.TEXTUREPROJECTION_EQUIRECT, 256);\n            const textureEqui2 = createReprojectionTexture(pc.TEXTUREPROJECTION_EQUIRECT, 256);\n            const textureOcta = createReprojectionTexture(pc.TEXTUREPROJECTION_OCTAHEDRAL, 64);\n            const textureOcta2 = createReprojectionTexture(pc.TEXTUREPROJECTION_OCTAHEDRAL, 32);\n\n            // create one envAtlas texture\n            const textureAtlas = createReprojectionTexture(pc.TEXTUREPROJECTION_OCTAHEDRAL, 512);\n\n            // update things each frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // rotate primitives around their center and also orbit them around the shiny sphere\n                for (let e = 0; e < entities.length; e++) {\n                    const scale = (e + 1) / entities.length;\n                    const offset = time + e * 200;\n                    entities[e].setLocalPosition(7 * Math.sin(offset), 2 * (e - 3), 7 * Math.cos(offset));\n                    entities[e].rotate(1 * scale, 2 * scale, 3 * scale);\n                }\n\n                // slowly orbit camera around\n                camera.setLocalPosition(20 * Math.cos(time * 0.2), 2, 20 * Math.sin(time * 0.2));\n                camera.lookAt(pc.Vec3.ZERO);\n\n                // project textures, and display them on the screen\n                // @ts-ignore engine-tsd\n                const srcCube = shinyBall.script.cubemapRenderer.cubeMap;\n\n                // cube -> equi1\n                pc.reprojectTexture(srcCube, textureEqui, {\n                    numSamples: 1\n                });\n                // @ts-ignore engine-tsd\n                app.drawTexture(-0.6, 0.7, 0.6, 0.3, textureEqui);\n\n                // cube -> octa1\n                pc.reprojectTexture(srcCube, textureOcta, {\n                    numSamples: 1\n                });\n                // @ts-ignore engine-tsd\n                app.drawTexture(0.7, 0.7, 0.4, 0.4, textureOcta);\n\n                // equi1 -> octa2\n                pc.reprojectTexture(textureEqui, textureOcta2, {\n                    specularPower: 32,\n                    numSamples: 1024\n                });\n                // @ts-ignore engine-tsd\n                app.drawTexture(-0.7, -0.7, 0.4, 0.4, textureOcta2);\n\n                // octa1 -> equi2\n                pc.reprojectTexture(textureOcta, textureEqui2, {\n                    specularPower: 16,\n                    numSamples: 512\n                });\n                // @ts-ignore engine-tsd\n                app.drawTexture(0.6, -0.7, 0.6, 0.3, textureEqui2);\n\n                // cube -> envAtlas\n                pc.EnvLighting.generateAtlas(srcCube, {\n                    target: textureAtlas\n                });\n                // @ts-ignore engine-tsd\n                app.drawTexture(0, -0.7, 0.5, 0.4, textureAtlas);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/utils/cubemap-renderer.js\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // set up some general scene rendering properties\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // setup skydome\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxMip = 0; // use top mipmap level of cubemap (full resolution)\n            app.scene.skyboxIntensity = 2; // make it brighter\n\n            // helper function to create high polygon version of a sphere and sets up an entity to allow it to be added to the scene\n            const createHighQualitySphere = function (material, layer) {\n                // Create Entity and add it to the scene\n                const entity = new pc.Entity(\"ShinyBall\");\n                app.root.addChild(entity);\n\n                // create hight resolution sphere\n                const mesh = pc.createSphere(app.graphicsDevice, {\n                    latitudeBands: 200,\n                    longitudeBands: 200,\n                });\n\n                // Add a render component with the mesh\n                entity.addComponent(\"render\", {\n                    type: \"asset\",\n                    layers: layer,\n                    meshInstances: [new pc.MeshInstance(mesh, material)],\n                });\n\n                return entity;\n            };\n\n            // helper function to create a primitive with shape type, position, scale, color and layer\n            function createPrimitive(\n                primitiveType,\n                position,\n                scale,\n                color,\n                layer\n            ) {\n                // create material of specified color\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                material.gloss = 0.6;\n                material.metalness = 0.7;\n                material.useMetalness = true;\n                material.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent(\"render\", {\n                    type: primitiveType,\n                    layers: layer,\n                    material: material,\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // create a layer for object that do not render into texture\n            const excludedLayer = new pc.Layer({ name: \"Excluded\" });\n            app.scene.layers.push(excludedLayer);\n\n            // create material for the shiny ball\n            const shinyMat = new pc.StandardMaterial();\n\n            // create shiny ball mesh - this is on excluded layer as it does not render to cubemap\n            const shinyBall = createHighQualitySphere(shinyMat, [\n                excludedLayer.id,\n            ]);\n            shinyBall.setLocalPosition(0, 0, 0);\n            shinyBall.setLocalScale(10, 10, 10);\n\n            // get world and skybox layers\n            const worldLayer = app.scene.layers.getLayerByName(\"World\");\n            const skyboxLayer = app.scene.layers.getLayerByName(\"Skybox\");\n            const immediateLayer = app.scene.layers.getLayerByName(\"Immediate\");\n\n            // add camera component to shiny ball - this defines camera properties for cubemap rendering\n            shinyBall.addComponent(\"camera\", {\n                // optimization - clear the surface even though all pixels are overwritten,\n                // as this has performance benefits on tiled architectures\n                clearColorBuffer: true,\n\n                // cubemap camera will render objects on world layer and also skybox\n                layers: [worldLayer.id, skyboxLayer.id],\n\n                // priority - render before world camera\n                priority: -1,\n\n                // disable as this is not a camera that renders cube map but only a container for properties for cube map rendering\n                enabled: false,\n            });\n\n            // add cubemapRenderer script component which takes care of rendering dynamic cubemap\n            shinyBall.addComponent(\"script\");\n            shinyBall.script.create(\"cubemapRenderer\", {\n                attributes: {\n                    resolution: 256,\n                    mipmaps: true,\n                    depth: true,\n                },\n            });\n\n            // finish set up of shiny material - make reflection a bit darker\n            shinyMat.diffuse = new pc.Color(0.6, 0.6, 0.6);\n\n            // use cubemap which is generated by cubemapRenderer instead of global skybox cubemap\n            shinyMat.useSkybox = false;\n            // @ts-ignore engine-tsd\n            shinyMat.cubeMap = shinyBall.script.cubemapRenderer.cubeMap;\n\n            // make it shiny without diffuse component\n            shinyMat.metalness = 1;\n            shinyMat.useMetalness = true;\n            shinyMat.update();\n\n            // create few random primitives in the world layer\n            const entities = [];\n            const shapes = [\"box\", \"cone\", \"cylinder\", \"sphere\", \"capsule\"];\n            for (let i = 0; i < 6; i++) {\n                const shapeName =\n                    shapes[Math.floor(Math.random() * shapes.length)];\n                const color = new pc.Color(\n                    Math.random(),\n                    Math.random(),\n                    Math.random()\n                );\n                entities.push(\n                    createPrimitive(\n                        shapeName,\n                        pc.Vec3.ZERO,\n                        new pc.Vec3(3, 3, 3),\n                        color,\n                        [worldLayer.id]\n                    )\n                );\n            }\n\n            // create green plane as a base to cast shadows on\n            createPrimitive(\n                \"plane\",\n                new pc.Vec3(0, -8, 0),\n                new pc.Vec3(20, 20, 20),\n                new pc.Color(0.3, 0.5, 0.3),\n                [worldLayer.id]\n            );\n\n            // Create main camera, which renders entities in world, excluded and skybox layers\n            const camera = new pc.Entity(\"MainCamera\");\n            camera.addComponent(\"camera\", {\n                fov: 60,\n                layers: [\n                    worldLayer.id,\n                    excludedLayer.id,\n                    skyboxLayer.id,\n                    immediateLayer.id,\n                ],\n            });\n\n            app.root.addChild(camera);\n\n            // Create an Entity with a directional light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n                color: pc.Color.YELLOW,\n                range: 40,\n                castShadows: true,\n                layers: [worldLayer.id],\n                shadowBias: 0.2,\n                shadowResolution: 1024,\n                normalOffsetBias: 0.05,\n                shadowDistance: 40,\n            });\n\n            app.root.addChild(light);\n\n            // helper function to create a texture that can be used to project cubemap to\n            function createReprojectionTexture(projection, size) {\n                return new pc.Texture(app.graphicsDevice, {\n                    width: size,\n                    height: size,\n                    format: pc.PIXELFORMAT_RGB8,\n                    mipmaps: false,\n                    minFilter: pc.FILTER_LINEAR,\n                    magFilter: pc.FILTER_LINEAR,\n                    addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n                    addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n                    projection: projection,\n                });\n            }\n\n            // create 2 uqirect and 2 octahedral textures\n            const textureEqui = createReprojectionTexture(\n                pc.TEXTUREPROJECTION_EQUIRECT,\n                256\n            );\n            const textureEqui2 = createReprojectionTexture(\n                pc.TEXTUREPROJECTION_EQUIRECT,\n                256\n            );\n            const textureOcta = createReprojectionTexture(\n                pc.TEXTUREPROJECTION_OCTAHEDRAL,\n                64\n            );\n            const textureOcta2 = createReprojectionTexture(\n                pc.TEXTUREPROJECTION_OCTAHEDRAL,\n                32\n            );\n\n            // create one envAtlas texture\n            const textureAtlas = createReprojectionTexture(\n                pc.TEXTUREPROJECTION_OCTAHEDRAL,\n                512\n            );\n\n            // update things each frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // rotate primitives around their center and also orbit them around the shiny sphere\n                for (let e = 0; e < entities.length; e++) {\n                    const scale = (e + 1) / entities.length;\n                    const offset = time + e * 200;\n                    entities[e].setLocalPosition(\n                        7 * Math.sin(offset),\n                        2 * (e - 3),\n                        7 * Math.cos(offset)\n                    );\n                    entities[e].rotate(1 * scale, 2 * scale, 3 * scale);\n                }\n\n                // slowly orbit camera around\n                camera.setLocalPosition(\n                    20 * Math.cos(time * 0.2),\n                    2,\n                    20 * Math.sin(time * 0.2)\n                );\n                camera.lookAt(pc.Vec3.ZERO);\n\n                // project textures, and display them on the screen\n                // @ts-ignore engine-tsd\n                const srcCube = shinyBall.script.cubemapRenderer.cubeMap;\n\n                // cube -> equi1\n                pc.reprojectTexture(srcCube, textureEqui, {\n                    numSamples: 1,\n                });\n\n                // @ts-ignore engine-tsd\n                app.drawTexture(-0.6, 0.7, 0.6, 0.3, textureEqui);\n\n                // cube -> octa1\n                pc.reprojectTexture(srcCube, textureOcta, {\n                    numSamples: 1,\n                });\n\n                // @ts-ignore engine-tsd\n                app.drawTexture(0.7, 0.7, 0.4, 0.4, textureOcta);\n\n                // equi1 -> octa2\n                pc.reprojectTexture(textureEqui, textureOcta2, {\n                    specularPower: 32,\n                    numSamples: 1024,\n                });\n\n                // @ts-ignore engine-tsd\n                app.drawTexture(-0.7, -0.7, 0.4, 0.4, textureOcta2);\n\n                // octa1 -> equi2\n                pc.reprojectTexture(textureOcta, textureEqui2, {\n                    specularPower: 16,\n                    numSamples: 512,\n                });\n\n                // @ts-ignore engine-tsd\n                app.drawTexture(0.6, -0.7, 0.6, 0.3, textureEqui2);\n\n                // cube -> envAtlas\n                pc.EnvLighting.generateAtlas(srcCube, {\n                    target: textureAtlas,\n                });\n\n                // @ts-ignore engine-tsd\n                app.drawTexture(0, -0.7, 0.5, 0.4, textureAtlas);\n            });\n        });\n    });\n}\n","nameSlug":"reflection-cubemap","categorySlug":"graphics"},"reflection-planar":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, files: { 'shader.vert': string, 'shader.frag': string }): void {\n\n    const assets = {\n        envatlas: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/dancing-hall-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' }),\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/utils/planar-renderer.js' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // set up some general scene rendering properties\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // setup skydome\n            app.scene.envAtlas = assets.envatlas.resource;\n            app.scene.skyboxMip = 1;\n            app.scene.skyboxIntensity = 1.2;  // make it brighter\n\n            // helper function to create a primitive with shape type, position, scale, color and layer\n            function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3, color: pc.Color, layer: number[], material: pc.Material | pc.StandardMaterial = null) {\n\n                // create material of specified color\n                if (!material) {\n                    const standardMaterial = new pc.StandardMaterial();\n                    standardMaterial.diffuse = color;\n                    standardMaterial.gloss = 0.6;\n                    standardMaterial.metalness = 0.7;\n                    standardMaterial.useMetalness = true;\n                    standardMaterial.update();\n                    material = standardMaterial;\n                }\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent('render', {\n                    type: primitiveType,\n                    layers: layer,\n                    material: material\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // create a layer for objects that do not render into texture\n            const excludedLayer = new pc.Layer({ name: \"Excluded\" });\n            app.scene.layers.push(excludedLayer);\n\n            // get world and skybox layers\n            const worldLayer = app.scene.layers.getLayerByName(\"World\");\n            const skyboxLayer = app.scene.layers.getLayerByName(\"Skybox\");\n\n            // Create the shader from the vertex and fragment shaders\n            const shader = pc.createShaderFromCode(app.graphicsDevice, files['shader.vert'], files['shader.frag'], 'myShader', {\n                aPosition: pc.SEMANTIC_POSITION,\n                aUv0: pc.SEMANTIC_TEXCOORD0\n            });\n\n            // reflective ground\n            // This is in the excluded layer so it does not render into reflection texture\n            const groundMaterial = new pc.Material();\n            groundMaterial.shader = shader;\n            createPrimitive(\"plane\", new pc.Vec3(0, 0, 0), new pc.Vec3(40, 1, 40), new pc.Color(0.5, 0.5, 0.5), [excludedLayer.id], groundMaterial);\n\n            // get the instance of the statue and set up with render component\n            const statueEntity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(statueEntity);\n\n            // create few random primitives in the world layer\n            const entities: pc.Entity[] = [];\n            const shapes = [\"box\", \"cone\", \"cylinder\", \"sphere\", \"capsule\"];\n            for (let i = 0; i < 6; i++) {\n                const shapeName = shapes[Math.floor(Math.random() * shapes.length)];\n                const color = new pc.Color(Math.random(), Math.random(), Math.random());\n                entities.push(createPrimitive(shapeName, pc.Vec3.ZERO, new pc.Vec3(3, 3, 3), color, [worldLayer.id]));\n            }\n\n            // Create main camera, which renders entities in world, excluded and skybox layers\n            const camera = new pc.Entity(\"MainCamera\");\n            camera.addComponent(\"camera\", {\n                fov: 60,\n                layers: [worldLayer.id, excludedLayer.id, skyboxLayer.id]\n            });\n            app.root.addChild(camera);\n\n            // create reflection camera, which renders entities in world and skybox layers only\n            const reflectionCamera = new pc.Entity(\"ReflectionCamera\");\n            reflectionCamera.addComponent(\"camera\", {\n                fov: 60,\n                layers: [worldLayer.id, skyboxLayer.id],\n                priority: -1    // render reflections before the main camera\n            });\n\n            // add planarRenderer script which renders the reflection texture\n            reflectionCamera.addComponent('script');\n            reflectionCamera.script.create('planarRenderer', {\n                attributes: {\n                    sceneCameraEntity: camera,\n                    scale: 1,\n                    mipmaps: false,\n                    depth: true,\n                    planePoint: pc.Vec3.ZERO,\n                    planeNormal: pc.Vec3.UP\n                }\n            });\n            app.root.addChild(reflectionCamera);\n\n            // update things each frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // rotate primitives around their center and also orbit them around the shiny sphere\n                for (let e = 0; e < entities.length; e++) {\n                    const scale = (e + 1) / entities.length;\n                    const offset = time + e * 200;\n                    entities[e].setLocalPosition(7 * Math.sin(offset), e + 5, 7 * Math.cos(offset));\n                    entities[e].rotate(1 * scale, 2 * scale, 3 * scale);\n                }\n\n                // slowly orbit camera around\n                camera.setLocalPosition(30 * Math.cos(time * 0.2), 10, 30 * Math.sin(time * 0.2));\n                camera.lookAt(pc.Vec3.ZERO);\n\n                // animate FOV\n                camera.camera.fov = 60 + 20 * Math.sin(time * 0.5);\n\n                // trigger reflection camera update (must be called after all parameters of the main camera are updated)\n                // @ts-ignore engine-tsd\n                const reflectionTexture = reflectionCamera.script.planarRenderer.frameUpdate();\n                groundMaterial.setParameter('uDiffuseMap', reflectionTexture);\n                groundMaterial.update();\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, files) {\n    const assets = {\n        envatlas: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/dancing-hall-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/utils/planar-renderer.js\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // set up some general scene rendering properties\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // setup skydome\n            app.scene.envAtlas = assets.envatlas.resource;\n            app.scene.skyboxMip = 1;\n            app.scene.skyboxIntensity = 1.2; // make it brighter\n\n            // helper function to create a primitive with shape type, position, scale, color and layer\n            function createPrimitive(\n                primitiveType,\n                position,\n                scale,\n                color,\n                layer,\n                material = null\n            ) {\n                // create material of specified color\n                if (!material) {\n                    const standardMaterial = new pc.StandardMaterial();\n                    standardMaterial.diffuse = color;\n                    standardMaterial.gloss = 0.6;\n                    standardMaterial.metalness = 0.7;\n                    standardMaterial.useMetalness = true;\n                    standardMaterial.update();\n                    material = standardMaterial;\n                }\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent(\"render\", {\n                    type: primitiveType,\n                    layers: layer,\n                    material: material,\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // create a layer for objects that do not render into texture\n            const excludedLayer = new pc.Layer({ name: \"Excluded\" });\n            app.scene.layers.push(excludedLayer);\n\n            // get world and skybox layers\n            const worldLayer = app.scene.layers.getLayerByName(\"World\");\n            const skyboxLayer = app.scene.layers.getLayerByName(\"Skybox\");\n\n            // Create the shader from the vertex and fragment shaders\n            const shader = pc.createShaderFromCode(\n                app.graphicsDevice,\n                files[\"shader.vert\"],\n                files[\"shader.frag\"],\n                \"myShader\",\n                {\n                    aPosition: pc.SEMANTIC_POSITION,\n                    aUv0: pc.SEMANTIC_TEXCOORD0,\n                }\n            );\n\n            // reflective ground\n            // This is in the excluded layer so it does not render into reflection texture\n            const groundMaterial = new pc.Material();\n            groundMaterial.shader = shader;\n            createPrimitive(\n                \"plane\",\n                new pc.Vec3(0, 0, 0),\n                new pc.Vec3(40, 1, 40),\n                new pc.Color(0.5, 0.5, 0.5),\n                [excludedLayer.id],\n                groundMaterial\n            );\n\n            // get the instance of the statue and set up with render component\n            const statueEntity =\n                assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(statueEntity);\n\n            // create few random primitives in the world layer\n            const entities = [];\n            const shapes = [\"box\", \"cone\", \"cylinder\", \"sphere\", \"capsule\"];\n            for (let i = 0; i < 6; i++) {\n                const shapeName =\n                    shapes[Math.floor(Math.random() * shapes.length)];\n                const color = new pc.Color(\n                    Math.random(),\n                    Math.random(),\n                    Math.random()\n                );\n                entities.push(\n                    createPrimitive(\n                        shapeName,\n                        pc.Vec3.ZERO,\n                        new pc.Vec3(3, 3, 3),\n                        color,\n                        [worldLayer.id]\n                    )\n                );\n            }\n\n            // Create main camera, which renders entities in world, excluded and skybox layers\n            const camera = new pc.Entity(\"MainCamera\");\n            camera.addComponent(\"camera\", {\n                fov: 60,\n                layers: [worldLayer.id, excludedLayer.id, skyboxLayer.id],\n            });\n\n            app.root.addChild(camera);\n\n            // create reflection camera, which renders entities in world and skybox layers only\n            const reflectionCamera = new pc.Entity(\"ReflectionCamera\");\n            reflectionCamera.addComponent(\"camera\", {\n                fov: 60,\n                layers: [worldLayer.id, skyboxLayer.id],\n                priority: -1, // render reflections before the main camera\n            });\n\n            // add planarRenderer script which renders the reflection texture\n            reflectionCamera.addComponent(\"script\");\n            reflectionCamera.script.create(\"planarRenderer\", {\n                attributes: {\n                    sceneCameraEntity: camera,\n                    scale: 1,\n                    mipmaps: false,\n                    depth: true,\n                    planePoint: pc.Vec3.ZERO,\n                    planeNormal: pc.Vec3.UP,\n                },\n            });\n\n            app.root.addChild(reflectionCamera);\n\n            // update things each frame\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // rotate primitives around their center and also orbit them around the shiny sphere\n                for (let e = 0; e < entities.length; e++) {\n                    const scale = (e + 1) / entities.length;\n                    const offset = time + e * 200;\n                    entities[e].setLocalPosition(\n                        7 * Math.sin(offset),\n                        e + 5,\n                        7 * Math.cos(offset)\n                    );\n                    entities[e].rotate(1 * scale, 2 * scale, 3 * scale);\n                }\n\n                // slowly orbit camera around\n                camera.setLocalPosition(\n                    30 * Math.cos(time * 0.2),\n                    10,\n                    30 * Math.sin(time * 0.2)\n                );\n                camera.lookAt(pc.Vec3.ZERO);\n\n                // animate FOV\n                camera.camera.fov = 60 + 20 * Math.sin(time * 0.5);\n\n                // trigger reflection camera update (must be called after all parameters of the main camera are updated)\n                // @ts-ignore engine-tsd\n                const reflectionTexture =\n                    reflectionCamera.script.planarRenderer.frameUpdate();\n                groundMaterial.setParameter(\"uDiffuseMap\", reflectionTexture);\n                groundMaterial.update();\n            });\n        });\n    });\n}\n","nameSlug":"reflection-planar","categorySlug":"graphics","files":{"shader.vert":"\n            attribute vec3 aPosition;\n            attribute vec2 aUv0;\n\n            uniform mat4 matrix_model;\n            uniform mat4 matrix_viewProjection;\n\n            void main(void)\n            {\n                gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, 1.0);;\n            }","shader.frag":"\n\n            // engine built-in constant storing render target size in .xy and inverse size in .zw\n            uniform vec4 uScreenSize;\n\n            // reflection texture\n            uniform sampler2D uDiffuseMap;\n\n            void main(void)\n            {\n                // sample reflection texture\n                vec2 coord = gl_FragCoord.xy * uScreenSize.zw;\n                coord.y = 1.0 - coord.y;\n                vec4 reflection = texture2D(uDiffuseMap, coord);\n\n                gl_FragColor = vec4(reflection.xyz * 0.7, 1);\n            }"}},"render-asset":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'helipad': new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' }),\n        'cube': new pc.Asset('cube', 'container', { url: '/static/assets/models/playcanvas-cube.glb' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            const cubeEntities: pc.Entity[] = [];\n\n            // get the instance of the cube it set up with render component and add it to scene\n            cubeEntities[0] = assets.cube.resource.instantiateRenderEntity();\n            cubeEntities[0].setLocalPosition(7, 12, 0);\n            cubeEntities[0].setLocalScale(3, 3, 3);\n            app.root.addChild(cubeEntities[0]);\n\n            // clone another copy of it and add it to scene\n            cubeEntities[1] = cubeEntities[0].clone() as pc.Entity;\n            cubeEntities[1].setLocalPosition(-7, 12, 0);\n            cubeEntities[1].setLocalScale(3, 3, 3);\n            app.root.addChild(cubeEntities[1]);\n\n            // get the instance of the statue and set up with render component\n            const statueEntity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(statueEntity);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.1, 0.1),\n                farClip: 100\n            });\n            camera.translate(-20, 15, 20);\n            camera.lookAt(0, 7, 0);\n            app.root.addChild(camera);\n\n            // set skybox\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.skyboxMip = 1;\n\n            // spin the meshes\n            app.on(\"update\", function (dt) {\n\n                if (cubeEntities[0]) {\n                    cubeEntities[0].rotate(3 * dt, 10 * dt, 6 * dt);\n                }\n\n                if (cubeEntities[1]) {\n                    cubeEntities[1].rotate(-7 * dt, 5 * dt, -2 * dt);\n                }\n\n                if (statueEntity) {\n                    statueEntity.rotate(0, -12 * dt, 0);\n                }\n\n            });\n        });\n    }).catch(console.error);\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n        cube: new pc.Asset(\"cube\", \"container\", {\n            url: \"/static/assets/models/playcanvas-cube.glb\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions)\n        .then((device) => {\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.RenderComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.LightComponentSystem,\n            ];\n\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.ContainerHandler,\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assetListLoader = new pc.AssetListLoader(\n                Object.values(assets),\n                app.assets\n            );\n            assetListLoader.load(() => {\n                app.start();\n\n                const cubeEntities = [];\n\n                // get the instance of the cube it set up with render component and add it to scene\n                cubeEntities[0] =\n                    assets.cube.resource.instantiateRenderEntity();\n                cubeEntities[0].setLocalPosition(7, 12, 0);\n                cubeEntities[0].setLocalScale(3, 3, 3);\n                app.root.addChild(cubeEntities[0]);\n\n                // clone another copy of it and add it to scene\n                cubeEntities[1] = cubeEntities[0].clone();\n                cubeEntities[1].setLocalPosition(-7, 12, 0);\n                cubeEntities[1].setLocalScale(3, 3, 3);\n                app.root.addChild(cubeEntities[1]);\n\n                // get the instance of the statue and set up with render component\n                const statueEntity =\n                    assets.statue.resource.instantiateRenderEntity();\n                app.root.addChild(statueEntity);\n\n                // Create an Entity with a camera component\n                const camera = new pc.Entity();\n                camera.addComponent(\"camera\", {\n                    clearColor: new pc.Color(0.2, 0.1, 0.1),\n                    farClip: 100,\n                });\n\n                camera.translate(-20, 15, 20);\n                camera.lookAt(0, 7, 0);\n                app.root.addChild(camera);\n\n                // set skybox\n                app.scene.envAtlas = assets.helipad.resource;\n                app.scene.toneMapping = pc.TONEMAP_ACES;\n                app.scene.skyboxMip = 1;\n\n                // spin the meshes\n                app.on(\"update\", function (dt) {\n                    if (cubeEntities[0]) {\n                        cubeEntities[0].rotate(3 * dt, 10 * dt, 6 * dt);\n                    }\n\n                    if (cubeEntities[1]) {\n                        cubeEntities[1].rotate(-7 * dt, 5 * dt, -2 * dt);\n                    }\n\n                    if (statueEntity) {\n                        statueEntity.rotate(0, -12 * dt, 0);\n                    }\n                });\n            });\n        })\n        .catch(console.error);\n}\n","nameSlug":"render-asset","categorySlug":"graphics"},"render-to-texture":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // Overview:\n    // There are 3 layers used:\n    // - worldLayer - it contains objects that render into main camera and also into texture\n    // - excludedLayer - it contains objects that are excluded from rendering into texture and so render only into main camera\n    // - skyboxLayer - it contains skybox and renders into both main and texture camera\n    // There are two cameras:\n    // - textureCamera - this camera renders into texture, objects from World and also Skybox layers\n    // - camera - this camera renders into main framebuffer, objects from World, Excluded and also Skybox layers\n\n    const assets = {\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.ParticleSystemComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ScriptHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // helper function to create a primitive with shape type, position, scale, color and layer\n            function createPrimitive(primitiveType: string, position: number | pc.Vec3, scale: number | pc.Vec3, color: pc.Color, layer: number[]) {\n                // create material of specified color\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                material.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent('render', {\n                    type: primitiveType,\n                    layers: layer,\n                    material: material\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // helper function to create a basic particle system\n            function createParticleSystem(position: pc.Vec3) {\n\n                // make particles move in different directions\n                const localVelocityCurve = new pc.CurveSet([\n                    [0, 0, 0.5, 8],\n                    [0, 0, 0.5, 8],\n                    [0, 0, 0.5, 8]\n                ]);\n                const localVelocityCurve2 = new pc.CurveSet([\n                    [0, 0, 0.5, -8],\n                    [0, 0, 0.5, -8],\n                    [0, 0, 0.5, -8]\n                ]);\n\n                // increasing gravity\n                const worldVelocityCurve = new pc.CurveSet([\n                    [0, 0],\n                    [0, 0, 0.2, 6, 1, -48],\n                    [0, 0]\n                ]);\n\n                // Create entity for particle system\n                const entity = new pc.Entity();\n                app.root.addChild(entity);\n                entity.setLocalPosition(position);\n\n                // add particlesystem component to entity\n                entity.addComponent(\"particlesystem\", {\n                    numParticles: 200,\n                    lifetime: 1,\n                    rate: 0.01,\n                    scaleGraph: new pc.Curve([0, 0.5]),\n                    velocityGraph: worldVelocityCurve,\n                    localVelocityGraph: localVelocityCurve,\n                    localVelocityGraph2: localVelocityCurve2\n                });\n            }\n\n            // create texture and render target for rendering into, including depth buffer\n            const texture = new pc.Texture(app.graphicsDevice, {\n                width: 512,\n                height: 256,\n                format: pc.PIXELFORMAT_RGB8,\n                mipmaps: true,\n                minFilter: pc.FILTER_LINEAR,\n                magFilter: pc.FILTER_LINEAR,\n                addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n                addressV: pc.ADDRESS_CLAMP_TO_EDGE\n            });\n            const renderTarget = new pc.RenderTarget({\n                name: `RT`,\n                colorBuffer: texture,\n                depth: true,\n                flipY: true,\n                samples: 2\n            });\n\n            // create a layer for object that do not render into texture, add it right after the world layer\n            const excludedLayer = new pc.Layer({ name: \"Excluded\" });\n            app.scene.layers.insert(excludedLayer, 1);\n\n            // get world and skybox layers\n            const worldLayer = app.scene.layers.getLayerByName(\"World\");\n            const skyboxLayer = app.scene.layers.getLayerByName(\"Skybox\");\n\n            // create ground plane and 3 primitives, visible in world layer\n            const plane = createPrimitive(\"plane\", new pc.Vec3(0, 0, 0), new pc.Vec3(20, 20, 20), new pc.Color(0.2, 0.4, 0.2), [worldLayer.id]);\n            createPrimitive(\"sphere\", new pc.Vec3(-2, 1, 0), new pc.Vec3(2, 2, 2), pc.Color.RED, [worldLayer.id]);\n            createPrimitive(\"cone\", new pc.Vec3(0, 1, -2), new pc.Vec3(2, 2, 2), pc.Color.CYAN, [worldLayer.id]);\n            createPrimitive(\"box\", new pc.Vec3(2, 1, 0), new pc.Vec3(2, 2, 2), pc.Color.YELLOW, [worldLayer.id]);\n\n            // particle system\n            createParticleSystem(new pc.Vec3(2, 3, 0));\n\n            // Create main camera, which renders entities in world, excluded and skybox layers\n            const camera = new pc.Entity(\"Camera\");\n            camera.addComponent(\"camera\", {\n                fov: 100,\n                layers: [worldLayer.id, excludedLayer.id, skyboxLayer.id]\n            });\n            camera.translate(0, 9, 15);\n            camera.lookAt(1, 4, 0);\n            app.root.addChild(camera);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: plane,\n                    distanceMax: 20,\n                    frameOnStart: false\n                }\n            });\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n\n            // Create texture camera, which renders entities in world and skybox layers into the texture\n            const textureCamera = new pc.Entity(\"TextureCamera\");\n            textureCamera.addComponent(\"camera\", {\n                layers: [worldLayer.id, skyboxLayer.id],\n\n                // set the priority of textureCamera to lower number than the priority of the main camera (which is at default 0)\n                // to make it rendered first each frame\n                priority: -1,\n\n                // this camera renders into texture target\n                renderTarget: renderTarget\n            });\n\n            // add sphere at the position of this camera to see it in the world\n            textureCamera.addComponent(\"render\", {\n                type: \"sphere\"\n            });\n            app.root.addChild(textureCamera);\n\n            // Create an Entity with a omni light component and add it to world layer (and so used by both cameras)\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: pc.Color.WHITE,\n                range: 200,\n                castShadows: true,\n                layers: [worldLayer.id]\n            });\n            light.translate(0, 2, 5);\n            app.root.addChild(light);\n\n            // create a plane called tv which we use to display rendered texture\n            // this is only added to excluded Layer, so it does not render into texture\n            const tv = createPrimitive(\"plane\", new pc.Vec3(6, 8, -5), new pc.Vec3(20, 10, 10), pc.Color.BLACK, [excludedLayer.id]);\n            tv.setLocalEulerAngles(90, 0, 0);\n            tv.render.castShadows = false;\n            tv.render.receiveShadows = false;\n            const material = tv.render.material as pc.StandardMaterial;\n            material.emissiveMap = texture;     // assign the rendered texture as an emissive texture\n            material.update();\n\n            // setup skydome, use top mipmap level of cubemap (full resolution)\n            app.scene.skyboxMip = 0;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // update things each frame\n            let time = 0;\n            let switchTime = 0;\n            app.on(\"update\", function (dt) {\n                // rotate texture camera around the objects\n                time += dt;\n                textureCamera.setLocalPosition(12 * Math.sin(time), 3, 12 * Math.cos(time));\n                textureCamera.lookAt(pc.Vec3.ZERO);\n\n                // every 5 seconds switch texture camera between perspective and orthographic projection\n                switchTime += dt;\n                if (switchTime > 5) {\n                    switchTime = 0;\n                    if (textureCamera.camera.projection === pc.PROJECTION_ORTHOGRAPHIC) {\n                        textureCamera.camera.projection = pc.PROJECTION_PERSPECTIVE;\n                    } else {\n                        textureCamera.camera.projection = pc.PROJECTION_ORTHOGRAPHIC;\n                        textureCamera.camera.orthoHeight = 5;\n                    }\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Overview:\n    // There are 3 layers used:\n    // - worldLayer - it contains objects that render into main camera and also into texture\n    // - excludedLayer - it contains objects that are excluded from rendering into texture and so render only into main camera\n    // - skyboxLayer - it contains skybox and renders into both main and texture camera\n    // There are two cameras:\n    // - textureCamera - this camera renders into texture, objects from World and also Skybox layers\n    // - camera - this camera renders into main framebuffer, objects from World, Excluded and also Skybox layers\n\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/orbit-camera.js\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n            // @ts-ignore\n            pc.ParticleSystemComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // helper function to create a primitive with shape type, position, scale, color and layer\n            function createPrimitive(\n                primitiveType,\n                position,\n                scale,\n                color,\n                layer\n            ) {\n                // create material of specified color\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                material.update();\n\n                // create primitive\n                const primitive = new pc.Entity();\n                primitive.addComponent(\"render\", {\n                    type: primitiveType,\n                    layers: layer,\n                    material: material,\n                });\n\n                // set position and scale and add it to scene\n                primitive.setLocalPosition(position);\n                primitive.setLocalScale(scale);\n                app.root.addChild(primitive);\n\n                return primitive;\n            }\n\n            // helper function to create a basic particle system\n            function createParticleSystem(position) {\n                // make particles move in different directions\n                const localVelocityCurve = new pc.CurveSet([\n                    [0, 0, 0.5, 8],\n                    [0, 0, 0.5, 8],\n                    [0, 0, 0.5, 8],\n                ]);\n\n                const localVelocityCurve2 = new pc.CurveSet([\n                    [0, 0, 0.5, -8],\n                    [0, 0, 0.5, -8],\n                    [0, 0, 0.5, -8],\n                ]);\n\n                // increasing gravity\n                const worldVelocityCurve = new pc.CurveSet([\n                    [0, 0],\n                    [0, 0, 0.2, 6, 1, -48],\n                    [0, 0],\n                ]);\n\n                // Create entity for particle system\n                const entity = new pc.Entity();\n                app.root.addChild(entity);\n                entity.setLocalPosition(position);\n\n                // add particlesystem component to entity\n                entity.addComponent(\"particlesystem\", {\n                    numParticles: 200,\n                    lifetime: 1,\n                    rate: 0.01,\n                    scaleGraph: new pc.Curve([0, 0.5]),\n                    velocityGraph: worldVelocityCurve,\n                    localVelocityGraph: localVelocityCurve,\n                    localVelocityGraph2: localVelocityCurve2,\n                });\n            }\n\n            // create texture and render target for rendering into, including depth buffer\n            const texture = new pc.Texture(app.graphicsDevice, {\n                width: 512,\n                height: 256,\n                format: pc.PIXELFORMAT_RGB8,\n                mipmaps: true,\n                minFilter: pc.FILTER_LINEAR,\n                magFilter: pc.FILTER_LINEAR,\n                addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n                addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n            });\n\n            const renderTarget = new pc.RenderTarget({\n                name: `RT`,\n                colorBuffer: texture,\n                depth: true,\n                flipY: true,\n                samples: 2,\n            });\n\n            // create a layer for object that do not render into texture, add it right after the world layer\n            const excludedLayer = new pc.Layer({ name: \"Excluded\" });\n            app.scene.layers.insert(excludedLayer, 1);\n\n            // get world and skybox layers\n            const worldLayer = app.scene.layers.getLayerByName(\"World\");\n            const skyboxLayer = app.scene.layers.getLayerByName(\"Skybox\");\n\n            // create ground plane and 3 primitives, visible in world layer\n            const plane = createPrimitive(\n                \"plane\",\n                new pc.Vec3(0, 0, 0),\n                new pc.Vec3(20, 20, 20),\n                new pc.Color(0.2, 0.4, 0.2),\n                [worldLayer.id]\n            );\n            createPrimitive(\n                \"sphere\",\n                new pc.Vec3(-2, 1, 0),\n                new pc.Vec3(2, 2, 2),\n                pc.Color.RED,\n                [worldLayer.id]\n            );\n            createPrimitive(\n                \"cone\",\n                new pc.Vec3(0, 1, -2),\n                new pc.Vec3(2, 2, 2),\n                pc.Color.CYAN,\n                [worldLayer.id]\n            );\n            createPrimitive(\n                \"box\",\n                new pc.Vec3(2, 1, 0),\n                new pc.Vec3(2, 2, 2),\n                pc.Color.YELLOW,\n                [worldLayer.id]\n            );\n\n            // particle system\n            createParticleSystem(new pc.Vec3(2, 3, 0));\n\n            // Create main camera, which renders entities in world, excluded and skybox layers\n            const camera = new pc.Entity(\"Camera\");\n            camera.addComponent(\"camera\", {\n                fov: 100,\n                layers: [worldLayer.id, excludedLayer.id, skyboxLayer.id],\n            });\n\n            camera.translate(0, 9, 15);\n            camera.lookAt(1, 4, 0);\n            app.root.addChild(camera);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: plane,\n                    distanceMax: 20,\n                    frameOnStart: false,\n                },\n            });\n\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n\n            // Create texture camera, which renders entities in world and skybox layers into the texture\n            const textureCamera = new pc.Entity(\"TextureCamera\");\n            textureCamera.addComponent(\"camera\", {\n                layers: [worldLayer.id, skyboxLayer.id],\n\n                // set the priority of textureCamera to lower number than the priority of the main camera (which is at default 0)\n                // to make it rendered first each frame\n                priority: -1,\n\n                // this camera renders into texture target\n                renderTarget: renderTarget,\n            });\n\n            // add sphere at the position of this camera to see it in the world\n            textureCamera.addComponent(\"render\", {\n                type: \"sphere\",\n            });\n\n            app.root.addChild(textureCamera);\n\n            // Create an Entity with a omni light component and add it to world layer (and so used by both cameras)\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: pc.Color.WHITE,\n                range: 200,\n                castShadows: true,\n                layers: [worldLayer.id],\n            });\n\n            light.translate(0, 2, 5);\n            app.root.addChild(light);\n\n            // create a plane called tv which we use to display rendered texture\n            // this is only added to excluded Layer, so it does not render into texture\n            const tv = createPrimitive(\n                \"plane\",\n                new pc.Vec3(6, 8, -5),\n                new pc.Vec3(20, 10, 10),\n                pc.Color.BLACK,\n                [excludedLayer.id]\n            );\n            tv.setLocalEulerAngles(90, 0, 0);\n            tv.render.castShadows = false;\n            tv.render.receiveShadows = false;\n            const material = tv.render.material;\n            material.emissiveMap = texture; // assign the rendered texture as an emissive texture\n            material.update();\n\n            // setup skydome, use top mipmap level of cubemap (full resolution)\n            app.scene.skyboxMip = 0;\n            app.scene.envAtlas = assets.helipad.resource;\n\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // update things each frame\n            let time = 0;\n            let switchTime = 0;\n            app.on(\"update\", function (dt) {\n                // rotate texture camera around the objects\n                time += dt;\n                textureCamera.setLocalPosition(\n                    12 * Math.sin(time),\n                    3,\n                    12 * Math.cos(time)\n                );\n                textureCamera.lookAt(pc.Vec3.ZERO);\n\n                // every 5 seconds switch texture camera between perspective and orthographic projection\n                switchTime += dt;\n                if (switchTime > 5) {\n                    switchTime = 0;\n                    if (\n                        textureCamera.camera.projection ===\n                        pc.PROJECTION_ORTHOGRAPHIC\n                    ) {\n                        textureCamera.camera.projection =\n                            pc.PROJECTION_PERSPECTIVE;\n                    } else {\n                        textureCamera.camera.projection =\n                            pc.PROJECTION_ORTHOGRAPHIC;\n                        textureCamera.camera.orthoHeight = 5;\n                    }\n                }\n            });\n        });\n    });\n}\n","nameSlug":"render-to-texture","categorySlug":"graphics"},"shader-burn":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, files: { 'shader.vert': string, 'shader.frag': string }): void {\n\n    const assets = {\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' }),\n        'clouds': new pc.Asset('clouds', 'texture', { url: '/static/assets/textures/clouds.jpg' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5)\n            });\n            camera.translate(0, 7, 24);\n\n            // Create an Entity with a omni light component and a sphere model component.\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(1, 1, 1),\n                radius: 10\n            });\n            light.translate(0, 1, 0);\n\n            // Add entities into scene hierarchy\n            app.root.addChild(camera);\n            app.root.addChild(light);\n\n            // Create the shader from the vertex and fragment shaders\n            const shader = pc.createShaderFromCode(app.graphicsDevice, files['shader.vert'], files['shader.frag'], 'myShader', {\n                aPosition: pc.SEMANTIC_POSITION,\n                aUv0: pc.SEMANTIC_TEXCOORD0\n            });\n\n            // Create a new material with the new shader\n            const material = new pc.Material();\n            material.shader = shader;\n            material.setParameter('uHeightMap', assets.clouds.resource);\n\n            // create a hierarchy of entities with render components, representing the statue model\n            const entity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            // Set the new material on all meshes in the model, and use original texture from the model on the new material\n            let originalTexture:pc.Texture = null;\n            const renders: Array<pc.RenderComponent> = entity.findComponents(\"render\");\n            renders.forEach((render) => {\n                const meshInstances = render.meshInstances;\n                for (let i = 0; i < meshInstances.length; i++) {\n                    const meshInstance = meshInstances[i];\n                    if (!originalTexture) {\n                        const originalMaterial = meshInstance.material as pc.StandardMaterial;\n                        originalTexture = originalMaterial.diffuseMap;\n                    }\n                    meshInstance.material = material;\n                }\n            });\n\n            // material is set up, update it\n            material.setParameter('uDiffuseMap', originalTexture);\n            material.update();\n\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += 0.2 * dt;\n\n                // reverse time\n                let t = time % 2;\n                if (t > 1) {\n                    t = 1 - (t - 1);\n                }\n\n                // set time parameter for the shader\n                material.setParameter('uTime', t);\n                material.update();\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, files) {\n    const assets = {\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n        clouds: new pc.Asset(\"clouds\", \"texture\", {\n            url: \"/static/assets/textures/clouds.jpg\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n            });\n\n            camera.translate(0, 7, 24);\n\n            // Create an Entity with a omni light component and a sphere model component.\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(1, 1, 1),\n                radius: 10,\n            });\n\n            light.translate(0, 1, 0);\n\n            // Add entities into scene hierarchy\n            app.root.addChild(camera);\n            app.root.addChild(light);\n\n            // Create the shader from the vertex and fragment shaders\n            const shader = pc.createShaderFromCode(\n                app.graphicsDevice,\n                files[\"shader.vert\"],\n                files[\"shader.frag\"],\n                \"myShader\",\n                {\n                    aPosition: pc.SEMANTIC_POSITION,\n                    aUv0: pc.SEMANTIC_TEXCOORD0,\n                }\n            );\n\n            // Create a new material with the new shader\n            const material = new pc.Material();\n            material.shader = shader;\n            material.setParameter(\"uHeightMap\", assets.clouds.resource);\n\n            // create a hierarchy of entities with render components, representing the statue model\n            const entity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            // Set the new material on all meshes in the model, and use original texture from the model on the new material\n            let originalTexture = null;\n            const renders = entity.findComponents(\"render\");\n            renders.forEach((render) => {\n                const meshInstances = render.meshInstances;\n                for (let i = 0; i < meshInstances.length; i++) {\n                    const meshInstance = meshInstances[i];\n                    if (!originalTexture) {\n                        const originalMaterial = meshInstance.material;\n                        originalTexture = originalMaterial.diffuseMap;\n                    }\n                    meshInstance.material = material;\n                }\n            });\n\n            // material is set up, update it\n            material.setParameter(\"uDiffuseMap\", originalTexture);\n            material.update();\n\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += 0.2 * dt;\n\n                // reverse time\n                let t = time % 2;\n                if (t > 1) {\n                    t = 1 - (t - 1);\n                }\n\n                // set time parameter for the shader\n                material.setParameter(\"uTime\", t);\n                material.update();\n            });\n        });\n    });\n}\n","nameSlug":"shader-burn","categorySlug":"graphics","files":{"shader.vert":"\nattribute vec3 aPosition;\nattribute vec2 aUv0;\n\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\n\nvarying vec2 vUv0;\n\nvoid main(void)\n{\n    vUv0 = aUv0;\n    gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, 1.0);\n}","shader.frag":"\nprecision mediump float;\n\nvarying vec2 vUv0;\n\nuniform sampler2D uDiffuseMap;\nuniform sampler2D uHeightMap;\nuniform float uTime;\n\nvoid main(void)\n{\n    float height = texture2D(uHeightMap, vUv0).r;\n    vec4 color = texture2D(uDiffuseMap, vUv0);\n    if (height < uTime) {\n    discard;\n    }\n    if (height < (uTime + uTime * 0.1)) {\n    color = vec4(1.0, 0.2, 0.0, 1.0);\n    }\n    gl_FragColor = color;\n}"}},"shader-compile":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // This example servers as a test framework for large shader compilation speed test. Enable tracking for it.\n    pc.Tracing.set(pc.TRACEID_SHADER_COMPILE, true);\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        'color': new pc.Asset('color', 'texture', { url: '/static/assets/textures/seaside-rocks01-color.jpg' }),\n        'normal': new pc.Asset('normal', 'texture', { url: '/static/assets/textures/seaside-rocks01-normal.jpg' }),\n        'gloss': new pc.Asset('gloss', 'texture', { url: '/static/assets/textures/seaside-rocks01-gloss.jpg' }),\n        'luts': new pc.Asset('luts', 'json', { url: '/static/assets/json/area-light-luts.json' }),\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n\n        // helper function to create a primitive with shape type, position, scale, color\n        function createPrimitive(primitiveType: string, position: pc.Vec3, scale: pc.Vec3, color: pc.Color, assetManifest: any, id: boolean = false) {\n\n            // create material of specified color\n            const material = new pc.StandardMaterial();\n            material.diffuse = color;\n            material.gloss = 0.4;\n            material.useMetalness = true;\n\n            material.diffuseMap = assetManifest.color.resource;\n            material.normalMap = assetManifest.normal.resource;\n            material.glossMap = assetManifest.gloss.resource;\n            material.metalness = 0.4;\n\n            material.diffuseMapTiling.set(7, 7);\n            material.normalMapTiling.set(7, 7);\n            material.glossMapTiling.set(7, 7);\n\n            // do a small update to a chunk to generate unique shader each time, to avoid any shader compilation caching\n            if (id) {\n                material.chunks.viewDirPS = `\n                    void getViewDir() {\n                        dViewDirW = normalize(view_position - vPositionW);\n                        dViewDirW.x += 0.00001 * ${Math.random()};\n                    }\n                `;\n            }\n\n            material.update();\n\n            // create primitive\n            const primitive = new pc.Entity();\n            primitive.addComponent('render', {\n                type: primitiveType,\n                material: material\n            });\n\n            // set position and scale and add it to scene\n            primitive.setLocalPosition(position);\n            primitive.setLocalScale(scale);\n            app.root.addChild(primitive);\n\n            return primitive;\n        }\n\n        app.start();\n\n        // enable area lights which are disabled by default for clustered lighting\n        app.scene.lighting.areaLightsEnabled = true;\n\n        // set the loaded area light LUT data\n        const luts = assets.luts.resource;\n        app.setAreaLightLuts(luts.LTC_MAT_1, luts.LTC_MAT_2);\n\n        // set up some general scene rendering properties\n        app.scene.toneMapping = pc.TONEMAP_ACES;\n\n        // setup skydome\n        app.scene.skyboxMip = 1;\n        app.scene.skyboxIntensity = 0.7;\n        app.scene.envAtlas = assets.helipad.resource;\n\n        // create ground plane\n        createPrimitive(\"plane\", new pc.Vec3(0, 0, 0), new pc.Vec3(20, 20, 20), new pc.Color(0.3, 0.3, 0.3), assets);\n\n        // Create the camera, which renders entities\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.2, 0.2, 0.2),\n            fov: 60,\n            farClip: 100000\n        });\n        app.root.addChild(camera);\n        camera.setLocalPosition(0, 15, 40);\n        camera.lookAt(0, 0, 0);\n\n        // generate a grid of spheres, each with a unique material / shader\n        for (let x = -10; x <= 10; x += 6) {\n            for (let y = -10; y <= 10; y += 6) {\n                const pos = new pc.Vec3(x, 0.6, y);\n                const color = new pc.Color(0.3 + Math.random() * 0.7, 0.3 + Math.random() * 0.7, 0.3 + Math.random() * 0.7);\n                createPrimitive(\"sphere\", pos, new pc.Vec3(1, 1, 1), color, assets, true);\n            }\n        }\n\n        // create some omni lights\n        const count = 10;\n        const lights: Array<pc.Entity> = [];\n        for (let i = 0; i < count; i++) {\n            const color = new pc.Color(Math.random(), Math.random(), Math.random(), 1);\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"spot\",\n                color: color,\n                intensity: 4,\n                range: 16,\n                castShadows: false\n            });\n\n            // attach a render component with a small cone to each light\n            const material = new pc.StandardMaterial();\n            material.emissive = color;\n            material.update();\n\n            light.addComponent('render', {\n                type: \"sphere\",\n                material: material\n            });\n            light.setLocalScale(0.5, 0.5, 0.5);\n\n            app.root.addChild(light);\n            lights.push(light);\n        }\n\n        // update things each frame\n        let time = 0;\n        app.on(\"update\", function (dt: number) {\n            time += dt;\n\n            // orbit spot lights around\n            lights.forEach(function (light, i) {\n                const angle = (i / lights.length) * Math.PI * 2;\n                light.setLocalPosition(8 * Math.sin(time + angle), 4, 8 * Math.cos(time + angle));\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // This example servers as a test framework for large shader compilation speed test. Enable tracking for it.\n    pc.Tracing.set(pc.TRACEID_SHADER_COMPILE, true);\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        color: new pc.Asset(\"color\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-color.jpg\",\n        }),\n        normal: new pc.Asset(\"normal\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-normal.jpg\",\n        }),\n        gloss: new pc.Asset(\"gloss\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-gloss.jpg\",\n        }),\n        luts: new pc.Asset(\"luts\", \"json\", {\n            url: \"/static/assets/json/area-light-luts.json\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        // helper function to create a primitive with shape type, position, scale, color\n        function createPrimitive(\n            primitiveType,\n            position,\n            scale,\n            color,\n            assetManifest,\n            id = false\n        ) {\n            // create material of specified color\n            const material = new pc.StandardMaterial();\n            material.diffuse = color;\n            material.gloss = 0.4;\n            material.useMetalness = true;\n\n            material.diffuseMap = assetManifest.color.resource;\n            material.normalMap = assetManifest.normal.resource;\n            material.glossMap = assetManifest.gloss.resource;\n            material.metalness = 0.4;\n\n            material.diffuseMapTiling.set(7, 7);\n            material.normalMapTiling.set(7, 7);\n            material.glossMapTiling.set(7, 7);\n\n            // do a small update to a chunk to generate unique shader each time, to avoid any shader compilation caching\n            if (id) {\n                material.chunks.viewDirPS = `\n                    void getViewDir() {\n                        dViewDirW = normalize(view_position - vPositionW);\n                        dViewDirW.x += 0.00001 * ${Math.random()};\n                    }\n                `;\n            }\n\n            material.update();\n\n            // create primitive\n            const primitive = new pc.Entity();\n            primitive.addComponent(\"render\", {\n                type: primitiveType,\n                material: material,\n            });\n\n            // set position and scale and add it to scene\n            primitive.setLocalPosition(position);\n            primitive.setLocalScale(scale);\n            app.root.addChild(primitive);\n\n            return primitive;\n        }\n\n        app.start();\n\n        // enable area lights which are disabled by default for clustered lighting\n        app.scene.lighting.areaLightsEnabled = true;\n\n        // set the loaded area light LUT data\n        const luts = assets.luts.resource;\n        app.setAreaLightLuts(luts.LTC_MAT_1, luts.LTC_MAT_2);\n\n        // set up some general scene rendering properties\n        app.scene.toneMapping = pc.TONEMAP_ACES;\n\n        // setup skydome\n        app.scene.skyboxMip = 1;\n        app.scene.skyboxIntensity = 0.7;\n        app.scene.envAtlas = assets.helipad.resource;\n\n        // create ground plane\n        createPrimitive(\n            \"plane\",\n            new pc.Vec3(0, 0, 0),\n            new pc.Vec3(20, 20, 20),\n            new pc.Color(0.3, 0.3, 0.3),\n            assets\n        );\n\n        // Create the camera, which renders entities\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.2, 0.2, 0.2),\n            fov: 60,\n            farClip: 100000,\n        });\n\n        app.root.addChild(camera);\n        camera.setLocalPosition(0, 15, 40);\n        camera.lookAt(0, 0, 0);\n\n        // generate a grid of spheres, each with a unique material / shader\n        for (let x = -10; x <= 10; x += 6) {\n            for (let y = -10; y <= 10; y += 6) {\n                const pos = new pc.Vec3(x, 0.6, y);\n                const color = new pc.Color(\n                    0.3 + Math.random() * 0.7,\n                    0.3 + Math.random() * 0.7,\n                    0.3 + Math.random() * 0.7\n                );\n                createPrimitive(\n                    \"sphere\",\n                    pos,\n                    new pc.Vec3(1, 1, 1),\n                    color,\n                    assets,\n                    true\n                );\n            }\n        }\n\n        // create some omni lights\n        const count = 10;\n        const lights = [];\n        for (let i = 0; i < count; i++) {\n            const color = new pc.Color(\n                Math.random(),\n                Math.random(),\n                Math.random(),\n                1\n            );\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"spot\",\n                color: color,\n                intensity: 4,\n                range: 16,\n                castShadows: false,\n            });\n\n            // attach a render component with a small cone to each light\n            const material = new pc.StandardMaterial();\n            material.emissive = color;\n            material.update();\n\n            light.addComponent(\"render\", {\n                type: \"sphere\",\n                material: material,\n            });\n\n            light.setLocalScale(0.5, 0.5, 0.5);\n\n            app.root.addChild(light);\n            lights.push(light);\n        }\n\n        // update things each frame\n        let time = 0;\n        app.on(\"update\", function (dt) {\n            time += dt;\n\n            // orbit spot lights around\n            lights.forEach(function (light, i) {\n                const angle = (i / lights.length) * Math.PI * 2;\n                light.setLocalPosition(\n                    8 * Math.sin(time + angle),\n                    4,\n                    8 * Math.cos(time + angle)\n                );\n            });\n        });\n    });\n}\n","nameSlug":"shader-compile","categorySlug":"graphics"},"shader-toon":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, files: { 'shader.vert': string, 'shader.frag': string }): void {\n\n    const assets = {\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5)\n            });\n            camera.translate(0, 7, 24);\n\n            // Create an Entity with a omni light component and a sphere model component.\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(1, 1, 1),\n                radius: 10\n            });\n            light.translate(0, 1, 0);\n\n            // Add entities into scene hierarchy\n            app.root.addChild(camera);\n            app.root.addChild(light);\n\n            // Create the shader from the vertex and fragment shaders\n            const shader = pc.createShaderFromCode(app.graphicsDevice, files['shader.vert'], files['shader.frag'], 'myShader', {\n                aPosition: pc.SEMANTIC_POSITION,\n                aNormal: pc.SEMANTIC_NORMAL,\n                aUv: pc.SEMANTIC_TEXCOORD0\n            });\n\n            // Create a new material with the new shader\n            const material = new pc.Material();\n            material.shader = shader;\n\n            // create a hierarchy of entities with render components, representing the statue model\n            const entity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            // Set the new material on all meshes in the model, and use original texture from the model on the new material\n            let originalTexture:pc.Texture = null;\n            const renders: Array<pc.RenderComponent> = entity.findComponents(\"render\");\n            renders.forEach((render) => {\n                const meshInstances = render.meshInstances;\n                for (let i = 0; i < meshInstances.length; i++) {\n                    const meshInstance = meshInstances[i];\n                    if (!originalTexture) {\n                        const originalMaterial = meshInstance.material as pc.StandardMaterial;\n                        originalTexture = originalMaterial.diffuseMap;\n                    }\n                    meshInstance.material = material;\n                }\n            });\n\n            // material parameters\n            const lightPosArray = [light.getPosition().x, light.getPosition().y, light.getPosition().z];\n            material.setParameter('uLightPos', lightPosArray);\n            material.setParameter('uTexture', originalTexture);\n            material.update();\n\n            // rotate the statue\n            app.on(\"update\", function (dt) {\n                entity.rotate(0, 60 * dt, 0);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, files) {\n    const assets = {\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n            });\n\n            camera.translate(0, 7, 24);\n\n            // Create an Entity with a omni light component and a sphere model component.\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(1, 1, 1),\n                radius: 10,\n            });\n\n            light.translate(0, 1, 0);\n\n            // Add entities into scene hierarchy\n            app.root.addChild(camera);\n            app.root.addChild(light);\n\n            // Create the shader from the vertex and fragment shaders\n            const shader = pc.createShaderFromCode(\n                app.graphicsDevice,\n                files[\"shader.vert\"],\n                files[\"shader.frag\"],\n                \"myShader\",\n                {\n                    aPosition: pc.SEMANTIC_POSITION,\n                    aNormal: pc.SEMANTIC_NORMAL,\n                    aUv: pc.SEMANTIC_TEXCOORD0,\n                }\n            );\n\n            // Create a new material with the new shader\n            const material = new pc.Material();\n            material.shader = shader;\n\n            // create a hierarchy of entities with render components, representing the statue model\n            const entity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            // Set the new material on all meshes in the model, and use original texture from the model on the new material\n            let originalTexture = null;\n            const renders = entity.findComponents(\"render\");\n            renders.forEach((render) => {\n                const meshInstances = render.meshInstances;\n                for (let i = 0; i < meshInstances.length; i++) {\n                    const meshInstance = meshInstances[i];\n                    if (!originalTexture) {\n                        const originalMaterial = meshInstance.material;\n                        originalTexture = originalMaterial.diffuseMap;\n                    }\n                    meshInstance.material = material;\n                }\n            });\n\n            // material parameters\n            const lightPosArray = [\n                light.getPosition().x,\n                light.getPosition().y,\n                light.getPosition().z,\n            ];\n            material.setParameter(\"uLightPos\", lightPosArray);\n            material.setParameter(\"uTexture\", originalTexture);\n            material.update();\n\n            // rotate the statue\n            app.on(\"update\", function (dt) {\n                entity.rotate(0, 60 * dt, 0);\n            });\n        });\n    });\n}\n","nameSlug":"shader-toon","categorySlug":"graphics","files":{"shader.vert":"\n// Attributes per vertex: position, normal and texture coordinates\nattribute vec4 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aUv;\n\nuniform mat4   matrix_viewProjection;\nuniform mat4   matrix_model;\nuniform mat4   matrix_view;\nuniform mat3   matrix_normal;\nuniform vec3   uLightPos;\n\n// Color to fragment program\nvarying float vertOutTexCoord;\nvarying vec2 texCoord;\n\nvoid main(void)\n{\n    mat4 modelView = matrix_view * matrix_model;\n    mat4 modelViewProj = matrix_viewProjection * matrix_model;\n\n    // Get surface normal in eye coordinates\n    vec3 eyeNormal = normalize(matrix_normal * aNormal);\n\n    // Get vertex position in eye coordinates\n    vec4 vertexPos = modelView * aPosition;\n    vec3 vertexEyePos = vertexPos.xyz / vertexPos.w;\n\n    // Get vector to light source\n    vec3 lightDir = normalize(uLightPos - vertexEyePos);\n\n    // Dot product gives us diffuse intensity. The diffuse intensity will be\n    // used as the 1D color texture coordinate to look for the color of the\n    // resulting fragment (see fragment shader).\n    vertOutTexCoord = max(0.0, dot(eyeNormal, lightDir));\n    texCoord = aUv;\n\n    // Transform the geometry\n    gl_Position = modelViewProj * aPosition;\n}","shader.frag":"\nprecision mediump float;\nuniform sampler2D uTexture;\nvarying float vertOutTexCoord;\nvarying vec2 texCoord;\nvoid main(void)\n{\n    float v = vertOutTexCoord;\n    v = float(int(v * 6.0)) / 6.0;\n    // vec4 color = texture2D (uTexture, texCoord); // try this to use the diffuse color.\n    vec4 color = vec4(0.5, 0.47, 0.43, 1.0);\n    gl_FragColor = color * vec4(v, v, v, 1.0);\n}\n"}},"shader-wobble":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, files: { 'shader.vert': string, 'shader.frag': string }): void {\n\n    const assets = {\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5)\n            });\n            camera.translate(0, 7, 25);\n\n            // Create an Entity with a omni light component and a sphere model component.\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(1, 1, 1),\n                radius: 10\n            });\n            light.translate(0, 1, 0);\n\n            // Add entities into scene hierarchy\n            app.root.addChild(camera);\n            app.root.addChild(light);\n\n            // Create the shader from the vertex and fragment shaders\n            const shader = pc.createShaderFromCode(app.graphicsDevice, files['shader.vert'], files['shader.frag'], 'myShader', {\n                aPosition: pc.SEMANTIC_POSITION,\n                aUv0: pc.SEMANTIC_TEXCOORD0\n            });\n\n            // Create a new material with the new shader\n            const material = new pc.Material();\n            material.shader = shader;\n\n            // create a hierarchy of entities with render components, representing the statue model\n            const entity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            // Set the new material on all meshes in the model, and use original texture from the model on the new material\n            let originalTexture: pc.Texture = null;\n            const renders: Array<pc.RenderComponent> = entity.findComponents(\"render\");\n            renders.forEach((render) => {\n                const meshInstances = render.meshInstances;\n                for (let i = 0; i < meshInstances.length; i++) {\n                    const meshInstance = meshInstances[i];\n                    if (!originalTexture) {\n                        const originalMaterial = meshInstance.material as pc.StandardMaterial;\n                        originalTexture = originalMaterial.diffuseMap;\n                    }\n                    meshInstance.material = material;\n                }\n            });\n\n            // material is set up, update it\n            material.setParameter('uDiffuseMap', originalTexture);\n            material.update();\n\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // set time parameter for the shader\n                material.setParameter('uTime', time);\n                material.update();\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, files) {\n    const assets = {\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.keyboard = new pc.Keyboard(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n            });\n\n            camera.translate(0, 7, 25);\n\n            // Create an Entity with a omni light component and a sphere model component.\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"omni\",\n                color: new pc.Color(1, 1, 1),\n                radius: 10,\n            });\n\n            light.translate(0, 1, 0);\n\n            // Add entities into scene hierarchy\n            app.root.addChild(camera);\n            app.root.addChild(light);\n\n            // Create the shader from the vertex and fragment shaders\n            const shader = pc.createShaderFromCode(\n                app.graphicsDevice,\n                files[\"shader.vert\"],\n                files[\"shader.frag\"],\n                \"myShader\",\n                {\n                    aPosition: pc.SEMANTIC_POSITION,\n                    aUv0: pc.SEMANTIC_TEXCOORD0,\n                }\n            );\n\n            // Create a new material with the new shader\n            const material = new pc.Material();\n            material.shader = shader;\n\n            // create a hierarchy of entities with render components, representing the statue model\n            const entity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            // Set the new material on all meshes in the model, and use original texture from the model on the new material\n            let originalTexture = null;\n            const renders = entity.findComponents(\"render\");\n            renders.forEach((render) => {\n                const meshInstances = render.meshInstances;\n                for (let i = 0; i < meshInstances.length; i++) {\n                    const meshInstance = meshInstances[i];\n                    if (!originalTexture) {\n                        const originalMaterial = meshInstance.material;\n                        originalTexture = originalMaterial.diffuseMap;\n                    }\n                    meshInstance.material = material;\n                }\n            });\n\n            // material is set up, update it\n            material.setParameter(\"uDiffuseMap\", originalTexture);\n            material.update();\n\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // set time parameter for the shader\n                material.setParameter(\"uTime\", time);\n                material.update();\n            });\n        });\n    });\n}\n","nameSlug":"shader-wobble","categorySlug":"graphics","files":{"shader.vert":"\nattribute vec3 aPosition;\nattribute vec2 aUv0;\n\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\nuniform float uTime;\n\nvarying vec2 vUv0;\n\nvoid main(void)\n{\n    vec4 pos = matrix_model * vec4(aPosition, 1.0);\n    pos.x += sin(uTime + pos.y * 4.0) * 0.1;\n    pos.y += cos(uTime + pos.x * 4.0) * 0.1;\n    vUv0 = aUv0;\n    gl_Position = matrix_viewProjection * pos;\n}","shader.frag":"\nprecision mediump float;\n\nuniform sampler2D uDiffuseMap;\n\nvarying vec2 vUv0;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uDiffuseMap, vUv0);\n}"}},"shadow-cascades":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data: any): void {\n\n    const assets = {\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' }),\n        'terrain': new pc.Asset('terrain', 'container', { url: '/static/assets/models/terrain.glb' }),\n        helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            data.set('settings', {\n                light: {\n                    numCascades: 4,             // number of cascades\n                    shadowResolution: 2048,     // shadow map resolution storing 4 cascades\n                    cascadeDistribution: 0.5,   // distribution of cascade distances to prefer sharpness closer to the camera\n                    shadowType: pc.SHADOW_PCF3, // shadow filter type\n                    vsmBlurSize: 11,            // shader filter blur size for VSM shadows\n                    everyFrame: true            // true if all cascades update every frame\n                }\n            });\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // setup skydome\n            app.scene.skyboxMip = 3;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(0, -70, 0);\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // instantiate the terrain\n            const terrain: pc.Entity = assets.terrain.resource.instantiateRenderEntity();\n            terrain.setLocalScale(30, 30, 30);\n            app.root.addChild(terrain);\n\n            // get the clouds so that we can animate them\n            // @ts-ignore\n            const srcClouds : Array<pc.Entity> = terrain.find((node: pc.GraphNode) => {\n\n                const isCloud = node.name.includes('Icosphere');\n\n                if (isCloud) {\n                    // no shadow receiving for clouds\n                    (node as pc.Entity).render.receiveShadows = false;\n                }\n\n                return isCloud;\n            });\n\n            // clone some additional clouds\n            const clouds : Array<pc.Entity> = [];\n            srcClouds.forEach((cloud) => {\n                clouds.push(cloud);\n\n                for (let i = 0; i < 3; i++) {\n                    const clone = cloud.clone() as pc.Entity;\n                    cloud.parent.addChild(clone);\n                    clouds.push(clone);\n                }\n            });\n\n            // shuffle the array to give clouds random order\n            clouds.sort(() => Math.random() - 0.5);\n\n            // find a tree in the middle to use as a focus point\n            // @ts-ignore\n            const tree = terrain.findOne(\"name\", \"Arbol 2.002\");\n\n            // create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.9, 0.9, 0.9),\n                farClip: 1000\n            });\n\n            // and position it in the world\n            camera.setLocalPosition(300, 160, 25);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: tree,\n                    distanceMax: 600\n                }\n            });\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // Create a directional light casting cascaded shadows\n            const dirLight = new pc.Entity();\n            dirLight.addComponent(\"light\", {\n                ...{\n                    type: \"directional\",\n                    color: pc.Color.WHITE,\n                    shadowBias: 0.3,\n                    normalOffsetBias: 0.2,\n                    intensity: 1.0,\n\n                    // enable shadow casting\n                    castShadows: true,\n                    shadowDistance: 1000\n                },\n                ...data.get('settings.light')\n            });\n            app.root.addChild(dirLight);\n            dirLight.setLocalEulerAngles(45, 350, 20);\n\n            // update mode of cascades\n            let updateEveryFrame = true;\n\n            // handle HUD changes - update properties on the light\n            data.on('*:set', (path: string, value: any) => {\n                const pathArray = path.split('.');\n\n                if (pathArray[2] === 'everyFrame') {\n                    updateEveryFrame = value;\n                } else {\n                    // @ts-ignore\n                    dirLight.light[pathArray[2]] = value;\n                }\n            });\n\n            const cloudSpeed = 0.2;\n            let frameNumber = 0;\n            let time = 0;\n            app.on(\"update\", function (dt: number) {\n\n                time += dt;\n\n                // on the first frame, when camera is updated, move it further away from the focus tree\n                if (frameNumber === 0) {\n                    // @ts-ignore engine-tsd\n                    camera.script.orbitCamera.distance = 470;\n                }\n\n                if (updateEveryFrame) {\n\n                    // no per cascade rendering control\n                    dirLight.light.shadowUpdateOverrides = null;\n\n                } else {\n\n                    // set up shadow update overrides, nearest cascade updates each frame, then next one every 5 and so on\n                    dirLight.light.shadowUpdateOverrides = [\n                        pc.SHADOWUPDATE_THISFRAME,\n                        (frameNumber % 5) === 0 ? pc.SHADOWUPDATE_THISFRAME : pc.SHADOWUPDATE_NONE,\n                        (frameNumber % 10) === 0 ? pc.SHADOWUPDATE_THISFRAME : pc.SHADOWUPDATE_NONE,\n                        (frameNumber % 15) === 0 ? pc.SHADOWUPDATE_THISFRAME : pc.SHADOWUPDATE_NONE\n                    ];\n                }\n\n                // move the clouds around\n                clouds.forEach((cloud, index: number) => {\n                    const redialOffset = (index / clouds.length) * (6.24 / cloudSpeed);\n                    const radius = 9 + 4 * Math.sin(redialOffset);\n                    const cloudTime = time + redialOffset;\n                    cloud.setLocalPosition(2 + radius * Math.sin(cloudTime * cloudSpeed), 4, -5 + radius * Math.cos(cloudTime * cloudSpeed));\n                });\n\n                frameNumber++;\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    const assets = {\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/orbit-camera.js\",\n        }),\n        terrain: new pc.Asset(\"terrain\", \"container\", {\n            url: \"/static/assets/models/terrain.glb\",\n        }),\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            data.set(\"settings\", {\n                light: {\n                    numCascades: 4, // number of cascades\n                    shadowResolution: 2048, // shadow map resolution storing 4 cascades\n                    cascadeDistribution: 0.5, // distribution of cascade distances to prefer sharpness closer to the camera\n                    shadowType: pc.SHADOW_PCF3, // shadow filter type\n                    vsmBlurSize: 11, // shader filter blur size for VSM shadows\n                    everyFrame: true, // true if all cascades update every frame\n                },\n            });\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // setup skydome\n            app.scene.skyboxMip = 3;\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.skyboxRotation = new pc.Quat().setFromEulerAngles(\n                0,\n                -70,\n                0\n            );\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n\n            // instantiate the terrain\n            const terrain = assets.terrain.resource.instantiateRenderEntity();\n            terrain.setLocalScale(30, 30, 30);\n            app.root.addChild(terrain);\n\n            // get the clouds so that we can animate them\n            // @ts-ignore\n            const srcClouds = terrain.find((node) => {\n                const isCloud = node.name.includes(\"Icosphere\");\n\n                if (isCloud) {\n                    // no shadow receiving for clouds\n                    node.render.receiveShadows = false;\n                }\n\n                return isCloud;\n            });\n\n            // clone some additional clouds\n            const clouds = [];\n            srcClouds.forEach((cloud) => {\n                clouds.push(cloud);\n\n                for (let i = 0; i < 3; i++) {\n                    const clone = cloud.clone();\n                    cloud.parent.addChild(clone);\n                    clouds.push(clone);\n                }\n            });\n\n            // shuffle the array to give clouds random order\n            clouds.sort(() => Math.random() - 0.5);\n\n            // find a tree in the middle to use as a focus point\n            // @ts-ignore\n            const tree = terrain.findOne(\"name\", \"Arbol 2.002\");\n\n            // create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.9, 0.9, 0.9),\n                farClip: 1000,\n            });\n\n            // and position it in the world\n            camera.setLocalPosition(300, 160, 25);\n\n            // add orbit camera script with a mouse and a touch support\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2,\n                    focusEntity: tree,\n                    distanceMax: 600,\n                },\n            });\n\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // Create a directional light casting cascaded shadows\n            const dirLight = new pc.Entity();\n            dirLight.addComponent(\"light\", {\n                ...{\n                    type: \"directional\",\n                    color: pc.Color.WHITE,\n                    shadowBias: 0.3,\n                    normalOffsetBias: 0.2,\n                    intensity: 1.0,\n\n                    // enable shadow casting\n                    castShadows: true,\n                    shadowDistance: 1000,\n                },\n\n                ...data.get(\"settings.light\"),\n            });\n\n            app.root.addChild(dirLight);\n            dirLight.setLocalEulerAngles(45, 350, 20);\n\n            // update mode of cascades\n            let updateEveryFrame = true;\n\n            // handle HUD changes - update properties on the light\n            data.on(\"*:set\", (path, value) => {\n                const pathArray = path.split(\".\");\n\n                if (pathArray[2] === \"everyFrame\") {\n                    updateEveryFrame = value;\n                } else {\n                    // @ts-ignore\n                    dirLight.light[pathArray[2]] = value;\n                }\n            });\n\n            const cloudSpeed = 0.2;\n            let frameNumber = 0;\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // on the first frame, when camera is updated, move it further away from the focus tree\n                if (frameNumber === 0) {\n                    // @ts-ignore engine-tsd\n                    camera.script.orbitCamera.distance = 470;\n                }\n\n                if (updateEveryFrame) {\n                    // no per cascade rendering control\n                    dirLight.light.shadowUpdateOverrides = null;\n                } else {\n                    // set up shadow update overrides, nearest cascade updates each frame, then next one every 5 and so on\n                    dirLight.light.shadowUpdateOverrides = [\n                        pc.SHADOWUPDATE_THISFRAME,\n                        frameNumber % 5 === 0\n                            ? pc.SHADOWUPDATE_THISFRAME\n                            : pc.SHADOWUPDATE_NONE,\n                        frameNumber % 10 === 0\n                            ? pc.SHADOWUPDATE_THISFRAME\n                            : pc.SHADOWUPDATE_NONE,\n                        frameNumber % 15 === 0\n                            ? pc.SHADOWUPDATE_THISFRAME\n                            : pc.SHADOWUPDATE_NONE,\n                    ];\n                }\n\n                // move the clouds around\n                clouds.forEach((cloud, index) => {\n                    const redialOffset =\n                        (index / clouds.length) * (6.24 / cloudSpeed);\n                    const radius = 9 + 4 * Math.sin(redialOffset);\n                    const cloudTime = time + redialOffset;\n                    cloud.setLocalPosition(\n                        2 + radius * Math.sin(cloudTime * cloudSpeed),\n                        4,\n                        -5 + radius * Math.cos(cloudTime * cloudSpeed)\n                    );\n                });\n\n                frameNumber++;\n            });\n        });\n    });\n}\n","nameSlug":"shadow-cascades","categorySlug":"graphics"},"shapes":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        app.scene.lighting.shadowsEnabled = false;\n\n        // All render component primitive shape types\n        const shapes = [\"box\", \"plane\", \"cone\", \"cylinder\", \"sphere\", \"capsule\"];\n        let x = -1, y = -1;\n\n        shapes.forEach(function (shape) {\n            // Create an entity with a render component\n            const entity = new pc.Entity();\n            entity.addComponent(\"render\", {\n                type: shape\n            });\n            app.root.addChild(entity);\n\n            // Lay out the 6 primitives in two rows, 3 per row\n            entity.setLocalPosition(x * 1.2, y, 0);\n            if (x++ === 1) {\n                x = -1;\n                y = 1;\n            }\n        });\n\n        // Create an entity with a directional light component\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\",\n            castShadows: false\n        });\n        app.root.addChild(light);\n        light.setLocalEulerAngles(45, 30, 0);\n\n        // Create an entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.4, 0.45, 0.5)\n        });\n        app.root.addChild(camera);\n        camera.setLocalPosition(0, 0, 5);\n\n    }).catch(console.error);\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions)\n        .then((device) => {\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.RenderComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.LightComponentSystem,\n            ];\n\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.ContainerHandler,\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            app.start();\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            app.scene.lighting.shadowsEnabled = false;\n\n            // All render component primitive shape types\n            const shapes = [\n                \"box\",\n                \"plane\",\n                \"cone\",\n                \"cylinder\",\n                \"sphere\",\n                \"capsule\",\n            ];\n            let x = -1,\n                y = -1;\n\n            shapes.forEach(function (shape) {\n                // Create an entity with a render component\n                const entity = new pc.Entity();\n                entity.addComponent(\"render\", {\n                    type: shape,\n                });\n\n                app.root.addChild(entity);\n\n                // Lay out the 6 primitives in two rows, 3 per row\n                entity.setLocalPosition(x * 1.2, y, 0);\n                if (x++ === 1) {\n                    x = -1;\n                    y = 1;\n                }\n            });\n\n            // Create an entity with a directional light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n                castShadows: false,\n            });\n\n            app.root.addChild(light);\n            light.setLocalEulerAngles(45, 30, 0);\n\n            // Create an entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n            });\n\n            app.root.addChild(camera);\n            camera.setLocalPosition(0, 0, 5);\n        })\n        .catch(console.error);\n}\n","nameSlug":"shapes","categorySlug":"graphics"},"texture-basis":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // initialize basis\n    pc.basisInitialize({\n        glueUrl: '/static/lib/basis/basis.wasm.js',\n        wasmUrl: '/static/lib/basis/basis.wasm.wasm',\n        fallbackUrl: '/static/lib/basis/basis.js'\n    });\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        'color': new pc.Asset('color', 'texture', { url: '/static/assets/textures/seaside-rocks01-color.basis' }),\n        'gloss': new pc.Asset('gloss', 'texture', { url: '/static/assets/textures/seaside-rocks01-gloss.basis' }),\n        'normal': new pc.Asset('normal', 'texture', { url: '/static/assets/textures/seaside-rocks01-normal.basis' }, { type: pc.TEXTURETYPE_SWIZZLEGGGR }),\n        'helipad': new pc.Asset('helipad', 'cubemap', { url: '/static/assets/cubemaps/helipad.dds' }, { type: pc.TEXTURETYPE_RGBM })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // Set skybox\n        app.scene.toneMapping = pc.TONEMAP_ACES;\n        app.scene.skyboxMip = 1;\n        app.scene.skyboxIntensity = 0.7;\n        app.scene.setSkybox(assets.helipad.resources);\n\n        // Create directional light\n        const light = new pc.Entity();\n        light.addComponent('light', {\n            type: 'directional'\n        });\n        light.setLocalEulerAngles(45, 0, 45);\n\n        // Construct material\n        const material = new pc.StandardMaterial();\n        material.useMetalness = true;\n        material.diffuse = new pc.Color(0.3, 0.3, 0.3);\n        material.gloss = 0.8;\n        material.metalness = 0.7;\n        material.diffuseMap = assets.color.resource;\n        material.normalMap = assets.normal.resource;\n        material.glossMap = assets.gloss.resource;\n        material.diffuseMapTiling.set(7, 7);\n        material.normalMapTiling.set(7, 7);\n        material.glossMapTiling.set(7, 7);\n        material.update();\n\n        // Create a torus shape\n        const torus = pc.createTorus(app.graphicsDevice, {\n            tubeRadius: 0.2,\n            ringRadius: 0.3,\n            segments: 50,\n            sides: 40\n        });\n        const shape = new pc.Entity();\n        shape.addComponent('render', {\n            material: material,\n            meshInstances: [new pc.MeshInstance(torus, material)]\n        });\n        shape.setPosition(0, 0, 0);\n        shape.setLocalScale(2, 2, 2);\n\n        // Create an Entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.4, 0.45, 0.5)\n        });\n\n        // Adjust the camera position\n        camera.translate(0, 0, 4);\n\n        // Add the new Entities to the hierarchy\n        app.root.addChild(light);\n        app.root.addChild(shape);\n        app.root.addChild(camera);\n\n        // Set an update function on the app's update event\n        let angle = 0;\n        app.on(\"update\", function (dt) {\n            angle = (angle + dt * 10) % 360;\n\n            // Rotate the boxes\n            shape.setEulerAngles(angle, angle * 2, angle * 4);\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // initialize basis\n    pc.basisInitialize({\n        glueUrl: \"/static/lib/basis/basis.wasm.js\",\n        wasmUrl: \"/static/lib/basis/basis.wasm.wasm\",\n        fallbackUrl: \"/static/lib/basis/basis.js\",\n    });\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        color: new pc.Asset(\"color\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-color.basis\",\n        }),\n        gloss: new pc.Asset(\"gloss\", \"texture\", {\n            url: \"/static/assets/textures/seaside-rocks01-gloss.basis\",\n        }),\n        normal: new pc.Asset(\n            \"normal\",\n            \"texture\",\n            { url: \"/static/assets/textures/seaside-rocks01-normal.basis\" },\n            { type: pc.TEXTURETYPE_SWIZZLEGGGR }\n        ),\n        helipad: new pc.Asset(\n            \"helipad\",\n            \"cubemap\",\n            { url: \"/static/assets/cubemaps/helipad.dds\" },\n            { type: pc.TEXTURETYPE_RGBM }\n        ),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // Set skybox\n        app.scene.toneMapping = pc.TONEMAP_ACES;\n        app.scene.skyboxMip = 1;\n        app.scene.skyboxIntensity = 0.7;\n        app.scene.setSkybox(assets.helipad.resources);\n\n        // Create directional light\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\",\n        });\n\n        light.setLocalEulerAngles(45, 0, 45);\n\n        // Construct material\n        const material = new pc.StandardMaterial();\n        material.useMetalness = true;\n        material.diffuse = new pc.Color(0.3, 0.3, 0.3);\n        material.gloss = 0.8;\n        material.metalness = 0.7;\n        material.diffuseMap = assets.color.resource;\n        material.normalMap = assets.normal.resource;\n        material.glossMap = assets.gloss.resource;\n        material.diffuseMapTiling.set(7, 7);\n        material.normalMapTiling.set(7, 7);\n        material.glossMapTiling.set(7, 7);\n        material.update();\n\n        // Create a torus shape\n        const torus = pc.createTorus(app.graphicsDevice, {\n            tubeRadius: 0.2,\n            ringRadius: 0.3,\n            segments: 50,\n            sides: 40,\n        });\n\n        const shape = new pc.Entity();\n        shape.addComponent(\"render\", {\n            material: material,\n            meshInstances: [new pc.MeshInstance(torus, material)],\n        });\n\n        shape.setPosition(0, 0, 0);\n        shape.setLocalScale(2, 2, 2);\n\n        // Create an Entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.4, 0.45, 0.5),\n        });\n\n        // Adjust the camera position\n        camera.translate(0, 0, 4);\n\n        // Add the new Entities to the hierarchy\n        app.root.addChild(light);\n        app.root.addChild(shape);\n        app.root.addChild(camera);\n\n        // Set an update function on the app's update event\n        let angle = 0;\n        app.on(\"update\", function (dt) {\n            angle = (angle + dt * 10) % 360;\n\n            // Rotate the boxes\n            shape.setEulerAngles(angle, angle * 2, angle * 4);\n        });\n    });\n}\n","nameSlug":"texture-basis","categorySlug":"graphics"},"transform-feedback":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, files: { 'shaderFeedback.vert': string, 'shaderCloud.vert': string, 'shaderCloud.frag': string }): void {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        // create small 2D texture representing movement direction (wind)\n        const textureResolution = 10;\n        const textureData = new Uint8ClampedArray(textureResolution * textureResolution * 4);\n\n        for (let i = 0; i < textureResolution * textureResolution; i++) {\n\n            // rgb store biased movement direction\n            textureData[i * 4] = 127 + Math.random() * 50 - 25;\n            textureData[i * 4 + 1] = 127 + Math.random() * 50 - 25;\n            textureData[i * 4 + 2] = 127 + Math.random() * 50 - 25;\n\n            // set alpha to 255 for debugging purposes\n            textureData[i * 4 + 3] = 255;\n        }\n\n        // create texture\n        const texture = new pc.Texture(app.graphicsDevice, {\n            width: textureResolution,\n            height: textureResolution,\n            format: pc.PIXELFORMAT_RGBA8,\n            cubemap: false,\n            mipmaps: false,\n            minFilter: pc.FILTER_LINEAR,\n            magFilter: pc.FILTER_LINEAR,\n            addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n            addressV: pc.ADDRESS_CLAMP_TO_EDGE\n        });\n\n        // initialize it with data\n        const pixels = texture.lock();\n        pixels.set(textureData);\n        texture.unlock();\n\n        // Create main camera, which renders the world\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.1, 0.1, 0.1)\n        });\n        app.root.addChild(camera);\n\n        // set up texture transform part, on webgl2 devices only\n        let tf: any;\n        let shader: any;\n        const areaSize = 30;\n\n        // resolve parameters to simulation shader parameters\n        const areaSizeUniform = app.graphicsDevice.scope.resolve(\"areaSize\");\n        const deltaTimeUniform = app.graphicsDevice.scope.resolve(\"deltaTime\");\n        const directionSampler = app.graphicsDevice.scope.resolve(\"directionSampler\");\n\n        // @ts-ignore engine-tsd\n        if (app.graphicsDevice.webgl2) {\n\n            // simulated particles\n            const maxNumPoints = 200000;\n            const positions = new Float32Array(4 * maxNumPoints);\n\n            // generate random data, these are used as seeds to generate particles in vertex shader\n            for (let i = 0; i < maxNumPoints; i++) {\n                positions[i * 4] = Math.random();\n                positions[i * 4 + 1] = Math.random();\n                positions[i * 4 + 2] = Math.random();\n\n                // set life time to 0 which triggers particle restart in shader\n                positions[i * 4 + 3] = 0;\n            }\n\n            // store these in a vertex buffer of a mesh\n            const mesh = new pc.Mesh(app.graphicsDevice);\n            mesh.setPositions(positions, 4);\n            mesh.update(pc.PRIMITIVE_POINTS, false);\n\n            // set large bounding box so we don't need to update it each frame\n            mesh.aabb = new pc.BoundingBox(new pc.Vec3(0, 0, 0), new pc.Vec3(100, 100, 100));\n\n            // Create the shader from the vertex and fragment shaders which is used to render point sprites\n            shader = new pc.Shader(app.graphicsDevice, {\n                attributes: { aPosition: pc.SEMANTIC_POSITION },\n                vshader: files['shaderCloud.vert'],\n                fshader: files['shaderCloud.frag']\n            });\n\n            // Create a new material with the new shader and additive alpha blending\n            const material = new pc.Material();\n            material.shader = shader;\n            material.blendType = pc.BLEND_ADDITIVEALPHA;\n            material.depthWrite = false;\n\n            // Create the mesh instance\n            const meshInstance = new pc.MeshInstance(mesh, material);\n\n            // create an entity used to render the mesh instance using a render component\n            const entity = new pc.Entity();\n            entity.addComponent(\"render\", {\n                type: 'asset',\n                meshInstances: [meshInstance]\n            });\n            app.root.addChild(entity);\n\n            // set up transform feedback. This creates a clone of the vertex buffer, and sets up rendering to ping pong between them\n            tf = new pc.TransformFeedback(mesh.vertexBuffer);\n            shader = pc.TransformFeedback.createShader(app.graphicsDevice, files['shaderFeedback.vert'], \"transformShaderExample\");\n        }\n\n        // update things each frame\n        let time = 0;\n        app.on(\"update\", function (dt) {\n\n            // rotate camera around\n            time += dt;\n            camera.setLocalPosition(9 * Math.sin(time * 0.2), 6, 25 * Math.cos(time * 0.2));\n            camera.lookAt(new pc.Vec3(0, 3, 0));\n\n            // if transform feedback was initialized\n            if (tf) {\n\n                // set up simulation parameters\n                areaSizeUniform.setValue(areaSize);\n                deltaTimeUniform.setValue(dt);\n                directionSampler.setValue(texture);\n\n                // execute simulation\n                tf.process(shader);\n            }\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, files) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        // create small 2D texture representing movement direction (wind)\n        const textureResolution = 10;\n        const textureData = new Uint8ClampedArray(\n            textureResolution * textureResolution * 4\n        );\n\n        for (let i = 0; i < textureResolution * textureResolution; i++) {\n            // rgb store biased movement direction\n            textureData[i * 4] = 127 + Math.random() * 50 - 25;\n            textureData[i * 4 + 1] = 127 + Math.random() * 50 - 25;\n            textureData[i * 4 + 2] = 127 + Math.random() * 50 - 25;\n\n            // set alpha to 255 for debugging purposes\n            textureData[i * 4 + 3] = 255;\n        }\n\n        // create texture\n        const texture = new pc.Texture(app.graphicsDevice, {\n            width: textureResolution,\n            height: textureResolution,\n            format: pc.PIXELFORMAT_RGBA8,\n            cubemap: false,\n            mipmaps: false,\n            minFilter: pc.FILTER_LINEAR,\n            magFilter: pc.FILTER_LINEAR,\n            addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n            addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n        });\n\n        // initialize it with data\n        const pixels = texture.lock();\n        pixels.set(textureData);\n        texture.unlock();\n\n        // Create main camera, which renders the world\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.1, 0.1, 0.1),\n        });\n\n        app.root.addChild(camera);\n\n        // set up texture transform part, on webgl2 devices only\n        let tf;\n        let shader;\n        const areaSize = 30;\n\n        // resolve parameters to simulation shader parameters\n        const areaSizeUniform = app.graphicsDevice.scope.resolve(\"areaSize\");\n        const deltaTimeUniform = app.graphicsDevice.scope.resolve(\"deltaTime\");\n        const directionSampler =\n            app.graphicsDevice.scope.resolve(\"directionSampler\");\n\n        // @ts-ignore engine-tsd\n        if (app.graphicsDevice.webgl2) {\n            // simulated particles\n            const maxNumPoints = 200000;\n            const positions = new Float32Array(4 * maxNumPoints);\n\n            // generate random data, these are used as seeds to generate particles in vertex shader\n            for (let i = 0; i < maxNumPoints; i++) {\n                positions[i * 4] = Math.random();\n                positions[i * 4 + 1] = Math.random();\n                positions[i * 4 + 2] = Math.random();\n\n                // set life time to 0 which triggers particle restart in shader\n                positions[i * 4 + 3] = 0;\n            }\n\n            // store these in a vertex buffer of a mesh\n            const mesh = new pc.Mesh(app.graphicsDevice);\n            mesh.setPositions(positions, 4);\n            mesh.update(pc.PRIMITIVE_POINTS, false);\n\n            // set large bounding box so we don't need to update it each frame\n            mesh.aabb = new pc.BoundingBox(\n                new pc.Vec3(0, 0, 0),\n                new pc.Vec3(100, 100, 100)\n            );\n\n            // Create the shader from the vertex and fragment shaders which is used to render point sprites\n            shader = new pc.Shader(app.graphicsDevice, {\n                attributes: { aPosition: pc.SEMANTIC_POSITION },\n                vshader: files[\"shaderCloud.vert\"],\n                fshader: files[\"shaderCloud.frag\"],\n            });\n\n            // Create a new material with the new shader and additive alpha blending\n            const material = new pc.Material();\n            material.shader = shader;\n            material.blendType = pc.BLEND_ADDITIVEALPHA;\n            material.depthWrite = false;\n\n            // Create the mesh instance\n            const meshInstance = new pc.MeshInstance(mesh, material);\n\n            // create an entity used to render the mesh instance using a render component\n            const entity = new pc.Entity();\n            entity.addComponent(\"render\", {\n                type: \"asset\",\n                meshInstances: [meshInstance],\n            });\n\n            app.root.addChild(entity);\n\n            // set up transform feedback. This creates a clone of the vertex buffer, and sets up rendering to ping pong between them\n            tf = new pc.TransformFeedback(mesh.vertexBuffer);\n            shader = pc.TransformFeedback.createShader(\n                app.graphicsDevice,\n                files[\"shaderFeedback.vert\"],\n                \"transformShaderExample\"\n            );\n        }\n\n        // update things each frame\n        let time = 0;\n        app.on(\"update\", function (dt) {\n            // rotate camera around\n            time += dt;\n            camera.setLocalPosition(\n                9 * Math.sin(time * 0.2),\n                6,\n                25 * Math.cos(time * 0.2)\n            );\n            camera.lookAt(new pc.Vec3(0, 3, 0));\n\n            // if transform feedback was initialized\n            if (tf) {\n                // set up simulation parameters\n                areaSizeUniform.setValue(areaSize);\n                deltaTimeUniform.setValue(dt);\n                directionSampler.setValue(texture);\n\n                // execute simulation\n                tf.process(shader);\n            }\n        });\n    });\n}\n","nameSlug":"transform-feedback","categorySlug":"graphics","files":{"shaderFeedback.vert":"\n// vertex shader used to move particles during transform-feedback simulation step\n\n// input and output is vec4, containing position in .xyz and lifetime in .w\nattribute vec4 vertex_position;\nvarying vec4 out_vertex_position;\n\n// parameters controlling simulation\nuniform float deltaTime;\nuniform float areaSize;\n\n// texture storing random direction vectors\nuniform sampler2D directionSampler;\n\n// function returning random number based on vec2 seed parameter\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main(void) {\n\n    // texture contains direction of particle movement - read it based on particle's position\n    vec2 texCoord = vertex_position.xz / areaSize + 0.5;\n    vec3 dir = texture2D(directionSampler, texCoord).xyz;\n    dir = dir * 2.0 - 1.0;\n\n    // move particle along direction with some speed\n    float speed = 20.0 * deltaTime;\n    vec3 pos = vertex_position.xyz + dir * speed;\n\n    // age the particle\n    float liveTime = vertex_position.w;\n    liveTime -= deltaTime;\n\n    // if particle is too old, regenerate it\n    if (liveTime <= 0.0) {\n\n        // random life time\n        liveTime = rand(pos.xy) * 2.0;\n\n        // random position\n        pos.x = rand(pos.xz) * areaSize - 0.5 * areaSize;\n        pos.y = rand(pos.xy) * 4.0;\n        pos.z = rand(pos.yz) * areaSize - 0.5 * areaSize;\n    }\n\n    // write out updated particle\n    out_vertex_position = vec4(pos, liveTime);\n}","shaderCloud.vert":"\n// vertex shader used to render point sprite particles\n\n// Attributes per vertex: position\nattribute vec4 aPosition;\n\nuniform mat4   matrix_viewProjection;\n\n// Color to fragment program\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    // Transform the geometry (ignore life time which is stored in .w of position)\n    vec4 worldPosition = vec4(aPosition.xyz, 1);\n    gl_Position = matrix_viewProjection * worldPosition;\n\n    // point sprite size\n    gl_PointSize = 2.0;\n\n    // color depends on position of particle\n    outColor = vec4(worldPosition.y * 0.25, 0.1, worldPosition.z * 0.2, 1);\n}","shaderCloud.frag":"\n// fragment shader used to render point sprite particles\nprecision mediump float;\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    // color supplied by vertex shader\n    gl_FragColor = outColor;\n}"}},"video-texture":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        'tv': new pc.Asset('tv', 'container', { url: '/static/assets/models/tv.glb' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        // Create an Entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.4, 0.45, 0.5)\n        });\n        camera.translate(0, 0, 15);\n\n        // Create an Entity with a omni light\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"omni\",\n            color: new pc.Color(1, 1, 1),\n            range: 30\n        });\n        light.translate(5, 5, 10);\n\n        app.root.addChild(camera);\n        app.root.addChild(light);\n\n        // Create a texture to hold the video frame data\n        const videoTexture = new pc.Texture(app.graphicsDevice, {\n            format: pc.PIXELFORMAT_RGB565,\n            mipmaps: false,\n            minFilter: pc.FILTER_LINEAR,\n            magFilter: pc.FILTER_LINEAR,\n            addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n            addressV: pc.ADDRESS_CLAMP_TO_EDGE\n        });\n\n        // Create our HTML element with the video\n        const video: HTMLVideoElement = document.createElement('video');\n        video.id = 'vid';\n        video.loop = true;\n\n        // Muted so that we can autoplay\n        video.muted = true;\n        video.autoplay = true;\n\n        // Inline needed for iOS otherwise it plays at fullscreen\n        video.playsInline = true;\n\n        video.crossOrigin = \"anonymous\";\n\n        // Make sure that the video is in view on the page otherwise it doesn't\n        // load on some browsers, especially mobile\n        video.setAttribute('style', 'display: block; width: 1px; height: 1px; position: absolute; opacity: 0; z-index: -1000; top: 0px; pointer-events: none');\n\n        video.src = '/static/assets/video/SampleVideo_1280x720_1mb.mp4';\n        document.body.append(video);\n\n        video.addEventListener('canplaythrough', function () {\n            videoTexture.setSource(video);\n        });\n\n        // create an entity to render the tv mesh\n        const entity = assets.tv.resource.instantiateRenderEntity();\n        app.root.addChild(entity);\n\n        // Create a material that will use our video texture\n        const material = new pc.StandardMaterial();\n        material.useLighting = false;\n        material.emissiveMap = videoTexture;\n        material.update();\n\n        // set the material on the screen mesh\n        entity.render.meshInstances[1].material = material;\n\n        video.load();\n\n        const mouse = new pc.Mouse(document.body);\n        mouse.on('mousedown', function (event) {\n            if (entity && event.buttons[pc.MOUSEBUTTON_LEFT]) {\n                video.muted = !video.muted;\n            }\n        });\n\n        let upload = false;\n        let time = 0;\n        app.on('update', function (dt) {\n            time += dt;\n\n            // rotate the tv object\n            entity.setLocalEulerAngles(100 + Math.sin(time) * 50, 0, -90);\n\n            // Upload the video data to the texture every other frame\n            upload = !upload;\n            if (upload) {\n                videoTexture.upload();\n            }\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        tv: new pc.Asset(\"tv\", \"container\", {\n            url: \"/static/assets/models/tv.glb\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        // Create an Entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.4, 0.45, 0.5),\n        });\n\n        camera.translate(0, 0, 15);\n\n        // Create an Entity with a omni light\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"omni\",\n            color: new pc.Color(1, 1, 1),\n            range: 30,\n        });\n\n        light.translate(5, 5, 10);\n\n        app.root.addChild(camera);\n        app.root.addChild(light);\n\n        // Create a texture to hold the video frame data\n        const videoTexture = new pc.Texture(app.graphicsDevice, {\n            format: pc.PIXELFORMAT_RGB565,\n            mipmaps: false,\n            minFilter: pc.FILTER_LINEAR,\n            magFilter: pc.FILTER_LINEAR,\n            addressU: pc.ADDRESS_CLAMP_TO_EDGE,\n            addressV: pc.ADDRESS_CLAMP_TO_EDGE,\n        });\n\n        // Create our HTML element with the video\n        const video = document.createElement(\"video\");\n        video.id = \"vid\";\n        video.loop = true;\n\n        // Muted so that we can autoplay\n        video.muted = true;\n        video.autoplay = true;\n\n        // Inline needed for iOS otherwise it plays at fullscreen\n        video.playsInline = true;\n\n        video.crossOrigin = \"anonymous\";\n\n        // Make sure that the video is in view on the page otherwise it doesn't\n        // load on some browsers, especially mobile\n        video.setAttribute(\n            \"style\",\n            \"display: block; width: 1px; height: 1px; position: absolute; opacity: 0; z-index: -1000; top: 0px; pointer-events: none\"\n        );\n\n        video.src = \"/static/assets/video/SampleVideo_1280x720_1mb.mp4\";\n        document.body.append(video);\n\n        video.addEventListener(\"canplaythrough\", function () {\n            videoTexture.setSource(video);\n        });\n\n        // create an entity to render the tv mesh\n        const entity = assets.tv.resource.instantiateRenderEntity();\n        app.root.addChild(entity);\n\n        // Create a material that will use our video texture\n        const material = new pc.StandardMaterial();\n        material.useLighting = false;\n        material.emissiveMap = videoTexture;\n        material.update();\n\n        // set the material on the screen mesh\n        entity.render.meshInstances[1].material = material;\n\n        video.load();\n\n        const mouse = new pc.Mouse(document.body);\n        mouse.on(\"mousedown\", function (event) {\n            if (entity && event.buttons[pc.MOUSEBUTTON_LEFT]) {\n                video.muted = !video.muted;\n            }\n        });\n\n        let upload = false;\n        let time = 0;\n        app.on(\"update\", function (dt) {\n            time += dt;\n\n            // rotate the tv object\n            entity.setLocalEulerAngles(100 + Math.sin(time) * 50, 0, -90);\n\n            // Upload the video data to the texture every other frame\n            upload = !upload;\n            if (upload) {\n                videoTexture.upload();\n            }\n        });\n    });\n}\n","nameSlug":"video-texture","categorySlug":"graphics"}},"input":{"gamepad":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n    // Create the application and start the update loop\n\n    const assets = {\n        'helipad': new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // set skybox\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.exposure = 1.6;\n            app.scene.skyboxMip = 1;\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5)\n            });\n            camera.translate(0, 7, 25);\n            app.root.addChild(camera);\n\n            const entity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            const gamepads = new pc.GamePads();\n            app.on(\"update\", function () {\n                gamepads.update();\n                if (gamepads.isPressed(pc.PAD_1, pc.PAD_LEFT)) {\n                    entity.rotate(0, -1, 0);\n                }\n                if (gamepads.isPressed(pc.PAD_1, pc.PAD_RIGHT)) {\n                    entity.rotate(0, 1, 0);\n                }\n                if (gamepads.wasPressed(pc.PAD_1, pc.PAD_UP)) {\n                    entity.rotate(-1, 0, 0);\n                }\n                if (gamepads.wasPressed(pc.PAD_1, pc.PAD_DOWN)) {\n                    entity.rotate(1, 0, 0);\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the application and start the update loop\n\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // set skybox\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.exposure = 1.6;\n            app.scene.skyboxMip = 1;\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n            });\n\n            camera.translate(0, 7, 25);\n            app.root.addChild(camera);\n\n            const entity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            const gamepads = new pc.GamePads();\n            app.on(\"update\", function () {\n                gamepads.update();\n                if (gamepads.isPressed(pc.PAD_1, pc.PAD_LEFT)) {\n                    entity.rotate(0, -1, 0);\n                }\n                if (gamepads.isPressed(pc.PAD_1, pc.PAD_RIGHT)) {\n                    entity.rotate(0, 1, 0);\n                }\n                if (gamepads.wasPressed(pc.PAD_1, pc.PAD_UP)) {\n                    entity.rotate(-1, 0, 0);\n                }\n                if (gamepads.wasPressed(pc.PAD_1, pc.PAD_DOWN)) {\n                    entity.rotate(1, 0, 0);\n                }\n            });\n        });\n    });\n}\n","nameSlug":"gamepad","categorySlug":"input"},"keyboard":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'helipad': new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // set skybox\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.exposure = 1.6;\n            app.scene.skyboxMip = 1;\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5)\n            });\n            camera.translate(0, 7, 25);\n            app.root.addChild(camera);\n\n            const entity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            const keyboard = new pc.Keyboard(document.body);\n            app.on(\"update\", function () {\n                if (keyboard.isPressed(pc.KEY_LEFT)) {\n                    entity.rotate(0, -1, 0);\n                }\n                if (keyboard.isPressed(pc.KEY_RIGHT)) {\n                    entity.rotate(0, 1, 0);\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // set skybox\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.exposure = 1.6;\n            app.scene.skyboxMip = 1;\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n            });\n\n            camera.translate(0, 7, 25);\n            app.root.addChild(camera);\n\n            const entity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            const keyboard = new pc.Keyboard(document.body);\n            app.on(\"update\", function () {\n                if (keyboard.isPressed(pc.KEY_LEFT)) {\n                    entity.rotate(0, -1, 0);\n                }\n                if (keyboard.isPressed(pc.KEY_RIGHT)) {\n                    entity.rotate(0, 1, 0);\n                }\n            });\n        });\n    });\n}\n","nameSlug":"keyboard","categorySlug":"input"},"mouse":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n    const assets = {\n        'helipad': new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'statue': new pc.Asset('statue', 'container', { url: '/static/assets/models/statue.glb' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // set skybox\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.exposure = 1.6;\n            app.scene.skyboxMip = 1;\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5)\n            });\n            camera.translate(0, 7, 25);\n            app.root.addChild(camera);\n\n            const entity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            const mouse = new pc.Mouse(document.body);\n\n            let x = 0;\n            const y = 0;\n\n            mouse.on('mousemove', function (event) {\n                if (event.buttons[pc.MOUSEBUTTON_LEFT]) {\n                    x += event.dx;\n\n                    entity.setLocalEulerAngles(0.2 * y, 0.2 * x, 0);\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        statue: new pc.Asset(\"statue\", \"container\", {\n            url: \"/static/assets/models/statue.glb\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // set skybox\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.exposure = 1.6;\n            app.scene.skyboxMip = 1;\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.4, 0.45, 0.5),\n            });\n\n            camera.translate(0, 7, 25);\n            app.root.addChild(camera);\n\n            const entity = assets.statue.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            const mouse = new pc.Mouse(document.body);\n\n            let x = 0;\n            const y = 0;\n\n            mouse.on(\"mousemove\", function (event) {\n                if (event.buttons[pc.MOUSEBUTTON_LEFT]) {\n                    x += event.dx;\n\n                    entity.setLocalEulerAngles(0.2 * y, 0.2 * x, 0);\n                }\n            });\n        });\n    });\n}\n","nameSlug":"mouse","categorySlug":"input"}},"loaders":{"draco-glb":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    pc.WasmModule.setConfig('DracoDecoderModule', {\n        glueUrl: '/static/lib/draco/draco.wasm.js',\n        wasmUrl: '/static/lib/draco/draco.wasm.wasm',\n        fallbackUrl: '/static/lib/draco/draco.js'\n    });\n\n    pc.WasmModule.getInstance('DracoDecoderModule', demo);\n\n    function demo() {\n\n        const gfxOptions = {\n            deviceTypes: [deviceType],\n            glslangUrl: '/static/lib/glslang/glslang.js',\n            twgslUrl: '/static/lib/twgsl/twgsl.js'\n        };\n\n        pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.RenderComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.LightComponentSystem\n            ];\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.ContainerHandler\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assets = {\n                heart: new pc.Asset('heart', 'container', { url: '/static/assets/models/heart_draco.glb' })\n            };\n\n            const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n            assetListLoader.load(() => {\n\n                app.start();\n\n                app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n                // create an instance using render component\n                const entity = assets.heart.resource.instantiateRenderEntity({\n                    receiveShadows: false\n                });\n                app.root.addChild(entity);\n                entity.setLocalScale(20, 20, 20);\n\n                // Create an Entity with a camera component\n                const camera = new pc.Entity();\n                camera.addComponent(\"camera\", {\n                    clearColor: new pc.Color(0.2, 0.2, 0.2)\n                });\n                camera.translate(0, 0.5, 4);\n                app.root.addChild(camera);\n\n                // Create an entity with a omni light component\n                const light = new pc.Entity();\n                light.addComponent(\"light\", {\n                    type: \"omni\",\n                    intensity: 3\n                });\n                light.setLocalPosition(1, 1, 5);\n                app.root.addChild(light);\n\n                app.on(\"update\", function (dt) {\n                    if (entity) {\n                        entity.rotate(4 * dt, -20 * dt, 0);\n                    }\n                });\n            });\n        });\n    }\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    pc.WasmModule.setConfig(\"DracoDecoderModule\", {\n        glueUrl: \"/static/lib/draco/draco.wasm.js\",\n        wasmUrl: \"/static/lib/draco/draco.wasm.wasm\",\n        fallbackUrl: \"/static/lib/draco/draco.js\",\n    });\n\n    pc.WasmModule.getInstance(\"DracoDecoderModule\", demo);\n\n    function demo() {\n        const gfxOptions = {\n            deviceTypes: [deviceType],\n            glslangUrl: \"/static/lib/glslang/glslang.js\",\n            twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n        };\n\n        pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.RenderComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.LightComponentSystem,\n            ];\n\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.ContainerHandler,\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assets = {\n                heart: new pc.Asset(\"heart\", \"container\", {\n                    url: \"/static/assets/models/heart_draco.glb\",\n                }),\n            };\n\n            const assetListLoader = new pc.AssetListLoader(\n                Object.values(assets),\n                app.assets\n            );\n            assetListLoader.load(() => {\n                app.start();\n\n                app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n                // create an instance using render component\n                const entity = assets.heart.resource.instantiateRenderEntity({\n                    receiveShadows: false,\n                });\n\n                app.root.addChild(entity);\n                entity.setLocalScale(20, 20, 20);\n\n                // Create an Entity with a camera component\n                const camera = new pc.Entity();\n                camera.addComponent(\"camera\", {\n                    clearColor: new pc.Color(0.2, 0.2, 0.2),\n                });\n\n                camera.translate(0, 0.5, 4);\n                app.root.addChild(camera);\n\n                // Create an entity with a omni light component\n                const light = new pc.Entity();\n                light.addComponent(\"light\", {\n                    type: \"omni\",\n                    intensity: 3,\n                });\n\n                light.setLocalPosition(1, 1, 5);\n                app.root.addChild(light);\n\n                app.on(\"update\", function (dt) {\n                    if (entity) {\n                        entity.rotate(4 * dt, -20 * dt, 0);\n                    }\n                });\n            });\n        });\n    }\n}\n","nameSlug":"draco-glb","categorySlug":"loaders"},"glb":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // The example demonstrates loading of glb file, which contains meshes,\n    // lights and cameras, and switches between the cameras every 2 seconds.\n\n    const assets = {\n        'scene': new pc.Asset('scene', 'container', { url: '/static/assets/models/geometry-camera-light.glb' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // the array will store loaded cameras\n            let camerasComponents: Array<pc.CameraComponent> = null;\n\n            // glb lights use physical units\n            app.scene.physicalUnits = true;\n\n            // create an instance using render component\n            const entity = assets.scene.resource.instantiateRenderEntity({\n            });\n            app.root.addChild(entity);\n\n            // find all cameras - by default they are disabled\n            camerasComponents = entity.findComponents(\"camera\");\n            camerasComponents.forEach((component) => {\n\n                // set the aspect ratio to automatic to work with any window size\n                component.aspectRatioMode = pc.ASPECT_AUTO;\n\n                // set up exposure for physical units\n                component.aperture = 4;\n                component.shutter = 1 / 100;\n                component.sensitivity = 500;\n            });\n\n            // enable all lights from the glb\n            const lightComponents: Array<pc.LightComponent> = entity.findComponents(\"light\");\n            lightComponents.forEach((component) => {\n                component.enabled = true;\n            });\n\n            let time = 0;\n            let activeCamera = 0;\n            app.on(\"update\", function (dt) {\n                time -= dt;\n\n                // change the camera every few seconds\n                if (time <= 0) {\n                    time = 2;\n\n                    // disable current camera\n                    camerasComponents[activeCamera].enabled = false;\n\n                    // activate next camera\n                    activeCamera = (activeCamera + 1) % camerasComponents.length;\n                    camerasComponents[activeCamera].enabled = true;\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // The example demonstrates loading of glb file, which contains meshes,\n    // lights and cameras, and switches between the cameras every 2 seconds.\n\n    const assets = {\n        scene: new pc.Asset(\"scene\", \"container\", {\n            url: \"/static/assets/models/geometry-camera-light.glb\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // the array will store loaded cameras\n            let camerasComponents = null;\n\n            // glb lights use physical units\n            app.scene.physicalUnits = true;\n\n            // create an instance using render component\n            const entity = assets.scene.resource.instantiateRenderEntity({});\n\n            app.root.addChild(entity);\n\n            // find all cameras - by default they are disabled\n            camerasComponents = entity.findComponents(\"camera\");\n            camerasComponents.forEach((component) => {\n                // set the aspect ratio to automatic to work with any window size\n                component.aspectRatioMode = pc.ASPECT_AUTO;\n\n                // set up exposure for physical units\n                component.aperture = 4;\n                component.shutter = 1 / 100;\n                component.sensitivity = 500;\n            });\n\n            // enable all lights from the glb\n            const lightComponents = entity.findComponents(\"light\");\n            lightComponents.forEach((component) => {\n                component.enabled = true;\n            });\n\n            let time = 0;\n            let activeCamera = 0;\n            app.on(\"update\", function (dt) {\n                time -= dt;\n\n                // change the camera every few seconds\n                if (time <= 0) {\n                    time = 2;\n\n                    // disable current camera\n                    camerasComponents[activeCamera].enabled = false;\n\n                    // activate next camera\n                    activeCamera =\n                        (activeCamera + 1) % camerasComponents.length;\n                    camerasComponents[activeCamera].enabled = true;\n                }\n            });\n        });\n    });\n}\n","nameSlug":"glb","categorySlug":"loaders"},"gltf-export":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, pcx: any, data: any): void {\n\n    // set up and load draco module, as the glb we load is draco compressed\n    pc.WasmModule.setConfig('DracoDecoderModule', {\n        glueUrl: '/static/lib/draco/draco.wasm.js',\n        wasmUrl: '/static/lib/draco/draco.wasm.wasm',\n        fallbackUrl: '/static/lib/draco/draco.js'\n    });\n\n    pc.WasmModule.getInstance('DracoDecoderModule', demo);\n\n    function demo() {\n\n        const assets = {\n            'helipad': new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n            'bench': new pc.Asset('bench', 'container', { url: '/static/assets/models/bench_wooden_01.glb' }),\n            'model': new pc.Asset('model', 'container', { url: '/static/assets/models/bitmoji.glb' }),\n            'board': new pc.Asset('statue', 'container', { url: '/static/assets/models/chess-board.glb' })\n        };\n\n        const gfxOptions = {\n            deviceTypes: [deviceType],\n            glslangUrl: '/static/lib/glslang/glslang.js',\n            twgslUrl: '/static/lib/twgsl/twgsl.js'\n        };\n\n        pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.RenderComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.LightComponentSystem\n            ];\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.ContainerHandler\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n            assetListLoader.load(() => {\n\n                app.start();\n\n                // get the instance of the bench and set up with render component\n                const entity1 = assets.bench.resource.instantiateRenderEntity();\n                entity1.setLocalPosition(0, 0, -1.5);\n                app.root.addChild(entity1);\n\n                // the character\n                const entity2 = assets.model.resource.instantiateRenderEntity();\n                app.root.addChild(entity2);\n\n                // chess board\n                const entity3 = assets.board.resource.instantiateRenderEntity();\n                entity3.setLocalScale(0.01, 0.01, 0.01);\n                app.root.addChild(entity3);\n\n                // a render component with a sphere and cone primitives\n                const material = new pc.StandardMaterial();\n                material.diffuse = pc.Color.RED;\n                material.update();\n\n                const entity = new pc.Entity(\"TwoMeshInstances\");\n                entity.addComponent('render', {\n                    type: 'asset',\n                    meshInstances: [\n                        new pc.MeshInstance(pc.createSphere(app.graphicsDevice), material),\n                        new pc.MeshInstance(pc.createCone(app.graphicsDevice), material)\n                    ]\n                });\n                app.root.addChild(entity);\n                entity.setLocalPosition(0, 1.5, -1.5);\n\n                // Create an Entity with a camera component\n                const camera = new pc.Entity();\n                camera.addComponent(\"camera\", {\n                    clearColor: new pc.Color(0.2, 0.1, 0.1),\n                    farClip: 100\n                });\n                camera.translate(-3, 1, 2);\n                camera.lookAt(0, 0.5, 0);\n                app.root.addChild(camera);\n\n                // set skybox\n                app.scene.envAtlas = assets.helipad.resource;\n                app.scene.toneMapping = pc.TONEMAP_ACES;\n                app.scene.skyboxMip = 1;\n                app.scene.exposure = 1.5;\n\n                // a link element, created in the html part of the examples.\n                const link = document.getElementById('ar-link');\n\n                // export the whole scene into a glb format\n                const options = {\n                    maxTextureSize: 1024\n                };\n\n                new pcx.GltfExporter().build(app.root, options).then((arrayBuffer: any) => {\n\n                    const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' });\n\n                    // @ts-ignore\n                    link.download = \"scene.glb\";\n\n                    // @ts-ignore\n                    link.href = URL.createObjectURL(blob);\n                }).catch(console.error);\n\n                // when clicking on the download UI button, trigger the download\n                data.on('download', function () {\n                    link.click();\n                });\n            });\n        });\n    }\n}","javaScriptFunction":"function example(canvas, deviceType, pcx, data) {\n    // set up and load draco module, as the glb we load is draco compressed\n    pc.WasmModule.setConfig(\"DracoDecoderModule\", {\n        glueUrl: \"/static/lib/draco/draco.wasm.js\",\n        wasmUrl: \"/static/lib/draco/draco.wasm.wasm\",\n        fallbackUrl: \"/static/lib/draco/draco.js\",\n    });\n\n    pc.WasmModule.getInstance(\"DracoDecoderModule\", demo);\n\n    function demo() {\n        const assets = {\n            helipad: new pc.Asset(\n                \"helipad-env-atlas\",\n                \"texture\",\n                { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n                { type: pc.TEXTURETYPE_RGBP }\n            ),\n            bench: new pc.Asset(\"bench\", \"container\", {\n                url: \"/static/assets/models/bench_wooden_01.glb\",\n            }),\n            model: new pc.Asset(\"model\", \"container\", {\n                url: \"/static/assets/models/bitmoji.glb\",\n            }),\n            board: new pc.Asset(\"statue\", \"container\", {\n                url: \"/static/assets/models/chess-board.glb\",\n            }),\n        };\n\n        const gfxOptions = {\n            deviceTypes: [deviceType],\n            glslangUrl: \"/static/lib/glslang/glslang.js\",\n            twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n        };\n\n        pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.RenderComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.LightComponentSystem,\n            ];\n\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.ContainerHandler,\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assetListLoader = new pc.AssetListLoader(\n                Object.values(assets),\n                app.assets\n            );\n            assetListLoader.load(() => {\n                app.start();\n\n                // get the instance of the bench and set up with render component\n                const entity1 = assets.bench.resource.instantiateRenderEntity();\n                entity1.setLocalPosition(0, 0, -1.5);\n                app.root.addChild(entity1);\n\n                // the character\n                const entity2 = assets.model.resource.instantiateRenderEntity();\n                app.root.addChild(entity2);\n\n                // chess board\n                const entity3 = assets.board.resource.instantiateRenderEntity();\n                entity3.setLocalScale(0.01, 0.01, 0.01);\n                app.root.addChild(entity3);\n\n                // a render component with a sphere and cone primitives\n                const material = new pc.StandardMaterial();\n                material.diffuse = pc.Color.RED;\n                material.update();\n\n                const entity = new pc.Entity(\"TwoMeshInstances\");\n                entity.addComponent(\"render\", {\n                    type: \"asset\",\n                    meshInstances: [\n                        new pc.MeshInstance(\n                            pc.createSphere(app.graphicsDevice),\n                            material\n                        ),\n                        new pc.MeshInstance(\n                            pc.createCone(app.graphicsDevice),\n                            material\n                        ),\n                    ],\n                });\n\n                app.root.addChild(entity);\n                entity.setLocalPosition(0, 1.5, -1.5);\n\n                // Create an Entity with a camera component\n                const camera = new pc.Entity();\n                camera.addComponent(\"camera\", {\n                    clearColor: new pc.Color(0.2, 0.1, 0.1),\n                    farClip: 100,\n                });\n\n                camera.translate(-3, 1, 2);\n                camera.lookAt(0, 0.5, 0);\n                app.root.addChild(camera);\n\n                // set skybox\n                app.scene.envAtlas = assets.helipad.resource;\n                app.scene.toneMapping = pc.TONEMAP_ACES;\n                app.scene.skyboxMip = 1;\n                app.scene.exposure = 1.5;\n\n                // a link element, created in the html part of the examples.\n                const link = document.getElementById(\"ar-link\");\n\n                // export the whole scene into a glb format\n                const options = {\n                    maxTextureSize: 1024,\n                };\n\n                new pcx.GltfExporter()\n                    .build(app.root, options)\n                    .then((arrayBuffer) => {\n                        const blob = new Blob([arrayBuffer], {\n                            type: \"application/octet-stream\",\n                        });\n\n                        // @ts-ignore\n                        link.download = \"scene.glb\";\n\n                        // @ts-ignore\n                        link.href = URL.createObjectURL(blob);\n                    })\n                    .catch(console.error);\n\n                // when clicking on the download UI button, trigger the download\n                data.on(\"download\", function () {\n                    link.click();\n                });\n            });\n        });\n    }\n}\n","nameSlug":"gltf-export","categorySlug":"loaders"},"loaders-gl":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, files: { 'shader.vert': string, 'shader.frag': string }): void {\n    // This example uses draco point cloud loader library from https://loaders.gl/\n    // Note that many additional formats are supported by the library and can be used.\n\n    // Create the app\n    const app = new pc.Application(canvas, {});\n    async function loadModel(url:string) {\n\n        // load the url using the draco format loader\n        // @ts-ignore: cannot find CORE and DRACO\n        const modelData = await CORE.load(url, DRACO.DracoLoader);\n\n        // loaded colors only contain RGB, convert it to an array of RGBA with alpha of 255\n        const srcColors = modelData.attributes.COLOR_0.value;\n        const numVertices = srcColors.length / modelData.attributes.COLOR_0.size;\n        const colors32 = new Uint8Array(numVertices * 4);\n        for (let i = 0; i < numVertices; i++) {\n            colors32[i * 4 + 0] = srcColors[i * 3 + 0];\n            colors32[i * 4 + 1] = srcColors[i * 3 + 1];\n            colors32[i * 4 + 2] = srcColors[i * 3 + 2];\n            colors32[i * 4 + 3] = 255;\n        }\n\n        // based on the loaded data, create the mesh with position and color vertex data\n        const mesh = new pc.Mesh(app.graphicsDevice);\n        mesh.clear(true, false);\n        mesh.setPositions(modelData.attributes.POSITION.value, modelData.attributes.POSITION.size);\n        mesh.setColors32(colors32);\n        mesh.update(pc.PRIMITIVE_POINTS);\n\n        // Create shader to render mesh as circular points with color\n        const shaderDefinition = {\n            attributes: {\n                aPosition: pc.SEMANTIC_POSITION,\n                aColor: pc.SEMANTIC_COLOR\n            },\n            vshader: files['shader.vert'],\n            fshader: files['shader.frag']\n        };\n        const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n        // create material using the shader\n        const material = new pc.Material();\n        material.shader = shader;\n        material.blendType = pc.BLENDMODE_ONE_MINUS_DST_ALPHA;\n        material.cull = pc.CULLFACE_NONE;\n\n        // Add an entity with a render component to render the mesh\n        const entity = new pc.Entity();\n        entity.addComponent('render', {\n            material: material,\n            meshInstances: [new pc.MeshInstance(mesh, material)]\n        });\n\n        app.root.addChild(entity);\n    }\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n        farClip: 100\n    });\n    camera.translate(-20, 15, 20);\n    camera.lookAt(0, 7, 0);\n    app.root.addChild(camera);\n\n    // load the draco model, and then start the application\n    loadModel(\"/static/assets/models/park_points.drc\").then(() => {\n        app.start();\n    });\n\n    // update things each frame\n    let time = 0;\n    app.on(\"update\", function (dt) {\n        time += dt;\n\n        // orbit the camera\n        if (camera) {\n            camera.setLocalPosition(40 * Math.sin(time * 0.5), 10, 20 * Math.cos(time * 0.5));\n            camera.lookAt(pc.Vec3.ZERO);\n        }\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, files) {\n    // This example uses draco point cloud loader library from https://loaders.gl/\n    // Note that many additional formats are supported by the library and can be used.\n\n    // Create the app\n    const app = new pc.Application(canvas, {});\n    async function loadModel(url) {\n        // load the url using the draco format loader\n        // @ts-ignore: cannot find CORE and DRACO\n        const modelData = await CORE.load(url, DRACO.DracoLoader);\n\n        // loaded colors only contain RGB, convert it to an array of RGBA with alpha of 255\n        const srcColors = modelData.attributes.COLOR_0.value;\n        const numVertices =\n            srcColors.length / modelData.attributes.COLOR_0.size;\n        const colors32 = new Uint8Array(numVertices * 4);\n        for (let i = 0; i < numVertices; i++) {\n            colors32[i * 4 + 0] = srcColors[i * 3 + 0];\n            colors32[i * 4 + 1] = srcColors[i * 3 + 1];\n            colors32[i * 4 + 2] = srcColors[i * 3 + 2];\n            colors32[i * 4 + 3] = 255;\n        }\n\n        // based on the loaded data, create the mesh with position and color vertex data\n        const mesh = new pc.Mesh(app.graphicsDevice);\n        mesh.clear(true, false);\n        mesh.setPositions(\n            modelData.attributes.POSITION.value,\n            modelData.attributes.POSITION.size\n        );\n        mesh.setColors32(colors32);\n        mesh.update(pc.PRIMITIVE_POINTS);\n\n        // Create shader to render mesh as circular points with color\n        const shaderDefinition = {\n            attributes: {\n                aPosition: pc.SEMANTIC_POSITION,\n                aColor: pc.SEMANTIC_COLOR,\n            },\n\n            vshader: files[\"shader.vert\"],\n            fshader: files[\"shader.frag\"],\n        };\n\n        const shader = new pc.Shader(app.graphicsDevice, shaderDefinition);\n\n        // create material using the shader\n        const material = new pc.Material();\n        material.shader = shader;\n        material.blendType = pc.BLENDMODE_ONE_MINUS_DST_ALPHA;\n        material.cull = pc.CULLFACE_NONE;\n\n        // Add an entity with a render component to render the mesh\n        const entity = new pc.Entity();\n        entity.addComponent(\"render\", {\n            material: material,\n            meshInstances: [new pc.MeshInstance(mesh, material)],\n        });\n\n        app.root.addChild(entity);\n    }\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n        farClip: 100,\n    });\n\n    camera.translate(-20, 15, 20);\n    camera.lookAt(0, 7, 0);\n    app.root.addChild(camera);\n\n    // load the draco model, and then start the application\n    loadModel(\"/static/assets/models/park_points.drc\").then(() => {\n        app.start();\n    });\n\n    // update things each frame\n    let time = 0;\n    app.on(\"update\", function (dt) {\n        time += dt;\n\n        // orbit the camera\n        if (camera) {\n            camera.setLocalPosition(\n                40 * Math.sin(time * 0.5),\n                10,\n                20 * Math.cos(time * 0.5)\n            );\n            camera.lookAt(pc.Vec3.ZERO);\n        }\n    });\n}\n","nameSlug":"loaders-gl","categorySlug":"loaders","files":{"shader.vert":"\n// Attributes per vertex: position\nattribute vec4 aPosition;\nattribute vec4 aColor;\n\nuniform mat4   matrix_viewProjection;\nuniform mat4   matrix_model;\n\n// Color to fragment program\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    mat4 modelViewProj = matrix_viewProjection * matrix_model;\n    gl_Position = modelViewProj * aPosition;\n\n    gl_PointSize = 1.5;\n    outColor = aColor;\n}","shader.frag":"\nprecision lowp float;\nvarying vec4 outColor;\n\nvoid main(void)\n{\n    // just output color supplied by vertex shader\n    gl_FragColor = outColor;\n}"}},"obj":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    const objurl = \"/static/assets/models/monkey.obj\";\n    const scripturl = \"/static/scripts/parsers/obj-model.js\";\n\n    let entity: pc.Entity;\n    app.assets.loadFromUrl(scripturl, \"script\", function () {\n\n        // OBJ Parser is not enabled by default in engine. Add the parser to the model resource handler\n        // set up obj parser\n        // @ts-ignore globally loaded ObjModelParser\n        app.loader.getHandler(\"model\").addParser(new ObjModelParser(app.graphicsDevice), function (url) {\n            return (pc.path.getExtension(url) === '.obj');\n        });\n\n        app.assets.loadFromUrl(objurl, \"model\", function (err, asset) {\n\n            app.start();\n\n            entity = new pc.Entity();\n            entity.addComponent(\"model\");\n            entity.model.model = asset.resource;\n            app.root.addChild(entity);\n\n            // add a randomly generated material to all mesh instances\n            const mis = entity.model.meshInstances;\n            for (let i = 0; i < mis.length; i++) {\n                const material = new pc.StandardMaterial();\n                material.diffuse = new pc.Color(pc.math.random(0, 1), pc.math.random(0, 1), pc.math.random(0, 1));\n                material.update();\n                mis[i].material = material;\n            }\n        });\n    });\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    camera.translate(0, 0, 5);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component\n    const light = new pc.Entity();\n    light.addComponent(\"light\", {\n        type: \"omni\",\n        color: new pc.Color(1, 1, 1),\n        range: 100\n    });\n    light.translate(5, 0, 15);\n    app.root.addChild(light);\n\n    app.on(\"update\", function (dt) {\n        if (entity) {\n            entity.rotate(0, 100 * dt, 0);\n        }\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the app and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n    const objurl = \"/static/assets/models/monkey.obj\";\n    const scripturl = \"/static/scripts/parsers/obj-model.js\";\n\n    let entity;\n    app.assets.loadFromUrl(scripturl, \"script\", function () {\n        // OBJ Parser is not enabled by default in engine. Add the parser to the model resource handler\n        // set up obj parser\n        // @ts-ignore globally loaded ObjModelParser\n        app.loader\n            .getHandler(\"model\")\n            .addParser(new ObjModelParser(app.graphicsDevice), function (url) {\n                return pc.path.getExtension(url) === \".obj\";\n            });\n\n        app.assets.loadFromUrl(objurl, \"model\", function (err, asset) {\n            app.start();\n\n            entity = new pc.Entity();\n            entity.addComponent(\"model\");\n            entity.model.model = asset.resource;\n            app.root.addChild(entity);\n\n            // add a randomly generated material to all mesh instances\n            const mis = entity.model.meshInstances;\n            for (let i = 0; i < mis.length; i++) {\n                const material = new pc.StandardMaterial();\n                material.diffuse = new pc.Color(\n                    pc.math.random(0, 1),\n                    pc.math.random(0, 1),\n                    pc.math.random(0, 1)\n                );\n                material.update();\n                mis[i].material = material;\n            }\n        });\n    });\n\n    // Create an Entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.4, 0.45, 0.5),\n    });\n\n    camera.translate(0, 0, 5);\n    app.root.addChild(camera);\n\n    // Create an Entity with a omni light component\n    const light = new pc.Entity();\n    light.addComponent(\"light\", {\n        type: \"omni\",\n        color: new pc.Color(1, 1, 1),\n        range: 100,\n    });\n\n    light.translate(5, 0, 15);\n    app.root.addChild(light);\n\n    app.on(\"update\", function (dt) {\n        if (entity) {\n            entity.rotate(0, 100 * dt, 0);\n        }\n    });\n}\n","nameSlug":"obj","categorySlug":"loaders"},"usdz-export":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, pcx: any, data: any): void {\n\n    const assets = {\n        'helipad': new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n        'bench': new pc.Asset('bench', 'container', { url: '/static/assets/models/bench_wooden_01.glb' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n\n            // get the instance of the bench and set up with render component\n            const entity = assets.bench.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.1, 0.1),\n                farClip: 100\n            });\n            camera.translate(-3, 1, 2);\n            camera.lookAt(0, 0.5, 0);\n            app.root.addChild(camera);\n\n            // set skybox\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.skyboxMip = 1;\n\n            // a link element, created in the html part of the examples.\n            const link = document.getElementById('ar-link');\n\n            // convert the loaded entity into asdz file\n            const options = {\n                maxTextureSize: 1024\n            };\n\n            new pcx.UsdzExporter().build(entity, options).then((arrayBuffer: any) => {\n                const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' });\n\n                // On iPhone Safari, this link creates a clickable AR link on the screen. When this is clicked,\n                // the download of the .asdz file triggers its opening in QuickLook AT mode.\n                // In other browsers, this simply downloads the generated .asdz file.\n\n                // @ts-ignore\n                link.download = \"bench.usdz\";\n\n                // @ts-ignore\n                link.href = URL.createObjectURL(blob);\n            }).catch(console.error);\n\n            // when clicking on the download UI button, trigger the download\n            data.on('download', function () {\n                link.click();\n            });\n\n            // spin the meshe\n            app.on(\"update\", function (dt) {\n                if (entity) {\n                    entity.rotate(0, -12 * dt, 0);\n                }\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, pcx, data) {\n    const assets = {\n        helipad: new pc.Asset(\n            \"helipad-env-atlas\",\n            \"texture\",\n            { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n            { type: pc.TEXTURETYPE_RGBP }\n        ),\n        bench: new pc.Asset(\"bench\", \"container\", {\n            url: \"/static/assets/models/bench_wooden_01.glb\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // get the instance of the bench and set up with render component\n            const entity = assets.bench.resource.instantiateRenderEntity();\n            app.root.addChild(entity);\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.2, 0.1, 0.1),\n                farClip: 100,\n            });\n\n            camera.translate(-3, 1, 2);\n            camera.lookAt(0, 0.5, 0);\n            app.root.addChild(camera);\n\n            // set skybox\n            app.scene.envAtlas = assets.helipad.resource;\n            app.scene.toneMapping = pc.TONEMAP_ACES;\n            app.scene.skyboxMip = 1;\n\n            // a link element, created in the html part of the examples.\n            const link = document.getElementById(\"ar-link\");\n\n            // convert the loaded entity into asdz file\n            const options = {\n                maxTextureSize: 1024,\n            };\n\n            new pcx.UsdzExporter()\n                .build(entity, options)\n                .then((arrayBuffer) => {\n                    const blob = new Blob([arrayBuffer], {\n                        type: \"application/octet-stream\",\n                    });\n\n                    // On iPhone Safari, this link creates a clickable AR link on the screen. When this is clicked,\n                    // the download of the .asdz file triggers its opening in QuickLook AT mode.\n                    // In other browsers, this simply downloads the generated .asdz file.\n\n                    // @ts-ignore\n                    link.download = \"bench.usdz\";\n\n                    // @ts-ignore\n                    link.href = URL.createObjectURL(blob);\n                })\n                .catch(console.error);\n\n            // when clicking on the download UI button, trigger the download\n            data.on(\"download\", function () {\n                link.click();\n            });\n\n            // spin the meshe\n            app.on(\"update\", function (dt) {\n                if (entity) {\n                    entity.rotate(0, -12 * dt, 0);\n                }\n            });\n        });\n    });\n}\n","nameSlug":"usdz-export","categorySlug":"loaders"}},"misc":{"hello-world":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // create box entity\n        const box = new pc.Entity('cube');\n        box.addComponent('render', {\n            type: 'box'\n        });\n        app.root.addChild(box);\n\n        // create camera entity\n        const camera = new pc.Entity('camera');\n        camera.addComponent('camera', {\n            clearColor: new pc.Color(0.5, 0.6, 0.9)\n        });\n        app.root.addChild(camera);\n        camera.setPosition(0, 0, 3);\n\n        // create directional light entity\n        const light = new pc.Entity('light');\n        light.addComponent('light');\n        app.root.addChild(light);\n        light.setEulerAngles(45, 0, 0);\n\n        // rotate the box according to the delta time since the last frame\n        app.on('update', (dt: number) => box.rotate(10 * dt, 20 * dt, 30 * dt));\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ContainerHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n        app.start();\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        // create box entity\n        const box = new pc.Entity(\"cube\");\n        box.addComponent(\"render\", {\n            type: \"box\",\n        });\n\n        app.root.addChild(box);\n\n        // create camera entity\n        const camera = new pc.Entity(\"camera\");\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(0.5, 0.6, 0.9),\n        });\n\n        app.root.addChild(camera);\n        camera.setPosition(0, 0, 3);\n\n        // create directional light entity\n        const light = new pc.Entity(\"light\");\n        light.addComponent(\"light\");\n        app.root.addChild(light);\n        light.setEulerAngles(45, 0, 0);\n\n        // rotate the box according to the delta time since the last frame\n        app.on(\"update\", (dt) => box.rotate(10 * dt, 20 * dt, 30 * dt));\n    });\n}\n","nameSlug":"hello-world","categorySlug":"misc"},"mini-stats":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, pcx: any): void {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // set up options for mini-stats, start with the default options\n    const options = pcx.MiniStats.getDefaultOptions();\n\n    // configure sizes\n    options.sizes = [\n        { width: 128, height: 16, spacing: 0, graphs: false },\n        { width: 256, height: 32, spacing: 2, graphs: true },\n        { width: 500, height: 64, spacing: 2, graphs: true }\n    ];\n\n    // when the application starts, use the largest size\n    options.startSizeIndex = 2;\n\n    // display additional counters\n    // Note: for most of these to report values, either debug or profiling engine build needs to be used.\n    options.stats = [\n\n        // frame update time in ms\n        {\n            name: \"Update\",\n            stats: [\"frame.updateTime\"],\n            decimalPlaces: 1,\n            unitsName: \"ms\",\n            watermark: 33\n        },\n\n        // total number of draw calls\n        {\n            name: \"DrawCalls\",\n            stats: [\"drawCalls.total\"],\n            watermark: 2000\n        },\n\n        // total number of triangles, in 1000s\n        {\n            name: \"triCount\",\n            stats: [\"frame.triangles\"],\n            decimalPlaces: 1,\n            multiplier: 1 / 1000,\n            unitsName: \"k\",\n            watermark: 500\n        },\n\n        // number of materials used in a frame\n        {\n            name: \"materials\",\n            stats: [\"frame.materials\"],\n            watermark: 2000\n        },\n\n        // frame time it took to do frustum culling\n        {\n            name: \"cull\",\n            stats: [\"frame.cullTime\"],\n            decimalPlaces: 1,\n            watermark: 1,\n            unitsName: \"ms\"\n        },\n\n        // used VRAM, displayed using 2 colors - red for textures, green for geometry\n        {\n            name: \"VRAM\",\n            stats: [\"vram.tex\", \"vram.geom\"],\n            decimalPlaces: 1,\n            multiplier: 1 / (1024 * 1024),\n            unitsName: \"MB\",\n            watermark: 100\n        },\n\n        // frames per second\n        {\n            name: \"FPS\",\n            stats: [\"frame.fps\"],\n            watermark: 60\n        },\n\n        // delta time\n        {\n            name: \"Frame\",\n            stats: [\"frame.ms\"],\n            decimalPlaces: 1,\n            unitsName: \"ms\",\n            watermark: 33\n        }\n    ];\n\n    // create mini-stats system\n    const miniStats = new pcx.MiniStats(app, options);\n\n    // add directional lights to the scene\n    const light = new pc.Entity();\n    light.addComponent(\"light\", {\n        type: \"directional\"\n    });\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 30, 0);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1)\n    });\n    app.root.addChild(camera);\n    camera.setLocalPosition(20, 10, 10);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // helper function to create a primitive with shape type, position, scale\n    function createPrimitive(primitiveType: string, position: number | pc.Vec3, scale: number | pc.Vec3) {\n        // create material of random color\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(Math.random(), Math.random(), Math.random());\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent('model', {\n            type: primitiveType\n        });\n        primitive.model.material = material;\n\n        // set position and scale\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n\n        return primitive;\n    }\n\n    // list of all created engine resources\n    const entities: any[] = [];\n    const vertexBuffers: any[] = [];\n    const textures: any[] = [];\n\n    // update function called every frame\n    let adding = true;\n    const step = 10, max = 2000;\n    let entity: pc.GraphNode, vertexBuffer: pc.VertexBuffer, texture: { destroy: () => void; };\n    app.on(\"update\", function () {\n\n        // execute some tasks multiple times per frame\n        for (let i = 0; i < step; i++) {\n\n            // allocating resources\n            if (adding) {\n\n                // add entity (they used shared geometry internally, and we create individual material for each)\n                const shape = Math.random() < 0.5 ? \"box\" : \"sphere\";\n                const position = new pc.Vec3(Math.random() * 10, Math.random() * 10, Math.random() * 10);\n                const scale = 0.5 + Math.random();\n                entity = createPrimitive(shape, position, new pc.Vec3(scale, scale, scale));\n                entities.push(entity);\n                app.root.addChild(entity);\n\n                // if allocation reached the max limit, switch to removing mode\n                if (entities.length >= max) {\n                    adding = false;\n                }\n\n                // add vertex buffer\n                const vertexCount = 500;\n                const data = new Float32Array(vertexCount * 16);\n                vertexBuffer = new pc.VertexBuffer(app.graphicsDevice, pc.VertexFormat.getDefaultInstancingFormat(app.graphicsDevice),\n                                                   vertexCount, pc.BUFFER_STATIC, data);\n                vertexBuffers.push(vertexBuffer);\n\n                // allocate texture\n                const texture = new pc.Texture(app.graphicsDevice, {\n                    width: 64,\n                    height: 64,\n                    format: pc.PIXELFORMAT_RGB8,\n                    mipmaps: false\n                });\n                textures.push(texture);\n\n                // ensure texture is uploaded (actual VRAM is allocated)\n                texture.lock();\n                texture.unlock();\n                // @ts-ignore engine-tsd\n                app.graphicsDevice.setTexture(texture, 0);\n\n            } else {    // de-allocating resources\n\n                if (entities.length > 0) {\n\n                    // destroy entities\n                    entity = entities[entities.length - 1];\n                    // @ts-ignore engine-tsd\n                    entity.destroy();\n                    entities.length--;\n\n                    // destroy vertex buffer\n                    vertexBuffer = vertexBuffers[vertexBuffers.length - 1];\n                    vertexBuffer.destroy();\n                    vertexBuffers.length--;\n\n                    // destroy texture\n                    texture = textures[textures.length - 1];\n                    texture.destroy();\n                    textures.length--;\n                } else {\n                    adding = true;\n                }\n            }\n        }\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, pcx) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n    app.start();\n\n    // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // set up options for mini-stats, start with the default options\n    const options = pcx.MiniStats.getDefaultOptions();\n\n    // configure sizes\n    options.sizes = [\n        { width: 128, height: 16, spacing: 0, graphs: false },\n        { width: 256, height: 32, spacing: 2, graphs: true },\n        { width: 500, height: 64, spacing: 2, graphs: true },\n    ];\n\n    // when the application starts, use the largest size\n    options.startSizeIndex = 2;\n\n    // display additional counters\n    // Note: for most of these to report values, either debug or profiling engine build needs to be used.\n    options.stats = [\n        // frame update time in ms\n        {\n            name: \"Update\",\n            stats: [\"frame.updateTime\"],\n            decimalPlaces: 1,\n            unitsName: \"ms\",\n            watermark: 33,\n        },\n\n        // total number of draw calls\n        {\n            name: \"DrawCalls\",\n            stats: [\"drawCalls.total\"],\n            watermark: 2000,\n        },\n\n        // total number of triangles, in 1000s\n        {\n            name: \"triCount\",\n            stats: [\"frame.triangles\"],\n            decimalPlaces: 1,\n            multiplier: 1 / 1000,\n            unitsName: \"k\",\n            watermark: 500,\n        },\n\n        // number of materials used in a frame\n        {\n            name: \"materials\",\n            stats: [\"frame.materials\"],\n            watermark: 2000,\n        },\n\n        // frame time it took to do frustum culling\n        {\n            name: \"cull\",\n            stats: [\"frame.cullTime\"],\n            decimalPlaces: 1,\n            watermark: 1,\n            unitsName: \"ms\",\n        },\n\n        // used VRAM, displayed using 2 colors - red for textures, green for geometry\n        {\n            name: \"VRAM\",\n            stats: [\"vram.tex\", \"vram.geom\"],\n            decimalPlaces: 1,\n            multiplier: 1 / (1024 * 1024),\n            unitsName: \"MB\",\n            watermark: 100,\n        },\n\n        // frames per second\n        {\n            name: \"FPS\",\n            stats: [\"frame.fps\"],\n            watermark: 60,\n        },\n\n        // delta time\n        {\n            name: \"Frame\",\n            stats: [\"frame.ms\"],\n            decimalPlaces: 1,\n            unitsName: \"ms\",\n            watermark: 33,\n        },\n    ];\n\n    // create mini-stats system\n    const miniStats = new pcx.MiniStats(app, options);\n\n    // add directional lights to the scene\n    const light = new pc.Entity();\n    light.addComponent(\"light\", {\n        type: \"directional\",\n    });\n\n    app.root.addChild(light);\n    light.setLocalEulerAngles(45, 30, 0);\n\n    // Create an entity with a camera component\n    const camera = new pc.Entity();\n    camera.addComponent(\"camera\", {\n        clearColor: new pc.Color(0.1, 0.1, 0.1),\n    });\n\n    app.root.addChild(camera);\n    camera.setLocalPosition(20, 10, 10);\n    camera.lookAt(pc.Vec3.ZERO);\n\n    // helper function to create a primitive with shape type, position, scale\n    function createPrimitive(primitiveType, position, scale) {\n        // create material of random color\n        const material = new pc.StandardMaterial();\n        material.diffuse = new pc.Color(\n            Math.random(),\n            Math.random(),\n            Math.random()\n        );\n        material.update();\n\n        // create primitive\n        const primitive = new pc.Entity();\n        primitive.addComponent(\"model\", {\n            type: primitiveType,\n        });\n\n        primitive.model.material = material;\n\n        // set position and scale\n        primitive.setLocalPosition(position);\n        primitive.setLocalScale(scale);\n\n        return primitive;\n    }\n\n    // list of all created engine resources\n    const entities = [];\n    const vertexBuffers = [];\n    const textures = [];\n\n    // update function called every frame\n    let adding = true;\n    const step = 10,\n        max = 2000;\n    let entity, vertexBuffer, texture;\n    app.on(\"update\", function () {\n        // execute some tasks multiple times per frame\n        for (let i = 0; i < step; i++) {\n            // allocating resources\n            if (adding) {\n                // add entity (they used shared geometry internally, and we create individual material for each)\n                const shape = Math.random() < 0.5 ? \"box\" : \"sphere\";\n                const position = new pc.Vec3(\n                    Math.random() * 10,\n                    Math.random() * 10,\n                    Math.random() * 10\n                );\n                const scale = 0.5 + Math.random();\n                entity = createPrimitive(\n                    shape,\n                    position,\n                    new pc.Vec3(scale, scale, scale)\n                );\n                entities.push(entity);\n                app.root.addChild(entity);\n\n                // if allocation reached the max limit, switch to removing mode\n                if (entities.length >= max) {\n                    adding = false;\n                }\n\n                // add vertex buffer\n                const vertexCount = 500;\n                const data = new Float32Array(vertexCount * 16);\n                vertexBuffer = new pc.VertexBuffer(\n                    app.graphicsDevice,\n                    pc.VertexFormat.getDefaultInstancingFormat(\n                        app.graphicsDevice\n                    ),\n                    vertexCount,\n                    pc.BUFFER_STATIC,\n                    data\n                );\n                vertexBuffers.push(vertexBuffer);\n\n                // allocate texture\n                const texture = new pc.Texture(app.graphicsDevice, {\n                    width: 64,\n                    height: 64,\n                    format: pc.PIXELFORMAT_RGB8,\n                    mipmaps: false,\n                });\n\n                textures.push(texture);\n\n                // ensure texture is uploaded (actual VRAM is allocated)\n                texture.lock();\n                texture.unlock();\n                // @ts-ignore engine-tsd\n                app.graphicsDevice.setTexture(texture, 0);\n            } else {\n                // de-allocating resources\n\n                if (entities.length > 0) {\n                    // destroy entities\n                    entity = entities[entities.length - 1];\n                    // @ts-ignore engine-tsd\n                    entity.destroy();\n                    entities.length--;\n\n                    // destroy vertex buffer\n                    vertexBuffer = vertexBuffers[vertexBuffers.length - 1];\n                    vertexBuffer.destroy();\n                    vertexBuffers.length--;\n\n                    // destroy texture\n                    texture = textures[textures.length - 1];\n                    texture.destroy();\n                    textures.length--;\n                } else {\n                    adding = true;\n                }\n            }\n        }\n    });\n}\n","nameSlug":"mini-stats","categorySlug":"misc"},"spineboy":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'skeleton': new pc.Asset('skeleton', 'json', { url: '/static/assets/spine/spineboy-pro.json' }),\n        'atlas': new pc.Asset('atlas', 'text', { url: '/static/assets/spine/spineboy-pro.atlas' }),\n        'texture': new pc.Asset('spineboy-pro.png', 'texture', { url: '/static/assets/spine/spineboy-pro.png' }),\n        'spinescript': new pc.Asset('spinescript', 'script', { url: '/static/scripts/spine/playcanvas-spine.3.8.js' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.JsonHandler,\n            // @ts-ignore\n            pc.TextHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // create camera entity\n            const camera = new pc.Entity('camera');\n            camera.addComponent('camera', {\n                clearColor: new pc.Color(0.5, 0.6, 0.9)\n            });\n            app.root.addChild(camera);\n            camera.translateLocal(0, 7, 20);\n\n            const createSpineInstance = (position: pc.Vec3, scale: pc.Vec3, timeScale: number) => {\n\n                const spineEntity = new pc.Entity();\n                spineEntity.addComponent(\"spine\", {\n                    atlasAsset: assets.atlas.id,\n                    skeletonAsset: assets.skeleton.id,\n                    textureAssets: [assets.texture.id]\n                });\n                spineEntity.setLocalPosition(position);\n                spineEntity.setLocalScale(scale);\n                app.root.addChild(spineEntity);\n\n                // play spine animation\n                // @ts-ignore\n                spineEntity.spine.state.setAnimation(0, \"portal\", true);\n\n                // @ts-ignore\n                spineEntity.spine.state.timeScale = timeScale;\n            };\n\n            // create spine entity 1\n            createSpineInstance(new pc.Vec3(2, 2, 0), new pc.Vec3(1, 1, 1), 1);\n\n            // create spine entity 2\n            createSpineInstance(new pc.Vec3(2, 10, 0), new pc.Vec3(-0.5, 0.5, 0.5), 0.5);\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        skeleton: new pc.Asset(\"skeleton\", \"json\", {\n            url: \"/static/assets/spine/spineboy-pro.json\",\n        }),\n        atlas: new pc.Asset(\"atlas\", \"text\", {\n            url: \"/static/assets/spine/spineboy-pro.atlas\",\n        }),\n        texture: new pc.Asset(\"spineboy-pro.png\", \"texture\", {\n            url: \"/static/assets/spine/spineboy-pro.png\",\n        }),\n        spinescript: new pc.Asset(\"spinescript\", \"script\", {\n            url: \"/static/scripts/spine/playcanvas-spine.3.8.js\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n            // @ts-ignore\n            pc.JsonHandler,\n            // @ts-ignore\n            pc.TextHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // create camera entity\n            const camera = new pc.Entity(\"camera\");\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.5, 0.6, 0.9),\n            });\n\n            app.root.addChild(camera);\n            camera.translateLocal(0, 7, 20);\n\n            const createSpineInstance = (position, scale, timeScale) => {\n                const spineEntity = new pc.Entity();\n                spineEntity.addComponent(\"spine\", {\n                    atlasAsset: assets.atlas.id,\n                    skeletonAsset: assets.skeleton.id,\n                    textureAssets: [assets.texture.id],\n                });\n\n                spineEntity.setLocalPosition(position);\n                spineEntity.setLocalScale(scale);\n                app.root.addChild(spineEntity);\n\n                // play spine animation\n                // @ts-ignore\n                spineEntity.spine.state.setAnimation(0, \"portal\", true);\n\n                // @ts-ignore\n                spineEntity.spine.state.timeScale = timeScale;\n            };\n\n            // create spine entity 1\n            createSpineInstance(new pc.Vec3(2, 2, 0), new pc.Vec3(1, 1, 1), 1);\n\n            // create spine entity 2\n            createSpineInstance(\n                new pc.Vec3(2, 10, 0),\n                new pc.Vec3(-0.5, 0.5, 0.5),\n                0.5\n            );\n        });\n    });\n}\n","nameSlug":"spineboy","categorySlug":"misc"}},"physics":{"compound-collision":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    pc.WasmModule.setConfig('Ammo', {\n        glueUrl: '/static/lib/ammo/ammo.wasm.js',\n        wasmUrl: '/static/lib/ammo/ammo.wasm.wasm',\n        fallbackUrl: '/static/lib/ammo/ammo.js'\n    });\n\n    pc.WasmModule.getInstance('Ammo', demo);\n\n    function demo() {\n        app.start();\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        function createMaterial(color: pc.Color) {\n            const material = new pc.StandardMaterial();\n            material.diffuse = color;\n            material.update();\n\n            return material;\n        }\n\n        // Create a couple of materials for our objects\n        const red = createMaterial(new pc.Color(0.7, 0.3, 0.3));\n        const gray = createMaterial(new pc.Color(0.7, 0.7, 0.7));\n\n        // Define a scene hierarchy in JSON format. This is loaded/parsed in\n        // the parseScene function below\n        const scene = [\n            {\n                // The Chair entity has a collision component of type 'compound' and a\n                // rigidbody component. This means that any descendent entity with a\n                // collision component is added to a compound collision shape on the\n                // Chair entity. You can use compound collision shapes to define\n                // complex, rigid shapes.\n                name: 'Chair',\n                pos: [0, 1, 0],\n                components: [\n                    {\n                        type: 'collision',\n                        options: {\n                            type: 'compound'\n                        }\n                    }, {\n                        type: 'rigidbody',\n                        options: {\n                            type: 'dynamic',\n                            friction: 0.5,\n                            mass: 10,\n                            restitution: 0.5\n                        }\n                    }\n                ],\n                children: [\n                    {\n                        name: 'Seat',\n                        components: [\n                            {\n                                type: 'collision',\n                                options: {\n                                    type: 'box',\n                                    halfExtents: [0.25, 0.025, 0.25]\n                                }\n                            }\n                        ],\n                        children: [\n                            {\n                                name: 'Seat Model',\n                                scl: [0.5, 0.05, 0.5],\n                                components: [\n                                    {\n                                        type: 'render',\n                                        options: {\n                                            type: 'box',\n                                            material: gray\n                                        }\n                                    }\n                                ]\n                            }\n                        ]\n                    }, {\n                        name: 'Seat Back',\n                        pos: [0, 0.3, -0.2],\n                        components: [\n                            {\n                                type: 'collision',\n                                options: {\n                                    type: 'box',\n                                    halfExtents: [0.25, 0.2, 0.025]\n                                }\n                            }\n                        ],\n                        children: [\n                            {\n                                name: 'Seat Back Model',\n                                scl: [0.5, 0.4, 0.05],\n                                components: [\n                                    {\n                                        type: 'render',\n                                        options: {\n                                            type: 'box',\n                                            material: gray\n                                        }\n                                    }\n                                ]\n                            }\n                        ]\n                    }, {\n                        name: 'Leg 1',\n                        pos: [0.2, -0.25, 0.2],\n                        components: [\n                            {\n                                type: 'collision',\n                                options: {\n                                    type: 'cylinder',\n                                    height: 0.5,\n                                    radius: 0.025\n                                }\n                            }\n                        ],\n                        children: [\n                            {\n                                name: 'Leg 1 Model',\n                                scl: [0.05, 0.5, 0.05],\n                                components: [\n                                    {\n                                        type: 'render',\n                                        options: {\n                                            type: 'cylinder',\n                                            material: gray\n                                        }\n                                    }\n                                ]\n                            }\n                        ]\n                    }, {\n                        name: 'Leg 2',\n                        pos: [-0.2, -0.25, 0.2],\n                        components: [\n                            {\n                                type: 'collision',\n                                options: {\n                                    type: 'cylinder',\n                                    height: 0.5,\n                                    radius: 0.025\n                                }\n                            }\n                        ],\n                        children: [\n                            {\n                                name: 'Leg 2 Model',\n                                scl: [0.05, 0.5, 0.05],\n                                components: [\n                                    {\n                                        type: 'render',\n                                        options: {\n                                            type: 'cylinder',\n                                            material: gray\n                                        }\n                                    }\n                                ]\n                            }\n                        ]\n                    }, {\n                        name: 'Leg 3',\n                        pos: [0.2, 0, -0.2],\n                        components: [\n                            {\n                                type: 'collision',\n                                options: {\n                                    type: 'cylinder',\n                                    height: 1,\n                                    radius: 0.025\n                                }\n                            }\n                        ],\n                        children: [\n                            {\n                                name: 'Leg 3 Model',\n                                scl: [0.05, 1, 0.05],\n                                components: [\n                                    {\n                                        type: 'render',\n                                        options: {\n                                            type: 'cylinder',\n                                            material: gray\n                                        }\n                                    }\n                                ]\n                            }\n                        ]\n                    }, {\n                        name: 'Leg 4',\n                        pos: [-0.2, 0, -0.2],\n                        components: [\n                            {\n                                type: 'collision',\n                                options: {\n                                    type: 'cylinder',\n                                    height: 1,\n                                    radius: 0.025\n                                }\n                            }\n                        ],\n                        children: [\n                            {\n                                name: 'Leg 4 Model',\n                                scl: [0.05, 1, 0.05],\n                                components: [\n                                    {\n                                        type: 'render',\n                                        options: {\n                                            type: 'cylinder',\n                                            material: gray\n                                        }\n                                    }\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            }, {\n                name: 'Ground',\n                pos: [0, -0.5, 0],\n                components: [\n                    {\n                        type: 'collision',\n                        options: {\n                            type: 'box',\n                            halfExtents: [5, 0.5, 5]\n                        }\n                    }, {\n                        type: 'rigidbody',\n                        options: {\n                            type: 'static',\n                            restitution: 0.5\n                        }\n                    }\n                ],\n                children: [\n                    {\n                        name: 'Ground Model',\n                        scl: [10, 1, 10],\n                        components: [\n                            {\n                                type: 'render',\n                                options: {\n                                    type: 'box',\n                                    material: gray\n                                }\n                            }\n                        ]\n                    }\n                ]\n            }, {\n                name: 'Directional Light',\n                rot: [45, 130, 0],\n                components: [\n                    {\n                        type: 'light',\n                        options: {\n                            type: 'directional',\n                            castShadows: true,\n                            shadowDistance: 8,\n                            shadowBias: 0.1,\n                            intensity: 1,\n                            normalOffsetBias: 0.05\n                        }\n                    }\n                ]\n            }, {\n                name: 'Camera',\n                pos: [0, 4, 7],\n                rot: [-30, 0, 0],\n                components: [\n                    {\n                        type: 'camera',\n                        options: {\n                            color: [0.5, 0.5, 0.5]\n                        }\n                    }\n                ]\n            }\n        ];\n\n        // Convert an entity definition in the structure above to a pc.Entity object\n        function parseEntity(e: any) {\n            const entity = new pc.Entity(e.name);\n\n            if (e.pos) {\n                entity.setLocalPosition(e.pos[0], e.pos[1], e.pos[2]);\n            }\n            if (e.rot) {\n                entity.setLocalEulerAngles(e.rot[0], e.rot[1], e.rot[2]);\n            }\n            if (e.scl) {\n                entity.setLocalScale(e.scl[0], e.scl[1], e.scl[2]);\n            }\n\n            if (e.components) {\n                e.components.forEach(function (c: any) {\n                    entity.addComponent(c.type, c.options);\n                });\n            }\n\n            if (e.children) {\n                e.children.forEach(function (child: pc.Entity) {\n                    entity.addChild(parseEntity(child));\n                });\n            }\n\n            return entity;\n        }\n\n        // Parse the scene data above into entities and add them to the scene's root entity\n        function parseScene(s: any) {\n            s.forEach(function (e: any) {\n                app.root.addChild(parseEntity(e));\n            });\n        }\n\n        parseScene(scene);\n\n        let numChairs = 0;\n\n        // Clone the chair entity hierarchy and add it to the scene root\n        function spawnChair() {\n            const chair: pc.Entity = app.root.findByName('Chair') as pc.Entity;\n            const clone = chair.clone();\n            clone.setLocalPosition(Math.random() * 1 - 0.5, Math.random() * 2 + 1, Math.random() * 1 - 0.5);\n            app.root.addChild(clone);\n            numChairs++;\n        }\n\n        // Set an update function on the application's update event\n        let time = 0;\n        app.on(\"update\", function (dt) {\n            // Add a new chair every 250 ms\n            time += dt;\n            if (time > 0.25 && numChairs < 20) {\n                spawnChair();\n                time = 0;\n            }\n\n            // Show active bodies in red and frozen bodies in gray\n            app.root.findComponents('rigidbody').forEach(function (body: pc.RigidBodyComponent) {\n                body.entity.findComponents('render').forEach(function (render: pc.RenderComponent) {\n                    render.material = body.isActive() ? red : gray;\n                });\n            });\n        });\n    }\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    pc.WasmModule.setConfig(\"Ammo\", {\n        glueUrl: \"/static/lib/ammo/ammo.wasm.js\",\n        wasmUrl: \"/static/lib/ammo/ammo.wasm.wasm\",\n        fallbackUrl: \"/static/lib/ammo/ammo.js\",\n    });\n\n    pc.WasmModule.getInstance(\"Ammo\", demo);\n\n    function demo() {\n        app.start();\n\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n        function createMaterial(color) {\n            const material = new pc.StandardMaterial();\n            material.diffuse = color;\n            material.update();\n\n            return material;\n        }\n\n        // Create a couple of materials for our objects\n        const red = createMaterial(new pc.Color(0.7, 0.3, 0.3));\n        const gray = createMaterial(new pc.Color(0.7, 0.7, 0.7));\n\n        // Define a scene hierarchy in JSON format. This is loaded/parsed in\n        // the parseScene function below\n        const scene = [\n            {\n                // The Chair entity has a collision component of type 'compound' and a\n                // rigidbody component. This means that any descendent entity with a\n                // collision component is added to a compound collision shape on the\n                // Chair entity. You can use compound collision shapes to define\n                // complex, rigid shapes.\n                name: \"Chair\",\n                pos: [0, 1, 0],\n                components: [\n                    {\n                        type: \"collision\",\n                        options: {\n                            type: \"compound\",\n                        },\n                    },\n\n                    {\n                        type: \"rigidbody\",\n                        options: {\n                            type: \"dynamic\",\n                            friction: 0.5,\n                            mass: 10,\n                            restitution: 0.5,\n                        },\n                    },\n                ],\n\n                children: [\n                    {\n                        name: \"Seat\",\n                        components: [\n                            {\n                                type: \"collision\",\n                                options: {\n                                    type: \"box\",\n                                    halfExtents: [0.25, 0.025, 0.25],\n                                },\n                            },\n                        ],\n\n                        children: [\n                            {\n                                name: \"Seat Model\",\n                                scl: [0.5, 0.05, 0.5],\n                                components: [\n                                    {\n                                        type: \"render\",\n                                        options: {\n                                            type: \"box\",\n                                            material: gray,\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n\n                    {\n                        name: \"Seat Back\",\n                        pos: [0, 0.3, -0.2],\n                        components: [\n                            {\n                                type: \"collision\",\n                                options: {\n                                    type: \"box\",\n                                    halfExtents: [0.25, 0.2, 0.025],\n                                },\n                            },\n                        ],\n\n                        children: [\n                            {\n                                name: \"Seat Back Model\",\n                                scl: [0.5, 0.4, 0.05],\n                                components: [\n                                    {\n                                        type: \"render\",\n                                        options: {\n                                            type: \"box\",\n                                            material: gray,\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n\n                    {\n                        name: \"Leg 1\",\n                        pos: [0.2, -0.25, 0.2],\n                        components: [\n                            {\n                                type: \"collision\",\n                                options: {\n                                    type: \"cylinder\",\n                                    height: 0.5,\n                                    radius: 0.025,\n                                },\n                            },\n                        ],\n\n                        children: [\n                            {\n                                name: \"Leg 1 Model\",\n                                scl: [0.05, 0.5, 0.05],\n                                components: [\n                                    {\n                                        type: \"render\",\n                                        options: {\n                                            type: \"cylinder\",\n                                            material: gray,\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n\n                    {\n                        name: \"Leg 2\",\n                        pos: [-0.2, -0.25, 0.2],\n                        components: [\n                            {\n                                type: \"collision\",\n                                options: {\n                                    type: \"cylinder\",\n                                    height: 0.5,\n                                    radius: 0.025,\n                                },\n                            },\n                        ],\n\n                        children: [\n                            {\n                                name: \"Leg 2 Model\",\n                                scl: [0.05, 0.5, 0.05],\n                                components: [\n                                    {\n                                        type: \"render\",\n                                        options: {\n                                            type: \"cylinder\",\n                                            material: gray,\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n\n                    {\n                        name: \"Leg 3\",\n                        pos: [0.2, 0, -0.2],\n                        components: [\n                            {\n                                type: \"collision\",\n                                options: {\n                                    type: \"cylinder\",\n                                    height: 1,\n                                    radius: 0.025,\n                                },\n                            },\n                        ],\n\n                        children: [\n                            {\n                                name: \"Leg 3 Model\",\n                                scl: [0.05, 1, 0.05],\n                                components: [\n                                    {\n                                        type: \"render\",\n                                        options: {\n                                            type: \"cylinder\",\n                                            material: gray,\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n\n                    {\n                        name: \"Leg 4\",\n                        pos: [-0.2, 0, -0.2],\n                        components: [\n                            {\n                                type: \"collision\",\n                                options: {\n                                    type: \"cylinder\",\n                                    height: 1,\n                                    radius: 0.025,\n                                },\n                            },\n                        ],\n\n                        children: [\n                            {\n                                name: \"Leg 4 Model\",\n                                scl: [0.05, 1, 0.05],\n                                components: [\n                                    {\n                                        type: \"render\",\n                                        options: {\n                                            type: \"cylinder\",\n                                            material: gray,\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n                ],\n            },\n\n            {\n                name: \"Ground\",\n                pos: [0, -0.5, 0],\n                components: [\n                    {\n                        type: \"collision\",\n                        options: {\n                            type: \"box\",\n                            halfExtents: [5, 0.5, 5],\n                        },\n                    },\n\n                    {\n                        type: \"rigidbody\",\n                        options: {\n                            type: \"static\",\n                            restitution: 0.5,\n                        },\n                    },\n                ],\n\n                children: [\n                    {\n                        name: \"Ground Model\",\n                        scl: [10, 1, 10],\n                        components: [\n                            {\n                                type: \"render\",\n                                options: {\n                                    type: \"box\",\n                                    material: gray,\n                                },\n                            },\n                        ],\n                    },\n                ],\n            },\n\n            {\n                name: \"Directional Light\",\n                rot: [45, 130, 0],\n                components: [\n                    {\n                        type: \"light\",\n                        options: {\n                            type: \"directional\",\n                            castShadows: true,\n                            shadowDistance: 8,\n                            shadowBias: 0.1,\n                            intensity: 1,\n                            normalOffsetBias: 0.05,\n                        },\n                    },\n                ],\n            },\n\n            {\n                name: \"Camera\",\n                pos: [0, 4, 7],\n                rot: [-30, 0, 0],\n                components: [\n                    {\n                        type: \"camera\",\n                        options: {\n                            color: [0.5, 0.5, 0.5],\n                        },\n                    },\n                ],\n            },\n        ];\n\n        // Convert an entity definition in the structure above to a pc.Entity object\n        function parseEntity(e) {\n            const entity = new pc.Entity(e.name);\n\n            if (e.pos) {\n                entity.setLocalPosition(e.pos[0], e.pos[1], e.pos[2]);\n            }\n            if (e.rot) {\n                entity.setLocalEulerAngles(e.rot[0], e.rot[1], e.rot[2]);\n            }\n            if (e.scl) {\n                entity.setLocalScale(e.scl[0], e.scl[1], e.scl[2]);\n            }\n\n            if (e.components) {\n                e.components.forEach(function (c) {\n                    entity.addComponent(c.type, c.options);\n                });\n            }\n\n            if (e.children) {\n                e.children.forEach(function (child) {\n                    entity.addChild(parseEntity(child));\n                });\n            }\n\n            return entity;\n        }\n\n        // Parse the scene data above into entities and add them to the scene's root entity\n        function parseScene(s) {\n            s.forEach(function (e) {\n                app.root.addChild(parseEntity(e));\n            });\n        }\n\n        parseScene(scene);\n\n        let numChairs = 0;\n\n        // Clone the chair entity hierarchy and add it to the scene root\n        function spawnChair() {\n            const chair = app.root.findByName(\"Chair\");\n            const clone = chair.clone();\n            clone.setLocalPosition(\n                Math.random() * 1 - 0.5,\n                Math.random() * 2 + 1,\n                Math.random() * 1 - 0.5\n            );\n            app.root.addChild(clone);\n            numChairs++;\n        }\n\n        // Set an update function on the application's update event\n        let time = 0;\n        app.on(\"update\", function (dt) {\n            // Add a new chair every 250 ms\n            time += dt;\n            if (time > 0.25 && numChairs < 20) {\n                spawnChair();\n                time = 0;\n            }\n\n            // Show active bodies in red and frozen bodies in gray\n            app.root.findComponents(\"rigidbody\").forEach(function (body) {\n                body.entity.findComponents(\"render\").forEach(function (render) {\n                    render.material = body.isActive() ? red : gray;\n                });\n            });\n        });\n    }\n}\n","nameSlug":"compound-collision","categorySlug":"physics"},"falling-shapes":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n        // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        'torus': new pc.Asset('torus', 'container', { url: '/static/assets/models/torus.glb' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n\n        pc.WasmModule.setConfig('Ammo', {\n            glueUrl: '/static/lib/ammo/ammo.wasm.js',\n            wasmUrl: '/static/lib/ammo/ammo.wasm.wasm',\n            fallbackUrl: '/static/lib/ammo/ammo.js'\n        });\n\n        pc.WasmModule.getInstance('Ammo', demo);\n\n        function demo() {\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // Set the gravity for our rigid bodies\n            app.systems.rigidbody.gravity.set(0, -9.81, 0);\n\n            function createMaterial(color: pc.Color) {\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                // we need to call material.update when we change its properties\n                material.update();\n                return material;\n            }\n\n            // create a few materials for our objects\n            const red = createMaterial(new pc.Color(1, 0.3, 0.3));\n            const gray = createMaterial(new pc.Color(0.7, 0.7, 0.7));\n\n            // ***********    Create our floor   *******************\n\n            const floor = new pc.Entity();\n            floor.addComponent(\"render\", {\n                type: \"box\",\n                material: gray\n            });\n\n            // scale it\n            floor.setLocalScale(10, 1, 10);\n\n            // add a rigidbody component so that other objects collide with it\n            floor.addComponent(\"rigidbody\", {\n                type: \"static\",\n                restitution: 0.5\n            });\n\n            // add a collision component\n            floor.addComponent(\"collision\", {\n                type: \"box\",\n                halfExtents: new pc.Vec3(5, 0.5, 5)\n            });\n\n            // add the floor to the hierarchy\n            app.root.addChild(floor);\n\n            // ***********    Create lights   *******************\n\n            // make our scene prettier by adding a directional light\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n                color: new pc.Color(1, 1, 1),\n                castShadows: true,\n                shadowBias: 0.2,\n                shadowDistance: 25,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048\n            });\n\n            // set the direction for our light\n            light.setLocalEulerAngles(45, 30, 0);\n\n            // Add the light to the hierarchy\n            app.root.addChild(light);\n\n            // ***********    Create camera    *******************\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.5, 0.5, 0.8),\n                farClip: 50\n            });\n\n            // add the camera to the hierarchy\n            app.root.addChild(camera);\n\n            // Move the camera a little further away\n            camera.translate(0, 10, 15);\n            camera.lookAt(0, 2, 0);\n\n            // helper function which creates a template for a collider\n            const createTemplate = function (type: any, collisionOptions: any, template?: any) {\n\n                // add a render component (visible mesh)\n                if (!template) {\n                    template = new pc.Entity();\n                    template.addComponent(\"render\", {\n                        type: type\n                    });\n                }\n\n                // ...a rigidbody component of type 'dynamic' so that it is simulated by the physics engine...\n                template.addComponent(\"rigidbody\", {\n                    type: \"dynamic\",\n                    mass: 50,\n                    restitution: 0.5\n                });\n\n                // ... and a collision component\n                template.addComponent(\"collision\", collisionOptions);\n\n                return template;\n            };\n\n            // ***********    Create templates    *******************\n\n            // Create a template for a falling box\n            const boxTemplate = createTemplate(\"box\", {\n                type: \"box\",\n                halfExtents: new pc.Vec3(0.5, 0.5, 0.5)\n            });\n\n            // A sphere...\n            const sphereTemplate = createTemplate(\"sphere\", {\n                type: \"sphere\",\n                radius: 0.5\n            });\n\n            // A capsule...\n            const capsuleTemplate = createTemplate(\"capsule\", {\n                type: \"capsule\",\n                radius: 0.5,\n                height: 2\n            });\n\n            // A cylinder...\n            const cylinderTemplate = createTemplate(\"cylinder\", {\n                type: \"cylinder\",\n                radius: 0.5,\n                height: 1\n            });\n\n            // A torus mesh...\n            const container = assets.torus.resource;\n            const meshTemplate = container.instantiateRenderEntity();\n\n            createTemplate(null, {\n                type: 'mesh',\n                renderAsset: container.renders[0]\n            }, meshTemplate);\n\n            // add all the templates to an array so that\n            // we can randomly spawn them\n            const templates = [boxTemplate, sphereTemplate, capsuleTemplate, cylinderTemplate, meshTemplate];\n\n            // disable the templates because we don't want them to be visible\n            // we'll just use them to clone other Entities\n            templates.forEach(function (template) {\n                template.enabled = false;\n            });\n\n            // ***********    Update Function   *******************\n\n            // initialize variables for our update function\n            let timer = 0;\n            let count = 40;\n\n            // Set an update function on the application's update event\n            app.on(\"update\", function (dt) {\n                // create a falling box every 0.2 seconds\n                if (count > 0) {\n                    timer -= dt;\n                    if (timer <= 0) {\n                        count--;\n                        timer = 0.2;\n\n                        // Clone a random template and position it above the floor\n                        const template = templates[Math.floor(Math.random() * templates.length)];\n                        const clone = template.clone();\n                        // enable the clone because the template is disabled\n                        clone.enabled = true;\n\n                        app.root.addChild(clone);\n\n                        clone.rigidbody.teleport(pc.math.random(-1, 1), 10, pc.math.random(-1, 1));\n                        clone.rigidbody.angularVelocity = new pc.Vec3(Math.random() * 10 - 5, Math.random() * 10 - 5, Math.random() * 10 - 5);\n                    }\n                }\n\n                // Show active bodies in red and frozen bodies in gray\n                app.root.findComponents('rigidbody').forEach(function (body: pc.RigidBodyComponent) {\n                    body.entity.render.meshInstances[0].material = body.isActive() ? red : gray;\n                });\n            });\n        }\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        torus: new pc.Asset(\"torus\", \"container\", {\n            url: \"/static/assets/models/torus.glb\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        pc.WasmModule.setConfig(\"Ammo\", {\n            glueUrl: \"/static/lib/ammo/ammo.wasm.js\",\n            wasmUrl: \"/static/lib/ammo/ammo.wasm.wasm\",\n            fallbackUrl: \"/static/lib/ammo/ammo.js\",\n        });\n\n        pc.WasmModule.getInstance(\"Ammo\", demo);\n\n        function demo() {\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            // Set the gravity for our rigid bodies\n            app.systems.rigidbody.gravity.set(0, -9.81, 0);\n\n            function createMaterial(color) {\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                // we need to call material.update when we change its properties\n                material.update();\n                return material;\n            }\n\n            // create a few materials for our objects\n            const red = createMaterial(new pc.Color(1, 0.3, 0.3));\n            const gray = createMaterial(new pc.Color(0.7, 0.7, 0.7));\n\n            // ***********    Create our floor   *******************\n\n            const floor = new pc.Entity();\n            floor.addComponent(\"render\", {\n                type: \"box\",\n                material: gray,\n            });\n\n            // scale it\n            floor.setLocalScale(10, 1, 10);\n\n            // add a rigidbody component so that other objects collide with it\n            floor.addComponent(\"rigidbody\", {\n                type: \"static\",\n                restitution: 0.5,\n            });\n\n            // add a collision component\n            floor.addComponent(\"collision\", {\n                type: \"box\",\n                halfExtents: new pc.Vec3(5, 0.5, 5),\n            });\n\n            // add the floor to the hierarchy\n            app.root.addChild(floor);\n\n            // ***********    Create lights   *******************\n\n            // make our scene prettier by adding a directional light\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n                color: new pc.Color(1, 1, 1),\n                castShadows: true,\n                shadowBias: 0.2,\n                shadowDistance: 25,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048,\n            });\n\n            // set the direction for our light\n            light.setLocalEulerAngles(45, 30, 0);\n\n            // Add the light to the hierarchy\n            app.root.addChild(light);\n\n            // ***********    Create camera    *******************\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.5, 0.5, 0.8),\n                farClip: 50,\n            });\n\n            // add the camera to the hierarchy\n            app.root.addChild(camera);\n\n            // Move the camera a little further away\n            camera.translate(0, 10, 15);\n            camera.lookAt(0, 2, 0);\n\n            // helper function which creates a template for a collider\n            const createTemplate = function (type, collisionOptions, template) {\n                // add a render component (visible mesh)\n                if (!template) {\n                    template = new pc.Entity();\n                    template.addComponent(\"render\", {\n                        type: type,\n                    });\n                }\n\n                // ...a rigidbody component of type 'dynamic' so that it is simulated by the physics engine...\n                template.addComponent(\"rigidbody\", {\n                    type: \"dynamic\",\n                    mass: 50,\n                    restitution: 0.5,\n                });\n\n                // ... and a collision component\n                template.addComponent(\"collision\", collisionOptions);\n\n                return template;\n            };\n\n            // ***********    Create templates    *******************\n\n            // Create a template for a falling box\n            const boxTemplate = createTemplate(\"box\", {\n                type: \"box\",\n                halfExtents: new pc.Vec3(0.5, 0.5, 0.5),\n            });\n\n            // A sphere...\n            const sphereTemplate = createTemplate(\"sphere\", {\n                type: \"sphere\",\n                radius: 0.5,\n            });\n\n            // A capsule...\n            const capsuleTemplate = createTemplate(\"capsule\", {\n                type: \"capsule\",\n                radius: 0.5,\n                height: 2,\n            });\n\n            // A cylinder...\n            const cylinderTemplate = createTemplate(\"cylinder\", {\n                type: \"cylinder\",\n                radius: 0.5,\n                height: 1,\n            });\n\n            // A torus mesh...\n            const container = assets.torus.resource;\n            const meshTemplate = container.instantiateRenderEntity();\n\n            createTemplate(\n                null,\n                {\n                    type: \"mesh\",\n                    renderAsset: container.renders[0],\n                },\n                meshTemplate\n            );\n\n            // add all the templates to an array so that\n            // we can randomly spawn them\n            const templates = [\n                boxTemplate,\n                sphereTemplate,\n                capsuleTemplate,\n                cylinderTemplate,\n                meshTemplate,\n            ];\n\n            // disable the templates because we don't want them to be visible\n            // we'll just use them to clone other Entities\n            templates.forEach(function (template) {\n                template.enabled = false;\n            });\n\n            // ***********    Update Function   *******************\n\n            // initialize variables for our update function\n            let timer = 0;\n            let count = 40;\n\n            // Set an update function on the application's update event\n            app.on(\"update\", function (dt) {\n                // create a falling box every 0.2 seconds\n                if (count > 0) {\n                    timer -= dt;\n                    if (timer <= 0) {\n                        count--;\n                        timer = 0.2;\n\n                        // Clone a random template and position it above the floor\n                        const template =\n                            templates[\n                                Math.floor(Math.random() * templates.length)\n                            ];\n                        const clone = template.clone();\n                        // enable the clone because the template is disabled\n                        clone.enabled = true;\n\n                        app.root.addChild(clone);\n\n                        clone.rigidbody.teleport(\n                            pc.math.random(-1, 1),\n                            10,\n                            pc.math.random(-1, 1)\n                        );\n                        clone.rigidbody.angularVelocity = new pc.Vec3(\n                            Math.random() * 10 - 5,\n                            Math.random() * 10 - 5,\n                            Math.random() * 10 - 5\n                        );\n                    }\n                }\n\n                // Show active bodies in red and frozen bodies in gray\n                app.root.findComponents(\"rigidbody\").forEach(function (body) {\n                    body.entity.render.meshInstances[0].material =\n                        body.isActive() ? red : gray;\n                });\n            });\n        }\n    });\n}\n","nameSlug":"falling-shapes","categorySlug":"physics"},"offset-collision":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, data: any): void {\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas)\n    });\n\n    const assets = {\n        'model': new pc.Asset('model', 'container', {url: '/static/assets/models/bitmoji.glb'}),\n        'idleAnim': new pc.Asset('idleAnim', 'container', {url: '/static/assets/animations/bitmoji/idle.glb'}),\n        'helipad.dds': new pc.Asset('helipad.dds', 'cubemap', {url: '/static/assets/cubemaps/helipad.dds'}, {type: pc.TEXTURETYPE_RGBM})\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n        // setup skydome\n        app.scene.exposure = 2;\n        app.scene.skyboxMip = 2;\n        app.scene.setSkybox(assets['helipad.dds'].resources);\n\n        pc.WasmModule.setConfig('Ammo', {\n            glueUrl: '/static/lib/ammo/ammo.wasm.js',\n            wasmUrl: '/static/lib/ammo/ammo.wasm.wasm',\n            fallbackUrl: '/static/lib/ammo/ammo.js'\n        });\n\n        pc.WasmModule.getInstance('Ammo', demo);\n\n        function demo() {\n            app.start();\n\n            // Create an entity with a light component\n            const lightEntity = new pc.Entity();\n            lightEntity.addComponent(\"light\", {\n                castShadows: true,\n                intensity: 1.5,\n                normalOffsetBias: 0.2,\n                shadowType: pc.SHADOW_PCF5,\n                shadowDistance: 12,\n                shadowResolution: 4096,\n                shadowBias: 0.2\n            });\n            app.root.addChild(lightEntity);\n            lightEntity.setLocalEulerAngles(45, 30, 0);\n\n            // Set the gravity for our rigid bodies\n            app.systems.rigidbody.gravity.set(0, -9.81, 0);\n\n            function createMaterial(color: pc.Color) {\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                // we need to call material.update when we change its properties\n                material.update();\n                return material;\n            }\n\n            // create a few materials for our objects\n            const red = createMaterial(new pc.Color(1, 0.3, 0.3));\n            const gray = createMaterial(new pc.Color(0.7, 0.7, 0.7));\n\n            const floor = new pc.Entity();\n            floor.addComponent(\"render\", {\n                type: \"box\",\n                material: gray\n            });\n\n            // Scale it and move it so that the top is at 0 on the y axis\n            floor.setLocalScale(10, 1, 10);\n            floor.translateLocal(0, -0.5, 0);\n\n            // Add a rigidbody component so that other objects collide with it\n            floor.addComponent(\"rigidbody\", {\n                type: \"static\",\n                restitution: 0.5\n            });\n\n            // Add a collision component\n            floor.addComponent(\"collision\", {\n                type: \"box\",\n                halfExtents: new pc.Vec3(5, 0.5, 5)\n            });\n\n            // Add the floor to the hierarchy\n            app.root.addChild(floor);\n\n            // Create an entity from the loaded model using the render component\n            const modelEntity = assets.model.resource.instantiateRenderEntity({\n                castShadows: true\n            });\n\n            // Add an anim component to the entity\n            modelEntity.addComponent('anim', {\n                activate: true\n            });\n\n            // create an anim state graph\n            const animStateGraphData = {\n                \"layers\": [\n                    {\n                        \"name\": \"characterState\",\n                        \"states\": [\n                            {\n                                \"name\": \"START\"\n                            },\n                            {\n                                \"name\": \"Idle\",\n                                \"speed\": 1.0,\n                                \"loop\": true\n                            }\n                        ],\n                        \"transitions\": [\n                            {\n                                \"from\": \"START\",\n                                \"to\": \"Idle\"\n                            }\n                        ]\n                    }\n                ],\n                \"parameters\": {}\n            };\n\n            // load the state graph into the anim component\n            modelEntity.anim.loadStateGraph(animStateGraphData);\n\n            // Add a rigid body and collision for the head with offset as the model's origin is\n            // at the feet on the floor\n            modelEntity.addComponent(\"rigidbody\", {\n                type: \"static\",\n                restitution: 0.5\n            });\n\n            modelEntity.addComponent(\"collision\", {\n                type: \"sphere\",\n                radius: 0.3,\n                linearOffset: [0, 1.25, 0]\n            });\n\n            // load the state graph asset resource into the anim component\n            const characterStateLayer = modelEntity.anim.baseLayer;\n            characterStateLayer.assignAnimation('Idle', assets.idleAnim.resource.animations[0].resource);\n\n            app.root.addChild(modelEntity);\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.addComponent(\"camera\");\n            cameraEntity.translate(0, 2, 5);\n            const lookAtPosition = modelEntity.getPosition();\n            cameraEntity.lookAt(lookAtPosition.x, lookAtPosition.y + 0.75, lookAtPosition.z);\n\n            app.root.addChild(cameraEntity);\n\n            // create a ball template that we can clone in the update loop\n            const ball = new pc.Entity();\n            ball.tags.add('shape');\n            ball.setLocalScale(0.4, 0.4, 0.4);\n            ball.addComponent(\"render\", {\n                type: \"sphere\"\n            });\n\n            ball.addComponent(\"rigidbody\", {\n                type: \"dynamic\",\n                mass: 50,\n                restitution: 0.5\n            });\n\n            ball.addComponent(\"collision\", {\n                type: \"sphere\",\n                radius: 0.2\n            });\n\n            ball.enabled = false;\n\n            // initialize variables for our update function\n            let timer = 0;\n            let count = 40;\n\n            // Set an update function on the application's update event\n            app.on(\"update\", function (dt) {\n                // create a falling box every 0.2 seconds\n                if (count > 0) {\n                    timer -= dt;\n                    if (timer <= 0) {\n                        count--;\n                        timer = 0.5;\n\n                        // Create a new ball to drop\n                        const clone = ball.clone();\n                        clone.rigidbody.teleport(pc.math.random(-0.25, 0.25), 5, pc.math.random(-0.25, 0.25));\n\n                        app.root.addChild(clone);\n                        clone.enabled = true;\n                    }\n                }\n\n                // Show active bodies in red and frozen bodies in gray\n                app.root.findByTag(\"shape\").forEach(function (entity: pc.Entity) {\n                    entity.render.meshInstances[0].material = entity.rigidbody.isActive() ? red : gray;\n                });\n\n                // Render the offset collision\n                app.scene.immediate.drawWireSphere(\n                    modelEntity.collision.getShapePosition(),\n                    0.3,\n                    pc.Color.GREEN,\n                    16,\n                    true,\n                    app.scene.layers.getLayerByName(\"World\")\n                );\n            });\n        }\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, data) {\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(document.body),\n        touch: new pc.TouchDevice(document.body),\n        elementInput: new pc.ElementInput(canvas),\n    });\n\n    const assets = {\n        model: new pc.Asset(\"model\", \"container\", {\n            url: \"/static/assets/models/bitmoji.glb\",\n        }),\n        idleAnim: new pc.Asset(\"idleAnim\", \"container\", {\n            url: \"/static/assets/animations/bitmoji/idle.glb\",\n        }),\n        \"helipad.dds\": new pc.Asset(\n            \"helipad.dds\",\n            \"cubemap\",\n            { url: \"/static/assets/cubemaps/helipad.dds\" },\n            { type: pc.TEXTURETYPE_RGBM }\n        ),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        // setup skydome\n        app.scene.exposure = 2;\n        app.scene.skyboxMip = 2;\n        app.scene.setSkybox(assets[\"helipad.dds\"].resources);\n\n        pc.WasmModule.setConfig(\"Ammo\", {\n            glueUrl: \"/static/lib/ammo/ammo.wasm.js\",\n            wasmUrl: \"/static/lib/ammo/ammo.wasm.wasm\",\n            fallbackUrl: \"/static/lib/ammo/ammo.js\",\n        });\n\n        pc.WasmModule.getInstance(\"Ammo\", demo);\n\n        function demo() {\n            app.start();\n\n            // Create an entity with a light component\n            const lightEntity = new pc.Entity();\n            lightEntity.addComponent(\"light\", {\n                castShadows: true,\n                intensity: 1.5,\n                normalOffsetBias: 0.2,\n                shadowType: pc.SHADOW_PCF5,\n                shadowDistance: 12,\n                shadowResolution: 4096,\n                shadowBias: 0.2,\n            });\n\n            app.root.addChild(lightEntity);\n            lightEntity.setLocalEulerAngles(45, 30, 0);\n\n            // Set the gravity for our rigid bodies\n            app.systems.rigidbody.gravity.set(0, -9.81, 0);\n\n            function createMaterial(color) {\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                // we need to call material.update when we change its properties\n                material.update();\n                return material;\n            }\n\n            // create a few materials for our objects\n            const red = createMaterial(new pc.Color(1, 0.3, 0.3));\n            const gray = createMaterial(new pc.Color(0.7, 0.7, 0.7));\n\n            const floor = new pc.Entity();\n            floor.addComponent(\"render\", {\n                type: \"box\",\n                material: gray,\n            });\n\n            // Scale it and move it so that the top is at 0 on the y axis\n            floor.setLocalScale(10, 1, 10);\n            floor.translateLocal(0, -0.5, 0);\n\n            // Add a rigidbody component so that other objects collide with it\n            floor.addComponent(\"rigidbody\", {\n                type: \"static\",\n                restitution: 0.5,\n            });\n\n            // Add a collision component\n            floor.addComponent(\"collision\", {\n                type: \"box\",\n                halfExtents: new pc.Vec3(5, 0.5, 5),\n            });\n\n            // Add the floor to the hierarchy\n            app.root.addChild(floor);\n\n            // Create an entity from the loaded model using the render component\n            const modelEntity = assets.model.resource.instantiateRenderEntity({\n                castShadows: true,\n            });\n\n            // Add an anim component to the entity\n            modelEntity.addComponent(\"anim\", {\n                activate: true,\n            });\n\n            // create an anim state graph\n            const animStateGraphData = {\n                layers: [\n                    {\n                        name: \"characterState\",\n                        states: [\n                            {\n                                name: \"START\",\n                            },\n\n                            {\n                                name: \"Idle\",\n                                speed: 1.0,\n                                loop: true,\n                            },\n                        ],\n\n                        transitions: [\n                            {\n                                from: \"START\",\n                                to: \"Idle\",\n                            },\n                        ],\n                    },\n                ],\n\n                parameters: {},\n            };\n\n            // load the state graph into the anim component\n            modelEntity.anim.loadStateGraph(animStateGraphData);\n\n            // Add a rigid body and collision for the head with offset as the model's origin is\n            // at the feet on the floor\n            modelEntity.addComponent(\"rigidbody\", {\n                type: \"static\",\n                restitution: 0.5,\n            });\n\n            modelEntity.addComponent(\"collision\", {\n                type: \"sphere\",\n                radius: 0.3,\n                linearOffset: [0, 1.25, 0],\n            });\n\n            // load the state graph asset resource into the anim component\n            const characterStateLayer = modelEntity.anim.baseLayer;\n            characterStateLayer.assignAnimation(\n                \"Idle\",\n                assets.idleAnim.resource.animations[0].resource\n            );\n\n            app.root.addChild(modelEntity);\n\n            // Create an Entity with a camera component\n            const cameraEntity = new pc.Entity();\n            cameraEntity.addComponent(\"camera\");\n            cameraEntity.translate(0, 2, 5);\n            const lookAtPosition = modelEntity.getPosition();\n            cameraEntity.lookAt(\n                lookAtPosition.x,\n                lookAtPosition.y + 0.75,\n                lookAtPosition.z\n            );\n\n            app.root.addChild(cameraEntity);\n\n            // create a ball template that we can clone in the update loop\n            const ball = new pc.Entity();\n            ball.tags.add(\"shape\");\n            ball.setLocalScale(0.4, 0.4, 0.4);\n            ball.addComponent(\"render\", {\n                type: \"sphere\",\n            });\n\n            ball.addComponent(\"rigidbody\", {\n                type: \"dynamic\",\n                mass: 50,\n                restitution: 0.5,\n            });\n\n            ball.addComponent(\"collision\", {\n                type: \"sphere\",\n                radius: 0.2,\n            });\n\n            ball.enabled = false;\n\n            // initialize variables for our update function\n            let timer = 0;\n            let count = 40;\n\n            // Set an update function on the application's update event\n            app.on(\"update\", function (dt) {\n                // create a falling box every 0.2 seconds\n                if (count > 0) {\n                    timer -= dt;\n                    if (timer <= 0) {\n                        count--;\n                        timer = 0.5;\n\n                        // Create a new ball to drop\n                        const clone = ball.clone();\n                        clone.rigidbody.teleport(\n                            pc.math.random(-0.25, 0.25),\n                            5,\n                            pc.math.random(-0.25, 0.25)\n                        );\n\n                        app.root.addChild(clone);\n                        clone.enabled = true;\n                    }\n                }\n\n                // Show active bodies in red and frozen bodies in gray\n                app.root.findByTag(\"shape\").forEach(function (entity) {\n                    entity.render.meshInstances[0].material =\n                        entity.rigidbody.isActive() ? red : gray;\n                });\n\n                // Render the offset collision\n                app.scene.immediate.drawWireSphere(\n                    modelEntity.collision.getShapePosition(),\n                    0.3,\n                    pc.Color.GREEN,\n                    16,\n                    true,\n                    app.scene.layers.getLayerByName(\"World\")\n                );\n            });\n        }\n    });\n}\n","nameSlug":"offset-collision","categorySlug":"physics"},"raycast":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    pc.WasmModule.setConfig('Ammo', {\n        glueUrl: '/static/lib/ammo/ammo.wasm.js',\n        wasmUrl: '/static/lib/ammo/ammo.wasm.wasm',\n        fallbackUrl: '/static/lib/ammo/ammo.js'\n    });\n\n    pc.WasmModule.getInstance('Ammo', demo);\n\n    function demo() {\n\n        const assets = {\n            'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/arial.json' })\n        };\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            function createMaterial(color: pc.Color) {\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                material.update();\n\n                return material;\n            }\n\n            // Create a couple of materials\n            const red = createMaterial(new pc.Color(1, 0, 0));\n            const green = createMaterial(new pc.Color(0, 1, 0));\n\n            // Create light\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\"\n            });\n\n            app.root.addChild(light);\n            light.setEulerAngles(45, 30, 0);\n\n            // Create camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.5, 0.5, 0.8)\n            });\n\n            app.root.addChild(camera);\n            camera.setPosition(5, 0, 15);\n\n            function createPhysicalShape(type: string, material: pc.Material, x: number, y: number, z: number) {\n                const e = new pc.Entity();\n\n                // Have to set the position of the entity before adding the static rigidbody\n                // component because static bodies cannot be moved after creation\n                app.root.addChild(e);\n                e.setPosition(x, y, z);\n\n                e.addComponent(\"render\", {\n                    type: type,\n                    material: material\n                });\n                e.addComponent(\"rigidbody\", {\n                    type: \"static\"\n                });\n                e.addComponent(\"collision\", {\n                    type: type,\n                    height: type === 'capsule' ? 2 : 1\n                });\n\n                return e;\n            }\n\n            // Create two rows of physical geometric shapes\n            const types = ['box', 'capsule', 'cone', 'cylinder', 'sphere'];\n            types.forEach(function (type, idx) {\n                createPhysicalShape(type, green, idx * 2 + 1, 2, 0);\n            });\n            types.forEach(function (type, idx) {\n                createPhysicalShape(type, green, idx * 2 + 1, -2, 0);\n            });\n\n            // Allocate some colors\n            const white = new pc.Color(1, 1, 1);\n            const blue = new pc.Color(0, 0, 1);\n\n            // Allocate some vectors\n            const start = new pc.Vec3();\n            const end = new pc.Vec3();\n            const temp = new pc.Vec3();\n\n            // Set an update function on the application's update event\n            let time = 0;\n            let y = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // Reset all shapes to green\n                app.root.findComponents('render').forEach(function (render: pc.RenderComponent) {\n                    render.material = green;\n                });\n\n                y = 2 + 1.2 * Math.sin(time);\n                start.set(0, y, 0);\n                end.set(10, y, 0);\n\n                // Render the ray used in the raycast\n                app.drawLine(start, end, white);\n\n                const result = app.systems.rigidbody.raycastFirst(start, end);\n                if (result) {\n                    result.entity.render.material = red;\n\n                    // Render the normal on the surface from the hit point\n                    temp.copy(result.normal).mulScalar(0.3).add(result.point);\n                    app.drawLine(result.point, temp, blue);\n                }\n\n                y = -2 + 1.2 * Math.sin(time);\n                start.set(0, y, 0);\n                end.set(10, y, 0);\n\n                // Render the ray used in the raycast\n                app.drawLine(start, end, white);\n\n                const results = app.systems.rigidbody.raycastAll(start, end);\n                results.forEach(function (result: pc.RaycastResult) {\n                    result.entity.render.material = red;\n\n                    // Render the normal on the surface from the hit point\n                    temp.copy(result.normal).mulScalar(0.3).add(result.point);\n                    app.drawLine(result.point, temp, blue);\n                }, this);\n            });\n\n            const createText = function (fontAsset: pc.Asset, message: string, x: number, y: number, z: number, rot: number) {\n                // Create a text element-based entity\n                const text = new pc.Entity();\n                text.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    fontAsset: fontAsset,\n                    fontSize: 0.5,\n                    pivot: [0, 0.5],\n                    text: message,\n                    type: pc.ELEMENTTYPE_TEXT\n                });\n                text.setLocalPosition(x, y, z);\n                text.setLocalEulerAngles(0, 0, rot);\n                app.root.addChild(text);\n            };\n\n            createText(assets.font, 'raycastFirst', 0.5, 3.75, 0, 0);\n            createText(assets.font, 'raycastAll', 0.5, -0.25, 0, 0);\n        });\n    }\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    pc.WasmModule.setConfig(\"Ammo\", {\n        glueUrl: \"/static/lib/ammo/ammo.wasm.js\",\n        wasmUrl: \"/static/lib/ammo/ammo.wasm.wasm\",\n        fallbackUrl: \"/static/lib/ammo/ammo.js\",\n    });\n\n    pc.WasmModule.getInstance(\"Ammo\", demo);\n\n    function demo() {\n        const assets = {\n            font: new pc.Asset(\"font\", \"font\", {\n                url: \"/static/assets/fonts/arial.json\",\n            }),\n        };\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\n\n            function createMaterial(color) {\n                const material = new pc.StandardMaterial();\n                material.diffuse = color;\n                material.update();\n\n                return material;\n            }\n\n            // Create a couple of materials\n            const red = createMaterial(new pc.Color(1, 0, 0));\n            const green = createMaterial(new pc.Color(0, 1, 0));\n\n            // Create light\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n            });\n\n            app.root.addChild(light);\n            light.setEulerAngles(45, 30, 0);\n\n            // Create camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(0.5, 0.5, 0.8),\n            });\n\n            app.root.addChild(camera);\n            camera.setPosition(5, 0, 15);\n\n            function createPhysicalShape(type, material, x, y, z) {\n                const e = new pc.Entity();\n\n                // Have to set the position of the entity before adding the static rigidbody\n                // component because static bodies cannot be moved after creation\n                app.root.addChild(e);\n                e.setPosition(x, y, z);\n\n                e.addComponent(\"render\", {\n                    type: type,\n                    material: material,\n                });\n\n                e.addComponent(\"rigidbody\", {\n                    type: \"static\",\n                });\n\n                e.addComponent(\"collision\", {\n                    type: type,\n                    height: type === \"capsule\" ? 2 : 1,\n                });\n\n                return e;\n            }\n\n            // Create two rows of physical geometric shapes\n            const types = [\"box\", \"capsule\", \"cone\", \"cylinder\", \"sphere\"];\n            types.forEach(function (type, idx) {\n                createPhysicalShape(type, green, idx * 2 + 1, 2, 0);\n            });\n            types.forEach(function (type, idx) {\n                createPhysicalShape(type, green, idx * 2 + 1, -2, 0);\n            });\n\n            // Allocate some colors\n            const white = new pc.Color(1, 1, 1);\n            const blue = new pc.Color(0, 0, 1);\n\n            // Allocate some vectors\n            const start = new pc.Vec3();\n            const end = new pc.Vec3();\n            const temp = new pc.Vec3();\n\n            // Set an update function on the application's update event\n            let time = 0;\n            let y = 0;\n            app.on(\"update\", function (dt) {\n                time += dt;\n\n                // Reset all shapes to green\n                app.root.findComponents(\"render\").forEach(function (render) {\n                    render.material = green;\n                });\n\n                y = 2 + 1.2 * Math.sin(time);\n                start.set(0, y, 0);\n                end.set(10, y, 0);\n\n                // Render the ray used in the raycast\n                app.drawLine(start, end, white);\n\n                const result = app.systems.rigidbody.raycastFirst(start, end);\n                if (result) {\n                    result.entity.render.material = red;\n\n                    // Render the normal on the surface from the hit point\n                    temp.copy(result.normal).mulScalar(0.3).add(result.point);\n                    app.drawLine(result.point, temp, blue);\n                }\n\n                y = -2 + 1.2 * Math.sin(time);\n                start.set(0, y, 0);\n                end.set(10, y, 0);\n\n                // Render the ray used in the raycast\n                app.drawLine(start, end, white);\n\n                const results = app.systems.rigidbody.raycastAll(start, end);\n                results.forEach(function (result) {\n                    result.entity.render.material = red;\n\n                    // Render the normal on the surface from the hit point\n                    temp.copy(result.normal).mulScalar(0.3).add(result.point);\n                    app.drawLine(result.point, temp, blue);\n                }, this);\n            });\n\n            const createText = function (fontAsset, message, x, y, z, rot) {\n                // Create a text element-based entity\n                const text = new pc.Entity();\n                text.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    fontAsset: fontAsset,\n                    fontSize: 0.5,\n                    pivot: [0, 0.5],\n                    text: message,\n                    type: pc.ELEMENTTYPE_TEXT,\n                });\n\n                text.setLocalPosition(x, y, z);\n                text.setLocalEulerAngles(0, 0, rot);\n                app.root.addChild(text);\n            };\n\n            createText(assets.font, \"raycastFirst\", 0.5, 3.75, 0, 0);\n            createText(assets.font, \"raycastAll\", 0.5, -0.25, 0, 0);\n        });\n    }\n}\n","nameSlug":"raycast","categorySlug":"physics"},"vehicle":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    pc.WasmModule.setConfig('Ammo', {\n        glueUrl: '/static/lib/ammo/ammo.wasm.js',\n        wasmUrl: '/static/lib/ammo/ammo.wasm.wasm',\n        fallbackUrl: '/static/lib/ammo/ammo.js'\n    });\n\n    pc.WasmModule.getInstance('Ammo', demo);\n\n    function demo() {\n\n        const assets = {\n            helipad: new pc.Asset('helipad-env-atlas', 'texture', { url: '/static/assets/cubemaps/helipad-env-atlas.png' }, { type: pc.TEXTURETYPE_RGBP }),\n            'script1': new pc.Asset('script1', 'script', { url: '/static/scripts/camera/tracking-camera.js' }),\n            'script2': new pc.Asset('script2', 'script', { url: '/static/scripts/physics/render-physics.js' }),\n            'script3': new pc.Asset('script3', 'script', { url: '/static/scripts/physics/action-physics-reset.js' }),\n            'script4': new pc.Asset('script4', 'script', { url: '/static/scripts/physics/vehicle.js' })\n        };\n\n        const gfxOptions = {\n            deviceTypes: [deviceType],\n            glslangUrl: '/static/lib/glslang/glslang.js',\n            twgslUrl: '/static/lib/twgsl/twgsl.js'\n        };\n\n        pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n            createOptions.keyboard = new pc.Keyboard(document.body);\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.ModelComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.LightComponentSystem,\n                // @ts-ignore\n                pc.ScriptComponentSystem,\n                // @ts-ignore\n                pc.CollisionComponentSystem,\n                // @ts-ignore\n                pc.RigidBodyComponentSystem\n            ];\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.ContainerHandler,\n                // @ts-ignore\n                pc.ScriptHandler,\n                // @ts-ignore\n                pc.JsonHandler\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n            assetListLoader.load(() => {\n\n                app.start();\n\n                // setup skydome\n                app.scene.skyboxMip = 2;\n                app.scene.exposure = 0.3;\n                app.scene.envAtlas = assets.helipad.resource;\n\n                const lighting = app.scene.lighting;\n                lighting.shadowsEnabled = false;\n\n                // Create a static ground shape for our car to drive on\n                const ground = new pc.Entity('Ground');\n                ground.addComponent('rigidbody', {\n                    type: 'static'\n                });\n                ground.addComponent('collision', {\n                    type: 'box',\n                    halfExtents: new pc.Vec3(50, 0.5, 50)\n                });\n                ground.setLocalPosition(0, -0.5, 0);\n                app.root.addChild(ground);\n\n                // Create 4 wheels for our vehicle\n                const wheels: any = [];\n                [\n                    { name: 'Front Left Wheel', pos: new pc.Vec3(0.8, 0.4, 1.2), front: true },\n                    { name: 'Front Right Wheel', pos: new pc.Vec3(-0.8, 0.4, 1.2), front: true },\n                    { name: 'Back Left Wheel', pos: new pc.Vec3(0.8, 0.4, -1.2), front: false },\n                    { name: 'Back Right Wheel', pos: new pc.Vec3(-0.8, 0.4, -1.2), front: false }\n                ].forEach(function (wheelDef) {\n                    // Create a wheel\n                    const wheel = new pc.Entity(wheelDef.name);\n                    wheel.addComponent('script');\n                    wheel.script.create('vehicleWheel', {\n                        attributes: {\n                            debugRender: true,\n                            isFront: wheelDef.front\n                        }\n                    });\n                    wheel.setLocalPosition(wheelDef.pos);\n                    wheels.push(wheel);\n                });\n\n                // Create a physical vehicle\n                const vehicle = new pc.Entity('Vehicle');\n                vehicle.addComponent('rigidbody', {\n                    mass: 800,\n                    type: 'dynamic'\n                });\n                vehicle.addComponent('collision', {\n                    type: 'compound'\n                });\n                vehicle.addComponent('script');\n                vehicle.script.create('vehicle', {\n                    attributes: {\n                        wheels: wheels\n                    }\n                });\n                vehicle.script.create('vehicleControls');\n                vehicle.script.create('actionPhysicsReset', {\n                    attributes: {\n                        event: 'reset'\n                    }\n                });\n                vehicle.setLocalPosition(0, 2, 0);\n\n                // Create the car chassis, offset upwards in Y from the compound body\n                const chassis = new pc.Entity('Chassis');\n                chassis.addComponent('collision', {\n                    type: 'box',\n                    halfExtents: [0.6, 0.35, 1.65]\n                });\n                chassis.setLocalPosition(0, 0.65, 0);\n\n                // Create the car chassis, offset upwards in Y from the compound body\n                const cab = new pc.Entity('Cab');\n                cab.addComponent('collision', {\n                    type: 'box',\n                    halfExtents: [0.5, 0.2, 1]\n                });\n                cab.setLocalPosition(0, 1.2, -0.25);\n\n                // Add the vehicle to the hierarchy\n                wheels.forEach(function (wheel: pc.Entity) {\n                    vehicle.addChild(wheel);\n                });\n                vehicle.addChild(chassis);\n                vehicle.addChild(cab);\n                app.root.addChild(vehicle);\n\n                // Build a wall of blocks for the car to smash through\n                for (let i = 0; i < 10; i++) {\n                    for (let j = 0; j < 5; j++) {\n                        const block = new pc.Entity('Block');\n                        block.addComponent('rigidbody', {\n                            type: 'dynamic'\n                        });\n                        block.addComponent('collision', {\n                            type: 'box'\n                        });\n                        block.addComponent('script');\n                        block.script.create('actionPhysicsReset', {\n                            attributes: {\n                                event: 'reset'\n                            }\n                        });\n                        block.setLocalPosition(i - 4.5, j + 0.5, -10);\n                        app.root.addChild(block);\n                    }\n                }\n\n                // Create a directional light source\n                const light = new pc.Entity('Directional Light');\n                light.addComponent(\"light\", {\n                    type: \"directional\",\n                    color: new pc.Color(1, 1, 1),\n                    castShadows: true,\n                    shadowBias: 0.2,\n                    shadowDistance: 40,\n                    normalOffsetBias: 0.05,\n                    shadowResolution: 2048\n                });\n                light.setLocalEulerAngles(45, 30, 0);\n                app.root.addChild(light);\n\n                // Create a camera to render the scene\n                const camera = new pc.Entity('Camera');\n                camera.addComponent(\"camera\");\n                camera.addComponent('script');\n                camera.script.create('trackingCamera', {\n                    attributes: {\n                        target: vehicle\n                    }\n                });\n                camera.translate(0, 10, 15);\n                camera.lookAt(0, 0, 0);\n                app.root.addChild(camera);\n\n                // Enable rendering and resetting of all rigid bodies in the scene\n                app.root.addComponent('script');\n                app.root.script.create('renderPhysics', {\n                    attributes: {\n                        drawShapes: true,\n                        opacity: 1\n                    }\n                });\n\n                app.keyboard.on(pc.EVENT_KEYDOWN, function (e) {\n                    if (e.key === pc.KEY_R) {\n                        app.fire('reset');\n                    }\n                });\n            });\n        });\n    }\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    pc.WasmModule.setConfig(\"Ammo\", {\n        glueUrl: \"/static/lib/ammo/ammo.wasm.js\",\n        wasmUrl: \"/static/lib/ammo/ammo.wasm.wasm\",\n        fallbackUrl: \"/static/lib/ammo/ammo.js\",\n    });\n\n    pc.WasmModule.getInstance(\"Ammo\", demo);\n\n    function demo() {\n        const assets = {\n            helipad: new pc.Asset(\n                \"helipad-env-atlas\",\n                \"texture\",\n                { url: \"/static/assets/cubemaps/helipad-env-atlas.png\" },\n                { type: pc.TEXTURETYPE_RGBP }\n            ),\n            script1: new pc.Asset(\"script1\", \"script\", {\n                url: \"/static/scripts/camera/tracking-camera.js\",\n            }),\n            script2: new pc.Asset(\"script2\", \"script\", {\n                url: \"/static/scripts/physics/render-physics.js\",\n            }),\n            script3: new pc.Asset(\"script3\", \"script\", {\n                url: \"/static/scripts/physics/action-physics-reset.js\",\n            }),\n            script4: new pc.Asset(\"script4\", \"script\", {\n                url: \"/static/scripts/physics/vehicle.js\",\n            }),\n        };\n\n        const gfxOptions = {\n            deviceTypes: [deviceType],\n            glslangUrl: \"/static/lib/glslang/glslang.js\",\n            twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n        };\n\n        pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n            const createOptions = new pc.AppOptions();\n            createOptions.graphicsDevice = device;\n            createOptions.keyboard = new pc.Keyboard(document.body);\n\n            createOptions.componentSystems = [\n                // @ts-ignore\n                pc.ModelComponentSystem,\n                // @ts-ignore\n                pc.CameraComponentSystem,\n                // @ts-ignore\n                pc.LightComponentSystem,\n                // @ts-ignore\n                pc.ScriptComponentSystem,\n                // @ts-ignore\n                pc.CollisionComponentSystem,\n                // @ts-ignore\n                pc.RigidBodyComponentSystem,\n            ];\n\n            createOptions.resourceHandlers = [\n                // @ts-ignore\n                pc.TextureHandler,\n                // @ts-ignore\n                pc.ContainerHandler,\n                // @ts-ignore\n                pc.ScriptHandler,\n                // @ts-ignore\n                pc.JsonHandler,\n            ];\n\n            const app = new pc.AppBase(canvas);\n            app.init(createOptions);\n\n            // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n            app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n            app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n            const assetListLoader = new pc.AssetListLoader(\n                Object.values(assets),\n                app.assets\n            );\n            assetListLoader.load(() => {\n                app.start();\n\n                // setup skydome\n                app.scene.skyboxMip = 2;\n                app.scene.exposure = 0.3;\n                app.scene.envAtlas = assets.helipad.resource;\n\n                const lighting = app.scene.lighting;\n                lighting.shadowsEnabled = false;\n\n                // Create a static ground shape for our car to drive on\n                const ground = new pc.Entity(\"Ground\");\n                ground.addComponent(\"rigidbody\", {\n                    type: \"static\",\n                });\n\n                ground.addComponent(\"collision\", {\n                    type: \"box\",\n                    halfExtents: new pc.Vec3(50, 0.5, 50),\n                });\n\n                ground.setLocalPosition(0, -0.5, 0);\n                app.root.addChild(ground);\n\n                // Create 4 wheels for our vehicle\n                const wheels = [];\n                [\n                    {\n                        name: \"Front Left Wheel\",\n                        pos: new pc.Vec3(0.8, 0.4, 1.2),\n                        front: true,\n                    },\n                    {\n                        name: \"Front Right Wheel\",\n                        pos: new pc.Vec3(-0.8, 0.4, 1.2),\n                        front: true,\n                    },\n                    {\n                        name: \"Back Left Wheel\",\n                        pos: new pc.Vec3(0.8, 0.4, -1.2),\n                        front: false,\n                    },\n                    {\n                        name: \"Back Right Wheel\",\n                        pos: new pc.Vec3(-0.8, 0.4, -1.2),\n                        front: false,\n                    },\n                ].forEach(function (wheelDef) {\n                    // Create a wheel\n                    const wheel = new pc.Entity(wheelDef.name);\n                    wheel.addComponent(\"script\");\n                    wheel.script.create(\"vehicleWheel\", {\n                        attributes: {\n                            debugRender: true,\n                            isFront: wheelDef.front,\n                        },\n                    });\n\n                    wheel.setLocalPosition(wheelDef.pos);\n                    wheels.push(wheel);\n                });\n\n                // Create a physical vehicle\n                const vehicle = new pc.Entity(\"Vehicle\");\n                vehicle.addComponent(\"rigidbody\", {\n                    mass: 800,\n                    type: \"dynamic\",\n                });\n\n                vehicle.addComponent(\"collision\", {\n                    type: \"compound\",\n                });\n\n                vehicle.addComponent(\"script\");\n                vehicle.script.create(\"vehicle\", {\n                    attributes: {\n                        wheels: wheels,\n                    },\n                });\n\n                vehicle.script.create(\"vehicleControls\");\n                vehicle.script.create(\"actionPhysicsReset\", {\n                    attributes: {\n                        event: \"reset\",\n                    },\n                });\n\n                vehicle.setLocalPosition(0, 2, 0);\n\n                // Create the car chassis, offset upwards in Y from the compound body\n                const chassis = new pc.Entity(\"Chassis\");\n                chassis.addComponent(\"collision\", {\n                    type: \"box\",\n                    halfExtents: [0.6, 0.35, 1.65],\n                });\n\n                chassis.setLocalPosition(0, 0.65, 0);\n\n                // Create the car chassis, offset upwards in Y from the compound body\n                const cab = new pc.Entity(\"Cab\");\n                cab.addComponent(\"collision\", {\n                    type: \"box\",\n                    halfExtents: [0.5, 0.2, 1],\n                });\n\n                cab.setLocalPosition(0, 1.2, -0.25);\n\n                // Add the vehicle to the hierarchy\n                wheels.forEach(function (wheel) {\n                    vehicle.addChild(wheel);\n                });\n                vehicle.addChild(chassis);\n                vehicle.addChild(cab);\n                app.root.addChild(vehicle);\n\n                // Build a wall of blocks for the car to smash through\n                for (let i = 0; i < 10; i++) {\n                    for (let j = 0; j < 5; j++) {\n                        const block = new pc.Entity(\"Block\");\n                        block.addComponent(\"rigidbody\", {\n                            type: \"dynamic\",\n                        });\n\n                        block.addComponent(\"collision\", {\n                            type: \"box\",\n                        });\n\n                        block.addComponent(\"script\");\n                        block.script.create(\"actionPhysicsReset\", {\n                            attributes: {\n                                event: \"reset\",\n                            },\n                        });\n\n                        block.setLocalPosition(i - 4.5, j + 0.5, -10);\n                        app.root.addChild(block);\n                    }\n                }\n\n                // Create a directional light source\n                const light = new pc.Entity(\"Directional Light\");\n                light.addComponent(\"light\", {\n                    type: \"directional\",\n                    color: new pc.Color(1, 1, 1),\n                    castShadows: true,\n                    shadowBias: 0.2,\n                    shadowDistance: 40,\n                    normalOffsetBias: 0.05,\n                    shadowResolution: 2048,\n                });\n\n                light.setLocalEulerAngles(45, 30, 0);\n                app.root.addChild(light);\n\n                // Create a camera to render the scene\n                const camera = new pc.Entity(\"Camera\");\n                camera.addComponent(\"camera\");\n                camera.addComponent(\"script\");\n                camera.script.create(\"trackingCamera\", {\n                    attributes: {\n                        target: vehicle,\n                    },\n                });\n\n                camera.translate(0, 10, 15);\n                camera.lookAt(0, 0, 0);\n                app.root.addChild(camera);\n\n                // Enable rendering and resetting of all rigid bodies in the scene\n                app.root.addComponent(\"script\");\n                app.root.script.create(\"renderPhysics\", {\n                    attributes: {\n                        drawShapes: true,\n                        opacity: 1,\n                    },\n                });\n\n                app.keyboard.on(pc.EVENT_KEYDOWN, function (e) {\n                    if (e.key === pc.KEY_R) {\n                        app.fire(\"reset\");\n                    }\n                });\n            });\n        });\n    }\n}\n","nameSlug":"vehicle","categorySlug":"physics"}},"sound":{"positional":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        'model': new pc.Asset('model', 'model', { url: '/static/assets/models/playbot/playbot.json' }),\n        'runAnim': new pc.Asset('runAnim', 'animation', { url: '/static/assets/animations/playbot/playbot-run.json' }),\n        'gravel': new pc.Asset('gravel', 'audio', { url: '/static/assets/sounds/footsteps.mp3' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n\n        // Create an Entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(1, 0, 0)\n        });\n        camera.addComponent(\"audiolistener\");\n        camera.rotateLocal(-30, 0, 0);\n        camera.translateLocal(0, 0, 5);\n        app.root.addChild(camera);\n\n        // Create an Entity for the ground\n        const material = new pc.StandardMaterial();\n        material.diffuse = pc.Color.GRAY;\n        material.update();\n\n        const ground = new pc.Entity();\n        ground.addComponent(\"render\", {\n            type: \"box\",\n            material: material\n        });\n        ground.setLocalScale(50, 1, 50);\n        ground.setLocalPosition(0, -0.5, 0);\n        app.root.addChild(ground);\n\n        // Create an entity with a light component\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\",\n            color: new pc.Color(1, 1, 1),\n            castShadows: true,\n            intensity: 2,\n            shadowBias: 0.2,\n            shadowDistance: 16,\n            normalOffsetBias: 0.05,\n            shadowResolution: 2048\n        });\n        light.setLocalEulerAngles(45, 30, 0);\n        app.root.addChild(light);\n\n        app.start();\n\n        // Create walking dude\n        const entity = new pc.Entity();\n\n        // add sound component\n        entity.addComponent('sound');\n\n        // add footsteps slot\n        entity.sound.addSlot('footsteps', {\n            asset: assets.gravel.id,\n            pitch: 1.7,\n            loop: true,\n            autoPlay: true\n        });\n\n        // add model\n        entity.addComponent(\"model\", {\n            type: \"asset\",\n            asset: assets.model,\n            castShadows: true\n        });\n\n        // add animation\n        entity.addComponent(\"animation\", {\n            assets: [assets.runAnim],\n            speed: 0.8\n        });\n\n        // add entity in the hierarchy\n        app.root.addChild(entity);\n\n        let angle = 135;\n        const radius = 3;\n        const height = 0;// 1.1;\n        app.on(\"update\", function (dt) {\n            angle += 30 * dt;\n            if (angle > 360) {\n                angle -= 360;\n            }\n            entity.setLocalPosition(radius * Math.sin(angle * pc.math.DEG_TO_RAD), height, radius * Math.cos(angle * pc.math.DEG_TO_RAD));\n            entity.setLocalEulerAngles(0, angle + 90, 0);\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    // Create the application and start the update loop\n    const app = new pc.Application(canvas, {});\n\n    const assets = {\n        model: new pc.Asset(\"model\", \"model\", {\n            url: \"/static/assets/models/playbot/playbot.json\",\n        }),\n        runAnim: new pc.Asset(\"runAnim\", \"animation\", {\n            url: \"/static/assets/animations/playbot/playbot-run.json\",\n        }),\n        gravel: new pc.Asset(\"gravel\", \"audio\", {\n            url: \"/static/assets/sounds/footsteps.mp3\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        // Create an Entity with a camera component\n        const camera = new pc.Entity();\n        camera.addComponent(\"camera\", {\n            clearColor: new pc.Color(1, 0, 0),\n        });\n\n        camera.addComponent(\"audiolistener\");\n        camera.rotateLocal(-30, 0, 0);\n        camera.translateLocal(0, 0, 5);\n        app.root.addChild(camera);\n\n        // Create an Entity for the ground\n        const material = new pc.StandardMaterial();\n        material.diffuse = pc.Color.GRAY;\n        material.update();\n\n        const ground = new pc.Entity();\n        ground.addComponent(\"render\", {\n            type: \"box\",\n            material: material,\n        });\n\n        ground.setLocalScale(50, 1, 50);\n        ground.setLocalPosition(0, -0.5, 0);\n        app.root.addChild(ground);\n\n        // Create an entity with a light component\n        const light = new pc.Entity();\n        light.addComponent(\"light\", {\n            type: \"directional\",\n            color: new pc.Color(1, 1, 1),\n            castShadows: true,\n            intensity: 2,\n            shadowBias: 0.2,\n            shadowDistance: 16,\n            normalOffsetBias: 0.05,\n            shadowResolution: 2048,\n        });\n\n        light.setLocalEulerAngles(45, 30, 0);\n        app.root.addChild(light);\n\n        app.start();\n\n        // Create walking dude\n        const entity = new pc.Entity();\n\n        // add sound component\n        entity.addComponent(\"sound\");\n\n        // add footsteps slot\n        entity.sound.addSlot(\"footsteps\", {\n            asset: assets.gravel.id,\n            pitch: 1.7,\n            loop: true,\n            autoPlay: true,\n        });\n\n        // add model\n        entity.addComponent(\"model\", {\n            type: \"asset\",\n            asset: assets.model,\n            castShadows: true,\n        });\n\n        // add animation\n        entity.addComponent(\"animation\", {\n            assets: [assets.runAnim],\n            speed: 0.8,\n        });\n\n        // add entity in the hierarchy\n        app.root.addChild(entity);\n\n        let angle = 135;\n        const radius = 3;\n        const height = 0; // 1.1;\n        app.on(\"update\", function (dt) {\n            angle += 30 * dt;\n            if (angle > 360) {\n                angle -= 360;\n            }\n            entity.setLocalPosition(\n                radius * Math.sin(angle * pc.math.DEG_TO_RAD),\n                height,\n                radius * Math.cos(angle * pc.math.DEG_TO_RAD)\n            );\n            entity.setLocalEulerAngles(0, angle + 90, 0);\n        });\n    });\n}\n","nameSlug":"positional","categorySlug":"sound"}},"user-interface":{"button-basic":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/courier.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n            });\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true\n            });\n            app.root.addChild(screen);\n\n            // Button\n            const button = new pc.Entity();\n            button.addComponent(\"button\", {\n                imageEntity: button\n            });\n            button.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                height: 40,\n                pivot: [0.5, 0.5],\n                type: pc.ELEMENTTYPE_IMAGE,\n                width: 175,\n                useInput: true\n            });\n            screen.addChild(button);\n\n            // Create a label for the button\n            const label = new pc.Entity();\n            label.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                color: new pc.Color(0, 0, 0),\n                fontAsset: assets.font.id,\n                fontSize: 32,\n                height: 64,\n                pivot: [0.5, 0.5],\n                text: \"CLICK ME\",\n                type: pc.ELEMENTTYPE_TEXT,\n                width: 128,\n                wrapLines: true\n            });\n            button.addChild(label);\n\n            // Change the background color every time the button is clicked\n            button.button.on('click', function () {\n                camera.camera.clearColor = new pc.Color(Math.random(), Math.random(), Math.random());\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/courier.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n            });\n\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true,\n            });\n\n            app.root.addChild(screen);\n\n            // Button\n            const button = new pc.Entity();\n            button.addComponent(\"button\", {\n                imageEntity: button,\n            });\n\n            button.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                height: 40,\n                pivot: [0.5, 0.5],\n                type: pc.ELEMENTTYPE_IMAGE,\n                width: 175,\n                useInput: true,\n            });\n\n            screen.addChild(button);\n\n            // Create a label for the button\n            const label = new pc.Entity();\n            label.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                color: new pc.Color(0, 0, 0),\n                fontAsset: assets.font.id,\n                fontSize: 32,\n                height: 64,\n                pivot: [0.5, 0.5],\n                text: \"CLICK ME\",\n                type: pc.ELEMENTTYPE_TEXT,\n                width: 128,\n                wrapLines: true,\n            });\n\n            button.addChild(label);\n\n            // Change the background color every time the button is clicked\n            button.button.on(\"click\", function () {\n                camera.camera.clearColor = new pc.Color(\n                    Math.random(),\n                    Math.random(),\n                    Math.random()\n                );\n            });\n        });\n    });\n}\n","nameSlug":"button-basic","categorySlug":"user-interface"},"button-sprite":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/courier.json' }),\n        'red_button_atlas': new pc.Asset('red_button_atlas', 'texture', { url: '/static/assets/button/red_button_atlas.png' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n            });\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true\n            });\n            app.root.addChild(screen);\n\n            // Create a simple button\n            const button = new pc.Entity();\n            button.addComponent(\"button\", {\n                active: true,\n                imageEntity: button,\n                transitionMode: pc.BUTTON_TRANSITION_MODE_SPRITE_CHANGE\n            });\n            button.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                height: 64,\n                pivot: [0.5, 0.5],\n                type: pc.ELEMENTTYPE_IMAGE,\n                width: 175,\n                useInput: true\n            });\n            screen.addChild(button);\n\n            // Create a label for the button\n            const label = new pc.Entity();\n            label.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                color: new pc.Color(1, 1, 1),\n                fontAsset: assets.font.id,\n                fontSize: 32,\n                height: 64,\n                opacity: 0.5,\n                pivot: [0.5, 0.5],\n                text: \"CLICK ME\",\n                type: pc.ELEMENTTYPE_TEXT,\n                width: 128,\n                wrapLines: true\n            });\n            button.addChild(label);\n\n            // Change the background color every time the button is clicked\n            button.button.on('click', function () {\n                const r = Math.random();\n                camera.camera.clearColor = new pc.Color(r, r, r);\n            });\n\n            // Move the button's label with the animation of the sprite\n            button.button.on('pressedstart', function () {\n                label.translateLocal(0, -4, 0);\n            });\n            button.button.on('pressedend', function () {\n                label.translateLocal(0, 4, 0);\n            });\n\n            // Apply the font to the text element\n            const texture = assets.red_button_atlas.resource;\n            texture.addressU = pc.ADDRESS_CLAMP_TO_EDGE;\n            texture.addressV = pc.ADDRESS_CLAMP_TO_EDGE;\n            texture.minFilter = pc.FILTER_NEAREST;\n            texture.magFilter = pc.FILTER_NEAREST;\n\n            const atlas = new pc.TextureAtlas();\n            atlas.frames = {\n                \"0\": {\n                    rect: new pc.Vec4(0, 147, 190, 49),\n                    pivot: new pc.Vec2(0.5, 0.5),\n                    border: new pc.Vec4(7, 11, 7, 7)\n                },\n                \"1\": {\n                    rect: new pc.Vec4(0, 98, 190, 49),\n                    pivot: new pc.Vec2(0.5, 0.5),\n                    border: new pc.Vec4(7, 11, 7, 7)\n                },\n                \"2\": {\n                    rect: new pc.Vec4(0, 49, 190, 49),\n                    pivot: new pc.Vec2(0.5, 0.5),\n                    border: new pc.Vec4(7, 11, 7, 7)\n                },\n                \"3\": {\n                    rect: new pc.Vec4(0, 0, 190, 49),\n                    pivot: new pc.Vec2(0.5, 0.5),\n                    border: new pc.Vec4(7, 11, 7, 7)\n                }\n            };\n            atlas.texture = texture;\n\n            const createSpriteAsset = function (frame: string) {\n                const sprite = new pc.Sprite(app.graphicsDevice, {\n                    atlas: atlas,\n                    frameKeys: [frame],\n                    pixelsPerUnit: 1,\n                    renderMode: pc.SPRITE_RENDERMODE_SIMPLE\n                });\n\n                const spriteAsset = new pc.Asset('sprite', 'sprite', { url: '' });\n                spriteAsset.resource = sprite;\n                spriteAsset.loaded = true;\n                app.assets.add(spriteAsset);\n                return spriteAsset;\n            };\n\n            button.element.spriteAsset = createSpriteAsset('0').id;\n            button.button.hoverSpriteAsset = createSpriteAsset('1');\n            button.button.pressedSpriteAsset = createSpriteAsset('2');\n            button.button.inactiveSpriteAsset = createSpriteAsset('3');\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/courier.json\",\n        }),\n        red_button_atlas: new pc.Asset(\"red_button_atlas\", \"texture\", {\n            url: \"/static/assets/button/red_button_atlas.png\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n            });\n\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true,\n            });\n\n            app.root.addChild(screen);\n\n            // Create a simple button\n            const button = new pc.Entity();\n            button.addComponent(\"button\", {\n                active: true,\n                imageEntity: button,\n                transitionMode: pc.BUTTON_TRANSITION_MODE_SPRITE_CHANGE,\n            });\n\n            button.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                height: 64,\n                pivot: [0.5, 0.5],\n                type: pc.ELEMENTTYPE_IMAGE,\n                width: 175,\n                useInput: true,\n            });\n\n            screen.addChild(button);\n\n            // Create a label for the button\n            const label = new pc.Entity();\n            label.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                color: new pc.Color(1, 1, 1),\n                fontAsset: assets.font.id,\n                fontSize: 32,\n                height: 64,\n                opacity: 0.5,\n                pivot: [0.5, 0.5],\n                text: \"CLICK ME\",\n                type: pc.ELEMENTTYPE_TEXT,\n                width: 128,\n                wrapLines: true,\n            });\n\n            button.addChild(label);\n\n            // Change the background color every time the button is clicked\n            button.button.on(\"click\", function () {\n                const r = Math.random();\n                camera.camera.clearColor = new pc.Color(r, r, r);\n            });\n\n            // Move the button's label with the animation of the sprite\n            button.button.on(\"pressedstart\", function () {\n                label.translateLocal(0, -4, 0);\n            });\n            button.button.on(\"pressedend\", function () {\n                label.translateLocal(0, 4, 0);\n            });\n\n            // Apply the font to the text element\n            const texture = assets.red_button_atlas.resource;\n            texture.addressU = pc.ADDRESS_CLAMP_TO_EDGE;\n            texture.addressV = pc.ADDRESS_CLAMP_TO_EDGE;\n            texture.minFilter = pc.FILTER_NEAREST;\n            texture.magFilter = pc.FILTER_NEAREST;\n\n            const atlas = new pc.TextureAtlas();\n            atlas.frames = {\n                \"0\": {\n                    rect: new pc.Vec4(0, 147, 190, 49),\n                    pivot: new pc.Vec2(0.5, 0.5),\n                    border: new pc.Vec4(7, 11, 7, 7),\n                },\n\n                \"1\": {\n                    rect: new pc.Vec4(0, 98, 190, 49),\n                    pivot: new pc.Vec2(0.5, 0.5),\n                    border: new pc.Vec4(7, 11, 7, 7),\n                },\n\n                \"2\": {\n                    rect: new pc.Vec4(0, 49, 190, 49),\n                    pivot: new pc.Vec2(0.5, 0.5),\n                    border: new pc.Vec4(7, 11, 7, 7),\n                },\n\n                \"3\": {\n                    rect: new pc.Vec4(0, 0, 190, 49),\n                    pivot: new pc.Vec2(0.5, 0.5),\n                    border: new pc.Vec4(7, 11, 7, 7),\n                },\n            };\n\n            atlas.texture = texture;\n\n            const createSpriteAsset = function (frame) {\n                const sprite = new pc.Sprite(app.graphicsDevice, {\n                    atlas: atlas,\n                    frameKeys: [frame],\n                    pixelsPerUnit: 1,\n                    renderMode: pc.SPRITE_RENDERMODE_SIMPLE,\n                });\n\n                const spriteAsset = new pc.Asset(\"sprite\", \"sprite\", {\n                    url: \"\",\n                });\n                spriteAsset.resource = sprite;\n                spriteAsset.loaded = true;\n                app.assets.add(spriteAsset);\n                return spriteAsset;\n            };\n\n            button.element.spriteAsset = createSpriteAsset(\"0\").id;\n            button.button.hoverSpriteAsset = createSpriteAsset(\"1\");\n            button.button.pressedSpriteAsset = createSpriteAsset(\"2\");\n            button.button.inactiveSpriteAsset = createSpriteAsset(\"3\");\n        });\n    });\n}\n","nameSlug":"button-sprite","categorySlug":"user-interface"},"custom-shader":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string, files: { 'shader.vert': string, 'shader.frag': string }): void {\n\n    const assets = {\n        \"playcanvas\": new pc.Asset(\"playcanvas\", \"texture\", { url: \"/static/assets/textures/playcanvas.png\" })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n            });\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true\n            });\n            app.root.addChild(screen);\n\n            // Create the shader from the vertex and fragment shader\n            const shader = pc.createShaderFromCode(app.graphicsDevice, files['shader.vert'], files['shader.frag'], 'myUIShader', {\n                vertex_position: pc.SEMANTIC_POSITION,\n                vertex_texCoord0: pc.SEMANTIC_TEXCOORD0\n            });\n\n            // Create a new material with the new shader and additive alpha blending\n            const material = new pc.Material();\n            material.shader = shader;\n            material.blendType = pc.BLEND_ADDITIVEALPHA;\n            material.depthWrite = true;\n            material.setParameter(\"uDiffuseMap\", assets.playcanvas.resource);\n            material.update();\n\n            // Create the UI image element with the custom material\n            const entity = new pc.Entity();\n            entity.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                width: 350,\n                height: 350,\n                type: pc.ELEMENTTYPE_IMAGE\n            });\n            entity.element.material = material;\n            screen.addChild(entity);\n\n            // update the material's 'amount' parameter to animate the inverse effect\n            let time = 0;\n            app.on('update', (dt) => {\n                time += dt;\n                // animate the amount as a sine wave varying from 0 to 1\n                material.setParameter(\"amount\", (Math.sin(time * 4) + 1) * 0.5);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType, files) {\n    const assets = {\n        playcanvas: new pc.Asset(\"playcanvas\", \"texture\", {\n            url: \"/static/assets/textures/playcanvas.png\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n            });\n\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true,\n            });\n\n            app.root.addChild(screen);\n\n            // Create the shader from the vertex and fragment shader\n            const shader = pc.createShaderFromCode(\n                app.graphicsDevice,\n                files[\"shader.vert\"],\n                files[\"shader.frag\"],\n                \"myUIShader\",\n                {\n                    vertex_position: pc.SEMANTIC_POSITION,\n                    vertex_texCoord0: pc.SEMANTIC_TEXCOORD0,\n                }\n            );\n\n            // Create a new material with the new shader and additive alpha blending\n            const material = new pc.Material();\n            material.shader = shader;\n            material.blendType = pc.BLEND_ADDITIVEALPHA;\n            material.depthWrite = true;\n            material.setParameter(\"uDiffuseMap\", assets.playcanvas.resource);\n            material.update();\n\n            // Create the UI image element with the custom material\n            const entity = new pc.Entity();\n            entity.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                width: 350,\n                height: 350,\n                type: pc.ELEMENTTYPE_IMAGE,\n            });\n\n            entity.element.material = material;\n            screen.addChild(entity);\n\n            // update the material's 'amount' parameter to animate the inverse effect\n            let time = 0;\n            app.on(\"update\", (dt) => {\n                time += dt;\n                // animate the amount as a sine wave varying from 0 to 1\n                material.setParameter(\"amount\", (Math.sin(time * 4) + 1) * 0.5);\n            });\n        });\n    });\n}\n","nameSlug":"custom-shader","categorySlug":"user-interface","files":{"shader.vert":"\n/**\n * Simple Screen-Space Vertex Shader with one UV coordinate.\n * This shader is useful for simple UI shaders.\n * \n * Usage: the following attributes must be configured when creating a new pc.Shader:\n *   vertex_position: pc.SEMANTIC_POSITION\n *   vertex_texCoord0: pc.SEMANTIC_TEXCOORD0\n */\n\n// Default PlayCanvas uniforms\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n\n// Additional inputs\nattribute vec3 vertex_position;\nattribute vec2 vertex_texCoord0;\n\n// Additional shader outputs\nvarying vec2 vUv0;\n\nvoid main(void) {\n    // UV is simply passed along as varying\n    vUv0 = vertex_texCoord0;\n\n    // Position for screen-space\n    gl_Position = matrix_model * vec4(vertex_position, 1.0);\n    gl_Position.zw = vec2(0.0, 1.0);\n}","shader.frag":"\n/**\n * Simple Color-Inverse Fragment Shader with intensity control.\n * \n * Usage: the following parameters must be set:\n *   uDiffuseMap: image texture.\n *   amount: float that controls the amount of the inverse-color effect. 0 means none (normal color), while 1 means full inverse.\n *\n * Additionally, the Vertex shader that is paired with this Fragment shader must specify:\n *   varying vec2 vUv0: for the UV.\n */\n\n// The following line is for setting the shader precision for floats. It is commented out because, ideally, it must be configured\n// on a per-device basis before loading the Shader. Please check the accompanying TypeScript code and look for 'app.graphicsDevice.precision'.\n\n// precision mediump float;\n\n// Additional varying from vertex shader\nvarying vec2 vUv0;\n\n// Custom Parameters (must be set from code via material.setParameter())\nuniform sampler2D uDiffuseMap;\nuniform float amount;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uDiffuseMap, vUv0);\n    vec3 roloc = 1.0 - color.rgb;\n    gl_FragColor = vec4(mix(color.rgb, roloc, amount), color.a);\n}"}},"layout-group":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/courier.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.LayoutGroupComponentSystem,\n            // @ts-ignore\n            pc.LayoutChildComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n            });\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true\n            });\n            app.root.addChild(screen);\n\n            // Create Layout Group Entity\n            const group = new pc.Entity();\n            group.addComponent(\"element\", {\n                // a Layout Group needs a 'group' element component\n                type: pc.ELEMENTTYPE_GROUP,\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                pivot: [0.5, 0.5],\n                // the element's width and height dictate the group's bounds\n                width: 350,\n                height: 150\n            });\n            group.addComponent(\"layoutgroup\", {\n                orientation: pc.ORIENTATION_HORIZONTAL,\n                spacing: new pc.Vec2(10, 10),\n                // fit_both for width and height, making all child elements take the entire space\n                widthFitting: pc.FITTING_BOTH,\n                heightFitting: pc.FITTING_BOTH,\n                // wrap children\n                wrap: true\n            });\n            screen.addChild(group);\n\n            // create 15 children to show off the layout group\n            for (let i = 0; i < 15; ++i) {\n                // create a random-colored panel\n                const child = new pc.Entity();\n                child.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    pivot: [0.5, 0.5],\n                    color: new pc.Color(Math.random(), Math.random(), Math.random()),\n                    type: pc.ELEMENTTYPE_IMAGE\n                });\n                child.addComponent(\"layoutchild\", {\n                    excludeFromLayout: false\n                });\n                group.addChild(child);\n\n                // add a text label\n                const childLabel = new pc.Entity();\n                childLabel.addComponent(\"element\", {\n                    // center-position and attach to the borders of parent\n                    // meaning this text element will scale along with parent\n                    anchor: [0, 0, 1, 1],\n                    margin: [0, 0, 0, 0],\n                    pivot: [0.5, 0.5],\n                    color: new pc.Color(1, 1, 1),\n                    fontAsset: assets.font.id,\n                    text: `${i + 1}`,\n                    type: pc.ELEMENTTYPE_TEXT,\n                    // auto font size\n                    autoWidth: false,\n                    autoHeight: false,\n                    autoFitWidth: true,\n                    autoFitHeight: true\n                });\n                child.addChild(childLabel);\n            }\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/courier.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.LayoutGroupComponentSystem,\n            // @ts-ignore\n            pc.LayoutChildComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n            });\n\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true,\n            });\n\n            app.root.addChild(screen);\n\n            // Create Layout Group Entity\n            const group = new pc.Entity();\n            group.addComponent(\"element\", {\n                // a Layout Group needs a 'group' element component\n                type: pc.ELEMENTTYPE_GROUP,\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                pivot: [0.5, 0.5],\n                // the element's width and height dictate the group's bounds\n                width: 350,\n                height: 150,\n            });\n\n            group.addComponent(\"layoutgroup\", {\n                orientation: pc.ORIENTATION_HORIZONTAL,\n                spacing: new pc.Vec2(10, 10),\n                // fit_both for width and height, making all child elements take the entire space\n                widthFitting: pc.FITTING_BOTH,\n                heightFitting: pc.FITTING_BOTH,\n                // wrap children\n                wrap: true,\n            });\n\n            screen.addChild(group);\n\n            // create 15 children to show off the layout group\n            for (let i = 0; i < 15; ++i) {\n                // create a random-colored panel\n                const child = new pc.Entity();\n                child.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    pivot: [0.5, 0.5],\n                    color: new pc.Color(\n                        Math.random(),\n                        Math.random(),\n                        Math.random()\n                    ),\n                    type: pc.ELEMENTTYPE_IMAGE,\n                });\n\n                child.addComponent(\"layoutchild\", {\n                    excludeFromLayout: false,\n                });\n\n                group.addChild(child);\n\n                // add a text label\n                const childLabel = new pc.Entity();\n                childLabel.addComponent(\"element\", {\n                    // center-position and attach to the borders of parent\n                    // meaning this text element will scale along with parent\n                    anchor: [0, 0, 1, 1],\n                    margin: [0, 0, 0, 0],\n                    pivot: [0.5, 0.5],\n                    color: new pc.Color(1, 1, 1),\n                    fontAsset: assets.font.id,\n                    text: `${i + 1}`,\n                    type: pc.ELEMENTTYPE_TEXT,\n                    // auto font size\n                    autoWidth: false,\n                    autoHeight: false,\n                    autoFitWidth: true,\n                    autoFitHeight: true,\n                });\n\n                child.addChild(childLabel);\n            }\n        });\n    });\n}\n","nameSlug":"layout-group","categorySlug":"user-interface"},"particle-system":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/courier.json' }),\n        'spark': new pc.Asset('spark', 'texture', { url: '/static/assets/textures/spark.png' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.ParticleSystemComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n            });\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true\n            });\n            app.root.addChild(screen);\n\n            // Create a simple panel\n            const panel = new pc.Entity();\n            panel.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                color: new pc.Color(0.4, 0.4, 0.4),\n                height: 40,\n                pivot: [0.5, 0.5],\n                type: pc.ELEMENTTYPE_IMAGE,\n                width: 175,\n                useInput: true\n            });\n            screen.addChild(panel);\n\n            // Create a label for the panel\n            const label = new pc.Entity();\n            label.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                color: new pc.Color(1, 1, 0),\n                fontAsset: assets.font.id,\n                fontSize: 36,\n                height: 64,\n                pivot: [0.5, 0.5],\n                text: \"LABEL\",\n                type: pc.ELEMENTTYPE_TEXT,\n                width: 128,\n                wrapLines: true\n            });\n            panel.addChild(label);\n\n            // Create entity for particle system\n            const particles = new pc.Entity();\n\n            // insert sparks as a child of the panel, but before Label - that is the order for rendering\n            panel.insertChild(particles, 0);\n\n            // particles will render in UI layer\n            const UILayer = app.scene.layers.getLayerByName(\"UI\");\n\n            // particle size\n            const scaleCurve = new pc.Curve(\n                [0, 0.03]\n            );\n\n            // color changes throughout lifetime\n            const colorCurve = new pc.CurveSet([\n                [0, 1, 0.25, 1, 0.375, 0.5, 0.5, 0],\n                [0, 0, 0.125, 0.25, 0.25, 0.5, 0.375, 0.75, 0.5, 1],\n                [0, 0, 1, 0]\n            ]);\n\n            // increasing gravity to get them to move\n            const worldVelocityCurve = new pc.CurveSet([\n                [0, 0],\n                [0, 0, 0.1, 0.1, 0.1, -0.1],\n                [0, 0]\n            ]);\n\n            // rotate sparks 360 degrees per second\n            const angleCurve = new pc.Curve(\n                [0, 360]\n            );\n\n            // when texture is loaded add particlesystem component to entity\n            particles.addComponent(\"particlesystem\", {\n                numParticles: 100,\n                lifetime: 1,\n                rate: 0.01,\n\n                // make them follow the buttn in screen-space\n                localSpace: true,\n                screenSpace: true,\n\n                emitterShape: pc.EMITTERSHAPE_SPHERE,\n                emitterRadius: 100,\n\n                scaleGraph: scaleCurve,\n                rotationSpeedGraph: angleCurve,\n                colorGraph: colorCurve,\n                velocityGraph: worldVelocityCurve,\n\n                colorMap: assets.spark.resource,\n                layers: [UILayer.id]\n            });\n\n            // sort all screen elements\n            screen.screen.syncDrawOrder();\n\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt * 0.3;\n\n                // move buttons along the circular path\n                panel.setLocalPosition(300 * Math.sin(time), 300 * Math.cos(time), 0);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/courier.json\",\n        }),\n        spark: new pc.Asset(\"spark\", \"texture\", {\n            url: \"/static/assets/textures/spark.png\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.ParticleSystemComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n            });\n\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true,\n            });\n\n            app.root.addChild(screen);\n\n            // Create a simple panel\n            const panel = new pc.Entity();\n            panel.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                color: new pc.Color(0.4, 0.4, 0.4),\n                height: 40,\n                pivot: [0.5, 0.5],\n                type: pc.ELEMENTTYPE_IMAGE,\n                width: 175,\n                useInput: true,\n            });\n\n            screen.addChild(panel);\n\n            // Create a label for the panel\n            const label = new pc.Entity();\n            label.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                color: new pc.Color(1, 1, 0),\n                fontAsset: assets.font.id,\n                fontSize: 36,\n                height: 64,\n                pivot: [0.5, 0.5],\n                text: \"LABEL\",\n                type: pc.ELEMENTTYPE_TEXT,\n                width: 128,\n                wrapLines: true,\n            });\n\n            panel.addChild(label);\n\n            // Create entity for particle system\n            const particles = new pc.Entity();\n\n            // insert sparks as a child of the panel, but before Label - that is the order for rendering\n            panel.insertChild(particles, 0);\n\n            // particles will render in UI layer\n            const UILayer = app.scene.layers.getLayerByName(\"UI\");\n\n            // particle size\n            const scaleCurve = new pc.Curve([0, 0.03]);\n\n            // color changes throughout lifetime\n            const colorCurve = new pc.CurveSet([\n                [0, 1, 0.25, 1, 0.375, 0.5, 0.5, 0],\n                [0, 0, 0.125, 0.25, 0.25, 0.5, 0.375, 0.75, 0.5, 1],\n                [0, 0, 1, 0],\n            ]);\n\n            // increasing gravity to get them to move\n            const worldVelocityCurve = new pc.CurveSet([\n                [0, 0],\n                [0, 0, 0.1, 0.1, 0.1, -0.1],\n                [0, 0],\n            ]);\n\n            // rotate sparks 360 degrees per second\n            const angleCurve = new pc.Curve([0, 360]);\n\n            // when texture is loaded add particlesystem component to entity\n            particles.addComponent(\"particlesystem\", {\n                numParticles: 100,\n                lifetime: 1,\n                rate: 0.01,\n\n                // make them follow the buttn in screen-space\n                localSpace: true,\n                screenSpace: true,\n\n                emitterShape: pc.EMITTERSHAPE_SPHERE,\n                emitterRadius: 100,\n\n                scaleGraph: scaleCurve,\n                rotationSpeedGraph: angleCurve,\n                colorGraph: colorCurve,\n                velocityGraph: worldVelocityCurve,\n\n                colorMap: assets.spark.resource,\n                layers: [UILayer.id],\n            });\n\n            // sort all screen elements\n            screen.screen.syncDrawOrder();\n\n            let time = 0;\n            app.on(\"update\", function (dt) {\n                time += dt * 0.3;\n\n                // move buttons along the circular path\n                panel.setLocalPosition(\n                    300 * Math.sin(time),\n                    300 * Math.cos(time),\n                    0\n                );\n            });\n        });\n    });\n}\n","nameSlug":"particle-system","categorySlug":"user-interface"},"scroll-view":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/courier.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.LayoutGroupComponentSystem,\n            // @ts-ignore\n            pc.ScrollViewComponentSystem,\n            // @ts-ignore\n            pc.ScrollbarComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // Create a camera\n            const camera = new pc.Entity();\n            app.root.addChild(camera);\n\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n            });\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            app.root.addChild(screen);\n\n            screen.addComponent(\"screen\", {\n                screenSpace: true,\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleMode: pc.SCALEMODE_BLEND,\n                scaleBlend: 0.5\n            });\n\n            function createScrollbar(horizontal: boolean) {\n                const handle = new pc.Entity('Handle');\n                const handleOptions = {\n                    type: pc.ELEMENTTYPE_IMAGE,\n                    color: new pc.Color(1, 1, 1),\n                    opacity: 1,\n                    margin: new pc.Vec4(0, 0, 0, 0),\n                    rect: new pc.Vec4(0, 0, 1, 1),\n                    mask: false,\n                    useInput: true\n                };\n                if (horizontal) {\n                    // @ts-ignore engine-tsd\n                    handleOptions.anchor = new pc.Vec4(0, 0, 0, 1);  // Split in Y\n                    // @ts-ignore engine-tsd\n                    handleOptions.pivot = new pc.Vec2(0, 0);         // Bottom left\n                } else {\n                    // @ts-ignore engine-tsd\n                    handleOptions.anchor = new pc.Vec4(0, 1, 1, 1);  // Split in X\n                    // @ts-ignore engine-tsd\n                    handleOptions.pivot = new pc.Vec2(1, 1);         // Top right\n                }\n                handle.addComponent('element', handleOptions);\n                handle.addComponent('button', {\n                    active: true,\n                    imageEntity: handle,\n                    hitPadding: new pc.Vec4(0, 0, 0, 0),\n                    transitionMode: pc.BUTTON_TRANSITION_MODE_TINT,\n                    hoverTint: new pc.Color(1, 1, 1),\n                    pressedTint: new pc.Color(1, 1, 1),\n                    inactiveTint: new pc.Color(1, 1, 1),\n                    fadeDuration: 0\n                });\n\n                const scrollbar = new pc.Entity(horizontal ? 'HorizontalScrollbar' : 'VerticalScrollbar');\n\n                scrollbar.addChild(handle);\n\n                const scrollbarOptions = {\n                    type: pc.ELEMENTTYPE_IMAGE,\n                    color: new pc.Color(0.5, 0.5, 0.5),\n                    opacity: 1,\n                    rect: new pc.Vec4(0, 0, 1, 1),\n                    mask: false,\n                    useInput: false\n                };\n\n                const scrollbarSize = 20;\n\n                if (horizontal) {\n                    // @ts-ignore engine-tsd\n                    scrollbarOptions.anchor = new pc.Vec4(0, 0, 1, 0);\n                    // @ts-ignore engine-tsd\n                    scrollbarOptions.pivot = new pc.Vec2(0, 0);\n                    // @ts-ignore engine-tsd\n                    scrollbarOptions.margin = new pc.Vec4(0, 0, scrollbarSize, -scrollbarSize);\n                } else {\n                    // @ts-ignore engine-tsd\n                    scrollbarOptions.anchor = new pc.Vec4(1, 0, 1, 1);\n                    // @ts-ignore engine-tsd\n                    scrollbarOptions.pivot = new pc.Vec2(1, 1);\n                    // @ts-ignore engine-tsd\n                    scrollbarOptions.margin = new pc.Vec4(-scrollbarSize, scrollbarSize, 0, 0);\n                }\n                scrollbar.addComponent('element', scrollbarOptions);\n                scrollbar.addComponent('scrollbar', {\n                    orientation: horizontal ? pc.ORIENTATION_HORIZONTAL : pc.ORIENTATION_VERTICAL,\n                    value: 0,\n                    handleSize: 0.5,\n                    handleEntity: handle\n                });\n\n                return scrollbar;\n            }\n\n            // Create some text content\n            const text = new pc.Entity(\"Text\");\n            text.addComponent(\"element\", {\n                alignment: new pc.Vec2(0, 0),\n                anchor: new pc.Vec4(0, 1, 0, 1),\n                autoHeight: true,\n                autoWidth: false,\n                fontAsset: assets.font.id,\n                fontSize: 32,\n                lineHeight: 36,\n                pivot: new pc.Vec2(0, 1),\n                text: \"This is a scroll view control. You can scroll the content by dragging the vertical \" +\n                        \"or horizontal scroll bars, by dragging the content itself, by using the mouse wheel, or \" +\n                        \"by using a trackpad. Notice the elastic bounce if you drag the content beyond the \" +\n                        \"limits of the scroll view.\",\n                type: pc.ELEMENTTYPE_TEXT,\n                width: 600,\n                wrapLines: true\n            });\n\n            // Group to hold the content inside the scroll view's viewport\n            const content = new pc.Entity('Content');\n            content.addChild(text);\n\n            content.addComponent('element', {\n                anchor: new pc.Vec4(0, 1, 0, 1),\n                height: 400,\n                pivot: new pc.Vec2(0, 1),\n                type: pc.ELEMENTTYPE_GROUP,\n                useInput: true,\n                width: 600\n            });\n\n            // Scroll view viewport\n            const viewport = new pc.Entity('Viewport');\n            viewport.addChild(content);\n\n            viewport.addComponent('element', {\n                anchor: new pc.Vec4(0, 0, 1, 1),\n                color: new pc.Color(0.2, 0.2, 0.2),\n                margin: new pc.Vec4(0, 20, 20, 0),\n                mask: true,\n                opacity: 1,\n                pivot: new pc.Vec2(0, 1),\n                rect: new pc.Vec4(0, 0, 1, 1),\n                type: pc.ELEMENTTYPE_IMAGE,\n                useInput: false\n            });\n\n            const horizontalScrollbar = createScrollbar(true);\n            const verticalScrollbar = createScrollbar(false);\n\n            // Create a scroll view\n            const scrollview = new pc.Entity('ScrollView');\n            scrollview.addChild(viewport);\n            scrollview.addChild(horizontalScrollbar);\n            scrollview.addChild(verticalScrollbar);\n\n            // You must add the scrollview entity to the hierarchy BEFORE adding the scrollview component\n            screen.addChild(scrollview);\n\n            scrollview.addComponent('element', {\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                height: 200,\n                pivot: new pc.Vec2(0.5, 0.5),\n                type: pc.ELEMENTTYPE_GROUP,\n                useInput: false,\n                width: 400\n            });\n\n            scrollview.addComponent('scrollview', {\n                bounceAmount: 0.1,\n                contentEntity: content,\n                friction: 0.05,\n                useMouseWheel: true,\n                mouseWheelSensitivity: pc.Vec2.ONE,\n                horizontal: true,\n                horizontalScrollbarEntity: horizontalScrollbar,\n                horizontalScrollbarVisibility: pc.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED,\n                scrollMode: pc.SCROLL_MODE_BOUNCE,\n                vertical: true,\n                verticalScrollbarEntity: verticalScrollbar,\n                verticalScrollbarVisibility: pc.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED,\n                viewportEntity: viewport\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/courier.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.LayoutGroupComponentSystem,\n            // @ts-ignore\n            pc.ScrollViewComponentSystem,\n            // @ts-ignore\n            pc.ScrollbarComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // Create a camera\n            const camera = new pc.Entity();\n            app.root.addChild(camera);\n\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n            });\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            app.root.addChild(screen);\n\n            screen.addComponent(\"screen\", {\n                screenSpace: true,\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleMode: pc.SCALEMODE_BLEND,\n                scaleBlend: 0.5,\n            });\n\n            function createScrollbar(horizontal) {\n                const handle = new pc.Entity(\"Handle\");\n                const handleOptions = {\n                    type: pc.ELEMENTTYPE_IMAGE,\n                    color: new pc.Color(1, 1, 1),\n                    opacity: 1,\n                    margin: new pc.Vec4(0, 0, 0, 0),\n                    rect: new pc.Vec4(0, 0, 1, 1),\n                    mask: false,\n                    useInput: true,\n                };\n\n                if (horizontal) {\n                    // @ts-ignore engine-tsd\n                    handleOptions.anchor = new pc.Vec4(0, 0, 0, 1); // Split in Y\n                    // @ts-ignore engine-tsd\n                    handleOptions.pivot = new pc.Vec2(0, 0); // Bottom left\n                } else {\n                    // @ts-ignore engine-tsd\n                    handleOptions.anchor = new pc.Vec4(0, 1, 1, 1); // Split in X\n                    // @ts-ignore engine-tsd\n                    handleOptions.pivot = new pc.Vec2(1, 1); // Top right\n                }\n                handle.addComponent(\"element\", handleOptions);\n                handle.addComponent(\"button\", {\n                    active: true,\n                    imageEntity: handle,\n                    hitPadding: new pc.Vec4(0, 0, 0, 0),\n                    transitionMode: pc.BUTTON_TRANSITION_MODE_TINT,\n                    hoverTint: new pc.Color(1, 1, 1),\n                    pressedTint: new pc.Color(1, 1, 1),\n                    inactiveTint: new pc.Color(1, 1, 1),\n                    fadeDuration: 0,\n                });\n\n                const scrollbar = new pc.Entity(\n                    horizontal ? \"HorizontalScrollbar\" : \"VerticalScrollbar\"\n                );\n\n                scrollbar.addChild(handle);\n\n                const scrollbarOptions = {\n                    type: pc.ELEMENTTYPE_IMAGE,\n                    color: new pc.Color(0.5, 0.5, 0.5),\n                    opacity: 1,\n                    rect: new pc.Vec4(0, 0, 1, 1),\n                    mask: false,\n                    useInput: false,\n                };\n\n                const scrollbarSize = 20;\n\n                if (horizontal) {\n                    // @ts-ignore engine-tsd\n                    scrollbarOptions.anchor = new pc.Vec4(0, 0, 1, 0);\n                    // @ts-ignore engine-tsd\n                    scrollbarOptions.pivot = new pc.Vec2(0, 0);\n                    // @ts-ignore engine-tsd\n                    scrollbarOptions.margin = new pc.Vec4(\n                        0,\n                        0,\n                        scrollbarSize,\n                        -scrollbarSize\n                    );\n                } else {\n                    // @ts-ignore engine-tsd\n                    scrollbarOptions.anchor = new pc.Vec4(1, 0, 1, 1);\n                    // @ts-ignore engine-tsd\n                    scrollbarOptions.pivot = new pc.Vec2(1, 1);\n                    // @ts-ignore engine-tsd\n                    scrollbarOptions.margin = new pc.Vec4(\n                        -scrollbarSize,\n                        scrollbarSize,\n                        0,\n                        0\n                    );\n                }\n                scrollbar.addComponent(\"element\", scrollbarOptions);\n                scrollbar.addComponent(\"scrollbar\", {\n                    orientation: horizontal\n                        ? pc.ORIENTATION_HORIZONTAL\n                        : pc.ORIENTATION_VERTICAL,\n                    value: 0,\n                    handleSize: 0.5,\n                    handleEntity: handle,\n                });\n\n                return scrollbar;\n            }\n\n            // Create some text content\n            const text = new pc.Entity(\"Text\");\n            text.addComponent(\"element\", {\n                alignment: new pc.Vec2(0, 0),\n                anchor: new pc.Vec4(0, 1, 0, 1),\n                autoHeight: true,\n                autoWidth: false,\n                fontAsset: assets.font.id,\n                fontSize: 32,\n                lineHeight: 36,\n                pivot: new pc.Vec2(0, 1),\n                text:\n                    \"This is a scroll view control. You can scroll the content by dragging the vertical \" +\n                    \"or horizontal scroll bars, by dragging the content itself, by using the mouse wheel, or \" +\n                    \"by using a trackpad. Notice the elastic bounce if you drag the content beyond the \" +\n                    \"limits of the scroll view.\",\n                type: pc.ELEMENTTYPE_TEXT,\n                width: 600,\n                wrapLines: true,\n            });\n\n            // Group to hold the content inside the scroll view's viewport\n            const content = new pc.Entity(\"Content\");\n            content.addChild(text);\n\n            content.addComponent(\"element\", {\n                anchor: new pc.Vec4(0, 1, 0, 1),\n                height: 400,\n                pivot: new pc.Vec2(0, 1),\n                type: pc.ELEMENTTYPE_GROUP,\n                useInput: true,\n                width: 600,\n            });\n\n            // Scroll view viewport\n            const viewport = new pc.Entity(\"Viewport\");\n            viewport.addChild(content);\n\n            viewport.addComponent(\"element\", {\n                anchor: new pc.Vec4(0, 0, 1, 1),\n                color: new pc.Color(0.2, 0.2, 0.2),\n                margin: new pc.Vec4(0, 20, 20, 0),\n                mask: true,\n                opacity: 1,\n                pivot: new pc.Vec2(0, 1),\n                rect: new pc.Vec4(0, 0, 1, 1),\n                type: pc.ELEMENTTYPE_IMAGE,\n                useInput: false,\n            });\n\n            const horizontalScrollbar = createScrollbar(true);\n            const verticalScrollbar = createScrollbar(false);\n\n            // Create a scroll view\n            const scrollview = new pc.Entity(\"ScrollView\");\n            scrollview.addChild(viewport);\n            scrollview.addChild(horizontalScrollbar);\n            scrollview.addChild(verticalScrollbar);\n\n            // You must add the scrollview entity to the hierarchy BEFORE adding the scrollview component\n            screen.addChild(scrollview);\n\n            scrollview.addComponent(\"element\", {\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                height: 200,\n                pivot: new pc.Vec2(0.5, 0.5),\n                type: pc.ELEMENTTYPE_GROUP,\n                useInput: false,\n                width: 400,\n            });\n\n            scrollview.addComponent(\"scrollview\", {\n                bounceAmount: 0.1,\n                contentEntity: content,\n                friction: 0.05,\n                useMouseWheel: true,\n                mouseWheelSensitivity: pc.Vec2.ONE,\n                horizontal: true,\n                horizontalScrollbarEntity: horizontalScrollbar,\n                horizontalScrollbarVisibility:\n                    pc.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED,\n                scrollMode: pc.SCROLL_MODE_BOUNCE,\n                vertical: true,\n                verticalScrollbarEntity: verticalScrollbar,\n                verticalScrollbarVisibility:\n                    pc.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED,\n                viewportEntity: viewport,\n            });\n        });\n    });\n}\n","nameSlug":"scroll-view","categorySlug":"user-interface"},"text-auto-font-size":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/courier.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.LayoutGroupComponentSystem,\n            // @ts-ignore\n            pc.ScrollViewComponentSystem,\n            // @ts-ignore\n            pc.ScrollbarComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n            });\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true\n            });\n            app.root.addChild(screen);\n\n            // Create a container entity with an image component\n            const autoFontSizeContainer = new pc.Entity();\n            autoFontSizeContainer.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                width: 220,\n                height: 50,\n                color: new pc.Color(60 / 255, 60 / 255, 60 / 255),\n                type: pc.ELEMENTTYPE_IMAGE\n            });\n            // Create a text element with auto font size, and place it inside the container\n            const autoFontSizeText = new pc.Entity();\n            autoFontSizeText.addComponent(\"element\", {\n                // place the text taking the entire parent space\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0, 0, 1, 1),\n                margin: new pc.Vec4(0, 0, 0, 0),\n                fontAsset: assets.font.id,\n                autoWidth: false,\n                autoHeight: false,\n                autoFitWidth: true,\n                autoFitHeight: true,\n                minFontSize: 10,\n                maxFontSize: 100,\n                text: \"Auto font size!\",\n                type: pc.ELEMENTTYPE_TEXT\n            });\n            screen.addChild(autoFontSizeContainer);\n            autoFontSizeContainer.addChild(autoFontSizeText);\n\n            // update the container's size to showcase the auto-sizing feature\n            let time = 0;\n            app.on('update', (dt) => {\n                time += dt;\n                autoFontSizeContainer.element.width = 280 + (Math.sin(time) * 80);\n                autoFontSizeContainer.element.height = 60 + (Math.sin(time * 0.5) * 50);\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/courier.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.LayoutGroupComponentSystem,\n            // @ts-ignore\n            pc.ScrollViewComponentSystem,\n            // @ts-ignore\n            pc.ScrollbarComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n            });\n\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true,\n            });\n\n            app.root.addChild(screen);\n\n            // Create a container entity with an image component\n            const autoFontSizeContainer = new pc.Entity();\n            autoFontSizeContainer.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                width: 220,\n                height: 50,\n                color: new pc.Color(60 / 255, 60 / 255, 60 / 255),\n                type: pc.ELEMENTTYPE_IMAGE,\n            });\n\n            // Create a text element with auto font size, and place it inside the container\n            const autoFontSizeText = new pc.Entity();\n            autoFontSizeText.addComponent(\"element\", {\n                // place the text taking the entire parent space\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0, 0, 1, 1),\n                margin: new pc.Vec4(0, 0, 0, 0),\n                fontAsset: assets.font.id,\n                autoWidth: false,\n                autoHeight: false,\n                autoFitWidth: true,\n                autoFitHeight: true,\n                minFontSize: 10,\n                maxFontSize: 100,\n                text: \"Auto font size!\",\n                type: pc.ELEMENTTYPE_TEXT,\n            });\n\n            screen.addChild(autoFontSizeContainer);\n            autoFontSizeContainer.addChild(autoFontSizeText);\n\n            // update the container's size to showcase the auto-sizing feature\n            let time = 0;\n            app.on(\"update\", (dt) => {\n                time += dt;\n                autoFontSizeContainer.element.width = 280 + Math.sin(time) * 80;\n                autoFontSizeContainer.element.height =\n                    60 + Math.sin(time * 0.5) * 50;\n            });\n        });\n    });\n}\n","nameSlug":"text-auto-font-size","categorySlug":"user-interface"},"text-emojis":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/arial.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.LayoutGroupComponentSystem,\n            // @ts-ignore\n            pc.ScrollViewComponentSystem,\n            // @ts-ignore\n            pc.ScrollbarComponentSystem,\n            // @ts-ignore\n            pc.LayoutChildComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n            });\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true\n            });\n            app.root.addChild(screen);\n\n            // some sample text\n            const firstLineText = \"PlayCanvas supports Emojis via CanvasFont!\";\n            const flagsText = \"Flags: 🇺🇸🇩🇪🇮🇪🇮🇹🏴‍☠️🇨🇦\";\n            const complexText = \"Complex emoji: 👨🏿3️⃣👁️‍🗨️\";\n\n            // Create a canvas font asset\n            const size = 64;\n            const elSize = 32;\n\n            const canvasFont = new pc.CanvasFont(app, {\n                color: new pc.Color(1, 1, 1), // white\n                fontName: \"Arial\",\n                fontSize: size,\n                width: 256,\n                height: 256\n            });\n\n            // The first texture update needs to be `createTextures()`. Follow-up calls need to be `updateTextures()`.\n            canvasFont.createTextures(firstLineText);\n            canvasFont.updateTextures(flagsText);\n            canvasFont.updateTextures(complexText);\n\n            // Create the text entities\n            function createText(y: number, text: string) {\n                const canvasElementEntity = new pc.Entity();\n                canvasElementEntity.setLocalPosition(0, y, 0);\n                canvasElementEntity.addComponent(\"element\", {\n                    pivot: new pc.Vec2(0.5, 0.5),\n                    anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                    fontSize: elSize,\n                    text: text,\n                    type: pc.ELEMENTTYPE_TEXT\n                });\n                canvasElementEntity.element.font = canvasFont;\n                screen.addChild(canvasElementEntity);\n            }\n            createText(225, firstLineText);\n            createText(150, flagsText);\n            createText(100, complexText);\n\n\n            // Canvas Fonts Debug - you shouldn't do this in your actual project\n            const debugText = new pc.Entity();\n            debugText.setLocalPosition(0, -50, 0);\n            debugText.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                fontAsset: assets.font.id,\n                fontSize: elSize,\n                text: \"The following are the CanvasFont's Texture Atlases,\\ncontaining all the rendered characters:\",\n                type: pc.ELEMENTTYPE_TEXT\n            });\n            screen.addChild(debugText);\n\n            // Create Layout Group Entity\n            const group = new pc.Entity();\n            group.setLocalPosition(0, -150, 0);\n            group.addComponent(\"element\", {\n                // a Layout Group needs a 'group' element component\n                type: pc.ELEMENTTYPE_GROUP,\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                pivot: [0.5, 0.5],\n                // the element's width and height dictate the group's bounds\n                width: 300,\n                height: 100\n            });\n            group.addComponent(\"layoutgroup\", {\n                orientation: pc.ORIENTATION_HORIZONTAL,\n                // fit_both for width and height, making all child elements take the entire space\n                widthFitting: pc.FITTING_BOTH,\n                heightFitting: pc.FITTING_BOTH,\n                // wrap children\n                wrap: true\n            });\n            screen.addChild(group);\n\n            // create 1 child per texture\n            for (let i = 0; i < canvasFont.textures.length; i++) {\n                const texture = canvasFont.textures[i];\n\n                // create a random-colored panel\n                const child = new pc.Entity();\n                child.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    pivot: [0.5, 0.5],\n                    texture: texture,\n                    type: pc.ELEMENTTYPE_IMAGE\n                });\n                child.addComponent(\"layoutchild\", {\n                    excludeFromLayout: false\n                });\n                group.addChild(child);\n            }\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/arial.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.LayoutGroupComponentSystem,\n            // @ts-ignore\n            pc.ScrollViewComponentSystem,\n            // @ts-ignore\n            pc.ScrollbarComponentSystem,\n            // @ts-ignore\n            pc.LayoutChildComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n            });\n\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true,\n            });\n\n            app.root.addChild(screen);\n\n            // some sample text\n            const firstLineText = \"PlayCanvas supports Emojis via CanvasFont!\";\n            const flagsText = \"Flags: 🇺🇸🇩🇪🇮🇪🇮🇹🏴‍☠️🇨🇦\";\n            const complexText = \"Complex emoji: 👨🏿3️⃣👁️‍🗨️\";\n\n            // Create a canvas font asset\n            const size = 64;\n            const elSize = 32;\n\n            const canvasFont = new pc.CanvasFont(app, {\n                color: new pc.Color(1, 1, 1), // white\n                fontName: \"Arial\",\n                fontSize: size,\n                width: 256,\n                height: 256,\n            });\n\n            // The first texture update needs to be `createTextures()`. Follow-up calls need to be `updateTextures()`.\n            canvasFont.createTextures(firstLineText);\n            canvasFont.updateTextures(flagsText);\n            canvasFont.updateTextures(complexText);\n\n            // Create the text entities\n            function createText(y, text) {\n                const canvasElementEntity = new pc.Entity();\n                canvasElementEntity.setLocalPosition(0, y, 0);\n                canvasElementEntity.addComponent(\"element\", {\n                    pivot: new pc.Vec2(0.5, 0.5),\n                    anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                    fontSize: elSize,\n                    text: text,\n                    type: pc.ELEMENTTYPE_TEXT,\n                });\n\n                canvasElementEntity.element.font = canvasFont;\n                screen.addChild(canvasElementEntity);\n            }\n            createText(225, firstLineText);\n            createText(150, flagsText);\n            createText(100, complexText);\n\n            // Canvas Fonts Debug - you shouldn't do this in your actual project\n            const debugText = new pc.Entity();\n            debugText.setLocalPosition(0, -50, 0);\n            debugText.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                fontAsset: assets.font.id,\n                fontSize: elSize,\n                text: \"The following are the CanvasFont's Texture Atlases,\\ncontaining all the rendered characters:\",\n                type: pc.ELEMENTTYPE_TEXT,\n            });\n\n            screen.addChild(debugText);\n\n            // Create Layout Group Entity\n            const group = new pc.Entity();\n            group.setLocalPosition(0, -150, 0);\n            group.addComponent(\"element\", {\n                // a Layout Group needs a 'group' element component\n                type: pc.ELEMENTTYPE_GROUP,\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                pivot: [0.5, 0.5],\n                // the element's width and height dictate the group's bounds\n                width: 300,\n                height: 100,\n            });\n\n            group.addComponent(\"layoutgroup\", {\n                orientation: pc.ORIENTATION_HORIZONTAL,\n                // fit_both for width and height, making all child elements take the entire space\n                widthFitting: pc.FITTING_BOTH,\n                heightFitting: pc.FITTING_BOTH,\n                // wrap children\n                wrap: true,\n            });\n\n            screen.addChild(group);\n\n            // create 1 child per texture\n            for (let i = 0; i < canvasFont.textures.length; i++) {\n                const texture = canvasFont.textures[i];\n\n                // create a random-colored panel\n                const child = new pc.Entity();\n                child.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    pivot: [0.5, 0.5],\n                    texture: texture,\n                    type: pc.ELEMENTTYPE_IMAGE,\n                });\n\n                child.addComponent(\"layoutchild\", {\n                    excludeFromLayout: false,\n                });\n\n                group.addChild(child);\n            }\n        });\n    });\n}\n","nameSlug":"text-emojis","categorySlug":"user-interface"},"text-localization":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/courier.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            app.i18n.addData({\n                header: {\n                    version: 1\n                },\n                data: [{\n                    info: {\n                        locale: 'en-US'\n                    },\n                    messages: {\n                        \"HELLO\": \"Hi\"\n                    }\n                }, {\n                    info: {\n                        locale: 'fr-FR'\n                    },\n                    messages: {\n                        \"HELLO\": \"Salut\"\n                    }\n                }, {\n                    info: {\n                        locale: 'es-ES'\n                    },\n                    messages: {\n                        \"HELLO\": \"Hola\"\n                    }\n                }, {\n                    info: {\n                        locale: 'pt-BR'\n                    },\n                    messages: {\n                        \"HELLO\": \"Oi!\"\n                    }\n                }]\n            });\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n            });\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true\n            });\n            app.root.addChild(screen);\n\n            // Create a basic text element\n            const text = new pc.Entity();\n            text.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                autoWidth: false,\n                fontAsset: assets.font.id,\n                fontSize: 128,\n                pivot: [0.5, 0.5],\n                key: \"HELLO\",\n                type: pc.ELEMENTTYPE_TEXT,\n                width: 640\n            });\n            screen.addChild(text);\n\n            function createButton(labelText: string, x: number, y: number) {\n                // Create a simple button\n                const button = new pc.Entity();\n                button.addComponent(\"button\", {\n                    imageEntity: button\n                });\n                button.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    height: 40,\n                    pivot: [0.5, 0.5],\n                    type: pc.ELEMENTTYPE_IMAGE,\n                    width: 128,\n                    useInput: true\n                });\n\n                // Create a label for the button\n                const label = new pc.Entity();\n                label.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    color: new pc.Color(0, 0, 0),\n                    fontAsset: assets.font.id,\n                    fontSize: 32,\n                    height: 64,\n                    pivot: [0.5, 0.5],\n                    text: labelText,\n                    type: pc.ELEMENTTYPE_TEXT,\n                    width: 128,\n                    wrapLines: true\n                });\n                button.addChild(label);\n\n                // Change the locale to the button text\n                button.button.on('click', function () {\n                    app.i18n.locale = labelText;\n                });\n\n                button.setLocalPosition(x, y, 0);\n\n                return button;\n            }\n\n            screen.addChild(createButton(\"en-US\", -225, -100));\n            screen.addChild(createButton(\"fr-FR\", -75, -100));\n            screen.addChild(createButton(\"es-ES\", 75, -100));\n            screen.addChild(createButton(\"pt-BR\", 225, -100));\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/courier.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            app.i18n.addData({\n                header: {\n                    version: 1,\n                },\n\n                data: [\n                    {\n                        info: {\n                            locale: \"en-US\",\n                        },\n\n                        messages: {\n                            HELLO: \"Hi\",\n                        },\n                    },\n\n                    {\n                        info: {\n                            locale: \"fr-FR\",\n                        },\n\n                        messages: {\n                            HELLO: \"Salut\",\n                        },\n                    },\n\n                    {\n                        info: {\n                            locale: \"es-ES\",\n                        },\n\n                        messages: {\n                            HELLO: \"Hola\",\n                        },\n                    },\n\n                    {\n                        info: {\n                            locale: \"pt-BR\",\n                        },\n\n                        messages: {\n                            HELLO: \"Oi!\",\n                        },\n                    },\n                ],\n            });\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n            });\n\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true,\n            });\n\n            app.root.addChild(screen);\n\n            // Create a basic text element\n            const text = new pc.Entity();\n            text.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                autoWidth: false,\n                fontAsset: assets.font.id,\n                fontSize: 128,\n                pivot: [0.5, 0.5],\n                key: \"HELLO\",\n                type: pc.ELEMENTTYPE_TEXT,\n                width: 640,\n            });\n\n            screen.addChild(text);\n\n            function createButton(labelText, x, y) {\n                // Create a simple button\n                const button = new pc.Entity();\n                button.addComponent(\"button\", {\n                    imageEntity: button,\n                });\n\n                button.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    height: 40,\n                    pivot: [0.5, 0.5],\n                    type: pc.ELEMENTTYPE_IMAGE,\n                    width: 128,\n                    useInput: true,\n                });\n\n                // Create a label for the button\n                const label = new pc.Entity();\n                label.addComponent(\"element\", {\n                    anchor: [0.5, 0.5, 0.5, 0.5],\n                    color: new pc.Color(0, 0, 0),\n                    fontAsset: assets.font.id,\n                    fontSize: 32,\n                    height: 64,\n                    pivot: [0.5, 0.5],\n                    text: labelText,\n                    type: pc.ELEMENTTYPE_TEXT,\n                    width: 128,\n                    wrapLines: true,\n                });\n\n                button.addChild(label);\n\n                // Change the locale to the button text\n                button.button.on(\"click\", function () {\n                    app.i18n.locale = labelText;\n                });\n\n                button.setLocalPosition(x, y, 0);\n\n                return button;\n            }\n\n            screen.addChild(createButton(\"en-US\", -225, -100));\n            screen.addChild(createButton(\"fr-FR\", -75, -100));\n            screen.addChild(createButton(\"es-ES\", 75, -100));\n            screen.addChild(createButton(\"pt-BR\", 225, -100));\n        });\n    });\n}\n","nameSlug":"text-localization","categorySlug":"user-interface"},"text-typewriter":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/courier.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n            });\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true\n            });\n            app.root.addChild(screen);\n\n            // Create a text element that wraps text over several lines\n            const loremIpsum = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\";\n            const text = new pc.Entity();\n            text.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                autoWidth: false,\n                fontAsset: assets.font.id,\n                fontSize: 32,\n                pivot: [0.5, 0.5],\n                text: loremIpsum,\n                type: pc.ELEMENTTYPE_TEXT,\n                width: 512,\n                wrapLines: true\n            });\n            screen.addChild(text);\n\n            // Start with no text printed\n            text.element.rangeStart = 0;\n            text.element.rangeEnd = 0;\n\n            // Render a new character every 75ms\n            setInterval(function () {\n                text.element.rangeEnd += 1;\n                if (text.element.rangeEnd >= loremIpsum.length) {\n                    text.element.rangeEnd = 0;\n                }\n            }, 75);\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/courier.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n            });\n\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true,\n            });\n\n            app.root.addChild(screen);\n\n            // Create a text element that wraps text over several lines\n            const loremIpsum =\n                \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\";\n            const text = new pc.Entity();\n            text.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                autoWidth: false,\n                fontAsset: assets.font.id,\n                fontSize: 32,\n                pivot: [0.5, 0.5],\n                text: loremIpsum,\n                type: pc.ELEMENTTYPE_TEXT,\n                width: 512,\n                wrapLines: true,\n            });\n\n            screen.addChild(text);\n\n            // Start with no text printed\n            text.element.rangeStart = 0;\n            text.element.rangeEnd = 0;\n\n            // Render a new character every 75ms\n            setInterval(function () {\n                text.element.rangeEnd += 1;\n                if (text.element.rangeEnd >= loremIpsum.length) {\n                    text.element.rangeEnd = 0;\n                }\n            }, 75);\n        });\n    });\n}\n","nameSlug":"text-typewriter","categorySlug":"user-interface"},"text":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/courier.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.LayoutGroupComponentSystem,\n            // @ts-ignore\n            pc.ScrollViewComponentSystem,\n            // @ts-ignore\n            pc.ScrollbarComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n            });\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true\n            });\n            app.root.addChild(screen);\n\n            // Basic Text\n            const textBasic = new pc.Entity();\n            textBasic.setLocalPosition(0, 200, 0);\n            textBasic.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                fontAsset: assets.font.id,\n                fontSize: 42,\n                text: \"Basic Text\",\n                type: pc.ELEMENTTYPE_TEXT\n            });\n            screen.addChild(textBasic);\n\n            // Markup Text with wrap\n            const textMarkup = new pc.Entity();\n            textMarkup.setLocalPosition(0, 50, 0);\n            textMarkup.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                fontAsset: assets.font.id,\n                fontSize: 32,\n                text: 'There are seven colors in the rainbow: [color=\"#ff0000\"]red[/color], [color=\"#ffa500\"]orange[/color], [color=\"#ffff00\"]yellow[/color], [color=\"#00ff00\"]green[/color], [color=\"#0000ff\"]blue[/color], [color=\"#4b0082\"]indigo[/color] and [color=\"#7f00ff\"]violet[/color].',\n                width: 500,\n                height: 100,\n                autoWidth: false,\n                autoHeight: false,\n                wrapLines: true,\n                enableMarkup: true,\n                type: pc.ELEMENTTYPE_TEXT\n            });\n            screen.addChild(textMarkup);\n\n            // Text with outline\n            const textOutline = new pc.Entity();\n            textOutline.setLocalPosition(0, -100, 0);\n            textOutline.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                fontAsset: assets.font.id,\n                fontSize: 62,\n                text: \"Outline\",\n                color: new pc.Color(0, 0, 0),\n                outlineColor: new pc.Color(1, 1, 1),\n                outlineThickness: 0.75,\n                type: pc.ELEMENTTYPE_TEXT\n            });\n            screen.addChild(textOutline);\n\n            // Text with drop shadow\n            const textDropShadow = new pc.Entity();\n            textDropShadow.setLocalPosition(0, -200, 0);\n            textDropShadow.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                fontAsset: assets.font.id,\n                fontSize: 62,\n                text: \"Drop Shadow\",\n                shadowColor: new pc.Color(1, 0, 0),\n                shadowOffset: new pc.Vec2(0.25, -0.25),\n                type: pc.ELEMENTTYPE_TEXT\n            });\n            screen.addChild(textDropShadow);\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/courier.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.LayoutGroupComponentSystem,\n            // @ts-ignore\n            pc.ScrollViewComponentSystem,\n            // @ts-ignore\n            pc.ScrollbarComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            window.addEventListener(\"resize\", function () {\n                app.resizeCanvas(canvas.width, canvas.height);\n            });\n\n            // Create a camera\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n            });\n\n            app.root.addChild(camera);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                scaleBlend: 0.5,\n                scaleMode: pc.SCALEMODE_BLEND,\n                screenSpace: true,\n            });\n\n            app.root.addChild(screen);\n\n            // Basic Text\n            const textBasic = new pc.Entity();\n            textBasic.setLocalPosition(0, 200, 0);\n            textBasic.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                fontAsset: assets.font.id,\n                fontSize: 42,\n                text: \"Basic Text\",\n                type: pc.ELEMENTTYPE_TEXT,\n            });\n\n            screen.addChild(textBasic);\n\n            // Markup Text with wrap\n            const textMarkup = new pc.Entity();\n            textMarkup.setLocalPosition(0, 50, 0);\n            textMarkup.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                fontAsset: assets.font.id,\n                fontSize: 32,\n                text: 'There are seven colors in the rainbow: [color=\"#ff0000\"]red[/color], [color=\"#ffa500\"]orange[/color], [color=\"#ffff00\"]yellow[/color], [color=\"#00ff00\"]green[/color], [color=\"#0000ff\"]blue[/color], [color=\"#4b0082\"]indigo[/color] and [color=\"#7f00ff\"]violet[/color].',\n                width: 500,\n                height: 100,\n                autoWidth: false,\n                autoHeight: false,\n                wrapLines: true,\n                enableMarkup: true,\n                type: pc.ELEMENTTYPE_TEXT,\n            });\n\n            screen.addChild(textMarkup);\n\n            // Text with outline\n            const textOutline = new pc.Entity();\n            textOutline.setLocalPosition(0, -100, 0);\n            textOutline.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                fontAsset: assets.font.id,\n                fontSize: 62,\n                text: \"Outline\",\n                color: new pc.Color(0, 0, 0),\n                outlineColor: new pc.Color(1, 1, 1),\n                outlineThickness: 0.75,\n                type: pc.ELEMENTTYPE_TEXT,\n            });\n\n            screen.addChild(textOutline);\n\n            // Text with drop shadow\n            const textDropShadow = new pc.Entity();\n            textDropShadow.setLocalPosition(0, -200, 0);\n            textDropShadow.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                fontAsset: assets.font.id,\n                fontSize: 62,\n                text: \"Drop Shadow\",\n                shadowColor: new pc.Color(1, 0, 0),\n                shadowOffset: new pc.Vec2(0.25, -0.25),\n                type: pc.ELEMENTTYPE_TEXT,\n            });\n\n            screen.addChild(textDropShadow);\n        });\n    });\n}\n","nameSlug":"text","categorySlug":"user-interface"},"world-to-screen":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        \"checkboard\": new pc.Asset(\"checkboard\", \"texture\", { url: \"/static/assets/textures/checkboard.png\" }),\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/courier.json' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n            });\n            camera.rotateLocal(-30, 0, 0);\n            camera.translateLocal(0, 0, 7);\n            app.root.addChild(camera);\n\n            // Create an Entity for the ground\n            const material = new pc.StandardMaterial();\n            material.diffuse = pc.Color.WHITE;\n            material.diffuseMap = assets.checkboard.resource;\n            material.diffuseMapTiling = new pc.Vec2(50, 50);\n            material.update();\n\n            const ground = new pc.Entity();\n            ground.addComponent(\"render\", {\n                type: \"box\",\n                material: material\n            });\n            ground.setLocalScale(50, 1, 50);\n            ground.setLocalPosition(0, -0.5, 0);\n            app.root.addChild(ground);\n\n            // Create an entity with a light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n                color: new pc.Color(1, 1, 1),\n                castShadows: true,\n                intensity: 1,\n                shadowBias: 0.2,\n                shadowDistance: 16,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048\n            });\n            light.setLocalEulerAngles(45, 30, 0);\n            app.root.addChild(light);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.setLocalScale(0.01, 0.01, 0.01);\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                screenSpace: true\n            });\n            app.root.addChild(screen);\n\n            /**\n             * Converts a coordinate in world space into a screen's space.\n             *\n             * @param {pc.Vec3} worldPosition - the Vec3 representing the world-space coordinate.\n             * @param {pc.CameraComponent} camera - the Camera.\n             * @param {pc.ScreenComponent} screen - the Screen\n             * @returns {pc.Vec3} a Vec3 of the input worldPosition relative to the camera and screen. The Z coordinate represents the depth,\n             * and negative numbers signal that the worldPosition is behind the camera.\n             */\n            function worldToScreenSpace(worldPosition: pc.Vec3, camera: pc.CameraComponent, screen: pc.ScreenComponent): pc.Vec3 {\n                const screenPos = camera.worldToScreen(worldPosition);\n\n                // take pixel ratio into account\n                const pixelRatio = app.graphicsDevice.maxPixelRatio;\n                screenPos.x *= pixelRatio;\n                screenPos.y *= pixelRatio;\n\n                // account for screen scaling\n                const scale = screen.scale;\n\n                // invert the y position\n                screenPos.y = screen.resolution.y - screenPos.y;\n\n                // put that into a Vec3\n                return new pc.Vec3(screenPos.x / scale, screenPos.y / scale, screenPos.z / scale);\n            }\n\n            function createPlayer(id: number, startingAngle: number, speed: number, radius: number) {\n                // Create a capsule entity to represent a player in the 3d world\n                const entity = new pc.Entity();\n                entity.setLocalScale(new pc.Vec3(0.5, 0.5, 0.5));\n                entity.addComponent(\"render\", {\n                    type: \"capsule\"\n                });\n                app.root.addChild(entity);\n\n                // update the player position every frame with some mock logic\n                // normally, this would be taking inputs, running physics simulation, etc\n                let angle = startingAngle;\n                const height = 0.5;\n                app.on(\"update\", function (dt) {\n                    angle += dt * speed;\n                    if (angle > 360) {\n                        angle -= 360;\n                    }\n                    entity.setLocalPosition(radius * Math.sin(angle * pc.math.DEG_TO_RAD), height, radius * Math.cos(angle * pc.math.DEG_TO_RAD));\n                    entity.setLocalEulerAngles(0, angle + 90, 0);\n                });\n\n                // Create a text element that will hover the player's head\n                const playerInfo = new pc.Entity();\n                playerInfo.addComponent(\"element\", {\n                    pivot: new pc.Vec2(0.5, 0),\n                    anchor: new pc.Vec4(0, 0, 0, 0),\n                    width: 150,\n                    height: 50,\n                    opacity: 0.05,\n                    type: pc.ELEMENTTYPE_IMAGE\n                });\n                screen.addChild(playerInfo);\n\n                const name = new pc.Entity();\n                name.addComponent(\"element\", {\n                    pivot: new pc.Vec2(0.5, 0.5),\n                    anchor: new pc.Vec4(0, 0.4, 1, 1),\n                    margin: new pc.Vec4(0, 0, 0, 0),\n                    fontAsset: assets.font.id,\n                    fontSize: 20,\n                    text: `Player ${id}`,\n                    useInput: true,\n                    type: pc.ELEMENTTYPE_TEXT\n                });\n                name.addComponent(\"button\", {\n                    imageEntity: name\n                });\n                name.button.on('click', function () {\n                    const color = new pc.Color(Math.random(), Math.random(), Math.random());\n                    name.element.color = color;\n                    entity.render.material.setParameter(\"material_diffuse\", [color.r, color.g, color.b]);\n                });\n                playerInfo.addChild(name);\n\n                const healthBar = new pc.Entity();\n                healthBar.addComponent(\"element\", {\n                    pivot: new pc.Vec2(0.5, 0),\n                    anchor: new pc.Vec4(0, 0, 1, 0.4),\n                    margin: new pc.Vec4(0, 0, 0, 0),\n                    color: new pc.Color(0.2, 0.6, 0.2, 1),\n                    opacity: 1,\n                    type: pc.ELEMENTTYPE_IMAGE\n                });\n                playerInfo.addChild(healthBar);\n\n                // update the player text's position to always hover the player\n                app.on(\"update\", function () {\n                    // get the desired world position\n                    const worldPosition = entity.getPosition();\n                    worldPosition.y += 0.6; // slightly above the player's head\n\n                    // convert to screen position\n                    const screenPosition = worldToScreenSpace(worldPosition, camera.camera, screen.screen);\n\n                    if (screenPosition.z > 0) {\n                        // if world position is in front of the camera, show it\n                        playerInfo.enabled = true;\n\n                        // set the UI position\n                        playerInfo.setLocalPosition(screenPosition);\n                    } else {\n                        // if world position is actually *behind* the camera, hide the UI\n                        playerInfo.enabled = false;\n                    }\n                });\n            }\n\n            createPlayer(1, 135, 30, 1.5);\n            createPlayer(2, 65, -18, 1);\n            createPlayer(3, 0, 15, 2.5);\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        checkboard: new pc.Asset(\"checkboard\", \"texture\", {\n            url: \"/static/assets/textures/checkboard.png\",\n        }),\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/courier.json\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // Create an Entity with a camera component\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n            });\n\n            camera.rotateLocal(-30, 0, 0);\n            camera.translateLocal(0, 0, 7);\n            app.root.addChild(camera);\n\n            // Create an Entity for the ground\n            const material = new pc.StandardMaterial();\n            material.diffuse = pc.Color.WHITE;\n            material.diffuseMap = assets.checkboard.resource;\n            material.diffuseMapTiling = new pc.Vec2(50, 50);\n            material.update();\n\n            const ground = new pc.Entity();\n            ground.addComponent(\"render\", {\n                type: \"box\",\n                material: material,\n            });\n\n            ground.setLocalScale(50, 1, 50);\n            ground.setLocalPosition(0, -0.5, 0);\n            app.root.addChild(ground);\n\n            // Create an entity with a light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n                color: new pc.Color(1, 1, 1),\n                castShadows: true,\n                intensity: 1,\n                shadowBias: 0.2,\n                shadowDistance: 16,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048,\n            });\n\n            light.setLocalEulerAngles(45, 30, 0);\n            app.root.addChild(light);\n\n            // Create a 2D screen\n            const screen = new pc.Entity();\n            screen.setLocalScale(0.01, 0.01, 0.01);\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                screenSpace: true,\n            });\n\n            app.root.addChild(screen);\n\n            /**\n             * Converts a coordinate in world space into a screen's space.\n             *\n             * @param {pc.Vec3} worldPosition - the Vec3 representing the world-space coordinate.\n             * @param {pc.CameraComponent} camera - the Camera.\n             * @param {pc.ScreenComponent} screen - the Screen\n             * @returns {pc.Vec3} a Vec3 of the input worldPosition relative to the camera and screen. The Z coordinate represents the depth,\n             * and negative numbers signal that the worldPosition is behind the camera.\n             */\n            function worldToScreenSpace(worldPosition, camera, screen) {\n                const screenPos = camera.worldToScreen(worldPosition);\n\n                // take pixel ratio into account\n                const pixelRatio = app.graphicsDevice.maxPixelRatio;\n                screenPos.x *= pixelRatio;\n                screenPos.y *= pixelRatio;\n\n                // account for screen scaling\n                const scale = screen.scale;\n\n                // invert the y position\n                screenPos.y = screen.resolution.y - screenPos.y;\n\n                // put that into a Vec3\n                return new pc.Vec3(\n                    screenPos.x / scale,\n                    screenPos.y / scale,\n                    screenPos.z / scale\n                );\n            }\n\n            function createPlayer(id, startingAngle, speed, radius) {\n                // Create a capsule entity to represent a player in the 3d world\n                const entity = new pc.Entity();\n                entity.setLocalScale(new pc.Vec3(0.5, 0.5, 0.5));\n                entity.addComponent(\"render\", {\n                    type: \"capsule\",\n                });\n\n                app.root.addChild(entity);\n\n                // update the player position every frame with some mock logic\n                // normally, this would be taking inputs, running physics simulation, etc\n                let angle = startingAngle;\n                const height = 0.5;\n                app.on(\"update\", function (dt) {\n                    angle += dt * speed;\n                    if (angle > 360) {\n                        angle -= 360;\n                    }\n                    entity.setLocalPosition(\n                        radius * Math.sin(angle * pc.math.DEG_TO_RAD),\n                        height,\n                        radius * Math.cos(angle * pc.math.DEG_TO_RAD)\n                    );\n                    entity.setLocalEulerAngles(0, angle + 90, 0);\n                });\n\n                // Create a text element that will hover the player's head\n                const playerInfo = new pc.Entity();\n                playerInfo.addComponent(\"element\", {\n                    pivot: new pc.Vec2(0.5, 0),\n                    anchor: new pc.Vec4(0, 0, 0, 0),\n                    width: 150,\n                    height: 50,\n                    opacity: 0.05,\n                    type: pc.ELEMENTTYPE_IMAGE,\n                });\n\n                screen.addChild(playerInfo);\n\n                const name = new pc.Entity();\n                name.addComponent(\"element\", {\n                    pivot: new pc.Vec2(0.5, 0.5),\n                    anchor: new pc.Vec4(0, 0.4, 1, 1),\n                    margin: new pc.Vec4(0, 0, 0, 0),\n                    fontAsset: assets.font.id,\n                    fontSize: 20,\n                    text: `Player ${id}`,\n                    useInput: true,\n                    type: pc.ELEMENTTYPE_TEXT,\n                });\n\n                name.addComponent(\"button\", {\n                    imageEntity: name,\n                });\n\n                name.button.on(\"click\", function () {\n                    const color = new pc.Color(\n                        Math.random(),\n                        Math.random(),\n                        Math.random()\n                    );\n                    name.element.color = color;\n                    entity.render.material.setParameter(\"material_diffuse\", [\n                        color.r,\n                        color.g,\n                        color.b,\n                    ]);\n                });\n                playerInfo.addChild(name);\n\n                const healthBar = new pc.Entity();\n                healthBar.addComponent(\"element\", {\n                    pivot: new pc.Vec2(0.5, 0),\n                    anchor: new pc.Vec4(0, 0, 1, 0.4),\n                    margin: new pc.Vec4(0, 0, 0, 0),\n                    color: new pc.Color(0.2, 0.6, 0.2, 1),\n                    opacity: 1,\n                    type: pc.ELEMENTTYPE_IMAGE,\n                });\n\n                playerInfo.addChild(healthBar);\n\n                // update the player text's position to always hover the player\n                app.on(\"update\", function () {\n                    // get the desired world position\n                    const worldPosition = entity.getPosition();\n                    worldPosition.y += 0.6; // slightly above the player's head\n\n                    // convert to screen position\n                    const screenPosition = worldToScreenSpace(\n                        worldPosition,\n                        camera.camera,\n                        screen.screen\n                    );\n\n                    if (screenPosition.z > 0) {\n                        // if world position is in front of the camera, show it\n                        playerInfo.enabled = true;\n\n                        // set the UI position\n                        playerInfo.setLocalPosition(screenPosition);\n                    } else {\n                        // if world position is actually *behind* the camera, hide the UI\n                        playerInfo.enabled = false;\n                    }\n                });\n            }\n\n            createPlayer(1, 135, 30, 1.5);\n            createPlayer(2, 65, -18, 1);\n            createPlayer(3, 0, 15, 2.5);\n        });\n    });\n}\n","nameSlug":"world-to-screen","categorySlug":"user-interface"},"world-ui":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n\n    const assets = {\n        \"checkboard\": new pc.Asset(\"checkboard\", \"texture\", { url: \"/static/assets/textures/checkboard.png\" }),\n        'font': new pc.Asset('font', 'font', { url: '/static/assets/fonts/courier.json' }),\n        'script': new pc.Asset('script', 'script', { url: '/static/scripts/camera/orbit-camera.js' })\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: '/static/lib/glslang/glslang.js',\n        twgslUrl: '/static/lib/twgsl/twgsl.js'\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device: pc.GraphicsDevice) => {\n\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem\n        ];\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n            // @ts-ignore\n            pc.ScriptHandler\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n        assetListLoader.load(() => {\n\n            app.start();\n\n            // Create an Entity with a camera component and simple orbiter script\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255)\n            });\n            camera.rotateLocal(-30, 0, 0);\n            camera.translateLocal(0, 0, 7);\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2 // Override default of 0 (no inertia)\n                }\n            });\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // Create an Entity for the ground\n            const material = new pc.StandardMaterial();\n            material.diffuse = pc.Color.WHITE;\n            material.diffuseMap = assets.checkboard.resource;\n            material.diffuseMapTiling = new pc.Vec2(50, 50);\n            material.update();\n\n            const ground = new pc.Entity();\n            ground.addComponent(\"render\", {\n                type: \"box\",\n                material: material\n            });\n            ground.setLocalScale(50, 1, 50);\n            ground.setLocalPosition(0, -0.5, 0);\n            app.root.addChild(ground);\n\n            // Create an entity with a light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n                color: new pc.Color(1, 1, 1),\n                castShadows: true,\n                intensity: 1,\n                shadowBias: 0.2,\n                shadowDistance: 16,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048\n            });\n            light.setLocalEulerAngles(45, 30, 0);\n            app.root.addChild(light);\n\n            // Create a 3D world screen, which is basically a `screen` with `screenSpace` set to false\n            const screen = new pc.Entity();\n            screen.setLocalScale(0.01, 0.01, 0.01);\n            screen.setPosition(0, 0.01, 0); // place UI slightly above the ground\n            screen.setLocalRotation(new pc.Quat().setFromEulerAngles(-90, 0, 0));\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                screenSpace: false\n            });\n            app.root.addChild(screen);\n\n            // Text\n            const text = new pc.Entity();\n            text.setLocalPosition(0, 25, 0);\n            text.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                fontAsset: assets.font.id,\n                fontSize: 18,\n                text: \"this is a UI screen placed in the 3D world\",\n                width: 200,\n                height: 100,\n                autoWidth: false,\n                autoHeight: false,\n                wrapLines: true,\n                enableMarkup: true,\n                type: pc.ELEMENTTYPE_TEXT\n            });\n            screen.addChild(text);\n\n            // Button\n            const button = new pc.Entity();\n            button.setLocalPosition(0, -25, 0);\n            button.addComponent(\"button\", {\n                imageEntity: button\n            });\n            button.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                width: 100,\n                height: 25,\n                pivot: [0.5, 0.5],\n                type: pc.ELEMENTTYPE_IMAGE,\n                useInput: true\n            });\n            screen.addChild(button);\n\n            // Create a label for the button\n            const buttonText = new pc.Entity();\n            buttonText.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0, 0, 1, 1),\n                margin: new pc.Vec4(0, 0, 0, 0),\n                color: new pc.Color(0, 0, 0),\n                fontAsset: assets.font.id,\n                fontSize: 12,\n                text: \"and this is a button\",\n                type: pc.ELEMENTTYPE_TEXT,\n                wrapLines: true\n            });\n            button.addChild(buttonText);\n\n            // Change the background color every time the button is clicked\n            button.button.on('click', function () {\n                camera.camera.clearColor = new pc.Color(Math.random(), Math.random(), Math.random());\n            });\n        });\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const assets = {\n        checkboard: new pc.Asset(\"checkboard\", \"texture\", {\n            url: \"/static/assets/textures/checkboard.png\",\n        }),\n        font: new pc.Asset(\"font\", \"font\", {\n            url: \"/static/assets/fonts/courier.json\",\n        }),\n        script: new pc.Asset(\"script\", \"script\", {\n            url: \"/static/scripts/camera/orbit-camera.js\",\n        }),\n    };\n\n    const gfxOptions = {\n        deviceTypes: [deviceType],\n        glslangUrl: \"/static/lib/glslang/glslang.js\",\n        twgslUrl: \"/static/lib/twgsl/twgsl.js\",\n    };\n\n    pc.createGraphicsDevice(canvas, gfxOptions).then((device) => {\n        const createOptions = new pc.AppOptions();\n        createOptions.graphicsDevice = device;\n        createOptions.mouse = new pc.Mouse(document.body);\n        createOptions.touch = new pc.TouchDevice(document.body);\n        createOptions.elementInput = new pc.ElementInput(canvas);\n\n        createOptions.componentSystems = [\n            // @ts-ignore\n            pc.RenderComponentSystem,\n            // @ts-ignore\n            pc.CameraComponentSystem,\n            // @ts-ignore\n            pc.LightComponentSystem,\n            // @ts-ignore\n            pc.ScreenComponentSystem,\n            // @ts-ignore\n            pc.ButtonComponentSystem,\n            // @ts-ignore\n            pc.ElementComponentSystem,\n            // @ts-ignore\n            pc.ScriptComponentSystem,\n        ];\n\n        createOptions.resourceHandlers = [\n            // @ts-ignore\n            pc.TextureHandler,\n            // @ts-ignore\n            pc.FontHandler,\n            // @ts-ignore\n            pc.ScriptHandler,\n        ];\n\n        const app = new pc.AppBase(canvas);\n        app.init(createOptions);\n\n        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        const assetListLoader = new pc.AssetListLoader(\n            Object.values(assets),\n            app.assets\n        );\n        assetListLoader.load(() => {\n            app.start();\n\n            // Create an Entity with a camera component and simple orbiter script\n            const camera = new pc.Entity();\n            camera.addComponent(\"camera\", {\n                clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),\n            });\n\n            camera.rotateLocal(-30, 0, 0);\n            camera.translateLocal(0, 0, 7);\n            camera.addComponent(\"script\");\n            camera.script.create(\"orbitCamera\", {\n                attributes: {\n                    inertiaFactor: 0.2, // Override default of 0 (no inertia)\n                },\n            });\n\n            camera.script.create(\"orbitCameraInputMouse\");\n            camera.script.create(\"orbitCameraInputTouch\");\n            app.root.addChild(camera);\n\n            // Create an Entity for the ground\n            const material = new pc.StandardMaterial();\n            material.diffuse = pc.Color.WHITE;\n            material.diffuseMap = assets.checkboard.resource;\n            material.diffuseMapTiling = new pc.Vec2(50, 50);\n            material.update();\n\n            const ground = new pc.Entity();\n            ground.addComponent(\"render\", {\n                type: \"box\",\n                material: material,\n            });\n\n            ground.setLocalScale(50, 1, 50);\n            ground.setLocalPosition(0, -0.5, 0);\n            app.root.addChild(ground);\n\n            // Create an entity with a light component\n            const light = new pc.Entity();\n            light.addComponent(\"light\", {\n                type: \"directional\",\n                color: new pc.Color(1, 1, 1),\n                castShadows: true,\n                intensity: 1,\n                shadowBias: 0.2,\n                shadowDistance: 16,\n                normalOffsetBias: 0.05,\n                shadowResolution: 2048,\n            });\n\n            light.setLocalEulerAngles(45, 30, 0);\n            app.root.addChild(light);\n\n            // Create a 3D world screen, which is basically a `screen` with `screenSpace` set to false\n            const screen = new pc.Entity();\n            screen.setLocalScale(0.01, 0.01, 0.01);\n            screen.setPosition(0, 0.01, 0); // place UI slightly above the ground\n            screen.setLocalRotation(\n                new pc.Quat().setFromEulerAngles(-90, 0, 0)\n            );\n            screen.addComponent(\"screen\", {\n                referenceResolution: new pc.Vec2(1280, 720),\n                screenSpace: false,\n            });\n\n            app.root.addChild(screen);\n\n            // Text\n            const text = new pc.Entity();\n            text.setLocalPosition(0, 25, 0);\n            text.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),\n                fontAsset: assets.font.id,\n                fontSize: 18,\n                text: \"this is a UI screen placed in the 3D world\",\n                width: 200,\n                height: 100,\n                autoWidth: false,\n                autoHeight: false,\n                wrapLines: true,\n                enableMarkup: true,\n                type: pc.ELEMENTTYPE_TEXT,\n            });\n\n            screen.addChild(text);\n\n            // Button\n            const button = new pc.Entity();\n            button.setLocalPosition(0, -25, 0);\n            button.addComponent(\"button\", {\n                imageEntity: button,\n            });\n\n            button.addComponent(\"element\", {\n                anchor: [0.5, 0.5, 0.5, 0.5],\n                width: 100,\n                height: 25,\n                pivot: [0.5, 0.5],\n                type: pc.ELEMENTTYPE_IMAGE,\n                useInput: true,\n            });\n\n            screen.addChild(button);\n\n            // Create a label for the button\n            const buttonText = new pc.Entity();\n            buttonText.addComponent(\"element\", {\n                pivot: new pc.Vec2(0.5, 0.5),\n                anchor: new pc.Vec4(0, 0, 1, 1),\n                margin: new pc.Vec4(0, 0, 0, 0),\n                color: new pc.Color(0, 0, 0),\n                fontAsset: assets.font.id,\n                fontSize: 12,\n                text: \"and this is a button\",\n                type: pc.ELEMENTTYPE_TEXT,\n                wrapLines: true,\n            });\n\n            button.addChild(buttonText);\n\n            // Change the background color every time the button is clicked\n            button.button.on(\"click\", function () {\n                camera.camera.clearColor = new pc.Color(\n                    Math.random(),\n                    Math.random(),\n                    Math.random()\n                );\n            });\n        });\n    });\n}\n","nameSlug":"world-ui","categorySlug":"user-interface"}},"xr":{"ar-basic":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector('.message');\n        if (!el) {\n            el = document.createElement('div');\n            el.classList.add('message');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n        graphicsDeviceOptions: { alpha: true }\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent('camera', {\n        clearColor: new pc.Color(0, 0, 0, 0),\n        farClip: 10000\n    });\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent(\"light\", {\n        type: \"spot\",\n        range: 30\n    });\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n\n    const createCube = function (x: number, y: number, z: number) {\n        const cube = new pc.Entity();\n        cube.addComponent(\"render\", {\n            type: \"box\"\n        });\n        cube.setLocalScale(0.5, 0.5, 0.5);\n        cube.translate(x * 0.5, y, z * 0.5);\n        app.root.addChild(cube);\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x < SIZE; x++) {\n        for (let y = 0; y < SIZE; y++) {\n            createCube(2 * x - SIZE, 0.25, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_AR)) {\n                c.camera.startXr(pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR, {\n                    callback: function (err) {\n                        if (err) message(\"WebXR Immersive AR failed to start: \" + err.message);\n                    }\n                });\n            } else {\n                message(\"Immersive AR is not available\");\n            }\n        };\n\n        app.mouse.on(\"mousedown\", function () {\n            if (!app.xr.active)\n                activate();\n        });\n\n        if (app.touch) {\n            app.touch.on(\"touchend\", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on('keydown', function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        app.xr.on('start', function () {\n            message(\"Immersive AR session has started\");\n        });\n        app.xr.on('end', function () {\n            message(\"Immersive AR session has ended\");\n        });\n        app.xr.on('available:' + pc.XRTYPE_AR, function (available) {\n            message(\"Immersive AR is \" + (available ? 'available' : 'unavailable'));\n        });\n\n        if (!app.xr.isAvailable(pc.XRTYPE_AR)) {\n            message(\"Immersive AR is not available\");\n        }\n    } else {\n        message(\"WebXR is not supported\");\n    }\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const message = function (msg) {\n        let el = document.querySelector(\".message\");\n        if (!el) {\n            el = document.createElement(\"div\");\n            el.classList.add(\"message\");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n        graphicsDeviceOptions: { alpha: true },\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent(\"camera\", {\n        clearColor: new pc.Color(0, 0, 0, 0),\n        farClip: 10000,\n    });\n\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent(\"light\", {\n        type: \"spot\",\n        range: 30,\n    });\n\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x, y, z) {\n        const cube = new pc.Entity();\n        cube.addComponent(\"render\", {\n            type: \"box\",\n        });\n\n        cube.setLocalScale(0.5, 0.5, 0.5);\n        cube.translate(x * 0.5, y, z * 0.5);\n        app.root.addChild(cube);\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x < SIZE; x++) {\n        for (let y = 0; y < SIZE; y++) {\n            createCube(2 * x - SIZE, 0.25, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_AR)) {\n                c.camera.startXr(pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR, {\n                    callback: function (err) {\n                        if (err)\n                            message(\n                                \"WebXR Immersive AR failed to start: \" +\n                                    err.message\n                            );\n                    },\n                });\n            } else {\n                message(\"Immersive AR is not available\");\n            }\n        };\n\n        app.mouse.on(\"mousedown\", function () {\n            if (!app.xr.active) activate();\n        });\n\n        if (app.touch) {\n            app.touch.on(\"touchend\", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on(\"keydown\", function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        app.xr.on(\"start\", function () {\n            message(\"Immersive AR session has started\");\n        });\n        app.xr.on(\"end\", function () {\n            message(\"Immersive AR session has ended\");\n        });\n        app.xr.on(\"available:\" + pc.XRTYPE_AR, function (available) {\n            message(\n                \"Immersive AR is \" + (available ? \"available\" : \"unavailable\")\n            );\n        });\n\n        if (!app.xr.isAvailable(pc.XRTYPE_AR)) {\n            message(\"Immersive AR is not available\");\n        }\n    } else {\n        message(\"WebXR is not supported\");\n    }\n}\n","nameSlug":"ar-basic","categorySlug":"xr"},"ar-hit-test":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector('.message');\n        if (!el) {\n            el = document.createElement('div');\n            el.classList.add('message');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n        graphicsDeviceOptions: { alpha: true }\n    });\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent('camera', {\n        clearColor: new pc.Color(0, 0, 0, 0),\n        farClip: 10000\n    });\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent(\"light\", {\n        type: \"spot\",\n        range: 30\n    });\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const target = new pc.Entity();\n    target.addComponent(\"render\", {\n        type: \"cylinder\"\n    });\n    target.setLocalScale(0.5, 0.01, 0.5);\n    app.root.addChild(target);\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_AR)) {\n                c.camera.startXr(pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR, {\n                    callback: function (err) {\n                        if (err) message(\"WebXR Immersive AR failed to start: \" + err.message);\n                    }\n                });\n            } else {\n                message(\"Immersive AR is not available\");\n            }\n        };\n\n        app.mouse.on(\"mousedown\", function () {\n            if (!app.xr.active)\n                activate();\n        });\n\n        if (app.touch) {\n            app.touch.on(\"touchend\", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on('keydown', function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        app.xr.on('start', function () {\n            message(\"Immersive AR session has started\");\n\n            if (!app.xr.hitTest.supported)\n                return;\n\n            app.xr.hitTest.start({\n                entityTypes: [pc.XRTRACKABLE_POINT, pc.XRTRACKABLE_PLANE],\n                callback: function (err, hitTestSource) {\n                    if (err) {\n                        message(\"Failed to start AR hit test\");\n                        return;\n                    }\n\n                    hitTestSource.on('result', function (position, rotation) {\n                        target.setPosition(position);\n                        target.setRotation(rotation);\n                    });\n                }\n            });\n        });\n        app.xr.on('end', function () {\n            message(\"Immersive AR session has ended\");\n        });\n        app.xr.on('available:' + pc.XRTYPE_AR, function (available) {\n            if (available) {\n                if (app.xr.hitTest.supported) {\n                    message(\"Touch screen to start AR session and look at the floor or walls\");\n                } else {\n                    message(\"AR Hit Test is not supported\");\n                }\n            } else {\n                message(\"Immersive AR is unavailable\");\n            }\n        });\n\n        if (!app.xr.isAvailable(pc.XRTYPE_AR)) {\n            message(\"Immersive AR is not available\");\n        } else if (!app.xr.hitTest.supported) {\n            message(\"AR Hit Test is not supported\");\n        } else {\n            message(\"Touch screen to start AR session and look at the floor or walls\");\n        }\n    } else {\n        message(\"WebXR is not supported\");\n    }\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const message = function (msg) {\n        let el = document.querySelector(\".message\");\n        if (!el) {\n            el = document.createElement(\"div\");\n            el.classList.add(\"message\");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n        graphicsDeviceOptions: { alpha: true },\n    });\n\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent(\"camera\", {\n        clearColor: new pc.Color(0, 0, 0, 0),\n        farClip: 10000,\n    });\n\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent(\"light\", {\n        type: \"spot\",\n        range: 30,\n    });\n\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const target = new pc.Entity();\n    target.addComponent(\"render\", {\n        type: \"cylinder\",\n    });\n\n    target.setLocalScale(0.5, 0.01, 0.5);\n    app.root.addChild(target);\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_AR)) {\n                c.camera.startXr(pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR, {\n                    callback: function (err) {\n                        if (err)\n                            message(\n                                \"WebXR Immersive AR failed to start: \" +\n                                    err.message\n                            );\n                    },\n                });\n            } else {\n                message(\"Immersive AR is not available\");\n            }\n        };\n\n        app.mouse.on(\"mousedown\", function () {\n            if (!app.xr.active) activate();\n        });\n\n        if (app.touch) {\n            app.touch.on(\"touchend\", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on(\"keydown\", function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        app.xr.on(\"start\", function () {\n            message(\"Immersive AR session has started\");\n\n            if (!app.xr.hitTest.supported) return;\n\n            app.xr.hitTest.start({\n                entityTypes: [pc.XRTRACKABLE_POINT, pc.XRTRACKABLE_PLANE],\n                callback: function (err, hitTestSource) {\n                    if (err) {\n                        message(\"Failed to start AR hit test\");\n                        return;\n                    }\n\n                    hitTestSource.on(\"result\", function (position, rotation) {\n                        target.setPosition(position);\n                        target.setRotation(rotation);\n                    });\n                },\n            });\n        });\n        app.xr.on(\"end\", function () {\n            message(\"Immersive AR session has ended\");\n        });\n        app.xr.on(\"available:\" + pc.XRTYPE_AR, function (available) {\n            if (available) {\n                if (app.xr.hitTest.supported) {\n                    message(\n                        \"Touch screen to start AR session and look at the floor or walls\"\n                    );\n                } else {\n                    message(\"AR Hit Test is not supported\");\n                }\n            } else {\n                message(\"Immersive AR is unavailable\");\n            }\n        });\n\n        if (!app.xr.isAvailable(pc.XRTYPE_AR)) {\n            message(\"Immersive AR is not available\");\n        } else if (!app.xr.hitTest.supported) {\n            message(\"AR Hit Test is not supported\");\n        } else {\n            message(\n                \"Touch screen to start AR session and look at the floor or walls\"\n            );\n        }\n    } else {\n        message(\"WebXR is not supported\");\n    }\n}\n","nameSlug":"ar-hit-test","categorySlug":"xr"},"vr-basic":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector('.message');\n        if (!el) {\n            el = document.createElement('div');\n            el.classList.add('message');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window)\n    });\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent('camera', {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n        farClip: 10000\n    });\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent(\"light\", {\n        type: \"spot\",\n        range: 30\n    });\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n\n    const createCube = function (x: number, y: number, z: number) {\n        const cube = new pc.Entity();\n        cube.addComponent(\"render\", {\n            type: \"box\"\n        });\n        cube.setLocalScale(1, 1, 1);\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    // create a grid of cubes\n    const SIZE = 16;\n    for (let x = 0; x < SIZE; x++) {\n        for (let y = 0; y < SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err) message(\"WebXR Immersive VR failed to start: \" + err.message);\n                    }\n                });\n            } else {\n                message(\"Immersive VR is not available\");\n            }\n        };\n\n        app.mouse.on(\"mousedown\", function () {\n            if (!app.xr.active)\n                activate();\n        });\n\n        if (app.touch) {\n            app.touch.on(\"touchend\", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on('keydown', function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        app.xr.on('start', function () {\n            message(\"Immersive VR session has started\");\n        });\n        app.xr.on('end', function () {\n            message(\"Immersive VR session has ended\");\n        });\n        app.xr.on('available:' + pc.XRTYPE_VR, function (available) {\n            message(\"Immersive VR is \" + (available ? 'available' : 'unavailable'));\n        });\n\n        if (!app.xr.isAvailable(pc.XRTYPE_VR)) {\n            message(\"Immersive VR is not available\");\n        }\n    } else {\n        message(\"WebXR is not supported\");\n    }\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const message = function (msg) {\n        let el = document.querySelector(\".message\");\n        if (!el) {\n            el = document.createElement(\"div\");\n            el.classList.add(\"message\");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent(\"camera\", {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n        farClip: 10000,\n    });\n\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent(\"light\", {\n        type: \"spot\",\n        range: 30,\n    });\n\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x, y, z) {\n        const cube = new pc.Entity();\n        cube.addComponent(\"render\", {\n            type: \"box\",\n        });\n\n        cube.setLocalScale(1, 1, 1);\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    // create a grid of cubes\n    const SIZE = 16;\n    for (let x = 0; x < SIZE; x++) {\n        for (let y = 0; y < SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err)\n                            message(\n                                \"WebXR Immersive VR failed to start: \" +\n                                    err.message\n                            );\n                    },\n                });\n            } else {\n                message(\"Immersive VR is not available\");\n            }\n        };\n\n        app.mouse.on(\"mousedown\", function () {\n            if (!app.xr.active) activate();\n        });\n\n        if (app.touch) {\n            app.touch.on(\"touchend\", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on(\"keydown\", function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        app.xr.on(\"start\", function () {\n            message(\"Immersive VR session has started\");\n        });\n        app.xr.on(\"end\", function () {\n            message(\"Immersive VR session has ended\");\n        });\n        app.xr.on(\"available:\" + pc.XRTYPE_VR, function (available) {\n            message(\n                \"Immersive VR is \" + (available ? \"available\" : \"unavailable\")\n            );\n        });\n\n        if (!app.xr.isAvailable(pc.XRTYPE_VR)) {\n            message(\"Immersive VR is not available\");\n        }\n    } else {\n        message(\"WebXR is not supported\");\n    }\n}\n","nameSlug":"vr-basic","categorySlug":"xr"},"vr-controllers":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector('.message');\n        if (!el) {\n            el = document.createElement('div');\n            el.classList.add('message');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window)\n    });\n\n    const assets = {\n        'glb': new pc.Asset('glb', 'container', { url: '/static/assets/models/vr-controller.glb' })\n    };\n\n    const assetListLoader = new pc.AssetListLoader(Object.values(assets), app.assets);\n    assetListLoader.load(() => {\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        window.addEventListener(\"resize\", function () {\n            app.resizeCanvas(canvas.width, canvas.height);\n        });\n\n        // use device pixel ratio\n        app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n        app.start();\n\n        // create camera\n        const c = new pc.Entity();\n        c.addComponent('camera', {\n            clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255)\n        });\n        app.root.addChild(c);\n\n        const l = new pc.Entity();\n        l.addComponent(\"light\", {\n            type: \"directional\",\n            castShadows: true,\n            shadowBias: 0.05,\n            normalOffsetBias: 0.05,\n            shadowDistance: 5\n        });\n        l.setEulerAngles(45, 135, 0);\n        app.root.addChild(l);\n\n        const createCube = function (x: number, y: number, z: number) {\n            const cube = new pc.Entity();\n            cube.addComponent(\"render\", {\n                type: \"box\",\n                material: new pc.StandardMaterial()\n            });\n            cube.translate(x, y, z);\n            app.root.addChild(cube);\n        };\n\n        const controllers: any = [];\n        // create controller model\n        const createController = function (inputSource: any) {\n            const entity = new pc.Entity();\n            entity.addComponent('model', {\n                type: 'asset',\n                asset: assets.glb.resource.model,\n                castShadows: true\n            });\n            app.root.addChild(entity);\n            // @ts-ignore engine-tsd\n            entity.inputSource = inputSource;\n            controllers.push(entity);\n\n            // destroy input source related entity\n            // when input source is removed\n            inputSource.on('remove', function () {\n                controllers.splice(controllers.indexOf(entity), 1);\n                entity.destroy();\n            });\n        };\n\n        // create a grid of cubes\n        const SIZE = 4;\n        for (let x = 0; x <= SIZE; x++) {\n            for (let y = 0; y <= SIZE; y++) {\n                createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n            }\n        }\n\n        if (app.xr.supported) {\n            const activate = function () {\n                if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                    c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                        callback: function (err) {\n                            if (err) message(\"Immersive VR failed to start: \" + err.message);\n                        }\n                    });\n                } else {\n                    message(\"Immersive VR is not available\");\n                }\n            };\n\n            app.mouse.on(\"mousedown\", function () {\n                if (!app.xr.active)\n                    activate();\n            });\n\n            if (app.touch) {\n                app.touch.on(\"touchend\", function (evt) {\n                    if (!app.xr.active) {\n                        // if not in VR, activate\n                        activate();\n                    } else {\n                        // otherwise reset camera\n                        c.camera.endXr();\n                    }\n\n                    evt.event.preventDefault();\n                    evt.event.stopPropagation();\n                });\n            }\n\n            // end session by keyboard ESC\n            app.keyboard.on('keydown', function (evt) {\n                if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                    app.xr.end();\n                }\n            });\n\n            // when new input source added\n            app.xr.input.on('add', function (inputSource) {\n                message(\"Controller Added\");\n                createController(inputSource);\n            });\n\n            message(\"Tap on screen to enter VR, and see controllers\");\n\n            // update position and rotation for each controller\n            app.on('update', function () {\n                for (let i = 0; i < controllers.length; i++) {\n                    const inputSource = controllers[i].inputSource;\n                    if (inputSource.grip) {\n                        // some controllers can be gripped\n                        controllers[i].enabled = true;\n                        controllers[i].setLocalPosition(inputSource.getLocalPosition());\n                        controllers[i].setLocalRotation(inputSource.getLocalRotation());\n                    } else {\n                        // some controllers cannot be gripped\n                        controllers[i].enabled = false;\n                    }\n                }\n            });\n        } else {\n            message(\"WebXR is not supported\");\n        }\n    });\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const message = function (msg) {\n        let el = document.querySelector(\".message\");\n        if (!el) {\n            el = document.createElement(\"div\");\n            el.classList.add(\"message\");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    const assets = {\n        glb: new pc.Asset(\"glb\", \"container\", {\n            url: \"/static/assets/models/vr-controller.glb\",\n        }),\n    };\n\n    const assetListLoader = new pc.AssetListLoader(\n        Object.values(assets),\n        app.assets\n    );\n    assetListLoader.load(() => {\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n        window.addEventListener(\"resize\", function () {\n            app.resizeCanvas(canvas.width, canvas.height);\n        });\n\n        // use device pixel ratio\n        app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n        app.start();\n\n        // create camera\n        const c = new pc.Entity();\n        c.addComponent(\"camera\", {\n            clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n        });\n\n        app.root.addChild(c);\n\n        const l = new pc.Entity();\n        l.addComponent(\"light\", {\n            type: \"directional\",\n            castShadows: true,\n            shadowBias: 0.05,\n            normalOffsetBias: 0.05,\n            shadowDistance: 5,\n        });\n\n        l.setEulerAngles(45, 135, 0);\n        app.root.addChild(l);\n\n        const createCube = function (x, y, z) {\n            const cube = new pc.Entity();\n            cube.addComponent(\"render\", {\n                type: \"box\",\n                material: new pc.StandardMaterial(),\n            });\n\n            cube.translate(x, y, z);\n            app.root.addChild(cube);\n        };\n\n        const controllers = [];\n        // create controller model\n        const createController = function (inputSource) {\n            const entity = new pc.Entity();\n            entity.addComponent(\"model\", {\n                type: \"asset\",\n                asset: assets.glb.resource.model,\n                castShadows: true,\n            });\n\n            app.root.addChild(entity);\n            // @ts-ignore engine-tsd\n            entity.inputSource = inputSource;\n            controllers.push(entity);\n\n            // destroy input source related entity\n            // when input source is removed\n            inputSource.on(\"remove\", function () {\n                controllers.splice(controllers.indexOf(entity), 1);\n                entity.destroy();\n            });\n        };\n\n        // create a grid of cubes\n        const SIZE = 4;\n        for (let x = 0; x <= SIZE; x++) {\n            for (let y = 0; y <= SIZE; y++) {\n                createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n            }\n        }\n\n        if (app.xr.supported) {\n            const activate = function () {\n                if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                    c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                        callback: function (err) {\n                            if (err)\n                                message(\n                                    \"Immersive VR failed to start: \" +\n                                        err.message\n                                );\n                        },\n                    });\n                } else {\n                    message(\"Immersive VR is not available\");\n                }\n            };\n\n            app.mouse.on(\"mousedown\", function () {\n                if (!app.xr.active) activate();\n            });\n\n            if (app.touch) {\n                app.touch.on(\"touchend\", function (evt) {\n                    if (!app.xr.active) {\n                        // if not in VR, activate\n                        activate();\n                    } else {\n                        // otherwise reset camera\n                        c.camera.endXr();\n                    }\n\n                    evt.event.preventDefault();\n                    evt.event.stopPropagation();\n                });\n            }\n\n            // end session by keyboard ESC\n            app.keyboard.on(\"keydown\", function (evt) {\n                if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                    app.xr.end();\n                }\n            });\n\n            // when new input source added\n            app.xr.input.on(\"add\", function (inputSource) {\n                message(\"Controller Added\");\n                createController(inputSource);\n            });\n\n            message(\"Tap on screen to enter VR, and see controllers\");\n\n            // update position and rotation for each controller\n            app.on(\"update\", function () {\n                for (let i = 0; i < controllers.length; i++) {\n                    const inputSource = controllers[i].inputSource;\n                    if (inputSource.grip) {\n                        // some controllers can be gripped\n                        controllers[i].enabled = true;\n                        controllers[i].setLocalPosition(\n                            inputSource.getLocalPosition()\n                        );\n                        controllers[i].setLocalRotation(\n                            inputSource.getLocalRotation()\n                        );\n                    } else {\n                        // some controllers cannot be gripped\n                        controllers[i].enabled = false;\n                    }\n                }\n            });\n        } else {\n            message(\"WebXR is not supported\");\n        }\n    });\n}\n","nameSlug":"vr-controllers","categorySlug":"xr"},"vr-hands":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector('.message');\n        if (!el) {\n            el = document.createElement('div');\n            el.classList.add('message');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window)\n    });\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent('camera', {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255)\n    });\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent(\"light\", {\n        type: \"directional\"\n    });\n    l.setEulerAngles(45, 135, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x: number, y: number, z: number) {\n        const cube = new pc.Entity();\n        cube.addComponent(\"render\", {\n            type: \"box\",\n            material: new pc.StandardMaterial()\n        });\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    const controllers: any = [];\n\n    // create controller model\n    const createController = function (inputSource: any) {\n        const entity = new pc.Entity();\n\n        if (inputSource.hand) {\n            // hand input\n            // @ts-ignore engine-tsd\n            entity.joints = [];\n\n            const material = new pc.StandardMaterial();\n\n            // create box for each hand joint\n            for (let i = 0; i < inputSource.hand.joints.length; i++) {\n                const joint = inputSource.hand.joints[i];\n                const jointEntity = new pc.Entity();\n                jointEntity.addComponent('model', {\n                    type: 'box',\n                    material: material\n                });\n                // @ts-ignore engine-tsd\n                jointEntity.joint = joint;\n                // @ts-ignore engine-tsd\n                entity.joints.push(jointEntity);\n                entity.addChild(jointEntity);\n            }\n            // when tracking lost, paint joints to red\n            inputSource.hand.on('trackinglost', function () {\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.diffuse.set(1, 0, 0);\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.update();\n            });\n            // when tracking recovered, paint joints to white\n            inputSource.hand.on('tracking', function () {\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.diffuse.set(1, 1, 1);\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.update();\n            });\n        } else {\n            // other inputs\n            entity.addComponent('model', {\n                type: 'box',\n                castShadows: true\n            });\n            entity.setLocalScale(0.05, 0.05, 0.05);\n        }\n\n        app.root.addChild(entity);\n        // @ts-ignore engine-tsd\n        entity.inputSource = inputSource;\n        controllers.push(entity);\n\n        // destroy input source related entity\n        // when input source is removed\n        inputSource.on('remove', function () {\n            controllers.splice(controllers.indexOf(entity), 1);\n            entity.destroy();\n        });\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err) message(\"Immersive VR failed to start: \" + err.message);\n                    }\n                });\n            } else {\n                message(\"Immersive VR is not available\");\n            }\n        };\n\n        app.mouse.on(\"mousedown\", function () {\n            if (!app.xr.active)\n                activate();\n        });\n\n        if (app.touch) {\n            app.touch.on(\"touchend\", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on('keydown', function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        // when new input source added\n        app.xr.input.on('add', function (inputSource) {\n            message(\"Controller Added\");\n            createController(inputSource);\n        });\n\n        if ((window as any).XRHand) {\n            message(\"Tap on screen to enter VR, and switch to hand input\");\n        } else {\n            message(\"WebXR Hands Input is not supported by your platform\");\n        }\n\n        // update position and rotation for each controller\n        app.on('update', function () {\n            for (let i = 0; i < controllers.length; i++) {\n                const inputSource = controllers[i].inputSource;\n\n                if (inputSource.hand) {\n                    // hand input source\n                    controllers[i].enabled = true;\n                    // update each hand joint\n                    for (let j = 0; j < controllers[i].joints.length; j++) {\n                        const joint = controllers[i].joints[j].joint;\n                        const r = joint.radius * 2;\n                        controllers[i].joints[j].setLocalScale(r, r, r);\n                        controllers[i].joints[j].setPosition(joint.getPosition());\n                        controllers[i].joints[j].setRotation(joint.getRotation());\n                    }\n                } else if (inputSource.grip) {\n                    // grippable input source\n                    controllers[i].enabled = true;\n                    controllers[i].setLocalPosition(inputSource.getLocalPosition());\n                    controllers[i].setLocalRotation(inputSource.getLocalRotation());\n                } else {\n                    // some controllers cannot be gripped\n                    controllers[i].enabled = false;\n                }\n            }\n        });\n    } else {\n        message(\"WebXR is not supported\");\n    }\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const message = function (msg) {\n        let el = document.querySelector(\".message\");\n        if (!el) {\n            el = document.createElement(\"div\");\n            el.classList.add(\"message\");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent(\"camera\", {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n    });\n\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent(\"light\", {\n        type: \"directional\",\n    });\n\n    l.setEulerAngles(45, 135, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x, y, z) {\n        const cube = new pc.Entity();\n        cube.addComponent(\"render\", {\n            type: \"box\",\n            material: new pc.StandardMaterial(),\n        });\n\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    const controllers = [];\n\n    // create controller model\n    const createController = function (inputSource) {\n        const entity = new pc.Entity();\n\n        if (inputSource.hand) {\n            // hand input\n            // @ts-ignore engine-tsd\n            entity.joints = [];\n\n            const material = new pc.StandardMaterial();\n\n            // create box for each hand joint\n            for (let i = 0; i < inputSource.hand.joints.length; i++) {\n                const joint = inputSource.hand.joints[i];\n                const jointEntity = new pc.Entity();\n                jointEntity.addComponent(\"model\", {\n                    type: \"box\",\n                    material: material,\n                });\n\n                // @ts-ignore engine-tsd\n                jointEntity.joint = joint;\n                // @ts-ignore engine-tsd\n                entity.joints.push(jointEntity);\n                entity.addChild(jointEntity);\n            }\n            // when tracking lost, paint joints to red\n            inputSource.hand.on(\"trackinglost\", function () {\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.diffuse.set(1, 0, 0);\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.update();\n            });\n            // when tracking recovered, paint joints to white\n            inputSource.hand.on(\"tracking\", function () {\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.diffuse.set(1, 1, 1);\n                // @ts-ignore engine-tsd\n                entity.joints[0].model.material.update();\n            });\n        } else {\n            // other inputs\n            entity.addComponent(\"model\", {\n                type: \"box\",\n                castShadows: true,\n            });\n\n            entity.setLocalScale(0.05, 0.05, 0.05);\n        }\n\n        app.root.addChild(entity);\n        // @ts-ignore engine-tsd\n        entity.inputSource = inputSource;\n        controllers.push(entity);\n\n        // destroy input source related entity\n        // when input source is removed\n        inputSource.on(\"remove\", function () {\n            controllers.splice(controllers.indexOf(entity), 1);\n            entity.destroy();\n        });\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err)\n                            message(\n                                \"Immersive VR failed to start: \" + err.message\n                            );\n                    },\n                });\n            } else {\n                message(\"Immersive VR is not available\");\n            }\n        };\n\n        app.mouse.on(\"mousedown\", function () {\n            if (!app.xr.active) activate();\n        });\n\n        if (app.touch) {\n            app.touch.on(\"touchend\", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on(\"keydown\", function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        // when new input source added\n        app.xr.input.on(\"add\", function (inputSource) {\n            message(\"Controller Added\");\n            createController(inputSource);\n        });\n\n        if (window.XRHand) {\n            message(\"Tap on screen to enter VR, and switch to hand input\");\n        } else {\n            message(\"WebXR Hands Input is not supported by your platform\");\n        }\n\n        // update position and rotation for each controller\n        app.on(\"update\", function () {\n            for (let i = 0; i < controllers.length; i++) {\n                const inputSource = controllers[i].inputSource;\n\n                if (inputSource.hand) {\n                    // hand input source\n                    controllers[i].enabled = true;\n                    // update each hand joint\n                    for (let j = 0; j < controllers[i].joints.length; j++) {\n                        const joint = controllers[i].joints[j].joint;\n                        const r = joint.radius * 2;\n                        controllers[i].joints[j].setLocalScale(r, r, r);\n                        controllers[i].joints[j].setPosition(\n                            joint.getPosition()\n                        );\n                        controllers[i].joints[j].setRotation(\n                            joint.getRotation()\n                        );\n                    }\n                } else if (inputSource.grip) {\n                    // grippable input source\n                    controllers[i].enabled = true;\n                    controllers[i].setLocalPosition(\n                        inputSource.getLocalPosition()\n                    );\n                    controllers[i].setLocalRotation(\n                        inputSource.getLocalRotation()\n                    );\n                } else {\n                    // some controllers cannot be gripped\n                    controllers[i].enabled = false;\n                }\n            }\n        });\n    } else {\n        message(\"WebXR is not supported\");\n    }\n}\n","nameSlug":"vr-hands","categorySlug":"xr"},"vr-movement":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector('.message');\n        if (!el) {\n            el = document.createElement('div');\n            el.classList.add('message');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window)\n    });\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera parent\n    const cameraParent = new pc.Entity();\n    app.root.addChild(cameraParent);\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent('camera', {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n        farClip: 10000\n    });\n    cameraParent.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent(\"light\", {\n        type: \"spot\",\n        range: 30\n    });\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x: number, y: number, z: number) {\n        const cube = new pc.Entity();\n        cube.addComponent(\"render\", {\n            type: \"box\",\n            material: new pc.StandardMaterial()\n        });\n        cube.setLocalScale(1, 1, 1);\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    const controllers: any = [];\n    // create controller box\n    const createController = function (inputSource: any) {\n        const entity = new pc.Entity();\n        entity.addComponent('model', {\n            type: 'box'\n        });\n        entity.setLocalScale(0.05, 0.05, 0.05);\n        cameraParent.addChild(entity);\n        // @ts-ignore engine-tsd\n        entity.inputSource = inputSource;\n        controllers.push(entity);\n\n        // destroy input source related entity\n        // when input source is removed\n        inputSource.on('remove', function () {\n            controllers.splice(controllers.indexOf(entity), 1);\n            entity.destroy();\n        });\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err) message(\"Immersive VR failed to start: \" + err.message);\n                    }\n                });\n            } else {\n                message(\"Immersive VR is not available\");\n            }\n        };\n\n        app.mouse.on(\"mousedown\", function () {\n            if (!app.xr.active)\n                activate();\n        });\n\n        if (app.touch) {\n            app.touch.on(\"touchend\", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on('keydown', function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        // when new input source added\n        app.xr.input.on('add', function (inputSource) {\n            createController(inputSource);\n        });\n\n        message(\"Tap on screen to enter VR, use left thumbstick to move and right thumbstick to rotate\");\n\n        const movementSpeed = 1.5; // 1.5 m/s\n        const rotateSpeed = 45;\n        const rotateThreshold = 0.5;\n        const rotateResetThreshold = 0.25;\n        let lastRotateValue = 0;\n\n        const tmpVec2A = new pc.Vec2();\n        const tmpVec2B = new pc.Vec2();\n        const tmpVec3A = new pc.Vec3();\n        const tmpVec3B = new pc.Vec3();\n        const lineColor = new pc.Color(1, 1, 1);\n\n        // update position and rotation for each controller\n        app.on('update', function (dt) {\n            let i, inputSource;\n\n            // first we update movement\n            for (i = 0; i < controllers.length; i++) {\n                inputSource = controllers[i].inputSource;\n\n                // should have gamepad\n                if (!inputSource.gamepad)\n                    continue;\n\n                // left controller - for movement\n                if (inputSource.handedness === pc.XRHAND_LEFT) {\n                    // set vector based on gamepad thumbstick axes values\n                    tmpVec2A.set(inputSource.gamepad.axes[2], inputSource.gamepad.axes[3]);\n\n                    // if there is input\n                    if (tmpVec2A.length()) {\n                        tmpVec2A.normalize();\n\n                        // we need to take in account camera facing\n                        // so we figure out Yaw of camera\n                        tmpVec2B.x = c.forward.x;\n                        tmpVec2B.y = c.forward.z;\n                        tmpVec2B.normalize();\n\n                        const rad = Math.atan2(tmpVec2B.x, tmpVec2B.y) - (Math.PI / 2);\n                        // and rotate our movement vector based on camera yaw\n                        const t =      tmpVec2A.x * Math.sin(rad) - tmpVec2A.y * Math.cos(rad);\n                        tmpVec2A.y = tmpVec2A.y * Math.sin(rad) + tmpVec2A.x * Math.cos(rad);\n                        tmpVec2A.x = t;\n\n                        // set movement speed\n                        tmpVec2A.mulScalar(movementSpeed * dt);\n                        // move camera parent based on calculated movement vector\n                        cameraParent.translate(tmpVec2A.x, 0, tmpVec2A.y);\n                    }\n\n                // right controller - for rotation\n                } else if (inputSource.handedness === pc.XRHAND_RIGHT) {\n                    // get rotation from thumbsitck\n                    const rotate = -inputSource.gamepad.axes[2];\n\n                    // each rotate should be done by moving thumbstick to the side enough\n                    // then thumbstick should be moved back close to neutral position\n                    // before it can be used again to rotate\n                    if (lastRotateValue > 0 && rotate < rotateResetThreshold) {\n                        lastRotateValue = 0;\n                    } else if (lastRotateValue < 0 && rotate > -rotateResetThreshold) {\n                        lastRotateValue = 0;\n                    }\n\n                    // if thumbstick is reset and moved enough to the side\n                    if (lastRotateValue === 0 && Math.abs(rotate) > rotateThreshold) {\n                        lastRotateValue = Math.sign(rotate);\n\n                        // we want to rotate relative to camera position\n                        tmpVec3A.copy(c.getLocalPosition());\n                        cameraParent.translateLocal(tmpVec3A);\n                        cameraParent.rotateLocal(0, Math.sign(rotate) * rotateSpeed, 0);\n                        cameraParent.translateLocal(tmpVec3A.mulScalar(-1));\n                    }\n                }\n            }\n\n            // after movement and rotation is done\n            // we update/render controllers\n            for (i = 0; i < controllers.length; i++) {\n                inputSource = controllers[i].inputSource;\n\n                // render controller ray\n                tmpVec3A.copy(inputSource.getOrigin());\n                tmpVec3B.copy(inputSource.getDirection());\n                tmpVec3B.mulScalar(100).add(tmpVec3A);\n                app.drawLine(tmpVec3A, tmpVec3B, lineColor);\n\n                // render controller\n                if (inputSource.grip) {\n                    // some controllers can be gripped\n                    controllers[i].model.enabled = true;\n                    controllers[i].setLocalPosition(inputSource.getLocalPosition);\n                    controllers[i].setLocalRotation(inputSource.getLocalRotation);\n                } else {\n                    // some controllers cannot be gripped\n                    controllers[i].model.enabled = false;\n                }\n            }\n        });\n    } else {\n        message(\"WebXR is not supported\");\n    }\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const message = function (msg) {\n        let el = document.querySelector(\".message\");\n        if (!el) {\n            el = document.createElement(\"div\");\n            el.classList.add(\"message\");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera parent\n    const cameraParent = new pc.Entity();\n    app.root.addChild(cameraParent);\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent(\"camera\", {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n        farClip: 10000,\n    });\n\n    cameraParent.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent(\"light\", {\n        type: \"spot\",\n        range: 30,\n    });\n\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const createCube = function (x, y, z) {\n        const cube = new pc.Entity();\n        cube.addComponent(\"render\", {\n            type: \"box\",\n            material: new pc.StandardMaterial(),\n        });\n\n        cube.setLocalScale(1, 1, 1);\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n    };\n\n    const controllers = [];\n    // create controller box\n    const createController = function (inputSource) {\n        const entity = new pc.Entity();\n        entity.addComponent(\"model\", {\n            type: \"box\",\n        });\n\n        entity.setLocalScale(0.05, 0.05, 0.05);\n        cameraParent.addChild(entity);\n        // @ts-ignore engine-tsd\n        entity.inputSource = inputSource;\n        controllers.push(entity);\n\n        // destroy input source related entity\n        // when input source is removed\n        inputSource.on(\"remove\", function () {\n            controllers.splice(controllers.indexOf(entity), 1);\n            entity.destroy();\n        });\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err)\n                            message(\n                                \"Immersive VR failed to start: \" + err.message\n                            );\n                    },\n                });\n            } else {\n                message(\"Immersive VR is not available\");\n            }\n        };\n\n        app.mouse.on(\"mousedown\", function () {\n            if (!app.xr.active) activate();\n        });\n\n        if (app.touch) {\n            app.touch.on(\"touchend\", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on(\"keydown\", function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        // when new input source added\n        app.xr.input.on(\"add\", function (inputSource) {\n            createController(inputSource);\n        });\n\n        message(\n            \"Tap on screen to enter VR, use left thumbstick to move and right thumbstick to rotate\"\n        );\n\n        const movementSpeed = 1.5; // 1.5 m/s\n        const rotateSpeed = 45;\n        const rotateThreshold = 0.5;\n        const rotateResetThreshold = 0.25;\n        let lastRotateValue = 0;\n\n        const tmpVec2A = new pc.Vec2();\n        const tmpVec2B = new pc.Vec2();\n        const tmpVec3A = new pc.Vec3();\n        const tmpVec3B = new pc.Vec3();\n        const lineColor = new pc.Color(1, 1, 1);\n\n        // update position and rotation for each controller\n        app.on(\"update\", function (dt) {\n            let i, inputSource;\n\n            // first we update movement\n            for (i = 0; i < controllers.length; i++) {\n                inputSource = controllers[i].inputSource;\n\n                // should have gamepad\n                if (!inputSource.gamepad) continue;\n\n                // left controller - for movement\n                if (inputSource.handedness === pc.XRHAND_LEFT) {\n                    // set vector based on gamepad thumbstick axes values\n                    tmpVec2A.set(\n                        inputSource.gamepad.axes[2],\n                        inputSource.gamepad.axes[3]\n                    );\n\n                    // if there is input\n                    if (tmpVec2A.length()) {\n                        tmpVec2A.normalize();\n\n                        // we need to take in account camera facing\n                        // so we figure out Yaw of camera\n                        tmpVec2B.x = c.forward.x;\n                        tmpVec2B.y = c.forward.z;\n                        tmpVec2B.normalize();\n\n                        const rad =\n                            Math.atan2(tmpVec2B.x, tmpVec2B.y) - Math.PI / 2;\n                        // and rotate our movement vector based on camera yaw\n                        const t =\n                            tmpVec2A.x * Math.sin(rad) -\n                            tmpVec2A.y * Math.cos(rad);\n                        tmpVec2A.y =\n                            tmpVec2A.y * Math.sin(rad) +\n                            tmpVec2A.x * Math.cos(rad);\n                        tmpVec2A.x = t;\n\n                        // set movement speed\n                        tmpVec2A.mulScalar(movementSpeed * dt);\n                        // move camera parent based on calculated movement vector\n                        cameraParent.translate(tmpVec2A.x, 0, tmpVec2A.y);\n                    }\n\n                    // right controller - for rotation\n                } else if (inputSource.handedness === pc.XRHAND_RIGHT) {\n                    // get rotation from thumbsitck\n                    const rotate = -inputSource.gamepad.axes[2];\n\n                    // each rotate should be done by moving thumbstick to the side enough\n                    // then thumbstick should be moved back close to neutral position\n                    // before it can be used again to rotate\n                    if (lastRotateValue > 0 && rotate < rotateResetThreshold) {\n                        lastRotateValue = 0;\n                    } else if (\n                        lastRotateValue < 0 &&\n                        rotate > -rotateResetThreshold\n                    ) {\n                        lastRotateValue = 0;\n                    }\n\n                    // if thumbstick is reset and moved enough to the side\n                    if (\n                        lastRotateValue === 0 &&\n                        Math.abs(rotate) > rotateThreshold\n                    ) {\n                        lastRotateValue = Math.sign(rotate);\n\n                        // we want to rotate relative to camera position\n                        tmpVec3A.copy(c.getLocalPosition());\n                        cameraParent.translateLocal(tmpVec3A);\n                        cameraParent.rotateLocal(\n                            0,\n                            Math.sign(rotate) * rotateSpeed,\n                            0\n                        );\n                        cameraParent.translateLocal(tmpVec3A.mulScalar(-1));\n                    }\n                }\n            }\n\n            // after movement and rotation is done\n            // we update/render controllers\n            for (i = 0; i < controllers.length; i++) {\n                inputSource = controllers[i].inputSource;\n\n                // render controller ray\n                tmpVec3A.copy(inputSource.getOrigin());\n                tmpVec3B.copy(inputSource.getDirection());\n                tmpVec3B.mulScalar(100).add(tmpVec3A);\n                app.drawLine(tmpVec3A, tmpVec3B, lineColor);\n\n                // render controller\n                if (inputSource.grip) {\n                    // some controllers can be gripped\n                    controllers[i].model.enabled = true;\n                    controllers[i].setLocalPosition(\n                        inputSource.getLocalPosition\n                    );\n                    controllers[i].setLocalRotation(\n                        inputSource.getLocalRotation\n                    );\n                } else {\n                    // some controllers cannot be gripped\n                    controllers[i].model.enabled = false;\n                }\n            }\n        });\n    } else {\n        message(\"WebXR is not supported\");\n    }\n}\n","nameSlug":"vr-movement","categorySlug":"xr"},"xr-picking":{"typeScriptFunction":"function example(canvas: HTMLCanvasElement, deviceType: string): void {\n    const message = function (msg: string) {\n        let el: HTMLDivElement = document.querySelector('.message');\n        if (!el) {\n            el = document.createElement('div');\n            el.classList.add('message');\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window)\n    });\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent('camera', {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n        farClip: 10000\n    });\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent(\"light\", {\n        type: \"spot\",\n        range: 30\n    });\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const cubes: any = [];\n\n    const createCube = function (x: number, y: number, z: number) {\n        const cube = new pc.Entity();\n        cube.addComponent(\"render\", {\n            type: \"box\",\n            material: new pc.StandardMaterial()\n        });\n        cube.setLocalScale(1, 1, 1);\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n        cubes.push(cube);\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err) message(\"Immersive VR failed to start: \" + err.message);\n                    }\n                });\n            } else {\n                message(\"Immersive VR is not available\");\n            }\n        };\n\n        app.mouse.on(\"mousedown\", function () {\n            if (!app.xr.active)\n                activate();\n        });\n\n        if (app.touch) {\n            app.touch.on(\"touchend\", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on('keydown', function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        message(\"Tap on screen to enter VR, and then pick objects\");\n\n        // when input source is triggers select\n        // pick closest box and change its color\n        const ray = new pc.Ray();\n        app.xr.input.on('select', function (inputSource) {\n            let candidate = null;\n            let candidateDist = Infinity;\n\n            for (let i = 0; i < cubes.length; i++) {\n                const mesh = cubes[i].model.meshInstances[0];\n\n                // check if mesh bounding box intersects with input source ray\n                ray.set(inputSource.getOrigin(), inputSource.getDirection());\n                if (mesh.aabb.intersectsRay(ray)) {\n                    // check distance to camera\n                    const dist = mesh.aabb.center.distance(c.getPosition());\n\n                    // if it is closer than previous distance\n                    if (dist < candidateDist) {\n\n                        // set new candidate\n                        candidate = mesh;\n                        candidateDist = dist;\n                    }\n                }\n            }\n\n            // if we have picked candidate\n            if (candidate) {\n                // randomize its color\n                candidate.material.diffuse.set(Math.random(), Math.random(), Math.random());\n                candidate.material.update();\n            }\n        });\n\n        const tmpVec = new pc.Vec3();\n        const lineColor = new pc.Color(1, 1, 1);\n\n        // on each app update\n        // render input source rays as a line\n        app.on('update', function () {\n            for (let i = 0; i < app.xr.input.inputSources.length; i++) {\n                const inputSource = app.xr.input.inputSources[i];\n                const direction = inputSource.getDirection();\n                const origin = inputSource.getOrigin();\n\n                tmpVec.copy(direction).mulScalar(100).add(origin);\n\n                app.drawLine(inputSource.getOrigin(), tmpVec, lineColor);\n            }\n        });\n    } else {\n        message(\"WebXR is not supported\");\n    }\n}","javaScriptFunction":"function example(canvas, deviceType) {\n    const message = function (msg) {\n        let el = document.querySelector(\".message\");\n        if (!el) {\n            el = document.createElement(\"div\");\n            el.classList.add(\"message\");\n            document.body.append(el);\n        }\n        el.textContent = msg;\n    };\n\n    const app = new pc.Application(canvas, {\n        mouse: new pc.Mouse(canvas),\n        touch: new pc.TouchDevice(canvas),\n        keyboard: new pc.Keyboard(window),\n    });\n\n    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    app.setCanvasResolution(pc.RESOLUTION_AUTO);\n\n    window.addEventListener(\"resize\", function () {\n        app.resizeCanvas(canvas.width, canvas.height);\n    });\n\n    // use device pixel ratio\n    app.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\n    app.start();\n\n    // create camera\n    const c = new pc.Entity();\n    c.addComponent(\"camera\", {\n        clearColor: new pc.Color(44 / 255, 62 / 255, 80 / 255),\n        farClip: 10000,\n    });\n\n    app.root.addChild(c);\n\n    const l = new pc.Entity();\n    l.addComponent(\"light\", {\n        type: \"spot\",\n        range: 30,\n    });\n\n    l.translate(0, 10, 0);\n    app.root.addChild(l);\n\n    const cubes = [];\n\n    const createCube = function (x, y, z) {\n        const cube = new pc.Entity();\n        cube.addComponent(\"render\", {\n            type: \"box\",\n            material: new pc.StandardMaterial(),\n        });\n\n        cube.setLocalScale(1, 1, 1);\n        cube.translate(x, y, z);\n        app.root.addChild(cube);\n        cubes.push(cube);\n    };\n\n    // create a grid of cubes\n    const SIZE = 4;\n    for (let x = 0; x <= SIZE; x++) {\n        for (let y = 0; y <= SIZE; y++) {\n            createCube(2 * x - SIZE, -1.5, 2 * y - SIZE);\n        }\n    }\n\n    if (app.xr.supported) {\n        const activate = function () {\n            if (app.xr.isAvailable(pc.XRTYPE_VR)) {\n                c.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {\n                    callback: function (err) {\n                        if (err)\n                            message(\n                                \"Immersive VR failed to start: \" + err.message\n                            );\n                    },\n                });\n            } else {\n                message(\"Immersive VR is not available\");\n            }\n        };\n\n        app.mouse.on(\"mousedown\", function () {\n            if (!app.xr.active) activate();\n        });\n\n        if (app.touch) {\n            app.touch.on(\"touchend\", function (evt) {\n                if (!app.xr.active) {\n                    // if not in VR, activate\n                    activate();\n                } else {\n                    // otherwise reset camera\n                    c.camera.endXr();\n                }\n\n                evt.event.preventDefault();\n                evt.event.stopPropagation();\n            });\n        }\n\n        // end session by keyboard ESC\n        app.keyboard.on(\"keydown\", function (evt) {\n            if (evt.key === pc.KEY_ESCAPE && app.xr.active) {\n                app.xr.end();\n            }\n        });\n\n        message(\"Tap on screen to enter VR, and then pick objects\");\n\n        // when input source is triggers select\n        // pick closest box and change its color\n        const ray = new pc.Ray();\n        app.xr.input.on(\"select\", function (inputSource) {\n            let candidate = null;\n            let candidateDist = Infinity;\n\n            for (let i = 0; i < cubes.length; i++) {\n                const mesh = cubes[i].model.meshInstances[0];\n\n                // check if mesh bounding box intersects with input source ray\n                ray.set(inputSource.getOrigin(), inputSource.getDirection());\n                if (mesh.aabb.intersectsRay(ray)) {\n                    // check distance to camera\n                    const dist = mesh.aabb.center.distance(c.getPosition());\n\n                    // if it is closer than previous distance\n                    if (dist < candidateDist) {\n                        // set new candidate\n                        candidate = mesh;\n                        candidateDist = dist;\n                    }\n                }\n            }\n\n            // if we have picked candidate\n            if (candidate) {\n                // randomize its color\n                candidate.material.diffuse.set(\n                    Math.random(),\n                    Math.random(),\n                    Math.random()\n                );\n                candidate.material.update();\n            }\n        });\n\n        const tmpVec = new pc.Vec3();\n        const lineColor = new pc.Color(1, 1, 1);\n\n        // on each app update\n        // render input source rays as a line\n        app.on(\"update\", function () {\n            for (let i = 0; i < app.xr.input.inputSources.length; i++) {\n                const inputSource = app.xr.input.inputSources[i];\n                const direction = inputSource.getDirection();\n                const origin = inputSource.getOrigin();\n\n                tmpVec.copy(direction).mulScalar(100).add(origin);\n\n                app.drawLine(inputSource.getOrigin(), tmpVec, lineColor);\n            }\n        });\n    } else {\n        message(\"WebXR is not supported\");\n    }\n}\n","nameSlug":"xr-picking","categorySlug":"xr"}}}; module.exports = exampleData;