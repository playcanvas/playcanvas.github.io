import"../../core/tracing.js";import{random as e}from"../../core/math/random.js";import{Vec3 as t}from"../../core/math/vec3.js";import{TEXTUREPROJECTION_OCTAHEDRAL as r,TEXTUREPROJECTION_CUBE as s,FILTER_NEAREST as o}from"../../platform/graphics/constants.js";import{DeviceCache as n}from"../../platform/graphics/device-cache.js";import{GraphicsDevice as a}from"../../platform/graphics/graphics-device.js";import{RenderTarget as i}from"../../platform/graphics/render-target.js";import{drawQuadWithShader as c}from"./quad-render-utils.js";import{Texture as h}from"../../platform/graphics/texture.js";import{ChunkUtils as l}from"../shader-lib/chunk-utils.js";import{shaderChunks as p}from"../shader-lib/chunks/chunks.js";import{getProgramLibrary as m}from"../shader-lib/get-program-library.js";import{createShaderFromCode as u}from"../shader-lib/utils.js";import{BlendState as d}from"../../platform/graphics/blend-state.js";const f=e=>{switch(e){case s:return"Cubemap";case r:return"Octahedral";default:return"Equirect"}},g=(e,t,r)=>{if(e<=0)t[r+0]=0,t[r+1]=0,t[r+2]=0,t[r+3]=0;else if(e>=1)t[r+0]=255,t[r+1]=0,t[r+2]=0,t[r+3]=0;else{let s=1*e%1,o=255*e%1,n=65025*e%1;const a=16581375*e%1;s-=o/255,o-=n/255,n-=a/255,t[r+0]=Math.min(255,Math.floor(256*s)),t[r+1]=Math.min(255,Math.floor(256*o)),t[r+2]=Math.min(255,Math.floor(256*n)),t[r+3]=Math.min(255,Math.floor(256*a))}},M=(e,t,r,s)=>{const o=2*r*Math.PI,n=Math.pow(1-t,1/(s+1)),a=Math.sqrt(1-n*n);e.set(Math.cos(o)*a,Math.sin(o)*a,n).normalize()},v=(e,t,r)=>{const s=2*r*Math.PI,o=Math.sqrt(1-t),n=Math.sqrt(t);e.set(Math.cos(s)*n,Math.sin(s)*n,o).normalize()},w=(e,t,r,s)=>{const o=2*r*Math.PI,n=Math.sqrt((1-t)/(1+(s*s-1)*t)),a=Math.sqrt(1-n*n);e.set(Math.cos(o)*a,Math.sin(o)*a,n).normalize()},S=(e,t)=>{const r=e*t,s=t/(1-e*e+r*r);return s*s*(1/Math.PI)},$={16:{2:26,8:20,32:17,128:16,512:16},32:{2:53,8:40,32:34,128:32,512:32},128:{2:214,8:163,32:139,128:130,512:128},1024:{2:1722,8:1310,32:1114,128:1041,512:1025}},b=(r,s,o)=>{const n=o/r,a=1-Math.log2(s)/11,i=a*a,c=new t,h=new t,l=new t(0,0,1),p=[],m=((e,t)=>{const r=$[e];return r&&r[t]||e})(r,s);for(let t=0;t<m;++t){w(c,t/m,e.radicalInverse(t),i);const r=c.z;if(h.set(c.x,c.y,c.z).mulScalar(2*r).sub(l),h.z>0){const e=S(Math.min(1,r),i)/4+.001,t=.5*Math.log2(n/e);p.push(h.x,h.y,h.z,t)}}for(;p.length<4*r;)p.push(0,0,0,0);return p},x=(e,t,r)=>{const s=(e=>{const t=e.length,r=Math.min(t,512),s=Math.ceil(t/r),o=new Uint8Array(r*s*4);let n=0;for(let r=0;r<t;r+=4)g(.5*e[r+0]+.5,o,n+0),g(.5*e[r+1]+.5,o,n+4),g(.5*e[r+2]+.5,o,n+8),g(e[r+3]/8,o,n+12),n+=16;return{width:r,height:s,data:o}})(r);return new h(e,{name:t,width:s.width,height:s.height,mipmaps:!1,minFilter:o,magFilter:o,levels:[s.data]})};class P{constructor(e=!0){this.map=new Map,this.destroyContent=e}destroy(){this.destroyContent&&this.map.forEach(((e,t)=>{e.destroy()}))}get(e,t){if(!this.map.has(e)){const r=t();return this.map.set(e,r),r}return this.map.get(e)}}const _=new P(!1),j=new n,y=(e,t,r)=>j.get(e,(()=>new P)).get(t,(()=>x(e,t,_.get(t,r)))),C=(r,s,o)=>y(r,`lambert-samples-${s}-${o}`,(()=>((r,s)=>{const o=s/r,n=new t,a=[];for(let t=0;t<r;++t){v(n,t/r,e.radicalInverse(t));const s=n.z/Math.PI,i=.5*Math.log2(o/s);a.push(n.x,n.y,n.z,i)}return a})(s,o))),E=(r,s,o)=>y(r,`phong-samples-${s}-${o}`,(()=>((r,s)=>{const o=new t,n=[];for(let t=0;t<r;++t)M(o,t/r,e.radicalInverse(t),s),n.push(o.x,o.y,o.z,0);return n})(s,o))),U=(e,t,r,s)=>y(e,`ggx-samples-${t}-${r}-${s}`,(()=>b(t,r,s))),z="\nattribute vec2 vertex_position;\n\nuniform vec4 uvMod;\n\nvarying vec2 vUv0;\n\nvoid main(void) {\n\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\tvUv0 = getImageEffectUV((vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw);\n}\n";function F(e,t,r={}){var s;e instanceof a&&(e=arguments[1],t=arguments[2],r={},void 0!==arguments[3]&&(r.specularPower=arguments[3]),void 0!==arguments[4]&&(r.numSamples=arguments[4]));const o={none:"reproject",lambert:"prefilterSamplesUnweighted",phong:"prefilterSamplesUnweighted",ggx:"prefilterSamples"},n=r.hasOwnProperty("specularPower")?r.specularPower:1,h=r.hasOwnProperty("face")?r.face:null,g=r.hasOwnProperty("distribution")?r.distribution:1===n?"none":"phong",M=o[g]||"reproject",v=M.startsWith("prefilterSamples"),w=l.decodeFunc(e.encoding),S=l.encodeFunc(t.encoding),$=`sample${f(e.projection)}`,b=`getDirection${f(t.projection)}`,x=r.hasOwnProperty("numSamples")?r.numSamples:1024,P=`${M}_${w}_${S}_${$}_${b}_${x}`,_=e.device;let j=m(_).getCachedShader(P);if(!j){const t=`#define PROCESS_FUNC ${M}\n`+(v?"#define USE_SAMPLES_TEX\n":"")+(e.cubemap?"#define CUBEMAP_SOURCE\n":"")+`#define DECODE_FUNC ${w}\n`+`#define ENCODE_FUNC ${S}\n`+`#define SOURCE_FUNC ${$}\n`+`#define TARGET_FUNC ${b}\n`+`#define NUM_SAMPLES ${x}\n`+`#define NUM_SAMPLES_SQRT ${Math.round(Math.sqrt(x)).toFixed(1)}\n`;j=u(_,z,`${t}\n${p.reprojectPS}`,P)}_.setBlendState(d.DEFAULT);const y=_.scope.resolve(e.cubemap?"sourceCube":"sourceTex");y.setValue(e);const F=_.scope.resolve("params"),I=_.scope.resolve("params2"),O=_.scope.resolve("uvMod");if(null!=(s=r)&&s.seamPixels){const e=r.seamPixels,s=(r.rect?r.rect.z:t.width)-2*e,o=(r.rect?r.rect.w:t.height)-2*e;O.setValue([(s+2*e)/s,(o+2*e)/o,-e/s,-e/o])}else O.setValue([1,1,0,0]);const q=[0,n,e.fixCubemapSeams?1/e.width:0,t.fixCubemapSeams?1/t.width:0],N=[t.width*t.height*(t.cubemap?6:1),e.width*e.height*(e.cubemap?6:1)];if(v){const t=e.width*e.height*(e.cubemap?6:1),r="ggx"===g?U(_,x,n,t):"lambert"===g?C(_,x,t):E(_,x,n);_.scope.resolve("samplesTex").setValue(r),_.scope.resolve("samplesTexInverseSize").setValue([1/r.width,1/r.height])}for(let e=0;e<(t.cubemap?6:1);e++)if(null===h||e===h){var T;const s=new i({colorBuffer:t,face:e,depth:!1});q[0]=e,F.setValue(q),I.setValue(N),c(_,s,j,null==(T=r)?void 0:T.rect),s.destroy()}}export{F as reprojectTexture};
