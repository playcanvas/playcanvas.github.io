/**
 * Callback used by {@link EventHandler } functions. Note the callback is limited to 8 arguments.
 */
type handleEventCallback = (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any) => any;
/**
 * Callback used by {@link EventHandler} functions. Note the callback is limited to 8 arguments.
 *
 * @callback handleEventCallback
 * @param {*} [arg1] - First argument that is passed from caller.
 * @param {*} [arg2] - Second argument that is passed from caller.
 * @param {*} [arg3] - Third argument that is passed from caller.
 * @param {*} [arg4] - Fourth argument that is passed from caller.
 * @param {*} [arg5] - Fifth argument that is passed from caller.
 * @param {*} [arg6] - Sixth argument that is passed from caller.
 * @param {*} [arg7] - Seventh argument that is passed from caller.
 * @param {*} [arg8] - Eighth argument that is passed from caller.
 */
/**
 * Abstract base class that implements functionality for event handling.
 */
declare class EventHandler$1 {
    /**
     * @type {object}
     * @private
     */
    private _callbacks;
    /**
     * @type {object}
     * @private
     */
    private _callbackActive;
    /**
     * Reinitialize the event handler.
     *
     * @private
     */
    private initEventHandler;
    /**
     * Registers a new event handler.
     *
     * @param {string} name - Name of the event to bind the callback to.
     * @param {handleEventCallback} callback - Function that is called when event is fired. Note
     * the callback is limited to 8 arguments.
     * @param {object} [scope] - Object to use as 'this' when the event is fired, defaults to
     * current this.
     * @param {boolean} [once=false] - If true, the callback will be unbound after being fired once.
     * @private
     */
    private _addCallback;
    /**
     * Attach an event handler to an event.
     *
     * @param {string} name - Name of the event to bind the callback to.
     * @param {handleEventCallback} callback - Function that is called when event is fired. Note
     * the callback is limited to 8 arguments.
     * @param {object} [scope] - Object to use as 'this' when the event is fired, defaults to
     * current this.
     * @returns {EventHandler} Self for chaining.
     * @example
     * obj.on('test', function (a, b) {
     *     console.log(a + b);
     * });
     * obj.fire('test', 1, 2); // prints 3 to the console
     */
    on(name: string, callback: handleEventCallback, scope?: object): EventHandler$1;
    /**
     * Detach an event handler from an event. If callback is not provided then all callbacks are
     * unbound from the event, if scope is not provided then all events with the callback will be
     * unbound.
     *
     * @param {string} [name] - Name of the event to unbind.
     * @param {handleEventCallback} [callback] - Function to be unbound.
     * @param {object} [scope] - Scope that was used as the this when the event is fired.
     * @returns {EventHandler} Self for chaining.
     * @example
     * var handler = function () {
     * };
     * obj.on('test', handler);
     *
     * obj.off(); // Removes all events
     * obj.off('test'); // Removes all events called 'test'
     * obj.off('test', handler); // Removes all handler functions, called 'test'
     * obj.off('test', handler, this); // Removes all handler functions, called 'test' with scope this
     */
    off(name?: string, callback?: handleEventCallback, scope?: object): EventHandler$1;
    /**
     * Fire an event, all additional arguments are passed on to the event listener.
     *
     * @param {string} name - Name of event to fire.
     * @param {*} [arg1] - First argument that is passed to the event handler.
     * @param {*} [arg2] - Second argument that is passed to the event handler.
     * @param {*} [arg3] - Third argument that is passed to the event handler.
     * @param {*} [arg4] - Fourth argument that is passed to the event handler.
     * @param {*} [arg5] - Fifth argument that is passed to the event handler.
     * @param {*} [arg6] - Sixth argument that is passed to the event handler.
     * @param {*} [arg7] - Seventh argument that is passed to the event handler.
     * @param {*} [arg8] - Eighth argument that is passed to the event handler.
     * @returns {EventHandler} Self for chaining.
     * @example
     * obj.fire('test', 'This is the message');
     */
    fire(name: string, arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): EventHandler$1;
    /**
     * Attach an event handler to an event. This handler will be removed after being fired once.
     *
     * @param {string} name - Name of the event to bind the callback to.
     * @param {handleEventCallback} callback - Function that is called when event is fired. Note
     * the callback is limited to 8 arguments.
     * @param {object} [scope] - Object to use as 'this' when the event is fired, defaults to
     * current this.
     * @returns {EventHandler} Self for chaining.
     * @example
     * obj.once('test', function (a, b) {
     *     console.log(a + b);
     * });
     * obj.fire('test', 1, 2); // prints 3 to the console
     * obj.fire('test', 1, 2); // not going to get handled
     */
    once(name: string, callback: handleEventCallback, scope?: object): EventHandler$1;
    /**
     * Test if there are any handlers bound to an event name.
     *
     * @param {string} name - The name of the event to test.
     * @returns {boolean} True if the object has handlers bound to the specified event name.
     * @example
     * obj.on('test', function () { }); // bind an event to 'test'
     * obj.hasEvent('test'); // returns true
     * obj.hasEvent('hello'); // returns false
     */
    hasEvent(name: string): boolean;
}

declare namespace events {
    function attach(target: any): any;
    const _addCallback: (name: string, callback: handleEventCallback, scope?: any, once?: boolean) => void;
    const on: (name: string, callback: handleEventCallback, scope?: any) => EventHandler$1;
    const off: (name?: string, callback?: handleEventCallback, scope?: any) => EventHandler$1;
    const fire: (name: string, arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any) => EventHandler$1;
    const once: (name: string, callback: handleEventCallback, scope?: any) => EventHandler$1;
    const hasEvent: (name: string) => boolean;
}

declare namespace guid {
    function create(): string;
}

declare namespace path {
    const delimiter: string;
    function join(...args: string[]): string;
    function normalize(pathname: string): string;
    function split(pathname: string): string[];
    function getBasename(pathname: string): string;
    function getDirectory(pathname: string): string;
    function getExtension(pathname: string): string;
    function isRelativePath(pathname: string): boolean;
    function extractPath(pathname: string): string;
}

declare namespace platform {
    export { environment };
    export const global: object;
    export const browser: boolean;
    export { desktop };
    export { mobile };
    export { ios };
    export { android };
    export { windows };
    export { xbox };
    export { gamepads };
    export { touch };
    export { workers };
    export { passiveEvents };
}
declare const environment: "browser" | "node";
declare let desktop: boolean;
declare let mobile: boolean;
declare let ios: boolean;
declare let android: boolean;
declare let windows: boolean;
declare let xbox: boolean;
declare let gamepads: boolean;
declare let touch: boolean;
declare let workers: boolean;
declare let passiveEvents: boolean;

declare namespace string {
    export { ASCII_LOWERCASE };
    export { ASCII_UPPERCASE };
    export { ASCII_LETTERS };
    export function format(s: string, ...args: any[]): string;
    export function toBool(s: string, strict?: boolean): boolean;
    export function getCodePoint(string: string, i?: number): number;
    export function getCodePoints(string: string): number[];
    export function getSymbols(string: string): string[];
    export function fromCodePoint(...args: number[]): string;
}
declare const ASCII_LOWERCASE: "abcdefghijklmnopqrstuvwxyz";
declare const ASCII_UPPERCASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
declare const ASCII_LETTERS: string;

/**
 * A ordered list-type data structure that can provide item look up by key and can also return a list.
 *
 * @ignore
 */
declare class IndexedList {
    /**
     * @type {object[]}
     * @private
     */
    private _list;
    /**
     * @type {Object.<string, number>}
     * @private
     */
    private _index;
    /**
     * Add a new item into the list with a index key.
     *
     * @param {string} key -  Key used to look up item in index.
     * @param {object} item - Item to be stored.
     */
    push(key: string, item: object): void;
    /**
     * Test whether a key has been added to the index.
     *
     * @param {string} key - The key to test.
     * @returns {boolean} Returns true if key is in the index, false if not.
     */
    has(key: string): boolean;
    /**
     * Return the item indexed by a key.
     *
     * @param {string} key - The key of the item to retrieve.
     * @returns {object|null} The item stored at key. Returns null if key is not in the index.
     */
    get(key: string): object | null;
    /**
     * Remove the item indexed by key from the list.
     *
     * @param {string} key - The key at which to remove the item.
     * @returns {boolean} Returns true if the key exists and an item was removed, returns false if
     * no item was removed.
     */
    remove(key: string): boolean;
    /**
     * Returns the list of items.
     *
     * @returns {object[]} The list of items.
     */
    list(): object[];
    /**
     * Remove all items from the list.
     */
    clear(): void;
}

/**
 * Helper class for organized reading of memory.
 *
 * @ignore
 */
declare class ReadStream {
    constructor(arraybuffer: any);
    arraybuffer: any;
    dataView: DataView;
    offset: number;
    stack: any[];
    get remainingBytes(): number;
    reset(offset?: number): void;
    skip(bytes: any): void;
    align(bytes: any): void;
    _inc(amount: any): number;
    readChar(): string;
    readChars(numChars: any): string;
    readU8(): number;
    readU16(): number;
    readU32(): number;
    readU64(): number;
    readU32be(): number;
    readArray(result: any): void;
    readLine(): string;
}

/**
 * Helper class used to hold an array of items in a specific order. This array is safe to modify
 * while we loop through it. The class assumes that it holds objects that need to be sorted based
 * on one of their fields.
 *
 * @ignore
 */
declare class SortedLoopArray {
    /**
     * Create a new SortedLoopArray instance.
     *
     * @param {object} args - Arguments.
     * @param {string} args.sortBy - The name of the field that each element in the array is going
     * to be sorted by.
     * @example
     * var array = new pc.SortedLoopArray({ sortBy: 'priority' });
     * array.insert(item); // adds item to the right slot based on item.priority
     * array.append(item); // adds item to the end of the array
     * array.remove(item); // removes item from array
     * for (array.loopIndex = 0; array.loopIndex < array.length; array.loopIndex++) {
     *   // do things with array elements
     *   // safe to remove and add elements into the array while looping
     * }
     */
    constructor(args: {
        sortBy: string;
    });
    /**
     * The internal array that holds the actual array elements.
     *
     * @type {object[]}
     */
    items: object[];
    /**
     * The number of elements in the array.
     *
     * @type {number}
     */
    length: number;
    /**
     * The current index used to loop through the array. This gets modified if we add or remove
     * elements from the array while looping. See the example to see how to loop through this
     * array.
     *
     * @type {number}
     */
    loopIndex: number;
    _sortBy: string;
    _sortHandler: any;
    /**
     * Searches for the right spot to insert the specified item.
     *
     * @param {object} item - The item.
     * @returns {number} The index where to insert the item.
     * @private
     */
    private _binarySearch;
    _doSort(a: any, b: any): number;
    /**
     * Inserts the specified item into the array at the right index based on the 'sortBy' field
     * passed into the constructor. This also adjusts the loopIndex accordingly.
     *
     * @param {object} item - The item to insert.
     */
    insert(item: object): void;
    /**
     * Appends the specified item to the end of the array. Faster than insert() as it does not
     * binary search for the right index. This also adjusts the loopIndex accordingly.
     *
     * @param {object} item - The item to append.
     */
    append(item: object): void;
    /**
     * Removes the specified item from the array.
     *
     * @param {object} item - The item to remove.
     */
    remove(item: object): void;
    /**
     * Sorts elements in the array based on the 'sortBy' field passed into the constructor. This
     * also updates the loopIndex if we are currently looping.
     *
     * WARNING: Be careful if you are sorting while iterating because if after sorting the array
     * element that you are currently processing is moved behind other elements then you might end
     * up iterating over elements more than once!
     */
    sort(): void;
}

/**
 * Set of tag names. Tags are automatically available on {@link Entity} and {@link Asset} as `tags`
 * field.
 *
 * @augments EventHandler
 */
declare class Tags extends EventHandler$1 {
    /**
     * Create an instance of a Tags.
     *
     * @param {object} [parent] - Parent object who tags belong to.
     */
    constructor(parent?: object);
    _index: {};
    _list: any[];
    _parent: any;
    /**
     * Add a tag, duplicates are ignored. Can be array or comma separated arguments for multiple tags.
     *
     * @param {...*} name - Name of a tag, or array of tags.
     * @returns {boolean} True if any tag were added.
     * @example
     * tags.add('level-1');
     * @example
     * tags.add('ui', 'settings');
     * @example
     * tags.add(['level-2', 'mob']);
     */
    add(...args: any[]): boolean;
    /**
     * Remove tag.
     *
     * @param {...*} name - Name of a tag or array of tags.
     * @returns {boolean} True if any tag were removed.
     * @example
     * tags.remove('level-1');
     * @example
     * tags.remove('ui', 'settings');
     * @example
     * tags.remove(['level-2', 'mob']);
     */
    remove(...args: any[]): boolean;
    /**
     * Remove all tags.
     *
     * @example
     * tags.clear();
     */
    clear(): void;
    /**
     * Check if tags satisfy filters. Filters can be provided by simple name of tag, as well as by
     * array of tags. When an array is provided it will check if tags contain each tag within the
     * array. If any of comma separated argument is satisfied, then it will return true. Any number
     * of combinations are valid, and order is irrelevant.
     *
     * @param {...*} query - Name of a tag or array of tags.
     * @returns {boolean} True if filters are satisfied.
     * @example
     * tags.has('player'); // player
     * @example
     * tags.has('mob', 'player'); // player OR mob
     * @example
     * tags.has(['level-1', 'mob']); // monster AND level-1
     * @example
     * tags.has(['ui', 'settings'], ['ui', 'levels']); // (ui AND settings) OR (ui AND levels)
     */
    has(...args: any[]): boolean;
    /**
     * @param {string[]|string[][]} tags - Array of tags.
     * @returns {boolean} True if the supplied tags are present.
     * @private
     */
    private _has;
    /**
     * Returns immutable array of tags.
     *
     * @returns {string[]} Copy of tags array.
     */
    list(): string[];
    /**
     * @param {IArguments} args - Arguments to process.
     * @param {boolean} [flat] - If true, will flatten array of tags. Defaults to false.
     * @returns {string[]|string[][]} Array of tags.
     * @private
     */
    private _processArguments;
    /**
     * Number of tags in set.
     *
     * @type {number}
     */
    get size(): number;
}

/**
 * A linear interpolation scheme.
 *
 * @type {number}
 */
declare const CURVE_LINEAR: number;
/**
 * A smooth step interpolation scheme.
 *
 * @type {number}
 */
declare const CURVE_SMOOTHSTEP: number;
/**
 * A Catmull-Rom spline interpolation scheme. This interpolation scheme is deprecated. Use
 * CURVE_SPLINE instead.
 *
 * @type {number}
 * @deprecated
 * @ignore
 */
declare const CURVE_CATMULL: number;
/**
 * A cardinal spline interpolation scheme. This interpolation scheme is deprecated. Use
 * CURVE_SPLINE instead.
 *
 * @type {number}
 * @deprecated
 * @ignore
 */
declare const CURVE_CARDINAL: number;
/**
 * Cardinal spline interpolation scheme. For Catmull-Rom, specify curve tension 0.5.
 *
 * @type {number}
 */
declare const CURVE_SPLINE: number;
/**
 * A stepped interpolator, free from the shackles of blending.
 *
 * @type {number}
 */
declare const CURVE_STEP: number;

/**
 * Ignores the integer part of texture coordinates, using only the fractional part.
 *
 * @type {number}
 */
declare const ADDRESS_REPEAT: number;
/**
 * Clamps texture coordinate to the range 0 to 1.
 *
 * @type {number}
 */
declare const ADDRESS_CLAMP_TO_EDGE: number;
/**
 * Texture coordinate to be set to the fractional part if the integer part is even. If the integer
 * part is odd, then the texture coordinate is set to 1 minus the fractional part.
 *
 * @type {number}
 */
declare const ADDRESS_MIRRORED_REPEAT: number;
/**
 * Multiply all fragment components by zero.
 *
 * @type {number}
 */
declare const BLENDMODE_ZERO: number;
/**
 * Multiply all fragment components by one.
 *
 * @type {number}
 */
declare const BLENDMODE_ONE: number;
/**
 * Multiply all fragment components by the components of the source fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_SRC_COLOR: number;
/**
 * Multiply all fragment components by one minus the components of the source fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_ONE_MINUS_SRC_COLOR: number;
/**
 * Multiply all fragment components by the components of the destination fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_DST_COLOR: number;
/**
 * Multiply all fragment components by one minus the components of the destination fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_ONE_MINUS_DST_COLOR: number;
/**
 * Multiply all fragment components by the alpha value of the source fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_SRC_ALPHA: number;
/**
 * Multiply all fragment components by the alpha value of the source fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_SRC_ALPHA_SATURATE: number;
/**
 * Multiply all fragment components by one minus the alpha value of the source fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_ONE_MINUS_SRC_ALPHA: number;
/**
 * Multiply all fragment components by the alpha value of the destination fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_DST_ALPHA: number;
/**
 * Multiply all fragment components by one minus the alpha value of the destination fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_ONE_MINUS_DST_ALPHA: number;
/**
 * Add the results of the source and destination fragment multiplies.
 *
 * @type {number}
 */
declare const BLENDEQUATION_ADD: number;
/**
 * Subtract the results of the source and destination fragment multiplies.
 *
 * @type {number}
 */
declare const BLENDEQUATION_SUBTRACT: number;
/**
 * Reverse and subtract the results of the source and destination fragment multiplies.
 *
 * @type {number}
 */
declare const BLENDEQUATION_REVERSE_SUBTRACT: number;
/**
 * Use the smallest value. Check app.graphicsDevice.extBlendMinmax for support.
 *
 * @type {number}
 */
declare const BLENDEQUATION_MIN: number;
/**
 * Use the largest value. Check app.graphicsDevice.extBlendMinmax for support.
 *
 * @type {number}
 */
declare const BLENDEQUATION_MAX: number;
/**
 * The data store contents will be modified once and used many times.
 *
 * @type {number}
 */
declare const BUFFER_STATIC: number;
/**
 * The data store contents will be modified repeatedly and used many times.
 *
 * @type {number}
 */
declare const BUFFER_DYNAMIC: number;
/**
 * The data store contents will be modified once and used at most a few times.
 *
 * @type {number}
 */
declare const BUFFER_STREAM: number;
/**
 * The data store contents will be modified repeatedly on the GPU and used many times. Optimal for
 * transform feedback usage (WebGL2 only).
 *
 * @type {number}
 */
declare const BUFFER_GPUDYNAMIC: number;
/**
 * Clear the color buffer.
 *
 * @type {number}
 */
declare const CLEARFLAG_COLOR: number;
/**
 * Clear the depth buffer.
 *
 * @type {number}
 */
declare const CLEARFLAG_DEPTH: number;
/**
 * Clear the stencil buffer.
 *
 * @type {number}
 */
declare const CLEARFLAG_STENCIL: number;
/**
 * The positive X face of a cubemap.
 *
 * @type {number}
 */
declare const CUBEFACE_POSX: number;
/**
 * The negative X face of a cubemap.
 *
 * @type {number}
 */
declare const CUBEFACE_NEGX: number;
/**
 * The positive Y face of a cubemap.
 *
 * @type {number}
 */
declare const CUBEFACE_POSY: number;
/**
 * The negative Y face of a cubemap.
 *
 * @type {number}
 */
declare const CUBEFACE_NEGY: number;
/**
 * The positive Z face of a cubemap.
 *
 * @type {number}
 */
declare const CUBEFACE_POSZ: number;
/**
 * The negative Z face of a cubemap.
 *
 * @type {number}
 */
declare const CUBEFACE_NEGZ: number;
/**
 * No triangles are culled.
 *
 * @type {number}
 */
declare const CULLFACE_NONE: number;
/**
 * Triangles facing away from the view direction are culled.
 *
 * @type {number}
 */
declare const CULLFACE_BACK: number;
/**
 * Triangles facing the view direction are culled.
 *
 * @type {number}
 */
declare const CULLFACE_FRONT: number;
/**
 * Triangles are culled regardless of their orientation with respect to the view direction. Note
 * that point or line primitives are unaffected by this render state.
 *
 * @type {number}
 */
declare const CULLFACE_FRONTANDBACK: number;
/**
 * Point sample filtering.
 *
 * @type {number}
 */
declare const FILTER_NEAREST: number;
/**
 * Bilinear filtering.
 *
 * @type {number}
 */
declare const FILTER_LINEAR: number;
/**
 * Use the nearest neighbor in the nearest mipmap level.
 *
 * @type {number}
 */
declare const FILTER_NEAREST_MIPMAP_NEAREST: number;
/**
 * Linearly interpolate in the nearest mipmap level.
 *
 * @type {number}
 */
declare const FILTER_NEAREST_MIPMAP_LINEAR: number;
/**
 * Use the nearest neighbor after linearly interpolating between mipmap levels.
 *
 * @type {number}
 */
declare const FILTER_LINEAR_MIPMAP_NEAREST: number;
/**
 * Linearly interpolate both the mipmap levels and between texels.
 *
 * @type {number}
 */
declare const FILTER_LINEAR_MIPMAP_LINEAR: number;
/**
 * Never pass.
 *
 * @type {number}
 */
declare const FUNC_NEVER: number;
/**
 * Pass if (ref & mask) < (stencil & mask).
 *
 * @type {number}
 */
declare const FUNC_LESS: number;
/**
 * Pass if (ref & mask) == (stencil & mask).
 *
 * @type {number}
 */
declare const FUNC_EQUAL: number;
/**
 * Pass if (ref & mask) <= (stencil & mask).
 *
 * @type {number}
 */
declare const FUNC_LESSEQUAL: number;
/**
 * Pass if (ref & mask) > (stencil & mask).
 *
 * @type {number}
 */
declare const FUNC_GREATER: number;
/**
 * Pass if (ref & mask) != (stencil & mask).
 *
 * @type {number}
 */
declare const FUNC_NOTEQUAL: number;
/**
 * Pass if (ref & mask) >= (stencil & mask).
 *
 * @type {number}
 */
declare const FUNC_GREATEREQUAL: number;
/**
 * Always pass.
 *
 * @type {number}
 */
declare const FUNC_ALWAYS: number;
/**
 * 8-bit unsigned vertex indices (0 to 255).
 *
 * @type {number}
 */
declare const INDEXFORMAT_UINT8: number;
/**
 * 16-bit unsigned vertex indices (0 to 65,535).
 *
 * @type {number}
 */
declare const INDEXFORMAT_UINT16: number;
/**
 * 32-bit unsigned vertex indices (0 to 4,294,967,295).
 *
 * @type {number}
 */
declare const INDEXFORMAT_UINT32: number;
/**
 * 8-bit alpha.
 *
 * @type {number}
 */
declare const PIXELFORMAT_A8: number;
/**
 * 8-bit luminance.
 *
 * @type {number}
 */
declare const PIXELFORMAT_L8: number;
/**
 * 8-bit luminance with 8-bit alpha.
 *
 * @type {number}
 */
declare const PIXELFORMAT_L8_A8: number;
/**
 * 16-bit RGB (5-bits for red channel, 6 for green and 5 for blue).
 *
 * @type {number}
 */
declare const PIXELFORMAT_R5_G6_B5: number;
/**
 * 16-bit RGBA (5-bits for red channel, 5 for green, 5 for blue with 1-bit alpha).
 *
 * @type {number}
 */
declare const PIXELFORMAT_R5_G5_B5_A1: number;
/**
 * 16-bit RGBA (4-bits for red channel, 4 for green, 4 for blue with 4-bit alpha).
 *
 * @type {number}
 */
declare const PIXELFORMAT_R4_G4_B4_A4: number;
/**
 * 24-bit RGB (8-bits for red channel, 8 for green and 8 for blue).
 *
 * @type {number}
 */
declare const PIXELFORMAT_R8_G8_B8: number;
/**
 * 32-bit RGBA (8-bits for red channel, 8 for green, 8 for blue with 8-bit alpha).
 *
 * @type {number}
 */
declare const PIXELFORMAT_R8_G8_B8_A8: number;
/**
 * Block compressed format storing 16 input pixels in 64 bits of output, consisting of two 16-bit
 * RGB 5:6:5 color values and a 4x4 two bit lookup table.
 *
 * @type {number}
 */
declare const PIXELFORMAT_DXT1: number;
/**
 * Block compressed format storing 16 input pixels (corresponding to a 4x4 pixel block) into 128
 * bits of output, consisting of 64 bits of alpha channel data (4 bits for each pixel) followed by
 * 64 bits of color data; encoded the same way as DXT1.
 *
 * @type {number}
 */
declare const PIXELFORMAT_DXT3: number;
/**
 * Block compressed format storing 16 input pixels into 128 bits of output, consisting of 64 bits
 * of alpha channel data (two 8 bit alpha values and a 4x4 3 bit lookup table) followed by 64 bits
 * of color data (encoded the same way as DXT1).
 *
 * @type {number}
 */
declare const PIXELFORMAT_DXT5: number;
/**
 * 16-bit floating point RGB (16-bit float for each red, green and blue channels).
 *
 * @type {number}
 */
declare const PIXELFORMAT_RGB16F: number;
/**
 * 16-bit floating point RGBA (16-bit float for each red, green, blue and alpha channels).
 *
 * @type {number}
 */
declare const PIXELFORMAT_RGBA16F: number;
/**
 * 32-bit floating point RGB (32-bit float for each red, green and blue channels).
 *
 * @type {number}
 */
declare const PIXELFORMAT_RGB32F: number;
/**
 * 32-bit floating point RGBA (32-bit float for each red, green, blue and alpha channels).
 *
 * @type {number}
 */
declare const PIXELFORMAT_RGBA32F: number;
/**
 * 32-bit floating point single channel format (WebGL2 only).
 *
 * @type {number}
 */
declare const PIXELFORMAT_R32F: number;
/**
 * A readable depth buffer format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_DEPTH: number;
/**
 * A readable depth/stencil buffer format (WebGL2 only).
 *
 * @type {number}
 */
declare const PIXELFORMAT_DEPTHSTENCIL: number;
/**
 * A floating-point color-only format with 11 bits for red and green channels and 10 bits for the
 * blue channel (WebGL2 only).
 *
 * @type {number}
 */
declare const PIXELFORMAT_111110F: number;
/**
 * Color-only sRGB format (WebGL2 only).
 *
 * @type {number}
 */
declare const PIXELFORMAT_SRGB: number;
/**
 * Color sRGB format with additional alpha channel (WebGL2 only).
 *
 * @type {number}
 */
declare const PIXELFORMAT_SRGBA: number;
/**
 * ETC1 compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_ETC1: number;
/**
 * ETC2 (RGB) compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_ETC2_RGB: number;
/**
 * ETC2 (RGBA) compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_ETC2_RGBA: number;
/**
 * PVRTC (2BPP RGB) compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_PVRTC_2BPP_RGB_1: number;
/**
 * PVRTC (2BPP RGBA) compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_PVRTC_2BPP_RGBA_1: number;
/**
 * PVRTC (4BPP RGB) compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_PVRTC_4BPP_RGB_1: number;
/**
 * PVRTC (4BPP RGBA) compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_PVRTC_4BPP_RGBA_1: number;
/**
 * ATC compressed format with alpha channel in blocks of 4x4.
 *
 * @type {number}
 */
declare const PIXELFORMAT_ASTC_4x4: number;
/**
 * ATC compressed format with no alpha channel.
 *
 * @type {number}
 */
declare const PIXELFORMAT_ATC_RGB: number;
/**
 * ATC compressed format with alpha channel.
 *
 * @type {number}
 */
declare const PIXELFORMAT_ATC_RGBA: number;
/**
 * List of distinct points.
 *
 * @type {number}
 */
declare const PRIMITIVE_POINTS: number;
/**
 * Discrete list of line segments.
 *
 * @type {number}
 */
declare const PRIMITIVE_LINES: number;
/**
 * List of points that are linked sequentially by line segments, with a closing line segment
 * between the last and first points.
 *
 * @type {number}
 */
declare const PRIMITIVE_LINELOOP: number;
/**
 * List of points that are linked sequentially by line segments.
 *
 * @type {number}
 */
declare const PRIMITIVE_LINESTRIP: number;
/**
 * Discrete list of triangles.
 *
 * @type {number}
 */
declare const PRIMITIVE_TRIANGLES: number;
/**
 * Connected strip of triangles where a specified vertex forms a triangle using the previous two.
 *
 * @type {number}
 */
declare const PRIMITIVE_TRISTRIP: number;
/**
 * Connected fan of triangles where the first vertex forms triangles with the following pairs of vertices.
 *
 * @type {number}
 */
declare const PRIMITIVE_TRIFAN: number;
/**
 * Vertex attribute to be treated as a position.
 *
 * @type {string}
 */
declare const SEMANTIC_POSITION: string;
/**
 * Vertex attribute to be treated as a normal.
 *
 * @type {string}
 */
declare const SEMANTIC_NORMAL: string;
/**
 * Vertex attribute to be treated as a tangent.
 *
 * @type {string}
 */
declare const SEMANTIC_TANGENT: string;
/**
 * Vertex attribute to be treated as skin blend weights.
 *
 * @type {string}
 */
declare const SEMANTIC_BLENDWEIGHT: string;
/**
 * Vertex attribute to be treated as skin blend indices.
 *
 * @type {string}
 */
declare const SEMANTIC_BLENDINDICES: string;
/**
 * Vertex attribute to be treated as a color.
 *
 * @type {string}
 */
declare const SEMANTIC_COLOR: string;
declare const SEMANTIC_TEXCOORD: "TEXCOORD";
/**
 * Vertex attribute to be treated as a texture coordinate (set 0).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD0: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 1).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD1: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 2).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD2: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 3).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD3: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 4).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD4: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 5).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD5: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 6).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD6: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 7).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD7: string;
declare const SEMANTIC_ATTR: "ATTR";
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR0: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR1: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR2: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR3: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR4: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR5: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR6: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR7: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR8: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR9: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR10: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR11: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR12: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR13: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR14: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR15: string;
declare const SHADERTAG_MATERIAL: 1;
/**
 * Don't change the stencil buffer value.
 *
 * @type {number}
 */
declare const STENCILOP_KEEP: number;
/**
 * Set value to zero.
 *
 * @type {number}
 */
declare const STENCILOP_ZERO: number;
/**
 * Replace value with the reference value (see {@link GraphicsDevice#setStencilFunc}).
 *
 * @type {number}
 */
declare const STENCILOP_REPLACE: number;
/**
 * Increment the value.
 *
 * @type {number}
 */
declare const STENCILOP_INCREMENT: number;
/**
 * Increment the value but wrap it to zero when it's larger than a maximum representable value.
 *
 * @type {number}
 */
declare const STENCILOP_INCREMENTWRAP: number;
/**
 * Decrement the value.
 *
 * @type {number}
 */
declare const STENCILOP_DECREMENT: number;
/**
 * Decrement the value but wrap it to a maximum representable value if the current value is 0.
 *
 * @type {number}
 */
declare const STENCILOP_DECREMENTWRAP: number;
/**
 * Invert the value bitwise.
 *
 * @type {number}
 */
declare const STENCILOP_INVERT: number;
/**
 * Read only. Any changes to the locked mip level's pixels will not update the texture.
 *
 * @type {number}
 */
declare const TEXTURELOCK_READ: number;
/**
 * Write only. The contents of the specified mip level will be entirely replaced.
 *
 * @type {number}
 */
declare const TEXTURELOCK_WRITE: number;
/**
 * Texture is a default type.
 *
 * @type {string}
 */
declare const TEXTURETYPE_DEFAULT: string;
/**
 * Texture stores high dynamic range data in RGBM format.
 *
 * @type {string}
 */
declare const TEXTURETYPE_RGBM: string;
/**
 * Texture stores high dynamic range data in RGBE format.
 *
 * @type {string}
 */
declare const TEXTURETYPE_RGBE: string;
/**
 * Texture stores normalmap data swizzled in GGGR format. This is used for tangent space normal
 * maps. The R component is stored in alpha and G is stored in RGB. This packing can result in
 * higher quality when the texture data is compressed.
 *
 * @type {string}
 */
declare const TEXTURETYPE_SWIZZLEGGGR: string;
declare const TEXHINT_NONE: 0;
declare const TEXHINT_SHADOWMAP: 1;
declare const TEXHINT_ASSET: 2;
declare const TEXHINT_LIGHTMAP: 3;
/**
 * Texture data is not stored a specific projection format.
 *
 * @type {string}
 */
declare const TEXTUREPROJECTION_NONE: string;
/**
 * Texture data is stored in cubemap projection format.
 *
 * @type {string}
 */
declare const TEXTUREPROJECTION_CUBE: string;
/**
 * Texture data is stored in equirectangular projection format.
 *
 * @type {string}
 */
declare const TEXTUREPROJECTION_EQUIRECT: string;
/**
 * Texture data is stored in octahedral projection format.
 *
 * @type {string}
 */
declare const TEXTUREPROJECTION_OCTAHEDRAL: string;
/**
 * Signed byte vertex element type.
 *
 * @type {number}
 */
declare const TYPE_INT8: number;
/**
 * Unsigned byte vertex element type.
 *
 * @type {number}
 */
declare const TYPE_UINT8: number;
/**
 * Signed short vertex element type.
 *
 * @type {number}
 */
declare const TYPE_INT16: number;
/**
 * Unsigned short vertex element type.
 *
 * @type {number}
 */
declare const TYPE_UINT16: number;
/**
 * Signed integer vertex element type.
 *
 * @type {number}
 */
declare const TYPE_INT32: number;
/**
 * Unsigned integer vertex element type.
 *
 * @type {number}
 */
declare const TYPE_UINT32: number;
/**
 * Floating point vertex element type.
 *
 * @type {number}
 */
declare const TYPE_FLOAT32: number;
declare const UNIFORMTYPE_BOOL: 0;
declare const UNIFORMTYPE_INT: 1;
declare const UNIFORMTYPE_FLOAT: 2;
declare const UNIFORMTYPE_VEC2: 3;
declare const UNIFORMTYPE_VEC3: 4;
declare const UNIFORMTYPE_VEC4: 5;
declare const UNIFORMTYPE_IVEC2: 6;
declare const UNIFORMTYPE_IVEC3: 7;
declare const UNIFORMTYPE_IVEC4: 8;
declare const UNIFORMTYPE_BVEC2: 9;
declare const UNIFORMTYPE_BVEC3: 10;
declare const UNIFORMTYPE_BVEC4: 11;
declare const UNIFORMTYPE_MAT2: 12;
declare const UNIFORMTYPE_MAT3: 13;
declare const UNIFORMTYPE_MAT4: 14;
declare const UNIFORMTYPE_TEXTURE2D: 15;
declare const UNIFORMTYPE_TEXTURECUBE: 16;
declare const UNIFORMTYPE_FLOATARRAY: 17;
declare const UNIFORMTYPE_TEXTURE2D_SHADOW: 18;
declare const UNIFORMTYPE_TEXTURECUBE_SHADOW: 19;
declare const UNIFORMTYPE_TEXTURE3D: 20;
declare const UNIFORMTYPE_VEC2ARRAY: 21;
declare const UNIFORMTYPE_VEC3ARRAY: 22;
declare const UNIFORMTYPE_VEC4ARRAY: 23;
declare const typedArrayTypes: (Int8ArrayConstructor | Uint8ArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor)[];
declare const typedArrayTypesByteSize: number[];
declare namespace typedArrayToType {
    export { TYPE_INT8 as Int8Array };
    export { TYPE_UINT8 as Uint8Array };
    export { TYPE_INT16 as Int16Array };
    export { TYPE_UINT16 as Uint16Array };
    export { TYPE_INT32 as Int32Array };
    export { TYPE_UINT32 as Uint32Array };
    export { TYPE_FLOAT32 as Float32Array };
}
declare const typedArrayIndexFormats: (Uint8ArrayConstructor | Uint16ArrayConstructor | Uint32ArrayConstructor)[];
declare const typedArrayIndexFormatsByteSize: number[];
/**
 * Map of engine semantics into location on device in range 0..15 (note - semantics mapping to the
 * same location cannot be used at the same time) organized in a way that ATTR0-ATTR7 do not
 * overlap with common important semantics.
 *
 * @type {object}
 * @ignore
 */
declare const semanticToLocation: object;

/**
 * Subtract the color of the source fragment from the destination fragment and write the result to
 * the frame buffer.
 *
 * @type {number}
 */
declare const BLEND_SUBTRACTIVE: number;
/**
 * Add the color of the source fragment to the destination fragment and write the result to the
 * frame buffer.
 *
 * @type {number}
 */
declare const BLEND_ADDITIVE: number;
/**
 * Enable simple translucency for materials such as glass. This is equivalent to enabling a source
 * blend mode of {@link BLENDMODE_SRC_ALPHA} and a destination blend mode of
 * {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.
 *
 * @type {number}
 */
declare const BLEND_NORMAL: number;
/**
 * Disable blending.
 *
 * @type {number}
 */
declare const BLEND_NONE: number;
/**
 * Similar to {@link BLEND_NORMAL} expect the source fragment is assumed to have already been
 * multiplied by the source alpha value.
 *
 * @type {number}
 */
declare const BLEND_PREMULTIPLIED: number;
/**
 * Multiply the color of the source fragment by the color of the destination fragment and write the
 * result to the frame buffer.
 *
 * @type {number}
 */
declare const BLEND_MULTIPLICATIVE: number;
/**
 * Same as {@link BLEND_ADDITIVE} except the source RGB is multiplied by the source alpha.
 *
 * @type {number}
 */
declare const BLEND_ADDITIVEALPHA: number;
/**
 * Multiplies colors and doubles the result.
 *
 * @type {number}
 */
declare const BLEND_MULTIPLICATIVE2X: number;
/**
 * Softer version of additive.
 *
 * @type {number}
 */
declare const BLEND_SCREEN: number;
/**
 * Minimum color. Check app.graphicsDevice.extBlendMinmax for support.
 *
 * @type {number}
 */
declare const BLEND_MIN: number;
/**
 * Maximum color. Check app.graphicsDevice.extBlendMinmax for support.
 *
 * @type {number}
 */
declare const BLEND_MAX: number;
/**
 * No fog is applied to the scene.
 *
 * @type {string}
 */
declare const FOG_NONE: string;
/**
 * Fog rises linearly from zero to 1 between a start and end depth.
 *
 * @type {string}
 */
declare const FOG_LINEAR: string;
/**
 * Fog rises according to an exponential curve controlled by a density value.
 *
 * @type {string}
 */
declare const FOG_EXP: string;
/**
 * Fog rises according to an exponential curve controlled by a density value.
 *
 * @type {string}
 */
declare const FOG_EXP2: string;
/**
 * No Fresnel.
 *
 * @type {number}
 */
declare const FRESNEL_NONE: number;
/**
 * Schlick's approximation of Fresnel.
 *
 * @type {number}
 */
declare const FRESNEL_SCHLICK: number;
declare const LAYER_HUD: 0;
declare const LAYER_GIZMO: 1;
declare const LAYER_FX: 2;
declare const LAYER_WORLD: 15;
/**
 * The world layer.
 *
 * @type {number}
 */
declare const LAYERID_WORLD: number;
/**
 * The depth layer.
 *
 * @type {number}
 */
declare const LAYERID_DEPTH: number;
/**
 * The skybox layer.
 *
 * @type {number}
 */
declare const LAYERID_SKYBOX: number;
/**
 * The immediate layer.
 *
 * @type {number}
 */
declare const LAYERID_IMMEDIATE: number;
/**
 * The UI layer.
 *
 * @type {number}
 */
declare const LAYERID_UI: number;
/**
 * Directional (global) light source.
 *
 * @type {number}
 */
declare const LIGHTTYPE_DIRECTIONAL: number;
/**
 * Omni-directional (local) light source.
 *
 * @type {number}
 */
declare const LIGHTTYPE_OMNI: number;
/**
 * Point (local) light source.
 *
 * @type {number}
 * @ignore
 */
declare const LIGHTTYPE_POINT: number;
/**
 * Spot (local) light source.
 *
 * @type {number}
 */
declare const LIGHTTYPE_SPOT: number;
/**
 * Infinitesimally small point light source shape.
 *
 * @type {number}
 */
declare const LIGHTSHAPE_PUNCTUAL: number;
/**
 * Rectangle shape of light source.
 *
 * @type {number}
 */
declare const LIGHTSHAPE_RECT: number;
/**
 * Disk shape of light source.
 *
 * @type {number}
 */
declare const LIGHTSHAPE_DISK: number;
/**
 * Sphere shape of light source.
 *
 * @type {number}
 */
declare const LIGHTSHAPE_SPHERE: number;
/**
 * Linear distance falloff model for light attenuation.
 *
 * @type {number}
 */
declare const LIGHTFALLOFF_LINEAR: number;
/**
 * Inverse squared distance falloff model for light attenuation.
 *
 * @type {number}
 */
declare const LIGHTFALLOFF_INVERSESQUARED: number;
/**
 * Render depth (color-packed on WebGL 1.0), can be used for PCF 3x3 sampling.
 *
 * @type {number}
 */
declare const SHADOW_PCF3: number;
declare const SHADOW_DEPTH: 0;
/**
 * Render packed variance shadow map. All shadow receivers must also cast shadows for this mode to
 * work correctly.
 *
 * @type {number}
 */
declare const SHADOW_VSM8: number;
/**
 * Render 16-bit exponential variance shadow map. Requires OES_texture_half_float extension. Falls
 * back to {@link SHADOW_VSM8}, if not supported.
 *
 * @type {number}
 */
declare const SHADOW_VSM16: number;
/**
 * Render 32-bit exponential variance shadow map. Requires OES_texture_float extension. Falls back
 * to {@link SHADOW_VSM16}, if not supported.
 *
 * @type {number}
 */
declare const SHADOW_VSM32: number;
/**
 * Render depth buffer only, can be used for hardware-accelerated PCF 5x5 sampling. Requires
 * WebGL 2. Falls back to {@link SHADOW_PCF3} on WebGL 1.
 *
 * @type {number}
 */
declare const SHADOW_PCF5: number;
/**
 * Render depth (color-packed on WebGL 1.0), can be used for PCF 1x1 sampling.
 *
 * @type {number}
 */
declare const SHADOW_PCF1: number;
declare const SHADOW_COUNT: 6;
/**
 * map of engine SHADOW__*** to a string representation
 *
 * @type {object}
 * @ignore
 */
declare const shadowTypeToString: object;
/**
 * Box filter.
 *
 * @type {number}
 */
declare const BLUR_BOX: number;
/**
 * Gaussian filter. May look smoother than box, but requires more samples.
 *
 * @type {number}
 */
declare const BLUR_GAUSSIAN: number;
/**
 * No sorting, particles are drawn in arbitrary order. Can be simulated on GPU.
 *
 * @type {number}
 */
declare const PARTICLESORT_NONE: number;
/**
 * Sorting based on distance to the camera. CPU only.
 *
 * @type {number}
 */
declare const PARTICLESORT_DISTANCE: number;
/**
 * Newer particles are drawn first. CPU only.
 *
 * @type {number}
 */
declare const PARTICLESORT_NEWER_FIRST: number;
/**
 * Older particles are drawn first. CPU only.
 *
 * @type {number}
 */
declare const PARTICLESORT_OLDER_FIRST: number;
declare const PARTICLEMODE_GPU: 0;
declare const PARTICLEMODE_CPU: 1;
/**
 * Box shape parameterized by emitterExtents. Initial velocity is directed towards local Z axis.
 *
 * @type {number}
 */
declare const EMITTERSHAPE_BOX: number;
/**
 * Sphere shape parameterized by emitterRadius. Initial velocity is directed outwards from the
 * center.
 *
 * @type {number}
 */
declare const EMITTERSHAPE_SPHERE: number;
/**
 * Particles are facing camera.
 *
 * @type {number}
 */
declare const PARTICLEORIENTATION_SCREEN: number;
/**
 * User defines world space normal (particleNormal) to set planes orientation.
 *
 * @type {number}
 */
declare const PARTICLEORIENTATION_WORLD: number;
/**
 * Similar to previous, but the normal is affected by emitter(entity) transformation.
 *
 * @type {number}
 */
declare const PARTICLEORIENTATION_EMITTER: number;
/**
 * A perspective camera projection where the frustum shape is essentially pyramidal.
 *
 * @type {number}
 */
declare const PROJECTION_PERSPECTIVE: number;
/**
 * An orthographic camera projection where the frustum shape is essentially a cuboid.
 *
 * @type {number}
 */
declare const PROJECTION_ORTHOGRAPHIC: number;
/**
 * Render mesh instance as solid geometry.
 *
 * @type {number}
 */
declare const RENDERSTYLE_SOLID: number;
/**
 * Render mesh instance as wireframe.
 *
 * @type {number}
 */
declare const RENDERSTYLE_WIREFRAME: number;
/**
 * Render mesh instance as points.
 *
 * @type {number}
 */
declare const RENDERSTYLE_POINTS: number;
/**
 * The cube map is treated as if it is infinitely far away.
 *
 * @type {number}
 */
declare const CUBEPROJ_NONE: number;
/**
 * The cube map is box-projected based on a world space axis-aligned bounding box.
 *
 * @type {number}
 */
declare const CUBEPROJ_BOX: number;
/**
 * Phong without energy conservation. You should only use it as a backwards compatibility with
 * older projects.
 *
 * @type {number}
 */
declare const SPECULAR_PHONG: number;
/**
 * Energy-conserving Blinn-Phong.
 *
 * @type {number}
 */
declare const SPECULAR_BLINN: number;
/**
 * Multiply together the primary and secondary colors.
 *
 * @type {string}
 */
declare const DETAILMODE_MUL: string;
/**
 * Add together the primary and secondary colors.
 *
 * @type {string}
 */
declare const DETAILMODE_ADD: string;
/**
 * Softer version of {@link DETAILMODE_ADD}.
 *
 * @name DETAILMODE_SCREEN
 */
declare const DETAILMODE_SCREEN: "screen";
/**
 * Multiplies or screens the colors, depending on the primary color.
 *
 * @type {string}
 */
declare const DETAILMODE_OVERLAY: string;
/**
 * Select whichever of the primary and secondary colors is darker, component-wise.
 *
 * @type {string}
 */
declare const DETAILMODE_MIN: string;
/**
 * Select whichever of the primary and secondary colors is lighter, component-wise.
 *
 * @type {string}
 */
declare const DETAILMODE_MAX: string;
/**
 * No gamma correction.
 *
 * @type {number}
 */
declare const GAMMA_NONE: number;
/**
 * Apply sRGB gamma correction.
 *
 * @type {number}
 */
declare const GAMMA_SRGB: number;
/**
 * Apply sRGB (fast) gamma correction.
 *
 * @type {number}
 * @deprecated
 * @ignore
 */
declare const GAMMA_SRGBFAST: number;
/**
 * Apply sRGB (HDR) gamma correction.
 *
 * @type {number}
 */
declare const GAMMA_SRGBHDR: number;
/**
 * Linear tonemapping.
 *
 * @type {number}
 */
declare const TONEMAP_LINEAR: number;
/**
 * Filmic tonemapping curve.
 *
 * @type {number}
 */
declare const TONEMAP_FILMIC: number;
/**
 * Hejl filmic tonemapping curve.
 *
 * @type {number}
 */
declare const TONEMAP_HEJL: number;
/**
 * ACES filmic tonemapping curve.
 *
 * @type {number}
 */
declare const TONEMAP_ACES: number;
/**
 * ACES v2 filmic tonemapping curve.
 *
 * @type {number}
 */
declare const TONEMAP_ACES2: number;
/**
 * No specular occlusion.
 *
 * @type {number}
 */
declare const SPECOCC_NONE: number;
/**
 * Use AO directly to occlude specular.
 *
 * @type {number}
 */
declare const SPECOCC_AO: number;
/**
 * Modify AO based on material glossiness/view angle to occlude specular.
 *
 * @type {number}
 */
declare const SPECOCC_GLOSSDEPENDENT: number;
declare const SHADERDEF_NOSHADOW: 1;
declare const SHADERDEF_SKIN: 2;
declare const SHADERDEF_UV0: 4;
declare const SHADERDEF_UV1: 8;
declare const SHADERDEF_VCOLOR: 16;
declare const SHADERDEF_INSTANCING: 32;
declare const SHADERDEF_LM: 64;
declare const SHADERDEF_DIRLM: 128;
declare const SHADERDEF_SCREENSPACE: 256;
declare const SHADERDEF_TANGENTS: 512;
declare const SHADERDEF_MORPH_POSITION: 1024;
declare const SHADERDEF_MORPH_NORMAL: 2048;
declare const SHADERDEF_MORPH_TEXTURE_BASED: 4096;
declare const SHADERDEF_LMAMBIENT: 8192;
declare const LINEBATCH_WORLD: 0;
declare const LINEBATCH_OVERLAY: 1;
declare const LINEBATCH_GIZMO: 2;
/**
 * The shadow map is not to be updated.
 *
 * @type {number}
 */
declare const SHADOWUPDATE_NONE: number;
/**
 * The shadow map is regenerated this frame and not on subsequent frames.
 *
 * @type {number}
 */
declare const SHADOWUPDATE_THISFRAME: number;
/**
 * The shadow map is regenerated every frame.
 *
 * @type {number}
 */
declare const SHADOWUPDATE_REALTIME: number;
declare const SORTKEY_FORWARD: 0;
declare const SORTKEY_DEPTH: 1;
declare const MASK_AFFECT_DYNAMIC: 1;
declare const MASK_AFFECT_LIGHTMAPPED: 2;
declare const MASK_BAKE: 4;
/**
 * Render shaded materials with gamma correction and tonemapping.
 *
 * @type {number}
 */
declare const SHADER_FORWARD: number;
/**
 * Render shaded materials without gamma correction and tonemapping.
 *
 * @type {number}
 */
declare const SHADER_FORWARDHDR: number;
/**
 * Render RGBA-encoded depth value.
 *
 * @type {number}
 */
declare const SHADER_DEPTH: number;
declare const SHADER_SHADOW: 3;
declare const SHADER_PICK: 18;
/**
 * This mode renders a sprite as a simple quad.
 *
 * @type {number}
 */
declare const SPRITE_RENDERMODE_SIMPLE: number;
/**
 * This mode renders a sprite using 9-slicing in 'sliced' mode. Sliced mode stretches the top and
 * bottom regions of the sprite horizontally, the left and right regions vertically and the middle
 * region both horizontally and vertically.
 *
 * @type {number}
 */
declare const SPRITE_RENDERMODE_SLICED: number;
/**
 * This mode renders a sprite using 9-slicing in 'tiled' mode. Tiled mode tiles the top and bottom
 * regions of the sprite horizontally, the left and right regions vertically and the middle region
 * both horizontally and vertically.
 *
 * @type {number}
 */
declare const SPRITE_RENDERMODE_TILED: number;
/**
 * Single color lightmap.
 *
 * @type {number}
 */
declare const BAKE_COLOR: number;
/**
 * Single color lightmap + dominant light direction (used for bump/specular).
 *
 * @type {number}
 */
declare const BAKE_COLORDIR: number;
/**
 * Center of view.
 *
 * @type {number}
 */
declare const VIEW_CENTER: number;
/**
 * Left of view. Only used in stereo rendering.
 *
 * @type {number}
 */
declare const VIEW_LEFT: number;
/**
 * Right of view. Only used in stereo rendering.
 *
 * @type {number}
 */
declare const VIEW_RIGHT: number;
/**
 * No sorting is applied. Mesh instances are rendered in the same order they were added to a layer.
 *
 * @type {number}
 */
declare const SORTMODE_NONE: number;
/**
 * Mesh instances are sorted based on {@link MeshInstance#drawOrder}.
 *
 * @type {number}
 */
declare const SORTMODE_MANUAL: number;
/**
 * Mesh instances are sorted to minimize switching between materials and meshes to improve
 * rendering performance.
 *
 * @type {number}
 */
declare const SORTMODE_MATERIALMESH: number;
/**
 * Mesh instances are sorted back to front. This is the way to properly render many
 * semi-transparent objects on different depth, one is blended on top of another.
 *
 * @type {number}
 */
declare const SORTMODE_BACK2FRONT: number;
/**
 * Mesh instances are sorted front to back. Depending on GPU and the scene, this option may give
 * better performance than {@link SORTMODE_MATERIALMESH} due to reduced overdraw.
 *
 * @type {number}
 */
declare const SORTMODE_FRONT2BACK: number;
/**
 * Provide custom functions for sorting drawcalls and calculating distance.
 *
 * @type {number}
 * @ignore
 */
declare const SORTMODE_CUSTOM: number;
declare const COMPUPDATED_INSTANCES: 1;
declare const COMPUPDATED_LIGHTS: 2;
declare const COMPUPDATED_CAMERAS: 4;
declare const COMPUPDATED_BLEND: 8;
/**
 * Automatically set aspect ratio to current render target's width divided by height.
 *
 * @type {number}
 */
declare const ASPECT_AUTO: number;
/**
 * Use the manual aspect ratio value.
 *
 * @type {number}
 */
declare const ASPECT_MANUAL: number;
/**
 * Horizontal orientation.
 *
 * @type {number}
 */
declare const ORIENTATION_HORIZONTAL: number;
/**
 * Vertical orientation.
 *
 * @type {number}
 */
declare const ORIENTATION_VERTICAL: number;

/**
 * A stepped interpolation scheme.
 *
 * @type {number}
 * @ignore
 */
declare const INTERPOLATION_STEP: number;
/**
 * A linear interpolation scheme.
 *
 * @type {number}
 * @ignore
 */
declare const INTERPOLATION_LINEAR: number;
/**
 * A cubic spline interpolation scheme.
 *
 * @type {number}
 * @ignore
 */
declare const INTERPOLATION_CUBIC: number;

/**
 * Used to set the anim state graph transition interruption source to no state.
 *
 * @type {string}
 */
declare const ANIM_INTERRUPTION_NONE: string;
/**
 * Used to set the anim state graph transition interruption source as the previous state only.
 *
 * @type {string}
 */
declare const ANIM_INTERRUPTION_PREV: string;
/**
 * Used to set the anim state graph transition interruption source as the next state only.
 *
 * @type {string}
 */
declare const ANIM_INTERRUPTION_NEXT: string;
/**
 * Used to set the anim state graph transition interruption sources as the previous state followed
 * by the next state.
 *
 * @type {string}
 */
declare const ANIM_INTERRUPTION_PREV_NEXT: string;
/**
 * Used to set the anim state graph transition interruption sources as the next state followed by
 * the previous state.
 *
 * @type {string}
 */
declare const ANIM_INTERRUPTION_NEXT_PREV: string;
/**
 * Used to set an anim state graph transition condition predicate as '>'.
 *
 * @type {string}
 */
declare const ANIM_GREATER_THAN: string;
/**
 * Used to set an anim state graph transition condition predicate as '<'.
 *
 * @type {string}
 */
declare const ANIM_LESS_THAN: string;
/**
 * Used to set an anim state graph transition condition predicate as '>='.
 *
 * @type {string}
 */
declare const ANIM_GREATER_THAN_EQUAL_TO: string;
/**
 * Used to set an anim state graph transition condition predicate as '<='.
 *
 * @type {string}
 */
declare const ANIM_LESS_THAN_EQUAL_TO: string;
/**
 * Used to set an anim state graph transition condition predicate as '==='.
 *
 * @type {string}
 */
declare const ANIM_EQUAL_TO: string;
/**
 * Used to set an anim state graph transition condition predicate as '!=='.
 *
 * @type {string}
 */
declare const ANIM_NOT_EQUAL_TO: string;
/**
 * Used to set an anim state graph parameter as type integer.
 *
 * @type {string}
 */
declare const ANIM_PARAMETER_INTEGER: string;
/**
 * Used to set an anim state graph parameter as type float.
 *
 * @type {string}
 */
declare const ANIM_PARAMETER_FLOAT: string;
/**
 * Used to set an anim state graph parameter as type boolean.
 *
 * @type {string}
 */
declare const ANIM_PARAMETER_BOOLEAN: string;
/**
 * Used to set an anim state graph parameter as type trigger.
 *
 * @type {string}
 */
declare const ANIM_PARAMETER_TRIGGER: string;
/**
 * @type {string}
 */
declare const ANIM_BLEND_1D: string;
/**
 * @type {string}
 */
declare const ANIM_BLEND_2D_DIRECTIONAL: string;
/**
 * @type {string}
 */
declare const ANIM_BLEND_2D_CARTESIAN: string;
/**
 * @type {string}
 */
declare const ANIM_BLEND_DIRECT: string;
/**
 * The starting state in an anim state graph layer.
 *
 * @type {string}
 */
declare const ANIM_STATE_START: string;
/**
 * The ending state in an anim state graph layer.
 *
 * @type {string}
 */
declare const ANIM_STATE_END: string;
/**
 * Used to indicate any state in an anim state graph layer.
 *
 * @type {string}
 */
declare const ANIM_STATE_ANY: string;
declare const ANIM_CONTROL_STATES: string[];
/**
 * Used to indicate that a layers animations should overwrite all previous layers.
 *
 * @type {string}
 */
declare const ANIM_LAYER_OVERWRITE: string;
/**
 * Used to indicate that a layers animations should blend additively with previous layers.
 *
 * @type {string}
 */
declare const ANIM_LAYER_ADDITIVE: string;

declare const FONT_MSDF: "msdf";
declare const FONT_BITMAP: "bitmap";

/**
 * Linear distance model.
 *
 * @type {string}
 */
declare const DISTANCE_LINEAR: string;
/**
 * Inverse distance model.
 *
 * @type {string}
 */
declare const DISTANCE_INVERSE: string;
/**
 * Exponential distance model.
 *
 * @type {string}
 */
declare const DISTANCE_EXPONENTIAL: string;

declare const ABSOLUTE_URL: RegExp;
/**
 * Asset type name for animation.
 *
 * @type {string}
 */
declare const ASSET_ANIMATION: string;
/**
 * Asset type name for audio.
 *
 * @type {string}
 */
declare const ASSET_AUDIO: string;
/**
 * Asset type name for image.
 *
 * @type {string}
 */
declare const ASSET_IMAGE: string;
/**
 * Asset type name for json.
 *
 * @type {string}
 */
declare const ASSET_JSON: string;
/**
 * Asset type name for model.
 *
 * @type {string}
 */
declare const ASSET_MODEL: string;
/**
 * Asset type name for material.
 *
 * @type {string}
 */
declare const ASSET_MATERIAL: string;
/**
 * Asset type name for text.
 *
 * @type {string}
 */
declare const ASSET_TEXT: string;
/**
 * Asset type name for texture.
 *
 * @type {string}
 */
declare const ASSET_TEXTURE: string;
/**
 * Asset type name for cubemap.
 *
 * @type {string}
 */
declare const ASSET_CUBEMAP: string;
/**
 * Asset type name for shader.
 *
 * @type {string}
 */
declare const ASSET_SHADER: string;
/**
 * Asset type name for CSS.
 *
 * @type {string}
 */
declare const ASSET_CSS: string;
/**
 * Asset type name for HTML.
 *
 * @type {string}
 */
declare const ASSET_HTML: string;
/**
 * Asset type name for script.
 *
 * @type {string}
 */
declare const ASSET_SCRIPT: string;
/**
 * Asset type name for a container.
 *
 * @type {string}
 */
declare const ASSET_CONTAINER: string;

declare const ACTION_MOUSE: "mouse";
declare const ACTION_KEYBOARD: "keyboard";
declare const ACTION_GAMEPAD: "gamepad";
declare const AXIS_MOUSE_X: "mousex";
declare const AXIS_MOUSE_Y: "mousey";
declare const AXIS_PAD_L_X: "padlx";
declare const AXIS_PAD_L_Y: "padly";
declare const AXIS_PAD_R_X: "padrx";
declare const AXIS_PAD_R_Y: "padry";
declare const AXIS_KEY: "key";
/**
 * Name of event fired when a key is pressed.
 *
 * @type {string}
 */
declare const EVENT_KEYDOWN: string;
/**
 * Name of event fired when a key is released.
 *
 * @type {string}
 */
declare const EVENT_KEYUP: string;
/**
 * Name of event fired when a mouse button is pressed.
 *
 * @type {string}
 */
declare const EVENT_MOUSEDOWN: string;
/**
 * Name of event fired when the mouse is moved.
 *
 * @type {string}
 */
declare const EVENT_MOUSEMOVE: string;
/**
 * Name of event fired when a mouse button is released.
 *
 * @type {string}
 */
declare const EVENT_MOUSEUP: string;
/**
 * Name of event fired when the mouse wheel is rotated.
 *
 * @type {string}
 */
declare const EVENT_MOUSEWHEEL: string;
/**
 * Name of event fired when a new touch occurs. For example, a finger is placed on the device.
 *
 * @type {string}
 */
declare const EVENT_TOUCHSTART: string;
/**
 * Name of event fired when touch ends. For example, a finger is lifted off the device.
 *
 * @type {string}
 */
declare const EVENT_TOUCHEND: string;
/**
 * Name of event fired when a touch moves.
 *
 * @type {string}
 */
declare const EVENT_TOUCHMOVE: string;
/**
 * Name of event fired when a touch point is interrupted in some way. The exact reasons for
 * canceling a touch can vary from device to device. For example, a modal alert pops up during the
 * interaction; the touch point leaves the document area, or there are more touch points than the
 * device supports, in which case the earliest touch point is canceled.
 *
 * @type {string}
 */
declare const EVENT_TOUCHCANCEL: string;
/**
 * Name of event fired when a new xr select occurs. For example, primary trigger was pressed.
 *
 * @type {string}
 */
declare const EVENT_SELECT: string;
/**
 * Name of event fired when a new xr select starts. For example, primary trigger is now pressed.
 *
 * @type {string}
 */
declare const EVENT_SELECTSTART: string;
/**
 * Name of event fired when xr select ends. For example, a primary trigger is now released.
 *
 * @type {string}
 */
declare const EVENT_SELECTEND: string;
/**
 * @type {number}
 */
declare const KEY_BACKSPACE: number;
/**
 * @type {number}
 */
declare const KEY_TAB: number;
/**
 * @type {number}
 */
declare const KEY_RETURN: number;
/**
 * @type {number}
 */
declare const KEY_ENTER: number;
/**
 * @type {number}
 */
declare const KEY_SHIFT: number;
/**
 * @type {number}
 */
declare const KEY_CONTROL: number;
/**
 * @type {number}
 */
declare const KEY_ALT: number;
/**
 * @type {number}
 */
declare const KEY_PAUSE: number;
/**
 * @type {number}
 */
declare const KEY_CAPS_LOCK: number;
/**
 * @type {number}
 */
declare const KEY_ESCAPE: number;
/**
 * @type {number}
 */
declare const KEY_SPACE: number;
/**
 * @type {number}
 */
declare const KEY_PAGE_UP: number;
/**
 * @type {number}
 */
declare const KEY_PAGE_DOWN: number;
/**
 * @type {number}
 */
declare const KEY_END: number;
/**
 * @type {number}
 */
declare const KEY_HOME: number;
/**
 * @type {number}
 */
declare const KEY_LEFT: number;
/**
 * @type {number}
 */
declare const KEY_UP: number;
/**
 * @type {number}
 */
declare const KEY_RIGHT: number;
/**
 * @type {number}
 */
declare const KEY_DOWN: number;
/**
 * @type {number}
 */
declare const KEY_PRINT_SCREEN: number;
/**
 * @type {number}
 */
declare const KEY_INSERT: number;
/**
 * @type {number}
 */
declare const KEY_DELETE: number;
/**
 * @type {number}
 */
declare const KEY_0: number;
/**
 * @type {number}
 */
declare const KEY_1: number;
/**
 * @type {number}
 */
declare const KEY_2: number;
/**
 * @type {number}
 */
declare const KEY_3: number;
/**
 * @type {number}
 */
declare const KEY_4: number;
/**
 * @type {number}
 */
declare const KEY_5: number;
/**
 * @type {number}
 */
declare const KEY_6: number;
/**
 * @type {number}
 */
declare const KEY_7: number;
/**
 * @type {number}
 */
declare const KEY_8: number;
/**
 * @type {number}
 */
declare const KEY_9: number;
/**
 * @type {number}
 */
declare const KEY_SEMICOLON: number;
/**
 * @type {number}
 */
declare const KEY_EQUAL: number;
/**
 * @type {number}
 */
declare const KEY_A: number;
/**
 * @type {number}
 */
declare const KEY_B: number;
/**
 * @type {number}
 */
declare const KEY_C: number;
/**
 * @type {number}
 */
declare const KEY_D: number;
/**
 * @type {number}
 */
declare const KEY_E: number;
/**
 * @type {number}
 */
declare const KEY_F: number;
/**
 * @type {number}
 */
declare const KEY_G: number;
/**
 * @type {number}
 */
declare const KEY_H: number;
/**
 * @type {number}
 */
declare const KEY_I: number;
/**
 * @type {number}
 */
declare const KEY_J: number;
/**
 * @type {number}
 */
declare const KEY_K: number;
/**
 * @type {number}
 */
declare const KEY_L: number;
/**
 * @type {number}
 */
declare const KEY_M: number;
/**
 * @type {number}
 */
declare const KEY_N: number;
/**
 * @type {number}
 */
declare const KEY_O: number;
/**
 * @type {number}
 */
declare const KEY_P: number;
/**
 * @type {number}
 */
declare const KEY_Q: number;
/**
 * @type {number}
 */
declare const KEY_R: number;
/**
 * @type {number}
 */
declare const KEY_S: number;
/**
 * @type {number}
 */
declare const KEY_T: number;
/**
 * @type {number}
 */
declare const KEY_U: number;
/**
 * @type {number}
 */
declare const KEY_V: number;
/**
 * @type {number}
 */
declare const KEY_W: number;
/**
 * @type {number}
 */
declare const KEY_X: number;
/**
 * @type {number}
 */
declare const KEY_Y: number;
/**
 * @type {number}
 */
declare const KEY_Z: number;
/**
 * @type {number}
 */
declare const KEY_WINDOWS: number;
/**
 * @type {number}
 */
declare const KEY_CONTEXT_MENU: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_0: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_1: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_2: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_3: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_4: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_5: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_6: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_7: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_8: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_9: number;
/**
 * @type {number}
 */
declare const KEY_MULTIPLY: number;
/**
 * @type {number}
 */
declare const KEY_ADD: number;
/**
 * @type {number}
 */
declare const KEY_SEPARATOR: number;
/**
 * @type {number}
 */
declare const KEY_SUBTRACT: number;
/**
 * @type {number}
 */
declare const KEY_DECIMAL: number;
/**
 * @type {number}
 */
declare const KEY_DIVIDE: number;
/**
 * @type {number}
 */
declare const KEY_F1: number;
/**
 * @type {number}
 */
declare const KEY_F2: number;
/**
 * @type {number}
 */
declare const KEY_F3: number;
/**
 * @type {number}
 */
declare const KEY_F4: number;
/**
 * @type {number}
 */
declare const KEY_F5: number;
/**
 * @type {number}
 */
declare const KEY_F6: number;
/**
 * @type {number}
 */
declare const KEY_F7: number;
/**
 * @type {number}
 */
declare const KEY_F8: number;
/**
 * @type {number}
 */
declare const KEY_F9: number;
/**
 * @type {number}
 */
declare const KEY_F10: number;
/**
 * @type {number}
 */
declare const KEY_F11: number;
/**
 * @type {number}
 */
declare const KEY_F12: number;
/**
 * @type {number}
 */
declare const KEY_COMMA: number;
/**
 * @type {number}
 */
declare const KEY_PERIOD: number;
/**
 * @type {number}
 */
declare const KEY_SLASH: number;
/**
 * @type {number}
 */
declare const KEY_OPEN_BRACKET: number;
/**
 * @type {number}
 */
declare const KEY_BACK_SLASH: number;
/**
 * @type {number}
 */
declare const KEY_CLOSE_BRACKET: number;
/**
 * @type {number}
 */
declare const KEY_META: number;
/**
 * No mouse buttons pressed.
 *
 * @type {number}
 */
declare const MOUSEBUTTON_NONE: number;
/**
 * The left mouse button.
 *
 * @type {number}
 */
declare const MOUSEBUTTON_LEFT: number;
/**
 * The middle mouse button.
 *
 * @type {number}
 */
declare const MOUSEBUTTON_MIDDLE: number;
/**
 * The right mouse button.
 *
 * @type {number}
 */
declare const MOUSEBUTTON_RIGHT: number;
/**
 * Index for pad 1.
 *
 * @type {number}
 */
declare const PAD_1: number;
/**
 * Index for pad 2.
 *
 * @type {number}
 */
declare const PAD_2: number;
/**
 * Index for pad 3.
 *
 * @type {number}
 */
declare const PAD_3: number;
/**
 * Index for pad 4.
 *
 * @type {number}
 */
declare const PAD_4: number;
/**
 * The first face button, from bottom going clockwise.
 *
 * @type {number}
 */
declare const PAD_FACE_1: number;
/**
 * The second face button, from bottom going clockwise.
 *
 * @type {number}
 */
declare const PAD_FACE_2: number;
/**
 * The third face button, from bottom going clockwise.
 *
 * @type {number}
 */
declare const PAD_FACE_3: number;
/**
 * The fourth face button, from bottom going clockwise.
 *
 * @type {number}
 */
declare const PAD_FACE_4: number;
/**
 * The first shoulder button on the left.
 *
 * @type {number}
 */
declare const PAD_L_SHOULDER_1: number;
/**
 * The first shoulder button on the right.
 *
 * @type {number}
 */
declare const PAD_R_SHOULDER_1: number;
/**
 * The second shoulder button on the left.
 *
 * @type {number}
 */
declare const PAD_L_SHOULDER_2: number;
/**
 * The second shoulder button on the right.
 *
 * @type {number}
 */
declare const PAD_R_SHOULDER_2: number;
/**
 * The select button.
 *
 * @type {number}
 */
declare const PAD_SELECT: number;
/**
 * The start button.
 *
 * @type {number}
 */
declare const PAD_START: number;
/**
 * The button when depressing the left analogue stick.
 *
 * @type {number}
 */
declare const PAD_L_STICK_BUTTON: number;
/**
 * The button when depressing the right analogue stick.
 *
 * @type {number}
 */
declare const PAD_R_STICK_BUTTON: number;
/**
 * Direction pad up.
 *
 * @type {number}
 */
declare const PAD_UP: number;
/**
 * Direction pad down.
 *
 * @type {number}
 */
declare const PAD_DOWN: number;
/**
 * Direction pad left.
 *
 * @type {number}
 */
declare const PAD_LEFT: number;
/**
 * Direction pad right.
 *
 * @type {number}
 */
declare const PAD_RIGHT: number;
/**
 * Vendor specific button.
 *
 * @type {number}
 */
declare const PAD_VENDOR: number;
/**
 * Horizontal axis on the left analogue stick.
 *
 * @type {number}
 */
declare const PAD_L_STICK_X: number;
/**
 * Vertical axis on the left analogue stick.
 *
 * @type {number}
 */
declare const PAD_L_STICK_Y: number;
/**
 * Horizontal axis on the right analogue stick.
 *
 * @type {number}
 */
declare const PAD_R_STICK_X: number;
/**
 * Vertical axis on the right analogue stick.
 *
 * @type {number}
 */
declare const PAD_R_STICK_Y: number;

/**
 * When resizing the window the size of the canvas will not change.
 *
 * @type {string}
 */
declare const FILLMODE_NONE: string;
/**
 * When resizing the window the size of the canvas will change to fill the window exactly.
 *
 * @type {string}
 */
declare const FILLMODE_FILL_WINDOW: string;
/**
 * When resizing the window the size of the canvas will change to fill the window as best it can,
 * while maintaining the same aspect ratio.
 *
 * @type {string}
 */
declare const FILLMODE_KEEP_ASPECT: string;
/**
 * When the canvas is resized the resolution of the canvas will change to match the size of the
 * canvas.
 *
 * @type {string}
 */
declare const RESOLUTION_AUTO: string;
/**
 * When the canvas is resized the resolution of the canvas will remain at the same value and the
 * output will just be scaled to fit the canvas.
 *
 * @type {string}
 */
declare const RESOLUTION_FIXED: string;

/**
 * Specifies different color tints for the hover, pressed and inactive states.
 *
 * @type {number}
 */
declare const BUTTON_TRANSITION_MODE_TINT: number;
/**
 * Specifies different sprites for the hover, pressed and inactive states.
 *
 * @type {number}
 */
declare const BUTTON_TRANSITION_MODE_SPRITE_CHANGE: number;

/**
 * A {@link ElementComponent} that contains child {@link ElementComponent}s.
 *
 * @type {string}
 */
declare const ELEMENTTYPE_GROUP: string;
/**
 * A {@link ElementComponent} that displays an image.
 *
 * @type {string}
 */
declare const ELEMENTTYPE_IMAGE: string;
/**
 * A {@link ElementComponent} that displays text.
 *
 * @type {string}
 */
declare const ELEMENTTYPE_TEXT: string;

/**
 * Specified degree of freedom has free movement.
 *
 * @type {string}
 * @ignore
 */
declare const MOTION_FREE: string;
/**
 * Specified degree of freedom has limited movement.
 *
 * @type {string}
 * @ignore
 */
declare const MOTION_LIMITED: string;
/**
 * Specified degree of freedom is locked and allows no movement.
 *
 * @type {string}
 * @ignore
 */
declare const MOTION_LOCKED: string;

/**
 * Disable all fitting logic.
 *
 * @type {number}
 */
declare const FITTING_NONE: number;
/**
 * Stretch child elements to fit the parent container.
 *
 * @type {number}
 */
declare const FITTING_STRETCH: number;
/**
 * Shrink child elements to fit the parent container.
 *
 * @type {number}
 */
declare const FITTING_SHRINK: number;
/**
 * Apply both STRETCH and SHRINK fitting logic where applicable.
 *
 * @type {number}
 */
declare const FITTING_BOTH: number;

/**
 * Rigid body has infinite mass and cannot move.
 *
 * @type {string}
 */
declare const BODYTYPE_STATIC: string;
/**
 * Rigid body is simulated according to applied forces.
 *
 * @type {string}
 */
declare const BODYTYPE_DYNAMIC: string;
/**
 * Rigid body has infinite mass and does not respond to forces but can still be moved by setting
 * their velocity or position.
 *
 * @type {string}
 */
declare const BODYTYPE_KINEMATIC: string;
declare const BODYFLAG_STATIC_OBJECT: 1;
declare const BODYFLAG_KINEMATIC_OBJECT: 2;
declare const BODYFLAG_NORESPONSE_OBJECT: 4;
declare const BODYSTATE_ACTIVE_TAG: 1;
declare const BODYSTATE_ISLAND_SLEEPING: 2;
declare const BODYSTATE_WANTS_DEACTIVATION: 3;
declare const BODYSTATE_DISABLE_DEACTIVATION: 4;
declare const BODYSTATE_DISABLE_SIMULATION: 5;
declare const BODYGROUP_NONE: 0;
declare const BODYGROUP_DEFAULT: 1;
declare const BODYGROUP_DYNAMIC: 1;
declare const BODYGROUP_STATIC: 2;
declare const BODYGROUP_KINEMATIC: 4;
declare const BODYGROUP_ENGINE_1: 8;
declare const BODYGROUP_TRIGGER: 16;
declare const BODYGROUP_ENGINE_2: 32;
declare const BODYGROUP_ENGINE_3: 64;
declare const BODYGROUP_USER_1: 128;
declare const BODYGROUP_USER_2: 256;
declare const BODYGROUP_USER_3: 512;
declare const BODYGROUP_USER_4: 1024;
declare const BODYGROUP_USER_5: 2048;
declare const BODYGROUP_USER_6: 4096;
declare const BODYGROUP_USER_7: 8192;
declare const BODYGROUP_USER_8: 16384;
declare const BODYMASK_NONE: 0;
declare const BODYMASK_ALL: 65535;
declare const BODYMASK_STATIC: 2;
declare const BODYMASK_NOT_STATIC: number;
declare const BODYMASK_NOT_STATIC_KINEMATIC: number;

/**
 * Always use the application's resolution as the resolution for the {@link ScreenComponent}.
 *
 * @type {string}
 */
declare const SCALEMODE_NONE: string;
/**
 * Scale the {@link ScreenComponent} when the application's resolution is different than the
 * ScreenComponent's referenceResolution.
 *
 * @type {string}
 */
declare const SCALEMODE_BLEND: string;

/**
 * Content does not scroll any further than its bounds.
 *
 * @type {number}
 */
declare const SCROLL_MODE_CLAMP: number;
/**
 * Content scrolls past its bounds and then gently bounces back.
 *
 * @type {number}
 */
declare const SCROLL_MODE_BOUNCE: number;
/**
 * Content can scroll forever.
 *
 * @type {number}
 */
declare const SCROLL_MODE_INFINITE: number;
/**
 * The scrollbar will be visible all the time.
 *
 * @type {number}
 */
declare const SCROLLBAR_VISIBILITY_SHOW_ALWAYS: number;
/**
 * The scrollbar will be visible only when content exceeds the size of the viewport.
 *
 * @type {number}
 */
declare const SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED: number;

/**
 * A {@link SpriteComponent} that displays a single frame from a sprite asset.
 *
 * @type {string}
 */
declare const SPRITETYPE_SIMPLE: string;
/**
 * A {@link SpriteComponent} that renders sprite animations.
 *
 * @type {string}
 */
declare const SPRITETYPE_ANIMATED: string;

/**
 * Inline - always available type of session. It has limited features availability and is rendered
 * into HTML element.
 *
 * @type {string}
 */
declare const XRTYPE_INLINE: string;
/**
 * Immersive VR - session that provides exclusive access to VR device with best available tracking
 * features.
 *
 * @type {string}
 */
declare const XRTYPE_VR: string;
/**
 * Immersive AR - session that provides exclusive access to VR/AR device that is intended to be
 * blended with real-world environment.
 *
 * @type {string}
 */
declare const XRTYPE_AR: string;
/**
 * Viewer - always supported space with some basic tracking capabilities.
 *
 * @type {string}
 */
declare const XRSPACE_VIEWER: string;
/**
 * Local - represents a tracking space with a native origin near the viewer at the time of
 * creation. The exact position and orientation will be initialized based on the conventions of the
 * underlying platform. When using this reference space the user is not expected to move beyond
 * their initial position much, if at all, and tracking is optimized for that purpose. For devices
 * with 6DoF tracking, local reference spaces should emphasize keeping the origin stable relative
 * to the user's environment.
 *
 * @type {string}
 */
declare const XRSPACE_LOCAL: string;
/**
 * Local Floor - represents a tracking space with a native origin at the floor in a safe position
 * for the user to stand. The y axis equals 0 at floor level, with the x and z position and
 * orientation initialized based on the conventions of the underlying platform. Floor level value
 * might be estimated by the underlying platform. When using this reference space, the user is not
 * expected to move beyond their initial position much, if at all, and tracking is optimized for
 * that purpose. For devices with 6DoF tracking, local-floor reference spaces should emphasize
 * keeping the origin stable relative to the user's environment.
 *
 * @type {string}
 */
declare const XRSPACE_LOCALFLOOR: string;
/**
 * Bounded Floor - represents a tracking space with its native origin at the floor, where the user
 * is expected to move within a pre-established boundary. Tracking in a bounded-floor reference
 * space is optimized for keeping the native origin and bounds geometry stable relative to the
 * user's environment.
 *
 * @type {string}
 */
declare const XRSPACE_BOUNDEDFLOOR: string;
/**
 * Unbounded - represents a tracking space where the user is expected to move freely around their
 * environment, potentially even long distances from their starting point. Tracking in an unbounded
 * reference space is optimized for stability around the user's current position, and as such the
 * native origin may drift over time.
 *
 * @type {string}
 */
declare const XRSPACE_UNBOUNDED: string;
/**
 * Gaze - indicates the target ray will originate at the viewer and follow the direction it is
 * facing. This is commonly referred to as a "gaze input" device in the context of head-mounted
 * displays.
 *
 * @type {string}
 */
declare const XRTARGETRAY_GAZE: string;
/**
 * Screen - indicates that the input source was an interaction with the canvas element associated
 * with an inline session's output context, such as a mouse click or touch event.
 *
 * @type {string}
 */
declare const XRTARGETRAY_SCREEN: string;
/**
 * Tracked Pointer - indicates that the target ray originates from either a handheld device or
 * other hand-tracking mechanism and represents that the user is using their hands or the held
 * device for pointing.
 *
 * @type {string}
 */
declare const XRTARGETRAY_POINTER: string;
/**
 * None - input source is not meant to be held in hands.
 *
 * @type {string}
 */
declare const XRHAND_NONE: string;
/**
 * Left - indicates that input source is meant to be held in left hand.
 *
 * @type {string}
 */
declare const XRHAND_LEFT: string;
/**
 * Right - indicates that input source is meant to be held in right hand.
 *
 * @type {string}
 */
declare const XRHAND_RIGHT: string;
/**
 * Point - indicates that the hit test results will be computed based on the feature points
 * detected by the underlying Augmented Reality system.
 *
 * @type {string}
 */
declare const XRTRACKABLE_POINT: string;
/**
 * Plane - indicates that the hit test results will be computed based on the planes detected by the
 * underlying Augmented Reality system.
 *
 * @type {string}
 */
declare const XRTRACKABLE_PLANE: string;
/**
 * Mesh - indicates that the hit test results will be computed based on the meshes detected by the
 * underlying Augmented Reality system.
 *
 * @type {string}
 */
declare const XRTRACKABLE_MESH: string;
/**
 * CPU - indicates that depth sensing preferred usage is CPU. This usage path is guaranteed to be
 * supported.
 *
 * @type {string}
 */
declare const XRDEPTHSENSINGUSAGE_CPU: string;
/**
 * GPU - indicates that depth sensing preferred usage is GPU.
 *
 * @type {string}
 */
declare const XRDEPTHSENSINGUSAGE_GPU: string;
/**
 * Luminance Alpha - indicates that depth sensing preferred raw data format is Luminance Alpha.
 * This format is guaranteed to be supported.
 *
 * @type {string}
 */
declare const XRDEPTHSENSINGFORMAT_L8A8: string;
/**
 * Float 32 - indicates that depth sensing preferred raw data format is Float 32.
 *
 * @type {string}
 */
declare const XRDEPTHSENSINGFORMAT_F32: string;

declare function now(): number;
/**
 * A Timer counts milliseconds from when start() is called until when stop() is called.
 *
 * @ignore
 */
declare class Timer {
    _isRunning: boolean;
    _a: number;
    _b: number;
    /**
     * Start the timer.
     */
    start(): void;
    /**
     * Stop the timer.
     */
    stop(): void;
    /**
     * Get the number of milliseconds that passed between start() and stop() being called.
     *
     * @returns {number} The elapsed milliseconds.
     */
    getMilliseconds(): number;
}

/**
 * 3-dimensional vector.
 */
declare class Vec3$1 {
    /**
     * A constant vector set to [0, 0, 0].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly ZERO: Vec3$1;
    /**
     * A constant vector set to [1, 1, 1].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly ONE: Vec3$1;
    /**
     * A constant vector set to [0, 1, 0].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly UP: Vec3$1;
    /**
     * A constant vector set to [0, -1, 0].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly DOWN: Vec3$1;
    /**
     * A constant vector set to [1, 0, 0].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly RIGHT: Vec3$1;
    /**
     * A constant vector set to [-1, 0, 0].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly LEFT: Vec3$1;
    /**
     * A constant vector set to [0, 0, -1].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly FORWARD: Vec3$1;
    /**
     * A constant vector set to [0, 0, 1].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly BACK: Vec3$1;
    /**
     * Creates a new Vec3 object.
     *
     * @param {number|number[]} [x] - The x value. Defaults to 0. If x is an array of length 3, the
     * array will be used to populate all components.
     * @param {number} [y] - The y value. Defaults to 0.
     * @param {number} [z] - The z value. Defaults to 0.
     * @example
     * var v = new pc.Vec3(1, 2, 3);
     */
    constructor(x?: number | number[], y?: number, z?: number);
    /**
     * The first component of the vector.
     *
     * @type {number}
     */
    x: number;
    /**
     * The second component of the vector.
     *
     * @type {number}
     */
    y: number;
    /**
     * The third component of the vector.
     *
     * @type {number}
     */
    z: number;
    /**
     * Adds a 3-dimensional vector to another in place.
     *
     * @param {Vec3} rhs - The vector to add to the specified vector.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(10, 10, 10);
     * var b = new pc.Vec3(20, 20, 20);
     *
     * a.add(b);
     *
     * // Outputs [30, 30, 30]
     * console.log("The result of the addition is: " + a.toString());
     */
    add(rhs: Vec3$1): Vec3$1;
    /**
     * Adds two 3-dimensional vectors together and returns the result.
     *
     * @param {Vec3} lhs - The first vector operand for the addition.
     * @param {Vec3} rhs - The second vector operand for the addition.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(10, 10, 10);
     * var b = new pc.Vec3(20, 20, 20);
     * var r = new pc.Vec3();
     *
     * r.add2(a, b);
     * // Outputs [30, 30, 30]
     *
     * console.log("The result of the addition is: " + r.toString());
     */
    add2(lhs: Vec3$1, rhs: Vec3$1): Vec3$1;
    /**
     * Adds a number to each element of a vector.
     *
     * @param {number} scalar - The number to add.
     * @returns {Vec3} Self for chaining.
     * @example
     * var vec = new pc.Vec3(3, 4, 5);
     *
     * vec.addScalar(2);
     *
     * // Outputs [5, 6, 7]
     * console.log("The result of the addition is: " + vec.toString());
     */
    addScalar(scalar: number): Vec3$1;
    /**
     * Returns an identical copy of the specified 3-dimensional vector.
     *
     * @returns {Vec3} A 3-dimensional vector containing the result of the cloning.
     * @example
     * var v = new pc.Vec3(10, 20, 30);
     * var vclone = v.clone();
     * console.log("The result of the cloning is: " + vclone.toString());
     */
    clone(): Vec3$1;
    /**
     * Copies the contents of a source 3-dimensional vector to a destination 3-dimensional vector.
     *
     * @param {Vec3} rhs - A vector to copy to the specified vector.
     * @returns {Vec3} Self for chaining.
     * @example
     * var src = new pc.Vec3(10, 20, 30);
     * var dst = new pc.Vec3();
     *
     * dst.copy(src);
     *
     * console.log("The two vectors are " + (dst.equals(src) ? "equal" : "different"));
     */
    copy(rhs: Vec3$1): Vec3$1;
    /**
     * Returns the result of a cross product operation performed on the two specified 3-dimensional
     * vectors.
     *
     * @param {Vec3} lhs - The first 3-dimensional vector operand of the cross product.
     * @param {Vec3} rhs - The second 3-dimensional vector operand of the cross product.
     * @returns {Vec3} Self for chaining.
     * @example
     * var back = new pc.Vec3().cross(pc.Vec3.RIGHT, pc.Vec3.UP);
     *
     * // Prints the Z axis (i.e. [0, 0, 1])
     * console.log("The result of the cross product is: " + back.toString());
     */
    cross(lhs: Vec3$1, rhs: Vec3$1): Vec3$1;
    /**
     * Returns the distance between the two specified 3-dimensional vectors.
     *
     * @param {Vec3} rhs - The second 3-dimensional vector to test.
     * @returns {number} The distance between the two vectors.
     * @example
     * var v1 = new pc.Vec3(5, 10, 20);
     * var v2 = new pc.Vec3(10, 20, 40);
     * var d = v1.distance(v2);
     * console.log("The between v1 and v2 is: " + d);
     */
    distance(rhs: Vec3$1): number;
    /**
     * Divides a 3-dimensional vector by another in place.
     *
     * @param {Vec3} rhs - The vector to divide the specified vector by.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(4, 9, 16);
     * var b = new pc.Vec3(2, 3, 4);
     *
     * a.div(b);
     *
     * // Outputs [2, 3, 4]
     * console.log("The result of the division is: " + a.toString());
     */
    div(rhs: Vec3$1): Vec3$1;
    /**
     * Divides one 3-dimensional vector by another and writes the result to the specified vector.
     *
     * @param {Vec3} lhs - The dividend vector (the vector being divided).
     * @param {Vec3} rhs - The divisor vector (the vector dividing the dividend).
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(4, 9, 16);
     * var b = new pc.Vec3(2, 3, 4);
     * var r = new pc.Vec3();
     *
     * r.div2(a, b);
     * // Outputs [2, 3, 4]
     *
     * console.log("The result of the division is: " + r.toString());
     */
    div2(lhs: Vec3$1, rhs: Vec3$1): Vec3$1;
    /**
     * Divides each element of a vector by a number.
     *
     * @param {number} scalar - The number to divide by.
     * @returns {Vec3} Self for chaining.
     * @example
     * var vec = new pc.Vec3(3, 6, 9);
     *
     * vec.divScalar(3);
     *
     * // Outputs [1, 2, 3]
     * console.log("The result of the division is: " + vec.toString());
     */
    divScalar(scalar: number): Vec3$1;
    /**
     * Returns the result of a dot product operation performed on the two specified 3-dimensional
     * vectors.
     *
     * @param {Vec3} rhs - The second 3-dimensional vector operand of the dot product.
     * @returns {number} The result of the dot product operation.
     * @example
     * var v1 = new pc.Vec3(5, 10, 20);
     * var v2 = new pc.Vec3(10, 20, 40);
     * var v1dotv2 = v1.dot(v2);
     * console.log("The result of the dot product is: " + v1dotv2);
     */
    dot(rhs: Vec3$1): number;
    /**
     * Reports whether two vectors are equal.
     *
     * @param {Vec3} rhs - The vector to compare to the specified vector.
     * @returns {boolean} True if the vectors are equal and false otherwise.
     * @example
     * var a = new pc.Vec3(1, 2, 3);
     * var b = new pc.Vec3(4, 5, 6);
     * console.log("The two vectors are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Vec3$1): boolean;
    /**
     * Returns the magnitude of the specified 3-dimensional vector.
     *
     * @returns {number} The magnitude of the specified 3-dimensional vector.
     * @example
     * var vec = new pc.Vec3(3, 4, 0);
     * var len = vec.length();
     * // Outputs 5
     * console.log("The length of the vector is: " + len);
     */
    length(): number;
    /**
     * Returns the magnitude squared of the specified 3-dimensional vector.
     *
     * @returns {number} The magnitude of the specified 3-dimensional vector.
     * @example
     * var vec = new pc.Vec3(3, 4, 0);
     * var len = vec.lengthSq();
     * // Outputs 25
     * console.log("The length squared of the vector is: " + len);
     */
    lengthSq(): number;
    /**
     * Returns the result of a linear interpolation between two specified 3-dimensional vectors.
     *
     * @param {Vec3} lhs - The 3-dimensional to interpolate from.
     * @param {Vec3} rhs - The 3-dimensional to interpolate to.
     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,
     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this
     * range, the linear interpolant will occur on a ray extrapolated from this line.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(0, 0, 0);
     * var b = new pc.Vec3(10, 10, 10);
     * var r = new pc.Vec3();
     *
     * r.lerp(a, b, 0);   // r is equal to a
     * r.lerp(a, b, 0.5); // r is 5, 5, 5
     * r.lerp(a, b, 1);   // r is equal to b
     */
    lerp(lhs: Vec3$1, rhs: Vec3$1, alpha: number): Vec3$1;
    /**
     * Multiplies a 3-dimensional vector to another in place.
     *
     * @param {Vec3} rhs - The 3-dimensional vector used as the second multiplicand of the operation.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(2, 3, 4);
     * var b = new pc.Vec3(4, 5, 6);
     *
     * a.mul(b);
     *
     * // Outputs 8, 15, 24
     * console.log("The result of the multiplication is: " + a.toString());
     */
    mul(rhs: Vec3$1): Vec3$1;
    /**
     * Returns the result of multiplying the specified 3-dimensional vectors together.
     *
     * @param {Vec3} lhs - The 3-dimensional vector used as the first multiplicand of the operation.
     * @param {Vec3} rhs - The 3-dimensional vector used as the second multiplicand of the operation.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(2, 3, 4);
     * var b = new pc.Vec3(4, 5, 6);
     * var r = new pc.Vec3();
     *
     * r.mul2(a, b);
     *
     * // Outputs 8, 15, 24
     * console.log("The result of the multiplication is: " + r.toString());
     */
    mul2(lhs: Vec3$1, rhs: Vec3$1): Vec3$1;
    /**
     * Multiplies each element of a vector by a number.
     *
     * @param {number} scalar - The number to multiply by.
     * @returns {Vec3} Self for chaining.
     * @example
     * var vec = new pc.Vec3(3, 6, 9);
     *
     * vec.mulScalar(3);
     *
     * // Outputs [9, 18, 27]
     * console.log("The result of the multiplication is: " + vec.toString());
     */
    mulScalar(scalar: number): Vec3$1;
    /**
     * Returns this 3-dimensional vector converted to a unit vector in place. If the vector has a
     * length of zero, the vector's elements will be set to zero.
     *
     * @returns {Vec3} Self for chaining.
     * @example
     * var v = new pc.Vec3(25, 0, 0);
     *
     * v.normalize();
     *
     * // Outputs 1, 0, 0
     * console.log("The result of the vector normalization is: " + v.toString());
     */
    normalize(): Vec3$1;
    /**
     * Each element is set to the largest integer less than or equal to its value.
     *
     * @returns {Vec3} Self for chaining.
     */
    floor(): Vec3$1;
    /**
     * Each element is rounded up to the next largest integer.
     *
     * @returns {Vec3} Self for chaining.
     */
    ceil(): Vec3$1;
    /**
     * Each element is rounded up or down to the nearest integer.
     *
     * @returns {Vec3} Self for chaining.
     */
    round(): Vec3$1;
    /**
     * Each element is assigned a value from rhs parameter if it is smaller.
     *
     * @param {Vec3} rhs - The 3-dimensional vector used as the source of elements to compare to.
     * @returns {Vec3} Self for chaining.
     */
    min(rhs: Vec3$1): Vec3$1;
    /**
     * Each element is assigned a value from rhs parameter if it is larger.
     *
     * @param {Vec3} rhs - The 3-dimensional vector used as the source of elements to compare to.
     * @returns {Vec3} Self for chaining.
     */
    max(rhs: Vec3$1): Vec3$1;
    /**
     * Projects this 3-dimensional vector onto the specified vector.
     *
     * @param {Vec3} rhs - The vector onto which the original vector will be projected on.
     * @returns {Vec3} Self for chaining.
     * @example
     * var v = new pc.Vec3(5, 5, 5);
     * var normal = new pc.Vec3(1, 0, 0);
     *
     * v.project(normal);
     *
     * // Outputs 5, 0, 0
     * console.log("The result of the vector projection is: " + v.toString());
     */
    project(rhs: Vec3$1): Vec3$1;
    /**
     * Sets the specified 3-dimensional vector to the supplied numerical values.
     *
     * @param {number} x - The value to set on the first component of the vector.
     * @param {number} y - The value to set on the second component of the vector.
     * @param {number} z - The value to set on the third component of the vector.
     * @returns {Vec3} Self for chaining.
     * @example
     * var v = new pc.Vec3();
     * v.set(5, 10, 20);
     *
     * // Outputs 5, 10, 20
     * console.log("The result of the vector set is: " + v.toString());
     */
    set(x: number, y: number, z: number): Vec3$1;
    /**
     * Subtracts a 3-dimensional vector from another in place.
     *
     * @param {Vec3} rhs - The vector to add to the specified vector.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(10, 10, 10);
     * var b = new pc.Vec3(20, 20, 20);
     *
     * a.sub(b);
     *
     * // Outputs [-10, -10, -10]
     * console.log("The result of the subtraction is: " + a.toString());
     */
    sub(rhs: Vec3$1): Vec3$1;
    /**
     * Subtracts two 3-dimensional vectors from one another and returns the result.
     *
     * @param {Vec3} lhs - The first vector operand for the addition.
     * @param {Vec3} rhs - The second vector operand for the addition.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(10, 10, 10);
     * var b = new pc.Vec3(20, 20, 20);
     * var r = new pc.Vec3();
     *
     * r.sub2(a, b);
     *
     * // Outputs [-10, -10, -10]
     * console.log("The result of the subtraction is: " + r.toString());
     */
    sub2(lhs: Vec3$1, rhs: Vec3$1): Vec3$1;
    /**
     * Subtracts a number from each element of a vector.
     *
     * @param {number} scalar - The number to subtract.
     * @returns {Vec3} Self for chaining.
     * @example
     * var vec = new pc.Vec3(3, 4, 5);
     *
     * vec.subScalar(2);
     *
     * // Outputs [1, 2, 3]
     * console.log("The result of the subtraction is: " + vec.toString());
     */
    subScalar(scalar: number): Vec3$1;
    /**
     * Converts the vector to string form.
     *
     * @returns {string} The vector in string form.
     * @example
     * var v = new pc.Vec3(20, 10, 5);
     * // Outputs [20, 10, 5]
     * console.log(v.toString());
     */
    toString(): string;
}

/**
 * An infinite ray.
 */
declare class Ray$4 {
    /**
     * Creates a new Ray instance. The ray is infinite, starting at a given origin and pointing in
     * a given direction.
     *
     * @param {Vec3} [origin] - The starting point of the ray. The constructor takes a reference of
     * this parameter. Defaults to the origin (0, 0, 0).
     * @param {Vec3} [direction] - The direction of the ray. The constructor takes a reference of
     * this parameter. Defaults to a direction down the world negative Z axis (0, 0, -1).
     * @example
     * // Create a new ray starting at the position of this entity and pointing down
     * // the entity's negative Z axis
     * var ray = new pc.Ray(this.entity.getPosition(), this.entity.forward);
     */
    constructor(origin?: Vec3$1, direction?: Vec3$1);
    /**
     * The starting point of the ray.
     *
     * @type {Vec3}
     */
    origin: Vec3$1;
    /**
     * The direction of the ray.
     *
     * @type {Vec3}
     */
    direction: Vec3$1;
    /**
     * Sets origin and direction to the supplied vector values.
     *
     * @param {Vec3} origin - The starting point of the ray.
     * @param {Vec3} direction - The direction of the ray.
     * @returns {Ray} Self for chaining.
     */
    set(origin: Vec3$1, direction: Vec3$1): Ray$4;
}

type Ray$3 = Ray$4;
/**
 * A bounding sphere is a volume for facilitating fast intersection testing.
 */
declare class BoundingSphere$2 {
    /**
     * Creates a new BoundingSphere instance.
     *
     * @param {Vec3} [center] - The world space coordinate marking the center of the sphere. The
     * constructor takes a reference of this parameter.
     * @param {number} [radius] - The radius of the bounding sphere. Defaults to 0.5.
     * @example
     * // Create a new bounding sphere centered on the origin with a radius of 0.5
     * var sphere = new pc.BoundingSphere();
     */
    constructor(center?: Vec3$1, radius?: number);
    /**
     * Center of sphere.
     *
     * @type {Vec3}
     */
    center: Vec3$1;
    /**
     * The radius of the bounding sphere.
     *
     * @type {number}
     */
    radius: number;
    containsPoint(point: any): boolean;
    /**
     * Test if a ray intersects with the sphere.
     *
     * @param {Ray} ray - Ray to test against (direction must be normalized).
     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied
     * into here.
     * @returns {boolean} True if there is an intersection.
     */
    intersectsRay(ray: Ray$3, point?: Vec3$1): boolean;
    /**
     * Test if a Bounding Sphere is overlapping, enveloping, or inside this Bounding Sphere.
     *
     * @param {BoundingSphere} sphere - Bounding Sphere to test.
     * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping, or inside this Bounding Sphere and false otherwise.
     */
    intersectsBoundingSphere(sphere: BoundingSphere$2): boolean;
}

type Mat4$6 = Mat4$5;
/** @typedef {import('./mat4.js').Mat4} Mat4 */
/**
 * A quaternion.
 */
declare class Quat$1 {
    /**
     * A constant quaternion set to [0, 0, 0, 1] (the identity).
     *
     * @type {Quat}
     * @readonly
     */
    static readonly IDENTITY: Quat$1;
    /**
     * A constant quaternion set to [0, 0, 0, 0].
     *
     * @type {Quat}
     * @readonly
     */
    static readonly ZERO: Quat$1;
    /**
     * Create a new Quat instance.
     *
     * @param {number|number[]} [x] - The quaternion's x component. Defaults to 0. If x is an array
     * of length 4, the array will be used to populate all components.
     * @param {number} [y] - The quaternion's y component. Defaults to 0.
     * @param {number} [z] - The quaternion's z component. Defaults to 0.
     * @param {number} [w] - The quaternion's w component. Defaults to 1.
     */
    constructor(x?: number | number[], y?: number, z?: number, w?: number);
    /**
     * The x component of the quaternion.
     *
     * @type {number}
     */
    x: number;
    /**
     * The y component of the quaternion.
     *
     * @type {number}
     */
    y: number;
    /**
     * The z component of the quaternion.
     *
     * @type {number}
     */
    z: number;
    /**
     * The w component of the quaternion.
     *
     * @type {number}
     */
    w: number;
    /**
     * Returns an identical copy of the specified quaternion.
     *
     * @returns {Quat} A quaternion containing the result of the cloning.
     * @example
     * var q = new pc.Quat(-0.11, -0.15, -0.46, 0.87);
     * var qclone = q.clone();
     *
     * console.log("The result of the cloning is: " + q.toString());
     */
    clone(): Quat$1;
    conjugate(): Quat$1;
    /**
     * Copies the contents of a source quaternion to a destination quaternion.
     *
     * @param {Quat} rhs - The quaternion to be copied.
     * @returns {Quat} Self for chaining.
     * @example
     * var src = new pc.Quat();
     * var dst = new pc.Quat();
     * dst.copy(src, src);
     * console.log("The two quaternions are " + (src.equals(dst) ? "equal" : "different"));
     */
    copy(rhs: Quat$1): Quat$1;
    /**
     * Reports whether two quaternions are equal.
     *
     * @param {Quat} rhs - The quaternion to be compared against.
     * @returns {boolean} True if the quaternions are equal and false otherwise.
     * @example
     * var a = new pc.Quat();
     * var b = new pc.Quat();
     * console.log("The two quaternions are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Quat$1): boolean;
    /**
     * Gets the rotation axis and angle for a given quaternion. If a quaternion is created with
     * `setFromAxisAngle`, this method will return the same values as provided in the original
     * parameter list OR functionally equivalent values.
     *
     * @param {Vec3} axis - The 3-dimensional vector to receive the axis of rotation.
     * @returns {number} Angle, in degrees, of the rotation.
     * @example
     * var q = new pc.Quat();
     * q.setFromAxisAngle(new pc.Vec3(0, 1, 0), 90);
     * var v = new pc.Vec3();
     * var angle = q.getAxisAngle(v);
     * // Outputs 90
     * console.log(angle);
     * // Outputs [0, 1, 0]
     * console.log(v.toString());
     */
    getAxisAngle(axis: Vec3$1): number;
    /**
     * Converts the supplied quaternion to Euler angles.
     *
     * @param {Vec3} [eulers] - The 3-dimensional vector to receive the Euler angles.
     * @returns {Vec3} The 3-dimensional vector holding the Euler angles that
     * correspond to the supplied quaternion.
     */
    getEulerAngles(eulers?: Vec3$1): Vec3$1;
    /**
     * Generates the inverse of the specified quaternion.
     *
     * @returns {Quat} Self for chaining.
     * @example
     * // Create a quaternion rotated 180 degrees around the y-axis
     * var rot = new pc.Quat().setFromEulerAngles(0, 180, 0);
     *
     * // Invert in place
     * rot.invert();
     */
    invert(): Quat$1;
    /**
     * Returns the magnitude of the specified quaternion.
     *
     * @returns {number} The magnitude of the specified quaternion.
     * @example
     * var q = new pc.Quat(0, 0, 0, 5);
     * var len = q.length();
     * // Outputs 5
     * console.log("The length of the quaternion is: " + len);
     */
    length(): number;
    /**
     * Returns the magnitude squared of the specified quaternion.
     *
     * @returns {number} The magnitude of the specified quaternion.
     * @example
     * var q = new pc.Quat(3, 4, 0);
     * var lenSq = q.lengthSq();
     * // Outputs 25
     * console.log("The length squared of the quaternion is: " + lenSq);
     */
    lengthSq(): number;
    /**
     * Returns the result of multiplying the specified quaternions together.
     *
     * @param {Quat} rhs - The quaternion used as the second multiplicand of the operation.
     * @returns {Quat} Self for chaining.
     * @example
     * var a = new pc.Quat().setFromEulerAngles(0, 30, 0);
     * var b = new pc.Quat().setFromEulerAngles(0, 60, 0);
     *
     * // a becomes a 90 degree rotation around the Y axis
     * // In other words, a = a * b
     * a.mul(b);
     *
     * console.log("The result of the multiplication is: " + a.toString());
     */
    mul(rhs: Quat$1): Quat$1;
    /**
     * Returns the result of multiplying the specified quaternions together.
     *
     * @param {Quat} lhs - The quaternion used as the first multiplicand of the operation.
     * @param {Quat} rhs - The quaternion used as the second multiplicand of the operation.
     * @returns {Quat} Self for chaining.
     * @example
     * var a = new pc.Quat().setFromEulerAngles(0, 30, 0);
     * var b = new pc.Quat().setFromEulerAngles(0, 60, 0);
     * var r = new pc.Quat();
     *
     * // r is set to a 90 degree rotation around the Y axis
     * // In other words, r = a * b
     * r.mul2(a, b);
     *
     * console.log("The result of the multiplication is: " + r.toString());
     */
    mul2(lhs: Quat$1, rhs: Quat$1): Quat$1;
    /**
     * Returns the specified quaternion converted in place to a unit quaternion.
     *
     * @returns {Quat} The result of the normalization.
     * @example
     * var v = new pc.Quat(0, 0, 0, 5);
     *
     * v.normalize();
     *
     * // Outputs 0, 0, 0, 1
     * console.log("The result of the vector normalization is: " + v.toString());
     */
    normalize(): Quat$1;
    /**
     * Sets the specified quaternion to the supplied numerical values.
     *
     * @param {number} x - The x component of the quaternion.
     * @param {number} y - The y component of the quaternion.
     * @param {number} z - The z component of the quaternion.
     * @param {number} w - The w component of the quaternion.
     * @returns {Quat} Self for chaining.
     * @example
     * var q = new pc.Quat();
     * q.set(1, 0, 0, 0);
     *
     * // Outputs 1, 0, 0, 0
     * console.log("The result of the vector set is: " + q.toString());
     */
    set(x: number, y: number, z: number, w: number): Quat$1;
    /**
     * Sets a quaternion from an angular rotation around an axis.
     *
     * @param {Vec3} axis - World space axis around which to rotate.
     * @param {number} angle - Angle to rotate around the given axis in degrees.
     * @returns {Quat} Self for chaining.
     * @example
     * var q = new pc.Quat();
     * q.setFromAxisAngle(pc.Vec3.UP, 90);
     */
    setFromAxisAngle(axis: Vec3$1, angle: number): Quat$1;
    /**
     * Sets a quaternion from Euler angles specified in XYZ order.
     *
     * @param {number} ex - Angle to rotate around X axis in degrees.
     * @param {number} ey - Angle to rotate around Y axis in degrees.
     * @param {number} ez - Angle to rotate around Z axis in degrees.
     * @returns {Quat} Self for chaining.
     * @example
     * var q = new pc.Quat();
     * q.setFromEulerAngles(45, 90, 180);
     */
    setFromEulerAngles(ex: number, ey: number, ez: number): Quat$1;
    /**
     * Converts the specified 4x4 matrix to a quaternion. Note that since a quaternion is purely a
     * representation for orientation, only the translational part of the matrix is lost.
     *
     * @param {Mat4} m - The 4x4 matrix to convert.
     * @returns {Quat} Self for chaining.
     * @example
     * // Create a 4x4 rotation matrix of 180 degrees around the y-axis
     * var rot = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
     *
     * // Convert to a quaternion
     * var q = new pc.Quat().setFromMat4(rot);
     */
    setFromMat4(m: Mat4$6): Quat$1;
    /**
     * Performs a spherical interpolation between two quaternions. The result of the interpolation
     * is written to the quaternion calling the function.
     *
     * @param {Quat} lhs - The quaternion to interpolate from.
     * @param {Quat} rhs - The quaternion to interpolate to.
     * @param {number} alpha - The value controlling the interpolation in relation to the two input
     * quaternions. The value is in the range 0 to 1, 0 generating q1, 1 generating q2 and anything
     * in between generating a spherical interpolation between the two.
     * @returns {Quat} Self for chaining.
     * @example
     * var q1 = new pc.Quat(-0.11, -0.15, -0.46, 0.87);
     * var q2 = new pc.Quat(-0.21, -0.21, -0.67, 0.68);
     *
     * var result;
     * result = new pc.Quat().slerp(q1, q2, 0);   // Return q1
     * result = new pc.Quat().slerp(q1, q2, 0.5); // Return the midpoint interpolant
     * result = new pc.Quat().slerp(q1, q2, 1);   // Return q2
     */
    slerp(lhs: Quat$1, rhs: Quat$1, alpha: number): Quat$1;
    /**
     * Transforms a 3-dimensional vector by the specified quaternion.
     *
     * @param {Vec3} vec - The 3-dimensional vector to be transformed.
     * @param {Vec3} [res] - An optional 3-dimensional vector to receive the result of the transformation.
     * @returns {Vec3} The input vector v transformed by the current instance.
     * @example
     * // Create a 3-dimensional vector
     * var v = new pc.Vec3(1, 2, 3);
     *
     * // Create a 4x4 rotation matrix
     * var q = new pc.Quat().setFromEulerAngles(10, 20, 30);
     *
     * var tv = q.transformVector(v);
     */
    transformVector(vec: Vec3$1, res?: Vec3$1): Vec3$1;
    /**
     * Converts the quaternion to string form.
     *
     * @returns {string} The quaternion in string form.
     * @example
     * var v = new pc.Quat(0, 0, 0, 1);
     * // Outputs [0, 0, 0, 1]
     * console.log(v.toString());
     */
    toString(): string;
}

/**
 * A 4-dimensional vector.
 */
declare class Vec4$6 {
    /**
     * A constant vector set to [0, 0, 0, 0].
     *
     * @type {Vec4}
     * @readonly
     */
    static readonly ZERO: Vec4$6;
    /**
     * A constant vector set to [1, 1, 1, 1].
     *
     * @type {Vec4}
     * @readonly
     */
    static readonly ONE: Vec4$6;
    /**
     * Creates a new Vec4 object.
     *
     * @param {number|number[]} [x] - The x value. Defaults to 0. If x is an array of length 4, the
     * array will be used to populate all components.
     * @param {number} [y] - The y value. Defaults to 0.
     * @param {number} [z] - The z value. Defaults to 0.
     * @param {number} [w] - The w value. Defaults to 0.
     * @example
     * var v = new pc.Vec4(1, 2, 3, 4);
     */
    constructor(x?: number | number[], y?: number, z?: number, w?: number);
    /**
     * The first component of the vector.
     *
     * @type {number}
     */
    x: number;
    /**
     * The second component of the vector.
     *
     * @type {number}
     */
    y: number;
    /**
     * The third component of the vector.
     *
     * @type {number}
     */
    z: number;
    /**
     * The fourth component of the vector.
     *
     * @type {number}
     */
    w: number;
    /**
     * Adds a 4-dimensional vector to another in place.
     *
     * @param {Vec4} rhs - The vector to add to the specified vector.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(10, 10, 10, 10);
     * var b = new pc.Vec4(20, 20, 20, 20);
     *
     * a.add(b);
     *
     * // Outputs [30, 30, 30]
     * console.log("The result of the addition is: " + a.toString());
     */
    add(rhs: Vec4$6): Vec4$6;
    /**
     * Adds two 4-dimensional vectors together and returns the result.
     *
     * @param {Vec4} lhs - The first vector operand for the addition.
     * @param {Vec4} rhs - The second vector operand for the addition.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(10, 10, 10, 10);
     * var b = new pc.Vec4(20, 20, 20, 20);
     * var r = new pc.Vec4();
     *
     * r.add2(a, b);
     * // Outputs [30, 30, 30]
     *
     * console.log("The result of the addition is: " + r.toString());
     */
    add2(lhs: Vec4$6, rhs: Vec4$6): Vec4$6;
    /**
     * Adds a number to each element of a vector.
     *
     * @param {number} scalar - The number to add.
     * @returns {Vec4} Self for chaining.
     * @example
     * var vec = new pc.Vec4(3, 4, 5, 6);
     *
     * vec.addScalar(2);
     *
     * // Outputs [5, 6, 7, 8]
     * console.log("The result of the addition is: " + vec.toString());
     */
    addScalar(scalar: number): Vec4$6;
    /**
     * Returns an identical copy of the specified 4-dimensional vector.
     *
     * @returns {Vec4} A 4-dimensional vector containing the result of the cloning.
     * @example
     * var v = new pc.Vec4(10, 20, 30, 40);
     * var vclone = v.clone();
     * console.log("The result of the cloning is: " + vclone.toString());
     */
    clone(): Vec4$6;
    /**
     * Copies the contents of a source 4-dimensional vector to a destination 4-dimensional vector.
     *
     * @param {Vec4} rhs - A vector to copy to the specified vector.
     * @returns {Vec4} Self for chaining.
     * @example
     * var src = new pc.Vec4(10, 20, 30, 40);
     * var dst = new pc.Vec4();
     *
     * dst.copy(src);
     *
     * console.log("The two vectors are " + (dst.equals(src) ? "equal" : "different"));
     */
    copy(rhs: Vec4$6): Vec4$6;
    /**
     * Divides a 4-dimensional vector by another in place.
     *
     * @param {Vec4} rhs - The vector to divide the specified vector by.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(4, 9, 16, 25);
     * var b = new pc.Vec4(2, 3, 4, 5);
     *
     * a.div(b);
     *
     * // Outputs [2, 3, 4, 5]
     * console.log("The result of the division is: " + a.toString());
     */
    div(rhs: Vec4$6): Vec4$6;
    /**
     * Divides one 4-dimensional vector by another and writes the result to the specified vector.
     *
     * @param {Vec4} lhs - The dividend vector (the vector being divided).
     * @param {Vec4} rhs - The divisor vector (the vector dividing the dividend).
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(4, 9, 16, 25);
     * var b = new pc.Vec4(2, 3, 4, 5);
     * var r = new pc.Vec4();
     *
     * r.div2(a, b);
     * // Outputs [2, 3, 4, 5]
     *
     * console.log("The result of the division is: " + r.toString());
     */
    div2(lhs: Vec4$6, rhs: Vec4$6): Vec4$6;
    /**
     * Divides each element of a vector by a number.
     *
     * @param {number} scalar - The number to divide by.
     * @returns {Vec4} Self for chaining.
     * @example
     * var vec = new pc.Vec4(3, 6, 9, 12);
     *
     * vec.divScalar(3);
     *
     * // Outputs [1, 2, 3, 4]
     * console.log("The result of the division is: " + vec.toString());
     */
    divScalar(scalar: number): Vec4$6;
    /**
     * Returns the result of a dot product operation performed on the two specified 4-dimensional
     * vectors.
     *
     * @param {Vec4} rhs - The second 4-dimensional vector operand of the dot product.
     * @returns {number} The result of the dot product operation.
     * @example
     * var v1 = new pc.Vec4(5, 10, 20, 40);
     * var v2 = new pc.Vec4(10, 20, 40, 80);
     * var v1dotv2 = v1.dot(v2);
     * console.log("The result of the dot product is: " + v1dotv2);
     */
    dot(rhs: Vec4$6): number;
    /**
     * Reports whether two vectors are equal.
     *
     * @param {Vec4} rhs - The vector to compare to the specified vector.
     * @returns {boolean} True if the vectors are equal and false otherwise.
     * @example
     * var a = new pc.Vec4(1, 2, 3, 4);
     * var b = new pc.Vec4(5, 6, 7, 8);
     * console.log("The two vectors are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Vec4$6): boolean;
    /**
     * Returns the magnitude of the specified 4-dimensional vector.
     *
     * @returns {number} The magnitude of the specified 4-dimensional vector.
     * @example
     * var vec = new pc.Vec4(3, 4, 0, 0);
     * var len = vec.length();
     * // Outputs 5
     * console.log("The length of the vector is: " + len);
     */
    length(): number;
    /**
     * Returns the magnitude squared of the specified 4-dimensional vector.
     *
     * @returns {number} The magnitude of the specified 4-dimensional vector.
     * @example
     * var vec = new pc.Vec4(3, 4, 0);
     * var len = vec.lengthSq();
     * // Outputs 25
     * console.log("The length squared of the vector is: " + len);
     */
    lengthSq(): number;
    /**
     * Returns the result of a linear interpolation between two specified 4-dimensional vectors.
     *
     * @param {Vec4} lhs - The 4-dimensional to interpolate from.
     * @param {Vec4} rhs - The 4-dimensional to interpolate to.
     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,
     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this
     * range, the linear interpolant will occur on a ray extrapolated from this line.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(0, 0, 0, 0);
     * var b = new pc.Vec4(10, 10, 10, 10);
     * var r = new pc.Vec4();
     *
     * r.lerp(a, b, 0);   // r is equal to a
     * r.lerp(a, b, 0.5); // r is 5, 5, 5, 5
     * r.lerp(a, b, 1);   // r is equal to b
     */
    lerp(lhs: Vec4$6, rhs: Vec4$6, alpha: number): Vec4$6;
    /**
     * Multiplies a 4-dimensional vector to another in place.
     *
     * @param {Vec4} rhs - The 4-dimensional vector used as the second multiplicand of the operation.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(2, 3, 4, 5);
     * var b = new pc.Vec4(4, 5, 6, 7);
     *
     * a.mul(b);
     *
     * // Outputs 8, 15, 24, 35
     * console.log("The result of the multiplication is: " + a.toString());
     */
    mul(rhs: Vec4$6): Vec4$6;
    /**
     * Returns the result of multiplying the specified 4-dimensional vectors together.
     *
     * @param {Vec4} lhs - The 4-dimensional vector used as the first multiplicand of the operation.
     * @param {Vec4} rhs - The 4-dimensional vector used as the second multiplicand of the operation.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(2, 3, 4, 5);
     * var b = new pc.Vec4(4, 5, 6, 7);
     * var r = new pc.Vec4();
     *
     * r.mul2(a, b);
     *
     * // Outputs 8, 15, 24, 35
     * console.log("The result of the multiplication is: " + r.toString());
     */
    mul2(lhs: Vec4$6, rhs: Vec4$6): Vec4$6;
    /**
     * Multiplies each element of a vector by a number.
     *
     * @param {number} scalar - The number to multiply by.
     * @returns {Vec4} Self for chaining.
     * @example
     * var vec = new pc.Vec4(3, 6, 9, 12);
     *
     * vec.mulScalar(3);
     *
     * // Outputs [9, 18, 27, 36]
     * console.log("The result of the multiplication is: " + vec.toString());
     */
    mulScalar(scalar: number): Vec4$6;
    /**
     * Returns this 4-dimensional vector converted to a unit vector in place. If the vector has a
     * length of zero, the vector's elements will be set to zero.
     *
     * @returns {Vec4} Self for chaining.
     * @example
     * var v = new pc.Vec4(25, 0, 0, 0);
     *
     * v.normalize();
     *
     * // Outputs 1, 0, 0, 0
     * console.log("The result of the vector normalization is: " + v.toString());
     */
    normalize(): Vec4$6;
    /**
     * Each element is set to the largest integer less than or equal to its value.
     *
     * @returns {Vec4} Self for chaining.
     */
    floor(): Vec4$6;
    /**
     * Each element is rounded up to the next largest integer.
     *
     * @returns {Vec4} Self for chaining.
     */
    ceil(): Vec4$6;
    /**
     * Each element is rounded up or down to the nearest integer.
     *
     * @returns {Vec4} Self for chaining.
     */
    round(): Vec4$6;
    /**
     * Each element is assigned a value from rhs parameter if it is smaller.
     *
     * @param {Vec4} rhs - The 4-dimensional vector used as the source of elements to compare to.
     * @returns {Vec4} Self for chaining.
     */
    min(rhs: Vec4$6): Vec4$6;
    /**
     * Each element is assigned a value from rhs parameter if it is larger.
     *
     * @param {Vec4} rhs - The 4-dimensional vector used as the source of elements to compare to.
     * @returns {Vec4} Self for chaining.
     */
    max(rhs: Vec4$6): Vec4$6;
    /**
     * Sets the specified 4-dimensional vector to the supplied numerical values.
     *
     * @param {number} x - The value to set on the first component of the vector.
     * @param {number} y - The value to set on the second component of the vector.
     * @param {number} z - The value to set on the third component of the vector.
     * @param {number} w - The value to set on the fourth component of the vector.
     * @returns {Vec4} Self for chaining.
     * @example
     * var v = new pc.Vec4();
     * v.set(5, 10, 20, 40);
     *
     * // Outputs 5, 10, 20, 40
     * console.log("The result of the vector set is: " + v.toString());
     */
    set(x: number, y: number, z: number, w: number): Vec4$6;
    /**
     * Subtracts a 4-dimensional vector from another in place.
     *
     * @param {Vec4} rhs - The vector to add to the specified vector.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(10, 10, 10, 10);
     * var b = new pc.Vec4(20, 20, 20, 20);
     *
     * a.sub(b);
     *
     * // Outputs [-10, -10, -10, -10]
     * console.log("The result of the subtraction is: " + a.toString());
     */
    sub(rhs: Vec4$6): Vec4$6;
    /**
     * Subtracts two 4-dimensional vectors from one another and returns the result.
     *
     * @param {Vec4} lhs - The first vector operand for the subtraction.
     * @param {Vec4} rhs - The second vector operand for the subtraction.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(10, 10, 10, 10);
     * var b = new pc.Vec4(20, 20, 20, 20);
     * var r = new pc.Vec4();
     *
     * r.sub2(a, b);
     *
     * // Outputs [-10, -10, -10, -10]
     * console.log("The result of the subtraction is: " + r.toString());
     */
    sub2(lhs: Vec4$6, rhs: Vec4$6): Vec4$6;
    /**
     * Subtracts a number from each element of a vector.
     *
     * @param {number} scalar - The number to subtract.
     * @returns {Vec4} Self for chaining.
     * @example
     * var vec = new pc.Vec4(3, 4, 5, 6);
     *
     * vec.subScalar(2);
     *
     * // Outputs [1, 2, 3, 4]
     * console.log("The result of the subtraction is: " + vec.toString());
     */
    subScalar(scalar: number): Vec4$6;
    /**
     * Converts the vector to string form.
     *
     * @returns {string} The vector in string form.
     * @example
     * var v = new pc.Vec4(20, 10, 5, 0);
     * // Outputs [20, 10, 5, 0]
     * console.log(v.toString());
     */
    toString(): string;
}

type Quat = Quat$1;
/**
 * A 4x4 matrix.
 */
declare class Mat4$5 {
    static _getPerspectiveHalfSize(halfSize: any, fov: any, aspect: any, znear: any, fovIsHorizontal: any): void;
    /**
     * A constant matrix set to the identity.
     *
     * @type {Mat4}
     * @readonly
     */
    static readonly IDENTITY: Mat4$5;
    /**
     * A constant matrix with all elements set to 0.
     *
     * @type {Mat4}
     * @readonly
     */
    static readonly ZERO: Mat4$5;
    /**
     * Matrix elements in the form of a flat array.
     *
     * @type {Float32Array}
     */
    data: Float32Array;
    /**
     * Adds the specified 4x4 matrices together and stores the result in the current instance.
     *
     * @param {Mat4} lhs - The 4x4 matrix used as the first operand of the addition.
     * @param {Mat4} rhs - The 4x4 matrix used as the second operand of the addition.
     * @returns {Mat4} Self for chaining.
     * @example
     * var m = new pc.Mat4();
     *
     * m.add2(pc.Mat4.IDENTITY, pc.Mat4.ONE);
     *
     * console.log("The result of the addition is: " + m.toString());
     */
    add2(lhs: Mat4$5, rhs: Mat4$5): Mat4$5;
    /**
     * Adds the specified 4x4 matrix to the current instance.
     *
     * @param {Mat4} rhs - The 4x4 matrix used as the second operand of the addition.
     * @returns {Mat4} Self for chaining.
     * @example
     * var m = new pc.Mat4();
     *
     * m.add(pc.Mat4.ONE);
     *
     * console.log("The result of the addition is: " + m.toString());
     */
    add(rhs: Mat4$5): Mat4$5;
    /**
     * Creates a duplicate of the specified matrix.
     *
     * @returns {Mat4} A duplicate matrix.
     * @example
     * var src = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     * var dst = src.clone();
     * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));
     */
    clone(): Mat4$5;
    /**
     * Copies the contents of a source 4x4 matrix to a destination 4x4 matrix.
     *
     * @param {Mat4} rhs - A 4x4 matrix to be copied.
     * @returns {Mat4} Self for chaining.
     * @example
     * var src = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     * var dst = new pc.Mat4();
     * dst.copy(src);
     * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));
     */
    copy(rhs: Mat4$5): Mat4$5;
    /**
     * Reports whether two matrices are equal.
     *
     * @param {Mat4} rhs - The other matrix.
     * @returns {boolean} True if the matrices are equal and false otherwise.
     * @example
     * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     * var b = new pc.Mat4();
     * console.log("The two matrices are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Mat4$5): boolean;
    /**
     * Reports whether the specified matrix is the identity matrix.
     *
     * @returns {boolean} True if the matrix is identity and false otherwise.
     * @example
     * var m = new pc.Mat4();
     * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
     */
    isIdentity(): boolean;
    /**
     * Multiplies the specified 4x4 matrices together and stores the result in the current
     * instance.
     *
     * @param {Mat4} lhs - The 4x4 matrix used as the first multiplicand of the operation.
     * @param {Mat4} rhs - The 4x4 matrix used as the second multiplicand of the operation.
     * @returns {Mat4} Self for chaining.
     * @example
     * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     * var b = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
     * var r = new pc.Mat4();
     *
     * // r = a * b
     * r.mul2(a, b);
     *
     * console.log("The result of the multiplication is: " + r.toString());
     */
    mul2(lhs: Mat4$5, rhs: Mat4$5): Mat4$5;
    /**
     * Multiplies the specified 4x4 matrices together and stores the result in the current
     * instance. This function assumes the matrices are affine transformation matrices, where the
     * upper left 3x3 elements are a rotation matrix, and the bottom left 3 elements are
     * translation. The rightmost column is assumed to be [0, 0, 0, 1]. The parameters are not
     * verified to be in the expected format. This function is faster than general
     * {@link Mat4#mul2}.
     *
     * @param {Mat4} lhs - The affine transformation 4x4 matrix used as the first multiplicand of
     * the operation.
     * @param {Mat4} rhs - The affine transformation 4x4 matrix used as the second multiplicand of
     * the operation.
     * @returns {Mat4} Self for chaining.
     */
    mulAffine2(lhs: Mat4$5, rhs: Mat4$5): Mat4$5;
    /**
     * Multiplies the current instance by the specified 4x4 matrix.
     *
     * @param {Mat4} rhs - The 4x4 matrix used as the second multiplicand of the operation.
     * @returns {Mat4} Self for chaining.
     * @example
     * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     * var b = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
     *
     * // a = a * b
     * a.mul(b);
     *
     * console.log("The result of the multiplication is: " + a.toString());
     */
    mul(rhs: Mat4$5): Mat4$5;
    /**
     * Transforms a 3-dimensional point by a 4x4 matrix.
     *
     * @param {Vec3} vec - The 3-dimensional point to be transformed.
     * @param {Vec3} [res] - An optional 3-dimensional point to receive the result of the
     * transformation.
     * @returns {Vec3} The input point v transformed by the current instance.
     * @example
     * // Create a 3-dimensional point
     * var v = new pc.Vec3(1, 2, 3);
     *
     * // Create a 4x4 rotation matrix
     * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     *
     * var tv = m.transformPoint(v);
     */
    transformPoint(vec: Vec3$1, res?: Vec3$1): Vec3$1;
    /**
     * Transforms a 3-dimensional vector by a 4x4 matrix.
     *
     * @param {Vec3} vec - The 3-dimensional vector to be transformed.
     * @param {Vec3} [res] - An optional 3-dimensional vector to receive the result of the
     * transformation.
     * @returns {Vec3} The input vector v transformed by the current instance.
     * @example
     * // Create a 3-dimensional vector
     * var v = new pc.Vec3(1, 2, 3);
     *
     * // Create a 4x4 rotation matrix
     * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     *
     * var tv = m.transformVector(v);
     */
    transformVector(vec: Vec3$1, res?: Vec3$1): Vec3$1;
    /**
     * Transforms a 4-dimensional vector by a 4x4 matrix.
     *
     * @param {Vec4} vec - The 4-dimensional vector to be transformed.
     * @param {Vec4} [res] - An optional 4-dimensional vector to receive the result of the
     * transformation.
     * @returns {Vec4} The input vector v transformed by the current instance.
     * @example
     * // Create an input 4-dimensional vector
     * var v = new pc.Vec4(1, 2, 3, 4);
     *
     * // Create an output 4-dimensional vector
     * var result = new pc.Vec4();
     *
     * // Create a 4x4 rotation matrix
     * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     *
     * m.transformVec4(v, result);
     */
    transformVec4(vec: Vec4$6, res?: Vec4$6): Vec4$6;
    /**
     * Sets the specified matrix to a viewing matrix derived from an eye point, a target point and
     * an up vector. The matrix maps the target point to the negative z-axis and the eye point to
     * the origin, so that when you use a typical projection matrix, the center of the scene maps
     * to the center of the viewport. Similarly, the direction described by the up vector projected
     * onto the viewing plane is mapped to the positive y-axis so that it points upward in the
     * viewport. The up vector must not be parallel to the line of sight from the eye to the
     * reference point.
     *
     * @param {Vec3} position - 3-d vector holding view position.
     * @param {Vec3} target - 3-d vector holding reference point.
     * @param {Vec3} up - 3-d vector holding the up direction.
     * @returns {Mat4} Self for chaining.
     * @example
     * var position = new pc.Vec3(10, 10, 10);
     * var target = new pc.Vec3(0, 0, 0);
     * var up = new pc.Vec3(0, 1, 0);
     * var m = new pc.Mat4().setLookAt(position, target, up);
     */
    setLookAt(position: Vec3$1, target: Vec3$1, up: Vec3$1): Mat4$5;
    /**
     * Sets the specified matrix to a perspective projection matrix. The function's parameters
     * define the shape of a frustum.
     *
     * @param {number} left - The x-coordinate for the left edge of the camera's projection plane
     * in eye space.
     * @param {number} right - The x-coordinate for the right edge of the camera's projection plane
     * in eye space.
     * @param {number} bottom - The y-coordinate for the bottom edge of the camera's projection
     * plane in eye space.
     * @param {number} top - The y-coordinate for the top edge of the camera's projection plane in
     * eye space.
     * @param {number} znear - The near clip plane in eye coordinates.
     * @param {number} zfar - The far clip plane in eye coordinates.
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 perspective projection matrix
     * var f = pc.Mat4().setFrustum(-2, 2, -1, 1, 1, 1000);
     * @ignore
     */
    setFrustum(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Mat4$5;
    /**
     * Sets the specified matrix to a perspective projection matrix. The function's parameters
     * define the shape of a frustum.
     *
     * @param {number} fov - The frustum's field of view in degrees. The fovIsHorizontal parameter
     * controls whether this is a vertical or horizontal field of view. By default, it's a vertical
     * field of view.
     * @param {number} aspect - The aspect ratio of the frustum's projection plane
     * (width / height).
     * @param {number} znear - The near clip plane in eye coordinates.
     * @param {number} zfar - The far clip plane in eye coordinates.
     * @param {boolean} [fovIsHorizontal=false] - Set to true to treat the fov as horizontal
     * (x-axis) and false for vertical (y-axis). Defaults to false.
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 perspective projection matrix
     * var persp = pc.Mat4().setPerspective(45, 16 / 9, 1, 1000);
     */
    setPerspective(fov: number, aspect: number, znear: number, zfar: number, fovIsHorizontal?: boolean): Mat4$5;
    /**
     * Sets the specified matrix to an orthographic projection matrix. The function's parameters
     * define the shape of a cuboid-shaped frustum.
     *
     * @param {number} left - The x-coordinate for the left edge of the camera's projection plane
     * in eye space.
     * @param {number} right - The x-coordinate for the right edge of the camera's projection plane
     * in eye space.
     * @param {number} bottom - The y-coordinate for the bottom edge of the camera's projection
     * plane in eye space.
     * @param {number} top - The y-coordinate for the top edge of the camera's projection plane in
     * eye space.
     * @param {number} near - The near clip plane in eye coordinates.
     * @param {number} far - The far clip plane in eye coordinates.
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 orthographic projection matrix
     * var ortho = pc.Mat4().ortho(-2, 2, -2, 2, 1, 1000);
     */
    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): Mat4$5;
    /**
     * Sets the specified matrix to a rotation matrix equivalent to a rotation around an axis. The
     * axis must be normalized (unit length) and the angle must be specified in degrees.
     *
     * @param {Vec3} axis - The normalized axis vector around which to rotate.
     * @param {number} angle - The angle of rotation in degrees.
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 rotation matrix
     * var rm = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 90);
     */
    setFromAxisAngle(axis: Vec3$1, angle: number): Mat4$5;
    /**
     * Sets the specified matrix to a translation matrix.
     *
     * @param {number} x - The x-component of the translation.
     * @param {number} y - The y-component of the translation.
     * @param {number} z - The z-component of the translation.
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 translation matrix
     * var tm = new pc.Mat4().setTranslate(10, 10, 10);
     * @ignore
     */
    setTranslate(x: number, y: number, z: number): Mat4$5;
    /**
     * Sets the specified matrix to a scale matrix.
     *
     * @param {number} x - The x-component of the scale.
     * @param {number} y - The y-component of the scale.
     * @param {number} z - The z-component of the scale.
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 scale matrix
     * var sm = new pc.Mat4().setScale(10, 10, 10);
     * @ignore
     */
    setScale(x: number, y: number, z: number): Mat4$5;
    /**
     * Sets the specified matrix to a matrix transforming a normalized view volume (in range of
     * -1 .. 1) to their position inside a viewport (in range of 0 .. 1). This encapsulates a
     * scaling to the size of the viewport and a translation to the position of the viewport.
     *
     * @param {number} x - The x-component of the position of the viewport (in 0..1 range).
     * @param {number} y - The y-component of the position of the viewport (in 0..1 range).
     * @param {number} width - The width of the viewport (in 0..1 range).
     * @param {number} height - The height of the viewport (in 0..1 range).
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 viewport matrix which scales normalized view volume to full texture viewport
     * var vm = new pc.Mat4().setViewport(0, 0, 1, 1);
     * @ignore
     */
    setViewport(x: number, y: number, width: number, height: number): Mat4$5;
    /**
     * Sets the specified matrix to its inverse.
     *
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 rotation matrix of 180 degrees around the y-axis
     * var rot = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
     *
     * // Invert in place
     * rot.invert();
     */
    invert(): Mat4$5;
    /**
     * Sets matrix data from an array.
     *
     * @param {number[]} src - Source array. Must have 16 values.
     * @returns {Mat4} Self for chaining.
     */
    set(src: number[]): Mat4$5;
    /**
     * Sets the specified matrix to the identity matrix.
     *
     * @returns {Mat4} Self for chaining.
     * @example
     * m.setIdentity();
     * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
     */
    setIdentity(): Mat4$5;
    /**
     * Sets the specified matrix to the concatenation of a translation, a quaternion rotation and a
     * scale.
     *
     * @param {Vec3} t - A 3-d vector translation.
     * @param {Quat} r - A quaternion rotation.
     * @param {Vec3} s - A 3-d vector scale.
     * @returns {Mat4} Self for chaining.
     * @example
     * var t = new pc.Vec3(10, 20, 30);
     * var r = new pc.Quat();
     * var s = new pc.Vec3(2, 2, 2);
     *
     * var m = new pc.Mat4();
     * m.setTRS(t, r, s);
     */
    setTRS(t: Vec3$1, r: Quat, s: Vec3$1): Mat4$5;
    /**
     * Sets the specified matrix to its transpose.
     *
     * @returns {Mat4} Self for chaining.
     * @example
     * var m = new pc.Mat4();
     *
     * // Transpose in place
     * m.transpose();
     */
    transpose(): Mat4$5;
    invertTo3x3(res: any): Mat4$5;
    /**
     * Extracts the translational component from the specified 4x4 matrix.
     *
     * @param {Vec3} [t] - The vector to receive the translation of the matrix.
     * @returns {Vec3} The translation of the specified 4x4 matrix.
     * @example
     * // Create a 4x4 matrix
     * var m = new pc.Mat4();
     *
     * // Query the z-axis component
     * var t = new pc.Vec3();
     * m.getTranslation(t);
     */
    getTranslation(t?: Vec3$1): Vec3$1;
    /**
     * Extracts the x-axis from the specified 4x4 matrix.
     *
     * @param {Vec3} [x] - The vector to receive the x axis of the matrix.
     * @returns {Vec3} The x-axis of the specified 4x4 matrix.
     * @example
     * // Create a 4x4 matrix
     * var m = new pc.Mat4();
     *
     * // Query the z-axis component
     * var x = new pc.Vec3();
     * m.getX(x);
     */
    getX(x?: Vec3$1): Vec3$1;
    /**
     * Extracts the y-axis from the specified 4x4 matrix.
     *
     * @param {Vec3} [y] - The vector to receive the y axis of the matrix.
     * @returns {Vec3} The y-axis of the specified 4x4 matrix.
     * @example
     * // Create a 4x4 matrix
     * var m = new pc.Mat4();
     *
     * // Query the z-axis component
     * var y = new pc.Vec3();
     * m.getY(y);
     */
    getY(y?: Vec3$1): Vec3$1;
    /**
     * Extracts the z-axis from the specified 4x4 matrix.
     *
     * @param {Vec3} [z] - The vector to receive the z axis of the matrix.
     * @returns {Vec3} The z-axis of the specified 4x4 matrix.
     * @example
     * // Create a 4x4 matrix
     * var m = new pc.Mat4();
     *
     * // Query the z-axis component
     * var z = new pc.Vec3();
     * m.getZ(z);
     */
    getZ(z?: Vec3$1): Vec3$1;
    /**
     * Extracts the scale component from the specified 4x4 matrix.
     *
     * @param {Vec3} [scale] - Vector to receive the scale.
     * @returns {Vec3} The scale in X, Y and Z of the specified 4x4 matrix.
     * @example
     * // Query the scale component
     * var scale = m.getScale();
     */
    getScale(scale?: Vec3$1): Vec3$1;
    /**
     * Sets the specified matrix to a rotation matrix defined by Euler angles. The Euler angles are
     * specified in XYZ order and in degrees.
     *
     * @param {number} ex - Angle to rotate around X axis in degrees.
     * @param {number} ey - Angle to rotate around Y axis in degrees.
     * @param {number} ez - Angle to rotate around Z axis in degrees.
     * @returns {Mat4} Self for chaining.
     * @example
     * var m = new pc.Mat4();
     * m.setFromEulerAngles(45, 90, 180);
     */
    setFromEulerAngles(ex: number, ey: number, ez: number): Mat4$5;
    /**
     * Extracts the Euler angles equivalent to the rotational portion of the specified matrix. The
     * returned Euler angles are in XYZ order an in degrees.
     *
     * @param {Vec3} [eulers] - A 3-d vector to receive the Euler angles.
     * @returns {Vec3} A 3-d vector containing the Euler angles.
     * @example
     * // Create a 4x4 rotation matrix of 45 degrees around the y-axis
     * var m = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 45);
     *
     * var eulers = m.getEulerAngles();
     */
    getEulerAngles(eulers?: Vec3$1): Vec3$1;
    /**
     * Converts the specified matrix to string form.
     *
     * @returns {string} The matrix in string form.
     * @example
     * var m = new pc.Mat4();
     * // Outputs [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
     * console.log(m.toString());
     */
    toString(): string;
}

type Mat4$4 = Mat4$5;
type BoundingSphere$1 = BoundingSphere$2;
type Ray$2 = Ray$4;
/**
 * Axis-Aligned Bounding Box.
 */
declare class BoundingBox$1 {
    /**
     * Create a new BoundingBox instance. The bounding box is axis-aligned.
     *
     * @param {Vec3} [center] - Center of box. The constructor takes a reference of this parameter.
     * @param {Vec3} [halfExtents] - Half the distance across the box in each axis. The constructor
     * takes a reference of this parameter. Defaults to 0.5 on each axis.
     */
    constructor(center?: Vec3$1, halfExtents?: Vec3$1);
    /**
     * Center of box.
     *
     * @type {Vec3}
     */
    center: Vec3$1;
    /**
     * Half the distance across the box in each axis.
     *
     * @type {Vec3}
     */
    halfExtents: Vec3$1;
    /**
     * @type {Vec3}
     * @private
     */
    private _min;
    /**
     * @type {Vec3}
     * @private
     */
    private _max;
    /**
     * Combines two bounding boxes into one, enclosing both.
     *
     * @param {BoundingBox} other - Bounding box to add.
     */
    add(other: BoundingBox$1): void;
    /**
     * Copies the contents of a source AABB.
     *
     * @param {BoundingBox} src - The AABB to copy from.
     */
    copy(src: BoundingBox$1): void;
    /**
     * Returns a clone of the AABB.
     *
     * @returns {BoundingBox} A duplicate AABB.
     */
    clone(): BoundingBox$1;
    /**
     * Test whether two axis-aligned bounding boxes intersect.
     *
     * @param {BoundingBox} other - Bounding box to test against.
     * @returns {boolean} True if there is an intersection.
     */
    intersects(other: BoundingBox$1): boolean;
    _intersectsRay(ray: any, point: any): boolean;
    _fastIntersectsRay(ray: any): boolean;
    /**
     * Test if a ray intersects with the AABB.
     *
     * @param {Ray} ray - Ray to test against (direction must be normalized).
     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied into here.
     * @returns {boolean} True if there is an intersection.
     */
    intersectsRay(ray: Ray$2, point?: Vec3$1): boolean;
    /**
     * Sets the minimum and maximum corner of the AABB. Using this function is faster than
     * assigning min and max separately.
     *
     * @param {Vec3} min - The minimum corner of the AABB.
     * @param {Vec3} max - The maximum corner of the AABB.
     */
    setMinMax(min: Vec3$1, max: Vec3$1): void;
    /**
     * Return the minimum corner of the AABB.
     *
     * @returns {Vec3} Minimum corner.
     */
    getMin(): Vec3$1;
    /**
     * Return the maximum corner of the AABB.
     *
     * @returns {Vec3} Maximum corner.
     */
    getMax(): Vec3$1;
    /**
     * Test if a point is inside a AABB.
     *
     * @param {Vec3} point - Point to test.
     * @returns {boolean} True if the point is inside the AABB and false otherwise.
     */
    containsPoint(point: Vec3$1): boolean;
    /**
     * Set an AABB to enclose the specified AABB if it were to be transformed by the specified 4x4
     * matrix.
     *
     * @param {BoundingBox} aabb - Box to transform and enclose.
     * @param {Mat4} m - Transformation matrix to apply to source AABB.
     * @param {boolean} ignoreScale - If true is specified, a scale from the matrix is ignored. Defaults to false.
     */
    setFromTransformedAabb(aabb: BoundingBox$1, m: Mat4$4, ignoreScale?: boolean): void;
    /**
     * Compute the size of the AABB to encapsulate all specified vertices.
     *
     * @param {number[]|Float32Array} vertices - The vertices used to compute the new size for the
     * AABB.
     * @param {number} [numVerts] - Number of vertices to use from the beginning of vertices array.
     * All vertices are used if not specified.
     */
    compute(vertices: number[] | Float32Array, numVerts?: number): void;
    /**
     * Test if a Bounding Sphere is overlapping, enveloping, or inside this AABB.
     *
     * @param {BoundingSphere} sphere - Bounding Sphere to test.
     * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping, or inside the
     * AABB and false otherwise.
     */
    intersectsBoundingSphere(sphere: BoundingSphere$1): boolean;
    _distanceToBoundingSphereSq(sphere: any): number;
    _expand(expandMin: any, expandMax: any): void;
}

type Ray$1 = Ray$4;
/**
 * An infinite plane.
 *
 * @ignore
 */
declare class Plane {
    /**
     * Create a new Plane instance.
     *
     * @param {Vec3} [point] - Point position on the plane. The constructor takes a reference of
     * this parameter.
     * @param {Vec3} [normal] - Normal of the plane. The constructor takes a reference of this
     * parameter.
     */
    constructor(point?: Vec3$1, normal?: Vec3$1);
    normal: Vec3$1;
    point: Vec3$1;
    /**
     * Test if the plane intersects between two points.
     *
     * @param {Vec3} start - Start position of line.
     * @param {Vec3} end - End position of line.
     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied
     * into here.
     * @returns {boolean} True if there is an intersection.
     */
    intersectsLine(start: Vec3$1, end: Vec3$1, point?: Vec3$1): boolean;
    /**
     * Test if a ray intersects with the infinite plane.
     *
     * @param {Ray} ray - Ray to test against (direction must be normalized).
     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied
     * into here.
     * @returns {boolean} True if there is an intersection.
     */
    intersectsRay(ray: Ray$1, point?: Vec3$1): boolean;
}

declare class Version {
    globalId: number;
    revision: number;
    equals(other: any): boolean;
    copy(other: any): void;
    reset(): void;
}

declare class VersionedObject {
    version: Version;
    increment(): void;
}

/**
 * The scope for a variable.
 */
declare class ScopeId$1 {
    /**
     * Create a new ScopeId instance.
     *
     * @param {string} name - The variable name.
     */
    constructor(name: string);
    /**
     * The variable name.
     *
     * @type {string}
     */
    name: string;
    value: any;
    versionObject: VersionedObject;
    /**
     * Set variable value.
     *
     * @param {*} value - The value.
     */
    setValue(value: any): void;
    /**
     * Get variable value.
     *
     * @returns {*} The value.
     */
    getValue(): any;
}

type GraphicsDevice$p = GraphicsDevice$l;
/** @typedef {import('./graphics-device.js').GraphicsDevice} GraphicsDevice */
/**
 * A vertex format is a descriptor that defines the layout of vertex data inside a
 * {@link VertexBuffer}.
 *
 * @property {object[]} elements The vertex attribute elements.
 * @property {string} elements[].name The meaning of the vertex element. This is used to link the
 * vertex data to a shader input. Can be:
 *
 * - {@link SEMANTIC_POSITION}
 * - {@link SEMANTIC_NORMAL}
 * - {@link SEMANTIC_TANGENT}
 * - {@link SEMANTIC_BLENDWEIGHT}
 * - {@link SEMANTIC_BLENDINDICES}
 * - {@link SEMANTIC_COLOR}
 * - {@link SEMANTIC_TEXCOORD0}
 * - {@link SEMANTIC_TEXCOORD1}
 * - {@link SEMANTIC_TEXCOORD2}
 * - {@link SEMANTIC_TEXCOORD3}
 * - {@link SEMANTIC_TEXCOORD4}
 * - {@link SEMANTIC_TEXCOORD5}
 * - {@link SEMANTIC_TEXCOORD6}
 * - {@link SEMANTIC_TEXCOORD7}
 *
 * If vertex data has a meaning other that one of those listed above, use the user-defined
 * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.
 * @property {number} elements[].numComponents The number of components of the vertex attribute.
 * Can be 1, 2, 3 or 4.
 * @property {number} elements[].dataType The data type of the attribute. Can be:
 *
 * - {@link TYPE_INT8}
 * - {@link TYPE_UINT8}
 * - {@link TYPE_INT16}
 * - {@link TYPE_UINT16}
 * - {@link TYPE_INT32}
 * - {@link TYPE_UINT32}
 * - {@link TYPE_FLOAT32}
 * @property {boolean} elements[].normalize If true, vertex attribute data will be mapped from a 0
 * to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data is left
 * unchanged. If this property is unspecified, false is assumed.
 * @property {number} elements[].offset The number of initial bytes at the start of a vertex that
 * are not relevant to this attribute.
 * @property {number} elements[].stride The number of total bytes that are between the start of one
 * vertex, and the start of the next.
 * @property {number} elements[].size The size of the attribute in bytes.
 */
declare class VertexFormat$2 {
    /**
     * @type {VertexFormat}
     * @private
     */
    private static _defaultInstancingFormat;
    /**
     * Initialize a default format use for instanced rendering.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to create the format.
     * @ignore
     */
    static init(graphicsDevice: GraphicsDevice$p): void;
    /**
     * The {@link VertexFormat} used to store matrices of type {@link Mat4} for hardware instancing.
     *
     * @type {VertexFormat}
     */
    static get defaultInstancingFormat(): VertexFormat$2;
    /**
     * Create a new VertexFormat instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this vertex format.
     * @param {object[]} description - An array of vertex attribute descriptions.
     * @param {string} description[].semantic - The meaning of the vertex element. This is used to link
     * the vertex data to a shader input. Can be:
     *
     * - {@link SEMANTIC_POSITION}
     * - {@link SEMANTIC_NORMAL}
     * - {@link SEMANTIC_TANGENT}
     * - {@link SEMANTIC_BLENDWEIGHT}
     * - {@link SEMANTIC_BLENDINDICES}
     * - {@link SEMANTIC_COLOR}
     * - {@link SEMANTIC_TEXCOORD0}
     * - {@link SEMANTIC_TEXCOORD1}
     * - {@link SEMANTIC_TEXCOORD2}
     * - {@link SEMANTIC_TEXCOORD3}
     * - {@link SEMANTIC_TEXCOORD4}
     * - {@link SEMANTIC_TEXCOORD5}
     * - {@link SEMANTIC_TEXCOORD6}
     * - {@link SEMANTIC_TEXCOORD7}
     *
     * If vertex data has a meaning other that one of those listed above, use the user-defined
     * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.
     * @param {number} description[].components - The number of components of the vertex attribute.
     * Can be 1, 2, 3 or 4.
     * @param {number} description[].type - The data type of the attribute. Can be:
     *
     * - {@link TYPE_INT8}
     * - {@link TYPE_UINT8}
     * - {@link TYPE_INT16}
     * - {@link TYPE_UINT16}
     * - {@link TYPE_INT32}
     * - {@link TYPE_UINT32}
     * - {@link TYPE_FLOAT32}
     *
     * @param {boolean} [description[].normalize] - If true, vertex attribute data will be mapped
     * from a 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data
     * is left unchanged. If this property is unspecified, false is assumed.
     * @param {number} [vertexCount] - When specified, vertex format will be set up for
     * non-interleaved format with a specified number of vertices. (example: PPPPNNNNCCCC), where
     * arrays of individual attributes will be stored one right after the other (subject to
     * alignment requirements). Note that in this case, the format depends on the number of
     * vertices, and needs to change when the number of vertices changes. When not specified,
     * vertex format will be interleaved. (example: PNCPNCPNCPNC).
     * @example
     * // Specify 3-component positions (x, y, z)
     * var vertexFormat = new pc.VertexFormat(graphicsDevice, [
     *     { semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }
     * ]);
     * @example
     * // Specify 2-component positions (x, y), a texture coordinate (u, v) and a vertex color (r, g, b, a)
     * var vertexFormat = new pc.VertexFormat(graphicsDevice, [
     *     { semantic: pc.SEMANTIC_POSITION, components: 2, type: pc.TYPE_FLOAT32 },
     *     { semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 },
     *     { semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_UINT8, normalize: true }
     * ]);
     */
    constructor(graphicsDevice: GraphicsDevice$p, description: {
        semantic: string;
        components: number;
        type: number;
        normalize?: boolean;
    }[], vertexCount?: number);
    elements: {
        name: string;
        offset: any;
        stride: any;
        dataType: number;
        numComponents: number;
        normalize: boolean;
        size: number;
    }[];
    hasUv0: boolean;
    hasUv1: boolean;
    hasColor: boolean;
    hasTangents: boolean;
    verticesByteSize: number;
    vertexCount: number;
    interleaved: boolean;
    size: number;
    /**
     * Applies any changes made to the VertexFormat's properties.
     */
    update(): void;
    /**
     * Evaluates hash values for the format allowing fast compare of batching / rendering compatibility.
     *
     * @private
     */
    private _evaluateHash;
    batchingHash: number;
    renderingingHash: number;
}

type GraphicsDevice$o = GraphicsDevice$l;
type VertexFormat$1 = VertexFormat$2;
/**
 * A vertex buffer is the mechanism via which the application specifies vertex data to the graphics
 * hardware.
 */
declare class VertexBuffer$3 {
    /**
     * Create a new VertexBuffer instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this vertex
     * buffer.
     * @param {VertexFormat} format - The vertex format of this vertex buffer.
     * @param {number} numVertices - The number of vertices that this vertex buffer will hold.
     * @param {number} [usage] - The usage type of the vertex buffer (see BUFFER_*). Defaults to BUFFER_STATIC.
     * @param {ArrayBuffer} [initialData] - Initial data.
     */
    constructor(graphicsDevice: GraphicsDevice$o, format: VertexFormat$1, numVertices: number, usage?: number, initialData?: ArrayBuffer);
    device: GraphicsDevice$l;
    format: VertexFormat$2;
    numVertices: number;
    usage: number;
    id: number;
    _vao: any;
    instancing: boolean;
    numBytes: number;
    storage: ArrayBuffer;
    /**
     * Frees resources associated with this vertex buffer.
     */
    destroy(): void;
    bufferId: WebGLBuffer;
    /**
     * Called when the WebGL context was lost. It releases all context related resources.
     *
     * @ignore
     */
    loseContext(): void;
    /**
     * Returns the data format of the specified vertex buffer.
     *
     * @returns {VertexFormat} The data format of the specified vertex buffer.
     */
    getFormat(): VertexFormat$1;
    /**
     * Returns the usage type of the specified vertex buffer. This indicates whether the buffer can
     * be modified once and used many times {@link BUFFER_STATIC}, modified repeatedly and used
     * many times {@link BUFFER_DYNAMIC} or modified once and used at most a few times
     * {@link BUFFER_STREAM}.
     *
     * @returns {number} The usage type of the vertex buffer (see BUFFER_*).
     */
    getUsage(): number;
    /**
     * Returns the number of vertices stored in the specified vertex buffer.
     *
     * @returns {number} The number of vertices stored in the vertex buffer.
     */
    getNumVertices(): number;
    /**
     * Returns a mapped memory block representing the content of the vertex buffer.
     *
     * @returns {ArrayBuffer} An array containing the byte data stored in the vertex buffer.
     */
    lock(): ArrayBuffer;
    /**
     * Notifies the graphics engine that the client side copy of the vertex buffer's memory can be
     * returned to the control of the graphics driver.
     */
    unlock(): void;
    /**
     * Copies data into vertex buffer's memory.
     *
     * @param {ArrayBuffer} [data] - Source data to copy.
     * @returns {boolean} True if function finished successfully, false otherwise.
     */
    setData(data?: ArrayBuffer): boolean;
}

type GraphicsDevice$n = GraphicsDevice$l;
/** @typedef {import('./graphics-device.js').GraphicsDevice} GraphicsDevice */
/**
 * A shader is a program that is responsible for rendering graphical primitives on a device's
 * graphics processor. The shader is generated from a shader definition. This shader definition
 * specifies the code for processing vertices and fragments processed by the GPU. The language of
 * the code is GLSL (or more specifically ESSL, the OpenGL ES Shading Language). The shader
 * definition also describes how the PlayCanvas engine should map vertex buffer elements onto the
 * attributes specified in the vertex shader code.
 */
declare class Shader$4 {
    /**
     * Creates a new Shader instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this shader.
     * @param {object} definition - The shader definition from which to build the shader.
     * @param {Object.<string, string>} definition.attributes - Object detailing the mapping of
     * vertex shader attribute names to semantics SEMANTIC_*. This enables the engine to match
     * vertex buffer data as inputs to the shader.
     * @param {string} definition.vshader - Vertex shader source (GLSL code).
     * @param {string} definition.fshader - Fragment shader source (GLSL code).
     * @param {boolean} [definition.useTransformFeedback] - Specifies that this shader outputs
     * post-VS data to a buffer.
     * @example
     * // Create a shader that renders primitives with a solid red color
     * var shaderDefinition = {
     *     attributes: {
     *         aPosition: pc.SEMANTIC_POSITION
     *     },
     *     vshader: [
     *         "attribute vec3 aPosition;",
     *         "",
     *         "void main(void)",
     *         "{",
     *         "    gl_Position = vec4(aPosition, 1.0);",
     *         "}"
     *     ].join("\n"),
     *     fshader: [
     *         "precision " + graphicsDevice.precision + " float;",
     *         "",
     *         "void main(void)",
     *         "{",
     *         "    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);",
     *         "}"
     *     ].join("\n")
     * };
     *
     * var shader = new pc.Shader(graphicsDevice, shaderDefinition);
     */
    constructor(graphicsDevice: GraphicsDevice$n, definition: {
        attributes: {
            [x: string]: string;
        };
        vshader: string;
        fshader: string;
        useTransformFeedback?: boolean;
    });
    device: GraphicsDevice$l;
    definition: {
        attributes: {
            [x: string]: string;
        };
        vshader: string;
        fshader: string;
        useTransformFeedback?: boolean;
    };
    /**
     * Initialize a shader back to its default state.
     *
     * @private
     */
    private init;
    attributes: any[];
    uniforms: any[];
    samplers: any[];
    ready: boolean;
    failed: boolean;
    /**
     * Frees resources associated with this shader.
     */
    destroy(): void;
    /**
     * Called when the WebGL context was lost. It releases all context related resources.
     *
     * @ignore
     */
    loseContext(): void;
}

type GraphicsDevice$m = GraphicsDevice$l;
/** @typedef {import('./graphics-device.js').GraphicsDevice} GraphicsDevice */
/**
 * An index buffer stores index values into a {@link VertexBuffer}. Indexed graphical primitives
 * can normally utilize less memory that unindexed primitives (if vertices are shared).
 *
 * Typically, index buffers are set on {@link Mesh} objects.
 */
declare class IndexBuffer$1 {
    /**
     * Create a new IndexBuffer instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this index
     * buffer.
     * @param {number} format - The type of each index to be stored in the index buffer. Can be:
     *
     * - {@link INDEXFORMAT_UINT8}
     * - {@link INDEXFORMAT_UINT16}
     * - {@link INDEXFORMAT_UINT32}
     * @param {number} numIndices - The number of indices to be stored in the index buffer.
     * @param {number} [usage] - The usage type of the vertex buffer. Can be:
     *
     * - {@link BUFFER_DYNAMIC}
     * - {@link BUFFER_STATIC}
     * - {@link BUFFER_STREAM}
     *
     * Defaults to {@link BUFFER_STATIC}.
     * @param {ArrayBuffer} [initialData] - Initial data. If left unspecified, the index buffer
     * will be initialized to zeros.
     * @example
     * // Create an index buffer holding 3 16-bit indices. The buffer is marked as
     * // static, hinting that the buffer will never be modified.
     * var indices = new UInt16Array([0, 1, 2]);
     * var indexBuffer = new pc.IndexBuffer(graphicsDevice,
     *                                      pc.INDEXFORMAT_UINT16,
     *                                      3,
     *                                      pc.BUFFER_STATIC,
     *                                      indices);
     */
    constructor(graphicsDevice: GraphicsDevice$m, format: number, numIndices: number, usage?: number, initialData?: ArrayBuffer);
    device: GraphicsDevice$l;
    format: number;
    numIndices: number;
    usage: number;
    glFormat: number;
    bytesPerIndex: number;
    numBytes: number;
    storage: ArrayBuffer;
    /**
     * Frees resources associated with this index buffer.
     */
    destroy(): void;
    bufferId: WebGLBuffer;
    /**
     * Called when the WebGL context was lost. It releases all context related resources.
     *
     * @ignore
     */
    loseContext(): void;
    /**
     * Returns the data format of the specified index buffer.
     *
     * @returns {number} The data format of the specified index buffer. Can be:
     *
     * - {@link INDEXFORMAT_UINT8}
     * - {@link INDEXFORMAT_UINT16}
     * - {@link INDEXFORMAT_UINT32}
     */
    getFormat(): number;
    /**
     * Returns the number of indices stored in the specified index buffer.
     *
     * @returns {number} The number of indices stored in the specified index buffer.
     */
    getNumIndices(): number;
    /**
     * Gives access to the block of memory that stores the buffer's indices.
     *
     * @returns {ArrayBuffer} A contiguous block of memory where index data can be written to.
     */
    lock(): ArrayBuffer;
    /**
     * Signals that the block of memory returned by a call to the lock function is ready to be
     * given to the graphics hardware. Only unlocked index buffers can be set on the currently
     * active device.
     */
    unlock(): void;
    /**
     * Set preallocated data on the index buffer.
     *
     * @param {ArrayBuffer} data - The index data to set.
     * @returns {boolean} True if the data was set successfully, false otherwise.
     * @ignore
     */
    setData(data: ArrayBuffer): boolean;
    /**
     * Get the appropriate typed array from an index buffer.
     *
     * @returns {Uint8Array|Uint16Array|Uint32Array} The typed array containing the index data.
     * @private
     */
    private _lockTypedArray;
    /**
     * Copies the specified number of elements from data into index buffer. Optimized for
     * performance from both typed array as well as array.
     *
     * @param {Uint8Array|Uint16Array|Uint32Array|number[]} data - The data to write.
     * @param {number} count - The number of indices to write.
     * @ignore
     */
    writeData(data: Uint8Array | Uint16Array | Uint32Array | number[], count: number): void;
    /**
     * Copies index data from index buffer into provided data array.
     *
     * @param {Uint8Array|Uint16Array|Uint32Array|number[]} data - The data array to write to.
     * @returns {number} The number of indices read.
     * @ignore
     */
    readData(data: Uint8Array | Uint16Array | Uint32Array | number[]): number;
}

/**
 * The scope for variables.
 */
declare class ScopeSpace {
    /**
     * Create a new ScopeSpace instance.
     *
     * @param {string} name - The scope name.
     */
    constructor(name: string);
    /**
     * The scope name.
     *
     * @type {string}
     */
    name: string;
    variables: Map<any, any>;
    /**
     * Get (or create, if it doesn't already exist) a variable in the scope.
     *
     * @param {string} name - The variable name.
     * @returns {ScopeId} The variable instance.
     */
    resolve(name: string): ScopeId$1;
    /**
     * Clears value for any uniform with matching value (used to remove deleted textures).
     *
     * @param {*} value - The value to clear.
     * @ignore
     */
    removeValue(value: any): void;
}

declare class ProgramLibrary {
    constructor(device: any);
    _device: any;
    _cache: {};
    _generators: {};
    _isClearingCache: boolean;
    _precached: boolean;
    _programsCollection: any[];
    _defaultStdMatOption: {};
    _defaultStdMatOptionMin: {};
    register(name: any, generator: any): void;
    unregister(name: any): void;
    isRegistered(name: any): boolean;
    getProgram(name: any, options: any): any;
    storeNewProgram(name: any, options: any): void;
    dumpPrograms(): void;
    clearCache(): void;
    removeFromCache(shader: any): void;
    _getDefaultStdMatOptions(pass: any): {};
    precompile(cache: any): void;
}

type Texture$9 = Texture$8;
/**
 * A render target is a rectangular rendering surface.
 */
declare class RenderTarget$3 {
    /**
     * Creates a new RenderTarget instance. A color buffer or a depth buffer must be set.
     *
     * @param {object} options - Object for passing optional arguments.
     * @param {boolean} [options.autoResolve] - If samples > 1, enables or disables automatic MSAA
     * resolve after rendering to this RT (see {@link RenderTarget#resolve}). Defaults to true.
     * @param {Texture} [options.colorBuffer] - The texture that this render target will treat as a
     * rendering surface.
     * @param {boolean} [options.depth] - If set to true, depth buffer will be created. Defaults to
     * true. Ignored if depthBuffer is defined.
     * @param {Texture} [options.depthBuffer] - The texture that this render target will treat as a
     * depth/stencil surface (WebGL2 only). If set, the 'depth' and 'stencil' properties are
     * ignored. Texture must have {@link PIXELFORMAT_DEPTH} or {@link PIXELFORMAT_DEPTHSTENCIL}
     * format.
     * @param {number} [options.face] - If the colorBuffer parameter is a cubemap, use this option
     * to specify the face of the cubemap to render to. Can be:
     *
     * - {@link CUBEFACE_POSX}
     * - {@link CUBEFACE_NEGX}
     * - {@link CUBEFACE_POSY}
     * - {@link CUBEFACE_NEGY}
     * - {@link CUBEFACE_POSZ}
     * - {@link CUBEFACE_NEGZ}
     *
     * Defaults to {@link CUBEFACE_POSX}.
     * @param {boolean} [options.flipY] - When set to true the image will be flipped in Y. Default
     * is false.
     * @param {string} [options.name] - The name of the render target.
     * @param {number} [options.samples] - Number of hardware anti-aliasing samples (WebGL2 only).
     * Default is 1.
     * @param {boolean} [options.stencil] - If set to true, depth buffer will include stencil.
     * Defaults to false. Ignored if depthBuffer is defined or depth is false.
     * @example
     * // Create a 512x512x24-bit render target with a depth buffer
     * var colorBuffer = new pc.Texture(graphicsDevice, {
     *     width: 512,
     *     height: 512,
     *     format: pc.PIXELFORMAT_R8_G8_B8
     * });
     * var renderTarget = new pc.RenderTarget({
     *     colorBuffer: colorBuffer,
     *     depth: true
     * });
     *
     * // Set the render target on a camera component
     * camera.renderTarget = renderTarget;
     *
     * // Destroy render target at a later stage. Note that the color buffer needs
     * // to be destroyed separately.
     * renderTarget.colorBuffer.destroy();
     * renderTarget.destroy();
     * camera.renderTarget = null;
     */
    constructor(options: {
        autoResolve?: boolean;
        colorBuffer?: Texture$9;
        depth?: boolean;
        depthBuffer?: Texture$9;
        face?: number;
        flipY?: boolean;
        name?: string;
        samples?: number;
        stencil?: boolean;
    }, ...args: any[]);
    _colorBuffer: any;
    _glFrameBuffer: any;
    _glDepthBuffer: any;
    _depthBuffer: Texture$8;
    _face: number;
    _depth: boolean;
    _stencil: boolean;
    _device: any;
    _samples: number;
    autoResolve: boolean;
    _glResolveFrameBuffer: any;
    _glMsaaColorBuffer: any;
    _glMsaaDepthBuffer: any;
    name: any;
    flipY: boolean;
    /**
     * Frees resources associated with this render target.
     */
    destroy(): void;
    /**
     * Free WebGL resources associated with this render target.
     *
     * @ignore
     */
    destroyFrameBuffers(): void;
    /**
     * Free textures associated with this render target.
     *
     * @ignore
     */
    destroyTextureBuffers(): void;
    /**
     * Called when the WebGL context was lost. It releases all context related resources.
     *
     * @ignore
     */
    loseContext(): void;
    /**
     * If samples > 1, resolves the anti-aliased render target (WebGL2 only). When you're rendering
     * to an anti-aliased render target, pixels aren't written directly to the readable texture.
     * Instead, they're first written to a MSAA buffer, where each sample for each pixel is stored
     * independently. In order to read the results, you first need to 'resolve' the buffer - to
     * average all samples and create a simple texture with one color per pixel. This function
     * performs this averaging and updates the colorBuffer and the depthBuffer. If autoResolve is
     * set to true, the resolve will happen after every rendering to this render target, otherwise
     * you can do it manually, during the app update or inside a {@link Command}.
     *
     * @param {boolean} [color] - Resolve color buffer. Defaults to true.
     * @param {boolean} [depth] - Resolve depth buffer. Defaults to true if the render target has a
     * depth buffer.
     */
    resolve(color?: boolean, depth?: boolean): void;
    /**
     * Copies color and/or depth contents of source render target to this one. Formats, sizes and
     * anti-aliasing samples must match. Depth buffer can only be copied on WebGL 2.0.
     *
     * @param {RenderTarget} source - Source render target to copy from.
     * @param {boolean} [color] - If true will copy the color buffer. Defaults to false.
     * @param {boolean} [depth] - If true will copy the depth buffer. Defaults to false.
     * @returns {boolean} True if the copy was successful, false otherwise.
     */
    copy(source: RenderTarget$3, color?: boolean, depth?: boolean): boolean;
    /**
     * Color buffer set up on the render target.
     *
     * @type {Texture}
     */
    get colorBuffer(): Texture$8;
    /**
     * Depth buffer set up on the render target. Only available, if depthBuffer was set in
     * constructor. Not available if depth property was used instead.
     *
     * @type {Texture}
     */
    get depthBuffer(): Texture$8;
    /**
     * If the render target is bound to a cubemap, this property specifies which face of the
     * cubemap is rendered to. Can be:
     *
     * - {@link CUBEFACE_POSX}
     * - {@link CUBEFACE_NEGX}
     * - {@link CUBEFACE_POSY}
     * - {@link CUBEFACE_NEGY}
     * - {@link CUBEFACE_POSZ}
     * - {@link CUBEFACE_NEGZ}
     *
     * @type {number}
     */
    get face(): number;
    /**
     * Width of the render target in pixels.
     *
     * @type {number}
     */
    get width(): number;
    /**
     * Height of the render target in pixels.
     *
     * @type {number}
     */
    get height(): number;
}

/**
 * A class used by the graphics device to handle the capture of the current framebuffer into a
 * texture to be used by following draw calls to implement refraction.
 *
 * @ignore
 */
declare class GrabPass {
    /**
     * Create a new GrabPass instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this grab pass.
     * @param {boolean} useAlpha - Whether the grab pass should have an alpha channel.
     */
    constructor(device: any, useAlpha: boolean);
    device: any;
    useAlpha: boolean;
    useMipmaps: any;
    texture: Texture$8;
    renderTarget: RenderTarget$3;
    textureId: any;
    /**
     * Release the grab pass resources.
     */
    destroy(): void;
    /**
     * Create the texture and render target used by the grab pass.
     */
    create(): void;
    /**
     * Resolve/copy the backbuffer into the grab pass render target.
     *
     * @returns {boolean} - Whether the grab pass was successfully resolved or not.
     */
    update(): boolean;
    /**
     * Generate mipmaps for the grab pass texture.
     */
    generateMipmaps(): void;
    /**
     * Grab a copy of the frame buffer to a texture and generate mipmaps for it.
     *
     * @returns {boolean} - Whether the grab pass was successfully updated or not.
     */
    prepareTexture(): boolean;
}

type IndexBuffer = IndexBuffer$1;
type Shader$3 = Shader$4;
type VertexBuffer$2 = VertexBuffer$3;
/**
 * @event
 * @name GraphicsDevice#resizecanvas
 * @description The 'resizecanvas' event is fired when the canvas is resized.
 * @param {number} width - The new width of the canvas in pixels.
 * @param {number} height - The new height of the canvas in pixels.
 */
/**
 * The graphics device manages the underlying graphics context. It is responsible for submitting
 * render state changes and graphics primitives to the hardware. A graphics device is tied to a
 * specific canvas HTML element. It is valid to have more than one canvas element per page and
 * create a new graphics device against each.
 *
 * @augments EventHandler
 */
declare class GraphicsDevice$l extends EventHandler$1 {
    /**
     * Creates a new GraphicsDevice instance.
     *
     * @param {HTMLCanvasElement} canvas - The canvas to which the graphics device will render.
     * @param {object} [options] - Options passed when creating the WebGL context.
     * @param {boolean} [options.alpha=true] - Boolean that indicates if the canvas contains an
     * alpha buffer.
     * @param {boolean} [options.depth=true] - Boolean that indicates that the drawing buffer is
     * requested to have a depth buffer of at least 16 bits.
     * @param {boolean} [options.stencil=false] - Boolean that indicates that the drawing buffer is
     * requested to have a stencil buffer of at least 8 bits.
     * @param {boolean} [options.antialias=true] - Boolean that indicates whether or not to perform
     * anti-aliasing if possible.
     * @param {boolean} [options.premultipliedAlpha=true] - Boolean that indicates that the page
     * compositor will assume the drawing buffer contains colors with pre-multiplied alpha.
     * @param {boolean} [options.preserveDrawingBuffer=false] - If the value is true the buffers
     * will not be cleared and will preserve their values until cleared or overwritten by the
     * author.
     * @param {'default'|'high-performance'|'low-power'} [options.powerPreference ='default'] - A
     * hint to the user agent indicating what configuration of GPU is suitable for the WebGL
     * context. Possible values are:
     *
     * - 'default': Let the user agent decide which GPU configuration is most suitable. This is the
     * default value.
     * - 'high-performance': Prioritizes rendering performance over power consumption.
     * - 'low-power': Prioritizes power saving over rendering performance.
     *
     * @param {boolean} [options.failIfMajorPerformanceCaveat=false] - Boolean that indicates if a
     * context will be created if the system performance is low or if no hardware GPU is available.
     * @param {boolean} [options.desynchronized=false] - Boolean that hints the user agent to
     * reduce the latency by desynchronizing the canvas paint cycle from the event loop.
     */
    constructor(canvas: HTMLCanvasElement, options?: {
        alpha?: boolean;
        depth?: boolean;
        stencil?: boolean;
        antialias?: boolean;
        premultipliedAlpha?: boolean;
        preserveDrawingBuffer?: boolean;
        powerPreference?: 'default' | 'high-performance' | 'low-power';
        failIfMajorPerformanceCaveat?: boolean;
        desynchronized?: boolean;
    });
    /**
     * The canvas DOM element that provides the underlying WebGL context used by the graphics device.
     *
     * @type {HTMLCanvasElement}
     */
    canvas: HTMLCanvasElement;
    /**
     * The WebGL context managed by the graphics device. The type could also technically be
     * `WebGLRenderingContext` if WebGL 2.0 is not available. But in order for IntelliSense to be
     * able to function for all WebGL calls in the codebase, we specify `WebGL2RenderingContext`
     * here instead.
     *
     * @type {WebGL2RenderingContext}
     * @ignore
     */
    gl: WebGL2RenderingContext;
    /**
     * The maximum supported texture anisotropy setting.
     *
     * @type {number}
     */
    maxAnisotropy: number;
    /**
     * The maximum supported dimension of a cube map.
     *
     * @type {number}
     */
    maxCubeMapSize: number;
    /**
     * The maximum supported dimension of a texture.
     *
     * @type {number}
     */
    maxTextureSize: number;
    /**
     * The maximum supported dimension of a 3D texture (any axis).
     *
     * @type {number}
     */
    maxVolumeSize: number;
    /**
     * The highest shader precision supported by this graphics device. Can be 'hiphp', 'mediump' or
     * 'lowp'.
     *
     * @type {string}
     */
    precision: string;
    /**
     * The scope namespace for shader attributes and variables.
     *
     * @type {ScopeSpace}
     */
    scope: ScopeSpace;
    /**
     * True if hardware instancing is supported.
     *
     * @type {boolean}
     */
    supportsInstancing: boolean;
    /**
     * True if 32-bit floating-point textures can be used as a frame buffer.
     *
     * @type {boolean}
     */
    textureFloatRenderable: boolean;
    /**
     * True if 16-bit floating-point textures can be used as a frame buffer.
     *
     * @type {boolean}
     */
    textureHalfFloatRenderable: boolean;
    /**
     * True if the WebGL context of this device is using the WebGL 2.0 API. If false, WebGL 1.0 is
     * being used.
     *
     * @type {boolean}
     * @ignore
     */
    webgl2: boolean;
    _enableAutoInstancing: boolean;
    autoInstancingMaxObjects: number;
    defaultFramebuffer: any;
    _maxPixelRatio: number;
    _width: number;
    _height: number;
    shaders: any[];
    buffers: any[];
    textures: any[];
    targets: any[];
    contextLost: boolean;
    _contextLostHandler: (event: any) => void;
    _contextRestoredHandler: () => void;
    _tempEnableSafariTextureUnitWorkaround: boolean;
    _tempMacChromeBlitFramebufferWorkaround: boolean;
    defaultClearOptions: {
        color: number[];
        depth: number;
        stencil: number;
        flags: number;
    };
    glAddress: any[];
    glBlendEquation: any[];
    glBlendFunction: any[];
    glComparison: any[];
    glStencilOp: any[];
    glClearFlag: any[];
    glCull: any[];
    glFilter: any[];
    glPrimitive: any[];
    glType: any[];
    pcUniformType: {};
    targetToSlot: {};
    commitFunction: {}[];
    programLib: ProgramLibrary;
    supportsBoneTextures: boolean;
    boneLimit: number;
    _drawCallsPerFrame: number;
    _shaderSwitchesPerFrame: number;
    _primsPerFrame: number[];
    _renderTargetCreationTime: number;
    _vram: {
        texShadow: number;
        texAsset: number;
        texLightmap: number;
        tex: number;
        vb: number;
        ib: number;
    };
    _shaderStats: {
        vsCompiled: number;
        fsCompiled: number;
        linked: number;
        materialShaders: number;
        compileTime: number;
    };
    constantTexSource: ScopeId$1;
    supportsMorphTargetTexturesCore: boolean;
    _textureFloatHighPrecision: boolean;
    _textureHalfFloatUpdatable: boolean;
    _spectorMarkers: any[];
    _spectorCurrentMarker: string;
    grabPassAvailable: boolean;
    grabPass: GrabPass;
    _destroyedTextures: Set<any>;
    areaLightLutFormat: number;
    /**
     * Destroy the graphics device.
     */
    destroy(): void;
    toJSON(key: any): any;
    updateMarker(): void;
    pushMarker(name: any): void;
    popMarker(): void;
    /**
     * Query the precision supported by ints and floats in vertex and fragment shaders. Note that
     * getShaderPrecisionFormat is not guaranteed to be present (such as some instances of the
     * default Android browser). In this case, assume highp is available.
     *
     * @returns {string} "highp", "mediump" or "lowp"
     * @ignore
     */
    getPrecision(): string;
    /**
     * Initialize the extensions provided by the WebGL context.
     *
     * @ignore
     */
    initializeExtensions(): void;
    extBlendMinmax: boolean | EXT_blend_minmax;
    extDrawBuffers: boolean | EXT_blend_minmax;
    extInstancing: boolean | EXT_blend_minmax;
    extStandardDerivatives: boolean | EXT_blend_minmax;
    extTextureFloat: boolean | EXT_blend_minmax;
    extTextureHalfFloat: boolean | EXT_blend_minmax;
    extTextureLod: boolean | EXT_blend_minmax;
    extUintElement: boolean | EXT_blend_minmax;
    extVertexArrayObject: boolean | EXT_blend_minmax;
    extColorBufferFloat: EXT_blend_minmax;
    extDisjointTimerQuery: EXT_blend_minmax;
    extDebugRendererInfo: EXT_blend_minmax;
    extTextureFloatLinear: EXT_blend_minmax;
    extTextureHalfFloatLinear: EXT_blend_minmax;
    extFloatBlend: EXT_blend_minmax;
    extTextureFilterAnisotropic: EXT_blend_minmax;
    extCompressedTextureETC1: EXT_blend_minmax;
    extCompressedTextureETC: EXT_blend_minmax;
    extCompressedTexturePVRTC: EXT_blend_minmax;
    extCompressedTextureS3TC: EXT_blend_minmax;
    extCompressedTextureATC: EXT_blend_minmax;
    extCompressedTextureASTC: EXT_blend_minmax;
    extParallelShaderCompile: EXT_blend_minmax;
    extColorBufferHalfFloat: EXT_blend_minmax;
    /**
     * Query the capabilities of the WebGL context.
     *
     * @ignore
     */
    initializeCapabilities(): void;
    maxPrecision: string;
    supportsMsaa: boolean;
    supportsStencil: boolean;
    maxRenderBufferSize: any;
    maxTextures: any;
    maxCombinedTextures: any;
    maxVertexTextures: any;
    vertexUniformsCount: any;
    fragmentUniformsCount: any;
    maxDrawBuffers: any;
    maxColorAttachments: any;
    unmaskedRenderer: any;
    unmaskedVendor: any;
    samples: any;
    maxSamples: any;
    supportsAreaLights: boolean;
    /**
     * Set the initial render state on the WebGL context.
     *
     * @ignore
     */
    initializeRenderState(): void;
    blending: any;
    blendSrc: any;
    blendDst: number;
    blendSrcAlpha: number;
    blendDstAlpha: number;
    separateAlphaBlend: boolean;
    blendEquation: any;
    blendAlphaEquation: number;
    separateAlphaEquation: boolean;
    writeRed: any;
    writeGreen: boolean;
    writeBlue: boolean;
    writeAlpha: boolean;
    cullMode: any;
    depthTest: any;
    depthFunc: any;
    depthWrite: any;
    stencil: any;
    stencilFuncFront: any;
    stencilFuncBack: any;
    stencilRefFront: number;
    stencilRefBack: number;
    stencilMaskFront: number;
    stencilMaskBack: number;
    stencilFailFront: any;
    stencilFailBack: any;
    stencilZfailFront: number;
    stencilZfailBack: number;
    stencilZpassFront: number;
    stencilZpassBack: number;
    stencilWriteMaskFront: any;
    stencilWriteMaskBack: any;
    alphaToCoverage: any;
    raster: any;
    depthBiasEnabled: any;
    clearDepth: any;
    clearRed: any;
    clearBlue: number;
    clearGreen: number;
    clearAlpha: number;
    clearStencil: any;
    vx: any;
    vy: number;
    vw: number;
    vh: number;
    sx: any;
    sy: number;
    sw: number;
    sh: number;
    unpackFlipY: any;
    unpackPremultiplyAlpha: any;
    initializeContextCaches(): void;
    vertexShaderCache: {};
    fragmentShaderCache: {};
    _vaoMap: Map<any, any>;
    boundVao: any;
    indexBuffer: IndexBuffer$1;
    vertexBuffers: any[];
    shader: any;
    renderTarget: any;
    activeFramebuffer: any;
    feedback: WebGLTransformFeedback;
    transformFeedbackBuffer: any;
    textureUnit: any;
    textureUnits: any[];
    /**
     * Called when the WebGL context was lost. It releases all context related resources.
     *
     * @ignore
     */
    loseContext(): void;
    /**
     * Called when the WebGL context is restored. It reinitializes all context related resources.
     *
     * @ignore
     */
    restoreContext(): void;
    updateClientRect(): void;
    clientRect: DOMRect;
    /**
     * Set the active rectangle for rendering on the specified device.
     *
     * @param {number} x - The pixel space x-coordinate of the bottom left corner of the viewport.
     * @param {number} y - The pixel space y-coordinate of the bottom left corner of the viewport.
     * @param {number} w - The width of the viewport in pixels.
     * @param {number} h - The height of the viewport in pixels.
     */
    setViewport(x: number, y: number, w: number, h: number): void;
    /**
     * Set the active scissor rectangle on the specified device.
     *
     * @param {number} x - The pixel space x-coordinate of the bottom left corner of the scissor rectangle.
     * @param {number} y - The pixel space y-coordinate of the bottom left corner of the scissor rectangle.
     * @param {number} w - The width of the scissor rectangle in pixels.
     * @param {number} h - The height of the scissor rectangle in pixels.
     */
    setScissor(x: number, y: number, w: number, h: number): void;
    /**
     * Retrieves the program library assigned to the specified graphics device.
     *
     * @returns {ProgramLibrary} The program library assigned to the device.
     * @ignore
     */
    getProgramLibrary(): ProgramLibrary;
    /**
     * Assigns a program library to the specified device. By default, a graphics device is created
     * with a program library that manages all of the programs that are used to render any
     * graphical primitives. However, this function allows the user to replace the existing program
     * library with a new one.
     *
     * @param {ProgramLibrary} programLib - The program library to assign to the device.
     * @ignore
     */
    setProgramLibrary(programLib: ProgramLibrary): void;
    /**
     * Binds the specified framebuffer object.
     *
     * @param {WebGLFramebuffer} fb - The framebuffer to bind.
     * @ignore
     */
    setFramebuffer(fb: WebGLFramebuffer): void;
    /**
     * Checks the completeness status of the currently bound WebGLFramebuffer object.
     *
     * @private
     */
    private _checkFbo;
    /**
     * Copies source render target into destination render target. Mostly used by post-effects.
     *
     * @param {RenderTarget} source - The source render target.
     * @param {RenderTarget} [dest] - The destination render target. Defaults to frame buffer.
     * @param {boolean} [color] - If true will copy the color buffer. Defaults to false.
     * @param {boolean} [depth] - If true will copy the depth buffer. Defaults to false.
     * @returns {boolean} True if the copy was successful, false otherwise.
     */
    copyRenderTarget(source: RenderTarget$3, dest?: RenderTarget$3, color?: boolean, depth?: boolean): boolean;
    /**
     * Initialize render target before it can be used.
     *
     * @param {RenderTarget} target - The render target to be initialized.
     * @ignore
     */
    initRenderTarget(target: RenderTarget$3): void;
    /**
     * Get copy shader for efficient rendering of fullscreen-quad with texture.
     *
     * @returns {Shader} The copy shader (based on `fullscreenQuadVS` and `outputTex2DPS` in
     * `shaderChunks`).
     * @ignore
     */
    getCopyShader(): Shader$3;
    _copyShader: Shader$4;
    /**
     * Marks the beginning of a block of rendering. Internally, this function binds the render
     * target currently set on the device. This function should be matched with a call to
     * {@link GraphicsDevice#updateEnd}. Calls to {@link GraphicsDevice#updateBegin} and
     * {@link GraphicsDevice#updateEnd} must not be nested.
     */
    updateBegin(): void;
    /**
     * Marks the end of a block of rendering. This function should be called after a matching call
     * to {@link GraphicsDevice#updateBegin}. Calls to {@link GraphicsDevice#updateBegin} and
     * {@link GraphicsDevice#updateEnd} must not be nested.
     */
    updateEnd(): void;
    /**
     * Allocate WebGL resources for a texture and add it to the array of textures managed by this
     * device.
     *
     * @param {Texture} texture - The texture to allocate WebGL resources for.
     * @ignore
     */
    initializeTexture(texture: Texture$8): void;
    /**
     * Free WebGL resources associated with a texture.
     *
     * @param {Texture} texture - The texture to free.
     * @ignore
     */
    destroyTexture(texture: Texture$8): void;
    /**
     * Updates a texture's vertical flip.
     *
     * @param {boolean} flipY - True to flip the texture vertically.
     * @ignore
     */
    setUnpackFlipY(flipY: boolean): void;
    /**
     * Updates a texture to have its RGB channels premultiplied by its alpha channel or not.
     *
     * @param {boolean} premultiplyAlpha - True to premultiply the alpha channel against the RGB
     * channels.
     * @ignore
     */
    setUnpackPremultiplyAlpha(premultiplyAlpha: boolean): void;
    /**
     * Reports whether a texture source is a canvas, image, video or ImageBitmap.
     *
     * @param {*} texture - Texture source data.
     * @returns {boolean} True if the texture is a canvas, image, video or ImageBitmap and false
     * otherwise.
     * @private
     */
    private _isBrowserInterface;
    /**
     * Uploads a texture to the GPU.
     *
     * @param {Texture} texture - The texture to upload.
     * @ignore
     */
    uploadTexture(texture: Texture$8): void;
    /**
     * Activate the specified texture unit.
     *
     * @param {number} textureUnit - The texture unit to activate.
     * @ignore
     */
    activeTexture(textureUnit: number): void;
    /**
     * If the texture is not already bound on the currently active texture unit, bind it.
     *
     * @param {Texture} texture - The texture to bind.
     * @ignore
     */
    bindTexture(texture: Texture$8): void;
    /**
     * If the texture is not bound on the specified texture unit, active the texture unit and bind
     * the texture to it.
     *
     * @param {Texture} texture - The texture to bind.
     * @param {number} textureUnit - The texture unit to activate and bind the texture to.
     * @ignore
     */
    bindTextureOnUnit(texture: Texture$8, textureUnit: number): void;
    /**
     * Update the texture parameters for a given texture if they have changed.
     *
     * @param {Texture} texture - The texture to update.
     * @ignore
     */
    setTextureParameters(texture: Texture$8): void;
    /**
     * Sets the specified texture on the specified texture unit.
     *
     * @param {Texture} texture - The texture to set.
     * @param {number} textureUnit - The texture unit to set the texture on.
     * @ignore
     */
    setTexture(texture: Texture$8, textureUnit: number): void;
    createVertexArray(vertexBuffers: any): any;
    setBuffers(): void;
    /**
     * Submits a graphical primitive to the hardware for immediate rendering.
     *
     * @param {object} primitive - Primitive object describing how to submit current vertex/index
     * buffers.
     * @param {number} primitive.type - The type of primitive to render. Can be:
     *
     * - {@link PRIMITIVE_POINTS}
     * - {@link PRIMITIVE_LINES}
     * - {@link PRIMITIVE_LINELOOP}
     * - {@link PRIMITIVE_LINESTRIP}
     * - {@link PRIMITIVE_TRIANGLES}
     * - {@link PRIMITIVE_TRISTRIP}
     * - {@link PRIMITIVE_TRIFAN}
     *
     * @param {number} primitive.base - The offset of the first index or vertex to dispatch in the
     * draw call.
     * @param {number} primitive.count - The number of indices or vertices to dispatch in the draw
     * call.
     * @param {boolean} [primitive.indexed] - True to interpret the primitive as indexed, thereby
     * using the currently set index buffer and false otherwise.
     * @param {number} [numInstances=1] - The number of instances to render when using
     * ANGLE_instanced_arrays. Defaults to 1.
     * @param {boolean} [keepBuffers] - Optionally keep the current set of vertex / index buffers /
     * VAO. This is used when rendering of multiple views, for example under WebXR.
     * @example
     * // Render a single, unindexed triangle
     * device.draw({
     *     type: pc.PRIMITIVE_TRIANGLES,
     *     base: 0,
     *     count: 3,
     *     indexed: false
     * });
     */
    draw(primitive: {
        type: number;
        base: number;
        count: number;
        indexed?: boolean;
    }, numInstances?: number, keepBuffers?: boolean): void;
    /**
     * Clears the frame buffer of the currently set render target.
     *
     * @param {object} [options] - Optional options object that controls the behavior of the clear
     * operation defined as follows:
     * @param {number[]} [options.color] - The color to clear the color buffer to in the range 0.0
     * to 1.0 for each component.
     * @param {number} [options.depth=1] - The depth value to clear the depth buffer to in the
     * range 0.0 to 1.0.
     * @param {number} [options.flags] - The buffers to clear (the types being color, depth and
     * stencil). Can be any bitwise combination of:
     *
     * - {@link CLEARFLAG_COLOR}
     * - {@link CLEARFLAG_DEPTH}
     * - {@link CLEARFLAG_STENCIL}
     *
     * @param {number} [options.stencil=0] - The stencil value to clear the stencil buffer to. Defaults to 0.
     * @example
     * // Clear color buffer to black and depth buffer to 1.0
     * device.clear();
     *
     * // Clear just the color buffer to red
     * device.clear({
     *     color: [1, 0, 0, 1],
     *     flags: pc.CLEARFLAG_COLOR
     * });
     *
     * // Clear color buffer to yellow and depth to 1.0
     * device.clear({
     *     color: [1, 1, 0, 1],
     *     depth: 1,
     *     flags: pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH
     * });
     */
    clear(options?: {
        color?: number[];
        depth?: number;
        flags?: number;
        stencil?: number;
    }): void;
    /**
     * Reads a block of pixels from a specified rectangle of the current color framebuffer into an
     * ArrayBufferView object.
     *
     * @param {number} x - The x-coordinate of the rectangle's lower-left corner.
     * @param {number} y - The y-coordinate of the rectangle's lower-left corner.
     * @param {number} w - The width of the rectangle, in pixels.
     * @param {number} h - The height of the rectangle, in pixels.
     * @param {ArrayBufferView} pixels - The ArrayBufferView object that holds the returned pixel
     * data.
     * @ignore
     */
    readPixels(x: number, y: number, w: number, h: number, pixels: ArrayBufferView): void;
    /**
     * Set the depth value used when the depth buffer is cleared.
     *
     * @param {number} depth - The depth value to clear the depth buffer to in the range 0.0
     * to 1.0.
     * @ignore
     */
    setClearDepth(depth: number): void;
    /**
     * Set the clear color used when the frame buffer is cleared.
     *
     * @param {number} r - The red component of the color in the range 0.0 to 1.0.
     * @param {number} g - The green component of the color in the range 0.0 to 1.0.
     * @param {number} b - The blue component of the color in the range 0.0 to 1.0.
     * @param {number} a - The alpha component of the color in the range 0.0 to 1.0.
     * @ignore
     */
    setClearColor(r: number, g: number, b: number, a: number): void;
    /**
     * Set the stencil clear value used when the stencil buffer is cleared.
     *
     * @param {number} value - The stencil value to clear the stencil buffer to.
     */
    setClearStencil(value: number): void;
    /**
     * Sets the specified render target on the device. If null is passed as a parameter, the back
     * buffer becomes the current target for all rendering operations.
     *
     * @param {RenderTarget} renderTarget - The render target to activate.
     * @example
     * // Set a render target to receive all rendering output
     * device.setRenderTarget(renderTarget);
     *
     * // Set the back buffer to receive all rendering output
     * device.setRenderTarget(null);
     */
    setRenderTarget(renderTarget: RenderTarget$3): void;
    /**
     * Queries the currently set render target on the device.
     *
     * @returns {RenderTarget} The current render target.
     * @example
     * // Get the current render target
     * var renderTarget = device.getRenderTarget();
     */
    getRenderTarget(): RenderTarget$3;
    /**
     * Queries whether depth testing is enabled.
     *
     * @returns {boolean} True if depth testing is enabled and false otherwise.
     * @example
     * var depthTest = device.getDepthTest();
     * console.log('Depth testing is ' + depthTest ? 'enabled' : 'disabled');
     */
    getDepthTest(): boolean;
    /**
     * Enables or disables depth testing of fragments. Once this state is set, it persists until it
     * is changed. By default, depth testing is enabled.
     *
     * @param {boolean} depthTest - True to enable depth testing and false otherwise.
     * @example
     * device.setDepthTest(true);
     */
    setDepthTest(depthTest: boolean): void;
    /**
     * Configures the depth test.
     *
     * @param {number} func - A function to compare a new depth value with an existing z-buffer
     * value and decide if to write a pixel. Can be:
     *
     * - {@link FUNC_NEVER}: don't draw
     * - {@link FUNC_LESS}: draw if new depth < depth buffer
     * - {@link FUNC_EQUAL}: draw if new depth == depth buffer
     * - {@link FUNC_LESSEQUAL}: draw if new depth <= depth buffer
     * - {@link FUNC_GREATER}: draw if new depth > depth buffer
     * - {@link FUNC_NOTEQUAL}: draw if new depth != depth buffer
     * - {@link FUNC_GREATEREQUAL}: draw if new depth >= depth buffer
     * - {@link FUNC_ALWAYS}: always draw
     */
    setDepthFunc(func: number): void;
    /**
     * Queries whether writes to the depth buffer are enabled.
     *
     * @returns {boolean} True if depth writing is enabled and false otherwise.
     * @example
     * var depthWrite = device.getDepthWrite();
     * console.log('Depth writing is ' + depthWrite ? 'enabled' : 'disabled');
     */
    getDepthWrite(): boolean;
    /**
     * Enables or disables writes to the depth buffer. Once this state is set, it persists until it
     * is changed. By default, depth writes are enabled.
     *
     * @param {boolean} writeDepth - True to enable depth writing and false otherwise.
     * @example
     * device.setDepthWrite(true);
     */
    setDepthWrite(writeDepth: boolean): void;
    /**
     * Enables or disables writes to the color buffer. Once this state is set, it persists until it
     * is changed. By default, color writes are enabled for all color channels.
     *
     * @param {boolean} writeRed - True to enable writing of the red channel and false otherwise.
     * @param {boolean} writeGreen - True to enable writing of the green channel and false otherwise.
     * @param {boolean} writeBlue - True to enable writing of the blue channel and false otherwise.
     * @param {boolean} writeAlpha - True to enable writing of the alpha channel and false otherwise.
     * @example
     * // Just write alpha into the frame buffer
     * device.setColorWrite(false, false, false, true);
     */
    setColorWrite(writeRed: boolean, writeGreen: boolean, writeBlue: boolean, writeAlpha: boolean): void;
    /**
     * Enables or disables alpha to coverage (WebGL2 only).
     *
     * @param {boolean} state - True to enable alpha to coverage and false to disable it.
     * @ignore
     */
    setAlphaToCoverage(state: boolean): void;
    /**
     * Sets the output vertex buffer. It will be written to by a shader with transform feedback
     * varyings.
     *
     * @param {VertexBuffer} tf - The output vertex buffer.
     * @ignore
     */
    setTransformFeedbackBuffer(tf: VertexBuffer$2): void;
    /**
     * Toggles the rasterization render state. Useful with transform feedback, when you only need
     * to process the data without drawing.
     *
     * @param {boolean} on - True to enable rasterization and false to disable it.
     * @ignore
     */
    setRaster(on: boolean): void;
    /**
     * Toggles the polygon offset render state.
     *
     * @param {boolean} on - True to enable polygon offset and false to disable it.
     * @ignore
     */
    setDepthBias(on: boolean): void;
    /**
     * Specifies the scale factor and units to calculate depth values. The offset is added before
     * the depth test is performed and before the value is written into the depth buffer.
     *
     * @param {number} constBias - The multiplier by which an implementation-specific value is
     * multiplied with to create a constant depth offset.
     * @param {number} slopeBias - The scale factor for the variable depth offset for each polygon.
     * @ignore
     */
    setDepthBiasValues(constBias: number, slopeBias: number): void;
    /**
     * Queries whether blending is enabled.
     *
     * @returns {boolean} True if blending is enabled and false otherwise.
     */
    getBlending(): boolean;
    /**
     * Enables or disables blending.
     *
     * @param {boolean} blending - True to enable blending and false to disable it.
     */
    setBlending(blending: boolean): void;
    /**
     * Enables or disables stencil test.
     *
     * @param {boolean} enable - True to enable stencil test and false to disable it.
     */
    setStencilTest(enable: boolean): void;
    /**
     * Configures stencil test for both front and back faces.
     *
     * @param {number} func - A comparison function that decides if the pixel should be written,
     * based on the current stencil buffer value, reference value, and mask value. Can be:
     *
     * - {@link FUNC_NEVER}: never pass
     * - {@link FUNC_LESS}: pass if (ref & mask) < (stencil & mask)
     * - {@link FUNC_EQUAL}: pass if (ref & mask) == (stencil & mask)
     * - {@link FUNC_LESSEQUAL}: pass if (ref & mask) <= (stencil & mask)
     * - {@link FUNC_GREATER}: pass if (ref & mask) > (stencil & mask)
     * - {@link FUNC_NOTEQUAL}: pass if (ref & mask) != (stencil & mask)
     * - {@link FUNC_GREATEREQUAL}: pass if (ref & mask) >= (stencil & mask)
     * - {@link FUNC_ALWAYS}: always pass
     *
     * @param {number} ref - Reference value used in comparison.
     * @param {number} mask - Mask applied to stencil buffer value and reference value before
     * comparison.
     */
    setStencilFunc(func: number, ref: number, mask: number): void;
    /**
     * Configures stencil test for front faces.
     *
     * @param {number} func - A comparison function that decides if the pixel should be written,
     * based on the current stencil buffer value, reference value, and mask value. Can be:
     *
     * - {@link FUNC_NEVER}: never pass
     * - {@link FUNC_LESS}: pass if (ref & mask) < (stencil & mask)
     * - {@link FUNC_EQUAL}: pass if (ref & mask) == (stencil & mask)
     * - {@link FUNC_LESSEQUAL}: pass if (ref & mask) <= (stencil & mask)
     * - {@link FUNC_GREATER}: pass if (ref & mask) > (stencil & mask)
     * - {@link FUNC_NOTEQUAL}: pass if (ref & mask) != (stencil & mask)
     * - {@link FUNC_GREATEREQUAL}: pass if (ref & mask) >= (stencil & mask)
     * - {@link FUNC_ALWAYS}: always pass
     *
     * @param {number} ref - Reference value used in comparison.
     * @param {number} mask - Mask applied to stencil buffer value and reference value before comparison.
     */
    setStencilFuncFront(func: number, ref: number, mask: number): void;
    /**
     * Configures stencil test for back faces.
     *
     * @param {number} func - A comparison function that decides if the pixel should be written,
     * based on the current stencil buffer value, reference value, and mask value. Can be:
     *
     * - {@link FUNC_NEVER}: never pass
     * - {@link FUNC_LESS}: pass if (ref & mask) < (stencil & mask)
     * - {@link FUNC_EQUAL}: pass if (ref & mask) == (stencil & mask)
     * - {@link FUNC_LESSEQUAL}: pass if (ref & mask) <= (stencil & mask)
     * - {@link FUNC_GREATER}: pass if (ref & mask) > (stencil & mask)
     * - {@link FUNC_NOTEQUAL}: pass if (ref & mask) != (stencil & mask)
     * - {@link FUNC_GREATEREQUAL}: pass if (ref & mask) >= (stencil & mask)
     * - {@link FUNC_ALWAYS}: always pass
     *
     * @param {number} ref - Reference value used in comparison.
     * @param {number} mask - Mask applied to stencil buffer value and reference value before comparison.
     */
    setStencilFuncBack(func: number, ref: number, mask: number): void;
    /**
     * Configures how stencil buffer values should be modified based on the result of depth/stencil
     * tests. Works for both front and back faces.
     *
     * @param {number} fail - Action to take if stencil test is failed. Can be:
     *
     * - {@link STENCILOP_KEEP}: don't change the stencil buffer value
     * - {@link STENCILOP_ZERO}: set value to zero
     * - {@link STENCILOP_REPLACE}: replace value with the reference value (see {@link GraphicsDevice#setStencilFunc})
     * - {@link STENCILOP_INCREMENT}: increment the value
     * - {@link STENCILOP_INCREMENTWRAP}: increment the value, but wrap it to zero when it's larger
     * than a maximum representable value
     * - {@link STENCILOP_DECREMENT}: decrement the value
     * - {@link STENCILOP_DECREMENTWRAP}: decrement the value, but wrap it to a maximum
     * representable value, if the current value is 0
     * - {@link STENCILOP_INVERT}: invert the value bitwise
     *
     * @param {number} zfail - Action to take if depth test is failed.  Accepts the same values as
     * `fail`.
     * @param {number} zpass - Action to take if both depth and stencil test are passed. Accepts
     * the same values as `fail`.
     * @param {number} writeMask - A bit mask applied to the reference value, when written.
     */
    setStencilOperation(fail: number, zfail: number, zpass: number, writeMask: number): void;
    /**
     * Configures how stencil buffer values should be modified based on the result of depth/stencil
     * tests. Works for front faces.
     *
     * @param {number} fail - Action to take if stencil test is failed. Can be:
     *
     * - {@link STENCILOP_KEEP}: don't change the stencil buffer value
     * - {@link STENCILOP_ZERO}: set value to zero
     * - {@link STENCILOP_REPLACE}: replace value with the reference value (see {@link GraphicsDevice#setStencilFunc})
     * - {@link STENCILOP_INCREMENT}: increment the value
     * - {@link STENCILOP_INCREMENTWRAP}: increment the value, but wrap it to zero when it's larger
     * than a maximum representable value
     * - {@link STENCILOP_DECREMENT}: decrement the value
     * - {@link STENCILOP_DECREMENTWRAP}: decrement the value, but wrap it to a maximum
     * representable value, if the current value is 0
     * - {@link STENCILOP_INVERT}: invert the value bitwise
     *
     * @param {number} zfail - Action to take if depth test is failed.  Accepts the same values as
     * `fail`.
     * @param {number} zpass - Action to take if both depth and stencil test are passed.  Accepts
     * the same values as `fail`.
     * @param {number} writeMask - A bit mask applied to the reference value, when written.
     */
    setStencilOperationFront(fail: number, zfail: number, zpass: number, writeMask: number): void;
    /**
     * Configures how stencil buffer values should be modified based on the result of depth/stencil
     * tests. Works for back faces.
     *
     * @param {number} fail - Action to take if stencil test is failed. Can be:
     *
     * - {@link STENCILOP_KEEP}: don't change the stencil buffer value
     * - {@link STENCILOP_ZERO}: set value to zero
     * - {@link STENCILOP_REPLACE}: replace value with the reference value (see {@link GraphicsDevice#setStencilFunc})
     * - {@link STENCILOP_INCREMENT}: increment the value
     * - {@link STENCILOP_INCREMENTWRAP}: increment the value, but wrap it to zero when it's larger
     * than a maximum representable value
     * - {@link STENCILOP_DECREMENT}: decrement the value
     * - {@link STENCILOP_DECREMENTWRAP}: decrement the value, but wrap it to a maximum
     * representable value, if the current value is 0
     * - {@link STENCILOP_INVERT}: invert the value bitwise
     *
     * @param {number} zfail - Action to take if depth test is failed. Accepts the same values as
     * `fail`.
     * @param {number} zpass - Action to take if both depth and stencil test are passed. Accepts
     * the same values as `fail`.
     * @param {number} writeMask - A bit mask applied to the reference value, when written.
     */
    setStencilOperationBack(fail: number, zfail: number, zpass: number, writeMask: number): void;
    /**
     * Configures blending operations. Both source and destination blend modes can take the
     * following values:
     *
     * - {@link BLENDMODE_ZERO}
     * - {@link BLENDMODE_ONE}
     * - {@link BLENDMODE_SRC_COLOR}
     * - {@link BLENDMODE_ONE_MINUS_SRC_COLOR}
     * - {@link BLENDMODE_DST_COLOR}
     * - {@link BLENDMODE_ONE_MINUS_DST_COLOR}
     * - {@link BLENDMODE_SRC_ALPHA}
     * - {@link BLENDMODE_SRC_ALPHA_SATURATE}
     * - {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}
     * - {@link BLENDMODE_DST_ALPHA}
     * - {@link BLENDMODE_ONE_MINUS_DST_ALPHA}
     *
     * @param {number} blendSrc - The source blend function.
     * @param {number} blendDst - The destination blend function.
     */
    setBlendFunction(blendSrc: number, blendDst: number): void;
    /**
     * Configures blending operations. Both source and destination blend modes can take the
     * following values:
     *
     * - {@link BLENDMODE_ZERO}
     * - {@link BLENDMODE_ONE}
     * - {@link BLENDMODE_SRC_COLOR}
     * - {@link BLENDMODE_ONE_MINUS_SRC_COLOR}
     * - {@link BLENDMODE_DST_COLOR}
     * - {@link BLENDMODE_ONE_MINUS_DST_COLOR}
     * - {@link BLENDMODE_SRC_ALPHA}
     * - {@link BLENDMODE_SRC_ALPHA_SATURATE}
     * - {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}
     * - {@link BLENDMODE_DST_ALPHA}
     * - {@link BLENDMODE_ONE_MINUS_DST_ALPHA}
     *
     * @param {number} blendSrc - The source blend function.
     * @param {number} blendDst - The destination blend function.
     * @param {number} blendSrcAlpha - The separate source blend function for the alpha channel.
     * @param {number} blendDstAlpha - The separate destination blend function for the alpha channel.
     */
    setBlendFunctionSeparate(blendSrc: number, blendDst: number, blendSrcAlpha: number, blendDstAlpha: number): void;
    /**
     * Configures the blending equation. The default blend equation is {@link BLENDEQUATION_ADD}.
     *
     * @param {number} blendEquation - The blend equation. Can be:
     *
     * - {@link BLENDEQUATION_ADD}
     * - {@link BLENDEQUATION_SUBTRACT}
     * - {@link BLENDEQUATION_REVERSE_SUBTRACT}
     * - {@link BLENDEQUATION_MIN}
     * - {@link BLENDEQUATION_MAX}
     *
     * Note that MIN and MAX modes require either EXT_blend_minmax or WebGL2 to work (check
     * device.extBlendMinmax).
     */
    setBlendEquation(blendEquation: number): void;
    /**
     * Configures the blending equation. The default blend equation is {@link BLENDEQUATION_ADD}.
     *
     * @param {number} blendEquation - The blend equation. Can be:
     *
     * - {@link BLENDEQUATION_ADD}
     * - {@link BLENDEQUATION_SUBTRACT}
     * - {@link BLENDEQUATION_REVERSE_SUBTRACT}
     * - {@link BLENDEQUATION_MIN}
     * - {@link BLENDEQUATION_MAX}
     *
     * Note that MIN and MAX modes require either EXT_blend_minmax or WebGL2 to work (check
     * device.extBlendMinmax).
     * @param {number} blendAlphaEquation - A separate blend equation for the alpha channel.
     * Accepts same values as `blendEquation`.
     */
    setBlendEquationSeparate(blendEquation: number, blendAlphaEquation: number): void;
    /**
     * Controls how triangles are culled based on their face direction. The default cull mode is
     * {@link CULLFACE_BACK}.
     *
     * @param {number} cullMode - The cull mode to set. Can be:
     *
     * - {@link CULLFACE_NONE}
     * - {@link CULLFACE_BACK}
     * - {@link CULLFACE_FRONT}
     * - {@link CULLFACE_FRONTANDBACK}
     */
    setCullMode(cullMode: number): void;
    cullFace: any;
    /**
     * Gets the current cull mode.
     *
     * @returns {number} The current cull mode.
     * @ignore
     */
    getCullMode(): number;
    /**
     * Sets the current index buffer on the graphics device. On subsequent calls to
     * {@link GraphicsDevice#draw}, the specified index buffer will be used to provide index data
     * for any indexed primitives.
     *
     * @param {IndexBuffer} indexBuffer - The index buffer to assign to the device.
     */
    setIndexBuffer(indexBuffer: IndexBuffer): void;
    /**
     * Sets the current vertex buffer on the graphics device. On subsequent calls to
     * {@link GraphicsDevice#draw}, the specified vertex buffer(s) will be used to provide vertex
     * data for any primitives.
     *
     * @param {VertexBuffer} vertexBuffer - The vertex buffer to assign to the device.
     */
    setVertexBuffer(vertexBuffer: VertexBuffer$2): void;
    /**
     * Compiles an individual shader.
     *
     * @param {string} src - The shader source code.
     * @param {boolean} isVertexShader - True if the shader is a vertex shader, false if it is a
     * fragment shader.
     * @returns {WebGLShader} The compiled shader.
     * @ignore
     */
    compileShaderSource(src: string, isVertexShader: boolean): WebGLShader;
    /**
     * Compile and link a shader program.
     *
     * @param {Shader} shader - The shader to compile.
     * @ignore
     */
    compileAndLinkShader(shader: Shader$3): void;
    /**
     * Compile and link a shader program and add it to a shader array managed by this device.
     *
     * @param {Shader} shader - The shader to compile and link.
     * @ignore
     */
    createShader(shader: Shader$3): void;
    /**
     * Free the WebGL resources associated with a shader.
     *
     * @param {Shader} shader - The shader to free.
     * @ignore
     */
    destroyShader(shader: Shader$3): void;
    /**
     * Truncate the WebGL shader compilation log to just include the error line plus the 5 lines
     * before and after it.
     *
     * @param {string} src - The shader source code.
     * @param {string} infoLog - The info log returned from WebGL on a failed shader compilation.
     * @returns {Array} An array where the first element is the 10 lines of code around the first
     * detected error, and the second element an object storing the error messsage, line number and
     * complete shader source.
     * @private
     */
    private _processError;
    /**
     * Check the compilation status of a shader.
     *
     * @param {Shader} shader - The shader to query.
     * @param {WebGLShader} glShader - The WebGL shader.
     * @param {string} source - The shader source code.
     * @param {string} shaderType - The shader type. Can be 'vertex' or 'fragment'.
     * @returns {boolean} True if the shader compiled successfully, false otherwise.
     * @private
     */
    private _isShaderCompiled;
    /**
     * Extract attribute and uniform information from a successfully linked shader.
     *
     * @param {Shader} shader - The shader to query.
     * @returns {boolean} True if the shader was successfully queried and false otherwise.
     * @ignore
     */
    postLink(shader: Shader$3): boolean;
    /**
     * Sets the active shader to be used during subsequent draw calls.
     *
     * @param {Shader} shader - The shader to set to assign to the device.
     * @returns {boolean} True if the shader was successfully set, false otherwise.
     */
    setShader(shader: Shader$3): boolean;
    attributesInvalidated: boolean;
    /**
     * Get the supported HDR pixel format.
     * Note that for WebGL2, PIXELFORMAT_RGB16F and PIXELFORMAT_RGB32F are not renderable according to this:
     * https://developer.mozilla.org/en-US/docs/Web/API/EXT_color_buffer_float
     * For WebGL1, only PIXELFORMAT_RGBA16F and PIXELFORMAT_RGBA32F are tested for being renderable.
     *
     * @returns {number} The HDR pixel format.
     * @ignore
     */
    getHdrFormat(): number;
    /**
     * Queries the maximum number of bones that can be referenced by a shader. The shader
     * generators (programlib) use this number to specify the matrix array size of the uniform
     * 'matrix_pose[0]'. The value is calculated based on the number of available uniform vectors
     * available after subtracting the number taken by a typical heavyweight shader. If a different
     * number is required, it can be tuned via {@link GraphicsDevice#setBoneLimit}.
     *
     * @returns {number} The maximum number of bones that can be supported by the host hardware.
     * @ignore
     */
    getBoneLimit(): number;
    /**
     * Specifies the maximum number of bones that the device can support on the current hardware.
     * This function allows the default calculated value based on available vector uniforms to be
     * overridden.
     *
     * @param {number} maxBones - The maximum number of bones supported by the host hardware.
     * @ignore
     */
    setBoneLimit(maxBones: number): void;
    /**
     * Sets the width and height of the canvas, then fires the `resizecanvas` event. Note that the
     * specified width and height values will be multiplied by the value of
     * {@link GraphicsDevice#maxPixelRatio} to give the final resultant width and height for the
     * canvas.
     *
     * @param {number} width - The new width of the canvas.
     * @param {number} height - The new height of the canvas.
     * @ignore
     */
    resizeCanvas(width: number, height: number): void;
    /**
     * Sets the width and height of the canvas, then fires the `resizecanvas` event. Note that the
     * value of {@link GraphicsDevice#maxPixelRatio} is ignored.
     *
     * @param {number} width - The new width of the canvas.
     * @param {number} height - The new height of the canvas.
     * @ignore
     */
    setResolution(width: number, height: number): void;
    /**
     * Frees memory from all shaders ever allocated with this device.
     *
     * @ignore
     */
    clearShaderCache(): void;
    /**
     * Frees memory from all vertex array objects ever allocated with this device.
     *
     * @ignore
     */
    clearVertexArrayObjectCache(): void;
    /**
     * Removes a shader from the cache.
     *
     * @param {Shader} shader - The shader to remove from the cache.
     * @ignore
     */
    removeShaderFromCache(shader: Shader$3): void;
    /**
     * Width of the back buffer in pixels.
     *
     * @type {number}
     */
    get width(): number;
    /**
     * Height of the back buffer in pixels.
     *
     * @type {number}
     */
    get height(): number;
    /**
     * Fullscreen mode.
     *
     * @type {boolean}
     */
    set fullscreen(arg: boolean);
    get fullscreen(): boolean;
    /**
     * Automatic instancing.
     *
     * @type {boolean}
     * @ignore
     */
    set enableAutoInstancing(arg: boolean);
    get enableAutoInstancing(): boolean;
    /**
     * Maximum pixel ratio.
     *
     * @type {number}
     */
    set maxPixelRatio(arg: number);
    get maxPixelRatio(): number;
    /**
     * Check if high precision floating-point textures are supported.
     *
     * @type {boolean}
     */
    get textureFloatHighPrecision(): boolean;
    /**
     * Check if texture with half float format can be updated with data.
     *
     * @type {boolean}
     */
    get textureHalfFloatUpdatable(): boolean;
}

type GraphicsDevice$k = GraphicsDevice$l;
/**
 * A texture is a container for texel data that can be utilized in a fragment shader. Typically,
 * the texel data represents an image that is mapped over geometry.
 */
declare class Texture$8 {
    /**
     * Calculate the GPU memory required for a texture.
     *
     * @param {number} width - Texture's width.
     * @param {number} height - Texture's height.
     * @param {number} depth - Texture's depth.
     * @param {number} format - Texture's pixel format PIXELFORMAT_***.
     * @param {boolean} mipmaps - True if the texture includes mipmaps, false otherwise.
     * @param {boolean} cubemap - True is the texture is a cubemap, false otherwise.
     * @returns {number} The number of bytes of GPU memory required for the texture.
     * @ignore
     */
    static calcGpuSize(width: number, height: number, depth: number, format: number, mipmaps: boolean, cubemap: boolean): number;
    /**
     * Create a new Texture instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this texture.
     * @param {object} [options] - Object for passing optional arguments.
     * @param {string} [options.name] - The name of the texture.
     * @param {number} [options.width] - The width of the texture in pixels. Defaults to 4.
     * @param {number} [options.height] - The height of the texture in pixels. Defaults to 4.
     * @param {number} [options.depth] - The number of depth slices in a 3D texture (WebGL2 only).
     * Defaults to 1 (single 2D image).
     * @param {number} [options.format] - The pixel format of the texture. Can be:
     *
     * - {@link PIXELFORMAT_A8}
     * - {@link PIXELFORMAT_L8}
     * - {@link PIXELFORMAT_L8_A8}
     * - {@link PIXELFORMAT_R5_G6_B5}
     * - {@link PIXELFORMAT_R5_G5_B5_A1}
     * - {@link PIXELFORMAT_R4_G4_B4_A4}
     * - {@link PIXELFORMAT_R8_G8_B8}
     * - {@link PIXELFORMAT_R8_G8_B8_A8}
     * - {@link PIXELFORMAT_DXT1}
     * - {@link PIXELFORMAT_DXT3}
     * - {@link PIXELFORMAT_DXT5}
     * - {@link PIXELFORMAT_RGB16F}
     * - {@link PIXELFORMAT_RGBA16F}
     * - {@link PIXELFORMAT_RGB32F}
     * - {@link PIXELFORMAT_RGBA32F}
     * - {@link PIXELFORMAT_ETC1}
     * - {@link PIXELFORMAT_PVRTC_2BPP_RGB_1}
     * - {@link PIXELFORMAT_PVRTC_2BPP_RGBA_1}
     * - {@link PIXELFORMAT_PVRTC_4BPP_RGB_1}
     * - {@link PIXELFORMAT_PVRTC_4BPP_RGBA_1}
     * - {@link PIXELFORMAT_111110F}
     * - {@link PIXELFORMAT_ASTC_4x4}>/li>
     * - {@link PIXELFORMAT_ATC_RGB}
     * - {@link PIXELFORMAT_ATC_RGBA}
     *
     * Defaults to {@link PIXELFORMAT_R8_G8_B8_A8}.
     * @param {string} [options.projection] - The projection type of the texture, used when the
     * texture represents an environment. Can be:
     *
     * - {@link TEXTUREPROJECTION_NONE}
     * - {@link TEXTUREPROJECTION_CUBE}
     * - {@link TEXTUREPROJECTION_EQUIRECT}
     * - {@link TEXTUREPROJECTION_OCTAHEDRAL}
     *
     * Defaults to {@link TEXTUREPROJECTION_CUBE} if options.cubemap is specified, otherwise
     * {@link TEXTUREPROJECTION_NONE}.
     * @param {number} [options.minFilter] - The minification filter type to use. Defaults to
     * {@link FILTER_LINEAR_MIPMAP_LINEAR}.
     * @param {number} [options.magFilter] - The magnification filter type to use. Defaults to
     * {@link FILTER_LINEAR}.
     * @param {number} [options.anisotropy] - The level of anisotropic filtering to use. Defaults
     * to 1.
     * @param {number} [options.addressU] - The repeat mode to use in the U direction. Defaults to
     * {@link ADDRESS_REPEAT}.
     * @param {number} [options.addressV] - The repeat mode to use in the V direction. Defaults to
     * {@link ADDRESS_REPEAT}.
     * @param {number} [options.addressW] - The repeat mode to use in the W direction. Defaults to
     * {@link ADDRESS_REPEAT}.
     * @param {boolean} [options.mipmaps] - When enabled try to generate or use mipmaps for this
     * texture. Default is true.
     * @param {boolean} [options.cubemap] - Specifies whether the texture is to be a cubemap.
     * Defaults to false.
     * @param {boolean} [options.volume] - Specifies whether the texture is to be a 3D volume
     * (WebGL2 only). Defaults to false.
     * @param {string} [options.type] - Specifies the image type, see {@link TEXTURETYPE_DEFAULT}.
     * @param {boolean} [options.fixCubemapSeams] - Specifies whether this cubemap texture requires
     * special seam fixing shader code to look right. Defaults to false.
     * @param {boolean} [options.flipY] - Specifies whether the texture should be flipped in the
     * Y-direction. Only affects textures with a source that is an image, canvas or video element.
     * Does not affect cubemaps, compressed textures or textures set from raw pixel data. Defaults
     * to false.
     * @param {boolean} [options.premultiplyAlpha] - If true, the alpha channel of the texture (if
     * present) is multiplied into the color channels. Defaults to false.
     * @param {boolean} [options.compareOnRead] - When enabled, and if texture format is
     * {@link PIXELFORMAT_DEPTH} or {@link PIXELFORMAT_DEPTHSTENCIL}, hardware PCF is enabled for
     * this texture, and you can get filtered results of comparison using texture() in your shader
     * (WebGL2 only). Defaults to false.
     * @param {number} [options.compareFunc] - Comparison function when compareOnRead is enabled
     * (WebGL2 only). Can be:
     *
     * - {@link FUNC_LESS}
     * - {@link FUNC_LESSEQUAL}
     * - {@link FUNC_GREATER}
     * - {@link FUNC_GREATEREQUAL}
     * - {@link FUNC_EQUAL}
     * - {@link FUNC_NOTEQUAL}
     *
     * Defaults to {@link FUNC_LESS}.
     * @example
     * // Create a 8x8x24-bit texture
     * var texture = new pc.Texture(graphicsDevice, {
     *     width: 8,
     *     height: 8,
     *     format: pc.PIXELFORMAT_R8_G8_B8
     * });
     *
     * // Fill the texture with a gradient
     * var pixels = texture.lock();
     * var count = 0;
     * for (var i = 0; i < 8; i++) {
     *     for (var j = 0; j < 8; j++) {
     *         pixels[count++] = i * 32;
     *         pixels[count++] = j * 32;
     *         pixels[count++] = 255;
     *     }
     * }
     * texture.unlock();
     */
    constructor(graphicsDevice: GraphicsDevice$k, options?: {
        name?: string;
        width?: number;
        height?: number;
        depth?: number;
        format?: number;
        projection?: string;
        minFilter?: number;
        magFilter?: number;
        anisotropy?: number;
        addressU?: number;
        addressV?: number;
        addressW?: number;
        mipmaps?: boolean;
        cubemap?: boolean;
        volume?: boolean;
        type?: string;
        fixCubemapSeams?: boolean;
        flipY?: boolean;
        premultiplyAlpha?: boolean;
        compareOnRead?: boolean;
        compareFunc?: number;
    });
    device: GraphicsDevice$l;
    /**
     * The name of the texture. Defaults to null.
     *
     * @type {string}
     */
    name: string;
    _width: number;
    _height: number;
    _depth: number;
    _format: number;
    type: string;
    projection: string;
    _cubemap: boolean;
    _volume: boolean;
    fixCubemapSeams: boolean;
    _flipY: boolean;
    _premultiplyAlpha: boolean;
    _isRenderTarget: boolean;
    _mipmaps: any;
    _minFilter: number;
    _magFilter: number;
    _anisotropy: number;
    _addressU: number;
    _addressV: number;
    _addressW: number;
    _compareOnRead: boolean;
    _compareFunc: any;
    profilerHint: any;
    _levels: any;
    _compressed: boolean;
    _invalid: boolean;
    _lockedLevel: number;
    _gpuSize: number;
    /**
     * The minification filter to be applied to the texture. Can be:
     *
     * - {@link FILTER_NEAREST}
     * - {@link FILTER_LINEAR}
     * - {@link FILTER_NEAREST_MIPMAP_NEAREST}
     * - {@link FILTER_NEAREST_MIPMAP_LINEAR}
     * - {@link FILTER_LINEAR_MIPMAP_NEAREST}
     * - {@link FILTER_LINEAR_MIPMAP_LINEAR}
     *
     * @type {number}
     */
    set minFilter(arg: number);
    get minFilter(): number;
    /**
     * The magnification filter to be applied to the texture. Can be:
     *
     * - {@link FILTER_NEAREST}
     * - {@link FILTER_LINEAR}
     *
     * @type {number}
     */
    set magFilter(arg: number);
    get magFilter(): number;
    /**
     * The addressing mode to be applied to the texture horizontally. Can be:
     *
     * - {@link ADDRESS_REPEAT}
     * - {@link ADDRESS_CLAMP_TO_EDGE}
     * - {@link ADDRESS_MIRRORED_REPEAT}
     *
     * @type {number}
     */
    set addressU(arg: number);
    get addressU(): number;
    /**
     * The addressing mode to be applied to the texture vertically. Can be:
     *
     * - {@link ADDRESS_REPEAT}
     * - {@link ADDRESS_CLAMP_TO_EDGE}
     * - {@link ADDRESS_MIRRORED_REPEAT}
     *
     * @type {number}
     */
    set addressV(arg: number);
    get addressV(): number;
    /**
     * The addressing mode to be applied to the 3D texture depth (WebGL2 only). Can be:
     *
     * - {@link ADDRESS_REPEAT}
     * - {@link ADDRESS_CLAMP_TO_EDGE}
     * - {@link ADDRESS_MIRRORED_REPEAT}
     *
     * @type {number}
     */
    set addressW(arg: number);
    get addressW(): number;
    /**
     * When enabled, and if texture format is {@link PIXELFORMAT_DEPTH} or
     * {@link PIXELFORMAT_DEPTHSTENCIL}, hardware PCF is enabled for this texture, and you can get
     * filtered results of comparison using texture() in your shader (WebGL2 only).
     *
     * @type {boolean}
     */
    set compareOnRead(arg: boolean);
    get compareOnRead(): boolean;
    /**
     * Comparison function when compareOnRead is enabled (WebGL2 only). Possible values:
     *
     * - {@link FUNC_LESS}
     * - {@link FUNC_LESSEQUAL}
     * - {@link FUNC_GREATER}
     * - {@link FUNC_GREATEREQUAL}
     * - {@link FUNC_EQUAL}
     * - {@link FUNC_NOTEQUAL}
     *
     * @type {number}
     */
    set compareFunc(arg: any);
    get compareFunc(): any;
    /**
     * Integer value specifying the level of anisotropic to apply to the texture ranging from 1 (no
     * anisotropic filtering) to the {@link GraphicsDevice} property maxAnisotropy.
     *
     * @type {number}
     */
    set anisotropy(arg: number);
    get anisotropy(): number;
    /**
     * Toggles automatic mipmap generation. Can't be used on non power of two textures.
     *
     * @type {boolean}
     * @ignore
     * @deprecated
     */
    set autoMipmap(arg: any);
    get autoMipmap(): any;
    /**
     * Defines if texture should generate/upload mipmaps if possible.
     *
     * @type {boolean}
     */
    set mipmaps(arg: any);
    get mipmaps(): any;
    _needsMipmapsUpload: any;
    /**
     * The width of the texture in pixels.
     *
     * @type {number}
     */
    get width(): number;
    /**
     * The height of the texture in pixels.
     *
     * @type {number}
     */
    get height(): number;
    /**
     * The number of depth slices in a 3D texture (WebGL2 only).
     *
     * @type {number}
     */
    get depth(): number;
    /**
     * The pixel format of the texture. Can be:
     *
     * - {@link PIXELFORMAT_A8}
     * - {@link PIXELFORMAT_L8}
     * - {@link PIXELFORMAT_L8_A8}
     * - {@link PIXELFORMAT_R5_G6_B5}
     * - {@link PIXELFORMAT_R5_G5_B5_A1}
     * - {@link PIXELFORMAT_R4_G4_B4_A4}
     * - {@link PIXELFORMAT_R8_G8_B8}
     * - {@link PIXELFORMAT_R8_G8_B8_A8}
     * - {@link PIXELFORMAT_DXT1}
     * - {@link PIXELFORMAT_DXT3}
     * - {@link PIXELFORMAT_DXT5}
     * - {@link PIXELFORMAT_RGB16F}
     * - {@link PIXELFORMAT_RGBA16F}
     * - {@link PIXELFORMAT_RGB32F}
     * - {@link PIXELFORMAT_RGBA32F}
     * - {@link PIXELFORMAT_ETC1}
     * - {@link PIXELFORMAT_PVRTC_2BPP_RGB_1}
     * - {@link PIXELFORMAT_PVRTC_2BPP_RGBA_1}
     * - {@link PIXELFORMAT_PVRTC_4BPP_RGB_1}
     * - {@link PIXELFORMAT_PVRTC_4BPP_RGBA_1}
     * - {@link PIXELFORMAT_111110F}
     * - {@link PIXELFORMAT_ASTC_4x4}>/li>
     * - {@link PIXELFORMAT_ATC_RGB}
     * - {@link PIXELFORMAT_ATC_RGBA}
     *
     * @type {number}
     */
    get format(): number;
    /**
     * Returns true if this texture is a cube map and false otherwise.
     *
     * @type {boolean}
     */
    get cubemap(): boolean;
    get gpuSize(): number;
    /**
     * Returns true if this texture is a 3D volume and false otherwise.
     *
     * @type {boolean}
     */
    get volume(): boolean;
    /**
     * Specifies whether the texture should be flipped in the Y-direction. Only affects textures
     * with a source that is an image, canvas or video element. Does not affect cubemaps,
     * compressed textures or textures set from raw pixel data. Defaults to true.
     *
     * @type {boolean}
     */
    set flipY(arg: boolean);
    get flipY(): boolean;
    _needsUpload: boolean;
    set premultiplyAlpha(arg: boolean);
    get premultiplyAlpha(): boolean;
    /**
     * Returns true if all dimensions of the texture are power of two, and false otherwise.
     *
     * @type {boolean}
     */
    get pot(): boolean;
    get encoding(): "srgb" | "linear" | "rgbm" | "rgbe";
    /**
     * Forcibly free up the underlying WebGL resource owned by the texture.
     */
    destroy(): void;
    dirtyAll(): void;
    _levelsUpdated: boolean[] | boolean[][];
    _mipmapsUploaded: boolean;
    _parameterFlags: number;
    /**
     * Locks a miplevel of the texture, returning a typed array to be filled with pixel data.
     *
     * @param {object} [options] - Optional options object. Valid properties are as follows:
     * @param {number} [options.level] - The mip level to lock with 0 being the top level. Defaults
     * to 0.
     * @param {number} [options.face] - If the texture is a cubemap, this is the index of the face
     * to lock.
     * @param {number} [options.mode] - The lock mode. Can be:
     * - {@link TEXTURELOCK_READ}
     * - {@link TEXTURELOCK_WRITE}
     * Defaults to {@link TEXTURELOCK_WRITE}.
     * @returns {Uint8Array|Uint16Array|Float32Array} A typed array containing the pixel data of
     * the locked mip level.
     */
    lock(options?: {
        level?: number;
        face?: number;
        mode?: number;
    }): Uint8Array | Uint16Array | Float32Array;
    /**
     * Set the pixel data of the texture from a canvas, image, video DOM element. If the texture is
     * a cubemap, the supplied source must be an array of 6 canvases, images or videos.
     *
     * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement[]|HTMLImageElement[]|HTMLVideoElement[]} source - A
     * canvas, image or video element, or an array of 6 canvas, image or video elements.
     * @param {number} [mipLevel] - A non-negative integer specifying the image level of detail.
     * Defaults to 0, which represents the base image source. A level value of N, that is greater
     * than 0, represents the image source for the Nth mipmap reduction level.
     */
    setSource(source: HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | HTMLCanvasElement[] | HTMLImageElement[] | HTMLVideoElement[], mipLevel?: number): void;
    /**
     * Get the pixel data of the texture. If this is a cubemap then an array of 6 images will be
     * returned otherwise a single image.
     *
     * @param {number} [mipLevel] - A non-negative integer specifying the image level of detail.
     * Defaults to 0, which represents the base image source. A level value of N, that is greater
     * than 0, represents the image source for the Nth mipmap reduction level.
     * @returns {HTMLImageElement} The source image of this texture. Can be null if source not
     * assigned for specific image level.
     */
    getSource(mipLevel?: number): HTMLImageElement;
    /**
     * Unlocks the currently locked mip level and uploads it to VRAM.
     */
    unlock(): void;
    /**
     * Forces a reupload of the textures pixel data to graphics memory. Ordinarily, this function
     * is called by internally by {@link Texture#setSource} and {@link Texture#unlock}. However, it
     * still needs to be called explicitly in the case where an HTMLVideoElement is set as the
     * source of the texture.  Normally, this is done once every frame before video textured
     * geometry is rendered.
     */
    upload(): void;
    /**
     * Generate an in-memory DDS representation of this texture. Only works on RGBA8 textures.
     * Currently, only used by the Editor to write prefiltered cubemaps to DDS format.
     *
     * @returns {ArrayBuffer} Buffer containing the DDS data.
     * @ignore
     */
    getDds(): ArrayBuffer;
}

type Vec4$5 = Vec4$6;
type GraphicsDevice$j = GraphicsDevice$l;
type RenderTarget$2 = RenderTarget$3;
type Shader$2 = Shader$4;
type Texture$7 = Texture$8;
/**
 * Draws a screen-space quad using a specific shader. Mostly used by post-effects.
 *
 * @param {GraphicsDevice} device - The graphics device used to draw the quad.
 * @param {RenderTarget|undefined} target - The destination render target. If undefined, target is
 * the frame buffer.
 * @param {Shader} shader - The shader used for rendering the quad. Vertex shader should contain
 * `attribute vec2 vertex_position`.
 * @param {Vec4} [rect] - The viewport rectangle of the quad, in pixels. Defaults to fullscreen
 * (`0, 0, target.width, target.height`).
 * @param {Vec4} [scissorRect] - The scissor rectangle of the quad, in pixels. Defaults to
 * fullscreen (`0, 0, target.width, target.height`).
 * @param {boolean} [useBlend] - True to enable blending. Defaults to false, disabling blending.
 */
declare function drawQuadWithShader(device: GraphicsDevice$j, target: RenderTarget$2 | undefined, shader: Shader$2, rect?: Vec4$5, scissorRect?: Vec4$5, useBlend?: boolean): void;
/**
 * Draws a texture in screen-space. Mostly used by post-effects.
 *
 * @param {GraphicsDevice} device - The graphics device used to draw the texture.
 * @param {Texture} texture - The source texture to be drawn. Accessible as `uniform sampler2D
 * source` in shader.
 * @param {RenderTarget} [target] - The destination render target. Defaults to the frame buffer.
 * @param {Shader} [shader] - The shader used for rendering the texture. Defaults to {@link GraphicsDevice#getCopyShader}.
 * @param {Vec4} [rect] - The viewport rectangle to use for the texture, in pixels. Defaults to
 * fullscreen (`0, 0, target.width, target.height`).
 * @param {Vec4} [scissorRect] - The scissor rectangle to use for the texture, in pixels. Defaults
 * to fullscreen (`0, 0, target.width, target.height`).
 * @param {boolean} [useBlend] - True to enable blending. Defaults to false, disabling blending.
 */
declare function drawTexture(device: GraphicsDevice$j, texture: Texture$7, target?: RenderTarget$2, shader?: Shader$2, rect?: Vec4$5, scissorRect?: Vec4$5, useBlend?: boolean): void;

declare function begin(): string;
declare function end(): string;
declare function dummyFragmentCode(): string;
declare function fogCode(value: any, chunks: any): any;
declare function gammaCode(value: any, chunks: any): any;
declare function precisionCode(device: any): string;
declare function skinCode(device: any, chunks: any): any;
declare function tonemapCode(value: any, chunks: any): any;
declare function versionCode(device: any): "" | "#version 300 es\n";

declare namespace basic {
    function generateKey(options: any): string;
    function createShaderDefinition(device: any, options: any): {
        attributes: {
            vertex_position: string;
        };
        vshader: string;
        fshader: string;
    };
}

declare namespace particle {
    function generateKey(options: any): string;
    function _animTex(options: any): string;
    function createShaderDefinition(device: any, options: any): {
        attributes: {
            [x: string]: string;
        };
        vshader: string;
        fshader: string;
    };
}

declare namespace skybox {
    function generateKey(options: any): string;
    function createShaderDefinition(device: any, options: any): {
        attributes: {
            aPosition: string;
        };
        vshader: any;
        fshader: string;
    };
}

declare namespace standard {
    const optionsContext: {};
    const optionsContextMin: {};
    const generateKey: Function;
    function _correctChannel(p: any, chan: any): any;
    function _setMapTransform(codes: any, name: any, id: any, uv: any): any;
    function _getUvSourceExpression(transformPropName: string, uVPropName: string, options: any): string;
    function _addMapDef(name: any, enabled: any): string;
    function _addMapDefs(float: any, color: any, vertex: any, map: any): string;
    function _addMap(propName: string, chunkName: string, options: any, chunks: any, samplerFormat: string): string;
    function _directionalShadowMapProjection(light: any, shadowCoordArgs: any, shadowParamArg: any, lightIndex: any, coordsFunctioName: any): string;
    function _nonPointShadowMapProjection(device: any, light: any, shadowMatArg: any, shadowParamArg: any, lightIndex: any): string;
    function _addVaryingIfNeeded(code: any, type: any, name: any): string;
    function _getLightSourceShapeString(shape: any): "" | "Rect" | "Disk" | "Sphere";
    function _getPassDefineString(pass: any): "" | "#define PICK_PASS\n" | "#define DEPTH_PASS\n" | "#define SHADOW_PASS\n";
    function _vsAddTransformCode(code: any, device: any, chunks: any, options: any): any;
    function _vsAddBaseCode(code: any, device: any, chunks: any, options: any): any;
    function _fsAddBaseCode(code: string, device: GraphicsDevice$l, chunks: any, options: any): string;
    function _decodeFunc(textureFormat: any): any;
    function _fsAddStartCode(code: string, device: GraphicsDevice$l, chunks: any, options: any): string;
    function _buildShadowPassFragmentCode(code: any, device: any, chunks: any, options: any, varyings: any): any;
    const createShaderDefinition: Function;
}

declare namespace programlib {
    export { begin };
    export { dummyFragmentCode };
    export { end };
    export { fogCode };
    export { gammaCode };
    export { precisionCode };
    export { skinCode };
    export { tonemapCode };
    export { versionCode };
    export { basic };
    export { particle };
    export { skybox };
    export { standard };
}

/**
 * @static
 * @readonly
 * @type {object}
 * @name shaderChunks
 * @description Object containing all default shader chunks used by shader generators.
 */
declare const shaderChunks: object;

type GraphicsDevice$i = GraphicsDevice$l;
/** @typedef {import('./graphics-device.js').GraphicsDevice} GraphicsDevice */
/**
 * Representation of a shader uniform.
 *
 * @ignore
 */
declare class ShaderInput {
    /**
     * Create a new ShaderInput instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this shader input.
     * @param {string} name - The name of the shader input.
     * @param {number} type - The type of the shader input.
     * @param {number} locationId - The location id of the shader input.
     */
    constructor(graphicsDevice: GraphicsDevice$i, name: string, type: number, locationId: number);
    locationId: number;
    scopeId: ScopeId$1;
    version: Version;
    dataType: number;
    value: any[];
    array: any[];
}

type ScopeId = ScopeId$1;
type VertexBuffer$1 = VertexBuffer$3;
type VertexFormat = VertexFormat$2;
/**
 * A vertex iterator simplifies the process of writing vertex data to a vertex buffer.
 */
declare class VertexIterator {
    /**
     * Create a new VertexIterator instance.
     *
     * @param {VertexBuffer} vertexBuffer - The vertex buffer to be iterated.
     */
    constructor(vertexBuffer: VertexBuffer$1);
    vertexBuffer: VertexBuffer$3;
    vertexFormatSize: number;
    buffer: ArrayBuffer;
    accessors: VertexIteratorAccessor[];
    /**
     * The vertex buffer elements.
     *
     * @type {Object.<string, VertexIteratorAccessor>}
     */
    element: {
        [x: string]: VertexIteratorAccessor;
    };
    /**
     * Moves the vertex iterator on to the next vertex.
     *
     * @param {number} [count] - Optional number of steps to move on when calling next. Defaults to
     * 1.
     * @example
     * var iterator = new pc.VertexIterator(vertexBuffer);
     * iterator.element[pc.SEMANTIC_POSITION].set(-0.9, -0.9, 0.0);
     * iterator.element[pc.SEMANTIC_COLOR].set(255, 0, 0, 255);
     * iterator.next();
     * iterator.element[pc.SEMANTIC_POSITION].set(0.9, -0.9, 0.0);
     * iterator.element[pc.SEMANTIC_COLOR].set(0, 255, 0, 255);
     * iterator.next();
     * iterator.element[pc.SEMANTIC_POSITION].set(0.0, 0.9, 0.0);
     * iterator.element[pc.SEMANTIC_COLOR].set(0, 0, 255, 255);
     * iterator.end();
     */
    next(count?: number): void;
    /**
     * Notifies the vertex buffer being iterated that writes are complete. Internally the vertex
     * buffer is unlocked and vertex data is uploaded to video memory.
     *
     * @example
     * var iterator = new pc.VertexIterator(vertexBuffer);
     * iterator.element[pc.SEMANTIC_POSITION].set(-0.9, -0.9, 0.0);
     * iterator.element[pc.SEMANTIC_COLOR].set(255, 0, 0, 255);
     * iterator.next();
     * iterator.element[pc.SEMANTIC_POSITION].set(0.9, -0.9, 0.0);
     * iterator.element[pc.SEMANTIC_COLOR].set(0, 255, 0, 255);
     * iterator.next();
     * iterator.element[pc.SEMANTIC_POSITION].set(0.0, 0.9, 0.0);
     * iterator.element[pc.SEMANTIC_COLOR].set(0, 0, 255, 255);
     * iterator.end();
     */
    end(): void;
    /**
     * Copies data for specified semantic into vertex buffer. Works with both interleaved (slower)
     * and non-interleaved (fast) vertex buffers.
     *
     * @param {string} semantic - The semantic of the vertex element to set.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - The data to set.
     * @param {number} numVertices - The number of vertices to write.
     * @ignore
     */
    writeData(semantic: string, data: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, numVertices: number): void;
    /**
     * Function to extract elements of a specified semantic from vertex buffer into flat array
     * (data). Works with both interleaved (slower) and non-interleaved (fast) vertex buffers.
     * Returns number of vertices. Note: when data is a typed array and is smaller than needed,
     * only part of the data gets copied out (typed arrays ignore read/write out of range).
     *
     * @param {string} semantic - The semantic of the vertex element to read.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - The aray to recieve the data.
     * @returns {number} The number of vertices read.
     * @ignore
     */
    readData(semantic: string, data: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;
}
/**
 * Helps with accessing a specific vertex attribute.
 */
declare class VertexIteratorAccessor {
    /**
     * Create a new VertexIteratorAccessor instance.
     *
     * @param {ArrayBuffer} buffer - The vertex buffer containing the attribute to be accessed.
     * @param {object} vertexElement - The vertex attribute to be accessed.
     * @param {string} vertexElement.name - The meaning of the vertex element. This is used to link
     * the vertex data to a shader input. Can be:
     *
     * - {@link SEMANTIC_POSITION}
     * - {@link SEMANTIC_NORMAL}
     * - {@link SEMANTIC_TANGENT}
     * - {@link SEMANTIC_BLENDWEIGHT}
     * - {@link SEMANTIC_BLENDINDICES}
     * - {@link SEMANTIC_COLOR}
     * - {@link SEMANTIC_TEXCOORD0}
     * - {@link SEMANTIC_TEXCOORD1}
     * - {@link SEMANTIC_TEXCOORD2}
     * - {@link SEMANTIC_TEXCOORD3}
     * - {@link SEMANTIC_TEXCOORD4}
     * - {@link SEMANTIC_TEXCOORD5}
     * - {@link SEMANTIC_TEXCOORD6}
     * - {@link SEMANTIC_TEXCOORD7}
     *
     * If vertex data has a meaning other that one of those listed above, use the user-defined
     * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.
     * @param {number} vertexElement.numComponents - The number of components of the vertex
     * attribute. Can be 1, 2, 3 or 4.
     * @param {number} vertexElement.dataType - The data type of the attribute. Can be:
     *
     * - {@link TYPE_INT8}
     * - {@link TYPE_UINT8}
     * - {@link TYPE_INT16}
     * - {@link TYPE_UINT16}
     * - {@link TYPE_INT32}
     * - {@link TYPE_UINT32}
     * - {@link TYPE_FLOAT32}
     * @param {boolean} vertexElement.normalize - If true, vertex attribute data will be mapped
     * from a 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data
     * is left unchanged. If this property is unspecified, false is assumed.
     * @param {number} vertexElement.offset - The number of initial bytes at the start of a vertex
     * that are not relevant to this attribute.
     * @param {number} vertexElement.stride - The number of total bytes that are between the start
     * of one vertex, and the start of the next.
     * @param {ScopeId} vertexElement.scopeId - The shader input variable corresponding to the
     * attribute.
     * @param {number} vertexElement.size - The size of the attribute in bytes.
     * @param {VertexFormat} vertexFormat - A vertex format that defines the layout of vertex data
     * inside the buffer.
     */
    constructor(buffer: ArrayBuffer, vertexElement: {
        name: string;
        numComponents: number;
        dataType: number;
        normalize: boolean;
        offset: number;
        stride: number;
        scopeId: ScopeId;
        size: number;
    }, vertexFormat: VertexFormat);
    index: number;
    numComponents: number;
    array: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array;
    stride: number;
    /**
     * Set all the attribute components at the iterator's current index.
     *
     * @param {number} a - The first component value.
     * @param {number} [b] - The second component value (if applicable).
     * @param {number} [c] - The third component value (if applicable).
     * @param {number} [d] - The fourth component value (if applicable).
     */
    set(a: number, b?: number, c?: number, d?: number): void;
    /**
     * Read attribute components to an output array.
     *
     * @param {number} offset - The component offset at which to read data from the buffer. Will be
     * used instead of the iterator's current index.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} outputArray - The output array to write data into.
     * @param {number} outputIndex - The output index at which to write into the output array.
     */
    getToArray(offset: number, outputArray: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, outputIndex: number): void;
    /**
     * Write attribute components from an input array.
     *
     * @param {number} index - The starting index at which to write data into the buffer. Will be
     * used instead of the iterator's current index.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} inputArray - The input array to read data from.
     * @param {number} inputIndex - The input index at which to read from the input array.
     */
    setFromArray(index: number, inputArray: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, inputIndex: number): void;
    /**
     * Get a attribute component at the iterator's current index.
     *
     * @param {number} offset - The component offset. Should be either 0, 1, 2, or 3.
     * @returns {number} The value of a attribute component.
     */
    get(offset: number): number;
}

type Vec4$4 = Vec4$6;
type GraphicsDevice$h = GraphicsDevice$l;
type RenderTarget$1 = RenderTarget$3;
type Shader$1 = Shader$4;
/**
 * Create a vertex buffer with 4 vertices representing a fullscreen quad.
 *
 * @param {GraphicsDevice} device - The graphics device.
 * @returns {VertexBuffer} - The fullscreen quad vertex buffer.
 * @ignore
 */
declare function createFullscreenQuad(device: GraphicsDevice$h): VertexBuffer$3;
/**
 * Draw a screen-space rectangle in a render target. Primarily meant to be used in custom post
 * effects based on {@link PostEffect}.
 *
 * @param {GraphicsDevice} device - The graphics device of the application.
 * @param {RenderTarget} target - The output render target.
 * @param {VertexBuffer} vertexBuffer - The vertex buffer for the rectangle mesh. When calling from
 * a custom post effect, pass the field {@link PostEffect#vertexBuffer}.
 * @param {Shader} shader - The shader to be used for drawing the rectangle. When calling from a
 * custom post effect, pass the field {@link PostEffect#shader}.
 * @param {Vec4} [rect] - The normalized screen-space position (rect.x, rect.y) and size (rect.z,
 * rect.w) of the rectangle. Default is [0, 0, 1, 1].
 */
declare function drawFullscreenQuad(device: GraphicsDevice$h, target: RenderTarget$1, vertexBuffer: VertexBuffer$3, shader: Shader$1, rect?: Vec4$4): void;
/**
 * Base class for all post effects. Post effects take a a render target as input apply effects to
 * it and then render the result to an output render target or the screen if no output is
 * specified.
 */
declare class PostEffect$1 {
    /**
     * Create a new PostEffect instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device of the application.
     */
    constructor(graphicsDevice: GraphicsDevice$h);
    /**
     * The graphics device of the application.
     *
     * @type {GraphicsDevice}
     */
    device: GraphicsDevice$h;
    /**
     * The shader definition for the fullscreen quad. Needs to be set by the custom post effect
     * (default is null). Used when calling {@link drawFullscreenQuad}.
     *
     * @type {Shader|null}
     */
    shader: Shader$1 | null;
    /**
     * The vertex buffer for the fullscreen quad. Used when calling {@link drawFullscreenQuad}.
     *
     * @type {VertexBuffer}
     */
    vertexBuffer: VertexBuffer$3;
    /**
     * The property that should to be set to `true` (by the custom post effect) if a depth map
     * is necessary (default is false).
     *
     * @type {boolean}
     */
    needsDepthBuffer: boolean;
    depthMap: any;
    /**
     * Render the post effect using the specified inputTarget to the specified outputTarget.
     *
     * @param {RenderTarget} inputTarget - The input render target.
     * @param {RenderTarget} outputTarget - The output render target. If null then this will be the
     * screen.
     * @param {Vec4} [rect] - The rect of the current camera. If not specified, it will default to
     * [0, 0, 1, 1].
     */
    render(inputTarget: RenderTarget$1, outputTarget: RenderTarget$1, rect?: Vec4$4): void;
}

/**
 * Attach a TouchDevice to an element and it will receive and fire events when the element is
 * touched. See also {@link Touch} and {@link TouchEvent}.
 *
 * @augments EventHandler
 */
declare class TouchDevice$2 extends EventHandler$1 {
    /**
     * Create a new touch device and attach it to an element.
     *
     * @param {Element} element - The element to attach listen for events on.
     */
    constructor(element: Element);
    _element: Element;
    _startHandler: any;
    _endHandler: any;
    _moveHandler: any;
    _cancelHandler: any;
    /**
     * Attach a device to an element in the DOM. If the device is already attached to an element
     * this method will detach it first.
     *
     * @param {Element} element - The element to attach to.
     */
    attach(element: Element): void;
    /**
     * Detach a device from the element it is attached to.
     */
    detach(): void;
    _handleTouchStart(e: any): void;
    _handleTouchEnd(e: any): void;
    _handleTouchMove(e: any): void;
    _handleTouchCancel(e: any): void;
}

/**
 * Callback used by {@link MouseenablePointerLock } and {@link ApplicationdisablePointerLock }.
 */
type lockMouseCallback = () => any;
/**
 * @event
 * @name Mouse#mousemove
 * @description Fired when the mouse is moved.
 * @param {MouseEvent} event - The MouseEvent object.
 */
/**
 * @event
 * @name Mouse#mousedown
 * @description Fired when a mouse button is pressed.
 * @param {MouseEvent} event - The MouseEvent object.
 */
/**
 * @event
 * @name Mouse#mouseup
 * @description Fired when a mouse button is released.
 * @param {MouseEvent} event - The MouseEvent object.
 */
/**
 * @event
 * @name Mouse#mousewheel
 * @description Fired when a mouse wheel is moved.
 * @param {MouseEvent} event - The MouseEvent object.
 */
/**
 * Callback used by {@link Mouse#enablePointerLock} and {@link Application#disablePointerLock}.
 *
 * @callback lockMouseCallback
 */
/**
 * A Mouse Device, bound to a DOM Element.
 *
 * @augments EventHandler
 */
declare class Mouse$2 extends EventHandler$1 {
    /**
     * Check if the mouse pointer has been locked, using {@link Mouse#enabledPointerLock}.
     *
     * @returns {boolean} True if locked.
     */
    static isPointerLocked(): boolean;
    /**
     * Create a new Mouse instance.
     *
     * @param {Element} [element] - The Element that the mouse events are attached to.
     */
    constructor(element?: Element);
    _lastX: number;
    _lastY: number;
    _buttons: boolean[];
    _lastbuttons: boolean[];
    _upHandler: any;
    _downHandler: any;
    _moveHandler: any;
    _wheelHandler: any;
    _contextMenuHandler: (event: any) => void;
    _target: Element;
    _attached: boolean;
    /**
     * Attach mouse events to an Element.
     *
     * @param {Element} element - The DOM element to attach the mouse to.
     */
    attach(element: Element): void;
    /**
     * Remove mouse events from the element that it is attached to.
     */
    detach(): void;
    /**
     * Disable the context menu usually activated with right-click.
     */
    disableContextMenu(): void;
    /**
     * Enable the context menu usually activated with right-click. This option is active by
     * default.
     */
    enableContextMenu(): void;
    /**
     * Request that the browser hides the mouse cursor and locks the mouse to the element. Allowing
     * raw access to mouse movement input without risking the mouse exiting the element. Notes:
     *
     * - In some browsers this will only work when the browser is running in fullscreen mode. See
     * {@link Application#enableFullscreen}
     * - Enabling pointer lock can only be initiated by a user action e.g. in the event handler for
     * a mouse or keyboard input.
     *
     * @param {lockMouseCallback} [success] - Function called if the request for mouse lock is
     * successful.
     * @param {lockMouseCallback} [error] - Function called if the request for mouse lock is
     * unsuccessful.
     */
    enablePointerLock(success?: lockMouseCallback, error?: lockMouseCallback): void;
    /**
     * Return control of the mouse cursor to the user.
     *
     * @param {lockMouseCallback} [success] - Function called when the mouse lock is disabled.
     */
    disablePointerLock(success?: lockMouseCallback): void;
    /**
     * Update method, should be called once per frame.
     */
    update(): void;
    /**
     * Returns true if the mouse button is currently pressed.
     *
     * @param {number} button - The mouse button to test. Can be:
     *
     * - {@link MOUSEBUTTON_LEFT}
     * - {@link MOUSEBUTTON_MIDDLE}
     * - {@link MOUSEBUTTON_RIGHT}
     *
     * @returns {boolean} True if the mouse button is current pressed.
     */
    isPressed(button: number): boolean;
    /**
     * Returns true if the mouse button was pressed this frame (since the last call to update).
     *
     * @param {number} button - The mouse button to test. Can be:
     *
     * - {@link MOUSEBUTTON_LEFT}
     * - {@link MOUSEBUTTON_MIDDLE}
     * - {@link MOUSEBUTTON_RIGHT}
     *
     * @returns {boolean} True if the mouse button was pressed since the last update.
     */
    wasPressed(button: number): boolean;
    /**
     * Returns true if the mouse button was released this frame (since the last call to update).
     *
     * @param {number} button - The mouse button to test. Can be:
     *
     * - {@link MOUSEBUTTON_LEFT}
     * - {@link MOUSEBUTTON_MIDDLE}
     * - {@link MOUSEBUTTON_RIGHT}
     *
     * @returns {boolean} True if the mouse button was released since the last update.
     */
    wasReleased(button: number): boolean;
    _handleUp(event: any): void;
    _handleDown(event: any): void;
    _handleMove(event: any): void;
    _handleWheel(event: any): void;
    _getTargetCoords(event: any): {
        x: number;
        y: number;
    };
}

/**
 * @event
 * @name Keyboard#keydown
 * @description Event fired when a key is pressed.
 * @param {KeyboardEvent} event - The Keyboard event object. Note, this event is only valid for the current callback.
 * @example
 * var onKeyDown = function (e) {
 *     if (e.key === pc.KEY_SPACE) {
 *         // space key pressed
 *     }
 *     e.event.preventDefault(); // Use original browser event to prevent browser action.
 * };
 * app.keyboard.on("keydown", onKeyDown, this);
 */
/**
 * @event
 * @name Keyboard#keyup
 * @description Event fired when a key is released.
 * @param {KeyboardEvent} event - The Keyboard event object. Note, this event is only valid for the current callback.
 * @example
 * var onKeyUp = function (e) {
 *     if (e.key === pc.KEY_SPACE) {
 *         // space key released
 *     }
 *     e.event.preventDefault(); // Use original browser event to prevent browser action.
 * };
 * app.keyboard.on("keyup", onKeyUp, this);
 */
/**
 * A Keyboard device bound to an Element. Allows you to detect the state of the key presses. Note
 * that the Keyboard object must be attached to an Element before it can detect any key presses.
 *
 * @augments EventHandler
 */
declare class Keyboard$2 extends EventHandler$1 {
    /**
     * Create a new Keyboard instance.
     *
     * @param {Element|Window} [element] - Element to attach Keyboard to. Note that elements like
     * &lt;div&gt; can't accept focus by default. To use keyboard events on an element like this it
     * must have a value of 'tabindex' e.g. tabindex="0". See
     * [here](http://www.w3.org/WAI/GL/WCAG20/WD-WCAG20-TECHS/SCR29.html) for more details.
     * @param {object} [options] - Optional options object.
     * @param {boolean} [options.preventDefault] - Call preventDefault() in key event handlers.
     * This stops the default action of the event occurring. e.g. Ctrl+T will not open a new
     * browser tab.
     * @param {boolean} [options.stopPropagation] - Call stopPropagation() in key event handlers.
     * This stops the event bubbling up the DOM so no parent handlers will be notified of the
     * event.
     * @example
     * // attach keyboard listeners to the window
     * var keyboard = new pc.Keyboard(window);
     */
    constructor(element?: Element | Window, options?: {
        preventDefault?: boolean;
        stopPropagation?: boolean;
    });
    _element: Element;
    _keyDownHandler: any;
    _keyUpHandler: any;
    _keyPressHandler: any;
    _visibilityChangeHandler: any;
    _windowBlurHandler: any;
    _keymap: {};
    _lastmap: {};
    preventDefault: boolean;
    stopPropagation: boolean;
    /**
     * Attach the keyboard event handlers to an Element.
     *
     * @param {Element} element - The element to listen for keyboard events on.
     */
    attach(element: Element): void;
    /**
     * Detach the keyboard event handlers from the element it is attached to.
     */
    detach(): void;
    /**
     * Convert a key code into a key identifier.
     *
     * @param {number} keyCode - The key code.
     * @returns {string} The key identifier.
     * @private
     */
    private toKeyIdentifier;
    /**
     * Process the browser keydown event.
     *
     * @param {globalThis.KeyboardEvent} event - The browser keyboard event.
     * @private
     */
    private _handleKeyDown;
    /**
     * Process the browser keyup event.
     *
     * @param {globalThis.KeyboardEvent} event - The browser keyboard event.
     * @private
     */
    private _handleKeyUp;
    /**
     * Process the browser keypress event.
     *
     * @param {globalThis.KeyboardEvent} event - The browser keyboard event.
     * @private
     */
    private _handleKeyPress;
    /**
     * Handle the browser visibilitychange event.
     *
     * @private
     */
    private _handleVisibilityChange;
    /**
     * Handle the browser blur event.
     *
     * @private
     */
    private _handleWindowBlur;
    /**
     * Called once per frame to update internal state.
     *
     * @ignore
     */
    update(): void;
    /**
     * Return true if the key is currently down.
     *
     * @param {number} key - The keyCode of the key to test. See the KEY_* constants.
     * @returns {boolean} True if the key was pressed, false if not.
     */
    isPressed(key: number): boolean;
    /**
     * Returns true if the key was pressed since the last update.
     *
     * @param {number} key - The keyCode of the key to test. See the KEY_* constants.
     * @returns {boolean} True if the key was pressed.
     */
    wasPressed(key: number): boolean;
    /**
     * Returns true if the key was released since the last update.
     *
     * @param {number} key - The keyCode of the key to test. See the KEY_* constants.
     * @returns {boolean} True if the key was pressed.
     */
    wasReleased(key: number): boolean;
}

/**
 * Input handler for accessing GamePad input.
 */
declare class GamePads$2 {
    gamepadsSupported: boolean;
    current: any[];
    previous: any[];
    deadZone: number;
    /**
     * Update the current and previous state of the gamepads. This must be called every frame for
     * `wasPressed` to work.
     */
    update(): void;
    /**
     * Poll for the latest data from the gamepad API.
     *
     * @param {object[]} [pads] - An optional array used to receive the gamepads mapping. This
     * array will be returned by this function.
     * @returns {object[]} An array of gamepads and mappings for the model of gamepad that is
     * attached.
     * @example
     * var gamepads = new pc.GamePads();
     * var pads = gamepads.poll();
     */
    poll(pads?: object[]): object[];
    getMap(pad: any): any;
    /**
     * Returns true if the button on the pad requested is pressed.
     *
     * @param {number} index - The index of the pad to check, use constants {@link PAD_1},
     * {@link PAD_2}, etc.
     * @param {number} button - The button to test, use constants {@link PAD_FACE_1}, etc.
     * @returns {boolean} True if the button is pressed.
     */
    isPressed(index: number, button: number): boolean;
    /**
     * Returns true if the button was pressed since the last frame.
     *
     * @param {number} index - The index of the pad to check, use constants {@link PAD_1},
     * {@link PAD_2}, etc.
     * @param {number} button - The button to test, use constants {@link PAD_FACE_1}, etc.
     * @returns {boolean} True if the button was pressed since the last frame.
     */
    wasPressed(index: number, button: number): boolean;
    /**
     * Returns true if the button was released since the last frame.
     *
     * @param {number} index - The index of the pad to check, use constants {@link PAD_1},
     * {@link PAD_2}, etc.
     * @param {number} button - The button to test, use constants {@link PAD_FACE_1}, etc.
     * @returns {boolean} True if the button was released since the last frame.
     */
    wasReleased(index: number, button: number): boolean;
    /**
     * Get the value of one of the analogue axes of the pad.
     *
     * @param {number} index - The index of the pad to check, use constants {@link PAD_1},
     * {@link PAD_2}, etc.
     * @param {number} axes - The axes to get the value of, use constants {@link PAD_L_STICK_X},
     * etc.
     * @returns {number} The value of the axis between -1 and 1.
     */
    getAxis(index: number, axes: number): number;
}

type ComponentSystem$1 = ComponentSystem;
type Entity$t = Entity$a;
/** @typedef {import('./system.js').ComponentSystem} ComponentSystem */
/** @typedef {import('../entity.js').Entity} Entity */
/**
 * Components are used to attach functionality on a {@link Entity}. Components can receive update
 * events each frame, and expose properties to the PlayCanvas Editor.
 *
 * @property {ComponentSystem} system The ComponentSystem used to create this Component.
 * @property {Entity} entity The Entity that this Component is attached to.
 * @property {boolean} enabled Enables or disables the component.
 * @augments EventHandler
 */
declare class Component$2 extends EventHandler$1 {
    static _buildAccessors(obj: any, schema: any): void;
    /**
     * Base constructor for a Component.
     *
     * @param {ComponentSystem} system - The ComponentSystem used to create this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ComponentSystem$1, entity: Entity$t);
    system: ComponentSystem;
    entity: Entity$a;
    buildAccessors(schema: any): void;
    onSetEnabled(name: any, oldValue: any, newValue: any): void;
    onEnable(): void;
    onDisable(): void;
    onPostStateChange(): void;
    /**
     * Access the component data directly. Usually you should access the data properties via the
     * individual properties as modifying this data directly will not fire 'set' events.
     *
     * @type {*}
     * @ignore
     */
    get data(): any;

    set enabled(arg: boolean);
    get enabled(): boolean;

}

type Application$i = Application$7;
type Component$1 = Component$2;
type Entity$s = Entity$a;
/** @typedef {import('../application.js').Application} Application */
/** @typedef {import('./component.js').Component} Component */
/** @typedef {import('../entity.js').Entity} Entity */
/**
 * Component Systems contain the logic and functionality to update all Components of a particular
 * type.
 *
 * @augments EventHandler
 */
declare class ComponentSystem extends EventHandler$1 {
    /**
     * Create a new ComponentSystem instance.
     *
     * @param {Application} app - The application managing this system.
     */
    constructor(app: Application$i);
    app: Application$7;
    store: {};
    schema: any[];
    /**
     * Create new {@link Component} and component data instances and attach them to the entity.
     *
     * @param {Entity} entity - The Entity to attach this component to.
     * @param {object} [data] - The source data with which to create the component.
     * @returns {Component} Returns a Component of type defined by the component system.
     * @example
     * var entity = new pc.Entity(app);
     * app.systems.model.addComponent(entity, { type: 'box' });
     * // entity.model is now set to a pc.ModelComponent
     * @ignore
     */
    addComponent(entity: Entity$s, data?: object): Component$1;
    /**
     * Remove the {@link Component} from the entity and delete the associated component data.
     *
     * @param {Entity} entity - The entity to remove the component from.
     * @example
     * app.systems.model.removeComponent(entity);
     * // entity.model === undefined
     * @ignore
     */
    removeComponent(entity: Entity$s): void;
    /**
     * Create a clone of component. This creates a copy of all component data variables.
     *
     * @param {Entity} entity - The entity to clone the component from.
     * @param {Entity} clone - The entity to clone the component into.
     * @returns {Component} The newly cloned component.
     * @ignore
     */
    cloneComponent(entity: Entity$s, clone: Entity$s): Component$1;
    /**
     * Called during {@link ComponentSystem#addComponent} to initialize the component data in the
     * store. This can be overridden by derived Component Systems and either called by the derived
     * System or replaced entirely.
     *
     * @param {Component} component - The component being initialized.
     * @param {object} data - The data block used to initialize the component.
     * @param {string[]|object[]} properties - The array of property descriptors for the component.
     * A descriptor can be either a plain property name, or an object specifying the name and type.
     * @ignore
     */
    initializeComponentData(component: Component$1, data: object, properties: string[] | object[]): void;
    /**
     * Searches the component schema for properties that match the specified type.
     *
     * @param {string} type - The type to search for.
     * @returns {string[]|object[]} An array of property descriptors matching the specified type.
     * @ignore
     */
    getPropertiesOfType(type: string): string[] | object[];
    destroy(): void;
}

declare class SpriteComponentData {
    enabled: boolean;
}

/**
 * Manages creation of {@link SpriteComponent}s.
 *
 * @augments ComponentSystem
 */
declare class SpriteComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof SpriteComponent$1;
    DataType: typeof SpriteComponentData;
    _defaultTexture: Texture$8;
    _defaultMaterial: any;
    _default9SlicedMaterialSlicedMode: any;
    _default9SlicedMaterialTiledMode: any;
    set defaultMaterial(arg: any);
    get defaultMaterial(): any;
    set default9SlicedMaterialSlicedMode(arg: any);
    get default9SlicedMaterialSlicedMode(): any;
    set default9SlicedMaterialTiledMode(arg: any);
    get default9SlicedMaterialTiledMode(): any;
    onUpdate(dt: any): void;
    onBeforeRemove(entity: any, component: any): void;
}

declare class TagsCache {
    constructor(key?: any);
    _index: {};
    _key: any;
    addItem(item: any): void;
    removeItem(item: any): void;
    add(tag: any, item: any): void;
    remove(tag: any, item: any): void;
    find(args: any): any[];
}

type ResourceLoader$5 = ResourceLoader$4;
/**
 * Callback used by {@link AssetRegistryfilter } to filter assets.
 */
type filterAssetCallback = (asset: Asset$6) => boolean;
/**
 * Callback used by {@link AssetRegistryloadFromUrl } and called when an asset is loaded (or an
 * error occurs).
 */
type loadAssetCallback = (err: string | null, asset?: Asset$6) => any;
/** @typedef {import('../resources/loader.js').ResourceLoader} ResourceLoader */
/**
 * Callback used by {@link AssetRegistry#filter} to filter assets.
 *
 * @callback filterAssetCallback
 * @param {Asset} asset - The current asset to filter.
 * @returns {boolean} Return `true` to include asset to result list.
 */
/**
 * Callback used by {@link AssetRegistry#loadFromUrl} and called when an asset is loaded (or an
 * error occurs).
 *
 * @callback loadAssetCallback
 * @param {string|null} err - The error message is null if no errors were encountered.
 * @param {Asset} [asset] - The loaded asset if no errors were encountered.
 */
/**
 * Container for all assets that are available to this application. Note that PlayCanvas scripts
 * are provided with an AssetRegistry instance as `app.assets`.
 *
 * @augments EventHandler
 */
declare class AssetRegistry$c extends EventHandler$1 {
    /**
     * Create an instance of an AssetRegistry.
     *
     * @param {ResourceLoader} loader - The ResourceLoader used to load the asset files.
     */
    constructor(loader: ResourceLoader$5);
    _loader: ResourceLoader$4;
    _assets: any[];
    _cache: {};
    _names: {};
    _tags: TagsCache;
    _urls: {};
    /**
     * A URL prefix that will be added to all asset loading requests.
     *
     * @type {string}
     */
    prefix: string;
    /**
     * @event
     * @name AssetRegistry#load
     * @description Fired when an asset completes loading.
     * @param {Asset} asset - The asset that has just loaded.
     * @example
     * app.assets.on("load", function (asset) {
     *     console.log("asset loaded: " + asset.name);
     * });
     */
    /**
     * @event
     * @name AssetRegistry#load:[id]
     * @description Fired when an asset completes loading.
     * @param {Asset} asset - The asset that has just loaded.
     * @example
     * var id = 123456;
     * var asset = app.assets.get(id);
     * app.assets.on("load:" + id, function (asset) {
     *     console.log("asset loaded: " + asset.name);
     * });
     * app.assets.load(asset);
     */
    /**
     * @event
     * @name AssetRegistry#load:url:[url]
     * @description Fired when an asset completes loading.
     * @param {Asset} asset - The asset that has just loaded.
     * @example
     * var id = 123456;
     * var asset = app.assets.get(id);
     * app.assets.on("load:url:" + asset.file.url, function (asset) {
     *     console.log("asset loaded: " + asset.name);
     * });
     * app.assets.load(asset);
     */
    /**
     * @event
     * @name AssetRegistry#add
     * @description Fired when an asset is added to the registry.
     * @param {Asset} asset - The asset that was added.
     * @example
     * app.assets.on("add", function (asset) {
     *     console.log("New asset added: " + asset.name);
     * });
     */
    /**
     * @event
     * @name AssetRegistry#add:[id]
     * @description Fired when an asset is added to the registry.
     * @param {Asset} asset - The asset that was added.
     * @example
     * var id = 123456;
     * app.assets.on("add:" + id, function (asset) {
     *     console.log("Asset 123456 loaded");
     * });
     */
    /**
     * @event
     * @name AssetRegistry#add:url:[url]
     * @description Fired when an asset is added to the registry.
     * @param {Asset} asset - The asset that was added.
     */
    /**
     * @event
     * @name AssetRegistry#remove
     * @description Fired when an asset is removed from the registry.
     * @param {Asset} asset - The asset that was removed.
     * @example
     * app.assets.on("remove", function (asset) {
     *     console.log("Asset removed: " + asset.name);
     * });
     */
    /**
     * @event
     * @name AssetRegistry#remove:[id]
     * @description Fired when an asset is removed from the registry.
     * @param {Asset} asset - The asset that was removed.
     * @example
     * var id = 123456;
     * app.assets.on("remove:" + id, function (asset) {
     *     console.log("Asset removed: " + asset.name);
     * });
     */
    /**
     * @event
     * @name AssetRegistry#remove:url:[url]
     * @description Fired when an asset is removed from the registry.
     * @param {Asset} asset - The asset that was removed.
     */
    /**
     * @event
     * @name AssetRegistry#error
     * @description Fired when an error occurs during asset loading.
     * @param {string} err - The error message.
     * @param {Asset} asset - The asset that generated the error.
     * @example
     * var id = 123456;
     * var asset = app.assets.get(id);
     * app.assets.on("error", function (err, asset) {
     *     console.error(err);
     * });
     * app.assets.load(asset);
     */
    /**
     * @event
     * @name AssetRegistry#error:[id]
     * @description Fired when an error occurs during asset loading.
     * @param {Asset} asset - The asset that generated the error.
     * @example
     * var id = 123456;
     * var asset = app.assets.get(id);
     * app.assets.on("error:" + id, function (err, asset) {
     *     console.error(err);
     * });
     * app.assets.load(asset);
     */
    /**
     * Create a filtered list of assets from the registry.
     *
     * @param {object} filters - Properties to filter on, currently supports: 'preload: true|false'.
     * @returns {Asset[]} The filtered list of assets.
     */
    list(filters: object): Asset$6[];
    /**
     * Add an asset to the registry.
     *
     * @param {Asset} asset - The asset to add.
     * @example
     * var asset = new pc.Asset("My Asset", "texture", {
     *     url: "../path/to/image.jpg"
     * });
     * app.assets.add(asset);
     */
    add(asset: Asset$6): void;
    /**
     * Remove an asset from the registry.
     *
     * @param {Asset} asset - The asset to remove.
     * @returns {boolean} True if the asset was successfully removed and false otherwise.
     * @example
     * var asset = app.assets.get(100);
     * app.assets.remove(asset);
     */
    remove(asset: Asset$6): boolean;
    /**
     * Retrieve an asset from the registry by its id field.
     *
     * @param {number} id - The id of the asset to get.
     * @returns {Asset} The asset.
     * @example
     * var asset = app.assets.get(100);
     */
    get(id: number): Asset$6;
    /**
     * Retrieve an asset from the registry by its file's URL field.
     *
     * @param {string} url - The url of the asset to get.
     * @returns {Asset} The asset.
     * @example
     * var asset = app.assets.getByUrl("../path/to/image.jpg");
     */
    getByUrl(url: string): Asset$6;
    /**
     * Load the asset's file from a remote source. Listen for "load" events on the asset to find
     * out when it is loaded.
     *
     * @param {Asset} asset - The asset to load.
     * @example
     * // load some assets
     * var assetsToLoad = [
     *     app.assets.find("My Asset"),
     *     app.assets.find("Another Asset")
     * ];
     * var count = 0;
     * assetsToLoad.forEach(function (assetToLoad) {
     *     assetToLoad.ready(function (asset) {
     *         count++;
     *         if (count === assetsToLoad.length) {
     *             // done
     *         }
     *     });
     *     app.assets.load(assetToLoad);
     * });
     */
    load(asset: Asset$6): void;
    /**
     * Use this to load and create an asset if you don't have assets created. Usually you would
     * only use this if you are not integrated with the PlayCanvas Editor.
     *
     * @param {string} url - The url to load.
     * @param {string} type - The type of asset to load.
     * @param {loadAssetCallback} callback - Function called when asset is loaded, passed (err,
     * asset), where err is null if no errors were encountered.
     * @example
     * app.assets.loadFromUrl("../path/to/texture.jpg", "texture", function (err, asset) {
     *     var texture = asset.resource;
     * });
     */
    loadFromUrl(url: string, type: string, callback: loadAssetCallback): void;
    /**
     * Use this to load and create an asset when both the URL and filename are required. For
     * example, use this function when loading BLOB assets, where the URL does not adequately
     * identify the file.
     *
     * @param {string} url - The url to load.
     * @param {string} filename - The filename of the asset to load.
     * @param {string} type - The type of asset to load.
     * @param {loadAssetCallback} callback - Function called when asset is loaded, passed (err,
     * asset), where err is null if no errors were encountered.
     * @example
     * var file = magicallyAttainAFile();
     * app.assets.loadFromUrlAndFilename(URL.createObjectURL(file), "texture.png", "texture", function (err, asset) {
     *     var texture = asset.resource;
     * });
     */
    loadFromUrlAndFilename(url: string, filename: string, type: string, callback: loadAssetCallback): void;
    loadFromUrlError: any;
    _loadModel(modelAsset: any, continuation: any): void;
    _loadMaterials(modelAsset: any, mapping: any, callback: any): void;
    _loadTextures(materialAsset: any, callback: any): void;
    /**
     * Return all Assets with the specified name and type found in the registry.
     *
     * @param {string} name - The name of the Assets to find.
     * @param {string} [type] - The type of the Assets to find.
     * @returns {Asset[]} A list of all Assets found.
     * @example
     * var assets = app.assets.findAll("myTextureAsset", "texture");
     * console.log("Found " + assets.length + " assets called " + name);
     */
    findAll(name: string, type?: string): Asset$6[];
    _onTagAdd(tag: any, asset: any): void;
    _onTagRemove(tag: any, asset: any): void;
    /**
     * Return all Assets that satisfy the search query. Query can be simply a string, or comma
     * separated strings, to have inclusive results of assets that match at least one query. A
     * query that consists of an array of tags can be used to match assets that have each tag of
     * array.
     *
     * @param {...*} query - Name of a tag or array of tags.
     * @returns {Asset[]} A list of all Assets matched query.
     * @example
     * var assets = app.assets.findByTag("level-1");
     * // returns all assets that tagged by `level-1`
     * @example
     * var assets = app.assets.findByTag("level-1", "level-2");
     * // returns all assets that tagged by `level-1` OR `level-2`
     * @example
     * var assets = app.assets.findByTag(["level-1", "monster"]);
     * // returns all assets that tagged by `level-1` AND `monster`
     * @example
     * var assets = app.assets.findByTag(["level-1", "monster"], ["level-2", "monster"]);
     * // returns all assets that tagged by (`level-1` AND `monster`) OR (`level-2` AND `monster`)
     */
    findByTag(...args: any[]): Asset$6[];
    /**
     * Return all Assets that satisfy a filter callback.
     *
     * @param {filterAssetCallback} callback - The callback function that is used to filter assets.
     * Return `true` to include an asset in the returned array.
     * @returns {Asset[]} A list of all Assets found.
     * @example
     * var assets = app.assets.filter(function (asset) {
     *     return asset.name.indexOf('monster') !== -1;
     * });
     * console.log("Found " + assets.length + " assets, where names contains 'monster'");
     */
    filter(callback: filterAssetCallback): Asset$6[];
    /**
     * Return the first Asset with the specified name and type found in the registry.
     *
     * @param {string} name - The name of the Asset to find.
     * @param {string} [type] - The type of the Asset to find.
     * @returns {Asset} A single Asset or null if no Asset is found.
     * @example
     * var asset = app.assets.find("myTextureAsset", "texture");
     */
    find(name: string, type?: string): Asset$6;
}

type Asset$8 = Asset$6;
type AssetRegistry$b = AssetRegistry$c;
/**
 * Callback used by {@link ResourceHandlerload } when a resource is loaded (or an error occurs).
 */
type resourceHandlerCallback$1 = (err: string | null, response?: any) => any;
/** @typedef {import('../asset/asset.js').Asset} Asset */
/** @typedef {import('../asset/asset-registry.js').AssetRegistry} AssetRegistry */
/**
 * Callback used by {@link ResourceHandler#load} when a resource is loaded (or an error occurs).
 *
 * @callback resourceHandlerCallback
 * @param {string|null} err - The error message in the case where the load fails.
 * @param {*} [response] - The raw data that has been successfully loaded.
 */
/**
 * @interface
 * @name ResourceHandler
 * @description Interface for ResourceHandlers used by {@link ResourceLoader}.
 */
declare class ResourceHandler$h {
    /**
     * @function
     * @name ResourceHandler#load
     * @description Load a resource from a remote URL. When loaded (or failed),
     * use the callback to return an the raw resource data (or error).
     * @param {string|object} url - Either the URL of the resource to load or a structure containing the
     * load and original URL.
     * @param {string} [url.load] - The URL to be used for loading the resource.
     * @param {string} [url.original] - The original URL to be used for identifying the resource
     * format. This is necessary when loading, for example from blob.
     * @param {resourceHandlerCallback} callback - The callback used when the resource is loaded or an error occurs.
     * @param {Asset} [asset] - Optional asset that is passed by ResourceLoader.
     */
    load(url: string | object, callback: resourceHandlerCallback$1, asset?: Asset$8): void;
    /**
     * @function
     * @name ResourceHandler#open
     * @description Convert raw resource data into a resource instance. E.g. Take 3D model format JSON and return a {@link Model}.
     * @param {string} url - The URL of the resource to open.
     * @param {*} data - The raw resource data passed by callback from {@link ResourceHandler#load}.
     * @param {Asset} [asset] - Optional asset that is passed by ResourceLoader.
     * @returns {*} The parsed resource data.
     */
    open(url: string, data: any, asset?: Asset$8): any;
    /**
     * @function
     * @name ResourceHandler#[patch]
     * @description Optional function to perform any operations on a resource, that requires a dependency on its asset data
     * or any other asset data.
     * @param {Asset} asset - The asset to patch.
     * @param {AssetRegistry} assets - The asset registry.
     */
    patch(asset: Asset$8, assets: AssetRegistry$b): void;
}

type Asset$7 = Asset$6;
type AssetRegistry$a = AssetRegistry$c;
type Application$h = Application$7;
type ResourceHandler$g = ResourceHandler$h;
type resourceLoaderCallback$1 = () => any;
/** @typedef {import('../asset/asset.js').Asset} Asset */
/** @typedef {import('../asset/asset-registry.js').AssetRegistry} AssetRegistry */
/** @typedef {import('../framework/application.js').Application} Application */
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * @callback resourceLoaderCallback
 * @description Callback used by {@link ResourceLoader#load} when a resource is loaded (or an error occurs).
 * @param {string|null} err - The error message in the case where the load fails.
 * @param {*} [resource] - The resource that has been successfully loaded.
 */
/**
 * Load resource data, potentially from remote sources. Caches resource on load to prevent multiple
 * requests. Add ResourceHandlers to handle different types of resources.
 */
declare class ResourceLoader$4 {
    /**
     * Create a new ResourceLoader instance.
     *
     * @param {Application} app - The application.
     */
    constructor(app: Application$h);
    _handlers: {};
    _requests: {};
    _cache: {};
    _app: Application$7;
    /**
     * Add a {@link ResourceHandler} for a resource type. Handler should support at least `load()`
     * and `open()`. Handlers can optionally support patch(asset, assets) to handle dependencies on
     * other assets.
     *
     * @param {string} type - The name of the resource type that the handler will be registered
     * with. Can be:
     *
     * - {@link ASSET_ANIMATION}
     * - {@link ASSET_AUDIO}
     * - {@link ASSET_IMAGE}
     * - {@link ASSET_JSON}
     * - {@link ASSET_MODEL}
     * - {@link ASSET_MATERIAL}
     * - {@link ASSET_TEXT}
     * - {@link ASSET_TEXTURE}
     * - {@link ASSET_CUBEMAP}
     * - {@link ASSET_SHADER}
     * - {@link ASSET_CSS}
     * - {@link ASSET_HTML}
     * - {@link ASSET_SCRIPT}
     * - {@link ASSET_CONTAINER}
     *
     * @param {ResourceHandler} handler - An instance of a resource handler supporting at least
     * `load()` and `open()`.
     * @example
     * var loader = new ResourceLoader();
     * loader.addHandler("json", new pc.JsonHandler());
     */
    addHandler(type: string, handler: ResourceHandler$g): void;
    /**
     * Remove a {@link ResourceHandler} for a resource type.
     *
     * @param {string} type - The name of the type that the handler will be removed.
     */
    removeHandler(type: string): void;
    /**
     * Get a {@link ResourceHandler} for a resource type.
     *
     * @param {string} type - The name of the resource type that the handler is registered with.
     * @returns {ResourceHandler} The registered handler.
     */
    getHandler(type: string): ResourceHandler$g;
    /**
     * Make a request for a resource from a remote URL. Parse the returned data using the handler
     * for the specified type. When loaded and parsed, use the callback to return an instance of
     * the resource.
     *
     * @param {string} url - The URL of the resource to load.
     * @param {string} type - The type of resource expected.
     * @param {resourceLoaderCallback} callback - The callback used when the resource is loaded or
     * an error occurs. Passed (err, resource) where err is null if there are no errors.
     * @param {Asset} [asset] - Optional asset that is passed into handler
     * @example
     * app.loader.load("../path/to/texture.png", "texture", function (err, texture) {
     *     // use texture here
     * });
     */
    load(url: string, type: string, callback: resourceLoaderCallback$1, asset?: Asset$7): void;
    _loadNull(handler: any, callback: any, asset: any): void;
    _onSuccess(key: any, result: any, extra: any): void;
    _onFailure(key: any, err: any): void;
    /**
     * Convert raw resource data into a resource instance. E.g. Take 3D model format JSON and
     * return a {@link Model}.
     *
     * @param {string} type - The type of resource.
     * @param {*} data - The raw resource data.
     * @returns {*} The parsed resource data.
     */
    open(type: string, data: any): any;
    /**
     * Perform any operations on a resource, that requires a dependency on its asset data or any
     * other asset data.
     *
     * @param {Asset} asset - The asset to patch.
     * @param {AssetRegistry} assets - The asset registry.
     */
    patch(asset: Asset$7, assets: AssetRegistry$a): void;
    /**
     * Remove resource from cache.
     *
     * @param {string} url - The URL of the resource.
     * @param {string} type - The type of resource.
     */
    clearCache(url: string, type: string): void;
    /**
     * Check cache for resource from a URL. If present, return the cached value.
     *
     * @param {string} url - The URL of the resource to get from the cache.
     * @param {string} type - The type of the resource.
     * @returns {*} The resource loaded from the cache.
     */
    getFromCache(url: string, type: string): any;
    /**
     * Enables retrying of failed requests when loading assets.
     *
     * @param {number} maxRetries - The maximum number of times to retry loading an asset. Defaults
     * to 5.
     * @ignore
     */
    enableRetry(maxRetries?: number): void;
    /**
     * Disables retrying of failed requests when loading assets.
     *
     * @ignore
     */
    disableRetry(): void;
    /**
     * Destroys the resource loader.
     */
    destroy(): void;
}

type AssetRegistry$9 = AssetRegistry$c;
type resourceLoaderCallback = resourceLoaderCallback$1;
/**
 * Callback used by {@link Assetready } and called when an asset is ready.
 */
type assetReadyCallback = (asset: Asset$6) => any;
/**
 * Callback used by {@link Asset#ready} and called when an asset is ready.
 *
 * @callback assetReadyCallback
 * @param {Asset} asset - The ready asset.
 */
/**
 * An asset record of a file or data resource that can be loaded by the engine. The asset contains
 * four important fields:
 *
 * - `file`: contains the details of a file (filename, url) which contains the resource data, e.g.
 * an image file for a texture asset.
 * - `data`: contains a JSON blob which contains either the resource data for the asset (e.g.
 * material data) or additional data for the file (e.g. material mappings for a model).
 * - `options`: contains a JSON blob with handler-specific load options.
 * - `resource`: contains the final resource when it is loaded. (e.g. a {@link StandardMaterial} or
 * a {@link Texture}).
 *
 * See the {@link AssetRegistry} for details on loading resources from assets.
 *
 * @augments EventHandler
 */
declare class Asset$6 extends EventHandler$1 {
    /**
     * Helper function to resolve asset file data and return the contents as an ArrayBuffer. If the
     * asset file contents are present, that is returned. Otherwise the file data is be downloaded
     * via http.
     *
     * @param {string} loadUrl - The URL as passed into the handler
     * @param {resourceLoaderCallback} callback - The callback function to receive results.
     * @param {Asset} [asset] - The asset
     * @param {number} maxRetries - Number of retries if http download is required
     * @ignore
     */
    static fetchArrayBuffer(loadUrl: string, callback: resourceLoaderCallback, asset?: Asset$6, maxRetries?: number): void;
    /**
     * Create a new Asset record. Generally, Assets are created in the loading process and you
     * won't need to create them by hand.
     *
     * @param {string} name - A non-unique but human-readable name which can be later used to
     * retrieve the asset.
     * @param {string} type - Type of asset. One of ["animation", "audio", "binary", "container",
     * "cubemap", "css", "font", "json", "html", "material", "model", "script", "shader", "sprite",
     * "template", text", "texture"]
     * @param {object} [file] - Details about the file the asset is made from. At the least must
     * contain the 'url' field. For assets that don't contain file data use null.
     * @param {string} [file.url] - The URL of the resource file that contains the asset data.
     * @param {string} [file.filename] - The filename of the resource file or null if no filename
     * was set (e.g from using {@link AssetRegistry#loadFromUrl}).
     * @param {number} [file.size] - The size of the resource file or null if no size was set
     * (e.g. from using {@link AssetRegistry#loadFromUrl}).
     * @param {string} [file.hash] - The MD5 hash of the resource file data and the Asset data
     * field or null if hash was set (e.g from using {@link AssetRegistry#loadFromUrl}).
     * @param {ArrayBuffer} [file.contents] - Optional file contents. This is faster than wrapping
     * the data in a (base64 encoded) blob. Currently only used by container assets.
     * @param {object} [data] - JSON object with additional data about the asset. (e.g. for texture
     * and model assets) or contains the asset data itself (e.g. in the case of materials).
     * @param {object} [options] - The asset handler options. For container options see
     * {@link ContainerHandler}.
     * @param {boolean} [options.crossOrigin] - For use with texture resources. For
     * browser-supported image formats only, enable cross origin.
     * @example
     * var asset = new pc.Asset("a texture", "texture", {
     *     url: "http://example.com/my/assets/here/texture.png"
     * });
     */
    constructor(name: string, type: string, file?: {
        url?: string;
        filename?: string;
        size?: number;
        hash?: string;
        contents?: ArrayBuffer;
    }, data?: object, options?: {
        crossOrigin?: boolean;
    });
    _id: number;
    /**
     * The name of the asset.
     *
     * @type {string}
     */
    name: string;
    /**
     * The type of the asset. One of ["animation", "audio", "binary", "container", "cubemap",
     * "css", "font", "json", "html", "material", "model", "script", "shader", "sprite",
     * "template", "text", "texture"]
     *
     * @type {("animation"|"audio"|"binary"|"container"|"cubemap"|"css"|"font"|"json"|"html"|"material"|"model"|"script"|"shader"|"sprite"|"template"|"text"|"texture")}
     */
    type: ("animation" | "audio" | "binary" | "container" | "cubemap" | "css" | "font" | "json" | "html" | "material" | "model" | "script" | "shader" | "sprite" | "template" | "text" | "texture");
    /**
     * Asset tags. Enables finding of assets by tags using the {@link AssetRegistry#findByTag} method.
     *
     * @type {Tags}
     */
    tags: Tags;
    _preload: boolean;
    _file: any;
    _data: any;
    /**
     * Optional JSON data that contains the asset handler options.
     *
     * @type {object}
     */
    options: object;
    _resources: any[];
    _i18n: {};
    /**
     * True if the asset has finished attempting to load the resource. It is not guaranteed
     * that the resources are available as there could have been a network error.
     *
     * @type {boolean}
     */
    loaded: boolean;
    /**
     * True if the resource is currently being loaded.
     *
     * @type {boolean}
     */
    loading: boolean;
    /**
     * The asset registry that this Asset belongs to.
     *
     * @type {AssetRegistry}
     */
    registry: AssetRegistry$9;
    /**
     * The file details or null if no file.
     *
     * @type {object}
     */
    set file(arg: any);
    get file(): any;
    /**
     * The asset id.
     *
     * @type {number}
     */
    set id(arg: number);
    get id(): number;
    /**
     * Optional JSON data that contains either the complete resource data. (e.g. in the case of a
     * material) or additional data (e.g. in the case of a model it contains mappings from mesh to
     * material).
     *
     * @type {object}
     */
    set data(arg: any);
    get data(): any;
    /**
     * A reference to the resource when the asset is loaded. e.g. a {@link Texture} or a {@link Model}.
     *
     * @type {object}
     */
    set resource(arg: any);
    get resource(): any;
    /**
     * A reference to the resources of the asset when it's loaded. An asset can hold more runtime
     * resources than one e.g. cubemaps.
     *
     * @type {object[]}
     */
    set resources(arg: any[]);
    get resources(): any[];
    /**
     * If true the asset will be loaded during the preload phase of application set up.
     *
     * @type {boolean}
     */
    set preload(arg: boolean);
    get preload(): boolean;
    set loadFaces(arg: any);
    get loadFaces(): any;
    _loadFaces: any;
    /**
     * @event
     * @name Asset#load
     * @description Fired when the asset has completed loading.
     * @param {Asset} asset - The asset that was loaded.
     */
    /**
     * @event
     * @name Asset#unload
     * @description Fired just before the asset unloads the resource. This allows for the opportunity to prepare for an asset that will be unloaded. E.g. Changing the texture of a model to a default before the one it was using is unloaded.
     * @param {Asset} asset - The asset that is due to be unloaded.
     */
    /**
     * @event
     * @name Asset#remove
     * @description Fired when the asset is removed from the asset registry.
     * @param {Asset} asset - The asset that was removed.
     */
    /**
     * @event
     * @name Asset#error
     * @description Fired if the asset encounters an error while loading.
     * @param {string} err - The error message.
     * @param {Asset} asset - The asset that generated the error.
     */
    /**
     * @event
     * @name Asset#change
     * @description Fired when one of the asset properties `file`, `data`, `resource` or `resources` is changed.
     * @param {Asset} asset - The asset that was loaded.
     * @param {string} property - The name of the property that changed.
     * @param {*} value - The new property value.
     * @param {*} oldValue - The old property value.
     */
    /**
     * @event
     * @name Asset#add:localized
     * @description Fired when we add a new localized asset id to the asset.
     * @param {string} locale - The locale.
     * @param {number} assetId - The asset id we added.
     */
    /**
     * @event
     * @name Asset#remove:localized
     * @description Fired when we remove a localized asset id from the asset.
     * @param {string} locale - The locale.
     * @param {number} assetId - The asset id we removed.
     */
    /**
     * Return the URL required to fetch the file for this asset.
     *
     * @returns {string|null} The URL. Returns null if the asset has no associated file.
     * @example
     * var assets = app.assets.find("My Image", "texture");
     * var img = "&lt;img src='" + assets[0].getFileUrl() + "'&gt;";
     */
    getFileUrl(): string | null;
    /**
     * Construct an asset URL from this asset's location and a relative path. If the relativePath
     * is a blob or Base64 URI, then return that instead.
     *
     * @param {string} relativePath - The relative path to be concatenated to this asset's base url.
     * @returns {string} Resulting URL of the asset.
     * @ignore
     */
    getAbsoluteUrl(relativePath: string): string;
    /**
     * Returns the asset id of the asset that corresponds to the specified locale.
     *
     * @param {string} locale - The desired locale e.g. Ar-AR.
     * @returns {number} An asset id or null if there is no asset specified for the desired locale.
     * @ignore
     */
    getLocalizedAssetId(locale: string): number;
    /**
     * Adds a replacement asset id for the specified locale. When the locale in
     * {@link Application#i18n} changes then references to this asset will be replaced with the
     * specified asset id. (Currently only supported by the {@link ElementComponent}).
     *
     * @param {string} locale - The locale e.g. Ar-AR.
     * @param {number} assetId - The asset id.
     * @ignore
     */
    addLocalizedAssetId(locale: string, assetId: number): void;
    /**
     * Removes a localized asset.
     *
     * @param {string} locale - The locale e.g. Ar-AR.
     * @ignore
     */
    removeLocalizedAssetId(locale: string): void;
    /**
     * Take a callback which is called as soon as the asset is loaded. If the asset is already
     * loaded the callback is called straight away.
     *
     * @param {assetReadyCallback} callback - The function called when the asset is ready. Passed
     * the (asset) arguments.
     * @param {object} [scope] - Scope object to use when calling the callback.
     * @example
     * var asset = app.assets.find("My Asset");
     * asset.ready(function (asset) {
     *   // asset loaded
     * });
     * app.assets.load(asset);
     */
    ready(callback: assetReadyCallback, scope?: object): void;
    reload(): void;
    /**
     * Destroys the associated resource and marks asset as unloaded.
     *
     * @example
     * var asset = app.assets.find("My Asset");
     * asset.unload();
     * // asset.resource is null
     */
    unload(): void;
}

/**
 * Representation of an RGBA color.
 */
declare class Color$4 {
    /**
     * A constant color set to black [0, 0, 0, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly BLACK: Color$4;
    /**
     * A constant color set to blue [0, 0, 1, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly BLUE: Color$4;
    /**
     * A constant color set to cyan [0, 1, 1, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly CYAN: Color$4;
    /**
     * A constant color set to gray [0.5, 0.5, 0.5, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly GRAY: Color$4;
    /**
     * A constant color set to green [0, 1, 0, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly GREEN: Color$4;
    /**
     * A constant color set to magenta [1, 0, 1, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly MAGENTA: Color$4;
    /**
     * A constant color set to red [1, 0, 0, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly RED: Color$4;
    /**
     * A constant color set to white [1, 1, 1, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly WHITE: Color$4;
    /**
     * A constant color set to yellow [1, 1, 0, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly YELLOW: Color$4;
    /**
     * Create a new Color object.
     *
     * @param {number|number[]} [r] - The value of the red component (0-1). Defaults to 0. If r is
     * an array of length 3 or 4, the array will be used to populate all components.
     * @param {number} [g] - The value of the green component (0-1). Defaults to 0.
     * @param {number} [b] - The value of the blue component (0-1). Defaults to 0.
     * @param {number} [a] - The value of the alpha component (0-1). Defaults to 1.
     */
    constructor(r?: number | number[], g?: number, b?: number, a?: number);
    /**
     * The red component of the color.
     *
     * @type {number}
     */
    r: number;
    /**
     * The green component of the color.
     *
     * @type {number}
     */
    g: number;
    /**
     * The blue component of the color.
     *
     * @type {number}
     */
    b: number;
    /**
     * The alpha component of the color.
     *
     * @type {number}
     */
    a: number;
    /**
     * Returns a clone of the specified color.
     *
     * @returns {Color} A duplicate color object.
     */
    clone(): Color$4;
    /**
     * Copies the contents of a source color to a destination color.
     *
     * @param {Color} rhs - A color to copy to the specified color.
     * @returns {Color} Self for chaining.
     * @example
     * var src = new pc.Color(1, 0, 0, 1);
     * var dst = new pc.Color();
     *
     * dst.copy(src);
     *
     * console.log("The two colors are " + (dst.equals(src) ? "equal" : "different"));
     */
    copy(rhs: Color$4): Color$4;
    /**
     * Reports whether two colors are equal.
     *
     * @param {Color} rhs - The color to compare to the specified color.
     * @returns {boolean} True if the colors are equal and false otherwise.
     * @example
     * var a = new pc.Color(1, 0, 0, 1);
     * var b = new pc.Color(1, 1, 0, 1);
     * console.log("The two colors are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Color$4): boolean;
    /**
     * Assign values to the color components, including alpha.
     *
     * @param {number} r - The value for red (0-1).
     * @param {number} g - The value for blue (0-1).
     * @param {number} b - The value for green (0-1).
     * @param {number} [a] - The value for the alpha (0-1), defaults to 1.
     * @returns {Color} Self for chaining.
     */
    set(r: number, g: number, b: number, a?: number): Color$4;
    /**
     * Returns the result of a linear interpolation between two specified colors.
     *
     * @param {Color} lhs - The color to interpolate from.
     * @param {Color} rhs - The color to interpolate to.
     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,
     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this
     * range, the linear interpolant will occur on a ray extrapolated from this line.
     * @returns {Color} Self for chaining.
     * @example
     * var a = new pc.Color(0, 0, 0);
     * var b = new pc.Color(1, 1, 0.5);
     * var r = new pc.Color();
     *
     * r.lerp(a, b, 0);   // r is equal to a
     * r.lerp(a, b, 0.5); // r is 0.5, 0.5, 0.25
     * r.lerp(a, b, 1);   // r is equal to b
     */
    lerp(lhs: Color$4, rhs: Color$4, alpha: number): Color$4;
    /**
     * Set the values of the color from a string representation '#11223344' or '#112233'.
     *
     * @param {string} hex - A string representation in the format '#RRGGBBAA' or '#RRGGBB'. Where
     * RR, GG, BB, AA are red, green, blue and alpha values. This is the same format used in
     * HTML/CSS.
     * @returns {Color} Self for chaining.
     */
    fromString(hex: string): Color$4;
    /**
     * Converts the color to string form. The format is '#RRGGBBAA', where RR, GG, BB, AA are the
     * red, green, blue and alpha values. When the alpha value is not included (the default), this
     * is the same format as used in HTML/CSS.
     *
     * @param {boolean} alpha - If true, the output string will include the alpha value.
     * @returns {string} The color in string form.
     * @example
     * var c = new pc.Color(1, 1, 1);
     * // Outputs #ffffffff
     * console.log(c.toString());
     */
    toString(alpha: boolean): string;
}

/**
 * A 2-dimensional vector.
 */
declare class Vec2$3 {
    /**
     * Calculates the angle between two Vec2's in radians.
     *
     * @param {Vec2} lhs - The first vector operand for the calculation.
     * @param {Vec2} rhs - The second vector operand for the calculation.
     * @returns {number} The calculated angle in radians.
     * @ignore
     */
    static angleRad(lhs: Vec2$3, rhs: Vec2$3): number;
    /**
     * A constant vector set to [0, 0].
     *
     * @type {Vec2}
     * @readonly
     */
    static readonly ZERO: Vec2$3;
    /**
     * A constant vector set to [1, 1].
     *
     * @type {Vec2}
     * @readonly
     */
    static readonly ONE: Vec2$3;
    /**
     * A constant vector set to [0, 1].
     *
     * @type {Vec2}
     * @readonly
     */
    static readonly UP: Vec2$3;
    /**
     * A constant vector set to [0, -1].
     *
     * @type {Vec2}
     * @readonly
     */
    static readonly DOWN: Vec2$3;
    /**
     * A constant vector set to [1, 0].
     *
     * @type {Vec2}
     * @readonly
     */
    static readonly RIGHT: Vec2$3;
    /**
     * A constant vector set to [-1, 0].
     *
     * @type {Vec2}
     * @readonly
     */
    static readonly LEFT: Vec2$3;
    /**
     * Create a new Vec2 instance.
     *
     * @param {number|number[]} [x] - The x value. Defaults to 0. If x is an array of length 2, the
     * array will be used to populate all components.
     * @param {number} [y] - The y value. Defaults to 0.
     * @example
     * var v = new pc.Vec2(1, 2);
     */
    constructor(x?: number | number[], y?: number);
    /**
     * The first component of the vector.
     *
     * @type {number}
     */
    x: number;
    /**
     * The second component of the vector.
     *
     * @type {number}
     */
    y: number;
    /**
     * Adds a 2-dimensional vector to another in place.
     *
     * @param {Vec2} rhs - The vector to add to the specified vector.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(10, 10);
     * var b = new pc.Vec2(20, 20);
     *
     * a.add(b);
     *
     * // Outputs [30, 30]
     * console.log("The result of the addition is: " + a.toString());
     */
    add(rhs: Vec2$3): Vec2$3;
    /**
     * Adds two 2-dimensional vectors together and returns the result.
     *
     * @param {Vec2} lhs - The first vector operand for the addition.
     * @param {Vec2} rhs - The second vector operand for the addition.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(10, 10);
     * var b = new pc.Vec2(20, 20);
     * var r = new pc.Vec2();
     *
     * r.add2(a, b);
     * // Outputs [30, 30]
     *
     * console.log("The result of the addition is: " + r.toString());
     */
    add2(lhs: Vec2$3, rhs: Vec2$3): Vec2$3;
    /**
     * Adds a number to each element of a vector.
     *
     * @param {number} scalar - The number to add.
     * @returns {Vec2} Self for chaining.
     * @example
     * var vec = new pc.Vec2(3, 4);
     *
     * vec.addScalar(2);
     *
     * // Outputs [5, 6]
     * console.log("The result of the addition is: " + vec.toString());
     */
    addScalar(scalar: number): Vec2$3;
    /**
     * Returns an identical copy of the specified 2-dimensional vector.
     *
     * @returns {Vec2} A 2-dimensional vector containing the result of the cloning.
     * @example
     * var v = new pc.Vec2(10, 20);
     * var vclone = v.clone();
     * console.log("The result of the cloning is: " + vclone.toString());
     */
    clone(): Vec2$3;
    /**
     * Copies the contents of a source 2-dimensional vector to a destination 2-dimensional vector.
     *
     * @param {Vec2} rhs - A vector to copy to the specified vector.
     * @returns {Vec2} Self for chaining.
     * @example
     * var src = new pc.Vec2(10, 20);
     * var dst = new pc.Vec2();
     *
     * dst.copy(src);
     *
     * console.log("The two vectors are " + (dst.equals(src) ? "equal" : "different"));
     */
    copy(rhs: Vec2$3): Vec2$3;
    /**
     * Returns the result of a cross product operation performed on the two specified 2-dimensional
     * vectors.
     *
     * @param {Vec2} rhs - The second 2-dimensional vector operand of the cross product.
     * @returns {number} The cross product of the two vectors.
     * @example
     * var right = new pc.Vec2(1, 0);
     * var up = new pc.Vec2(0, 1);
     * var crossProduct = right.cross(up);
     *
     * // Prints 1
     * console.log("The result of the cross product is: " + crossProduct);
     */
    cross(rhs: Vec2$3): number;
    /**
     * Returns the distance between the two specified 2-dimensional vectors.
     *
     * @param {Vec2} rhs - The second 2-dimensional vector to test.
     * @returns {number} The distance between the two vectors.
     * @example
     * var v1 = new pc.Vec2(5, 10);
     * var v2 = new pc.Vec2(10, 20);
     * var d = v1.distance(v2);
     * console.log("The between v1 and v2 is: " + d);
     */
    distance(rhs: Vec2$3): number;
    /**
     * Divides a 2-dimensional vector by another in place.
     *
     * @param {Vec2} rhs - The vector to divide the specified vector by.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(4, 9);
     * var b = new pc.Vec2(2, 3);
     *
     * a.div(b);
     *
     * // Outputs [2, 3]
     * console.log("The result of the division is: " + a.toString());
     */
    div(rhs: Vec2$3): Vec2$3;
    /**
     * Divides one 2-dimensional vector by another and writes the result to the specified vector.
     *
     * @param {Vec2} lhs - The dividend vector (the vector being divided).
     * @param {Vec2} rhs - The divisor vector (the vector dividing the dividend).
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(4, 9);
     * var b = new pc.Vec2(2, 3);
     * var r = new pc.Vec2();
     *
     * r.div2(a, b);
     * // Outputs [2, 3]
     *
     * console.log("The result of the division is: " + r.toString());
     */
    div2(lhs: Vec2$3, rhs: Vec2$3): Vec2$3;
    /**
     * Divides each element of a vector by a number.
     *
     * @param {number} scalar - The number to divide by.
     * @returns {Vec2} Self for chaining.
     * @example
     * var vec = new pc.Vec2(3, 6);
     *
     * vec.divScalar(3);
     *
     * // Outputs [1, 2]
     * console.log("The result of the division is: " + vec.toString());
     */
    divScalar(scalar: number): Vec2$3;
    /**
     * Returns the result of a dot product operation performed on the two specified 2-dimensional
     * vectors.
     *
     * @param {Vec2} rhs - The second 2-dimensional vector operand of the dot product.
     * @returns {number} The result of the dot product operation.
     * @example
     * var v1 = new pc.Vec2(5, 10);
     * var v2 = new pc.Vec2(10, 20);
     * var v1dotv2 = v1.dot(v2);
     * console.log("The result of the dot product is: " + v1dotv2);
     */
    dot(rhs: Vec2$3): number;
    /**
     * Reports whether two vectors are equal.
     *
     * @param {Vec2} rhs - The vector to compare to the specified vector.
     * @returns {boolean} True if the vectors are equal and false otherwise.
     * @example
     * var a = new pc.Vec2(1, 2);
     * var b = new pc.Vec2(4, 5);
     * console.log("The two vectors are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Vec2$3): boolean;
    /**
     * Returns the magnitude of the specified 2-dimensional vector.
     *
     * @returns {number} The magnitude of the specified 2-dimensional vector.
     * @example
     * var vec = new pc.Vec2(3, 4);
     * var len = vec.length();
     * // Outputs 5
     * console.log("The length of the vector is: " + len);
     */
    length(): number;
    /**
     * Returns the magnitude squared of the specified 2-dimensional vector.
     *
     * @returns {number} The magnitude of the specified 2-dimensional vector.
     * @example
     * var vec = new pc.Vec2(3, 4);
     * var len = vec.lengthSq();
     * // Outputs 25
     * console.log("The length squared of the vector is: " + len);
     */
    lengthSq(): number;
    /**
     * Returns the result of a linear interpolation between two specified 2-dimensional vectors.
     *
     * @param {Vec2} lhs - The 2-dimensional to interpolate from.
     * @param {Vec2} rhs - The 2-dimensional to interpolate to.
     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,
     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this
     * range, the linear interpolant will occur on a ray extrapolated from this line.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(0, 0);
     * var b = new pc.Vec2(10, 10);
     * var r = new pc.Vec2();
     *
     * r.lerp(a, b, 0);   // r is equal to a
     * r.lerp(a, b, 0.5); // r is 5, 5
     * r.lerp(a, b, 1);   // r is equal to b
     */
    lerp(lhs: Vec2$3, rhs: Vec2$3, alpha: number): Vec2$3;
    /**
     * Multiplies a 2-dimensional vector to another in place.
     *
     * @param {Vec2} rhs - The 2-dimensional vector used as the second multiplicand of the operation.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(2, 3);
     * var b = new pc.Vec2(4, 5);
     *
     * a.mul(b);
     *
     * // Outputs 8, 15
     * console.log("The result of the multiplication is: " + a.toString());
     */
    mul(rhs: Vec2$3): Vec2$3;
    /**
     * Returns the result of multiplying the specified 2-dimensional vectors together.
     *
     * @param {Vec2} lhs - The 2-dimensional vector used as the first multiplicand of the operation.
     * @param {Vec2} rhs - The 2-dimensional vector used as the second multiplicand of the operation.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(2, 3);
     * var b = new pc.Vec2(4, 5);
     * var r = new pc.Vec2();
     *
     * r.mul2(a, b);
     *
     * // Outputs 8, 15
     * console.log("The result of the multiplication is: " + r.toString());
     */
    mul2(lhs: Vec2$3, rhs: Vec2$3): Vec2$3;
    /**
     * Multiplies each element of a vector by a number.
     *
     * @param {number} scalar - The number to multiply by.
     * @returns {Vec2} Self for chaining.
     * @example
     * var vec = new pc.Vec2(3, 6);
     *
     * vec.mulScalar(3);
     *
     * // Outputs [9, 18]
     * console.log("The result of the multiplication is: " + vec.toString());
     */
    mulScalar(scalar: number): Vec2$3;
    /**
     * Returns this 2-dimensional vector converted to a unit vector in place. If the vector has a
     * length of zero, the vector's elements will be set to zero.
     *
     * @returns {Vec2} Self for chaining.
     * @example
     * var v = new pc.Vec2(25, 0);
     *
     * v.normalize();
     *
     * // Outputs 1, 0
     * console.log("The result of the vector normalization is: " + v.toString());
     */
    normalize(): Vec2$3;
    /**
     * Each element is set to the largest integer less than or equal to its value.
     *
     * @returns {Vec2} Self for chaining.
     */
    floor(): Vec2$3;
    /**
     * Each element is rounded up to the next largest integer.
     *
     * @returns {Vec2} Self for chaining.
     */
    ceil(): Vec2$3;
    /**
     * Each element is rounded up or down to the nearest integer.
     *
     * @returns {Vec2} Self for chaining.
     */
    round(): Vec2$3;
    /**
     * Each element is assigned a value from rhs parameter if it is smaller.
     *
     * @param {Vec2} rhs - The 2-dimensional vector used as the source of elements to compare to.
     * @returns {Vec2} Self for chaining.
     */
    min(rhs: Vec2$3): Vec2$3;
    /**
     * Each element is assigned a value from rhs parameter if it is larger.
     *
     * @param {Vec2} rhs - The 2-dimensional vector used as the source of elements to compare to.
     * @returns {Vec2} Self for chaining.
     */
    max(rhs: Vec2$3): Vec2$3;
    /**
     * Sets the specified 2-dimensional vector to the supplied numerical values.
     *
     * @param {number} x - The value to set on the first component of the vector.
     * @param {number} y - The value to set on the second component of the vector.
     * @returns {Vec2} Self for chaining.
     * @example
     * var v = new pc.Vec2();
     * v.set(5, 10);
     *
     * // Outputs 5, 10
     * console.log("The result of the vector set is: " + v.toString());
     */
    set(x: number, y: number): Vec2$3;
    /**
     * Subtracts a 2-dimensional vector from another in place.
     *
     * @param {Vec2} rhs - The vector to add to the specified vector.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(10, 10);
     * var b = new pc.Vec2(20, 20);
     *
     * a.sub(b);
     *
     * // Outputs [-10, -10]
     * console.log("The result of the subtraction is: " + a.toString());
     */
    sub(rhs: Vec2$3): Vec2$3;
    /**
     * Subtracts two 2-dimensional vectors from one another and returns the result.
     *
     * @param {Vec2} lhs - The first vector operand for the addition.
     * @param {Vec2} rhs - The second vector operand for the addition.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(10, 10);
     * var b = new pc.Vec2(20, 20);
     * var r = new pc.Vec2();
     *
     * r.sub2(a, b);
     *
     * // Outputs [-10, -10]
     * console.log("The result of the subtraction is: " + r.toString());
     */
    sub2(lhs: Vec2$3, rhs: Vec2$3): Vec2$3;
    /**
     * Subtracts a number from each element of a vector.
     *
     * @param {number} scalar - The number to subtract.
     * @returns {Vec2} Self for chaining.
     * @example
     * var vec = new pc.Vec2(3, 4);
     *
     * vec.subScalar(2);
     *
     * // Outputs [1, 2]
     * console.log("The result of the subtraction is: " + vec.toString());
     */
    subScalar(scalar: number): Vec2$3;
    /**
     * Converts the vector to string form.
     *
     * @returns {string} The vector in string form.
     * @example
     * var v = new pc.Vec2(20, 10);
     * // Outputs [20, 10]
     * console.log(v.toString());
     */
    toString(): string;
}

/**
 * Callback used by {@link GraphNodefind } and {@link GraphNodefindOne } to search through a graph
 * node and all of its descendants.
 */
type findNodeCallback = (node: GraphNode$3) => boolean;
/**
 * Callback used by {@link GraphNodeforEach } to iterate through a graph node and all of its
 * descendants.
 */
type forEachNodeCallback = (node: GraphNode$3) => any;
/**
 * Callback used by {@link GraphNode#find} and {@link GraphNode#findOne} to search through a graph
 * node and all of its descendants.
 *
 * @callback findNodeCallback
 * @param {GraphNode} node - The current graph node.
 * @returns {boolean} Returning `true` will result in that node being returned from
 * {@link GraphNode#find} or {@link GraphNode#findOne}.
 */
/**
 * Callback used by {@link GraphNode#forEach} to iterate through a graph node and all of its
 * descendants.
 *
 * @callback forEachNodeCallback
 * @param {GraphNode} node - The current graph node.
 */
/**
 * A hierarchical scene node.
 *
 * @augments EventHandler
 */
declare class GraphNode$3 extends EventHandler$1 {
    /**
     * Create a new GraphNode instance.
     *
     * @param {string} [name] - The non-unique name of a graph node. Defaults to 'Untitled'.
     */
    constructor(name?: string);
    /**
     * The non-unique name of a graph node. Defaults to 'Untitled'.
     *
     * @type {string}
     */
    name: string;
    /**
     * Interface for tagging graph nodes. Tag based searches can be performed using the
     * {@link GraphNode#findByTag} function.
     *
     * @type {Tags}
     */
    tags: Tags;
    /** @private */
    private _labels;
    /**
     * @type {Vec3}
     * @private
     */
    private localPosition;
    /**
     * @type {Quat}
     * @private
     */
    private localRotation;
    /**
     * @type {Vec3}
     * @private
     */
    private localScale;
    /**
     * @type {Vec3}
     * @private
     */
    private localEulerAngles;
    /**
     * @type {Vec3}
     * @private
     */
    private position;
    /**
     * @type {Quat}
     * @private
     */
    private rotation;
    /**
     * @type {Vec3}
     * @private
     */
    private eulerAngles;
    /**
     * @type {Vec3|null}
     * @private
     */
    private _scale;
    /**
     * @type {Mat4}
     * @private
     */
    private localTransform;
    /**
     * @type {boolean}
     * @private
     */
    private _dirtyLocal;
    /**
     * @type {number}
     * @private
     */
    private _aabbVer;
    /**
     * Marks the node to ignore hierarchy sync entirely (including children nodes). The engine
     * code automatically freezes and unfreezes objects whenever required. Segregating dynamic
     * and stationary nodes into subhierarchies allows to reduce sync time significantly.
     *
     * @type {boolean}
     * @private
     */
    private _frozen;
    /**
     * @type {Mat4}
     * @private
     */
    private worldTransform;
    /**
     * @type {boolean}
     * @private
     */
    private _dirtyWorld;
    /**
     * @type {Mat3}
     * @private
     */
    private normalMatrix;
    /**
     * @type {boolean}
     * @private
     */
    private _dirtyNormal;
    /**
     * @type {Vec3|null}
     * @private
     */
    private _right;
    /**
     * @type {Vec3|null}
     * @private
     */
    private _up;
    /**
     * @type {Vec3|null}
     * @private
     */
    private _forward;
    /**
     * @type {GraphNode|null}
     * @private
     */
    private _parent;
    /**
     * @type {GraphNode[]}
     * @private
     */
    private _children;
    /**
     * @type {number}
     * @private
     */
    private _graphDepth;
    /**
     * @type {boolean}
     * @private
     */
    private _enabled;
    /**
     * @type {boolean}
     * @private
     */
    private _enabledInHierarchy;
    /**
     * @type {boolean}
     * @ignore
     */
    scaleCompensation: boolean;
    /**
     * The normalized local space X-axis vector of the graph node in world space.
     *
     * @type {Vec3}
     */
    get right(): Vec3$1;
    /**
     * The normalized local space Y-axis vector of the graph node in world space.
     *
     * @type {Vec3}
     */
    get up(): Vec3$1;
    /**
     * The normalized local space negative Z-axis vector of the graph node in world space.
     *
     * @type {Vec3}
     */
    get forward(): Vec3$1;
    /**
     * Enable or disable a GraphNode. If one of the GraphNode's parents is disabled there will be
     * no other side effects. If all the parents are enabled then the new value will activate or
     * deactivate all the enabled children of the GraphNode.
     *
     * @type {boolean}
     */
    set enabled(arg: boolean);
    get enabled(): boolean;
    /**
     * A read-only property to get a parent graph node.
     *
     * @type {GraphNode|null}
     */
    get parent(): GraphNode$3;
    /**
     * A read-only property to get the path of the graph node relative to the root of the hierarchy.
     *
     * @type {string}
     */
    get path(): string;
    /**
     * A read-only property to get highest graph node from current node.
     *
     * @type {GraphNode}
     */
    get root(): GraphNode$3;
    /**
     * A read-only property to get the children of this graph node.
     *
     * @type {GraphNode[]}
     */
    get children(): GraphNode$3[];
    /**
     * A read-only property to get the depth of this child within the graph. Note that for
     * performance reasons this is only recalculated when a node is added to a new parent, i.e. It
     * is not recalculated when a node is simply removed from the graph.
     *
     * @type {number}
     */
    get graphDepth(): number;
    /**
     * @param {GraphNode} node - Graph node to update.
     * @param {boolean} enabled - True if enabled in the hierarchy, false if disabled.
     * @private
     */
    private _notifyHierarchyStateChanged;
    /**
     * Called when the enabled flag of the entity or one of its parents changes.
     *
     * @param {boolean} enabled - True if enabled in the hierarchy, false if disabled.
     * @private
     */
    private _onHierarchyStateChanged;
    /**
     * @param {GraphNode} clone - The cloned graph node to copy into.
     * @private
     */
    private _cloneInternal;
    /**
     * Clone a graph node.
     *
     * @returns {GraphNode} A clone of the specified graph node.
     */
    clone(): GraphNode$3;
    /**
     * Copy a graph node.
     *
     * @param {GraphNode} source - The graph node to copy.
     * @returns {GraphNode} The destination graph node.
     * @ignore
     */
    copy(source: GraphNode$3): GraphNode$3;
    /**
     * Search the graph node and all of its descendants for the nodes that satisfy some search
     * criteria.
     *
     * @param {findNodeCallback|string} attr - This can either be a function or a string. If it's a
     * function, it is executed for each descendant node to test if node satisfies the search
     * logic. Returning true from the function will include the node into the results. If it's a
     * string then it represents the name of a field or a method of the node. If this is the name
     * of a field then the value passed as the second argument will be checked for equality. If
     * this is the name of a function then the return value of the function will be checked for
     * equality against the valued passed as the second argument to this function.
     * @param {object} [value] - If the first argument (attr) is a property name then this value
     * will be checked against the value of the property.
     * @returns {GraphNode[]} The array of graph nodes that match the search criteria.
     * @example
     * // Finds all nodes that have a model component and have `door` in their lower-cased name
     * var doors = house.find(function (node) {
     *     return node.model && node.name.toLowerCase().indexOf('door') !== -1;
     * });
     * @example
     * // Finds all nodes that have the name property set to 'Test'
     * var entities = parent.find('name', 'Test');
     */
    find(attr: findNodeCallback | string, value?: object): GraphNode$3[];
    /**
     * Search the graph node and all of its descendants for the first node that satisfies some
     * search criteria.
     *
     * @param {findNodeCallback|string} attr - This can either be a function or a string. If it's a
     * function, it is executed for each descendant node to test if node satisfies the search
     * logic. Returning true from the function will result in that node being returned from
     * findOne. If it's a string then it represents the name of a field or a method of the node. If
     * this is the name of a field then the value passed as the second argument will be checked for
     * equality. If this is the name of a function then the return value of the function will be
     * checked for equality against the valued passed as the second argument to this function.
     * @param {object} [value] - If the first argument (attr) is a property name then this value
     * will be checked against the value of the property.
     * @returns {GraphNode|null} A graph node that match the search criteria. Returns null if no
     * node is found.
     * @example
     * // Find the first node that is called `head` and has a model component
     * var head = player.findOne(function (node) {
     *     return node.model && node.name === 'head';
     * });
     * @example
     * // Finds the first node that has the name property set to 'Test'
     * var node = parent.findOne('name', 'Test');
     */
    findOne(attr: findNodeCallback | string, value?: object): GraphNode$3 | null;
    /**
     * Return all graph nodes that satisfy the search query. Query can be simply a string, or comma
     * separated strings, to have inclusive results of assets that match at least one query. A
     * query that consists of an array of tags can be used to match graph nodes that have each tag
     * of array.
     *
     * @param {...*} query - Name of a tag or array of tags.
     * @returns {GraphNode[]} A list of all graph nodes that match the query.
     * @example
     * // Return all graph nodes that tagged by `animal`
     * var animals = node.findByTag("animal");
     * @example
     * // Return all graph nodes that tagged by `bird` OR `mammal`
     * var birdsAndMammals = node.findByTag("bird", "mammal");
     * @example
     * // Return all assets that tagged by `carnivore` AND `mammal`
     * var meatEatingMammals = node.findByTag(["carnivore", "mammal"]);
     * @example
     * // Return all assets that tagged by (`carnivore` AND `mammal`) OR (`carnivore` AND `reptile`)
     * var meatEatingMammalsAndReptiles = node.findByTag(["carnivore", "mammal"], ["carnivore", "reptile"]);
     */
    findByTag(...args: any[]): GraphNode$3[];
    /**
     * Get the first node found in the graph with the name. The search is depth first.
     *
     * @param {string} name - The name of the graph.
     * @returns {GraphNode|null} The first node to be found matching the supplied name. Returns
     * null if no node is found.
     */
    findByName(name: string): GraphNode$3 | null;
    /**
     * Get the first node found in the graph by its full path in the graph. The full path has this
     * form 'parent/child/sub-child'. The search is depth first.
     *
     * @param {string|string[]} path - The full path of the {@link GraphNode} as either a string or
     * array of {@link GraphNode} names.
     * @returns {GraphNode|null} The first node to be found matching the supplied path. Returns
     * null if no node is found.
     * @example
     * // String form
     * var grandchild = this.entity.findByPath('child/grandchild');
     * @example
     * // Array form
     * var grandchild = this.entity.findByPath(['child', 'grandchild']);
     */
    findByPath(path: string | string[]): GraphNode$3 | null;
    /**
     * Executes a provided function once on this graph node and all of its descendants.
     *
     * @param {forEachNodeCallback} callback - The function to execute on the graph node and each
     * descendant.
     * @param {object} [thisArg] - Optional value to use as this when executing callback function.
     * @example
     * // Log the path and name of each node in descendant tree starting with "parent"
     * parent.forEach(function (node) {
     *     console.log(node.path + "/" + node.name);
     * });
     */
    forEach(callback: forEachNodeCallback, thisArg?: object): void;
    /**
     * Check if node is descendant of another node.
     *
     * @param {GraphNode} node - Potential ancestor of node.
     * @returns {boolean} If node is descendant of another node.
     * @example
     * if (roof.isDescendantOf(house)) {
     *     // roof is descendant of house entity
     * }
     */
    isDescendantOf(node: GraphNode$3): boolean;
    /**
     * Check if node is ancestor for another node.
     *
     * @param {GraphNode} node - Potential descendant of node.
     * @returns {boolean} If node is ancestor for another node.
     * @example
     * if (body.isAncestorOf(foot)) {
     *     // foot is within body's hierarchy
     * }
     */
    isAncestorOf(node: GraphNode$3): boolean;
    /**
     * Get the world space rotation for the specified GraphNode in Euler angle form. The rotation
     * is returned as euler angles in a {@link Vec3}. The value returned by this function should be
     * considered read-only. In order to set the world-space rotation of the graph node, use
     * {@link GraphNode#setEulerAngles}.
     *
     * @returns {Vec3} The world space rotation of the graph node in Euler angle form.
     * @example
     * var angles = this.entity.getEulerAngles();
     * angles.y = 180; // rotate the entity around Y by 180 degrees
     * this.entity.setEulerAngles(angles);
     */
    getEulerAngles(): Vec3$1;
    /**
     * Get the rotation in local space for the specified GraphNode. The rotation is returned as
     * euler angles in a {@link Vec3}. The returned vector should be considered read-only. To
     * update the local rotation, use {@link GraphNode#setLocalEulerAngles}.
     *
     * @returns {Vec3} The local space rotation of the graph node as euler angles in XYZ order.
     * @example
     * var angles = this.entity.getLocalEulerAngles();
     * angles.y = 180;
     * this.entity.setLocalEulerAngles(angles);
     */
    getLocalEulerAngles(): Vec3$1;
    /**
     * Get the position in local space for the specified GraphNode. The position is returned as a
     * {@link Vec3}. The returned vector should be considered read-only. To update the local
     * position, use {@link GraphNode#setLocalPosition}.
     *
     * @returns {Vec3} The local space position of the graph node.
     * @example
     * var position = this.entity.getLocalPosition();
     * position.x += 1; // move the entity 1 unit along x.
     * this.entity.setLocalPosition(position);
     */
    getLocalPosition(): Vec3$1;
    /**
     * Get the rotation in local space for the specified GraphNode. The rotation is returned as a
     * {@link Quat}. The returned quaternion should be considered read-only. To update the local
     * rotation, use {@link GraphNode#setLocalRotation}.
     *
     * @returns {Quat} The local space rotation of the graph node as a quaternion.
     * @example
     * var rotation = this.entity.getLocalRotation();
     */
    getLocalRotation(): Quat$1;
    /**
     * Get the scale in local space for the specified GraphNode. The scale is returned as a
     * {@link Vec3}. The returned vector should be considered read-only. To update the local scale,
     * use {@link GraphNode#setLocalScale}.
     *
     * @returns {Vec3} The local space scale of the graph node.
     * @example
     * var scale = this.entity.getLocalScale();
     * scale.x = 100;
     * this.entity.setLocalScale(scale);
     */
    getLocalScale(): Vec3$1;
    /**
     * Get the local transform matrix for this graph node. This matrix is the transform relative to
     * the node's parent's world transformation matrix.
     *
     * @returns {Mat4} The node's local transformation matrix.
     * @example
     * var transform = this.entity.getLocalTransform();
     */
    getLocalTransform(): Mat4$5;
    /**
     * Get the world space position for the specified GraphNode. The position is returned as a
     * {@link Vec3}. The value returned by this function should be considered read-only. In order
     * to set the world-space position of the graph node, use {@link GraphNode#setPosition}.
     *
     * @returns {Vec3} The world space position of the graph node.
     * @example
     * var position = this.entity.getPosition();
     * position.x = 10;
     * this.entity.setPosition(position);
     */
    getPosition(): Vec3$1;
    /**
     * Get the world space rotation for the specified GraphNode. The rotation is returned as a
     * {@link Quat}. The value returned by this function should be considered read-only. In order
     * to set the world-space rotation of the graph node, use {@link GraphNode#setRotation}.
     *
     * @returns {Quat} The world space rotation of the graph node as a quaternion.
     * @example
     * var rotation = this.entity.getRotation();
     */
    getRotation(): Quat$1;
    /**
     * Get the world space scale for the specified GraphNode. The returned value will only be
     * correct for graph nodes that have a non-skewed world transform (a skew can be introduced by
     * the compounding of rotations and scales higher in the graph node hierarchy). The scale is
     * returned as a {@link Vec3}. The value returned by this function should be considered
     * read-only. Note that it is not possible to set the world space scale of a graph node
     * directly.
     *
     * @returns {Vec3} The world space scale of the graph node.
     * @example
     * var scale = this.entity.getScale();
     * @ignore
     */
    getScale(): Vec3$1;
    /**
     * Get the world transformation matrix for this graph node.
     *
     * @returns {Mat4} The node's world transformation matrix.
     * @example
     * var transform = this.entity.getWorldTransform();
     */
    getWorldTransform(): Mat4$5;
    /**
     * Remove graph node from current parent and add as child to new parent.
     *
     * @param {GraphNode} parent - New parent to attach graph node to.
     * @param {number} [index] - The child index where the child node should be placed.
     */
    reparent(parent: GraphNode$3, index?: number): void;
    /**
     * Sets the local-space rotation of the specified graph node using euler angles. Eulers are
     * interpreted in XYZ order. Eulers must be specified in degrees. This function has two valid
     * signatures: you can either pass a 3D vector or 3 numbers to specify the local-space euler
     * rotation.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding eulers or rotation around local-space
     * x-axis in degrees.
     * @param {number} [y] - Rotation around local-space y-axis in degrees.
     * @param {number} [z] - Rotation around local-space z-axis in degrees.
     * @example
     * // Set rotation of 90 degrees around y-axis via 3 numbers
     * this.entity.setLocalEulerAngles(0, 90, 0);
     * @example
     * // Set rotation of 90 degrees around y-axis via a vector
     * var angles = new pc.Vec3(0, 90, 0);
     * this.entity.setLocalEulerAngles(angles);
     */
    setLocalEulerAngles(x: Vec3$1 | number, y?: number, z?: number): void;
    /**
     * Sets the local-space position of the specified graph node. This function has two valid
     * signatures: you can either pass a 3D vector or 3 numbers to specify the local-space
     * position.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding local-space position or
     * x-coordinate of local-space position.
     * @param {number} [y] - Y-coordinate of local-space position.
     * @param {number} [z] - Z-coordinate of local-space position.
     * @example
     * // Set via 3 numbers
     * this.entity.setLocalPosition(0, 10, 0);
     * @example
     * // Set via vector
     * var pos = new pc.Vec3(0, 10, 0);
     * this.entity.setLocalPosition(pos);
     */
    setLocalPosition(x: Vec3$1 | number, y?: number, z?: number): void;
    /**
     * Sets the local-space rotation of the specified graph node. This function has two valid
     * signatures: you can either pass a quaternion or 3 numbers to specify the local-space
     * rotation.
     *
     * @param {Quat|number} x - Quaternion holding local-space rotation or x-component of
     * local-space quaternion rotation.
     * @param {number} [y] - Y-component of local-space quaternion rotation.
     * @param {number} [z] - Z-component of local-space quaternion rotation.
     * @param {number} [w] - W-component of local-space quaternion rotation.
     * @example
     * // Set via 4 numbers
     * this.entity.setLocalRotation(0, 0, 0, 1);
     * @example
     * // Set via quaternion
     * var q = pc.Quat();
     * this.entity.setLocalRotation(q);
     */
    setLocalRotation(x: Quat$1 | number, y?: number, z?: number, w?: number): void;
    /**
     * Sets the local-space scale factor of the specified graph node. This function has two valid
     * signatures: you can either pass a 3D vector or 3 numbers to specify the local-space scale.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding local-space scale or x-coordinate
     * of local-space scale.
     * @param {number} [y] - Y-coordinate of local-space scale.
     * @param {number} [z] - Z-coordinate of local-space scale.
     * @example
     * // Set via 3 numbers
     * this.entity.setLocalScale(10, 10, 10);
     * @example
     * // Set via vector
     * var scale = new pc.Vec3(10, 10, 10);
     * this.entity.setLocalScale(scale);
     */
    setLocalScale(x: Vec3$1 | number, y?: number, z?: number): void;
    /** @private */
    private _dirtifyLocal;
    /** @private */
    private _unfreezeParentToRoot;
    /** @private */
    private _dirtifyWorld;
    /** @private */
    private _dirtifyWorldInternal;
    /**
     * Sets the world-space position of the specified graph node. This function has two valid
     * signatures: you can either pass a 3D vector or 3 numbers to specify the world-space
     * position.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding world-space position or
     * x-coordinate of world-space position.
     * @param {number} [y] - Y-coordinate of world-space position.
     * @param {number} [z] - Z-coordinate of world-space position.
     * @example
     * // Set via 3 numbers
     * this.entity.setPosition(0, 10, 0);
     * @example
     * // Set via vector
     * var position = new pc.Vec3(0, 10, 0);
     * this.entity.setPosition(position);
     */
    setPosition(x: Vec3$1 | number, y?: number, z?: number): void;
    /**
     * Sets the world-space rotation of the specified graph node. This function has two valid
     * signatures: you can either pass a quaternion or 3 numbers to specify the world-space
     * rotation.
     *
     * @param {Quat|number} x - Quaternion holding world-space rotation or x-component of
     * world-space quaternion rotation.
     * @param {number} [y] - Y-component of world-space quaternion rotation.
     * @param {number} [z] - Z-component of world-space quaternion rotation.
     * @param {number} [w] - W-component of world-space quaternion rotation.
     * @example
     * // Set via 4 numbers
     * this.entity.setRotation(0, 0, 0, 1);
     * @example
     * // Set via quaternion
     * var q = pc.Quat();
     * this.entity.setRotation(q);
     */
    setRotation(x: Quat$1 | number, y?: number, z?: number, w?: number): void;
    /**
     * Sets the world-space rotation of the specified graph node using euler angles. Eulers are
     * interpreted in XYZ order. Eulers must be specified in degrees. This function has two valid
     * signatures: you can either pass a 3D vector or 3 numbers to specify the world-space euler
     * rotation.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding eulers or rotation around world-space
     * x-axis in degrees.
     * @param {number} [y] - Rotation around world-space y-axis in degrees.
     * @param {number} [z] - Rotation around world-space z-axis in degrees.
     * @example
     * // Set rotation of 90 degrees around world-space y-axis via 3 numbers
     * this.entity.setEulerAngles(0, 90, 0);
     * @example
     * // Set rotation of 90 degrees around world-space y-axis via a vector
     * var angles = new pc.Vec3(0, 90, 0);
     * this.entity.setEulerAngles(angles);
     */
    setEulerAngles(x: Vec3$1 | number, y?: number, z?: number): void;
    /**
     * Add a new child to the child list and update the parent value of the child node.
     *
     * @param {GraphNode} node - The new child to add.
     * @example
     * var e = new pc.Entity(app);
     * this.entity.addChild(e);
     */
    addChild(node: GraphNode$3): void;
    /**
     * Add a child to this node, maintaining the child's transform in world space.
     *
     * @param {GraphNode} node - The child to add.
     * @example
     * var e = new pc.Entity(app);
     * this.entity.addChildAndSaveTransform(e);
     * @ignore
     */
    addChildAndSaveTransform(node: GraphNode$3): void;
    /**
     * Insert a new child to the child list at the specified index and update the parent value of
     * the child node.
     *
     * @param {GraphNode} node - The new child to insert.
     * @param {number} index - The index in the child list of the parent where the new node will be
     * inserted.
     * @example
     * var e = new pc.Entity(app);
     * this.entity.insertChild(e, 1);
     */
    insertChild(node: GraphNode$3, index: number): void;
    /**
     * @param {GraphNode} node - The node being inserted.
     * @private
     */
    private _debugInsertChild;
    /**
     * Fires an event on all children of the node. The event `name` is fired on the first (root)
     * node only. The event `nameHierarchy` is fired for all children.
     *
     * @param {string} name - The name of the event to fire on the root.
     * @param {string} nameHierarchy - The name of the event to fire for all descendants.
     * @param {GraphNode} parent - The parent of the node being added/removed from the hierarchy.
     * @private
     */
    private _fireOnHierarchy;
    /**
     * Called when a node is inserted into a node's child list.
     *
     * @param {GraphNode} node - The node that was inserted.
     * @private
     */
    private _onInsertChild;
    /**
     * Recurse the hierarchy and update the graph depth at each node.
     *
     * @private
     */
    private _updateGraphDepth;
    /**
     * Remove the node from the child list and update the parent value of the child.
     *
     * @param {GraphNode} child - The node to remove.
     * @example
     * var child = this.entity.children[0];
     * this.entity.removeChild(child);
     */
    removeChild(child: GraphNode$3): void;
    _sync(): void;
    /**
     * Updates the world transformation matrices at this node and all of its descendants.
     *
     * @ignore
     */
    syncHierarchy(): void;
    /**
     * Reorients the graph node so that the negative z-axis points towards the target. This
     * function has two valid signatures. Either pass 3D vectors for the look at coordinate and up
     * vector, or pass numbers to represent the vectors.
     *
     * @param {Vec3|number} x - If passing a 3D vector, this is the world-space coordinate to look at.
     * Otherwise, it is the x-component of the world-space coordinate to look at.
     * @param {Vec3|number} [y] - If passing a 3D vector, this is the world-space up vector for look at
     * transform. Otherwise, it is the y-component of the world-space coordinate to look at.
     * @param {number} [z] - Z-component of the world-space coordinate to look at.
     * @param {number} [ux=0] - X-component of the up vector for the look at transform.
     * @param {number} [uy=1] - Y-component of the up vector for the look at transform.
     * @param {number} [uz=0] - Z-component of the up vector for the look at transform.
     * @example
     * // Look at another entity, using the (default) positive y-axis for up
     * var position = otherEntity.getPosition();
     * this.entity.lookAt(position);
     * @example
     * // Look at another entity, using the negative world y-axis for up
     * var position = otherEntity.getPosition();
     * this.entity.lookAt(position, pc.Vec3.DOWN);
     * @example
     * // Look at the world space origin, using the (default) positive y-axis for up
     * this.entity.lookAt(0, 0, 0);
     * @example
     * // Look at world-space coordinate [10, 10, 10], using the negative world y-axis for up
     * this.entity.lookAt(10, 10, 10, 0, -1, 0);
     */
    lookAt(x: Vec3$1 | number, y?: Vec3$1 | number, z?: number, ux?: number, uy?: number, uz?: number): void;
    /**
     * Translates the graph node in world-space by the specified translation vector. This function
     * has two valid signatures: you can either pass a 3D vector or 3 numbers to specify the
     * world-space translation.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding world-space translation or
     * x-coordinate of world-space translation.
     * @param {number} [y] - Y-coordinate of world-space translation.
     * @param {number} [z] - Z-coordinate of world-space translation.
     * @example
     * // Translate via 3 numbers
     * this.entity.translate(10, 0, 0);
     * @example
     * // Translate via vector
     * var t = new pc.Vec3(10, 0, 0);
     * this.entity.translate(t);
     */
    translate(x: Vec3$1 | number, y?: number, z?: number): void;
    /**
     * Translates the graph node in local-space by the specified translation vector. This function
     * has two valid signatures: you can either pass a 3D vector or 3 numbers to specify the
     * local-space translation.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding local-space translation or
     * x-coordinate of local-space translation.
     * @param {number} [y] - Y-coordinate of local-space translation.
     * @param {number} [z] - Z-coordinate of local-space translation.
     * @example
     * // Translate via 3 numbers
     * this.entity.translateLocal(10, 0, 0);
     * @example
     * // Translate via vector
     * var t = new pc.Vec3(10, 0, 0);
     * this.entity.translateLocal(t);
     */
    translateLocal(x: Vec3$1 | number, y?: number, z?: number): void;
    /**
     * Rotates the graph node in world-space by the specified Euler angles. Eulers are specified in
     * degrees in XYZ order. This function has two valid signatures: you can either pass a 3D
     * vector or 3 numbers to specify the world-space rotation.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding world-space rotation or
     * rotation around world-space x-axis in degrees.
     * @param {number} [y] - Rotation around world-space y-axis in degrees.
     * @param {number} [z] - Rotation around world-space z-axis in degrees.
     * @example
     * // Rotate via 3 numbers
     * this.entity.rotate(0, 90, 0);
     * @example
     * // Rotate via vector
     * var r = new pc.Vec3(0, 90, 0);
     * this.entity.rotate(r);
     */
    rotate(x: Vec3$1 | number, y?: number, z?: number): void;
    /**
     * Rotates the graph node in local-space by the specified Euler angles. Eulers are specified in
     * degrees in XYZ order. This function has two valid signatures: you can either pass a 3D
     * vector or 3 numbers to specify the local-space rotation.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding local-space rotation or
     * rotation around local-space x-axis in degrees.
     * @param {number} [y] - Rotation around local-space y-axis in degrees.
     * @param {number} [z] - Rotation around local-space z-axis in degrees.
     * @example
     * // Rotate via 3 numbers
     * this.entity.rotateLocal(0, 90, 0);
     * @example
     * // Rotate via vector
     * var r = new pc.Vec3(0, 90, 0);
     * this.entity.rotateLocal(r);
     */
    rotateLocal(x: Vec3$1 | number, y?: number, z?: number): void;
}

type GraphicsDevice$g = GraphicsDevice$l;
type Mat4$3 = Mat4$5;
/** @typedef {import('../graphics/graphics-device.js').GraphicsDevice} GraphicsDevice */
/** @typedef {import('../math/mat4.js').Mat4} Mat4 */
/**
 * A skin contains data about the bones in a hierarchy that drive a skinned mesh animation.
 * Specifically, the skin stores the bone name and inverse bind matrix and for each bone. Inverse
 * bind matrices are instrumental in the mathematics of vertex skinning.
 */
declare class Skin$2 {
    /**
     * Create a new Skin instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this skin.
     * @param {Mat4[]} ibp - The array of inverse bind matrices.
     * @param {string[]} boneNames - The array of bone names for the bones referenced by this skin.
     */
    constructor(graphicsDevice: GraphicsDevice$g, ibp: Mat4$3[], boneNames: string[]);
    device: GraphicsDevice$l;
    inverseBindPose: Mat4$5[];
    boneNames: string[];
}

type GraphNode$2 = GraphNode$3;
type Skin$1 = Skin$2;
/**
 * A skin instance is responsible for generating the matrix palette that is used to skin vertices
 * from object space to world space.
 */
declare class SkinInstance {
    /**
     * Create a new SkinInstance instance.
     *
     * @param {Skin} skin - The skin that will provide the inverse bind pose matrices to generate
     * the final matrix palette.
     */
    constructor(skin: Skin$1);
    /**
     * An array of nodes representing each bone in this skin instance.
     *
     * @type {GraphNode[]}
     */
    bones: GraphNode$2[];
    _dirty: boolean;
    _rootBone: any;
    _skinUpdateIndex: number;
    _updateBeforeCull: boolean;
    set rootBone(arg: any);
    get rootBone(): any;
    init(device: any, numBones: any): void;
    boneTexture: Texture$8;
    matrixPalette: Uint8Array | Uint16Array | Float32Array;
    destroy(): void;
    resolve(rootBone: any, entity: any): void;
    initSkin(skin: any): void;
    skin: any;
    matrices: any[];
    uploadBones(device: any): void;
    _updateMatrices(rootNode: any, skinUpdateIndex: any): void;
    updateMatrices(rootNode: any, skinUpdateIndex: any): void;
    updateMatrixPalette(rootNode: any, skinUpdateIndex: any): void;
}

/**
 * A Morph Target (also known as Blend Shape) contains deformation data to apply to existing mesh.
 * Multiple morph targets can be blended together on a mesh. This is useful for effects that are
 * hard to achieve with conventional animation and skinning.
 */
declare class MorphTarget$1 {
    /**
     * Create a new MorphTarget instance.
     *
     * @param {object} options - Object for passing optional arguments.
     * @param {ArrayBuffer} options.deltaPositions - An array of 3-dimensional vertex position
     * offsets.
     * @param {number} options.deltaPositionsType - A format to store position offsets inside
     * {@link VertexBuffer}. Defaults to {@link TYPE_FLOAT32} if not provided.
     * @param {ArrayBuffer} [options.deltaNormals] - An array of 3-dimensional vertex normal
     * offsets.
     * @param {number} options.deltaNormalsType - A format to store normal offsets inside
     * {@link VertexBuffer}. Defaults to {@link TYPE_FLOAT32} if not provided.
     * @param {string} [options.name] - Name.
     * @param {BoundingBox} [options.aabb] - Bounding box. Will be automatically generated, if
     * undefined.
     * @param {number} [options.defaultWeight] - Default blend weight to use for this morph target.
     */
    constructor(options: {
        deltaPositions: ArrayBuffer;
        deltaPositionsType: number;
        deltaNormals?: ArrayBuffer;
        deltaNormalsType: number;
        name?: string;
        aabb?: BoundingBox$1;
        defaultWeight?: number;
    }, ...args: any[]);
    options: {
        deltaPositions: ArrayBuffer;
        deltaPositionsType: number;
        deltaNormals?: ArrayBuffer;
        deltaNormalsType: number;
        name?: string;
        aabb?: BoundingBox$1;
        defaultWeight?: number;
    };
    _name: string;
    _defaultWeight: number;
    aabb: BoundingBox$1;
    deltaPositions: ArrayBuffer;
    /**
     * The name of the morph target.
     *
     * @type {string}
     */
    get name(): string;
    /**
     * The default weight of the morph target.
     *
     * @type {number}
     */
    get defaultWeight(): number;
    get morphPositions(): boolean;
    get morphNormals(): boolean;
    _postInit(): void;
    _initVertexBuffers(graphicsDevice: any): void;
    _vertexBufferPositions: VertexBuffer$3;
    _vertexBufferNormals: VertexBuffer$3;
    _createVertexBuffer(device: any, data: any, dataType?: number): VertexBuffer$3;
    _setTexture(name: any, texture: any): void;
    destroy(): void;
    texturePositions: any;
    textureNormals: any;
}

/**
 * Base class implementing reference counting for objects.
 *
 * @ignore
 */
declare class RefCountedObject {
    /**
     * @type {number}
     * @private
     */
    private _refCount;
    /**
     * Inrements the counter.
     */
    incRefCount(): void;
    /**
     * Decrements the counter. When the value reaches zero, destroy is called.
     */
    decRefCount(): void;
    /**
     * The current reference count.
     *
     * @type {number}
     */
    get refCount(): number;
}

type GraphicsDevice$f = GraphicsDevice$l;
type MorphTarget = MorphTarget$1;
/**
 * Contains a list of {@link MorphTarget}, a combined delta AABB and some associated data.
 */
declare class Morph extends RefCountedObject {
    static FORMAT_FLOAT: number;
    static FORMAT_HALF_FLOAT: number;
    /**
     * Create a new Morph instance.
     *
     * @param {MorphTarget[]} targets - A list of morph targets.
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this morph
     * target. If it is not provided, a device is obtained from the {@link Application}.
     */
    constructor(targets: MorphTarget[], graphicsDevice: GraphicsDevice$f);
    device: any;
    _targets: MorphTarget$1[];
    _renderTextureFormat: number;
    _textureFormat: number;
    _useTextureMorph: boolean;
    get morphPositions(): boolean;
    get morphNormals(): boolean;
    get maxActiveTargets(): number;
    get useTextureMorph(): boolean;
    _init(): void;
    _initTextureBased(): boolean;
    morphTextureWidth: number;
    morphTextureHeight: number;
    vertexBufferIds: VertexBuffer$3;
    /**
     * Frees video memory allocated by this object.
     */
    destroy(): void;
    /**
     * The array of morph targets.
     *
     * @type {MorphTarget[]}
     */
    get targets(): MorphTarget$1[];
    _updateMorphFlags(): void;
    _morphPositions: boolean;
    _morphNormals: boolean;
    _calculateAabb(): void;
    aabb: BoundingBox$1;
    _createTexture(name: any, format: any, pixelData: any): Texture$8;
}

type MeshInstance$4 = MeshInstance$3;
/**
 * An instance of {@link Morph}. Contains weights to assign to every {@link MorphTarget}, manages
 * selection of active morph targets.
 */
declare class MorphInstance {
    /**
     * Create a new MorphInstance instance.
     *
     * @param {Morph} morph - The {@link Morph} to instance.
     */
    constructor(morph: Morph);
    /**
     * The morph with its targets, which is being instanced.
     *
     * @type {Morph}
     */
    morph: Morph;
    device: any;
    /**
     * The mesh instance this morph instance controls the morphing of.
     *
     * @type {MeshInstance}
     */
    meshInstance: MeshInstance$4;
    _weights: any[];
    _activeTargets: any[];
    shaderCache: {};
    maxSubmitCount: any;
    _shaderMorphWeights: Float32Array;
    rtPositions: RenderTarget$3;
    rtNormals: RenderTarget$3;
    _textureParams: Float32Array;
    morphFactor: any;
    zeroTextures: boolean;
    _shaderMorphWeightsA: Float32Array;
    _shaderMorphWeightsB: Float32Array;
    _activeVertexBuffers: any[];
    /**
     * Frees video memory allocated by this object.
     */
    destroy(): void;
    shader: any;
    texturePositions: any;
    textureNormals: any;
    /**
     * Clones a MorphInstance. The returned clone uses the same {@link Morph} and weights are set
     * to defaults.
     *
     * @returns {MorphInstance} A clone of the specified MorphInstance.
     */
    clone(): MorphInstance;
    /**
     * Gets current weight of the specified morph target.
     *
     * @param {number} index - An index of morph target.
     * @returns {number} Weight.
     */
    getWeight(index: number): number;
    /**
     * Sets weight of the specified morph target.
     *
     * @param {number} index - An index of morph target.
     * @param {number} weight - Weight.
     */
    setWeight(index: number, weight: number): void;
    _dirty: boolean;
    /**
     * Generate fragment shader to blend a number of textures using specified weights.
     *
     * @param {number} numTextures - Number of textures to blend.
     * @returns {string} Fragment shader.
     * @private
     */
    private _getFragmentShader;
    /**
     * Create complete shader for texture based morphing.
     *
     * @param {number} count - Number of textures to blend.
     * @returns {Shader} Shader.
     * @private
     */
    private _getShader;
    _updateTextureRenderTarget(renderTarget: any, srcTextureName: any): void;
    _updateTextureMorph(): void;
    _updateVertexMorph(): void;
    /**
     * Selects active morph targets and prepares morph for rendering. Called automatically by
     * renderer.
     */
    update(): void;
}

type GraphicsDevice$e = GraphicsDevice$l;
type Skin = Skin$2;
/**
 * A graphical primitive. The mesh is defined by a {@link VertexBuffer} and an optional
 * {@link IndexBuffer}. It also contains a primitive definition which controls the type of the
 * primitive and the portion of the vertex or index buffer to use.
 *
 * ## Mesh APIs
 * There are two ways a mesh can be generated or updated.
 *
 * ### Simple Mesh API
 * {@link Mesh} class provides interfaces such as {@link Mesh#setPositions} and {@link Mesh#setUvs}
 * that provide a simple way to provide vertex and index data for the Mesh, and hiding the
 * complexity of creating the {@link VertexFormat}. This is the recommended interface to use.
 *
 * A simple example which creates a Mesh with 3 vertices, containing position coordinates only, to
 * form a single triangle.
 *
 * ```javascript
 * var mesh = new pc.Mesh(device);
 * var positions = [
 *     0, 0, 0, // pos 0
 *     1, 0, 0, // pos 1
 *     1, 1, 0  // pos 2
 * ];
 * mesh.setPositions(positions);
 * mesh.update();
 * ```
 *
 * An example which creates a Mesh with 4 vertices, containing position and uv coordinates in
 * channel 0, and an index buffer to form two triangles. Float32Array is used for positions and uvs.
 *
 * ```javascript
 * var mesh = new pc.Mesh(device);
 * var positions = new Float32Array([
 *     0, 0, 0, // pos 0
 *     1, 0, 0, // pos 1
 *     1, 1, 0, // pos 2
 *     0, 1, 0  // pos 3
 * ]);
 * var uvs = new Float32Array([
 *     0, 0, // uv 0
 *     1, 0, // uv 1
 *     1, 1, // uv 2
 *     0, 1  // uv 3
 * ]);
 * var indices = [
 *     0, 1, 2, // triangle 0
 *     0, 2, 3  // triangle 1
 * ];
 * mesh.setPositions(positions);
 * mesh.setUvs(0, uvs);
 * mesh.setIndices(indices);
 * mesh.update();
 * ```
 *
 * This example demonstrates that vertex attributes such as position and normals, and also indices
 * can be provided using Arrays ([]) and also Typed Arrays (Float32Array and similar). Note that
 * typed arrays have higher performance, and are generally recommended for per-frame operations or
 * larger meshes, but their construction using new operator is costly operation. If you only need
 * to operate on a small number of vertices or indices, consider using Arrays to avoid the overhead
 * associated with allocating Typed Arrays.
 *
 * Follow these links for more complex examples showing the functionality.
 *
 * - {@link http://playcanvas.github.io/#graphics/mesh-decals.html}
 * - {@link http://playcanvas.github.io/#graphics/mesh-deformation.html}
 * - {@link http://playcanvas.github.io/#graphics/mesh-generation.html}
 * - {@link http://playcanvas.github.io/#graphics/point-cloud-simulation.html}
 *
 * ### Update Vertex and Index buffers
 * This allows greater flexibility, but is more complex to use. It allows more advanced setups, for
 * example sharing a Vertex or Index Buffer between multiple meshes. See {@link VertexBuffer},
 * {@link IndexBuffer} and {@link VertexFormat} for details.
 */
declare class Mesh$1 extends RefCountedObject {
    /**
     * Create a new Mesh instance.
     *
     * @param {GraphicsDevice} [graphicsDevice] - The graphics device used to manage this mesh. If
     * it is not provided, a device is obtained from the {@link Application}.
     */
    constructor(graphicsDevice?: GraphicsDevice$e);
    id: number;
    device: any;
    /**
     * The vertex buffer holding the vertex data of the mesh.
     *
     * @type {VertexBuffer}
     */
    vertexBuffer: VertexBuffer$3;
    /**
     * An array of index buffers. For unindexed meshes, this array can be empty. The first
     * index buffer in the array is used by {@link MeshInstance}s with a renderStyle property
     * set to {@link RENDERSTYLE_SOLID}. The second index buffer in the array is used if
     * renderStyle is set to {@link RENDERSTYLE_WIREFRAME}.
     *
     * @type {IndexBuffer[]}
     */
    indexBuffer: IndexBuffer$1[];
    /**
     * Array of primitive objects defining how vertex (and index) data in the mesh should be
     * interpreted by the graphics device.
     *
     * - `type` is the type of primitive to render. Can be:
     *
     *   - {@link PRIMITIVE_POINTS}
     *   - {@link PRIMITIVE_LINES}
     *   - {@link PRIMITIVE_LINELOOP}
     *   - {@link PRIMITIVE_LINESTRIP}
     *   - {@link PRIMITIVE_TRIANGLES}
     *   - {@link PRIMITIVE_TRISTRIP}
     *   - {@link PRIMITIVE_TRIFAN}
     *
     * - `base` is the offset of the first index or vertex to dispatch in the draw call.
     * - `count` is the number of indices or vertices to dispatch in the draw call.
     * - `indexed` specifies whether to interpret the primitive as indexed, thereby using the
     * currently set index buffer.
     *
     * @type {Array.<{type: number, base: number, count: number, indexed: boolean|undefined}>}
     */
    primitive: {
        type: number;
        base: number;
        count: number;
        indexed: boolean | undefined;
    }[];
    /**
     * The skin data (if any) that drives skinned mesh animations for this mesh.
     *
     * @type {Skin|null}
     */
    skin: Skin | null;
    _morph: any;
    _geometryData: GeometryData;
    _aabb: BoundingBox$1;
    boneAabb: any[];
    /**
     * The morph data (if any) that drives morph target animations for this mesh.
     *
     * @type {Morph|null}
     */
    set morph(arg: any);
    get morph(): any;
    /**
     * The axis-aligned bounding box for the object space vertices of this mesh.
     *
     * @type {BoundingBox}
     */
    set aabb(arg: BoundingBox$1);
    get aabb(): BoundingBox$1;
    /**
     * Destroys {@link VertexBuffer} and {@link IndexBuffer} associate with the mesh. This is
     * normally called by {@link Model#destroy} and does not need to be called manually.
     */
    destroy(): void;
    _destroyIndexBuffer(index: any): void;
    _initBoneAabbs(morphTargets: any): void;
    boneUsed: any[];
    _initGeometryData(): void;
    /**
     * Clears the mesh of existing vertices and indices and resets the {@link VertexFormat}
     * associated with the mesh. This call is typically followed by calls to methods such as
     * {@link Mesh#setPositions}, {@link Mesh#setVertexStream} or {@link Mesh#setIndices} and
     * finally {@link Mesh#update} to rebuild the mesh, allowing different {@link VertexFormat}.
     *
     * @param {boolean} [verticesDynamic] - Indicates the {@link VertexBuffer} should be created
     * with {@link BUFFER_DYNAMIC} usage. If not specified, {@link BUFFER_STATIC} is used.
     * @param {boolean} [indicesDynamic] - Indicates the {@link IndexBuffer} should be created with
     * {@link BUFFER_DYNAMIC} usage. If not specified, {@link BUFFER_STATIC} is used.
     * @param {number} [maxVertices] - A {@link VertexBuffer} will be allocated with at least
     * maxVertices, allowing additional vertices to be added to it without the allocation. If no
     * value is provided, a size to fit the provided vertices will be allocated.
     * @param {number} [maxIndices] - An {@link IndexBuffer} will be allocated with at least
     * maxIndices, allowing additional indices to be added to it without the allocation. If no
     * value is provided, a size to fit the provided indices will be allocated.
     */
    clear(verticesDynamic?: boolean, indicesDynamic?: boolean, maxVertices?: number, maxIndices?: number): void;
    /**
     * Sets the vertex data for any supported semantic.
     *
     * @param {string} semantic - The meaning of the vertex element. For supported semantics, see
     * SEMANTIC_* in {@link VertexFormat}.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - Vertex
     * data for the specified semantic.
     * @param {number} componentCount - The number of values that form a single Vertex element. For
     * example when setting a 3D position represented by 3 numbers per vertex, number 3 should be
     * specified.
     * @param {number} [numVertices] - The number of vertices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     * @param {number} [dataType] - The format of data when stored in the {@link VertexBuffer}, see
     * TYPE_* in {@link VertexFormat}. When not specified, {@link TYPE_FLOAT32} is used.
     * @param {boolean} [dataTypeNormalize] - If true, vertex attribute data will be mapped from a
     * 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data is left
     * unchanged. If this property is unspecified, false is assumed.
     */
    setVertexStream(semantic: string, data: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount: number, numVertices?: number, dataType?: number, dataTypeNormalize?: boolean): void;
    /**
     * Gets the vertex data corresponding to a semantic.
     *
     * @param {string} semantic - The semantic of the vertex element to get. For supported
     * semantics, see SEMANTIC_* in {@link VertexFormat}.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - An
     * array to populate with the vertex data. When typed array is supplied, enough space needs to
     * be reserved, otherwise only partial data is copied.
     * @returns {number} Returns the number of vertices populated.
     */
    getVertexStream(semantic: string, data: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;
    /**
     * Sets the vertex positions array. Vertices are stored using {@link TYPE_FLOAT32} format.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} positions - Vertex
     * data containing positions.
     * @param {number} [componentCount] - The number of values that form a single position element.
     * Defaults to 3 if not specified, corresponding to x, y and z coordinates.
     * @param {number} [numVertices] - The number of vertices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     */
    setPositions(positions: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount?: number, numVertices?: number): void;
    /**
     * Sets the vertex normals array. Normals are stored using {@link TYPE_FLOAT32} format.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} normals - Vertex
     * data containing normals.
     * @param {number} [componentCount] - The number of values that form a single normal element.
     * Defaults to 3 if not specified, corresponding to x, y and z direction.
     * @param {number} [numVertices] - The number of vertices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     */
    setNormals(normals: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount?: number, numVertices?: number): void;
    /**
     * Sets the vertex uv array. Uvs are stored using {@link TYPE_FLOAT32} format.
     *
     * @param {number} channel - The uv channel in [0..7] range.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} uvs - Vertex
     * data containing uv-coordinates.
     * @param {number} [componentCount] - The number of values that form a single uv element.
     * Defaults to 2 if not specified, corresponding to u and v coordinates.
     * @param {number} [numVertices] - The number of vertices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     */
    setUvs(channel: number, uvs: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount?: number, numVertices?: number): void;
    /**
     * Sets the vertex color array. Colors are stored using {@link TYPE_FLOAT32} format, which is
     * useful for HDR colors.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} colors - Vertex
     * data containing colors.
     * @param {number} [componentCount] - The number of values that form a single color element.
     * Defaults to 4 if not specified, corresponding to r, g, b and a.
     * @param {number} [numVertices] - The number of vertices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     */
    setColors(colors: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount?: number, numVertices?: number): void;
    /**
     * Sets the vertex color array. Colors are stored using {@link TYPE_UINT8} format, which is
     * useful for LDR colors. Values in the array are expected in [0..255] range, and are mapped to
     * [0..1] range in the shader.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} colors - Vertex
     * data containing colors. The array is expected to contain 4 components per vertex,
     * corresponding to r, g, b and a.
     * @param {number} [numVertices] - The number of vertices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     */
    setColors32(colors: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, numVertices?: number): void;
    /**
     * Sets the index array. Indices are stored using 16-bit format by default, unless more than
     * 65535 vertices are specified, in which case 32-bit format is used.
     *
     * @param {number[]|Uint8Array|Uint16Array|Uint32Array} indices - The array of indices that
     * define primitives (lines, triangles, etc.).
     * @param {number} [numIndices] - The number of indices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     */
    setIndices(indices: number[] | Uint8Array | Uint16Array | Uint32Array, numIndices?: number): void;
    /**
     * Gets the vertex positions data.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} positions - An
     * array to populate with the vertex data. When typed array is supplied, enough space needs to
     * be reserved, otherwise only partial data is copied.
     * @returns {number} Returns the number of vertices populated.
     */
    getPositions(positions: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;
    /**
     * Gets the vertex normals data.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} normals - An
     * array to populate with the vertex data. When typed array is supplied, enough space needs to
     * be reserved, otherwise only partial data is copied.
     * @returns {number} Returns the number of vertices populated.
     */
    getNormals(normals: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;
    /**
     * Gets the vertex uv data.
     *
     * @param {number} channel - The uv channel in [0..7] range.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} uvs - An
     * array to populate with the vertex data. When typed array is supplied, enough space needs to
     * be reserved, otherwise only partial data is copied.
     * @returns {number} Returns the number of vertices populated.
     */
    getUvs(channel: number, uvs: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;
    /**
     * Gets the vertex color data.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} colors - An
     * array to populate with the vertex data. When typed array is supplied, enough space needs to
     * be reserved, otherwise only partial data is copied.
     * @returns {number} Returns the number of vertices populated.
     */
    getColors(colors: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;
    /**
     * Gets the index data.
     *
     * @param {number[]|Uint8Array|Uint16Array|Uint32Array} indices - An array to populate with the
     * index data. When a typed array is supplied, enough space needs to be reserved, otherwise
     * only partial data is copied.
     * @returns {number} Returns the number of indices populated.
     */
    getIndices(indices: number[] | Uint8Array | Uint16Array | Uint32Array): number;
    /**
     * Applies any changes to vertex stream and indices to mesh. This allocates or reallocates
     * {@link vertexBuffer} or {@link IndexBuffer} to fit all provided vertices and indices, and
     * fills them with data.
     *
     * @param {number} [primitiveType] - The type of primitive to render.  Can be:
     *
     * - {@link PRIMITIVE_POINTS}
     * - {@link PRIMITIVE_LINES}
     * - {@link PRIMITIVE_LINELOOP}
     * - {@link PRIMITIVE_LINESTRIP}
     * - {@link PRIMITIVE_TRIANGLES}
     * - {@link PRIMITIVE_TRISTRIP}
     * - {@link PRIMITIVE_TRIFAN}
     *
     * Defaults to {@link PRIMITIVE_TRIANGLES} if unspecified.
     * @param {boolean} [updateBoundingBox] - True to update bounding box. Bounding box is updated
     * only if positions were set since last time update was called, and componentCount for
     * position was 3, otherwise bounding box is not updated. See {@link Mesh#setPositions}.
     * Defaults to true if unspecified. Set this to false to avoid update of the bounding box and
     * use aabb property to set it instead.
     */
    update(primitiveType?: number, updateBoundingBox?: boolean): void;
    _buildVertexFormat(vertexCount: any): VertexFormat$2;
    _updateVertexBuffer(): void;
    _updateIndexBuffer(): void;
    prepareRenderState(renderStyle: any): void;
    updateRenderStates(): void;
    generateWireframe(): void;
}

declare class GeometryData {
    static DEFAULT_COMPONENTS_POSITION: number;
    static DEFAULT_COMPONENTS_NORMAL: number;
    static DEFAULT_COMPONENTS_UV: number;
    static DEFAULT_COMPONENTS_COLORS: number;
    initDefaults(): void;
    recreate: boolean;
    verticesUsage: number;
    indicesUsage: number;
    maxVertices: number;
    maxIndices: number;
    vertexCount: any;
    indexCount: number;
    vertexStreamsUpdated: boolean;
    indexStreamUpdated: boolean;
    vertexStreamDictionary: {};
    indices: any;
    _changeVertexCount(count: any, semantic: any): void;
}

type Texture$6 = Texture$8;
/**
 * A material determines how a particular mesh instance is rendered. It specifies the shader and
 * render state that is set before the mesh instance is submitted to the graphics device.
 *
 * @property {number} alphaTest The alpha test reference value to control which fragments are
 * written to the currently active render target based on alpha value. All fragments with an alpha
 * value of less than the alphaTest reference value will be discarded. alphaTest defaults to 0 (all
 * fragments pass).
 * @property {boolean} alphaToCoverage Enables or disables alpha to coverage (WebGL2 only). When
 * enabled, and if hardware anti-aliasing is on, limited order-independent transparency can be
 * achieved. Quality depends on the number of MSAA samples of the current render target.
 * It can nicely soften edges of otherwise sharp alpha cutouts, but isn't recommended for large
 * area semi-transparent surfaces. Note, that you don't need to enable blending to make alpha to
 * coverage work. It will work without it, just like alphaTest.
 * @property {boolean} alphaWrite If true, the alpha component of fragments generated by the shader
 * of this material is written to the color buffer of the currently active render target. If false,
 * the alpha component will not be written. Defaults to true.
 * @property {number} blendType Controls how primitives are blended when being written to the
 * currently active render target. Can be:
 *
 * - {@link BLEND_SUBTRACTIVE}: Subtract the color of the source fragment from the destination
 * fragment and write the result to the frame buffer.
 * - {@link BLEND_ADDITIVE}: Add the color of the source fragment to the destination fragment and
 * write the result to the frame buffer.
 * - {@link BLEND_NORMAL}: Enable simple translucency for materials such as glass. This is
 * equivalent to enabling a source blend mode of {@link BLENDMODE_SRC_ALPHA} and a destination
 * blend mode of {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.
 * - {@link BLEND_NONE}: Disable blending.
 * - {@link BLEND_PREMULTIPLIED}: Similar to {@link BLEND_NORMAL} expect the source fragment is
 * assumed to have already been multiplied by the source alpha value.
 * - {@link BLEND_MULTIPLICATIVE}: Multiply the color of the source fragment by the color of the
 * destination fragment and write the result to the frame buffer.
 * - {@link BLEND_ADDITIVEALPHA}: Same as {@link BLEND_ADDITIVE} except the source RGB is
 * multiplied by the source alpha.
 * - {@link BLEND_MULTIPLICATIVE2X}: Multiplies colors and doubles the result.
 * - {@link BLEND_SCREEN}: Softer version of additive.
 * - {@link BLEND_MIN}: Minimum color. Check app.graphicsDevice.extBlendMinmax for support.
 * - {@link BLEND_MAX}: Maximum color. Check app.graphicsDevice.extBlendMinmax for support.
 *
 * Defaults to {@link BLEND_NONE}.
 * @property {boolean} blueWrite If true, the blue component of fragments generated by the shader
 * of this material is written to the color buffer of the currently active render target. If false,
 * the blue component will not be written. Defaults to true.
 * @property {number} cull Controls how triangles are culled based on their face direction with
 * respect to the viewpoint. Can be:
 *
 * - {@link CULLFACE_NONE}: Do not cull triangles based on face direction.
 * - {@link CULLFACE_BACK}: Cull the back faces of triangles (do not render triangles facing away
 * from the view point).
 * - {@link CULLFACE_FRONT}: Cull the front faces of triangles (do not render triangles facing
 * towards the view point).
 * - {@link CULLFACE_FRONTANDBACK}: Cull both front and back faces (triangles will not be
 * rendered).
 *
 * Defaults to {@link CULLFACE_BACK}.
 * @property {boolean} depthTest If true, fragments generated by the shader of this material are
 * only written to the current render target if they pass the depth test. If false, fragments
 * generated by the shader of this material are written to the current render target regardless of
 * what is in the depth buffer. Defaults to true.
 * @property {boolean} depthWrite If true, fragments generated by the shader of this material write
 * a depth value to the depth buffer of the currently active render target. If false, no depth
 * value is written. Defaults to true.
 * @property {boolean} greenWrite If true, the green component of fragments generated by the shader
 * of this material is written to the color buffer of the currently active render target. If false,
 * the green component will not be written. Defaults to true.
 * @property {string} name The name of the material.
 * @property {boolean} redWrite If true, the red component of fragments generated by the shader of
 * this material is written to the color buffer of the currently active render target. If false,
 * the red component will not be written. Defaults to true.
 * @property {Shader|null} shader The shader used by this material to render mesh instances
 * (default is null).
 * @property {StencilParameters|null} stencilFront Stencil parameters for front faces (default is
 * null).
 * @property {StencilParameters|null} stencilBack Stencil parameters for back faces (default is
 * null).
 * @property {number} depthBias Offsets the output depth buffer value. Useful for decals to prevent
 * z-fighting.
 * @property {number} slopeDepthBias Same as {@link Material#depthBias}, but also depends on the
 * slope of the triangle relative to the camera.
 */
declare class Material$2 {
    name: string;
    id: number;
    _shader: any;
    variants: {};
    parameters: {};
    alphaTest: number;
    alphaToCoverage: boolean;
    blend: boolean;
    blendSrc: number;
    blendDst: number;
    blendEquation: number;
    separateAlphaBlend: boolean;
    blendSrcAlpha: number;
    blendDstAlpha: number;
    blendAlphaEquation: number;
    cull: number;
    depthTest: boolean;
    depthWrite: boolean;
    stencilFront: any;
    stencilBack: any;
    depthBias: number;
    slopeDepthBias: number;
    redWrite: boolean;
    greenWrite: boolean;
    blueWrite: boolean;
    alphaWrite: boolean;
    meshInstances: any[];
    _shaderVersion: number;
    _scene: any;
    _dirtyBlend: boolean;
    dirty: boolean;
    set shader(arg: any);
    get shader(): any;
    get transparent(): boolean;
    set blendType(arg: number);
    get blendType(): number;
    /**
     * Copy a material.
     *
     * @param {Material} source - The material to copy.
     * @returns {Material} The destination material.
     */
    copy(source: Material$2): Material$2;
    /**
     * Clone a material.
     *
     * @returns {Material} A newly cloned material.
     */
    clone(): Material$2;
    _updateMeshInstanceKeys(): void;
    updateUniforms(device: any, scene: any): void;
    updateShader(device: any, scene: any, objDefs: any): void;
    /**
     * Applies any changes made to the material's properties.
     */
    update(): void;
    clearParameters(): void;
    getParameters(): {};
    clearVariants(): void;
    /**
     * Retrieves the specified shader parameter from a material.
     *
     * @param {string} name - The name of the parameter to query.
     * @returns {object} The named parameter.
     */
    getParameter(name: string): object;
    /**
     * Sets a shader parameter on a material.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {number|number[]|Texture} data - The value for the specified parameter.
     */
    setParameter(name: string, data: number | number[] | Texture$6): void;
    /**
     * Deletes a shader parameter on a material.
     *
     * @param {string} name - The name of the parameter to delete.
     */
    deleteParameter(name: string): void;
    setParameters(device: any, names: any): void;
    /**
     * Removes this material from the scene and possibly frees up memory from its shaders (if there
     * are no other materials using it).
     */
    destroy(): void;
    addMeshInstanceRef(meshInstance: any): void;
    removeMeshInstanceRef(meshInstance: any): void;
}

type Texture$5 = Texture$8;
type VertexBuffer = VertexBuffer$3;
type Material$1 = Material$2;
type Mesh = Mesh$1;
declare class Command {
    constructor(layer: any, blendType: any, command: any);
    _key: number[];
    command: any;
    set key(arg: number);
    get key(): number;
}
/**
 * Callback used by {@link Layer} to calculate the "sort distance" for a {@link MeshInstance},
 * which determines its place in the render order.
 *
 * @callback calculateSortDistanceCallback
 * @param {MeshInstance} meshInstance - The mesh instance.
 * @param {Vec3} cameraPosition - The position of the camera.
 * @param {Vec3} cameraForward - The forward vector of the camera.
 */
/**
 * An instance of a {@link Mesh}. A single mesh can be referenced by many mesh instances that can
 * have different transforms and materials.
 */
declare class MeshInstance$3 {
    static lightmapParamNames: string[];
    static _prepareRenderStyleForArray(meshInstances: any, renderStyle: any): void;
    /**
     * Create a new MeshInstance instance.
     *
     * @param {Mesh} mesh - The graphics mesh to instance.
     * @param {Material} material - The material to use for this mesh instance.
     * @param {GraphNode} [node] - The graph node defining the transform for this instance. This
     * parameter is optional when used with {@link RenderComponent} and will use the node the
     * component is attached to.
     * @example
     * // Create a mesh instance pointing to a 1x1x1 'cube' mesh
     * var mesh = pc.createBox(graphicsDevice);
     * var material = new pc.StandardMaterial();
     *
     * var meshInstance = new pc.MeshInstance(mesh, material);
     *
     * var entity = new pc.Entity();
     * entity.addComponent('render', {
     *     meshInstances: [meshInstance]
     * });
     *
     * // Add the entity to the scene hierarchy
     * this.app.scene.root.addChild(entity);
     */
    constructor(mesh: Mesh, material: Material$1, node?: GraphNode$3);
    _key: number[];
    _shader: any[];
    isStatic: boolean;
    _staticLightList: any;
    _staticSource: any;
    /**
     * The graph node defining the transform for this instance.
     *
     * @type {GraphNode}
     */
    node: GraphNode$3;
    _mesh: Mesh$1;
    /**
     * The material used by this mesh instance.
     *
     * @type {Material}
     */
    set material(arg: any);
    get material(): any;
    _shaderDefs: number;
    _lightHash: number;
    /**
     * Enable rendering for this mesh instance. Use visible property to enable/disable
     * rendering without overhead of removing from scene. But note that the mesh instance is
     * still in the hierarchy and still in the draw call list.
     *
     * @type {boolean}
     */
    visible: boolean;
    set layer(arg: any);
    get layer(): any;
    _renderStyle: number;
    castShadow: boolean;
    _receiveShadow: boolean;
    _screenSpace: boolean;
    _noDepthDrawGl1: boolean;
    /**
     * Controls whether the mesh instance can be culled by frustum culling
     * ({@link CameraComponent#frustumCulling}).
     *
     * @type {boolean}
     */
    cull: boolean;
    /**
     * True if the mesh instance is pickable by the {@link Picker}. Defaults to true.
     *
     * @type {boolean}
     * @private
     */
    private pick;
    _updateAabb: boolean;
    _updateAabbFunc: any;
    _calculateSortDistance: any;
    /**
     * @type {SkinInstance}
     * @private
     */
    private _skinInstance;
    /**
     * @type {MorphInstance}
     * @private
     */
    private _morphInstance;
    instancingData: InstancingData;
    /**
     * @type {BoundingBox}
     * @private
     */
    private _customAabb;
    /**
     * The world space axis-aligned bounding box for this mesh instance.
     *
     * @type {BoundingBox}
     */
    set aabb(arg: any);
    get aabb(): any;
    _aabbVer: number;
    /**
     * Use this value to affect rendering order of mesh instances. Only used when mesh
     * instances are added to a {@link Layer} with {@link Layer#opaqueSortMode} or
     * {@link Layer#transparentSortMode} (depending on the material) set to
     * {@link SORTMODE_MANUAL}.
     *
     * @type {number}
     */
    drawOrder: number;
    /**
     * Read this value in {@link Layer#onPostCull} to determine if the object is actually going
     * to be rendered.
     *
     * @type {boolean}
     */
    visibleThisFrame: boolean;
    isVisibleFunc: any;
    parameters: {};
    stencilFront: any;
    stencilBack: any;
    flipFaces: boolean;
    /**
     * The render style of the mesh instance. Can be:
     *
     * - {@link RENDERSTYLE_SOLID}
     * - {@link RENDERSTYLE_WIREFRAME}
     * - {@link RENDERSTYLE_POINTS}
     *
     * Defaults to {@link RENDERSTYLE_SOLID}.
     *
     * @type {number}
     */
    set renderStyle(arg: number);
    get renderStyle(): number;
    /**
     * The graphics mesh being instanced.
     *
     * @type {Mesh}
     */
    set mesh(arg: Mesh$1);
    get mesh(): Mesh$1;
    _aabb: any;
    _material: any;
    _layer: any;
    /**
     * In some circumstances mesh instances are sorted by a distance calculation to determine their
     * rendering order. Set this callback to override the default distance calculation, which gives
     * the dot product of the camera forward vector and the vector between the camera position and
     * the center of the mesh instance's axis-aligned bounding box. This option can be particularly
     * useful for rendering transparent meshes in a better order than default.
     *
     * @type {calculateSortDistanceCallback}
     */
    set calculateSortDistance(arg: any);
    get calculateSortDistance(): any;
    set receiveShadow(arg: boolean);
    get receiveShadow(): boolean;
    /**
     * The skin instance managing skinning of this mesh instance, or null if skinning is not used.
     *
     * @type {SkinInstance}
     */
    set skinInstance(arg: SkinInstance);
    get skinInstance(): SkinInstance;
    /**
     * The morph instance managing morphing of this mesh instance, or null if morphing is not used.
     *
     * @type {MorphInstance}
     */
    set morphInstance(arg: MorphInstance);
    get morphInstance(): MorphInstance;
    set screenSpace(arg: boolean);
    get screenSpace(): boolean;
    set key(arg: number);
    get key(): number;
    /**
     * Mask controlling which {@link LightComponent}s light this mesh instance, which
     * {@link CameraComponent} sees it and in which {@link Layer} it is rendered. Defaults to 1.
     *
     * @type {number}
     */
    set mask(arg: number);
    get mask(): number;
    /**
     * Number of instances when using hardware instancing to render the mesh.
     *
     * @type {number}
     */
    set instancingCount(arg: number);
    get instancingCount(): number;
    destroy(): void;
    _isVisible(camera: any): any;
    updateKey(): void;
    /**
     * Sets up {@link MeshInstance} to be rendered using Hardware Instancing.
     *
     * @param {VertexBuffer|null} vertexBuffer - Vertex buffer to hold per-instance vertex data
     * (usually world matrices). Pass null to turn off hardware instancing.
     */
    setInstancing(vertexBuffer: VertexBuffer | null): void;
    clearParameters(): void;
    getParameters(): {};
    /**
     * Retrieves the specified shader parameter from a mesh instance.
     *
     * @param {string} name - The name of the parameter to query.
     * @returns {object} The named parameter.
     */
    getParameter(name: string): object;
    /**
     * Sets a shader parameter on a mesh instance. Note that this parameter will take precedence
     * over parameter of the same name if set on Material this mesh instance uses for rendering.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {number|number[]|Texture} data - The value for the specified parameter.
     * @param {number} [passFlags] - Mask describing which passes the material should be included
     * in.
     */
    setParameter(name: string, data: number | number[] | Texture$5, passFlags?: number): void;
    setRealtimeLightmap(name: any, texture: any): void;
    /**
     * Deletes a shader parameter on a mesh instance.
     *
     * @param {string} name - The name of the parameter to delete.
     */
    deleteParameter(name: string): void;
    setParameters(device: any, passFlag: any): void;
    setLightmapped(value: any): void;
    setCustomAabb(aabb: any): void;
    _setupSkinUpdate(): void;
}

declare class InstancingData {
    constructor(numObjects: any);
    /**
     * @type {number}
     * @private
     */
    private count;
    vertexBuffer: any;
}

type GraphNode$1 = GraphNode$3;
/** @typedef {import('./graph-node.js').GraphNode} GraphNode */
/**
 * A model is a graphical object that can be added to or removed from a scene. It contains a
 * hierarchy and any number of mesh instances.
 */
declare class Model {
    /**
     * The root node of the model's graph node hierarchy.
     *
     * @type {GraphNode}
     */
    graph: GraphNode$1;
    /**
     * An array of MeshInstances contained in this model.
     *
     * @type {MeshInstance[]}
     */
    meshInstances: MeshInstance$3[];
    /**
     * An array of SkinInstances contained in this model.
     *
     * @type {SkinInstance[]}
     */
    skinInstances: SkinInstance[];
    /**
     * An array of MorphInstances contained in this model.
     *
     * @type {MorphInstance[]}
     */
    morphInstances: MorphInstance[];
    cameras: any[];
    lights: any[];
    _shadersVersion: number;
    _immutable: boolean;
    getGraph(): GraphNode$3;
    setGraph(graph: any): void;
    getCameras(): any[];
    setCameras(cameras: any): void;
    getLights(): any[];
    setLights(lights: any): void;
    getMaterials(): any[];
    /**
     * Clones a model. The returned model has a newly created hierarchy and mesh instances, but
     * meshes are shared between the clone and the specified model.
     *
     * @returns {Model} A clone of the specified model.
     * @example
     * var clonedModel = model.clone();
     */
    clone(): Model;
    /**
     * Destroys skinning texture and possibly deletes vertex/index buffers of a model. Mesh is
     * reference-counted, so buffers are only deleted if all models with referencing mesh instances
     * were deleted. That means all in-scene models + the "base" one (asset.resource) which is
     * created when the model is parsed. It is recommended to use asset.unload() instead, which
     * will also remove the model from the scene.
     */
    destroy(): void;
    /**
     * Generates the necessary internal data for a model to be renderable as wireframe. Once this
     * function has been called, any mesh instance in the model can have its renderStyle property
     * set to {@link RENDERSTYLE_WIREFRAME}.
     *
     * @example
     * model.generateWireframe();
     * for (var i = 0; i < model.meshInstances.length; i++) {
     *     model.meshInstances[i].renderStyle = pc.RENDERSTYLE_WIREFRAME;
     * }
     */
    generateWireframe(): void;
}

type Vec2$2 = Vec2$3;
type Vec4$3 = Vec4$6;
/** @typedef {import('../math/vec2.js').Vec2} Vec2 */
/** @typedef {import('../math/vec4.js').Vec4} Vec4 */
/** @typedef {import('../graphics/texture.js').Texture} Texture */
/**
 * A TextureAtlas contains a number of frames from a texture. Each frame defines a region in a
 * texture. The TextureAtlas is referenced by {@link Sprite}s.
 *
 * @augments EventHandler
 */
declare class TextureAtlas$1 extends EventHandler$1 {
    /**
     * @type {Texture}
     * @private
     */
    private _texture;
    /**
     * @type {object}
     * @private
     */
    private _frames;
    /**
     * The texture used by the atlas.
     *
     * @type {Texture}
     */
    set texture(arg: Texture$8);
    get texture(): Texture$8;
    /**
     * Contains frames which define portions of the texture atlas.
     *
     * @type {object}
     */
    set frames(arg: any);
    get frames(): any;
    /**
     * Set a new frame in the texture atlas.
     *
     * @param {string} key - The key of the frame.
     * @param {object} data - The properties of the frame.
     * @param {Vec4} data.rect - The u, v, width, height properties of the frame in pixels.
     * @param {Vec2} data.pivot - The pivot of the frame - values are between 0-1.
     * @param {Vec4} data.border - The border of the frame for 9-slicing. Values are ordered as
     * follows: left, bottom, right, top border in pixels.
     * @example
     * atlas.setFrame('1', {
     *     rect: new pc.Vec4(0, 0, 128, 128),
     *     pivot: new pc.Vec2(0.5, 0.5),
     *     border: new pc.Vec4(5, 5, 5, 5)
     * });
     */
    setFrame(key: string, data: {
        rect: Vec4$3;
        pivot: Vec2$2;
        border: Vec4$3;
    }): void;
    /**
     * Removes a frame from the texture atlas.
     *
     * @param {string} key - The key of the frame.
     * @example
     * atlas.removeFrame('1');
     */
    removeFrame(key: string): void;
    /**
     * Free up the underlying texture owned by the atlas.
     */
    destroy(): void;
}

type GraphicsDevice$d = GraphicsDevice$l;
type TextureAtlas = TextureAtlas$1;
/**
 * A Sprite contains references to one or more frames of a {@link TextureAtlas}. It can be used by
 * the {@link SpriteComponent} or the {@link ElementComponent} to render a single frame or a sprite
 * animation.
 *
 * @augments EventHandler
 */
declare class Sprite$1 extends EventHandler$1 {
    /**
     * Create a new Sprite instance.
     *
     * @param {GraphicsDevice} device - The graphics device of the application.
     * @param {object} [options] - Options for creating the Sprite.
     * @param {number} [options.pixelsPerUnit] - The number of pixels that map to one PlayCanvas
     * unit. Defaults to 1.
     * @param {number} [options.renderMode] - The rendering mode of the sprite. Can be:
     *
     * - {@link SPRITE_RENDERMODE_SIMPLE}
     * - {@link SPRITE_RENDERMODE_SLICED}
     * - {@link SPRITE_RENDERMODE_TILED}
     *
     * Defaults to {@link SPRITE_RENDERMODE_SIMPLE}.
     * @param {TextureAtlas} [options.atlas] - The texture atlas. Defaults to null.
     * @param {string[]} [options.frameKeys] - The keys of the frames in the sprite atlas that this
     * sprite is using. Defaults to null.
     */
    constructor(device: GraphicsDevice$d, options?: {
        pixelsPerUnit?: number;
        renderMode?: number;
        atlas?: TextureAtlas;
        frameKeys?: string[];
    });
    _device: GraphicsDevice$l;
    _pixelsPerUnit: number;
    _renderMode: number;
    _atlas: TextureAtlas$1;
    _frameKeys: string[];
    _meshes: any[];
    _updatingProperties: boolean;
    _meshesDirty: boolean;
    /**
     * The keys of the frames in the sprite atlas that this sprite is using.
     *
     * @type {string[]}
     */
    set frameKeys(arg: string[]);
    get frameKeys(): string[];
    /**
     * The texture atlas.
     *
     * @type {TextureAtlas}
     */
    set atlas(arg: TextureAtlas$1);
    get atlas(): TextureAtlas$1;
    /**
     * The number of pixels that map to one PlayCanvas unit.
     *
     * @type {number}
     */
    set pixelsPerUnit(arg: number);
    get pixelsPerUnit(): number;
    /**
     * The rendering mode of the sprite. Can be:
     *
     * - {@link SPRITE_RENDERMODE_SIMPLE}
     * - {@link SPRITE_RENDERMODE_SLICED}
     * - {@link SPRITE_RENDERMODE_TILED}
     *
     * @type {number}
     */
    set renderMode(arg: number);
    get renderMode(): number;
    /**
     * An array that contains a mesh for each frame.
     *
     * @type {Mesh[]}
     */
    get meshes(): Mesh$1[];
    _createMeshes(): void;
    _createSimpleMesh(frame: any): Mesh$1;
    _create9SliceMesh(): Mesh$1;
    _onSetFrames(frames: any): void;
    _onFrameChanged(frameKey: any, frame: any): void;
    _onFrameRemoved(frameKey: any): void;
    startUpdate(): void;
    endUpdate(): void;
    /**
     * Free up the meshes created by the sprite.
     */
    destroy(): void;
}

type SpriteComponent$2 = SpriteComponent$1;
/** @typedef {import('../../../scene/sprite.js').Sprite} Sprite */
/** @typedef {import('./component.js').SpriteComponent} SpriteComponent */
/**
 * Handles playing of sprite animations and loading of relevant sprite assets.
 *
 * @augments EventHandler
 */
declare class SpriteAnimationClip extends EventHandler$1 {
    /**
     * Create a new SpriteAnimationClip instance.
     *
     * @param {SpriteComponent} component - The sprite component managing this clip.
     * @param {object} data - Data for the new animation clip.
     * @param {number} [data.fps] - Frames per second for the animation clip.
     * @param {boolean} [data.loop] - Whether to loop the animation clip.
     * @param {string} [data.name] - The name of the new animation clip.
     * @param {number} [data.spriteAsset] - The id of the sprite asset that this clip will play.
     */
    constructor(component: SpriteComponent$2, data: {
        fps?: number;
        loop?: boolean;
        name?: string;
        spriteAsset?: number;
    });
    _component: SpriteComponent$1;
    _frame: number;
    _sprite: any;
    _spriteAsset: any;
    /**
     * The id of the sprite asset used to play the animation.
     *
     * @type {number}
     */
    set spriteAsset(arg: any);
    get spriteAsset(): any;
    name: string;
    fps: number;
    loop: boolean;
    _playing: boolean;
    _paused: boolean;
    _time: number;
    /**
     * The total duration of the animation in seconds.
     *
     * @type {number}
     */
    get duration(): number;
    /**
     * The index of the frame of the {@link Sprite} currently being rendered.
     *
     * @type {number}
     */
    set frame(arg: number);
    get frame(): number;
    /**
     * Whether the animation is currently paused.
     *
     * @type {boolean}
     */
    get isPaused(): boolean;
    /**
     * Whether the animation is currently playing.
     *
     * @type {boolean}
     */
    get isPlaying(): boolean;
    /**
     * The current sprite used to play the animation.
     *
     * @type {Sprite}
     */
    set sprite(arg: any);
    get sprite(): any;
    /**
     * The current time of the animation in seconds.
     *
     * @type {number}
     */
    set time(arg: number);
    get time(): number;
    _onSpriteAssetAdded(asset: any): void;
    _bindSpriteAsset(asset: any): void;
    _unbindSpriteAsset(asset: any): void;
    _onSpriteAssetLoad(asset: any): void;
    _onTextureAtlasLoad(atlasAsset: any): void;
    _onSpriteAssetRemove(asset: any): void;
    _onSpriteMeshesChange(): void;
    _onSpritePpuChanged(): void;
    /**
     * Advances the animation, looping if necessary.
     *
     * @param {number} dt - The delta time.
     * @private
     */
    private _update;
    _setTime(value: any): void;
    _setFrame(value: any): void;
    _destroy(): void;
    /**
     * Plays the animation. If it's already playing then this does nothing.
     */
    play(): void;
    /**
     * Pauses the animation.
     */
    pause(): void;
    /**
     * Resumes the paused animation.
     */
    resume(): void;
    /**
     * Stops the animation and resets the animation to the first frame.
     */
    stop(): void;
}

type Asset$5 = Asset$6;
type Entity$r = Entity$a;
type SpriteComponentSystem$1 = SpriteComponentSystem$2;
/**
 * Enables an Entity to render a simple static sprite or sprite animations.
 *
 * @augments Component
 */
declare class SpriteComponent$1 extends Component$2 {
    /**
     * Create a new SpriteComponent instance.
     *
     * @param {SpriteComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: SpriteComponentSystem$1, entity: Entity$r);
    _type: string;
    _material: any;
    _color: Color$4;
    _colorUniform: Float32Array;
    _speed: number;
    _flipX: boolean;
    _flipY: boolean;
    _width: number;
    _height: number;
    _drawOrder: number;
    _layers: number[];
    _outerScale: Vec2$3;
    _outerScaleUniform: Float32Array;
    _innerOffset: Vec4$6;
    _innerOffsetUniform: Float32Array;
    _atlasRect: Vec4$6;
    _atlasRectUniform: Float32Array;
    _batchGroupId: number;
    _batchGroup: any;
    _node: GraphNode$3;
    _model: Model;
    _meshInstance: MeshInstance$3;
    _updateAabbFunc: any;
    _addedModel: boolean;
    _autoPlayClip: any;
    /**
     * Dictionary of sprite animation clips.
     *
     * @type {Object.<string, SpriteAnimationClip>}
     * @private
     */
    private _clips;
    _defaultClip: SpriteAnimationClip;
    /**
     * The sprite animation clip currently playing.
     *
     * @type {SpriteAnimationClip}
     * @private
     */
    private _currentClip;
    /**
     * The type of the SpriteComponent. Can be:
     *
     * - {@link SPRITETYPE_SIMPLE}: The component renders a single frame from a sprite asset.
     * - {@link SPRITETYPE_ANIMATED}: The component can play sprite animation clips.
     *
     * Defaults to {@link SPRITETYPE_SIMPLE}.
     *
     * @type {string}
     */
    set type(arg: string);
    get type(): string;
    /**
     * The frame counter of the sprite. Specifies which frame from the current sprite asset to
     * render.
     *
     * @type {number}
     */
    set frame(arg: number);
    get frame(): number;
    /**
     * The asset id or the {@link Asset} of the sprite to render. Only works for
     * {@link SPRITETYPE_SIMPLE} sprites.
     *
     * @type {number|Asset}
     */
    set spriteAsset(arg: any);
    get spriteAsset(): any;
    /**
     * The current sprite.
     *
     * @type {Sprite}
     */
    set sprite(arg: any);
    get sprite(): any;
    set material(arg: any);
    get material(): any;
    /**
     * The color tint of the sprite.
     *
     * @type {Color}
     */
    set color(arg: Color$4);
    get color(): Color$4;
    /**
     * The opacity of the sprite.
     *
     * @type {number}
     */
    set opacity(arg: number);
    get opacity(): number;
    /**
     * A dictionary that contains {@link SpriteAnimationClip}s.
     *
     * @type {Object.<string, SpriteAnimationClip>}
     */
    set clips(arg: {
        [x: string]: SpriteAnimationClip;
    });
    get clips(): {
        [x: string]: SpriteAnimationClip;
    };
    /**
     * The current clip being played.
     *
     * @type {SpriteAnimationClip}
     */
    get currentClip(): SpriteAnimationClip;
    /**
     * A global speed modifier used when playing sprite animation clips.
     *
     * @type {number}
     */
    set speed(arg: number);
    get speed(): number;
    /**
     * Flip the X axis when rendering a sprite.
     *
     * @type {boolean}
     */
    set flipX(arg: boolean);
    get flipX(): boolean;
    /**
     * Flip the Y axis when rendering a sprite.
     *
     * @type {boolean}
     */
    set flipY(arg: boolean);
    get flipY(): boolean;
    /**
     * The width of the sprite when rendering using 9-Slicing. The width and height are only used
     * when the render mode of the sprite asset is Sliced or Tiled.
     *
     * @type {number}
     */
    set width(arg: number);
    get width(): number;
    /**
     * The height of the sprite when rendering using 9-Slicing. The width and height are only used
     * when the render mode of the sprite asset is Sliced or Tiled.
     *
     * @type {number}
     */
    set height(arg: number);
    get height(): number;
    /**
     * Assign sprite to a specific batch group (see {@link BatchGroup}). Default is -1 (no group).
     *
     * @type {number}
     */
    set batchGroupId(arg: number);
    get batchGroupId(): number;
    /**
     * The name of the clip to play automatically when the component is enabled and the clip exists.
     *
     * @type {string}
     */
    set autoPlayClip(arg: any);
    get autoPlayClip(): any;
    /**
     * The draw order of the component. A higher value means that the component will be rendered on
     * top of other components in the same layer. This is not used unless the layer's sort order is
     * set to {@link SORTMODE_MANUAL}.
     *
     * @type {number}
     */
    set drawOrder(arg: number);
    get drawOrder(): number;
    /**
     * An array of layer IDs ({@link Layer#id}) to which this sprite should belong.
     *
     * @type {number[]}
     */
    set layers(arg: number[]);
    get layers(): number[];
    get aabb(): any;
    onDestroy(): void;
    _showModel(): void;
    _hideModel(): void;
    _showFrame(frame: any): void;
    _updateTransform(): void;
    _updateAabb(aabb: any): any;
    _tryAutoPlay(): void;
    _onLayersChanged(oldComp: any, newComp: any): void;
    _onLayerAdded(layer: any): void;
    _onLayerRemoved(layer: any): void;
    removeModelFromLayers(): void;
    /**
     * Creates and adds a new {@link SpriteAnimationClip} to the component's clips.
     *
     * @param {object} data - Data for the new animation clip.
     * @param {string} [data.name] - The name of the new animation clip.
     * @param {number} [data.fps] - Frames per second for the animation clip.
     * @param {object} [data.loop] - Whether to loop the animation clip.
     * @param {number|Asset} [data.spriteAsset] - The asset id or the {@link Asset} of the sprite
     * that this clip will play.
     * @returns {SpriteAnimationClip} The new clip that was added.
     */
    addClip(data: {
        name?: string;
        fps?: number;
        loop?: object;
        spriteAsset?: number | Asset$5;
    }): SpriteAnimationClip;
    /**
     * Removes a clip by name.
     *
     * @param {string} name - The name of the animation clip to remove.
     */
    removeClip(name: string): void;
    /**
     * Get an animation clip by name.
     *
     * @param {string} name - The name of the clip.
     * @returns {SpriteAnimationClip} The clip.
     */
    clip(name: string): SpriteAnimationClip;
    /**
     * Plays a sprite animation clip by name. If the animation clip is already playing then this
     * will do nothing.
     *
     * @param {string} name - The name of the clip to play.
     * @returns {SpriteAnimationClip} The clip that started playing.
     */
    play(name: string): SpriteAnimationClip;
    /**
     * Pauses the current animation clip.
     */
    pause(): void;
    /**
     * Resumes the current paused animation clip.
     */
    resume(): void;
    /**
     * Stops the current animation clip and resets it to the first frame.
     */
    stop(): void;
}

type SoundManager$8 = SoundManager$7;
/** @typedef {import('./manager.js').SoundManager} SoundManager */
/**
 * Represents an audio listener - used internally.
 *
 * @ignore
 */
declare class Listener {
    /**
     * Create a new listener instance.
     *
     * @param {SoundManager} manager - The sound manager.
     */
    constructor(manager: SoundManager$8);
    _manager: SoundManager$7;
    position: Vec3$1;
    velocity: Vec3$1;
    orientation: Mat4$5;
    getPosition(): Vec3$1;
    setPosition(position: any): void;
    getVelocity(): Vec3$1;
    setVelocity(velocity: any): void;
    setOrientation(orientation: any): void;
    getOrientation(): Mat4$5;
    get listener(): any;
}

/**
 * The SoundManager is used to load and play audio. It also applies system-wide settings like
 * global volume, suspend and resume.
 *
 * @augments EventHandler
 */
declare class SoundManager$7 extends EventHandler$1 {
    /**
     * Create a new SoundManager instance.
     *
     * @param {object} [options] - Options options object.
     * @param {boolean} [options.forceWebAudioApi] - Always use the Web Audio API, even if check
     * indicates that it is not available.
     */
    constructor(options?: {
        forceWebAudioApi?: boolean;
    });
    _context: any;
    _forceWebAudioApi: boolean;
    _resumeContext: () => void;
    _unlock: () => void;
    listener: Listener;
    _volume: number;
    suspended: boolean;
    /**
     * Global volume for the manager. All {@link SoundInstance}s will scale their volume with this
     * volume. Valid between [0, 1].
     *
     * @type {number}
     */
    set volume(arg: number);
    get volume(): number;
    get context(): any;
    suspend(): void;
    resume(): void;
    destroy(): void;
    /**
     * Create a new {@link Channel} and begin playback of the sound.
     *
     * @param {Sound} sound - The Sound object to play.
     * @param {object} options - Optional options object.
     * @param {number} [options.volume] - The volume to playback at, between 0 and 1.
     * @param {boolean} [options.loop] - Whether to loop the sound when it reaches the end.
     * @returns {Channel} The channel playing the sound.
     * @private
     */
    private playSound;
    /**
     * Create a new {@link Channel3d} and begin playback of the sound at the position specified.
     *
     * @param {Sound} sound - The Sound object to play.
     * @param {Vec3} position - The position of the sound in 3D space.
     * @param {object} options - Optional options object.
     * @param {number} [options.volume] - The volume to playback at, between 0 and 1.
     * @param {boolean} [options.loop] - Whether to loop the sound when it reaches the end.
     * @returns {Channel3d} The 3D channel playing the sound.
     * @private
     */
    private playSound3d;
}

declare class SoundComponentData {
    enabled: boolean;
}

type SoundManager$6 = SoundManager$7;
type Application$g = Application$7;
/**
 * Manages creation of {@link SoundComponent}s.
 *
 * @augments ComponentSystem
 */
declare class SoundComponentSystem$2 extends ComponentSystem {
    /**
     * Create a SoundComponentSystem.
     *
     * @param {Application} app - The Application.
     * @param {SoundManager} manager - The sound manager.
     */
    constructor(app: Application$g, manager: SoundManager$6);
    id: string;
    ComponentType: typeof SoundComponent$1;
    DataType: typeof SoundComponentData;
    /**
     * Gets / sets the sound manager.
     *
     * @type {SoundManager}
     */
    manager: SoundManager$6;
    /**
     * Sets / gets the volume for the entire Sound system. All sounds will have their volume
     * multiplied by this value. Valid between [0, 1].
     *
     * @type {number}
     */
    set volume(arg: number);
    get volume(): number;
    /**
     * Gets the AudioContext currently used by the sound manager. Requires Web Audio API support.
     * Returns null if the device does not support the Web Audio API.
     *
     * @type {AudioContext|null}
     */
    get context(): AudioContext;
    onUpdate(dt: any): void;
    onBeforeRemove(entity: any, component: any): void;
}

/**
 * Represents the resource of an audio asset.
 *
 * @property {AudioBuffer} buffer If the Web Audio API is supported this contains the audio data.
 * @property {HTMLAudioElement} audio If the Web Audio API is not supported this contains the
 * audio data.
 * @property {number} duration Returns the duration of the sound. If the sound is not loaded it
 * returns 0.
 */
declare class Sound$3 {
    /**
     * Create a new Sound instance.
     *
     * @param {HTMLAudioElement|AudioBuffer} resource - If the Web Audio API is supported, pass an
     * AudioBuffer object, otherwise an Audio object.
     */
    constructor(resource: HTMLAudioElement | AudioBuffer);
    audio: HTMLAudioElement;
    buffer: AudioBuffer;
    get duration(): number;
}

type Sound$2 = Sound$3;
type SoundManager$5 = SoundManager$7;
/**
 * A SoundInstance plays a {@link Sound}.
 *
 * @property {number} volume The volume modifier to play the sound with. In range 0-1.
 * @property {number} pitch The pitch modifier to play the sound with. Must be larger than 0.01.
 * @property {number} currentTime Gets or sets the current time of the sound that is playing. If
 * the value provided is bigger than the duration of the instance it will wrap from the beginning.
 * @property {AudioBufferSourceNode} source Gets the source that plays the sound resource. If the
 * Web Audio API is not supported the type of source is
 * [Audio](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio). Source is only
 * available after calling play.
 * @property {Sound} sound The sound resource that the instance will play.
 * @augments EventHandler
 */
declare class SoundInstance$1 extends EventHandler$1 {
    /**
     * Create a new SoundInstance instance.
     *
     * @param {SoundManager} manager - The sound manager.
     * @param {Sound} sound - The sound to play.
     * @param {object} options - Options for the instance.
     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
     * @param {boolean} [options.loop=false] - Whether the sound should loop when it reaches the
     * end or not.
     * @param {number} [options.startTime=0] - The time from which the playback will start in
     * seconds. Default is 0 to start at the beginning.
     * @param {number} [options.duration=null] - The total time after the startTime in seconds when
     * playback will stop or restart if loop is true.
     * @param {Function} [options.onPlay=null] - Function called when the instance starts playing.
     * @param {Function} [options.onPause=null] - Function called when the instance is paused.
     * @param {Function} [options.onResume=null] - Function called when the instance is resumed.
     * @param {Function} [options.onStop=null] - Function called when the instance is stopped.
     * @param {Function} [options.onEnd=null] - Function called when the instance ends.
     */
    constructor(manager: SoundManager$5, sound: Sound$2, options: {
        volume?: number;
        pitch?: number;
        loop?: boolean;
        startTime?: number;
        duration?: number;
        onPlay?: Function;
        onPause?: Function;
        onResume?: Function;
        onStop?: Function;
        onEnd?: Function;
    });
    _manager: SoundManager$7;
    _volume: number;
    _pitch: number;
    _loop: boolean;
    _sound: Sound$3;
    _state: number;
    _suspended: boolean;
    _suspendEndEvent: boolean;
    _suspendInstanceEvents: boolean;
    _playWhenLoaded: boolean;
    _startTime: number;
    _duration: number;
    _startOffset: any;
    source: any;
    _onPlayCallback: Function;
    _onPauseCallback: Function;
    _onResumeCallback: Function;
    _onStopCallback: Function;
    _onEndCallback: Function;
    _startedAt: number;
    _currentTime: number;
    _currentOffset: number;
    _inputNode: any;
    _connectorNode: any;
    _firstNode: any;
    _lastNode: any;
    _endedHandler: any;
    _isReady: boolean;
    _loadedMetadataHandler: any;
    _timeUpdateHandler: any;
    /**
     * The duration of the sound that the instance will play starting from startTime.
     *
     * @type {number}
     */
    set duration(arg: number);
    get duration(): number;
    /**
     * Returns true if the instance is currently paused.
     *
     * @type {boolean}
     */
    get isPaused(): boolean;
    /**
     * Returns true if the instance is currently playing.
     *
     * @type {boolean}
     */
    get isPlaying(): boolean;
    /**
     * Returns true if the instance is currently stopped.
     *
     * @type {boolean}
     */
    get isStopped(): boolean;
    /**
     * Returns true if the instance is currently suspended because the window is not focused.
     *
     * @type {boolean}
     */
    get isSuspended(): boolean;
    /**
     * If true the instance will restart when it finishes playing.
     *
     * @type {boolean}
     */
    set loop(arg: boolean);
    get loop(): boolean;
    /**
     * The start time from which the sound will start playing.
     *
     * @type {number}
     */
    set startTime(arg: number);
    get startTime(): number;
    _onPlay(): void;
    _onPause(): void;
    _onResume(): void;
    _onStop(): void;
    _onEnded(): void;
    /**
     * Handle the manager's 'volumechange' event.
     *
     * @private
     */
    private _onManagerVolumeChange;
    set volume(arg: any);
    get volume(): any;
    /**
     * Handle the manager's 'suspend' event.
     *
     * @private
     */
    private _onManagerSuspend;
    /**
     * Handle the manager's 'resume' event.
     *
     * @private
     */
    private _onManagerResume;
    set pitch(arg: any);
    get pitch(): any;
    set sound(arg: any);
    get sound(): any;
    set currentTime(arg: any);
    get currentTime(): any;
}

type SoundComponent$2 = SoundComponent$1;
/**
 * The SoundSlot controls playback of an audio asset.
 *
 * @augments EventHandler
 */
declare class SoundSlot extends EventHandler$1 {
    /**
     * Create a new SoundSlot.
     *
     * @param {SoundComponent} component - The Component that created this slot.
     * @param {string} [name] - The name of the slot. Defaults to 'Untitled'.
     * @param {object} [options] - Settings for the slot.
     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
     * @param {boolean} [options.loop=false] - If true the sound will restart when it reaches the
     * end.
     * @param {number} [options.startTime=0] - The start time from which the sound will start
     * playing.
     * @param {number} [options.duration=null] - The duration of the sound that the slot will play
     * starting from startTime.
     * @param {boolean} [options.overlap=false] - If true then sounds played from slot will be
     * played independently of each other. Otherwise the slot will first stop the current sound
     * before starting the new one.
     * @param {boolean} [options.autoPlay=false] - If true the slot will start playing as soon as
     * its audio asset is loaded.
     * @param {number} [options.asset=null] - The asset id of the audio asset that is going to be
     * played by this slot.
     */
    constructor(component: SoundComponent$2, name?: string, options?: {
        volume?: number;
        pitch?: number;
        loop?: boolean;
        startTime?: number;
        duration?: number;
        overlap?: boolean;
        autoPlay?: boolean;
        asset?: number;
    });
    /**
     * The name of the slot.
     *
     * @type {string}
     */
    name: string;
    /**
     * An array that contains all the {@link SoundInstance}s currently being played by the slot.
     *
     * @type {SoundInstance[]}
     */
    instances: SoundInstance$1[];
    _component: SoundComponent$1;
    _assets: AssetRegistry$c;
    _manager: any;
    _volume: number;
    _pitch: number;
    _loop: boolean;
    _duration: number;
    _startTime: number;
    _overlap: boolean;
    _autoPlay: boolean;
    _firstNode: AudioNode;
    _lastNode: AudioNode;
    _asset: number;
    _onInstancePlayHandler: any;
    _onInstancePauseHandler: any;
    _onInstanceResumeHandler: any;
    _onInstanceStopHandler: any;
    _onInstanceEndHandler: any;
    /**
     * Plays a sound. If {@link SoundSlot#overlap} is true the new sound instance will be played
     * independently of any other instances already playing. Otherwise existing sound instances
     * will stop before playing the new sound.
     *
     * @returns {SoundInstance} The new sound instance.
     */
    play(): SoundInstance$1;
    /**
     * Pauses all sound instances. To continue playback call {@link SoundSlot#resume}.
     *
     * @returns {boolean} True if the sound instances paused successfully, false otherwise.
     */
    pause(): boolean;
    /**
     * Resumes playback of all paused sound instances.
     *
     * @returns {boolean} True if any instances were resumed.
     */
    resume(): boolean;
    /**
     * Stops playback of all sound instances.
     *
     * @returns {boolean} True if any instances were stopped.
     */
    stop(): boolean;
    /**
     * Loads the asset assigned to this slot.
     */
    load(): void;
    /**
     * Connect external Web Audio API nodes. Any sound played by this slot will automatically
     * attach the specified nodes to the source that plays the sound. You need to pass the first
     * node of the node graph that you created externally and the last node of that graph. The
     * first node will be connected to the audio source and the last node will be connected to the
     * destination of the AudioContext (e.g. speakers).
     *
     * @param {AudioNode} firstNode - The first node that will be connected to the audio source of
     * sound instances.
     * @param {AudioNode} [lastNode] - The last node that will be connected to the destination of
     * the AudioContext. If unspecified then the firstNode will be connected to the destination
     * instead.
     * @example
     * var context = app.systems.sound.context;
     * var analyzer = context.createAnalyzer();
     * var distortion = context.createWaveShaper();
     * var filter = context.createBiquadFilter();
     * analyzer.connect(distortion);
     * distortion.connect(filter);
     * slot.setExternalNodes(analyzer, filter);
     */
    setExternalNodes(firstNode: AudioNode, lastNode?: AudioNode): void;
    /**
     * Clears any external nodes set by {@link SoundSlot#setExternalNodes}.
     */
    clearExternalNodes(): void;
    /**
     * Gets an array that contains the two external nodes set by {@link SoundSlot#setExternalNodes}.
     *
     * @returns {AudioNode[]} An array of 2 elements that contains the first and last nodes set by
     * {@link SoundSlot#setExternalNodes}.
     */
    getExternalNodes(): AudioNode[];
    /**
     * Reports whether an asset is set on this slot.
     *
     * @returns {boolean} Returns true if the slot has an asset assigned.
     * @private
     */
    private _hasAsset;
    /**
     * Creates a new {@link SoundInstance} with the properties of the slot.
     *
     * @returns {SoundInstance} The new instance.
     * @private
     */
    private _createInstance;
    _onInstancePlay(instance: any): void;
    _onInstancePause(instance: any): void;
    _onInstanceResume(instance: any): void;
    _onInstanceStop(instance: any): void;
    _onInstanceEnd(instance: any): void;
    _onAssetAdd(asset: any): void;
    _onAssetLoad(asset: any): void;
    _onAssetRemoved(asset: any): void;
    updatePosition(position: any): void;
    /**
     * The asset id.
     *
     * @type {number|null}
     */
    set asset(arg: number);
    get asset(): number;
    /**
     * If true the slot will begin playing as soon as it is loaded.
     *
     * @type {boolean}
     */
    set autoPlay(arg: boolean);
    get autoPlay(): boolean;
    /**
     * The duration of the sound that the slot will play starting from startTime.
     *
     * @type {number}
     */
    set duration(arg: number);
    get duration(): number;
    /**
     * Returns true if the asset of the slot is loaded.
     *
     * @type {boolean}
     */
    get isLoaded(): boolean;
    /**
     * Returns true if the slot is currently paused.
     *
     * @type {boolean}
     */
    get isPaused(): boolean;
    /**
     * Returns true if the slot is currently playing.
     *
     * @type {boolean}
     */
    get isPlaying(): boolean;
    /**
     * Returns true if the slot is currently stopped.
     *
     * @type {boolean}
     */
    get isStopped(): boolean;
    /**
     * If true the slot will restart when it finishes playing.
     *
     * @type {boolean}
     */
    set loop(arg: boolean);
    get loop(): boolean;
    /**
     * If true then sounds played from slot will be played independently of each other. Otherwise
     * the slot will first stop the current sound before starting the new one.
     *
     * @type {boolean}
     */
    set overlap(arg: boolean);
    get overlap(): boolean;
    /**
     * The pitch modifier to play the sound with. Must be larger than 0.01.
     *
     * @type {number}
     */
    set pitch(arg: number);
    get pitch(): number;
    /**
     * The start time from which the sound will start playing.
     *
     * @type {number}
     */
    set startTime(arg: number);
    get startTime(): number;
    /**
     * The volume modifier to play the sound with. In range 0-1.
     *
     * @type {number}
     */
    set volume(arg: number);
    get volume(): number;
}

type Entity$q = Entity$a;
type SoundInstance = SoundInstance$1;
type SoundComponentSystem$1 = SoundComponentSystem$2;
/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('../../../sound/instance.js').SoundInstance} SoundInstance */
/** @typedef {import('./system.js').SoundComponentSystem} SoundComponentSystem */
/**
 * The Sound Component controls playback of {@link Sound}s.
 *
 * @augments Component
 */
declare class SoundComponent$1 extends Component$2 {
    /**
     * Create a new Sound Component.
     *
     * @param {SoundComponentSystem} system - The ComponentSystem that created this component.
     * @param {Entity} entity - The entity that the Component is attached to.
     */
    constructor(system: SoundComponentSystem$1, entity: Entity$q);
    /** @private */
    private _volume;
    /** @private */
    private _pitch;
    /** @private */
    private _positional;
    /** @private */
    private _refDistance;
    /** @private */
    private _maxDistance;
    /** @private */
    private _rollOffFactor;
    /** @private */
    private _distanceModel;
    /**
     * @type {Object.<string, SoundSlot>}
     * @private
     */
    private _slots;
    /** @private */
    private _playingBeforeDisable;
    /**
     * Update the specified property on all sound instances.
     *
     * @param {string} property - The name of the SoundInstance property to update.
     * @param {string|number} value - The value to set the property to.
     * @param {boolean} isFactor - True if the value is a factor of the slot property or false
     * if it is an absolute value.
     * @private
     */
    private _updateSoundInstances;
    /**
     * Determines which algorithm to use to reduce the volume of the sound as it moves away from
     * the listener. Can be:
     *
     * - {@link DISTANCE_LINEAR}
     * - {@link DISTANCE_INVERSE}
     * - {@link DISTANCE_EXPONENTIAL}
     *
     * Defaults to {@link DISTANCE_LINEAR}.
     *
     * @type {string}
     */
    set distanceModel(arg: string);
    get distanceModel(): string;
    /**
     * The maximum distance from the listener at which audio falloff stops. Note the volume of the
     * audio is not 0 after this distance, but just doesn't fall off anymore. Defaults to 10000.
     *
     * @type {number}
     */
    set maxDistance(arg: number);
    get maxDistance(): number;
    /**
     * The reference distance for reducing volume as the sound source moves further from the
     * listener. Defaults to 1.
     *
     * @type {number}
     */
    set refDistance(arg: number);
    get refDistance(): number;
    /**
     * The factor used in the falloff equation. Defaults to 1.
     *
     * @type {number}
     */
    set rollOffFactor(arg: number);
    get rollOffFactor(): number;
    /**
     * The pitch modifier to play the audio with. Must be larger than 0.01. Defaults to 1.
     *
     * @type {number}
     */
    set pitch(arg: number);
    get pitch(): number;
    /**
     * The volume modifier to play the audio with. In range 0-1. Defaults to 1.
     *
     * @type {number}
     */
    set volume(arg: number);
    get volume(): number;
    /**
     * If true the audio will play back at the location of the Entity in space, so the audio will
     * be affected by the position of the {@link AudioListenerComponent}. Defaults to true.
     *
     * @type {boolean}
     */
    set positional(arg: boolean);
    get positional(): boolean;
    /**
     * A dictionary that contains the {@link SoundSlot}s managed by this SoundComponent.
     *
     * @type {Object.<string, SoundSlot>}
     */
    set slots(arg: {
        [x: string]: SoundSlot;
    });
    get slots(): {
        [x: string]: SoundSlot;
    };
    onRemove(): void;
    /**
     * Creates a new {@link SoundSlot} with the specified name.
     *
     * @param {string} name - The name of the slot.
     * @param {object} [options] - Settings for the slot.
     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
     * @param {boolean} [options.loop=false] - If true the sound will restart when it reaches the end.
     * @param {number} [options.startTime=0] - The start time from which the sound will start playing.
     * @param {number} [options.duration=null] - The duration of the sound that the slot will play
     * starting from startTime.
     * @param {boolean} [options.overlap=false] - If true then sounds played from slot will be
     * played independently of each other. Otherwise the slot will first stop the current sound
     * before starting the new one.
     * @param {boolean} [options.autoPlay=false] - If true the slot will start playing as soon as
     * its audio asset is loaded.
     * @param {number} [options.asset=null] - The asset id of the audio asset that is going to be
     * played by this slot.
     * @returns {SoundSlot|null} The new slot or null if the slot already exists.
     * @example
     * // get an asset by id
     * var asset = app.assets.get(10);
     * // add a slot
     * this.entity.sound.addSlot('beep', {
     *     asset: asset
     * });
     * // play
     * this.entity.sound.play('beep');
     */
    addSlot(name: string, options?: {
        volume?: number;
        pitch?: number;
        loop?: boolean;
        startTime?: number;
        duration?: number;
        overlap?: boolean;
        autoPlay?: boolean;
        asset?: number;
    }): SoundSlot | null;
    /**
     * Removes the {@link SoundSlot} with the specified name.
     *
     * @param {string} name - The name of the slot.
     * @example
     * // remove a slot called 'beep'
     * this.entity.sound.removeSlot('beep');
     */
    removeSlot(name: string): void;
    /**
     * Returns the slot with the specified name.
     *
     * @param {string} name - The name of the slot.
     * @returns {SoundSlot} The slot.
     * @example
     * // get a slot and set its volume
     * this.entity.sound.slot('beep').volume = 0.5;
     *
     */
    slot(name: string): SoundSlot;
    /**
     * Begins playing the sound slot with the specified name. The slot will restart playing if it
     * is already playing unless the overlap field is true in which case a new sound will be
     * created and played.
     *
     * @param {string} name - The name of the {@link SoundSlot} to play.
     * @returns {SoundInstance|null} The sound instance that will be played. Returns null if the
     * component or its parent entity is disabled or if the SoundComponent has no slot with the
     * specified name.
     * @example
     * // get asset by id
     * var asset = app.assets.get(10);
     * // create a slot and play it
     * this.entity.sound.addSlot('beep', {
     *     asset: asset
     * });
     * this.entity.sound.play('beep');
     */
    play(name: string): SoundInstance | null;
    /**
     * Pauses playback of the slot with the specified name. If the name is undefined then all slots
     * currently played will be paused. The slots can be resumed by calling {@link SoundComponent#resume}.
     *
     * @param {string} [name] - The name of the slot to pause. Leave undefined to pause everything.
     * @example
     * // pause all sounds
     * this.entity.sound.pause();
     * // pause a specific sound
     * this.entity.sound.pause('beep');
     */
    pause(name?: string): void;
    /**
     * Resumes playback of the sound slot with the specified name if it's paused. If no name is
     * specified all slots will be resumed.
     *
     * @param {string} [name] - The name of the slot to resume. Leave undefined to resume everything.
     * @example
     * // resume all sounds
     * this.entity.sound.resume();
     * // resume a specific sound
     * this.entity.sound.resume('beep');
     */
    resume(name?: string): void;
    /**
     * Stops playback of the sound slot with the specified name if it's paused. If no name is
     * specified all slots will be stopped.
     *
     * @param {string} [name] - The name of the slot to stop. Leave undefined to stop everything.
     * @example
     * // stop all sounds
     * this.entity.sound.stop();
     * // stop a specific sound
     * this.entity.sound.stop('beep');
     */
    stop(name?: string): void;
}

declare class ScrollViewComponentData {
    enabled: boolean;
}

/**
 * Manages creation of {@link ScrollViewComponent}s.
 *
 * @augments ComponentSystem
 */
declare class ScrollViewComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof ScrollViewComponent$1;
    DataType: typeof ScrollViewComponentData;
    onUpdate(dt: any): void;
    _onRemoveComponent(entity: any, component: any): void;
}

/**
 * An EntityReference can be used in scenarios where a component has one or more properties that
 * refer to entities in the scene graph. Using an EntityReference simplifies the job of dealing
 * with the presence or non-presence of the underlying entity and its components, especially when
 * it comes to dealing with the runtime addition or removal of components, and addition/removal of
 * associated event listeners.
 *
 * ## Usage Scenario ##
 *
 * Imagine that you're creating a Checkbox component, which has a reference to an entity
 * representing the checkmark/tickmark that is rendered in the Checkbox. The reference is modeled
 * as an entity guid property on the Checkbox component, called simply 'checkmark'. We have to
 * implement a basic piece of functionality whereby when the 'checkmark' entity reference is set,
 * the Checkbox component must toggle the tint of an ImageElementComponent present on the checkmark
 * entity to indicate whether the Checkbox is currently in the active or inactive state.
 *
 * Without using an EntityReference, the Checkbox component must implement some or all of the
 * following:
 *
 * - Listen for its 'checkmark' property being set to a valid guid, and retrieve a reference to the
 *   entity associated with this guid whenever it changes (i.e. via `app.root.findByGuid()`).
 * - Once a valid entity is received, check to see whether it has already has an
 *   ImageElementComponent or not:
 *   - If it has one, proceed to set the tint of the ImageElementComponent based on whether the
 *     Checkbox is currently active or inactive.
 *   - If it doesn't have one, add a listener to wait for the addition of an ImageElementComponent,
 *     and then apply the tint once one becomes present.
 * - If the checkmark entity is then reassigned (such as if the user reassigns the field in the
 *   editor, or if this is done at runtime via a script), a well-behaved Checkbox component must
 *   also undo the tinting so that no lasting effect is applied to the old entity.
 * - If the checkmark entity's ImageElementComponent is removed and then another
 *   ImageElementComponent is added, the Checkbox component must handle this in order to re-apply
 *   the tint.
 * - To prevent memory leaks, the Checkbox component must also make sure to correctly remove
 *   listeners in each of the following scenarios:
 *   - Destruction of the Checkbox component.
 *   - Reassignment of the checkmark entity.
 *   - Removal of the ImageElementComponent.
 * - It must also be careful not to double-add listeners in any of the above code paths, to avoid
 *   various forms of undesirable behavior.
 *
 * If the Checkbox component becomes more complicated and has multiple entity reference properties,
 * all of the above must be done correctly for each entity. Similarly, if it depends on multiple
 * different component types being present on the entities it has references to, it must correctly
 * handle the presence and non-presence of each of these components in the various possible
 * sequences of addition and removal. In addition to generating a lot of boilerplate, it's also
 * very easy for subtle mistakes to be made that lead to memory leaks, null reference errors or
 * visual bugs.
 *
 * By using an EntityReference, all of the above can be reduced to the following:
 *
 * ```javascript
 * function CheckboxComponent() {
 *    this._checkmarkReference = new pc.EntityReference(this, 'checkmark', {
 *        'element#gain': this._onCheckmarkImageElementGain,
 *        'element#lose': this._onCheckmarkImageElementLose
 *    });
 * }
 * ```
 *
 * Using the above code snippet, the `_onCheckmarkImageElementGain()` listener will be called
 * in either of the following scenarios:
 *
 * 1. A checkmark entity is assigned and already has an ElementComponent.
 * 2. A checkmark entity is assigned that does not have an ElementComponent, but one is added
 * later.
 *
 * Similarly, the `_onCheckmarkImageElementLose()` listener will be called in either of the
 * following scenarios:
 *
 * 1. An ElementComponent is removed from the checkmark entity.
 * 2. The checkmark entity is re-assigned (i.e. to another entity), or nullified. In this
 * scenario the callback will only be called if the entity actually had an ElementComponent.
 *
 * ## Event String Format ##
 *
 * The event string (i.e. "element#gain" in the above examples) is of the format
 * `sourceName#eventName`, and is defined as follows:
 *
 * - `sourceName`: May be any component name, or the special string "entity", which refers to the
 * entity itself.
 * - `eventName`: May be the name of any event dispatched by the relevant component or entity, as
 * well as the special strings "gain" or "lose".
 *
 * Some examples are as follows:
 *
 * ```javascript
 * "entity#destroy"    // Called when the entity managed by the entity reference is destroyed.
 * "element#set:width" // Called when the width of an ElementComponent is set.
 * ```
 *
 * When the entity reference changes to another entity (or null) the set:entity event is fired.
 *
 * ## Ownership and Destruction ##
 *
 * The lifetime of an ElementReference is tied to the parent component that instantiated it. This
 * coupling is indicated by the provision of the `this` keyword to the ElementReference's
 * constructor in the above examples (i.e. `new pc.EntityReference(this, ...`).
 *
 * Any event listeners managed by the ElementReference are automatically cleaned up when the parent
 * component is removed or the parent component's entity is destroyed  as such you should never
 * have to worry about dangling listeners.
 *
 * Additionally, any callbacks listed in the event config will automatically be called in the scope
 * of the parent component  you should never have to worry about manually calling
 * `Function.bind()`.
 *
 * @property {Entity} entity A reference to the entity, if present.
 * @augments EventHandler
 * @ignore
 */
declare class EntityReference extends EventHandler$1 {
    /**
     * Helper class used for managing component properties that represent entity references.
     *
     * @param {Component} parentComponent - A reference to the parent component that owns this
     * entity reference.
     * @param {string} entityPropertyName - The name of the component property that contains the
     * entity guid.
     * @param {object<string, Function>} [eventConfig] - A map of event listener configurations.
     */
    constructor(parentComponent: Component$2, entityPropertyName: string, eventConfig: any);
    _parentComponent: Component$2;
    _entityPropertyName: string;
    _entity: Entity$a;
    _app: Application$7;
    _configureEventListeners(externalEventConfig: any, internalEventConfig: any): void;
    _eventListenerConfigs: {
        id: string;
        sourceName: string;
        eventName: string;
        callback: any;
        scope: any;
    }[];
    _listenerStatusFlags: {};
    _gainListeners: {};
    _loseListeners: {};
    _parseEventListenerConfig(eventConfig: any, prefix: any, scope: any): {
        id: string;
        sourceName: string;
        eventName: string;
        callback: any;
        scope: any;
    }[];
    _toggleLifecycleListeners(onOrOff: any): void;
    _onSetEntity(name: any, oldValue: any, newValue: any): void;
    /**
     * Must be called from the parent component's onEnable() method in order for entity references
     * to be correctly resolved when {@link Entity#clone} is called.
     *
     * @private
     */
    private onParentComponentEnable;
    _onSceneLoaded(): void;
    _updateEntityReference(): void;
    _onBeforeEntityChange(): void;
    _onAfterEntityChange(): void;
    _onComponentAdd(entity: any, component: any): void;
    _onComponentRemove(entity: any, component: any): void;
    _callAllGainOrLoseListeners(listenerMap: any): void;
    _callGainOrLoseListener(componentName: any, listenerMap: any): void;
    _toggleEntityListeners(onOrOff: any, isDestroying: any): void;
    _toggleComponentListeners(onOrOff: any, componentName: any, isDestroying: any): void;
    _safeToggleListener(onOrOff: any, config: any, isDestroying: any): void;
    _getEventSource(sourceName: any, isDestroying: any): any;
    _onEntityDestroy(entity: any): void;
    _onParentComponentRemove(entity: any, component: any): void;
    /**
     * Convenience method indicating whether the entity exists and has a component of the provided
     * type.
     *
     * @param {string} componentName - Name of the component.
     * @returns {boolean} True if the entity exists and has a component of the provided type.
     * @private
     */
    private hasComponent;
    get entity(): Entity$a;
}

declare class ElementComponentData {
    enabled: boolean;
}

declare class StandardMaterialOptionsBuilder {
    _mapXForms: any[];
    updateMinRef(options: any, device: any, scene: any, stdMat: any, objDefs: any, staticLightList: any, pass: any, sortedLights: any): void;
    updateRef(options: any, device: any, scene: any, stdMat: any, objDefs: any, staticLightList: any, pass: any, sortedLights: any): void;
    _updateSharedOptions(options: any, scene: any, stdMat: any, objDefs: any, pass: any): void;
    _updateUVOptions(options: any, stdMat: any, objDefs: any, minimalOptions: any): void;
    _updateMinOptions(options: any, stdMat: any): void;
    _updateMaterialOptions(options: any, stdMat: any): void;
    _updateEnvOptions(options: any, device: any, stdMat: any, scene: any): void;
    _updateLightOptions(options: any, stdMat: any, objDefs: any, sortedLights: any, staticLightList: any): void;
    _updateTexOptions(options: any, stdMat: any, p: any, hasUv0: any, hasUv1: any, hasVcolor: any, minimalOptions: any): any;
    _collectLights(lType: any, lights: any, lightsFiltered: any, mask: any, staticLightList: any): void;
    _getMapTransformID(xform: any, uv: any): any;
}

type Texture$4 = Texture$8;
type Color$3 = Color$4;
type Vec2$1 = Vec2$3;
type BoundingBox = BoundingBox$1;
/**
 * Callback used by {@link StandardMaterialonUpdateShader }.
 */
type updateShaderCallback = (options: any) => any;
/**
 * Callback used by {@link StandardMaterial#onUpdateShader}.
 *
 * @callback updateShaderCallback
 * @param {*} options - An object with shader generator settings (based on current material and
 * scene properties), that you can change and then return. Properties of the object passed into
 * this function are documented in {@link StandardMaterial#onUpdateShader}.
 * @returns {*} Returned settings will be used by the shader.
 */
/**
 * A Standard material is the main, general purpose material that is most often used for rendering.
 * It can approximate a wide variety of surface types and can simulate dynamic reflected light.
 * Most maps can use 3 types of input values in any combination: constant (color or number), mesh
 * vertex colors and a texture. All enabled inputs are multiplied together.
 *
 * @property {Color} ambient The ambient color of the material. This color value is 3-component
 * (RGB), where each component is between 0 and 1.
 * @property {Color} diffuse The diffuse color of the material. This color value is 3-component
 * (RGB), where each component is between 0 and 1. Defines basic surface color (aka albedo).
 * @property {boolean} diffuseTint Multiply main (primary) diffuse map and/or diffuse vertex color
 * by the constant diffuse value.
 * @property {Texture|null} diffuseMap The main (primary) diffuse map of the material (default is
 * null).
 * @property {number} diffuseMapUv Main (primary) diffuse map UV channel.
 * @property {Vec2} diffuseMapTiling Controls the 2D tiling of the main (primary) diffuse map.
 * @property {Vec2} diffuseMapOffset Controls the 2D offset of the main (primary) diffuse map. Each
 * component is between 0 and 1.
 * @property {number} diffuseMapRotation Controls the 2D rotation (in degrees) of the main
 * (primary) diffuse map.
 * @property {string} diffuseMapChannel Color channels of the main (primary) diffuse map to use.
 * Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
 * @property {boolean} diffuseVertexColor Use mesh vertex colors for diffuse. If diffuseMap or are
 * diffuseTint are set, they'll be multiplied by vertex colors.
 * @property {string} diffuseVertexColorChannel Vertex color channels to use for diffuse. Can be
 * "r", "g", "b", "a", "rgb" or any swizzled combination.
 * @property {Texture|null} diffuseDetailMap The detail (secondary) diffuse map of the material
 * (default is null). Will only be used if main (primary) diffuse map is non-null.
 * @property {number} diffuseDetailMapUv Detail (secondary) diffuse map UV channel.
 * @property {Vec2} diffuseDetailMapTiling Controls the 2D tiling of the detail (secondary) diffuse
 * map.
 * @property {Vec2} diffuseDetailMapOffset Controls the 2D offset of the detail (secondary) diffuse
 * map. Each component is between 0 and 1.
 * @property {number} diffuseDetailMapRotation Controls the 2D rotation (in degrees) of the main
 * (secondary) diffuse map.
 * @property {string} diffuseDetailMapChannel Color channels of the detail (secondary) diffuse map
 * to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
 * @property {string} diffuseDetailMode Determines how the main (primary) and detail (secondary)
 * diffuse maps are blended together. Can be:
 *
 * - {@link DETAILMODE_MUL}: Multiply together the primary and secondary colors.
 * - {@link DETAILMODE_ADD}: Add together the primary and secondary colors.
 * - {@link DETAILMODE_SCREEN}: Softer version of {@link DETAILMODE_ADD}.
 * - {@link DETAILMODE_OVERLAY}: Multiplies or screens the colors, depending on the primary color.
 * - {@link DETAILMODE_MIN}: Select whichever of the primary and secondary colors is darker,
 * component-wise.
 * - {@link DETAILMODE_MAX}: Select whichever of the primary and secondary colors is lighter,
 * component-wise.
 *
 * Defaults to {@link DETAILMODE_MUL}.
 * @property {Color} specular The specular color of the material. This color value is 3-component
 * (RGB), where each component is between 0 and 1. Defines surface reflection/specular color.
 * Affects specular intensity and tint.
 * @property {boolean} specularTint Multiply specular map and/or specular vertex color by the
 * constant specular value.
 * @property {Texture|null} specularMap The specular map of the material (default is null).
 * @property {number} specularMapUv Specular map UV channel.
 * @property {Vec2} specularMapTiling Controls the 2D tiling of the specular map.
 * @property {Vec2} specularMapOffset Controls the 2D offset of the specular map. Each component is
 * between 0 and 1.
 * @property {number} specularMapRotation Controls the 2D rotation (in degrees) of the specular map.
 * @property {string} specularMapChannel Color channels of the specular map to use. Can be "r", "g",
 * "b", "a", "rgb" or any swizzled combination.
 * @property {boolean} specularVertexColor Use mesh vertex colors for specular. If specularMap or
 * are specularTint are set, they'll be multiplied by vertex colors.
 * @property {string} specularVertexColorChannel Vertex color channels to use for specular. Can be
 * "r", "g", "b", "a", "rgb" or any swizzled combination.
 * @property {boolean} enableGGXSpecular Enables GGX specular. Also enables
 * {@link StandardMaterial#anisotropy}  parameter to set material anisotropy.
 * @property {number} anisotropy Defines amount of anisotropy. Requires
 * {@link StandardMaterial#enableGGXSpecular} is set to true.
 *
 * - When anisotropy == 0, specular is isotropic.
 * - When anisotropy < 0, anisotropy direction aligns with the tangent, and specular anisotropy
 * increases as the anisotropy value decreases to minimum of -1.
 * - When anisotropy > 0, anisotropy direction aligns with the bi-normal, and specular anisotropy
 * increases as anisotropy value increases to maximum of 1.
 *
 * @property {number} clearCoat Defines intensity of clear coat layer from 0 to 1. Clear coat layer
 * is disabled when clearCoat == 0. Default value is 0 (disabled).
 * @property {Texture|null} clearCoatMap Monochrome clear coat intensity map (default is null). If
 * specified, will be multiplied by normalized 'clearCoat' value and/or vertex colors.
 * @property {number} clearCoatMapUv Clear coat intensity map UV channel.
 * @property {Vec2} clearCoatMapTiling Controls the 2D tiling of the clear coat intensity map.
 * @property {Vec2} clearCoatMapOffset Controls the 2D offset of the clear coat intensity map. Each
 * component is between 0 and 1.
 * @property {number} clearCoatMapRotation Controls the 2D rotation (in degrees) of the clear coat
 * intensity map.
 * @property {string} clearCoatMapChannel Color channel of the clear coat intensity map to use. Can
 * be "r", "g", "b" or "a".
 * @property {boolean} clearCoatVertexColor Use mesh vertex colors for clear coat intensity. If
 * clearCoatMap is set, it'll be multiplied by vertex colors.
 * @property {string} clearCoatVertexColorChannel Vertex color channel to use for clear coat
 * intensity. Can be "r", "g", "b" or "a".
 * @property {number} clearCoatGlossiness Defines the clear coat glossiness of the clear coat layer
 * from 0 (rough) to 1 (mirror).
 * @property {Texture|null} clearCoatGlossMap Monochrome clear coat glossiness map (default is
 * null). If specified, will be multiplied by normalized 'clearCoatGlossiness' value and/or vertex
 * colors.
 * @property {number} clearCoatGlossMapUv Clear coat gloss map UV channel.
 * @property {Vec2} clearCoatGlossMapTiling Controls the 2D tiling of the clear coat gloss map.
 * @property {Vec2} clearCoatGlossMapOffset Controls the 2D offset of the clear coat gloss map.
 * Each component is between 0 and 1.
 * @property {number} clearCoatGlossMapRotation Controls the 2D rotation (in degrees) of the clear
 * coat gloss map.
 * @property {string} clearCoatGlossMapChannel Color channel of the clear coat gloss map to use.
 * Can be "r", "g", "b" or "a".
 * @property {boolean} clearCoatGlossVertexColor Use mesh vertex colors for clear coat glossiness.
 * If clearCoatGlossMap is set, it'll be multiplied by vertex colors.
 * @property {string} clearCoatGlossVertexColorChannel Vertex color channel to use for clear coat
 * glossiness. Can be "r", "g", "b" or "a".
 * @property {Texture|null} clearCoatNormalMap The clear coat normal map of the material (default
 * is null). The texture must contains normalized, tangent space normals.
 * @property {number} clearCoatNormalMapUv Clear coat normal map UV channel.
 * @property {Vec2} clearCoatNormalMapTiling Controls the 2D tiling of the main clear coat normal
 * map.
 * @property {Vec2} clearCoatNormalMapOffset Controls the 2D offset of the main clear coat normal
 * map. Each component is between 0 and 1.
 * @property {number} clearCoatNormalMapRotation Controls the 2D rotation (in degrees) of the main
 * clear coat map.
 * @property {number} clearCoatBumpiness The bumpiness of the clear coat layer. This value scales
 * the assigned main clear coat normal map. It should be normally between 0 (no bump mapping) and 1
 * (full bump mapping), but can be set to e.g. 2 to give even more pronounced bump effect.
 * @property {boolean} useMetalness Use metalness properties instead of specular. When enabled,
 * diffuse colors also affect specular instead of the dedicated specular map. This can be used as
 * alternative to specular color to save space. With metaless == 0, the pixel is assumed to be
 * dielectric, and diffuse color is used as normal. With metaless == 1, the pixel is fully
 * metallic, and diffuse color is used as specular color instead.
 * @property {number} metalness Defines how much the surface is metallic. From 0 (dielectric) to 1
 * (metal).
 * @property {Texture|null} metalnessMap Monochrome metalness map (default is null).
 * @property {number} metalnessMapUv Metalness map UV channel.
 * @property {Vec2} metalnessMapTiling Controls the 2D tiling of the metalness map.
 * @property {Vec2} metalnessMapOffset Controls the 2D offset of the metalness map. Each component
 * is between 0 and 1.
 * @property {number} metalnessMapRotation Controls the 2D rotation (in degrees) of the metalness
 * map.
 * @property {string} metalnessMapChannel Color channel of the metalness map to use. Can be "r",
 * "g", "b" or "a".
 * @property {boolean} metalnessVertexColor Use mesh vertex colors for metalness. If metalnessMap
 * is set, it'll be multiplied by vertex colors.
 * @property {string} metalnessVertexColorChannel Vertex color channel to use for metalness. Can be
 * "r", "g", "b" or "a".
 * @property {number} shininess Defines glossiness of the material from 0 (rough) to 100 (shiny
 * mirror). A higher shininess value results in a more focused specular highlight. Glossiness map/
 * vertex colors are always multiplied by this value (normalized to 0 - 1 range), or it is used
 * directly as constant output.
 * @property {Texture|null} glossMap Glossiness map (default is null). If specified, will be
 * multiplied by normalized 'shininess' value and/or vertex colors.
 * @property {number} glossMapUv Gloss map UV channel.
 * @property {string} glossMapChannel Color channel of the gloss map to use. Can be "r", "g", "b"
 * or "a".
 * @property {Vec2} glossMapTiling Controls the 2D tiling of the gloss map.
 * @property {Vec2} glossMapOffset Controls the 2D offset of the gloss map. Each component is
 * between 0 and 1.
 * @property {number} glossMapRotation Controls the 2D rotation (in degrees) of the gloss map.
 * @property {boolean} glossVertexColor Use mesh vertex colors for glossiness. If glossMap is set,
 * it'll be multiplied by vertex colors.
 * @property {string} glossVertexColorChannel Vertex color channel to use for glossiness. Can be
 * "r", "g", "b" or "a".
 * @property {number} refraction Defines the visibility of refraction. Material can refract the
 * same cube map as used for reflections.
 * @property {number} refractionIndex Defines the index of refraction, i.e. The amount of
 * distortion. The value is calculated as (outerIor / surfaceIor), where inputs are measured
 * indices of refraction, the one around the object and the one of its own surface. In most
 * situations outer medium is air, so outerIor will be approximately 1. Then you only need to do
 * (1.0 / surfaceIor).
 * @property {Color} emissive The emissive color of the material. This color value is 3-component
 * (RGB), where each component is between 0 and 1.
 * @property {boolean} emissiveTint Multiply emissive map and/or emissive vertex color by the
 * constant emissive value.
 * @property {Texture|null} emissiveMap The emissive map of the material (default is null). Can be
 * HDR.
 * @property {number} emissiveIntensity Emissive color multiplier.
 * @property {number} emissiveMapUv Emissive map UV channel.
 * @property {Vec2} emissiveMapTiling Controls the 2D tiling of the emissive map.
 * @property {Vec2} emissiveMapOffset Controls the 2D offset of the emissive map. Each component is
 * between 0 and 1.
 * @property {number} emissiveMapRotation Controls the 2D rotation (in degrees) of the emissive
 * map.
 * @property {string} emissiveMapChannel Color channels of the emissive map to use. Can be "r",
 * "g", "b", "a", "rgb" or any swizzled combination.
 * @property {boolean} emissiveVertexColor Use mesh vertex colors for emission. If emissiveMap or
 * emissiveTint are set, they'll be multiplied by vertex colors.
 * @property {string} emissiveVertexColorChannel Vertex color channels to use for emission. Can be
 * "r", "g", "b", "a", "rgb" or any swizzled combination.
 * @property {number} opacity The opacity of the material. This value can be between 0 and 1, where
 * 0 is fully transparent and 1 is fully opaque. If you want the material to be semi-transparent
 * you also need to set the {@link Material#blendType} to {@link BLEND_NORMAL},
 * {@link BLEND_ADDITIVE} or any other mode. Also note that for most semi-transparent objects you
 * want {@link Material#depthWrite} to be false, otherwise they can fully occlude objects behind
 * them.
 * @property {Texture|null} opacityMap The opacity map of the material (default is null).
 * @property {number} opacityMapUv Opacity map UV channel.
 * @property {string} opacityMapChannel Color channel of the opacity map to use. Can be "r", "g",
 * "b" or "a".
 * @property {Vec2} opacityMapTiling Controls the 2D tiling of the opacity map.
 * @property {Vec2} opacityMapOffset Controls the 2D offset of the opacity map. Each component is
 * between 0 and 1.
 * @property {number} opacityMapRotation Controls the 2D rotation (in degrees) of the opacity map.
 * @property {boolean} opacityVertexColor Use mesh vertex colors for opacity. If opacityMap is set,
 * it'll be multiplied by vertex colors.
 * @property {string} opacityVertexColorChannel Vertex color channels to use for opacity. Can be
 * "r", "g", "b" or "a".
 * @property {boolean} opacityFadesSpecular used to specify whether specular and reflections are
 * faded out using {@link StandardMaterial#opacity}. Default is true. When set to false use
 * {@link Material#alphaFade} to fade out materials.
 * @property {number} alphaFade used to fade out materials when
 * {@link StandardMaterial#opacityFadesSpecular} is set to false.
 * @property {Texture|null} normalMap The main (primary) normal map of the material (default is
 * null). The texture must contains normalized, tangent space normals.
 * @property {number} normalMapUv Main (primary) normal map UV channel.
 * @property {Vec2} normalMapTiling Controls the 2D tiling of the main (primary) normal map.
 * @property {Vec2} normalMapOffset Controls the 2D offset of the main (primary) normal map. Each
 * component is between 0 and 1.
 * @property {number} normalMapRotation Controls the 2D rotation (in degrees) of the main (primary)
 * normal map.
 * @property {number} bumpiness The bumpiness of the material. This value scales the assigned main
 * (primary) normal map. It should be normally between 0 (no bump mapping) and 1 (full bump
 * mapping), but can be set to e.g. 2 to give even more pronounced bump effect.
 * @property {Texture|null} normalDetailMap The detail (secondary) normal map of the material
 * (default is null). Will only be used if main (primary) normal map is non-null.
 * @property {number} normalDetailMapUv Detail (secondary) normal map UV channel.
 * @property {Vec2} normalDetailMapTiling Controls the 2D tiling of the detail (secondary) normal
 * map.
 * @property {Vec2} normalDetailMapOffset Controls the 2D offset of the detail (secondary) normal
 * map. Each component is between 0 and 1.
 * @property {number} normalDetailMapRotation Controls the 2D rotation (in degrees) of the detail
 * (secondary) normal map.
 * @property {number} normalDetailMapBumpiness The bumpiness of the material. This value scales the
 * assigned detail (secondary) normal map. It should be normally between 0 (no bump mapping) and 1
 * (full bump mapping), but can be set to e.g. 2 to give even more pronounced bump effect.
 * @property {Texture|null} heightMap The height map of the material (default is null). Used for a
 * view-dependent parallax effect. The texture must represent the height of the surface where
 * darker pixels are lower and lighter pixels are higher. It is recommended to use it together with
 * a normal map.
 * @property {number} heightMapUv Height map UV channel.
 * @property {string} heightMapChannel Color channel of the height map to use. Can be "r", "g", "b"
 * or "a".
 * @property {Vec2} heightMapTiling Controls the 2D tiling of the height map.
 * @property {Vec2} heightMapOffset Controls the 2D offset of the height map. Each component is
 * between 0 and 1.
 * @property {number} heightMapRotation Controls the 2D rotation (in degrees) of the height map.
 * @property {number} heightMapFactor Height map multiplier. Affects the strength of the parallax
 * effect.
 * @property {Texture|null} sphereMap The spherical environment map of the material (default is
 * null). Affects reflections.
 * @property {Texture|null} cubeMap The cubic environment map of the material (default is null).
 * Overrides sphereMap. Affects reflections. If cubemap is prefiltered, will also affect ambient
 * color.
 * @property {number} cubeMapProjection The type of projection applied to the cubeMap property:
 * - {@link CUBEPROJ_NONE}: The cube map is treated as if it is infinitely far away.
 * - {@link CUBEPROJ_BOX}: Box-projection based on a world space axis-aligned bounding box.
 * Defaults to {@link CUBEPROJ_NONE}.
 * @property {BoundingBox} cubeMapProjectionBox The world space axis-aligned bounding box defining
 * the box-projection used for the cubeMap property. Only used when cubeMapProjection is set to
 * {@link CUBEPROJ_BOX}.
 * @property {number} reflectivity Environment map intensity.
 * @property {Texture|null} lightMap A custom lightmap of the material (default is null). Lightmaps
 * are textures that contain pre-rendered lighting. Can be HDR.
 * @property {number} lightMapUv Lightmap UV channel
 * @property {string} lightMapChannel Color channels of the lightmap to use. Can be "r", "g", "b",
 * "a", "rgb" or any swizzled combination.
 * @property {Vec2} lightMapTiling Controls the 2D tiling of the lightmap.
 * @property {Vec2} lightMapOffset Controls the 2D offset of the lightmap. Each component is
 * between 0 and 1.
 * @property {number} lightMapRotation Controls the 2D rotation (in degrees) of the lightmap.
 * @property {boolean} lightVertexColor Use baked vertex lighting. If lightMap is set, it'll be
 * multiplied by vertex colors.
 * @property {string} lightVertexColorChannel Vertex color channels to use for baked lighting. Can
 * be "r", "g", "b", "a", "rgb" or any swizzled combination.
 * @property {boolean} ambientTint Enables scene ambient multiplication by material ambient color.
 * @property {Texture|null} aoMap Baked ambient occlusion (AO) map (default is null). Modulates
 * ambient color.
 * @property {number} aoMapUv AO map UV channel
 * @property {string} aoMapChannel Color channel of the AO map to use. Can be "r", "g", "b" or "a".
 * @property {Vec2} aoMapTiling Controls the 2D tiling of the AO map.
 * @property {Vec2} aoMapOffset Controls the 2D offset of the AO map. Each component is between 0
 * and 1.
 * @property {number} aoMapRotation Controls the 2D rotation (in degrees) of the AO map.
 * @property {boolean} aoVertexColor Use mesh vertex colors for AO. If aoMap is set, it'll be
 * multiplied by vertex colors.
 * @property {string} aoVertexColorChannel Vertex color channels to use for AO. Can be "r", "g",
 * "b" or "a".
 * @property {number} occludeSpecular Uses ambient occlusion to darken specular/reflection. It's a
 * hack, because real specular occlusion is view-dependent. However, it can be better than nothing.
 *
 * - {@link SPECOCC_NONE}: No specular occlusion
 * - {@link SPECOCC_AO}: Use AO directly to occlude specular.
 * - {@link SPECOCC_GLOSSDEPENDENT}: Modify AO based on material glossiness/view angle to occlude
 * specular.
 *
 * @property {number} occludeSpecularIntensity Controls visibility of specular occlusion.
 * @property {boolean} occludeDirect Tells if AO should darken directional lighting. Defaults to
 * false.
 * @property {boolean} specularAntialias Enables Toksvig AA for mipmapped normal maps with
 * specular.
 * @property {boolean} conserveEnergy Defines how diffuse and specular components are combined when
 * Fresnel is on. It is recommended that you leave this option enabled, although you may want to
 * disable it in case when all reflection comes only from a few light sources, and you don't use an
 * environment map, therefore having mostly black reflection.
 * @property {number} shadingModel Defines the shading model.
 * - {@link SPECULAR_PHONG}: Phong without energy conservation. You should only use it as a
 * backwards compatibility with older projects.
 * - {@link SPECULAR_BLINN}: Energy-conserving Blinn-Phong.
 * @property {number} fresnelModel Defines the formula used for Fresnel effect.
 * As a side-effect, enabling any Fresnel model changes the way diffuse and reflection components
 * are combined. When Fresnel is off, legacy non energy-conserving combining is used. When it is
 * on, combining behavior is defined by conserveEnergy parameter.
 *
 * - {@link FRESNEL_NONE}: No Fresnel.
 * - {@link FRESNEL_SCHLICK}: Schlick's approximation of Fresnel (recommended). Parameterized by
 * specular color.
 *
 * @property {boolean} useFog Apply fogging (as configured in scene settings)
 * @property {boolean} useLighting Apply lighting
 * @property {boolean} useSkybox Apply scene skybox as prefiltered environment map
 * @property {boolean} useGammaTonemap Apply gamma correction and tonemapping (as configured in
 * scene settings).
 * @property {boolean} pixelSnap Align vertices to pixel coordinates when rendering. Useful for
 * pixel perfect 2D graphics.
 * @property {boolean} twoSidedLighting Calculate proper normals (and therefore lighting) on
 * backfaces.
 * @property {updateShaderCallback} onUpdateShader A custom function that will be called after all
 * shader generator properties are collected and before shader code is generated. This function
 * will receive an object with shader generator settings (based on current material and scene
 * properties), that you can change and then return. Returned value will be used instead. This is
 * mostly useful when rendering the same set of objects, but with different shader variations based
 * on the same material. For example, you may wish to render a depth or normal pass using textures
 * assigned to the material, a reflection pass with simpler shaders and so on. Properties of the
 * object passed into this function are:
 *
 * - pass: value of {@link Layer#shaderPass} of the Layer being rendered.
 * - chunks: Object containing custom shader chunks that will replace default ones.
 * - customFragmentShader: Completely replace fragment shader with this code.
 * - forceUv1: if UV1 (second set of texture coordinates) is required in the shader. Will be
 * declared as "vUv1" and passed to the fragment shader.
 * - fog: the type of fog being applied in the shader. See {@link Scene#fog} for the list of
 * possible values.
 * - gamma: the type of gamma correction being applied in the shader. See
 * {@link Scene#gammaCorrection} for the list of possible values.
 * - toneMap: the type of tone mapping being applied in the shader. See {@link Scene#toneMapping}
 * for the list of possible values.
 * - ambientTint: the value of {@link StandardMaterial#ambientTint}.
 * - specularAntialias: the value of {@link StandardMaterial#specularAntialias}.
 * - conserveEnergy: the value of {@link StandardMaterial#conserveEnergy}.
 * - occludeSpecular: the value of {@link StandardMaterial#occludeSpecular}.
 * - occludeDirect: the value of {@link StandardMaterial#occludeDirect}.
 * - shadingModel: the value of {@link StandardMaterial#shadingModel}.
 * - fresnelModel: the value of {@link StandardMaterial#fresnelModel}.
 * - cubeMapProjection: the value of {@link StandardMaterial#cubeMapProjection}.
 * - useMetalness: the value of {@link StandardMaterial#useMetalness}.
 * - blendType: the value of {@link Material#blendType}.
 * - twoSidedLighting: the value of {@link Material#twoSidedLighting}.
 * - diffuseTint: defines if {@link StandardMaterial#diffuse} constant should affect diffuse color.
 * - specularTint: defines if {@link StandardMaterial#specular} constant should affect specular
 * color.
 * - metalnessTint: defines if {@link StandardMaterial#metalness} constant should affect metalness
 * value.
 * - glossTint: defines if {@link StandardMaterial#shininess} constant should affect glossiness
 * value.
 * - emissiveTint: defines if {@link StandardMaterial#emissive} constant should affect emission
 * value.
 * - opacityTint: defines if {@link StandardMaterial#opacity} constant should affect opacity value.
 * - occludeSpecularFloat: defines if {@link StandardMaterial#occludeSpecularIntensity} constant
 * should affect specular occlusion.
 * - alphaTest: enable alpha testing. See {@link Material#alphaTest}.
 * - alphaToCoverage: enable alpha to coverage. See {@link Material#alphaToCoverage}.
 * - opacityFadesSpecular: enable specular fade. See {@link Material#opacityFadesSpecular}.
 * - alphaFade: fade value. See {@link Material#alphaFade}.
 * - sphereMap: if {@link StandardMaterial#sphereMap} is used.
 * - cubeMap: if {@link StandardMaterial#cubeMap} is used.
 * - ambientSH: if ambient spherical harmonics are used. Ambient SH replace prefiltered cubemap
 * ambient on certain platform (mostly Android) for performance reasons.
 * - useSpecular: if any specular or reflections are needed at all.
 * - fixSeams: if cubemaps require seam fixing (see {@link Texture#options.fixCubemapSeams}).
 * - emissiveFormat: how emissiveMap must be sampled. This value is based on
 * {@link Texture#options.rgbm} and {@link Texture#options.format}. Possible values are:
 *   - 0: sRGB texture
 *   - 1: RGBM-encoded HDR texture
 *   - 2: Simple read (no conversion from sRGB)
 * - lightMapFormat: how lightMap must be sampled. This value is based on
 * {@link Texture#options.rgbm} and {@link Texture#options.format}. Possible values are:
 *   - 0: sRGB texture
 *   - 1: RGBM-encoded HDR texture
 *   - 2: Simple read (no conversion from sRGB)
 * - useRgbm: if decodeRGBM() function is needed in the shader at all.
 * - packedNormal: if normal map contains X in RGB, Y in Alpha, and Z must be reconstructed.
 * - forceFragmentPrecision: Override fragment shader numeric precision. Can be "lowp", "mediump",
 * "highp" or null to use default.
 * - fastTbn: Use slightly cheaper normal mapping code (skip tangent space normalization). Can look
 * buggy sometimes.
 * - refraction: if refraction is used.
 * - skyboxIntensity: if reflected skybox intensity should be modulated.
 * - useCubeMapRotation: if cube map rotation is enabled.
 * - useInstancing: if hardware instancing compatible shader should be generated. Transform is read
 * from per-instance {@link VertexBuffer} instead of shader's uniforms.
 * - useMorphPosition: if morphing code should be generated to morph positions.
 * - useMorphNormal: if morphing code should be generated to morph normals.
 * - reflectionSource: one of "envAtlas", "cubeMap", "sphereMap"
 * - reflectionEncoding: one of null, "rgbm", "rgbe", "linear", "srgb"
 * - ambientSource: one of "ambientSH", "envAtlas", "constant"
 * - ambientEncoding: one of null, "rgbm", "rgbe", "linear", "srgb"
 * @augments Material
 */
declare class StandardMaterial extends Material$2 {
    static TEXTURE_PARAMETERS: any[];
    static CUBEMAP_PARAMETERS: any[];
    _dirtyShader: boolean;
    _assetReferences: {};
    _activeParams: Set<any>;
    _activeLightingParams: Set<any>;
    shaderOptBuilder: StandardMaterialOptionsBuilder;
    reset(): void;

    set alphaFade(arg: boolean);
    get alphaFade(): boolean;

    set ambient(arg: Color$3);
    get ambient(): Color$3;

    set ambientTint(arg: boolean);
    get ambientTint(): boolean;

    set anisotropy(arg: number);
    get anisotropy(): number;

    set aoMap(arg: Texture$4);
    get aoMap(): Texture$4;

    set aoMapChannel(arg: string);
    get aoMapChannel(): string;

    set aoMapOffset(arg: Vec2$1);
    get aoMapOffset(): Vec2$1;

    set aoMapRotation(arg: number);
    get aoMapRotation(): number;

    set aoMapTiling(arg: Vec2$1);
    get aoMapTiling(): Vec2$1;

    set aoMapUv(arg: number);
    get aoMapUv(): number;

    set aoVertexColor(arg: boolean);
    get aoVertexColor(): boolean;

    set aoVertexColorChannel(arg: string);
    get aoVertexColorChannel(): string;

    set bumpiness(arg: number);
    get bumpiness(): number;

    set clearCoat(arg: number);
    get clearCoat(): number;

    set clearCoatBumpiness(arg: number);
    get clearCoatBumpiness(): number;

    set clearCoatGlossMap(arg: Texture$4);
    get clearCoatGlossMap(): Texture$4;

    set clearCoatGlossMapChannel(arg: string);
    get clearCoatGlossMapChannel(): string;

    set clearCoatGlossMapOffset(arg: Vec2$1);
    get clearCoatGlossMapOffset(): Vec2$1;

    set clearCoatGlossMapRotation(arg: number);
    get clearCoatGlossMapRotation(): number;

    set clearCoatGlossMapTiling(arg: Vec2$1);
    get clearCoatGlossMapTiling(): Vec2$1;

    set clearCoatGlossMapUv(arg: number);
    get clearCoatGlossMapUv(): number;

    set clearCoatGlossVertexColor(arg: boolean);
    get clearCoatGlossVertexColor(): boolean;

    set clearCoatGlossVertexColorChannel(arg: string);
    get clearCoatGlossVertexColorChannel(): string;

    set clearCoatGlossiness(arg: number);
    get clearCoatGlossiness(): number;

    set clearCoatMap(arg: Texture$4);
    get clearCoatMap(): Texture$4;

    set clearCoatMapChannel(arg: string);
    get clearCoatMapChannel(): string;

    set clearCoatMapOffset(arg: Vec2$1);
    get clearCoatMapOffset(): Vec2$1;

    set clearCoatMapRotation(arg: number);
    get clearCoatMapRotation(): number;

    set clearCoatMapTiling(arg: Vec2$1);
    get clearCoatMapTiling(): Vec2$1;

    set clearCoatMapUv(arg: number);
    get clearCoatMapUv(): number;

    set clearCoatNormalMap(arg: Texture$4);
    get clearCoatNormalMap(): Texture$4;

    set clearCoatNormalMapOffset(arg: Vec2$1);
    get clearCoatNormalMapOffset(): Vec2$1;

    set clearCoatNormalMapRotation(arg: number);
    get clearCoatNormalMapRotation(): number;

    set clearCoatNormalMapTiling(arg: Vec2$1);
    get clearCoatNormalMapTiling(): Vec2$1;

    set clearCoatNormalMapUv(arg: number);
    get clearCoatNormalMapUv(): number;

    set clearCoatVertexColor(arg: boolean);
    get clearCoatVertexColor(): boolean;

    set clearCoatVertexColorChannel(arg: string);
    get clearCoatVertexColorChannel(): string;

    set conserveEnergy(arg: boolean);
    get conserveEnergy(): boolean;

    set cubeMap(arg: Texture$4);
    get cubeMap(): Texture$4;

    set cubeMapProjection(arg: number);
    get cubeMapProjection(): number;

    set cubeMapProjectionBox(arg: BoundingBox);
    get cubeMapProjectionBox(): BoundingBox;

    set diffuse(arg: Color$3);
    get diffuse(): Color$3;

    set diffuseDetailMap(arg: Texture$4);
    get diffuseDetailMap(): Texture$4;

    set diffuseDetailMapChannel(arg: string);
    get diffuseDetailMapChannel(): string;

    set diffuseDetailMapOffset(arg: Vec2$1);
    get diffuseDetailMapOffset(): Vec2$1;

    set diffuseDetailMapRotation(arg: number);
    get diffuseDetailMapRotation(): number;

    set diffuseDetailMapTiling(arg: Vec2$1);
    get diffuseDetailMapTiling(): Vec2$1;

    set diffuseDetailMapUv(arg: number);
    get diffuseDetailMapUv(): number;

    set diffuseDetailMode(arg: string);
    get diffuseDetailMode(): string;

    set diffuseMap(arg: Texture$4);
    get diffuseMap(): Texture$4;

    set diffuseMapChannel(arg: string);
    get diffuseMapChannel(): string;

    set diffuseMapOffset(arg: Vec2$1);
    get diffuseMapOffset(): Vec2$1;

    set diffuseMapRotation(arg: number);
    get diffuseMapRotation(): number;

    set diffuseMapTiling(arg: Vec2$1);
    get diffuseMapTiling(): Vec2$1;

    set diffuseMapUv(arg: number);
    get diffuseMapUv(): number;

    set diffuseTint(arg: boolean);
    get diffuseTint(): boolean;

    set diffuseVertexColor(arg: boolean);
    get diffuseVertexColor(): boolean;

    set diffuseVertexColorChannel(arg: string);
    get diffuseVertexColorChannel(): string;

    set emissive(arg: Color$3);
    get emissive(): Color$3;

    set emissiveIntensity(arg: number);
    get emissiveIntensity(): number;

    set emissiveMap(arg: Texture$4);
    get emissiveMap(): Texture$4;

    set emissiveMapChannel(arg: string);
    get emissiveMapChannel(): string;

    set emissiveMapOffset(arg: Vec2$1);
    get emissiveMapOffset(): Vec2$1;

    set emissiveMapRotation(arg: number);
    get emissiveMapRotation(): number;

    set emissiveMapTiling(arg: Vec2$1);
    get emissiveMapTiling(): Vec2$1;

    set emissiveMapUv(arg: number);
    get emissiveMapUv(): number;

    set emissiveTint(arg: boolean);
    get emissiveTint(): boolean;

    set emissiveVertexColor(arg: boolean);
    get emissiveVertexColor(): boolean;

    set emissiveVertexColorChannel(arg: string);
    get emissiveVertexColorChannel(): string;

    set enableGGXSpecular(arg: boolean);
    get enableGGXSpecular(): boolean;

    set fresnelModel(arg: number);
    get fresnelModel(): number;

    set glossMap(arg: Texture$4);
    get glossMap(): Texture$4;

    set glossMapChannel(arg: string);
    get glossMapChannel(): string;

    set glossMapOffset(arg: Vec2$1);
    get glossMapOffset(): Vec2$1;

    set glossMapRotation(arg: number);
    get glossMapRotation(): number;

    set glossMapTiling(arg: Vec2$1);
    get glossMapTiling(): Vec2$1;

    set glossMapUv(arg: number);
    get glossMapUv(): number;

    set glossVertexColor(arg: boolean);
    get glossVertexColor(): boolean;

    set glossVertexColorChannel(arg: string);
    get glossVertexColorChannel(): string;

    set heightMap(arg: Texture$4);
    get heightMap(): Texture$4;

    set heightMapChannel(arg: string);
    get heightMapChannel(): string;

    set heightMapFactor(arg: number);
    get heightMapFactor(): number;

    set heightMapOffset(arg: Vec2$1);
    get heightMapOffset(): Vec2$1;

    set heightMapRotation(arg: number);
    get heightMapRotation(): number;

    set heightMapTiling(arg: Vec2$1);
    get heightMapTiling(): Vec2$1;

    set heightMapUv(arg: number);
    get heightMapUv(): number;

    set lightMap(arg: Texture$4);
    get lightMap(): Texture$4;

    set lightMapChannel(arg: string);
    get lightMapChannel(): string;

    set lightMapOffset(arg: Vec2$1);
    get lightMapOffset(): Vec2$1;

    set lightMapRotation(arg: number);
    get lightMapRotation(): number;

    set lightMapTiling(arg: Vec2$1);
    get lightMapTiling(): Vec2$1;

    set lightMapUv(arg: number);
    get lightMapUv(): number;

    set lightVertexColor(arg: boolean);
    get lightVertexColor(): boolean;

    set lightVertexColorChannel(arg: string);
    get lightVertexColorChannel(): string;

    set metalness(arg: number);
    get metalness(): number;

    set metalnessMap(arg: Texture$4);
    get metalnessMap(): Texture$4;

    set metalnessMapChannel(arg: string);
    get metalnessMapChannel(): string;

    set metalnessMapOffset(arg: Vec2$1);
    get metalnessMapOffset(): Vec2$1;

    set metalnessMapRotation(arg: number);
    get metalnessMapRotation(): number;

    set metalnessMapTiling(arg: Vec2$1);
    get metalnessMapTiling(): Vec2$1;

    set metalnessMapUv(arg: number);
    get metalnessMapUv(): number;

    set metalnessVertexColor(arg: boolean);
    get metalnessVertexColor(): boolean;

    set metalnessVertexColorChannel(arg: string);
    get metalnessVertexColorChannel(): string;

    set normalDetailMap(arg: Texture$4);
    get normalDetailMap(): Texture$4;

    set normalDetailMapBumpiness(arg: number);
    get normalDetailMapBumpiness(): number;

    set normalDetailMapOffset(arg: Vec2$1);
    get normalDetailMapOffset(): Vec2$1;

    set normalDetailMapRotation(arg: number);
    get normalDetailMapRotation(): number;

    set normalDetailMapTiling(arg: Vec2$1);
    get normalDetailMapTiling(): Vec2$1;

    set normalDetailMapUv(arg: number);
    get normalDetailMapUv(): number;

    set normalMap(arg: Texture$4);
    get normalMap(): Texture$4;

    set normalMapOffset(arg: Vec2$1);
    get normalMapOffset(): Vec2$1;

    set normalMapRotation(arg: number);
    get normalMapRotation(): number;

    set normalMapTiling(arg: Vec2$1);
    get normalMapTiling(): Vec2$1;

    set normalMapUv(arg: number);
    get normalMapUv(): number;

    set occludeDirect(arg: number);
    get occludeDirect(): number;

    set occludeSpecular(arg: number);
    get occludeSpecular(): number;

    set occludeSpecularIntensity(arg: number);
    get occludeSpecularIntensity(): number;

    set onUpdateShader(arg: updateShaderCallback);
    get onUpdateShader(): updateShaderCallback;

    set opacity(arg: number);
    get opacity(): number;

    set opacityFadesSpecular(arg: boolean);
    get opacityFadesSpecular(): boolean;

    set opacityMap(arg: Texture$4);
    get opacityMap(): Texture$4;

    set opacityMapChannel(arg: string);
    get opacityMapChannel(): string;

    set opacityMapOffset(arg: Vec2$1);
    get opacityMapOffset(): Vec2$1;

    set opacityMapRotation(arg: number);
    get opacityMapRotation(): number;

    set opacityMapTiling(arg: Vec2$1);
    get opacityMapTiling(): Vec2$1;

    set opacityMapUv(arg: number);
    get opacityMapUv(): number;

    set opacityVertexColor(arg: boolean);
    get opacityVertexColor(): boolean;

    set opacityVertexColorChannel(arg: string);
    get opacityVertexColorChannel(): string;

    set pixelSnap(arg: boolean);
    get pixelSnap(): boolean;

    set reflectivity(arg: number);
    get reflectivity(): number;

    set refraction(arg: number);
    get refraction(): number;

    set refractionIndex(arg: number);
    get refractionIndex(): number;

    set shadingModel(arg: number);
    get shadingModel(): number;

    set shininess(arg: number);
    get shininess(): number;

    set specular(arg: Color$3);
    get specular(): Color$3;

    set specularAntialias(arg: boolean);
    get specularAntialias(): boolean;

    set specularMap(arg: Texture$4);
    get specularMap(): Texture$4;

    set specularMapChannel(arg: string);
    get specularMapChannel(): string;

    set specularMapOffset(arg: Vec2$1);
    get specularMapOffset(): Vec2$1;

    set specularMapRotation(arg: number);
    get specularMapRotation(): number;

    set specularMapTiling(arg: Vec2$1);
    get specularMapTiling(): Vec2$1;

    set specularMapUv(arg: number);
    get specularMapUv(): number;

    set specularTint(arg: boolean);
    get specularTint(): boolean;

    set specularVertexColor(arg: boolean);
    get specularVertexColor(): boolean;

    set specularVertexColorChannel(arg: string);
    get specularVertexColorChannel(): string;

    set sphereMap(arg: Texture$4);
    get sphereMap(): Texture$4;

    set twoSidedLighting(arg: boolean);
    get twoSidedLighting(): boolean;

    set useFog(arg: boolean);
    get useFog(): boolean;

    set useGammaTonemap(arg: boolean);
    get useGammaTonemap(): boolean;

    set useLighting(arg: boolean);
    get useLighting(): boolean;

    set useMetalness(arg: boolean);
    get useMetalness(): boolean;

    set useSkybox(arg: boolean);
    get useSkybox(): boolean;

    /**
     * @type {Object.<string, string>}
     * @private
     */
    private _chunks;
    _uniformCache: {};
    /**
     * Object containing custom shader chunks that will replace default ones.
     *
     * @type {Object.<string, string>}
     */
    set chunks(arg: {
        [x: string]: string;
    });
    get chunks(): {
        [x: string]: string;
    };
    _setParameter(name: any, value: any): void;
    _setParameters(parameters: any): void;
    _processParameters(paramsName: any): void;
    _updateMap(p: any): void;
    _allocUniform(name: any, allocFunc: any): any;
    getUniform(name: any, device: any, scene: any): any;
    updateEnvUniforms(device: any, scene: any): void;
}

/**
 * Manages creation of {@link ElementComponent}s.
 *
 * @augments ComponentSystem
 */
declare class ElementComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof ElementComponent$2;
    DataType: typeof ElementComponentData;
    _unicodeConverter: any;
    _rtlReorder: any;
    _defaultTexture: Texture$8;
    defaultImageMaterial: StandardMaterial;
    defaultImage9SlicedMaterial: StandardMaterial;
    defaultImage9TiledMaterial: StandardMaterial;
    defaultImageMaskMaterial: StandardMaterial;
    defaultImage9SlicedMaskMaterial: StandardMaterial;
    defaultImage9TiledMaskMaterial: StandardMaterial;
    defaultScreenSpaceImageMaterial: StandardMaterial;
    defaultScreenSpaceImage9SlicedMaterial: StandardMaterial;
    defaultScreenSpaceImage9TiledMaterial: StandardMaterial;
    defaultScreenSpaceImageMask9SlicedMaterial: StandardMaterial;
    defaultScreenSpaceImageMask9TiledMaterial: Material$2;
    defaultScreenSpaceImageMaskMaterial: StandardMaterial;
    defaultTextMaterial: StandardMaterial;
    defaultBitmapTextMaterial: StandardMaterial;
    defaultScreenSpaceTextMaterial: StandardMaterial;
    defaultScreenSpaceBitmapTextMaterial: StandardMaterial;
    defaultImageMaterials: any[];
    onRemoveComponent(entity: any, component: any): void;
    getTextElementMaterial(screenSpace: any, msdf: any): StandardMaterial;
    _createBaseImageMaterial(): StandardMaterial;
    getImageElementMaterial(screenSpace: any, mask: any, nineSliced: any, nineSliceTiled: any): Material$2 | StandardMaterial;
    registerUnicodeConverter(func: any): void;
    registerRtlReorder(func: any): void;
    getUnicodeConverter(): any;
    getRtlReorder(): any;
}

type Texture$3 = Texture$8;
/** @typedef {import('../graphics/texture.js').Texture} Texture */
/**
 * Represents the resource of a font asset.
 */
declare class Font$1 {
    /**
     * Create a new Font instance.
     *
     * @param {Texture[]} textures - The font textures.
     * @param {object} data - The font data.
     */
    constructor(textures: Texture$3[], data: object);
    type: any;
    em: number;
    /**
     * The font textures.
     *
     * @type {Texture[]}
     */
    textures: Texture$3[];
    /**
     * The font intensity.
     *
     * @type {number}
     */
    intensity: number;
    _data: any;
    set data(arg: any);
    get data(): any;
}

/**
 * Represents the resource of a canvas font asset.
 *
 * @augments EventHandler
 * @ignore
 */
declare class CanvasFont$1 extends EventHandler$1 {
    /**
     * Create a new CanvasFont instance.
     *
     * @param {Application} app - The application.
     * @param {object} options - The font options.
     * @param {string} [options.fontName] - The name of the font. CSS font names are supported.
     * Defaults to 'Arial'.
     * @param {string} [options.fontWeight] - The weight of the font, e.g. 'normal', 'bold'.
     * Defaults to 'normal'.
     * @param {number} [options.fontSize] - The font size in pixels. Defaults to 32.
     * @param {Color} [options.color] - The font color.Defaults to white.
     * @param {number} [options.width] - The width of each texture atlas. Defaults to 512.
     * @param {number} [options.height] - The height of each texture atlas. Defaults to 512.
     * @param {number} [options.padding] - Amount of glyph padding in pixels that is added to each
     * glyph in the atlas. Defaults to 0.
     */
    constructor(app: any, options?: {
        fontName?: string;
        fontWeight?: string;
        fontSize?: number;
        color?: Color$4;
        width?: number;
        height?: number;
        padding?: number;
    });
    type: string;
    app: any;
    intensity: number;
    fontWeight: string;
    fontSize: number;
    glyphSize: number;
    fontName: string;
    color: Color$4;
    padding: number;
    textures: Texture$8[];
    chars: string;
    data: {};
    /**
     * Render the necessary textures for all characters in a string to be used for the canvas font.
     *
     * @param {string} text - The list of characters to render into the texture atlas.
     */
    createTextures(text: string): void;
    /**
     * Update the list of characters to include in the atlas to include those provided and
     * re-render the texture atlas to include all the characters that have been supplied so far.
     *
     * @param {string} text - The list of characters to add to the texture atlas.
     */
    updateTextures(text: string): void;
    /**
     * Destroys the font. This also destroys the textures owned by the font.
     */
    destroy(): void;
    /**
     * @param {HTMLCanvasElement} canvas - The canvas used to render the font.
     * @param {string} clearColor - The color to clear the canvas with.
     * @returns {CanvasRenderingContext2D} - A 2D rendering contxt.
     * @private
     */
    private _getAndClearContext;
    /**
     * @param {Color} color - The color to covert.
     * @param {boolean} alpha - Whether to include the alpha channel.
     * @returns {string} The hex string for the color.
     * @private
     */
    private _colorToRgbString;
    /**
     * @param {CanvasRenderingContext2D} context - The canvas 2D context.
     * @param {string} char - The character to render.
     * @param {number} x - The x position to render the character at.
     * @param {number} y - The y position to render the character at.
     * @param {number} color - The color to render the character in.
     * @ignore
     */
    renderCharacter(context: CanvasRenderingContext2D, char: string, x: number, y: number, color: number): void;
    /**
     * Renders an array of characters into one or more textures atlases.
     *
     * @param {string[]} charsArray - The list of characters to render.
     * @private
     */
    private _renderAtlas;
    /**
     * @param {string[]} chars - A list of characters.
     * @param {string} fontName - The font name.
     * @param {number} width - The width of the texture atlas.
     * @param {number} height - The height of the texture atlas.
     * @returns {object} The font JSON object.
     * @private
     */
    private _createJson;
    /**
     * @param {object} json - Font data.
     * @param {string} char - The character to add.
     * @param {number} charCode - The code point number of the character to add.
     * @param {number} x - The x position of the character.
     * @param {number} y - The y position of the character.
     * @param {number} w - The width of the character.
     * @param {number} h - The height of the character.
     * @param {number} xoffset - The x offset of the character.
     * @param {number} yoffset - The y offset of the character.
     * @param {number} xadvance - The x advance of the character.
     * @param {number} mapNum - The map number of the character.
     * @param {number} mapW - The width of the map.
     * @param {number} mapH - The height of the map.
     * @private
     */
    private _addChar;
    /**
     * Take a unicode string and produce the set of characters used to create that string.
     * e.g. "abcabcabc" -> ['a', 'b', 'c']
     *
     * @param {string} text - The unicode string to process.
     * @returns {string[]} The set of characters used to create the string.
     * @private
     */
    private _normalizeCharsSet;
    /**
     * Calculate some metrics that aren't available via the browser API, notably character height
     * and descent size.
     *
     * @param {string} text - The text to measure.
     * @returns {{ascent: number, descent: number, height: number}} The metrics of the text.
     * @private
     */
    private _getTextMetrics;
}

declare class ImageElement {
    constructor(element: any);
    _element: any;
    _entity: any;
    _system: any;
    _textureAsset: any;
    _texture: any;
    _materialAsset: any;
    _material: any;
    _spriteAsset: any;
    _sprite: any;
    _spriteFrame: number;
    _pixelsPerUnit: any;
    _rect: Vec4$6;
    _mask: boolean;
    _maskRef: number;
    _outerScale: Vec2$3;
    _outerScaleUniform: Float32Array;
    _innerOffset: Vec4$6;
    _innerOffsetUniform: Float32Array;
    _atlasRect: Vec4$6;
    _atlasRectUniform: Float32Array;
    _defaultMesh: Mesh$1;
    _renderable: ImageRenderable;
    _color: Color$4;
    _colorUniform: Float32Array;
    _updateAabbFunc: any;
    destroy(): void;
    set textureAsset(arg: any);
    get textureAsset(): any;
    set spriteAsset(arg: any);
    get spriteAsset(): any;
    set materialAsset(arg: any);
    get materialAsset(): any;
    _onResolutionChange(res: any): void;
    _onParentResizeOrPivotChange(): void;
    _onScreenSpaceChange(value: any): void;
    _onScreenChange(screen: any, previous: any): void;
    _onDrawOrderChange(order: any): void;
    _hasUserMaterial(): boolean;
    _use9Slicing(): boolean;
    _updateMaterial(screenSpace: any): void;
    _createMesh(): Mesh$1;
    _updateMesh(mesh: any): void;
    _meshDirty: boolean;
    _updateSprite(): void;
    set mesh(arg: any);
    get mesh(): any;
    _updateAabb(aabb: any): any;
    _toggleMask(): void;
    _onMaterialLoad(asset: any): void;
    set material(arg: any);
    get material(): any;
    _onMaterialAdded(asset: any): void;
    _bindMaterialAsset(asset: any): void;
    _unbindMaterialAsset(asset: any): void;
    _onMaterialChange(): void;
    _onMaterialRemove(): void;
    _onTextureAdded(asset: any): void;
    _bindTextureAsset(asset: any): void;
    _unbindTextureAsset(asset: any): void;
    _onTextureLoad(asset: any): void;
    set texture(arg: any);
    get texture(): any;
    _onTextureChange(asset: any): void;
    _onTextureRemove(asset: any): void;
    _onSpriteAssetAdded(asset: any): void;
    _bindSpriteAsset(asset: any): void;
    _unbindSpriteAsset(asset: any): void;
    _onSpriteAssetLoad(asset: any): void;
    set sprite(arg: any);
    get sprite(): any;
    _onSpriteAssetChange(asset: any): void;
    _onSpriteAssetRemove(asset: any): void;
    _bindSprite(sprite: any): void;
    _unbindSprite(sprite: any): void;
    _onSpriteMeshesChange(): void;
    _onSpritePpuChange(): void;
    _onAtlasTextureChange(): void;
    _onTextureAtlasLoad(atlasAsset: any): void;
    onEnable(): void;
    onDisable(): void;
    _setStencil(stencilParams: any): void;
    set color(arg: Color$4);
    get color(): Color$4;
    set opacity(arg: number);
    get opacity(): number;
    set rect(arg: Vec4$6);
    get rect(): Vec4$6;
    set spriteFrame(arg: number);
    get spriteFrame(): number;
    set mask(arg: boolean);
    get mask(): boolean;
    set pixelsPerUnit(arg: any);
    get pixelsPerUnit(): any;
    get aabb(): any;
}

declare class ImageRenderable {
    constructor(entity: any, mesh: any, material: any);
    _entity: any;
    _element: any;
    model: Model;
    node: GraphNode$3;
    mesh: any;
    meshInstance: MeshInstance$3;
    _meshDirty: boolean;
    unmaskMeshInstance: MeshInstance$3;
    destroy(): void;
    setMesh(mesh: any): void;
    setMask(mask: any): void;
    setMaterial(material: any): void;
    setParameter(name: any, value: any): void;
    deleteParameter(name: any): void;
    setUnmaskDrawOrder(): void;
    setDrawOrder(drawOrder: any): void;
    setCull(cull: any): void;
    setScreenSpace(screenSpace: any): void;
    setLayer(layer: any): void;
    forceUpdateAabb(mask: any): void;
    setAabbFunc(fn: any): void;
}

declare class LocalizedAsset extends EventHandler$1 {
    constructor(app: any);
    _app: any;
    _autoLoad: boolean;
    _disableLocalization: boolean;
    _defaultAsset: any;
    _localizedAsset: any;
    set defaultAsset(arg: any);
    get defaultAsset(): any;
    set localizedAsset(arg: any);
    get localizedAsset(): any;
    set autoLoad(arg: boolean);
    get autoLoad(): boolean;
    set disableLocalization(arg: boolean);
    get disableLocalization(): boolean;
    _bindDefaultAsset(): void;
    _unbindDefaultAsset(): void;
    _onDefaultAssetAdd(asset: any): void;
    _onDefaultAssetRemove(asset: any): void;
    _bindLocalizedAsset(): void;
    _unbindLocalizedAsset(): void;
    _onLocalizedAssetAdd(asset: any): void;
    _onLocalizedAssetLoad(asset: any): void;
    _onLocalizedAssetChange(asset: any, name: any, newValue: any, oldValue: any): void;
    _onLocalizedAssetRemove(asset: any): void;
    _onLocaleAdd(locale: any, assetId: any): void;
    _onLocaleRemove(locale: any, assetId: any): void;
    _onSetLocale(locale: any): void;
    destroy(): void;
}

declare class TextElement {
    constructor(element: any);
    _element: any;
    _system: any;
    _entity: any;
    _text: string;
    _symbols: any[];
    _colorPalette: any[];
    _symbolColors: any[];
    _i18nKey: any;
    _fontAsset: LocalizedAsset;
    _font: any;
    _color: Color$4;
    _colorUniform: Float32Array;
    _spacing: number;
    _fontSize: number;
    _fontMinY: number;
    _fontMaxY: number;
    _originalFontSize: number;
    _maxFontSize: number;
    _minFontSize: number;
    _autoFitWidth: boolean;
    _autoFitHeight: boolean;
    _maxLines: number;
    _lineHeight: number;
    _scaledLineHeight: number;
    _wrapLines: boolean;
    _drawOrder: number;
    _alignment: Vec2$3;
    _autoWidth: boolean;
    _autoHeight: boolean;
    width: number;
    height: number;
    _node: GraphNode$3;
    _model: Model;
    _meshInfo: any[];
    _material: any;
    _aabbDirty: boolean;
    _aabb: BoundingBox$1;
    _noResize: boolean;
    _currentMaterialType: any;
    _maskedMaterialSrc: any;
    _rtlReorder: boolean;
    _unicodeConverter: boolean;
    _rtl: boolean;
    _outlineColor: Color$4;
    _outlineColorUniform: Float32Array;
    _outlineThicknessScale: number;
    _outlineThickness: number;
    _shadowColor: Color$4;
    _shadowColorUniform: Float32Array;
    _shadowOffsetScale: number;
    _shadowOffset: Vec2$3;
    _shadowOffsetUniform: Float32Array;
    _enableMarkup: boolean;
    _rangeStart: number;
    _rangeEnd: number;
    destroy(): void;
    set font(arg: any);
    get font(): any;
    _onParentResize(width: any, height: any): void;
    _onScreenChange(screen: any): void;
    _onScreenSpaceChange(value: any): void;
    _onDrawOrderChange(order: any): void;
    _onPivotChange(pivot: any): void;
    _onLocaleSet(locale: any): void;
    _onLocalizationData(locale: any, messages: any): void;
    _resetLocalizedText(): void;
    _setText(text: any): void;
    _updateText(text: any): void;
    _removeMeshInstance(meshInstance: any): void;
    _setMaterial(material: any): void;
    _updateMaterial(screenSpace: any): void;
    _isWordBoundary(char: any): boolean;
    _isValidNextChar(nextchar: any): boolean;
    _isNextCJKBoundary(char: any, nextchar: any): boolean;
    _isNextCJKWholeWord(nextchar: any): boolean;
    _updateMeshes(): void;
    _lineWidths: any[];
    _lineContents: any[];
    set autoWidth(arg: boolean);
    get autoWidth(): boolean;
    set autoHeight(arg: boolean);
    get autoHeight(): boolean;
    _onFontRender(): void;
    _onFontLoad(asset: any): void;
    _onFontChange(asset: any, name: any, _new: any, _old: any): void;
    _onFontRemove(asset: any): void;
    _setTextureParams(mi: any, texture: any): void;
    _getPxRange(font: any): number;
    _getUv(char: any): any;
    onEnable(): void;
    onDisable(): void;
    _setStencil(stencilParams: any): void;
    _shouldAutoFitWidth(): boolean;
    _shouldAutoFitHeight(): boolean;
    _shouldAutoFit(): boolean;
    _calculateCharsPerTexture(symbolIndex: any): {};
    _updateRenderRange(): void;
    set text(arg: string);
    get text(): string;
    set key(arg: any);
    get key(): any;
    set color(arg: Color$4);
    get color(): Color$4;
    set opacity(arg: number);
    get opacity(): number;
    set lineHeight(arg: number);
    get lineHeight(): number;
    set wrapLines(arg: boolean);
    get wrapLines(): boolean;
    get lines(): any[];
    set spacing(arg: number);
    get spacing(): number;
    set fontSize(arg: number);
    get fontSize(): number;
    set fontAsset(arg: any);
    get fontAsset(): any;
    set alignment(arg: Vec2$3);
    get alignment(): Vec2$3;
    set rtlReorder(arg: boolean);
    get rtlReorder(): boolean;
    set unicodeConverter(arg: boolean);
    get unicodeConverter(): boolean;
    get aabb(): BoundingBox$1;
    set outlineColor(arg: Color$4);
    get outlineColor(): Color$4;
    set outlineThickness(arg: number);
    get outlineThickness(): number;
    set shadowColor(arg: Color$4);
    get shadowColor(): Color$4;
    set shadowOffset(arg: Vec2$3);
    get shadowOffset(): Vec2$3;
    set minFontSize(arg: number);
    get minFontSize(): number;
    set maxFontSize(arg: number);
    get maxFontSize(): number;
    set autoFitWidth(arg: boolean);
    get autoFitWidth(): boolean;
    set autoFitHeight(arg: boolean);
    get autoFitHeight(): boolean;
    set maxLines(arg: number);
    get maxLines(): number;
    set enableMarkup(arg: boolean);
    get enableMarkup(): boolean;
    get symbols(): any[];
    get symbolColors(): any[];
    get rtl(): boolean;
    set rangeStart(arg: number);
    get rangeStart(): number;
    set rangeEnd(arg: number);
    get rangeEnd(): number;
}

type Color$2 = Color$4;
type CanvasFont = CanvasFont$1;
type Font = Font$1;
type Texture$2 = Texture$8;
type Material = Material$2;
type Sprite = Sprite$1;
type ElementComponentSystem$1 = ElementComponentSystem$2;
/**
 * ElementComponents are used to construct user interfaces. An ElementComponent's [type](#type)
 * property can be configured in 3 main ways: as a text element, as an image element or as a group
 * element. If the ElementComponent has a {@link ScreenComponent} ancestor in the hierarchy, it
 * will be transformed with respect to the coordinate system of the screen. If there is no
 * {@link ScreenComponent} ancestor, the ElementComponent will be transformed like any other
 * entity.
 *
 * You should never need to use the ElementComponent constructor. To add an ElementComponent to a
 * {@link Entity}, use {@link Entity#addComponent}:
 *
 * ```javascript
 * // Add an element component to an entity with the default options
 * let entity = pc.Entity();
 * entity.addComponent("element"); // This defaults to a 'group' element
 * ```
 *
 * To create a simple text-based element:
 *
 * ```javascript
 * entity.addComponent("element", {
 *     anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5), // centered anchor
 *     fontAsset: fontAsset,
 *     fontSize: 128,
 *     pivot: new pc.Vec2(0.5, 0.5),            // centered pivot
 *     text: "Hello World!",
 *     type: pc.ELEMENTTYPE_TEXT
 * });
 * ```
 *
 * Once the ElementComponent is added to the entity, you can set and get any of its properties:
 *
 * ```javascript
 * entity.element.color = pc.Color.RED; // Set the element's color to red
 *
 * console.log(entity.element.color);   // Get the element's color and print it
 * ```
 *
 * Relevant 'Engine-only' examples:
 * - [Basic text rendering](http://playcanvas.github.io/#user-interface/text-basic.html)
 * - [Rendering text outlines](http://playcanvas.github.io/#user-interface/text-outline.html)
 * - [Adding drop shadows to text](http://playcanvas.github.io/#user-interface/text-drop-shadow.html)
 * - [Coloring text with markup](http://playcanvas.github.io/#user-interface/text-markup.html)
 * - [Wrapping text](http://playcanvas.github.io/#user-interface/text-wrap.html)
 * - [Typewriter text](http://playcanvas.github.io/#user-interface/text-typewriter.html)
 *
 * @property {Entity} screen The Entity with a {@link ScreenComponent} that this component belongs
 * to. This is automatically set when the component is a child of a ScreenComponent.
 * @property {Color} color The color of the image for {@link ELEMENTTYPE_IMAGE} types or the color
 * of the text for {@link ELEMENTTYPE_TEXT} types.
 * @property {number} opacity The opacity of the image for {@link ELEMENTTYPE_IMAGE} types or the
 * text for {@link ELEMENTTYPE_TEXT} types.
 * @property {Color} outlineColor The text outline effect color and opacity. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {number} outlineThickness The width of the text outline effect. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {Color} shadowColor The text shadow effect color and opacity. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {Vec2} shadowOffset The text shadow effect shift amount from original text. Only works
 * for {@link ELEMENTTYPE_TEXT} types.
 * @property {boolean} autoWidth Automatically set the width of the component to be the same as the
 * textWidth. Only works for {@link ELEMENTTYPE_TEXT} types.
 * @property {boolean} autoHeight Automatically set the height of the component to be the same as
 * the textHeight. Only works for {@link ELEMENTTYPE_TEXT} types.
 * @property {number} fontAsset The id of the font asset used for rendering the text. Only works
 * for {@link ELEMENTTYPE_TEXT} types.
 * @property {Font} font The font used for rendering the text. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {number} fontSize The size of the font. Only works for {@link ELEMENTTYPE_TEXT} types.
 * @property {boolean} autoFitWidth When true the font size and line height will scale so that the
 * text fits inside the width of the Element. The font size will be scaled between minFontSize and
 * maxFontSize. The value of autoFitWidth will be ignored if autoWidth is true.
 * @property {boolean} autoFitHeight When true the font size and line height will scale so that the
 * text fits inside the height of the Element. The font size will be scaled between minFontSize and
 * maxFontSize. The value of autoFitHeight will be ignored if autoHeight is true.
 * @property {number} minFontSize The minimum size that the font can scale to when autoFitWidth or
 * autoFitHeight are true.
 * @property {number} maxFontSize The maximum size that the font can scale to when autoFitWidth or
 * autoFitHeight are true.
 * @property {number} spacing The spacing between the letters of the text. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {number} lineHeight The height of each line of text. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {boolean} wrapLines Whether to automatically wrap lines based on the element width.
 * Only works for {@link ELEMENTTYPE_TEXT} types, and when autoWidth is set to false.
 * @property {number} maxLines The maximum number of lines that the Element can wrap to. Any
 * leftover text will be appended to the last line. Set this to null to allow unlimited lines.
 * @property {Vec2} alignment The horizontal and vertical alignment of the text. Values range from
 * 0 to 1 where [0,0] is the bottom left and [1,1] is the top right.  Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {string} text The text to render. Only works for {@link ELEMENTTYPE_TEXT} types.
 * @property {string} key The localization key to use to get the localized text from
 * {@link Application#i18n}. Only works for {@link ELEMENTTYPE_TEXT} types.
 * @property {number} textureAsset The id of the texture asset to render. Only works for
 * {@link ELEMENTTYPE_IMAGE} types.
 * @property {Texture} texture The texture to render. Only works for {@link ELEMENTTYPE_IMAGE}
 * types.
 * @property {number} spriteAsset The id of the sprite asset to render. Only works for
 * {@link ELEMENTTYPE_IMAGE} types which can render either a texture or a sprite.
 * @property {Sprite} sprite The sprite to render. Only works for {@link ELEMENTTYPE_IMAGE} types
 * which can render either a texture or a sprite.
 * @property {number} spriteFrame The frame of the sprite to render. Only works for
 * {@link ELEMENTTYPE_IMAGE} types who have a sprite assigned.
 * @property {number} pixelsPerUnit The number of pixels that map to one PlayCanvas unit. Only
 * works for {@link ELEMENTTYPE_IMAGE} types who have a sliced sprite assigned.
 * @property {number} materialAsset The id of the material asset to use when rendering an image.
 * Only works for {@link ELEMENTTYPE_IMAGE} types.
 * @property {Material} material The material to use when rendering an image. Only works for
 * {@link ELEMENTTYPE_IMAGE} types.
 * @property {Vec4} rect Specifies which region of the texture to use in order to render an image.
 * Values range from 0 to 1 and indicate u, v, width, height. Only works for
 * {@link ELEMENTTYPE_IMAGE} types.
 * @property {boolean} rtlReorder Reorder the text for RTL languages using a function registered
 * by `app.systems.element.registerUnicodeConverter`.
 * @property {boolean} unicodeConverter Convert unicode characters using a function registered by
 * `app.systems.element.registerUnicodeConverter`.
 * @property {boolean} enableMarkup Flag for enabling markup processing. Only works for
 * {@link ELEMENTTYPE_TEXT} types. The only supported tag is `[color]` with a hex color value. e.g.
 * `[color="#ff0000"]red text[/color]`
 * @property {number} rangeStart Index of the first character to render. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {number} rangeEnd Index of the last character to render. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {boolean} mask Switch Image Element into a mask. Masks do not render into the scene,
 * but instead limit child elements to only be rendered where this element is rendered.
 * @augments Component
 */
declare class ElementComponent$2 extends Component$2 {
    /**
     * Create a new ElementComponent instance.
     *
     * @param {ElementComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ElementComponentSystem$1, entity: Entity$a);
    _beingInitialized: boolean;
    _anchor: Vec4$6;
    _localAnchor: Vec4$6;
    _pivot: Vec2$3;
    _width: number;
    _calculatedWidth: number;
    _height: number;
    _calculatedHeight: number;
    _margin: Vec4$6;
    _modelTransform: Mat4$5;
    _screenToWorld: Mat4$5;
    _anchorTransform: Mat4$5;
    _anchorDirty: boolean;
    _parentWorldTransform: Mat4$5;
    _screenTransform: Mat4$5;
    _screenCorners: Vec3$1[];
    _canvasCorners: Vec2$3[];
    _worldCorners: Vec3$1[];
    _cornersDirty: boolean;
    _canvasCornersDirty: boolean;
    _worldCornersDirty: boolean;
    screen: any;
    _type: string;
    _image: ImageElement;
    _text: TextElement;
    _group: any;
    _drawOrder: number;
    _useInput: boolean;
    _layers: number[];
    _addedModels: any[];
    _batchGroupId: number;
    _batchGroup: any;
    _offsetReadAt: number;
    _maskOffset: number;
    _maskedBy: any;

    set alignment(arg: Vec2$3);
    get alignment(): Vec2$3;

    set autoFitHeight(arg: boolean);
    get autoFitHeight(): boolean;

    set autoFitWidth(arg: boolean);
    get autoFitWidth(): boolean;

    set autoHeight(arg: boolean);
    get autoHeight(): boolean;

    set autoWidth(arg: boolean);
    get autoWidth(): boolean;

    set color(arg: Color$2);
    get color(): Color$2;

    set enableMarkup(arg: boolean);
    get enableMarkup(): boolean;

    set font(arg: Font|CanvasFont);
    get font(): Font|CanvasFont;

    set fontAsset(arg: number);
    get fontAsset(): number;

    set fontSize(arg: number);
    get fontSize(): number;

    set key(arg: string);
    get key(): string;

    set lineHeight(arg: number);
    get lineHeight(): number;

    set mask(arg: boolean);
    get mask(): boolean;

    set material(arg: Material);
    get material(): Material;

    set materialAsset(arg: number);
    get materialAsset(): number;

    set maxFontSize(arg: number);
    get maxFontSize(): number;

    set maxLines(arg: number);
    get maxLines(): number;

    set minFontSize(arg: number);
    get minFontSize(): number;

    set opacity(arg: number);
    get opacity(): number;

    set outlineColor(arg: Color$2);
    get outlineColor(): Color$2;

    set outlineThickness(arg: number);
    get outlineThickness(): number;

    set pixelsPerUnit(arg: number);
    get pixelsPerUnit(): number;

    set rangeEnd(arg: number);
    get rangeEnd(): number;

    set rangeStart(arg: number);
    get rangeStart(): number;

    set rect(arg: Vec4$6);
    get rect(): Vec4$6;

    set rtlReorder(arg: boolean);
    get rtlReorder(): boolean;

    set shadowColor(arg: Color$2);
    get shadowColor(): Color$2;

    set shadowOffset(arg: number);
    get shadowOffset(): number;

    set spacing(arg: number);
    get spacing(): number;

    set sprite(arg: Sprite);
    get sprite(): Sprite;

    set spriteAsset(arg: number);
    get spriteAsset(): number;

    set spriteFrame(arg: number);
    get spriteFrame(): number;

    set text(arg: string);
    get text(): string;

    set texture(arg: Texture$2);
    get texture(): Texture$2;

    set textureAsset(arg: number);
    get textureAsset(): number;

    set unicodeConverter(arg: boolean);
    get unicodeConverter(): boolean;

    set wrapLines(arg: boolean);
    get wrapLines(): boolean;

    get _absLeft(): number;
    get _absRight(): number;
    get _absTop(): number;
    get _absBottom(): number;
    get _hasSplitAnchorsX(): boolean;
    get _hasSplitAnchorsY(): boolean;
    get aabb(): any;
    /**
     * Specifies where the left, bottom, right and top edges of the component are anchored relative
     * to its parent. Each value ranges from 0 to 1. e.g. a value of [0, 0, 0, 0] means that the
     * element will be anchored to the bottom left of its parent. A value of [1, 1, 1, 1] means it
     * will be anchored to the top right. A split anchor is when the left-right or top-bottom pairs
     * of the anchor are not equal. In that case the component will be resized to cover that entire
     * area. e.g. a value of [0, 0, 1, 1] will make the component resize exactly as its parent.
     *
     * @type {Vec4}
     */
    set anchor(arg: Vec4$6);
    get anchor(): Vec4$6;
    /**
     * Assign element to a specific batch group (see {@link BatchGroup}). Default is -1 (no group).
     *
     * @type {number}
     */
    set batchGroupId(arg: number);
    get batchGroupId(): number;
    /**
     * The distance from the bottom edge of the anchor. Can be used in combination with a split
     * anchor to make the component's top edge always be 'top' units away from the top.
     *
     * @type {number}
     */
    set bottom(arg: number);
    get bottom(): number;
    /**
     * The width at which the element will be rendered. In most cases this will be the same as
     * `width`. However, in some cases the engine may calculate a different width for the element,
     * such as when the element is under the control of a {@link LayoutGroupComponent}. In these
     * scenarios, `calculatedWidth` may be smaller or larger than the width that was set in the
     * editor.
     *
     * @type {number}
     */
    set calculatedWidth(arg: number);
    get calculatedWidth(): number;
    /**
     * The height at which the element will be rendered. In most cases this will be the same as
     * `height`. However, in some cases the engine may calculate a different height for the element,
     * such as when the element is under the control of a {@link LayoutGroupComponent}. In these
     * scenarios, `calculatedHeight` may be smaller or larger than the height that was set in the
     * editor.
     *
     * @type {number}
     */
    set calculatedHeight(arg: number);
    get calculatedHeight(): number;
    /**
     * An array of 4 {@link Vec2}s that represent the bottom left, bottom right, top right and top
     * left corners of the component in canvas pixels. Only works for screen space element
     * components.
     *
     * @type {Vec2[]}
     */
    get canvasCorners(): Vec2$3[];
    /**
     * The draw order of the component. A higher value means that the component will be rendered on
     * top of other components.
     *
     * @type {number}
     */
    set drawOrder(arg: number);
    get drawOrder(): number;
    /**
     * The height of the element as set in the editor. Note that in some cases this may not reflect
     * the true height at which the element is rendered, such as when the element is under the
     * control of a {@link LayoutGroupComponent}. See `calculatedHeight` in order to ensure you are
     * reading the true height at which the element will be rendered.
     *
     * @type {number}
     */
    set height(arg: number);
    get height(): number;
    /**
     * An array of layer IDs ({@link Layer#id}) to which this element should belong. Don't push,
     * pop, splice or modify this array, if you want to change it - set a new one instead.
     *
     * @type {number[]}
     */
    set layers(arg: number[]);
    get layers(): number[];
    /**
     * The distance from the left edge of the anchor. Can be used in combination with a split
     * anchor to make the component's left edge always be 'left' units away from the left.
     *
     * @type {number}
     */
    set left(arg: number);
    get left(): number;
    /**
     * The distance from the left, bottom, right and top edges of the anchor. For example if we are
     * using a split anchor like [0,0,1,1] and the margin is [0,0,0,0] then the component will be
     * the same width and height as its parent.
     *
     * @type {Vec4}
     */
    set margin(arg: Vec4$6);
    get margin(): Vec4$6;
    /**
     * Get the entity that is currently masking this element.
     *
     * @type {Entity}
     * @private
     */
    private get maskedBy();
    /**
     * The position of the pivot of the component relative to its anchor. Each value ranges from 0
     * to 1 where [0,0] is the bottom left and [1,1] is the top right.
     *
     * @type {Vec2}
     */
    set pivot(arg: Vec2$3);
    get pivot(): Vec2$3;
    /**
     * The distance from the right edge of the anchor. Can be used in combination with a split
     * anchor to make the component's right edge always be 'right' units away from the right.
     *
     * @type {number}
     */
    set right(arg: number);
    get right(): number;
    /**
     * An array of 4 {@link Vec3}s that represent the bottom left, bottom right, top right and top
     * left corners of the component relative to its parent {@link ScreenComponent}.
     *
     * @type {Vec3[]}
     */
    get screenCorners(): Vec3$1[];
    /**
     * The width of the text rendered by the component. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    get textWidth(): number;
    /**
     * The height of the text rendered by the component. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    get textHeight(): number;
    /**
     * The distance from the top edge of the anchor. Can be used in combination with a split anchor
     * to make the component's bottom edge always be 'bottom' units away from the bottom.
     *
     * @type {number}
     */
    set top(arg: number);
    get top(): number;
    /**
     * The type of the ElementComponent. Can be:
     *
     * - {@link ELEMENTTYPE_GROUP}: The component can be used as a layout mechanism to create groups of
     * ElementComponents e.g. panels.
     * - {@link ELEMENTTYPE_IMAGE}: The component will render an image
     * - {@link ELEMENTTYPE_TEXT}: The component will render text
     *
     * @type {string}
     */
    set type(arg: string);
    get type(): string;
    /**
     * If true then the component will receive Mouse or Touch input events.
     *
     * @type {boolean}
     */
    set useInput(arg: boolean);
    get useInput(): boolean;
    /**
     * The width of the element as set in the editor. Note that in some cases this may not reflect
     * the true width at which the element is rendered, such as when the element is under the
     * control of a {@link LayoutGroupComponent}. See `calculatedWidth` in order to ensure you are
     * reading the true width at which the element will be rendered.
     *
     * @type {number}
     */
    set width(arg: number);
    get width(): number;
    /**
     * An array of 4 {@link Vec3}s that represent the bottom left, bottom right, top right and top
     * left corners of the component in world space. Only works for 3D element components.
     *
     * @type {Vec3[]}
     */
    get worldCorners(): Vec3$1[];
    _patch(): void;
    _unpatch(): void;
    _setPosition(x: any, y: any, z: any): any;
    _setLocalPosition(x: any, y: any, z: any): void;
    _sync(): any;
    _dirtyLocal: boolean;
    _dirtyWorld: boolean;
    _onInsert(parent: any): void;
    _dirtifyMask(): void;
    _onPrerender(): void;
    _bindScreen(screen: any): void;
    _unbindScreen(screen: any): void;
    _updateScreen(screen: any): void;
    syncMask(depth: any): void;
    _setMaskedBy(mask: any): void;
    _updateMask(currentMask: any, depth: any): void;
    _parseUpToScreen(): {
        screen: any;
        mask: any;
    };
    _onScreenResize(res: any): void;
    _onScreenSpaceChange(): void;
    _onScreenRemove(): void;
    _calculateLocalAnchors(): void;
    getOffsetPosition(x: any, y: any): Vec3$1;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    onRemove(): void;
    _calculateSize(propagateCalculatedWidth: any, propagateCalculatedHeight: any): void;
    _sizeDirty: boolean;
    _setWidth(w: any): void;
    _setHeight(h: any): void;
    _setCalculatedWidth(value: any, updateMargins: any): void;
    _setCalculatedHeight(value: any, updateMargins: any): void;
    _flagChildrenAsDirty(): void;
    addModelToLayers(model: any): void;
    removeModelFromLayers(model: any): void;
    getMaskOffset(): number;
    isVisibleForCamera(camera: any): boolean;
    _isScreenSpace(): any;
    _isScreenCulled(): any;
}

/**
 * Helper class that makes it easy to create Elements that can be dragged by the mouse or touch.
 *
 * @augments EventHandler
 */
declare class ElementDragHelper extends EventHandler$1 {
    /**
     * Create a new ElementDragHelper instance.
     *
     * @param {ElementComponent} element - The Element that should become draggable.
     * @param {string} [axis] - Optional axis to constrain to, either 'x', 'y' or null.
     */
    constructor(element: ElementComponent$2, axis?: string);
    _element: ElementComponent$2;
    _app: Application$7;
    _axis: string;
    _enabled: boolean;
    _dragScale: Vec3$1;
    _dragStartMousePosition: Vec3$1;
    _dragStartHandlePosition: Vec3$1;
    _deltaMousePosition: Vec3$1;
    _deltaHandlePosition: Vec3$1;
    _isDragging: boolean;
    _toggleLifecycleListeners(onOrOff: any): void;
    _toggleDragListeners(onOrOff: any): void;
    _handleMouseUpOrTouchEnd: any;
    _hasDragListeners: boolean;
    _onMouseDownOrTouchStart(event: any): void;
    _dragCamera: any;
    _onMouseUpOrTouchEnd(): void;
    _screenToLocal(event: any): Vec3$1;
    _determineInputPosition(event: any): void;
    _chooseRayOriginAndDirection(): void;
    _calculateDragScale(): void;
    _onMove(event: any): void;
    destroy(): void;
    set enabled(arg: boolean);
    get enabled(): boolean;
    get isDragging(): boolean;
}

type Entity$p = Entity$a;
type ScrollViewComponentSystem$1 = ScrollViewComponentSystem$2;
/**
 * A ScrollViewComponent enables a group of entities to behave like a masked scrolling area, with
 * optional horizontal and vertical scroll bars.
 *
 * @property {boolean} horizontal Whether to enable horizontal scrolling.
 * @property {boolean} vertical Whether to enable vertical scrolling.
 * @property {number} scrollMode Specifies how the scroll view should behave when the user scrolls
 * past the end of the content. Modes are defined as follows:
 *
 * - {@link SCROLL_MODE_CLAMP}: Content does not scroll any further than its bounds.
 * - {@link SCROLL_MODE_BOUNCE}: Content scrolls past its bounds and then gently bounces back.
 * - {@link SCROLL_MODE_INFINITE}: Content can scroll forever.
 *
 * @property {number} bounceAmount Controls how far the content should move before bouncing back.
 * @property {number} friction Controls how freely the content should move if thrown, i.e. By
 * flicking on a phone or by flinging the scroll wheel on a mouse. A value of 1 means that content
 * will stop immediately; 0 means that content will continue moving forever (or until the bounds of
 * the content are reached, depending on the scrollMode).
 * @property {boolean} useMouseWheel Whether to use mouse wheel for scrolling (horizontally and
 * vertically).
 * @property {Vec2} mouseWheelSensitivity Mouse wheel horizontal and vertical sensitivity. Only
 * used if useMouseWheel is set. Setting a direction to 0 will disable mouse wheel scrolling in
 * that direction. 1 is a default sensitivity that is considered to feel good. The values can be
 * set higher or lower than 1 to tune the sensitivity. Defaults to [1, 1].
 * @property {number} horizontalScrollbarVisibility Controls whether the horizontal scrollbar
 * should be visible all the time, or only visible when the content exceeds the size of the
 * viewport.
 * @property {number} verticalScrollbarVisibility Controls whether the vertical scrollbar should be
 * visible all the time, or only visible when the content exceeds the size of the viewport.
 * @property {Entity} viewportEntity The entity to be used as the masked viewport area, within
 * which the content will scroll. This entity must have an ElementGroup component.
 * @property {Entity} contentEntity The entity which contains the scrolling content itself. This
 * entity must have an Element component.
 * @property {Entity} horizontalScrollbarEntity The entity to be used as the vertical scrollbar.
 * This entity must have a Scrollbar component.
 * @property {Entity} verticalScrollbarEntity The entity to be used as the vertical scrollbar. This
 * entity must have a Scrollbar component.
 * @augments Component
 */
declare class ScrollViewComponent$1 extends Component$2 {
    /**
     * Create a new ScrollViewComponent.
     *
     * @param {ScrollViewComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ScrollViewComponentSystem$1, entity: Entity$p);
    _viewportReference: EntityReference;
    _contentReference: EntityReference;
    _scrollbarUpdateFlags: {};
    _scrollbarReferences: {};
    _prevContentSizes: {};
    _scroll: Vec2$3;
    _velocity: Vec3$1;
    _dragStartPosition: Vec3$1;
    _disabledContentInput: boolean;
    _disabledContentInputEntities: any[];
    _toggleLifecycleListeners(onOrOff: any, system: any): void;
    _toggleElementListeners(onOrOff: any): void;
    _hasElementListeners: boolean;
    _onElementComponentAdd(entity: any): void;
    _onElementComponentRemove(entity: any): void;
    _onViewportElementGain(): void;
    _onContentElementGain(): void;
    _contentDragHelper: ElementDragHelper;
    _onContentElementLose(): void;
    _onContentDragStart(): void;
    _onContentDragEnd(): void;
    _prevContentDragPosition: any;
    _onContentDragMove(position: any): void;
    _wasDragged: boolean;
    _onSetContentOrViewportSize(): void;
    _onSetHorizontalScrollbarValue(scrollValueX: any): void;
    _onSetVerticalScrollbarValue(scrollValueY: any): void;
    _onSetHorizontalScrollingEnabled(): void;
    _onSetVerticalScrollingEnabled(): void;
    _onHorizontalScrollbarGain(): void;
    _onVerticalScrollbarGain(): void;
    _onSetScroll(x: any, y: any, resetVelocity: any): void;
    _updateAxis(scrollValue: any, axis: any, orientation: any): boolean;
    _determineNewScrollValue(scrollValue: any, axis: any, orientation: any): any;
    _syncAll(): void;
    _syncContentPosition(orientation: any): void;
    _syncScrollbarPosition(orientation: any): void;
    _syncScrollbarEnabledState(orientation: any): void;
    _contentIsLargerThanViewport(orientation: any): boolean;
    _contentPositionToScrollValue(contentPosition: any): Vec2$3;
    _getMaxOffset(orientation: any, contentSize: any): number;
    _getMaxScrollValue(orientation: any): 1 | 0;
    _getScrollbarHandleSize(axis: any, orientation: any): number;
    _getViewportSize(orientation: any): any;
    _getContentSize(orientation: any): any;
    _getSize(orientation: any, entityReference: any): any;
    _getScrollingEnabled(orientation: any): any;
    _getScrollbarVisibility(orientation: any): any;
    _getSign(orientation: any): 1 | -1;
    _getAxis(orientation: any): "x" | "y";
    _getCalculatedDimension(orientation: any): "calculatedWidth" | "calculatedHeight";
    _destroyDragHelper(): void;
    onUpdate(): void;
    _updateVelocity(): void;
    _hasOvershoot(axis: any, orientation: any): boolean;
    _toOvershoot(scrollValue: any, orientation: any): any;
    _setVelocityFromOvershoot(scrollValue: any, axis: any, orientation: any): void;
    _setVelocityFromContentPositionDelta(position: any): void;
    _setScrollFromContentPosition(position: any): void;
    _applyScrollValueTension(scrollValue: any): any;
    _isDragging(): boolean;
    _setScrollbarComponentsEnabled(enabled: any): void;
    _setContentDraggingEnabled(enabled: any): void;
    _onMouseWheel(event: any): void;
    set scroll(arg: Vec2$3);
    get scroll(): Vec2$3;
    _enableContentInput(): void;
    _disableContentInput(): void;
    onRemove(): void;
}

declare class ScrollbarComponentData {
    enabled: boolean;
}

/**
 * Manages creation of {@link ScrollbarComponent}s.
 *
 * @augments ComponentSystem
 */
declare class ScrollbarComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof ScrollbarComponent$1;
    DataType: typeof ScrollbarComponentData;
    _onRemoveComponent(entity: any, component: any): void;
}

type Entity$o = Entity$a;
type ScrollbarComponentSystem$1 = ScrollbarComponentSystem$2;
/** @typedef {import('../../application.js').Application} Application */
/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').ScrollbarComponentSystem} ScrollbarComponentSystem */
/**
 * A ScrollbarComponent enables a group of entities to behave like a draggable scrollbar.
 *
 * @property {number} orientation Whether the scrollbar moves horizontally or vertically. Can be:
 *
 * - {@link ORIENTATION_HORIZONTAL}: The scrollbar animates in the horizontal axis.
 * - {@link ORIENTATION_VERTICAL}: The scrollbar animates in the vertical axis.
 *
 * Defaults to {@link ORIENTATION_HORIZONTAL}.
 * @property {number} value The current position value of the scrollbar, in the range 0 to 1.
 * Defaults to 0.
 * @property {number} handleSize The size of the handle relative to the size of the track, in the
 * range 0 to 1. For a vertical scrollbar, a value of 1 means that the handle will take up the full
 * height of the track.
 * @property {Entity} handleEntity The entity to be used as the scrollbar handle. This entity must
 * have a Scrollbar component.
 * @augments Component
 */
declare class ScrollbarComponent$1 extends Component$2 {
    /**
     * Create a new ScrollbarComponent.
     *
     * @param {ScrollbarComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ScrollbarComponentSystem$1, entity: Entity$o);
    _app: Application$7;
    _handleReference: EntityReference;
    _toggleLifecycleListeners(onOrOff: any): void;
    _onHandleElementGain(): void;
    _handleDragHelper: ElementDragHelper;
    _onHandleElementLose(): void;
    _onHandleDrag(position: any): void;
    value: number;
    _onSetValue(name: any, oldValue: any, newValue: any): void;
    _onSetHandleSize(name: any, oldValue: any, newValue: any): void;
    _onSetHandleAlignment(): void;
    _onSetOrientation(name: any, oldValue: any, newValue: any): void;
    _updateHandlePositionAndSize(): void;
    _handlePositionToScrollValue(handlePosition: any): number;
    _scrollValueToHandlePosition(value: any): number;
    _getUsableTrackLength(): number;
    _getTrackLength(): number;
    _getHandleLength(): number;
    _getHandlePosition(): number;
    _getSign(): 1 | -1;
    _getAxis(): "x" | "y";
    _getDimension(): "height" | "width";
    _getOppositeDimension(): "height" | "width";
    _destroyDragHelper(): void;
    _setHandleDraggingEnabled(enabled: any): void;
    onRemove(): void;
}

declare class ScriptComponentData {
    enabled: boolean;
}

/**
 * Allows scripts to be attached to an Entity and executed.
 *
 * @augments ComponentSystem
 */
declare class ScriptComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof ScriptComponent$1;
    DataType: typeof ScriptComponentData;
    _components: SortedLoopArray;
    _enabledComponents: SortedLoopArray;
    preloading: boolean;
    _resetExecutionOrder(): void;
    _callComponentMethod(components: any, name: any, dt: any): void;
    _onInitialize(): void;
    _onPostInitialize(): void;
    _onUpdate(dt: any): void;
    _onPostUpdate(dt: any): void;
    _addComponentToEnabled(component: any): void;
    _removeComponentFromEnabled(component: any): void;
    _onBeforeRemove(entity: any, component: any): void;
}

/**
 * Container of Script Attribute definitions. Implements an interface to add/remove attributes and
 * store their definition for a {@link ScriptType}. Note: An instance of ScriptAttributes is
 * created automatically by each {@link ScriptType}.
 */
declare class ScriptAttributes {
    static reservedNames: Set<string>;
    /**
     * Create a new ScriptAttributes instance.
     *
     * @param {typeof ScriptType} scriptType - Script Type that attributes relate to.
     */
    constructor(scriptType: typeof ScriptType);
    scriptType: typeof ScriptType;
    index: {};
    /**
     * Add Attribute.
     *
     * @param {string} name - Name of an attribute.
     * @param {object} args - Object with Arguments for an attribute.
     * @param {("boolean"|"number"|"string"|"json"|"asset"|"entity"|"rgb"|"rgba"|"vec2"|"vec3"|"vec4"|"curve")} args.type - Type
     * of an attribute value.  Can be:
     *
     * - "asset"
     * - "boolean"
     * - "curve"
     * - "entity"
     * - "json"
     * - "number"
     * - "rgb"
     * - "rgba"
     * - "string"
     * - "vec2"
     * - "vec3"
     * - "vec4"
     *
     * @param {*} [args.default] - Default attribute value.
     * @param {string} [args.title] - Title for Editor's for field UI.
     * @param {string} [args.description] - Description for Editor's for field UI.
     * @param {string|string[]} [args.placeholder] - Placeholder for Editor's for field UI.
     * For multi-field types, such as vec2, vec3, and others use array of strings.
     * @param {boolean} [args.array] - If attribute can hold single or multiple values.
     * @param {number} [args.size] - If attribute is array, maximum number of values can be set.
     * @param {number} [args.min] - Minimum value for type 'number', if max and min defined, slider
     * will be rendered in Editor's UI.
     * @param {number} [args.max] - Maximum value for type 'number', if max and min defined, slider
     * will be rendered in Editor's UI.
     * @param {number} [args.precision] - Level of precision for field type 'number' with floating
     * values.
     * @param {number} [args.step] - Step value for type 'number'. The amount used to increment the
     * value when using the arrow keys in the Editor's UI.
     * @param {string} [args.assetType] - Name of asset type to be used in 'asset' type attribute
     * picker in Editor's UI, defaults to '*' (all).
     * @param {string[]} [args.curves] - List of names for Curves for field type 'curve'.
     * @param {string} [args.color] - String of color channels for Curves for field type 'curve',
     * can be any combination of `rgba` characters. Defining this property will render Gradient in
     * Editor's field UI.
     * @param {object[]} [args.enum] - List of fixed choices for field, defined as array of objects,
     * where key in object is a title of an option.
     * @param {object[]} [args.schema] - List of attributes for type 'json'. Each attribute
     * description is an object with the same properties as regular script attributes but with an
     * added 'name' field to specify the name of each attribute in the JSON.
     * @example
     * PlayerController.attributes.add('fullName', {
     *     type: 'string'
     * });
     * @example
     * PlayerController.attributes.add('speed', {
     *     type: 'number',
     *     title: 'Speed',
     *     placeholder: 'km/h',
     *     default: 22.2
     * });
     * @example
     * PlayerController.attributes.add('resolution', {
     *     type: 'number',
     *     default: 32,
     *     enum: [
     *         { '32x32': 32 },
     *         { '64x64': 64 },
     *         { '128x128': 128 }
     *     ]
     * });
     * @example
     * PlayerController.attributes.add('config', {
     *     type: 'json',
     *     schema: [{
     *         name: 'speed',
     *         type: 'number',
     *         title: 'Speed',
     *         placeholder: 'km/h',
     *         default: 22.2
     *     }, {
     *         name: 'resolution',
     *         type: 'number',
     *         default: 32,
     *         enum: [
     *             { '32x32': 32 },
     *             { '64x64': 64 },
     *             { '128x128': 128 }
     *         ]
     *     }]
     * });
     */
    add(name: string, args: {
        type: ("boolean" | "number" | "string" | "json" | "asset" | "entity" | "rgb" | "rgba" | "vec2" | "vec3" | "vec4" | "curve");
        default?: any;
        title?: string;
        description?: string;
        placeholder?: string | string[];
        array?: boolean;
        size?: number;
        min?: number;
        max?: number;
        precision?: number;
        step?: number;
        assetType?: string;
        curves?: string[];
        color?: string;
        enum?: object[];
        schema?: object[];
    }): void;
    /**
     * Remove Attribute.
     *
     * @param {string} name - Name of an attribute.
     * @returns {boolean} True if removed or false if not defined.
     * @example
     * PlayerController.attributes.remove('fullName');
     */
    remove(name: string): boolean;
    /**
     * Detect if Attribute is added.
     *
     * @param {string} name - Name of an attribute.
     * @returns {boolean} True if Attribute is defined.
     * @example
     * if (PlayerController.attributes.has('fullName')) {
     *     // attribute fullName is defined
     * }
     */
    has(name: string): boolean;
    /**
     * Get object with attribute arguments. Note: Changing argument properties will not affect
     * existing Script Instances.
     *
     * @param {string} name - Name of an attribute.
     * @returns {?object} Arguments with attribute properties.
     * @example
     * // changing default value for an attribute 'fullName'
     * var attr = PlayerController.attributes.get('fullName');
     * if (attr) attr.default = 'Unknown';
     */
    get(name: string): object | null;
}

type Application$f = Application$7;
type Entity$n = Entity$a;
/**
 * Represents the type of a script. It is returned by {@link createScript}. Also referred to as
 * Script Type.
 *
 * The type is to be extended using its JavaScript prototype. There is a list of methods that will
 * be executed by the engine on instances of this type, such as:
 *
 * - `initialize`
 * - `postInitialize`
 * - `update`
 * - `postUpdate`
 * - `swap`
 *
 * `initialize` and `postInitialize` - are called (if defined) when a script is about to run for
 * the first time - `postInitialize` will run after all `initialize` methods are executed in the
 * same tick or enabling chain of actions.
 *
 * `update` and `postUpdate` - are called (if defined) for enabled (running state) scripts on each
 * tick.
 *
 * `swap` - is called when a ScriptType that already exists in the registry gets redefined. If the
 * new ScriptType has a `swap` method in its prototype, then it will be executed to perform hot-
 * reload at runtime.
 *
 * @augments EventHandler
 */
declare class ScriptType extends EventHandler$1 {
    /**
     * Name of a Script Type.
     *
     * @type {string}
     * @private
     */
    private static __name;
    static __getScriptName(constructorFn: any): any;
    /**
     * Name of a Script Type.
     *
     * @type {string|null}
     */
    static get scriptName(): string;
    /**
     * The interface to define attributes for Script Types. Refer to {@link ScriptAttributes}.
     *
     * @type {ScriptAttributes}
     * @example
     * var PlayerController = pc.createScript('playerController');
     *
     * PlayerController.attributes.add('speed', {
     *     type: 'number',
     *     title: 'Speed',
     *     placeholder: 'km/h',
     *     default: 22.2
     * });
     */
    static get attributes(): ScriptAttributes;
    /**
     * Shorthand function to extend Script Type prototype with list of methods.
     *
     * @param {object} methods - Object with methods, where key - is name of method, and value - is function.
     * @example
     * var PlayerController = pc.createScript('playerController');
     *
     * PlayerController.extend({
     *     initialize: function () {
     *         // called once on initialize
     *     },
     *     update: function (dt) {
     *         // called each tick
     *     }
     * });
     */
    static extend(methods: object): void;
    /**
     * Create a new ScriptType instance.
     *
     * @param {object} args - The input arguments object.
     * @param {Application} args.app - The {@link Application} that is running the script.
     * @param {Entity} args.entity - The {@link Entity} that the script is attached to.
     */
    constructor(args: {
        app: Application$f;
        entity: Entity$n;
    });
    /**
     * True if the instance of this type is in running state. False when script is not running,
     * because the Entity or any of its parents are disabled or the {@link ScriptComponent} is
     * disabled or the Script Instance is disabled. When disabled no update methods will be called
     * on each tick. initialize and postInitialize methods will run once when the script instance
     * is in `enabled` state during app tick.
     *
     * @type {boolean}
     */
    set enabled(arg: boolean);
    get enabled(): boolean;
    _enabled: any;
    _enabledOld: any;
    _initialized: boolean;
    _postInitialized: boolean;
    initScriptType(args: any): void;
    /**
     * The {@link Application} that the instance of this type belongs to.
     *
     * @type {Application}
     */
    app: Application$f;
    /**
     * The {@link Entity} that the instance of this type belongs to.
     *
     * @type {Entity}
     */
    entity: Entity$n;
    __destroyed: boolean;
    __attributes: {};
    __attributesRaw: any;
    __scriptType: Function;
    __executionOrder: number;
    __initializeAttributes(force: any): void;
    /**
     * @callback scriptTypeInitializeCallback
     */
    /**
     * @callback scriptTypeUpdateCallback
     * @param {number} dt - The delta time in seconds since the last frame.
     */
    /**
     * @callback scriptTypeSwapCallback
     * @param {ScriptType} old - The delta time in seconds since the last frame.
     */
    /**
     * Called when script is about to run for the first time.
     *
     * @type {scriptTypeInitializeCallback}
     */
    initialize: () => any;
    /**
     * Called after all initialize methods are executed in the same tick or enabling chain of actions.
     *
     * @type {scriptTypeInitializeCallback}
     */
    postInitialize: () => any;
    /**
     * Called for enabled (running state) scripts on each tick. It is passed the delta time in
     * seconds since the last frame.
     *
     * @type {scriptTypeUpdateCallback}
     */
    update: (dt: number) => any;
    /**
     * Called for enabled (running state) scripts on each tick, after update. It is passed the
     * delta time in seconds since the last frame.
     *
     * @type {scriptTypeUpdateCallback}
     */
    postUpdate: (dt: number) => any;
    /**
     * Called when a ScriptType that already exists in the registry gets redefined. If the new
     * ScriptType has a `swap` method in its prototype, then it will be executed to perform
     * hot-reload at runtime. It is passed the old instance of the scriptType to copy data to the
     * new instance.
     *
     * @type {scriptTypeSwapCallback}
     */
    swap: (old: ScriptType) => any;
}

type ScriptComponentSystem$1 = ScriptComponentSystem$2;
/** @typedef {import('./system.js').ScriptComponentSystem} ScriptComponentSystem */
/**
 * The ScriptComponent allows you to extend the functionality of an Entity by attaching your own
 * Script Types defined in JavaScript files to be executed with access to the Entity. For more
 * details on scripting see [Scripting](https://developer.playcanvas.com/user-manual/scripting/).
 *
 * @augments Component
 */
declare class ScriptComponent$1 extends Component$2 {
    static scriptMethods: {
        initialize: string;
        postInitialize: string;
        update: string;
        postUpdate: string;
        swap: string;
    };
    /**
     * Create a new ScriptComponent instance.
     *
     * @param {ScriptComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ScriptComponentSystem$1, entity: Entity$a);
    _scripts: any[];
    _updateList: SortedLoopArray;
    _postUpdateList: SortedLoopArray;
    _scriptsIndex: {};
    _destroyedScripts: any[];
    _destroyed: boolean;
    _scriptsData: any[];
    _oldState: boolean;
    _enabled: boolean;
    _beingEnabled: boolean;
    _isLoopingThroughScripts: boolean;
    _executionOrder: number;
    set enabled(arg: boolean);
    get enabled(): boolean;
    /**
     * An array of all script instances attached to an entity. This array is read-only and should
     * not be modified by developer.
     *
     * @type {ScriptType[]}
     */
    set scripts(arg: any[]);
    get scripts(): any[];
    _beginLooping(): boolean;
    _endLooping(wasLoopingBefore: any): void;
    _onSetEnabled(prop: any, old: any, value: any): void;
    _checkState(): void;
    _onBeforeRemove(): void;
    _removeDestroyedScripts(): void;
    _onInitializeAttributes(): void;
    _scriptMethod(script: any, method: any, arg: any): void;
    _onInitialize(): void;
    _onPostInitialize(): void;
    _onUpdate(dt: any): void;
    _onPostUpdate(dt: any): void;
    /**
     * Inserts script instance into the scripts array at the specified index. Also inserts the
     * script into the update list if it has an update method and the post update list if it has a
     * postUpdate method.
     *
     * @param {object} scriptInstance - The script instance.
     * @param {number} index - The index where to insert the script at. If -1, append it at the end.
     * @param {number} scriptsLength - The length of the scripts array.
     * @private
     */
    private _insertScriptInstance;
    _removeScriptInstance(scriptInstance: any): number;
    _resetExecutionOrder(startIndex: any, scriptsLength: any): void;
    _resolveEntityScriptAttribute(attribute: any, attributeName: any, oldValue: any, useGuid: any, newAttributes: any, duplicatedIdsMap: any): void;
    /**
     * Detect if script is attached to an entity.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @returns {boolean} If script is attached to an entity.
     * @example
     * if (entity.script.has('playerController')) {
     *     // entity has script
     * }
     */
    has(nameOrType: string | typeof ScriptType): boolean;
    /**
     * Get a script instance (if attached).
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @returns {ScriptType|null} If script is attached, the instance is returned. Otherwise null
     * is returned.
     * @example
     * var controller = entity.script.get('playerController');
     */
    get(nameOrType: string | typeof ScriptType): ScriptType | null;
    /**
     * Create a script instance and attach to an entity script component.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @param {object} [args] - Object with arguments for a script.
     * @param {boolean} [args.enabled] - If script instance is enabled after creation. Defaults to
     * true.
     * @param {object} [args.attributes] - Object with values for attributes (if any), where key is
     * name of an attribute.
     * @param {boolean} [args.preloading] - If script instance is created during preload. If true,
     * script and attributes must be initialized manually. Defaults to false.
     * @param {number} [args.ind] - The index where to insert the script instance at. Defaults to
     * -1, which means append it at the end.
     * @returns {ScriptType|null} Returns an instance of a {@link ScriptType} if successfully attached
     * to an entity, or null if it failed because a script with a same name has already been added
     * or if the {@link ScriptType} cannot be found by name in the {@link ScriptRegistry}.
     * @example
     * entity.script.create('playerController', {
     *     attributes: {
     *         speed: 4
     *     }
     * });
     */
    create(nameOrType: string | typeof ScriptType, args?: {
        enabled?: boolean;
        attributes?: object;
        preloading?: boolean;
        ind?: number;
    }): ScriptType | null;
    /**
     * Destroy the script instance that is attached to an entity.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @returns {boolean} If it was successfully destroyed.
     * @example
     * entity.script.destroy('playerController');
     */
    destroy(nameOrType: string | typeof ScriptType): boolean;
    /**
     * Swap the script instance.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @returns {boolean} If it was successfully swapped.
     * @private
     */
    private swap;
    /**
     * When an entity is cloned and it has entity script attributes that point to other entities in
     * the same subtree that is cloned, then we want the new script attributes to point at the
     * cloned entities. This method remaps the script attributes for this entity and it assumes
     * that this entity is the result of the clone operation.
     *
     * @param {ScriptComponent} oldScriptComponent - The source script component that belongs to
     * the entity that was being cloned.
     * @param {object} duplicatedIdsMap - A dictionary with guid-entity values that contains the
     * entities that were cloned.
     * @private
     */
    private resolveDuplicatedEntityReferenceProperties;
    /**
     * Move script instance to different position to alter update order of scripts within entity.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @param {number} ind - New position index.
     * @returns {boolean} If it was successfully moved.
     * @example
     * entity.script.move('playerController', 0);
     */
    move(nameOrType: string | typeof ScriptType, ind: number): boolean;
}

declare class ScreenComponentData {
    enabled: boolean;
}

/**
 * Manages creation of {@link ScreenComponent}s.
 *
 * @augments ComponentSystem
 */
declare class ScreenComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof ScreenComponent$1;
    DataType: typeof ScreenComponentData;
    windowResolution: Vec2$3;
    _drawOrderSyncQueue: IndexedList;
    _onUpdate(dt: any): void;
    _onResize(width: any, height: any): void;
    onRemoveComponent(entity: any, component: any): void;
    processDrawOrderSyncQueue(): void;
    queueDrawOrderSync(id: any, fn: any, scope: any): void;
}

type ScreenComponentSystem$1 = ScreenComponentSystem$2;
/**
 * A ScreenComponent enables the Entity to render child {@link ElementComponent}s using anchors and
 * positions in the ScreenComponent's space.
 *
 * @augments Component
 */
declare class ScreenComponent$1 extends Component$2 {
    /**
     * Create a new ScreenComponent.
     *
     * @param {ScreenComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ScreenComponentSystem$1, entity: Entity$a);
    _resolution: Vec2$3;
    _referenceResolution: Vec2$3;
    _scaleMode: string;
    scale: number;
    _scaleBlend: number;
    _priority: number;
    _screenSpace: boolean;
    /**
     * If true then elements inside this screen will be not be rendered when outside of the
     * screen (only valid when screenSpace is true).
     *
     * @type {boolean}
     */
    cull: boolean;
    _screenMatrix: Mat4$5;
    _elements: Set<any>;
    /**
     * Set the drawOrder of each child {@link ElementComponent} so that ElementComponents which are
     * last in the hierarchy are rendered on top. Draw Order sync is queued and will be updated by
     * the next update loop.
     */
    syncDrawOrder(): void;
    _recurseDrawOrderSync(e: any, i: any): any;
    _processDrawOrderSync(): void;
    _calcProjectionMatrix(): void;
    _updateScale(): void;
    _calcScale(resolution: any, referenceResolution: any): number;
    _onResize(width: any, height: any): void;
    /**
     * The width and height of the ScreenComponent. When screenSpace is true the resolution will
     * always be equal to {@link GraphicsDevice#width} x {@link GraphicsDevice#height}.
     *
     * @type {Vec2}
     */
    set resolution(arg: Vec2$3);
    get resolution(): Vec2$3;
    _bindElement(element: any): void;
    _unbindElement(element: any): void;
    onRemove(): void;
    /**
     * The resolution that the ScreenComponent is designed for. This is only taken into account
     * when screenSpace is true and scaleMode is {@link SCALEMODE_BLEND}. If the actual resolution
     * is different then the ScreenComponent will be scaled according to the scaleBlend value.
     *
     * @type {Vec2}
     */
    set referenceResolution(arg: Vec2$3);
    get referenceResolution(): Vec2$3;
    /**
     * If true then the ScreenComponent will render its child {@link ElementComponent}s in screen
     * space instead of world space. Enable this to create 2D user interfaces.
     *
     * @type {boolean}
     */
    set screenSpace(arg: boolean);
    get screenSpace(): boolean;
    /**
     * Can either be {@link SCALEMODE_NONE} or {@link SCALEMODE_BLEND}. See the description of
     * referenceResolution for more information.
     *
     * @type {string}
     */
    set scaleMode(arg: string);
    get scaleMode(): string;
    /**
     * A value between 0 and 1 that is used when scaleMode is equal to {@link SCALEMODE_BLEND}.
     * Scales the ScreenComponent with width as a reference (when value is 0), the height as a
     * reference (when value is 1) or anything in between.
     *
     * @type {number}
     */
    set scaleBlend(arg: number);
    get scaleBlend(): number;
    /**
     * Priority determines the order in which screens components are rendered. Priority is set into
     * the top 8 bits of the drawOrder property in an element.
     *
     * @type {number}
     * @private
     */
    private set priority(arg);
    private get priority();
}

declare class RigidBodyComponentData {
    enabled: boolean;
}

declare class ObjectPool {
    constructor(constructorFunc: any, size: any);
    _constructor: any;
    _pool: any[];
    _count: number;
    _resize(size: any): void;
    allocate(): any;
    freeAll(): void;
}

type Entity$m = Entity$a;
/**
 * Object holding the result of a contact between two Entities.
 *
 * @property {Vec3} localPoint The point on the entity where the contact occurred, relative to the
 * entity.
 * @property {Vec3} localPointOther The point on the other entity where the contact occurred,
 * relative to the other entity.
 * @property {Vec3} point The point on the entity where the contact occurred, in world space.
 * @property {Vec3} pointOther The point on the other entity where the contact occurred, in world
 * space.
 * @property {Vec3} normal The normal vector of the contact on the other entity, in world space.
 * @property {number} impulse The total accumulated impulse applied by the constraint solver during
 * the last sub-step. Describes how hard two objects collide.
 */
declare class ContactPoint {
    /**
     * Create a new ContactPoint instance.
     *
     * @param {Vec3} [localPoint] - The point on the entity where the contact occurred, relative to
     * the entity.
     * @param {Vec3} [localPointOther] - The point on the other entity where the contact occurred,
     * relative to the other entity.
     * @param {Vec3} [point] - The point on the entity where the contact occurred, in world space.
     * @param {Vec3} [pointOther] - The point on the other entity where the contact occurred, in
     * world space.
     * @param {Vec3} [normal] - The normal vector of the contact on the other entity, in world
     * space.
     * @param {number} [impulse] - The total accumulated impulse applied by the constraint solver
     * during the last sub-step. Describes how hard two objects collide. Defaults to 0.
     */
    constructor(localPoint?: Vec3$1, localPointOther?: Vec3$1, point?: Vec3$1, pointOther?: Vec3$1, normal?: Vec3$1, impulse?: number);
    localPoint: Vec3$1;
    localPointOther: Vec3$1;
    point: Vec3$1;
    pointOther: Vec3$1;
    normal: Vec3$1;
    impulse: number;
}
/**
 * Object holding the result of a contact between two Entities.
 *
 * @property {Entity} other The entity that was involved in the contact with this entity.
 * @property {ContactPoint[]} contacts An array of ContactPoints with the other entity.
 */
declare class ContactResult {
    /**
     * Create a new ContactResult instance.
     *
     * @param {Entity} other - The entity that was involved in the contact with this entity.
     * @param {ContactPoint[]} contacts - An array of ContactPoints with the other entity.
     */
    constructor(other: Entity$m, contacts: ContactPoint[]);
    other: Entity$a;
    contacts: ContactPoint[];
}
/**
 * Object holding the result of a successful raycast hit.
 *
 * @property {Entity} entity The entity that was hit.
 * @property {Vec3} point The point at which the ray hit the entity in world space.
 * @property {Vec3} normal The normal vector of the surface where the ray hit in world space.
 */
declare class RaycastResult {
    /**
     * Create a new RaycastResult instance.
     *
     * @param {Entity} entity - The entity that was hit.
     * @param {Vec3} point - The point at which the ray hit the entity in world space.
     * @param {Vec3} normal - The normal vector of the surface where the ray hit in world space.
     */
    constructor(entity: Entity$m, point: Vec3$1, normal: Vec3$1);
    entity: Entity$a;
    point: Vec3$1;
    normal: Vec3$1;
}
/**
 * The RigidBodyComponentSystem maintains the dynamics world for simulating rigid bodies, it also
 * controls global values for the world such as gravity. Note: The RigidBodyComponentSystem is only
 * valid if 3D Physics is enabled in your application. You can enable this in the application
 * settings for your project.
 *
 * @property {Vec3} gravity The world space vector representing global gravity in the physics
 * simulation. Defaults to [0, -9.81, 0] which is an approximation of the gravitational force on
 * Earth.
 * @augments ComponentSystem
 */
declare class RigidBodyComponentSystem$2 extends ComponentSystem {
    id: string;
    _stats: {
        fps: number;
        ms: number;
        dt: number;
        updateStart: number;
        updateTime: number;
        renderStart: number;
        renderTime: number;
        physicsStart: number;
        physicsTime: number;
        cullTime: number;
        sortTime: number;
        skinTime: number;
        morphTime: number;
        instancingTime: number;
        triangles: number;
        otherPrimitives: number;
        shaders: number;
        materials: number;
        cameras: number;
        shadowMapUpdates: number;
        shadowMapTime: number;
        depthMapTime: number;
        forwardTime: number;
        lightClustersTime: number;
        lightClusters: number;
        _timeToCountFrames: number;
        _fpsAccum: number;
    };
    ComponentType: typeof RigidBodyComponent$1;
    DataType: typeof RigidBodyComponentData;
    contactPointPool: ObjectPool;
    contactResultPool: ObjectPool;
    singleContactResultPool: ObjectPool;
    maxSubSteps: number;
    fixedTimeStep: number;
    gravity: Vec3$1;
    _dynamic: any[];
    _kinematic: any[];
    _triggers: any[];
    _compounds: any[];
    collisions: {};
    frameCollisions: {};
    onLibraryLoaded(): void;
    collisionConfiguration: any;
    dispatcher: any;
    overlappingPairCache: any;
    solver: any;
    dynamicsWorld: any;
    onBeforeRemove(entity: any, component: any): void;
    onRemove(entity: any, component: any): void;
    addBody(body: any, group: any, mask: any): void;
    removeBody(body: any): void;
    createBody(mass: any, shape: any, transform: any): any;
    destroyBody(body: any): void;
    /**
     * Raycast the world and return the first entity the ray hits. Fire a ray into the world from
     * start to end, if the ray hits an entity with a collision component, it returns a
     * {@link RaycastResult}, otherwise returns null.
     *
     * @param {Vec3} start - The world space point where the ray starts.
     * @param {Vec3} end - The world space point where the ray ends.
     * @returns {RaycastResult} The result of the raycasting or null if there was no hit.
     */
    raycastFirst(start: Vec3$1, end: Vec3$1, ...args: any[]): RaycastResult;
    /**
     * Raycast the world and return all entities the ray hits. It returns an array of
     * {@link RaycastResult}, one for each hit. If no hits are detected, the returned array will be
     * of length 0.
     *
     * @param {Vec3} start - The world space point where the ray starts.
     * @param {Vec3} end - The world space point where the ray ends.
     * @returns {RaycastResult[]} An array of raycast hit results (0 length if there were no hits).
     */
    raycastAll(start: Vec3$1, end: Vec3$1): RaycastResult[];
    /**
     * Stores a collision between the entity and other in the contacts map and returns true if it
     * is a new collision.
     *
     * @param {Entity} entity - The entity.
     * @param {Entity} other - The entity that collides with the first entity.
     * @returns {boolean} True if this is a new collision, false otherwise.
     * @private
     */
    private _storeCollision;
    _createContactPointFromAmmo(contactPoint: any): any;
    _createReverseContactPointFromAmmo(contactPoint: any): any;
    _createSingleContactResult(a: any, b: any, contactPoint: any): any;
    _createContactResult(other: any, contacts: any): any;
    /**
     * Removes collisions that no longer exist from the collisions list and fires collisionend
     * events to the related entities.
     *
     * @private
     */
    private _cleanOldCollisions;
    /**
     * Returns true if the entity has a contact event attached and false otherwise.
     *
     * @param {object} entity - Entity to test.
     * @returns {boolean} True if the entity has a contact and false otherwise.
     * @private
     */
    private _hasContactEvent;
    /**
     * Checks for collisions and fires collision events.
     *
     * @param {number} world - The pointer to the dynamics world that invoked this callback.
     * @param {number} timeStep - The amount of simulation time processed in the last simulation tick.
     * @private
     */
    private _checkForCollisions;
    onUpdate(dt: any): void;
}
/**
 * Object holding the result of a contact between two rigid bodies.
 *
 * @property {Entity} a The first entity involved in the contact.
 * @property {Entity} b The second entity involved in the contact.
 * @property {Vec3} localPointA The point on Entity A where the contact occurred, relative to A.
 * @property {Vec3} localPointB The point on Entity B where the contact occurred, relative to B.
 * @property {Vec3} pointA The point on Entity A where the contact occurred, in world space.
 * @property {Vec3} pointB The point on Entity B where the contact occurred, in world space.
 * @property {Vec3} normal The normal vector of the contact on Entity B, in world space.
 */
declare class SingleContactResult {
    /**
     * Create a new SingleContactResult instance.
     *
     * @param {Entity} a - The first entity involved in the contact.
     * @param {Entity} b - The second entity involved in the contact.
     * @param {ContactPoint} contactPoint - The contact point between the two entities.
     */
    constructor(a: Entity$m, b: Entity$m, contactPoint: ContactPoint, ...args: any[]);
    a: Entity$a;
    b: Entity$a;
    impulse: number;
    localPointA: Vec3$1;
    localPointB: Vec3$1;
    pointA: Vec3$1;
    pointB: Vec3$1;
    normal: Vec3$1;
}

type Entity$l = Entity$a;
type RigidBodyComponentSystem$1 = RigidBodyComponentSystem$2;
/**
 * The rigidbody component, when combined with a {@link CollisionComponent}, allows your entities
 * to be simulated using realistic physics. A rigidbody component will fall under gravity and
 * collide with other rigid bodies. Using scripts, you can apply forces and impulses to rigid
 * bodies.
 *
 * You should never need to use the RigidBodyComponent constructor. To add an RigidBodyComponent to
 * a {@link Entity}, use {@link Entity#addComponent}:
 *
 * ```javascript
 * // Create a static 1x1x1 box-shaped rigid body
 * const entity = pc.Entity();
 * entity.addComponent("rigidbody"); // With no options specified, this defaults to a 'static' body
 * entity.addComponent("collision"); // With no options specified, this defaults to a 1x1x1 box shape
 * ```
 *
 * To create a dynamic sphere with mass of 10, do:
 *
 * ```javascript
 * const entity = pc.Entity();
 * entity.addComponent("rigidbody", {
 *     type: pc.BODYTYPE_DYNAMIC,
 *     mass: 10
 * });
 * entity.addComponent("collision", {
 *     type: "sphere"
 * });
 * ```
 *
 * Relevant 'Engine-only' examples:
 *
 * - [Falling shapes](http://playcanvas.github.io/#physics/falling-shapes.html)
 * - [Vehicle physics](http://playcanvas.github.io/#physics/vehicle.html)
 *
 * @augments Component
 */
declare class RigidBodyComponent$1 extends Component$2 {
    static onLibraryLoaded(): void;
    /**
     * Create a new RigidBodyComponent instance.
     *
     * @param {RigidBodyComponentSystem} system - The ComponentSystem that created this component.
     * @param {Entity} entity - The entity this component is attached to.
     */
    constructor(system: RigidBodyComponentSystem$1, entity: Entity$l);
    _angularDamping: number;
    _angularFactor: Vec3$1;
    _angularVelocity: Vec3$1;
    _body: any;
    _friction: number;
    _group: number;
    _linearDamping: number;
    _linearFactor: Vec3$1;
    _linearVelocity: Vec3$1;
    _mask: number;
    _mass: number;
    _restitution: number;
    _rollingFriction: number;
    _simulationEnabled: boolean;
    _type: string;
    /**
     * Controls the rate at which a body loses angular velocity over time.
     *
     * @type {number}
     */
    set angularDamping(arg: number);
    get angularDamping(): number;
    /**
     * Scaling factor for angular movement of the body in each axis. Only valid for rigid bodies of
     * type {@link BODYTYPE_DYNAMIC}. Defaults to 1 in all axes (body can freely rotate).
     *
     * @type {Vec3}
     */
    set angularFactor(arg: Vec3$1);
    get angularFactor(): Vec3$1;
    /**
     * Defines the rotational speed of the body around each world axis.
     *
     * @type {Vec3}
     */
    set angularVelocity(arg: Vec3$1);
    get angularVelocity(): Vec3$1;
    set body(arg: any);
    get body(): any;
    /**
     * The friction value used when contacts occur between two bodies. A higher value indicates
     * more friction. Should be set in the range 0 to 1. Defaults to 0.5.
     *
     * @type {number}
     */
    set friction(arg: number);
    get friction(): number;
    /**
     * The collision group this body belongs to. Combine the group and the mask to prevent bodies
     * colliding with each other. Defaults to 1.
     *
     * @type {number}
     */
    set group(arg: number);
    get group(): number;
    /**
     * Controls the rate at which a body loses linear velocity over time. Defaults to 0.
     *
     * @type {number}
     */
    set linearDamping(arg: number);
    get linearDamping(): number;
    /**
     * Scaling factor for linear movement of the body in each axis. Only valid for rigid bodies of
     * type {@link BODYTYPE_DYNAMIC}. Defaults to 1 in all axes (body can freely move).
     *
     * @type {Vec3}
     */
    set linearFactor(arg: Vec3$1);
    get linearFactor(): Vec3$1;
    /**
     * Defines the speed of the body in a given direction.
     *
     * @type {Vec3}
     */
    set linearVelocity(arg: Vec3$1);
    get linearVelocity(): Vec3$1;
    /**
     * The collision mask sets which groups this body collides with. It is a bitfield of 16 bits,
     * the first 8 bits are reserved for engine use. Defaults to 65535.
     *
     * @type {number}
     */
    set mask(arg: number);
    get mask(): number;
    /**
     * The mass of the body. This is only relevant for {@link BODYTYPE_DYNAMIC} bodies, other types
     * have infinite mass. Defaults to 1.
     *
     * @type {number}
     */
    set mass(arg: number);
    get mass(): number;
    /**
     * Influences the amount of energy lost when two rigid bodies collide. The calculation
     * multiplies the restitution values for both colliding bodies. A multiplied value of 0 means
     * that all energy is lost in the collision while a value of 1 means that no energy is lost.
     * Should be set in the range 0 to 1. Defaults to 0.
     *
     * @type {number}
     */
    set restitution(arg: number);
    get restitution(): number;
    /**
     * Sets a torsional friction orthogonal to the contact point. Defaults to 0.
     *
     * @type {number}
     */
    set rollingFriction(arg: number);
    get rollingFriction(): number;
    /**
     * The rigid body type determines how the body is simulated. Can be:
     *
     * - {@link BODYTYPE_STATIC}: infinite mass and cannot move.
     * - {@link BODYTYPE_DYNAMIC}: simulated according to applied forces.
     * - {@link BODYTYPE_KINEMATIC}: infinite mass and does not respond to forces (can only be
     * moved by setting the position and rotation of component's {@link Entity}).
     *
     * Defaults to {@link BODYTYPE_STATIC}.
     *
     * @type {string}
     */
    set type(arg: string);
    get type(): string;
    /**
     * If the Entity has a Collision shape attached then create a rigid body using this shape. This
     * method destroys the existing body.
     *
     * @private
     */
    private createBody;
    /**
     * Returns true if the rigid body is currently actively being simulated. I.e. Not 'sleeping'.
     *
     * @returns {boolean} True if the body is active.
     */
    isActive(): boolean;
    /**
     * Forcibly activate the rigid body simulation. Only affects rigid bodies of type
     * {@link BODYTYPE_DYNAMIC}.
     */
    activate(): void;
    enableSimulation(): void;
    disableSimulation(): void;
    /**
     * Apply an force to the body at a point. By default, the force is applied at the origin of the
     * body. However, the force can be applied at an offset this point by specifying a world space
     * vector from the body's origin to the point of application. This function has two valid
     * signatures. You can either specify the force (and optional relative point) via 3D-vector or
     * numbers.
     *
     * @param {Vec3|number} x - A 3-dimensional vector representing the force in world-space or
     * the x-component of the force in world-space.
     * @param {Vec3|number} [y] - An optional 3-dimensional vector representing the relative point
     * at which to apply the impulse in world-space or the y-component of the force in world-space.
     * @param {number} [z] - The z-component of the force in world-space.
     * @param {number} [px] - The x-component of a world-space offset from the body's position
     * where the force is applied.
     * @param {number} [py] - The y-component of a world-space offset from the body's position
     * where the force is applied.
     * @param {number} [pz] - The z-component of a world-space offset from the body's position
     * where the force is applied.
     * @example
     * // Apply an approximation of gravity at the body's center
     * this.entity.rigidbody.applyForce(0, -10, 0);
     * @example
     * // Apply an approximation of gravity at 1 unit down the world Z from the center of the body
     * this.entity.rigidbody.applyForce(0, -10, 0, 0, 0, 1);
     * @example
     * // Apply a force at the body's center
     * // Calculate a force vector pointing in the world space direction of the entity
     * var force = this.entity.forward.clone().mulScalar(100);
     *
     * // Apply the force
     * this.entity.rigidbody.applyForce(force);
     * @example
     * // Apply a force at some relative offset from the body's center
     * // Calculate a force vector pointing in the world space direction of the entity
     * var force = this.entity.forward.clone().mulScalar(100);
     *
     * // Calculate the world space relative offset
     * var relativePos = new pc.Vec3();
     * var childEntity = this.entity.findByName('Engine');
     * relativePos.sub2(childEntity.getPosition(), this.entity.getPosition());
     *
     * // Apply the force
     * this.entity.rigidbody.applyForce(force, relativePos);
     */
    applyForce(...args: any[]): void;
    /**
     * Apply torque (rotational force) to the body. This function has two valid signatures. You can
     * either specify the torque force with a 3D-vector or with 3 numbers.
     *
     * @param {Vec3|number} x - A 3-dimensional vector representing the torque force in world-space
     * or the x-component of the torque force in world-space.
     * @param {number} [y] - The y-component of the torque force in world-space.
     * @param {number} [z] - The z-component of the torque force in world-space.
     * @example
     * // Apply via vector
     * var torque = new pc.Vec3(0, 10, 0);
     * entity.rigidbody.applyTorque(torque);
     * @example
     * // Apply via numbers
     * entity.rigidbody.applyTorque(0, 10, 0);
     */
    applyTorque(...args: any[]): void;
    /**
     * Apply an impulse (instantaneous change of velocity) to the body at a point. This function
     * has two valid signatures. You can either specify the impulse (and optional relative point)
     * via 3D-vector or numbers.
     *
     * @param {Vec3|number} x - A 3-dimensional vector representing the impulse in world-space or
     * the x-component of the impulse in world-space.
     * @param {Vec3|number} [y] - An optional 3-dimensional vector representing the relative point
     * at which to apply the impulse in the local-space of the entity or the y-component of the
     * impulse to apply in world-space.
     * @param {number} [z] - The z-component of the impulse to apply in world-space.
     * @param {number} [px=0] - The x-component of the point at which to apply the impulse in the
     * local-space of the entity.
     * @param {number} [py=0] - The y-component of the point at which to apply the impulse in the
     * local-space of the entity.
     * @param {number} [pz=0] - The z-component of the point at which to apply the impulse in the
     * local-space of the entity.
     * @example
     * // Apply an impulse along the world-space positive y-axis at the entity's position.
     * var impulse = new pc.Vec3(0, 10, 0);
     * entity.rigidbody.applyImpulse(impulse);
     * @example
     * // Apply an impulse along the world-space positive y-axis at 1 unit down the positive
     * // z-axis of the entity's local-space.
     * var impulse = new pc.Vec3(0, 10, 0);
     * var relativePoint = new pc.Vec3(0, 0, 1);
     * entity.rigidbody.applyImpulse(impulse, relativePoint);
     * @example
     * // Apply an impulse along the world-space positive y-axis at the entity's position.
     * entity.rigidbody.applyImpulse(0, 10, 0);
     * @example
     * // Apply an impulse along the world-space positive y-axis at 1 unit down the positive
     * // z-axis of the entity's local-space.
     * entity.rigidbody.applyImpulse(0, 10, 0, 0, 0, 1);
     */
    applyImpulse(...args: any[]): void;
    /**
     * Apply a torque impulse (rotational force applied instantaneously) to the body. This function
     * has two valid signatures. You can either specify the torque force with a 3D-vector or with 3
     * numbers.
     *
     * @param {Vec3|number} x - A 3-dimensional vector representing the torque impulse in
     * world-space or the x-component of the torque impulse in world-space.
     * @param {number} [y] - The y-component of the torque impulse in world-space.
     * @param {number} [z] - The z-component of the torque impulse in world-space.
     * @example
     * // Apply via vector
     * var torque = new pc.Vec3(0, 10, 0);
     * entity.rigidbody.applyTorqueImpulse(torque);
     * @example
     * // Apply via numbers
     * entity.rigidbody.applyTorqueImpulse(0, 10, 0);
     */
    applyTorqueImpulse(...args: any[]): void;
    /**
     * Returns true if the rigid body is of type {@link BODYTYPE_STATIC}.
     *
     * @returns {boolean} True if static.
     */
    isStatic(): boolean;
    /**
     * Returns true if the rigid body is of type {@link BODYTYPE_STATIC} or {@link BODYTYPE_KINEMATIC}.
     *
     * @returns {boolean} True if static or kinematic.
     */
    isStaticOrKinematic(): boolean;
    /**
     * Returns true if the rigid body is of type {@link BODYTYPE_KINEMATIC}.
     *
     * @returns {boolean} True if kinematic.
     */
    isKinematic(): boolean;
    /**
     * Writes an entity transform into an Ammo.btTransform but ignoring scale.
     *
     * @param {object} transform - The ammo transform to write the entity transform to.
     * @private
     */
    private _getEntityTransform;
    /**
     * Set the rigid body transform to be the same as the Entity transform. This must be called
     * after any Entity transformation functions (e.g. {@link Entity#setPosition}) are called in
     * order to update the rigid body to match the Entity.
     *
     * @private
     */
    private syncEntityToBody;
    /**
     * Sets an entity's transform to match that of the world transformation matrix of a dynamic
     * rigid body's motion state.
     *
     * @private
     */
    private _updateDynamic;
    /**
     * Writes the entity's world transformation matrix into the motion state of a kinematic body.
     *
     * @private
     */
    private _updateKinematic;
    /**
     * Teleport an entity to a new world-space position, optionally setting orientation. This
     * function should only be called for rigid bodies that are dynamic. This function has three
     * valid signatures. The first takes a 3-dimensional vector for the position and an optional
     * 3-dimensional vector for Euler rotation. The second takes a 3-dimensional vector for the
     * position and an optional quaternion for rotation. The third takes 3 numbers for the position
     * and an optional 3 numbers for Euler rotation.
     *
     * @param {Vec3|number} x - A 3-dimensional vector holding the new position or the new position
     * x-coordinate.
     * @param {Vec3|Quat|number} y - A 3-dimensional vector or quaternion holding the new rotation
     * or the new position y-coordinate.
     * @param {number} [z] - The new position z-coordinate.
     * @param {number} [rx] - The new Euler x-angle value.
     * @param {number} [ry] - The new Euler y-angle value.
     * @param {number} [rz] - The new Euler z-angle value.
     * @example
     * // Teleport the entity to the origin
     * entity.rigidbody.teleport(pc.Vec3.ZERO);
     * @example
     * // Teleport the entity to the origin
     * entity.rigidbody.teleport(0, 0, 0);
     * @example
     * // Teleport the entity to world-space coordinate [1, 2, 3] and reset orientation
     * var position = new pc.Vec3(1, 2, 3);
     * entity.rigidbody.teleport(position, pc.Vec3.ZERO);
     * @example
     * // Teleport the entity to world-space coordinate [1, 2, 3] and reset orientation
     * entity.rigidbody.teleport(1, 2, 3, 0, 0, 0);
     */
    teleport(...args: any[]): void;
}

declare class RenderComponentData {
    enabled: boolean;
    rootBone: any;
}

/**
 * Allows an Entity to render a mesh or a primitive shape like a box, capsule, sphere, cylinder,
 * cone etc.
 *
 * @augments ComponentSystem
 */
declare class RenderComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof RenderComponent$1;
    DataType: typeof RenderComponentData;
    defaultMaterial: any;
    onRemove(entity: any, component: any): void;
}

type Asset$4 = Asset$6;
type AssetRegistry$8 = AssetRegistry$c;
/** @typedef {import('./asset.js').Asset} Asset */
/** @typedef {import('./asset-registry.js').AssetRegistry} AssetRegistry */
/**
 * An object that manages the case where an object holds a reference to an asset and needs to be
 * notified when changes occur in the asset. e.g. notifications include load, add and remove
 * events.
 */
declare class AssetReference {
    /**
     * Create a new AssetReference instance.
     *
     * @param {string} propertyName - The name of the property that the asset is stored under,
     * passed into callbacks to enable updating.
     * @param {Asset|object} parent - The parent object that contains the asset reference, passed
     * into callbacks to enable updating. Currently an asset, but could be component or other.
     * @param {AssetRegistry} registry - The asset registry that stores all assets.
     * @param {object} callbacks - A set of functions called when the asset state changes: load,
     * add, remove.
     * @param {object} [callbacks.load] - The function called when the asset loads
     * load(propertyName, parent, asset).
     * @param {object} [callbacks.add] - The function called when the asset is added to the
     * registry add(propertyName, parent, asset).
     * @param {object} [callbacks.remove] - The function called when the asset is remove from the
     * registry remove(propertyName, parent, asset).
     * @param {object} [callbacks.unload] - The function called when the asset is unloaded
     * unload(propertyName, parent, asset).
     * @param {object} [scope] - The scope to call the callbacks in.
     * @example
     * var reference = new pc.AssetReference('textureAsset', this, this.app.assets, {
     *     load: this.onTextureAssetLoad,
     *     add: this.onTextureAssetAdd,
     *     remove: this.onTextureAssetRemove
     * }, this);
     * reference.id = this.textureAsset.id;
     */
    constructor(propertyName: string, parent: Asset$4 | object, registry: AssetRegistry$8, callbacks: {
        load?: object;
        add?: object;
        remove?: object;
        unload?: object;
    }, scope?: object);
    propertyName: string;
    parent: any;
    _scope: any;
    _registry: AssetRegistry$c;
    /**
     * Get or set the asset id which this references. One of either id or url must be set to
     * initialize an asset reference.
     *
     * @type {number}
     */
    set id(arg: any);
    get id(): any;
    /**
     * Get or set the asset url which this references. One of either id or url must be called to
     * initialize an asset reference.
     *
     * @type {string}
     */
    set url(arg: any);
    get url(): any;
    asset: any;
    _onAssetLoad: any;
    _onAssetAdd: any;
    _onAssetRemove: any;
    _onAssetUnload: any;
    _id: any;
    _url: any;
    _bind(): void;
    _unbind(): void;
    _onLoad(asset: any): void;
    _onAdd(asset: any): void;
    _onRemove(asset: any): void;
    _onUnload(asset: any): void;
}

type Entity$k = Entity$a;
type RenderComponentSystem$1 = RenderComponentSystem$2;
/** @typedef {import('../../../scene/materials/material.js').Material} Material */
/** @typedef {import('../../../shape/bounding-box.js').BoundingBox} BoundingBox */
/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').RenderComponentSystem} RenderComponentSystem */
/**
 * Enables an Entity to render a {@link Mesh} or a primitive shape. This component attaches
 * {@link MeshInstance} geometry to the Entity.
 *
 * @property {Entity} rootBone A reference to the entity to be used as the root bone for any
 * skinned meshes that are rendered by this component.
 * @augments Component
 */
declare class RenderComponent$1 extends Component$2 {
    /**
     * Create a new RenderComponent.
     *
     * @param {RenderComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: RenderComponentSystem$1, entity: Entity$k);
    _type: string;
    _castShadows: boolean;
    _receiveShadows: boolean;
    _castShadowsLightmap: boolean;
    _lightmapped: boolean;
    _lightmapSizeMultiplier: number;
    _isStatic: boolean;
    _batchGroupId: number;
    /**
     * @type {MeshInstance[]}
     * @private
     */
    private _meshInstances;
    _layers: number[];
    _renderStyle: number;
    /**
     * @type {BoundingBox}
     * @private
     */
    private _customAabb;
    _area: any;
    _rootBone: EntityReference;
    _assetReference: AssetReference;
    /**
     * Material used to render meshes other than asset type. It gets priority when set to
     * something else than defaultMaterial, otherwise materialASsets[0] is used.
     *
     * @type {Material}
     * @private
     */
    private _material;
    _materialReferences: any[];
    /**
     * Set rendering of all {@link MeshInstance}s to the specified render style. Can be:
     *
     * - {@link RENDERSTYLE_SOLID}
     * - {@link RENDERSTYLE_WIREFRAME}
     * - {@link RENDERSTYLE_POINTS}
     *
     * Defaults to {@link RENDERSTYLE_SOLID}.
     *
     * @type {number}
     */
    set renderStyle(arg: number);
    get renderStyle(): number;
    /**
     * If set, the object space bounding box is used as a bounding box for visibility culling of
     * attached mesh instances. This is an optimization, allowing oversized bounding box to be
     * specified for skinned characters in order to avoid per frame bounding box computations based
     * on bone positions.
     *
     * @type {BoundingBox}
     */
    set customAabb(arg: BoundingBox$1);
    get customAabb(): BoundingBox$1;
    /**
     * The type of the render. Can be one of the following:
     *
     * - "asset": The component will render a render asset
     * - "box": The component will render a box (1 unit in each dimension)
     * - "capsule": The component will render a capsule (radius 0.5, height 2)
     * - "cone": The component will render a cone (radius 0.5, height 1)
     * - "cylinder": The component will render a cylinder (radius 0.5, height 1)
     * - "plane": The component will render a plane (1 unit in each dimension)
     * - "sphere": The component will render a sphere (radius 0.5)
     *
     * @type {string}
     */
    set type(arg: string);
    get type(): string;
    /**
     * An array of meshInstances contained in the component. If meshes are not set or loaded for
     * component it will return null.
     *
     * @type {MeshInstance[]}
     */
    set meshInstances(arg: MeshInstance$3[]);
    get meshInstances(): MeshInstance$3[];
    /**
     * If true, the meshes will be lightmapped after using lightmapper.bake().
     *
     * @type {boolean}
     */
    set lightmapped(arg: boolean);
    get lightmapped(): boolean;
    /**
     * If true, attached meshes will cast shadows for lights that have shadow casting enabled.
     *
     * @type {boolean}
     */
    set castShadows(arg: boolean);
    get castShadows(): boolean;
    /**
     * If true, shadows will be cast on attached meshes.
     *
     * @type {boolean}
     */
    set receiveShadows(arg: boolean);
    get receiveShadows(): boolean;
    /**
     * If true, the meshes will cast shadows when rendering lightmaps.
     *
     * @type {boolean}
     */
    set castShadowsLightmap(arg: boolean);
    get castShadowsLightmap(): boolean;
    /**
     * Lightmap resolution multiplier.
     *
     * @type {number}
     */
    set lightmapSizeMultiplier(arg: number);
    get lightmapSizeMultiplier(): number;
    /**
     * Mark meshes as non-movable (optimization).
     *
     * @type {boolean}
     */
    set isStatic(arg: boolean);
    get isStatic(): boolean;
    /**
     * An array of layer IDs ({@link Layer#id}) to which the meshes should belong. Don't push, pop,
     * splice or modify this array, if you want to change it - set a new one instead.
     *
     * @type {number[]}
     */
    set layers(arg: number[]);
    get layers(): number[];
    /**
     * Assign meshes to a specific batch group (see {@link BatchGroup}). Default is -1 (no group).
     *
     * @type {number}
     */
    set batchGroupId(arg: number);
    get batchGroupId(): number;
    /**
     * The material {@link Material} that will be used to render the meshes (not used on renders of
     * type 'asset').
     *
     * @type {Material}
     */
    set material(arg: Material$2);
    get material(): Material$2;
    /**
     * The material assets that will be used to render the meshes. Each material corresponds to the
     * respective mesh instance.
     *
     * @type {Asset[]|number[]}
     */
    set materialAssets(arg: any[]);
    get materialAssets(): any[];
    /**
     * The render asset for the render component (only applies to type 'asset') - can also be an
     * asset id.
     *
     * @type {Asset|number}
     */
    set asset(arg: any);
    get asset(): any;
    _onSetRootBone(entity: any): void;
    _onRootBoneChanged(): void;
    destroyMeshInstances(): void;
    addToLayers(): void;
    removeFromLayers(): void;
    onRemoveChild(): void;
    onInsertChild(): void;
    onRemove(): void;
    materialAsset: any;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    /**
     * Stop rendering {@link MeshInstance}s without removing them from the scene hierarchy. This
     * method sets the {@link MeshInstance#visible} property of every MeshInstance to false. Note,
     * this does not remove the mesh instances from the scene hierarchy or draw call list. So the
     * render component still incurs some CPU overhead.
     */
    hide(): void;
    /**
     * Enable rendering of the component's {@link MeshInstance}s if hidden using
     * {@link RenderComponent#hide}. This method sets the {@link MeshInstance#visible} property on
     * all mesh instances to true.
     */
    show(): void;
    _onRenderAssetAdded(): void;
    _onRenderAssetLoad(): void;
    _onSetMeshes(meshes: any): void;
    _clearSkinInstances(): void;
    _cloneSkinInstances(): void;
    _cloneMeshes(meshes: any): void;
    _onRenderAssetUnload(): void;
    _onRenderAssetRemove(): void;
    _onMaterialAdded(index: any, component: any, asset: any): void;
    _updateMainMaterial(index: any, material: any): void;
    _onMaterialLoad(index: any, component: any, asset: any): void;
    _onMaterialRemove(index: any, component: any, asset: any): void;
    _onMaterialUnload(index: any, component: any, asset: any): void;
    resolveDuplicatedEntityReferenceProperties(oldRender: any, duplicatedIdsMap: any): void;
    rootBone: any;
}

declare class ParticleSystemComponentData {
    numParticles: number;
    rate: number;
    rate2: any;
    startAngle: number;
    startAngle2: any;
    lifetime: number;
    emitterExtents: Vec3$1;
    emitterExtentsInner: Vec3$1;
    emitterRadius: number;
    emitterRadiusInner: number;
    emitterShape: number;
    initialVelocity: number;
    wrapBounds: Vec3$1;
    localSpace: boolean;
    screenSpace: boolean;
    colorMap: any;
    colorMapAsset: any;
    normalMap: any;
    normalMapAsset: any;
    loop: boolean;
    preWarm: boolean;
    sort: number;
    mode: number;
    scene: any;
    lighting: boolean;
    halfLambert: boolean;
    intensity: number;
    stretch: number;
    alignToMotion: boolean;
    depthSoftening: number;
    meshAsset: any;
    mesh: any;
    depthWrite: boolean;
    noFog: boolean;
    orientation: number;
    particleNormal: Vec3$1;
    animTilesX: number;
    animTilesY: number;
    animStartFrame: number;
    animNumFrames: number;
    animNumAnimations: number;
    animIndex: number;
    randomizeAnimIndex: boolean;
    animSpeed: number;
    animLoop: boolean;
    scaleGraph: any;
    scaleGraph2: any;
    colorGraph: any;
    colorGraph2: any;
    alphaGraph: any;
    alphaGraph2: any;
    localVelocityGraph: any;
    localVelocityGraph2: any;
    velocityGraph: any;
    velocityGraph2: any;
    rotationSpeedGraph: any;
    rotationSpeedGraph2: any;
    radialSpeedGraph: any;
    radialSpeedGraph2: any;
    blendType: number;
    enabled: boolean;
    paused: boolean;
    autoPlay: boolean;
    layers: number[];
}

/**
 * Allows an Entity to render a particle system.
 *
 * @augments ComponentSystem
 */
declare class ParticleSystemComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof ParticleSystemComponent$1;
    DataType: typeof ParticleSystemComponentData;
    propertyTypes: {
        emitterExtents: string;
        emitterExtentsInner: string;
        particleNormal: string;
        wrapBounds: string;
        localVelocityGraph: string;
        localVelocityGraph2: string;
        velocityGraph: string;
        velocityGraph2: string;
        colorGraph: string;
        colorGraph2: string;
        alphaGraph: string;
        alphaGraph2: string;
        rotationSpeedGraph: string;
        rotationSpeedGraph2: string;
        radialSpeedGraph: string;
        radialSpeedGraph2: string;
        scaleGraph: string;
        scaleGraph2: string;
    };
    onUpdate(dt: any): void;
    onBeforeRemove(entity: any, component: any): void;
}

declare class ParticleGPUUpdater {
    constructor(emitter: any, gd: any);
    _emitter: any;
    frameRandomUniform: Float32Array;
    emitterPosUniform: Float32Array;
    emitterScaleUniform: Float32Array;
    worldBoundsMulUniform: Float32Array;
    worldBoundsAddUniform: Float32Array;
    inBoundsSizeUniform: Float32Array;
    inBoundsCenterUniform: Float32Array;
    constantParticleTexIN: any;
    constantParticleTexOUT: any;
    constantEmitterPos: any;
    constantEmitterScale: any;
    constantSpawnBounds: any;
    constantSpawnPosInnerRatio: any;
    constantSpawnBoundsSphere: any;
    constantSpawnBoundsSphereInnerRatio: any;
    constantInitialVelocity: any;
    constantFrameRandom: any;
    constantDelta: any;
    constantRate: any;
    constantRateDiv: any;
    constantLifetime: any;
    constantGraphSampleSize: any;
    constantGraphNumSamples: any;
    constantInternalTex0: any;
    constantInternalTex1: any;
    constantInternalTex2: any;
    constantInternalTex3: any;
    constantEmitterMatrix: any;
    constantEmitterMatrixInv: any;
    constantNumParticles: any;
    constantNumParticlesPot: any;
    constantLocalVelocityDivMult: any;
    constantVelocityDivMult: any;
    constantRotSpeedDivMult: any;
    constantSeed: any;
    constantStartAngle: any;
    constantStartAngle2: any;
    constantOutBoundsMul: any;
    constantOutBoundsAdd: any;
    constantInBoundsSize: any;
    constantInBoundsCenter: any;
    constantMaxVel: any;
    constantFaceTangent: any;
    constantFaceBinorm: any;
    _setInputBounds(): void;
    randomize(): void;
    update(device: any, spawnMatrix: any, extentsInnerRatioUniform: any, delta: any, isOnStop: any): void;
}

declare class ParticleCPUUpdater {
    constructor(emitter: any);
    _emitter: any;
    calcSpawnPosition(particleTex: any, spawnMatrix: any, extentsInnerRatioUniform: any, emitterPos: any, i: any): void;
    update(data: any, vbToSort: any, particleTex: any, spawnMatrix: any, extentsInnerRatioUniform: any, emitterPos: any, delta: any, isOnStop: any): void;
}

declare class ParticleEmitter {
    static DEFAULT_PARAM_TEXTURE: any;
    static staticInit(device: any): void;
    static staticDestroy(): void;
    constructor(graphicsDevice: any, options: any);
    graphicsDevice: any;
    precision: number;
    _addTimeTime: number;
    numParticles: any;
    _gpuUpdater: ParticleGPUUpdater;
    _cpuUpdater: ParticleCPUUpdater;
    constantLightCube: any;
    emitterPosUniform: Float32Array;
    wrapBoundsUniform: Float32Array;
    emitterScaleUniform: Float32Array;
    lightCube: Float32Array;
    lightCubeDir: any[];
    animTilesParams: Float32Array;
    animParams: Float32Array;
    animIndexParams: Float32Array;
    internalTex0: Texture$8;
    internalTex1: Texture$8;
    internalTex2: Texture$8;
    colorParam: Texture$8;
    vbToSort: any[];
    vbOld: Float32Array;
    particleDistance: Float32Array;
    camera: any;
    swapTex: boolean;
    useMesh: boolean;
    useCpu: boolean;
    pack8: boolean;
    localBounds: BoundingBox$1;
    worldBoundsNoTrail: BoundingBox$1;
    worldBoundsTrail: BoundingBox$1[];
    worldBounds: BoundingBox$1;
    worldBoundsSize: Vec3$1;
    prevWorldBoundsSize: Vec3$1;
    prevWorldBoundsCenter: Vec3$1;
    prevEmitterExtents: any;
    prevEmitterRadius: any;
    worldBoundsMul: Vec3$1;
    worldBoundsAdd: Vec3$1;
    timeToSwitchBounds: number;
    shaderParticleUpdateRespawn: Shader$4;
    shaderParticleUpdateNoRespawn: Shader$4;
    shaderParticleUpdateOnStop: Shader$4;
    numParticleVerts: number;
    numParticleIndices: number;
    material: Material$2;
    meshInstance: MeshInstance$3;
    drawOrder: number;
    seed: number;
    fixedTimeStep: number;
    maxSubSteps: number;
    simTime: number;
    simTimeTotal: number;
    beenReset: boolean;
    _layer: any;
    onChangeCamera(): void;
    calculateBoundsMad(): void;
    calculateWorldBounds(): void;
    resetWorldBounds(): void;
    calculateLocalBounds(): void;
    rebuild(): void;
    colorMap: any;
    spawnBounds: any;
    numParticlesPot: number;
    particleTex: Float32Array;
    particleTexStart: any;
    particleTexIN: Texture$8;
    particleTexOUT: Texture$8;
    rtParticleTexIN: RenderTarget$3;
    rtParticleTexOUT: RenderTarget$3;
    _isAnimated(): any;
    rebuildGraphs(): void;
    qLocalVelocity: any;
    qVelocity: any;
    qColor: any;
    qRotSpeed: any;
    qScale: any;
    qAlpha: any;
    qRadialSpeed: any;
    qLocalVelocity2: any;
    qVelocity2: any;
    qColor2: any;
    qRotSpeed2: any;
    qScale2: any;
    qAlpha2: any;
    qRadialSpeed2: any;
    localVelocityUMax: Float32Array;
    velocityUMax: Float32Array;
    colorUMax: Float32Array;
    rotSpeedUMax: number[];
    scaleUMax: number[];
    alphaUMax: number[];
    radialSpeedUMax: number[];
    qLocalVelocityDiv: Float32Array;
    qVelocityDiv: Float32Array;
    qColorDiv: Float32Array;
    qRotSpeedDiv: Float32Array;
    qScaleDiv: Float32Array;
    qAlphaDiv: Float32Array;
    qRadialSpeedDiv: Float32Array;
    maxVel: number;
    internalTex3: Texture$8;
    _initializeTextures(): void;
    regenShader(): void;
    normalOption: number;
    resetMaterial(): void;
    _compParticleFaceParams(): void;
    _allocate(numParticles: any): void;
    vertexBuffer: VertexBuffer$3;
    indexBuffer: IndexBuffer$1;
    vbCPU: Float32Array;
    reset(): void;
    loop: any;
    prewarm(time: any): void;
    resetTime(): void;
    endTime: number;
    finishFrame(): void;
    addTime(delta: any, isOnStop: any): void;
    _destroyResources(): void;
    destroy(): void;
}

type Entity$j = Entity$a;
type ParticleSystemComponentSystem$1 = ParticleSystemComponentSystem$2;
/**
 * Used to simulate particles and produce renderable particle mesh on either CPU or GPU. GPU
 * simulation is generally much faster than its CPU counterpart, because it avoids slow CPU-GPU
 * synchronization and takes advantage of many GPU cores. However, it requires client to support
 * reasonable uniform count, reading from multiple textures in vertex shader and OES_texture_float
 * extension, including rendering into float textures. Most mobile devices fail to satisfy these
 * requirements, so it's not recommended to simulate thousands of particles on them. GPU version
 * also can't sort particles, so enabling sorting forces CPU mode too. Particle rotation is
 * specified by a single angle parameter: default billboard particles rotate around camera facing
 * axis, while mesh particles rotate around 2 different view-independent axes. Most of the
 * simulation parameters are specified with {@link Curve} or {@link CurveSet}. Curves are
 * interpolated based on each particle's lifetime, therefore parameters are able to change over
 * time. Most of the curve parameters can also be specified by 2 minimum/maximum curves, this way
 * each particle will pick a random value in-between.
 *
 * @property {boolean} autoPlay Controls whether the particle system plays automatically on
 * creation. If set to false, it is necessary to call {@link ParticleSystemComponent#play} for the
 * particle system to play. Defaults to true.
 * @property {boolean} loop Enables or disables respawning of particles.
 * @property {boolean} preWarm If enabled, the particle system will be initialized as though it had
 * already completed a full cycle. This only works with looping particle systems.
 * @property {boolean} lighting If enabled, particles will be lit by ambient and directional
 * lights.
 * @property {boolean} halfLambert Enabling Half Lambert lighting avoids particles looking too flat
 * in shadowed areas. It is a completely non-physical lighting model but can give more pleasing
 * visual results.
 * @property {boolean} alignToMotion Orient particles in their direction of motion.
 * @property {boolean} depthWrite If enabled, the particles will write to the depth buffer. If
 * disabled, the depth buffer is left unchanged and particles will be guaranteed to overwrite one
 * another in the order in which they are rendered.
 * @property {boolean} noFog Disable fogging.
 * @property {boolean} localSpace Binds particles to emitter transformation rather then world
 * space.
 * @property {boolean} screenSpace Renders particles in 2D screen space. This needs to be set when
 * particle system is part of hierarchy with {@link ScreenComponent} as its ancestor, and allows
 * particle system to integrate with the rendering of {@link ElementComponent}s. Note that an
 * entity with ParticleSystem component cannot be parented directly to {@link ScreenComponent}, but
 * has to be a child of a {@link ElementComponent}, for example {@link LayoutGroupComponent}.
 * @property {number} numParticles Maximum number of simulated particles.
 * @property {number} rate Minimal interval in seconds between particle births.
 * @property {number} rate2 Maximal interval in seconds between particle births.
 * @property {number} startAngle Minimal initial Euler angle of a particle.
 * @property {number} startAngle2 Maximal initial Euler angle of a particle.
 * @property {number} lifetime The length of time in seconds between a particle's birth and its
 * death.
 * @property {number} stretch A value in world units that controls the amount by which particles
 * are stretched based on their velocity. Particles are stretched from their center towards their
 * previous position.
 * @property {number} intensity Color multiplier.
 * @property {boolean} animLoop Controls whether the sprite sheet animation plays once or loops
 * continuously.
 * @property {number} animTilesX Number of horizontal tiles in the sprite sheet.
 * @property {number} animTilesY Number of vertical tiles in the sprite sheet.
 * @property {number} animNumAnimations Number of sprite sheet animations contained within the
 * current sprite sheet. The number of animations multiplied by number of frames should be a value
 * less than animTilesX multiplied by animTilesY.
 * @property {number} animNumFrames Number of sprite sheet frames in the current sprite sheet
 * animation. The number of animations multiplied by number of frames should be a value less than
 * animTilesX multiplied by animTilesY.
 * @property {number} animStartFrame The sprite sheet frame that the animation should begin playing
 * from. Indexed from the start of the current animation.
 * @property {number} animIndex When animNumAnimations is greater than 1, the sprite sheet
 * animation index determines which animation the particle system should play.
 * @property {number} randomizeAnimIndex Each particle emitted by the system will play a random
 * animation from the sprite sheet, up to animNumAnimations.
 * @property {number} animSpeed Sprite sheet animation speed. 1 = particle lifetime, 2 = twice
 * during lifetime etc...
 * @property {number} depthSoftening Controls fading of particles near their intersections with
 * scene geometry. This effect, when it's non-zero, requires scene depth map to be rendered.
 * Multiple depth-dependent effects can share the same map, but if you only use it for particles,
 * bear in mind that it can double engine draw calls.
 * @property {number} initialVelocity Defines magnitude of the initial emitter velocity. Direction
 * is given by emitter shape.
 * @property {Vec3} emitterExtents (Only for EMITTERSHAPE_BOX) The extents of a local space
 * bounding box within which particles are spawned at random positions.
 * @property {Vec3} emitterExtentsInner (Only for EMITTERSHAPE_BOX) The exception of extents of a
 * local space bounding box within which particles are not spawned. Aligned to the center of
 * EmitterExtents.
 * @property {number} emitterRadius (Only for EMITTERSHAPE_SPHERE) The radius within which
 * particles are spawned at random positions.
 * @property {number} emitterRadiusInner (Only for EMITTERSHAPE_SPHERE) The inner radius within
 * which particles are not spawned.
 * @property {Vec3} wrapBounds The half extents of a world space box volume centered on the owner
 * entity's position. If a particle crosses the boundary of one side of the volume, it teleports to
 * the opposite side.
 * @property {Asset} colorMapAsset The {@link Asset} used to set the colorMap.
 * @property {Asset} normalMapAsset The {@link Asset} used to set the normalMap.
 * @property {Asset} meshAsset The {@link Asset} used to set the mesh.
 * @property {Asset} renderAsset The Render {@link Asset} used to set the mesh.
 * @property {Texture} colorMap The color map texture to apply to all particles in the system. If
 * no texture is assigned, a default spot texture is used.
 * @property {Texture} normalMap The normal map texture to apply to all particles in the system. If
 * no texture is assigned, an approximate spherical normal is calculated for each vertex.
 * @property {number} emitterShape Shape of the emitter. Defines the bounds inside which particles
 * are spawned. Also affects the direction of initial velocity.
 *
 * - {@link EMITTERSHAPE_BOX}: Box shape parameterized by emitterExtents. Initial velocity is
 * directed towards local Z axis.
 * - {@link EMITTERSHAPE_SPHERE}: Sphere shape parameterized by emitterRadius. Initial velocity is
 * directed outwards from the center.
 *
 * @property {number} sort Sorting mode. Forces CPU simulation, so be careful.
 *
 * - {@link PARTICLESORT_NONE}: No sorting, particles are drawn in arbitrary order. Can be
 * simulated on GPU.
 * - {@link PARTICLESORT_DISTANCE}: Sorting based on distance to the camera. CPU only.
 * - {@link PARTICLESORT_NEWER_FIRST}: Newer particles are drawn first. CPU only.
 * - {@link PARTICLESORT_OLDER_FIRST}: Older particles are drawn first. CPU only.
 *
 * @property {Mesh} mesh Triangular mesh to be used as a particle. Only first vertex/index buffer
 * is used. Vertex buffer must contain local position at first 3 floats of each vertex.
 * @property {number} blend Controls how particles are blended when being written to the currently
 * active render target. Can be:
 *
 * - {@link BLEND_SUBTRACTIVE}: Subtract the color of the source fragment from the destination
 * fragment and write the result to the frame buffer.
 * - {@link BLEND_ADDITIVE}: Add the color of the source fragment to the destination fragment and
 * write the result to the frame buffer.
 * - {@link BLEND_NORMAL}: Enable simple translucency for materials such as glass. This is
 * equivalent to enabling a source blend mode of {@link BLENDMODE_SRC_ALPHA} and a destination
 * blend mode of {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.
 * - {@link BLEND_NONE}: Disable blending.
 * - {@link BLEND_PREMULTIPLIED}: Similar to {@link BLEND_NORMAL} expect the source fragment is
 * assumed to have already been multiplied by the source alpha value.
 * - {@link BLEND_MULTIPLICATIVE}: Multiply the color of the source fragment by the color of the
 * destination fragment and write the result to the frame buffer.
 * - {@link BLEND_ADDITIVEALPHA}: Same as {@link BLEND_ADDITIVE} except the source RGB is
 * multiplied by the source alpha.
 *
 * @property {number} orientation Sorting mode. Forces CPU simulation, so be careful.
 *
 * - {@link PARTICLEORIENTATION_SCREEN}: Particles are facing camera.
 * - {@link PARTICLEORIENTATION_WORLD}: User defines world space normal (particleNormal) to set
 * planes orientation.
 * - {@link PARTICLEORIENTATION_EMITTER}: Similar to previous, but the normal is affected by
 * emitter (entity) transformation.
 *
 * @property {Vec3} particleNormal (Only for PARTICLEORIENTATION_WORLD and
 * PARTICLEORIENTATION_EMITTER) The exception of extents of a local space bounding box within which
 * particles are not spawned. Aligned to the center of EmitterExtents.
 * @property {CurveSet} localVelocityGraph Velocity relative to emitter over lifetime.
 * @property {CurveSet} localVelocityGraph2 If not null, particles pick random values between
 * localVelocityGraph and localVelocityGraph2.
 * @property {CurveSet} velocityGraph World-space velocity over lifetime.
 * @property {CurveSet} velocityGraph2 If not null, particles pick random values between
 * velocityGraph and velocityGraph2.
 * @property {CurveSet} colorGraph Color over lifetime.
 * @property {Curve} rotationSpeedGraph Rotation speed over lifetime.
 * @property {Curve} rotationSpeedGraph2 If not null, particles pick random values between
 * rotationSpeedGraph and rotationSpeedGraph2.
 * @property {Curve} radialSpeedGraph Radial speed over lifetime, velocity vector points from
 * emitter origin to particle pos.
 * @property {Curve} radialSpeedGraph2 If not null, particles pick random values between
 * radialSpeedGraph and radialSpeedGraph2.
 * @property {Curve} scaleGraph Scale over lifetime.
 * @property {Curve} scaleGraph2 If not null, particles pick random values between scaleGraph and
 * scaleGraph2.
 * @property {Curve} alphaGraph Alpha over lifetime.
 * @property {Curve} alphaGraph2 If not null, particles pick random values between alphaGraph and
 * alphaGraph2.
 * @property {number[]} layers An array of layer IDs ({@link Layer#id}) to which this particle
 * system should belong. Don't push/pop/splice or modify this array, if you want to change it - set
 * a new one instead.
 * @augments Component
 */
declare class ParticleSystemComponent$1 extends Component$2 {
    /**
     * Create a new ParticleSystemComponent.
     *
     * @param {ParticleSystemComponentSystem} system - The ComponentSystem that created this
     * Component.
     * @param {Entity} entity - The Entity this Component is attached to.
     */
    constructor(system: ParticleSystemComponentSystem$1, entity: Entity$j);
    _requestedDepth: boolean;
    _drawOrder: number;
    set drawOrder(arg: number);
    get drawOrder(): number;
    addMeshInstanceToLayers(): void;
    removeMeshInstanceFromLayers(): void;
    onSetLayers(name: any, oldValue: any, newValue: any): void;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    _bindColorMapAsset(asset: any): void;
    _unbindColorMapAsset(asset: any): void;
    _onColorMapAssetLoad(asset: any): void;
    colorMap: any;
    _onColorMapAssetUnload(asset: any): void;
    _onColorMapAssetRemove(asset: any): void;
    _onColorMapAssetChange(asset: any): void;
    onSetColorMapAsset(name: any, oldValue: any, newValue: any): void;
    _bindNormalMapAsset(asset: any): void;
    _unbindNormalMapAsset(asset: any): void;
    _onNormalMapAssetLoad(asset: any): void;
    normalMap: any;
    _onNormalMapAssetUnload(asset: any): void;
    _onNormalMapAssetRemove(asset: any): void;
    _onNormalMapAssetChange(asset: any): void;
    onSetNormalMapAsset(name: any, oldValue: any, newValue: any): void;
    _bindMeshAsset(asset: any): void;
    _unbindMeshAsset(asset: any): void;
    _onMeshAssetLoad(asset: any): void;
    _onMeshAssetUnload(asset: any): void;
    mesh: any;
    _onMeshAssetRemove(asset: any): void;
    _onMeshAssetChange(asset: any): void;
    onSetMeshAsset(name: any, oldValue: any, newValue: any): void;
    onSetMesh(name: any, oldValue: any, newValue: any): void;
    meshAsset: any;
    _onMeshChanged(mesh: any): void;
    onSetRenderAsset(name: any, oldValue: any, newValue: any): void;
    _bindRenderAsset(asset: any): void;
    _unbindRenderAsset(asset: any): void;
    _onRenderAssetLoad(asset: any): void;
    _onRenderAssetUnload(asset: any): void;
    _onRenderAssetRemove(asset: any): void;
    _onRenderChanged(render: any): void;
    _onRenderSetMeshes(meshes: any): void;
    onSetLoop(name: any, oldValue: any, newValue: any): void;
    onSetBlendType(name: any, oldValue: any, newValue: any): void;
    _requestDepth(): void;
    _releaseDepth(): void;
    onSetDepthSoftening(name: any, oldValue: any, newValue: any): void;
    onSetSimpleProperty(name: any, oldValue: any, newValue: any): void;
    onSetComplexProperty(name: any, oldValue: any, newValue: any): void;
    onSetGraphProperty(name: any, oldValue: any, newValue: any): void;
    emitter: ParticleEmitter;
    onBeforeRemove(): void;
    
    /**
     * Resets particle state, doesn't affect playing.
     */
    reset(): void;
    /**
     * Disables the emission of new particles, lets existing to finish their simulation.
     */
    stop(): void;
    /**
     * Freezes the simulation.
     */
    pause(): void;
    /**
     * Unfreezes the simulation.
     */
    unpause(): void;
    /**
     * Enables/unfreezes the simulation.
     */
    play(): void;
    /**
     * Checks if simulation is in progress.
     *
     * @returns {boolean} True if the particle system is currently playing and false otherwise.
     */
    isPlaying(): boolean;
    /**
     * Rebuilds all data used by this particle system.
     *
     * @private
     */
    private rebuild;
}

declare class ModelComponentData {
    enabled: boolean;
}

/**
 * Allows an Entity to render a model or a primitive shape like a box, capsule, sphere, cylinder,
 * cone etc.
 *
 * @augments ComponentSystem
 */
declare class ModelComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof ModelComponent$1;
    DataType: typeof ModelComponentData;
    defaultMaterial: any;
    onRemove(entity: any, component: any): void;
}

type Entity$i = Entity$a;
type ModelComponentSystem$1 = ModelComponentSystem$2;
/** @typedef {import('../../../shape/bounding-box.js').BoundingBox} BoundingBox */
/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').ModelComponentSystem} ModelComponentSystem */
/**
 * Enables an Entity to render a model or a primitive shape. This Component attaches additional
 * model geometry in to the scene graph below the Entity.
 *
 * @augments Component
 */
declare class ModelComponent$1 extends Component$2 {
    /**
     * Create a new ModelComponent instance.
     *
     * @param {ModelComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ModelComponentSystem$1, entity: Entity$i);
    _type: string;
    /**
     * @type {number}
     * @private
     */
    private _asset;
    /**
     * @type {Model}
     * @private
     */
    private _model;
    _mapping: {};
    _castShadows: boolean;
    _receiveShadows: boolean;
    /**
     * @type {Asset}
     * @private
     */
    private _materialAsset;
    _material: any;
    _castShadowsLightmap: boolean;
    _lightmapped: boolean;
    _lightmapSizeMultiplier: number;
    _isStatic: boolean;
    _layers: number[];
    _batchGroupId: number;
    /**
     * @type {BoundingBox}
     * @private
     */
    private _customAabb;
    _area: any;
    _assetOld: number;
    _materialEvents: any[];
    _dirtyModelAsset: boolean;
    _dirtyMaterialAsset: boolean;
    _clonedModel: boolean;
    _batchGroup: any;
    /**
     * An array of meshInstances contained in the component's model. If model is not set or loaded
     * for component it will return null.
     *
     * @type {MeshInstance[]|null}
     */
    set meshInstances(arg: MeshInstance$3[]);
    get meshInstances(): MeshInstance$3[];
    /**
     * If set, the object space bounding box is used as a bounding box for visibility culling of
     * attached mesh instances. This is an optimization, allowing oversized bounding box to be
     * specified for skinned characters in order to avoid per frame bounding box computations based
     * on bone positions.
     *
     * @type {BoundingBox}
     */
    set customAabb(arg: BoundingBox$1);
    get customAabb(): BoundingBox$1;
    /**
     * The type of the model. Can be:
     *
     * - "asset": The component will render a model asset
     * - "box": The component will render a box (1 unit in each dimension)
     * - "capsule": The component will render a capsule (radius 0.5, height 2)
     * - "cone": The component will render a cone (radius 0.5, height 1)
     * - "cylinder": The component will render a cylinder (radius 0.5, height 1)
     * - "plane": The component will render a plane (1 unit in each dimension)
     * - "sphere": The component will render a sphere (radius 0.5)
     *
     * @type {string}
     */
    set type(arg: string);
    get type(): string;
    /**
     * The model that is added to the scene graph. It can be not set or loaded, so will return null.
     *
     * @type {Model}
     */
    set model(arg: Model);
    get model(): Model;
    /**
     * The asset for the model (only applies to models of type 'asset') can also be an asset id.
     *
     * @type {Asset|number}
     */
    set asset(arg: number);
    get asset(): number;
    /**
     * If true, this model will be lightmapped after using lightmapper.bake().
     *
     * @type {boolean}
     */
    set lightmapped(arg: boolean);
    get lightmapped(): boolean;
    /**
     * A dictionary that holds material overrides for each mesh instance. Only applies to model
     * components of type 'asset'. The mapping contains pairs of mesh instance index - material
     * asset id.
     *
     * @type {object}
     */
    set mapping(arg: {});
    get mapping(): {};
    /**
     * If true, this model will cast shadows for lights that have shadow casting enabled.
     *
     * @type {boolean}
     */
    set castShadows(arg: boolean);
    get castShadows(): boolean;
    /**
     * If true, shadows will be cast on this model.
     *
     * @type {boolean}
     */
    set receiveShadows(arg: boolean);
    get receiveShadows(): boolean;
    /**
     * If true, this model will cast shadows when rendering lightmaps.
     *
     * @type {boolean}
     */
    set castShadowsLightmap(arg: boolean);
    get castShadowsLightmap(): boolean;
    /**
     * Lightmap resolution multiplier.
     *
     * @type {number}
     */
    set lightmapSizeMultiplier(arg: number);
    get lightmapSizeMultiplier(): number;
    /**
     * Mark model as non-movable (optimization).
     *
     * @type {boolean}
     */
    set isStatic(arg: boolean);
    get isStatic(): boolean;
    /**
     * An array of layer IDs ({@link Layer#id}) to which this model should belong. Don't push, pop,
     * splice or modify this array, if you want to change it - set a new one instead.
     *
     * @type {number[]}
     */
    set layers(arg: number[]);
    get layers(): number[];
    /**
     * Assign model to a specific batch group (see {@link BatchGroup}). Default is -1 (no group).
     *
     * @type {number}
     */
    set batchGroupId(arg: number);
    get batchGroupId(): number;
    /**
     * The material {@link Asset} that will be used to render the model (not used on models of type
     * 'asset').
     *
     * @type {Asset|number}
     */
    set materialAsset(arg: Asset$6);
    get materialAsset(): Asset$6;
    /**
     * The material {@link Material} that will be used to render the model (not used on models of
     * type 'asset').
     *
     * @type {Material}
     */
    set material(arg: any);
    get material(): any;
    addModelToLayers(): void;
    removeModelFromLayers(): void;
    onRemoveChild(): void;
    onInsertChild(): void;
    onRemove(): void;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    _setMaterialEvent(index: any, event: any, id: any, handler: any): void;
    _unsetMaterialEvents(): void;
    _getAssetByIdOrPath(idOrPath: any): Asset$6;
    _getMaterialAssetUrl(path: any): string;
    _loadAndSetMeshInstanceMaterial(materialAsset: any, meshInstance: any, index: any): void;
    /**
     * Stop rendering model without removing it from the scene hierarchy. This method sets the
     * {@link MeshInstance#visible} property of every MeshInstance in the model to false Note, this
     * does not remove the model or mesh instances from the scene hierarchy or draw call list. So
     * the model component still incurs some CPU overhead.
     *
     * @example
     * this.timer = 0;
     * this.visible = true;
     * // ...
     * // blink model every 0.1 seconds
     * this.timer += dt;
     * if (this.timer > 0.1) {
     *     if (!this.visible) {
     *         this.entity.model.show();
     *         this.visible = true;
     *     } else {
     *         this.entity.model.hide();
     *         this.visible = false;
     *     }
     *     this.timer = 0;
     * }
     */
    hide(): void;
    /**
     * Enable rendering of the model if hidden using {@link ModelComponent#hide}. This method sets
     * all the {@link MeshInstance#visible} property on all mesh instances to true.
     */
    show(): void;
    _bindMaterialAsset(asset: any): void;
    _unbindMaterialAsset(asset: any): void;
    _onMaterialAssetAdd(asset: any): void;
    _onMaterialAssetLoad(asset: any): void;
    _onMaterialAssetUnload(asset: any): void;
    _onMaterialAssetRemove(asset: any): void;
    _onMaterialAssetChange(asset: any): void;
    _bindModelAsset(asset: any): void;
    _unbindModelAsset(asset: any): void;
    _onModelAssetAdded(asset: any): void;
    _onModelAssetLoad(asset: any): void;
    _onModelAssetUnload(asset: any): void;
    _onModelAssetChange(asset: any, attr: any, _new: any, _old: any): void;
    _onModelAssetRemove(asset: any): void;
    _setMaterial(material: any): void;
}

declare class LightComponentData {
}

/**
 * A Light Component is used to dynamically light the scene.
 *
 * @augments ComponentSystem
 */
declare class LightComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof LightComponent$2;
    DataType: typeof LightComponentData;
    _onRemoveComponent(entity: any, component: any): void;
    changeType(component: any, oldValue: any, newValue: any): void;
}

type Color$1 = Color$4;
type Vec2 = Vec2$3;
type Entity$h = Entity$a;
type LightComponentSystem$1 = LightComponentSystem$2;
/**
 * The Light Component enables the Entity to light the scene. There are three types of light:
 * directional, omni and spot. Directional lights are global in that they are considered to be
 * infinitely far away and light the entire scene. Omni and spot lights are local in that they have
 * a position and a range. A spot light is a specialization of an omni light where light is emitted
 * in a cone rather than in all directions. Lights also have the ability to cast shadows to add
 * realism to your scenes.
 *
 * ```javascript
 * // Add a pc.LightComponent to an entity
 * var entity = new pc.Entity();
 * entity.addComponent('light', {
 *     type: "omni",
 *     color: new pc.Color(1, 0, 0),
 *     range: 10
 * });
 *
 * // Get the pc.LightComponent on an entity
 * var lightComponent = entity.light;
 *
 * // Update a property on a light component
 * entity.light.range = 20;
 * ```
 *
 * @property {string} type The type of light. Can be:
 *
 * - "directional": A light that is infinitely far away and lights the entire scene from one
 * direction.
 * - "omni": An omni-directional light that illuminates in all directions from the light source.
 * - "spot": An omni-directional light but is bounded by a cone.
 *
 * Defaults to "directional".
 * @property {Color} color The Color of the light. The alpha component of the color is ignored.
 * Defaults to white (1, 1, 1).
 * @property {number} intensity The brightness of the light. Defaults to 1.
 * @property {number} shape The light source shape. Can be:
 *
 * - {@link pc.LIGHTSHAPE_PUNCTUAL}: Infinitesimally small point.
 * - {@link pc.LIGHTSHAPE_RECT}: Rectangle shape.
 * - {@link pc.LIGHTSHAPE_DISK}: Disk shape.
 * - {@link pc.LIGHTSHAPE_SPHERE}: Sphere shape.
 *
 * Defaults to pc.LIGHTSHAPE_PUNCTUAL.
 * @property {boolean} castShadows If enabled the light will cast shadows. Defaults to false.
 * @property {number} shadowDistance The distance from the viewpoint beyond which shadows are no
 * longer rendered. Affects directional lights only. Defaults to 40.
 * @property {number} shadowResolution The size of the texture used for the shadow map. Valid sizes
 * are 64, 128, 256, 512, 1024, 2048. Defaults to 1024.
 * @property {number} shadowBias The depth bias for tuning the appearance of the shadow mapping
 * generated by this light. Valid range is 0 to 1. Defaults to 0.05.
 * @property {number} numCascades Number of shadow cascades. Can be 1, 2, 3 or 4. Defaults to 1,
 * representing no cascades.
 * @property {number} cascadeDistribution The distribution of subdivision of the camera frustum for
 * individual shadow cascades. Only used if {@link LightComponent#numCascades} is larger than 1.
 * Can be a value in range of 0 and 1. Value of 0 represents a linear distribution, value of 1
 * represents a logarithmic distribution. Defaults to 0.5. Larger value increases the resolution of
 * the shadows in the near distance.
 * @property {number} normalOffsetBias Normal offset depth bias. Valid range is 0 to 1. Defaults to
 * 0.
 * @property {number} range The range of the light. Affects omni and spot lights only. Defaults to
 * 10.
 * @property {number} innerConeAngle The angle at which the spotlight cone starts to fade off. The
 * angle is specified in degrees. Affects spot lights only. Defaults to 40.
 * @property {number} outerConeAngle The angle at which the spotlight cone has faded to nothing.
 * The angle is specified in degrees. Affects spot lights only. Defaults to 45.
 * @property {number} falloffMode Controls the rate at which a light attenuates from its position.
 * Can be:
 *
 * - {@link LIGHTFALLOFF_LINEAR}: Linear.
 * - {@link LIGHTFALLOFF_INVERSESQUARED}: Inverse squared.
 *
 * Affects omni and spot lights only. Defaults to {@link LIGHTFALLOFF_LINEAR}.
 * @property {number} mask Defines a mask to determine which {@link MeshInstance}s are lit by this
 * light. Defaults to 1.
 * @property {boolean} affectDynamic If enabled the light will affect non-lightmapped objects.
 * @property {boolean} affectLightmapped If enabled the light will affect lightmapped objects.
 * @property {boolean} bake If enabled the light will be rendered into lightmaps.
 * @property {number} bakeNumSamples If bake is true, this specifies the number of samples used to
 * bake this light into the lightmap. Defaults to 1. Maximum value is 255.
 * @property {number} bakeArea If bake is true and the light type is {@link LIGHTTYPE_DIRECTIONAL},
 * this specifies the penumbra angle in degrees, allowing a soft shadow boundary. Defaults to 0.
 * @property {boolean} bakeDir If enabled and bake=true, the light's direction will contribute to
 * directional lightmaps. Be aware, that directional lightmap is an approximation and can only hold
 * single direction per pixel. Intersecting multiple lights with bakeDir=true may lead to incorrect
 * look of specular/bump-mapping in the area of intersection. The error is not always visible
 * though, and highly scene-dependent.
 * @property {number} shadowUpdateMode Tells the renderer how often shadows must be updated for
 * this light. Can be:
 *
 * - {@link SHADOWUPDATE_NONE}: Don't render shadows.
 * - {@link SHADOWUPDATE_THISFRAME}: Render shadows only once (then automatically switches to
 * {@link SHADOWUPDATE_NONE}.
 * - {@link SHADOWUPDATE_REALTIME}: Render shadows every frame (default).
 * @property {number} shadowType Type of shadows being rendered by this light. Options:
 *
 * - {@link SHADOW_PCF3}: Render depth (color-packed on WebGL 1.0), can be used for PCF 3x3
 * sampling.
 * - {@link SHADOW_VSM8}: Render packed variance shadow map. All shadow receivers must also cast
 * shadows for this mode to work correctly.
 * - {@link SHADOW_VSM16}: Render 16-bit exponential variance shadow map. Requires
 * OES_texture_half_float extension. Falls back to {@link SHADOW_VSM8}, if not supported.
 * - {@link SHADOW_VSM32}: Render 32-bit exponential variance shadow map. Requires
 * OES_texture_float extension. Falls back to {@link SHADOW_VSM16}, if not supported.
 * - {@link SHADOW_PCF5}: Render depth buffer only, can be used for hardware-accelerated PCF 5x5
 * sampling. Requires WebGL2. Falls back to {@link SHADOW_PCF3} on WebGL 1.0.
 * @property {number} vsmBlurMode Blurring mode for variance shadow maps. Can be:
 *
 * - {@link BLUR_BOX}: Box filter.
 * - {@link BLUR_GAUSSIAN}: Gaussian filter. May look smoother than box, but requires more samples.
 * @property {number} vsmBlurSize Number of samples used for blurring a variance shadow map. Only
 * uneven numbers work, even are incremented. Minimum value is 1, maximum is 25. Defaults to 11.
 * @property {number} cookieAsset Asset that has texture that will be assigned to cookie internally
 * once asset resource is available.
 * @property {Texture} cookie Projection texture. Must be 2D for spot and cubemap for omni light
 * (ignored if incorrect type is used).
 * @property {number} cookieIntensity Projection texture intensity (default is 1).
 * @property {boolean} cookieFalloff Toggle normal spotlight falloff when projection texture is
 * used. When set to false, spotlight will work like a pure texture projector (only fading with
 * distance). Default is false.
 * @property {string} cookieChannel Color channels of the projection texture to use. Can be "r",
 * "g", "b", "a", "rgb".
 * @property {number} cookieAngle Angle for spotlight cookie rotation.
 * @property {Vec2} cookieScale Spotlight cookie scale.
 * @property {Vec2} cookieOffset Spotlight cookie position offset.
 * @property {boolean} isStatic Mark light as non-movable (optimization).
 * @property {number[]} layers An array of layer IDs ({@link Layer#id}) to which this light should
 * belong. Don't push/pop/splice or modify this array, if you want to change it - set a new one
 * instead.
 * @augments Component
 */
declare class LightComponent$2 extends Component$2 {
    /**
     * Creates a new LightComponent instance.
     *
     * @param {LightComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: LightComponentSystem$1, entity: Entity$h);

    set affectDynamic(arg: boolean);
    get affectDynamic(): boolean;

    set affectLightmapped(arg: boolean);
    get affectLightmapped(): boolean;

    set bake(arg: boolean);
    get bake(): boolean;

    set bakeArea(arg: number);
    get bakeArea(): number;

    set bakeDir(arg: boolean);
    get bakeDir(): boolean;

    set bakeNumSamples(arg: number);
    get bakeNumSamples(): number;

    set cascadeDistribution(arg: number);
    get cascadeDistribution(): number;

    set castShadows(arg: boolean);
    get castShadows(): boolean;

    set color(arg: Color$1);
    get color(): Color$1;

    set cookieAngle(arg: number);
    get cookieAngle(): number;

    set cookieChannel(arg: string);
    get cookieChannel(): string;

    set cookieFalloff(arg: boolean);
    get cookieFalloff(): boolean;

    set cookieIntensity(arg: number);
    get cookieIntensity(): number;

    set cookieOffset(arg: Vec2);
    get cookieOffset(): Vec2;

    set cookieScale(arg: Vec2);
    get cookieScale(): Vec2;

    set falloffMode(arg: number);
    get falloffMode(): number;

    set innerConeAngle(arg: number);
    get innerConeAngle(): number;

    set intensity(arg: number);
    get intensity(): number;

    set isStatic(arg: boolean);
    get isStatic(): boolean;

    set layers(arg: number[]);
    get layers(): number[];

    set mask(arg: number);
    get mask(): number;

    set normalOffsetBias(arg: number);
    get normalOffsetBias(): number;

    set numCascades(arg: number);
    get numCascades(): number;

    set outerConeAngle(arg: number);
    get outerConeAngle(): number;

    set range(arg: number);
    get range(): number;

    set shadowBias(arg: number);
    get shadowBias(): number;

    set shadowDistance(arg: number);
    get shadowDistance(): number;

    set shadowResolution(arg: number);
    get shadowResolution(): number;

    set shadowType(arg: number);
    get shadowType(): number;

    set shadowUpdateMode(arg: number);
    get shadowUpdateMode(): number;

    set shape(arg: number);
    get shape(): number;

    set type(arg: string);
    get type(): string;

    set vsmBlurMode(arg: number);
    get vsmBlurMode(): number;

    set vsmBlurSize(arg: number);
    get vsmBlurSize(): number;

    _cookieAsset: any;
    _cookieAssetId: any;
    _cookieAssetAdd: boolean;
    _cookieMatrix: any;
    addLightToLayers(): void;
    removeLightFromLayers(): void;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    refreshProperties(): void;
    updateShadow(): void;
    onCookieAssetSet(): void;
    onCookieAssetAdd(asset: any): void;
    onCookieAssetLoad(): void;
    cookie: any;
    onCookieAssetRemove(): void;
    onRemove(): void;
    cookieAsset: any;
}

declare class LayoutGroupComponentData {
    enabled: boolean;
}

/**
 * Manages creation of {@link LayoutGroupComponent}s.
 *
 * @augments ComponentSystem
 */
declare class LayoutGroupComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof LayoutGroupComponent$1;
    DataType: typeof LayoutGroupComponentData;
    _reflowQueue: any[];
    scheduleReflow(component: any): void;
    _onPostUpdate(): void;
    _processReflowQueue(): void;
    _onRemoveComponent(entity: any, component: any): void;
}

type Entity$g = Entity$a;
type LayoutGroupComponentSystem$1 = LayoutGroupComponentSystem$2;
/**
 * A LayoutGroupComponent enables the Entity to position and scale child {@link ElementComponent}s
 * according to configurable layout rules.
 *
 * @augments Component
 */
declare class LayoutGroupComponent$1 extends Component$2 {
    /**
     * Create a new LayoutGroupComponent instance.
     *
     * @param {LayoutGroupComponentSystem} system - The ComponentSystem that created this
     * Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: LayoutGroupComponentSystem$1, entity: Entity$g);
    /** @private */
    private _orientation;
    /** @private */
    private _reverseX;
    /** @private */
    private _reverseY;
    /** @private */
    private _alignment;
    /** @private */
    private _padding;
    /** @private */
    private _spacing;
    /** @private */
    private _widthFitting;
    /** @private */
    private _heightFitting;
    /** @private */
    private _wrap;
    /** @private */
    private _layoutCalculator;
    /**
     * Whether the layout should run horizontally or vertically. Can be:
     *
     * - {@link ORIENTATION_HORIZONTAL}
     * - {@link ORIENTATION_VERTICAL}
     *
     * Defaults to {@link ORIENTATION_HORIZONTAL}.
     *
     * @type {number}
     */
    set orientation(arg: number);
    get orientation(): number;
    /**
     * Reverses the order of children along the x axis. Defaults to false.
     *
     * @type {boolean}
     */
    set reverseX(arg: boolean);
    get reverseX(): boolean;
    /**
     * Reverses the order of children along the y axis. Defaults to true.
     *
     * @type {boolean}
     */
    set reverseY(arg: boolean);
    get reverseY(): boolean;
    /**
     * Specifies the horizontal and vertical alignment of child elements. Values range from 0 to 1
     * where [0, 0] is the bottom left and [1, 1] is the top right. Defaults to [0, 1].
     *
     * @type {Vec2}
     */
    set alignment(arg: Vec2$3);
    get alignment(): Vec2$3;
    /**
     * Padding to be applied inside the container before positioning any children. Specified as
     * left, bottom, right and top values. Defaults to [0, 0, 0, 0] (no padding).
     *
     * @type {Vec4}
     */
    set padding(arg: Vec4$6);
    get padding(): Vec4$6;
    /**
     * Spacing to be applied between each child element. Defaults to [0, 0] (no spacing).
     *
     * @type {Vec2}
     */
    set spacing(arg: Vec2$3);
    get spacing(): Vec2$3;
    /**
     * Fitting logic to be applied when positioning and scaling child elements. Can be:
     *
     * - {@link FITTING_NONE}: Child elements will be rendered at their natural size.
     * - {@link FITTING_STRETCH}: When the natural size of all child elements does not fill the width
     * of the container, children will be stretched to fit. The rules for how each child will be
     * stretched are outlined below:
     *   1. Sum the {@link LayoutChildComponent#fitWidthProportion} values of each child and normalize
     * so that all values sum to 1.
     *   2. Apply the natural width of each child.
     *   3. If there is space remaining in the container, distribute it to each child based on the
     * normalized {@link LayoutChildComponent#fitWidthProportion} values, but do not exceed the
     * {@link LayoutChildComponent#maxWidth} of each child.
     * - {@link FITTING_SHRINK}: When the natural size of all child elements overflows the width of the
     * container, children will be shrunk to fit. The rules for how each child will be stretched are
     * outlined below:
     *   1. Sum the {@link LayoutChildComponent#fitWidthProportion} values of each child and normalize
     * so that all values sum to 1.
     *   2. Apply the natural width of each child.
     *   3. If the new total width of all children exceeds the available space of the container, reduce
     * each child's width proportionally based on the normalized {@link
     * LayoutChildComponent#fitWidthProportion} values, but do not exceed the {@link
     * LayoutChildComponent#minWidth} of each child.
     * - {@link FITTING_BOTH}: Applies both STRETCH and SHRINK logic as necessary.
     *
     * Defaults to {@link FITTING_NONE}.
     *
     * @type {number}
     */
    set widthFitting(arg: number);
    get widthFitting(): number;
    /**
     * Identical to {@link LayoutGroupComponent#widthFitting} but for the Y axis. Defaults to
     * {@link FITTING_NONE}.
     *
     * @type {number}
     */
    set heightFitting(arg: number);
    get heightFitting(): number;
    /**
     * Whether or not to wrap children onto a new row/column when the size of the container is
     * exceeded. Defaults to false, which means that children will be be rendered in a single row
     * (horizontal orientation) or column (vertical orientation). Note that setting wrap to true
     * makes it impossible for the {@link FITTING_BOTH} fitting mode to operate in any logical
     * manner. For this reason, when wrap is true, a {@link LayoutGroupComponent#widthFitting} or
     * {@link LayoutGroupComponent#heightFitting} mode of {@link FITTING_BOTH} will be coerced to
     * {@link FITTING_STRETCH}.
     *
     * @type {boolean}
     */
    set wrap(arg: boolean);
    get wrap(): boolean;
    _isSelfOrChild(entity: any): boolean;
    _listenForReflowEvents(target: any, onOff: any): void;
    _onElementOrLayoutComponentAdd(entity: any): void;
    _onElementOrLayoutComponentRemove(entity: any): void;
    _onChildInsert(child: any): void;
    _onChildRemove(child: any): void;
    _scheduleReflow(): void;
    reflow(): void;
    _isPerformingReflow: boolean;
    onRemove(): void;
}

declare class LayoutChildComponentData {
    enabled: boolean;
}

/**
 * Manages creation of {@link LayoutChildComponent}s.
 *
 * @augments ComponentSystem
 */
declare class LayoutChildComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof LayoutChildComponent$1;
    DataType: typeof LayoutChildComponentData;
}

type Entity$f = Entity$a;
type LayoutChildComponentSystem$1 = LayoutChildComponentSystem$2;
/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').LayoutChildComponentSystem} LayoutChildComponentSystem */
/**
 * A LayoutChildComponent enables the Entity to control the sizing applied to it by its parent
 * {@link LayoutGroupComponent}.
 *
 * @augments Component
 */
declare class LayoutChildComponent$1 extends Component$2 {
    /**
     * Create a new LayoutChildComponent.
     *
     * @param {LayoutChildComponentSystem} system - The ComponentSystem that created this
     * Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: LayoutChildComponentSystem$1, entity: Entity$f);
    /** @private */
    private _minWidth;
    /** @private */
    private _minHeight;
    /** @private */
    private _maxWidth;
    /** @private */
    private _maxHeight;
    /** @private */
    private _fitWidthProportion;
    /** @private */
    private _fitHeightProportion;
    /** @private */
    private _excludeFromLayout;
    /**
     * The minimum width the element should be rendered at.
     *
     * @type {number}
     */
    set minWidth(arg: number);
    get minWidth(): number;
    /**
     * The minimum height the element should be rendered at.
     *
     * @type {number}
     */
    set minHeight(arg: number);
    get minHeight(): number;
    /**
     * The maximum width the element should be rendered at.
     *
     * @type {number|null}
     */
    set maxWidth(arg: any);
    get maxWidth(): any;
    /**
     * The maximum height the element should be rendered at.
     *
     * @type {number|null}
     */
    set maxHeight(arg: any);
    get maxHeight(): any;
    /**
     * The amount of additional horizontal space that the element should take up, if necessary to
     * satisfy a Stretch/Shrink fitting calculation. This is specified as a proportion, taking into
     * account the proportion values of other siblings.
     *
     * @type {number}
     */
    set fitWidthProportion(arg: number);
    get fitWidthProportion(): number;
    /**
     * The amount of additional vertical space that the element should take up, if necessary to
     * satisfy a Stretch/Shrink fitting calculation. This is specified as a proportion, taking into
     * account the proportion values of other siblings.
     *
     * @type {number}
     */
    set fitHeightProportion(arg: number);
    get fitHeightProportion(): number;
    /**
     * If set to true, the child will be excluded from all layout calculations.
     *
     * @type {boolean}
     */
    set excludeFromLayout(arg: boolean);
    get excludeFromLayout(): boolean;
}

declare class CollisionComponentData {
    enabled: boolean;
    type: string;
    halfExtents: Vec3$1;
    radius: number;
    axis: number;
    height: number;
    asset: any;
    renderAsset: any;
    shape: any;
    model: any;
    render: any;
    initialized: boolean;
}

/**
 * Manages creation of {@link CollisionComponent}s.
 *
 * @augments ComponentSystem
 */
declare class CollisionComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof CollisionComponent$1;
    DataType: typeof CollisionComponentData;
    implementations: {};
    _triMeshCache: {};
    _createImplementation(type: any): any;
    _getImplementation(entity: any): any;
    onBeforeRemove(entity: any, component: any): void;
    onRemove(entity: any, data: any): void;
    updateCompoundChildTransform(entity: any): void;
    _removeCompoundChild(collision: any, shape: any): void;
    onTransformChanged(component: any, position: any, rotation: any, scale: any): void;
    changeType(component: any, previousType: any, newType: any): void;
    recreatePhysicalShapes(component: any): void;
    _calculateNodeRelativeTransform(node: any, relative: any): void;
    _getNodeScaling(node: any): any;
    _getNodeTransform(node: any, relative: any): any;
}

type Entity$e = Entity$a;
type CollisionComponentSystem$1 = CollisionComponentSystem$2;
/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').CollisionComponentSystem} CollisionComponentSystem */
/**
 * A collision volume. Use this in conjunction with a {@link RigidBodyComponent} to make a
 * collision volume that can be simulated using the physics engine.
 *
 * If the {@link Entity} does not have a {@link RigidBodyComponent} then this collision volume will
 * act as a trigger volume. When an entity with a dynamic or kinematic body enters or leaves an
 * entity with a trigger volume, both entities will receive trigger events.
 *
 * The following table shows all the events that can be fired between two Entities:
 *
 * |                                       | Rigid Body (Static)                                                   | Rigid Body (Dynamic or Kinematic)                                     | Trigger Volume                                      |
 * | ------------------------------------- | --------------------------------------------------------------------- | --------------------------------------------------------------------- | --------------------------------------------------- |
 * | **Rigid Body (Static)**               |                                                                       | <ul><li>contact</li><li>collisionstart</li><li>collisionend</li></ul> |                                                     |
 * | **Rigid Body (Dynamic or Kinematic)** | <ul><li>contact</li><li>collisionstart</li><li>collisionend</li></ul> | <ul><li>contact</li><li>collisionstart</li><li>collisionend</li></ul> | <ul><li>triggerenter</li><li>triggerleave</li></ul> |
 * | **Trigger Volume**                    |                                                                       | <ul><li>triggerenter</li><li>triggerleave</li></ul>                   |                                                     |
 *
 * @property {string} type The type of the collision volume. Can be:
 *
 * - "box": A box-shaped collision volume.
 * - "capsule": A capsule-shaped collision volume.
 * - "compound": A compound shape. Any descendant entities with a collision component
 * of type box, capsule, cone, cylinder or sphere will be combined into a single, rigid
 * shape.
 * - "cone": A cone-shaped collision volume.
 * - "cylinder": A cylinder-shaped collision volume.
 * - "mesh": A collision volume that uses a model asset as its shape.
 * - "sphere": A sphere-shaped collision volume.
 *
 * Defaults to "box".
 * @property {Vec3} halfExtents The half-extents of the box-shaped collision volume in the x, y and
 * z axes. Defaults to [0.5, 0.5, 0.5].
 * @property {number} radius The radius of the sphere, capsule, cylinder or cone-shaped collision
 * volumes. Defaults to 0.5.
 * @property {number} axis The local space axis with which the capsule, cylinder or cone-shaped
 * collision volume's length is aligned. 0 for X, 1 for Y and 2 for Z. Defaults to 1 (Y-axis).
 * @property {number} height The total height of the capsule, cylinder or cone-shaped collision
 * volume from tip to tip. Defaults to 2.
 * @property {Asset|number} asset The asset for the model of the mesh collision volume - can also
 * be an asset id. Defaults to null.
 * @property {Asset|number} renderAsset The render asset of the mesh collision volume - can also be
 * an asset id. Defaults to null. If not set then the asset property will be checked instead.
 * @property {Model} model The model that is added to the scene graph for the mesh collision
 * volume.
 * @augments Component
 */
declare class CollisionComponent$1 extends Component$2 {
    /**
     * Create a new CollisionComponent.
     *
     * @param {CollisionComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: CollisionComponentSystem$1, entity: Entity$e);
    _compoundParent: any;
    /**
     * @event
     * @name CollisionComponent#contact
     * @description The 'contact' event is fired when a contact occurs between two rigid bodies.
     * @param {ContactResult} result - Details of the contact between the two rigid bodies.
     */
    /**
     * @event
     * @name CollisionComponent#collisionstart
     * @description The 'collisionstart' event is fired when two rigid bodies start touching.
     * @param {ContactResult} result - Details of the contact between the two Entities.
     */
    /**
     * @event
     * @name CollisionComponent#collisionend
     * @description The 'collisionend' event is fired two rigid-bodies stop touching.
     * @param {Entity} other - The {@link Entity} that stopped touching this collision volume.
     */
    /**
     * @event
     * @name CollisionComponent#triggerenter
     * @description The 'triggerenter' event is fired when a rigid body enters a trigger volume.
     * a {@link RigidBodyComponent} attached.
     * @param {Entity} other - The {@link Entity} that entered this collision volume.
     */
    /**
     * @event
     * @name CollisionComponent#triggerleave
     * @description The 'triggerleave' event is fired when a rigid body exits a trigger volume.
     * a {@link RigidBodyComponent} attached.
     * @param {Entity} other - The {@link Entity} that exited this collision volume.
     */
    onSetType(name: any, oldValue: any, newValue: any): void;
    onSetHalfExtents(name: any, oldValue: any, newValue: any): void;
    onSetRadius(name: any, oldValue: any, newValue: any): void;
    onSetHeight(name: any, oldValue: any, newValue: any): void;
    onSetAxis(name: any, oldValue: any, newValue: any): void;
    onSetAsset(name: any, oldValue: any, newValue: any): void;
    onSetRenderAsset(name: any, oldValue: any, newValue: any): void;
    onSetModel(name: any, oldValue: any, newValue: any): void;
    onSetRender(name: any, oldValue: any, newValue: any): void;
    onAssetRemoved(asset: any): void;
    asset: any;
    onRenderAssetRemoved(asset: any): void;
    renderAsset: any;
    _getCompoundChildShapeIndex(shape: any): number;
    _onInsert(parent: any): void;
    _updateCompound(): void;
    onBeforeRemove(): void;
}

declare class ButtonComponentData {
    enabled: boolean;
    active: boolean;
    imageEntity: any;
    hitPadding: Vec4$6;
    transitionMode: number;
    hoverTint: Color$4;
    pressedTint: Color$4;
    inactiveTint: Color$4;
    fadeDuration: number;
    hoverSpriteAsset: any;
    hoverSpriteFrame: number;
    pressedSpriteAsset: any;
    pressedSpriteFrame: number;
    inactiveSpriteAsset: any;
    inactiveSpriteFrame: number;
}

/**
 * Manages creation of {@link ButtonComponent}s.
 *
 * @augments ComponentSystem
 */
declare class ButtonComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof ButtonComponent$1;
    DataType: typeof ButtonComponentData;
    onUpdate(dt: any): void;
    _onRemoveComponent(entity: any, component: any): void;
}

type Asset$3 = Asset$6;
type Vec4$2 = Vec4$6;
type Entity$d = Entity$a;
type ButtonComponentSystem$1 = ButtonComponentSystem$2;
/**
 * A ButtonComponent enables a group of entities to behave like a button, with different visual
 * states for hover and press interactions.
 *
 * @property {boolean} active If set to false, the button will be visible but will not respond to hover or touch interactions.
 * @property {Entity} imageEntity A reference to the entity to be used as the button background. The entity must have an ImageElement component.
 * @property {Vec4} hitPadding Padding to be used in hit-test calculations. Can be used to expand the bounding box so that the button is easier to tap.
 * @property {number} transitionMode Controls how the button responds when the user hovers over it/presses it.
 * @property {Color} hoverTint Color to be used on the button image when the user hovers over it.
 * @property {Color} pressedTint Color to be used on the button image when the user presses it.
 * @property {Color} inactiveTint Color to be used on the button image when the button is not interactive.
 * @property {number} fadeDuration Duration to be used when fading between tints, in milliseconds.
 * @property {Asset} hoverSpriteAsset Sprite to be used as the button image when the user hovers over it.
 * @property {number} hoverSpriteFrame Frame to be used from the hover sprite.
 * @property {Asset} pressedSpriteAsset Sprite to be used as the button image when the user presses it.
 * @property {number} pressedSpriteFrame Frame to be used from the pressed sprite.
 * @property {Asset} inactiveSpriteAsset Sprite to be used as the button image when the button is not interactive.
 * @property {number} inactiveSpriteFrame Frame to be used from the inactive sprite.
 * @augments Component
 */
declare class ButtonComponent$1 extends Component$2 {
    /**
     * Create a new ButtonComponent instance.
     *
     * @param {ButtonComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ButtonComponentSystem$1, entity: Entity$d);

    set active(arg: boolean);
    get active(): boolean;

    set fadeDuration(arg: number);
    get fadeDuration(): number;

    set hitPadding(arg: Vec4$2);
    get hitPadding(): Vec4$2;

    set hoverSpriteAsset(arg: Asset$3);
    get hoverSpriteAsset(): Asset$3;

    set hoverSpriteFrame(arg: number);
    get hoverSpriteFrame(): number;

    set hoverTint(arg: Color$4);
    get hoverTint(): Color$4;

    set imageEntity(arg: Entity$d);
    get imageEntity(): Entity$d;

    set inactiveSpriteAsset(arg: Asset$3);
    get inactiveSpriteAsset(): Asset$3;

    set inactiveSpriteFrame(arg: number);
    get inactiveSpriteFrame(): number;

    set inactiveTint(arg: Color$4);
    get inactiveTint(): Color$4;

    set pressedSpriteAsset(arg: Asset$3);
    get pressedSpriteAsset(): Asset$3;

    set pressedSpriteFrame(arg: number);
    get pressedSpriteFrame(): number;

    set pressedTint(arg: Color$4);
    get pressedTint(): Color$4;

    set transitionMode(arg: number);
    get transitionMode(): number;

    _visualState: string;
    _isHovering: boolean;
    _hoveringCounter: number;
    _isPressed: boolean;
    _defaultTint: Color$4;
    _defaultSpriteAsset: any;
    _defaultSpriteFrame: number;
    _imageReference: EntityReference;
    _toggleLifecycleListeners(onOrOff: any, system: any): void;
    _onSetActive(name: any, oldValue: any, newValue: any): void;
    _onSetTransitionMode(name: any, oldValue: any, newValue: any): void;
    _onSetTransitionValue(name: any, oldValue: any, newValue: any): void;
    _onElementComponentRemove(entity: any): void;
    _onElementComponentAdd(entity: any): void;
    _onImageElementLose(): void;
    _onImageElementGain(): void;
    _toggleHitElementListeners(onOrOff: any): void;
    _hasHitElementListeners: boolean;
    _storeDefaultVisualState(): void;
    _storeDefaultColor(color: any): void;
    _storeDefaultOpacity(opacity: any): void;
    _storeDefaultSpriteAsset(spriteAsset: any): void;
    _storeDefaultSpriteFrame(spriteFrame: any): void;
    _onSetColor(color: any): void;
    _onSetOpacity(opacity: any): void;
    _onSetSpriteAsset(spriteAsset: any): void;
    _onSetSpriteFrame(spriteFrame: any): void;
    _onMouseEnter(event: any): void;
    _onMouseLeave(event: any): void;
    _onMouseDown(event: any): void;
    _onMouseUp(event: any): void;
    _onTouchStart(event: any): void;
    _onTouchEnd(event: any): void;
    _onTouchLeave(event: any): void;
    _onTouchCancel(event: any): void;
    _onSelectStart(event: any): void;
    _onSelectEnd(event: any): void;
    _onSelectEnter(event: any): void;
    _onSelectLeave(event: any): void;
    _onClick(event: any): void;
    _fireIfActive(name: any, event: any): void;
    _updateVisualState(force: any): void;
    _forceReapplyVisualState(): void;
    _resetToDefaultVisualState(transitionMode: any): void;
    _determineVisualState(): string;
    _applySprite(spriteAsset: any, spriteFrame: any): void;
    _isApplyingSprite: boolean;
    _applyTint(tintColor: any): void;
    _applyTintImmediately(tintColor: any): void;
    _isApplyingTint: boolean;
    _applyTintWithTween(tintColor: any): void;
    _tweenInfo: {
        startTime: number;
        from: Color$4;
        to: any;
        lerpColor: Color$4;
    };
    _updateTintTween(): void;
    _cancelTween(): void;
    onUpdate(): void;
    onRemove(): void;
}

declare class AudioListenerComponentData {
    enabled: boolean;
}

type SoundManager$4 = SoundManager$7;
type Application$e = Application$7;
/**
 * Component System for adding and removing {@link AudioComponent} objects to Entities.
 *
 * @augments ComponentSystem
 */
declare class AudioListenerComponentSystem$2 extends ComponentSystem {
    /**
     * Create a new AudioListenerComponentSystem instance.
     *
     * @param {Application} app - The application managing this system.
     * @param {SoundManager} manager - A sound manager instance.
     */
    constructor(app: Application$e, manager: SoundManager$4);
    id: string;
    ComponentType: typeof AudioListenerComponent$1;
    DataType: typeof AudioListenerComponentData;
    manager: SoundManager$7;
    current: any;
    onUpdate(dt: any): void;
}

type Entity$c = Entity$a;
type AudioListenerComponentSystem$1 = AudioListenerComponentSystem$2;
/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').AudioListenerComponentSystem} AudioListenerComponentSystem */
/**
 * Represents the audio listener in the 3D world, so that 3D positioned audio sources are heard
 * correctly.
 *
 * @augments Component
 */
declare class AudioListenerComponent$1 extends Component$2 {
    /**
     * Create a new AudioListenerComponent instance.
     *
     * @param {AudioListenerComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: AudioListenerComponentSystem$1, entity: Entity$c);
    setCurrentListener(): void;
}

declare class AnimationComponentData {
    assets: any[];
    speed: number;
    loop: boolean;
    activate: boolean;
    enabled: boolean;
    animations: {};
    model: any;
    prevAnim: any;
    currAnim: any;
    blending: boolean;
    blend: number;
    blendSpeed: number;
    playing: boolean;
    skeleton: any;
    fromSkel: any;
    toSkel: any;
    animEvaluator: any;
}

/**
 * The AnimationComponentSystem manages creating and deleting AnimationComponents.
 *
 * @augments ComponentSystem
 */
declare class AnimationComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof AnimationComponent$1;
    DataType: typeof AnimationComponentData;
    onBeforeRemove(entity: any, component: any): void;
    onUpdate(dt: any): void;
}

type Entity$b = Entity$a;
type AnimationComponentSystem$1 = AnimationComponentSystem$2;
/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').AnimationComponentSystem} AnimationComponentSystem */
/**
 * The Animation Component allows an Entity to playback animations on models.
 *
 * @property {number} speed Speed multiplier for animation play back speed. 1.0 is playback at normal speed, 0.0 pauses the animation.
 * @property {boolean} loop If true the animation will restart from the beginning when it reaches the end.
 * @property {boolean} activate If true the first animation asset will begin playing when the scene is loaded.
 * @property {Asset[]|number[]} assets The array of animation assets - can also be an array of asset ids.
 * @property {Skeleton|null} skeleton Get the skeleton for the current model; unless model is from glTF/glb, then skeleton is null. [read only]
 * @property {object<string, Animation>} animations Get or Set dictionary of animations by name.
 * @augments Component
 */
declare class AnimationComponent$1 extends Component$2 {
    /**
     * Create a new AnimationComponent instance.
     *
     * @param {AnimationComponentSystem} system - The {@link ComponentSystem} that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: AnimationComponentSystem$1, entity: Entity$b);
    animationsIndex: {};
    /**
     * Get or Set the current time position (in seconds) of the animation.
     *
     * @type {number}
     */
    set currentTime(arg: any);
    get currentTime(): any;
    /**
     * Get the duration in seconds of the current animation.
     *
     * @type {number}
     */
    get duration(): number;
    /**
     * Start playing an animation.
     *
     * @param {string} name - The name of the animation asset to begin playing.
     * @param {number} [blendTime] - The time in seconds to blend from the current
     * animation state to the start of the animation being set. Defaults to 0.
     */
    play(name: string, blendTime?: number): void;
    /**
     * Return an animation.
     *
     * @param {string} name - The name of the animation asset.
     * @returns {Animation} An Animation.
     */
    getAnimation(name: string): Animation;
    setModel(model: any): void;
    _resetAnimationController(): void;
    _createAnimationController(): void;
    loadAnimationAssets(ids: any): void;
    animations: any;
    onAssetChanged(asset: any, attribute: any, newValue: any, oldValue: any): void;
    onAssetRemoved(asset: any): void;
    _stopCurrentAnimation(): void;
    onSetAnimations(name: any, oldValue: any, newValue: any): void;
    onSetAssets(name: any, oldValue: any, newValue: any): void;
    onSetLoop(name: any, oldValue: any, newValue: any): void;
    onSetCurrentTime(name: any, oldValue: any, newValue: any): void;
    onBeforeRemove(): void;
}

declare class AnimComponentData {
    enabled: boolean;
}

/**
 * The AnimComponentSystem manages creating and deleting AnimComponents.
 *
 * @augments ComponentSystem
 */
declare class AnimComponentSystem$2 extends ComponentSystem {
    id: string;
    ComponentType: typeof AnimComponent$1;
    DataType: typeof AnimComponentData;
    onAnimationUpdate(dt: any): void;
    onBeforeRemove(entity: any, component: any): void;
}

type AnimComponent$2 = AnimComponent$1;
type Asset$2 = Asset$6;
/** @typedef {import('./component.js').AnimComponent} AnimComponent */
/** @typedef {import('../../../asset/asset.js').Asset} Asset */
/**
 * The Anim Component Layer allows managers a single layer of the animation state graph.
 */
declare class AnimComponentLayer {
    /**
     * Create a new AnimComponentLayer instance.
     *
     * @param {string} name - The name of the layer.
     * @param {object} controller - The controller to manage this layers animations.
     * @param {AnimComponent} component - The component that this layer is a member of.
     * @param {number} [weight] - The weight of this layer. Defaults to 1.
     * @param {string} [blendType] - The blend type of this layer. Defaults to {@link ANIM_LAYER_OVERWRITE}.
     */
    constructor(name: string, controller: object, component: AnimComponent$2, weight?: number, blendType?: string);
    _name: string;
    _controller: any;
    _component: AnimComponent$1;
    _weight: number;
    _blendType: string;
    _mask: any;
    /**
     * Returns the name of the layer.
     *
     * @type {string}
     */
    get name(): string;
    /**
     * Whether this layer is currently playing.
     *
     * @type {string}
     */
    set playing(arg: any);
    get playing(): any;
    /**
     * Returns true if a state graph has been loaded and all states in the graph have been assigned
     * animation tracks.
     *
     * @type {string}
     */
    get playable(): string;
    /**
     * Returns the currently active state name.
     *
     * @type {string}
     */
    get activeState(): string;
    /**
     * Returns the previously active state name.
     *
     * @type {string}
     */
    get previousState(): string;
    /**
     * Returns the currently active states progress as a value normalized by the states animation
     * duration. Looped animations will return values greater than 1.
     *
     * @type {number}
     */
    get activeStateProgress(): number;
    /**
     * Returns the currently active states duration.
     *
     * @type {number}
     */
    get activeStateDuration(): number;
    /**
     * The active states time in seconds.
     *
     * @type {number}
     */
    set activeStateCurrentTime(arg: any);
    get activeStateCurrentTime(): any;
    /**
     * Returns whether the anim component layer is currently transitioning between states.
     *
     * @type {boolean}
     */
    get transitioning(): boolean;
    /**
     * If the anim component layer is currently transitioning between states, returns the progress.
     * Otherwise returns null.
     *
     * @type {number|null}
     */
    get transitionProgress(): number;
    /**
     * Lists all available states in this layers state graph.
     *
     * @type {string[]}
     */
    get states(): string[];
    /**
     * The blending weight of this layer. Used when calculating the value of properties that are
     * animated by more than one layer.
     *
     * @type {number}
     */
    set weight(arg: number);
    get weight(): number;
    set blendType(arg: string);
    get blendType(): string;
    /**
     * A mask of bones which should be animated or ignored by this layer.
     *
     * @type {object}
     * @example
     * entity.anim.baseLayer.mask = {
     *     // include the spine of the current model and all of its children
     *     "path/to/spine": {
     *         children: true
     *     },
     *     // include the hip of the current model but not all of its children
     *     "path/to/hip": true
     * };
     */
    set mask(arg: any);
    get mask(): any;
    /**
     * Start playing the animation in the current state.
     *
     * @param {string} [name] - If provided, will begin playing from the start of the state with
     * this name.
     */
    play(name?: string): void;
    /**
     * Pause the animation in the current state.
     */
    pause(): void;
    /**
     * Reset the animation component to its initial state, including all parameters. The system
     * will be paused.
     */
    reset(): void;
    /**
     * Rebind any animations in the layer to the currently present components and model of the anim
     * components entity.
     */
    rebind(): void;
    update(dt: any): void;
    /**
     * Add a mask to this layer.
     *
     * @param {object} [mask] - The mask to assign to the layer. If not provided the current mask
     * in the layer will be removed.
     * @example
     * entity.anim.baseLayer.assignMask({
     *     // include the spine of the current model and all of its children
     *     "path/to/spine": {
     *         children: true
     *     },
     *     // include the hip of the current model but not all of its children
     *     "path/to/hip": true
     * });
     * @ignore
     */
    assignMask(mask?: object): void;
    /**
     * Assigns an animation track to a state or blend tree node in the current graph. If a state
     * for the given nodePath doesn't exist, it will be created. If all states nodes are linked and
     * the {@link AnimComponent#activate} value was set to true then the component will begin
     * playing.
     *
     * @param {string} nodePath - Either the state name or the path to a blend tree node that this
     * animation should be associated with. Each section of a blend tree path is split using a
     * period (`.`) therefore state names should not include this character (e.g "MyStateName" or
     * "MyStateName.BlendTreeNode").
     * @param {object} animTrack - The animation track that will be assigned to this state and
     * played whenever this state is active.
     * @param {number} [speed] - Update the speed of the state you are assigning an animation to.
     * Defaults to 1.
     * @param {boolean} [loop] - Update the loop property of the state you are assigning an
     * animation to. Defaults to true.
     */
    assignAnimation(nodePath: string, animTrack: object, speed?: number, loop?: boolean): void;
    /**
     * Removes animations from a node in the loaded state graph.
     *
     * @param {string} nodeName - The name of the node that should have its animation tracks removed.
     */
    removeNodeAnimations(nodeName: string): void;
    /**
     * Returns the asset that is associated with the given state.
     *
     * @param {string} stateName - The name of the state to get the asset for.
     * @returns {Asset} The asset associated with the given state.
     */
    getAnimationAsset(stateName: string): Asset$2;
    /**
     * Transition to any state in the current layers graph. Transitions can be instant or take an
     * optional blend time.
     *
     * @param {string} to - The state that this transition will transition to.
     * @param {number} [time] - The duration of the transition in seconds. Defaults to 0.
     * @param {number} [transitionOffset] - If provided, the destination state will begin playing
     * its animation at this time. Given in normalized time, based on the states duration & must be
     * between 0 and 1. Defaults to null.
     */
    transition(to: string, time?: number, transitionOffset?: number): void;
}

type AnimComponentSystem$1 = AnimComponentSystem$2;
/** @typedef {import('./system.js').AnimComponentSystem} AnimComponentSystem */
/**
 * The Anim Component allows an Entity to playback animations on models and entity properties.
 *
 * @augments Component
 */
declare class AnimComponent$1 extends Component$2 {
    /**
     * Create a new AnimComponent instance.
     *
     * @param {AnimComponentSystem} system - The {@link ComponentSystem} that created this
     * Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: AnimComponentSystem$1, entity: Entity$a);
    _stateGraphAsset: any;
    _animationAssets: {};
    _speed: number;
    _activate: boolean;
    _playing: boolean;
    _rootBone: any;
    _stateGraph: any;
    _layers: any[];
    _layerIndices: {};
    _parameters: {};
    _targets: {};
    _consumedTriggers: Set<any>;
    set stateGraphAsset(arg: any);
    get stateGraphAsset(): any;
    set animationAssets(arg: {});
    get animationAssets(): {};
    /**
     * Speed multiplier for animation play back speed. 1.0 is playback at normal speed, 0.0 pauses
     * the animation.
     *
     * @type {number}
     */
    set speed(arg: number);
    get speed(): number;
    /**
     * If true the first animation will begin playing when the scene is loaded.
     *
     * @type {boolean}
     */
    set activate(arg: boolean);
    get activate(): boolean;
    /**
     * Plays or pauses all animations in the component.
     *
     * @type {boolean}
     */
    set playing(arg: boolean);
    get playing(): boolean;
    /**
     * The entity that this anim component should use as the root of the animation hierarchy.
     *
     * @type {Entity}
     */
    set rootBone(arg: any);
    get rootBone(): any;
    set stateGraph(arg: any);
    get stateGraph(): any;
    /**
     * Returns the animation layers available in this anim component.
     *
     * @type {AnimComponentLayer[]}
     */
    get layers(): AnimComponentLayer[];
    set layerIndices(arg: {});
    get layerIndices(): {};
    set parameters(arg: {});
    get parameters(): {};
    set targets(arg: {});
    get targets(): {};
    /**
     * Returns whether all component layers are currently playable.
     *
     * @type {boolean}
     */
    get playable(): boolean;
    /**
     * Returns the base layer of the state graph.
     *
     * @type {AnimComponentLayer|null}
     */
    get baseLayer(): AnimComponentLayer;
    _onStateGraphAssetChangeEvent(asset: any): void;
    dirtifyTargets(): void;
    _addLayer({ name, states, transitions, weight, mask, blendType }: {
        name: any;
        states: any;
        transitions: any;
        weight: any;
        mask: any;
        blendType: any;
    }): any;
    /**
     * Adds a new anim component layer to the anim component.
     *
     * @param {string} name - The name of the layer to create.
     * @param {number} [weight] - The blending weight of the layer. Defaults to 1.
     * @param {object[]} [mask] - A list of paths to bones in the model which should be animated in
     * this layer. If omitted the full model is used. Defaults to null.
     * @param {string} [blendType] - Defines how properties animated by this layer blend with
     * animations of those properties in previous layers. Defaults to pc.ANIM_LAYER_OVERWRITE.
     * @returns {AnimComponentLayer} The created anim component layer.
     */
    addLayer(name: string, weight?: number, mask?: object[], blendType?: string): AnimComponentLayer;
    /**
     * Initializes component animation controllers using the provided state graph.
     *
     * @param {object} stateGraph - The state graph asset to load into the component. Contains the
     * states, transitions and parameters used to define a complete animation controller.
     * @example
     * entity.anim.loadStateGraph({
     *     "layers": [
     *         {
     *             "name": layerName,
     *             "states": [
     *                 {
     *                     "name": "START",
     *                     "speed": 1
     *                 },
     *                 {
     *                     "name": "Initial State",
     *                     "speed": speed,
     *                     "loop": loop,
     *                     "defaultState": true
     *                 }
     *             ],
     *             "transitions": [
     *                 {
     *                     "from": "START",
     *                     "to": "Initial State"
     *                 }
     *             ]
     *         }
     *     ],
     *     "parameters": {}
     * });
     */
    loadStateGraph(stateGraph: object): void;
    setupAnimationAssets(): void;
    loadAnimationAssets(): void;
    onAnimationAssetLoaded(layerName: any, stateName: any, asset: any): void;
    /**
     * Removes all layers from the anim component.
     */
    removeStateGraph(): void;
    resetStateGraph(): void;
    /**
     * Reset all of the components layers and parameters to their initial states. If a layer was
     * playing before it will continue playing.
     */
    reset(): void;
    /**
     * Rebind all of the components layers.
     */
    rebind(): void;
    /**
     * Finds a {@link AnimComponentLayer} in this component.
     *
     * @param {string} name - The name of the anim component layer to find.
     * @returns {AnimComponentLayer} Layer.
     */
    findAnimationLayer(name: string): AnimComponentLayer;
    addAnimationState(nodeName: any, animTrack: any, speed?: number, loop?: boolean, layerName?: string): void;
    /**
     * Associates an animation with a state or blend tree node in the loaded state graph. If all
     * states are linked and the {@link AnimComponent#activate} value was set to true then the
     * component will begin playing. If no state graph is loaded, a default state graph will be
     * created with a single state based on the provided nodePath parameter.
     *
     * @param {string} nodePath - Either the state name or the path to a blend tree node that this
     * animation should be associated with. Each section of a blend tree path is split using a
     * period (`.`) therefore state names should not include this character (e.g "MyStateName" or
     * "MyStateName.BlendTreeNode").
     * @param {object} animTrack - The animation track that will be assigned to this state and
     * played whenever this state is active.
     * @param {string} [layerName] - The name of the anim component layer to update. If omitted the
     * default layer is used. If no state graph has been previously loaded this parameter is
     * ignored.
     * @param {number} [speed] - Update the speed of the state you are assigning an animation to.
     * Defaults to 1.
     * @param {boolean} [loop] - Update the loop property of the state you are assigning an
     * animation to. Defaults to true.
     */
    assignAnimation(nodePath: string, animTrack: object, layerName?: string, speed?: number, loop?: boolean): void;
    /**
     * Removes animations from a node in the loaded state graph.
     *
     * @param {string} nodeName - The name of the node that should have its animation tracks removed.
     * @param {string} [layerName] - The name of the anim component layer to update. If omitted the
     * default layer is used.
     */
    removeNodeAnimations(nodeName: string, layerName?: string): void;
    getParameterValue(name: any, type: any): any;
    setParameterValue(name: any, type: any, value: any): void;
    /**
     * Returns a float parameter value by name.
     *
     * @param {string} name - The name of the float to return the value of.
     * @returns {number} A float.
     */
    getFloat(name: string): number;
    /**
     * Sets the value of a float parameter that was defined in the animation components state graph.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {number} value - The new float value to set this parameter to.
     */
    setFloat(name: string, value: number): void;
    /**
     * Returns an integer parameter value by name.
     *
     * @param {string} name - The name of the integer to return the value of.
     * @returns {number} An integer.
     */
    getInteger(name: string): number;
    /**
     * Sets the value of an integer parameter that was defined in the animation components state
     * graph.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {number} value - The new integer value to set this parameter to.
     */
    setInteger(name: string, value: number): void;
    /**
     * Returns a boolean parameter value by name.
     *
     * @param {string} name - The name of the boolean to return the value of.
     * @returns {boolean} A boolean.
     */
    getBoolean(name: string): boolean;
    /**
     * Sets the value of a boolean parameter that was defined in the animation components state
     * graph.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {boolean} value - The new boolean value to set this parameter to.
     */
    setBoolean(name: string, value: boolean): void;
    /**
     * Returns a trigger parameter value by name.
     *
     * @param {string} name - The name of the trigger to return the value of.
     * @returns {boolean} A boolean.
     */
    getTrigger(name: string): boolean;
    /**
     * Sets the value of a trigger parameter that was defined in the animation components state
     * graph to true.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {boolean} [singleFrame] - If true, this trigger will be set back to false at the end
     * of the animation update. Defaults to false.
     */
    setTrigger(name: string, singleFrame?: boolean): void;
    /**
     * Resets the value of a trigger parameter that was defined in the animation components state
     * graph to false.
     *
     * @param {string} name - The name of the parameter to set.
     */
    resetTrigger(name: string): void;
    onBeforeRemove(): void;
    update(dt: any): void;
    resolveDuplicatedEntityReferenceProperties(oldAnim: any, duplicatedIdsMap: any): void;
}

type Component = Component$2;
type AnimComponent = AnimComponent$1;
type AnimationComponent = AnimationComponent$1;
type AudioListenerComponent = AudioListenerComponent$1;
type ButtonComponent = ButtonComponent$1;
type CameraComponent$6 = CameraComponent$2;
type CollisionComponent = CollisionComponent$1;
type ElementComponent$1 = ElementComponent$2;
type LayoutChildComponent = LayoutChildComponent$1;
type LayoutGroupComponent = LayoutGroupComponent$1;
type LightComponent$1 = LightComponent$2;
type ModelComponent = ModelComponent$1;
type ParticleSystemComponent = ParticleSystemComponent$1;
type RenderComponent = RenderComponent$1;
type RigidBodyComponent = RigidBodyComponent$1;
type ScreenComponent = ScreenComponent$1;
type ScriptComponent = ScriptComponent$1;
type ScrollbarComponent = ScrollbarComponent$1;
type ScrollViewComponent = ScrollViewComponent$1;
type SoundComponent = SoundComponent$1;
type SpriteComponent = SpriteComponent$1;
/** @typedef {import('./components/component.js').Component} Component */
/** @typedef {import('./components/anim/component.js').AnimComponent} AnimComponent */
/** @typedef {import('./components/animation/component.js').AnimationComponent} AnimationComponent */
/** @typedef {import('./components/audio-listener/component.js').AudioListenerComponent} AudioListenerComponent */
/** @typedef {import('./components/button/component.js').ButtonComponent} ButtonComponent */
/** @typedef {import('./components/camera/component.js').CameraComponent} CameraComponent */
/** @typedef {import('./components/collision/component.js').CollisionComponent} CollisionComponent */
/** @typedef {import('./components/element/component.js').ElementComponent} ElementComponent */
/** @typedef {import('./components/layout-child/component.js').LayoutChildComponent} LayoutChildComponent */
/** @typedef {import('./components/layout-group/component.js').LayoutGroupComponent} LayoutGroupComponent */
/** @typedef {import('./components/light/component.js').LightComponent} LightComponent */
/** @typedef {import('./components/model/component.js').ModelComponent} ModelComponent */
/** @typedef {import('./components/particle-system/component.js').ParticleSystemComponent} ParticleSystemComponent */
/** @typedef {import('./components/render/component.js').RenderComponent} RenderComponent */
/** @typedef {import('./components/rigid-body/component.js').RigidBodyComponent} RigidBodyComponent */
/** @typedef {import('./components/screen/component.js').ScreenComponent} ScreenComponent */
/** @typedef {import('./components/script/component.js').ScriptComponent} ScriptComponent */
/** @typedef {import('./components/scrollbar/component.js').ScrollbarComponent} ScrollbarComponent */
/** @typedef {import('./components/scroll-view/component.js').ScrollViewComponent} ScrollViewComponent */
/** @typedef {import('./components/sound/component.js').SoundComponent} SoundComponent */
/** @typedef {import('./components/sprite/component.js').SpriteComponent} SpriteComponent */
/**
 * The Entity is the core primitive of a PlayCanvas game. Generally speaking an object in your game
 * will consist of an {@link Entity}, and a set of {@link Component}s which are managed by their
 * respective {@link ComponentSystem}s. One of those components maybe a {@link ScriptComponent}
 * which allows you to write custom code to attach to your Entity.
 *
 * The Entity uniquely identifies the object and also provides a transform for position and
 * orientation which it inherits from {@link GraphNode} so can be added into the scene graph. The
 * Component and ComponentSystem provide the logic to give an Entity a specific type of behavior.
 * e.g. the ability to render a model or play a sound. Components are specific to an instance of an
 * Entity and are attached (e.g. `this.entity.model`) ComponentSystems allow access to all Entities
 * and Components and are attached to the {@link Application}.
 *
 * @augments GraphNode
 */
declare class Entity$a extends GraphNode$3 {
    /**
     * Create a new Entity.
     *
     * @param {string} [name] - The non-unique name of the entity, default is "Untitled".
     * @param {Application} [app] - The application the entity belongs to, default is the current application.
     * @example
     * var entity = new pc.Entity();
     *
     * // Add a Component to the Entity
     * entity.addComponent("camera", {
     *     fov: 45,
     *     nearClip: 1,
     *     farClip: 10000
     * });
     *
     * // Add the Entity into the scene graph
     * app.root.addChild(entity);
     *
     * // Move the entity
     * entity.translate(10, 0, 0);
     *
     * // Or translate it by setting its position directly
     * var p = entity.getPosition();
     * entity.setPosition(p.x + 10, p.y, p.z);
     *
     * // Change the entity's rotation in local space
     * var e = entity.getLocalEulerAngles();
     * entity.setLocalEulerAngles(e.x, e.y + 90, e.z);
     *
     * // Or use rotateLocal
     * entity.rotateLocal(0, 90, 0);
     */
    constructor(name?: string, app?: Application$7);
    /**
     * Gets the {@link AnimComponent} attached to this entity.
     *
     * @type {AnimComponent}
     * @readonly
     */
    readonly anim: AnimComponent;
    /**
     * Gets the {@link AnimationComponent} attached to this entity.
     *
     * @type {AnimationComponent}
     * @readonly
     */
    readonly animation: AnimationComponent;
    /**
     * Gets the {@link AudioListenerComponent} attached to this entity.
     *
     * @type {AudioListenerComponent}
     * @readonly
     */
    readonly audiolistener: AudioListenerComponent;
    /**
     * Gets the {@link ButtonComponent} attached to this entity.
     *
     * @type {ButtonComponent}
     * @readonly
     */
    readonly button: ButtonComponent;
    /**
     * Gets the {@link CameraComponent} attached to this entity.
     *
     * @type {CameraComponent}
     * @readonly
     */
    readonly camera: CameraComponent$6;
    /**
     * Gets the {@link CollisionComponent} attached to this entity.
     *
     * @type {CollisionComponent}
     * @readonly
     */
    readonly collision: CollisionComponent;
    /**
     * Gets the {@link ElementComponent} attached to this entity.
     *
     * @type {ElementComponent}
     * @readonly
     */
    readonly element: ElementComponent$1;
    /**
     * Gets the {@link LayoutChildComponent} attached to this entity.
     *
     * @type {LayoutChildComponent}
     * @readonly
     */
    readonly layoutchild: LayoutChildComponent;
    /**
     * Gets the {@link LayoutGroupComponent} attached to this entity.
     *
     * @type {LayoutGroupComponent}
     * @readonly
     */
    readonly layoutgroup: LayoutGroupComponent;
    /**
     * Gets the {@link LightComponent} attached to this entity.
     *
     * @type {LightComponent}
     * @readonly
     */
    readonly light: LightComponent$1;
    /**
     * Gets the {@link ModelComponent} attached to this entity.
     *
     * @type {ModelComponent}
     * @readonly
     */
    readonly model: ModelComponent;
    /**
     * Gets the {@link ParticleSystemComponent} attached to this entity.
     *
     * @type {ParticleSystemComponent}
     * @readonly
     */
    readonly particlesystem: ParticleSystemComponent;
    /**
     * Gets the {@link RenderComponent} attached to this entity.
     *
     * @type {RenderComponent}
     * @readonly
     */
    readonly render: RenderComponent;
    /**
     * Gets the {@link RigidBodyComponent} attached to this entity.
     *
     * @type {RigidBodyComponent}
     * @readonly
     */
    readonly rigidbody: RigidBodyComponent;
    /**
     * Gets the {@link ScreenComponent} attached to this entity.
     *
     * @type {ScreenComponent}
     * @readonly
     */
    readonly screen: ScreenComponent;
    /**
     * Gets the {@link ScriptComponent} attached to this entity.
     *
     * @type {ScriptComponent}
     * @readonly
     */
    readonly script: ScriptComponent;
    /**
     * Gets the {@link ScrollbarComponent} attached to this entity.
     *
     * @type {ScrollbarComponent}
     * @readonly
     */
    readonly scrollbar: ScrollbarComponent;
    /**
     * Gets the {@link ScrollViewComponent} attached to this entity.
     *
     * @type {ScrollViewComponent}
     * @readonly
     */
    readonly scrollview: ScrollViewComponent;
    /**
     * Gets the {@link SoundComponent} attached to this entity.
     *
     * @type {SoundComponent}
     * @readonly
     */
    readonly sound: SoundComponent;
    /**
     * Gets the {@link SpriteComponent} attached to this entity.
     *
     * @type {SpriteComponent}
     * @readonly
     */
    readonly sprite: SpriteComponent;
    _batchHandle: any;
    c: {};
    _app: Application$7;
    _guid: string;
    _destroying: boolean;
    _template: boolean;
    /**
     * Create a new component and add it to the entity. Use this to add functionality to the entity
     * like rendering a model, playing sounds and so on.
     *
     * @param {string} type - The name of the component to add. Valid strings are:
     *
     * - "anim" - see {@link AnimComponent}
     * - "animation" - see {@link AnimationComponent}
     * - "audiolistener" - see {@link AudioListenerComponent}
     * - "button" - see {@link ButtonComponent}
     * - "camera" - see {@link CameraComponent}
     * - "collision" - see {@link CollisionComponent}
     * - "element" - see {@link ElementComponent}
     * - "layoutchild" - see {@link LayoutChildComponent}
     * - "layoutgroup" - see {@link LayoutGroupComponent}
     * - "light" - see {@link LightComponent}
     * - "model" - see {@link ModelComponent}
     * - "particlesystem" - see {@link ParticleSystemComponent}
     * - "render" - see {@link RenderComponent}
     * - "rigidbody" - see {@link RigidBodyComponent}
     * - "screen" - see {@link ScreenComponent}
     * - "script" - see {@link ScriptComponent}
     * - "scrollbar" - see {@link ScrollbarComponent}
     * - "scrollview" - see {@link ScrollViewComponent}
     * - "sound" - see {@link SoundComponent}
     * - "sprite" - see {@link SpriteComponent}
     *
     * @param {object} [data] - The initialization data for the specific component type. Refer to
     * each specific component's API reference page for details on valid values for this parameter.
     * @returns {Component|null} The new Component that was attached to the entity or null if there
     * was an error.
     * @example
     * var entity = new pc.Entity();
     *
     * // Add a light component with default properties
     * entity.addComponent("light");
     *
     * // Add a camera component with some specified properties
     * entity.addComponent("camera", {
     *     fov: 45,
     *     clearColor: new pc.Color(1, 0, 0)
     * });
     */
    addComponent(type: string, data?: object): Component | null;
    /**
     * Remove a component from the Entity.
     *
     * @param {string} type - The name of the Component type.
     * @example
     * var entity = new pc.Entity();
     * entity.addComponent("light"); // add new light component
     *
     * entity.removeComponent("light"); // remove light component
     */
    removeComponent(type: string): void;
    /**
     * Search the entity and all of its descendants for the first component of specified type.
     *
     * @param {string} type - The name of the component type to retrieve.
     * @returns {Component} A component of specified type, if the entity or any of its descendants
     * has one. Returns undefined otherwise.
     * @example
     * // Get the first found light component in the hierarchy tree that starts with this entity
     * var light = entity.findComponent("light");
     */
    findComponent(type: string): Component;
    /**
     * Search the entity and all of its descendants for all components of specified type.
     *
     * @param {string} type - The name of the component type to retrieve.
     * @returns {Component[]} All components of specified type in the entity or any of its
     * descendants. Returns empty array if none found.
     * @example
     * // Get all light components in the hierarchy tree that starts with this entity
     * var lights = entity.findComponents("light");
     */
    findComponents(type: string): Component[];
    /**
     * Get the GUID value for this Entity.
     *
     * @returns {string} The GUID of the Entity.
     * @ignore
     */
    getGuid(): string;
    /**
     * Set the GUID value for this Entity. Note that it is unlikely that you should need to change
     * the GUID value of an Entity at run-time. Doing so will corrupt the graph this Entity is in.
     *
     * @param {string} guid - The GUID to assign to the Entity.
     * @ignore
     */
    setGuid(guid: string): void;
    _onHierarchyStatePostChanged(): void;
    /**
     * Find a descendant of this entity with the GUID.
     *
     * @param {string} guid - The GUID to search for.
     * @returns {Entity|null} The entity with the matching GUID or null if no entity is found.
     */
    findByGuid(guid: string): Entity$a | null;
    /**
     * Remove all components from the Entity and detach it from the Entity hierarchy. Then
     * recursively destroy all ancestor Entities.
     *
     * @example
     * var firstChild = this.entity.children[0];
     * firstChild.destroy(); // delete child, all components and remove from hierarchy
     */
    destroy(): void;
    _cloneRecursively(duplicatedIdsMap: any): Entity$a;
}

type XrManager$9 = XrManager$1;
/** @typedef {import('./xr-manager.js').XrManager} XrManager */
/**
 * Depth Sensing provides depth information which is reconstructed using the underlying AR system.
 * It provides the ability to query depth values (CPU path) or access a depth texture (GPU path).
 * Depth information can be used (not limited to) for reconstructing real world geometry, virtual
 * object placement, occlusion of virtual objects by real world geometry and more.
 *
 * ```javascript
 * // CPU path
 * var depthSensing = app.xr.depthSensing;
 * if (depthSensing.available) {
 *     // get depth in the middle of the screen, value is in meters
 *     var depth = depthSensing.getDepth(depthSensing.width / 2, depthSensing.height / 2);
 * }
 * ```
 *
 * ```javascript
 * // GPU path, attaching texture to material
 * material.diffuseMap = depthSensing.texture;
 * material.setParameter('matrix_depth_uv', depthSensing.uvMatrix.data);
 * material.setParameter('depth_raw_to_meters', depthSensing.rawValueToMeters);
 * material.update();
 *
 * // update UV transformation matrix on depth texture resize
 * depthSensing.on('resize', function () {
 *     material.setParameter('matrix_depth_uv', depthSensing.uvMatrix.data);
 *     material.setParameter('depth_raw_to_meters', depthSensing.rawValueToMeters);
 * });
 * ```
 *
 * ```javascript
 * // GLSL shader to unpack depth texture
 * varying vec2 vUv0;
 *
 * uniform sampler2D texture_depthSensingMap;
 * uniform mat4 matrix_depth_uv;
 * uniform float depth_raw_to_meters;
 *
 * void main(void) {
 *     // transform UVs using depth matrix
 *     vec2 texCoord = (matrix_depth_uv * vec4(vUv0.xy, 0.0, 1.0)).xy;
 *
 *     // get luminance alpha components from depth texture
 *     vec2 packedDepth = texture2D(texture_depthSensingMap, texCoord).ra;
 *
 *     // unpack into single value in millimeters
 *     float depth = dot(packedDepth, vec2(255.0, 256.0 * 255.0)) * depth_raw_to_meters; // m
 *
 *     // normalize: 0m to 8m distance
 *     depth = min(depth / 8.0, 1.0); // 0..1 = 0..8
 *
 *     // paint scene from black to white based on distance
 *     gl_FragColor = vec4(depth, depth, depth, 1.0);
 * }
 * ```
 *
 * @augments EventHandler
 */
declare class XrDepthSensing extends EventHandler$1 {
    /**
     * Create a new XrDepthSensing instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager$9);
    _manager: XrManager$1;
    _available: boolean;
    _depthInfoCpu: any;
    _depthInfoGpu: any;
    _usage: any;
    _dataFormat: any;
    _matrixDirty: boolean;
    _matrix: Mat4$5;
    _emptyBuffer: Uint8Array;
    _depthBuffer: Uint8Array;
    _texture: Texture$8;
    /**
     * @event
     * @name XrDepthSensing#available
     * @description Fired when depth sensing data becomes available.
     */
    /**
     * @event
     * @name XrDepthSensing#unavailable
     * @description Fired when depth sensing data becomes unavailable.
     */
    /**
     * @event
     * @name XrDepthSensing#resize
     * @description Fired when the depth sensing texture been resized. The {@link XrDepthSensing#uvMatrix} needs to be updated for relevant shaders.
     * @param {number} width - The new width of the depth texture in pixels.
     * @param {number} height - The new height of the depth texture in pixels.
     * @example
     * depthSensing.on('resize', function () {
     *     material.setParameter('matrix_depth_uv', depthSensing.uvMatrix);
     * });
     */
    _onSessionStart(): void;
    _onSessionEnd(): void;
    _updateTexture(): void;
    update(frame: any, view: any): void;
    /**
     * Get depth value from depth information in meters. UV is in range of 0..1, with origin in
     * top-left corner of a texture.
     *
     * @param {number} u - U coordinate of pixel in depth texture, which is in range from 0.0 to
     * 1.0 (left to right).
     * @param {number} v - V coordinate of pixel in depth texture, which is in range from 0.0 to
     * 1.0 (top to bottom).
     * @returns {number|null} Depth in meters or null if depth information is currently not
     * available.
     * @example
     * var depth = app.xr.depthSensing.getDepth(u, v);
     * if (depth !== null) {
     *     // depth in meters
     * }
     */
    getDepth(u: number, v: number): number | null;
    /**
     * True if Depth Sensing is supported.
     *
     * @type {boolean}
     */
    get supported(): boolean;
    /**
     * True if depth sensing information is available.
     *
     * @type {boolean}
     * @example
     * if (app.xr.depthSensing.available) {
     *     var depth = app.xr.depthSensing.getDepth(x, y);
     * }
     */
    get available(): boolean;
    get usage(): any;
    get dataFormat(): any;
    /**
     * Width of depth texture or 0 if not available.
     *
     * @type {number}
     */
    get width(): number;
    /**
     * Height of depth texture or 0 if not available.
     *
     * @type {number}
     */
    get height(): number;
    /**
     * Texture that contains packed depth information. The format of this texture is
     * {@link PIXELFORMAT_L8_A8}. It is UV transformed based on the underlying AR system which can
     * be normalized using {@link XrDepthSensing#uvMatrix}.
     *
     * @type {Texture}
     * @example
     * material.diffuseMap = depthSensing.texture;
     * @example
     * // GLSL shader to unpack depth texture
     * varying vec2 vUv0;
     *
     * uniform sampler2D texture_depthSensingMap;
     * uniform mat4 matrix_depth_uv;
     * uniform float depth_raw_to_meters;
     *
     * void main(void) {
     *     // transform UVs using depth matrix
     *     vec2 texCoord = (matrix_depth_uv * vec4(vUv0.xy, 0.0, 1.0)).xy;
     *
     *     // get luminance alpha components from depth texture
     *     vec2 packedDepth = texture2D(texture_depthSensingMap, texCoord).ra;
     *
     *     // unpack into single value in millimeters
     *     float depth = dot(packedDepth, vec2(255.0, 256.0 * 255.0)) * depth_raw_to_meters; // m
     *
     *     // normalize: 0m to 8m distance
     *     depth = min(depth / 8.0, 1.0); // 0..1 = 0m..8m
     *
     *     // paint scene from black to white based on distance
     *     gl_FragColor = vec4(depth, depth, depth, 1.0);
     * }
     */
    get texture(): Texture$8;
    /**
     * 4x4 matrix that should be used to transform depth texture UVs to normalized UVs in a shader.
     * It is updated when the depth texture is resized. Refer to {@link XrDepthSensing#resize}.
     *
     * @type {Mat4}
     * @example
     * material.setParameter('matrix_depth_uv', depthSensing.uvMatrix.data);
     */
    get uvMatrix(): Mat4$5;
    /**
     * Multiply this coefficient number by raw depth value to get depth in meters.
     *
     * @type {number}
     * @example
     * material.setParameter('depth_raw_to_meters', depthSensing.rawValueToMeters);
     */
    get rawValueToMeters(): number;
}

type XrManager$8 = XrManager$1;
/** @typedef {import('./xr-manager.js').XrManager} XrManager */
/**
 * DOM Overlay provides the ability to use DOM elements as an overlay in a WebXR AR session. It
 * requires that the root DOM element is provided for session start. That way, input source select
 * events are first tested against DOM Elements and then propagated down to the XR Session. If this
 * propagation is not desirable, use the `beforexrselect` event on a DOM element and the
 * `preventDefault` function to stop propagation.
 *
 * ```javascript```
 * app.xr.domOverlay.root = element;
 * app.xr.start(camera, pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR);
 * ```
 *
 * ```javascript
 * // Disable input source firing `select` event when some descendant element of DOM overlay root
 * // is touched/clicked. This is useful when the user interacts with UI elements and there should
 * // not be `select` events behind UI.
 * someElement.addEventListener('beforexrselect', function (evt) {
 *     evt.preventDefault();
 * });
 * ```
 */
declare class XrDomOverlay {
    /**
     * DOM Overlay provides the ability to use DOM elements as an overlay in a WebXR AR session. It
     * requires that the root DOM element is provided for session start. That way, input source
     * select events are first tested against DOM Elements and then propagated down to the XR
     * Session. If this propagation is not desirable, use the `beforexrselect` event on a DOM
     * element and the `preventDefault` function to stop propagation.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager$8);
    _manager: XrManager$1;
    _supported: boolean;
    _root: any;
    /**
     * True if DOM Overlay is supported.
     *
     * @type {boolean}
     */
    get supported(): boolean;
    /**
     * True if DOM Overlay is available. It can only be available if it is supported, during a
     * valid WebXR session and if a valid root element is provided.
     *
     * @type {boolean}
     */
    get available(): boolean;
    /**
     * State of the DOM Overlay, which defines how the root DOM element is rendered. Possible
     * options:
     *
     * - screen: Screen - indicates that the DOM element is covering whole physical screen,
     * matching XR viewports.
     * - floating: Floating - indicates that the underlying platform renders the DOM element as
     * floating in space, which can move during the WebXR session or allow the application to move
     * the element.
     * - head-locked: Head Locked - indicates that the DOM element follows the user's head movement
     * consistently, appearing similar to a helmet heads-up display.
     *
     * @type {string|null}
     */
    get state(): string;
    /**
     * The DOM element to be used as the root for DOM Overlay. Can be changed only outside of an
     * active WebXR session.
     *
     * @type {object|null}
     * @example
     * app.xr.domOverlay.root = element;
     * app.xr.start(camera, pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR);
     */
    set root(arg: any);
    get root(): any;
}

type XrManager$7 = XrManager$1;
/**
 * Represents XR hit test source, which provides access to hit results of real world geometry from
 * AR session.
 *
 * @augments EventHandler
 */
declare class XrHitTestSource extends EventHandler$1 {
    /**
     * Create a new XrHitTestSource instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @param {object} xrHitTestSource - XRHitTestSource object that is created by WebXR API.
     * @param {boolean} transient - True if XRHitTestSource created for input source profile.
     * @hideconstructor
     */
    constructor(manager: XrManager$7, xrHitTestSource: object, transient: boolean);
    manager: XrManager$1;
    _xrHitTestSource: any;
    _transient: boolean;
    /**
     * @event
     * @name XrHitTestSource#remove
     * @description Fired when {@link XrHitTestSource} is removed.
     * @example
     * hitTestSource.once('remove', function () {
     *     // hit test source has been removed
     * });
     */
    /**
     * @event
     * @name XrHitTestSource#result
     * @description Fired when hit test source receives new results. It provides transform information that tries to match real world picked geometry.
     * @param {Vec3} position - Position of hit test.
     * @param {Quat} rotation - Rotation of hit test.
     * @param {XrInputSource|null} inputSource - If is transient hit test source, then it will provide related input source.
     * @example
     * hitTestSource.on('result', function (position, rotation, inputSource) {
     *     target.setPosition(position);
     *     target.setRotation(rotation);
     * });
     */
    /**
     * Stop and remove hit test source.
     */
    remove(): void;
    onStop(): void;
    update(frame: any): void;
    updateHitResults(results: any, inputSource: any): void;
}

type XrManager$6 = XrManager$1;
type Ray = Ray$4;
/**
 * Callback used by {@link XrHitTeststart } and {@link XrHitTeststartForInputSource }.
 */
type xrHitTestStartCallback$1 = (err: Error | null, hitTestSource: XrHitTestSource | null) => any;
/** @typedef {import('./xr-manager.js').XrManager} XrManager */
/** @typedef {import('../shape/ray.js').Ray} Ray */
/**
 * Callback used by {@link XrHitTest#start} and {@link XrHitTest#startForInputSource}.
 *
 * @callback xrHitTestStartCallback
 * @param {Error|null} err - The Error object if failed to create hit test source or null.
 * @param {XrHitTestSource|null} hitTestSource - Object that provides access to hit results against
 * real world geometry.
 */
/**
 * Hit Test provides ability to get position and rotation of ray intersecting point with
 * representation of real world geometry by underlying AR system.
 *
 * @augments EventHandler
 */
declare class XrHitTest extends EventHandler$1 {
    /**
     * Create a new XrHitTest instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager$6);
    manager: XrManager$1;
    _supported: boolean;
    _session: any;
    /**
     * List of active {@link XrHitTestSource}.
     *
     * @type {XrHitTestSource[]}
     */
    sources: XrHitTestSource[];
    /**
     * @event
     * @name XrHitTest#add
     * @description Fired when new {@link XrHitTestSource} is added to the list.
     * @param {XrHitTestSource} hitTestSource - Hit test source that has been added.
     * @example
     * app.xr.hitTest.on('add', function (hitTestSource) {
     *     // new hit test source is added
     * });
     */
    /**
     * @event
     * @name XrHitTest#remove
     * @description Fired when {@link XrHitTestSource} is removed to the list.
     * @param {XrHitTestSource} hitTestSource - Hit test source that has been removed.
     * @example
     * app.xr.hitTest.on('remove', function (hitTestSource) {
     *     // hit test source is removed
     * });
     */
    /**
     * @event
     * @name XrHitTest#result
     * @description Fired when hit test source receives new results. It provides transform information that tries to match real world picked geometry.
     * @param {XrHitTestSource} hitTestSource - Hit test source that produced the hit result.
     * @param {Vec3} position - Position of hit test.
     * @param {Quat} rotation - Rotation of hit test.
     * @param {XrInputSource|null} inputSource - If is transient hit test source, then it will provide related input source.
     * @example
     * app.xr.hitTest.on('result', function (hitTestSource, position, rotation, inputSource) {
     *     target.setPosition(position);
     *     target.setRotation(rotation);
     * });
     */
    /**
     * @event
     * @name XrHitTest#error
     * @param {Error} error - Error object related to failure of creating hit test source.
     * @description Fired when failed create hit test source.
     */
    _onSessionStart(): void;
    _onSessionEnd(): void;
    isAvailable(callback: any, fireError: any): boolean;
    /**
     * Attempts to start hit test with provided reference space.
     *
     * @param {object} [options] - Optional object for passing arguments.
     * @param {string} [options.spaceType] - Reference space type. Defaults to
     * {@link XRSPACE_VIEWER}. Can be one of the following:
     *
     * - {@link XRSPACE_VIEWER}: Viewer - hit test will be facing relative to viewers space.
     * - {@link XRSPACE_LOCAL}: Local - represents a tracking space with a native origin near the
     * viewer at the time of creation.
     * - {@link XRSPACE_LOCALFLOOR}: Local Floor - represents a tracking space with a native origin
     * at the floor in a safe position for the user to stand. The y axis equals 0 at floor level.
     * Floor level value might be estimated by the underlying platform.
     * - {@link XRSPACE_BOUNDEDFLOOR}: Bounded Floor - represents a tracking space with its native
     * origin at the floor, where the user is expected to move within a pre-established boundary.
     * - {@link XRSPACE_UNBOUNDED}: Unbounded - represents a tracking space where the user is
     * expected to move freely around their environment, potentially long distances from their
     * starting point.
     *
     * @param {string} [options.profile] - if hit test source meant to match input source instead
     * of reference space, then name of profile of the {@link XrInputSource} should be provided.
     * @param {string[]} [options.entityTypes] - Optional list of underlying entity types against
     * which hit tests will be performed. Defaults to [ {@link XRTRACKABLE_PLANE} ]. Can be any
     * combination of the following:
     *
     * - {@link XRTRACKABLE_POINT}: Point - indicates that the hit test results will be computed
     * based on the feature points detected by the underlying Augmented Reality system.
     * - {@link XRTRACKABLE_PLANE}: Plane - indicates that the hit test results will be computed
     * based on the planes detected by the underlying Augmented Reality system.
     * - {@link XRTRACKABLE_MESH}: Mesh - indicates that the hit test results will be computed
     * based on the meshes detected by the underlying Augmented Reality system.
     *
     * @param {Ray} [options.offsetRay] - Optional ray by which hit test ray can be offset.
     * @param {xrHitTestStartCallback} [options.callback] - Optional callback function called once
     * hit test source is created or failed.
     * @example
     * app.xr.hitTest.start({
     *     spaceType: pc.XRSPACE_VIEWER,
     *     callback: function (err, hitTestSource) {
     *         if (err) return;
     *         hitTestSource.on('result', function (position, rotation) {
     *             // position and rotation of hit test result
     *             // based on Ray facing forward from the Viewer reference space
     *         });
     *     }
     * });
     * @example
     * var ray = new pc.Ray(new pc.Vec3(0, 0, 0), new pc.Vec3(0, -1, 0));
     * app.xr.hitTest.start({
     *     spaceType: pc.XRSPACE_LOCAL,
     *     offsetRay: ray,
     *     callback: function (err, hitTestSource) {
     *         // hit test source that will sample real world geometry straight down
     *         // from the position where AR session started
     *     }
     * });
     * @example
     * app.xr.hitTest.start({
     *     profile: 'generic-touchscreen',
     *     callback: function (err, hitTestSource) {
     *         if (err) return;
     *         hitTestSource.on('result', function (position, rotation, inputSource) {
     *             // position and rotation of hit test result
     *             // that will be created from touch on mobile devices
     *         });
     *     }
     * });
     */
    start(options?: {
        spaceType?: string;
        profile?: string;
        entityTypes?: string[];
        offsetRay?: Ray;
        callback?: xrHitTestStartCallback$1;
    }): void;
    _onHitTestSource(xrHitTestSource: any, transient: any, callback: any): void;
    update(frame: any): void;
    /**
     * True if AR Hit Test is supported.
     *
     * @type {boolean}
     */
    get supported(): boolean;
}

/**
 * The tracked image interface that is created by the Image Tracking system and is provided as a
 * list from {@link XrImageTracking#images}. It contains information about the tracking state as
 * well as the position and rotation of the tracked image.
 *
 * @augments EventHandler
 */
declare class XrTrackedImage extends EventHandler$1 {
    /**
     * The tracked image interface that is created by the Image Tracking system and is provided as
     * a list from {@link XrImageTracking#images}. It contains information about the tracking state
     * as well as the position and rotation of the tracked image.
     *
     * @param {HTMLCanvasElement|HTMLImageElement|SVGImageElement|HTMLVideoElement|Blob|ImageData|ImageBitmap} image - Image
     * that is matching the real world image as closely as possible. Resolution of images should be
     * at least 300x300. High resolution does NOT improve tracking performance. Color of image is
     * irrelevant, so grayscale images can be used. Images with too many geometric features or
     * repeating patterns will reduce tracking stability.
     * @param {number} width - Width (in meters) of image in real world. Providing this value as
     * close to the real value will improve tracking quality.
     * @hideconstructor
     */
    constructor(image: HTMLCanvasElement | HTMLImageElement | SVGImageElement | HTMLVideoElement | Blob | ImageData | ImageBitmap, width: number);
    _image: Blob | HTMLImageElement | SVGImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap | ImageData;
    _bitmap: ImageBitmap;
    _width: number;
    _measuredWidth: number;
    _trackable: boolean;
    _tracking: boolean;
    _emulated: boolean;
    _pose: any;
    _position: Vec3$1;
    _rotation: Quat$1;
    /**
     * Image that is used for tracking.
     *
     * @type {HTMLCanvasElement|HTMLImageElement|SVGImageElement|HTMLVideoElement|Blob|ImageData|ImageBitmap}
     */
    get image(): Blob | HTMLImageElement | SVGImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap | ImageData;
    /**
     * Width that is provided to assist tracking performance. This property can be updated only
     * when the AR session is not running.
     *
     * @type {number}
     */
    set width(arg: number);
    get width(): number;
    /**
     * True if image is trackable. A too small resolution or invalid images can be untrackable by
     * the underlying AR system.
     *
     * @type {boolean}
     */
    get trackable(): boolean;
    /**
     * True if image is in tracking state and being tracked in real world by the underlying AR
     * system.
     *
     * @type {boolean}
     */
    get tracking(): boolean;
    /**
     * True if image was recently tracked but currently is not actively tracked due to inability of
     * identifying the image by the underlying AR system. Position and rotation will be based on
     * the previously known transformation assuming the tracked image has not moved.
     *
     * @type {boolean}
     */
    get emulated(): boolean;
    /**
     * @event
     * @name XrTrackedImage#tracked
     * @description Fired when image becomes actively tracked.
     */
    /**
     * @event
     * @name XrTrackedImage#untracked
     * @description Fired when image is no more actively tracked.
     */
    prepare(): Promise<{
        image: ImageBitmap;
        widthInMeters: number;
    }> | {
        image: ImageBitmap;
        widthInMeters: number;
    };
    destroy(): void;
    /**
     * Get the position of the tracked image. The position is the most recent one based on the
     * tracked image state.
     *
     * @returns {Vec3} Position in world space.
     * @example
     * // update entity position to match tracked image position
     * entity.setPosition(trackedImage.getPosition());
     */
    getPosition(): Vec3$1;
    /**
     * Get the rotation of the tracked image. The rotation is the most recent based on the tracked
     * image state.
     *
     * @returns {Quat} Rotation in world space.
     * @example
     * // update entity rotation to match tracked image rotation
     * entity.setRotation(trackedImage.getRotation());
     */
    getRotation(): Quat$1;
}

type XrManager$5 = XrManager$1;
/** @typedef {import('./xr-manager.js').XrManager} XrManager */
/**
 * Image Tracking provides the ability to track real world images by provided image samples and
 * their estimated sizes.
 *
 * @augments EventHandler
 */
declare class XrImageTracking extends EventHandler$1 {
    /**
     * Image Tracking provides the ability to track real world images by provided image samples and
     * their estimate sizes.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager$5);
    _manager: XrManager$1;
    _supported: boolean;
    _available: boolean;
    _images: any[];
    /**
     * @event
     * @name XrImageTracking#error
     * @param {Error} error - Error object related to a failure of image tracking.
     * @description Fired when the XR session is started, but image tracking failed to process the provided images.
     */
    /**
     * Add an image for image tracking. A width can also be provided to help the underlying system
     * estimate the appropriate transformation. Modifying the tracked images list is only possible
     * before an AR session is started.
     *
     * @param {HTMLCanvasElement|HTMLImageElement|SVGImageElement|HTMLVideoElement|Blob|ImageData|ImageBitmap} image - Image that is matching real world image as close as possible. Resolution of images should be at least 300x300. High resolution does NOT improve tracking performance. Color of image is irrelevant, so greyscale images can be used. Images with too many geometric features or repeating patterns will reduce tracking stability.
     * @param {number} width - Width (in meters) of image in the real world. Providing this value
     * as close to the real value will improve tracking quality.
     * @returns {XrTrackedImage|null} Tracked image object that will contain tracking information.
     * Returns null if image tracking is not supported or if the XR manager is not active.
     * @example
     * // image with width of 20cm (0.2m)
     * app.xr.imageTracking.add(bookCoverImg, 0.2);
     */
    add(image: HTMLCanvasElement | HTMLImageElement | SVGImageElement | HTMLVideoElement | Blob | ImageData | ImageBitmap, width: number): XrTrackedImage | null;
    /**
     * Remove an image from image tracking.
     *
     * @param {XrTrackedImage} trackedImage - Tracked image to be removed. Modifying the tracked
     * images list is only possible before an AR session is started.
     */
    remove(trackedImage: XrTrackedImage): void;
    _onSessionStart(): void;
    _onSessionEnd(): void;
    prepareImages(callback: any): void;
    update(frame: any): void;
    /**
     * True if Image Tracking is supported.
     *
     * @type {boolean}
     */
    get supported(): boolean;
    /**
     * True if Image Tracking is available. This property will be false if no images were provided
     * for the AR session or there was an error processing the provided images.
     *
     * @type {boolean}
     */
    get available(): boolean;
    /**
     * List of {@link XrTrackedImage} that contain tracking information.
     *
     * @type {XrTrackedImage[]}
     */
    get images(): XrTrackedImage[];
}

type XrPlaneDetection$1 = XrPlaneDetection;
/**
 * Detected Plane instance that provides position, rotation and polygon points. Plane is a subject
 * to change during its lifetime.
 */
declare class XrPlane extends EventHandler$1 {
    /**
     * Create a new XrPlane instance.
     *
     * @param {XrPlaneDetection} planeDetection - Plane detection system.
     * @param {object} xrPlane - XRPlane that is instantiated by WebXR system.
     * @hideconstructor
     */
    constructor(planeDetection: XrPlaneDetection$1, xrPlane: object);
    _id: number;
    _planeDetection: XrPlaneDetection;
    _manager: XrManager$1;
    _xrPlane: any;
    _lastChangedTime: any;
    _orientation: any;
    _position: Vec3$1;
    _rotation: Quat$1;
    /**
     * @event
     * @name XrPlane#remove
     * @description Fired when {@link XrPlane} is removed.
     * @example
     * plane.once('remove', function () {
     *     // plane is not available anymore
     * });
     */
    /**
     * @event
     * @name XrPlane#change
     * @description Fired when {@link XrPlane} attributes such as: orientation and/or points have been changed. Position and rotation can change at any time without triggering a `change` event.
     * @example
     * plane.on('change', function () {
     *     // plane has been changed
     * });
     */
    destroy(): void;
    update(frame: any): void;
    /**
     * Get the world space position of a plane.
     *
     * @returns {Vec3} The world space position of a plane.
     */
    getPosition(): Vec3$1;
    /**
     * Get the world space rotation of a plane.
     *
     * @returns {Quat} The world space rotation of a plane.
     */
    getRotation(): Quat$1;
    /**
     * Unique identifier of a plane.
     *
     * @type {number}
     */
    get id(): number;
    /**
     * Plane's specific orientation (horizontal or vertical) or null if orientation is anything else.
     *
     * @type {string|null}
     */
    get orientation(): string;
    /**
     * Array of DOMPointReadOnly objects. DOMPointReadOnly is an object with `x y z` properties
     * that defines a local point of a plane's polygon.
     *
     * @type {object[]}
     * @example
     * // prepare reusable objects
     * var vecA = new pc.Vec3();
     * var vecB = new pc.Vec3();
     * var color = new pc.Color(1, 1, 1);
     *
     * // update Mat4 to plane position and rotation
     * transform.setTRS(plane.getPosition(), plane.getRotation(), pc.Vec3.ONE);
     *
     * // draw lines between points
     * for (var i = 0; i < plane.points.length; i++) {
     *     vecA.copy(plane.points[i]);
     *     vecB.copy(plane.points[(i + 1) % plane.points.length]);
     *
     *     // transform from planes local to world coords
     *     transform.transformPoint(vecA, vecA);
     *     transform.transformPoint(vecB, vecB);
     *
     *     // render line
     *     app.drawLine(vecA, vecB, color);
     * }
     */
    get points(): any[];
}

type XrManager$4 = XrManager$1;
/** @typedef {import('./xr-manager.js').XrManager} XrManager */
/**
 * Plane Detection provides the ability to detect real world surfaces based on estimations of the
 * underlying AR system.
 *
 * ```javascript
 * // start session with plane detection enabled
 * app.xr.start(camera, pc.XRTYPE_VR, pc.XRSPACE_LOCALFLOOR, {
 *     planeDetection: true
 * });
 * ```
 *
 * ```javascript
 * app.xr.planeDetection.on('add', function (plane) {
 *     // new plane been added
 * });
 * ```
 */
declare class XrPlaneDetection extends EventHandler$1 {
    /**
     * Create a new XrPlaneDetection instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager$4);
    _manager: XrManager$1;
    _supported: boolean;
    _available: boolean;
    _planesIndex: Map<any, any>;
    _planes: any[];
    /**
     * @event
     * @name XrPlaneDetection#available
     * @description Fired when plane detection becomes available.
     */
    /**
     * @event
     * @name XrPlaneDetection#unavailable
     * @description Fired when plane detection becomes unavailable.
     */
    /**
     * @event
     * @name XrPlaneDetection#add
     * @description Fired when new {@link XrPlane} is added to the list.
     * @param {XrPlane} plane - Plane that has been added.
     * @example
     * app.xr.planeDetection.on('add', function (plane) {
     *     // new plane is added
     * });
     */
    /**
     * @event
     * @name XrPlaneDetection#remove
     * @description Fired when a {@link XrPlane} is removed from the list.
     * @param {XrPlane} plane - Plane that has been removed.
     * @example
     * app.xr.planeDetection.on('remove', function (plane) {
     *     // new plane is removed
     * });
     */
    _onSessionEnd(): void;
    update(frame: any): void;
    /**
     * True if Plane Detection is supported.
     *
     * @type {boolean}
     */
    get supported(): boolean;
    /**
     * True if Plane Detection is available. This property can be set to true only during a running
     * session.
     *
     * @type {boolean}
     */
    get available(): boolean;
    /**
     * Array of {@link XrPlane} instances that contain individual plane information, or null if
     * plane detection is not available.
     *
     * @type {XrPlane[]|null}
     */
    get planes(): XrPlane[];
}

type XrManager$3 = XrManager$1;
/** @typedef {import('./xr-manager.js').XrManager} XrManager */
/**
 * Provides access to input sources for WebXR.
 *
 * @augments EventHandler
 */
declare class XrInput extends EventHandler$1 {
    /**
     * Create a new XrInput instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager$3);
    manager: XrManager$1;
    _session: any;
    _inputSources: any[];
    _onInputSourcesChangeEvt: (evt: any) => void;
    /**
     * @event
     * @name XrInput#add
     * @description Fired when new {@link XrInputSource} is added to the list.
     * @param {XrInputSource} inputSource - Input source that has been added.
     * @example
     * app.xr.input.on('add', function (inputSource) {
     *     // new input source is added
     * });
     */
    /**
     * @event
     * @name XrInput#remove
     * @description Fired when {@link XrInputSource} is removed to the list.
     * @param {XrInputSource} inputSource - Input source that has been removed.
     * @example
     * app.xr.input.on('remove', function (inputSource) {
     *     // input source is removed
     * });
     */
    /**
     * @event
     * @name XrInput#select
     * @description Fired when {@link XrInputSource} has triggered primary action. This could be pressing a trigger button, or touching a screen.
     * @param {XrInputSource} inputSource - Input source that triggered select event.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     * @example
     * var ray = new pc.Ray();
     * app.xr.input.on('select', function (inputSource, evt) {
     *     ray.set(inputSource.getOrigin(), inputSource.getDirection());
     *     if (obj.intersectsRay(ray)) {
     *         // selected an object with input source
     *     }
     * });
     */
    /**
     * @event
     * @name XrInput#selectstart
     * @description Fired when {@link XrInputSource} has started to trigger primary action.
     * @param {XrInputSource} inputSource - Input source that triggered selectstart event.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * @event
     * @name XrInput#selectend
     * @description Fired when {@link XrInputSource} has ended triggerring primary action.
     * @param {XrInputSource} inputSource - Input source that triggered selectend event.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * @event
     * @name XrInput#squeeze
     * @description Fired when {@link XrInputSource} has triggered squeeze action. This is associated with "grabbing" action on the controllers.
     * @param {XrInputSource} inputSource - Input source that triggered squeeze event.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * @event
     * @name XrInput#squeezestart
     * @description Fired when {@link XrInputSource} has started to trigger sqeeze action.
     * @param {XrInputSource} inputSource - Input source that triggered squeezestart event.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     * @example
     * app.xr.input.on('squeezestart', function (inputSource, evt) {
     *     if (obj.containsPoint(inputSource.getPosition())) {
     *         // grabbed an object
     *     }
     * });
     */
    /**
     * @event
     * @name XrInput#squeezeend
     * @description Fired when {@link XrInputSource} has ended triggerring sqeeze action.
     * @param {XrInputSource} inputSource - Input source that triggered squeezeend event.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    _onSessionStart(): void;
    _onSessionEnd(): void;
    _onInputSourcesChange(evt: any): void;
    _getByInputSource(xrInputSource: any): any;
    _addInputSource(xrInputSource: any): void;
    _removeInputSource(xrInputSource: any): void;
    update(frame: any): void;
    /**
     * List of active {@link XrInputSource} instances.
     *
     * @type {XrInputSource[]}
     */
    get inputSources(): XrInputSource$1[];
}

type XrManager$2 = XrManager$1;
/**
 * Light Estimation provides illumination data from the real world, which is estimated by the
 * underlying AR system. It provides a reflection Cube Map, that represents the reflection
 * estimation from the viewer position. A more simplified approximation of light is provided by L2
 * Spherical Harmonics data. And the most simple level of light estimation is the most prominent
 * directional light, its rotation, intensity and color.
 *
 * @augments EventHandler
 */
declare class XrLightEstimation extends EventHandler$1 {
    /**
     * Create a new XrLightEstimation instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager$2);
    _manager: XrManager$1;
    _supported: boolean;
    _available: boolean;
    _lightProbeRequested: boolean;
    _lightProbe: any;
    _intensity: number;
    _rotation: Quat$1;
    _color: Color$4;
    _sphericalHarmonics: Float32Array;
    /**
     * @event
     * @name XrLightEstimation#available
     * @description Fired when light estimation data becomes available.
     */
    /**
     * @event
     * @name XrLightEstimation#error
     * @param {Error} error - Error object related to failure of light estimation start.
     * @description Fired when light estimation has failed to start.
     * @example
     * app.xr.lightEstimation.on('error', function (ex) {
     *     // has failed to start
     * });
     */
    _onSessionStart(): void;
    _onSessionEnd(): void;
    /**
     * Start estimation of illumination data. Availability of such data will come later and an
     * `available` event will be fired. If it failed to start estimation, an `error` event will be
     * fired.
     *
     * @example
     * app.xr.on('start', function () {
     *     if (app.xr.lightEstimation.supported) {
     *         app.xr.lightEstimation.start();
     *     }
     * });
     */
    start(): void;
    /**
     * End estimation of illumination data.
     */
    end(): void;
    update(frame: any): void;
    /**
     * True if Light Estimation is supported. This information is available only during an active AR
     * session.
     *
     * @type {boolean}
     */
    get supported(): boolean;
    /**
     * True if estimated light information is available.
     *
     * @type {boolean}
     * @example
     * if (app.xr.lightEstimation.available) {
     *     entity.light.intensity = app.xr.lightEstimation.intensity;
     * }
     */
    get available(): boolean;
    /**
     * Intensity of what is estimated to be the most prominent directional light. Or null if data
     * is not available.
     *
     * @type {number|null}
     */
    get intensity(): number;
    /**
     * Color of what is estimated to be the most prominent directional light. Or null if data is
     * not available.
     *
     * @type {Color|null}
     */
    get color(): Color$4;
    /**
     * Rotation of what is estimated to be the most prominent directional light. Or null if data is
     * not available.
     *
     * @type {Quat|null}
     */
    get rotation(): Quat$1;
    get sphericalHarmonics(): Float32Array;
}

type CameraComponent$5 = CameraComponent$2;
type Application$d = Application$7;
/**
 * Callback used by {@link XrManagerendXr } and {@link XrManagerstartXr }.
 */
type xrErrorCallback$1 = (err: Error | null) => any;
/** @typedef {import('../framework/components/camera/component.js').CameraComponent} CameraComponent */
/** @typedef {import('../framework/application.js').Application} Application */
/** @typedef {import('../framework/entity.js').Entity} Entity */
/**
 * Callback used by {@link XrManager#endXr} and {@link XrManager#startXr}.
 *
 * @callback xrErrorCallback
 * @param {Error|null} err - The Error object or null if operation was successful.
 */
/**
 * Manage and update XR session and its states.
 *
 * @property {XrInput} input Provides access to Input Sources.
 * @property {XrHitTest} hitTest Provides ability to hit test representation of real world geometry
 * of underlying AR system.
 * @augments EventHandler
 */
declare class XrManager$1 extends EventHandler$1 {
    /**
     * Create a new XrManager instance.
     *
     * @param {Application} app - The main application.
     * @hideconstructor
     */
    constructor(app: Application$d);
    app: Application$7;
    _supported: boolean;
    _available: {};
    _type: string;
    _spaceType: string;
    _session: any;
    _baseLayer: any;
    _referenceSpace: any;
    depthSensing: XrDepthSensing;
    domOverlay: XrDomOverlay;
    hitTest: XrHitTest;
    imageTracking: XrImageTracking;
    planeDetection: XrPlaneDetection;
    input: XrInput;
    lightEstimation: XrLightEstimation;
    _camera: CameraComponent$2;
    views: any[];
    viewsPool: any[];
    _localPosition: Vec3$1;
    _localRotation: Quat$1;
    _depthNear: number;
    _depthFar: number;
    _width: number;
    _height: number;
    /**
     * @event
     * @name XrManager#available
     * @description Fired when availability of specific XR type is changed.
     * @param {string} type - The session type that has changed availability.
     * @param {boolean} available - True if specified session type is now available.
     * @example
     * app.xr.on('available', function (type, available) {
     *     console.log('"' + type + '" XR session is now ' + (available ? 'available' : 'unavailable'));
     * });
     */
    /**
     * @event
     * @name XrManager#available:[type]
     * @description Fired when availability of specific XR type is changed.
     * @param {boolean} available - True if specified session type is now available.
     * @example
     * app.xr.on('available:' + pc.XRTYPE_VR, function (available) {
     *     console.log('Immersive VR session is now ' + (available ? 'available' : 'unavailable'));
     * });
     */
    /**
     * @event
     * @name XrManager#start
     * @description Fired when XR session is started.
     * @example
     * app.xr.on('start', function () {
     *     // XR session has started
     * });
     */
    /**
     * @event
     * @name XrManager#end
     * @description Fired when XR session is ended.
     * @example
     * app.xr.on('end', function () {
     *     // XR session has ended
     * });
     */
    /**
     * @event
     * @name XrManager#update
     * @param {object} frame - [XRFrame](https://developer.mozilla.org/en-US/docs/Web/API/XRFrame) object that can be used for interfacing directly with WebXR APIs.
     * @description Fired when XR session is updated, providing relevant XRFrame object.
     * @example
     * app.xr.on('update', function (frame) {
     *
     * });
     */
    /**
     * @event
     * @name XrManager#error
     * @param {Error} error - Error object related to failure of session start or check of session type support.
     * @description Fired when XR session is failed to start or failed to check for session type support.
     * @example
     * app.xr.on('error', function (ex) {
     *     // XR session has failed to start, or failed to check for session type support
     * });
     */
    /**
     * Attempts to start XR session for provided {@link CameraComponent} and optionally fires
     * callback when session is created or failed to create. Integrated XR APIs need to be enabled
     * by providing relevant options.
     *
     * @param {CameraComponent} camera - It will be used to render XR session and manipulated based
     * on pose tracking.
     * @param {string} type - Session type. Can be one of the following:
     *
     * - {@link XRTYPE_INLINE}: Inline - always available type of session. It has limited features
     * availability and is rendered into HTML element.
     * - {@link XRTYPE_VR}: Immersive VR - session that provides exclusive access to VR device with
     * best available tracking features.
     * - {@link XRTYPE_AR}: Immersive AR - session that provides exclusive access to VR/AR device
     * that is intended to be blended with real-world environment.
     *
     * @param {string} spaceType - Reference space type. Can be one of the following:
     *
     * - {@link XRSPACE_VIEWER}: Viewer - always supported space with some basic tracking
     * capabilities.
     * - {@link XRSPACE_LOCAL}: Local - represents a tracking space with a native origin near the
     * viewer at the time of creation. It is meant for seated or basic local XR sessions.
     * - {@link XRSPACE_LOCALFLOOR}: Local Floor - represents a tracking space with a native origin
     * at the floor in a safe position for the user to stand. The y axis equals 0 at floor level.
     * Floor level value might be estimated by the underlying platform. It is meant for seated or
     * basic local XR sessions.
     * - {@link XRSPACE_BOUNDEDFLOOR}: Bounded Floor - represents a tracking space with its native
     * origin at the floor, where the user is expected to move within a pre-established boundary.
     * - {@link XRSPACE_UNBOUNDED}: Unbounded - represents a tracking space where the user is
     * expected to move freely around their environment, potentially long distances from their
     * starting point.
     *
     * @param {object} [options] - Object with additional options for XR session initialization.
     * @param {string[]} [options.optionalFeatures] - Optional features for XRSession start. It is
     * used for getting access to additional WebXR spec extensions.
     * @param {boolean} [options.imageTracking] - Set to true to attempt to enable
     * {@link XrImageTracking}.
     * @param {boolean} [options.planeDetection] - Set to true to attempt to enable
     * {@link XrPlaneDetection}.
     * @param {xrErrorCallback} [options.callback] - Optional callback function called once session
     * is started. The callback has one argument Error - it is null if successfully started XR
     * session.
     * @param {object} [options.depthSensing] - Optional object with depth sensing parameters to
     * attempt to enable {@link XrDepthSensing}.
     * @param {string} [options.depthSensing.usagePreference] - Optional usage preference for depth
     * sensing, can be 'cpu-optimized' or 'gpu-optimized' (XRDEPTHSENSINGUSAGE_*), defaults to
     * 'cpu-optimized'. Most preferred and supported will be chosen by the underlying depth sensing
     * system.
     * @param {string} [options.depthSensing.dataFormatPreference] - Optional data format
     * preference for depth sensing, can be 'luminance-alpha' or 'float32'
     * (XRDEPTHSENSINGFORMAT_*), defaults to 'luminance-alpha'. Most preferred and supported will
     * be chosen by the underlying depth sensing system.
     * @example
     * button.on('click', function () {
     *     app.xr.start(camera, pc.XRTYPE_VR, pc.XRSPACE_LOCALFLOOR);
     * });
     * @example
     * button.on('click', function () {
     *     app.xr.start(camera, pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR, {
     *         depthSensing: { }
     *     });
     * });
     */
    start(camera: CameraComponent$5, type: string, spaceType: string, options?: {
        optionalFeatures?: string[];
        imageTracking?: boolean;
        planeDetection?: boolean;
        callback?: xrErrorCallback$1;
        depthSensing?: {
            usagePreference?: string;
            dataFormatPreference?: string;
        };
    }): void;
    _onStartOptionsReady(type: any, spaceType: any, options: any, callback: any): void;
    /**
     * Attempts to end XR session and optionally fires callback when session is ended or failed to
     * end.
     *
     * @param {xrErrorCallback} [callback] - Optional callback function called once session is
     * started. The callback has one argument Error - it is null if successfully started XR
     * session.
     * @example
     * app.keyboard.on('keydown', function (evt) {
     *     if (evt.key === pc.KEY_ESCAPE && app.xr.active) {
     *         app.xr.end();
     *     }
     * });
     */
    end(callback?: xrErrorCallback$1): void;
    /**
     * Check if specific type of session is available.
     *
     * @param {string} type - Session type. Can be one of the following:
     *
     * - {@link XRTYPE_INLINE}: Inline - always available type of session. It has limited features
     * availability and is rendered into HTML element.
     * - {@link XRTYPE_VR}: Immersive VR - session that provides exclusive access to VR device with
     * best available tracking features.
     * - {@link XRTYPE_AR}: Immersive AR - session that provides exclusive access to VR/AR device
     * that is intended to be blended with real-world environment.
     *
     * @example
     * if (app.xr.isAvailable(pc.XRTYPE_VR)) {
     *     // VR is available
     * }
     * @returns {boolean} True if specified session type is available.
     */
    isAvailable(type: string): boolean;
    _deviceAvailabilityCheck(): void;
    _sessionSupportCheck(type: any): void;
    _onSessionStart(session: any, spaceType: any, callback: any): void;
    _setClipPlanes(near: any, far: any): void;
    update(frame: any): void;
    /**
     * True if XR is supported.
     *
     * @type {boolean}
     */
    get supported(): boolean;
    /**
     * True if XR session is running.
     *
     * @type {boolean}
     */
    get active(): boolean;
    /**
     * Returns type of currently running XR session or null if no session is running. Can be any of
     * XRTYPE_*.
     *
     * @type {string|null}
     */
    get type(): string;
    /**
     * Returns reference space type of currently running XR session or null if no session is
     * running. Can be any of XRSPACE_*.
     *
     * @type {string|null}
     */
    get spaceType(): string;
    /**
     * Provides access to XRSession of WebXR.
     *
     * @type {object|null}
     */
    get session(): any;
    /**
     * Active camera for which XR session is running or null.
     *
     * @type {Entity|null}
     */
    get camera(): Entity$a;
    get visibilityState(): any;
}

type XrHand$2 = XrHand;
/** @typedef {import('./xr-hand.js').XrHand} XrHand */
/** @typedef {import('./xr-joint.js').XrJoint} XrJoint */
/**
 * Represents finger with related joints and index.
 */
declare class XrFinger$1 {
    /**
     * Create a new XrFinger instance.
     *
     * @param {number} index - Index of a finger.
     * @param {XrHand} hand - Hand that finger relates to.
     * @hideconstructor
     */
    constructor(index: number, hand: XrHand$2);
    _index: number;
    _hand: XrHand;
    _joints: any[];
    _tip: any;
    /**
     * Index of a finger, numeration is: thumb, index, middle, ring, little.
     *
     * @type {number}
     */
    get index(): number;
    /**
     * Hand that finger relates to.
     *
     * @type {XrHand}
     */
    get hand(): XrHand;
    /**
     * List of joints that relates to this finger, starting from joint closest to wrist all the way
     * to the tip of a finger.
     *
     * @type {XrJoint[]}
     */
    get joints(): XrJoint[];
    /**
     * Tip of a finger, or null if not available.
     *
     * @type {XrJoint|null}
     */
    get tip(): XrJoint;
}

type XrFinger = XrFinger$1;
type XrHand$1 = XrHand;
/**
 * Represents the joint of a finger.
 */
declare class XrJoint {
    /**
     * Create an XrJoint instance.
     *
     * @param {number} index - Index of a joint within a finger.
     * @param {string} id - Id of a joint based on WebXR Hand Input Specs.
     * @param {XrHand} hand - Hand that joint relates to.
     * @param {XrFinger} [finger] - Finger that joint is related to, can be null in case of wrist.
     * joint.
     * @hideconstructor
     */
    constructor(index: number, id: string, hand: XrHand$1, finger?: XrFinger);
    _index: number;
    _id: string;
    _hand: XrHand;
    _finger: XrFinger$1;
    _wrist: boolean;
    _tip: boolean;
    _radius: any;
    _localTransform: Mat4$5;
    _worldTransform: Mat4$5;
    _localPosition: Vec3$1;
    _localRotation: Quat$1;
    _position: Vec3$1;
    _rotation: Quat$1;
    _dirtyLocal: boolean;
    update(pose: any): void;
    _updateTransforms(): void;
    /**
     * Get the world space position of a joint.
     *
     * @returns {Vec3} The world space position of a joint.
     */
    getPosition(): Vec3$1;
    /**
     * Get the world space rotation of a joint.
     *
     * @returns {Quat} The world space rotation of a joint.
     */
    getRotation(): Quat$1;
    /**
     * Index of a joint within a finger, starting from 0 (root of a finger) all the way to tip of
     * the finger.
     *
     * @type {number}
     */
    get index(): number;
    /**
     * Hand that joint relates to.
     *
     * @type {XrHand}
     */
    get hand(): XrHand;
    /**
     * Finger that joint relates to.
     *
     * @type {XrFinger|null}
     */
    get finger(): XrFinger$1;
    /**
     * True if joint is a wrist.
     *
     * @type {boolean}
     */
    get wrist(): boolean;
    /**
     * True if joint is a tip of a finger.
     *
     * @type {boolean}
     */
    get tip(): boolean;
    /**
     * The radius of a joint, which is a distance from joint to the edge of a skin.
     *
     * @type {number}
     */
    get radius(): number;
}

type XrInputSource$2 = XrInputSource$1;
/**
 * Represents a hand with fingers and joints.
 *
 * @augments EventHandler
 */
declare class XrHand extends EventHandler$1 {
    /**
     * Represents a hand with fingers and joints.
     *
     * @param {XrInputSource} inputSource - Input Source that hand is related to.
     * @hideconstructor
     */
    constructor(inputSource: XrInputSource$2);
    _manager: XrManager$1;
    _inputSource: XrInputSource$1;
    _tracking: boolean;
    _fingers: any[];
    _joints: XrJoint[];
    _jointsById: {};
    _tips: XrJoint[];
    _wrist: XrJoint;
    /**
     * @event
     * @name XrHand#tracking
     * @description Fired when tracking becomes available.
     */
    /**
     * @event
     * @name XrHand#trackinglost
     * @description Fired when tracking is lost.
     */
    update(frame: any): void;
    _fingerIsClosed(index: any): boolean;
    /**
     * Returns joint by XRHand id from list in specs: https://immersive-web.github.io/webxr-hand-input/.
     *
     * @param {string} id - Id of a joint based on specs ID's in XRHand: https://immersive-web.github.io/webxr-hand-input/.
     * @returns {XrJoint|null} Joint or null if not available.
     */
    getJointById(id: string): XrJoint | null;
    /**
     * List of fingers of a hand.
     *
     * @type {XrFinger[]}
     */
    get fingers(): XrFinger$1[];
    /**
     * List of joints of hand.
     *
     * @type {XrJoint[]}
     */
    get joints(): XrJoint[];
    /**
     * List of joints that are fingertips.
     *
     * @type {XrJoint[]}
     */
    get tips(): XrJoint[];
    /**
     * Wrist of a hand, or null if it is not available by WebXR underlying system.
     *
     * @type {XrJoint|null}
     */
    get wrist(): XrJoint;
    /**
     * True if tracking is available, otherwise tracking might be lost.
     *
     * @type {boolean}
     */
    get tracking(): boolean;
}

type xrHitTestStartCallback = xrHitTestStartCallback$1;
type XrManager = XrManager$1;
/**
 * Represents XR input source, which is any input mechanism which allows the user to perform
 * targeted actions in the same virtual space as the viewer. Example XR input sources include, but
 * are not limited to, handheld controllers, optically tracked hands, and gaze-based input methods
 * that operate on the viewer's pose.
 *
 * @augments EventHandler
 */
declare class XrInputSource$1 extends EventHandler$1 {
    /**
     * Create a new XrInputSource instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @param {object} xrInputSource - [XRInputSource](https://developer.mozilla.org/en-US/docs/Web/API/XRInputSource)
     * object that is created by WebXR API.
     * @hideconstructor
     */
    constructor(manager: XrManager, xrInputSource: object);
    _id: number;
    _manager: XrManager$1;
    _xrInputSource: any;
    _ray: Ray$4;
    _rayLocal: Ray$4;
    _grip: boolean;
    _hand: XrHand;
    _localTransform: Mat4$5;
    _worldTransform: Mat4$5;
    _position: Vec3$1;
    _rotation: Quat$1;
    _localPosition: Vec3$1;
    _localRotation: Quat$1;
    _dirtyLocal: boolean;
    _selecting: boolean;
    _squeezing: boolean;
    _elementInput: boolean;
    _elementEntity: any;
    _hitTestSources: any[];
    /**
     * Unique number associated with instance of input source. Same physical devices when
     * reconnected will not share this ID.
     *
     * @type {number}
     */
    get id(): number;
    /**
     * XRInputSource object that is associated with this input source.
     *
     * @type {object}
     */
    get inputSource(): any;
    /**
     * Type of ray Input Device is based on. Can be one of the following:
     *
     * - {@link XRTARGETRAY_GAZE}: Gaze - indicates the target ray will originate at the viewer and
     * follow the direction it is facing. This is commonly referred to as a "gaze input" device in
     * the context of head-mounted displays.
     * - {@link XRTARGETRAY_SCREEN}: Screen - indicates that the input source was an interaction
     * with the canvas element associated with an inline session's output context, such as a mouse
     * click or touch event.
     * - {@link XRTARGETRAY_POINTER}: Tracked Pointer - indicates that the target ray originates
     * from either a handheld device or other hand-tracking mechanism and represents that the user
     * is using their hands or the held device for pointing.
     *
     * @type {string}
     */
    get targetRayMode(): string;
    /**
     * Describes which hand input source is associated with. Can be one of the following:
     *
     * - {@link XRHAND_NONE}: None - input source is not meant to be held in hands.
     * - {@link XRHAND_LEFT}: Left - indicates that input source is meant to be held in left hand.
     * - {@link XRHAND_RIGHT}: Right - indicates that input source is meant to be held in right
     * hand.
     *
     * @type {string}
     */
    get handedness(): string;
    /**
     * List of input profile names indicating both the preferred visual representation and behavior
     * of the input source.
     *
     * @type {string[]}
     */
    get profiles(): string[];
    /**
     * If input source can be held, then it will have node with its world transformation, that can
     * be used to position and rotate virtual joysticks based on it.
     *
     * @type {boolean}
     */
    get grip(): boolean;
    /**
     * If input source is a tracked hand, then it will point to {@link XrHand} otherwise it is
     * null.
     *
     * @type {XrHand|null}
     */
    get hand(): XrHand;
    /**
     * If input source has buttons, triggers, thumbstick or touchpad, then this object provides
     * access to its states.
     *
     * @type {Gamepad|null}
     */
    get gamepad(): Gamepad;
    /**
     * True if input source is in active primary action between selectstart and selectend events.
     *
     * @type {boolean}
     */
    get selecting(): boolean;
    /**
     * True if input source is in active squeeze action between squeezestart and squeezeend events.
     *
     * @type {boolean}
     */
    get squeezing(): boolean;
    /**
     * Set to true to allow input source to interact with Element components. Defaults to true.
     *
     * @type {boolean}
     */
    set elementInput(arg: boolean);
    get elementInput(): boolean;
    /**
     * If {@link XrInputSource#elementInput} is true, this property will hold entity with Element
     * component at which this input source is hovering, or null if not hovering over any element.
     *
     * @type {Entity|null}
     */
    get elementEntity(): any;
    /**
     * List of active {@link XrHitTestSource} instances created by this input source.
     *
     * @type {XrHitTestSource[]}
     */
    get hitTestSources(): XrHitTestSource[];
    /**
     * @event
     * @name XrInputSource#remove
     * @description Fired when {@link XrInputSource} is removed.
     * @example
     * inputSource.once('remove', function () {
     *     // input source is not available anymore
     * });
     */
    /**
     * @event
     * @name XrInputSource#select
     * @description Fired when input source has triggered primary action. This could be pressing a trigger button, or touching a screen.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     * @example
     * var ray = new pc.Ray();
     * inputSource.on('select', function (evt) {
     *     ray.set(inputSource.getOrigin(), inputSource.getDirection());
     *     if (obj.intersectsRay(ray)) {
     *         // selected an object with input source
     *     }
     * });
     */
    /**
     * @event
     * @name XrInputSource#selectstart
     * @description Fired when input source has started to trigger primary action.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * @event
     * @name XrInputSource#selectend
     * @description Fired when input source has ended triggering primary action.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * @event
     * @name XrInputSource#squeeze
     * @description Fired when input source has triggered squeeze action. This is associated with "grabbing" action on the controllers.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * @event
     * @name XrInputSource#squeezestart
     * @description Fired when input source has started to trigger squeeze action.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     * @example
     * inputSource.on('squeezestart', function (evt) {
     *     if (obj.containsPoint(inputSource.getPosition())) {
     *         // grabbed an object
     *     }
     * });
     */
    /**
     * @event
     * @name XrInputSource#squeezeend
     * @description Fired when input source has ended triggering squeeze action.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * @event
     * @name XrInputSource#hittest:add
     * @description Fired when new {@link XrHitTestSource} is added to the input source.
     * @param {XrHitTestSource} hitTestSource - Hit test source that has been added.
     * @example
     * inputSource.on('hittest:add', function (hitTestSource) {
     *     // new hit test source is added
     * });
     */
    /**
     * @event
     * @name XrInputSource#hittest:remove
     * @description Fired when {@link XrHitTestSource} is removed to the the input source.
     * @param {XrHitTestSource} hitTestSource - Hit test source that has been removed.
     * @example
     * inputSource.on('remove', function (hitTestSource) {
     *     // hit test source is removed
     * });
     */
    /**
     * @event
     * @name XrInputSource#hittest:result
     * @description Fired when hit test source receives new results. It provides transform information that tries to match real world picked geometry.
     * @param {XrHitTestSource} hitTestSource - Hit test source that produced the hit result.
     * @param {Vec3} position - Position of hit test.
     * @param {Quat} rotation - Rotation of hit test.
     * @example
     * inputSource.on('hittest:result', function (hitTestSource, position, rotation) {
     *     target.setPosition(position);
     *     target.setRotation(rotation);
     * });
     */
    update(frame: any): void;
    _dirtyRay: boolean;
    _updateTransforms(): void;
    _updateRayTransforms(): void;
    /**
     * Get the world space position of input source if it is handheld ({@link XrInputSource#grip}
     * is true). Otherwise it will return null.
     *
     * @returns {Vec3|null} The world space position of handheld input source.
     */
    getPosition(): Vec3$1 | null;
    /**
     * Get the local space position of input source if it is handheld ({@link XrInputSource#grip}
     * is true). Local space is relative to parent of the XR camera. Otherwise it will return null.
     *
     * @returns {Vec3|null} The world space position of handheld input source.
     */
    getLocalPosition(): Vec3$1 | null;
    /**
     * Get the world space rotation of input source if it is handheld ({@link XrInputSource#grip}
     * is true). Otherwise it will return null.
     *
     * @returns {Quat|null} The world space rotation of handheld input source.
     */
    getRotation(): Quat$1 | null;
    /**
     * Get the local space rotation of input source if it is handheld ({@link XrInputSource#grip}
     * is true). Local space is relative to parent of the XR camera. Otherwise it will return null.
     *
     * @returns {Vec3|null} The world space rotation of handheld input source.
     */
    getLocalRotation(): Vec3$1 | null;
    /**
     * Get the world space origin of input source ray.
     *
     * @returns {Vec3} The world space origin of input source ray.
     */
    getOrigin(): Vec3$1;
    /**
     * Get the world space direction of input source ray.
     *
     * @returns {Vec3} The world space direction of input source ray.
     */
    getDirection(): Vec3$1;
    /**
     * Attempts to start hit test source based on this input source.
     *
     * @param {object} [options] - Object for passing optional arguments.
     * @param {string[]} [options.entityTypes] - Optional list of underlying entity types against
     * which hit tests will be performed. Defaults to [ {@link XRTRACKABLE_PLANE} ]. Can be any
     * combination of the following:
     *
     * - {@link XRTRACKABLE_POINT}: Point - indicates that the hit test results will be computed
     * based on the feature points detected by the underlying Augmented Reality system.
     * - {@link XRTRACKABLE_PLANE}: Plane - indicates that the hit test results will be computed
     * based on the planes detected by the underlying Augmented Reality system.
     * - {@link XRTRACKABLE_MESH}: Mesh - indicates that the hit test results will be computed
     * based on the meshes detected by the underlying Augmented Reality system.
     *
     * @param {Ray} [options.offsetRay] - Optional ray by which hit test ray can be offset.
     * @param {xrHitTestStartCallback} [options.callback] - Optional callback function called once
     * hit test source is created or failed.
     * @example
     * app.xr.input.on('add', function (inputSource) {
     *     inputSource.hitTestStart({
     *         callback: function (err, hitTestSource) {
     *             if (err) return;
     *             hitTestSource.on('result', function (position, rotation) {
     *                 // position and rotation of hit test result
     *                 // that will be created from touch on mobile devices
     *             });
     *         }
     *     });
     * });
     */
    hitTestStart(options?: {
        entityTypes?: string[];
        offsetRay?: Ray$4;
        callback?: xrHitTestStartCallback;
    }): void;
    onHitTestSourceAdd(hitTestSource: any): void;
    onHitTestSourceRemove(hitTestSource: any): void;
}

type CameraComponent$4 = CameraComponent$2;
type ElementComponent = ElementComponent$2;
type XrInputSource = XrInputSource$1;
/**
 * Handles mouse and touch events for {@link ElementComponent}s. When input events occur on an
 * ElementComponent this fires the appropriate events on the ElementComponent.
 */
declare class ElementInput$1 {
    /**
     * Create a new ElementInput instance.
     *
     * @param {Element} domElement - The DOM element.
     * @param {object} [options] - Optional arguments.
     * @param {boolean} [options.useMouse] - Whether to allow mouse input. Defaults to true.
     * @param {boolean} [options.useTouch] - Whether to allow touch input. Defaults to true.
     * @param {boolean} [options.useXr] - Whether to allow XR input sources. Defaults to true.
     */
    constructor(domElement: Element, options?: {
        useMouse?: boolean;
        useTouch?: boolean;
        useXr?: boolean;
    });
    _app: any;
    _attached: boolean;
    _target: Element;
    _enabled: boolean;
    _lastX: number;
    _lastY: number;
    _upHandler: any;
    _downHandler: any;
    _moveHandler: any;
    _wheelHandler: any;
    _touchstartHandler: any;
    _touchendHandler: any;
    _touchcancelHandler: any;
    _touchmoveHandler: any;
    _sortHandler: any;
    _elements: any[];
    _hoveredElement: any;
    _pressedElement: any;
    _touchedElements: {};
    _touchesForWhichTouchLeaveHasFired: {};
    _selectedElements: {};
    _selectedPressedElements: {};
    _useMouse: boolean;
    _useTouch: boolean;
    _useXr: boolean;
    _selectEventsAttached: boolean;
    _clickedEntities: {};
    set enabled(arg: boolean);
    get enabled(): boolean;
    set app(arg: any);
    get app(): any;
    /**
     * Attach mouse and touch events to a DOM element.
     *
     * @param {Element} domElement - The DOM element.
     */
    attach(domElement: Element): void;
    attachSelectEvents(): void;
    /**
     * Remove mouse and touch events from the DOM element that it is attached to.
     */
    detach(): void;
    /**
     * Add a {@link ElementComponent} to the internal list of ElementComponents that are being
     * checked for input.
     *
     * @param {ElementComponent} element - The ElementComponent.
     */
    addElement(element: ElementComponent): void;
    /**
     * Remove a {@link ElementComponent} from the internal list of ElementComponents that are being
     * checked for input.
     *
     * @param {ElementComponent} element - The ElementComponent.
     */
    removeElement(element: ElementComponent): void;
    _handleUp(event: any): void;
    _handleDown(event: any): void;
    _handleMove(event: any): void;
    _handleWheel(event: any): void;
    _determineTouchedElements(event: any): {};
    _handleTouchStart(event: any): void;
    _handleTouchEnd(event: any): void;
    _handleTouchMove(event: any): void;
    _onElementMouseEvent(eventType: any, event: any): void;
    _onXrStart(): void;
    _onXrEnd(): void;
    _onXrUpdate(): void;
    _onXrInputRemove(inputSource: any): void;
    _onSelectStart(inputSource: any, event: any): void;
    _onSelectEnd(inputSource: any, event: any): void;
    _onElementSelectEvent(eventType: any, inputSource: any, event: any): void;
    _fireEvent(name: any, evt: any): void;
    _calcMouseCoords(event: any): void;
    _calcTouchCoords(touch: any): {
        x: number;
        y: number;
    };
    _sortElements(a: any, b: any): any;
    _getTargetElement(camera: any, x: any, y: any): any;
    _getTargetElementByRay(ray: any, camera: any): any;
    _buildHitCorners(element: any, screenOrWorldCorners: any, scaleX: any, scaleY: any, scaleZ: any): any;
    _calculateScaleToScreen(element: any): Vec3$1;
    _calculateScaleToWorld(element: any): Vec3$1;
    _calculateRayScreen(x: any, y: any, camera: any, ray: any): boolean;
    _calculateRay3d(x: any, y: any, camera: any, ray: any): boolean;
    _checkElement(ray: any, element: any, screen: any): number;
}
/**
 * Represents an input event fired on a {@link ElementComponent}. When an event is raised on an
 * ElementComponent it bubbles up to its parent ElementComponents unless we call stopPropagation().
 */
declare class ElementInputEvent {
    /**
     * Create a new ElementInputEvent instance.
     *
     * @param {MouseEvent|TouchEvent} event - The MouseEvent or TouchEvent that was originally
     * raised.
     * @param {ElementComponent} element - The ElementComponent that this event was originally
     * raised on.
     * @param {CameraComponent} camera - The CameraComponent that this event was originally raised
     * via.
     */
    constructor(event: MouseEvent | TouchEvent, element: ElementComponent, camera: CameraComponent$4);
    /**
     * The MouseEvent or TouchEvent that was originally raised.
     *
     * @type {MouseEvent|TouchEvent}
     */
    event: MouseEvent | TouchEvent;
    /**
     * The ElementComponent that this event was originally raised on.
     *
     * @type {ElementComponent}
     */
    element: ElementComponent;
    /**
     * The CameraComponent that this event was originally raised via.
     *
     * @type {CameraComponent}
     */
    camera: CameraComponent$4;
    _stopPropagation: boolean;
    /**
     * Stop propagation of the event to parent {@link ElementComponent}s. This also stops
     * propagation of the event to other event listeners of the original DOM Event.
     */
    stopPropagation(): void;
}
/**
 * Represents a Mouse event fired on a {@link ElementComponent}.
 *
 * @augments ElementInputEvent
 */
declare class ElementMouseEvent extends ElementInputEvent {
    /**
     * Create an instance of an ElementMouseEvent.
     *
     * @param {MouseEvent} event - The MouseEvent that was originally raised.
     * @param {ElementComponent} element - The ElementComponent that this event was originally
     * raised on.
     * @param {CameraComponent} camera - The CameraComponent that this event was originally raised
     * via.
     * @param {number} x - The x coordinate.
     * @param {number} y - The y coordinate.
     * @param {number} lastX - The last x coordinate.
     * @param {number} lastY - The last y coordinate.
     */
    constructor(event: MouseEvent, element: ElementComponent, camera: CameraComponent$4, x: number, y: number, lastX: number, lastY: number);
    x: number;
    y: number;
    /**
     * Whether the ctrl key was pressed.
     *
     * @type {boolean}
     */
    ctrlKey: boolean;
    /**
     * Whether the alt key was pressed.
     *
     * @type {boolean}
     */
    altKey: boolean;
    /**
     * Whether the shift key was pressed.
     *
     * @type {boolean}
     */
    shiftKey: boolean;
    /**
     * Whether the meta key was pressed.
     *
     * @type {boolean}
     */
    metaKey: boolean;
    /**
     * The mouse button.
     *
     * @type {number}
     */
    button: number;
    /**
     * The amount of horizontal movement of the cursor.
     *
     * @type {number}
     */
    dx: number;
    /**
     * The amount of vertical movement of the cursor.
     *
     * @type {number}
     */
    dy: number;
    /**
     * The amount of the wheel movement.
     *
     * @type {number}
     */
    wheelDelta: number;
}
/**
 * Represents a XRInputSourceEvent fired on a {@link ElementComponent}.
 *
 * @augments ElementInputEvent
 */
declare class ElementSelectEvent extends ElementInputEvent {
    /**
     * Create an instance of a ElementSelectEvent.
     *
     * @param {object} event - The XRInputSourceEvent that was originally raised.
     * @param {ElementComponent} element - The ElementComponent that this event was originally
     * raised on.
     * @param {CameraComponent} camera - The CameraComponent that this event was originally raised
     * via.
     * @param {XrInputSource} inputSource - The XR input source that this event was originally
     * raised from.
     */
    constructor(event: object, element: ElementComponent, camera: CameraComponent$4, inputSource: XrInputSource);
    /**
     * The XR input source that this event was originally raised from.
     *
     * @type {XrInputSource}
     */
    inputSource: XrInputSource;
}
/**
 * Represents a TouchEvent fired on a {@link ElementComponent}.
 *
 * @augments ElementInputEvent
 */
declare class ElementTouchEvent extends ElementInputEvent {
    /**
     * Create an instance of an ElementTouchEvent.
     *
     * @param {TouchEvent} event - The TouchEvent that was originally raised.
     * @param {ElementComponent} element - The ElementComponent that this event was originally
     * raised on.
     * @param {CameraComponent} camera - The CameraComponent that this event was originally raised
     * via.
     * @param {number} x - The x coordinate of the touch that triggered the event.
     * @param {number} y - The y coordinate of the touch that triggered the event.
     * @param {Touch} touch - The touch object that triggered the event.
     */
    constructor(event: TouchEvent, element: ElementComponent, camera: CameraComponent$4, x: number, y: number, touch: Touch);
    /**
     * The Touch objects representing all current points of contact with the surface,
     * regardless of target or changed status.
     *
     * @type {Touch[]}
     */
    touches: Touch[];
    /**
     * The Touch objects representing individual points of contact whose states changed between
     * the previous touch event and this one.
     *
     * @type {Touch[]}
     */
    changedTouches: Touch[];
    x: number;
    y: number;
    /**
     * The touch object that triggered the event.
     *
     * @type {Touch}
     */
    touch: Touch;
}

type GraphicsDevice$c = GraphicsDevice$l;
/** @typedef {import('../graphics/graphics-device.js').GraphicsDevice} GraphicsDevice */
/**
 * Records performance-related statistics related to the application.
 *
 * @ignore
 */
declare class ApplicationStats {
    /**
     * Create a new ApplicationStats instance.
     *
     * @param {GraphicsDevice} device - The graphics device.
     */
    constructor(device: GraphicsDevice$c);
    frame: {
        fps: number;
        ms: number;
        dt: number;
        updateStart: number;
        updateTime: number;
        renderStart: number;
        renderTime: number;
        physicsStart: number;
        physicsTime: number;
        cullTime: number;
        sortTime: number;
        skinTime: number;
        morphTime: number;
        instancingTime: number;
        triangles: number;
        otherPrimitives: number;
        shaders: number;
        materials: number;
        cameras: number;
        shadowMapUpdates: number;
        shadowMapTime: number;
        depthMapTime: number;
        forwardTime: number;
        lightClustersTime: number;
        lightClusters: number;
        _timeToCountFrames: number;
        _fpsAccum: number;
    };
    drawCalls: {
        forward: number;
        depth: number;
        shadow: number;
        immediate: number;
        misc: number;
        total: number;
        skinned: number;
        instanced: number;
        removedByInstancing: number;
    };
    misc: {
        renderTargetCreationTime: number;
    };
    particles: {
        updatesPerFrame: number;
        _updatesPerFrame: number;
        frameTime: number;
        _frameTime: number;
    };
    shaders: {
        vsCompiled: number;
        fsCompiled: number;
        linked: number;
        materialShaders: number;
        compileTime: number;
    };
    vram: {
        texShadow: number;
        texAsset: number;
        texLightmap: number;
        tex: number;
        vb: number;
        ib: number;
    };
    get scene(): any;
    get lightmapper(): any;
    get batcher(): any;
}

type CameraComponent$3 = CameraComponent$2;
type LightComponent = LightComponent$2;
type MeshInstance$2 = MeshInstance$3;
/**
 * A Layer represents a renderable subset of the scene. It can contain a list of mesh instances,
 * lights and cameras, their render settings and also defines custom callbacks before, after or
 * during rendering. Layers are organized inside {@link LayerComposition} in a desired order.
 *
 * @property {boolean} enabled Enable the layer. Disabled layers are skipped. Defaults to true.
 * @property {string} name Name of the layer. Can be used in
 * {@link LayerComposition#getLayerByName}.
 * @property {number} opaqueSortMode Defines the method used for sorting opaque (that is, not semi-
 * transparent) mesh instances before rendering. Can be:
 *
 * - {@link SORTMODE_NONE}
 * - {@link SORTMODE_MANUAL}
 * - {@link SORTMODE_MATERIALMESH}
 * - {@link SORTMODE_BACK2FRONT}
 * - {@link SORTMODE_FRONT2BACK}
 *
 * Defaults to {@link SORTMODE_MATERIALMESH}.
 * @property {number} transparentSortMode Defines the method used for sorting semi-transparent mesh
 * instances before rendering. Can be:
 *
 * - {@link SORTMODE_NONE}
 * - {@link SORTMODE_MANUAL}
 * - {@link SORTMODE_MATERIALMESH}
 * - {@link SORTMODE_BACK2FRONT}
 * - {@link SORTMODE_FRONT2BACK}
 *
 * Defaults to {@link SORTMODE_BACK2FRONT}.
 * @property {number} shaderPass A type of shader to use during rendering. Possible values are:
 *
 * - {@link SHADER_FORWARD}
 * - {@link SHADER_FORWARDHDR}
 * - {@link SHADER_DEPTH}
 * - Your own custom value. Should be in 19 - 31 range. Use {@link StandardMaterial#onUpdateShader}
 * to apply shader modifications based on this value.
 *
 * Defaults to {@link SHADER_FORWARD}.
 * @property {boolean} passThrough Tells that this layer is simple and needs to just render a bunch
 * of mesh instances without lighting, skinning and morphing (faster).
 * @property {boolean} clearColorBuffer If true, the camera will clear the color buffer when it
 * renders this layer.
 * @property {boolean} clearDepthBuffer If true, the camera will clear the depth buffer when it
 * renders this layer.
 * @property {boolean} clearStencilBuffer If true, the camera will clear the stencil buffer when it
 * renders this layer.
 * @property {Layer} layerReference Make this layer render the same mesh instances that another
 * layer does instead of having its own mesh instance list. Both layers must share cameras. Frustum
 * culling is only performed for one layer. Useful for rendering multiple passes using different
 * shaders.
 * @property {Function} cullingMask Visibility mask that interacts with {@link MeshInstance#mask}.
 * @property {Function} onEnable Custom function that is called after the layer has been enabled.
 * This happens when:
 *
 * - The layer is created with {@link Layer#enabled} set to true (which is the default value).
 * - {@link Layer#enabled} was changed from false to true
 * - {@link Layer#incrementCounter} was called and incremented the counter above zero.
 *
 * Useful for allocating resources this layer will use (e.g. creating render targets).
 * @property {Function} onDisable Custom function that is called after the layer has been disabled.
 * This happens when:
 *
 * - {@link Layer#enabled} was changed from true to false
 * - {@link Layer#decrementCounter} was called and set the counter to zero.
 *
 * @property {Function} onPreCull Custom function that is called before visibility culling is
 * performed for this layer. Useful, for example, if you want to modify camera projection while
 * still using the same camera and make frustum culling work correctly with it (see
 * {@link CameraComponent#calculateTransform} and {@link CameraComponent#calculateProjection}).
 * This function will receive camera index as the only argument. You can get the actual camera
 * being used by looking up {@link LayerComposition#cameras} with this index.
 * @property {Function} onPostCull Custom function that is called after visibility culling is
 * performed for this layer. Useful for reverting changes done in {@link Layer#onPreCull} and
 * determining final mesh instance visibility (see {@link MeshInstance#visibleThisFrame}). This
 * function will receive camera index as the only argument. You can get the actual camera being
 * used by looking up {@link LayerComposition#cameras} with this index.
 * @property {Function} onPreRender Custom function that is called before this layer is rendered.
 * Useful, for example, for reacting on screen size changes. This function is called before the
 * first occurrence of this layer in {@link LayerComposition}. It will receive camera index as the
 * only argument. You can get the actual camera being used by looking up
 * {@link LayerComposition#cameras} with this index.
 * @property {Function} onPreRenderOpaque Custom function that is called before opaque mesh
 * instances (not semi-transparent) in this layer are rendered. This function will receive camera
 * index as the only argument. You can get the actual camera being used by looking up
 * {@link LayerComposition#cameras} with this index.
 * @property {Function} onPreRenderTransparent Custom function that is called before semi-
 * transparent mesh instances in this layer are rendered. This function will receive camera index
 * as the only argument. You can get the actual camera being used by looking up
 * {@link LayerComposition#cameras} with this index.
 * @property {Function} onPostRender Custom function that is called after this layer is rendered.
 * Useful to revert changes made in {@link Layer#onPreRender} or performing some processing on
 * {@link Layer#renderTarget}. This function is called after the last occurrence of this layer in
 * {@link LayerComposition}. It will receive camera index as the only argument. You can get the
 * actual camera being used by looking up {@link LayerComposition#cameras} with this index.
 * @property {Function} onPostRenderOpaque Custom function that is called after opaque mesh
 * instances (not semi-transparent) in this layer are rendered. This function will receive camera
 * index as the only argument. You can get the actual camera being used by looking up
 * {@link LayerComposition#cameras} with this index.
 * @property {Function} onPostRenderTransparent Custom function that is called after semi-
 * transparent mesh instances in this layer are rendered. This function will receive camera index
 * as the only argument. You can get the actual camera being used by looking up
 * {@link LayerComposition#cameras} with this index.
 * @property {Function} onDrawCall Custom function that is called before every mesh instance in
 * this layer is rendered. It is not recommended to set this function when rendering many objects
 * every frame due to performance reasons.
 * @property {number} id A unique ID of the layer. Layer IDs are stored inside
 * {@link ModelComponent#layers}, {@link CameraComponent#layers}, {@link LightComponent#layers}
 * and {@link ElementComponent#layers} instead of names. Can be used in
 * {@link LayerComposition#getLayerById}.
 */
declare class Layer$1 {
    /**
     * Create a new Layer instance.
     *
     * @param {object} options - Object for passing optional arguments. These arguments are the
     * same as properties of the Layer.
     */
    constructor(options?: object);
    id: any;
    name: any;
    _enabled: any;
    _refCounter: number;
    opaqueSortMode: any;
    transparentSortMode: any;
    set renderTarget(arg: any);
    get renderTarget(): any;
    shaderPass: any;
    passThrough: any;
    _clearColorBuffer: any;
    _clearDepthBuffer: any;
    _clearStencilBuffer: any;
    onPreCull: any;
    onPreRender: any;
    onPreRenderOpaque: any;
    onPreRenderTransparent: any;
    onPostCull: any;
    onPostRender: any;
    onPostRenderOpaque: any;
    onPostRenderTransparent: any;
    onDrawCall: any;
    onEnable: any;
    onDisable: any;
    layerReference: any;
    instances: any;
    cullingMask: any;
    opaqueMeshInstances: any;
    transparentMeshInstances: any;
    shadowCasters: any;
    customSortCallback: any;
    customCalculateSortValues: any;
    _lights: any[];
    _lightsSet: Set<any>;
    _clusteredLightsSet: Set<any>;
    _splitLights: any[][];
    cameras: any[];
    _dirty: boolean;
    _dirtyLights: boolean;
    _dirtyCameras: boolean;
    _lightHash: number;
    _staticLightHash: number;
    _needsStaticPrepare: boolean;
    _staticPrepareDone: boolean;
    skipRenderAfter: number;
    _skipRenderCounter: number;
    _renderTime: number;
    _forwardDrawCalls: number;
    _shadowDrawCalls: number;
    _shaderVersion: number;
    _lightCube: any;
    _renderTarget: any;
    set enabled(arg: any);
    get enabled(): any;
    set clearColor(arg: any);
    get clearColor(): any;
    set clearColorBuffer(arg: any);
    get clearColorBuffer(): any;
    set clearDepthBuffer(arg: any);
    get clearDepthBuffer(): any;
    set clearStencilBuffer(arg: any);
    get clearStencilBuffer(): any;
    /**
     * Increments the usage counter of this layer. By default, layers are created with counter set
     * to 1 (if {@link Layer.enabled} is true) or 0 (if it was false). Incrementing the counter
     * from 0 to 1 will enable the layer and call {@link Layer.onEnable}. Use this function to
     * "subscribe" multiple effects to the same layer. For example, if the layer is used to render
     * a reflection texture which is used by 2 mirrors, then each mirror can call this function
     * when visible and {@link Layer.decrementCounter} if invisible. In such case the reflection
     * texture won't be updated, when there is nothing to use it, saving performance.
     *
     * @private
     */
    private incrementCounter;
    /**
     * Decrements the usage counter of this layer. Decrementing the counter from 1 to 0 will
     * disable the layer and call {@link Layer.onDisable}. See {@link Layer#incrementCounter} for
     * more details.
     *
     * @private
     */
    private decrementCounter;
    /**
     * Adds an array of mesh instances to this layer.
     *
     * @param {MeshInstance[]} meshInstances - Array of {@link MeshInstance}.
     * @param {boolean} [skipShadowCasters] - Set it to true if you don't want these mesh instances
     * to cast shadows in this layer.
     */
    addMeshInstances(meshInstances: MeshInstance$2[], skipShadowCasters?: boolean): void;
    removeMeshInstanceFromArray(m: any, arr: any): void;
    /**
     * Removes multiple mesh instances from this layer.
     *
     * @param {MeshInstance[]} meshInstances - Array of {@link MeshInstance}. If they were added to
     * this layer, they will be removed.
     * @param {boolean} [skipShadowCasters] - Set it to true if you want to still cast shadows from
     * removed mesh instances or if they never did cast shadows before.
     */
    removeMeshInstances(meshInstances: MeshInstance$2[], skipShadowCasters?: boolean): void;
    /**
     * Removes all mesh instances from this layer.
     *
     * @param {boolean} [skipShadowCasters] - Set it to true if you want to still cast shadows from
     * removed mesh instances or if they never did cast shadows before.
     */
    clearMeshInstances(skipShadowCasters?: boolean): void;
    /**
     * Adds a light to this layer.
     *
     * @param {LightComponent} light - A {@link LightComponent}.
     */
    addLight(light: LightComponent): void;
    /**
     * Removes a light from this layer.
     *
     * @param {LightComponent} light - A {@link LightComponent}.
     */
    removeLight(light: LightComponent): void;
    /**
     * Removes all lights from this layer.
     */
    clearLights(): void;
    get clusteredLightsSet(): Set<any>;
    /**
     * Adds an array of mesh instances to this layer, but only as shadow casters (they will not be
     * rendered anywhere, but only cast shadows on other objects).
     *
     * @param {MeshInstance[]} meshInstances - Array of {@link MeshInstance}.
     */
    addShadowCasters(meshInstances: MeshInstance$2[]): void;
    /**
     * Removes multiple mesh instances from the shadow casters list of this layer, meaning they
     * will stop casting shadows.
     *
     * @param {MeshInstance[]} meshInstances - Array of {@link MeshInstance}. If they were added to
     * this layer, they will be removed.
     */
    removeShadowCasters(meshInstances: MeshInstance$2[]): void;
    _generateLightHash(): void;
    /**
     * Adds a camera to this layer.
     *
     * @param {CameraComponent} camera - A {@link CameraComponent}.
     */
    addCamera(camera: CameraComponent$3): void;
    /**
     * Removes a camera from this layer.
     *
     * @param {CameraComponent} camera - A {@link CameraComponent}.
     */
    removeCamera(camera: CameraComponent$3): void;
    /**
     * Removes all cameras from this layer.
     */
    clearCameras(): void;
    _calculateSortDistances(drawCalls: any, drawCallsCount: any, camPos: any, camFwd: any): void;
    _sortVisible(transparent: any, cameraNode: any, cameraPass: any): void;
}

declare class LightsBuffer {
    static FORMAT_FLOAT: number;
    static FORMAT_8BIT: number;
    static lightTextureFormat: number;
    static shaderDefines: string;
    static initShaderDefines(): void;
    static buildShaderDefines(object: any, prefix: any): string;
    static init(device: any): void;
    static createTexture(device: any, width: any, height: any, format: any, name: any): Texture$8;
    constructor(device: any);
    device: any;
    cookiesEnabled: boolean;
    shadowsEnabled: boolean;
    areaLightsEnabled: boolean;
    maxLights: number;
    lights8: Uint8ClampedArray;
    lightsTexture8: Texture$8;
    _lightsTexture8Id: any;
    lightsFloat: Float32Array;
    lightsTextureFloat: Texture$8;
    _lightsTextureFloatId: any;
    _lightsTextureInvSizeId: any;
    _lightsTextureInvSizeData: Float32Array;
    invMaxColorValue: number;
    invMaxAttenuation: number;
    boundsMin: Vec3$1;
    boundsDelta: Vec3$1;
    destroy(): void;
    setCompressionRanges(maxAttenuation: any, maxColorValue: any): void;
    setBounds(min: any, delta: any): void;
    uploadTextures(): void;
    updateUniforms(): void;
    getSpotDirection(direction: any, spot: any): void;
    getLightAreaSizes(light: any): Float32Array;
    addLightDataFlags(data8: any, index: any, light: any, isSpot: any, castShadows: any): void;
    addLightDataColor(data8: any, index: any, light: any, gammaCorrection: any, isCookie: any): void;
    addLightDataSpotAngles(data8: any, index: any, light: any): void;
    addLightDataShadowBias(data8: any, index: any, light: any): void;
    addLightDataPositionRange(data8: any, index: any, light: any, pos: any): void;
    addLightDataSpotDirection(data8: any, index: any, light: any): void;
    addLightDataLightProjMatrix(data8: any, index: any, lightProjectionMatrix: any): void;
    addLightDataCookies(data8: any, index: any, light: any): void;
    addLightAtlasViewport(data8: any, index: any, atlasViewport: any): void;
    addLightAreaSizes(data8: any, index: any, light: any): void;
    addLightData(light: any, lightIndex: any, gammaCorrection: any): void;
}

declare class WorldClusters {
    constructor(device: any);
    device: any;
    name: string;
    reportCount: number;
    boundsMin: Vec3$1;
    boundsMax: Vec3$1;
    boundsDelta: Vec3$1;
    _cells: Vec3$1;
    _cellsLimit: Vec3$1;
    set cells(arg: Vec3$1);
    get cells(): Vec3$1;
    _maxCellLightCount: number;
    _pixelsPerCellCount: number;
    set maxCellLightCount(arg: number);
    get maxCellLightCount(): number;
    _maxAttenuation: number;
    _maxColorValue: number;
    _usedLights: ClusterLight[];
    lightsBuffer: LightsBuffer;
    _cellsDirty: boolean;
    destroy(): void;
    releaseClusterTexture(): void;
    clusterTexture: Texture$8;
    registerUniforms(device: any): void;
    _clusterWorldTextureId: any;
    _clusterPixelsPerCellId: any;
    _clusterTextureSizeId: any;
    _clusterTextureSizeData: Float32Array;
    _clusterBoundsMinId: any;
    _clusterBoundsMinData: Float32Array;
    _clusterBoundsDeltaId: any;
    _clusterBoundsDeltaData: Float32Array;
    _clusterCellsCountByBoundsSizeId: any;
    _clusterCellsCountByBoundsSizeData: Float32Array;
    _clusterCellsDotId: any;
    _clusterCellsDotData: Float32Array;
    _clusterCellsMaxId: any;
    _clusterCellsMaxData: Float32Array;
    _clusterCompressionLimit0Id: any;
    _clusterCompressionLimit0Data: Float32Array;
    updateParams(lightingParams: any): void;
    updateCells(): void;
    clusters: Uint8ClampedArray;
    counts: Int32Array;
    uploadTextures(): void;
    updateUniforms(): void;
    evalLightCellMinMax(clusteredLight: any, min: any, max: any): void;
    collectLights(lights: any): void;
    evaluateBounds(): void;
    evaluateCompressionLimits(gammaCorrection: any): void;
    updateClusters(gammaCorrection: any): void;
    update(lights: any, gammaCorrection: any, lightingParams: any): void;
    activate(): void;
}

declare class ClusterLight {
    light: any;
    min: Vec3$1;
    max: Vec3$1;
}

type Layer = Layer$1;
/**
 * Layer Composition is a collection of {@link Layer} that is fed to {@link Scene#layers} to define
 * rendering order.
 *
 * @property {Layer[]} layerList A read-only array of {@link Layer} sorted in the order they will
 * be rendered.
 * @property {boolean[]} subLayerList A read-only array of boolean values, matching
 * {@link Layer#layerList}. True means only semi-transparent objects are rendered, and false means
 * opaque.
 * @property {boolean[]} subLayerEnabled A read-only array of boolean values, matching
 * {@link Layer#layerList}. True means the layer is rendered, false means it's skipped.
 * @property {CameraComponent[]} cameras A read-only array of {@link CameraComponent} that can be
 * used during rendering. e.g. Inside {@link Layer#onPreCull}, {@link Layer#onPostCull},
 * {@link Layer#onPreRender}, {@link Layer#onPostRender}.
 * @augments EventHandler
 */
declare class LayerComposition extends EventHandler$1 {
    /**
     * Create a new layer composition.
     *
     * @param {string} [name] - Optional non-unique name of the layer composition. Defaults to
     * "Untitled" if not specified.
     */
    constructor(name?: string);
    name: string;
    logRenderActions: boolean;
    layerList: any[];
    subLayerList: any[];
    subLayerEnabled: any[];
    _opaqueOrder: {};
    _transparentOrder: {};
    _dirty: boolean;
    _dirtyBlend: boolean;
    _dirtyLights: boolean;
    _dirtyCameras: boolean;
    _meshInstances: any[];
    _meshInstancesSet: Set<any>;
    _lights: any[];
    _lightsMap: Map<any, any>;
    _lightCompositionData: any[];
    _splitLights: any[][];
    cameras: any[];
    _renderActions: any[];
    _worldClusters: any[];
    _emptyWorldClusters: WorldClusters;
    destroy(): void;
    getEmptyWorldClusters(device: any): WorldClusters;
    _splitLightsArray(target: any): void;
    _update(device: any, clusteredLightingEnabled?: boolean): number;
    updateShadowCasters(): void;
    updateLights(): void;
    findCompatibleCluster(layer: any, renderActionCount: any): any;
    allocateLightClusters(device: any): void;
    addRenderAction(renderActions: any, renderActionIndex: any, layer: any, layerIndex: any, cameraIndex: any, cameraFirstRenderAction: any, postProcessMarked: any): any;
    propagateRenderTarget(startIndex: any, fromCamera: any): void;
    _logRenderActions(): void;
    _isLayerAdded(layer: any): boolean;
    _isSublayerAdded(layer: any, transparent: any): boolean;
    /**
     * Adds a layer (both opaque and semi-transparent parts) to the end of the {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to add.
     */
    push(layer: Layer): void;
    /**
     * Inserts a layer (both opaque and semi-transparent parts) at the chosen index in the
     * {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to add.
     * @param {number} index - Insertion position.
     */
    insert(layer: Layer, index: number): void;
    /**
     * Removes a layer (both opaque and semi-transparent parts) from {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to remove.
     */
    remove(layer: Layer): void;
    /**
     * Adds part of the layer with opaque (non semi-transparent) objects to the end of the
     * {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to add.
     */
    pushOpaque(layer: Layer): void;
    /**
     * Inserts an opaque part of the layer (non semi-transparent mesh instances) at the chosen
     * index in the {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to add.
     * @param {number} index - Insertion position.
     */
    insertOpaque(layer: Layer, index: number): void;
    /**
     * Removes an opaque part of the layer (non semi-transparent mesh instances) from
     * {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to remove.
     */
    removeOpaque(layer: Layer): void;
    /**
     * Adds part of the layer with semi-transparent objects to the end of the {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to add.
     */
    pushTransparent(layer: Layer): void;
    /**
     * Inserts a semi-transparent part of the layer at the chosen index in the {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to add.
     * @param {number} index - Insertion position.
     */
    insertTransparent(layer: Layer, index: number): void;
    /**
     * Removes a transparent part of the layer from {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to remove.
     */
    removeTransparent(layer: Layer): void;
    _getSublayerIndex(layer: any, transparent: any): number;
    /**
     * Gets index of the opaque part of the supplied layer in the {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to find index of.
     * @returns {number} The index of the opaque part of the specified layer.
     */
    getOpaqueIndex(layer: Layer): number;
    /**
     * Gets index of the semi-transparent part of the supplied layer in the {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to find index of.
     * @returns {number} The index of the semi-transparent part of the specified layer.
     */
    getTransparentIndex(layer: Layer): number;
    /**
     * Finds a layer inside this composition by its ID. Null is returned, if nothing is found.
     *
     * @param {number} id - An ID of the layer to find.
     * @returns {Layer|null} The layer corresponding to the specified ID. Returns null if layer is
     * not found.
     */
    getLayerById(id: number): Layer | null;
    /**
     * Finds a layer inside this composition by its name. Null is returned, if nothing is found.
     *
     * @param {string} name - The name of the layer to find.
     * @returns {Layer|null} The layer corresponding to the specified name. Returns null if layer
     * is not found.
     */
    getLayerByName(name: string): Layer | null;
    _updateOpaqueOrder(startIndex: any, endIndex: any): void;
    _updateTransparentOrder(startIndex: any, endIndex: any): void;
    _sortLayersDescending(layersA: any, layersB: any, order: any): number;
    /**
     * Used to determine which array of layers has any transparent sublayer that is on top of all
     * the transparent sublayers in the other array.
     *
     * @param {number[]} layersA - IDs of layers.
     * @param {number[]} layersB - IDs of layers.
     * @returns {number} Returns a negative number if any of the transparent sublayers in layersA
     * is on top of all the transparent sublayers in layersB, or a positive number if any of the
     * transparent sublayers in layersB is on top of all the transparent sublayers in layersA, or 0
     * otherwise.
     * @private
     */
    private sortTransparentLayers;
    /**
     * Used to determine which array of layers has any opaque sublayer that is on top of all the
     * opaque sublayers in the other array.
     *
     * @param {number[]} layersA - IDs of layers.
     * @param {number[]} layersB - IDs of layers.
     * @returns {number} Returns a negative number if any of the opaque sublayers in layersA is on
     * top of all the opaque sublayers in layersB, or a positive number if any of the opaque
     * sublayers in layersB is on top of all the opaque sublayers in layersA, or 0 otherwise.
     * @private
     */
    private sortOpaqueLayers;
}

type Mat4$2 = Mat4$5;
/** @typedef {import('./mat4.js').Mat4} Mat4 */
/**
 * A 3x3 matrix.
 */
declare class Mat3 {
    /**
     * A constant matrix set to the identity.
     *
     * @type {Mat3}
     * @readonly
     */
    static readonly IDENTITY: Mat3;
    /**
     * A constant matrix with all elements set to 0.
     *
     * @type {Mat3}
     * @readonly
     */
    static readonly ZERO: Mat3;
    /**
     * Matrix elements in the form of a flat array.
     *
     * @type {Float32Array}
     */
    data: Float32Array;
    /**
     * Creates a duplicate of the specified matrix.
     *
     * @returns {Mat3} A duplicate matrix.
     * @example
     * var src = new pc.Mat3().translate(10, 20, 30);
     * var dst = src.clone();
     * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));
     */
    clone(): Mat3;
    /**
     * Copies the contents of a source 3x3 matrix to a destination 3x3 matrix.
     *
     * @param {Mat3} rhs - A 3x3 matrix to be copied.
     * @returns {Mat3} Self for chaining.
     * @example
     * var src = new pc.Mat3().translate(10, 20, 30);
     * var dst = new pc.Mat3();
     * dst.copy(src);
     * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));
     */
    copy(rhs: Mat3): Mat3;
    /**
     * Copies the contents of a source array[9] to a destination 3x3 matrix.
     *
     * @param {number[]} src - An array[9] to be copied.
     * @returns {Mat3} Self for chaining.
     * @example
     * var dst = new pc.Mat3();
     * dst.set([0, 1, 2, 3, 4, 5, 6, 7, 8]);
     */
    set(src: number[]): Mat3;
    /**
     * Reports whether two matrices are equal.
     *
     * @param {Mat3} rhs - The other matrix.
     * @returns {boolean} True if the matrices are equal and false otherwise.
     * @example
     * var a = new pc.Mat3().translate(10, 20, 30);
     * var b = new pc.Mat3();
     * console.log("The two matrices are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Mat3): boolean;
    /**
     * Reports whether the specified matrix is the identity matrix.
     *
     * @returns {boolean} True if the matrix is identity and false otherwise.
     * @example
     * var m = new pc.Mat3();
     * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
     */
    isIdentity(): boolean;
    /**
     * Sets the matrix to the identity matrix.
     *
     * @returns {Mat3} Self for chaining.
     * @example
     * m.setIdentity();
     * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
     */
    setIdentity(): Mat3;
    /**
     * Converts the matrix to string form.
     *
     * @returns {string} The matrix in string form.
     * @example
     * var m = new pc.Mat3();
     * // Outputs [1, 0, 0, 0, 1, 0, 0, 0, 1]
     * console.log(m.toString());
     */
    toString(): string;
    /**
     * Generates the transpose of the specified 3x3 matrix.
     *
     * @returns {Mat3} Self for chaining.
     * @example
     * var m = new pc.Mat3();
     *
     * // Transpose in place
     * m.transpose();
     */
    transpose(): Mat3;
    /**
     * Converts the specified 4x4 matrix to a Mat3.
     *
     * @param {Mat4} m - The 4x4 matrix to convert.
     * @returns {Mat3} Self for chaining.
     */
    setFromMat4(m: Mat4$2): Mat3;
    /**
     * Transforms a 3-dimensional vector by a 3x3 matrix.
     *
     * @param {Vec3} vec - The 3-dimensional vector to be transformed.
     * @param {Vec3} [res] - An optional 3-dimensional vector to receive the result of the
     * transformation.
     * @returns {Vec3} The input vector v transformed by the current instance.
     */
    transformVector(vec: Vec3$1, res?: Vec3$1): Vec3$1;
}

declare class LightingParams {
    constructor(supportsAreaLights: any, maxTextureSize: any, dirtyLightsFnc: any);
    _maxTextureSize: any;
    _supportsAreaLights: any;
    _dirtyLightsFnc: any;
    _areaLightsEnabled: boolean;
    _cells: Vec3$1;
    _maxLightsPerCell: number;
    _shadowsEnabled: boolean;
    _shadowType: number;
    _shadowAtlasResolution: number;
    _cookiesEnabled: boolean;
    _cookieAtlasResolution: number;
    atlasSplit: any;
    debugLayer: any;
    set cells(arg: Vec3$1);
    get cells(): Vec3$1;
    set maxLightsPerCell(arg: number);
    get maxLightsPerCell(): number;
    set cookieAtlasResolution(arg: number);
    get cookieAtlasResolution(): number;
    set shadowAtlasResolution(arg: number);
    get shadowAtlasResolution(): number;
    set shadowType(arg: number);
    get shadowType(): number;
    set cookiesEnabled(arg: boolean);
    get cookiesEnabled(): boolean;
    set areaLightsEnabled(arg: boolean);
    get areaLightsEnabled(): boolean;
    set shadowsEnabled(arg: boolean);
    get shadowsEnabled(): boolean;
}

type Texture$1 = Texture$8;
/** @typedef {import('../../graphics/texture.js').Texture} Texture */
/**
 * A BasicMaterial is for rendering unlit geometry, either using a constant color or a color map
 * modulated with a color.
 *
 * @augments Material
 */
declare class BasicMaterial extends Material$2 {
    /**
     * The flat color of the material (RGBA, where each component is 0 to 1).
     *
     * @type {Color}
     */
    color: Color$4;
    colorUniform: Float32Array;
    /**
     * The color map of the material (default is null). If specified, the color map is
     * modulated by the color property.
     *
     * @type {Texture|null}
     */
    colorMap: Texture$1 | null;
    vertexColors: boolean;
}

declare class Immediate {
    static getTextureVS(): string;
    constructor(device: any);
    device: any;
    quadMesh: Mesh$1;
    textureShader: Shader$4;
    depthTextureShader: Shader$4;
    cubeLocalPos: any;
    cubeWorldPos: any;
    batchesMap: Map<any, any>;
    allBatches: Set<any>;
    updatedLayers: Set<any>;
    _materialDepth: BasicMaterial;
    _materialNoDepth: BasicMaterial;
    layerMeshInstances: Map<any, any>;
    createMaterial(depthTest: any): BasicMaterial;
    get materialDepth(): BasicMaterial;
    get materialNoDepth(): BasicMaterial;
    getBatch(layer: any, depthTest: any): any;
    getTextureShader(): Shader$4;
    getDepthTextureShader(): Shader$4;
    getQuadMesh(): Mesh$1;
    drawMesh(material: any, matrix: any, mesh: any, meshInstance: any, layer: any): void;
    drawWireAlignedBox(min: any, max: any, color: any, depthTest: any, layer: any): void;
    drawWireSphere(center: any, radius: any, color: any, numSegments: any, depthTest: any, layer: any): void;
    getGraphNode(matrix: any): GraphNode$3;
    onPreRenderLayer(layer: any, visibleList: any, transparent: any): void;
    onPostRender(): void;
}

type Entity$9 = Entity$a;
type GraphicsDevice$b = GraphicsDevice$l;
type Texture = Texture$8;
/** @typedef {import('../framework/entity.js').Entity} Entity */
/** @typedef {import('../graphics/graphics-device.js').GraphicsDevice} GraphicsDevice */
/** @typedef {import('../graphics/texture.js').Texture} Texture */
/** @typedef {import('./composition/layer-composition.js').LayerComposition} LayerComposition */
/** @typedef {import('./layer.js').Layer} Layer */
/**
 * A scene is graphical representation of an environment. It manages the scene hierarchy, all
 * graphical objects, lights, and scene-wide properties.
 *
 * @augments EventHandler
 */
declare class Scene$3 extends EventHandler$1 {
    /**
     * Create a new Scene instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this scene.
     * @hideconstructor
     */
    constructor(graphicsDevice: GraphicsDevice$b);
    /**
     * If enabled, the ambient lighting will be baked into lightmaps. This will be either the
     * {@link Scene#skybox} if set up, otherwise {@link Scene#ambientLight}. Defaults to false.
     *
     * @type {boolean}
     */
    ambientBake: boolean;
    /**
     * If {@link Scene#ambientBake} is true, this specifies the brightness of ambient occlusion.
     * Typical range is -1 to 1. Defaults to 0, representing no change to brightness.
     *
     * @type {number}
     */
    ambientBakeOcclusionBrightness: number;
    /**
     * If {@link Scene#ambientBake} is true, this specifies the contrast of ambient occlusion.
     * Typical range is -1 to 1. Defaults to 0, representing no change to contrast.
     *
     * @type {number}
     */
    ambientBakeOcclusionContrast: number;
    /**
     * The color of the scene's ambient light. Defaults to black (0, 0, 0).
     *
     * @type {Color}
     */
    ambientLight: Color$4;
    /**
     * The exposure value tweaks the overall brightness of the scene. Defaults to 1.
     *
     * @type {number}
     */
    exposure: number;
    /**
     * The color of the fog (if enabled). Defaults to black (0, 0, 0).
     *
     * @type {Color}
     */
    fogColor: Color$4;
    /**
     * The density of the fog (if enabled). This property is only valid if the fog property is set
     * to {@link FOG_EXP} or {@link FOG_EXP2}. Defaults to 0.
     *
     * @type {number}
     */
    fogDensity: number;
    /**
     * The distance from the viewpoint where linear fog reaches its maximum. This property is only
     * valid if the fog property is set to {@link FOG_LINEAR}. Defaults to 1000.
     *
     * @type {number}
     */
    fogEnd: number;
    /**
     * The distance from the viewpoint where linear fog begins. This property is only valid if the
     * fog property is set to {@link FOG_LINEAR}. Defaults to 1.
     *
     * @type {number}
     */
    fogStart: number;
    /**
     * The lightmap resolution multiplier. Defaults to 1.
     *
     * @type {number}
     */
    lightmapSizeMultiplier: number;
    /**
     * The maximum lightmap resolution. Defaults to 2048.
     *
     * @type {number}
     */
    lightmapMaxResolution: number;
    /**
     * The lightmap baking mode. Can be:
     *
     * - {@link BAKE_COLOR}: single color lightmap
     * - {@link BAKE_COLORDIR}: single color lightmap + dominant light direction (used for bump or
     * specular). Only lights with bakeDir=true will be used for generating the dominant light
     * direction.
     *
     * Defaults to {@link BAKE_COLORDIR}.
     *
     * @type {number}
     */
    lightmapMode: number;
    /**
     * Enables bilateral filter on runtime baked color lightmaps, which removes the noise and
     * banding while preserving the edges. Defaults to false. Note that the filtering takes place
     * in the image space of the lightmap, and it does not filter across lightmap UV space seams,
     * often making the seams more visible. It's important to balance the strength of the filter
     * with number of samples used for lightmap baking to limit the visible artifacts.
     *
     * @type {boolean}
     */
    lightmapFilterEnabled: boolean;
    /**
     * The root entity of the scene, which is usually the only child to the {@link Application}
     * root entity.
     *
     * @type {Entity}
     */
    root: Entity$9;
    device: any;
    _gravity: Vec3$1;
    /**
     * @type {LayerComposition}
     * @private
     */
    private _layers;
    _fog: string;
    _gammaCorrection: number;
    _toneMapping: number;
    /**
     * The skybox cubemap as set by user (gets used when skyboxMip === 0)
     *
     * @type {Texture}
     * @private
     */
    private _skyboxCubeMap;
    /**
     * Array of 6 prefiltered lighting data cubemaps.
     *
     * @type {Texture[]}
     * @private
     */
    private _prefilteredCubemaps;
    /**
     * Environment lighting atlas
     *
     * @type {Texture}
     * @private
     */
    private _envAtlas;
    _internalEnvAtlas: any;
    skyboxModel: Model;
    _skyboxIntensity: number;
    _skyboxMip: number;
    _skyboxRotation: Quat$1;
    _skyboxRotationMat3: Mat3;
    _skyboxRotationMat4: Mat4$5;
    _ambientBakeNumSamples: number;
    _ambientBakeSpherePart: number;
    _lightmapFilterRange: number;
    _lightmapFilterSmoothness: number;
    _clusteredLightingEnabled: boolean;
    _lightingParams: LightingParams;
    _stats: {
        meshInstances: number;
        lights: number;
        dynamicLights: number;
        bakedLights: number;
        lastStaticPrepareFullTime: number;
        lastStaticPrepareSearchTime: number;
        lastStaticPrepareWriteTime: number;
        lastStaticPrepareTriAabbTime: number;
        lastStaticPrepareCombineTime: number;
        updateShadersTime: number;
    };
    /**
     * This flag indicates changes were made to the scene which may require recompilation of
     * shaders that reference global settings.
     *
     * @type {boolean}
     * @private
     */
    private updateShaders;
    _shaderVersion: number;
    _statsUpdated: boolean;
    _models: any[];
    immediate: Immediate;
    /**
     * Returns the default layer used by the immediate drawing functions.
     *
     * @type {Layer}
     * @private
     */
    private get defaultDrawLayer();
    /**
     * If {@link Scene#ambientBake} is true, this specifies the number of samples used to bake the
     * ambient light into the lightmap. Defaults to 1. Maximum value is 255.
     *
     * @type {number}
     */
    set ambientBakeNumSamples(arg: number);
    get ambientBakeNumSamples(): number;
    /**
     * If {@link Scene#ambientBake} is true, this specifies a part of the sphere which represents
     * the source of ambient light. The valid range is 0..1, representing a part of the sphere from
     * top to the bottom. A value of 0.5 represents the upper hemisphere. A value of 1 represents a
     * full sphere. Defaults to 0.4, which is a smaller upper hemisphere as this requires fewer
     * samples to bake.
     *
     * @type {number}
     */
    set ambientBakeSpherePart(arg: number);
    get ambientBakeSpherePart(): number;
    set clusteredLightingEnabled(arg: boolean);
    get clusteredLightingEnabled(): boolean;
    /**
     * List of all active composition mesh instances. Only for backwards compatibility.
     * TODO: BatchManager is using it - perhaps that could be refactored
     *
     * @type {MeshInstance[]}
     * @private
     */
    private set drawCalls(arg);
    private get drawCalls();
    /**
     * The environment lighting atlas.
     *
     * @type {Texture}
     */
    set envAtlas(arg: Texture$8);
    get envAtlas(): Texture$8;
    /**
     * The type of fog used by the scene. Can be:
     *
     * - {@link FOG_NONE}
     * - {@link FOG_LINEAR}
     * - {@link FOG_EXP}
     * - {@link FOG_EXP2}
     *
     * Defaults to {@link FOG_NONE}.
     *
     * @type {string}
     */
    set fog(arg: string);
    get fog(): string;
    /**
     * The gamma correction to apply when rendering the scene. Can be:
     *
     * - {@link GAMMA_NONE}
     * - {@link GAMMA_SRGB}
     *
     * Defaults to {@link GAMMA_SRGB}.
     *
     * @type {number}
     */
    set gammaCorrection(arg: number);
    get gammaCorrection(): number;
    /**
     * A {@link LayerComposition} that defines rendering order of this scene.
     *
     * @type {LayerComposition}
     */
    set layers(arg: LayerComposition);
    get layers(): LayerComposition;
    get lighting(): LightingParams;
    /**
     * A range parameter of the bilateral filter. It's used when {@link Scene#lightmapFilterEnabled}
     * is enabled. Larger value applies more widespread blur. This needs to be a positive non-zero
     * value. Defaults to 10.
     *
     * @type {number}
     */
    set lightmapFilterRange(arg: number);
    get lightmapFilterRange(): number;
    /**
     * A spatial parameter of the bilateral filter. It's used when {@link Scene#lightmapFilterEnabled}
     * is enabled. Larger value blurs less similar colors. This needs to be a positive non-zero
     * value. Defaults to 0.2.
     *
     * @type {number}
     */
    set lightmapFilterSmoothness(arg: number);
    get lightmapFilterSmoothness(): number;
    /**
     * Set of 6 prefiltered cubemaps.
     *
     * @type {Texture[]}
     */
    set prefilteredCubemaps(arg: Texture$8[]);
    get prefilteredCubemaps(): Texture$8[];
    /**
     * The base cubemap texture used as the scene's skybox, if mip level is 0. Defaults to null.
     *
     * @type {Texture}
     */
    set skybox(arg: Texture$8);
    get skybox(): Texture$8;
    /**
     * Multiplier for skybox intensity. Defaults to 1.
     *
     * @type {number}
     */
    set skyboxIntensity(arg: number);
    get skyboxIntensity(): number;
    /**
     * The mip level of the skybox to be displayed. Only valid for prefiltered cubemap skyboxes.
     * Defaults to 0 (base level).
     *
     * @type {number}
     */
    set skyboxMip(arg: number);
    get skyboxMip(): number;
    /**
     * The rotation of the skybox to be displayed. Defaults to {@link Quat.IDENTITY}.
     *
     * @type {Quat}
     */
    set skyboxRotation(arg: Quat$1);
    get skyboxRotation(): Quat$1;
    /**
     * The tonemapping transform to apply when writing fragments to the frame buffer. Can be:
     *
     * - {@link TONEMAP_LINEAR}
     * - {@link TONEMAP_FILMIC}
     * - {@link TONEMAP_HEJL}
     * - {@link TONEMAP_ACES}
     *
     * Defaults to {@link TONEMAP_LINEAR}.
     *
     * @type {number}
     */
    set toneMapping(arg: number);
    get toneMapping(): number;
    destroy(): void;
    drawLine(start: any, end: any, color?: Color$4, depthTest?: boolean, layer?: Layer$1): void;
    drawLines(positions: any, colors: any, depthTest?: boolean, layer?: Layer$1): void;
    drawLineArrays(positions: any, colors: any, depthTest?: boolean, layer?: Layer$1): void;
    applySettings(settings: any): void;
    _getSkyboxTex(): Texture$8;
    _updateSkybox(device: any): void;
    skyLayer: Layer$1;
    _resetSkyboxModel(): void;
    /**
     * Sets the cubemap for the scene skybox.
     *
     * @param {Texture[]} [cubemaps] - An array of cubemaps corresponding to the skybox at
     * different mip levels. If undefined, scene will remove skybox. Cubemap array should be of
     * size 7, with the first element (index 0) corresponding to the base cubemap (mip level 0)
     * with original resolution. Each remaining element (index 1-6) corresponds to a fixed
     * prefiltered resolution (128x128, 64x64, 32x32, 16x16, 8x8, 4x4).
     */
    setSkybox(cubemaps?: Texture[]): void;
    addModel(model: any): void;
    addShadowCaster(model: any): void;
    removeModel(model: any): void;
    removeShadowCasters(model: any): void;
    containsModel(model: any): boolean;
    getModels(model: any): any[];
}

type Asset$1 = Asset$6;
type AssetRegistry$7 = AssetRegistry$c;
/** @typedef {import('../asset/asset.js').Asset} Asset */
/** @typedef {import('../asset/asset-registry.js').AssetRegistry} AssetRegistry */
/**
 * Keeps track of which assets are in bundles and loads files from bundles.
 *
 * @ignore
 */
declare class BundleRegistry {
    /**
     * Create a new BundleRegistry instance.
     *
     * @param {AssetRegistry} assets - The asset registry.
     */
    constructor(assets: AssetRegistry$7);
    _assets: AssetRegistry$c;
    _bundleAssets: {};
    _assetsInBundles: {};
    _urlsInBundles: {};
    _fileRequests: {};
    _onAssetAdded(asset: any): void;
    _registerBundleEventListeners(bundleAssetId: any): void;
    _unregisterBundleEventListeners(bundleAssetId: any): void;
    _indexAssetInBundle(assetId: any, bundleAsset: any): void;
    _indexAssetFileUrls(asset: any): void;
    _getAssetFileUrls(asset: any): any[];
    _normalizeUrl(url: any): any;
    _onAssetRemoved(asset: any): void;
    _onBundleLoaded(bundleAsset: any): void;
    _onBundleError(err: any, bundleAsset: any): void;
    _findLoadedOrLoadingBundleForUrl(url: any): any;
    /**
     * Lists all of the available bundles that reference the specified asset id.
     *
     * @param {Asset} asset - The asset.
     * @returns {Asset[]} An array of bundle assets or null if the asset is not in any bundle.
     */
    listBundlesForAsset(asset: Asset$1): Asset$1[];
    /**
     * Lists all of the available bundles. This includes bundles that are not loaded.
     *
     * @returns {Asset[]} An array of bundle assets.
     */
    list(): Asset$1[];
    /**
     * Returns true if there is a bundle that contains the specified URL.
     *
     * @param {string} url - The url.
     * @returns {boolean} True or false.
     */
    hasUrl(url: string): boolean;
    /**
     * Returns true if there is a bundle that contains the specified URL and that bundle is either
     * loaded or currently being loaded.
     *
     * @param {string} url - The url.
     * @returns {boolean} True or false.
     */
    canLoadUrl(url: string): boolean;
    /**
     * Loads the specified file URL from a bundle that is either loaded or currently being loaded.
     *
     * @param {string} url - The URL. Make sure you are using a relative URL that does not contain
     * any query parameters.
     * @param {Function} callback - The callback is called when the file has been loaded or if an
     * error occurs. The callback expects the first argument to be the error message (if any) and
     * the second argument is the file blob URL.
     * @example
     * var url = asset.getFileUrl().split('?')[0]; // get normalized asset URL
     * this.app.bundles.loadFile(url, function (err, blobUrl) {
     *     // do something with the blob URL
     * });
     */
    loadUrl(url: string, callback: Function): void;
    /**
     * Destroys the registry, and releases its resources. Does not unload bundle assets as these
     * should be unloaded by the {@link AssetRegistry}.
     */
    destroy(): void;
}

type Application$c = Application$7;
/** @typedef {import('../framework/application.js').Application} Application */
/**
 * Container for all {@link ScriptType}s that are available to this application. Note that
 * PlayCanvas scripts can access the Script Registry from inside the application with
 * {@link Application#scripts}.
 *
 * @augments EventHandler
 */
declare class ScriptRegistry extends EventHandler$1 {
    /**
     * Create a new ScriptRegistry instance.
     *
     * @param {Application} app - Application to attach registry to.
     */
    constructor(app: Application$c);
    app: Application$7;
    _scripts: {};
    _list: any[];
    destroy(): void;
    /**
     * Add {@link ScriptType} to registry. Note: when {@link createScript} is called, it will add
     * the {@link ScriptType} to the registry automatically. If a script already exists in
     * registry, and the new script has a `swap` method defined, it will perform code hot swapping
     * automatically in async manner.
     *
     * @param {typeof ScriptType} script - Script Type that is created using {@link createScript}.
     * @returns {boolean} True if added for the first time or false if script already exists.
     * @example
     * var PlayerController = pc.createScript('playerController');
     * // playerController Script Type will be added to pc.ScriptRegistry automatically
     * console.log(app.scripts.has('playerController')); // outputs true
     */
    add(script: typeof ScriptType): boolean;
    /**
     * Remove {@link ScriptType}.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @returns {boolean} True if removed or False if already not in registry.
     * @example
     * app.scripts.remove('playerController');
     */
    remove(nameOrType: string | typeof ScriptType): boolean;
    /**
     * Get {@link ScriptType} by name.
     *
     * @param {string} name - Name of a {@link ScriptType}.
     * @returns {typeof ScriptType} The Script Type if it exists in the registry or null otherwise.
     * @example
     * var PlayerController = app.scripts.get('playerController');
     */
    get(name: string): typeof ScriptType;
    /**
     * Check if a {@link ScriptType} with the specified name is in the registry.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @returns {boolean} True if {@link ScriptType} is in registry.
     * @example
     * if (app.scripts.has('playerController')) {
     *     // playerController is in pc.ScriptRegistry
     * }
     */
    has(nameOrType: string | typeof ScriptType): boolean;
    /**
     * Get list of all {@link ScriptType}s from registry.
     *
     * @returns {Array<typeof ScriptType>} list of all {@link ScriptType}s in registry.
     * @example
     * // logs array of all Script Type names available in registry
     * console.log(app.scripts.list().map(function (o) {
     *     return o.name;
     * }));
     */
    list(): Array<typeof ScriptType>;
}

declare class I18nParser {
    _validate(data: any): void;
    parse(data: any): any;
}

type Application$b = Application$7;
/**
 * Handles localization. Responsible for loading localization assets and returning translations for
 * a certain key. Can also handle plural forms. To override its default behavior define a different
 * implementation for {@link I18n#getText} and {@link I18n#getPluralText}.
 *
 * @augments EventHandler
 */
declare class I18n extends EventHandler$1 {
    /**
     * Returns the first available locale based on the desired locale specified. First tries to
     * find the desired locale and then tries to find an alternative locale based on the language.
     *
     * @param {string} desiredLocale - The desired locale e.g. en-US.
     * @param {object} availableLocales - A dictionary where each key is an available locale.
     * @returns {string} The locale found or if no locale is available returns the default en-US
     * locale.
     * @example
     * // With a defined dictionary of locales
     * var availableLocales = { en: 'en-US', fr: 'fr-FR' };
     * var locale = pc.I18n.getText('en-US', availableLocales);
     * // returns 'en'
     * @ignore
     */
    static findAvailableLocale(desiredLocale: string, availableLocales: object): string;
    /**
     * Create a new I18n instance.
     *
     * @param {Application} app - The application.
     */
    constructor(app: Application$b);
    /**
     * The current locale for example "en-US". Changing the locale will raise an event which will
     * cause localized Text Elements to change language to the new locale.
     *
     * @type {string}
     */
    set locale(arg: any);
    get locale(): any;
    _translations: {};
    _availableLangs: {};
    _app: Application$7;
    _assets: any[];
    _parser: I18nParser;
    /**
     * An array of asset ids or assets that contain localization data in the expected format. I18n
     * will automatically load translations from these assets as the assets are loaded and it will
     * also automatically unload translations if the assets get removed or unloaded at runtime.
     *
     * @type {number[]|Asset[]}
     */
    set assets(arg: any[]);
    get assets(): any[];
    _locale: any;
    _lang: any;
    _pluralFn: any;
    /**
     * Returns the first available locale based on the desired locale specified. First tries to
     * find the desired locale in the loaded translations and then tries to find an alternative
     * locale based on the language.
     *
     * @param {string} desiredLocale - The desired locale e.g. en-US.
     * @returns {string} The locale found or if no locale is available returns the default en-US
     * locale.
     * @example
     * var locale = this.app.i18n.getText('en-US');
     */
    findAvailableLocale(desiredLocale: string): string;
    /**
     * Returns the translation for the specified key and locale. If the locale is not specified it
     * will use the current locale.
     *
     * @param {string} key - The localization key.
     * @param {string} [locale] - The desired locale.
     * @returns {string} The translated text. If no translations are found at all for the locale
     * then it will return the en-US translation. If no translation exists for that key then it will
     * return the localization key.
     * @example
     * var localized = this.app.i18n.getText('localization-key');
     * var localizedFrench = this.app.i18n.getText('localization-key', 'fr-FR');
     */
    getText(key: string, locale?: string): string;
    /**
     * Returns the pluralized translation for the specified key, number n and locale. If the locale
     * is not specified it will use the current locale.
     *
     * @param {string} key - The localization key.
     * @param {number} n - The number used to determine which plural form to use. E.g. For the
     * phrase "5 Apples" n equals 5.
     * @param {string} [locale] - The desired locale.
     * @returns {string} The translated text. If no translations are found at all for the locale
     * then it will return the en-US translation. If no translation exists for that key then it
     * will return the localization key.
     * @example
     * // manually replace {number} in the resulting translation with our number
     * var localized = this.app.i18n.getPluralText('{number} apples', number).replace("{number}", number);
     */
    getPluralText(key: string, n: number, locale?: string): string;
    /**
     * Adds localization data. If the locale and key for a translation already exists it will be
     * overwritten.
     *
     * @param {object} data - The localization data. See example for the expected format of the
     * data.
     * @example
     * this.app.i18n.addData({
     *     header: {
     *         version: 1
     *     },
     *     data: [{
     *         info: {
     *             locale: 'en-US'
     *         },
     *         messages: {
     *             "key": "translation",
     *             // The number of plural forms depends on the locale. See the manual for more information.
     *             "plural_key": ["one item", "more than one items"]
     *         }
     *     }, {
     *         info: {
     *             locale: 'fr-FR'
     *         },
     *         messages: {
     *             // ...
     *         }
     *     }]
     * });
     */
    addData(data: object): void;
    /**
     * Removes localization data.
     *
     * @param {object} data - The localization data. The data is expected to be in the same format
     * as {@link I18n#addData}.
     */
    removeData(data: object): void;
    /**
     * Frees up memory.
     */
    destroy(): void;
    _findFallbackLocale(locale: any, lang: any): any;
    _onAssetAdd(asset: any): void;
    _onAssetLoad(asset: any): void;
    _onAssetChange(asset: any): void;
    _onAssetRemove(asset: any): void;
    _onAssetUnload(asset: any): void;
}

/**
 * Item to be stored in the {@link SceneRegistry}.
 */
declare class SceneRegistryItem {
    /**
     * Creates a new SceneRegistryItem instance.
     *
     * @param {string} name - The name of the scene.
     * @param {string} url - The url of the scene file.
     */
    constructor(name: string, url: string);
    /**
     * The name of the scene.
     *
     * @type {string}
     */
    name: string;
    /**
     * The url of the scene file.
     *
     * @type {string}
     */
    url: string;
    data: any;
    _loading: boolean;
    _onLoadedCallbacks: any[];
    /**
     * Returns true if the scene data has loaded.
     *
     * @type {boolean}
     */
    get loaded(): boolean;
    /**
     * Returns true if the scene data is still being loaded.
     *
     * @type {boolean}
     */
    get loading(): boolean;
}

type Application$a = Application$7;
type Entity$8 = Entity$a;
/**
 * Callback used by {@link SceneRegistryloadSceneHierarchy }.
 */
type loadHierarchyCallback = (err: string | null, entity?: Entity$8) => any;
/**
 * Callback used by {@link SceneRegistryloadSceneSettings }.
 */
type loadSettingsCallback = (err: string | null) => any;
/**
 * Callback used by {@link SceneRegistryloadScene }.
 */
type loadSceneCallback = (err: string | null, entity?: Entity$8) => any;
/**
 * Callback used by {@link SceneRegistryloadSceneData }.
 */
type loadSceneDataCallback = (err: string | null, sceneItem?: SceneRegistryItem) => any;
/** @typedef {import('./application.js').Application} Application */
/** @typedef {import('./entity.js').Entity} Entity */
/**
 * Callback used by {@link SceneRegistry#loadSceneHierarchy}.
 *
 * @callback loadHierarchyCallback
 * @param {string|null} err - The error message in the case where the loading or parsing fails.
 * @param {Entity} [entity] - The loaded root entity if no errors were encountered.
 */
/**
 * Callback used by {@link SceneRegistry#loadSceneSettings}.
 *
 * @callback loadSettingsCallback
 * @param {string|null} err - The error message in the case where the loading or parsing fails.
 */
/**
 * Callback used by {@link SceneRegistry#loadScene}.
 *
 * @callback loadSceneCallback
 * @param {string|null} err - The error message in the case where the loading or parsing fails.
 * @param {Entity} [entity] - The loaded root entity if no errors were encountered.
 */
/**
 * Callback used by {@link SceneRegistry#loadSceneData}.
 *
 * @callback loadSceneDataCallback
 * @param {string|null} err - The error message in the case where the loading or parsing fails.
 * @param {SceneRegistryItem} [sceneItem] - The scene registry item if no errors were encountered.
 */
/**
 * Container for storing and loading of scenes. An instance of the registry is created on the
 * {@link Application} object as {@link Application#scenes}.
 */
declare class SceneRegistry {
    /**
     * Create a new SceneRegistry instance.
     *
     * @param {Application} app - The application.
     */
    constructor(app: Application$a);
    _app: Application$7;
    _list: any[];
    _index: {};
    _urlIndex: {};
    destroy(): void;
    /**
     * Return the list of scene.
     *
     * @returns {SceneRegistryItem[]} All items in the registry.
     */
    list(): SceneRegistryItem[];
    /**
     * Add a new item to the scene registry.
     *
     * @param {string} name - The name of the scene.
     * @param {string} url -  The url of the scene file.
     * @returns {boolean} Returns true if the scene was successfully added to the registry, false otherwise.
     */
    add(name: string, url: string): boolean;
    /**
     * Find a Scene by name and return the {@link SceneRegistryItem}.
     *
     * @param {string} name - The name of the scene.
     * @returns {SceneRegistryItem|null} The stored data about a scene or null if no scene with
     * that name exists.
     */
    find(name: string): SceneRegistryItem | null;
    /**
     * Find a scene by the URL and return the {@link SceneRegistryItem}.
     *
     * @param {string} url - The URL to search by.
     * @returns {SceneRegistryItem|null} The stored data about a scene or null if no scene with
     * that URL exists.
     */
    findByUrl(url: string): SceneRegistryItem | null;
    /**
     * Remove an item from the scene registry.
     *
     * @param {string} name - The name of the scene.
     */
    remove(name: string): void;
    _loadSceneData(sceneItem: any, storeInCache: any, callback: any): void;
    /**
     * Loads and stores the scene data to reduce the number of the network requests when the same
     * scenes are loaded multiple times. Can also be used to load data before calling
     * {@link SceneRegistry#loadSceneHierarchy} and {@link SceneRegistry#loadSceneSettings} to make
     * scene loading quicker for the user.
     *
     * @param {SceneRegistryItem | string} sceneItem - The scene item (which can be found with
     * {@link SceneRegistry#find} or URL of the scene file. Usually this will be "scene_id.json".
     * @param {loadSceneDataCallback} callback - The function to call after loading,
     * passed (err, sceneItem) where err is null if no errors occurred.
     * @example
     * var sceneItem = app.scenes.find("Scene Name");
     * app.scenes.loadSceneData(sceneItem, function (err, sceneItem) {
     *     if (err) {
     *         // error
     *     }
     * });
     */
    loadSceneData(sceneItem: SceneRegistryItem | string, callback: loadSceneDataCallback): void;
    /**
     * Unloads scene data that has been loaded previously using {@link SceneRegistry#loadSceneData}.
     *
     * @param {SceneRegistryItem | string} sceneItem - The scene item (which can be found with
     * {@link SceneRegistry#find} or URL of the scene file. Usually this will be "scene_id.json".
     * @example
     * var sceneItem = app.scenes.find("Scene Name");
     * app.scenes.unloadSceneData(sceneItem);
     */
    unloadSceneData(sceneItem: SceneRegistryItem | string): void;
    /**
     * Load a scene file, create and initialize the Entity hierarchy and add the hierarchy to the
     * application root Entity.
     *
     * @param {SceneRegistryItem | string} sceneItem - The scene item (which can be found with
     * {@link SceneRegistry#find} or URL of the scene file. Usually this will be "scene_id.json".
     * @param {loadHierarchyCallback} callback - The function to call after loading,
     * passed (err, entity) where err is null if no errors occurred.
     * @example
     * var sceneItem = app.scenes.find("Scene Name");
     * app.scenes.loadSceneHierarchy(sceneItem, function (err, entity) {
     *     if (!err) {
     *         var e = app.root.find("My New Entity");
     *     } else {
     *         // error
     *     }
     * });
     */
    loadSceneHierarchy(sceneItem: SceneRegistryItem | string, callback: loadHierarchyCallback): void;
    /**
     * Load a scene file and apply the scene settings to the current scene.
     *
     * @param {SceneRegistryItem | string} sceneItem - The scene item (which can be found with
     * {@link SceneRegistry#find} or URL of the scene file. Usually this will be "scene_id.json".
     * @param {loadSettingsCallback} callback - The function called after the settings
     * are applied. Passed (err) where err is null if no error occurred.
     * @example
     * var sceneItem = app.scenes.find("Scene Name");
     * app.scenes.loadSceneHierarchy(sceneItem, function (err, entity) {
     *     if (!err) {
     *         var e = app.root.find("My New Entity");
     *     } else {
     *         // error
     *     }
     * });
     */
    loadSceneSettings(sceneItem: SceneRegistryItem | string, callback: loadSettingsCallback): void;
    /**
     * Load the scene hierarchy and scene settings. This is an internal method used by the
     * {@link Application}.
     *
     * @param {string} url - The URL of the scene file.
     * @param {loadSceneCallback} callback - The function called after the settings are
     * applied. Passed (err, scene) where err is null if no error occurred and scene is the
     * {@link Scene}.
     */
    loadScene(url: string, callback: loadSceneCallback): void;
}

declare class SceneDepth {
    constructor(application: any);
    application: any;
    device: any;
    clearOptions: {
        flags: number;
        color?: undefined;
        depth?: undefined;
    } | {
        color: number[];
        depth: number;
        flags: number;
    };
    layer: Layer$1;
    allocateTexture(device: any, name: any, format: any): Texture$8;
    allocateRenderTarget(renderTarget: any, device: any, name: any, format: any, isDepth: any): any;
    releaseRenderTarget(rt: any): void;
    initWebGl2(): void;
    initWebGl1(): void;
    init(): void;
    patch(layer: any): void;
}

declare class ShadowMapCache {
    shadowMapCache: Map<any, any>;
    destroy(): void;
    clear(): void;
    getKey(light: any): string;
    get(device: any, light: any): any;
    add(light: any, shadowMap: any): void;
}

declare class ShadowMap {
    static getShadowFormat(device: any, shadowType: any): number;
    static getShadowFiltering(device: any, shadowType: any): number;
    static create(device: any, light: any): ShadowMap;
    static createAtlas(device: any, resolution: any, shadowType: any): ShadowMap;
    static create2dMap(device: any, size: any, shadowType: any): ShadowMap;
    static createCubemap(device: any, size: any): ShadowMap;
    constructor(texture: any, targets: any);
    texture: any;
    cached: boolean;
    renderTargets: any;
    destroy(): void;
}

declare class LightTextureAtlas {
    constructor(device: any);
    device: any;
    version: number;
    shadowAtlasResolution: number;
    shadowAtlas: ShadowMap;
    shadowEdgePixels: number;
    cookieAtlasResolution: number;
    cookieAtlas: Texture$8;
    cookieRenderTarget: RenderTarget$3;
    slots: any[];
    atlasSplit: any[];
    cubeSlotsOffsets: Vec2$3[];
    scissorVec: Vec4$6;
    destroy(): void;
    destroyShadowAtlas(): void;
    destroyCookieAtlas(): void;
    allocateShadowAtlas(resolution: any): void;
    allocateCookieAtlas(resolution: any): void;
    allocateUniforms(): void;
    _shadowAtlasTextureId: any;
    _shadowAtlasParamsId: any;
    _shadowAtlasParams: Float32Array;
    _cookieAtlasTextureId: any;
    updateUniforms(): void;
    subdivide(numLights: any, lightingParams: any): void;
    collectLights(spotLights: any, omniLights: any, lightingParams: any): any[];
    setupSlot(light: any, rect: any): void;
    assignSlot(light: any, slotIndex: any, slotReassigned: any): void;
    update(spotLights: any, omniLights: any, lightingParams: any): void;
}

type Mat4$1 = Mat4$5;
type BoundingSphere = BoundingSphere$2;
/**
 * A frustum is a shape that defines the viewing space of a camera. It can be used to determine
 * visibility of points and bounding spheres. Typically, you would not create a Frustum shape
 * directly, but instead query {@link CameraComponent#frustum}.
 */
declare class Frustum {
    static getPoints(camera: any, near: any, far: any): Vec3$1[];
    planes: any[][];
    /**
     * Updates the frustum shape based on the supplied 4x4 matrix.
     *
     * @param {Mat4} matrix - The matrix describing the shape of the frustum.
     * @example
     * // Create a perspective projection matrix
     * var projMat = pc.Mat4();
     * projMat.setPerspective(45, 16 / 9, 1, 1000);
     *
     * // Create a frustum shape that is represented by the matrix
     * var frustum = new pc.Frustum();
     * frustum.setFromMat4(projMat);
     */
    setFromMat4(matrix: Mat4$1): void;
    /**
     * Tests whether a point is inside the frustum. Note that points lying in a frustum plane are
     * considered to be outside the frustum.
     *
     * @param {Vec3} point - The point to test.
     * @returns {boolean} True if the point is inside the frustum, false otherwise.
     */
    containsPoint(point: Vec3$1): boolean;
    /**
     * Tests whether a bounding sphere intersects the frustum. If the sphere is outside the
     * frustum, zero is returned. If the sphere intersects the frustum, 1 is returned. If the
     * sphere is completely inside the frustum, 2 is returned. Note that a sphere touching a
     * frustum plane from the outside is considered to be outside the frustum.
     *
     * @param {BoundingSphere} sphere - The sphere to test.
     * @returns {number} 0 if the bounding sphere is outside the frustum, 1 if it intersects the
     * frustum and 2 if it is contained by the frustum.
     */
    containsSphere(sphere: BoundingSphere): number;
}

/**
 * A camera.
 *
 * @ignore
 */
declare class Camera {
    _aspectRatio: number;
    _aspectRatioMode: number;
    _calculateProjection: any;
    _calculateTransform: any;
    _clearColor: Color$4;
    _clearColorBuffer: boolean;
    _clearDepth: number;
    _clearDepthBuffer: boolean;
    _clearStencil: number;
    _clearStencilBuffer: boolean;
    _cullingMask: number;
    _cullFaces: boolean;
    _farClip: number;
    _flipFaces: boolean;
    _fov: number;
    _frustumCulling: boolean;
    _horizontalFov: boolean;
    _layers: number[];
    _nearClip: number;
    _node: any;
    _orthoHeight: number;
    _projection: number;
    _rect: Vec4$6;
    _renderTarget: any;
    _scissorRect: Vec4$6;
    _scissorRectClear: boolean;
    _vrDisplay: any;
    _projMat: Mat4$5;
    _projMatDirty: boolean;
    _projMatSkybox: Mat4$5;
    _viewMat: Mat4$5;
    _viewMatDirty: boolean;
    _viewProjMat: Mat4$5;
    _viewProjMatDirty: boolean;
    frustum: Frustum;
    set aspectRatio(arg: number);
    get aspectRatio(): number;
    set aspectRatioMode(arg: number);
    get aspectRatioMode(): number;
    set calculateProjection(arg: any);
    get calculateProjection(): any;
    set calculateTransform(arg: any);
    get calculateTransform(): any;
    set clearColor(arg: Color$4);
    get clearColor(): Color$4;
    set clearColorBuffer(arg: boolean);
    get clearColorBuffer(): boolean;
    set clearDepth(arg: number);
    get clearDepth(): number;
    set clearDepthBuffer(arg: boolean);
    get clearDepthBuffer(): boolean;
    set clearStencil(arg: number);
    get clearStencil(): number;
    set clearStencilBuffer(arg: boolean);
    get clearStencilBuffer(): boolean;
    set cullingMask(arg: number);
    get cullingMask(): number;
    set cullFaces(arg: boolean);
    get cullFaces(): boolean;
    set farClip(arg: number);
    get farClip(): number;
    set flipFaces(arg: boolean);
    get flipFaces(): boolean;
    set fov(arg: number);
    get fov(): number;
    set frustumCulling(arg: boolean);
    get frustumCulling(): boolean;
    set horizontalFov(arg: boolean);
    get horizontalFov(): boolean;
    set layers(arg: number[]);
    get layers(): number[];
    set nearClip(arg: number);
    get nearClip(): number;
    set node(arg: any);
    get node(): any;
    set orthoHeight(arg: number);
    get orthoHeight(): number;
    set projection(arg: number);
    get projection(): number;
    get projectionMatrix(): Mat4$5;
    set rect(arg: Vec4$6);
    get rect(): Vec4$6;
    set renderTarget(arg: any);
    get renderTarget(): any;
    set scissorRect(arg: Vec4$6);
    get scissorRect(): Vec4$6;
    get viewMatrix(): Mat4$5;
    set vrDisplay(arg: any);
    get vrDisplay(): any;
    /**
     * Creates a duplicate of the camera.
     *
     * @returns {Camera} A cloned Camera.
     */
    clone(): Camera;
    /**
     * Copies one camera to another.
     *
     * @param {Camera} other - Camera to copy.
     * @returns {Camera} Self for chaining.
     */
    copy(other: Camera): Camera;
    _updateViewProjMat(): void;
    /**
     * Convert a point from 3D world space to 2D canvas pixel space.
     *
     * @param {Vec3} worldCoord - The world space coordinate to transform.
     * @param {number} cw - The width of PlayCanvas' canvas element.
     * @param {number} ch - The height of PlayCanvas' canvas element.
     * @param {Vec3} [screenCoord] - 3D vector to receive screen coordinate result.
     * @returns {Vec3} The screen space coordinate.
     */
    worldToScreen(worldCoord: Vec3$1, cw: number, ch: number, screenCoord?: Vec3$1): Vec3$1;
    /**
     * Convert a point from 2D canvas pixel space to 3D world space.
     *
     * @param {number} x - X coordinate on PlayCanvas' canvas element.
     * @param {number} y - Y coordinate on PlayCanvas' canvas element.
     * @param {number} z - The distance from the camera in world space to create the new point.
     * @param {number} cw - The width of PlayCanvas' canvas element.
     * @param {number} ch - The height of PlayCanvas' canvas element.
     * @param {Vec3} [worldCoord] - 3D vector to receive world coordinate result.
     * @returns {Vec3} The world space coordinate.
     */
    screenToWorld(x: number, y: number, z: number, cw: number, ch: number, worldCoord?: Vec3$1): Vec3$1;
    _evaluateProjectionMatrix(): void;
    getProjectionMatrixSkybox(): Mat4$5;
    getScreenSize(sphere: any): number;
}

declare class ShadowRenderer {
    static createShadowCamera(device: any, shadowType: any, type: any, face: any): Camera;
    static setShadowCameraSettings(shadowCam: any, device: any, shadowType: any, type: any, isClustered: any): void;
    constructor(forwardRenderer: any, lightTextureAtlas: any);
    device: any;
    forwardRenderer: any;
    lightTextureAtlas: any;
    polygonOffsetId: any;
    polygonOffset: Float32Array;
    sourceId: any;
    pixelOffsetId: any;
    weightId: any;
    blurVsmShaderCode: any[];
    blurPackedVsmShaderCode: string[];
    blurVsmShader: {}[];
    blurPackedVsmShader: {}[];
    blurVsmWeights: {};
    shadowMapLightRadiusId: any;
    shadowMapCache: ShadowMapCache;
    destroy(): void;
    cullShadowCasters(meshInstances: any, visible: any, camera: any): void;
    cullLocal(light: any, drawCalls: any): void;
    generateSplitDistances(light: any, nearDist: any, farDist: any): void;
    cullDirectional(light: any, drawCalls: any, camera: any): void;
    setupRenderState(device: any, light: any): void;
    restoreRenderState(device: any): void;
    dispatchUniforms(light: any, shadowCam: any, lightRenderData: any, face: any): void;
    submitCasters(visibleCasters: any, light: any): void;
    render(light: any, camera: any): void;
    getVsmBlurShader(isVsm8: any, blurMode: any, filterSize: any): any;
    applyVsmBlur(light: any, camera: any): void;
}

declare class CookieRenderer {
    static createTexture(device: any, resolution: any): Texture$8;
    static _invViewProjMatrices: any;
    constructor(device: any, lightTextureAtlas: any);
    device: any;
    lightTextureAtlas: any;
    blitShader2d: any;
    blitShaderCube: any;
    blitTextureId: any;
    invViewProjId: any;
    destroy(): void;
    getShader(shader: any, fragment: any): any;
    get shader2d(): any;
    get shaderCube(): any;
    initInvViewProjMatrices(): void;
    render(light: any, renderTarget: any): void;
}

type GraphicsDevice$a = GraphicsDevice$l;
/**
 * The forward renderer renders {@link Scene}s.
 */
declare class ForwardRenderer$1 {
    static skipRenderCamera: any;
    static _skipRenderCounter: number;
    static skipRenderAfter: number;
    /**
     * Create a new ForwardRenderer instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used by the renderer.
     * @hideconstructor
     */
    constructor(graphicsDevice: GraphicsDevice$a);
    device: GraphicsDevice$l;
    scene: any;
    _shadowDrawCalls: number;
    _forwardDrawCalls: number;
    _skinDrawCalls: number;
    _numDrawCallsCulled: number;
    _instancedDrawCalls: number;
    _camerasRendered: number;
    _materialSwitches: number;
    _shadowMapUpdates: number;
    _shadowMapTime: number;
    _depthMapTime: number;
    _forwardTime: number;
    _cullTime: number;
    _sortTime: number;
    _skinTime: number;
    _morphTime: number;
    _instancingTime: number;
    _removedByInstancing: number;
    _layerCompositionUpdateTime: number;
    _lightClustersTime: number;
    _lightClusters: number;
    library: ProgramLibrary;
    lightTextureAtlas: LightTextureAtlas;
    _shadowRenderer: ShadowRenderer;
    _cookieRenderer: CookieRenderer;
    projId: ScopeId$1;
    projSkyboxId: ScopeId$1;
    viewId: ScopeId$1;
    viewId3: ScopeId$1;
    viewInvId: ScopeId$1;
    viewProjId: ScopeId$1;
    viewPos: Float32Array;
    viewPosId: ScopeId$1;
    nearClipId: ScopeId$1;
    farClipId: ScopeId$1;
    cameraParamsId: ScopeId$1;
    tbnBasis: ScopeId$1;
    fogColorId: ScopeId$1;
    fogStartId: ScopeId$1;
    fogEndId: ScopeId$1;
    fogDensityId: ScopeId$1;
    modelMatrixId: ScopeId$1;
    normalMatrixId: ScopeId$1;
    poseMatrixId: ScopeId$1;
    boneTextureId: ScopeId$1;
    boneTextureSizeId: ScopeId$1;
    morphWeightsA: ScopeId$1;
    morphWeightsB: ScopeId$1;
    morphPositionTex: ScopeId$1;
    morphNormalTex: ScopeId$1;
    morphTexParams: ScopeId$1;
    alphaTestId: ScopeId$1;
    opacityMapId: ScopeId$1;
    ambientId: ScopeId$1;
    exposureId: ScopeId$1;
    skyboxIntensityId: ScopeId$1;
    lightColorId: any[];
    lightDir: any[];
    lightDirId: any[];
    lightShadowMapId: any[];
    lightShadowMatrixId: any[];
    lightShadowParamsId: any[];
    lightRadiusId: any[];
    lightPos: any[];
    lightPosId: any[];
    lightWidth: any[];
    lightWidthId: any[];
    lightHeight: any[];
    lightHeightId: any[];
    lightInAngleId: any[];
    lightOutAngleId: any[];
    lightCookieId: any[];
    lightCookieIntId: any[];
    lightCookieMatrixId: any[];
    lightCookieOffsetId: any[];
    shadowMatrixPaletteId: any[];
    shadowCascadeDistancesId: any[];
    shadowCascadeCountId: any[];
    depthMapId: ScopeId$1;
    screenSizeId: ScopeId$1;
    _screenSize: Float32Array;
    twoSidedLightingNegScaleFactorId: ScopeId$1;
    fogColor: Float32Array;
    ambientColor: Float32Array;
    cameraParams: Float32Array;
    destroy(): void;
    sortCompare(drawCallA: any, drawCallB: any): number;
    sortCompareMesh(drawCallA: any, drawCallB: any): number;
    depthSortCompare(drawCallA: any, drawCallB: any): number;
    updateCameraFrustum(camera: any): void;
    setCamera(camera: any, target: any, clear: any): void;
    clearView(camera: any, target: any, clear: any, forceWrite: any, options: any): void;
    dispatchGlobalLights(scene: any): void;
    _resolveLight(scope: any, i: any): void;
    setLTCDirectionallLight(wtm: any, cnt: any, dir: any, campos: any, far: any): void;
    dispatchDirectLights(dirs: any, scene: any, mask: any, camera: any): number;
    setLTCPositionalLight(wtm: any, cnt: any): void;
    dispatchOmniLight(scene: any, scope: any, omni: any, cnt: any): void;
    dispatchSpotLight(scene: any, scope: any, spot: any, cnt: any): void;
    dispatchLocalLights(sortedLights: any, scene: any, mask: any, usedDirLights: any, staticLightList: any): void;
    cull(camera: any, drawCalls: any, visibleList: any): number;
    cullLights(camera: any, lights: any): void;
    updateCpuSkinMatrices(drawCalls: any): void;
    updateGpuSkinMatrices(drawCalls: any): void;
    updateMorphing(drawCalls: any): void;
    setBaseConstants(device: any, material: any): void;
    setSkinning(device: any, meshInstance: any, material: any): void;
    drawInstance(device: any, meshInstance: any, mesh: any, style: any, normal: any): number;
    drawInstance2(device: any, meshInstance: any, mesh: any, style: any): number;
    renderShadows(lights: any, camera: any): void;
    renderCookies(lights: any): void;
    updateShader(meshInstance: any, objDefs: any, staticLightList: any, pass: any, sortedLights: any): void;
    setCullMode(cullFaces: any, flip: any, drawCall: any): void;
    setVertexBuffers(device: any, mesh: any): void;
    setMorphing(device: any, morphInstance: any): void;
    dispatchViewPos(position: any): void;
    renderForwardPrepareMaterials(camera: any, drawCalls: any, drawCallsCount: any, sortedLights: any, cullingMask: any, layer: any, pass: any): {
        drawCalls: any[];
        isNewMaterial: any[];
        lightMaskChanged: any[];
    };
    renderForward(camera: any, allDrawCalls: any, allDrawCallsCount: any, sortedLights: any, pass: any, cullingMask: any, drawCallback: any, layer: any, flipFaces: any): void;
    setupInstancing(device: any): void;
    updateShaders(drawCalls: any, onlyLitShaders: any): void;
    beginFrame(comp: any, lightsChanged: any): void;
    beginLayers(comp: any): void;
    gpuUpdate(drawCalls: any): void;
    setSceneConstants(): void;
    updateLightStats(comp: any, compUpdatedFlags: any): void;
    cullShadowmaps(comp: any): void;
    cullComposition(comp: any): void;
    updateLightTextureAtlas(comp: any): void;
    updateClusters(comp: any): void;
    renderComposition(comp: any): void;
}

declare class LightmapFilters {
    constructor(device: any);
    device: any;
    shaderDilate: Shader$4;
    constantTexSource: any;
    constantPixelOffset: any;
    pixelOffset: Float32Array;
    shaderDenoise: Shader$4;
    sigmas: Float32Array;
    constantSigmas: any;
    kernel: any;
    setSourceTexture(texture: any): void;
    prepare(textureWidth: any, textureHeight: any): void;
    prepareDenoise(filterRange: any, filterSmoothness: any): void;
    constantKernel: any;
    bZnorm: any;
    evaluateDenoiseUniforms(filterRange: any, filterSmoothness: any): void;
}

type AssetRegistry$6 = AssetRegistry$c;
type Entity$7 = Entity$a;
type ForwardRenderer = ForwardRenderer$1;
type GraphicsDevice$9 = GraphicsDevice$l;
type Scene$2 = Scene$3;
/**
 * The lightmapper is used to bake scene lights into textures.
 */
declare class Lightmapper {
    /**
     * Create a new Lightmapper instance.
     *
     * @param {GraphicsDevice} device - The graphics device used by the lightmapper.
     * @param {Entity} root - The root entity of the scene.
     * @param {Scene} scene - The scene to lightmap.
     * @param {ForwardRenderer} renderer - The renderer.
     * @param {AssetRegistry} assets - Registry of assets to lightmap.
     * @hideconstructor
     */
    constructor(device: GraphicsDevice$9, root: Entity$7, scene: Scene$2, renderer: ForwardRenderer, assets: AssetRegistry$6);
    device: GraphicsDevice$l;
    root: Entity$a;
    scene: Scene$3;
    renderer: ForwardRenderer$1;
    assets: AssetRegistry$c;
    shadowMapCache: ShadowMapCache;
    _tempSet: Set<any>;
    _initCalled: boolean;
    passMaterials: any[];
    ambientAOMaterial: StandardMaterial;
    fog: string;
    ambientLight: Color$4;
    renderTargets: Map<any, any>;
    stats: {
        renderPasses: number;
        lightmapCount: number;
        totalRenderTime: number;
        forwardTime: number;
        fboTime: number;
        shadowMapTime: number;
        compileTime: number;
        shadersLinked: number;
    };
    destroy(): void;
    blackTex: Texture$8;
    initBake(device: any): void;
    lightmapFilters: LightmapFilters;
    constantBakeDir: any;
    materials: any[];
    camera: Camera;
    lightingParams: LightingParams;
    worldClusters: WorldClusters;
    finishBake(bakeNodes: any): void;
    createMaterialForPass(device: any, scene: any, pass: any, addAmbient: any): StandardMaterial;
    createMaterials(device: any, scene: any, passCount: any): void;
    createTexture(size: any, type: any, name: any): Texture$8;
    collectModels(node: any, bakeNodes: any, allNodes: any): void;
    prepareShadowCasters(nodes: any): any[];
    updateTransforms(nodes: any): void;
    calculateLightmapSize(node: any): number;
    setLightmapping(nodes: any, value: any, passCount: any, shaderDefs: any): void;
    /**
     * Generates and applies the lightmaps.
     *
     * @param {Entity[]|null} nodes - An array of entities (with model or render components) to
     * render lightmaps for. If not supplied, the entire scene will be baked.
     * @param {number} [mode] - Baking mode. Can be:
     *
     * - {@link BAKE_COLOR}: single color lightmap
     * - {@link BAKE_COLORDIR}: single color lightmap + dominant light direction (used for
     * bump/specular)
     *
     * Only lights with bakeDir=true will be used for generating the dominant light direction.
     * Defaults to {@link BAKE_COLORDIR}.
     */
    bake(nodes: Entity$7[] | null, mode?: number): void;
    allocateTextures(bakeNodes: any, passCount: any): void;
    prepareLightsToBake(layerComposition: any, allLights: any, bakeLights: any): void;
    restoreLights(allLights: any): void;
    setupScene(): void;
    revertStatic: boolean;
    restoreScene(): void;
    computeNodeBounds(meshInstances: any): BoundingBox$1;
    computeNodesBounds(nodes: any): void;
    computeBounds(meshInstances: any): BoundingBox$1;
    backupMaterials(meshInstances: any): void;
    restoreMaterials(meshInstances: any): void;
    lightCameraPrepare(device: any, bakeLight: any): any;
    lightCameraPrepareAndCull(bakeLight: any, bakeNode: any, shadowCam: any, casterBounds: any): boolean;
    setupLightArray(lightArray: any, light: any): void;
    renderShadowMap(shadowMapRendered: any, casters: any, lightArray: any, bakeLight: any): boolean;
    postprocessTextures(device: any, bakeNodes: any, passCount: any): void;
    bakeInternal(passCount: any, bakeNodes: any, allNodes: any): void;
}

/**
 * Holds mesh batching settings and a unique id. Created via {@link BatchManager#addGroup}.
 *
 * @property {boolean} dynamic Whether objects within this batch group should support transforming
 * at runtime.
 * @property {number} maxAabbSize Maximum size of any dimension of a bounding box around batched
 * objects. {@link BatchManager#prepare} will split objects into local groups based on this size.
 * @property {number} id Unique id. Can be assigned to model and element components.
 * @property {string} name Name of the group.
 * @property {number[]} [layers] Layer ID array. Default is [{@link LAYERID_WORLD}]. The whole
 * batch group will belong to these layers. Layers of source models will be ignored.
 */
declare class BatchGroup {
    static MODEL: string;
    static ELEMENT: string;
    static SPRITE: string;
    static RENDER: string;
    /**
     * Create a new BatchGroup instance.
     *
     * @param {number} id - Unique id. Can be assigned to model and element components.
     * @param {string} name - The name of the group.
     * @param {boolean} dynamic - Whether objects within this batch group should support
     * transforming at runtime.
     * @param {number} maxAabbSize - Maximum size of any dimension of a bounding box around batched
     * objects. {@link BatchManager#prepare} will split objects into local groups based on this
     * size.
     * @param {number[]} [layers] - Layer ID array. Default is [{@link LAYERID_WORLD}]. The whole
     * batch group will belong to these layers. Layers of source models will be ignored.
     */
    constructor(id: number, name: string, dynamic: boolean, maxAabbSize: number, layers?: number[]);
    dynamic: boolean;
    maxAabbSize: number;
    id: number;
    name: string;
    layers: number[];
    _ui: boolean;
    _sprite: boolean;
    _obj: {
        model: any[];
        element: any[];
        sprite: any[];
        render: any[];
    };
}

type MeshInstance$1 = MeshInstance$3;
/** @typedef {import('../mesh-instance.js').MeshInstance} MeshInstance */
/**
 * Holds information about batched mesh instances. Created in {@link BatchManager#create}.
 *
 * @property {MeshInstance[]} origMeshInstances An array of original mesh instances, from which
 * this batch was generated.
 * @property {MeshInstance} meshInstance A single combined mesh instance, the result of batching.
 * @property {boolean} dynamic Whether this batch is dynamic (supports transforming mesh instances
 * at runtime).
 * @property {number} [batchGroupId] Link this batch to a specific batch group. This is done
 * automatically with default batches.
 */
declare class Batch {
    /**
     * Create a new Batch instance.
     *
     * @param {MeshInstance[]} meshInstances - The mesh instances to be batched.
     * @param {boolean} dynamic - Whether this batch is dynamic (supports transforming mesh instances at runtime).
     * @param {number} batchGroupId - Link this batch to a specific batch group. This is done automatically with default batches.
     */
    constructor(meshInstances: MeshInstance$1[], dynamic: boolean, batchGroupId: number);
    origMeshInstances: MeshInstance$3[];
    _aabb: BoundingBox$1;
    meshInstance: any;
    dynamic: boolean;
    batchGroupId: number;
    destroy(scene: any, layers: any): void;
    addToLayers(scene: any, layers: any): void;
    removeFromLayers(scene: any, layers: any): void;
    updateBoundingBox(): void;
}

type Entity$6 = Entity$a;
type GraphicsDevice$8 = GraphicsDevice$l;
type Scene$1 = Scene$3;
/**
 * Glues many mesh instances into a single one for better performance.
 */
declare class BatchManager {
    /**
     * Create a new BatchManager instance.
     *
     * @param {GraphicsDevice} device - The graphics device used by the batch manager.
     * @param {Entity} root - The entity under which batched models are added.
     * @param {Scene} scene - The scene that the batch manager affects.
     */
    constructor(device: GraphicsDevice$8, root: Entity$6, scene: Scene$1);
    device: GraphicsDevice$l;
    rootNode: Entity$a;
    scene: Scene$3;
    _init: boolean;
    _batchGroups: {};
    _batchGroupCounter: number;
    _batchList: any[];
    _dirtyGroups: any[];
    _stats: {
        createTime: number;
        updateLastFrameTime: number;
    };
    destroy(): void;
    /**
     * Adds new global batch group.
     *
     * @param {string} name - Custom name.
     * @param {boolean} dynamic - Is this batch group dynamic? Will these objects move/rotate/scale
     * after being batched?
     * @param {number} maxAabbSize - Maximum size of any dimension of a bounding box around batched
     * objects.
     * {@link BatchManager#prepare} will split objects into local groups based on this size.
     * @param {number} [id] - Optional custom unique id for the group (will be generated
     * automatically otherwise).
     * @param {number[]} [layers] - Optional layer ID array. Default is [{@link LAYERID_WORLD}].
     * The whole batch group will belong to these layers. Layers of source models will be ignored.
     * @returns {BatchGroup} Group object.
     */
    addGroup(name: string, dynamic: boolean, maxAabbSize: number, id?: number, layers?: number[]): BatchGroup;
    /**
     * Remove global batch group by id. Note, this traverses the entire scene graph and clears the
     * batch group id from all components.
     *
     * @param {number} id - Batch Group ID.
     */
    removeGroup(id: number): void;
    /**
     * Mark a specific batch group as dirty. Dirty groups are re-batched before the next frame is
     * rendered. Note, re-batching a group is a potentially expensive operation.
     *
     * @param {number} id - Batch Group ID to mark as dirty.
     */
    markGroupDirty(id: number): void;
    /**
     * Retrieves a {@link BatchGroup} object with a corresponding name, if it exists, or null
     * otherwise.
     *
     * @param {string} name - Name.
     * @returns {BatchGroup|null} The batch group matching the name or null if not found.
     */
    getGroupByName(name: string): BatchGroup | null;
    /**
     * Return a list of all {@link Batch} objects that belong to the Batch Group supplied.
     *
     * @param {number} batchGroupId - The id of the batch group.
     * @returns {Batch[]} A list of batches that are used to render the batch group.
     * @private
     */
    private getBatches;
    _removeModelsFromBatchGroup(node: any, id: any): void;
    insert(type: any, groupId: any, node: any): void;
    remove(type: any, groupId: any, node: any): void;
    _extractRender(node: any, arr: any, group: any, groupMeshInstances: any): any;
    _extractModel(node: any, arr: any, group: any, groupMeshInstances: any): any;
    _extractElement(node: any, arr: any, group: any): void;
    _collectAndRemoveMeshInstances(groupMeshInstances: any, groupIds: any): void;
    /**
     * Destroys all batches and creates new based on scene models. Hides original models. Called by
     * engine automatically on app start, and if batchGroupIds on models are changed.
     *
     * @param {number[]} [groupIds] - Optional array of batch group IDs to update. Otherwise all
     * groups are updated.
     */
    generate(groupIds?: number[]): void;
    /**
     * Takes a list of mesh instances to be batched and sorts them into lists one for each draw
     * call. The input list will be split, if:
     *
     * - Mesh instances use different materials.
     * - Mesh instances have different parameters (e.g. lightmaps or static lights).
     * - Mesh instances have different shader defines (shadow receiving, being aligned to screen
     * space, etc).
     * - Too many vertices for a single batch (65535 is maximum).
     * - Too many instances for a single batch (hardware-dependent, expect 128 on low-end and 1024
     * on high-end).
     * - Bounding box of a batch is larger than maxAabbSize in any dimension.
     *
     * @param {MeshInstance[]} meshInstances - Input list of mesh instances
     * @param {boolean} dynamic - Are we preparing for a dynamic batch? Instance count will matter
     * then (otherwise not).
     * @param {number} maxAabbSize - Maximum size of any dimension of a bounding box around batched
     * objects.
     * @param {boolean} translucent - Are we batching UI elements or sprites
     * This is useful to keep a balance between the number of draw calls and the number of drawn
     * triangles, because smaller batches can be hidden when not visible in camera.
     * @returns {MeshInstance[][]} An array of arrays of mesh instances, each valid to pass to
     * {@link BatchManager#create}.
     */
    prepare(meshInstances: MeshInstance$3[], dynamic: boolean, maxAabbSize: number, translucent: boolean): MeshInstance$3[][];
    collectBatchedMeshData(meshInstances: any, dynamic: any): {
        streams: {};
        batchNumVerts: number;
        batchNumIndices: number;
        material: any;
    };
    /**
     * Takes a mesh instance list that has been prepared by {@link BatchManager#prepare}, and
     * returns a {@link Batch} object. This method assumes that all mesh instances provided can be
     * rendered in a single draw call.
     *
     * @param {MeshInstance[]} meshInstances - Input list of mesh instances.
     * @param {boolean} dynamic - Is it a static or dynamic batch? Will objects be transformed
     * after batching?
     * @param {number} [batchGroupId] - Link this batch to a specific batch group. This is done
     * automatically with default batches.
     * @returns {Batch} The resulting batch object.
     */
    create(meshInstances: MeshInstance$3[], dynamic: boolean, batchGroupId?: number): Batch;
    transformVS: string;
    skinTexVS: any;
    skinConstVS: any;
    vertexFormats: {};
    /**
     * Updates bounding boxes for all dynamic batches. Called automatically.
     *
     * @private
     */
    private updateAll;
    /**
     * Clones a batch. This method doesn't rebuild batch geometry, but only creates a new model and
     * batch objects, linked to different source mesh instances.
     *
     * @param {Batch} batch - A batch object.
     * @param {MeshInstance[]} clonedMeshInstances - New mesh instances.
     * @returns {Batch} New batch object.
     */
    clone(batch: Batch, clonedMeshInstances: MeshInstance$3[]): Batch;
    /**
     * Removes the batch model from all layers and destroys it.
     *
     * @param {Batch} batch - A batch object.
     * @private
     */
    private destroyBatch;
}

type Application$9 = Application$7;
/** @typedef {import('../framework/application.js').Application} Application */
/**
 * Manage and update {@link VrDisplay}s that are attached to this device.
 *
 * @property {VrDisplay[]} displays The list of {@link VrDisplay}s that are attached to this
 * device.
 * @property {VrDisplay} display The default {@link VrDisplay} to be used. Usually the first in the
 * `displays` list.
 * @property {boolean} isSupported Reports whether this device supports the WebVR API.
 * @augments EventHandler
 * @deprecated
 * @ignore
 */
declare class VrManager extends EventHandler$1 {
    /**
     * @ignore
     * @deprecated
     * @event
     * @name VrManager#displayconnect
     * @description Fired when an VR display is connected.
     * @param {VrDisplay} display - The {@link VrDisplay} that has just been connected.
     * @example
     * this.app.vr.on("displayconnect", function (display) {
     *     // use `display` here
     * });
     */
    /**
     * @ignore
     * @deprecated
     * @event
     * @name VrManager#displaydisconnect
     * @description Fired when an VR display is disconnected.
     * @param {VrDisplay} display - The {@link VrDisplay} that has just been disconnected.
     * @example
     * this.app.vr.on("displaydisconnect", function (display) {
     *     // `display` is no longer connected
     * });
     */
    /**
     * Reports whether this device supports the WebVR API.
     *
     * @type {boolean}
     * @deprecated
     */
    static isSupported: boolean;
    /**
     * Create a new VrManager instance.
     *
     * @param {Application} app - The main application.
     */
    constructor(app: Application$9);
    isSupported: boolean;
    _index: {};
    displays: any[];
    display: any;
    _app: Application$7;
    _onDisplayConnect(e: any): void;
    _onDisplayDisconnect(e: any): void;
    _attach(): void;
    _detach(): void;
    /**
     * Remove events and clear up manager.
     *
     * @deprecated
     */
    destroy(): void;
    /**
     * Called once per frame to poll all attached displays.
     *
     * @deprecated
     */
    poll(): void;
    _getDisplays(callback: any): void;
    _addDisplay(vrDisplay: any): void;
}

type Entity$5 = Entity$a;
type ZoneComponentSystem$2 = ZoneComponentSystem$1;
/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').ZoneComponentSystem} ZoneComponentSystem */
/**
 * The ZoneComponent allows you to define an area in world space of certain size. This can be used
 * in various ways, such as affecting audio reverb when {@link AudioListenerComponent} is within
 * zone. Or create culling system with portals between zones to hide whole indoor sections for
 * performance reasons. And many other possible options. Zones are building blocks and meant to be
 * used in many different ways.
 *
 * @augments Component
 * @ignore
 */
declare class ZoneComponent extends Component$2 {
    /**
     * Create a new ZoneComponent instance.
     *
     * @param {ZoneComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ZoneComponentSystem$2, entity: Entity$5);
    _oldState: boolean;
    _size: Vec3$1;
    /**
     * The size of the axis-aligned box of this ZoneComponent.
     *
     * @type {Vec3}
     */
    set size(arg: Vec3$1);
    get size(): Vec3$1;
    _onSetEnabled(prop: any, old: any, value: any): void;
    _checkState(): void;
    _onBeforeRemove(): void;
}

declare class ZoneComponentData {
    enabled: boolean;
}

/**
 * Creates and manages {@link ZoneComponent} instances.
 *
 * @augments ComponentSystem
 * @ignore
 */
declare class ZoneComponentSystem$1 extends ComponentSystem {
    id: string;
    ComponentType: typeof ZoneComponent;
    DataType: typeof ZoneComponentData;
    _onBeforeRemove(entity: any, component: any): void;
}

type Entity$4 = Entity$a;
type JointComponentSystem$2 = JointComponentSystem$1;
/**
 * The JointComponent adds a physics joint constraint linking two rigid bodies.
 *
 * @augments Component
 * @ignore
 */
declare class JointComponent extends Component$2 {
    /**
     * Create a new JointComponent instance.
     *
     * @param {JointComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: JointComponentSystem$2, entity: Entity$4);
    _constraint: any;
    _entityA: any;
    _entityB: any;
    _breakForce: number;
    _enableCollision: boolean;
    _linearMotionX: string;
    _linearLimitsX: Vec2$3;
    _linearSpringX: boolean;
    _linearStiffnessX: number;
    _linearDampingX: number;
    _linearEquilibriumX: number;
    _linearMotionY: string;
    _linearLimitsY: Vec2$3;
    _linearSpringY: boolean;
    _linearStiffnessY: number;
    _linearDampingY: number;
    _linearEquilibriumY: number;
    _linearMotionZ: string;
    _linearLimitsZ: Vec2$3;
    _linearSpringZ: boolean;
    _linearStiffnessZ: number;
    _linearDampingZ: number;
    _linearEquilibriumZ: number;
    _angularMotionX: string;
    _angularLimitsX: Vec2$3;
    _angularSpringX: boolean;
    _angularStiffnessX: number;
    _angularDampingX: number;
    _angularEquilibriumX: number;
    _angularMotionY: string;
    _angularLimitsY: Vec2$3;
    _angularSpringY: boolean;
    _angularStiffnessY: number;
    _angularDampingY: number;
    _angularEquilibriumY: number;
    _angularMotionZ: string;
    _angularLimitsZ: Vec2$3;
    _angularSpringZ: boolean;
    _angularEquilibriumZ: number;
    _angularDampingZ: number;
    _angularStiffnessZ: number;
    set entityA(arg: any);
    get entityA(): any;
    set entityB(arg: any);
    get entityB(): any;
    set breakForce(arg: number);
    get breakForce(): number;
    set enableCollision(arg: boolean);
    get enableCollision(): boolean;
    set angularLimitsX(arg: Vec2$3);
    get angularLimitsX(): Vec2$3;
    set angularMotionX(arg: string);
    get angularMotionX(): string;
    set angularLimitsY(arg: Vec2$3);
    get angularLimitsY(): Vec2$3;
    set angularMotionY(arg: string);
    get angularMotionY(): string;
    set angularLimitsZ(arg: Vec2$3);
    get angularLimitsZ(): Vec2$3;
    set angularMotionZ(arg: string);
    get angularMotionZ(): string;
    set linearLimitsX(arg: Vec2$3);
    get linearLimitsX(): Vec2$3;
    set linearMotionX(arg: string);
    get linearMotionX(): string;
    set linearLimitsY(arg: Vec2$3);
    get linearLimitsY(): Vec2$3;
    set linearMotionY(arg: string);
    get linearMotionY(): string;
    set linearLimitsZ(arg: Vec2$3);
    get linearLimitsZ(): Vec2$3;
    set linearMotionZ(arg: string);
    get linearMotionZ(): string;
    _convertTransform(pcTransform: any, ammoTransform: any): void;
    _updateAngularLimits(): void;
    _updateLinearLimits(): void;
    _createConstraint(): void;
    _destroyConstraint(): void;
    initFromData(data: any): void;
    _onSetEnabled(prop: any, old: any, value: any): void;
    _onBeforeRemove(): void;
}

declare class JointComponentData {
    enabled: boolean;
}

/**
 * Creates and manages physics joint components.
 *
 * @augments ComponentSystem
 * @ignore
 */
declare class JointComponentSystem$1 extends ComponentSystem {
    id: string;
    ComponentType: typeof JointComponent;
    DataType: typeof JointComponentData;
}

type AudioSourceComponentSystem$2 = AudioSourceComponentSystem$1;
type Entity$3 = Entity$a;
/** @typedef {import('./system.js').AudioSourceComponentSystem} AudioSourceComponentSystem */
/** @typedef {import('../../entity.js').Entity} Entity */
/**
 * The AudioSource Component controls playback of an audio sample. This class will be deprecated
 * in favor of {@link SoundComponent}.
 *
 * @property {Asset[]} assets The list of audio assets - can also be an array of asset ids.
 * @property {boolean} activate If true the audio will begin playing as soon as the scene is
 * loaded.
 * @property {number} volume The volume modifier to play the audio with. In range 0-1.
 * @property {number} pitch The pitch modifier to play the audio with. Must be larger than 0.01.
 * @property {boolean} loop If true the audio will restart when it finishes playing.
 * @property {boolean} 3d If true the audio will play back at the location of the entity in space,
 * so the audio will be affect by the position of the {@link AudioListenerComponent}.
 * @property {string} distanceModel Determines which algorithm to use to reduce the volume of the
 * audio as it moves away from the listener. Can be:
 *
 * - "linear"
 * - "inverse"
 * - "exponential"
 *
 * Default is "inverse".
 * @property {number} minDistance The minimum distance from the listener at which audio falloff
 * begins.
 * @property {number} maxDistance The maximum distance from the listener at which audio falloff
 * stops. Note the volume of the audio is not 0 after this distance, but just doesn't fall off
 * anymore.
 * @property {number} rollOffFactor The factor used in the falloff equation.
 * @augments Component
 * @ignore
 */
declare class AudioSourceComponent extends Component$2 {
    /**
     * Create a new AudioSource Component instance.
     *
     * @param {AudioSourceComponentSystem} system - The ComponentSystem that created
     * this component.
     * @param {Entity} entity - The entity that the Component is attached to.
     */
    constructor(system: AudioSourceComponentSystem$2, entity: Entity$3);
    /**
     * Begin playback of an audio asset in the component attached to an entity.
     *
     * @param {string} name - The name of the Asset to play.
     */
    play(name: string): void;
    /**
     * Pause playback of the audio that is playing on the Entity. Playback can be resumed by
     * calling {@link AudioSourceComponent#unpause}.
     */
    pause(): void;
    /**
     * Resume playback of the audio if paused. Playback is resumed at the time it was paused.
     */
    unpause(): void;
    /**
     * Stop playback on an Entity. Playback can not be resumed after being stopped.
     */
    stop(): void;
    channel: any;
    onSetAssets(name: any, oldValue: any, newValue: any): void;
    onAssetChanged(asset: any, attribute: any, newValue: any, oldValue: any): void;
    onAssetRemoved(asset: any): void;
    onSetLoop(name: any, oldValue: any, newValue: any): void;
    onSetVolume(name: any, oldValue: any, newValue: any): void;
    onSetPitch(name: any, oldValue: any, newValue: any): void;
    onSetMaxDistance(name: any, oldValue: any, newValue: any): void;
    onSetMinDistance(name: any, oldValue: any, newValue: any): void;
    onSetRollOffFactor(name: any, oldValue: any, newValue: any): void;
    onSetDistanceModel(name: any, oldValue: any, newValue: any): void;
    onSet3d(name: any, oldValue: any, newValue: any): void;
    loadAudioSourceAssets(ids: any): void;
}

declare class AudioSourceComponentData {
    enabled: boolean;
    assets: any[];
    activate: boolean;
    volume: number;
    pitch: number;
    loop: boolean;
    '3d': boolean;
    minDistance: number;
    maxDistance: number;
    rollOffFactor: number;
    distanceModel: string;
    paused: boolean;
    sources: {};
    currentSource: any;
    channel: any;
}

type Application$8 = Application$7;
type SoundManager$3 = SoundManager$7;
/**
 * Controls playback of an audio sample. This class will be deprecated in favor of
 * {@link SoundComponentSystem}.
 *
 * @augments ComponentSystem
 * @ignore
 */
declare class AudioSourceComponentSystem$1 extends ComponentSystem {
    /**
     * Create a new AudioSourceComponentSystem instance.
     *
     * @param {Application} app - The application managing this system.
     * @param {SoundManager} manager - A sound manager instance.
     */
    constructor(app: Application$8, manager: SoundManager$3);
    id: string;
    ComponentType: typeof AudioSourceComponent;
    DataType: typeof AudioSourceComponentData;
    manager: SoundManager$7;
    initialized: boolean;
    onInitialize(root: any): void;
    onUpdate(dt: any): void;
    onRemove(entity: any, data: any): void;
    /**
     * Set the volume for the entire AudioSource system. All sources will have their volume
     * multiplied by this value.
     *
     * @param {number} volume - The value to set the volume to. Valid from 0 to 1.
     */
    setVolume(volume: number): void;
}

type AnimComponentSystem = AnimComponentSystem$2;
type AnimationComponentSystem = AnimationComponentSystem$2;
type AudioListenerComponentSystem = AudioListenerComponentSystem$2;
type AudioSourceComponentSystem = AudioSourceComponentSystem$1;
type ButtonComponentSystem = ButtonComponentSystem$2;
type CameraComponentSystem$2 = CameraComponentSystem$1;
type CollisionComponentSystem = CollisionComponentSystem$2;
type ElementComponentSystem = ElementComponentSystem$2;
type JointComponentSystem = JointComponentSystem$1;
type LayoutChildComponentSystem = LayoutChildComponentSystem$2;
type LayoutGroupComponentSystem = LayoutGroupComponentSystem$2;
type LightComponentSystem = LightComponentSystem$2;
type ModelComponentSystem = ModelComponentSystem$2;
type ParticleSystemComponentSystem = ParticleSystemComponentSystem$2;
type RenderComponentSystem = RenderComponentSystem$2;
type RigidBodyComponentSystem = RigidBodyComponentSystem$2;
type ScreenComponentSystem = ScreenComponentSystem$2;
type ScriptComponentSystem = ScriptComponentSystem$2;
type ScrollbarComponentSystem = ScrollbarComponentSystem$2;
type ScrollViewComponentSystem = ScrollViewComponentSystem$2;
type SoundComponentSystem = SoundComponentSystem$2;
type SpriteComponentSystem = SpriteComponentSystem$2;
type ZoneComponentSystem = ZoneComponentSystem$1;
/** @typedef {import('./anim/system.js').AnimComponentSystem} AnimComponentSystem */
/** @typedef {import('./animation/system.js').AnimationComponentSystem} AnimationComponentSystem */
/** @typedef {import('./audio-listener/system.js').AudioListenerComponentSystem} AudioListenerComponentSystem */
/** @typedef {import('./audio-source/system.js').AudioSourceComponentSystem} AudioSourceComponentSystem */
/** @typedef {import('./button/system.js').ButtonComponentSystem} ButtonComponentSystem */
/** @typedef {import('./camera/system.js').CameraComponentSystem} CameraComponentSystem */
/** @typedef {import('./collision/system.js').CollisionComponentSystem} CollisionComponentSystem */
/** @typedef {import('./element/system.js').ElementComponentSystem} ElementComponentSystem */
/** @typedef {import('./joint/system.js').JointComponentSystem} JointComponentSystem */
/** @typedef {import('./layout-child/system.js').LayoutChildComponentSystem} LayoutChildComponentSystem */
/** @typedef {import('./layout-group/system.js').LayoutGroupComponentSystem} LayoutGroupComponentSystem */
/** @typedef {import('./light/system.js').LightComponentSystem} LightComponentSystem */
/** @typedef {import('./model/system.js').ModelComponentSystem} ModelComponentSystem */
/** @typedef {import('./particle-system/system.js').ParticleSystemComponentSystem} ParticleSystemComponentSystem */
/** @typedef {import('./render/system.js').RenderComponentSystem} RenderComponentSystem */
/** @typedef {import('./rigid-body/system.js').RigidBodyComponentSystem} RigidBodyComponentSystem */
/** @typedef {import('./screen/system.js').ScreenComponentSystem} ScreenComponentSystem */
/** @typedef {import('./script/system.js').ScriptComponentSystem} ScriptComponentSystem */
/** @typedef {import('./scrollbar/system.js').ScrollbarComponentSystem} ScrollbarComponentSystem */
/** @typedef {import('./scroll-view/system.js').ScrollViewComponentSystem} ScrollViewComponentSystem */
/** @typedef {import('./sound/system.js').SoundComponentSystem} SoundComponentSystem */
/** @typedef {import('./sprite/system.js').SpriteComponentSystem} SpriteComponentSystem */
/** @typedef {import('./zone/system.js').ZoneComponentSystem} ZoneComponentSystem */
/**
 * Store, access and delete instances of the various ComponentSystems.
 */
declare class ComponentSystemRegistry extends EventHandler$1 {
    /**
     * Gets the {@link AnimComponentSystem} from the registry.
     *
     * @type {AnimComponentSystem}
     * @readonly
     */
    readonly anim: AnimComponentSystem;
    /**
     * Gets the {@link AnimationComponentSystem} from the registry.
     *
     * @type {AnimationComponentSystem}
     * @readonly
     */
    readonly animation: AnimationComponentSystem;
    /**
     * Gets the {@link AudioListenerComponentSystem} from the registry.
     *
     * @type {AudioListenerComponentSystem}
     * @readonly
     */
    readonly audiolistener: AudioListenerComponentSystem;
    /**
     * Gets the {@link AudioSourceComponentSystem} from the registry.
     *
     * @type {AudioSourceComponentSystem}
     * @readonly
     * @ignore
     */
    readonly audiosource: AudioSourceComponentSystem;
    /**
     * Gets the {@link ButtonComponentSystem} from the registry.
     *
     * @type {ButtonComponentSystem}
     * @readonly
     */
    readonly button: ButtonComponentSystem;
    /**
     * Gets the {@link CameraComponentSystem} from the registry.
     *
     * @type {CameraComponentSystem}
     * @readonly
     */
    readonly camera: CameraComponentSystem$2;
    /**
     * Gets the {@link CollisionComponentSystem} from the registry.
     *
     * @type {CollisionComponentSystem}
     * @readonly
     */
    readonly collision: CollisionComponentSystem;
    /**
     * Gets the {@link ElementComponentSystem} from the registry.
     *
     * @type {ElementComponentSystem}
     * @readonly
     */
    readonly element: ElementComponentSystem;
    /**
     * Gets the {@link JointComponentSystem} from the registry.
     *
     * @type {JointComponentSystem}
     * @readonly
     * @ignore
     */
    readonly joint: JointComponentSystem;
    /**
     * Gets the {@link LayoutChildComponentSystem} from the registry.
     *
     * @type {LayoutChildComponentSystem}
     * @readonly
     */
    readonly layoutchild: LayoutChildComponentSystem;
    /**
     * Gets the {@link LayoutGroupComponentSystem} from the registry.
     *
     * @type {LayoutGroupComponentSystem}
     * @readonly
     */
    readonly layoutgroup: LayoutGroupComponentSystem;
    /**
     * Gets the {@link LightComponentSystem} from the registry.
     *
     * @type {LightComponentSystem}
     * @readonly
     */
    readonly light: LightComponentSystem;
    /**
     * Gets the {@link ModelComponentSystem} from the registry.
     *
     * @type {ModelComponentSystem}
     * @readonly
     */
    readonly model: ModelComponentSystem;
    /**
     * Gets the {@link ParticleSystemComponentSystem} from the registry.
     *
     * @type {ParticleSystemComponentSystem}
     * @readonly
     */
    readonly particlesystem: ParticleSystemComponentSystem;
    /**
     * Gets the {@link RenderComponentSystem} from the registry.
     *
     * @type {RenderComponentSystem}
     * @readonly
     */
    readonly render: RenderComponentSystem;
    /**
     * Gets the {@link RigidBodyComponentSystem} from the registry.
     *
     * @type {RigidBodyComponentSystem}
     * @readonly
     */
    readonly rigidbody: RigidBodyComponentSystem;
    /**
     * Gets the {@link ScreenComponentSystem} from the registry.
     *
     * @type {ScreenComponentSystem}
     * @readonly
     */
    readonly screen: ScreenComponentSystem;
    /**
     * Gets the {@link ScriptComponentSystem} from the registry.
     *
     * @type {ScriptComponentSystem}
     * @readonly
     */
    readonly script: ScriptComponentSystem;
    /**
     * Gets the {@link ScrollbarComponentSystem} from the registry.
     *
     * @type {ScrollbarComponentSystem}
     * @readonly
     */
    readonly scrollbar: ScrollbarComponentSystem;
    /**
     * Gets the {@link ScrollViewComponentSystem} from the registry.
     *
     * @type {ScrollViewComponentSystem}
     * @readonly
     */
    readonly scrollview: ScrollViewComponentSystem;
    /**
     * Gets the {@link SoundComponentSystem} from the registry.
     *
     * @type {SoundComponentSystem}
     * @readonly
     */
    readonly sound: SoundComponentSystem;
    /**
     * Gets the {@link SpriteComponentSystem} from the registry.
     *
     * @type {SpriteComponentSystem}
     * @readonly
     */
    readonly sprite: SpriteComponentSystem;
    /**
     * Gets the {@link ZoneComponentSystem} from the registry.
     *
     * @type {ZoneComponentSystem}
     * @readonly
     * @ignore
     */
    readonly zone: ZoneComponentSystem;
    list: any[];
    /**
     * Add a component system to the registry.
     *
     * @param {object} system - The {@link ComponentSystem} instance.
     * @ignore
     */
    add(system: object): void;
    /**
     * Remove a component system from the registry.
     *
     * @param {object} system - The {@link ComponentSystem} instance.
     * @ignore
     */
    remove(system: object): void;
    destroy(): void;
}

type ElementInput = ElementInput$1;
type GamePads$1 = GamePads$2;
type Keyboard$1 = Keyboard$2;
type Mouse$1 = Mouse$2;
type TouchDevice$1 = TouchDevice$2;
/**
 * Callback used by {@link Applicationconfigure } when configuration file is loaded and parsed (or
 * an error occurs).
 */
type configureAppCallback = (err: string | null) => any;
/**
 * Callback used by {@link Applicationpreload } when all assets (marked as 'preload') are loaded.
 */
type preloadAppCallback = () => any;
/**
 * Callback used by {@link Application#configure} when configuration file is loaded and parsed (or
 * an error occurs).
 *
 * @callback configureAppCallback
 * @param {string|null} err - The error message in the case where the loading or parsing fails.
 */
/**
 * Callback used by {@link Application#preload} when all assets (marked as 'preload') are loaded.
 *
 * @callback preloadAppCallback
 */
declare let app: any;
/**
 * An Application represents and manages your PlayCanvas application. If you are developing using
 * the PlayCanvas Editor, the Application is created for you. You can access your Application
 * instance in your scripts. Below is a skeleton script which shows how you can access the
 * application 'app' property inside the initialize and update functions:
 *
 * ```javascript
 * // Editor example: accessing the pc.Application from a script
 * var MyScript = pc.createScript('myScript');
 *
 * MyScript.prototype.initialize = function() {
 *     // Every script instance has a property 'this.app' accessible in the initialize...
 *     var app = this.app;
 * };
 *
 * MyScript.prototype.update = function(dt) {
 *     // ...and update functions.
 *     var app = this.app;
 * };
 * ```
 *
 * If you are using the Engine without the Editor, you have to create the application instance
 * manually.
 *
 * @augments EventHandler
 */
declare class Application$7 extends EventHandler$1 {
    /**
     * @private
     * @static
     * @name app
     * @type {Application|undefined}
     * @description Gets the current application, if any.
     */
    private static _applications;
    /**
     * Get the current application. In the case where there are multiple running applications, the
     * function can get an application based on a supplied canvas id. This function is particularly
     * useful when the current Application is not readily available. For example, in the JavaScript
     * console of the browser's developer tools.
     *
     * @param {string} [id] - If defined, the returned application should use the canvas which has
     * this id. Otherwise current application will be returned.
     * @returns {Application|undefined} The running application, if any.
     * @example
     * var app = pc.Application.getApplication();
     */
    static getApplication(id?: string): Application$7 | undefined;
    /**
     * Create a new Application instance.
     *
     * @param {Element} canvas - The canvas element.
     * @param {object} [options] - The options object to configure the Application.
     * @param {ElementInput} [options.elementInput] - Input handler for {@link ElementComponent}s.
     * @param {Keyboard} [options.keyboard] - Keyboard handler for input.
     * @param {Mouse} [options.mouse] - Mouse handler for input.
     * @param {TouchDevice} [options.touch] - TouchDevice handler for input.
     * @param {GamePads} [options.gamepads] - Gamepad handler for input.
     * @param {string} [options.scriptPrefix] - Prefix to apply to script urls before loading.
     * @param {string} [options.assetPrefix] - Prefix to apply to asset urls before loading.
     * @param {object} [options.graphicsDeviceOptions] - Options object that is passed into the
     * {@link GraphicsDevice} constructor.
     * @param {string[]} [options.scriptsOrder] - Scripts in order of loading first.
     * @example
     * // Engine-only example: create the application manually
     * var app = new pc.Application(canvas, options);
     *
     * // Start the application's main loop
     * app.start();
     */
    constructor(canvas: Element, options?: {
        elementInput?: ElementInput;
        keyboard?: Keyboard$1;
        mouse?: Mouse$1;
        touch?: TouchDevice$1;
        gamepads?: GamePads$1;
        scriptPrefix?: string;
        assetPrefix?: string;
        graphicsDeviceOptions?: object;
        scriptsOrder?: string[];
    });
    _destroyRequested: boolean;
    _inFrameUpdate: boolean;
    _time: number;
    /**
     * Scales the global time delta. Defaults to 1.
     *
     * @type {number}
     * @example
     * // Set the app to run at half speed
     * this.app.timeScale = 0.5;
     */
    timeScale: number;
    /**
     * Clamps per-frame delta time to an upper bound. Useful since returning from a tab
     * deactivation can generate huge values for dt, which can adversely affect game state.
     * Defaults to 0.1 (seconds).
     *
     * @type {number}
     * @example
     * // Don't clamp inter-frame times of 200ms or less
     * this.app.maxDeltaTime = 0.2;
     */
    maxDeltaTime: number;
    frame: number;
    /**
     * When true, the application's render function is called every frame. Setting autoRender
     * to false is useful to applications where the rendered image may often be unchanged over
     * time. This can heavily reduce the application's load on the CPU and GPU. Defaults to
     * true.
     *
     * @type {boolean}
     * @example
     * // Disable rendering every frame and only render on a keydown event
     * this.app.autoRender = false;
     * this.app.keyboard.on('keydown', function (event) {
     *     this.app.renderNextFrame = true;
     * }, this);
     */
    autoRender: boolean;
    /**
     * Set to true to render the scene on the next iteration of the main loop. This only has an
     * effect if {@link Application#autoRender} is set to false. The value of renderNextFrame
     * is set back to false again as soon as the scene has been rendered.
     *
     * @type {boolean}
     * @example
     * // Render the scene only while space key is pressed
     * if (this.app.keyboard.isPressed(pc.KEY_SPACE)) {
     *     this.app.renderNextFrame = true;
     * }
     */
    renderNextFrame: boolean;
    useLegacyScriptAttributeCloning: any;
    _librariesLoaded: boolean;
    _fillMode: string;
    _resolutionMode: string;
    _allowResize: boolean;
    context: Application$7;
    /**
     * The graphics device used by the application.
     *
     * @type {GraphicsDevice}
     */
    graphicsDevice: GraphicsDevice$l;
    stats: ApplicationStats;
    _soundManager: SoundManager$7;
    /**
     * The resource loader.
     *
     * @type {ResourceLoader}
     */
    loader: ResourceLoader$4;
    _entityIndex: {};
    /**
     * The scene managed by the application.
     *
     * @type {Scene}
     * @example
     * // Set the tone mapping property of the application's scene
     * this.app.scene.toneMapping = pc.TONEMAP_FILMIC;
     */
    scene: Scene$3;
    /**
     * The root entity of the application.
     *
     * @type {Entity}
     * @example
     * // Return the first entity called 'Camera' in a depth-first search of the scene hierarchy
     * var camera = this.app.root.findByName('Camera');
     */
    root: Entity$a;
    _enableList: any[];
    /**
     * The asset registry managed by the application.
     *
     * @type {AssetRegistry}
     * @example
     * // Search the asset registry for all assets with the tag 'vehicle'
     * var vehicleAssets = this.app.assets.findByTag('vehicle');
     */
    assets: AssetRegistry$c;
    bundles: BundleRegistry;
    enableBundles: boolean;
    scriptsOrder: string[];
    /**
     * The application's script registry.
     *
     * @type {ScriptRegistry}
     */
    scripts: ScriptRegistry;
    /**
     * Handles localization.
     *
     * @type {I18n}
     */
    i18n: I18n;
    /**
     * The scene registry managed by the application.
     *
     * @type {SceneRegistry}
     * @example
     * // Search the scene registry for a item with the name 'racetrack1'
     * var sceneItem = this.app.scenes.find('racetrack1');
     *
     * // Load the scene using the item's url
     * this.app.scenes.loadScene(sceneItem.url);
     */
    scenes: SceneRegistry;
    defaultLayerWorld: Layer$1;
    sceneDepth: SceneDepth;
    defaultLayerDepth: Layer$1;
    defaultLayerSkybox: Layer$1;
    defaultLayerUi: Layer$1;
    defaultLayerImmediate: Layer$1;
    _immediateLayer: Layer$1;
    /**
     * The forward renderer.
     *
     * @type {ForwardRenderer}
     * @private
     */
    private renderer;
    /**
     * The run-time lightmapper.
     *
     * @type {Lightmapper}
     */
    lightmapper: Lightmapper;
    /**
     * The application's batch manager. The batch manager is used to merge mesh instances in
     * the scene, which reduces the overall number of draw calls, thereby boosting performance.
     *
     * @type {BatchManager}
     */
    batcher: BatchManager;
    /**
     * The keyboard device.
     *
     * @type {Keyboard}
     */
    keyboard: Keyboard$1;
    /**
     * The mouse device.
     *
     * @type {Mouse}
     */
    mouse: Mouse$1;
    /**
     * Used to get touch events input.
     *
     * @type {TouchDevice}
     */
    touch: TouchDevice$1;
    /**
     * Used to access GamePad input.
     *
     * @type {GamePads}
     */
    gamepads: GamePads$1;
    /**
     * Used to handle input for {@link ElementComponent}s.
     *
     * @type {ElementInput}
     */
    elementInput: ElementInput;
    vr: VrManager;
    /**
     * The XR Manager that provides ability to start VR/AR sessions.
     *
     * @type {XrManager}
     * @example
     * // check if VR is available
     * if (app.xr.isAvailable(pc.XRTYPE_VR)) {
     *     // VR is available
     * }
     */
    xr: XrManager$1;
    _inTools: boolean;
    _skyboxAsset: any;
    _scriptPrefix: string;
    /**
     * The application's component system registry. The Application constructor adds the
     * following component systems to its component system registry:
     *
     * - anim ({@link AnimComponentSystem})
     * - animation ({@link AnimationComponentSystem})
     * - audiolistener ({@link AudioListenerComponentSystem})
     * - button ({@link ButtonComponentSystem})
     * - camera ({@link CameraComponentSystem})
     * - collision ({@link CollisionComponentSystem})
     * - element ({@link ElementComponentSystem})
     * - layoutchild ({@link LayoutChildComponentSystem})
     * - layoutgroup ({@link LayoutGroupComponentSystem})
     * - light ({@link LightComponentSystem})
     * - model ({@link ModelComponentSystem})
     * - particlesystem ({@link ParticleSystemComponentSystem})
     * - rigidbody ({@link RigidBodyComponentSystem})
     * - render ({@link RenderComponentSystem})
     * - screen ({@link ScreenComponentSystem})
     * - script ({@link ScriptComponentSystem})
     * - scrollbar ({@link ScrollbarComponentSystem})
     * - scrollview ({@link ScrollViewComponentSystem})
     * - sound ({@link SoundComponentSystem})
     * - sprite ({@link SpriteComponentSystem})
     *
     * @type {ComponentSystemRegistry}
     * @example
     * // Set global gravity to zero
     * this.app.systems.rigidbody.gravity.set(0, 0, 0);
     * @example
     * // Set the global sound volume to 50%
     * this.app.systems.sound.volume = 0.5;
     */
    systems: ComponentSystemRegistry;
    _visibilityChangeHandler: any;
    _hiddenAttr: string;
    tick: (timestamp: any, frame: any) => void;
    _initDefaultMaterial(): void;
    /**
     * The current fill mode of the canvas. Can be:
     *
     * - {@link FILLMODE_NONE}: the canvas will always match the size provided.
     * - {@link FILLMODE_FILL_WINDOW}: the canvas will simply fill the window, changing aspect ratio.
     * - {@link FILLMODE_KEEP_ASPECT}: the canvas will grow to fill the window as best it can while
     * maintaining the aspect ratio.
     *
     * @type {string}
     */
    get fillMode(): string;
    /**
     * The current resolution mode of the canvas, Can be:
     *
     * - {@link RESOLUTION_AUTO}: if width and height are not provided, canvas will be resized to
     * match canvas client size.
     * - {@link RESOLUTION_FIXED}: resolution of canvas will be fixed.
     *
     * @type {string}
     */
    get resolutionMode(): string;
    /**
     * Load the application configuration file and apply application properties and fill the asset
     * registry.
     *
     * @param {string} url - The URL of the configuration file to load.
     * @param {configureAppCallback} callback - The Function called when the configuration file is
     * loaded and parsed (or an error occurs).
     */
    configure(url: string, callback: configureAppCallback): void;
    /**
     * Load all assets in the asset registry that are marked as 'preload'.
     *
     * @param {preloadAppCallback} callback - Function called when all assets are loaded.
     */
    preload(callback: preloadAppCallback): void;
    _preloadScripts(sceneData: any, callback: any): void;
    _handleAreaLightDataProperty(prop: any): void;
    _parseApplicationProperties(props: any, callback: any): void;
    _width: any;
    _height: any;
    _loadLibraries(urls: any, callback: any): void;
    _parseScenes(scenes: any): void;
    _parseAssets(assets: any): void;
    _getScriptReferences(scene: any): any[];
    /**
     * Start the application. This function does the following:
     *
     * 1. Fires an event on the application named 'start'
     * 2. Calls initialize for all components on entities in the hierarchy
     * 3. Fires an event on the application named 'initialize'
     * 4. Calls postInitialize for all components on entities in the hierarchy
     * 5. Fires an event on the application named 'postinitialize'
     * 6. Starts executing the main loop of the application
     *
     * This function is called internally by PlayCanvas applications made in the Editor but you
     * will need to call start yourself if you are using the engine stand-alone.
     *
     * @example
     * app.start();
     */
    start(): void;
    /**
     * Update all input devices managed by the application.
     *
     * @param {number} dt - The time in seconds since the last update.
     * @private
     */
    private inputUpdate;
    /**
     * Update the application. This function will call the update functions and then the postUpdate
     * functions of all enabled components. It will then update the current state of all connected
     * input devices. This function is called internally in the application's main loop and does
     * not need to be called explicitly.
     *
     * @param {number} dt - The time delta in seconds since the last frame.
     */
    update(dt: number): void;
    /**
     * Render the application's scene. More specifically, the scene's {@link LayerComposition} is
     * rendered by the application's {@link ForwardRenderer}. This function is called internally in
     * the application's main loop and does not need to be called explicitly.
     */
    render(): void;
    _fillFrameStatsBasic(now: any, dt: any, ms: any): void;
    _fillFrameStats(): void;
    /**
     * Controls how the canvas fills the window and resizes when the window changes.
     *
     * @param {string} mode - The mode to use when setting the size of the canvas. Can be:
     *
     * - {@link FILLMODE_NONE}: the canvas will always match the size provided.
     * - {@link FILLMODE_FILL_WINDOW}: the canvas will simply fill the window, changing aspect ratio.
     * - {@link FILLMODE_KEEP_ASPECT}: the canvas will grow to fill the window as best it can while
     * maintaining the aspect ratio.
     *
     * @param {number} [width] - The width of the canvas (only used when mode is {@link FILLMODE_NONE}).
     * @param {number} [height] - The height of the canvas (only used when mode is {@link FILLMODE_NONE}).
     */
    setCanvasFillMode(mode: string, width?: number, height?: number): void;
    /**
     * Change the resolution of the canvas, and set the way it behaves when the window is resized.
     *
     * @param {string} mode - The mode to use when setting the resolution. Can be:
     *
     * - {@link RESOLUTION_AUTO}: if width and height are not provided, canvas will be resized to
     * match canvas client size.
     * - {@link RESOLUTION_FIXED}: resolution of canvas will be fixed.
     *
     * @param {number} [width] - The horizontal resolution, optional in AUTO mode, if not provided
     * canvas clientWidth is used.
     * @param {number} [height] - The vertical resolution, optional in AUTO mode, if not provided
     * canvas clientHeight is used.
     */
    setCanvasResolution(mode: string, width?: number, height?: number): void;
    /**
     * Queries the visibility of the window or tab in which the application is running.
     *
     * @returns {boolean} True if the application is not visible and false otherwise.
     */
    isHidden(): boolean;
    /**
     * Called when the visibility state of the current tab/window changes.
     *
     * @private
     */
    private onVisibilityChange;
    /**
     * Resize the application's canvas element in line with the current fill mode.
     *
     * - In {@link FILLMODE_KEEP_ASPECT} mode, the canvas will grow to fill the window as best it
     * can while maintaining the aspect ratio.
     * - In {@link FILLMODE_FILL_WINDOW} mode, the canvas will simply fill the window, changing
     * aspect ratio.
     * - In {@link FILLMODE_NONE} mode, the canvas will always match the size provided.
     *
     * @param {number} [width] - The width of the canvas. Only used if current fill mode is {@link FILLMODE_NONE}.
     * @param {number} [height] - The height of the canvas. Only used if current fill mode is {@link FILLMODE_NONE}.
     * @returns {object} A object containing the values calculated to use as width and height.
     */
    resizeCanvas(width?: number, height?: number): object;
    /**
     * Updates the {@link GraphicsDevice} canvas size to match the canvas size on the document
     * page. It is recommended to call this function when the canvas size changes (e.g on window
     * resize and orientation change events) so that the canvas resolution is immediately updated.
     */
    updateCanvasSize(): void;
    /**
     * Event handler called when all code libraries have been loaded. Code libraries are passed
     * into the constructor of the Application and the application won't start running or load
     * packs until all libraries have been loaded.
     *
     * @private
     */
    private onLibrariesLoaded;
    /**
     * Apply scene settings to the current scene. Useful when your scene settings are parsed or
     * generated from a non-URL source.
     *
     * @param {object} settings - The scene settings to be applied.
     * @param {object} settings.physics - The physics settings to be applied.
     * @param {number[]} settings.physics.gravity - The world space vector representing global
     * gravity in the physics simulation. Must be a fixed size array with three number elements,
     * corresponding to each axis [ X, Y, Z ].
     * @param {object} settings.render - The rendering settings to be applied.
     * @param {number[]} settings.render.global_ambient - The color of the scene's ambient light.
     * Must be a fixed size array with three number elements, corresponding to each color channel
     * [ R, G, B ].
     * @param {string} settings.render.fog - The type of fog used by the scene. Can be:
     *
     * - {@link FOG_NONE}
     * - {@link FOG_LINEAR}
     * - {@link FOG_EXP}
     * - {@link FOG_EXP2}
     *
     * @param {number[]} settings.render.fog_color - The color of the fog (if enabled). Must be a
     * fixed size array with three number elements, corresponding to each color channel [ R, G, B ].
     * @param {number} settings.render.fog_density - The density of the fog (if enabled). This
     * property is only valid if the fog property is set to {@link FOG_EXP} or {@link FOG_EXP2}.
     * @param {number} settings.render.fog_start - The distance from the viewpoint where linear fog
     * begins. This property is only valid if the fog property is set to {@link FOG_LINEAR}.
     * @param {number} settings.render.fog_end - The distance from the viewpoint where linear fog
     * reaches its maximum. This property is only valid if the fog property is set to {@link FOG_LINEAR}.
     * @param {number} settings.render.gamma_correction - The gamma correction to apply when
     * rendering the scene. Can be:
     *
     * - {@link GAMMA_NONE}
     * - {@link GAMMA_SRGB}
     *
     * @param {number} settings.render.tonemapping - The tonemapping transform to apply when
     * writing fragments to the frame buffer. Can be:
     *
     * - {@link TONEMAP_LINEAR}
     * - {@link TONEMAP_FILMIC}
     * - {@link TONEMAP_HEJL}
     * - {@link TONEMAP_ACES}
     *
     * @param {number} settings.render.exposure - The exposure value tweaks the overall brightness
     * of the scene.
     * @param {number|null} [settings.render.skybox] - The asset ID of the cube map texture to be
     * used as the scene's skybox. Defaults to null.
     * @param {number} settings.render.skyboxIntensity - Multiplier for skybox intensity.
     * @param {number} settings.render.skyboxMip - The mip level of the skybox to be displayed.
     * Only valid for prefiltered cubemap skyboxes.
     * @param {number[]} settings.render.skyboxRotation - Rotation of skybox.
     * @param {number} settings.render.lightmapSizeMultiplier - The lightmap resolution multiplier.
     * @param {number} settings.render.lightmapMaxResolution - The maximum lightmap resolution.
     * @param {number} settings.render.lightmapMode - The lightmap baking mode. Can be:
     *
     * - {@link BAKE_COLOR}: single color lightmap
     * - {@link BAKE_COLORDIR}: single color lightmap + dominant light direction (used for bump/specular)
     *
     * Only lights with bakeDir=true will be used for generating the dominant light direction.
     * @example
     *
     * var settings = {
     *     physics: {
     *         gravity: [0, -9.8, 0]
     *     },
     *     render: {
     *         fog_end: 1000,
     *         tonemapping: 0,
     *         skybox: null,
     *         fog_density: 0.01,
     *         gamma_correction: 1,
     *         exposure: 1,
     *         fog_start: 1,
     *         global_ambient: [0, 0, 0],
     *         skyboxIntensity: 1,
     *         skyboxRotation: [0, 0, 0],
     *         fog_color: [0, 0, 0],
     *         lightmapMode: 1,
     *         fog: 'none',
     *         lightmapMaxResolution: 2048,
     *         skyboxMip: 2,
     *         lightmapSizeMultiplier: 16
     *     }
     * };
     * app.applySceneSettings(settings);
     */
    applySceneSettings(settings: {
        physics: {
            gravity: number[];
        };
        render: {
            global_ambient: number[];
            fog: string;
            fog_color: number[];
            fog_density: number;
            fog_start: number;
            fog_end: number;
            gamma_correction: number;
            tonemapping: number;
            exposure: number;
            skybox?: number | null;
            skyboxIntensity: number;
            skyboxMip: number;
            skyboxRotation: number[];
            lightmapSizeMultiplier: number;
            lightmapMaxResolution: number;
            lightmapMode: number;
        };
    }): void;
    /**
     * Sets the area light LUT asset for this app.
     *
     * @param {Asset} asset - LUT asset of type `binary` to be set.
     */
    setAreaLightLuts(asset: Asset$6): void;
    /**
     * Sets the skybox asset to current scene, and subscribes to asset load/change events.
     *
     * @param {Asset} asset - Asset of type `skybox` to be set to, or null to remove skybox.
     */
    setSkybox(asset: Asset$6): void;
    /**
     * Create and assign a {@link VrManager} object to allow this application render in VR.
     *
     * @private
     * @deprecated
     */
    private enableVr;
    /**
     * Destroy the {@link VrManager}.
     *
     * @private
     * @deprecated
     */
    private disableVr;
    _firstBake(): void;
    _firstBatch(): void;
    _processTimestamp(timestamp: any): any;
    /**
     * Draws a single line. Line start and end coordinates are specified in world-space. The line
     * will be flat-shaded with the specified color.
     *
     * @param {Vec3} start - The start world-space coordinate of the line.
     * @param {Vec3} end - The end world-space coordinate of the line.
     * @param {Color} [color] - The color of the line. It defaults to white if not specified.
     * @param {boolean} [depthTest] - Specifies if the line is depth tested against the depth
     * buffer. Defaults to true.
     * @param {Layer} [layer] - The layer to render the line into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @example
     * // Render a 1-unit long white line
     * var start = new pc.Vec3(0, 0, 0);
     * var end = new pc.Vec3(1, 0, 0);
     * app.drawLine(start, end);
     * @example
     * // Render a 1-unit long red line which is not depth tested and renders on top of other geometry
     * var start = new pc.Vec3(0, 0, 0);
     * var end = new pc.Vec3(1, 0, 0);
     * app.drawLine(start, end, pc.Color.RED, false);
     * @example
     * // Render a 1-unit long white line into the world layer
     * var start = new pc.Vec3(0, 0, 0);
     * var end = new pc.Vec3(1, 0, 0);
     * var worldLayer = app.scene.layers.getLayerById(pc.LAYERID_WORLD);
     * app.drawLine(start, end, pc.Color.WHITE, true, worldLayer);
     */
    drawLine(start: Vec3$1, end: Vec3$1, color?: Color$4, depthTest?: boolean, layer?: Layer$1): void;
    /**
     * Renders an arbitrary number of discrete line segments. The lines are not connected by each
     * subsequent point in the array. Instead, they are individual segments specified by two
     * points. Therefore, the lengths of the supplied position and color arrays must be the same
     * and also must be a multiple of 2. The colors of the ends of each line segment will be
     * interpolated along the length of each line.
     *
     * @param {Vec3[]} positions - An array of points to draw lines between. The length of the
     * array must be a multiple of 2.
     * @param {Color[]} colors - An array of colors to color the lines. This must be the same
     * length as the position array. The length of the array must also be a multiple of 2.
     * @param {boolean} [depthTest] - Specifies if the lines are depth tested against the depth
     * buffer. Defaults to true.
     * @param {Layer} [layer] - The layer to render the lines into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @example
     * // Render a single line, with unique colors for each point
     * var start = new pc.Vec3(0, 0, 0);
     * var end = new pc.Vec3(1, 0, 0);
     * app.drawLines([start, end], [pc.Color.RED, pc.Color.WHITE]);
     * @example
     * // Render 2 discrete line segments
     * var points = [
     *     // Line 1
     *     new pc.Vec3(0, 0, 0),
     *     new pc.Vec3(1, 0, 0),
     *     // Line 2
     *     new pc.Vec3(1, 1, 0),
     *     new pc.Vec3(1, 1, 1)
     * ];
     * var colors = [
     *     // Line 1
     *     pc.Color.RED,
     *     pc.Color.YELLOW,
     *     // Line 2
     *     pc.Color.CYAN,
     *     pc.Color.BLUE
     * ];
     * app.drawLines(points, colors);
     */
    drawLines(positions: Vec3$1[], colors: Color$4[], depthTest?: boolean, layer?: Layer$1): void;
    /**
     * Renders an arbitrary number of discrete line segments. The lines are not connected by each
     * subsequent point in the array. Instead, they are individual segments specified by two
     * points.
     *
     * @param {number[]} positions - An array of points to draw lines between. Each point is
     * represented by 3 numbers - x, y and z coordinate.
     * @param {number[]} colors - An array of colors to color the lines. This must be the same
     * length as the position array. The length of the array must also be a multiple of 2.
     * @param {boolean} [depthTest] - Specifies if the lines are depth tested against the depth
     * buffer. Defaults to true.
     * @param {Layer} [layer] - The layer to render the lines into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @example
     * // Render 2 discrete line segments
     * var points = [
     *     // Line 1
     *     0, 0, 0,
     *     1, 0, 0,
     *     // Line 2
     *     1, 1, 0,
     *     1, 1, 1
     * ];
     * var colors = [
     *     // Line 1
     *     1, 0, 0, 1,  // red
     *     0, 1, 0, 1,  // green
     *     // Line 2
     *     0, 0, 1, 1,  // blue
     *     1, 1, 1, 1   // white
     * ];
     * app.drawLineArrays(points, colors);
     */
    drawLineArrays(positions: number[], colors: number[], depthTest?: boolean, layer?: Layer$1): void;
    /**
     * Draws a wireframe sphere with center, radius and color.
     *
     * @param {Vec3} center - The center of the sphere.
     * @param {number} radius - The radius of the sphere.
     * @param {Color} [color] - The color of the sphere. It defaults to white if not specified.
     * @param {number} [segments] - Number of line segments used to render the circles forming the
     * sphere. Defaults to 20.
     * @param {boolean} [depthTest] - Specifies if the sphere lines are depth tested against the
     * depth buffer. Defaults to true.
     * @param {Layer} [layer] - The layer to render the sphere into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @example
     * // Render a red wire sphere with radius of 1
     * var center = new pc.Vec3(0, 0, 0);
     * app.drawWireSphere(center, 1.0, pc.Color.RED);
     * @private
     */
    private drawWireSphere;
    /**
     * Draws a wireframe axis aligned box specified by min and max points and color.
     *
     * @param {Vec3} minPoint - The min corner point of the box.
     * @param {Vec3} maxPoint - The max corner point of the box.
     * @param {Color} [color] - The color of the sphere. It defaults to white if not specified.
     * @param {boolean} [depthTest] - Specifies if the sphere lines are depth tested against the
     * depth buffer. Defaults to true.
     * @param {Layer} [layer] - The layer to render the sphere into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @example
     * // Render a red wire aligned box
     * var min = new pc.Vec3(-1, -1, -1);
     * var max = new pc.Vec3(1, 1, 1);
     * app.drawWireAlignedBox(min, max, pc.Color.RED);
     * @private
     */
    private drawWireAlignedBox;
    drawMeshInstance(meshInstance: any, layer?: Layer$1): void;
    drawMesh(mesh: any, material: any, matrix: any, layer?: Layer$1): void;
    drawQuad(matrix: any, material: any, layer?: Layer$1): void;
    drawTexture(x: any, y: any, width: any, height: any, texture: any, material: any, layer?: Layer$1): void;
    drawDepthTexture(x: any, y: any, width: any, height: any, layer?: Layer$1): void;
    /**
     * Destroys application and removes all event listeners at the end of the current engine frame
     * update. However, if called outside of the engine frame update, calling destroy() will
     * destroy the application immediately.
     *
     * @example
     * app.destroy();
     */
    destroy(): void;
    controller: any;
    /**
     * Get entity from the index by guid.
     *
     * @param {string} guid - The GUID to search for.
     * @returns {Entity} The Entity with the GUID or null.
     * @private
     */
    private getEntityFromIndex;
    _registerSceneImmediate(scene: any): void;
}

declare class CameraComponentData {
    enabled: boolean;
}

/**
 * Used to add and remove {@link CameraComponent}s from Entities. It also holds an array of all
 * active cameras.
 *
 * @property {CameraComponent[]} cameras Holds all the active camera components.
 * @augments ComponentSystem
 */
declare class CameraComponentSystem$1 extends ComponentSystem {
    id: string;
    ComponentType: typeof CameraComponent$2;
    DataType: typeof CameraComponentData;
    cameras: any[];
    onBeforeRemove(entity: any, component: any): void;
    onUpdate(dt: any): void;
    onAppPrerender(): void;
    addCamera(camera: any): void;
    removeCamera(camera: any): void;
    sortCamerasByPriority(): void;
}

type RenderTarget = RenderTarget$3;
type Color = Color$4;
type Mat4 = Mat4$5;
type Vec3 = Vec3$1;
type Vec4$1 = Vec4$6;
type xrErrorCallback = xrErrorCallback$1;
type Entity$2 = Entity$a;
type CameraComponentSystem = CameraComponentSystem$1;
/**
 * Callback used by {@link CameraComponentcalculateTransform } and {@link CameraComponentcalculateProjection }.
 */
type calculateMatrixCallback = (transformMatrix: Mat4, view: number) => any;
/**
 * Callback used by {@link CameraComponent#calculateTransform} and {@link CameraComponent#calculateProjection}.
 *
 * @callback calculateMatrixCallback
 * @param {Mat4} transformMatrix - Output of the function.
 * @param {number} view - Type of view. Can be {@link VIEW_CENTER}, {@link VIEW_LEFT} or {@link VIEW_RIGHT}. Left and right are only used in stereo rendering.
 */
/**
 * Callback used by {@link CameraComponent#enterVr} and {@link CameraComponent#exitVr}.
 *
 * @callback vrCameraCallback
 * @param {string|null} err - On success it is null on failure it is the error message.
 */
/**
 * The Camera Component enables an Entity to render the scene. A scene requires at least one
 * enabled camera component to be rendered. Note that multiple camera components can be enabled
 * simultaneously (for split-screen or offscreen rendering, for example).
 *
 * ```javascript
 * // Add a pc.CameraComponent to an entity
 * var entity = new pc.Entity();
 * entity.addComponent('camera', {
 *     nearClip: 1,
 *     farClip: 100,
 *     fov: 55
 * });
 *
 * // Get the pc.CameraComponent on an entity
 * var cameraComponent = entity.camera;
 *
 * // Update a property on a camera component
 * entity.camera.nearClip = 2;
 * ```
 *
 * @property {number} projection The type of projection used to render the camera. Can be:
 *
 * - {@link PROJECTION_PERSPECTIVE}: A perspective projection. The camera frustum
 * resembles a truncated pyramid.
 * - {@link PROJECTION_ORTHOGRAPHIC}: An orthographic projection. The camera
 * frustum is a cuboid.
 *
 * Defaults to {@link PROJECTION_PERSPECTIVE}.
 * @property {number} aspectRatio The aspect ratio (width divided by height) of the camera. If
 * aspectRatioMode is {@link ASPECT_AUTO}, then this value will be automatically calculated every
 * frame, and you can only read it. If it's ASPECT_MANUAL, you can set the value.
 * @property {number} aspectRatioMode The aspect ratio mode of the camera. Can be:
 *
 * - {@link ASPECT_AUTO}: aspect ratio will be calculated from the current render
 * target's width divided by height.
 * - {@link ASPECT_MANUAL}: use the aspectRatio value.
 *
 * Defaults to {@link ASPECT_AUTO}.
 * @property {Color} clearColor The color used to clear the canvas to before the camera starts to
 * render. Defaults to [0.75, 0.75, 0.75, 1].
 * @property {number} farClip The distance from the camera after which no rendering will take
 * place. Defaults to 1000.
 * @property {number} fov The field of view of the camera in degrees. Usually this is the Y-axis
 * field of view, see {@link CameraComponent#horizontalFov}. Used for
 * {@link PROJECTION_PERSPECTIVE} cameras only. Defaults to 45.
 * @property {boolean} horizontalFov Set which axis to use for the Field of View calculation.
 * Defaults to false.
 * @property {number} nearClip The distance from the camera before which no rendering will take
 * place. Defaults to 0.1.
 * @property {number} orthoHeight The half-height of the orthographic view window (in the Y-axis).
 * Used for {@link PROJECTION_ORTHOGRAPHIC} cameras only. Defaults to 10.
 * @property {Vec4} scissorRect Clips all pixels which are not in the rectangle. The order of the
 * values is [x, y, width, height]. Defaults to [0, 0, 1, 1].
 * @property {boolean} frustumCulling Controls the culling of mesh instances against the camera
 * frustum, i.e. if objects outside of camera should be omitted from rendering. If false, all mesh
 * instances in the scene are rendered by the camera, regardless of visibility. Defaults to false.
 * @property {calculateMatrixCallback} calculateTransform Custom function you can provide to
 * calculate the camera transformation matrix manually. Can be used for complex effects like
 * reflections. Function is called using component's scope. Arguments:
 *
 * - {@link Mat4} transformMatrix: output of the function.
 * - view: Type of view. Can be {@link VIEW_CENTER}, {@link VIEW_LEFT} or {@link VIEW_RIGHT}.
 *
 * Left and right are only used in stereo rendering.
 * @property {calculateMatrixCallback} calculateProjection Custom function you can provide to
 * calculate the camera projection matrix manually. Can be used for complex effects like doing
 * oblique projection. Function is called using component's scope. Arguments:
 *
 * - {@link Mat4} transformMatrix: output of the function
 * - view: Type of view. Can be {@link VIEW_CENTER}, {@link VIEW_LEFT} or {@link VIEW_RIGHT}.
 *
 * Left and right are only used in stereo rendering.
 * @property {boolean} cullFaces If true the camera will take material.cull into account. Otherwise
 * both front and back faces will be rendered. Defaults to true.
 * @property {boolean} flipFaces If true the camera will invert front and back faces. Can be useful
 * for reflection rendering. Defaults to false.
 * @augments Component
 */
declare class CameraComponent$2 extends Component$2 {
    /**
     * Create a new CameraComponent instance.
     *
     * @param {CameraComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: CameraComponentSystem, entity: Entity$2);
    /**
     * Custom function that is called when postprocessing should execute.
     *
     * @type {Function}
     * @private
     */
    private onPostprocessing;
    /**
     * Custom function that is called before the camera renders the scene.
     *
     * @type {Function}
     */
    onPreRender: Function;
    /**
     * Custom function that is called after the camera renders the scene.
     *
     * @type {Function}
     */
    onPostRender: Function;
    _camera: Camera;
    _priority: number;
    _disablePostEffectsLayer: number;
    _postEffects: PostEffectQueue;

    set aspectRatioMode(arg: number);
    get aspectRatioMode(): number;

    set calculateProjection(arg: calculateMatrixCallback);
    get calculateProjection(): calculateMatrixCallback;

    set calculateTransform(arg: calculateMatrixCallback);
    get calculateTransform(): calculateMatrixCallback;

    set clearColor(arg: Color);
    get clearColor(): Color;

    set cullFaces(arg: boolean);
    get cullFaces(): boolean;

    set farClip(arg: number);
    get farClip(): number;

    set flipFaces(arg: boolean);
    get flipFaces(): boolean;

    set fov(arg: number);
    get fov(): number;

    set frustumCulling(arg: boolean);
    get frustumCulling(): boolean;

    set horizontalFov(arg: boolean);
    get horizontalFov(): boolean;

    set nearClip(arg: number);
    get nearClip(): number;

    set orthoHeight(arg: number);
    get orthoHeight(): number;

    set projection(arg: number);
    get projection(): number;

    set scissorRect(arg: Vec4$1);
    get scissorRect(): Vec4$1;

    /**
     * Queries the camera component's underlying Camera instance.
     *
     * @type {Camera}
     * @private
     */
    private get camera();
    /**
     * If true the camera will clear the color buffer to the color set in clearColor. Defaults to true.
     *
     * @type {boolean}
     */
    set clearColorBuffer(arg: boolean);
    get clearColorBuffer(): boolean;
    /**
     * If true the camera will clear the depth buffer. Defaults to true.
     *
     * @type {boolean}
     */
    set clearDepthBuffer(arg: boolean);
    get clearDepthBuffer(): boolean;
    /**
     * If true the camera will clear the stencil buffer. Defaults to true.
     *
     * @type {boolean}
     */
    set clearStencilBuffer(arg: boolean);
    get clearStencilBuffer(): boolean;
    /**
     * Layer ID of a layer on which the postprocessing of the camera stops being applied to.
     * Defaults to LAYERID_UI, which causes post processing to not be applied to UI layer and any
     * following layers for the camera. Set to undefined for post-processing to be applied to all
     * layers of the camera.
     *
     * @type {number}
     */
    set disablePostEffectsLayer(arg: number);
    get disablePostEffectsLayer(): number;
    /**
     * Queries the camera's frustum shape.
     *
     * @type {Frustum}
     */
    get frustum(): Frustum;
    /**
     * An array of layer IDs ({@link Layer#id}) to which this camera should belong. Don't push,
     * pop, splice or modify this array, if you want to change it, set a new one instead. Defaults
     * to [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE].
     *
     * @type {number[]}
     */
    set layers(arg: number[]);
    get layers(): number[];
    /**
     * The post effects queue for this camera. Use this to add or remove post effects from the camera.
     *
     * @type {PostEffectQueue}
     */
    get postEffectsEnabled(): PostEffectQueue;
    get postEffects(): PostEffectQueue;
    /**
     * Controls the order in which cameras are rendered. Cameras with smaller values for priority
     * are rendered first. Defaults to 0.
     *
     * @type {number}
     */
    set priority(arg: number);
    get priority(): number;
    /**
     * Queries the camera's projection matrix.
     *
     * @type {Mat4}
     */
    get projectionMatrix(): Mat4$5;
    /**
     * Controls where on the screen the camera will be rendered in normalized screen coordinates.
     * Defaults to [0, 0, 1, 1].
     *
     * @type {Vec4}
     */
    set rect(arg: Vec4$6);
    get rect(): Vec4$6;
    /**
     * Render target to which rendering of the cameras is performed. If not set, it will render
     * simply to the screen.
     *
     * @type {RenderTarget}
     */
    set renderTarget(arg: any);
    get renderTarget(): any;
    /**
     * Queries the camera's view matrix.
     *
     * @type {Mat4}
     */
    get viewMatrix(): Mat4$5;
    dirtyLayerCompositionCameras(): void;
    /**
     * Convert a point from 2D screen space to 3D world space.
     *
     * @param {number} screenx - X coordinate on PlayCanvas' canvas element. Should be in the range
     * 0 to `canvas.offsetWidth` of the application's canvas element.
     * @param {number} screeny - Y coordinate on PlayCanvas' canvas element. Should be in the range
     * 0 to `canvas.offsetHeight` of the application's canvas element.
     * @param {number} cameraz - The distance from the camera in world space to create the new
     * point.
     * @param {Vec3} [worldCoord] - 3D vector to receive world coordinate result.
     * @example
     * // Get the start and end points of a 3D ray fired from a screen click position
     * var start = entity.camera.screenToWorld(clickX, clickY, entity.camera.nearClip);
     * var end = entity.camera.screenToWorld(clickX, clickY, entity.camera.farClip);
     *
     * // Use the ray coordinates to perform a raycast
     * app.systems.rigidbody.raycastFirst(start, end, function (result) {
     *     console.log("Entity " + result.entity.name + " was selected");
     * });
     * @returns {Vec3} The world space coordinate.
     */
    screenToWorld(screenx: number, screeny: number, cameraz: number, worldCoord?: Vec3): Vec3;
    /**
     * Convert a point from 3D world space to 2D screen space.
     *
     * @param {Vec3} worldCoord - The world space coordinate.
     * @param {Vec3} [screenCoord] - 3D vector to receive screen coordinate result.
     * @returns {Vec3} The screen space coordinate.
     */
    worldToScreen(worldCoord: Vec3, screenCoord?: Vec3): Vec3;
    onAppPrerender(): void;
    addCameraToLayers(): void;
    removeCameraFromLayers(): void;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    onRemove(): void;
    /**
     * Calculates aspect ratio value for a given render target.
     *
     * @param {RenderTarget} [rt] - Optional render target. If unspecified, the backbuffer is used.
     * @returns {number} The aspect ratio of the render target (or backbuffer).
     */
    calculateAspectRatio(rt?: RenderTarget): number;
    /**
     * Start rendering the frame for this camera.
     *
     * @param {RenderTarget} rt - Render target to which rendering will be performed. Will affect
     * camera's aspect ratio, if aspectRatioMode is {@link ASPECT_AUTO}.
     * @private
     */
    private frameBegin;
    aspectRatio: number;
    /**
     * End rendering the frame for this camera.
     *
     * @private
     */
    private frameEnd;
    /**
     * @private
     * @deprecated
     * @function
     * @name CameraComponent#enterVr
     * @description Attempt to start presenting this camera to a {@link VrDisplay}.
     * @param {vrCameraCallback} callback - Function called once to indicate success
     * of failure. The callback takes one argument (err).
     * On success it returns null on failure it returns the error message.
     * @example
     * // On an entity with a camera component
     * this.entity.camera.enterVr(function (err) {
     *     if (err) {
     *         console.error(err);
     *     } else {
     *         // in VR!
     *     }
     * });
     */
    /**
     * @private
     * @deprecated
     * @function
     * @name CameraComponent#enterVr
     * @variation 2
     * @description Attempt to start presenting this camera to a {@link VrDisplay}.
     * @param {VrDisplay} display - The VrDisplay to present. If not supplied this uses
     * {@link VrManager#display} as the default.
     * @param {vrCameraCallback} callback - Function called once to indicate success
     * of failure. The callback takes one argument (err). On success it returns null on
     * failure it returns the error message.
     * @example
     * // On an entity with a camera component
     * this.entity.camera.enterVr(function (err) {
     *     if (err) {
     *         console.error(err);
     *     } else {
     *         // in VR!
     *     }
     * });
     */
    private enterVr;
    /**
     * Attempt to stop presenting this camera.
     *
     * @param {vrCameraCallback} callback - Function called once to indicate success of failure.
     * The callback takes one argument (err). On success it returns null on failure it returns the
     * error message.
     * @example
     * this.entity.camera.exitVr(function (err) {
     *     if (err) {
     *         console.error(err);
     *     } else {
     *         // exited successfully
     *     }
     * });
     * @private
     * @deprecated
     */
    private exitVr;
    vrDisplay: any;
    /**
     * Attempt to start XR session with this camera.
     *
     * @param {string} type - The type of session. Can be one of the following:
     *
     * - {@link XRTYPE_INLINE}: Inline - always available type of session. It has limited feature
     * availability and is rendered into HTML element.
     * - {@link XRTYPE_VR}: Immersive VR - session that provides exclusive access to the VR device
     * with the best available tracking features.
     * - {@link XRTYPE_AR}: Immersive AR - session that provides exclusive access to the VR/AR
     * device that is intended to be blended with the real-world environment.
     *
     * @param {string} spaceType - Reference space type. Can be one of the following:
     *
     * - {@link XRSPACE_VIEWER}: Viewer - always supported space with some basic tracking
     * capabilities.
     * - {@link XRSPACE_LOCAL}: Local - represents a tracking space with a native origin near the
     * viewer at the time of creation. It is meant for seated or basic local XR sessions.
     * - {@link XRSPACE_LOCALFLOOR}: Local Floor - represents a tracking space with a native origin
     * at the floor in a safe position for the user to stand. The y-axis equals 0 at floor level.
     * Floor level value might be estimated by the underlying platform. It is meant for seated or
     * basic local XR sessions.
     * - {@link XRSPACE_BOUNDEDFLOOR}: Bounded Floor - represents a tracking space with its native
     * origin at the floor, where the user is expected to move within a pre-established boundary.
     * - {@link XRSPACE_UNBOUNDED}: Unbounded - represents a tracking space where the user is
     * expected to move freely around their environment, potentially long distances from their
     * starting point.
     *
     * @param {object} [options] - Object with options for XR session initialization.
     * @param {string[]} [options.optionalFeatures] - Optional features for XRSession start. It is
     * used for getting access to additional WebXR spec extensions.
     * @param {boolean} [options.imageTracking] - Set to true to attempt to enable {@link XrImageTracking}.
     * @param {boolean} [options.planeDetection] - Set to true to attempt to enable {@link XrPlaneDetection}.
     * @param {xrErrorCallback} [options.callback] - Optional callback function called once the
     * session is started. The callback has one argument Error - it is null if the XR session
     * started successfully.
     * @param {object} [options.depthSensing] - Optional object with depth sensing parameters to
     * attempt to enable {@link XrDepthSensing}.
     * @param {string} [options.depthSensing.usagePreference] - Optional usage preference for depth
     * sensing, can be 'cpu-optimized' or 'gpu-optimized' (XRDEPTHSENSINGUSAGE_*), defaults to
     * 'cpu-optimized'. Most preferred and supported will be chosen by the underlying depth sensing
     * system.
     * @param {string} [options.depthSensing.dataFormatPreference] - Optional data format
     * preference for depth sensing. Can be 'luminance-alpha' or 'float32' (XRDEPTHSENSINGFORMAT_*),
     * defaults to 'luminance-alpha'. Most preferred and supported will be chosen by the underlying
     * depth sensing system.
     * @example
     * // On an entity with a camera component
     * this.entity.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {
     *     callback: function (err) {
     *         if (err) {
     *             // failed to start XR session
     *         } else {
     *             // in XR
     *         }
     *     }
     * });
     */
    startXr(type: string, spaceType: string, options?: {
        optionalFeatures?: string[];
        imageTracking?: boolean;
        planeDetection?: boolean;
        callback?: xrErrorCallback;
        depthSensing?: {
            usagePreference?: string;
            dataFormatPreference?: string;
        };
    }): void;
    /**
     * Attempt to end XR session of this camera.
     *
     * @param {xrErrorCallback} [callback] - Optional callback function called once session is
     * ended. The callback has one argument Error - it is null if successfully ended XR session.
     * @example
     * // On an entity with a camera component
     * this.entity.camera.endXr(function (err) {
     *     // not anymore in XR
     * });
     */
    endXr(callback?: xrErrorCallback): void;
    copy(source: any): void;
}

type Application$6 = Application$7;
type CameraComponent$1 = CameraComponent$2;
/**
 * Used to manage multiple post effects for a camera.
 */
declare class PostEffectQueue {
    /**
     * Create a new PostEffectQueue instance.
     *
     * @param {Application} app - The application.
     * @param {CameraComponent} camera - The camera component.
     */
    constructor(app: Application$6, camera: CameraComponent$1);
    app: Application$7;
    camera: CameraComponent$2;
    destinationRenderTarget: any;
    effects: any[];
    enabled: boolean;
    depthTarget: any;
    renderTargetScale: number;
    resizeTimeout: NodeJS.Timeout;
    resizeLast: number;
    _resizeTimeoutCallback: () => void;
    _allocateColorBuffer(format: any, name: any): Texture$8;
    /**
     * Creates a render target with the dimensions of the canvas, with an optional depth buffer.
     *
     * @param {boolean} useDepth - Set to true to create a render target with a depth buffer.
     * @param {boolean} hdr - Use HDR render target format.
     * @returns {RenderTarget} The render target.
     * @private
     */
    private _createOffscreenTarget;
    _resizeOffscreenTarget(rt: any): void;
    _destroyOffscreenTarget(rt: any): void;
    setRenderTargetScale(scale: any): void;
    /**
     * Adds a post effect to the queue. If the queue is disabled adding a post effect will
     * automatically enable the queue.
     *
     * @param {PostEffect} effect - The post effect to add to the queue.
     */
    addEffect(effect: PostEffect): void;
    _sourceTarget: any;
    _newPostEffect: PostEffect;
    /**
     * Removes a post effect from the queue. If the queue becomes empty it will be disabled
     * automatically.
     *
     * @param {PostEffect} effect - The post effect to remove.
     */
    removeEffect(effect: PostEffect): void;
    _requestDepthMaps(): void;
    _releaseDepthMaps(): void;
    _requestDepthMap(): void;
    _releaseDepthMap(): void;
    /**
     * Removes all the effects from the queue and disables it.
     */
    destroy(): void;
    /**
     * Enables the queue and all of its effects. If there are no effects then the queue will not be
     * enabled.
     */
    enable(): void;
    /**
     * Disables the queue and all of its effects.
     */
    disable(): void;
    _onCanvasResized(width: any, height: any): void;
    resizeRenderTargets(): void;
    onCameraRectChanged(name: any, oldValue: any, newValue: any): void;
}

declare class PostEffect {
    constructor(effect: any, inputTarget: any);
    effect: any;
    inputTarget: any;
    outputTarget: any;
    name: any;
}

declare function partitionSkin(model: any, materialMappings: any, boneLimit: any): void;

type GraphicsDevice$7 = GraphicsDevice$l;
/**
 * Generates normal information from the specified positions and triangle indices. See
 * {@link createMesh}.
 *
 * @param {number[]} positions - An array of 3-dimensional vertex positions.
 * @param {number[]} indices - An array of triangle indices.
 * @returns {number[]} An array of 3-dimensional vertex normals.
 * @example
 * var normals = pc.calculateNormals(positions, indices);
 * var tangents = pc.calculateTangents(positions, normals, uvs, indices);
 * var mesh = pc.createMesh(positions, normals, tangents, uvs, indices);
 */
declare function calculateNormals(positions: number[], indices: number[]): number[];
/**
 * Generates tangent information from the specified positions, normals, texture coordinates and
 * triangle indices. See {@link createMesh}.
 *
 * @param {number[]} positions - An array of 3-dimensional vertex positions.
 * @param {number[]} normals - An array of 3-dimensional vertex normals.
 * @param {number[]} uvs - An array of 2-dimensional vertex texture coordinates.
 * @param {number[]} indices - An array of triangle indices.
 * @returns {number[]} An array of 3-dimensional vertex tangents.
 * @example
 * var tangents = pc.calculateTangents(positions, normals, uvs, indices);
 * var mesh = pc.createMesh(positions, normals, tangents, uvs, indices);
 */
declare function calculateTangents(positions: number[], normals: number[], uvs: number[], indices: number[]): number[];
/**
 * Creates a procedural box-shaped mesh.
 *
 * The size, shape and tesselation properties of the box can be controlled via function parameters.
 * By default, the function will create a box centered on the object space origin with a width,
 * length and height of 1.0 unit and 10 segments in either axis (50 triangles per face).
 *
 * Note that the box is created with UVs in the range of 0 to 1 on each face. Additionally, tangent
 * information is generated into the vertex buffer of the box's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {Vec3} [opts.halfExtents] - The half dimensions of the box in each axis (defaults to
 * [0.5, 0.5, 0.5]).
 * @param {number} [opts.widthSegments] - The number of divisions along the X axis of the box
 * (defaults to 1).
 * @param {number} [opts.lengthSegments] - The number of divisions along the Z axis of the box
 * (defaults to 1).
 * @param {number} [opts.heightSegments] - The number of divisions along the Y axis of the box
 * (defaults to 1).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new box-shaped mesh.
 */
declare function createBox(device: GraphicsDevice$7, opts?: {
    halfExtents?: Vec3$1;
    widthSegments?: number;
    lengthSegments?: number;
    heightSegments?: number;
    calculateTangents?: boolean;
}): Mesh$1;
/**
 * Creates a procedural capsule-shaped mesh.
 *
 * The size, shape and tesselation properties of the capsule can be controlled via function
 * parameters. By default, the function will create a capsule standing vertically centered on the
 * XZ-plane with a radius of 0.25, a height of 1.0, 1 height segment and 10 cap segments.
 *
 * Note that the capsule is created with UVs in the range of 0 to 1. Additionally, tangent
 * information is generated into the vertex buffer of the capsule's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {number} [opts.radius] - The radius of the tube forming the body of the capsule (defaults
 * to 0.3).
 * @param {number} [opts.height] - The length of the body of the capsule from tip to tip (defaults
 * to 1.0).
 * @param {number} [opts.heightSegments] - The number of divisions along the tubular length of the
 * capsule (defaults to 1).
 * @param {number} [opts.sides] - The number of divisions around the tubular body of the capsule
 * (defaults to 20).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new cylinder-shaped mesh.
 */
declare function createCapsule(device: GraphicsDevice$7, opts?: {
    radius?: number;
    height?: number;
    heightSegments?: number;
    sides?: number;
    calculateTangents?: boolean;
}): Mesh$1;
/**
 * Creates a procedural cone-shaped mesh.
 *
 * The size, shape and tesselation properties of the cone can be controlled via function
 * parameters. By default, the function will create a cone standing vertically centered on the
 * XZ-plane with a base radius of 0.5, a height of 1.0, 5 height segments and 20 cap segments.
 *
 * Note that the cone is created with UVs in the range of 0 to 1. Additionally, tangent information
 * is generated into the vertex buffer of the cone's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {number} [opts.baseRadius] - The base radius of the cone (defaults to 0.5).
 * @param {number} [opts.peakRadius] - The peak radius of the cone (defaults to 0.0).
 * @param {number} [opts.height] - The length of the body of the cone (defaults to 1.0).
 * @param {number} [opts.heightSegments] - The number of divisions along the length of the cone
 * (defaults to 5).
 * @param {number} [opts.capSegments] - The number of divisions around the tubular body of the cone
 * (defaults to 18).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new cone-shaped mesh.
 */
declare function createCone(device: GraphicsDevice$7, opts?: {
    baseRadius?: number;
    peakRadius?: number;
    height?: number;
    heightSegments?: number;
    capSegments?: number;
    calculateTangents?: boolean;
}): Mesh$1;
/**
 * Creates a procedural cylinder-shaped mesh.
 *
 * The size, shape and tesselation properties of the cylinder can be controlled via function
 * parameters. By default, the function will create a cylinder standing vertically centered on the
 * XZ-plane with a radius of 0.5, a height of 1.0, 1 height segment and 20 cap segments.
 *
 * Note that the cylinder is created with UVs in the range of 0 to 1. Additionally, tangent
 * information is generated into the vertex buffer of the cylinder's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {number} [opts.radius] - The radius of the tube forming the body of the cylinder (defaults to 0.5).
 * @param {number} [opts.height] - The length of the body of the cylinder (defaults to 1.0).
 * @param {number} [opts.heightSegments] - The number of divisions along the length of the cylinder (defaults to 5).
 * @param {number} [opts.capSegments] - The number of divisions around the tubular body of the cylinder (defaults to 20).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new cylinder-shaped mesh.
 */
declare function createCylinder(device: GraphicsDevice$7, opts?: {
    radius?: number;
    height?: number;
    heightSegments?: number;
    capSegments?: number;
    calculateTangents?: boolean;
}): Mesh$1;
/**
 * Creates a new mesh object from the supplied vertex information and topology.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {number[]} positions - An array of 3-dimensional vertex positions.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {number[]} [opts.normals] - An array of 3-dimensional vertex normals.
 * @param {number[]} [opts.tangents] - An array of 3-dimensional vertex tangents.
 * @param {number[]} [opts.colors] - An array of 4-dimensional vertex colors where each component
 * is an integer in the range 0 to 255.
 * @param {number[]} [opts.uvs] - An array of 2-dimensional vertex texture coordinates.
 * @param {number[]} [opts.uvs1] - Same as opts.uvs, but for additional UV set
 * @param {number[]} [opts.blendIndices] - An array of 4-dimensional bone indices where each
 * component is an integer in the range 0 to 255.
 * @param {number[]} [opts.blendWeights] - An array of 4-dimensional bone weights where each
 * component is in the range 0 to 1 and the sum of the weights should equal 1.
 * @param {number[]} [opts.indices] - An array of triangle indices.
 * @returns {Mesh} A new Mesh constructed from the supplied vertex and triangle data.
 * @example
 * // Create a simple, indexed triangle (with texture coordinates and vertex normals)
 * var mesh = pc.createMesh(graphicsDevice, [0, 0, 0, 1, 0, 0, 0, 1, 0], {
 *     normals: [0, 0, 1, 0, 0, 1, 0, 0, 1],
 *     uvs: [0, 0, 1, 0, 0, 1],
 *     indices: [0, 1, 2]
 * });
 */
declare function createMesh(device: GraphicsDevice$7, positions: number[], opts?: {
    normals?: number[];
    tangents?: number[];
    colors?: number[];
    uvs?: number[];
    uvs1?: number[];
    blendIndices?: number[];
    blendWeights?: number[];
    indices?: number[];
}): Mesh$1;
/**
 * Creates a procedural plane-shaped mesh.
 *
 * The size and tesselation properties of the plane can be controlled via function parameters. By
 * default, the function will create a plane centered on the object space origin with a width and
 * length of 1.0 and 5 segments in either axis (50 triangles). The normal vector of the plane is
 * aligned along the positive Y axis.
 *
 * Note that the plane is created with UVs in the range of 0 to 1. Additionally, tangent
 * information is generated into the vertex buffer of the plane's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {Vec2} [opts.halfExtents] - The half dimensions of the plane in the X and Z axes
 * (defaults to [0.5, 0.5]).
 * @param {number} [opts.widthSegments] - The number of divisions along the X axis of the plane
 * (defaults to 5).
 * @param {number} [opts.lengthSegments] - The number of divisions along the Z axis of the plane
 * (defaults to 5).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new plane-shaped mesh.
 */
declare function createPlane(device: GraphicsDevice$7, opts?: {
    halfExtents?: Vec2$3;
    widthSegments?: number;
    lengthSegments?: number;
    calculateTangents?: boolean;
}): Mesh$1;
/**
 * Creates a procedural sphere-shaped mesh.
 *
 * The size and tesselation properties of the sphere can be controlled via function parameters. By
 * default, the function will create a sphere centered on the object space origin with a radius of
 * 0.5 and 16 segments in both longitude and latitude.
 *
 * Note that the sphere is created with UVs in the range of 0 to 1. Additionally, tangent
 * information is generated into the vertex buffer of the sphere's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {number} [opts.radius] - The radius of the sphere (defaults to 0.5).
 * @param {number} [opts.latitudeBands] - The number of divisions along the latitudinal axis of the
 * sphere (defaults to 16).
 * @param {number} [opts.longitudeBands] - The number of divisions along the longitudinal axis of
 * the sphere (defaults to 16).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new sphere-shaped mesh.
 */
declare function createSphere(device: GraphicsDevice$7, opts?: {
    radius?: number;
    latitudeBands?: number;
    longitudeBands?: number;
    calculateTangents?: boolean;
}): Mesh$1;
/**
 * Creates a procedural torus-shaped mesh.
 *
 * The size, shape and tesselation properties of the torus can be controlled via function
 * parameters. By default, the function will create a torus in the XZ-plane with a tube radius of
 * 0.2, a ring radius of 0.3, 20 segments and 30 sides.
 *
 * Note that the torus is created with UVs in the range of 0 to 1. Additionally, tangent
 * information is generated into the vertex buffer of the torus's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {number} [opts.tubeRadius] - The radius of the tube forming the body of the torus
 * (defaults to 0.2).
 * @param {number} [opts.ringRadius] - The radius from the centre of the torus to the centre of the
 * tube (defaults to 0.3).
 * @param {number} [opts.segments] - The number of radial divisions forming cross-sections of the
 * torus ring (defaults to 20).
 * @param {number} [opts.sides] - The number of divisions around the tubular body of the torus ring
 * (defaults to 30).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new torus-shaped mesh.
 */
declare function createTorus(device: GraphicsDevice$7, opts?: {
    tubeRadius?: number;
    ringRadius?: number;
    segments?: number;
    sides?: number;
    calculateTangents?: boolean;
}): Mesh$1;

/**
 * A Depth material is for rendering linear depth values to a render target.
 *
 * @ignore
 */
declare class DepthMaterial extends Material$2 {
}

type Application$5 = Application$7;
type CameraComponent = CameraComponent$2;
type MeshInstance = MeshInstance$3;
type Scene = Scene$3;
/**
 * Picker object used to select mesh instances from screen coordinates.
 *
 * @property {number} width Width of the pick buffer in pixels (read-only).
 * @property {number} height Height of the pick buffer in pixels (read-only).
 * @property {RenderTarget} renderTarget The render target used by the picker internally
 * (read-only).
 */
declare class Picker {
    /**
     * Create a new Picker instance.
     *
     * @param {Application} app - The application managing this picker instance.
     * @param {number} width - The width of the pick buffer in pixels.
     * @param {number} height - The height of the pick buffer in pixels.
     */
    constructor(app: Application$5, width: number, height: number);
    app: Application$7;
    device: GraphicsDevice$l;
    pickColor: Float32Array;
    mapping: any[];
    cameraEntity: Entity$a;
    layer: Layer$1;
    layerComp: LayerComposition;
    _renderTarget: any;
    clearDepthCommand: Command;
    width: number;
    height: number;
    /**
     * Return the list of mesh instances selected by the specified rectangle in the previously
     * prepared pick buffer.The rectangle using top-left coordinate system.
     *
     * @param {number} x - The left edge of the rectangle.
     * @param {number} y - The top edge of the rectangle.
     * @param {number} [width] - The width of the rectangle.
     * @param {number} [height] - The height of the rectangle.
     * @returns {MeshInstance[]} An array of mesh instances that are in the selection.
     * @example
     * // Get the selection at the point (10,20)
     * var selection = picker.getSelection(10, 20);
     * @example
     * // Get all models in rectangle with corners at (10,20) and (20,40)
     * var selection = picker.getSelection(10, 20, 10, 20);
     */
    getSelection(x: number, y: number, width?: number, height?: number): MeshInstance[];
    allocateRenderTarget(): void;
    renderTarget: RenderTarget$3;
    releaseRenderTarget(): void;
    initLayerComposition(): void;
    /**
     * Primes the pick buffer with a rendering of the specified models from the point of view of
     * the supplied camera. Once the pick buffer has been prepared, {@link Picker#getSelection} can
     * be called multiple times on the same picker object. Therefore, if the models or camera do
     * not change in any way, {@link Picker#prepare} does not need to be called again.
     *
     * @param {CameraComponent} camera - The camera component used to render the scene.
     * @param {Scene} scene - The scene containing the pickable mesh instances.
     * @param {Layer[]} [layers] - Layers from which objects will be picked. If not supplied, all layers of the specified camera will be used.
     */
    prepare(camera: CameraComponent, scene: Scene, layers?: Layer$1[]): void;
    updateCamera(srcCamera: any): void;
    /**
     * Sets the resolution of the pick buffer. The pick buffer resolution does not need to match
     * the resolution of the corresponding frame buffer use for general rendering of the 3D scene.
     * However, the lower the resolution of the pick buffer, the less accurate the selection
     * results returned by {@link Picker#getSelection}. On the other hand, smaller pick buffers
     * will yield greater performance, so there is a trade off.
     *
     * @param {number} width - The width of the pick buffer in pixels.
     * @param {number} height - The height of the pick buffer in pixels.
     */
    resize(width: number, height: number): void;
}

/**
 * An animation is a sequence of keyframe arrays which map to the nodes of a skeletal hierarchy. It
 * controls how the nodes of the hierarchy are transformed over time.
 */
declare class Animation$1 {
    /**
     * Human-readable name of the animation.
     *
     * @type {string}
     */
    name: string;
    /**
     * Duration of the animation in seconds.
     *
     * @type {number}
     */
    duration: number;
    _nodes: any[];
    _nodeDict: {};
    /**
     * Gets a {@link Node} by name.
     *
     * @param {string} name - The name of the {@link Node}.
     * @returns {Node} The {@link Node} with the specified name.
     */
    getNode(name: string): Node$1;
    /**
     * Adds a node to the internal nodes array.
     *
     * @param {Node} node - The node to add.
     */
    addNode(node: Node$1): void;
    /**
     * A read-only property to get array of animation nodes.
     *
     * @type {Node[]}
     */
    get nodes(): Node$1[];
}
declare class Key {
    constructor(time: any, position: any, rotation: any, scale: any);
    time: any;
    position: any;
    rotation: any;
    scale: any;
}
/**
 * A animation node has a name and contains an array of keyframes.
 */
declare class Node$1 {
    _name: string;
    _keys: any[];
}

type GraphNode = GraphNode$3;
/**
 * Represents a skeleton used to play animations.
 */
declare class Skeleton {
    /**
     * Create a new Skeleton instance.
     *
     * @param {GraphNode} graph - The root {@link GraphNode} of the skeleton.
     */
    constructor(graph: GraphNode);
    /**
     * Determines whether skeleton is looping its animation.
     *
     * @type {boolean}
     */
    looping: boolean;
    /**
     * @type {Animation}
     * @private
     */
    private _animation;
    _time: number;
    _interpolatedKeys: any[];
    _interpolatedKeyDict: {};
    _currKeyIndices: {};
    graph: GraphNode$3;
    /**
     * Animation currently assigned to skeleton.
     *
     * @type {Animation}
     */
    set animation(arg: Animation);
    get animation(): Animation;
    /**
     * Current time of currently active animation in seconds. This value is between zero and the
     * duration of the animation.
     *
     * @type {number}
     */
    set currentTime(arg: number);
    get currentTime(): number;
    /**
     * Read-only property that returns number of nodes of a skeleton.
     *
     * @type {number}
     */
    get numNodes(): number;
    /**
     * Progresses the animation assigned to the specified skeleton by the supplied time delta. If
     * the delta takes the animation passed its end point, if the skeleton is set to loop, the
     * animation will continue from the beginning. Otherwise, the animation's current time will
     * remain at its duration (i.e. the end).
     *
     * @param {number} delta - The time in seconds to progress the skeleton's animation.
     */
    addTime(delta: number): void;
    /**
     * Blends two skeletons together.
     *
     * @param {Skeleton} skel1 - Skeleton holding the first pose to be blended.
     * @param {Skeleton} skel2 - Skeleton holding the second pose to be blended.
     * @param {number} alpha - The value controlling the interpolation in relation to the two input
     * skeletons. The value is in the range 0 to 1, 0 generating skel1, 1 generating skel2 and
     * anything in between generating a spherical interpolation between the two.
     */
    blend(skel1: Skeleton, skel2: Skeleton, alpha: number): void;
    /**
     * Links a skeleton to a node hierarchy. The nodes animated skeleton are then subsequently used
     * to drive the local transformation matrices of the node hierarchy.
     *
     * @param {GraphNode} graph - The root node of the graph that the skeleton is to drive.
     */
    setGraph(graph: GraphNode): void;
    /**
     * Synchronizes the currently linked node hierarchy with the current state of the skeleton.
     * Internally, this function converts the interpolated keyframe at each node in the skeleton
     * into the local transformation matrix at each corresponding node in the linked node
     * hierarchy.
     */
    updateGraph(): void;
}

type Sound$1 = Sound$3;
type SoundManager$2 = SoundManager$7;
/** @typedef {import('../sound/sound.js').Sound} Sound */
/** @typedef {import('../sound/manager.js').SoundManager} SoundManager */
/**
 * A channel is created when the {@link SoundManager} begins playback of a {@link Sound}. Usually
 * created internally by {@link SoundManager#playSound} or {@link SoundManager#playSound3d}.
 * Developers usually won't have to create Channels manually.
 *
 * @ignore
 */
declare class Channel {
    /**
     * Create a new Channel instance.
     *
     * @param {SoundManager} manager - The SoundManager instance.
     * @param {Sound} sound - The sound to playback.
     * @param {object} [options] - Optional options object.
     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
     * @param {boolean} [options.loop=false] - Whether the sound should loop when it reaches the
     * end or not.
     */
    constructor(manager: SoundManager$2, sound: Sound$1, options?: {
        volume?: number;
        pitch?: number;
        loop?: boolean;
    });
    volume: number;
    loop: boolean;
    pitch: number;
    sound: Sound$3;
    paused: boolean;
    suspended: boolean;
    manager: SoundManager$7;
    source: Node;
    startTime: number;
    startOffset: number;
    gain: any;
    /**
     * Get the current value for the volume. Between 0 and 1.
     *
     * @returns {number} The volume of the channel.
     */
    getVolume(): number;
    /**
     * Get the current looping state of the Channel.
     *
     * @returns {boolean} The loop property for the channel.
     */
    getLoop(): boolean;
    /**
     * Enable/disable the loop property to make the sound restart from the beginning when it
     * reaches the end.
     *
     * @param {boolean} loop - True to loop the sound, false otherwise.
     */
    setLoop(loop: boolean): void;
    /**
     * Get the current pitch of the Channel.
     *
     * @returns {number} The pitch of the channel.
     */
    getPitch(): number;
    /**
     * Handle the manager's 'volumechange' event.
     */
    onManagerVolumeChange(): void;
    /**
     * Handle the manager's 'suspend' event.
     */
    onManagerSuspend(): void;
    /**
     * Handle the manager's 'resume' event.
     */
    onManagerResume(): void;
    /**
     * Begin playback of sound.
     */
    play(): void;
    /**
     * Pause playback of sound. Call unpause() to resume playback from the same position.
     */
    pause(): void;
    /**
     * Resume playback of the sound. Playback resumes at the point that the audio was paused.
     */
    unpause(): void;
    /**
     * Stop playback of sound. Calling play() again will restart playback from the beginning of the
     * sound.
     */
    stop(): void;
    /**
     * Set the volume of playback between 0 and 1.
     *
     * @param {number} volume - The volume of the sound. Will be clamped between 0 and 1.
     */
    setVolume(volume: number): void;
    setPitch(pitch: any): void;
    isPlaying(): boolean;
    getDuration(): any;
    _createSource(): void;
}

/**
 * 3D audio channel.
 *
 * @ignore
 */
declare class Channel3d extends Channel {
    position: Vec3$1;
    velocity: Vec3$1;
    panner: any;
    maxDistance: number;
    minDistance: number;
    rollOffFactor: number;
    distanceModel: string;
    getPosition(): Vec3$1;
    getVelocity(): Vec3$1;
    setPosition(position: any): void;
    setVelocity(velocity: any): void;
    getMaxDistance(): any;
    setMaxDistance(max: any): void;
    getMinDistance(): any;
    setMinDistance(min: any): void;
    getRollOffFactor(): any;
    setRollOffFactor(factor: any): void;
    getDistanceModel(): any;
    setDistanceModel(distanceModel: any): void;
}

type TouchDevice = TouchDevice$2;
/** @typedef {import('./touch-device.js').TouchDevice} TouchDevice */
/**
 * Similar to {@link getTargetCoords} for the MouseEvents. This function takes a browser Touch
 * object and returns the coordinates of the touch relative to the target element.
 *
 * @param {globalThis.Touch} touch - The browser Touch object.
 * @returns {object} The coordinates of the touch relative to the touch.target element. In the
 * format {x, y}.
 */
declare function getTouchTargetCoords(touch: globalThis.Touch): object;
/**
 * A instance of a single point touch on a {@link TouchDevice}.
 */
declare class Touch$1 {
    /**
     * Create a new Touch object from the browser Touch.
     *
     * @param {globalThis.Touch} touch - The browser Touch object.
     */
    constructor(touch: globalThis.Touch);
    /**
     * The identifier of the touch.
     *
     * @type {number}
     */
    id: number;
    /**
     * The x coordinate relative to the element that the TouchDevice is attached to.
     *
     * @type {number}
     */
    x: number;
    /**
     * The y coordinate relative to the element that the TouchDevice is attached to.
     *
     * @type {number}
     */
    y: number;
    /**
     * The target element of the touch event.
     *
     * @type {Element}
     */
    target: Element;
    /**
     * The original browser Touch object.
     *
     * @type {globalThis.Touch}
     */
    touch: globalThis.Touch;
}
/**
 * A Event corresponding to touchstart, touchend, touchmove or touchcancel. TouchEvent wraps the
 * standard browser event and provides lists of {@link Touch} objects.
 */
declare class TouchEvent$1 {
    /**
     * Create a new TouchEvent instance. It is created from an existing browser event.
     *
     * @param {TouchDevice} device - The source device of the touch events.
     * @param {globalThis.TouchEvent} event - The original browser TouchEvent.
     */
    constructor(device: TouchDevice, event: globalThis.TouchEvent);
    /**
     * The target Element that the event was fired from.
     *
     * @type {Element}
     */
    element: Element;
    /**
     * The original browser TouchEvent.
     *
     * @type {globalThis.TouchEvent}
     */
    event: globalThis.TouchEvent;
    /**
     * A list of all touches currently in contact with the device.
     *
     * @type {Touch[]}
     */
    touches: Touch$1[];
    /**
     * A list of touches that have changed since the last event.
     *
     * @type {Touch[]}
     */
    changedTouches: Touch$1[];
    /**
     * Get an event from one of the touch lists by the id. It is useful to access
     * touches by their id so that you can be sure you are referencing the same
     * touch.
     *
     * @param {number} id - The identifier of the touch.
     * @param {Touch[]|null} list - An array of touches to search.
     * @returns {Touch} The {@link Touch} object or null.
     */
    getTouchById(id: number, list: Touch$1[] | null): Touch$1;
}

type GamePads = GamePads$2;
/** @typedef {import('./game-pads.js').GamePads} GamePads */
/**
 * A general input handler which handles both mouse and keyboard input assigned to named actions.
 * This allows you to define input handlers separately to defining keyboard/mouse configurations.
 */
declare class Controller {
    /**
     * Create a new instance of a Controller.
     *
     * @param {Element} [element] - Element to attach Controller to.
     * @param {object} [options] - Optional arguments.
     * @param {Keyboard} [options.keyboard] - A Keyboard object to use.
     * @param {Mouse} [options.mouse] - A Mouse object to use.
     * @param {GamePads} [options.gamepads] - A Gamepads object to use.
     * @example
     * var c = new pc.Controller(document);
     *
     * // Register the "fire" action and assign it to both the Enter key and the Spacebar.
     * c.registerKeys("fire", [pc.KEY_ENTER, pc.KEY_SPACE]);
     */
    constructor(element?: Element, options?: {
        keyboard?: Keyboard$2;
        mouse?: Mouse$2;
        gamepads?: GamePads;
    });
    _keyboard: Keyboard$2;
    _mouse: Mouse$2;
    _gamepads: GamePads$2;
    _element: Element;
    _actions: {};
    _axes: {};
    _axesValues: {};
    /**
     * Attach Controller to an Element. This is required before you can monitor for key/mouse
     * inputs.
     *
     * @param {Element} element - The element to attach mouse and keyboard event handler too.
     */
    attach(element: Element): void;
    /**
     * Detach Controller from an Element. This should be done before the Controller is destroyed.
     */
    detach(): void;
    /**
     * Disable the context menu usually activated with the right mouse button.
     */
    disableContextMenu(): void;
    /**
     * Enable the context menu usually activated with the right mouse button. This is enabled by
     * default.
     */
    enableContextMenu(): void;
    /**
     * Update the Keyboard and Mouse handlers.
     *
     * @param {object} dt - The time since the last frame.
     */
    update(dt: object): void;
    /**
     * Create or update a action which is enabled when the supplied keys are pressed.
     *
     * @param {string} action - The name of the action.
     * @param {number[]} keys - A list of keycodes.
     */
    registerKeys(action: string, keys: number[]): void;
    /**
     * Create or update an action which is enabled when the supplied mouse button is pressed.
     *
     * @param {string} action - The name of the action.
     * @param {number} button - The mouse button.
     */
    registerMouse(action: string, button: number): void;
    /**
     * Create or update an action which is enabled when the gamepad button is pressed.
     *
     * @param {string} action - The name of the action.
     * @param {number} pad - The index of the pad to register (use {@link PAD_1}, etc).
     * @param {number} button - The pad button.
     */
    registerPadButton(action: string, pad: number, button: number): void;
    /**
     * Register an action against a controller axis.
     *
     * @param {object} [options] - Optional options object.
     * @param {object} [options.pad] - The index of the game pad to register for (use {@link PAD_1}, etc).
     */
    registerAxis(options?: {
        pad?: object;
    }): void;
    /**
     * Returns true if the current action is enabled.
     *
     * @param {string} actionName - The name of the action.
     * @returns {boolean} True if the action is enabled.
     */
    isPressed(actionName: string): boolean;
    /**
     * Returns true if the action was enabled this since the last update.
     *
     * @param {string} actionName - The name of the action.
     * @returns {boolean} True if the action was enabled this since the last update.
     */
    wasPressed(actionName: string): boolean;
    getAxis(name: any): number;
    _enableMouse(): void;
    _enableKeyboard(): void;
}

type Keyboard = Keyboard$2;
/** @typedef {import('./keyboard.js').Keyboard} Keyboard */
/**
 * The KeyboardEvent is passed into all event callbacks from the {@link Keyboard}. It corresponds
 * to a key press or release.
 */
declare class KeyboardEvent {
    /**
     * Create a new KeyboardEvent.
     *
     * @param {Keyboard} keyboard - The keyboard object which is firing the event.
     * @param {globalThis.KeyboardEvent} event - The original browser event that was fired.
     * @example
     * var onKeyDown = function (e) {
     *     if (e.key === pc.KEY_SPACE) {
     *         // space key pressed
     *     }
     *     e.event.preventDefault(); // Use original browser event to prevent browser action.
     * };
     * app.keyboard.on("keydown", onKeyDown, this);
     */
    constructor(keyboard: Keyboard, event: globalThis.KeyboardEvent);
    /**
     * The keyCode of the key that has changed. See the KEY_* constants.
     *
     * @type {number}
     */
    key: number;
    /**
     * The element that fired the keyboard event.
     *
     * @type {Element}
     */
    element: Element;
    /**
     * The original browser event which was fired.
     *
     * @type {globalThis.KeyboardEvent}
     */
    event: globalThis.KeyboardEvent;
}

type Mouse = Mouse$2;
/**
 * MouseEvent object that is passed to events 'mousemove', 'mouseup', 'mousedown' and 'mousewheel'.
 */
declare class MouseEvent$1 {
    /**
     * Create a new MouseEvent instance.
     *
     * @param {Mouse} mouse - The Mouse device that is firing this event.
     * @param {globalThis.MouseEvent} event - The original browser event that fired.
     */
    constructor(mouse: Mouse, event: globalThis.MouseEvent);
    /**
     * The x coordinate of the mouse pointer relative to the element {@link Mouse} is
     * attached to.
     *
     * @type {number}
     */
    x: number;
    /**
     * The y coordinate of the mouse pointer relative to the element {@link Mouse} is
     * attached to.
     *
     * @type {number}
     */
    y: number;
    /**
     * A value representing the amount the mouse wheel has moved, only valid for
     * {@link mousewheel} events.
     *
     * @type {number}
     */
    wheelDelta: number;
    /**
     * The change in x coordinate since the last mouse event.
     *
     * @type {number}
     */
    dx: number;
    /**
     * The change in y coordinate since the last mouse event.
     *
     * @type {number}
     */
    dy: number;
    /**
     * The mouse button associated with this event. Can be:
     *
     * - {@link MOUSEBUTTON_LEFT}
     * - {@link MOUSEBUTTON_MIDDLE}
     * - {@link MOUSEBUTTON_RIGHT}
     *
     * @type {number}
     */
    button: number;
    buttons: boolean[];
    /**
     * The element that the mouse was fired from.
     *
     * @type {Element}
     */
    element: Element;
    /**
     * True if the ctrl key was pressed when this event was fired.
     *
     * @type {boolean}
     */
    ctrlKey: boolean;
    /**
     * True if the alt key was pressed when this event was fired.
     *
     * @type {boolean}
     */
    altKey: boolean;
    /**
     * True if the shift key was pressed when this event was fired.
     *
     * @type {boolean}
     */
    shiftKey: boolean;
    /**
     * True if the meta key was pressed when this event was fired.
     *
     * @type {boolean}
     */
    metaKey: boolean;
    /**
     * The original browser event.
     *
     * @type {globalThis.MouseEvent}
     */
    event: globalThis.MouseEvent;
}

declare function inherits(Self: any, Super: any): {
    (arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any): void;
    _super: any;
    prototype: any;
};
declare function makeArray(arr: any): any;
declare function UnsupportedBrowserError(message: any): void;
declare class UnsupportedBrowserError {
    constructor(message: any);
    name: string;
    message: any;
}
declare function ContextCreationError(message: any): void;
declare class ContextCreationError {
    constructor(message: any);
    name: string;
    message: any;
}
declare function basisSetDownloadConfig(glueUrl: any, wasmUrl: any, fallbackUrl: any): void;
declare function prefilterCubemap(options: any): void;
declare namespace log {
    function write(text: any): void;
    function open(): void;
    function info(text: any): void;
    function debug(text: any): void;
    function error(text: any): void;
    function warning(text: any): void;
    function alert(text: any): void;
    function assert(condition: any, text: any): void;
}
declare namespace time {
    export { now };
    export { Timer };
}
declare namespace shape {
    export { BoundingBox$1 as Aabb };
    export { BoundingSphere$2 as Sphere };
    export { Plane };
}
declare const ELEMENTTYPE_INT8: number;
declare const ELEMENTTYPE_UINT8: number;
declare const ELEMENTTYPE_INT16: number;
declare const ELEMENTTYPE_UINT16: number;
declare const ELEMENTTYPE_INT32: number;
declare const ELEMENTTYPE_UINT32: number;
declare const ELEMENTTYPE_FLOAT32: number;
declare namespace gfx {
    export { ADDRESS_CLAMP_TO_EDGE };
    export { ADDRESS_MIRRORED_REPEAT };
    export { ADDRESS_REPEAT };
    export { BLENDMODE_ZERO };
    export { BLENDMODE_ONE };
    export { BLENDMODE_SRC_COLOR };
    export { BLENDMODE_ONE_MINUS_SRC_COLOR };
    export { BLENDMODE_DST_COLOR };
    export { BLENDMODE_ONE_MINUS_DST_COLOR };
    export { BLENDMODE_SRC_ALPHA };
    export { BLENDMODE_SRC_ALPHA_SATURATE };
    export { BLENDMODE_ONE_MINUS_SRC_ALPHA };
    export { BLENDMODE_DST_ALPHA };
    export { BLENDMODE_ONE_MINUS_DST_ALPHA };
    export { BUFFER_STATIC };
    export { BUFFER_DYNAMIC };
    export { BUFFER_STREAM };
    export { CULLFACE_NONE };
    export { CULLFACE_BACK };
    export { CULLFACE_FRONT };
    export { CULLFACE_FRONTANDBACK };
    export { TYPE_INT8 as ELEMENTTYPE_INT8 };
    export { TYPE_UINT8 as ELEMENTTYPE_UINT8 };
    export { TYPE_INT16 as ELEMENTTYPE_INT16 };
    export { TYPE_UINT16 as ELEMENTTYPE_UINT16 };
    export { TYPE_INT32 as ELEMENTTYPE_INT32 };
    export { TYPE_UINT32 as ELEMENTTYPE_UINT32 };
    export { TYPE_FLOAT32 as ELEMENTTYPE_FLOAT32 };
    export { FILTER_NEAREST };
    export { FILTER_LINEAR };
    export { FILTER_NEAREST_MIPMAP_NEAREST };
    export { FILTER_NEAREST_MIPMAP_LINEAR };
    export { FILTER_LINEAR_MIPMAP_NEAREST };
    export { FILTER_LINEAR_MIPMAP_LINEAR };
    export { INDEXFORMAT_UINT8 };
    export { INDEXFORMAT_UINT16 };
    export { INDEXFORMAT_UINT32 };
    export { PIXELFORMAT_R5_G6_B5 };
    export { PIXELFORMAT_R8_G8_B8 };
    export { PIXELFORMAT_R8_G8_B8_A8 };
    export { PRIMITIVE_POINTS };
    export { PRIMITIVE_LINES };
    export { PRIMITIVE_LINELOOP };
    export { PRIMITIVE_LINESTRIP };
    export { PRIMITIVE_TRIANGLES };
    export { PRIMITIVE_TRISTRIP };
    export { PRIMITIVE_TRIFAN };
    export { SEMANTIC_POSITION };
    export { SEMANTIC_NORMAL };
    export { SEMANTIC_COLOR };
    export { SEMANTIC_TEXCOORD };
    export { SEMANTIC_TEXCOORD0 };
    export { SEMANTIC_TEXCOORD1 };
    export { SEMANTIC_ATTR0 };
    export { SEMANTIC_ATTR1 };
    export { SEMANTIC_ATTR2 };
    export { SEMANTIC_ATTR3 };
    export { TEXTURELOCK_READ };
    export { TEXTURELOCK_WRITE };
    export { drawQuadWithShader };
    export { programlib };
    export { shaderChunks };
    export { ContextCreationError };
    export { GraphicsDevice$l as Device };
    export { IndexBuffer$1 as IndexBuffer };
    export { ProgramLibrary };
    export { RenderTarget$3 as RenderTarget };
    export { ScopeId$1 as ScopeId };
    export { Shader$4 as Shader };
    export { ShaderInput };
    export { Texture$8 as Texture };
    export { UnsupportedBrowserError };
    export { VertexBuffer$3 as VertexBuffer };
    export { VertexFormat$2 as VertexFormat };
    export { VertexIterator };
}
declare namespace posteffect {
    export { createFullscreenQuad };
    export { drawFullscreenQuad };
    export { PostEffect$1 as PostEffect };
    export { PostEffectQueue };
}
declare const PhongMaterial: typeof StandardMaterial;
declare namespace scene {
    export { partitionSkin };
    export namespace procedural {
        export { calculateTangents };
        export { createMesh };
        export { createTorus };
        export { createCylinder };
        export { createCapsule };
        export { createCone };
        export { createSphere };
        export { createPlane };
        export { createBox };
    }
    export { BasicMaterial };
    export { Command };
    export { DepthMaterial };
    export { ForwardRenderer$1 as ForwardRenderer };
    export { GraphNode$3 as GraphNode };
    export { Material$2 as Material };
    export { Mesh$1 as Mesh };
    export { MeshInstance$3 as MeshInstance };
    export { Model };
    export { ParticleEmitter };
    export { StandardMaterial as PhongMaterial };
    export { Picker };
    export namespace Projection {
        export { PROJECTION_ORTHOGRAPHIC as ORTHOGRAPHIC };
        export { PROJECTION_PERSPECTIVE as PERSPECTIVE };
    }
    export { Scene$3 as Scene };
    export { Skin$2 as Skin };
    export { SkinInstance };
}
declare namespace anim {
    export { Animation$1 as Animation };
    export { Key };
    export { Node$1 as Node };
    export { Skeleton };
}
declare namespace audio {
    export { SoundManager$7 as AudioManager };
    export { Channel };
    export { Channel3d };
    export { Listener };
    export { Sound$3 as Sound };
}
declare namespace asset {
    const ASSET_ANIMATION: string;
    const ASSET_AUDIO: string;
    const ASSET_IMAGE: string;
    const ASSET_JSON: string;
    const ASSET_MODEL: string;
    const ASSET_MATERIAL: string;
    const ASSET_TEXT: string;
    const ASSET_TEXTURE: string;
    const ASSET_CUBEMAP: string;
    const ASSET_SCRIPT: string;
}
declare namespace input {
    export { getTouchTargetCoords };
    export { Controller };
    export { GamePads$2 as GamePads };
    export { Keyboard$2 as Keyboard };
    export { KeyboardEvent };
    export { Mouse$2 as Mouse };
    export { MouseEvent$1 as MouseEvent };
    export { Touch$1 as Touch };
    export { TouchDevice$2 as TouchDevice };
    export { TouchEvent$1 as TouchEvent };
}
declare const RIGIDBODY_TYPE_STATIC: string;
declare const RIGIDBODY_TYPE_DYNAMIC: string;
declare const RIGIDBODY_TYPE_KINEMATIC: string;
declare const RIGIDBODY_CF_STATIC_OBJECT: 1;
declare const RIGIDBODY_CF_KINEMATIC_OBJECT: 2;
declare const RIGIDBODY_CF_NORESPONSE_OBJECT: 4;
declare const RIGIDBODY_ACTIVE_TAG: 1;
declare const RIGIDBODY_ISLAND_SLEEPING: 2;
declare const RIGIDBODY_WANTS_DEACTIVATION: 3;
declare const RIGIDBODY_DISABLE_DEACTIVATION: 4;
declare const RIGIDBODY_DISABLE_SIMULATION: 5;
declare namespace fw {
    export { Application$7 as Application };
    export { Component$2 as Component };
    export { ComponentSystem };
    export { Entity$a as Entity };
    export namespace FillMode {
        export { FILLMODE_NONE as NONE };
        export { FILLMODE_FILL_WINDOW as FILL_WINDOW };
        export { FILLMODE_KEEP_ASPECT as KEEP_ASPECT };
    }
    export namespace ResolutionMode {
        export { RESOLUTION_AUTO as AUTO };
        export { RESOLUTION_FIXED as FIXED };
    }
}
declare class AssetListLoader extends EventHandler$1 {
    constructor(assetList: any, assetRegistry: any);
    _assets: any;
    _registry: any;
    _loaded: boolean;
    _count: number;
    _total: number;
    _failed: any[];
    _waitingAssets: any[];
    destroy(): void;
    /**
     * @private
     * @function
     * @name AssetListLoader#load
     * @description Start loading asset list, call done() when all assets have loaded or failed to load.
     * @param {Function} done - Callback called when all assets in the list are loaded. Passed (err, failed) where err is the undefined if no errors are encountered and failed contains a list of assets that failed to load.
     * @param {object} [scope] - Scope to use when calling callback.
     *
     */
    private load;
    _callback: Function;
    _scope: any;
    /**
     * @private
     * @function
     * @name AssetListLoader#ready
     * @param {Function} done - Callback called when all assets in the list are loaded.
     * @param {object} [scope] - Scope to use when calling callback.
     */
    private ready;
    _loadingComplete(): void;
    _onLoad(asset: any): void;
    _onError(err: any, asset: any): void;
    _onAddAsset(asset: any): void;
    _waitForAsset(assetId: any): void;
}

declare namespace math {
    const DEG_TO_RAD: number;
    const RAD_TO_DEG: number;
    function clamp(value: number, min: number, max: number): number;
    function intToBytes24(i: number): number[];
    function intToBytes32(i: number): number[];
    function bytesToInt24(r: number, g: number, b: number): number;
    function bytesToInt32(r: number, g: number, b: number, a: number): number;
    function lerp(a: number, b: number, alpha: number): number;
    function lerpAngle(a: number, b: number, alpha: number): number;
    function powerOfTwo(x: number): boolean;
    function nextPowerOfTwo(val: number): number;
    function random(min: number, max: number): number;
    function smoothstep(min: number, max: number, x: number): number;
    function smootherstep(min: number, max: number, x: number): number;
    function roundUp(numToRound: number, multiple: number): number;
    function between(num: number, a: number, b: number, inclusive: boolean): boolean;
}

/**
 * A curve is a collection of keys (time/value pairs). The shape of the curve is defined by its
 * type that specifies an interpolation scheme for the keys.
 */
declare class Curve {
    /**
     * Creates a new Curve instance.
     *
     * @param {number[]} [data] - An array of keys (pairs of numbers with the time first and value
     * second).
     * @example
     * var curve = new pc.Curve([
     *     0, 0,        // At 0 time, value of 0
     *     0.33, 2,     // At 0.33 time, value of 2
     *     0.66, 2.6,   // At 0.66 time, value of 2.6
     *     1, 3         // At 1 time, value of 3
     * ]);
     */
    constructor(data?: number[]);
    keys: number[][];
    /**
     * The curve interpolation scheme. Can be:
     *
     * - {@link CURVE_LINEAR}
     * - {@link CURVE_SMOOTHSTEP}
     * - {@link CURVE_SPLINE}
     * - {@link CURVE_STEP}
     *
     * Defaults to {@link CURVE_SMOOTHSTEP}.
     *
     * @type {number}
     */
    type: number;
    /**
     * Controls how {@link CURVE_SPLINE} tangents are calculated. Valid range is between 0 and
     * 1 where 0 results in a non-smooth curve (equivalent to linear interpolation) and 1
     * results in a very smooth curve. Use 0.5 for a Catmull-rom spline.
     *
     * @type {number}
     */
    tension: number;
    /**
     * @type {CurveEvaluator}
     * @private
     */
    private _eval;
    /**
     * Get the number of keys in the curve.
     *
     * @type {number}
     */
    get length(): number;
    /**
     * Add a new key to the curve.
     *
     * @param {number} time - Time to add new key.
     * @param {number} value - Value of new key.
     * @returns {number[]} [time, value] pair.
     */
    add(time: number, value: number): number[];
    /**
     * Return a specific key.
     *
     * @param {number} index - The index of the key to return.
     * @returns {number[]} The key at the specified index.
     */
    get(index: number): number[];
    /**
     * Sort keys by time.
     */
    sort(): void;
    /**
     * Returns the interpolated value of the curve at specified time.
     *
     * @param {number} time - The time at which to calculate the value.
     * @returns {number} The interpolated value.
     */
    value(time: number): number;
    closest(time: any): number[];
    /**
     * Returns a clone of the specified curve object.
     *
     * @returns {Curve} A clone of the specified curve.
     */
    clone(): Curve;
    /**
     * Sample the curve at regular intervals over the range [0..1].
     *
     * @param {number} precision - The number of samples to return.
     * @returns {Float32Array} The set of quantized values.
     * @ignore
     */
    quantize(precision: number): Float32Array;
    /**
     * Sample the curve at regular intervals over the range [0..1] and clamp the resulting samples
     * to [min..max].
     *
     * @param {number} precision - The number of samples to return.
     * @param {number} min - The minimum output value.
     * @param {number} max - The maximum output value.
     * @returns {Float32Array} The set of quantized values.
     * @ignore
     */
    quantizeClamped(precision: number, min: number, max: number): Float32Array;
}

/**
 * A curve set is a collection of curves.
 */
declare class CurveSet {
    /**
     * Creates a new CurveSet instance.
     *
     * @param {Array<number[]>} curveKeys - An array of arrays of keys (pairs of numbers with the
     * time first and value second).
     * @example
     * var curveSet = new pc.CurveSet([
     *     [
     *         0, 0,        // At 0 time, value of 0
     *         0.33, 2,     // At 0.33 time, value of 2
     *         0.66, 2.6,   // At 0.66 time, value of 2.6
     *         1, 3         // At 1 time, value of 3
     *     ],
     *     [
     *         0, 34,
     *         0.33, 35,
     *         0.66, 36,
     *         1, 37
     *     ]
     * ]);
     */
    constructor(...args: any[]);
    curves: Curve[];
    /**
     * @type {number}
     * @private
     */
    private _type;
    /**
     * The number of curves in the curve set.
     *
     * @type {number}
     */
    get length(): number;
    /**
     * The interpolation scheme applied to all curves in the curve set. Can be:
     *
     * - {@link CURVE_LINEAR}
     * - {@link CURVE_SMOOTHSTEP}
     * - {@link CURVE_SPLINE}
     * - {@link CURVE_STEP}
     *
     * Defaults to {@link CURVE_SMOOTHSTEP}.
     *
     * @type {number}
     */
    set type(arg: number);
    get type(): number;
    /**
     * Return a specific curve in the curve set.
     *
     * @param {number} index - The index of the curve to return.
     * @returns {Curve} The curve at the specified index.
     */
    get(index: number): Curve;
    /**
     * Returns the interpolated value of all curves in the curve set at the specified time.
     *
     * @param {number} time - The time at which to calculate the value.
     * @param {number[]} [result] - The interpolated curve values at the specified time. If this
     * parameter is not supplied, the function allocates a new array internally to return the
     * result.
     * @returns {number[]} The interpolated curve values at the specified time.
     */
    value(time: number, result?: number[]): number[];
    /**
     * Returns a clone of the specified curve set object.
     *
     * @returns {CurveSet} A clone of the specified curve set.
     */
    clone(): CurveSet;
    /**
     * Sample the curveset at regular intervals over the range [0..1].
     *
     * @param {number} precision - The number of samples to return.
     * @returns {Float32Array} The set of quantized values.
     * @ignore
     */
    quantize(precision: number): Float32Array;
    /**
     * Sample the curveset at regular intervals over the range [0..1] and clamp the result to min
     * and max.
     *
     * @param {number} precision - The number of samples to return.
     * @param {number} min - The minimum output value.
     * @param {number} max - The maximum output value.
     * @returns {Float32Array} The set of quantized values.
     * @ignore
     */
    quantizeClamped(precision: number, min: number, max: number): Float32Array;
}

/**
 * Oriented Box.
 */
declare class OrientedBox {
    /**
     * Create a new OrientedBox instance.
     *
     * @param {Mat4} [worldTransform] - Transform that has the orientation and position of the box.
     * Scale is assumed to be one.
     * @param {Vec3} [halfExtents] - Half the distance across the box in each local axis. The
     * constructor takes a reference of this parameter.
     */
    constructor(worldTransform?: Mat4$5, halfExtents?: Vec3$1);
    halfExtents: Vec3$1;
    /**
     * @type {Mat4}
     * @private
     */
    private _modelTransform;
    /**
     * @type {Mat4}
     * @private
     */
    private _worldTransform;
    /**
     * @type {BoundingBox}
     * @private
     */
    private _aabb;
    /**
     * The world transform of the OBB.
     *
     * @type {Mat4}
     */
    set worldTransform(arg: Mat4$5);
    get worldTransform(): Mat4$5;
    /**
     * Test if a ray intersects with the OBB.
     *
     * @param {Ray} ray - Ray to test against (direction must be normalized).
     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied
     * into here.
     * @returns {boolean} True if there is an intersection.
     */
    intersectsRay(ray: Ray$4, point?: Vec3$1): boolean;
    /**
     * Test if a point is inside a OBB.
     *
     * @param {Vec3} point - Point to test.
     * @returns {boolean} True if the point is inside the OBB and false otherwise.
     */
    containsPoint(point: Vec3$1): boolean;
    /**
     * Test if a Bounding Sphere is overlapping, enveloping, or inside this OBB.
     *
     * @param {BoundingSphere} sphere - Bounding Sphere to test.
     * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping or inside this OBB
     * and false otherwise.
     */
    intersectsBoundingSphere(sphere: BoundingSphere$2): boolean;
}

declare function shFromCubemap(device: any, source: any, dontFlipX: any): Float32Array;

type Vec4 = Vec4$6;
/**
 * This function reprojects textures between cubemap, equirectangular and octahedral formats. The
 * function can read and write textures with pixel data in RGBE, RGBM, linear and sRGB formats.
 * When specularPower is specified it will perform a phong-weighted convolution of the source (for
 * generating a gloss maps).
 *
 * @param {Texture} source - The source texture.
 * @param {Texture} target - The target texture.
 * @param {object} [options] - The options object.
 * @param {number} [options.specularPower] - Optional specular power. When specular power is
 * specified, the source is convolved by a phong-weighted kernel raised to the specified power.
 * Otherwise the function performs a standard resample.
 * @param {number} [options.numSamples] - Optional number of samples (default is 1024).
 * @param {number} [options.face] - Optional cubemap face to update (default is update all faces).
 * @param {string} [options.distribution] - Specify convolution distribution - 'none', 'lambert',
 * 'phong', 'ggx'. Default depends on specularPower.
 * @param {Vec4} [options.rect] - Optional viewport rectangle.
 * @param {number} [options.seamPixels] - Optional number of seam pixels to render
 */
declare function reprojectTexture(source: Texture$8, target: Texture$8, options?: {
    specularPower?: number;
    numSamples?: number;
    face?: number;
    distribution?: string;
    rect?: Vec4;
    seamPixels?: number;
}, ...args: any[]): void;

/**
 * Helper functions to support prefiltering lighting data.
 *
 * @ignore
 */
declare class EnvLighting {
    /**
     * Generate a skybox cubemap in the correct pixel format from the source texture.
     *
     * @param {Texture} source - The source texture. This is either a 2d texture in equirect format
     * or a cubemap.
     * @param {number} [size] - Size of the resulting texture. Otherwise use automatic sizing.
     * @returns {Texture} The resulting cubemap.
     */
    static generateSkyboxCubemap(source: Texture$8, size?: number): Texture$8;
    /**
     * Create a texture in the format needed to precalculate lighting data.
     *
     * @param {Texture} source - The source texture. This is either a 2d texture in equirect format
     * or a cubemap.
     * @returns {Texture} The resulting cubemap.
     */
    static generateLightingSource(source: Texture$8): Texture$8;
    /**
     * Generate the environment lighting atlas containing prefiltered reflections and ambient.
     *
     * @param {Texture} source - The source lighting texture, generated by generateLightingSource.
     * @param {object} options - Specify prefilter options.
     * @returns {Texture} The resulting atlas
     */
    static generateAtlas(source: Texture$8, options: object): Texture$8;
    /**
     * Generate the environment lighting atlas from prefiltered cubemap data.
     *
     * @param {Texture[]} sources - Array of 6 prefiltered textures.
     * @param {object} options - The options object
     * @returns {Texture} The resulting atlas
     */
    static generatePrefilteredAtlas(sources: Texture$8[], options: object): Texture$8;
}

type GraphicsDevice$6 = GraphicsDevice$l;
type Shader = Shader$4;
/** @typedef {import('./graphics-device.js').GraphicsDevice} GraphicsDevice */
/** @typedef {import('./shader.js').Shader} Shader */
/**
 * This object allows you to configure and use the transform feedback feature (WebGL2 only). How to
 * use:
 *
 * 1. First, check that you're on WebGL2, by looking at the `app.graphicsDevice.webgl2`` value.
 * 2. Define the outputs in your vertex shader. The syntax is `out vec3 out_vertex_position`,
 * note that there must be out_ in the name. You can then simply assign values to these outputs in
 * VS. The order and size of shader outputs must match the output buffer layout.
 * 3. Create the shader using `TransformFeedback.createShader(device, vsCode, yourShaderName)`.
 * 4. Create/acquire the input vertex buffer. Can be any VertexBuffer, either manually created, or
 * from a Mesh.
 * 5. Create the TransformFeedback object: `var tf = new TransformFeedback(inputBuffer)`. This
 * object will internally create an output buffer.
 * 6. Run the shader: `tf.process(shader)`. Shader will take the input buffer, process it and write
 * to the output buffer, then the input/output buffers will be automatically swapped, so you'll
 * immediately see the result.
 *
 * ```javascript
 * // *** shader asset ***
 * attribute vec3 vertex_position;
 * attribute vec3 vertex_normal;
 * attribute vec2 vertex_texCoord0;
 * out vec3 out_vertex_position;
 * out vec3 out_vertex_normal;
 * out vec2 out_vertex_texCoord0;
 * void main(void) {
 *     // read position and normal, write new position (push away)
 *     out_vertex_position = vertex_position + vertex_normal * 0.01;
 *     // pass other attributes unchanged
 *     out_vertex_normal = vertex_normal;
 *     out_vertex_texCoord0 = vertex_texCoord0;
 * }
 * ```
 *
 * ```javascript
 * // *** script asset ***
 * var TransformExample = pc.createScript('transformExample');
 *
 * // attribute that references shader asset and material
 * TransformExample.attributes.add('shaderCode', { type: 'asset', assetType: 'shader' });
 * TransformExample.attributes.add('material', { type: 'asset', assetType: 'material' });
 *
 * TransformExample.prototype.initialize = function() {
 *     var device = this.app.graphicsDevice;
 *     var mesh = pc.createTorus(device, { tubeRadius: 0.01, ringRadius: 3 });
 *     var node = new pc.GraphNode();
 *     var meshInstance = new pc.MeshInstance(mesh, this.material.resource, node);
 *     var model = new pc.Model();
 *     model.graph = node;
 *     model.meshInstances = [ meshInstance ];
 *     this.app.scene.addModel(model);
 *
 *     // if webgl2 is not supported, TF is not available
 *     if (!device.webgl2) return;
 *     var inputBuffer = mesh.vertexBuffer;
 *     this.tf = new pc.TransformFeedback(inputBuffer);
 *     this.shader = pc.TransformFeedback.createShader(device, this.shaderCode.resource, "tfMoveUp");
 * };
 *
 * TransformExample.prototype.update = function(dt) {
 *     if (!this.app.graphicsDevice.webgl2) return;
 *     this.tf.process(this.shader);
 * };
 * ```
 */
declare class TransformFeedback {
    /**
     * Creates a transform feedback ready vertex shader from code.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used by the renderer.
     * @param {string} vsCode - Vertex shader code. Should contain output variables starting with "out_".
     * @param {string} name - Unique name for caching the shader.
     * @returns {Shader} A shader to use in the process() function.
     */
    static createShader(graphicsDevice: GraphicsDevice$6, vsCode: string, name: string): Shader;
    /**
     * Create a new TransformFeedback instance.
     *
     * @param {VertexBuffer} inputBuffer - The input vertex buffer.
     * @param {number} [usage] - The optional usage type of the output vertex buffer. Can be:
     *
     * - {@link BUFFER_STATIC}
     * - {@link BUFFER_DYNAMIC}
     * - {@link BUFFER_STREAM}
     * - {@link BUFFER_GPUDYNAMIC}
     *
     * Defaults to {@link BUFFER_GPUDYNAMIC} (which is recommended for continuous update).
     */
    constructor(inputBuffer: VertexBuffer$3, usage?: number);
    device: GraphicsDevice$l;
    _inputBuffer: VertexBuffer$3;
    _outputBuffer: VertexBuffer$3;
    /**
     * Destroys the transform feedback helper object.
     */
    destroy(): void;
    /**
     * Runs the specified shader on the input buffer, writes results into the new buffer, then
     * optionally swaps input/output.
     *
     * @param {Shader} shader - A vertex shader to run. Should be created with
     * {@link TransformFeedback.createShader}.
     * @param {boolean} [swap] - Swap input/output buffer data. Useful for continuous buffer
     * processing. Default is true.
     */
    process(shader: Shader, swap?: boolean): void;
    /**
     * The current input buffer.
     *
     * @type {VertexBuffer}
     */
    get inputBuffer(): VertexBuffer$3;
    /**
     * The current output buffer.
     *
     * @type {VertexBuffer}
     */
    get outputBuffer(): VertexBuffer$3;
}

declare class SkinBatchInstance extends SkinInstance {
    constructor(device: any, nodes: any, rootNode: any);
    device: any;
    rootNode: any;
}

/**
 * A light.
 *
 * @ignore
 */
declare class Light {
    constructor(graphicsDevice: any);
    device: any;
    id: number;
    _type: number;
    _color: Color$4;
    _intensity: number;
    _castShadows: boolean;
    _enabled: boolean;
    mask: number;
    isStatic: boolean;
    key: number;
    bakeDir: boolean;
    bakeNumSamples: number;
    bakeArea: number;
    attenuationStart: number;
    attenuationEnd: number;
    _falloffMode: number;
    _shadowType: number;
    _vsmBlurSize: number;
    vsmBlurMode: number;
    vsmBias: number;
    _cookie: any;
    cookieIntensity: number;
    _cookieFalloff: boolean;
    _cookieChannel: string;
    _cookieTransform: any;
    _cookieTransformUniform: Float32Array;
    _cookieOffset: any;
    _cookieOffsetUniform: Float32Array;
    _cookieTransformSet: boolean;
    _cookieOffsetSet: boolean;
    _innerConeAngle: number;
    _outerConeAngle: number;
    cascades: any;
    _shadowMatrixPalette: Float32Array;
    _shadowCascadeDistances: Float32Array;
    set numCascades(arg: any);
    get numCascades(): any;
    cascadeDistribution: number;
    _shape: number;
    _finalColor: Float32Array;
    _linearFinalColor: Float32Array;
    _position: Vec3$1;
    _direction: Vec3$1;
    _innerConeAngleCos: number;
    _outerConeAngleCos: number;
    _shadowMap: any;
    _shadowRenderParams: any[];
    shadowDistance: number;
    _shadowResolution: number;
    shadowBias: number;
    _normalOffsetBias: number;
    shadowUpdateMode: number;
    _isVsm: boolean;
    _isPcf: boolean;
    _cookieMatrix: Mat4$5;
    _atlasViewport: Vec4$6;
    atlasViewportAllocated: boolean;
    atlasVersion: number;
    atlasSlotIndex: number;
    atlasSlotUpdated: boolean;
    _scene: any;
    _node: any;
    _renderData: any[];
    visibleThisFrame: boolean;
    maxScreenSize: number;
    destroy(): void;
    set shadowMap(arg: any);
    get shadowMap(): any;
    get numShadowFaces(): any;
    set type(arg: number);
    get type(): number;
    set shadowType(arg: number);
    get shadowType(): number;
    set shape(arg: number);
    get shape(): number;
    set enabled(arg: boolean);
    get enabled(): boolean;
    set castShadows(arg: boolean);
    get castShadows(): boolean;
    set shadowResolution(arg: number);
    get shadowResolution(): number;
    set vsmBlurSize(arg: number);
    get vsmBlurSize(): number;
    set normalOffsetBias(arg: number);
    get normalOffsetBias(): number;
    set falloffMode(arg: number);
    get falloffMode(): number;
    set innerConeAngle(arg: number);
    get innerConeAngle(): number;
    set outerConeAngle(arg: number);
    get outerConeAngle(): number;
    set intensity(arg: number);
    get intensity(): number;
    get cookieMatrix(): Mat4$5;
    get atlasViewport(): Vec4$6;
    set cookie(arg: any);
    get cookie(): any;
    set cookieFalloff(arg: boolean);
    get cookieFalloff(): boolean;
    set cookieChannel(arg: string);
    get cookieChannel(): string;
    set cookieTransform(arg: any);
    get cookieTransform(): any;
    set cookieOffset(arg: any);
    get cookieOffset(): any;
    beginFrame(): void;
    _destroyShadowMap(): void;
    getRenderData(camera: any, face: any): any;
    /**
     * Duplicates a light node but does not 'deep copy' the hierarchy.
     *
     * @returns {Light} A cloned Light.
     */
    clone(): Light;
    _getUniformBiasValues(lightRenderData: any): {
        bias: number;
        normalBias: number;
    };
    getColor(): Color$4;
    getBoundingSphere(sphere: any): void;
    getBoundingBox(box: any): void;
    _updateFinalColor(): void;
    setColor(...args: any[]): void;
    updateShadow(): void;
    layersDirty(): void;
    updateKey(): void;
}

/**
 * Holds stencil test settings.
 *
 * @property {number} func Sets stencil test function. See {@link GraphicsDevice#setStencilFunc}.
 * @property {number} ref Sets stencil test reference value. See
 * {@link GraphicsDevice#setStencilFunc}.
 * @property {number} fail Sets operation to perform if stencil test is failed. See
 * {@link GraphicsDevice#setStencilOperation}.
 * @property {number} zfail Sets operation to perform if depth test is failed. See
 * {@link GraphicsDevice#setStencilOperation}.
 * @property {number} zpass Sets operation to perform if both stencil and depth test are passed.
 * See {@link GraphicsDevice#setStencilOperation}.
 * @property {number} readMask Sets stencil test reading mask. See
 * {@link GraphicsDevice#setStencilFunc}.
 * @property {number} writeMask Sets stencil test writing mask. See
 * {@link GraphicsDevice#setStencilOperation}.
 */
declare class StencilParameters {
    /**
     * Create a new StencilParameters instance.
     *
     * @param {object} options - Options object to configure the stencil parameters.
     */
    constructor(options: object);
    func: any;
    ref: any;
    readMask: any;
    writeMask: any;
    fail: any;
    zfail: any;
    zpass: any;
    clone(): StencilParameters;
}

/**
 * Callback function that the {@link AnimEvaluator } uses to set final animation values. These
 * callbacks are stored in {@link AnimTarget } instances which are constructed by an
 * {@link AnimBinder }.
 */
type AnimSetter = (value: number[]) => any;
/**
 * Callback function that the {@link AnimEvaluator} uses to set final animation values. These
 * callbacks are stored in {@link AnimTarget} instances which are constructed by an
 * {@link AnimBinder}.
 *
 * @callback AnimSetter
 * @param {number[]} value - Updated animation value.
 * @ignore
 */
/**
 * Stores the information required by {@link AnimEvaluator} for updating a target value.
 *
 * @ignore
 */
declare class AnimTarget$1 {
    /**
     * Create a new AnimTarget instance.
     *
     * @param {AnimSetter} func - This function will be called when a new animation value is output
     * by the {@link AnimEvaluator}.
     * @param {'vector'|'quaternion'} type - The type of animation data this target expects.
     * @param {number} components - The number of components on this target (this should ideally
     * match the number of components found on all attached animation curves).
     * @param {string} targetPath - The path to the target value.
     */
    constructor(func: AnimSetter, type: 'vector' | 'quaternion', components: number, targetPath: string);
    _func: AnimSetter;
    _type: "quaternion" | "vector";
    _components: number;
    _targetPath: string;
    _isTransform: boolean;
    get func(): AnimSetter;
    get type(): "quaternion" | "vector";
    get components(): number;
    get targetPath(): string;
    get isTransform(): boolean;
}

type AnimTarget = AnimTarget$1;
/** @typedef {import('../evaluator/anim-target.js').AnimTarget} AnimTarget */
/**
 * This interface is used by {@link AnimEvaluator} to resolve unique animation target path strings
 * into instances of {@link AnimTarget}.
 *
 * @ignore
 */
declare class AnimBinder$1 {
    static joinPath(pathSegments: any, character: any): any;
    static splitPath(path: any, character: any): string[];
    /**
     * Converts a locator array into its string version.
     *
     * @param {string|Array} entityPath - The entity location in the scene defined as an array or
     * string path.
     * @param {string} component - The component of the entity the property is located under.
     * @param {string|Array} propertyPath - The property location in the entity defined as an array
     * or string path.
     * @returns {string} The locator encoded as a string.
     * @example
     * // returns 'spotLight/light/color.r'
     * encode(['spotLight'], 'light', ['color', 'r']);
     */
    static encode(entityPath: string | any[], component: string, propertyPath: string | any[]): string;
    /**
     * Resolve the provided target path and return an instance of {@link AnimTarget} which will
     * handle setting the value, or return null if no such target exists.
     *
     * @param {string} path - The animation curve path to resolve.
     * @returns {AnimTarget|null} - Returns the target instance on success and null otherwise.
     */
    resolve(path: string): AnimTarget | null;
    /**
     * Called when the {@link AnimEvaluator} no longer has a curve driving the given key.
     *
     * @param {string} path - The animation curve path which is no longer driven.
     */
    unresolve(path: string): void;
    /**
     * Called by {@link AnimEvaluator} once a frame after animation updates are done.
     *
     * @param {number} deltaTime - Amount of time that passed in the current update.
     */
    update(deltaTime: number): void;
}

/**
 * Wraps a set of data used in animation.
 *
 * @ignore
 */
declare class AnimData$1 {
    /**
     * Create a new animation AnimData instance.
     *
     * @param {number} components - Specifies how many components make up an element of data. For
     * example, specify 3 for a set of 3-dimensional vectors. The number of elements in data array
     * must be a multiple of components.
     * @param {Float32Array|number[]} data - The set of data.
     */
    constructor(components: number, data: Float32Array | number[]);
    _components: number;
    _data: number[] | Float32Array;
    /**
     * Gets the number of components that make up an element.
     *
     * @type {number}
     */
    get components(): number;
    /**
     * Gets the data.
     *
     * @type {Float32Array|number[]}
     */
    get data(): number[] | Float32Array;
}

/**
 * Animation curve links an input data set to an output data set and defines the interpolation
 * method to use.
 *
 * @ignore
 */
declare class AnimCurve$1 {
    /**
     * Create a new animation curve.
     *
     * @param {string[]} paths - Array of path strings identifying the targets of this curve, for
     * example "rootNode.translation".
     * @param {number} input - Index of the curve which specifies the key data.
     * @param {number} output - Index of the curve which specifies the value data.
     * @param {number} interpolation - The interpolation method to use. One of the following:
     *
     * - {@link INTERPOLATION_STEP}
     * - {@link INTERPOLATION_LINEAR}
     * - {@link INTERPOLATION_CUBIC}
     */
    constructor(paths: string[], input: number, output: number, interpolation: number);
    _paths: string[];
    _input: number;
    _output: number;
    _interpolation: number;
    /**
     * The list of paths which identify targets of this curve.
     *
     * @type {string[]}
     */
    get paths(): string[];
    /**
     * The index of the AnimTrack input which contains the key data for this curve.
     *
     * @type {number}
     */
    get input(): number;
    /**
     * The index of the AnimTrack input which contains the key data for this curve.
     *
     * @type {number}
     */
    get output(): number;
    /**
     * The interpolation method used by this curve.
     *
     * @type {number}
     */
    get interpolation(): number;
}

/**
 * AnimEvents stores a sorted array of animation events which should fire sequentially during the
 * playback of an pc.AnimTrack.
 */
declare class AnimEvents {
    /**
     * Create a new AnimEvents instance.
     *
     * @param {object[]} events - An array of animation events.
     * @example
     * const events = new pc.AnimEvents([
     *     {
     *         name: 'my_event',
     *         time: 1.3, // given in seconds
     *         // any additional properties added are optional and will be available in the EventHandler callback's event object
     *         myProperty: 'test',
     *         myOtherProperty: true
     *     }
     * ]);
     * animTrack.events = events;
     */
    constructor(events: object[]);
    _events: any[];
    get events(): any[];
}

type AnimCurve = AnimCurve$1;
type AnimData = AnimData$1;
/** @typedef {import('./anim-curve.js').AnimCurve} AnimCurve */
/** @typedef {import('./anim-data.js').AnimData} AnimData */
/**
 * An AnimTrack stores the curve data necessary to animate a set of target nodes. It can be linked
 * to the nodes it should animate using the {@link AnimComponent#assignAnimation} method.
 */
declare class AnimTrack$2 {
    /**
     * Create a new AnimTrack instance.
     *
     * @param {string} name - The track name.
     * @param {number} duration - The duration of the track in seconds.
     * @param {AnimData[]} inputs - List of curve key data.
     * @param {AnimData[]} outputs - List of curve value data.
     * @param {AnimCurve[]} curves - The list of curves.
     * @param {AnimEvents} animEvents - A sequence of animation events.
     * @hideconstructor
     */
    constructor(name: string, duration: number, inputs: AnimData[], outputs: AnimData[], curves: AnimCurve[], animEvents?: AnimEvents);
    _name: string;
    _duration: number;
    _inputs: AnimData$1[];
    _outputs: AnimData$1[];
    _curves: AnimCurve$1[];
    _animEvents: AnimEvents;
    /**
     * Gets the name of the AnimTrack.
     *
     * @type {string}
     */
    get name(): string;
    /**
     * Gets the duration of the AnimTrack.
     *
     * @type {number}
     */
    get duration(): number;
    /**
     * Gets the list of curve key data contained in the AnimTrack.
     *
     * @type {AnimData[]}
     */
    get inputs(): AnimData$1[];
    /**
     * Gets the list of curve values contained in the AnimTrack.
     *
     * @type {AnimData[]}
     */
    get outputs(): AnimData$1[];
    /**
     * Gets the list of curves contained in the AnimTrack.
     *
     * @type {AnimCurve[]}
     */
    get curves(): AnimCurve$1[];
    /**
     * The animation events that will fire during the playback of this anim track.
     *
     * @type {AnimEvents}
     */
    set events(arg: any[]);
    get events(): any[];
    eval(time: any, snapshot: any): void;
}

/**
 * Internal cache data for the evaluation of a single curve timeline.
 *
 * @ignore
 */
declare class AnimCache {
    _left: number;
    _right: number;
    _len: number;
    _recip: number;
    _p0: number;
    _p1: number;
    _t: number;
    _hermite: {
        valid: boolean;
        p0: number;
        m0: number;
        p1: number;
        m1: number;
    };
    update(time: any, input: any): void;
    _findKey(time: any, input: any): number;
    eval(result: any, interpolation: any, output: any): void;
}

type AnimTrack$1 = AnimTrack$2;
/** @typedef {import('./anim-track.js').AnimTrack} AnimTrack */
/**
 * AnimSnapshot stores the state of an animation track at a particular time.
 *
 * @ignore
 */
declare class AnimSnapshot {
    /**
     * Create a new animation snapshot.
     *
     * @param {AnimTrack} animTrack - The source track.
     */
    constructor(animTrack: AnimTrack$1);
    _name: string;
    _time: number;
    _cache: AnimCache[];
    _results: number[][];
}

type AnimTrack = AnimTrack$2;
/** @typedef {import('./anim-track.js').AnimTrack} AnimTrack */
/**
 * AnimClip wraps the running state of an animation track. It contains and update the animation
 * 'cursor' and performs looping logic.
 *
 * @ignore
 */
declare class AnimClip$1 {
    /**
     * Create a new animation clip.
     *
     * @param {AnimTrack} track - The animation data.
     * @param {number} time - The initial time of the clip.
     * @param {number} speed - Speed of the animation playback.
     * @param {boolean} playing - true if the clip is playing and false otherwise.
     * @param {boolean} loop - Whether the clip should loop.
     * @param {Function} eventHandler - The handler to call when an event is fired by the clip.
     */
    constructor(track: AnimTrack, time: number, speed: number, playing: boolean, loop: boolean, eventHandler: Function);
    _name: string;
    _track: AnimTrack$2;
    _snapshot: AnimSnapshot;
    _playing: boolean;
    _time: number;
    _speed: number;
    _loop: boolean;
    _blendWeight: number;
    _blendOrder: number;
    _eventHandler: Function;
    _eventCursor: number;
    set name(arg: string);
    get name(): string;
    get track(): AnimTrack$2;
    get snapshot(): AnimSnapshot;
    set time(arg: number);
    get time(): number;
    set speed(arg: number);
    get speed(): number;
    set loop(arg: boolean);
    get loop(): boolean;
    set blendWeight(arg: number);
    get blendWeight(): number;
    set blendOrder(arg: number);
    get blendOrder(): number;
    set eventCursor(arg: number);
    get eventCursor(): number;
    activeEventsForFrame(frameStartTime: any, frameEndTime: any): void;
    _update(deltaTime: any): void;
    play(): void;
    stop(): void;
    pause(): void;
    resume(): void;
    reset(): void;
}

type AnimBinder = AnimBinder$1;
type AnimClip = AnimClip$1;
/** @typedef {import('../binder/anim-binder.js').AnimBinder} AnimBinder */
/** @typedef {import('./anim-clip.js').AnimClip} AnimClip */
/**
 * AnimEvaluator blends multiple sets of animation clips together.
 *
 * @ignore
 */
declare class AnimEvaluator$1 {
    static _dot(a: any, b: any): number;
    static _normalize(a: any): void;
    static _set(a: any, b: any, type: any): void;
    static _blendVec(a: any, b: any, t: any): void;
    static _blendQuat(a: any, b: any, t: any): void;
    static _blend(a: any, b: any, t: any, type: any): void;
    static _stableSort(a: any, lessFunc: any): void;
    /**
     * Create a new animation evaluator.
     *
     * @param {AnimBinder} binder - interface resolves curve paths to instances of {@link AnimTarget}.
     */
    constructor(binder: AnimBinder);
    _binder: AnimBinder$1;
    _clips: any[];
    _inputs: any[];
    _outputs: any[];
    _targets: {};
    /**
     * The list of animation clips.
     *
     * @type {AnimClip[]}
     */
    get clips(): AnimClip$1[];
    /**
     * Add a clip to the evaluator.
     *
     * @param {AnimClip} clip - The clip to add to the evaluator.
     */
    addClip(clip: AnimClip): void;
    /**
     * Remove a clip from the evaluator.
     *
     * @param {number} index - Index of the clip to remove.
     */
    removeClip(index: number): void;
    /**
     * Remove all clips from the evaluator.
     */
    removeClips(): void;
    /**
     * Returns the first clip which matches the given name, or null if no such clip was found.
     *
     * @param {string} name - Name of the clip to find.
     * @returns {AnimClip|null} - The clip with the given name or null if no such clip was found.
     */
    findClip(name: string): AnimClip | null;
    rebind(): void;
    assignMask(mask: any): any;
    /**
     * Evaluator frame update function. All the attached {@link AnimClip}s are evaluated, blended
     * and the results set on the {@link AnimTarget}.
     *
     * @param {number} deltaTime - The amount of time that has passed since the last update, in
     * seconds.
     */
    update(deltaTime: number): void;
}

/**
 * Implementation of {@link AnimBinder} for animating a skeleton in the graph-node hierarchy.
 *
 * @implements {AnimBinder}
 * @ignore
 */
declare class DefaultAnimBinder implements AnimBinder$1 {
    static createAnimTarget(func: any, type: any, valueCount: any, node: any, propertyPath: any, componentType: any): AnimTarget$1;
    constructor(graph: any);
    graph: any;
    _mask: any;
    nodes: {};
    targetCache: {};
    visitedFallbackGraphPaths: {};
    nodeCounts: {};
    activeNodes: any[];
    handlers: {
        localPosition: (node: any) => AnimTarget$1;
        localRotation: (node: any) => AnimTarget$1;
        localScale: (node: any) => AnimTarget$1;
        weights: (node: any) => AnimTarget$1;
        materialTexture: (node: any, textureName: any) => AnimTarget$1;
    };
    _isPathInMask: (path: any, checkMaskValue: any) => boolean;
    _isPathActive(path: any): boolean;
    findNode(path: any): any;
    resolve(path: any): any;
    unresolve(path: any): void;
    update(deltaTime: any): void;
    assignMask(mask: any): boolean;
}

/**
 * AnimTransitions represent connections in the controllers state graph between AnimStates. During
 * each frame, the controller tests to see if any of the AnimTransitions have the current AnimState
 * as their source (from) state. If so and the AnimTransitions parameter based conditions are met,
 * the controller will transition to the destination state.
 *
 * @ignore
 */
declare class AnimTransition {
    /**
     * Create a new AnimTransition.
     *
     * @param {object} options - Options.
     * @param {string} options.from - The state that this transition will exit from.
     * @param {string} options.to - The state that this transition will transition to.
     * @param {number} options.time - The duration of the transition in seconds. Defaults to 0.
     * @param {number} options.priority - Used to sort all matching transitions in ascending order.
     * The first transition in the list will be selected. Defaults to 0.
     * @param {object[]} options.conditions - A list of conditions which must pass for this
     * transition to be used. Defaults to [].
     * @param {number} options.exitTime - If provided, this transition will only be active for the
     * exact frame during which the source states progress passes the time specified. Given as a
     * normalized value of the source states duration. Values less than 1 will be checked every
     * animation loop. Defaults to null.
     * @param {number} options.transitionOffset - If provided, the destination state will begin
     * playing its animation at this time. Given in normalized time, based on the state's duration
     * and must be between 0 and 1. Defaults to null.
     * @param {string} options.interruptionSource - Defines whether another transition can
     * interrupt this one and which of the current or previous states transitions can do so. One of
     * pc.ANIM_INTERRUPTION_*. Defaults to pc.ANIM_INTERRUPTION_NONE.
     */
    constructor({ from, to, time, priority, conditions, exitTime, transitionOffset, interruptionSource }: {
        from: string;
        to: string;
        time: number;
        priority: number;
        conditions: object[];
        exitTime: number;
        transitionOffset: number;
        interruptionSource: string;
    });
    _from: string;
    _to: string;
    _time: number;
    _priority: number;
    _conditions: any[];
    _exitTime: number;
    _transitionOffset: number;
    _interruptionSource: string;
    get from(): string;
    set to(arg: string);
    get to(): string;
    get time(): number;
    get priority(): number;
    get conditions(): any[];
    get exitTime(): number;
    get transitionOffset(): number;
    get interruptionSource(): string;
    get hasExitTime(): boolean;
}

type EventHandler = EventHandler$1;
type AnimEvaluator = AnimEvaluator$1;
/** @typedef {import('../../core/event-handler.js').EventHandler} EventHandler */
/** @typedef {import('../evaluator/anim-evaluator.js').AnimEvaluator} AnimEvaluator */
/**
 * The AnimController manages the animations for its entity, based on the provided state graph and
 * parameters. Its update method determines which state the controller should be in based on the
 * current time, parameters and available states / transitions. It also ensures the AnimEvaluator
 * is supplied with the correct animations, based on the currently active state.
 *
 * @ignore
 */
declare class AnimController {
    /**
     * Create a new AnimController.
     *
     * @param {AnimEvaluator} animEvaluator - The animation evaluator used to blend all current
     * playing animation keyframes and update the entities properties based on the current
     * animation values.
     * @param {object[]} states - The list of states used to form the controller state graph.
     * @param {object[]} transitions - The list of transitions used to form the controller state
     * graph.
     * @param {object[]} parameters - The anim components parameters.
     * @param {boolean} activate - Determines whether the anim controller should automatically play
     * once all {@link AnimNodes} are assigned animations.
     * @param {EventHandler} eventHandler - The event handler which should be notified with anim
     * events.
     * @param {Set} consumedTriggers - Used to set triggers back to their default state after they
     * have been consumed by a transition.
     */
    constructor(animEvaluator: AnimEvaluator, states: object[], transitions: object[], parameters: object[], activate: boolean, eventHandler: EventHandler, consumedTriggers: Set<any>);
    _animEvaluator: AnimEvaluator$1;
    _states: {};
    _stateNames: any[];
    _eventHandler: EventHandler$1;
    _consumedTriggers: Set<any>;
    _transitions: AnimTransition[];
    _findTransitionsFromStateCache: {};
    _findTransitionsBetweenStatesCache: {};
    _parameters: any[];
    _previousStateName: any;
    _activeStateName: string;
    _playing: boolean;
    _activate: boolean;
    _currTransitionTime: number;
    _totalTransitionTime: number;
    _isTransitioning: boolean;
    _transitionInterruptionSource: string;
    _transitionPreviousStates: any[];
    _timeInState: number;
    _timeInStateBefore: number;
    get animEvaluator(): AnimEvaluator$1;
    set activeState(arg: any);
    get activeState(): any;
    get activeStateName(): string;
    get activeStateAnimations(): any;
    set previousState(arg: any);
    get previousState(): any;
    get previousStateName(): any;
    get playable(): boolean;
    set playing(arg: boolean);
    get playing(): boolean;
    get activeStateProgress(): number;
    get activeStateDuration(): number;
    set activeStateCurrentTime(arg: number);
    get activeStateCurrentTime(): number;
    get transitioning(): boolean;
    get transitionProgress(): number;
    get states(): any[];
    assignMask(mask: any): any;
    _findState(stateName: any): any;
    _getActiveStateProgressForTime(time: any): number;
    _findTransitionsFromState(stateName: any): any;
    _findTransitionsBetweenStates(sourceStateName: any, destinationStateName: any): any;
    _transitionHasConditionsMet(transition: any): boolean;
    _findTransition(from: any, to: any): any;
    updateStateFromTransition(transition: any): void;
    _transitionToState(newStateName: any): void;
    assignAnimation(pathString: any, animTrack: any, speed: any, loop: any): void;
    removeNodeAnimations(nodeName: any): boolean;
    play(stateName: any): void;
    pause(): void;
    reset(): void;
    rebind(): void;
    update(dt: any): void;
    findParameter(name: any): any;
}

/**
 * An asset resource which represents an anim state graph. It can be loaded into an anim component using the {@link AnimComponent#loadStateGraph} method.
 *
 * ## Usage
 * Scripts can retrieve an AnimStateGraph instance from assets of type 'animstategraph'. An AnimStateGraph can then be loaded into an anim component as follows:
 * ```javascript
 * const animStateGraph = app.assets.get(ASSET_ID).resource;
 * const entity = new pc.Entity();
 * entity.addComponent('anim');
 * entity.anim.loadStateGraph(animStateGraph);
 * ```
 */
declare class AnimStateGraph {
    /**
     * Create an AnimStateGraph instance from JSON data.
     *
     * @param {object} data - The JSON data to create the AnimStateGraph from.
     * @hideconstructor
     */
    constructor(data: object);
    _layers: any;
    _parameters: {};
    get parameters(): {};
    get layers(): any;
}

type Sound = Sound$3;
type SoundManager$1 = SoundManager$7;
/**
 * A SoundInstance3d plays a {@link Sound} in 3D.
 *
 * @property {Vec3} position The position of the sound in 3D space.
 * @property {Vec3} velocity The velocity of the sound.
 * @property {string} distanceModel Determines which algorithm to use to reduce the volume of the
 * audio as it moves away from the listener. Can be:
 *
 * - {@link DISTANCE_LINEAR}
 * - {@link DISTANCE_INVERSE}
 * - {@link DISTANCE_EXPONENTIAL}
 *
 * Default is {@link DISTANCE_LINEAR}.
 * @property {number} refDistance The reference distance for reducing volume as the sound source
 * moves further from the listener.
 * @property {number} maxDistance The maximum distance from the listener at which audio falloff
 * stops. Note the volume of the audio is not 0 after this distance, but just doesn't fall off
 * anymore.
 * @property {number} rollOffFactor The factor used in the falloff equation.
 * @augments SoundInstance
 */
declare class SoundInstance3d extends SoundInstance$1 {
    /**
     * Create a new SoundInstance3d instance.
     *
     * @param {SoundManager} manager - The sound manager.
     * @param {Sound} sound - The sound to play.
     * @param {object} options - Options for the instance.
     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
     * @param {boolean} [options.loop=false] - Whether the sound should loop when it reaches the
     * end or not.
     * @param {number} [options.startTime=0] - The time from which the playback will start. Default
     * is 0 to start at the beginning.
     * @param {number} [options.duration=null] - The total time after the startTime when playback
     * will stop or restart if loop is true.
     * @param {Vec3} [options.position=null] - The position of the sound in 3D space.
     * @param {Vec3} [options.velocity=null] - The velocity of the sound.
     * @param {string} [options.distanceModel=DISTANCE_LINEAR] - Determines which algorithm to use
     * to reduce the volume of the audio as it moves away from the listener. Can be:
     *
     * - {@link DISTANCE_LINEAR}
     * - {@link DISTANCE_INVERSE}
     * - {@link DISTANCE_EXPONENTIAL}
     *
     * Default is {@link DISTANCE_LINEAR}.
     * @param {number} [options.refDistance=1] - The reference distance for reducing volume as the
     * sound source moves further from the listener.
     * @param {number} [options.maxDistance=10000] - The maximum distance from the listener at which
     * audio falloff stops. Note the volume of the audio is not 0 after this distance, but just
     * doesn't fall off anymore.
     * @param {number} [options.rollOffFactor=1] - The factor used in the falloff equation.
     */
    constructor(manager: SoundManager$1, sound: Sound, options: {
        volume?: number;
        pitch?: number;
        loop?: boolean;
        startTime?: number;
        duration?: number;
        position?: Vec3$1;
        velocity?: Vec3$1;
        distanceModel?: string;
        refDistance?: number;
        maxDistance?: number;
        rollOffFactor?: number;
    });
    _position: Vec3$1;
    set position(arg: any);
    get position(): any;
    _velocity: Vec3$1;
    set velocity(arg: any);
    get velocity(): any;
    set maxDistance(arg: any);
    get maxDistance(): any;
    set refDistance(arg: any);
    get refDistance(): any;
    set rollOffFactor(arg: any);
    get rollOffFactor(): any;
    set distanceModel(arg: any);
    get distanceModel(): any;
}

/**
 * Represents the resource of a Bundle Asset, which contains an index that maps URLs to blob URLs.
 *
 * @ignore
 */
declare class Bundle {
    /**
     * Create a new Bundle instance.
     *
     * @param {object[]} files - An array of objects that have a name field and contain a
     * getBlobUrl() function.
     */
    constructor(files: object[]);
    _blobUrls: {};
    /**
     * Returns true if the specified URL exists in the loaded bundle.
     *
     * @param {string} url - The original file URL. Make sure you have called decodeURIComponent on
     * the URL first.
     * @returns {boolean} True of false.
     */
    hasBlobUrl(url: string): boolean;
    /**
     * Returns a blob URL for the specified URL.
     *
     * @param {string} url - The original file URL. Make sure you have called decodeURIComponent on
     * the URL first.
     * @returns {string} A blob URL.
     */
    getBlobUrl(url: string): string;
    /**
     * Destroys the bundle and frees up blob URLs.
     */
    destroy(): void;
}

type ResourceHandler$f = ResourceHandler$h;
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Resource handler used for loading {@link AnimClip} resources.
 *
 * @implements {ResourceHandler}
 * @ignore
 */
declare class AnimClipHandler implements ResourceHandler$f {
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): AnimTrack$2;
    patch(asset: any, assets: any): void;
}

type ResourceHandler$e = ResourceHandler$h;
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Resource handler used for loading {@link AnimStateGraph} resources.
 *
 * @implements {ResourceHandler}
 * @ignore
 */
declare class AnimStateGraphHandler implements ResourceHandler$e {
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): AnimStateGraph;
    patch(asset: any, assets: any): void;
}

type ResourceHandler$d = ResourceHandler$h;
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Resource handler used for loading {@link Animation} resources.
 *
 * @implements {ResourceHandler}
 */
declare class AnimationHandler implements ResourceHandler$d {
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
    _parseAnimationV3(data: any): Animation$1;
    _parseAnimationV4(data: any): Animation$1;
}

type SoundManager = SoundManager$7;
type ResourceHandler$c = ResourceHandler$h;
/**
 * Resource handler used for loading {@link Sound} resources.
 *
 * @implements {ResourceHandler}
 */
declare class AudioHandler implements ResourceHandler$c {
    /**
     * Create a new AudioHandler instance.
     *
     * @param {SoundManager} manager - The sound manager.
     */
    constructor(manager: SoundManager);
    manager: SoundManager$7;
    maxRetries: number;
    _isSupported(url: any): boolean;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
    /**
     * Loads an audio asset using an AudioContext by URL and calls success or error with the
     * created resource or error respectively.
     *
     * @param {string} url - The url of the audio asset.
     * @param {Function} success - Function to be called if the audio asset was loaded or if we
     * just want to continue without errors even if the audio is not loaded.
     * @param {Function} error - Function to be called if there was an error while loading the
     * audio asset.
     * @private
     */
    private _createSound;
}

declare class BinaryHandler {
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
}

type AssetRegistry$5 = AssetRegistry$c;
type ResourceHandler$b = ResourceHandler$h;
/** @typedef {import('../asset/asset-registry.js').AssetRegistry} AssetRegistry */
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Loads Bundle Assets.
 *
 * @implements {ResourceHandler}
 * @ignore
 */
declare class BundleHandler implements ResourceHandler$b {
    /**
     * Create a new BundleHandler instance.
     *
     * @param {AssetRegistry} assets - The asset registry.
     */
    constructor(assets: AssetRegistry$5);
    _assets: AssetRegistry$c;
    _worker: any;
    maxRetries: number;
    load(url: any, callback: any): void;
    _untar(response: any, callback: any): void;
    open(url: any, data: any): Bundle;
    patch(asset: any, assets: any): void;
}

type AssetRegistry$4 = AssetRegistry$c;
type GraphicsDevice$5 = GraphicsDevice$l;
type ResourceHandler$a = ResourceHandler$h;
type ResourceLoader$3 = ResourceLoader$4;
/** @typedef {import('../asset/asset-registry.js').AssetRegistry} AssetRegistry */
/** @typedef {import('../graphics/graphics-device.js').GraphicsDevice} GraphicsDevice */
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/** @typedef {import('./loader.js').ResourceLoader} ResourceLoader */
/**
 * Resource handler used for loading cubemap {@link Texture} resources.
 *
 * @implements {ResourceHandler}
 */
declare class CubemapHandler implements ResourceHandler$a {
    /**
     * Create a new CubemapHandler instance.
     *
     * @param {GraphicsDevice} device - The graphics device.
     * @param {AssetRegistry} assets - The asset registry.
     * @param {ResourceLoader} loader - The resource loader.
     */
    constructor(device: GraphicsDevice$5, assets: AssetRegistry$4, loader: ResourceLoader$3);
    _device: GraphicsDevice$l;
    _registry: AssetRegistry$c;
    _loader: ResourceLoader$4;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, asset: any): any;
    patch(asset: any, registry: any): void;
    getAssetIds(cubemapAsset: any): any[];
    compareAssetIds(assetIdA: any, assetIdB: any): boolean;
    update(cubemapAsset: any, assetIds: any, assets: any): void;
    cmpArrays(arr1: any, arr2: any): boolean;
    resolveId(value: any): any;
    loadAssets(cubemapAsset: any, callback: any): void;
}

declare class FolderHandler {
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
}

type ResourceHandler$9 = ResourceHandler$h;
type ResourceLoader$2 = ResourceLoader$4;
/**
 * Resource handler used for loading {@link Font} resources.
 *
 * @implements {ResourceHandler}
 */
declare class FontHandler implements ResourceHandler$9 {
    /**
     * Create a new FontHandler instance.
     *
     * @param {ResourceLoader} loader - The resource loader.
     */
    constructor(loader: ResourceLoader$2);
    _loader: ResourceLoader$4;
    maxRetries: number;
    load(url: any, callback: any, asset: any): void;
    _loadTextures(url: any, data: any, callback: any): void;
    open(url: any, data: any, asset: any): Font$1;
    patch(asset: any, assets: any): void;
}

declare class HierarchyHandler {
    constructor(app: any);
    _app: any;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): Entity$a;
}

declare class HtmlHandler {
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
}

declare class JsonHandler {
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
}

declare class StandardMaterialValidator {
    removeInvalid: boolean;
    valid: boolean;
    enumValidators: {
        occludeSpecular: (value: any) => boolean;
        cull: (value: any) => boolean;
        blendType: (value: any) => boolean;
        shadingModel: (value: any) => boolean;
    };
    setInvalid(key: any, data: any): void;
    validate(data: any): boolean;
    _createEnumValidator(values: any): (value: any) => boolean;
}

/**
 * Convert incoming JSON data into a {@link StandardMaterial}.
 *
 * @ignore
 */
declare class JsonStandardMaterialParser {
    _validator: StandardMaterialValidator;
    parse(input: any): StandardMaterial;
    /**
     * Initialize material properties from the material data block e.g. Loading from server.
     *
     * @param {StandardMaterial} material - The material to be initialized.
     * @param {object} data - The data block that is used to initialize.
     */
    initialize(material: StandardMaterial, data: object): void;
    migrate(data: any): any;
    _validate(data: any): any;
}

type Application$4 = Application$7;
type ResourceHandler$8 = ResourceHandler$h;
/**
 * Resource handler used for loading {@link Material} resources.
 *
 * @implements {ResourceHandler}
 */
declare class MaterialHandler implements ResourceHandler$8 {
    /**
     * Create a new MaterialHandler instance.
     *
     * @param {Application} app - The running {@link Application}.
     */
    constructor(app: Application$4);
    _assets: AssetRegistry$c;
    _device: GraphicsDevice$l;
    _placeholderTextures: {};
    _parser: JsonStandardMaterialParser;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): StandardMaterial;
    _createPlaceholders(): void;
    patch(asset: any, assets: any): void;
    _onAssetUnload(asset: any): void;
    _assignTexture(parameterName: any, materialAsset: any, texture: any): void;
    _getPlaceholderTexture(parameterName: any): any;
    _assignPlaceholderTexture(parameterName: any, materialAsset: any): void;
    _onTextureLoad(parameterName: any, materialAsset: any, textureAsset: any): void;
    _onTextureAdd(parameterName: any, materialAsset: any, textureAsset: any): void;
    _onTextureRemoveOrUnload(parameterName: any, materialAsset: any, textureAsset: any): void;
    _assignCubemap(parameterName: any, materialAsset: any, textures: any): void;
    _onCubemapLoad(parameterName: any, materialAsset: any, cubemapAsset: any): void;
    _onCubemapAdd(parameterName: any, materialAsset: any, cubemapAsset: any): void;
    _onCubemapRemoveOrUnload(parameterName: any, materialAsset: any, cubemapAsset: any): void;
    _bindAndAssignAssets(materialAsset: any, assets: any): void;
}

type GraphicsDevice$4 = GraphicsDevice$l;
type ResourceHandler$7 = ResourceHandler$h;
/**
 * Callback used by {@link ModelHandleraddParser } to decide on which parser to use.
 */
type addParserCallback = (url: string, data: object) => boolean;
/** @typedef {import('../graphics/graphics-device.js').GraphicsDevice} GraphicsDevice */
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Callback used by {@link ModelHandler#addParser} to decide on which parser to use.
 *
 * @callback addParserCallback
 * @param {string} url - The resource url.
 * @param {object} data - The raw model data.
 * @returns {boolean} Return true if this parser should be used to parse the data into a
 * {@link Model}.
 */
/**
 * Resource handler used for loading {@link Model} resources.
 *
 * @implements {ResourceHandler}
 */
declare class ModelHandler implements ResourceHandler$7 {
    /**
     * Create a new ModelHandler instance.
     *
     * @param {GraphicsDevice} device - The graphics device that will be rendering.
     */
    constructor(device: GraphicsDevice$4);
    _device: GraphicsDevice$l;
    _parsers: any[];
    _defaultMaterial: any;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
    /**
     * Add a parser that converts raw data into a {@link Model}. Default parser is for JSON models.
     *
     * @param {object} parser - See JsonModelParser for example.
     * @param {addParserCallback} decider - Function that decides on which parser to use. Function
     * should take (url, data) arguments and return true if this parser should be used to parse the
     * data into a {@link Model}. The first parser to return true is used.
     */
    addParser(parser: object, decider: addParserCallback): void;
}

/** @typedef {import('./mesh.js').Mesh} Mesh */
/**
 * @event
 * @private
 * @name Render#set:meshes
 * @description Fired when the meshes are set
 * @param {Mesh[]} meshes - The meshes
 */
/**
 * A render contains an array of meshes that are referenced by a single hierarchy node in a GLB
 * model, and are accessible using {@link ContainerResource#renders} property. The render is the
 * resource of a Render Asset.
 *
 * @augments EventHandler
 * @ignore
 */
declare class Render extends EventHandler$1 {
    /**
     * Meshes are reference counted, and this class owns the references and is responsible for
     * releasing the meshes when they are no longer referenced.
     *
     * @type {Mesh[]}
     * @private
     */
    private _meshes;
    /**
     * The meshes that the render contains.
     *
     * @type {Mesh[]}
     */
    set meshes(arg: Mesh$1[]);
    get meshes(): Mesh$1[];
    destroy(): void;
    decRefMeshes(): void;
    incRefMeshes(): void;
}

type AssetRegistry$3 = AssetRegistry$c;
type ResourceHandler$6 = ResourceHandler$h;
/**
 * Resource handler used for loading {@link Render} resources.
 *
 * @implements {ResourceHandler}
 */
declare class RenderHandler implements ResourceHandler$6 {
    /**
     * Create a new RenderHandler instance.
     *
     * @param {AssetRegistry} assets - The asset registry.
     */
    constructor(assets: AssetRegistry$3);
    _registry: AssetRegistry$c;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any): Render;
    patch(asset: any, registry: any): void;
}

type Application$3 = Application$7;
type ResourceHandler$5 = ResourceHandler$h;
/** @typedef {import('../framework/application.js').Application} Application */
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Resource handler for loading JavaScript files dynamically.  Two types of JavaScript files can be
 * loaded, PlayCanvas scripts which contain calls to {@link createScript}, or regular JavaScript
 * files, such as third-party libraries.
 *
 * @implements {ResourceHandler}
 */
declare class ScriptHandler implements ResourceHandler$5 {
    static _types: any[];
    static _push(Type: any): void;
    /**
     * Create a new ScriptHandler instance.
     *
     * @param {Application} app - The running {@link Application}.
     */
    constructor(app: Application$3);
    _app: Application$7;
    _scripts: {};
    _cache: {};
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
    _loadScript(url: any, callback: any): void;
}

type Application$2 = Application$7;
type ResourceHandler$4 = ResourceHandler$h;
/** @typedef {import('../framework/application.js').Application} Application */
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Resource handler used for loading {@link Scene} resources.
 *
 * @implements {ResourceHandler}
 */
declare class SceneHandler implements ResourceHandler$4 {
    /**
     * Create a new SceneHandler instance.
     *
     * @param {Application} app - The running {@link Application}.
     */
    constructor(app: Application$2);
    _app: Application$7;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): Scene$3;
    patch(asset: any, assets: any): void;
}

declare class SceneSettingsHandler {
    constructor(app: any);
    _app: any;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
}

declare class ShaderHandler {
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
}

type AssetRegistry$2 = AssetRegistry$c;
type GraphicsDevice$3 = GraphicsDevice$l;
type ResourceHandler$3 = ResourceHandler$h;
/**
 * Resource handler used for loading {@link Sprite} resources.
 *
 * @implements {ResourceHandler}
 */
declare class SpriteHandler implements ResourceHandler$3 {
    /**
     * Create a new SpriteHandler instance.
     *
     * @param {AssetRegistry} assets - The asset registry.
     * @param {GraphicsDevice} device - The graphics device.
     */
    constructor(assets: AssetRegistry$2, device: GraphicsDevice$3);
    _assets: AssetRegistry$c;
    _device: GraphicsDevice$l;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): Sprite$1;
    patch(asset: any, assets: any): void;
    _updateAtlas(asset: any): void;
    _onAssetChange(asset: any, attribute: any, value: any, oldValue: any): void;
}

type Application$1 = Application$7;
type Entity$1 = Entity$a;
/** @typedef {import('../framework/application.js').Application} Application */
/** @typedef {import('../framework/entity.js').Entity} Entity */
/**
 * Create a Template resource from raw database data.
 */
declare class Template {
    /**
     * Create a new Template instance.
     *
     * @param {Application} app - The application.
     * @param {object} data - Asset data from the database.
     */
    constructor(app: Application$1, data: object);
    _app: Application$7;
    _data: any;
    _templateRoot: Entity$a;
    /**
     * Create an instance of this template.
     *
     * @returns {Entity} The root entity of the created instance.
     */
    instantiate(): Entity$1;
    _parseTemplate(): void;
}

declare class TemplateHandler {
    constructor(app: any);
    _app: any;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): Template;
}

declare class TextHandler {
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
}

type ResourceHandler$2 = ResourceHandler$h;
type ResourceLoader$1 = ResourceLoader$4;
/**
 * Resource handler used for loading {@link TextureAtlas} resources.
 *
 * @implements {ResourceHandler}
 */
declare class TextureAtlasHandler implements ResourceHandler$2 {
    /**
     * Create a new TextureAtlasHandler instance.
     *
     * @param {ResourceLoader} loader - The resource loader.
     */
    constructor(loader: ResourceLoader$1);
    _loader: ResourceLoader$4;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): TextureAtlas$1;
    patch(asset: any, assets: any): void;
    _onAssetChange(asset: any, attribute: any, value: any): void;
}

declare namespace script {
    const legacy: boolean;
}

/**
 * Used to manage layout calculations for {@link LayoutGroupComponent}s.
 *
 * @ignore
 */
declare class LayoutCalculator {
    calculateLayout(elements: any, options: any): any;
}

declare class ScriptLegacyComponent extends Component$2 {
    constructor(system: any, entity: any);
    send(name: any, functionName: any, ...args: any[]): any;
    onSetScripts(name: any, oldValue: any, newValue: any): void;
    _updateScriptAttributes(oldValue: any, newValue: any): boolean;
    _loadFromCache(urls: any): boolean;
    _loadScripts(urls: any): void;
}

declare class ScriptLegacyComponentData {
    scripts: any[];
    enabled: boolean;
    instances: {};
    _instances: {};
    runInTools: boolean;
    attributes: {};
    initialized: boolean;
    postInitialized: boolean;
    areScriptsLoaded: boolean;
}

declare class ScriptLegacyComponentSystem extends ComponentSystem {
    constructor(app: any);
    id: string;
    ComponentType: typeof ScriptLegacyComponent;
    DataType: typeof ScriptLegacyComponentData;
    preloading: boolean;
    instancesWithUpdate: any[];
    instancesWithFixedUpdate: any[];
    instancesWithPostUpdate: any[];
    instancesWithToolsUpdate: any[];
    onBeforeRemove(entity: any, component: any): void;
    onInitialize(root: any): void;
    onPostInitialize(root: any): void;
    _callInstancesMethod(script: any, method: any): void;
    _initializeScriptComponent(script: any): void;
    _enableScriptComponent(script: any): void;
    _disableScriptComponent(script: any): void;
    _destroyScriptComponent(script: any): void;
    _postInitializeScriptComponent(script: any): void;
    _updateInstances(method: any, updateList: any, dt: any): void;
    onUpdate(dt: any): void;
    onFixedUpdate(dt: any): void;
    onPostUpdate(dt: any): void;
    onToolsUpdate(dt: any): void;
    broadcast(name: any, functionName: any, ...args: any[]): void;
    _preRegisterInstance(entity: any, url: any, name: any, instance: any): void;
    _registerInstances(entity: any): void;
    _cloneAttributes(attributes: any): {};
    _createAccessors(entity: any, instance: any): void;
    _createAccessor(attribute: any, instance: any): void;
    _updateAccessors(entity: any, instance: any): void;
    _convertAttributeValue(attribute: any): void;
}

type Application = Application$7;
/**
 * Callback used by {@link VrDisplayrequestPresent } and {@link VrDisplayexitPresent }.
 */
type vrDisplayCallback = (err: string | null) => any;
/**
 * Callback used by {@link VrDisplayrequestAnimationFrame }.
 */
type vrFrameCallback = () => any;
/** @typedef {import('../framework/application.js').Application} Application */
/**
 * Callback used by {@link VrDisplay#requestPresent} and {@link VrDisplay#exitPresent}.
 *
 * @callback vrDisplayCallback
 * @param {string|null} err - The error message if presenting fails, or null if the call succeeds.
 * @ignore
 */
/**
 * Callback used by {@link VrDisplay#requestAnimationFrame}.
 *
 * @callback vrFrameCallback
 * @ignore
 */
/**
 * Represents a single Display for VR content. This could be a Head Mounted display that can
 * present content on a separate screen or a phone which can display content full screen on the
 * same screen. This object contains the native `navigator.VRDisplay` object from the WebVR API.
 *
 * @property {number} id An identifier for this distinct VRDisplay.
 * @property {*} display The native VRDisplay object from the WebVR API.
 * @property {boolean} presenting True if this display is currently presenting VR content.
 * @property {VRDisplayCapabilities} capabilities Returns the
 * [VRDisplayCapabilities](https://w3c.github.io/webvr/#interface-vrdisplaycapabilities) object
 * from the VRDisplay. This can be used to determine what features are available on this display.
 * @augments EventHandler
 * @deprecated
 * @ignore
 */
declare class VrDisplay extends EventHandler$1 {
    /**
     * Create a new VrDisplay instance.
     *
     * @param {Application} app - The application outputting to this VR display.
     * @param {*} display - The native VRDisplay object from the WebVR API.
     */
    constructor(app: Application, display: any);
    _app: Application$7;
    _device: GraphicsDevice$l;
    id: any;
    _frameData: any;
    display: any;
    _camera: any;
    sitToStandInv: Mat4$5;
    leftView: Mat4$5;
    leftProj: Mat4$5;
    leftViewInv: Mat4$5;
    leftPos: Vec3$1;
    rightView: Mat4$5;
    rightProj: Mat4$5;
    rightViewInv: Mat4$5;
    rightPos: Vec3$1;
    combinedPos: Vec3$1;
    combinedView: Mat4$5;
    combinedProj: Mat4$5;
    combinedViewInv: Mat4$5;
    combinedFov: number;
    combinedAspect: number;
    presenting: boolean;
    _presentChange: (event: any) => void;
    /**
     * Destroy this display object.
     *
     * @deprecated
     */
    destroy(): void;
    /**
     * Called once per frame to update the current status from the display. Usually called by {@link VrManager}.
     *
     * @deprecated
     */
    poll(): void;
    /**
     * Try to present full screen VR content on this display.
     *
     * @param {vrDisplayCallback} callback - Called when the request is completed. Callback takes a
     * single argument (err) that is the error message return if presenting fails, or null if the
     * call succeeds. Usually called by {@link CameraComponent#enterVr}.
     * @deprecated
     */
    requestPresent(callback: vrDisplayCallback): void;
    /**
     * Try to stop presenting VR content on this display.
     *
     * @param {vrDisplayCallback} callback - Called when the request is completed. Callback takes a
     * single argument (err) that is the error message return if presenting fails, or null if the
     * call succeeds. Usually called by {@link CameraComponent#exitVr}.
     * @deprecated
     */
    exitPresent(callback: vrDisplayCallback): void;
    /**
     * Used in the main application loop instead of the regular `window.requestAnimationFrame`.
     * Usually only called from inside {@link Application}.
     *
     * @param {vrFrameCallback} fn - Function called when it is time to update the frame.
     * @deprecated
     */
    requestAnimationFrame(fn: vrFrameCallback): void;
    /**
     * Called when animation update is complete and the frame is ready to be sent to the display.
     * Usually only called from inside {@link Application}.
     *
     * @deprecated
     */
    submitFrame(): void;
    /**
     * Called to reset the pose of the {@link VrDisplay}. Treating its current pose as the
     * origin/zero. This should only be called in 'sitting' experiences.
     *
     * @deprecated
     */
    reset(): void;
    /**
     * Set the near and far depth plans of the display. This enables mapping of values in the
     * render target depth attachment to scene coordinates.
     *
     * @param {number} n - The near depth distance.
     * @param {number} f - The far depth distance.
     * @deprecated
     */
    setClipPlanes(n: number, f: number): void;
    /**
     * Return the current frame data that is updated during polling.
     *
     * @returns {*} The frame data object.
     * @deprecated
     */
    getFrameData(): any;
    get capabilities(): any;
}

declare const apps: {};
declare const common: {};
declare const config: {};
declare const data: {};
/**
 * Merge the contents of two objects into a single object.
 *
 * @param {object} target - The target object of the merge.
 * @param {object} ex - The object that is merged with target.
 * @returns {object} The target object.
 * @example
 * var A = {
 *     a: function () {
 *         console.log(this.a);
 *     }
 * };
 * var B = {
 *     b: function () {
 *         console.log(this.b);
 *     }
 * };
 *
 * pc.extend(A, B);
 * A.a();
 * // logs "a"
 * A.b();
 * // logs "b"
 * @ignore
 */
declare function extend(target: object, ex: object): object;
/**
 * Return true if the Object is not undefined.
 *
 * @param {object} o - The Object to test.
 * @returns {boolean} True if the Object is not undefined.
 * @ignore
 */
declare function isDefined(o: object): boolean;
declare const revision: "__REVISION__";
/**
 * Extended typeof() function, returns the type of the object.
 *
 * @param {object} obj - The object to get the type of.
 * @returns {string} The type string: "null", "undefined", "number", "string", "boolean", "array", "object", "function", "date", "regexp" or "float32array".
 * @ignore
 */
declare function type(obj: object): string;
/**
 * @name pc
 * @namespace
 * @description Root namespace for the PlayCanvas Engine.
 */
declare const version: "__CURRENT_SDK_VERSION__";

/**
 * Create a URI object from constituent parts.
 *
 * @param {object} options - Parts of the URI to build.
 * @param {string} [options.scheme] - The URI scheme (e.g. http).
 * @param {string} [options.authority] - The URI authority (e.g. `www.example.com`).
 * @param {string} [options.host] - Combination of scheme and authority (e.g. `http://www.example.com`).
 * @param {string} [options.path] - The URI path (e.g. /users/example).
 * @param {string} [options.hostpath] - Combination of scheme, authority and path (e.g. `http://www.example.com/users/example`).
 * @param {string} [options.query] - The query section, after the ?(e.g. `http://example.com?**key=value&another=123**`).
 * @param {string} [options.fragment] - The fragment section, after the # (e.g. `http://example.com#**fragment/data**`).
 * @returns {string} A URI string.
 * @ignore
 */
declare function createURI(options: {
    scheme?: string;
    authority?: string;
    host?: string;
    path?: string;
    hostpath?: string;
    query?: string;
    fragment?: string;
}): string;
/**
 * A URI object.
 *
 * @ignore
 */
declare class URI {
    /**
     * Create a new URI instance.
     *
     * @param {string} uri - URI string.
     */
    constructor(uri: string);
    /**
     * The scheme. (e.g. http).
     *
     * @type {string}
     */
    scheme: string;
    /**
     * The authority. (e.g. `www.example.com`).
     *
     * @type {string}
     */
    authority: string;
    /**
     * The path. (e.g. /users/example).
     *
     * @type {string}
     */
    path: string;
    /**
     * The query, the section after a ?. (e.g. search=value).
     *
     * @type {string}
     */
    query: string;
    /**
     * The fragment, the section after a #.
     *
     * @type {string}
     */
    fragment: string;
    /**
     * Convert URI back to string.
     *
     * @returns {string} The URI as a string.
     */
    toString(): string;
    /**
     * Returns the query parameters as an Object.
     *
     * @returns {object} The URI's query parameters converted to an Object.
     * @example
     * var s = "http://example.com?a=1&b=2&c=3";
     * var uri = new pc.URI(s);
     * var q = uri.getQuery();
     * console.log(q.a); // logs "1"
     * console.log(q.b); // logs "2"
     * console.log(q.c); // logs "3"
     */
    getQuery(): object;
    /**
     * Set the query section of the URI from a Object.
     *
     * @param {object} params - Key-Value pairs to encode into the query string.
     * @example
     * var s = "http://example.com";
     * var uri = new pc.URI(s);
     * uri.setQuery({
     *     "a": 1,
     *     "b": 2
     * });
     * console.log(uri.toString()); // logs "http://example.com?a=1&b=2
     */
    setQuery(params: object): void;
}

/**
 * Callback used by {@link Httpget }, {@link Httppost }, {@link Httpput }, {@link Httpdel }, and
 * {@link Httprequest }.
 */
type httpResponseCallback = (err: number | string | Error | null, response?: any) => any;
declare const http: Http;
/**
 * Callback used by {@link Http#get}, {@link Http#post}, {@link Http#put}, {@link Http#del}, and
 * {@link Http#request}.
 *
 * @callback httpResponseCallback
 * @param {number|string|Error|null} err - The error code, message, or exception in the case where the request fails.
 * @param {*} [response] - The response data if no errors were encountered. (format depends on response type: text, Object, ArrayBuffer, XML).
 */
/**
 * Used to send and receive HTTP requests.
 */
declare class Http {
    static ContentType: {
        FORM_URLENCODED: string;
        GIF: string;
        JPEG: string;
        DDS: string;
        JSON: string;
        PNG: string;
        TEXT: string;
        XML: string;
        WAV: string;
        OGG: string;
        MP3: string;
        MP4: string;
        AAC: string;
        BIN: string;
        BASIS: string;
        GLB: string;
    };
    static ResponseType: {
        TEXT: string;
        ARRAY_BUFFER: string;
        BLOB: string;
        DOCUMENT: string;
        JSON: string;
    };
    static binaryExtensions: string[];
    static retryDelay: number;
    /**
     * @function
     * @name Http#get
     * @description Perform an HTTP GET request to the given url.
     * @param {string} url - The URL to make the request to.
     * @param {httpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.get("http://example.com/", function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    /**
     * @function
     * @name Http#get
     * @variation 2
     * @description Perform an HTTP GET request to the given url with additional options such as headers, retries, credentials, etc.
     * @param {string} url - The URL to make the request to.
     * @param {object} options - Additional options.
     * @param {object} [options.headers] - HTTP headers to add to the request.
     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
     * @param {object} [options.cache] - If false, then add a timestamp to the request to prevent caching.
     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
     * @param {string} [options.responseType] - Override the response type.
     * @param {Document|object} [options.postdata] - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
     * @param {httpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.get("http://example.com/", { "retry": true, "maxRetries": 5 }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    get(url: string, options: {
        headers?: object;
        async?: boolean;
        cache?: object;
        withCredentials?: boolean;
        responseType?: string;
        postdata?: Document | object;
        retry?: boolean;
        maxRetries?: number;
        maxRetryDelay?: number;
    }, callback: httpResponseCallback): XMLHttpRequest;
    /**
     * @function
     * @name Http#post
     * @description Perform an HTTP POST request to the given url.
     * @param {string} url - The URL to make the request to.
     * @param {object} data - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {httpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.post("http://example.com/", { "name": "Alix" }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    /**
     * @function
     * @name Http#post
     * @variation 2
     * @description Perform an HTTP POST request to the given url with additional options such as headers, retries, credentials, etc.
     * @param {string} url - The URL to make the request to.
     * @param {object} data - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {object} options - Additional options.
     * @param {object} [options.headers] - HTTP headers to add to the request.
     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
     * @param {object} [options.cache] - If false, then add a timestamp to the request to prevent caching.
     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
     * @param {string} [options.responseType] - Override the response type.
     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
     * @param {httpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.post("http://example.com/", { "name": "Alix" }, { "retry": true, "maxRetries": 5 }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    post(url: string, data: object, options: {
        headers?: object;
        async?: boolean;
        cache?: object;
        withCredentials?: boolean;
        responseType?: string;
        retry?: boolean;
        maxRetries?: number;
        maxRetryDelay?: number;
    }, callback: httpResponseCallback): XMLHttpRequest;
    /**
     * @function
     * @name Http#put
     * @description Perform an HTTP PUT request to the given url.
     * @param {string} url - The URL to make the request to.
     * @param {Document|object} data - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {httpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.put("http://example.com/", { "name": "Alix" }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    /**
     * @function
     * @name Http#put
     * @variation 2
     * @description Perform an HTTP PUT request to the given url with additional options such as headers, retries, credentials, etc.
     * @param {string} url - The URL to make the request to.
     * @param {Document|object} data - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {object} options - Additional options.
     * @param {object} [options.headers] - HTTP headers to add to the request.
     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
     * @param {object} [options.cache] - If false, then add a timestamp to the request to prevent caching.
     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
     * @param {string} [options.responseType] - Override the response type.
     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
     * @param {httpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.put("http://example.com/", { "name": "Alix" }, { "retry": true, "maxRetries": 5 }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    put(url: string, data: Document | object, options: {
        headers?: object;
        async?: boolean;
        cache?: object;
        withCredentials?: boolean;
        responseType?: string;
        retry?: boolean;
        maxRetries?: number;
        maxRetryDelay?: number;
    }, callback: httpResponseCallback): XMLHttpRequest;
    /**
     * @function
     * @name Http#del
     * @description Perform an HTTP DELETE request to the given url.
     * @param {object} url - The URL to make the request to.
     * @param {httpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.del("http://example.com/", function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    /**
     * @function
     * @name Http#del
     * @variation 2
     * @description Perform an HTTP DELETE request to the given url with additional options such as headers, retries, credentials, etc.
     * @param {object} url - The URL to make the request to.
     * @param {object} options - Additional options.
     * @param {object} [options.headers] - HTTP headers to add to the request.
     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
     * @param {boolean} [options.cache] - If false, then add a timestamp to the request to prevent caching.
     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
     * @param {string} [options.responseType] - Override the response type.
     * @param {Document|object} [options.postdata] - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
     * @param {httpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.del("http://example.com/", { "retry": true, "maxRetries": 5 }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    del(url: object, options: {
        headers?: object;
        async?: boolean;
        cache?: boolean;
        withCredentials?: boolean;
        responseType?: string;
        postdata?: Document | object;
        retry?: boolean;
        maxRetries?: number;
        maxRetryDelay?: number;
    }, callback: httpResponseCallback): XMLHttpRequest;
    /**
     * @function
     * @name Http#request
     * @description Make a general purpose HTTP request.
     * @param {string} method - The HTTP method "GET", "POST", "PUT", "DELETE".
     * @param {string} url - The url to make the request to.
     * @param {httpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.request("get", "http://example.com/", function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    /**
     * @function
     * @name Http#request
     * @variation 2
     * @description Make a general purpose HTTP request with additional options such as headers, retries, credentials, etc.
     * @param {string} method - The HTTP method "GET", "POST", "PUT", "DELETE".
     * @param {string} url - The url to make the request to.
     * @param {object} options - Additional options.
     * @param {object} [options.headers] - HTTP headers to add to the request.
     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
     * @param {boolean} [options.cache] - If false, then add a timestamp to the request to prevent caching.
     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
     * @param {string} [options.responseType] - Override the response type.
     * @param {Document|object} [options.postdata] - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {httpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.request("get", "http://example.com/", { "retry": true, "maxRetries": 5 }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    request(method: string, url: string, options: {
        headers?: object;
        async?: boolean;
        cache?: boolean;
        withCredentials?: boolean;
        retry?: boolean;
        maxRetries?: number;
        maxRetryDelay?: number;
        responseType?: string;
        postdata?: Document | object;
    }, callback: httpResponseCallback): XMLHttpRequest;
    _guessResponseType(url: any): string;
    _isBinaryContentType(contentType: any): boolean;
    _onReadyStateChange(method: any, url: any, options: any, xhr: any): void;
    _onSuccess(method: any, url: any, options: any, xhr: any): void;
    _onError(method: any, url: any, options: any, xhr: any): void;
}

type GraphicsDevice$2 = GraphicsDevice$l;
/**
 * Initialize the Basis transcode worker.
 *
 * @param {object} [config] - The Basis configuration.
 * @param {string} [config.glueUrl] - URL of glue script.
 * @param {string} [config.wasmUrl] - URL of the wasm module.
 * @param {string} [config.fallbackUrl] - URL of the fallback script to use when wasm modules
 * aren't supported.
 * @param {boolean} [config.lazyInit] - Wait for first transcode request before initializing Basis
 * (default is false). Otherwise initialize Basis immediately.
 * @param {number} [config.numWorkers] - Number of workers to use for transcoding (default is 1).
 * While it is possible to improve transcode performance using multiple workers, this will likely
 * depend on the runtime platform. For example, desktop will likely benefit from more workers
 * compared to mobile. Also keep in mind that it takes time to initialize workers and increasing
 * this value could impact application startup time. Make sure to test your application performance
 * on all target platforms when changing this parameter.
 * @param {boolean} [config.eagerWorkers] - Use eager workers (default is true). When enabled, jobs
 * are assigned to workers immediately, independent of their work load. This can result in
 * unbalanced workloads, however there is no delay between jobs. If disabled, new jobs are assigned
 * to workers only when their previous job has completed. This will result in balanced workloads
 * across workers, however workers can be idle for a short time between jobs.
 * @param {string[]} [config.rgbPriority] - Array of texture compression formats in priority order
 * for textures without alpha. The supported compressed formats are: 'astc', 'atc', 'dxt', 'etc1',
 * 'etc2', 'pvr'.
 * @param {string[]} [config.rgbaPriority] - Array of texture compression formats in priority order
 * for textures with alpha. The supported compressed formats are: 'astc', 'atc', 'dxt', 'etc1',
 * 'etc2', 'pvr'.
 */
declare function basisInitialize(config?: {
    glueUrl?: string;
    wasmUrl?: string;
    fallbackUrl?: string;
    lazyInit?: boolean;
    numWorkers?: number;
    eagerWorkers?: boolean;
    rgbPriority?: string[];
    rgbaPriority?: string[];
}): void;
/**
 * Enqueue a blob of basis data for transcoding.
 *
 * @param {GraphicsDevice} device - The graphics device.
 * @param {string} url - URL of the basis file.
 * @param {object} data - The file data to transcode.
 * @param {Function} callback - Callback function to receive transcode result.
 * @param {object} [options] - Options structure
 * @param {boolean} [options.isGGGR] - Indicates this is a GGGR swizzled texture. Under some
 * circumstances the texture will be unswizzled during transcoding.
 * @param {boolean} [options.isKTX2] - Indicates the image is KTX2 format. Otherwise
 * basis format is assumed.
 * @returns {boolean} True if the basis worker was initialized and false otherwise.
 * @ignore
 */
declare function basisTranscode(device: GraphicsDevice$2, url: string, data: object, callback: Function, options?: {
    isGGGR?: boolean;
    isKTX2?: boolean;
}): boolean;

declare class GlbParser {
    static parseAsync(filename: any, urlBase: any, data: any, device: any, registry: any, options: any, callback: any): void;
    static parse(filename: any, data: any, device: any, options: any): any;
    constructor(device: any, assets: any, maxRetries: any);
    _device: any;
    _assets: any;
    _defaultMaterial: any;
    _maxRetries: any;
    _getUrlWithoutParams(url: any): any;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, asset: any): any;
    patch(asset: any, assets: any): void;
}

type AssetRegistry$1 = AssetRegistry$c;
type Entity = Entity$a;
type GraphicsDevice$1 = GraphicsDevice$l;
type ResourceHandler$1 = ResourceHandler$h;
/** @typedef {import('../asset/asset-registry.js').AssetRegistry} AssetRegistry */
/** @typedef {import('../framework/entity.js').Entity} Entity */
/** @typedef {import('../graphics/graphics-device.js').GraphicsDevice} GraphicsDevice */
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * @interface
 * @name ContainerResource
 * @description Container for a list of animations, textures, materials, renders and a model.
 */
declare class ContainerResource {
    /**
     * Instantiates an entity with a model component.
     *
     * @param {object} [options] - The initialization data for the model component type
     * {@link ModelComponent}.
     * @returns {Entity} A single entity with a model component. Model component internally
     * contains a hierarchy based on {@link GraphNode}.
     * @example
     * // load a glb file and instantiate an entity with a model component based on it
     * app.assets.loadFromUrl("statue.glb", "container", function (err, asset) {
     *     var entity = asset.resource.instantiateModelEntity({
     *         castShadows: true
     *     });
     *     app.root.addChild(entity);
     * });
     */
    instantiateModelEntity(options?: object): Entity;
    /**
     * Instantiates an entity with a render component.
     *
     * @param {object} [options] - The initialization data for the render component type
     * {@link RenderComponent}.
     * @returns {Entity} A hierarchy of entities with render components on entities containing
     * renderable geometry.
     * @example
     * // load a glb file and instantiate an entity with a render component based on it
     * app.assets.loadFromUrl("statue.glb", "container", function (err, asset) {
     *     var entity = asset.resource.instantiateRenderEntity({
     *         castShadows: true
     *     });
     *     app.root.addChild(entity);
     *
     *     // find all render components containing mesh instances, and change blend mode on their materials
     *     var renders = entity.findComponents("render");
     *     renders.forEach(function (render) {
     *         render.meshInstances.forEach(function (meshInstance) {
     *             meshInstance.material.blendType = pc.BLEND_MULTIPLICATIVE;
     *             meshInstance.material.update();
     *         });
     *     });
     * });
     */
    instantiateRenderEntity(options?: object): Entity;
}
/**
 * Loads files that contain multiple resources. For example glTF files can contain textures, models
 * and animations.
 *
 * For glTF files, the asset options object can be used to pass load time callbacks for handling
 * the various resources at different stages of loading. The table below lists the resource types
 * and the corresponding supported process functions.
 *
 * ```
 * |---------------------------------------------------------------------|
 * |  resource   |  preprocess |   process   |processAsync | postprocess |
 * |-------------+-------------+-------------+-------------+-------------|
 * | global      |      x      |             |             |      x      |
 * | node        |      x      |      x      |             |      x      |
 * | light       |      x      |      x      |             |      x      |
 * | camera      |      x      |      x      |             |      x      |
 * | animation   |      x      |             |             |      x      |
 * | material    |      x      |      x      |             |      x      |
 * | image       |      x      |             |      x      |      x      |
 * | texture     |      x      |             |      x      |      x      |
 * | buffer      |      x      |             |      x      |      x      |
 * | bufferView  |      x      |             |      x      |      x      |
 * |---------------------------------------------------------------------|
 * ```
 *
 * For example, to receive a texture preprocess callback:
 *
 * ```javascript
 * var containerAsset = new pc.Asset(filename, 'container', { url: url, filename: filename }, null, {
 *     texture: {
 *         preprocess(gltfTexture) { console.log("texture preprocess"); }
 *     },
 * });
 * ```
 *
 * @implements {ResourceHandler}
 */
declare class ContainerHandler implements ResourceHandler$1 {
    /**
     * Create a new ContainerResource instance.
     *
     * @param {GraphicsDevice} device - The graphics device that will be rendering.
     * @param {AssetRegistry} assets - The asset registry
     * @param {StandardMaterial} defaultMaterial - The shared default material that is used in any
     * place that a material is not specified.
     */
    constructor(device: GraphicsDevice$1, assets: AssetRegistry$1);
    glbParser: GlbParser;
    parsers: {};
    _getUrlWithoutParams(url: any): any;
    _getParser(url: any): any;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, asset: any): any;
    patch(asset: any, assets: any): void;
}

/**
 * Creates a &lt;style&gt; DOM element from a string that contains CSS.
 *
 * @param {string} cssString - A string that contains valid CSS.
 * @returns {Element} The style DOM element.
 * @example
 * var css = 'body {height: 100;}';
 * var style = pc.createStyle(css);
 * document.head.appendChild(style);
 */
declare function createStyle(cssString: string): Element;
declare class CssHandler {
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
}

type TextureParser$6 = TextureParser;
/** @typedef {import('../../texture.js').TextureParser} TextureParser */
/**
 * Parser for browser-supported image formats.
 *
 * @implements {TextureParser}
 * @ignore
 */
declare class ImgParser implements TextureParser$6 {
    constructor(registry: any);
    crossOrigin: string;
    maxRetries: number;
    useImageBitmap: boolean;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, device: any): Texture$8;
    _loadImage(url: any, originalUrl: any, crossOrigin: any, callback: any): void;
    _loadImageBitmap(url: any, originalUrl: any, crossOrigin: any, callback: any): void;
}

type TextureParser$5 = TextureParser;
/** @typedef {import('../../texture.js').TextureParser} TextureParser */
/**
 * Legacy texture parser for dds files.
 *
 * @implements {TextureParser}
 * @ignore
 */
declare class DdsParser implements TextureParser$5 {
    constructor(registry: any);
    maxRetries: number;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, device: any): Texture$8;
}

type TextureParser$4 = TextureParser;
/**
 * Texture parser for ktx files.
 *
 * @implements {TextureParser}
 * @ignore
 */
declare class KtxParser implements TextureParser$4 {
    constructor(registry: any);
    maxRetries: number;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, device: any): Texture$8;
    parse(data: any): {
        format: any;
        width: number;
        height: number;
        levels: any[][];
        cubemap: boolean;
    };
}

type TextureParser$3 = TextureParser;
/**
 * Texture parser for ktx2 files.
 *
 * @implements {TextureParser}
 * @ignore
 */
declare class Ktx2Parser implements TextureParser$3 {
    constructor(registry: any, device: any);
    maxRetries: number;
    device: any;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, device: any): Texture$8;
    parse(arraybuffer: any, url: any, callback: any, asset: any): any;
}

type TextureParser$2 = TextureParser;
/** @typedef {import('../../texture.js').TextureParser} TextureParser */
/**
 * Parser for basis files.
 *
 * @implements {TextureParser}
 * @ignore
 */
declare class BasisParser implements TextureParser$2 {
    constructor(registry: any, device: any);
    device: any;
    maxRetries: number;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, device: any): Texture$8;
}

type TextureParser$1 = TextureParser;
/** @typedef {import('../../texture.js').TextureParser} TextureParser */
/**
 * Texture parser for hdr files.
 *
 * @implements {TextureParser}
 * @ignore
 */
declare class HdrParser implements TextureParser$1 {
    constructor(registry: any);
    maxRetries: number;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, device: any): Texture$8;
    parse(data: any): {
        width: number;
        height: number;
        levels: Uint8Array[];
    };
    _readPixels(readStream: any, width: any, height: any, flipY: any): Uint8Array;
    _readPixelsFlat(readStream: any, width: any, height: any): Uint8Array;
}

type Asset = Asset$6;
type AssetRegistry = AssetRegistry$c;
type GraphicsDevice = GraphicsDevice$l;
type ResourceHandler = ResourceHandler$h;
type resourceHandlerCallback = resourceHandlerCallback$1;
type ResourceLoader = ResourceLoader$4;
/**
 * Resource handler used for loading 2D and 3D {@link Texture} resources.
 *
 * @implements {ResourceHandler}
 */
declare class TextureHandler implements ResourceHandler {
    /**
     * Create a new TextureHandler instance.
     *
     * @param {GraphicsDevice} device - The graphics device.
     * @param {AssetRegistry} assets - The asset registry.
     * @param {ResourceLoader} loader - The resource loader.
     */
    constructor(device: GraphicsDevice, assets: AssetRegistry, loader: ResourceLoader);
    _device: GraphicsDevice$l;
    _assets: AssetRegistry$c;
    _loader: ResourceLoader$4;
    imgParser: ImgParser;
    parsers: {
        dds: DdsParser;
        ktx: KtxParser;
        ktx2: Ktx2Parser;
        basis: BasisParser;
        hdr: HdrParser;
    };
    set crossOrigin(arg: string);
    get crossOrigin(): string;
    set maxRetries(arg: number);
    get maxRetries(): number;
    _getUrlWithoutParams(url: any): any;
    _getParser(url: any): any;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, asset: any): any;
    patch(asset: any, assets: any): void;
}
/**
 * @interface
 * @name TextureParser
 * @description Interface to a texture parser. Implementations of this interface handle the loading
 * and opening of texture assets.
 */
declare class TextureParser {
    /**
     * @function
     * @name TextureParser#load
     * @description Load the texture from the remote URL. When loaded (or failed),
     * use the callback to return an the raw resource data (or error).
     * @param {object} url - The URL of the resource to load.
     * @param {string} url.load - The URL to use for loading the resource.
     * @param {string} url.original - The original URL useful for identifying the resource type.
     * @param {resourceHandlerCallback} callback - The callback used when the resource is loaded or an error occurs.
     * @param {Asset} [asset] - Optional asset that is passed by ResourceLoader.
     */
    load(url: {
        load: string;
        original: string;
    }, callback: resourceHandlerCallback, asset?: Asset): void;
    /**
     * @function
     * @name TextureParser#open
     * @description Convert raw resource data into a resource instance. E.g. Take 3D model format JSON and return a {@link Model}.
     * @param {string} url - The URL of the resource to open.
     * @param {*} data - The raw resource data passed by callback from {@link ResourceHandler#load}.
     * @param {Asset|null} asset - Optional asset which is passed in by ResourceLoader.
     * @param {GraphicsDevice} device - The graphics device.
     * @returns {Texture} The parsed resource data.
     */
    open(url: string, data: any, device: GraphicsDevice): Texture$8;
}

/**
 * Create and register a new {@link ScriptType}. It returns new class type (constructor function),
 * which is auto-registered to {@link ScriptRegistry} using its name. This is the main interface to
 * create Script Types, to define custom logic using JavaScript, that is used to create interaction
 * for entities.
 *
 * @param {string} name - Unique Name of a Script Type. If a Script Type with the same name has
 * already been registered and the new one has a `swap` method defined in its prototype, then it
 * will perform hot swapping of existing Script Instances on entities using this new Script Type.
 * Note: There is a reserved list of names that cannot be used, such as list below as well as some
 * starting from `_` (underscore): system, entity, create, destroy, swap, move, scripts, onEnable,
 * onDisable, onPostStateChange, has, on, off, fire, once, hasEvent.
 * @param {Application} [app] - Optional application handler, to choose which {@link ScriptRegistry}
 * to add a script to. By default it will use `Application.getApplication()` to get current
 * {@link Application}.
 * @returns {typeof ScriptType|null} A class type (constructor function) that inherits {@link ScriptType},
 * which the developer is meant to further extend by adding attributes and prototype methods.
 * Returns null if there was an error.
 * @example
 * var Turning = pc.createScript('turn');
 *
 * // define `speed` attribute that is available in Editor UI
 * Turning.attributes.add('speed', {
 *     type: 'number',
 *     default: 180,
 *     placeholder: 'deg/s'
 * });
 *
 * // runs every tick
 * Turning.prototype.update = function (dt) {
 *     this.entity.rotate(0, this.speed * dt, 0);
 * };
 */
declare function createScript(name: string, app?: Application$7): typeof ScriptType | null;
declare namespace createScript {
    export { reservedAttributes };
}
/**
 * Register a existing class type as a Script Type to {@link ScriptRegistry}. Useful when defining
 * a ES6 script class that extends {@link ScriptType} (see example).
 *
 * @param {typeof ScriptType} script - The existing class type (constructor function) to be
 * registered as a Script Type. Class must extend {@link ScriptType} (see example). Please note: A
 * class created using {@link createScript} is auto-registered, and should therefore not be pass
 * into {@link registerScript} (which would result in swapping out all related script instances).
 * @param {string} [name] - Optional unique name of the Script Type. By default it will use the
 * same name as the existing class. If a Script Type with the same name has already been registered
 * and the new one has a `swap` method defined in its prototype, then it will perform hot swapping
 * of existing Script Instances on entities using this new Script Type. Note: There is a reserved
 * list of names that cannot be used, such as list below as well as some starting from `_`
 * (underscore): system, entity, create, destroy, swap, move, scripts, onEnable, onDisable,
 * onPostStateChange, has, on, off, fire, once, hasEvent.
 * @param {Application} [app] - Optional application handler, to choose which {@link ScriptRegistry}
 * to register the script type to. By default it will use `Application.getApplication()` to get
 * current {@link Application}.
 * @example
 * // define a ES6 script class
 * class PlayerController extends pc.ScriptType {
 *
 *     initialize() {
 *         // called once on initialize
 *     }
 *
 *     update(dt) {
 *         // called each tick
 *     }
 * }
 *
 * // register the class as a script
 * pc.registerScript(PlayerController);
 *
 * // declare script attributes (Must be after pc.registerScript())
 * PlayerController.attributes.add('attribute1', {type: 'number'});
 */
declare function registerScript(script: typeof ScriptType, name?: string, app?: Application$7): void;

declare const reservedAttributes: {};

export { ABSOLUTE_URL, ACTION_GAMEPAD, ACTION_KEYBOARD, ACTION_MOUSE, ADDRESS_CLAMP_TO_EDGE, ADDRESS_MIRRORED_REPEAT, ADDRESS_REPEAT, ANIM_BLEND_1D, ANIM_BLEND_2D_CARTESIAN, ANIM_BLEND_2D_DIRECTIONAL, ANIM_BLEND_DIRECT, ANIM_CONTROL_STATES, ANIM_EQUAL_TO, ANIM_GREATER_THAN, ANIM_GREATER_THAN_EQUAL_TO, ANIM_INTERRUPTION_NEXT, ANIM_INTERRUPTION_NEXT_PREV, ANIM_INTERRUPTION_NONE, ANIM_INTERRUPTION_PREV, ANIM_INTERRUPTION_PREV_NEXT, ANIM_LAYER_ADDITIVE, ANIM_LAYER_OVERWRITE, ANIM_LESS_THAN, ANIM_LESS_THAN_EQUAL_TO, ANIM_NOT_EQUAL_TO, ANIM_PARAMETER_BOOLEAN, ANIM_PARAMETER_FLOAT, ANIM_PARAMETER_INTEGER, ANIM_PARAMETER_TRIGGER, ANIM_STATE_ANY, ANIM_STATE_END, ANIM_STATE_START, ASPECT_AUTO, ASPECT_MANUAL, ASSET_ANIMATION, ASSET_AUDIO, ASSET_CONTAINER, ASSET_CSS, ASSET_CUBEMAP, ASSET_HTML, ASSET_IMAGE, ASSET_JSON, ASSET_MATERIAL, ASSET_MODEL, ASSET_SCRIPT, ASSET_SHADER, ASSET_TEXT, ASSET_TEXTURE, AXIS_KEY, AXIS_MOUSE_X, AXIS_MOUSE_Y, AXIS_PAD_L_X, AXIS_PAD_L_Y, AXIS_PAD_R_X, AXIS_PAD_R_Y, AnimBinder$1 as AnimBinder, AnimClip$1 as AnimClip, AnimClipHandler, AnimComponent$1 as AnimComponent, AnimComponentLayer, AnimComponentSystem$2 as AnimComponentSystem, AnimController, AnimCurve$1 as AnimCurve, AnimData$1 as AnimData, AnimEvaluator$1 as AnimEvaluator, AnimEvents, AnimSnapshot, AnimStateGraph, AnimStateGraphHandler, AnimTarget$1 as AnimTarget, AnimTrack$2 as AnimTrack, Animation$1 as Animation, AnimationComponent$1 as AnimationComponent, AnimationComponentSystem$2 as AnimationComponentSystem, AnimationHandler, Application$7 as Application, Asset$6 as Asset, AssetListLoader, AssetReference, AssetRegistry$c as AssetRegistry, AudioHandler, AudioListenerComponent$1 as AudioListenerComponent, AudioListenerComponentSystem$2 as AudioListenerComponentSystem, AudioSourceComponent, AudioSourceComponentSystem$1 as AudioSourceComponentSystem, BAKE_COLOR, BAKE_COLORDIR, BLENDEQUATION_ADD, BLENDEQUATION_MAX, BLENDEQUATION_MIN, BLENDEQUATION_REVERSE_SUBTRACT, BLENDEQUATION_SUBTRACT, BLENDMODE_DST_ALPHA, BLENDMODE_DST_COLOR, BLENDMODE_ONE, BLENDMODE_ONE_MINUS_DST_ALPHA, BLENDMODE_ONE_MINUS_DST_COLOR, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_COLOR, BLENDMODE_SRC_ALPHA, BLENDMODE_SRC_ALPHA_SATURATE, BLENDMODE_SRC_COLOR, BLENDMODE_ZERO, BLEND_ADDITIVE, BLEND_ADDITIVEALPHA, BLEND_MAX, BLEND_MIN, BLEND_MULTIPLICATIVE, BLEND_MULTIPLICATIVE2X, BLEND_NONE, BLEND_NORMAL, BLEND_PREMULTIPLIED, BLEND_SCREEN, BLEND_SUBTRACTIVE, BLUR_BOX, BLUR_GAUSSIAN, BODYFLAG_KINEMATIC_OBJECT, BODYFLAG_NORESPONSE_OBJECT, BODYFLAG_STATIC_OBJECT, BODYGROUP_DEFAULT, BODYGROUP_DYNAMIC, BODYGROUP_ENGINE_1, BODYGROUP_ENGINE_2, BODYGROUP_ENGINE_3, BODYGROUP_KINEMATIC, BODYGROUP_NONE, BODYGROUP_STATIC, BODYGROUP_TRIGGER, BODYGROUP_USER_1, BODYGROUP_USER_2, BODYGROUP_USER_3, BODYGROUP_USER_4, BODYGROUP_USER_5, BODYGROUP_USER_6, BODYGROUP_USER_7, BODYGROUP_USER_8, BODYMASK_ALL, BODYMASK_NONE, BODYMASK_NOT_STATIC, BODYMASK_NOT_STATIC_KINEMATIC, BODYMASK_STATIC, BODYSTATE_ACTIVE_TAG, BODYSTATE_DISABLE_DEACTIVATION, BODYSTATE_DISABLE_SIMULATION, BODYSTATE_ISLAND_SLEEPING, BODYSTATE_WANTS_DEACTIVATION, BODYTYPE_DYNAMIC, BODYTYPE_KINEMATIC, BODYTYPE_STATIC, BUFFER_DYNAMIC, BUFFER_GPUDYNAMIC, BUFFER_STATIC, BUFFER_STREAM, BUTTON_TRANSITION_MODE_SPRITE_CHANGE, BUTTON_TRANSITION_MODE_TINT, BasicMaterial, Batch, BatchGroup, BatchManager, BinaryHandler, BoundingBox$1 as BoundingBox, BoundingSphere$2 as BoundingSphere, Bundle, BundleHandler, BundleRegistry, ButtonComponent$1 as ButtonComponent, ButtonComponentSystem$2 as ButtonComponentSystem, CLEARFLAG_COLOR, CLEARFLAG_DEPTH, CLEARFLAG_STENCIL, COMPUPDATED_BLEND, COMPUPDATED_CAMERAS, COMPUPDATED_INSTANCES, COMPUPDATED_LIGHTS, CUBEFACE_NEGX, CUBEFACE_NEGY, CUBEFACE_NEGZ, CUBEFACE_POSX, CUBEFACE_POSY, CUBEFACE_POSZ, CUBEPROJ_BOX, CUBEPROJ_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK, CULLFACE_NONE, CURVE_CARDINAL, CURVE_CATMULL, CURVE_LINEAR, CURVE_SMOOTHSTEP, CURVE_SPLINE, CURVE_STEP, Camera, CameraComponent$2 as CameraComponent, CameraComponentSystem$1 as CameraComponentSystem, CanvasFont$1 as CanvasFont, CollisionComponent$1 as CollisionComponent, CollisionComponentSystem$2 as CollisionComponentSystem, Color$4 as Color, Command, Component$2 as Component, ComponentSystem, ComponentSystemRegistry, ContactPoint, ContactResult, ContainerHandler, ContainerResource, ContextCreationError, Controller, CssHandler, CubemapHandler, Curve, CurveSet, DETAILMODE_ADD, DETAILMODE_MAX, DETAILMODE_MIN, DETAILMODE_MUL, DETAILMODE_OVERLAY, DETAILMODE_SCREEN, DISTANCE_EXPONENTIAL, DISTANCE_INVERSE, DISTANCE_LINEAR, DefaultAnimBinder, DepthMaterial, ELEMENTTYPE_FLOAT32, ELEMENTTYPE_GROUP, ELEMENTTYPE_IMAGE, ELEMENTTYPE_INT16, ELEMENTTYPE_INT32, ELEMENTTYPE_INT8, ELEMENTTYPE_TEXT, ELEMENTTYPE_UINT16, ELEMENTTYPE_UINT32, ELEMENTTYPE_UINT8, EMITTERSHAPE_BOX, EMITTERSHAPE_SPHERE, EVENT_KEYDOWN, EVENT_KEYUP, EVENT_MOUSEDOWN, EVENT_MOUSEMOVE, EVENT_MOUSEUP, EVENT_MOUSEWHEEL, EVENT_SELECT, EVENT_SELECTEND, EVENT_SELECTSTART, EVENT_TOUCHCANCEL, EVENT_TOUCHEND, EVENT_TOUCHMOVE, EVENT_TOUCHSTART, ElementComponent$2 as ElementComponent, ElementComponentSystem$2 as ElementComponentSystem, ElementDragHelper, ElementInput$1 as ElementInput, ElementInputEvent, ElementMouseEvent, ElementSelectEvent, ElementTouchEvent, Entity$a as Entity, EntityReference, EnvLighting, EventHandler$1 as EventHandler, FILLMODE_FILL_WINDOW, FILLMODE_KEEP_ASPECT, FILLMODE_NONE, FILTER_LINEAR, FILTER_LINEAR_MIPMAP_LINEAR, FILTER_LINEAR_MIPMAP_NEAREST, FILTER_NEAREST, FILTER_NEAREST_MIPMAP_LINEAR, FILTER_NEAREST_MIPMAP_NEAREST, FITTING_BOTH, FITTING_NONE, FITTING_SHRINK, FITTING_STRETCH, FOG_EXP, FOG_EXP2, FOG_LINEAR, FOG_NONE, FONT_BITMAP, FONT_MSDF, FRESNEL_NONE, FRESNEL_SCHLICK, FUNC_ALWAYS, FUNC_EQUAL, FUNC_GREATER, FUNC_GREATEREQUAL, FUNC_LESS, FUNC_LESSEQUAL, FUNC_NEVER, FUNC_NOTEQUAL, FolderHandler, Font$1 as Font, FontHandler, ForwardRenderer$1 as ForwardRenderer, Frustum, GAMMA_NONE, GAMMA_SRGB, GAMMA_SRGBFAST, GAMMA_SRGBHDR, GamePads$2 as GamePads, GraphNode$3 as GraphNode, GraphicsDevice$l as GraphicsDevice, HierarchyHandler, HtmlHandler, Http, I18n, INDEXFORMAT_UINT16, INDEXFORMAT_UINT32, INDEXFORMAT_UINT8, INTERPOLATION_CUBIC, INTERPOLATION_LINEAR, INTERPOLATION_STEP, ImageElement, IndexBuffer$1 as IndexBuffer, IndexedList, JointComponent, JointComponentSystem$1 as JointComponentSystem, JsonHandler, JsonStandardMaterialParser, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_A, KEY_ADD, KEY_ALT, KEY_B, KEY_BACKSPACE, KEY_BACK_SLASH, KEY_C, KEY_CAPS_LOCK, KEY_CLOSE_BRACKET, KEY_COMMA, KEY_CONTEXT_MENU, KEY_CONTROL, KEY_D, KEY_DECIMAL, KEY_DELETE, KEY_DIVIDE, KEY_DOWN, KEY_E, KEY_END, KEY_ENTER, KEY_EQUAL, KEY_ESCAPE, KEY_F, KEY_F1, KEY_F10, KEY_F11, KEY_F12, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_G, KEY_H, KEY_HOME, KEY_I, KEY_INSERT, KEY_J, KEY_K, KEY_L, KEY_LEFT, KEY_M, KEY_META, KEY_MULTIPLY, KEY_N, KEY_NUMPAD_0, KEY_NUMPAD_1, KEY_NUMPAD_2, KEY_NUMPAD_3, KEY_NUMPAD_4, KEY_NUMPAD_5, KEY_NUMPAD_6, KEY_NUMPAD_7, KEY_NUMPAD_8, KEY_NUMPAD_9, KEY_O, KEY_OPEN_BRACKET, KEY_P, KEY_PAGE_DOWN, KEY_PAGE_UP, KEY_PAUSE, KEY_PERIOD, KEY_PRINT_SCREEN, KEY_Q, KEY_R, KEY_RETURN, KEY_RIGHT, KEY_S, KEY_SEMICOLON, KEY_SEPARATOR, KEY_SHIFT, KEY_SLASH, KEY_SPACE, KEY_SUBTRACT, KEY_T, KEY_TAB, KEY_U, KEY_UP, KEY_V, KEY_W, KEY_WINDOWS, KEY_X, KEY_Y, KEY_Z, Key, Keyboard$2 as Keyboard, KeyboardEvent, LAYERID_DEPTH, LAYERID_IMMEDIATE, LAYERID_SKYBOX, LAYERID_UI, LAYERID_WORLD, LAYER_FX, LAYER_GIZMO, LAYER_HUD, LAYER_WORLD, LIGHTFALLOFF_INVERSESQUARED, LIGHTFALLOFF_LINEAR, LIGHTSHAPE_DISK, LIGHTSHAPE_PUNCTUAL, LIGHTSHAPE_RECT, LIGHTSHAPE_SPHERE, LIGHTTYPE_DIRECTIONAL, LIGHTTYPE_OMNI, LIGHTTYPE_POINT, LIGHTTYPE_SPOT, LINEBATCH_GIZMO, LINEBATCH_OVERLAY, LINEBATCH_WORLD, Layer$1 as Layer, LayerComposition, LayoutCalculator, LayoutChildComponent$1 as LayoutChildComponent, LayoutChildComponentSystem$2 as LayoutChildComponentSystem, LayoutGroupComponent$1 as LayoutGroupComponent, LayoutGroupComponentSystem$2 as LayoutGroupComponentSystem, Light, LightComponent$2 as LightComponent, LightComponentSystem$2 as LightComponentSystem, LightingParams, Lightmapper, LocalizedAsset, MASK_AFFECT_DYNAMIC, MASK_AFFECT_LIGHTMAPPED, MASK_BAKE, MOTION_FREE, MOTION_LIMITED, MOTION_LOCKED, MOUSEBUTTON_LEFT, MOUSEBUTTON_MIDDLE, MOUSEBUTTON_NONE, MOUSEBUTTON_RIGHT, Mat3, Mat4$5 as Mat4, Material$2 as Material, MaterialHandler, Mesh$1 as Mesh, MeshInstance$3 as MeshInstance, Model, ModelComponent$1 as ModelComponent, ModelComponentSystem$2 as ModelComponentSystem, ModelHandler, Morph, MorphInstance, MorphTarget$1 as MorphTarget, Mouse$2 as Mouse, MouseEvent$1 as MouseEvent, Node$1 as Node, ORIENTATION_HORIZONTAL, ORIENTATION_VERTICAL, OrientedBox, PAD_1, PAD_2, PAD_3, PAD_4, PAD_DOWN, PAD_FACE_1, PAD_FACE_2, PAD_FACE_3, PAD_FACE_4, PAD_LEFT, PAD_L_SHOULDER_1, PAD_L_SHOULDER_2, PAD_L_STICK_BUTTON, PAD_L_STICK_X, PAD_L_STICK_Y, PAD_RIGHT, PAD_R_SHOULDER_1, PAD_R_SHOULDER_2, PAD_R_STICK_BUTTON, PAD_R_STICK_X, PAD_R_STICK_Y, PAD_SELECT, PAD_START, PAD_UP, PAD_VENDOR, PARTICLEMODE_CPU, PARTICLEMODE_GPU, PARTICLEORIENTATION_EMITTER, PARTICLEORIENTATION_SCREEN, PARTICLEORIENTATION_WORLD, PARTICLESORT_DISTANCE, PARTICLESORT_NEWER_FIRST, PARTICLESORT_NONE, PARTICLESORT_OLDER_FIRST, PIXELFORMAT_111110F, PIXELFORMAT_A8, PIXELFORMAT_ASTC_4x4, PIXELFORMAT_ATC_RGB, PIXELFORMAT_ATC_RGBA, PIXELFORMAT_DEPTH, PIXELFORMAT_DEPTHSTENCIL, PIXELFORMAT_DXT1, PIXELFORMAT_DXT3, PIXELFORMAT_DXT5, PIXELFORMAT_ETC1, PIXELFORMAT_ETC2_RGB, PIXELFORMAT_ETC2_RGBA, PIXELFORMAT_L8, PIXELFORMAT_L8_A8, PIXELFORMAT_PVRTC_2BPP_RGBA_1, PIXELFORMAT_PVRTC_2BPP_RGB_1, PIXELFORMAT_PVRTC_4BPP_RGBA_1, PIXELFORMAT_PVRTC_4BPP_RGB_1, PIXELFORMAT_R32F, PIXELFORMAT_R4_G4_B4_A4, PIXELFORMAT_R5_G5_B5_A1, PIXELFORMAT_R5_G6_B5, PIXELFORMAT_R8_G8_B8, PIXELFORMAT_R8_G8_B8_A8, PIXELFORMAT_RGB16F, PIXELFORMAT_RGB32F, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_SRGB, PIXELFORMAT_SRGBA, PRIMITIVE_LINELOOP, PRIMITIVE_LINES, PRIMITIVE_LINESTRIP, PRIMITIVE_POINTS, PRIMITIVE_TRIANGLES, PRIMITIVE_TRIFAN, PRIMITIVE_TRISTRIP, PROJECTION_ORTHOGRAPHIC, PROJECTION_PERSPECTIVE, ParticleEmitter, ParticleSystemComponent$1 as ParticleSystemComponent, ParticleSystemComponentSystem$2 as ParticleSystemComponentSystem, PhongMaterial, Picker, Plane, PostEffect$1 as PostEffect, PostEffectQueue, ProgramLibrary, Quat$1 as Quat, RENDERSTYLE_POINTS, RENDERSTYLE_SOLID, RENDERSTYLE_WIREFRAME, RESOLUTION_AUTO, RESOLUTION_FIXED, RIGIDBODY_ACTIVE_TAG, RIGIDBODY_CF_KINEMATIC_OBJECT, RIGIDBODY_CF_NORESPONSE_OBJECT, RIGIDBODY_CF_STATIC_OBJECT, RIGIDBODY_DISABLE_DEACTIVATION, RIGIDBODY_DISABLE_SIMULATION, RIGIDBODY_ISLAND_SLEEPING, RIGIDBODY_TYPE_DYNAMIC, RIGIDBODY_TYPE_KINEMATIC, RIGIDBODY_TYPE_STATIC, RIGIDBODY_WANTS_DEACTIVATION, Ray$4 as Ray, RaycastResult, ReadStream, RenderComponent$1 as RenderComponent, RenderComponentSystem$2 as RenderComponentSystem, RenderHandler, RenderTarget$3 as RenderTarget, ResourceHandler$h as ResourceHandler, ResourceLoader$4 as ResourceLoader, RigidBodyComponent$1 as RigidBodyComponent, RigidBodyComponentSystem$2 as RigidBodyComponentSystem, SCALEMODE_BLEND, SCALEMODE_NONE, SCROLLBAR_VISIBILITY_SHOW_ALWAYS, SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED, SCROLL_MODE_BOUNCE, SCROLL_MODE_CLAMP, SCROLL_MODE_INFINITE, SEMANTIC_ATTR, SEMANTIC_ATTR0, SEMANTIC_ATTR1, SEMANTIC_ATTR10, SEMANTIC_ATTR11, SEMANTIC_ATTR12, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15, SEMANTIC_ATTR2, SEMANTIC_ATTR3, SEMANTIC_ATTR4, SEMANTIC_ATTR5, SEMANTIC_ATTR6, SEMANTIC_ATTR7, SEMANTIC_ATTR8, SEMANTIC_ATTR9, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_COLOR, SEMANTIC_NORMAL, SEMANTIC_POSITION, SEMANTIC_TANGENT, SEMANTIC_TEXCOORD, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_TEXCOORD2, SEMANTIC_TEXCOORD3, SEMANTIC_TEXCOORD4, SEMANTIC_TEXCOORD5, SEMANTIC_TEXCOORD6, SEMANTIC_TEXCOORD7, SHADERDEF_DIRLM, SHADERDEF_INSTANCING, SHADERDEF_LM, SHADERDEF_LMAMBIENT, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_TEXTURE_BASED, SHADERDEF_NOSHADOW, SHADERDEF_SCREENSPACE, SHADERDEF_SKIN, SHADERDEF_TANGENTS, SHADERDEF_UV0, SHADERDEF_UV1, SHADERDEF_VCOLOR, SHADERTAG_MATERIAL, SHADER_DEPTH, SHADER_FORWARD, SHADER_FORWARDHDR, SHADER_PICK, SHADER_SHADOW, SHADOWUPDATE_NONE, SHADOWUPDATE_REALTIME, SHADOWUPDATE_THISFRAME, SHADOW_COUNT, SHADOW_DEPTH, SHADOW_PCF1, SHADOW_PCF3, SHADOW_PCF5, SHADOW_VSM16, SHADOW_VSM32, SHADOW_VSM8, SORTKEY_DEPTH, SORTKEY_FORWARD, SORTMODE_BACK2FRONT, SORTMODE_CUSTOM, SORTMODE_FRONT2BACK, SORTMODE_MANUAL, SORTMODE_MATERIALMESH, SORTMODE_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT, SPECOCC_NONE, SPECULAR_BLINN, SPECULAR_PHONG, SPRITETYPE_ANIMATED, SPRITETYPE_SIMPLE, SPRITE_RENDERMODE_SIMPLE, SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED, STENCILOP_DECREMENT, STENCILOP_DECREMENTWRAP, STENCILOP_INCREMENT, STENCILOP_INCREMENTWRAP, STENCILOP_INVERT, STENCILOP_KEEP, STENCILOP_REPLACE, STENCILOP_ZERO, Scene$3 as Scene, SceneHandler, SceneRegistry, SceneRegistryItem, SceneSettingsHandler, ScopeId$1 as ScopeId, ScopeSpace, ScreenComponent$1 as ScreenComponent, ScreenComponentSystem$2 as ScreenComponentSystem, ScriptAttributes, ScriptComponent$1 as ScriptComponent, ScriptComponentSystem$2 as ScriptComponentSystem, ScriptHandler, ScriptLegacyComponent, ScriptLegacyComponentSystem, ScriptRegistry, ScriptType, ScrollViewComponent$1 as ScrollViewComponent, ScrollViewComponentSystem$2 as ScrollViewComponentSystem, ScrollbarComponent$1 as ScrollbarComponent, ScrollbarComponentSystem$2 as ScrollbarComponentSystem, Shader$4 as Shader, ShaderHandler, SingleContactResult, Skeleton, Skin$2 as Skin, SkinBatchInstance, SkinInstance, SortedLoopArray, Sound$3 as Sound, SoundComponent$1 as SoundComponent, SoundComponentSystem$2 as SoundComponentSystem, SoundInstance$1 as SoundInstance, SoundInstance3d, SoundManager$7 as SoundManager, SoundSlot, Sprite$1 as Sprite, SpriteAnimationClip, SpriteComponent$1 as SpriteComponent, SpriteComponentSystem$2 as SpriteComponentSystem, SpriteHandler, StandardMaterial, StencilParameters, TEXHINT_ASSET, TEXHINT_LIGHTMAP, TEXHINT_NONE, TEXHINT_SHADOWMAP, TEXTURELOCK_READ, TEXTURELOCK_WRITE, TEXTUREPROJECTION_CUBE, TEXTUREPROJECTION_EQUIRECT, TEXTUREPROJECTION_NONE, TEXTUREPROJECTION_OCTAHEDRAL, TEXTURETYPE_DEFAULT, TEXTURETYPE_RGBE, TEXTURETYPE_RGBM, TEXTURETYPE_SWIZZLEGGGR, TONEMAP_ACES, TONEMAP_ACES2, TONEMAP_FILMIC, TONEMAP_HEJL, TONEMAP_LINEAR, TYPE_FLOAT32, TYPE_INT16, TYPE_INT32, TYPE_INT8, TYPE_UINT16, TYPE_UINT32, TYPE_UINT8, Tags, Template, TemplateHandler, TextElement, TextHandler, Texture$8 as Texture, TextureAtlas$1 as TextureAtlas, TextureAtlasHandler, TextureHandler, TextureParser, Timer, Touch$1 as Touch, TouchDevice$2 as TouchDevice, TouchEvent$1 as TouchEvent, TransformFeedback, UNIFORMTYPE_BOOL, UNIFORMTYPE_BVEC2, UNIFORMTYPE_BVEC3, UNIFORMTYPE_BVEC4, UNIFORMTYPE_FLOAT, UNIFORMTYPE_FLOATARRAY, UNIFORMTYPE_INT, UNIFORMTYPE_IVEC2, UNIFORMTYPE_IVEC3, UNIFORMTYPE_IVEC4, UNIFORMTYPE_MAT2, UNIFORMTYPE_MAT3, UNIFORMTYPE_MAT4, UNIFORMTYPE_TEXTURE2D, UNIFORMTYPE_TEXTURE2D_SHADOW, UNIFORMTYPE_TEXTURE3D, UNIFORMTYPE_TEXTURECUBE, UNIFORMTYPE_TEXTURECUBE_SHADOW, UNIFORMTYPE_VEC2, UNIFORMTYPE_VEC2ARRAY, UNIFORMTYPE_VEC3, UNIFORMTYPE_VEC3ARRAY, UNIFORMTYPE_VEC4, UNIFORMTYPE_VEC4ARRAY, URI, UnsupportedBrowserError, VIEW_CENTER, VIEW_LEFT, VIEW_RIGHT, Vec2$3 as Vec2, Vec3$1 as Vec3, Vec4$6 as Vec4, VertexBuffer$3 as VertexBuffer, VertexFormat$2 as VertexFormat, VertexIterator, VrDisplay, VrManager, WorldClusters, XRDEPTHSENSINGFORMAT_F32, XRDEPTHSENSINGFORMAT_L8A8, XRDEPTHSENSINGUSAGE_CPU, XRDEPTHSENSINGUSAGE_GPU, XRHAND_LEFT, XRHAND_NONE, XRHAND_RIGHT, XRSPACE_BOUNDEDFLOOR, XRSPACE_LOCAL, XRSPACE_LOCALFLOOR, XRSPACE_UNBOUNDED, XRSPACE_VIEWER, XRTARGETRAY_GAZE, XRTARGETRAY_POINTER, XRTARGETRAY_SCREEN, XRTRACKABLE_MESH, XRTRACKABLE_PLANE, XRTRACKABLE_POINT, XRTYPE_AR, XRTYPE_INLINE, XRTYPE_VR, XrDepthSensing, XrDomOverlay, XrHitTest, XrHitTestSource, XrImageTracking, XrInput, XrInputSource$1 as XrInputSource, XrLightEstimation, XrManager$1 as XrManager, XrPlane, XrPlaneDetection, XrTrackedImage, ZoneComponent, ZoneComponentSystem$1 as ZoneComponentSystem, anim, app, apps, asset, audio, basisInitialize, basisSetDownloadConfig, basisTranscode, calculateNormals, calculateTangents, common, config, createBox, createCapsule, createCone, createCylinder, createMesh, createPlane, createScript, createSphere, createStyle, createTorus, createURI, data, drawFullscreenQuad, drawQuadWithShader, drawTexture, events, extend, fw, getTouchTargetCoords, gfx, guid, http, inherits, input, isDefined, log, makeArray, math, now, path, platform, posteffect, prefilterCubemap, programlib, registerScript, reprojectTexture, revision, scene, script, semanticToLocation, shFromCubemap, shaderChunks, shadowTypeToString, shape, string, time, type, typedArrayIndexFormats, typedArrayIndexFormatsByteSize, typedArrayToType, typedArrayTypes, typedArrayTypesByteSize, version };
export as namespace pc;
