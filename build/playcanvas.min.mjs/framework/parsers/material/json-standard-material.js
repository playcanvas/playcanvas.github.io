import{extends as e}from"../../../_virtual/_rollupPluginBabelHelpers.js";import{Color as t}from"../../../core/math/color.js";import{Vec2 as r}from"../../../core/math/vec2.js";import{Vec3 as a}from"../../../core/math/vec3.js";import{Texture as o}from"../../../platform/graphics/texture.js";import{BoundingBox as s}from"../../../core/shape/bounding-box.js";import{SPECULAR_BLINN as i,SPECULAR_PHONG as l}from"../../../scene/constants.js";import{StandardMaterial as n}from"../../../scene/materials/standard-material.js";import{StandardMaterialValidator as p}from"../../../scene/materials/standard-material-validator.js";import{standardMaterialParameterTypes as m}from"../../../scene/materials/standard-material-parameters.js";class c{constructor(){this._validator=null}parse(e){const t=this.migrate(e),r=this._validate(t),a=new n;return this.initialize(a,r),a}initialize(i,l){l.validated||(l=this._validate(l)),l.chunks&&(i.chunks=e({},l.chunks));for(const e in l){const n=m[e],p=l[e];if("vec2"===n)i[e]=new r(p[0],p[1]);else if("rgb"===n)i[e]=new t(p[0],p[1],p[2]);else if("texture"===n)p instanceof o?i[e]=p:i[e]instanceof o&&"number"==typeof p&&p>0||(i[e]=null);else if("cubemap"===n)p instanceof o?i[e]=p:i[e]instanceof o&&"number"==typeof p&&p>0||(i[e]=null),"cubeMap"!==e||p||(i.prefilteredCubemaps=null);else if("boundingbox"===n){const t=new a(p.center[0],p.center[1],p.center[2]),r=new a(p.halfExtents[0],p.halfExtents[1],p.halfExtents[2]);i[e]=new s(t,r)}else i[e]=l[e]}i.update()}migrate(e){let t;void 0===e.shadingModel&&("blinn"===e.shader?e.shadingModel=i:e.shadingModel=l),e.shader&&delete e.shader,e.mapping_format&&(e.mappingFormat=e.mapping_format,delete e.mapping_format);const r=[["bumpMapFactor","bumpiness"],["aoUvSet","aoMapUv"],["aoMapVertexColor","aoVertexColor"],["diffuseMapVertexColor","diffuseVertexColor"],["emissiveMapVertexColor","emissiveVertexColor"],["specularMapVertexColor","specularVertexColor"],["metalnessMapVertexColor","metalnessVertexColor"],["opacityMapVertexColor","opacityVertexColor"],["glossMapVertexColor","glossVertexColor"],["lightMapVertexColor","lightVertexColor"],["diffuseMapTint","diffuseTint"],["specularMapTint","specularTint"],["emissiveMapTint","emissiveTint"],["metalnessMapTint","metalnessTint"],["clearCoatGlossiness","clearCoatGloss"]];for(t=0;t<r.length;t++){const a=r[t][0],o=r[t][1];void 0!==e[a]&&(void 0===e[o]&&(e[o]=e[a]),delete e[a])}const a=["fresnelFactor","shadowSampleType"];for(t=0;t<a.length;t++){const r=a[t];e.hasOwnProperty(r)&&delete e[r]}return e}_validate(e){return e.validated||(this._validator||(this._validator=new p),this._validator.validate(e)),e}}export{c as JsonStandardMaterialParser};
