import"../tracing.js";import{Vec3 as t}from"../math/vec3.js";const s=new t,e=new t,n=new t,a=new t,i=new t;class h{constructor(s=new t,e=new t(.5,.5,.5)){this.center=void 0,this.halfExtents=void 0,this._min=new t,this._max=new t,this.center=s,this.halfExtents=e}add(t){const s=this.center,e=s.x,n=s.y,a=s.z,i=this.halfExtents,h=i.x,x=i.y,r=i.z;let c=e-h,M=e+h,y=n-x,o=n+x,z=a-r,l=a+r;const u=t.center,m=u.x,b=u.y,E=u.z,f=t.halfExtents,d=f.x,A=f.y,g=f.z,_=m-d,p=m+d,L=b-A,N=b+A,U=E-g,V=E+g;_<c&&(c=_),p>M&&(M=p),L<y&&(y=L),N>o&&(o=N),U<z&&(z=U),V>l&&(l=V),s.x=.5*(c+M),s.y=.5*(y+o),s.z=.5*(z+l),i.x=.5*(M-c),i.y=.5*(o-y),i.z=.5*(l-z)}copy(t){this.center.copy(t.center),this.halfExtents.copy(t.halfExtents)}clone(){return new h(this.center.clone(),this.halfExtents.clone())}intersects(t){const s=this.getMax(),e=this.getMin(),n=t.getMax(),a=t.getMin();return e.x<=n.x&&s.x>=a.x&&e.y<=n.y&&s.y>=a.y&&e.z<=n.z&&s.z>=a.z}_intersectsRay(t,i){const h=s.copy(this.getMin()).sub(t.origin),x=e.copy(this.getMax()).sub(t.origin),r=t.direction;0===r.x?(h.x=h.x<0?-Number.MAX_VALUE:Number.MAX_VALUE,x.x=x.x<0?-Number.MAX_VALUE:Number.MAX_VALUE):(h.x/=r.x,x.x/=r.x),0===r.y?(h.y=h.y<0?-Number.MAX_VALUE:Number.MAX_VALUE,x.y=x.y<0?-Number.MAX_VALUE:Number.MAX_VALUE):(h.y/=r.y,x.y/=r.y),0===r.z?(h.z=h.z<0?-Number.MAX_VALUE:Number.MAX_VALUE,x.z=x.z<0?-Number.MAX_VALUE:Number.MAX_VALUE):(h.z/=r.z,x.z/=r.z);const c=n.set(Math.min(h.x,x.x),Math.min(h.y,x.y),Math.min(h.z,x.z)),M=a.set(Math.max(h.x,x.x),Math.max(h.y,x.y),Math.max(h.z,x.z)),y=Math.min(Math.min(M.x,M.y),M.z),o=Math.max(Math.max(c.x,c.y),c.z),z=y>=o&&o>=0;return z&&i.copy(t.direction).mulScalar(o).add(t.origin),z}_fastIntersectsRay(t){const h=s,x=e,r=n,c=a,M=i,y=t.direction;return h.sub2(t.origin,this.center),c.set(Math.abs(h.x),Math.abs(h.y),Math.abs(h.z)),r.mul2(h,y),!(c.x>this.halfExtents.x&&r.x>=0)&&(!(c.y>this.halfExtents.y&&r.y>=0)&&(!(c.z>this.halfExtents.z&&r.z>=0)&&(M.set(Math.abs(y.x),Math.abs(y.y),Math.abs(y.z)),x.cross(y,h),x.set(Math.abs(x.x),Math.abs(x.y),Math.abs(x.z)),!(x.x>this.halfExtents.y*M.z+this.halfExtents.z*M.y)&&(!(x.y>this.halfExtents.x*M.z+this.halfExtents.z*M.x)&&!(x.z>this.halfExtents.x*M.y+this.halfExtents.y*M.x)))))}intersectsRay(t,s){return s?this._intersectsRay(t,s):this._fastIntersectsRay(t)}setMinMax(t,s){this.center.add2(s,t).mulScalar(.5),this.halfExtents.sub2(s,t).mulScalar(.5)}getMin(){return this._min.copy(this.center).sub(this.halfExtents)}getMax(){return this._max.copy(this.center).add(this.halfExtents)}containsPoint(t){const s=this.getMin(),e=this.getMax();return!(t.x<s.x||t.x>e.x||t.y<s.y||t.y>e.y||t.z<s.z||t.z>e.z)}setFromTransformedAabb(t,s,e=!1){const n=t.center,a=t.halfExtents,i=s.data;let h=i[0],x=i[4],r=i[8],c=i[1],M=i[5],y=i[9],o=i[2],z=i[6],l=i[10];if(e){let t=h*h+x*x+r*r;if(t>0){const s=1/Math.sqrt(t);h*=s,x*=s,r*=s}if(t=c*c+M*M+y*y,t>0){const s=1/Math.sqrt(t);c*=s,M*=s,y*=s}if(t=o*o+z*z+l*l,t>0){const s=1/Math.sqrt(t);o*=s,z*=s,l*=s}}this.center.set(i[12]+h*n.x+x*n.y+r*n.z,i[13]+c*n.x+M*n.y+y*n.z,i[14]+o*n.x+z*n.y+l*n.z),this.halfExtents.set(Math.abs(h)*a.x+Math.abs(x)*a.y+Math.abs(r)*a.z,Math.abs(c)*a.x+Math.abs(M)*a.y+Math.abs(y)*a.z,Math.abs(o)*a.x+Math.abs(z)*a.y+Math.abs(l)*a.z)}static computeMinMax(t,s,e,n=t.length/3){if(n>0){s.set(t[0],t[1],t[2]),e.set(t[0],t[1],t[2]);for(let a=1;a<n;a++){const n=t[3*a+0],i=t[3*a+1],h=t[3*a+2];n<s.x&&(s.x=n),i<s.y&&(s.y=i),h<s.z&&(s.z=h),n>e.x&&(e.x=n),i>e.y&&(e.y=i),h>e.z&&(e.z=h)}}}compute(t,n){h.computeMinMax(t,s,e,n),this.setMinMax(s,e)}intersectsBoundingSphere(t){return this._distanceToBoundingSphereSq(t)<=t.radius*t.radius}_distanceToBoundingSphereSq(t){const s=this.getMin(),e=this.getMax();let n=0;const a=["x","y","z"];for(let i=0;i<3;++i){let h=0;const x=t.center[a[i]],r=s[a[i]],c=e[a[i]];let M=0;x<r&&(M=r-x,h+=M*M),x>c&&(M=x-c,h+=M*M),n+=h}return n}_expand(t,n){s.add2(this.getMin(),t),e.add2(this.getMax(),n),this.setMinMax(s,e)}}export{h as BoundingBox};
