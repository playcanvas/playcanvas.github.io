import"../../core/tracing.js";import{math as t}from"../../core/math/math.js";import{UNIFORMTYPE_MAT4 as e,UNIFORMTYPE_MAT4ARRAY as s,UNIFORMTYPE_VEC4 as i,UNIFORMTYPE_VEC4ARRAY as o,UNIFORMTYPE_VEC3 as a,UNIFORMTYPE_VEC3ARRAY as h,UNIFORMTYPE_VEC2 as c,UNIFORMTYPE_VEC2ARRAY as r,UNIFORMTYPE_FLOAT as n,UNIFORMTYPE_FLOATARRAY as p,bindGroupNames as u,uniformTypeToName as d,UNIFORMTYPE_INT as m,UNIFORMTYPE_IVEC2 as f,UNIFORMTYPE_IVEC3 as y,UNIFORMTYPE_IVEC4 as l,UNIFORMTYPE_BOOL as b,UNIFORMTYPE_BVEC2 as S,UNIFORMTYPE_BVEC3 as z,UNIFORMTYPE_BVEC4 as $,UNIFORMTYPE_MAT2 as v,UNIFORMTYPE_MAT3 as g}from"./constants.js";const T=[];T[n]=1,T[c]=2,T[a]=3,T[i]=4,T[m]=1,T[f]=2,T[y]=3,T[l]=4,T[b]=1,T[S]=2,T[z]=3,T[$]=4,T[v]=8,T[g]=12,T[e]=16;class k{constructor(u,d,m=0){if(this.name=void 0,this.type=void 0,this.byteSize=void 0,this.offset=void 0,this.scopeId=void 0,this.count=void 0,this.shortName=u,this.name=m?`${u}[0]`:u,this.type=d,this.updateType=d,m)switch(d){case n:this.updateType=p;break;case c:this.updateType=r;break;case a:this.updateType=h;break;case i:this.updateType=o;break;case e:this.updateType=s}this.count=m;let f=T[d];m&&(f=t.roundUp(f,4)),this.byteSize=4*f,m&&(this.byteSize*=m)}calculateOffset(e){let s=this.byteSize<=8?this.byteSize:16;this.count&&(s=16),e=t.roundUp(e,s),this.offset=e/4}}class j{constructor(e,s){this.byteSize=0,this.map=new Map,this.scope=e.scope,this.uniforms=s;let i=0;for(let t=0;t<s.length;t++){const e=s[t];e.calculateOffset(i),i=4*e.offset+e.byteSize,e.scopeId=this.scope.resolve(e.name),this.map.set(e.name,e)}this.byteSize=t.roundUp(i,16)}get(t){return this.map.get(t)}getShaderDeclaration(t,e){let s=`layout(set = ${t}, binding = ${e}, std140) uniform ub_${u[t]} {\n`;return this.uniforms.forEach((t=>{const e=d[t.type];s+=`    ${e} ${t.shortName}${t.count?`[${t.count}]`:""};\n`})),s+"};\n"}}export{j as UniformBufferFormat,k as UniformFormat};
