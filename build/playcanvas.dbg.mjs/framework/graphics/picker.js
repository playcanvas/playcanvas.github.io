import { Color } from '../../core/math/color.js';
import { PIXELFORMAT_RGBA8, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE, CLEARFLAG_DEPTH } from '../../platform/graphics/constants.js';
import { GraphicsDevice } from '../../platform/graphics/graphics-device.js';
import { RenderTarget } from '../../platform/graphics/render-target.js';
import { Texture } from '../../platform/graphics/texture.js';
import { DebugGraphics } from '../../platform/graphics/debug-graphics.js';
import { SHADER_PICK, SORTMODE_NONE } from '../../scene/constants.js';
import { Camera } from '../../scene/camera.js';
import { Command } from '../../scene/mesh-instance.js';
import { Layer } from '../../scene/layer.js';
import { LayerComposition } from '../../scene/composition/layer-composition.js';
import { getApplication } from '../globals.js';
import { Entity } from '../entity.js';
import { Debug } from '../../core/debug.js';
import { BlendState } from '../../platform/graphics/blend-state.js';

const tempSet = new Set();
const clearDepthOptions = {
  depth: 1.0,
  flags: CLEARFLAG_DEPTH
};

/**
 * Picker object used to select mesh instances from screen coordinates.
 *
 * @property {number} width Width of the pick buffer in pixels (read-only).
 * @property {number} height Height of the pick buffer in pixels (read-only).
 * @property {RenderTarget} renderTarget The render target used by the picker internally
 * (read-only).
 */
class Picker {
  // internal render target

  /**
   * Create a new Picker instance.
   *
   * @param {import('../app-base.js').AppBase} app - The application managing this picker
   * instance.
   * @param {number} width - The width of the pick buffer in pixels.
   * @param {number} height - The height of the pick buffer in pixels.
   */
  constructor(app, width, height) {
    this.renderTarget = null;
    if (app instanceof GraphicsDevice) {
      app = getApplication();
      Debug.deprecated('pc.Picker now takes pc.AppBase as first argument. Passing pc.GraphicsDevice is deprecated.');
    }
    this.app = app;
    this.device = app.graphicsDevice;

    // uniform for the mesh index encoded into rgba
    this.pickColor = new Float32Array(4);
    this.pickColor[3] = 1;

    // mapping table from ids to meshInstances
    this.mapping = [];

    // create layer composition with the layer and camera
    this.cameraEntity = null;
    this.layer = null;
    this.layerComp = null;
    this.initLayerComposition();

    // clear command user to simulate layer clearing, required due to storing meshes from multiple layers on a singe layer
    const device = this.device;
    this.clearDepthCommand = new Command(0, 0, function () {
      device.clear(clearDepthOptions);
    });
    this.width = 0;
    this.height = 0;
    this.resize(width, height);
  }

  /**
   * Return the list of mesh instances selected by the specified rectangle in the previously
   * prepared pick buffer.The rectangle using top-left coordinate system.
   *
   * @param {number} x - The left edge of the rectangle.
   * @param {number} y - The top edge of the rectangle.
   * @param {number} [width] - The width of the rectangle.
   * @param {number} [height] - The height of the rectangle.
   * @returns {import('../../scene/mesh-instance.js').MeshInstance[]} An array of mesh instances
   * that are in the selection.
   * @example
   * // Get the selection at the point (10,20)
   * const selection = picker.getSelection(10, 20);
   * @example
   * // Get all models in rectangle with corners at (10,20) and (20,40)
   * const selection = picker.getSelection(10, 20, 10, 20);
   */
  getSelection(x, y, width, height) {
    const device = this.device;
    if (typeof x === 'object') {
      Debug.deprecated('Picker.getSelection:param \'rect\' is deprecated, use \'x, y, width, height\' instead.');
      const rect = x;
      x = rect.x;
      y = rect.y;
      width = rect.width;
      height = rect.height;
    } else {
      y = this.renderTarget.height - (y + (height || 1));
    }

    // make sure we have nice numbers to work with
    x = Math.floor(x);
    y = Math.floor(y);
    width = Math.floor(Math.max(width || 1, 1));
    height = Math.floor(Math.max(height || 1, 1));

    // backup active render target
    const origRenderTarget = device.renderTarget;
    DebugGraphics.pushGpuMarker(device, 'PICKER');

    // Ready the device for rendering to the pick buffer
    device.setRenderTarget(this.renderTarget);
    device.updateBegin();
    const pixels = new Uint8Array(4 * width * height);
    device.readPixels(x, y, width, height, pixels);
    device.updateEnd();

    // Restore render target
    device.setRenderTarget(origRenderTarget);
    DebugGraphics.popGpuMarker(device);
    const mapping = this.mapping;
    for (let i = 0; i < width * height; i++) {
      const r = pixels[4 * i + 0];
      const g = pixels[4 * i + 1];
      const b = pixels[4 * i + 2];
      const index = r << 16 | g << 8 | b;

      // White is 'no selection'
      if (index !== 0xffffff) {
        tempSet.add(mapping[index]);
      }
    }

    // return the content of the set as an array
    const selection = [];
    tempSet.forEach(meshInstance => selection.push(meshInstance));
    tempSet.clear();
    return selection;
  }
  allocateRenderTarget() {
    const colorBuffer = new Texture(this.device, {
      format: PIXELFORMAT_RGBA8,
      width: this.width,
      height: this.height,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      name: 'pick'
    });
    this.renderTarget = new RenderTarget({
      colorBuffer: colorBuffer,
      depth: true
    });
  }
  releaseRenderTarget() {
    // unset it from the camera
    this.cameraEntity.camera.renderTarget = null;
    if (this.renderTarget) {
      this.renderTarget.destroyTextureBuffers();
      this.renderTarget.destroy();
      this.renderTarget = null;
    }
  }
  initLayerComposition() {
    const device = this.device;
    const self = this;
    const pickColorId = device.scope.resolve('uColor');

    // camera
    this.cameraEntity = new Entity();
    this.cameraEntity.addComponent('camera');

    // layer all meshes rendered for picking at added to
    this.layer = new Layer({
      name: 'Picker',
      shaderPass: SHADER_PICK,
      opaqueSortMode: SORTMODE_NONE,
      // executes just before the mesh is rendered. And index encoded in rgb is assigned to it
      onDrawCall: function (meshInstance, index) {
        self.pickColor[0] = (index >> 16 & 0xff) / 255;
        self.pickColor[1] = (index >> 8 & 0xff) / 255;
        self.pickColor[2] = (index & 0xff) / 255;
        pickColorId.setValue(self.pickColor);
        device.setBlendState(BlendState.DEFAULT);

        // keep the index -> meshInstance index mapping
        self.mapping[index] = meshInstance;
      }
    });
    this.layer.addCamera(this.cameraEntity.camera);

    // composition
    this.layerComp = new LayerComposition('picker');
    this.layerComp.pushOpaque(this.layer);
  }

  /**
   * Primes the pick buffer with a rendering of the specified models from the point of view of
   * the supplied camera. Once the pick buffer has been prepared, {@link Picker#getSelection} can
   * be called multiple times on the same picker object. Therefore, if the models or camera do
   * not change in any way, {@link Picker#prepare} does not need to be called again.
   *
   * @param {import('../components/camera/component.js').CameraComponent} camera - The camera
   * component used to render the scene.
   * @param {import('../../scene/scene.js').Scene} scene - The scene containing the pickable mesh
   * instances.
   * @param {Layer[]} [layers] - Layers from which objects will be picked. If not supplied, all layers of the specified camera will be used.
   */
  prepare(camera, scene, layers) {
    // handle deprecated arguments
    if (camera instanceof Camera) {
      Debug.deprecated('pc.Picker#prepare now takes pc.CameraComponent as first argument. Passing pc.Camera is deprecated.');

      // Get the camera component
      camera = camera.node.camera;
    }
    if (layers instanceof Layer) {
      layers = [layers];
    }

    // populate the layer with meshes and depth clear commands
    this.layer.clearMeshInstances();
    const destMeshInstances = this.layer.opaqueMeshInstances;

    // source mesh instances
    const srcLayers = scene.layers.layerList;
    const subLayerEnabled = scene.layers.subLayerEnabled;
    const isTransparent = scene.layers.subLayerList;
    for (let i = 0; i < srcLayers.length; i++) {
      const srcLayer = srcLayers[i];

      // skip the layer if it does not match the provided ones
      if (layers && layers.indexOf(srcLayer) < 0) {
        continue;
      }
      if (srcLayer.enabled && subLayerEnabled[i]) {
        // if the layer is rendered by the camera
        const layerCamId = srcLayer.cameras.indexOf(camera);
        if (layerCamId >= 0) {
          // if the layer clears the depth, add command to clear it
          if (srcLayer._clearDepthBuffer) {
            destMeshInstances.push(this.clearDepthCommand);
          }

          // copy all pickable mesh instances
          const meshInstances = isTransparent[i] ? srcLayer.instances.transparentMeshInstances : srcLayer.instances.opaqueMeshInstances;
          for (let j = 0; j < meshInstances.length; j++) {
            const meshInstance = meshInstances[j];
            if (meshInstance.pick) {
              destMeshInstances.push(meshInstance);
            }
          }
        }
      }
    }

    // make the render target the right size
    if (!this.renderTarget || this.width !== this.renderTarget.width || this.height !== this.renderTarget.height) {
      this.releaseRenderTarget();
      this.allocateRenderTarget();
    }

    // prepare the rendering camera
    this.updateCamera(camera);

    // clear registered meshes mapping
    this.mapping.length = 0;

    // render
    this.app.renderComposition(this.layerComp);
  }
  updateCamera(srcCamera) {
    // copy transform
    this.cameraEntity.copy(srcCamera.entity);
    this.cameraEntity.name = 'PickerCamera';

    // copy camera component properties - which overwrites few properties we change to what is needed later
    const destCamera = this.cameraEntity.camera;
    destCamera.copy(srcCamera);

    // set up clears
    destCamera.clearColorBuffer = true;
    destCamera.clearDepthBuffer = true;
    destCamera.clearStencilBuffer = true;
    destCamera.clearColor = Color.WHITE;

    // render target
    destCamera.renderTarget = this.renderTarget;

    // layers
    this.layer.clearCameras();
    this.layer.addCamera(destCamera);
    destCamera.layers = [this.layer.id];
  }

  /**
   * Sets the resolution of the pick buffer. The pick buffer resolution does not need to match
   * the resolution of the corresponding frame buffer use for general rendering of the 3D scene.
   * However, the lower the resolution of the pick buffer, the less accurate the selection
   * results returned by {@link Picker#getSelection}. On the other hand, smaller pick buffers
   * will yield greater performance, so there is a trade off.
   *
   * @param {number} width - The width of the pick buffer in pixels.
   * @param {number} height - The height of the pick buffer in pixels.
   */
  resize(width, height) {
    this.width = Math.floor(width);
    this.height = Math.floor(height);
  }
}

export { Picker };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGlja2VyLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvZnJhbWV3b3JrL2dyYXBoaWNzL3BpY2tlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL2NvcmUvbWF0aC9jb2xvci5qcyc7XG5cbmltcG9ydCB7IEFERFJFU1NfQ0xBTVBfVE9fRURHRSwgQ0xFQVJGTEFHX0RFUFRILCBGSUxURVJfTkVBUkVTVCwgUElYRUxGT1JNQVRfUkdCQTggfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NEZXZpY2UgfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy9ncmFwaGljcy1kZXZpY2UuanMnO1xuaW1wb3J0IHsgUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvcmVuZGVyLXRhcmdldC5qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvdGV4dHVyZS5qcyc7XG5pbXBvcnQgeyBEZWJ1Z0dyYXBoaWNzIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvZGVidWctZ3JhcGhpY3MuanMnO1xuXG5pbXBvcnQgeyBTSEFERVJfUElDSywgU09SVE1PREVfTk9ORSB9IGZyb20gJy4uLy4uL3NjZW5lL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBDYW1lcmEgfSBmcm9tICcuLi8uLi9zY2VuZS9jYW1lcmEuanMnO1xuaW1wb3J0IHsgQ29tbWFuZCB9IGZyb20gJy4uLy4uL3NjZW5lL21lc2gtaW5zdGFuY2UuanMnO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi9zY2VuZS9sYXllci5qcyc7XG5pbXBvcnQgeyBMYXllckNvbXBvc2l0aW9uIH0gZnJvbSAnLi4vLi4vc2NlbmUvY29tcG9zaXRpb24vbGF5ZXItY29tcG9zaXRpb24uanMnO1xuXG5pbXBvcnQgeyBnZXRBcHBsaWNhdGlvbiB9IGZyb20gJy4uL2dsb2JhbHMuanMnO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnLi4vZW50aXR5LmpzJztcbmltcG9ydCB7IERlYnVnIH0gZnJvbSAnLi4vLi4vY29yZS9kZWJ1Zy5qcyc7XG5pbXBvcnQgeyBCbGVuZFN0YXRlIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvYmxlbmQtc3RhdGUuanMnO1xuXG5jb25zdCB0ZW1wU2V0ID0gbmV3IFNldCgpO1xuXG5jb25zdCBjbGVhckRlcHRoT3B0aW9ucyA9IHtcbiAgICBkZXB0aDogMS4wLFxuICAgIGZsYWdzOiBDTEVBUkZMQUdfREVQVEhcbn07XG5cbi8qKlxuICogUGlja2VyIG9iamVjdCB1c2VkIHRvIHNlbGVjdCBtZXNoIGluc3RhbmNlcyBmcm9tIHNjcmVlbiBjb29yZGluYXRlcy5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggV2lkdGggb2YgdGhlIHBpY2sgYnVmZmVyIGluIHBpeGVscyAocmVhZC1vbmx5KS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSBwaWNrIGJ1ZmZlciBpbiBwaXhlbHMgKHJlYWQtb25seSkuXG4gKiBAcHJvcGVydHkge1JlbmRlclRhcmdldH0gcmVuZGVyVGFyZ2V0IFRoZSByZW5kZXIgdGFyZ2V0IHVzZWQgYnkgdGhlIHBpY2tlciBpbnRlcm5hbGx5XG4gKiAocmVhZC1vbmx5KS5cbiAqL1xuY2xhc3MgUGlja2VyIHtcbiAgICAvLyBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0XG4gICAgcmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBQaWNrZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vYXBwLWJhc2UuanMnKS5BcHBCYXNlfSBhcHAgLSBUaGUgYXBwbGljYXRpb24gbWFuYWdpbmcgdGhpcyBwaWNrZXJcbiAgICAgKiBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHBpY2sgYnVmZmVyIGluIHBpeGVscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgcGljayBidWZmZXIgaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAoYXBwIGluc3RhbmNlb2YgR3JhcGhpY3NEZXZpY2UpIHtcbiAgICAgICAgICAgIGFwcCA9IGdldEFwcGxpY2F0aW9uKCk7XG4gICAgICAgICAgICBEZWJ1Zy5kZXByZWNhdGVkKCdwYy5QaWNrZXIgbm93IHRha2VzIHBjLkFwcEJhc2UgYXMgZmlyc3QgYXJndW1lbnQuIFBhc3NpbmcgcGMuR3JhcGhpY3NEZXZpY2UgaXMgZGVwcmVjYXRlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLmRldmljZSA9IGFwcC5ncmFwaGljc0RldmljZTtcblxuICAgICAgICAvLyB1bmlmb3JtIGZvciB0aGUgbWVzaCBpbmRleCBlbmNvZGVkIGludG8gcmdiYVxuICAgICAgICB0aGlzLnBpY2tDb2xvciA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICAgIHRoaXMucGlja0NvbG9yWzNdID0gMTtcblxuICAgICAgICAvLyBtYXBwaW5nIHRhYmxlIGZyb20gaWRzIHRvIG1lc2hJbnN0YW5jZXNcbiAgICAgICAgdGhpcy5tYXBwaW5nID0gW107XG5cbiAgICAgICAgLy8gY3JlYXRlIGxheWVyIGNvbXBvc2l0aW9uIHdpdGggdGhlIGxheWVyIGFuZCBjYW1lcmFcbiAgICAgICAgdGhpcy5jYW1lcmFFbnRpdHkgPSBudWxsO1xuICAgICAgICB0aGlzLmxheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXllckNvbXAgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRMYXllckNvbXBvc2l0aW9uKCk7XG5cbiAgICAgICAgLy8gY2xlYXIgY29tbWFuZCB1c2VyIHRvIHNpbXVsYXRlIGxheWVyIGNsZWFyaW5nLCByZXF1aXJlZCBkdWUgdG8gc3RvcmluZyBtZXNoZXMgZnJvbSBtdWx0aXBsZSBsYXllcnMgb24gYSBzaW5nZSBsYXllclxuICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmRldmljZTtcbiAgICAgICAgdGhpcy5jbGVhckRlcHRoQ29tbWFuZCA9IG5ldyBDb21tYW5kKDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRldmljZS5jbGVhcihjbGVhckRlcHRoT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbGlzdCBvZiBtZXNoIGluc3RhbmNlcyBzZWxlY3RlZCBieSB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSBpbiB0aGUgcHJldmlvdXNseVxuICAgICAqIHByZXBhcmVkIHBpY2sgYnVmZmVyLlRoZSByZWN0YW5nbGUgdXNpbmcgdG9wLWxlZnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB0b3AgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAqIEByZXR1cm5zIHtpbXBvcnQoJy4uLy4uL3NjZW5lL21lc2gtaW5zdGFuY2UuanMnKS5NZXNoSW5zdGFuY2VbXX0gQW4gYXJyYXkgb2YgbWVzaCBpbnN0YW5jZXNcbiAgICAgKiB0aGF0IGFyZSBpbiB0aGUgc2VsZWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gR2V0IHRoZSBzZWxlY3Rpb24gYXQgdGhlIHBvaW50ICgxMCwyMClcbiAgICAgKiBjb25zdCBzZWxlY3Rpb24gPSBwaWNrZXIuZ2V0U2VsZWN0aW9uKDEwLCAyMCk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBHZXQgYWxsIG1vZGVscyBpbiByZWN0YW5nbGUgd2l0aCBjb3JuZXJzIGF0ICgxMCwyMCkgYW5kICgyMCw0MClcbiAgICAgKiBjb25zdCBzZWxlY3Rpb24gPSBwaWNrZXIuZ2V0U2VsZWN0aW9uKDEwLCAyMCwgMTAsIDIwKTtcbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmRldmljZTtcblxuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBEZWJ1Zy5kZXByZWNhdGVkKCdQaWNrZXIuZ2V0U2VsZWN0aW9uOnBhcmFtIFxcJ3JlY3RcXCcgaXMgZGVwcmVjYXRlZCwgdXNlIFxcJ3gsIHksIHdpZHRoLCBoZWlnaHRcXCcgaW5zdGVhZC4nKTtcblxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHg7XG4gICAgICAgICAgICB4ID0gcmVjdC54O1xuICAgICAgICAgICAgeSA9IHJlY3QueTtcbiAgICAgICAgICAgIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeSA9IHRoaXMucmVuZGVyVGFyZ2V0LmhlaWdodCAtICh5ICsgKGhlaWdodCB8fCAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBuaWNlIG51bWJlcnMgdG8gd29yayB3aXRoXG4gICAgICAgIHggPSBNYXRoLmZsb29yKHgpO1xuICAgICAgICB5ID0gTWF0aC5mbG9vcih5KTtcbiAgICAgICAgd2lkdGggPSBNYXRoLmZsb29yKE1hdGgubWF4KHdpZHRoIHx8IDEsIDEpKTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihNYXRoLm1heChoZWlnaHQgfHwgMSwgMSkpO1xuXG4gICAgICAgIC8vIGJhY2t1cCBhY3RpdmUgcmVuZGVyIHRhcmdldFxuICAgICAgICBjb25zdCBvcmlnUmVuZGVyVGFyZ2V0ID0gZGV2aWNlLnJlbmRlclRhcmdldDtcblxuICAgICAgICBEZWJ1Z0dyYXBoaWNzLnB1c2hHcHVNYXJrZXIoZGV2aWNlLCAnUElDS0VSJyk7XG5cbiAgICAgICAgLy8gUmVhZHkgdGhlIGRldmljZSBmb3IgcmVuZGVyaW5nIHRvIHRoZSBwaWNrIGJ1ZmZlclxuICAgICAgICBkZXZpY2Uuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgZGV2aWNlLnVwZGF0ZUJlZ2luKCk7XG5cbiAgICAgICAgY29uc3QgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoNCAqIHdpZHRoICogaGVpZ2h0KTtcbiAgICAgICAgZGV2aWNlLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgcGl4ZWxzKTtcblxuICAgICAgICBkZXZpY2UudXBkYXRlRW5kKCk7XG5cbiAgICAgICAgLy8gUmVzdG9yZSByZW5kZXIgdGFyZ2V0XG4gICAgICAgIGRldmljZS5zZXRSZW5kZXJUYXJnZXQob3JpZ1JlbmRlclRhcmdldCk7XG5cbiAgICAgICAgRGVidWdHcmFwaGljcy5wb3BHcHVNYXJrZXIoZGV2aWNlKTtcblxuICAgICAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5tYXBwaW5nO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoICogaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBwaXhlbHNbNCAqIGkgKyAwXTtcbiAgICAgICAgICAgIGNvbnN0IGcgPSBwaXhlbHNbNCAqIGkgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBwaXhlbHNbNCAqIGkgKyAyXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gciA8PCAxNiB8IGcgPDwgOCB8IGI7XG5cbiAgICAgICAgICAgIC8vIFdoaXRlIGlzICdubyBzZWxlY3Rpb24nXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IDB4ZmZmZmZmKSB7XG4gICAgICAgICAgICAgICAgdGVtcFNldC5hZGQobWFwcGluZ1tpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBjb250ZW50IG9mIHRoZSBzZXQgYXMgYW4gYXJyYXlcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gW107XG4gICAgICAgIHRlbXBTZXQuZm9yRWFjaChtZXNoSW5zdGFuY2UgPT4gc2VsZWN0aW9uLnB1c2gobWVzaEluc3RhbmNlKSk7XG4gICAgICAgIHRlbXBTZXQuY2xlYXIoKTtcblxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH1cblxuICAgIGFsbG9jYXRlUmVuZGVyVGFyZ2V0KCkge1xuXG4gICAgICAgIGNvbnN0IGNvbG9yQnVmZmVyID0gbmV3IFRleHR1cmUodGhpcy5kZXZpY2UsIHtcbiAgICAgICAgICAgIGZvcm1hdDogUElYRUxGT1JNQVRfUkdCQTgsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtaXBtYXBzOiBmYWxzZSxcbiAgICAgICAgICAgIG1pbkZpbHRlcjogRklMVEVSX05FQVJFU1QsXG4gICAgICAgICAgICBtYWdGaWx0ZXI6IEZJTFRFUl9ORUFSRVNULFxuICAgICAgICAgICAgYWRkcmVzc1U6IEFERFJFU1NfQ0xBTVBfVE9fRURHRSxcbiAgICAgICAgICAgIGFkZHJlc3NWOiBBRERSRVNTX0NMQU1QX1RPX0VER0UsXG4gICAgICAgICAgICBuYW1lOiAncGljaydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgUmVuZGVyVGFyZ2V0KHtcbiAgICAgICAgICAgIGNvbG9yQnVmZmVyOiBjb2xvckJ1ZmZlcixcbiAgICAgICAgICAgIGRlcHRoOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbGVhc2VSZW5kZXJUYXJnZXQoKSB7XG5cbiAgICAgICAgLy8gdW5zZXQgaXQgZnJvbSB0aGUgY2FtZXJhXG4gICAgICAgIHRoaXMuY2FtZXJhRW50aXR5LmNhbWVyYS5yZW5kZXJUYXJnZXQgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLnJlbmRlclRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQuZGVzdHJveVRleHR1cmVCdWZmZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRhcmdldC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0TGF5ZXJDb21wb3NpdGlvbigpIHtcblxuICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmRldmljZTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHBpY2tDb2xvcklkID0gZGV2aWNlLnNjb3BlLnJlc29sdmUoJ3VDb2xvcicpO1xuXG4gICAgICAgIC8vIGNhbWVyYVxuICAgICAgICB0aGlzLmNhbWVyYUVudGl0eSA9IG5ldyBFbnRpdHkoKTtcbiAgICAgICAgdGhpcy5jYW1lcmFFbnRpdHkuYWRkQ29tcG9uZW50KCdjYW1lcmEnKTtcblxuICAgICAgICAvLyBsYXllciBhbGwgbWVzaGVzIHJlbmRlcmVkIGZvciBwaWNraW5nIGF0IGFkZGVkIHRvXG4gICAgICAgIHRoaXMubGF5ZXIgPSBuZXcgTGF5ZXIoe1xuICAgICAgICAgICAgbmFtZTogJ1BpY2tlcicsXG4gICAgICAgICAgICBzaGFkZXJQYXNzOiBTSEFERVJfUElDSyxcbiAgICAgICAgICAgIG9wYXF1ZVNvcnRNb2RlOiBTT1JUTU9ERV9OT05FLFxuXG4gICAgICAgICAgICAvLyBleGVjdXRlcyBqdXN0IGJlZm9yZSB0aGUgbWVzaCBpcyByZW5kZXJlZC4gQW5kIGluZGV4IGVuY29kZWQgaW4gcmdiIGlzIGFzc2lnbmVkIHRvIGl0XG4gICAgICAgICAgICBvbkRyYXdDYWxsOiBmdW5jdGlvbiAobWVzaEluc3RhbmNlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHNlbGYucGlja0NvbG9yWzBdID0gKChpbmRleCA+PiAxNikgJiAweGZmKSAvIDI1NTtcbiAgICAgICAgICAgICAgICBzZWxmLnBpY2tDb2xvclsxXSA9ICgoaW5kZXggPj4gOCkgJiAweGZmKSAvIDI1NTtcbiAgICAgICAgICAgICAgICBzZWxmLnBpY2tDb2xvclsyXSA9IChpbmRleCAmIDB4ZmYpIC8gMjU1O1xuICAgICAgICAgICAgICAgIHBpY2tDb2xvcklkLnNldFZhbHVlKHNlbGYucGlja0NvbG9yKTtcbiAgICAgICAgICAgICAgICBkZXZpY2Uuc2V0QmxlbmRTdGF0ZShCbGVuZFN0YXRlLkRFRkFVTFQpO1xuXG4gICAgICAgICAgICAgICAgLy8ga2VlcCB0aGUgaW5kZXggLT4gbWVzaEluc3RhbmNlIGluZGV4IG1hcHBpbmdcbiAgICAgICAgICAgICAgICBzZWxmLm1hcHBpbmdbaW5kZXhdID0gbWVzaEluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sYXllci5hZGRDYW1lcmEodGhpcy5jYW1lcmFFbnRpdHkuY2FtZXJhKTtcblxuICAgICAgICAvLyBjb21wb3NpdGlvblxuICAgICAgICB0aGlzLmxheWVyQ29tcCA9IG5ldyBMYXllckNvbXBvc2l0aW9uKCdwaWNrZXInKTtcbiAgICAgICAgdGhpcy5sYXllckNvbXAucHVzaE9wYXF1ZSh0aGlzLmxheWVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmltZXMgdGhlIHBpY2sgYnVmZmVyIHdpdGggYSByZW5kZXJpbmcgb2YgdGhlIHNwZWNpZmllZCBtb2RlbHMgZnJvbSB0aGUgcG9pbnQgb2YgdmlldyBvZlxuICAgICAqIHRoZSBzdXBwbGllZCBjYW1lcmEuIE9uY2UgdGhlIHBpY2sgYnVmZmVyIGhhcyBiZWVuIHByZXBhcmVkLCB7QGxpbmsgUGlja2VyI2dldFNlbGVjdGlvbn0gY2FuXG4gICAgICogYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIHBpY2tlciBvYmplY3QuIFRoZXJlZm9yZSwgaWYgdGhlIG1vZGVscyBvciBjYW1lcmEgZG9cbiAgICAgKiBub3QgY2hhbmdlIGluIGFueSB3YXksIHtAbGluayBQaWNrZXIjcHJlcGFyZX0gZG9lcyBub3QgbmVlZCB0byBiZSBjYWxsZWQgYWdhaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29tcG9uZW50cy9jYW1lcmEvY29tcG9uZW50LmpzJykuQ2FtZXJhQ29tcG9uZW50fSBjYW1lcmEgLSBUaGUgY2FtZXJhXG4gICAgICogY29tcG9uZW50IHVzZWQgdG8gcmVuZGVyIHRoZSBzY2VuZS5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vc2NlbmUvc2NlbmUuanMnKS5TY2VuZX0gc2NlbmUgLSBUaGUgc2NlbmUgY29udGFpbmluZyB0aGUgcGlja2FibGUgbWVzaFxuICAgICAqIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0ge0xheWVyW119IFtsYXllcnNdIC0gTGF5ZXJzIGZyb20gd2hpY2ggb2JqZWN0cyB3aWxsIGJlIHBpY2tlZC4gSWYgbm90IHN1cHBsaWVkLCBhbGwgbGF5ZXJzIG9mIHRoZSBzcGVjaWZpZWQgY2FtZXJhIHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBwcmVwYXJlKGNhbWVyYSwgc2NlbmUsIGxheWVycykge1xuXG4gICAgICAgIC8vIGhhbmRsZSBkZXByZWNhdGVkIGFyZ3VtZW50c1xuICAgICAgICBpZiAoY2FtZXJhIGluc3RhbmNlb2YgQ2FtZXJhKSB7XG4gICAgICAgICAgICBEZWJ1Zy5kZXByZWNhdGVkKCdwYy5QaWNrZXIjcHJlcGFyZSBub3cgdGFrZXMgcGMuQ2FtZXJhQ29tcG9uZW50IGFzIGZpcnN0IGFyZ3VtZW50LiBQYXNzaW5nIHBjLkNhbWVyYSBpcyBkZXByZWNhdGVkLicpO1xuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNhbWVyYSBjb21wb25lbnRcbiAgICAgICAgICAgIGNhbWVyYSA9IGNhbWVyYS5ub2RlLmNhbWVyYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMYXllcikge1xuICAgICAgICAgICAgbGF5ZXJzID0gW2xheWVyc107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwb3B1bGF0ZSB0aGUgbGF5ZXIgd2l0aCBtZXNoZXMgYW5kIGRlcHRoIGNsZWFyIGNvbW1hbmRzXG4gICAgICAgIHRoaXMubGF5ZXIuY2xlYXJNZXNoSW5zdGFuY2VzKCk7XG4gICAgICAgIGNvbnN0IGRlc3RNZXNoSW5zdGFuY2VzID0gdGhpcy5sYXllci5vcGFxdWVNZXNoSW5zdGFuY2VzO1xuXG4gICAgICAgIC8vIHNvdXJjZSBtZXNoIGluc3RhbmNlc1xuICAgICAgICBjb25zdCBzcmNMYXllcnMgPSBzY2VuZS5sYXllcnMubGF5ZXJMaXN0O1xuICAgICAgICBjb25zdCBzdWJMYXllckVuYWJsZWQgPSBzY2VuZS5sYXllcnMuc3ViTGF5ZXJFbmFibGVkO1xuICAgICAgICBjb25zdCBpc1RyYW5zcGFyZW50ID0gc2NlbmUubGF5ZXJzLnN1YkxheWVyTGlzdDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNyY0xheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3JjTGF5ZXIgPSBzcmNMYXllcnNbaV07XG5cbiAgICAgICAgICAgIC8vIHNraXAgdGhlIGxheWVyIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBvbmVzXG4gICAgICAgICAgICBpZiAobGF5ZXJzICYmIGxheWVycy5pbmRleE9mKHNyY0xheWVyKSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNyY0xheWVyLmVuYWJsZWQgJiYgc3ViTGF5ZXJFbmFibGVkW2ldKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGF5ZXIgaXMgcmVuZGVyZWQgYnkgdGhlIGNhbWVyYVxuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyQ2FtSWQgPSBzcmNMYXllci5jYW1lcmFzLmluZGV4T2YoY2FtZXJhKTtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJDYW1JZCA+PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxheWVyIGNsZWFycyB0aGUgZGVwdGgsIGFkZCBjb21tYW5kIHRvIGNsZWFyIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNMYXllci5fY2xlYXJEZXB0aEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdE1lc2hJbnN0YW5jZXMucHVzaCh0aGlzLmNsZWFyRGVwdGhDb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgYWxsIHBpY2thYmxlIG1lc2ggaW5zdGFuY2VzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc2hJbnN0YW5jZXMgPSBpc1RyYW5zcGFyZW50W2ldID8gc3JjTGF5ZXIuaW5zdGFuY2VzLnRyYW5zcGFyZW50TWVzaEluc3RhbmNlcyA6IHNyY0xheWVyLmluc3RhbmNlcy5vcGFxdWVNZXNoSW5zdGFuY2VzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1lc2hJbnN0YW5jZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc2hJbnN0YW5jZSA9IG1lc2hJbnN0YW5jZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzaEluc3RhbmNlLnBpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0TWVzaEluc3RhbmNlcy5wdXNoKG1lc2hJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHRoZSByZW5kZXIgdGFyZ2V0IHRoZSByaWdodCBzaXplXG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJUYXJnZXQgfHwgKHRoaXMud2lkdGggIT09IHRoaXMucmVuZGVyVGFyZ2V0LndpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9PSB0aGlzLnJlbmRlclRhcmdldC5oZWlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VSZW5kZXJUYXJnZXQoKTtcbiAgICAgICAgICAgIHRoaXMuYWxsb2NhdGVSZW5kZXJUYXJnZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXBhcmUgdGhlIHJlbmRlcmluZyBjYW1lcmFcbiAgICAgICAgdGhpcy51cGRhdGVDYW1lcmEoY2FtZXJhKTtcblxuICAgICAgICAvLyBjbGVhciByZWdpc3RlcmVkIG1lc2hlcyBtYXBwaW5nXG4gICAgICAgIHRoaXMubWFwcGluZy5sZW5ndGggPSAwO1xuXG4gICAgICAgIC8vIHJlbmRlclxuICAgICAgICB0aGlzLmFwcC5yZW5kZXJDb21wb3NpdGlvbih0aGlzLmxheWVyQ29tcCk7XG4gICAgfVxuXG4gICAgdXBkYXRlQ2FtZXJhKHNyY0NhbWVyYSkge1xuXG4gICAgICAgIC8vIGNvcHkgdHJhbnNmb3JtXG4gICAgICAgIHRoaXMuY2FtZXJhRW50aXR5LmNvcHkoc3JjQ2FtZXJhLmVudGl0eSk7XG4gICAgICAgIHRoaXMuY2FtZXJhRW50aXR5Lm5hbWUgPSAnUGlja2VyQ2FtZXJhJztcblxuICAgICAgICAvLyBjb3B5IGNhbWVyYSBjb21wb25lbnQgcHJvcGVydGllcyAtIHdoaWNoIG92ZXJ3cml0ZXMgZmV3IHByb3BlcnRpZXMgd2UgY2hhbmdlIHRvIHdoYXQgaXMgbmVlZGVkIGxhdGVyXG4gICAgICAgIGNvbnN0IGRlc3RDYW1lcmEgPSB0aGlzLmNhbWVyYUVudGl0eS5jYW1lcmE7XG4gICAgICAgIGRlc3RDYW1lcmEuY29weShzcmNDYW1lcmEpO1xuXG4gICAgICAgIC8vIHNldCB1cCBjbGVhcnNcbiAgICAgICAgZGVzdENhbWVyYS5jbGVhckNvbG9yQnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgZGVzdENhbWVyYS5jbGVhckRlcHRoQnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgZGVzdENhbWVyYS5jbGVhclN0ZW5jaWxCdWZmZXIgPSB0cnVlO1xuICAgICAgICBkZXN0Q2FtZXJhLmNsZWFyQ29sb3IgPSBDb2xvci5XSElURTtcblxuICAgICAgICAvLyByZW5kZXIgdGFyZ2V0XG4gICAgICAgIGRlc3RDYW1lcmEucmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG5cbiAgICAgICAgLy8gbGF5ZXJzXG4gICAgICAgIHRoaXMubGF5ZXIuY2xlYXJDYW1lcmFzKCk7XG4gICAgICAgIHRoaXMubGF5ZXIuYWRkQ2FtZXJhKGRlc3RDYW1lcmEpO1xuICAgICAgICBkZXN0Q2FtZXJhLmxheWVycyA9IFt0aGlzLmxheWVyLmlkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBwaWNrIGJ1ZmZlci4gVGhlIHBpY2sgYnVmZmVyIHJlc29sdXRpb24gZG9lcyBub3QgbmVlZCB0byBtYXRjaFxuICAgICAqIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjb3JyZXNwb25kaW5nIGZyYW1lIGJ1ZmZlciB1c2UgZm9yIGdlbmVyYWwgcmVuZGVyaW5nIG9mIHRoZSAzRCBzY2VuZS5cbiAgICAgKiBIb3dldmVyLCB0aGUgbG93ZXIgdGhlIHJlc29sdXRpb24gb2YgdGhlIHBpY2sgYnVmZmVyLCB0aGUgbGVzcyBhY2N1cmF0ZSB0aGUgc2VsZWN0aW9uXG4gICAgICogcmVzdWx0cyByZXR1cm5lZCBieSB7QGxpbmsgUGlja2VyI2dldFNlbGVjdGlvbn0uIE9uIHRoZSBvdGhlciBoYW5kLCBzbWFsbGVyIHBpY2sgYnVmZmVyc1xuICAgICAqIHdpbGwgeWllbGQgZ3JlYXRlciBwZXJmb3JtYW5jZSwgc28gdGhlcmUgaXMgYSB0cmFkZSBvZmYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHBpY2sgYnVmZmVyIGluIHBpeGVscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgcGljayBidWZmZXIgaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMud2lkdGggPSBNYXRoLmZsb29yKHdpZHRoKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBQaWNrZXIgfTtcbiJdLCJuYW1lcyI6WyJ0ZW1wU2V0IiwiU2V0IiwiY2xlYXJEZXB0aE9wdGlvbnMiLCJkZXB0aCIsImZsYWdzIiwiQ0xFQVJGTEFHX0RFUFRIIiwiUGlja2VyIiwiY29uc3RydWN0b3IiLCJhcHAiLCJ3aWR0aCIsImhlaWdodCIsInJlbmRlclRhcmdldCIsIkdyYXBoaWNzRGV2aWNlIiwiZ2V0QXBwbGljYXRpb24iLCJEZWJ1ZyIsImRlcHJlY2F0ZWQiLCJkZXZpY2UiLCJncmFwaGljc0RldmljZSIsInBpY2tDb2xvciIsIkZsb2F0MzJBcnJheSIsIm1hcHBpbmciLCJjYW1lcmFFbnRpdHkiLCJsYXllciIsImxheWVyQ29tcCIsImluaXRMYXllckNvbXBvc2l0aW9uIiwiY2xlYXJEZXB0aENvbW1hbmQiLCJDb21tYW5kIiwiY2xlYXIiLCJyZXNpemUiLCJnZXRTZWxlY3Rpb24iLCJ4IiwieSIsInJlY3QiLCJNYXRoIiwiZmxvb3IiLCJtYXgiLCJvcmlnUmVuZGVyVGFyZ2V0IiwiRGVidWdHcmFwaGljcyIsInB1c2hHcHVNYXJrZXIiLCJzZXRSZW5kZXJUYXJnZXQiLCJ1cGRhdGVCZWdpbiIsInBpeGVscyIsIlVpbnQ4QXJyYXkiLCJyZWFkUGl4ZWxzIiwidXBkYXRlRW5kIiwicG9wR3B1TWFya2VyIiwiaSIsInIiLCJnIiwiYiIsImluZGV4IiwiYWRkIiwic2VsZWN0aW9uIiwiZm9yRWFjaCIsIm1lc2hJbnN0YW5jZSIsInB1c2giLCJhbGxvY2F0ZVJlbmRlclRhcmdldCIsImNvbG9yQnVmZmVyIiwiVGV4dHVyZSIsImZvcm1hdCIsIlBJWEVMRk9STUFUX1JHQkE4IiwibWlwbWFwcyIsIm1pbkZpbHRlciIsIkZJTFRFUl9ORUFSRVNUIiwibWFnRmlsdGVyIiwiYWRkcmVzc1UiLCJBRERSRVNTX0NMQU1QX1RPX0VER0UiLCJhZGRyZXNzViIsIm5hbWUiLCJSZW5kZXJUYXJnZXQiLCJyZWxlYXNlUmVuZGVyVGFyZ2V0IiwiY2FtZXJhIiwiZGVzdHJveVRleHR1cmVCdWZmZXJzIiwiZGVzdHJveSIsInNlbGYiLCJwaWNrQ29sb3JJZCIsInNjb3BlIiwicmVzb2x2ZSIsIkVudGl0eSIsImFkZENvbXBvbmVudCIsIkxheWVyIiwic2hhZGVyUGFzcyIsIlNIQURFUl9QSUNLIiwib3BhcXVlU29ydE1vZGUiLCJTT1JUTU9ERV9OT05FIiwib25EcmF3Q2FsbCIsInNldFZhbHVlIiwic2V0QmxlbmRTdGF0ZSIsIkJsZW5kU3RhdGUiLCJERUZBVUxUIiwiYWRkQ2FtZXJhIiwiTGF5ZXJDb21wb3NpdGlvbiIsInB1c2hPcGFxdWUiLCJwcmVwYXJlIiwic2NlbmUiLCJsYXllcnMiLCJDYW1lcmEiLCJub2RlIiwiY2xlYXJNZXNoSW5zdGFuY2VzIiwiZGVzdE1lc2hJbnN0YW5jZXMiLCJvcGFxdWVNZXNoSW5zdGFuY2VzIiwic3JjTGF5ZXJzIiwibGF5ZXJMaXN0Iiwic3ViTGF5ZXJFbmFibGVkIiwiaXNUcmFuc3BhcmVudCIsInN1YkxheWVyTGlzdCIsImxlbmd0aCIsInNyY0xheWVyIiwiaW5kZXhPZiIsImVuYWJsZWQiLCJsYXllckNhbUlkIiwiY2FtZXJhcyIsIl9jbGVhckRlcHRoQnVmZmVyIiwibWVzaEluc3RhbmNlcyIsImluc3RhbmNlcyIsInRyYW5zcGFyZW50TWVzaEluc3RhbmNlcyIsImoiLCJwaWNrIiwidXBkYXRlQ2FtZXJhIiwicmVuZGVyQ29tcG9zaXRpb24iLCJzcmNDYW1lcmEiLCJjb3B5IiwiZW50aXR5IiwiZGVzdENhbWVyYSIsImNsZWFyQ29sb3JCdWZmZXIiLCJjbGVhckRlcHRoQnVmZmVyIiwiY2xlYXJTdGVuY2lsQnVmZmVyIiwiY2xlYXJDb2xvciIsIkNvbG9yIiwiV0hJVEUiLCJjbGVhckNhbWVyYXMiLCJpZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxNQUFNQSxPQUFPLEdBQUcsSUFBSUMsR0FBRyxFQUFFLENBQUE7QUFFekIsTUFBTUMsaUJBQWlCLEdBQUc7QUFDdEJDLEVBQUFBLEtBQUssRUFBRSxHQUFHO0FBQ1ZDLEVBQUFBLEtBQUssRUFBRUMsZUFBQUE7QUFDWCxDQUFDLENBQUE7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLE1BQU0sQ0FBQztBQUNUOztBQUdBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUMsRUFBQUEsV0FBV0EsQ0FBQ0MsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRTtJQUFBLElBVmhDQyxDQUFBQSxZQUFZLEdBQUcsSUFBSSxDQUFBO0lBV2YsSUFBSUgsR0FBRyxZQUFZSSxjQUFjLEVBQUU7TUFDL0JKLEdBQUcsR0FBR0ssY0FBYyxFQUFFLENBQUE7QUFDdEJDLE1BQUFBLEtBQUssQ0FBQ0MsVUFBVSxDQUFDLDRGQUE0RixDQUFDLENBQUE7QUFDbEgsS0FBQTtJQUVBLElBQUksQ0FBQ1AsR0FBRyxHQUFHQSxHQUFHLENBQUE7QUFDZCxJQUFBLElBQUksQ0FBQ1Es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
