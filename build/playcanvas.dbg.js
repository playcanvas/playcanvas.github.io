/**
 * @license
 * PlayCanvas Engine v1.53.4 revision 7d36fcd91 (DEBUG PROFILER)
 * Copyright 2011-2022 PlayCanvas Ltd. All rights reserved.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pc = {}));
})(this, (function (exports) { 'use strict';

	function defineProtoFunc(cls, name, func) {
		if (!cls.prototype[name]) {
			Object.defineProperty(cls.prototype, name, {
				value: func,
				configurable: true,
				enumerable: false,
				writable: true
			});
		}
	}

	defineProtoFunc(Array, 'fill', function (value) {
		if (this == null) {
			throw new TypeError('this is null or not defined');
		}

		var O = Object(this);
		var len = O.length >>> 0;
		var start = arguments[1];
		var relativeStart = start >> 0;
		var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
		var end = arguments[2];
		var relativeEnd = end === undefined ? len : end >> 0;
		var finalValue = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);

		while (k < finalValue) {
			O[k] = value;
			k++;
		}

		return O;
	});

	defineProtoFunc(Array, 'find', function (predicate) {
		if (this == null) {
			throw TypeError('"this" is null or not defined');
		}

		var o = Object(this);
		var len = o.length >>> 0;

		if (typeof predicate !== 'function') {
			throw TypeError('predicate must be a function');
		}

		var thisArg = arguments[1];
		var k = 0;

		while (k < len) {
			var kValue = o[k];

			if (predicate.call(thisArg, kValue, k, o)) {
				return kValue;
			}

			k++;
		}

		return undefined;
	});

	defineProtoFunc(Array, 'findIndex', function (predicate) {
		if (this == null) {
			throw new TypeError('"this" is null or not defined');
		}

		var o = Object(this);
		var len = o.length >>> 0;

		if (typeof predicate !== 'function') {
			throw new TypeError('predicate must be a function');
		}

		var thisArg = arguments[1];
		var k = 0;

		while (k < len) {
			var kValue = o[k];

			if (predicate.call(thisArg, kValue, k, o)) {
				return k;
			}

			k++;
		}

		return -1;
	});

	Math.log2 = Math.log2 || function (x) {
		return Math.log(x) * Math.LOG2E;
	};

	if (!Math.sign) {
		Math.sign = function (x) {
			return (x > 0) - (x < 0) || +x;
		};
	}

	if (Number.isFinite === undefined) Number.isFinite = function (value) {
		return typeof value === 'number' && isFinite(value);
	};

	if (typeof Object.assign != 'function') {
		Object.defineProperty(Object, "assign", {
			value: function assign(target, varArgs) {

				if (target == null) {
					throw new TypeError('Cannot convert undefined or null to object');
				}

				var to = Object(target);

				for (var index = 1; index < arguments.length; index++) {
					var nextSource = arguments[index];

					if (nextSource != null) {
						for (var nextKey in nextSource) {
							if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
								to[nextKey] = nextSource[nextKey];
							}
						}
					}
				}

				return to;
			},
			writable: true,
			configurable: true
		});
	}

	(function () {
		if (typeof navigator === 'undefined' || typeof document === 'undefined') {
			return;
		}

		navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;

		var pointerlockchange = function pointerlockchange() {
			var e = document.createEvent('CustomEvent');
			e.initCustomEvent('pointerlockchange', true, false, null);
			document.dispatchEvent(e);
		};

		var pointerlockerror = function pointerlockerror() {
			var e = document.createEvent('CustomEvent');
			e.initCustomEvent('pointerlockerror', true, false, null);
			document.dispatchEvent(e);
		};

		document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
		document.addEventListener('webkitpointerlocklost', pointerlockchange, false);
		document.addEventListener('mozpointerlockchange', pointerlockchange, false);
		document.addEventListener('mozpointerlocklost', pointerlockchange, false);
		document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
		document.addEventListener('mozpointerlockerror', pointerlockerror, false);

		if (Element.prototype.mozRequestPointerLock) {
			Element.prototype.requestPointerLock = function () {
				this.mozRequestPointerLock();
			};
		} else {
			Element.prototype.requestPointerLock = Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;
		}

		if (!Element.prototype.requestPointerLock && navigator.pointer) {
			Element.prototype.requestPointerLock = function () {
				var el = this;
				document.pointerLockElement = el;
				navigator.pointer.lock(el, pointerlockchange, pointerlockerror);
			};
		}

		document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;

		if (!document.exitPointerLock) {
			document.exitPointerLock = function () {
				if (navigator.pointer) {
					document.pointerLockElement = null;
					navigator.pointer.unlock();
				}
			};
		}
	})();

	(function () {
		if (typeof window === 'undefined') return;
		var lastTime = 0;
		var vendors = ['ms', 'moz', 'webkit', 'o'];

		for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
			window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
			window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
		}

		if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
			var currTime = new Date().getTime();
			var timeToCall = Math.max(0, 16 - (currTime - lastTime));
			var id = window.setTimeout(function () {
				callback(currTime + timeToCall);
			}, timeToCall);
			lastTime = currTime + timeToCall;
			return id;
		};
		if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
			clearTimeout(id);
		};
	})();

	defineProtoFunc(String, 'endsWith', function (search, this_len) {
		if (this_len === undefined || this_len > this.length) {
			this_len = this.length;
		}

		return this.substring(this_len - search.length, this_len) === search;
	});
	defineProtoFunc(String, 'includes', function (search, start) {

		if (typeof start !== 'number') {
			start = 0;
		}

		if (start + search.length > this.length) {
			return false;
		} else {
			return this.indexOf(search, start) !== -1;
		}
	});
	defineProtoFunc(String, 'startsWith', function (search, pos) {
		return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
	});

	var typedArrays = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array];

	for (var _i = 0, _typedArrays = typedArrays; _i < _typedArrays.length; _i++) {
		var typedArray = _typedArrays[_i];
		defineProtoFunc(typedArray, "fill", Array.prototype.fill);
		defineProtoFunc(typedArray, "join", Array.prototype.join);
	}

	var glErrorShadow = {};

	function error(msg) {
		if (window.console && window.console.error) {
			window.console.error(msg);
		}
	}

	function log$1(msg) {
		if (window.console && window.console.log) {
			window.console.log(msg);
		}
	}

	function synthesizeGLError(err, opt_msg) {
		glErrorShadow[err] = true;

		if (opt_msg !== undefined) {
			error(opt_msg);
		}
	}

	function wrapGLError(gl) {
		var f = gl.getError;

		gl.getError = function () {
			var err;

			do {
				err = f.apply(gl);

				if (err != gl.NO_ERROR) {
					glErrorShadow[err] = true;
				}
			} while (err != gl.NO_ERROR);

			for (var err in glErrorShadow) {
				if (glErrorShadow[err]) {
					delete glErrorShadow[err];
					return parseInt(err);
				}
			}

			return gl.NO_ERROR;
		};
	}

	var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
		var gl = ext.gl;
		this.ext = ext;
		this.isAlive = true;
		this.hasBeenBound = false;
		this.elementArrayBuffer = null;
		this.attribs = new Array(ext.maxVertexAttribs);

		for (var n = 0; n < this.attribs.length; n++) {
			var attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
			this.attribs[n] = attrib;
		}

		this.maxAttrib = 0;
	};

	WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
		this.enabled = false;
		this.buffer = null;
		this.size = 4;
		this.type = gl.FLOAT;
		this.normalized = false;
		this.stride = 16;
		this.offset = 0;
		this.cached = "";
		this.recache();
	};

	WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
		this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
	};

	var OESVertexArrayObject = function OESVertexArrayObject(gl) {
		var self = this;
		this.gl = gl;
		wrapGLError(gl);
		var original = this.original = {
			getParameter: gl.getParameter,
			enableVertexAttribArray: gl.enableVertexAttribArray,
			disableVertexAttribArray: gl.disableVertexAttribArray,
			bindBuffer: gl.bindBuffer,
			getVertexAttrib: gl.getVertexAttrib,
			vertexAttribPointer: gl.vertexAttribPointer
		};

		gl.getParameter = function getParameter(pname) {
			if (pname == self.VERTEX_ARRAY_BINDING_OES) {
				if (self.currentVertexArrayObject == self.defaultVertexArrayObject) {
					return null;
				} else {
					return self.currentVertexArrayObject;
				}
			}

			return original.getParameter.apply(this, arguments);
		};

		gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
			var vao = self.currentVertexArrayObject;
			vao.maxAttrib = Math.max(vao.maxAttrib, index);
			var attrib = vao.attribs[index];
			attrib.enabled = true;
			return original.enableVertexAttribArray.apply(this, arguments);
		};

		gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
			var vao = self.currentVertexArrayObject;
			vao.maxAttrib = Math.max(vao.maxAttrib, index);
			var attrib = vao.attribs[index];
			attrib.enabled = false;
			return original.disableVertexAttribArray.apply(this, arguments);
		};

		gl.bindBuffer = function bindBuffer(target, buffer) {
			switch (target) {
				case gl.ARRAY_BUFFER:
					self.currentArrayBuffer = buffer;
					break;

				case gl.ELEMENT_ARRAY_BUFFER:
					self.currentVertexArrayObject.elementArrayBuffer = buffer;
					break;
			}

			return original.bindBuffer.apply(this, arguments);
		};

		gl.getVertexAttrib = function getVertexAttrib(index, pname) {
			var vao = self.currentVertexArrayObject;
			var attrib = vao.attribs[index];

			switch (pname) {
				case gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
					return attrib.buffer;

				case gl.VERTEX_ATTRIB_ARRAY_ENABLED:
					return attrib.enabled;

				case gl.VERTEX_ATTRIB_ARRAY_SIZE:
					return attrib.size;

				case gl.VERTEX_ATTRIB_ARRAY_STRIDE:
					return attrib.stride;

				case gl.VERTEX_ATTRIB_ARRAY_TYPE:
					return attrib.type;

				case gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:
					return attrib.normalized;

				default:
					return original.getVertexAttrib.apply(this, arguments);
			}
		};

		gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
			var vao = self.currentVertexArrayObject;
			vao.maxAttrib = Math.max(vao.maxAttrib, indx);
			var attrib = vao.attribs[indx];
			attrib.buffer = self.currentArrayBuffer;
			attrib.size = size;
			attrib.type = type;
			attrib.normalized = normalized;
			attrib.stride = stride;
			attrib.offset = offset;
			attrib.recache();
			return original.vertexAttribPointer.apply(this, arguments);
		};

		if (gl.instrumentExtension) {
			gl.instrumentExtension(this, "OES_vertex_array_object");
		}

		gl.canvas.addEventListener('webglcontextrestored', function () {
			log$1("OESVertexArrayObject emulation library context restored");
			self.reset_();
		}, true);
		this.reset_();
	};

	OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85B5;

	OESVertexArrayObject.prototype.reset_ = function reset_() {
		var contextWasLost = this.vertexArrayObjects !== undefined;

		if (contextWasLost) {
			for (var ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
				this.vertexArrayObjects.isAlive = false;
			}
		}

		var gl = this.gl;
		this.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
		this.currentVertexArrayObject = null;
		this.currentArrayBuffer = null;
		this.vertexArrayObjects = [this.defaultVertexArrayObject];
		this.bindVertexArrayOES(null);
	};

	OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
		var arrayObject = new WebGLVertexArrayObjectOES(this);
		this.vertexArrayObjects.push(arrayObject);
		return arrayObject;
	};

	OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
		arrayObject.isAlive = false;
		this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);

		if (this.currentVertexArrayObject == arrayObject) {
			this.bindVertexArrayOES(null);
		}
	};

	OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
		if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
			if (arrayObject.hasBeenBound && arrayObject.ext == this) {
				return true;
			}
		}

		return false;
	};

	OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
		var gl = this.gl;

		if (arrayObject && !arrayObject.isAlive) {
			synthesizeGLError(gl.INVALID_OPERATION, "bindVertexArrayOES: attempt to bind deleted arrayObject");
			return;
		}

		var original = this.original;
		var oldVAO = this.currentVertexArrayObject;
		this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
		this.currentVertexArrayObject.hasBeenBound = true;
		var newVAO = this.currentVertexArrayObject;

		if (oldVAO == newVAO) {
			return;
		}

		if (!oldVAO || newVAO.elementArrayBuffer != oldVAO.elementArrayBuffer) {
			original.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);
		}

		var currentBinding = this.currentArrayBuffer;
		var maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);

		for (var n = 0; n <= maxAttrib; n++) {
			var attrib = newVAO.attribs[n];
			var oldAttrib = oldVAO ? oldVAO.attribs[n] : null;

			if (!oldVAO || attrib.enabled != oldAttrib.enabled) {
				if (attrib.enabled) {
					original.enableVertexAttribArray.call(gl, n);
				} else {
					original.disableVertexAttribArray.call(gl, n);
				}
			}

			if (attrib.enabled) {
				var bufferChanged = false;

				if (!oldVAO || attrib.buffer != oldAttrib.buffer) {
					if (currentBinding != attrib.buffer) {
						original.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer);
						currentBinding = attrib.buffer;
					}

					bufferChanged = true;
				}

				if (bufferChanged || attrib.cached != oldAttrib.cached) {
					original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
				}
			}
		}

		if (this.currentArrayBuffer != currentBinding) {
			original.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer);
		}
	};

	var setupVertexArrayObject = function setupVertexArrayObject(gl) {
		if (gl.getSupportedExtensions) {
			var exts = gl.getSupportedExtensions();

			if (exts.indexOf("OES_vertex_array_object") != -1) {
				return;
			}
		} else if (gl.getExtension) {
			var vao = gl.getExtension("OES_vertex_array_object");

			if (vao) {
				return;
			}
		}

		if (gl.getSupportedExtensions) {
			var original_getSupportedExtensions = gl.getSupportedExtensions;

			gl.getSupportedExtensions = function getSupportedExtensions() {
				var list = original_getSupportedExtensions.call(this) || [];
				list.push("OES_vertex_array_object");
				return list;
			};
		}

		var original_getExtension = gl.getExtension;

		gl.getExtension = function getExtension(name) {
			if (name == "OES_vertex_array_object") {
				if (!gl.__OESVertexArrayObject) {
					gl.__OESVertexArrayObject = new OESVertexArrayObject(gl);
				}

				return gl.__OESVertexArrayObject;
			}

			if (original_getExtension) {
				return original_getExtension.call(this, name);
			} else {
				return null;
			}
		};
	};

	var version = "1.53.4";
	var revision = "7d36fcd91";
	var config = {};
	var common = {};
	var apps = {};
	var data = {};

	var _typeLookup = function () {
		var result = {};
		var names = ["Array", "Object", "Function", "Date", "RegExp", "Float32Array"];

		for (var i = 0; i < names.length; i++) {
			result["[object " + names[i] + "]"] = names[i].toLowerCase();
		}

		return result;
	}();

	function type$1(obj) {
		if (obj === null) {
			return "null";
		}

		var type = typeof obj;

		if (type === "undefined" || type === "number" || type === "string" || type === "boolean") {
			return type;
		}

		return _typeLookup[Object.prototype.toString.call(obj)];
	}

	function extend(target, ex) {
		for (var prop in ex) {
			var copy = ex[prop];

			if (type$1(copy) === "object") {
				target[prop] = extend({}, copy);
			} else if (type$1(copy) === "array") {
				target[prop] = extend([], copy);
			} else {
				target[prop] = copy;
			}
		}

		return target;
	}

	function isDefined(o) {
		var a;
		return o !== a;
	}

	var EventHandler = function () {
		function EventHandler() {
			this._callbacks = {};
			this._callbackActive = {};
		}

		var _proto = EventHandler.prototype;

		_proto.initEventHandler = function initEventHandler() {
			this._callbacks = {};
			this._callbackActive = {};
		};

		_proto._addCallback = function _addCallback(name, callback, scope, once) {
			if (once === void 0) {
				once = false;
			}

			if (!name || typeof name !== 'string' || !callback) return;
			if (!this._callbacks[name]) this._callbacks[name] = [];
			if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();

			this._callbacks[name].push({
				callback: callback,
				scope: scope || this,
				once: once
			});
		};

		_proto.on = function on(name, callback, scope) {
			this._addCallback(name, callback, scope, false);

			return this;
		};

		_proto.off = function off(name, callback, scope) {
			if (name) {
				if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();
			} else {
				for (var key in this._callbackActive) {
					if (!this._callbacks[key]) continue;
					if (this._callbacks[key] !== this._callbackActive[key]) continue;
					this._callbackActive[key] = this._callbackActive[key].slice();
				}
			}

			if (!name) {
				this._callbacks = {};
			} else if (!callback) {
				if (this._callbacks[name]) this._callbacks[name] = [];
			} else {
				var events = this._callbacks[name];
				if (!events) return this;
				var count = events.length;

				for (var i = 0; i < count; i++) {
					if (events[i].callback !== callback) continue;
					if (scope && events[i].scope !== scope) continue;
					events[i--] = events[--count];
				}

				events.length = count;
			}

			return this;
		};

		_proto.fire = function fire(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
			if (!name || !this._callbacks[name]) return this;
			var callbacks;

			if (!this._callbackActive[name]) {
				this._callbackActive[name] = this._callbacks[name];
			} else {
				if (this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();
				callbacks = this._callbacks[name].slice();
			}

			for (var i = 0; (callbacks || this._callbackActive[name]) && i < (callbacks || this._callbackActive[name]).length; i++) {
				var evt = (callbacks || this._callbackActive[name])[i];
				evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);

				if (evt.once) {
					var existingCallback = this._callbacks[name];
					var ind = existingCallback ? existingCallback.indexOf(evt) : -1;

					if (ind !== -1) {
						if (this._callbackActive[name] === existingCallback) this._callbackActive[name] = this._callbackActive[name].slice();

						this._callbacks[name].splice(ind, 1);
					}
				}
			}

			if (!callbacks) this._callbackActive[name] = null;
			return this;
		};

		_proto.once = function once(name, callback, scope) {
			this._addCallback(name, callback, scope, true);

			return this;
		};

		_proto.hasEvent = function hasEvent(name) {
			return this._callbacks[name] && this._callbacks[name].length !== 0 || false;
		};

		return EventHandler;
	}();

	var events = {
		attach: function attach(target) {
			var ev = events;
			target._addCallback = ev._addCallback;
			target.on = ev.on;
			target.off = ev.off;
			target.fire = ev.fire;
			target.once = ev.once;
			target.hasEvent = ev.hasEvent;
			target._callbacks = {};
			target._callbackActive = {};
			return target;
		},
		_addCallback: EventHandler.prototype._addCallback,
		on: EventHandler.prototype.on,
		off: EventHandler.prototype.off,
		fire: EventHandler.prototype.fire,
		once: EventHandler.prototype.once,
		hasEvent: EventHandler.prototype.hasEvent
	};

	var guid = {
		create: function create() {
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
				var r = Math.random() * 16 | 0;
				var v = c === 'x' ? r : r & 0x3 | 0x8;
				return v.toString(16);
			});
		}
	};

	var path = {
		delimiter: "/",
		join: function join() {
			var num = arguments.length;
			var result = arguments[0];

			for (var index = 0; index < num - 1; ++index) {
				var one = arguments[index];
				var two = arguments[index + 1];

				if (!isDefined(one) || !isDefined(two)) {
					throw new Error("undefined argument to pc.path.join");
				}

				if (two[0] === path.delimiter) {
					result = two;
					continue;
				}

				if (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {
					result += path.delimiter + two;
				} else {
					result += two;
				}
			}

			return result;
		},
		normalize: function normalize(pathname) {
			var lead = pathname.startsWith(path.delimiter);
			var trail = pathname.endsWith(path.delimiter);
			var parts = pathname.split('/');
			var result = '';
			var cleaned = [];

			for (var i = 0; i < parts.length; i++) {
				if (parts[i] === '') continue;
				if (parts[i] === '.') continue;

				if (parts[i] === '..' && cleaned.length > 0) {
					cleaned = cleaned.slice(0, cleaned.length - 2);
					continue;
				}

				if (i > 0) cleaned.push(path.delimiter);
				cleaned.push(parts[i]);
			}

			result = cleaned.join('');

			if (!lead && result[0] === path.delimiter) {
				result = result.slice(1);
			}

			if (trail && result[result.length - 1] !== path.delimiter) {
				result += path.delimiter;
			}

			return result;
		},
		split: function split(pathname) {
			var parts = pathname.split(path.delimiter);
			var tail = parts.slice(parts.length - 1)[0];
			var head = parts.slice(0, parts.length - 1).join(path.delimiter);
			return [head, tail];
		},
		getBasename: function getBasename(pathname) {
			return path.split(pathname)[1];
		},
		getDirectory: function getDirectory(pathname) {
			var parts = pathname.split(path.delimiter);
			return parts.slice(0, parts.length - 1).join(path.delimiter);
		},
		getExtension: function getExtension(pathname) {
			var ext = pathname.split('?')[0].split('.').pop();

			if (ext !== pathname) {
				return "." + ext;
			}

			return "";
		},
		isRelativePath: function isRelativePath(pathname) {
			return pathname.charAt(0) !== "/" && pathname.match(/:\/\//) === null;
		},
		extractPath: function extractPath(pathname) {
			var result = "";
			var parts = pathname.split("/");
			var i = 0;

			if (parts.length > 1) {
				if (path.isRelativePath(pathname)) {
					if (parts[0] === ".") {
						for (i = 0; i < parts.length - 1; ++i) {
							result += i === 0 ? parts[i] : "/" + parts[i];
						}
					} else if (parts[0] === "..") {
						for (i = 0; i < parts.length - 1; ++i) {
							result += i === 0 ? parts[i] : "/" + parts[i];
						}
					} else {
						result = ".";

						for (i = 0; i < parts.length - 1; ++i) {
							result += "/" + parts[i];
						}
					}
				} else {
					for (i = 0; i < parts.length - 1; ++i) {
						result += i === 0 ? parts[i] : "/" + parts[i];
					}
				}
			}

			return result;
		}
	};

	var desktop = false;
	var mobile = false;
	var windows = false;
	var xbox = false;
	var android = false;
	var ios = false;
	var touch = false;
	var gamepads = false;
	var workers = false;
	var passiveEvents = false;

	if (typeof navigator !== 'undefined') {
		var ua = navigator.userAgent;
		if (/(windows|mac os|linux|cros)/i.test(ua)) desktop = true;
		if (/xbox/i.test(ua)) xbox = true;

		if (/(windows phone|iemobile|wpdesktop)/i.test(ua)) {
			desktop = false;
			mobile = true;
			windows = true;
		} else if (/android/i.test(ua)) {
			desktop = false;
			mobile = true;
			android = true;
		} else if (/ip([ao]d|hone)/i.test(ua)) {
			desktop = false;
			mobile = true;
			ios = true;
		}

		if (typeof window !== 'undefined') {
			touch = 'ontouchstart' in window || 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0;
		}

		gamepads = 'getGamepads' in navigator;
		workers = typeof Worker !== 'undefined';

		try {
			var opts = Object.defineProperty({}, 'passive', {
				get: function get() {
					passiveEvents = true;
					return false;
				}
			});
			window.addEventListener("testpassive", null, opts);
			window.removeEventListener("testpassive", null, opts);
		} catch (e) {}
	}

	var environment = typeof window !== 'undefined' ? 'browser' : 'node';
	var platform = {
		environment: environment,
		global: environment === 'browser' ? window : global,
		browser: environment === 'browser',
		desktop: desktop,
		mobile: mobile,
		ios: ios,
		android: android,
		windows: windows,
		xbox: xbox,
		gamepads: gamepads,
		touch: touch,
		workers: workers,
		passiveEvents: passiveEvents
	};

	var ASCII_LOWERCASE = "abcdefghijklmnopqrstuvwxyz";
	var ASCII_UPPERCASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	var ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;
	var HIGH_SURROGATE_BEGIN = 0xD800;
	var HIGH_SURROGATE_END = 0xDBFF;
	var LOW_SURROGATE_BEGIN = 0xDC00;
	var LOW_SURROGATE_END = 0xDFFF;
	var ZERO_WIDTH_JOINER = 0x200D;
	var REGIONAL_INDICATOR_BEGIN = 0x1F1E6;
	var REGIONAL_INDICATOR_END = 0x1F1FF;
	var FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;
	var FITZPATRICK_MODIFIER_END = 0x1F3FF;
	var DIACRITICAL_MARKS_BEGIN = 0x20D0;
	var DIACRITICAL_MARKS_END = 0x20FF;
	var VARIATION_MODIFIER_BEGIN = 0xFE00;
	var VARIATION_MODIFIER_END = 0xFE0F;

	function getCodePointData(string, i) {
		if (i === void 0) {
			i = 0;
		}

		var size = string.length;

		if (i < 0 || i >= size) {
			return null;
		}

		var first = string.charCodeAt(i);

		if (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {
			var second = string.charCodeAt(i + 1);

			if (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {
				return {
					code: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000,
					long: true
				};
			}
		}

		return {
			code: first,
			long: false
		};
	}

	function isCodeBetween(string, begin, end) {
		if (!string) return false;
		var codeData = getCodePointData(string);

		if (codeData) {
			var code = codeData.code;
			return code >= begin && code <= end;
		}

		return false;
	}

	function numCharsToTakeForNextSymbol(string, index) {
		if (index === string.length - 1) {
			return 1;
		}

		if (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {
			var first = string.substring(index, index + 2);
			var second = string.substring(index + 2, index + 4);

			if (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {
				return 4;
			}

			if (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
				return 3;
			}

			return 2;
		}

		if (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
			return 2;
		}

		return 1;
	}

	var string = {
		ASCII_LOWERCASE: ASCII_LOWERCASE,
		ASCII_UPPERCASE: ASCII_UPPERCASE,
		ASCII_LETTERS: ASCII_LETTERS,
		format: function format(s) {
			for (var i = 1; i < arguments.length; i++) {
				s = s.replace('{' + (i - 1) + '}', arguments[i]);
			}

			return s;
		},
		toBool: function toBool(s, strict) {
			if (strict === void 0) {
				strict = false;
			}

			if (s === 'true') {
				return true;
			}

			if (strict) {
				if (s === 'false') {
					return false;
				}

				throw new TypeError('Not a boolean string');
			}

			return false;
		},
		getCodePoint: function getCodePoint(string, i) {
			var codePointData = getCodePointData(string, i);
			return codePointData && codePointData.code;
		},
		getCodePoints: function getCodePoints(string) {
			if (typeof string !== 'string') {
				throw new TypeError('Not a string');
			}

			var i = 0;
			var arr = [];
			var codePoint;

			while (!!(codePoint = getCodePointData(string, i))) {
				arr.push(codePoint.code);
				i += codePoint.long ? 2 : 1;
			}

			return arr;
		},
		getSymbols: function getSymbols(string) {
			if (typeof string !== 'string') {
				throw new TypeError('Not a string');
			}

			var index = 0;
			var length = string.length;
			var output = [];
			var take = 0;
			var ch;

			while (index < length) {
				take += numCharsToTakeForNextSymbol(string, index + take);
				ch = string[index + take];

				if (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {
					ch = string[index + take++];
				}

				if (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
					ch = string[index + take++];
				}

				if (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {
					ch = string[index + take++];
					continue;
				}

				var char = string.substring(index, index + take);
				output.push(char);
				index += take;
				take = 0;
			}

			return output;
		},
		fromCodePoint: function fromCodePoint() {
			var chars = [];
			var current;
			var codePoint;
			var units;

			for (var i = 0; i < arguments.length; ++i) {
				current = Number(arguments[i]);
				codePoint = current - 0x10000;
				units = current > 0xFFFF ? [(codePoint >> 10) + 0xD800, codePoint % 0x400 + 0xDC00] : [current];
				chars.push(String.fromCharCode.apply(null, units));
			}

			return chars.join('');
		}
	};

	var IndexedList = function () {
		function IndexedList() {
			this._list = [];
			this._index = {};
		}

		var _proto = IndexedList.prototype;

		_proto.push = function push(key, item) {
			if (this._index[key]) {
				throw Error("Key already in index " + key);
			}

			var location = this._list.push(item) - 1;
			this._index[key] = location;
		};

		_proto.has = function has(key) {
			return this._index[key] !== undefined;
		};

		_proto.get = function get(key) {
			var location = this._index[key];

			if (location !== undefined) {
				return this._list[location];
			}

			return null;
		};

		_proto.remove = function remove(key) {
			var location = this._index[key];

			if (location !== undefined) {
				this._list.splice(location, 1);

				delete this._index[key];

				for (key in this._index) {
					var idx = this._index[key];

					if (idx > location) {
						this._index[key] = idx - 1;
					}
				}

				return true;
			}

			return false;
		};

		_proto.list = function list() {
			return this._list;
		};

		_proto.clear = function clear() {
			this._list.length = 0;

			for (var prop in this._index) {
				delete this._index[prop];
			}
		};

		return IndexedList;
	}();

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  Object.defineProperty(Constructor, "prototype", {
	    writable: false
	  });
	  return Constructor;
	}

	function _extends() {
	  _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;

	  _setPrototypeOf(subClass, superClass);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _createForOfIteratorHelperLoose(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
	  if (it) return (it = it.call(o)).next.bind(it);

	  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	    if (it) o = it;
	    var i = 0;
	    return function () {
	      if (i >= o.length) return {
	        done: true
	      };
	      return {
	        done: false,
	        value: o[i++]
	      };
	    };
	  }

	  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	var ReadStream = function () {
		function ReadStream(arraybuffer) {
			this.arraybuffer = arraybuffer;
			this.dataView = new DataView(arraybuffer);
			this.offset = 0;
			this.stack = [];
		}

		var _proto = ReadStream.prototype;

		_proto.reset = function reset(offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this.offset = offset;
		};

		_proto.skip = function skip(bytes) {
			this.offset += bytes;
		};

		_proto.align = function align(bytes) {
			this.offset = this.offset + bytes - 1 & ~(bytes - 1);
		};

		_proto._inc = function _inc(amount) {
			this.offset += amount;
			return this.offset - amount;
		};

		_proto.readChar = function readChar() {
			return String.fromCharCode(this.dataView.getUint8(this.offset++));
		};

		_proto.readChars = function readChars(numChars) {
			var result = '';

			for (var i = 0; i < numChars; ++i) {
				result += this.readChar();
			}

			return result;
		};

		_proto.readU8 = function readU8() {
			return this.dataView.getUint8(this.offset++);
		};

		_proto.readU16 = function readU16() {
			return this.dataView.getUint16(this._inc(2), true);
		};

		_proto.readU32 = function readU32() {
			return this.dataView.getUint32(this._inc(4), true);
		};

		_proto.readU64 = function readU64() {
			return this.readU32() + Math.pow(2, 32) * this.readU32();
		};

		_proto.readU32be = function readU32be() {
			return this.dataView.getUint32(this._inc(4), false);
		};

		_proto.readArray = function readArray(result) {
			for (var i = 0; i < result.length; ++i) {
				result[i] = this.readU8();
			}
		};

		_proto.readLine = function readLine() {
			var view = this.dataView;
			var result = "";

			while (true) {
				if (this.offset >= view.byteLength) {
					break;
				}

				var c = String.fromCharCode(this.readU8());

				if (c === '\n') {
					break;
				}

				result += c;
			}

			return result;
		};

		_createClass(ReadStream, [{
			key: "remainingBytes",
			get: function get() {
				return this.dataView.byteLength - this.offset;
			}
		}]);

		return ReadStream;
	}();

	var SortedLoopArray = function () {
		function SortedLoopArray(args) {
			this.items = [];
			this.length = 0;
			this.loopIndex = -1;
			this._sortBy = args.sortBy;
			this._sortHandler = this._doSort.bind(this);
		}

		var _proto = SortedLoopArray.prototype;

		_proto._binarySearch = function _binarySearch(item) {
			var left = 0;
			var right = this.items.length - 1;
			var search = item[this._sortBy];
			var middle;
			var current;

			while (left <= right) {
				middle = Math.floor((left + right) / 2);
				current = this.items[middle][this._sortBy];

				if (current <= search) {
					left = middle + 1;
				} else if (current > search) {
					right = middle - 1;
				}
			}

			return left;
		};

		_proto._doSort = function _doSort(a, b) {
			var sortBy = this._sortBy;
			return a[sortBy] - b[sortBy];
		};

		_proto.insert = function insert(item) {
			var index = this._binarySearch(item);

			this.items.splice(index, 0, item);
			this.length++;

			if (this.loopIndex >= index) {
				this.loopIndex++;
			}
		};

		_proto.append = function append(item) {
			this.items.push(item);
			this.length++;
		};

		_proto.remove = function remove(item) {
			var idx = this.items.indexOf(item);
			if (idx < 0) return;
			this.items.splice(idx, 1);
			this.length--;

			if (this.loopIndex >= idx) {
				this.loopIndex--;
			}
		};

		_proto.sort = function sort() {
			var current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
			this.items.sort(this._sortHandler);

			if (current !== null) {
				this.loopIndex = this.items.indexOf(current);
			}
		};

		return SortedLoopArray;
	}();

	var Tags = function (_EventHandler) {
		_inheritsLoose(Tags, _EventHandler);

		function Tags(parent) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._index = {};
			_this._list = [];
			_this._parent = parent;
			return _this;
		}

		var _proto = Tags.prototype;

		_proto.add = function add() {
			var changed = false;

			var tags = this._processArguments(arguments, true);

			if (!tags.length) return changed;

			for (var i = 0; i < tags.length; i++) {
				if (this._index[tags[i]]) continue;
				changed = true;
				this._index[tags[i]] = true;

				this._list.push(tags[i]);

				this.fire('add', tags[i], this._parent);
			}

			if (changed) this.fire('change', this._parent);
			return changed;
		};

		_proto.remove = function remove() {
			var changed = false;
			if (!this._list.length) return changed;

			var tags = this._processArguments(arguments, true);

			if (!tags.length) return changed;

			for (var i = 0; i < tags.length; i++) {
				if (!this._index[tags[i]]) continue;
				changed = true;
				delete this._index[tags[i]];

				this._list.splice(this._list.indexOf(tags[i]), 1);

				this.fire('remove', tags[i], this._parent);
			}

			if (changed) this.fire('change', this._parent);
			return changed;
		};

		_proto.clear = function clear() {
			if (!this._list.length) return;

			var tags = this._list.slice(0);

			this._list = [];
			this._index = {};

			for (var i = 0; i < tags.length; i++) {
				this.fire('remove', tags[i], this._parent);
			}

			this.fire('change', this._parent);
		};

		_proto.has = function has() {
			if (!this._list.length) return false;
			return this._has(this._processArguments(arguments));
		};

		_proto._has = function _has(tags) {
			if (!this._list.length || !tags.length) return false;

			for (var i = 0; i < tags.length; i++) {
				if (tags[i].length === 1) {
					if (this._index[tags[i][0]]) return true;
				} else {
					var multiple = true;

					for (var t = 0; t < tags[i].length; t++) {
						if (this._index[tags[i][t]]) continue;
						multiple = false;
						break;
					}

					if (multiple) return true;
				}
			}

			return false;
		};

		_proto.list = function list() {
			return this._list.slice(0);
		};

		_proto._processArguments = function _processArguments(args, flat) {
			var tags = [];
			var tmp = [];
			if (!args || !args.length) return tags;

			for (var i = 0; i < args.length; i++) {
				if (args[i] instanceof Array) {
					if (!flat) tmp = [];

					for (var t = 0; t < args[i].length; t++) {
						if (typeof args[i][t] !== 'string') continue;

						if (flat) {
							tags.push(args[i][t]);
						} else {
							tmp.push(args[i][t]);
						}
					}

					if (!flat && tmp.length) tags.push(tmp);
				} else if (typeof args[i] === 'string') {
					if (flat) {
						tags.push(args[i]);
					} else {
						tags.push([args[i]]);
					}
				}
			}

			return tags;
		};

		_createClass(Tags, [{
			key: "size",
			get: function get() {
				return this._list.length;
			}
		}]);

		return Tags;
	}(EventHandler);

	var now = typeof window !== 'undefined' && window.performance && window.performance.now && window.performance.timing ? function () {
		return window.performance.now();
	} : Date.now;

	var Timer = function () {
		function Timer() {
			this._isRunning = false;
			this._a = 0;
			this._b = 0;
		}

		var _proto = Timer.prototype;

		_proto.start = function start() {
			this._isRunning = true;
			this._a = now();
		};

		_proto.stop = function stop() {
			this._isRunning = false;
			this._b = now();
		};

		_proto.getMilliseconds = function getMilliseconds() {
			return this._b - this._a;
		};

		return Timer;
	}();

	function createURI(options) {
		var s = "";

		if ((options.authority || options.scheme) && (options.host || options.hostpath)) {
			throw new Error("Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option");
		}

		if (options.host && options.hostpath) {
			throw new Error("Can't have 'host' and 'hostpath' option");
		}

		if (options.path && options.hostpath) {
			throw new Error("Can't have 'path' and 'hostpath' option");
		}

		if (options.scheme) {
			s += options.scheme + ":";
		}

		if (options.authority) {
			s += "//" + options.authority;
		}

		if (options.host) {
			s += options.host;
		}

		if (options.path) {
			s += options.path;
		}

		if (options.hostpath) {
			s += options.hostpath;
		}

		if (options.query) {
			s += "?" + options.query;
		}

		if (options.fragment) {
			s += "#" + options.fragment;
		}

		return s;
	}

	var re = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;

	var URI = function () {
		function URI(uri) {
			var result = uri.match(re);
			this.scheme = result[2];
			this.authority = result[4];
			this.path = result[5];
			this.query = result[7];
			this.fragment = result[9];
		}

		var _proto = URI.prototype;

		_proto.toString = function toString() {
			var s = "";

			if (this.scheme) {
				s += this.scheme + ":";
			}

			if (this.authority) {
				s += "//" + this.authority;
			}

			s += this.path;

			if (this.query) {
				s += "?" + this.query;
			}

			if (this.fragment) {
				s += "#" + this.fragment;
			}

			return s;
		};

		_proto.getQuery = function getQuery() {
			var result = {};

			if (this.query) {
				var queryParams = decodeURIComponent(this.query).split("&");

				for (var _iterator = _createForOfIteratorHelperLoose(queryParams), _step; !(_step = _iterator()).done;) {
					var queryParam = _step.value;
					var pair = queryParam.split("=");
					result[pair[0]] = pair[1];
				}
			}

			return result;
		};

		_proto.setQuery = function setQuery(params) {
			var q = "";

			for (var key in params) {
				if (params.hasOwnProperty(key)) {
					if (q !== "") {
						q += "&";
					}

					q += encodeURIComponent(key) + "=" + encodeURIComponent(params[key]);
				}
			}

			this.query = q;
		};

		return URI;
	}();

	var math = {
		DEG_TO_RAD: Math.PI / 180,
		RAD_TO_DEG: 180 / Math.PI,
		clamp: function clamp(value, min, max) {
			if (value >= max) return max;
			if (value <= min) return min;
			return value;
		},
		intToBytes24: function intToBytes24(i) {
			var r = i >> 16 & 0xff;
			var g = i >> 8 & 0xff;
			var b = i & 0xff;
			return [r, g, b];
		},
		intToBytes32: function intToBytes32(i) {
			var r = i >> 24 & 0xff;
			var g = i >> 16 & 0xff;
			var b = i >> 8 & 0xff;
			var a = i & 0xff;
			return [r, g, b, a];
		},
		bytesToInt24: function bytesToInt24(r, g, b) {
			if (r.length) {
				b = r[2];
				g = r[1];
				r = r[0];
			}

			return r << 16 | g << 8 | b;
		},
		bytesToInt32: function bytesToInt32(r, g, b, a) {
			if (r.length) {
				a = r[3];
				b = r[2];
				g = r[1];
				r = r[0];
			}

			return (r << 24 | g << 16 | b << 8 | a) >>> 0;
		},
		lerp: function lerp(a, b, alpha) {
			return a + (b - a) * math.clamp(alpha, 0, 1);
		},
		lerpAngle: function lerpAngle(a, b, alpha) {
			if (b - a > 180) {
				b -= 360;
			}

			if (b - a < -180) {
				b += 360;
			}

			return math.lerp(a, b, math.clamp(alpha, 0, 1));
		},
		powerOfTwo: function powerOfTwo(x) {
			return x !== 0 && !(x & x - 1);
		},
		nextPowerOfTwo: function nextPowerOfTwo(val) {
			val--;
			val |= val >> 1;
			val |= val >> 2;
			val |= val >> 4;
			val |= val >> 8;
			val |= val >> 16;
			val++;
			return val;
		},
		random: function random(min, max) {
			var diff = max - min;
			return Math.random() * diff + min;
		},
		smoothstep: function smoothstep(min, max, x) {
			if (x <= min) return 0;
			if (x >= max) return 1;
			x = (x - min) / (max - min);
			return x * x * (3 - 2 * x);
		},
		smootherstep: function smootherstep(min, max, x) {
			if (x <= min) return 0;
			if (x >= max) return 1;
			x = (x - min) / (max - min);
			return x * x * x * (x * (x * 6 - 15) + 10);
		},
		roundUp: function roundUp(numToRound, multiple) {
			if (multiple === 0) return numToRound;
			return Math.ceil(numToRound / multiple) * multiple;
		},
		between: function between(num, a, b, inclusive) {
			var min = Math.min(a, b);
			var max = Math.max(a, b);
			return inclusive ? num >= min && num <= max : num > min && num < max;
		}
	};

	var Http = function () {
		function Http() {}

		var _proto = Http.prototype;

		_proto.get = function get(url, options, callback) {
			if (typeof options === "function") {
				callback = options;
				options = {};
			}

			return this.request("GET", url, options, callback);
		};

		_proto.post = function post(url, data, options, callback) {
			if (typeof options === "function") {
				callback = options;
				options = {};
			}

			options.postdata = data;
			return this.request("POST", url, options, callback);
		};

		_proto.put = function put(url, data, options, callback) {
			if (typeof options === "function") {
				callback = options;
				options = {};
			}

			options.postdata = data;
			return this.request("PUT", url, options, callback);
		};

		_proto.del = function del(url, options, callback) {
			if (typeof options === "function") {
				callback = options;
				options = {};
			}

			return this.request("DELETE", url, options, callback);
		};

		_proto.request = function request(method, url, options, callback) {
			var _this = this;

			var uri, query, postdata;
			var errored = false;

			if (typeof options === "function") {
				callback = options;
				options = {};
			}

			if (options.retry) {
				options = Object.assign({
					retries: 0,
					maxRetries: 5
				}, options);
			}

			options.callback = callback;

			if (options.async == null) {
				options.async = true;
			}

			if (options.headers == null) {
				options.headers = {};
			}

			if (options.postdata != null) {
				if (options.postdata instanceof Document) {
					postdata = options.postdata;
				} else if (options.postdata instanceof FormData) {
					postdata = options.postdata;
				} else if (options.postdata instanceof Object) {
					var contentType = options.headers["Content-Type"];

					if (contentType === undefined) {
						options.headers["Content-Type"] = Http.ContentType.FORM_URLENCODED;
						contentType = options.headers["Content-Type"];
					}

					switch (contentType) {
						case Http.ContentType.FORM_URLENCODED:
							{
								postdata = "";
								var bFirstItem = true;

								for (var key in options.postdata) {
									if (options.postdata.hasOwnProperty(key)) {
										if (bFirstItem) {
											bFirstItem = false;
										} else {
											postdata += "&";
										}

										var encodedKey = encodeURIComponent(key);
										var encodedValue = encodeURIComponent(options.postdata[key]);
										postdata += encodedKey + "=" + encodedValue;
									}
								}

								break;
							}

						default:
						case Http.ContentType.JSON:
							if (contentType == null) {
								options.headers["Content-Type"] = Http.ContentType.JSON;
							}

							postdata = JSON.stringify(options.postdata);
							break;
					}
				} else {
					postdata = options.postdata;
				}
			}

			if (options.cache === false) {
				var timestamp = now();
				uri = new URI(url);

				if (!uri.query) {
					uri.query = "ts=" + timestamp;
				} else {
					uri.query = uri.query + "&ts=" + timestamp;
				}

				url = uri.toString();
			}

			if (options.query) {
				uri = new URI(url);
				query = extend(uri.getQuery(), options.query);
				uri.setQuery(query);
				url = uri.toString();
			}

			var xhr = new XMLHttpRequest();
			xhr.open(method, url, options.async);
			xhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;
			xhr.responseType = options.responseType || this._guessResponseType(url);

			for (var header in options.headers) {
				if (options.headers.hasOwnProperty(header)) {
					xhr.setRequestHeader(header, options.headers[header]);
				}
			}

			xhr.onreadystatechange = function () {
				_this._onReadyStateChange(method, url, options, xhr);
			};

			xhr.onerror = function () {
				_this._onError(method, url, options, xhr);

				errored = true;
			};

			try {
				xhr.send(postdata);
			} catch (e) {
				if (!errored) {
					options.error(xhr.status, xhr, e);
				}
			}

			return xhr;
		};

		_proto._guessResponseType = function _guessResponseType(url) {
			var uri = new URI(url);
			var ext = path.getExtension(uri.path);

			if (Http.binaryExtensions.indexOf(ext) >= 0) {
				return Http.ResponseType.ARRAY_BUFFER;
			}

			if (ext === ".xml") {
				return Http.ResponseType.DOCUMENT;
			}

			return Http.ResponseType.TEXT;
		};

		_proto._isBinaryContentType = function _isBinaryContentType(contentType) {
			var binTypes = [Http.ContentType.MP4, Http.ContentType.WAV, Http.ContentType.OGG, Http.ContentType.MP3, Http.ContentType.BIN, Http.ContentType.DDS, Http.ContentType.BASIS, Http.ContentType.GLB];

			if (binTypes.indexOf(contentType) >= 0) {
				return true;
			}

			return false;
		};

		_proto._onReadyStateChange = function _onReadyStateChange(method, url, options, xhr) {
			if (xhr.readyState === 4) {
				switch (xhr.status) {
					case 0:
						{
							if (xhr.responseURL && xhr.responseURL.startsWith('file:///')) {
								this._onSuccess(method, url, options, xhr);
							} else {
								this._onError(method, url, options, xhr);
							}

							break;
						}

					case 200:
					case 201:
					case 206:
					case 304:
						{
							this._onSuccess(method, url, options, xhr);

							break;
						}

					default:
						{
							this._onError(method, url, options, xhr);

							break;
						}
				}
			}
		};

		_proto._onSuccess = function _onSuccess(method, url, options, xhr) {
			var response;
			var contentType;
			var header = xhr.getResponseHeader("Content-Type");

			if (header) {
				var parts = header.split(";");
				contentType = parts[0].trim();
			}

			try {
				if (contentType === Http.ContentType.JSON || url.split('?')[0].endsWith(".json")) {
					response = JSON.parse(xhr.responseText);
				} else if (this._isBinaryContentType(contentType)) {
					response = xhr.response;
				} else {
					if (contentType) {
						console.warn("responseType: " + xhr.responseType + " being served with Content-Type: " + contentType);
					}

					if (xhr.responseType === Http.ResponseType.ARRAY_BUFFER) {
						response = xhr.response;
					} else if (xhr.responseType === Http.ResponseType.BLOB || xhr.responseType === Http.ResponseType.JSON) {
						response = xhr.response;
					} else {
						if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === Http.ContentType.XML) {
							response = xhr.responseXML;
						} else {
							response = xhr.responseText;
						}
					}
				}

				options.callback(null, response);
			} catch (err) {
				options.callback(err);
			}
		};

		_proto._onError = function _onError(method, url, options, xhr) {
			var _this2 = this;

			if (options.retrying) {
				return;
			}

			if (options.retry && options.retries < options.maxRetries) {
				options.retries++;
				options.retrying = true;
				var retryDelay = math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);
				console.log(method + ": " + url + " - Error " + xhr.status + ". Retrying in " + retryDelay + " ms");
				setTimeout(function () {
					options.retrying = false;

					_this2.request(method, url, options, options.callback);
				}, retryDelay);
			} else {
				options.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);
			}
		};

		return Http;
	}();

	Http.ContentType = {
		FORM_URLENCODED: "application/x-www-form-urlencoded",
		GIF: "image/gif",
		JPEG: "image/jpeg",
		DDS: "image/dds",
		JSON: "application/json",
		PNG: "image/png",
		TEXT: "text/plain",
		XML: "application/xml",
		WAV: "audio/x-wav",
		OGG: "audio/ogg",
		MP3: "audio/mpeg",
		MP4: "audio/mp4",
		AAC: "audio/aac",
		BIN: "application/octet-stream",
		BASIS: "image/basis",
		GLB: "model/gltf-binary"
	};
	Http.ResponseType = {
		TEXT: 'text',
		ARRAY_BUFFER: 'arraybuffer',
		BLOB: 'blob',
		DOCUMENT: 'document',
		JSON: 'json'
	};
	Http.binaryExtensions = ['.model', '.wav', '.ogg', '.mp3', '.mp4', '.m4a', '.aac', '.dds', '.basis', '.glb'];
	Http.retryDelay = 100;
	var http = new Http();

	var CURVE_LINEAR = 0;
	var CURVE_SMOOTHSTEP = 1;
	var CURVE_CATMULL = 2;
	var CURVE_CARDINAL = 3;
	var CURVE_SPLINE = 4;
	var CURVE_STEP = 5;

	var Color = function () {
		function Color(r, g, b, a) {
			if (r === void 0) {
				r = 0;
			}

			if (g === void 0) {
				g = 0;
			}

			if (b === void 0) {
				b = 0;
			}

			if (a === void 0) {
				a = 1;
			}

			var length = r.length;

			if (length === 3 || length === 4) {
				this.r = r[0];
				this.g = r[1];
				this.b = r[2];
				this.a = r[3] !== undefined ? r[3] : 1;
			} else {
				this.r = r;
				this.g = g;
				this.b = b;
				this.a = a;
			}
		}

		var _proto = Color.prototype;

		_proto.clone = function clone() {
			return new Color(this.r, this.g, this.b, this.a);
		};

		_proto.copy = function copy(rhs) {
			this.r = rhs.r;
			this.g = rhs.g;
			this.b = rhs.b;
			this.a = rhs.a;
			return this;
		};

		_proto.equals = function equals(rhs) {
			return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
		};

		_proto.set = function set(r, g, b, a) {
			if (a === void 0) {
				a = 1;
			}

			this.r = r;
			this.g = g;
			this.b = b;
			this.a = a;
			return this;
		};

		_proto.lerp = function lerp(lhs, rhs, alpha) {
			this.r = lhs.r + alpha * (rhs.r - lhs.r);
			this.g = lhs.g + alpha * (rhs.g - lhs.g);
			this.b = lhs.b + alpha * (rhs.b - lhs.b);
			this.a = lhs.a + alpha * (rhs.a - lhs.a);
			return this;
		};

		_proto.fromString = function fromString(hex) {
			var i = parseInt(hex.replace('#', '0x'), 16);
			var bytes;

			if (hex.length > 7) {
				bytes = math.intToBytes32(i);
			} else {
				bytes = math.intToBytes24(i);
				bytes[3] = 255;
			}

			this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
			return this;
		};

		_proto.toString = function toString(alpha) {
			var s = "#" + ((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);

			if (alpha === true) {
				var a = Math.round(this.a * 255).toString(16);

				if (this.a < 16 / 255) {
					s += '0' + a;
				} else {
					s += a;
				}
			}

			return s;
		};

		return Color;
	}();

	Color.BLACK = Object.freeze(new Color(0, 0, 0, 1));
	Color.BLUE = Object.freeze(new Color(0, 0, 1, 1));
	Color.CYAN = Object.freeze(new Color(0, 1, 1, 1));
	Color.GRAY = Object.freeze(new Color(0.5, 0.5, 0.5, 1));
	Color.GREEN = Object.freeze(new Color(0, 1, 0, 1));
	Color.MAGENTA = Object.freeze(new Color(1, 0, 1, 1));
	Color.RED = Object.freeze(new Color(1, 0, 0, 1));
	Color.WHITE = Object.freeze(new Color(1, 1, 1, 1));
	Color.YELLOW = Object.freeze(new Color(1, 1, 0, 1));

	var CurveEvaluator = function () {
		function CurveEvaluator(curve, time) {
			if (time === void 0) {
				time = 0;
			}

			this._curve = curve;
			this._left = -Infinity;
			this._right = Infinity;
			this._recip = 0;
			this._p0 = 0;
			this._p1 = 0;
			this._m0 = 0;
			this._m1 = 0;

			this._reset(time);
		}

		var _proto = CurveEvaluator.prototype;

		_proto.evaluate = function evaluate(time, forceReset) {
			if (forceReset === void 0) {
				forceReset = false;
			}

			if (forceReset || time < this._left || time >= this._right) {
				this._reset(time);
			}

			var result;
			var type = this._curve.type;

			if (type === CURVE_STEP) {
				result = this._p0;
			} else {
				var t = this._recip === 0 ? 0 : (time - this._left) * this._recip;

				if (type === CURVE_LINEAR) {
					result = math.lerp(this._p0, this._p1, t);
				} else if (type === CURVE_SMOOTHSTEP) {
					result = math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));
				} else {
					result = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);
				}
			}

			return result;
		};

		_proto._reset = function _reset(time) {
			var keys = this._curve.keys;
			var len = keys.length;

			if (!len) {
				this._left = -Infinity;
				this._right = Infinity;
				this._recip = 0;
				this._p0 = this._p1 = this._m0 = this._m1 = 0;
			} else {
				if (time < keys[0][0]) {
					this._left = -Infinity;
					this._right = keys[0][0];
					this._recip = 0;
					this._p0 = this._p1 = keys[0][1];
					this._m0 = this._m1 = 0;
				} else if (time >= keys[len - 1][0]) {
					this._left = keys[len - 1][0];
					this._right = Infinity;
					this._recip = 0;
					this._p0 = this._p1 = keys[len - 1][1];
					this._m0 = this._m1 = 0;
				} else {
					var index = 0;

					while (time >= keys[index + 1][0]) {
						index++;
					}

					this._left = keys[index][0];
					this._right = keys[index + 1][0];
					var diff = 1.0 / (this._right - this._left);
					this._recip = isFinite(diff) ? diff : 0;
					this._p0 = keys[index][1];
					this._p1 = keys[index + 1][1];

					if (this._isHermite()) {
						this._calcTangents(keys, index);
					}
				}
			}
		};

		_proto._isHermite = function _isHermite() {
			return this._curve.type === CURVE_CATMULL || this._curve.type === CURVE_CARDINAL || this._curve.type === CURVE_SPLINE;
		};

		_proto._calcTangents = function _calcTangents(keys, index) {
			var a;
			var b = keys[index];
			var c = keys[index + 1];
			var d;

			if (index === 0) {
				a = [keys[0][0] + (keys[0][0] - keys[1][0]), keys[0][1] + (keys[0][1] - keys[1][1])];
			} else {
				a = keys[index - 1];
			}

			if (index === keys.length - 2) {
				d = [keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]), keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])];
			} else {
				d = keys[index + 2];
			}

			if (this._curve.type === CURVE_SPLINE) {
				var s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);
				var s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);
				this._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);
				this._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);
			} else {
				var s1 = (c[0] - b[0]) / (b[0] - a[0]);
				var s2 = (c[0] - b[0]) / (d[0] - c[0]);
				var a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);
				var d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);
				var tension = this._curve.type === CURVE_CATMULL ? 0.5 : this._curve.tension;
				this._m0 = tension * (c[1] - a_);
				this._m1 = tension * (d_ - b[1]);
			}
		};

		_proto._evaluateHermite = function _evaluateHermite(p0, p1, m0, m1, t) {
			var t2 = t * t;
			var twot = t + t;
			var omt = 1 - t;
			var omt2 = omt * omt;
			return p0 * ((1 + twot) * omt2) + m0 * (t * omt2) + p1 * (t2 * (3 - twot)) + m1 * (t2 * (t - 1));
		};

		return CurveEvaluator;
	}();

	var Curve = function () {
		function Curve(data) {
			this.keys = [];
			this.type = CURVE_SMOOTHSTEP;
			this.tension = 0.5;
			this._eval = new CurveEvaluator(this);

			if (data) {
				for (var i = 0; i < data.length - 1; i += 2) {
					this.keys.push([data[i], data[i + 1]]);
				}
			}

			this.sort();
		}

		var _proto = Curve.prototype;

		_proto.add = function add(time, value) {
			var keys = this.keys;
			var len = keys.length;
			var i = 0;

			for (; i < len; i++) {
				if (keys[i][0] > time) {
					break;
				}
			}

			var key = [time, value];
			this.keys.splice(i, 0, key);
			return key;
		};

		_proto.get = function get(index) {
			return this.keys[index];
		};

		_proto.sort = function sort() {
			this.keys.sort(function (a, b) {
				return a[0] - b[0];
			});
		};

		_proto.value = function value(time) {
			return this._eval.evaluate(time, true);
		};

		_proto.closest = function closest(time) {
			var keys = this.keys;
			var length = keys.length;
			var min = 2;
			var result = null;

			for (var i = 0; i < length; i++) {
				var diff = Math.abs(time - keys[i][0]);

				if (min >= diff) {
					min = diff;
					result = keys[i];
				} else {
					break;
				}
			}

			return result;
		};

		_proto.clone = function clone() {
			var result = new Curve();
			result.keys = extend(result.keys, this.keys);
			result.type = this.type;
			result.tension = this.tension;
			return result;
		};

		_proto.quantize = function quantize(precision) {
			precision = Math.max(precision, 2);
			var values = new Float32Array(precision);
			var step = 1.0 / (precision - 1);
			values[0] = this._eval.evaluate(0, true);

			for (var i = 1; i < precision; i++) {
				values[i] = this._eval.evaluate(step * i);
			}

			return values;
		};

		_proto.quantizeClamped = function quantizeClamped(precision, min, max) {
			var result = this.quantize(precision);

			for (var i = 0; i < result.length; ++i) {
				result[i] = Math.min(max, Math.max(min, result[i]));
			}

			return result;
		};

		_createClass(Curve, [{
			key: "length",
			get: function get() {
				return this.keys.length;
			}
		}]);

		return Curve;
	}();

	var CurveSet = function () {
		function CurveSet() {
			this.curves = [];
			this._type = CURVE_SMOOTHSTEP;

			if (arguments.length > 1) {
				for (var i = 0; i < arguments.length; i++) {
					this.curves.push(new Curve(arguments[i]));
				}
			} else {
				if (arguments.length === 0) {
					this.curves.push(new Curve());
				} else {
					var arg = arguments[0];

					if (typeof arg === 'number') {
						for (var _i = 0; _i < arg; _i++) {
							this.curves.push(new Curve());
						}
					} else {
						for (var _i2 = 0; _i2 < arg.length; _i2++) {
							this.curves.push(new Curve(arg[_i2]));
						}
					}
				}
			}
		}

		var _proto = CurveSet.prototype;

		_proto.get = function get(index) {
			return this.curves[index];
		};

		_proto.value = function value(time, result) {
			if (result === void 0) {
				result = [];
			}

			var length = this.curves.length;
			result.length = length;

			for (var i = 0; i < length; i++) {
				result[i] = this.curves[i].value(time);
			}

			return result;
		};

		_proto.clone = function clone() {
			var result = new CurveSet();
			result.curves = [];

			for (var i = 0; i < this.curves.length; i++) {
				result.curves.push(this.curves[i].clone());
			}

			result._type = this._type;
			return result;
		};

		_proto.quantize = function quantize(precision) {
			precision = Math.max(precision, 2);
			var numCurves = this.curves.length;
			var values = new Float32Array(precision * numCurves);
			var step = 1.0 / (precision - 1);

			for (var c = 0; c < numCurves; c++) {
				var ev = new CurveEvaluator(this.curves[c]);

				for (var i = 0; i < precision; i++) {
					values[i * numCurves + c] = ev.evaluate(step * i);
				}
			}

			return values;
		};

		_proto.quantizeClamped = function quantizeClamped(precision, min, max) {
			var result = this.quantize(precision);

			for (var i = 0; i < result.length; ++i) {
				result[i] = Math.min(max, Math.max(min, result[i]));
			}

			return result;
		};

		_createClass(CurveSet, [{
			key: "length",
			get: function get() {
				return this.curves.length;
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				this._type = value;

				for (var i = 0; i < this.curves.length; i++) {
					this.curves[i].type = value;
				}
			}
		}]);

		return CurveSet;
	}();

	var Vec3 = function () {
		function Vec3(x, y, z) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			if (z === void 0) {
				z = 0;
			}

			if (x.length === 3) {
				this.x = x[0];
				this.y = x[1];
				this.z = x[2];
			} else {
				this.x = x;
				this.y = y;
				this.z = z;
			}
		}

		var _proto = Vec3.prototype;

		_proto.add = function add(rhs) {
			this.x += rhs.x;
			this.y += rhs.y;
			this.z += rhs.z;
			return this;
		};

		_proto.add2 = function add2(lhs, rhs) {
			this.x = lhs.x + rhs.x;
			this.y = lhs.y + rhs.y;
			this.z = lhs.z + rhs.z;
			return this;
		};

		_proto.addScalar = function addScalar(scalar) {
			this.x += scalar;
			this.y += scalar;
			this.z += scalar;
			return this;
		};

		_proto.clone = function clone() {
			return new Vec3(this.x, this.y, this.z);
		};

		_proto.copy = function copy(rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			return this;
		};

		_proto.cross = function cross(lhs, rhs) {
			var lx = lhs.x;
			var ly = lhs.y;
			var lz = lhs.z;
			var rx = rhs.x;
			var ry = rhs.y;
			var rz = rhs.z;
			this.x = ly * rz - ry * lz;
			this.y = lz * rx - rz * lx;
			this.z = lx * ry - rx * ly;
			return this;
		};

		_proto.distance = function distance(rhs) {
			var x = this.x - rhs.x;
			var y = this.y - rhs.y;
			var z = this.z - rhs.z;
			return Math.sqrt(x * x + y * y + z * z);
		};

		_proto.div = function div(rhs) {
			this.x /= rhs.x;
			this.y /= rhs.y;
			this.z /= rhs.z;
			return this;
		};

		_proto.div2 = function div2(lhs, rhs) {
			this.x = lhs.x / rhs.x;
			this.y = lhs.y / rhs.y;
			this.z = lhs.z / rhs.z;
			return this;
		};

		_proto.divScalar = function divScalar(scalar) {
			this.x /= scalar;
			this.y /= scalar;
			this.z /= scalar;
			return this;
		};

		_proto.dot = function dot(rhs) {
			return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
		};

		_proto.equals = function equals(rhs) {
			return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
		};

		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		};

		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		};

		_proto.lerp = function lerp(lhs, rhs, alpha) {
			this.x = lhs.x + alpha * (rhs.x - lhs.x);
			this.y = lhs.y + alpha * (rhs.y - lhs.y);
			this.z = lhs.z + alpha * (rhs.z - lhs.z);
			return this;
		};

		_proto.mul = function mul(rhs) {
			this.x *= rhs.x;
			this.y *= rhs.y;
			this.z *= rhs.z;
			return this;
		};

		_proto.mul2 = function mul2(lhs, rhs) {
			this.x = lhs.x * rhs.x;
			this.y = lhs.y * rhs.y;
			this.z = lhs.z * rhs.z;
			return this;
		};

		_proto.mulScalar = function mulScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			return this;
		};

		_proto.normalize = function normalize() {
			var lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;

			if (lengthSq > 0) {
				var invLength = 1 / Math.sqrt(lengthSq);
				this.x *= invLength;
				this.y *= invLength;
				this.z *= invLength;
			}

			return this;
		};

		_proto.floor = function floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			return this;
		};

		_proto.ceil = function ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			return this;
		};

		_proto.round = function round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			return this;
		};

		_proto.min = function min(rhs) {
			if (rhs.x < this.x) this.x = rhs.x;
			if (rhs.y < this.y) this.y = rhs.y;
			if (rhs.z < this.z) this.z = rhs.z;
			return this;
		};

		_proto.max = function max(rhs) {
			if (rhs.x > this.x) this.x = rhs.x;
			if (rhs.y > this.y) this.y = rhs.y;
			if (rhs.z > this.z) this.z = rhs.z;
			return this;
		};

		_proto.project = function project(rhs) {
			var a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
			var b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;
			var s = a_dot_b / b_dot_b;
			this.x = rhs.x * s;
			this.y = rhs.y * s;
			this.z = rhs.z * s;
			return this;
		};

		_proto.set = function set(x, y, z) {
			this.x = x;
			this.y = y;
			this.z = z;
			return this;
		};

		_proto.sub = function sub(rhs) {
			this.x -= rhs.x;
			this.y -= rhs.y;
			this.z -= rhs.z;
			return this;
		};

		_proto.sub2 = function sub2(lhs, rhs) {
			this.x = lhs.x - rhs.x;
			this.y = lhs.y - rhs.y;
			this.z = lhs.z - rhs.z;
			return this;
		};

		_proto.subScalar = function subScalar(scalar) {
			this.x -= scalar;
			this.y -= scalar;
			this.z -= scalar;
			return this;
		};

		_proto.toString = function toString() {
			return "[" + this.x + ", " + this.y + ", " + this.z + "]";
		};

		return Vec3;
	}();

	Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0));
	Vec3.ONE = Object.freeze(new Vec3(1, 1, 1));
	Vec3.UP = Object.freeze(new Vec3(0, 1, 0));
	Vec3.DOWN = Object.freeze(new Vec3(0, -1, 0));
	Vec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));
	Vec3.LEFT = Object.freeze(new Vec3(-1, 0, 0));
	Vec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));
	Vec3.BACK = Object.freeze(new Vec3(0, 0, 1));

	var Mat3 = function () {
		function Mat3() {
			var data = new Float32Array(9);
			data[0] = data[4] = data[8] = 1;
			this.data = data;
		}

		var _proto = Mat3.prototype;

		_proto.clone = function clone() {
			return new Mat3().copy(this);
		};

		_proto.copy = function copy(rhs) {
			var src = rhs.data;
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			return this;
		};

		_proto.set = function set(src) {
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			return this;
		};

		_proto.equals = function equals(rhs) {
			var l = this.data;
			var r = rhs.data;
			return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];
		};

		_proto.isIdentity = function isIdentity() {
			var m = this.data;
			return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;
		};

		_proto.setIdentity = function setIdentity() {
			var m = this.data;
			m[0] = 1;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 1;
			m[5] = 0;
			m[6] = 0;
			m[7] = 0;
			m[8] = 1;
			return this;
		};

		_proto.toString = function toString() {
			return '[' + this.data.join(', ') + ']';
		};

		_proto.transpose = function transpose() {
			var m = this.data;
			var tmp;
			tmp = m[1];
			m[1] = m[3];
			m[3] = tmp;
			tmp = m[2];
			m[2] = m[6];
			m[6] = tmp;
			tmp = m[5];
			m[5] = m[7];
			m[7] = tmp;
			return this;
		};

		_proto.setFromMat4 = function setFromMat4(m) {
			var src = m.data;
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[4];
			dst[4] = src[5];
			dst[5] = src[6];
			dst[6] = src[8];
			dst[7] = src[9];
			dst[8] = src[10];
			return this;
		};

		_proto.transformVector = function transformVector(vec, res) {
			if (res === void 0) {
				res = new Vec3();
			}

			var m = this.data;
			var x = vec.x;
			var y = vec.y;
			var z = vec.z;
			res.x = x * m[0] + y * m[3] + z * m[6];
			res.y = x * m[1] + y * m[4] + z * m[7];
			res.z = x * m[2] + y * m[5] + z * m[8];
			return res;
		};

		return Mat3;
	}();

	Mat3.IDENTITY = Object.freeze(new Mat3());
	Mat3.ZERO = Object.freeze(new Mat3().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));

	var Vec2 = function () {
		function Vec2(x, y) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			if (x.length === 2) {
				this.x = x[0];
				this.y = x[1];
			} else {
				this.x = x;
				this.y = y;
			}
		}

		var _proto = Vec2.prototype;

		_proto.add = function add(rhs) {
			this.x += rhs.x;
			this.y += rhs.y;
			return this;
		};

		_proto.add2 = function add2(lhs, rhs) {
			this.x = lhs.x + rhs.x;
			this.y = lhs.y + rhs.y;
			return this;
		};

		_proto.addScalar = function addScalar(scalar) {
			this.x += scalar;
			this.y += scalar;
			return this;
		};

		_proto.clone = function clone() {
			return new Vec2(this.x, this.y);
		};

		_proto.copy = function copy(rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			return this;
		};

		_proto.cross = function cross(rhs) {
			return this.x * rhs.y - this.y * rhs.x;
		};

		_proto.distance = function distance(rhs) {
			var x = this.x - rhs.x;
			var y = this.y - rhs.y;
			return Math.sqrt(x * x + y * y);
		};

		_proto.div = function div(rhs) {
			this.x /= rhs.x;
			this.y /= rhs.y;
			return this;
		};

		_proto.div2 = function div2(lhs, rhs) {
			this.x = lhs.x / rhs.x;
			this.y = lhs.y / rhs.y;
			return this;
		};

		_proto.divScalar = function divScalar(scalar) {
			this.x /= scalar;
			this.y /= scalar;
			return this;
		};

		_proto.dot = function dot(rhs) {
			return this.x * rhs.x + this.y * rhs.y;
		};

		_proto.equals = function equals(rhs) {
			return this.x === rhs.x && this.y === rhs.y;
		};

		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		};

		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y;
		};

		_proto.lerp = function lerp(lhs, rhs, alpha) {
			this.x = lhs.x + alpha * (rhs.x - lhs.x);
			this.y = lhs.y + alpha * (rhs.y - lhs.y);
			return this;
		};

		_proto.mul = function mul(rhs) {
			this.x *= rhs.x;
			this.y *= rhs.y;
			return this;
		};

		_proto.mul2 = function mul2(lhs, rhs) {
			this.x = lhs.x * rhs.x;
			this.y = lhs.y * rhs.y;
			return this;
		};

		_proto.mulScalar = function mulScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			return this;
		};

		_proto.normalize = function normalize() {
			var lengthSq = this.x * this.x + this.y * this.y;

			if (lengthSq > 0) {
				var invLength = 1 / Math.sqrt(lengthSq);
				this.x *= invLength;
				this.y *= invLength;
			}

			return this;
		};

		_proto.floor = function floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this;
		};

		_proto.ceil = function ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			return this;
		};

		_proto.round = function round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			return this;
		};

		_proto.min = function min(rhs) {
			if (rhs.x < this.x) this.x = rhs.x;
			if (rhs.y < this.y) this.y = rhs.y;
			return this;
		};

		_proto.max = function max(rhs) {
			if (rhs.x > this.x) this.x = rhs.x;
			if (rhs.y > this.y) this.y = rhs.y;
			return this;
		};

		_proto.set = function set(x, y) {
			this.x = x;
			this.y = y;
			return this;
		};

		_proto.sub = function sub(rhs) {
			this.x -= rhs.x;
			this.y -= rhs.y;
			return this;
		};

		_proto.sub2 = function sub2(lhs, rhs) {
			this.x = lhs.x - rhs.x;
			this.y = lhs.y - rhs.y;
			return this;
		};

		_proto.subScalar = function subScalar(scalar) {
			this.x -= scalar;
			this.y -= scalar;
			return this;
		};

		_proto.toString = function toString() {
			return "[" + this.x + ", " + this.y + "]";
		};

		Vec2.angleRad = function angleRad(lhs, rhs) {
			return Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);
		};

		return Vec2;
	}();

	Vec2.ZERO = Object.freeze(new Vec2(0, 0));
	Vec2.ONE = Object.freeze(new Vec2(1, 1));
	Vec2.UP = Object.freeze(new Vec2(0, 1));
	Vec2.DOWN = Object.freeze(new Vec2(0, -1));
	Vec2.RIGHT = Object.freeze(new Vec2(1, 0));
	Vec2.LEFT = Object.freeze(new Vec2(-1, 0));

	var Vec4 = function () {
		function Vec4(x, y, z, w) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			if (z === void 0) {
				z = 0;
			}

			if (w === void 0) {
				w = 0;
			}

			if (x.length === 4) {
				this.x = x[0];
				this.y = x[1];
				this.z = x[2];
				this.w = x[3];
			} else {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
			}
		}

		var _proto = Vec4.prototype;

		_proto.add = function add(rhs) {
			this.x += rhs.x;
			this.y += rhs.y;
			this.z += rhs.z;
			this.w += rhs.w;
			return this;
		};

		_proto.add2 = function add2(lhs, rhs) {
			this.x = lhs.x + rhs.x;
			this.y = lhs.y + rhs.y;
			this.z = lhs.z + rhs.z;
			this.w = lhs.w + rhs.w;
			return this;
		};

		_proto.addScalar = function addScalar(scalar) {
			this.x += scalar;
			this.y += scalar;
			this.z += scalar;
			this.w += scalar;
			return this;
		};

		_proto.clone = function clone() {
			return new Vec4(this.x, this.y, this.z, this.w);
		};

		_proto.copy = function copy(rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			this.w = rhs.w;
			return this;
		};

		_proto.div = function div(rhs) {
			this.x /= rhs.x;
			this.y /= rhs.y;
			this.z /= rhs.z;
			this.w /= rhs.w;
			return this;
		};

		_proto.div2 = function div2(lhs, rhs) {
			this.x = lhs.x / rhs.x;
			this.y = lhs.y / rhs.y;
			this.z = lhs.z / rhs.z;
			this.w = lhs.w / rhs.w;
			return this;
		};

		_proto.divScalar = function divScalar(scalar) {
			this.x /= scalar;
			this.y /= scalar;
			this.z /= scalar;
			this.w /= scalar;
			return this;
		};

		_proto.dot = function dot(rhs) {
			return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;
		};

		_proto.equals = function equals(rhs) {
			return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
		};

		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		};

		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		};

		_proto.lerp = function lerp(lhs, rhs, alpha) {
			this.x = lhs.x + alpha * (rhs.x - lhs.x);
			this.y = lhs.y + alpha * (rhs.y - lhs.y);
			this.z = lhs.z + alpha * (rhs.z - lhs.z);
			this.w = lhs.w + alpha * (rhs.w - lhs.w);
			return this;
		};

		_proto.mul = function mul(rhs) {
			this.x *= rhs.x;
			this.y *= rhs.y;
			this.z *= rhs.z;
			this.w *= rhs.w;
			return this;
		};

		_proto.mul2 = function mul2(lhs, rhs) {
			this.x = lhs.x * rhs.x;
			this.y = lhs.y * rhs.y;
			this.z = lhs.z * rhs.z;
			this.w = lhs.w * rhs.w;
			return this;
		};

		_proto.mulScalar = function mulScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
			return this;
		};

		_proto.normalize = function normalize() {
			var lengthSq = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

			if (lengthSq > 0) {
				var invLength = 1 / Math.sqrt(lengthSq);
				this.x *= invLength;
				this.y *= invLength;
				this.z *= invLength;
				this.w *= invLength;
			}

			return this;
		};

		_proto.floor = function floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			this.w = Math.floor(this.w);
			return this;
		};

		_proto.ceil = function ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			this.w = Math.ceil(this.w);
			return this;
		};

		_proto.round = function round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			this.w = Math.round(this.w);
			return this;
		};

		_proto.min = function min(rhs) {
			if (rhs.x < this.x) this.x = rhs.x;
			if (rhs.y < this.y) this.y = rhs.y;
			if (rhs.z < this.z) this.z = rhs.z;
			if (rhs.w < this.w) this.w = rhs.w;
			return this;
		};

		_proto.max = function max(rhs) {
			if (rhs.x > this.x) this.x = rhs.x;
			if (rhs.y > this.y) this.y = rhs.y;
			if (rhs.z > this.z) this.z = rhs.z;
			if (rhs.w > this.w) this.w = rhs.w;
			return this;
		};

		_proto.set = function set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		};

		_proto.sub = function sub(rhs) {
			this.x -= rhs.x;
			this.y -= rhs.y;
			this.z -= rhs.z;
			this.w -= rhs.w;
			return this;
		};

		_proto.sub2 = function sub2(lhs, rhs) {
			this.x = lhs.x - rhs.x;
			this.y = lhs.y - rhs.y;
			this.z = lhs.z - rhs.z;
			this.w = lhs.w - rhs.w;
			return this;
		};

		_proto.subScalar = function subScalar(scalar) {
			this.x -= scalar;
			this.y -= scalar;
			this.z -= scalar;
			this.w -= scalar;
			return this;
		};

		_proto.toString = function toString() {
			return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
		};

		return Vec4;
	}();

	Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));
	Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));

	var _halfSize$1 = new Vec2();

	var x = new Vec3();
	var y = new Vec3();
	var z = new Vec3();
	var scale = new Vec3();

	var Mat4 = function () {
		function Mat4() {
			var data = new Float32Array(16);
			data[0] = data[5] = data[10] = data[15] = 1;
			this.data = data;
		}

		Mat4._getPerspectiveHalfSize = function _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {
			if (fovIsHorizontal) {
				halfSize.x = znear * Math.tan(fov * Math.PI / 360);
				halfSize.y = halfSize.x / aspect;
			} else {
				halfSize.y = znear * Math.tan(fov * Math.PI / 360);
				halfSize.x = halfSize.y * aspect;
			}
		};

		var _proto = Mat4.prototype;

		_proto.add2 = function add2(lhs, rhs) {
			var a = lhs.data,
					b = rhs.data,
					r = this.data;
			r[0] = a[0] + b[0];
			r[1] = a[1] + b[1];
			r[2] = a[2] + b[2];
			r[3] = a[3] + b[3];
			r[4] = a[4] + b[4];
			r[5] = a[5] + b[5];
			r[6] = a[6] + b[6];
			r[7] = a[7] + b[7];
			r[8] = a[8] + b[8];
			r[9] = a[9] + b[9];
			r[10] = a[10] + b[10];
			r[11] = a[11] + b[11];
			r[12] = a[12] + b[12];
			r[13] = a[13] + b[13];
			r[14] = a[14] + b[14];
			r[15] = a[15] + b[15];
			return this;
		};

		_proto.add = function add(rhs) {
			return this.add2(this, rhs);
		};

		_proto.clone = function clone() {
			return new Mat4().copy(this);
		};

		_proto.copy = function copy(rhs) {
			var src = rhs.data,
					dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			dst[9] = src[9];
			dst[10] = src[10];
			dst[11] = src[11];
			dst[12] = src[12];
			dst[13] = src[13];
			dst[14] = src[14];
			dst[15] = src[15];
			return this;
		};

		_proto.equals = function equals(rhs) {
			var l = this.data,
					r = rhs.data;
			return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];
		};

		_proto.isIdentity = function isIdentity() {
			var m = this.data;
			return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
		};

		_proto.mul2 = function mul2(lhs, rhs) {
			var a = lhs.data;
			var b = rhs.data;
			var r = this.data;
			var a00 = a[0];
			var a01 = a[1];
			var a02 = a[2];
			var a03 = a[3];
			var a10 = a[4];
			var a11 = a[5];
			var a12 = a[6];
			var a13 = a[7];
			var a20 = a[8];
			var a21 = a[9];
			var a22 = a[10];
			var a23 = a[11];
			var a30 = a[12];
			var a31 = a[13];
			var a32 = a[14];
			var a33 = a[15];
			var b0, b1, b2, b3;
			b0 = b[0];
			b1 = b[1];
			b2 = b[2];
			b3 = b[3];
			r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			b0 = b[4];
			b1 = b[5];
			b2 = b[6];
			b3 = b[7];
			r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			b0 = b[8];
			b1 = b[9];
			b2 = b[10];
			b3 = b[11];
			r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			b0 = b[12];
			b1 = b[13];
			b2 = b[14];
			b3 = b[15];
			r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			return this;
		};

		_proto.mulAffine2 = function mulAffine2(lhs, rhs) {
			var a = lhs.data;
			var b = rhs.data;
			var r = this.data;
			var a00 = a[0];
			var a01 = a[1];
			var a02 = a[2];
			var a10 = a[4];
			var a11 = a[5];
			var a12 = a[6];
			var a20 = a[8];
			var a21 = a[9];
			var a22 = a[10];
			var a30 = a[12];
			var a31 = a[13];
			var a32 = a[14];
			var b0, b1, b2;
			b0 = b[0];
			b1 = b[1];
			b2 = b[2];
			r[0] = a00 * b0 + a10 * b1 + a20 * b2;
			r[1] = a01 * b0 + a11 * b1 + a21 * b2;
			r[2] = a02 * b0 + a12 * b1 + a22 * b2;
			r[3] = 0;
			b0 = b[4];
			b1 = b[5];
			b2 = b[6];
			r[4] = a00 * b0 + a10 * b1 + a20 * b2;
			r[5] = a01 * b0 + a11 * b1 + a21 * b2;
			r[6] = a02 * b0 + a12 * b1 + a22 * b2;
			r[7] = 0;
			b0 = b[8];
			b1 = b[9];
			b2 = b[10];
			r[8] = a00 * b0 + a10 * b1 + a20 * b2;
			r[9] = a01 * b0 + a11 * b1 + a21 * b2;
			r[10] = a02 * b0 + a12 * b1 + a22 * b2;
			r[11] = 0;
			b0 = b[12];
			b1 = b[13];
			b2 = b[14];
			r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;
			r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;
			r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;
			r[15] = 1;
			return this;
		};

		_proto.mul = function mul(rhs) {
			return this.mul2(this, rhs);
		};

		_proto.transformPoint = function transformPoint(vec, res) {
			if (res === void 0) {
				res = new Vec3();
			}

			var m = this.data;
			var x = vec.x;
			var y = vec.y;
			var z = vec.z;
			res.x = x * m[0] + y * m[4] + z * m[8] + m[12];
			res.y = x * m[1] + y * m[5] + z * m[9] + m[13];
			res.z = x * m[2] + y * m[6] + z * m[10] + m[14];
			return res;
		};

		_proto.transformVector = function transformVector(vec, res) {
			if (res === void 0) {
				res = new Vec3();
			}

			var m = this.data;
			var x = vec.x;
			var y = vec.y;
			var z = vec.z;
			res.x = x * m[0] + y * m[4] + z * m[8];
			res.y = x * m[1] + y * m[5] + z * m[9];
			res.z = x * m[2] + y * m[6] + z * m[10];
			return res;
		};

		_proto.transformVec4 = function transformVec4(vec, res) {
			if (res === void 0) {
				res = new Vec4();
			}

			var m = this.data;
			var x = vec.x;
			var y = vec.y;
			var z = vec.z;
			var w = vec.w;
			res.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];
			res.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];
			res.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];
			res.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];
			return res;
		};

		_proto.setLookAt = function setLookAt(position, target, up) {
			z.sub2(position, target).normalize();
			y.copy(up).normalize();
			x.cross(y, z).normalize();
			y.cross(z, x);
			var r = this.data;
			r[0] = x.x;
			r[1] = x.y;
			r[2] = x.z;
			r[3] = 0;
			r[4] = y.x;
			r[5] = y.y;
			r[6] = y.z;
			r[7] = 0;
			r[8] = z.x;
			r[9] = z.y;
			r[10] = z.z;
			r[11] = 0;
			r[12] = position.x;
			r[13] = position.y;
			r[14] = position.z;
			r[15] = 1;
			return this;
		};

		_proto.setFrustum = function setFrustum(left, right, bottom, top, znear, zfar) {
			var temp1 = 2 * znear;
			var temp2 = right - left;
			var temp3 = top - bottom;
			var temp4 = zfar - znear;
			var r = this.data;
			r[0] = temp1 / temp2;
			r[1] = 0;
			r[2] = 0;
			r[3] = 0;
			r[4] = 0;
			r[5] = temp1 / temp3;
			r[6] = 0;
			r[7] = 0;
			r[8] = (right + left) / temp2;
			r[9] = (top + bottom) / temp3;
			r[10] = (-zfar - znear) / temp4;
			r[11] = -1;
			r[12] = 0;
			r[13] = 0;
			r[14] = -temp1 * zfar / temp4;
			r[15] = 0;
			return this;
		};

		_proto.setPerspective = function setPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {
			Mat4._getPerspectiveHalfSize(_halfSize$1, fov, aspect, znear, fovIsHorizontal);

			return this.setFrustum(-_halfSize$1.x, _halfSize$1.x, -_halfSize$1.y, _halfSize$1.y, znear, zfar);
		};

		_proto.setOrtho = function setOrtho(left, right, bottom, top, near, far) {
			var r = this.data;
			r[0] = 2 / (right - left);
			r[1] = 0;
			r[2] = 0;
			r[3] = 0;
			r[4] = 0;
			r[5] = 2 / (top - bottom);
			r[6] = 0;
			r[7] = 0;
			r[8] = 0;
			r[9] = 0;
			r[10] = -2 / (far - near);
			r[11] = 0;
			r[12] = -(right + left) / (right - left);
			r[13] = -(top + bottom) / (top - bottom);
			r[14] = -(far + near) / (far - near);
			r[15] = 1;
			return this;
		};

		_proto.setFromAxisAngle = function setFromAxisAngle(axis, angle) {
			angle *= math.DEG_TO_RAD;
			var x = axis.x;
			var y = axis.y;
			var z = axis.z;
			var c = Math.cos(angle);
			var s = Math.sin(angle);
			var t = 1 - c;
			var tx = t * x;
			var ty = t * y;
			var m = this.data;
			m[0] = tx * x + c;
			m[1] = tx * y + s * z;
			m[2] = tx * z - s * y;
			m[3] = 0;
			m[4] = tx * y - s * z;
			m[5] = ty * y + c;
			m[6] = ty * z + s * x;
			m[7] = 0;
			m[8] = tx * z + s * y;
			m[9] = ty * z - x * s;
			m[10] = t * z * z + c;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		};

		_proto.setTranslate = function setTranslate(x, y, z) {
			var m = this.data;
			m[0] = 1;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = 1;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = 1;
			m[11] = 0;
			m[12] = x;
			m[13] = y;
			m[14] = z;
			m[15] = 1;
			return this;
		};

		_proto.setScale = function setScale(x, y, z) {
			var m = this.data;
			m[0] = x;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = y;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = z;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		};

		_proto.setViewport = function setViewport(x, y, width, height) {
			var m = this.data;
			m[0] = width * 0.5;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = height * 0.5;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = 0.5;
			m[11] = 0;
			m[12] = x + width * 0.5;
			m[13] = y + height * 0.5;
			m[14] = 0.5;
			m[15] = 1;
			return this;
		};

		_proto.invert = function invert() {
			var m = this.data;
			var a00 = m[0];
			var a01 = m[1];
			var a02 = m[2];
			var a03 = m[3];
			var a10 = m[4];
			var a11 = m[5];
			var a12 = m[6];
			var a13 = m[7];
			var a20 = m[8];
			var a21 = m[9];
			var a22 = m[10];
			var a23 = m[11];
			var a30 = m[12];
			var a31 = m[13];
			var a32 = m[14];
			var a33 = m[15];
			var b00 = a00 * a11 - a01 * a10;
			var b01 = a00 * a12 - a02 * a10;
			var b02 = a00 * a13 - a03 * a10;
			var b03 = a01 * a12 - a02 * a11;
			var b04 = a01 * a13 - a03 * a11;
			var b05 = a02 * a13 - a03 * a12;
			var b06 = a20 * a31 - a21 * a30;
			var b07 = a20 * a32 - a22 * a30;
			var b08 = a20 * a33 - a23 * a30;
			var b09 = a21 * a32 - a22 * a31;
			var b10 = a21 * a33 - a23 * a31;
			var b11 = a22 * a33 - a23 * a32;
			var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

			if (det === 0) {
				this.setIdentity();
			} else {
				var invDet = 1 / det;
				m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
				m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
				m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
				m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
				m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
				m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
				m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
				m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
				m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
				m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
				m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
				m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
				m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
				m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
				m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
				m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
			}

			return this;
		};

		_proto.set = function set(src) {
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			dst[9] = src[9];
			dst[10] = src[10];
			dst[11] = src[11];
			dst[12] = src[12];
			dst[13] = src[13];
			dst[14] = src[14];
			dst[15] = src[15];
			return this;
		};

		_proto.setIdentity = function setIdentity() {
			var m = this.data;
			m[0] = 1;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = 1;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = 1;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		};

		_proto.setTRS = function setTRS(t, r, s) {
			var qx = r.x;
			var qy = r.y;
			var qz = r.z;
			var qw = r.w;
			var sx = s.x;
			var sy = s.y;
			var sz = s.z;
			var x2 = qx + qx;
			var y2 = qy + qy;
			var z2 = qz + qz;
			var xx = qx * x2;
			var xy = qx * y2;
			var xz = qx * z2;
			var yy = qy * y2;
			var yz = qy * z2;
			var zz = qz * z2;
			var wx = qw * x2;
			var wy = qw * y2;
			var wz = qw * z2;
			var m = this.data;
			m[0] = (1 - (yy + zz)) * sx;
			m[1] = (xy + wz) * sx;
			m[2] = (xz - wy) * sx;
			m[3] = 0;
			m[4] = (xy - wz) * sy;
			m[5] = (1 - (xx + zz)) * sy;
			m[6] = (yz + wx) * sy;
			m[7] = 0;
			m[8] = (xz + wy) * sz;
			m[9] = (yz - wx) * sz;
			m[10] = (1 - (xx + yy)) * sz;
			m[11] = 0;
			m[12] = t.x;
			m[13] = t.y;
			m[14] = t.z;
			m[15] = 1;
			return this;
		};

		_proto.transpose = function transpose() {
			var tmp;
			var m = this.data;
			tmp = m[1];
			m[1] = m[4];
			m[4] = tmp;
			tmp = m[2];
			m[2] = m[8];
			m[8] = tmp;
			tmp = m[3];
			m[3] = m[12];
			m[12] = tmp;
			tmp = m[6];
			m[6] = m[9];
			m[9] = tmp;
			tmp = m[7];
			m[7] = m[13];
			m[13] = tmp;
			tmp = m[11];
			m[11] = m[14];
			m[14] = tmp;
			return this;
		};

		_proto.invertTo3x3 = function invertTo3x3(res) {
			var m = this.data;
			var r = res.data;
			var m0 = m[0];
			var m1 = m[1];
			var m2 = m[2];
			var m4 = m[4];
			var m5 = m[5];
			var m6 = m[6];
			var m8 = m[8];
			var m9 = m[9];
			var m10 = m[10];
			var a11 = m10 * m5 - m6 * m9;
			var a21 = -m10 * m1 + m2 * m9;
			var a31 = m6 * m1 - m2 * m5;
			var a12 = -m10 * m4 + m6 * m8;
			var a22 = m10 * m0 - m2 * m8;
			var a32 = -m6 * m0 + m2 * m4;
			var a13 = m9 * m4 - m5 * m8;
			var a23 = -m9 * m0 + m1 * m8;
			var a33 = m5 * m0 - m1 * m4;
			var det = m0 * a11 + m1 * a12 + m2 * a13;

			if (det === 0) {
				return this;
			}

			var idet = 1 / det;
			r[0] = idet * a11;
			r[1] = idet * a21;
			r[2] = idet * a31;
			r[3] = idet * a12;
			r[4] = idet * a22;
			r[5] = idet * a32;
			r[6] = idet * a13;
			r[7] = idet * a23;
			r[8] = idet * a33;
			return this;
		};

		_proto.getTranslation = function getTranslation(t) {
			if (t === void 0) {
				t = new Vec3();
			}

			return t.set(this.data[12], this.data[13], this.data[14]);
		};

		_proto.getX = function getX(x) {
			if (x === void 0) {
				x = new Vec3();
			}

			return x.set(this.data[0], this.data[1], this.data[2]);
		};

		_proto.getY = function getY(y) {
			if (y === void 0) {
				y = new Vec3();
			}

			return y.set(this.data[4], this.data[5], this.data[6]);
		};

		_proto.getZ = function getZ(z) {
			if (z === void 0) {
				z = new Vec3();
			}

			return z.set(this.data[8], this.data[9], this.data[10]);
		};

		_proto.getScale = function getScale(scale) {
			if (scale === void 0) {
				scale = new Vec3();
			}

			this.getX(x);
			this.getY(y);
			this.getZ(z);
			scale.set(x.length(), y.length(), z.length());
			return scale;
		};

		_proto.setFromEulerAngles = function setFromEulerAngles(ex, ey, ez) {
			ex *= math.DEG_TO_RAD;
			ey *= math.DEG_TO_RAD;
			ez *= math.DEG_TO_RAD;
			var s1 = Math.sin(-ex);
			var c1 = Math.cos(-ex);
			var s2 = Math.sin(-ey);
			var c2 = Math.cos(-ey);
			var s3 = Math.sin(-ez);
			var c3 = Math.cos(-ez);
			var m = this.data;
			m[0] = c2 * c3;
			m[1] = -c2 * s3;
			m[2] = s2;
			m[3] = 0;
			m[4] = c1 * s3 + c3 * s1 * s2;
			m[5] = c1 * c3 - s1 * s2 * s3;
			m[6] = -c2 * s1;
			m[7] = 0;
			m[8] = s1 * s3 - c1 * c3 * s2;
			m[9] = c3 * s1 + c1 * s2 * s3;
			m[10] = c1 * c2;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		};

		_proto.getEulerAngles = function getEulerAngles(eulers) {
			if (eulers === void 0) {
				eulers = new Vec3();
			}

			this.getScale(scale);
			var sx = scale.x;
			var sy = scale.y;
			var sz = scale.z;
			if (sx === 0 || sy === 0 || sz === 0) return eulers.set(0, 0, 0);
			var m = this.data;
			var y = Math.asin(-m[2] / sx);
			var halfPi = Math.PI * 0.5;
			var x, z;

			if (y < halfPi) {
				if (y > -halfPi) {
					x = Math.atan2(m[6] / sy, m[10] / sz);
					z = Math.atan2(m[1] / sx, m[0] / sx);
				} else {
					z = 0;
					x = -Math.atan2(m[4] / sy, m[5] / sy);
				}
			} else {
				z = 0;
				x = Math.atan2(m[4] / sy, m[5] / sy);
			}

			return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
		};

		_proto.toString = function toString() {
			return '[' + this.data.join(', ') + ']';
		};

		return Mat4;
	}();

	Mat4.IDENTITY = Object.freeze(new Mat4());
	Mat4.ZERO = Object.freeze(new Mat4().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));

	var Quat = function () {
		function Quat(x, y, z, w) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			if (z === void 0) {
				z = 0;
			}

			if (w === void 0) {
				w = 1;
			}

			if (x.length === 4) {
				this.x = x[0];
				this.y = x[1];
				this.z = x[2];
				this.w = x[3];
			} else {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
			}
		}

		var _proto = Quat.prototype;

		_proto.clone = function clone() {
			return new Quat(this.x, this.y, this.z, this.w);
		};

		_proto.conjugate = function conjugate() {
			this.x *= -1;
			this.y *= -1;
			this.z *= -1;
			return this;
		};

		_proto.copy = function copy(rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			this.w = rhs.w;
			return this;
		};

		_proto.equals = function equals(rhs) {
			return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
		};

		_proto.getAxisAngle = function getAxisAngle(axis) {
			var rad = Math.acos(this.w) * 2;
			var s = Math.sin(rad / 2);

			if (s !== 0) {
				axis.x = this.x / s;
				axis.y = this.y / s;
				axis.z = this.z / s;

				if (axis.x < 0 || axis.y < 0 || axis.z < 0) {
					axis.x *= -1;
					axis.y *= -1;
					axis.z *= -1;
					rad *= -1;
				}
			} else {
				axis.x = 1;
				axis.y = 0;
				axis.z = 0;
			}

			return rad * math.RAD_TO_DEG;
		};

		_proto.getEulerAngles = function getEulerAngles(eulers) {
			if (eulers === void 0) {
				eulers = new Vec3();
			}

			var x, y, z;
			var qx = this.x;
			var qy = this.y;
			var qz = this.z;
			var qw = this.w;
			var a2 = 2 * (qw * qy - qx * qz);

			if (a2 <= -0.99999) {
				x = 2 * Math.atan2(qx, qw);
				y = -Math.PI / 2;
				z = 0;
			} else if (a2 >= 0.99999) {
				x = 2 * Math.atan2(qx, qw);
				y = Math.PI / 2;
				z = 0;
			} else {
				x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
				y = Math.asin(a2);
				z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
			}

			return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
		};

		_proto.invert = function invert() {
			return this.conjugate().normalize();
		};

		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		};

		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		};

		_proto.mul = function mul(rhs) {
			var q1x = this.x;
			var q1y = this.y;
			var q1z = this.z;
			var q1w = this.w;
			var q2x = rhs.x;
			var q2y = rhs.y;
			var q2z = rhs.z;
			var q2w = rhs.w;
			this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
			this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
			this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
			this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
			return this;
		};

		_proto.mul2 = function mul2(lhs, rhs) {
			var q1x = lhs.x;
			var q1y = lhs.y;
			var q1z = lhs.z;
			var q1w = lhs.w;
			var q2x = rhs.x;
			var q2y = rhs.y;
			var q2z = rhs.z;
			var q2w = rhs.w;
			this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
			this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
			this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
			this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
			return this;
		};

		_proto.normalize = function normalize() {
			var len = this.length();

			if (len === 0) {
				this.x = this.y = this.z = 0;
				this.w = 1;
			} else {
				len = 1 / len;
				this.x *= len;
				this.y *= len;
				this.z *= len;
				this.w *= len;
			}

			return this;
		};

		_proto.set = function set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		};

		_proto.setFromAxisAngle = function setFromAxisAngle(axis, angle) {
			angle *= 0.5 * math.DEG_TO_RAD;
			var sa = Math.sin(angle);
			var ca = Math.cos(angle);
			this.x = sa * axis.x;
			this.y = sa * axis.y;
			this.z = sa * axis.z;
			this.w = ca;
			return this;
		};

		_proto.setFromEulerAngles = function setFromEulerAngles(ex, ey, ez) {
			if (ex instanceof Vec3) {
				var vec = ex;
				ex = vec.x;
				ey = vec.y;
				ez = vec.z;
			}

			var halfToRad = 0.5 * math.DEG_TO_RAD;
			ex *= halfToRad;
			ey *= halfToRad;
			ez *= halfToRad;
			var sx = Math.sin(ex);
			var cx = Math.cos(ex);
			var sy = Math.sin(ey);
			var cy = Math.cos(ey);
			var sz = Math.sin(ez);
			var cz = Math.cos(ez);
			this.x = sx * cy * cz - cx * sy * sz;
			this.y = cx * sy * cz + sx * cy * sz;
			this.z = cx * cy * sz - sx * sy * cz;
			this.w = cx * cy * cz + sx * sy * sz;
			return this;
		};

		_proto.setFromMat4 = function setFromMat4(m) {
			var m00, m01, m02, m10, m11, m12, m20, m21, m22, s, rs, lx, ly, lz;
			m = m.data;
			m00 = m[0];
			m01 = m[1];
			m02 = m[2];
			m10 = m[4];
			m11 = m[5];
			m12 = m[6];
			m20 = m[8];
			m21 = m[9];
			m22 = m[10];
			lx = m00 * m00 + m01 * m01 + m02 * m02;
			if (lx === 0) return this;
			lx = 1 / Math.sqrt(lx);
			ly = m10 * m10 + m11 * m11 + m12 * m12;
			if (ly === 0) return this;
			ly = 1 / Math.sqrt(ly);
			lz = m20 * m20 + m21 * m21 + m22 * m22;
			if (lz === 0) return this;
			lz = 1 / Math.sqrt(lz);
			m00 *= lx;
			m01 *= lx;
			m02 *= lx;
			m10 *= ly;
			m11 *= ly;
			m12 *= ly;
			m20 *= lz;
			m21 *= lz;
			m22 *= lz;
			var tr = m00 + m11 + m22;

			if (tr >= 0) {
				s = Math.sqrt(tr + 1);
				this.w = s * 0.5;
				s = 0.5 / s;
				this.x = (m12 - m21) * s;
				this.y = (m20 - m02) * s;
				this.z = (m01 - m10) * s;
			} else {
				if (m00 > m11) {
					if (m00 > m22) {
						rs = m00 - (m11 + m22) + 1;
						rs = Math.sqrt(rs);
						this.x = rs * 0.5;
						rs = 0.5 / rs;
						this.w = (m12 - m21) * rs;
						this.y = (m01 + m10) * rs;
						this.z = (m02 + m20) * rs;
					} else {
						rs = m22 - (m00 + m11) + 1;
						rs = Math.sqrt(rs);
						this.z = rs * 0.5;
						rs = 0.5 / rs;
						this.w = (m01 - m10) * rs;
						this.x = (m20 + m02) * rs;
						this.y = (m21 + m12) * rs;
					}
				} else if (m11 > m22) {
					rs = m11 - (m22 + m00) + 1;
					rs = Math.sqrt(rs);
					this.y = rs * 0.5;
					rs = 0.5 / rs;
					this.w = (m20 - m02) * rs;
					this.z = (m12 + m21) * rs;
					this.x = (m10 + m01) * rs;
				} else {
					rs = m22 - (m00 + m11) + 1;
					rs = Math.sqrt(rs);
					this.z = rs * 0.5;
					rs = 0.5 / rs;
					this.w = (m01 - m10) * rs;
					this.x = (m20 + m02) * rs;
					this.y = (m21 + m12) * rs;
				}
			}

			return this;
		};

		_proto.slerp = function slerp(lhs, rhs, alpha) {
			var lx = lhs.x;
			var ly = lhs.y;
			var lz = lhs.z;
			var lw = lhs.w;
			var rx = rhs.x;
			var ry = rhs.y;
			var rz = rhs.z;
			var rw = rhs.w;
			var cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;

			if (cosHalfTheta < 0) {
				rw = -rw;
				rx = -rx;
				ry = -ry;
				rz = -rz;
				cosHalfTheta = -cosHalfTheta;
			}

			if (Math.abs(cosHalfTheta) >= 1) {
				this.w = lw;
				this.x = lx;
				this.y = ly;
				this.z = lz;
				return this;
			}

			var halfTheta = Math.acos(cosHalfTheta);
			var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);

			if (Math.abs(sinHalfTheta) < 0.001) {
				this.w = lw * 0.5 + rw * 0.5;
				this.x = lx * 0.5 + rx * 0.5;
				this.y = ly * 0.5 + ry * 0.5;
				this.z = lz * 0.5 + rz * 0.5;
				return this;
			}

			var ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;
			var ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;
			this.w = lw * ratioA + rw * ratioB;
			this.x = lx * ratioA + rx * ratioB;
			this.y = ly * ratioA + ry * ratioB;
			this.z = lz * ratioA + rz * ratioB;
			return this;
		};

		_proto.transformVector = function transformVector(vec, res) {
			if (res === void 0) {
				res = new Vec3();
			}

			var x = vec.x,
					y = vec.y,
					z = vec.z;
			var qx = this.x,
					qy = this.y,
					qz = this.z,
					qw = this.w;
			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = -qx * x - qy * y - qz * z;
			res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
			return res;
		};

		_proto.toString = function toString() {
			return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
		};

		return Quat;
	}();

	Quat.IDENTITY = Object.freeze(new Quat(0, 0, 0, 1));
	Quat.ZERO = Object.freeze(new Quat(0, 0, 0, 0));

	var Debug = function () {
		function Debug() {}

		Debug.deprecated = function deprecated(message) {
			if (!Debug._deprecatedMessages.has(message)) {
				Debug._deprecatedMessages.add(message);

				console.warn("DEPRECATED: " + message);
			}
		};

		Debug.assert = function assert(assertion) {
			if (!assertion) {
				var _console;

				for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					args[_key - 1] = arguments[_key];
				}

				(_console = console).error.apply(_console, ["ASSERT FAILED: "].concat(args));
			}
		};

		Debug.log = function log() {
			var _console2;

			(_console2 = console).log.apply(_console2, arguments);
		};

		Debug.warn = function warn() {
			var _console3;

			(_console3 = console).warn.apply(_console3, arguments);
		};

		Debug.error = function error() {
			var _console4;

			(_console4 = console).error.apply(_console4, arguments);
		};

		return Debug;
	}();

	Debug._deprecatedMessages = new Set();

	var tmpVecA$2 = new Vec3();
	var tmpVecB$1 = new Vec3();
	var tmpVecC = new Vec3();
	var tmpVecD = new Vec3();
	var tmpVecE = new Vec3();

	var BoundingBox = function () {
		function BoundingBox(center, halfExtents) {
			if (center === void 0) {
				center = new Vec3();
			}

			if (halfExtents === void 0) {
				halfExtents = new Vec3(0.5, 0.5, 0.5);
			}

			Debug.assert(!Object.isFrozen(center), "The constructor of 'BoundingBox' does not accept a constant (frozen) object as a 'center' parameter");
			Debug.assert(!Object.isFrozen(halfExtents), "The constructor of 'BoundingBox' does not accept a constant (frozen) object as a 'halfExtents' parameter");
			this.center = center;
			this.halfExtents = halfExtents;
			this._min = new Vec3();
			this._max = new Vec3();
		}

		var _proto = BoundingBox.prototype;

		_proto.add = function add(other) {
			var tc = this.center;
			var tcx = tc.x;
			var tcy = tc.y;
			var tcz = tc.z;
			var th = this.halfExtents;
			var thx = th.x;
			var thy = th.y;
			var thz = th.z;
			var tminx = tcx - thx;
			var tmaxx = tcx + thx;
			var tminy = tcy - thy;
			var tmaxy = tcy + thy;
			var tminz = tcz - thz;
			var tmaxz = tcz + thz;
			var oc = other.center;
			var ocx = oc.x;
			var ocy = oc.y;
			var ocz = oc.z;
			var oh = other.halfExtents;
			var ohx = oh.x;
			var ohy = oh.y;
			var ohz = oh.z;
			var ominx = ocx - ohx;
			var omaxx = ocx + ohx;
			var ominy = ocy - ohy;
			var omaxy = ocy + ohy;
			var ominz = ocz - ohz;
			var omaxz = ocz + ohz;
			if (ominx < tminx) tminx = ominx;
			if (omaxx > tmaxx) tmaxx = omaxx;
			if (ominy < tminy) tminy = ominy;
			if (omaxy > tmaxy) tmaxy = omaxy;
			if (ominz < tminz) tminz = ominz;
			if (omaxz > tmaxz) tmaxz = omaxz;
			tc.x = (tminx + tmaxx) * 0.5;
			tc.y = (tminy + tmaxy) * 0.5;
			tc.z = (tminz + tmaxz) * 0.5;
			th.x = (tmaxx - tminx) * 0.5;
			th.y = (tmaxy - tminy) * 0.5;
			th.z = (tmaxz - tminz) * 0.5;
		};

		_proto.copy = function copy(src) {
			this.center.copy(src.center);
			this.halfExtents.copy(src.halfExtents);
		};

		_proto.clone = function clone() {
			return new BoundingBox(this.center.clone(), this.halfExtents.clone());
		};

		_proto.intersects = function intersects(other) {
			var aMax = this.getMax();
			var aMin = this.getMin();
			var bMax = other.getMax();
			var bMin = other.getMin();
			return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
		};

		_proto._intersectsRay = function _intersectsRay(ray, point) {
			var tMin = tmpVecA$2.copy(this.getMin()).sub(ray.origin);
			var tMax = tmpVecB$1.copy(this.getMax()).sub(ray.origin);
			var dir = ray.direction;

			if (dir.x === 0) {
				tMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				tMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			} else {
				tMin.x /= dir.x;
				tMax.x /= dir.x;
			}

			if (dir.y === 0) {
				tMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				tMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			} else {
				tMin.y /= dir.y;
				tMax.y /= dir.y;
			}

			if (dir.z === 0) {
				tMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				tMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			} else {
				tMin.z /= dir.z;
				tMax.z /= dir.z;
			}

			var realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));
			var realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));
			var minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);
			var maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);
			var intersects = minMax >= maxMin && maxMin >= 0;
			if (intersects) point.copy(ray.direction).mulScalar(maxMin).add(ray.origin);
			return intersects;
		};

		_proto._fastIntersectsRay = function _fastIntersectsRay(ray) {
			var diff = tmpVecA$2;
			var cross = tmpVecB$1;
			var prod = tmpVecC;
			var absDiff = tmpVecD;
			var absDir = tmpVecE;
			var rayDir = ray.direction;
			diff.sub2(ray.origin, this.center);
			absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));
			prod.mul2(diff, rayDir);
			if (absDiff.x > this.halfExtents.x && prod.x >= 0) return false;
			if (absDiff.y > this.halfExtents.y && prod.y >= 0) return false;
			if (absDiff.z > this.halfExtents.z && prod.z >= 0) return false;
			absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
			cross.cross(rayDir, diff);
			cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));
			if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) return false;
			if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) return false;
			if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) return false;
			return true;
		};

		_proto.intersectsRay = function intersectsRay(ray, point) {
			if (point) {
				return this._intersectsRay(ray, point);
			}

			return this._fastIntersectsRay(ray);
		};

		_proto.setMinMax = function setMinMax(min, max) {
			this.center.add2(max, min).mulScalar(0.5);
			this.halfExtents.sub2(max, min).mulScalar(0.5);
		};

		_proto.getMin = function getMin() {
			return this._min.copy(this.center).sub(this.halfExtents);
		};

		_proto.getMax = function getMax() {
			return this._max.copy(this.center).add(this.halfExtents);
		};

		_proto.containsPoint = function containsPoint(point) {
			var min = this.getMin();
			var max = this.getMax();

			if (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {
				return false;
			}

			return true;
		};

		_proto.setFromTransformedAabb = function setFromTransformedAabb(aabb, m, ignoreScale) {
			if (ignoreScale === void 0) {
				ignoreScale = false;
			}

			var ac = aabb.center;
			var ar = aabb.halfExtents;
			var d = m.data;
			var mx0 = d[0];
			var mx1 = d[4];
			var mx2 = d[8];
			var my0 = d[1];
			var my1 = d[5];
			var my2 = d[9];
			var mz0 = d[2];
			var mz1 = d[6];
			var mz2 = d[10];

			if (ignoreScale) {
				var lengthSq = mx0 * mx0 + mx1 * mx1 + mx2 * mx2;

				if (lengthSq > 0) {
					var invLength = 1 / Math.sqrt(lengthSq);
					mx0 *= invLength;
					mx1 *= invLength;
					mx2 *= invLength;
				}

				lengthSq = my0 * my0 + my1 * my1 + my2 * my2;

				if (lengthSq > 0) {
					var _invLength = 1 / Math.sqrt(lengthSq);

					my0 *= _invLength;
					my1 *= _invLength;
					my2 *= _invLength;
				}

				lengthSq = mz0 * mz0 + mz1 * mz1 + mz2 * mz2;

				if (lengthSq > 0) {
					var _invLength2 = 1 / Math.sqrt(lengthSq);

					mz0 *= _invLength2;
					mz1 *= _invLength2;
					mz2 *= _invLength2;
				}
			}

			this.center.set(d[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, d[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, d[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);
			this.halfExtents.set(Math.abs(mx0) * ar.x + Math.abs(mx1) * ar.y + Math.abs(mx2) * ar.z, Math.abs(my0) * ar.x + Math.abs(my1) * ar.y + Math.abs(my2) * ar.z, Math.abs(mz0) * ar.x + Math.abs(mz1) * ar.y + Math.abs(mz2) * ar.z);
		};

		_proto.compute = function compute(vertices, numVerts) {
			numVerts = numVerts === undefined ? vertices.length / 3 : numVerts;

			if (numVerts > 0) {
				var min = tmpVecA$2.set(vertices[0], vertices[1], vertices[2]);
				var max = tmpVecB$1.set(vertices[0], vertices[1], vertices[2]);

				for (var i = 1; i < numVerts; i++) {
					var x = vertices[i * 3 + 0];
					var y = vertices[i * 3 + 1];
					var z = vertices[i * 3 + 2];
					if (x < min.x) min.x = x;
					if (y < min.y) min.y = y;
					if (z < min.z) min.z = z;
					if (x > max.x) max.x = x;
					if (y > max.y) max.y = y;
					if (z > max.z) max.z = z;
				}

				this.setMinMax(min, max);
			}
		};

		_proto.intersectsBoundingSphere = function intersectsBoundingSphere(sphere) {
			var sq = this._distanceToBoundingSphereSq(sphere);

			if (sq <= sphere.radius * sphere.radius) {
				return true;
			}

			return false;
		};

		_proto._distanceToBoundingSphereSq = function _distanceToBoundingSphereSq(sphere) {
			var boxMin = this.getMin();
			var boxMax = this.getMax();
			var sq = 0;
			var axis = ['x', 'y', 'z'];

			for (var i = 0; i < 3; ++i) {
				var out = 0;
				var pn = sphere.center[axis[i]];
				var bMin = boxMin[axis[i]];
				var bMax = boxMax[axis[i]];
				var val = 0;

				if (pn < bMin) {
					val = bMin - pn;
					out += val * val;
				}

				if (pn > bMax) {
					val = pn - bMax;
					out += val * val;
				}

				sq += out;
			}

			return sq;
		};

		_proto._expand = function _expand(expandMin, expandMax) {
			tmpVecA$2.add2(this.getMin(), expandMin);
			tmpVecB$1.add2(this.getMax(), expandMax);
			this.setMinMax(tmpVecA$2, tmpVecB$1);
		};

		return BoundingBox;
	}();

	var tmpVecA$1 = new Vec3();
	var tmpVecB = new Vec3();

	var BoundingSphere = function () {
		function BoundingSphere(center, radius) {
			if (center === void 0) {
				center = new Vec3();
			}

			if (radius === void 0) {
				radius = 0.5;
			}

			Debug.assert(!Object.isFrozen(center), "The constructor of 'BoundingSphere' does not accept a constant (frozen) object as a 'center' parameter");
			this.center = center;
			this.radius = radius;
		}

		var _proto = BoundingSphere.prototype;

		_proto.containsPoint = function containsPoint(point) {
			var lenSq = tmpVecA$1.sub2(point, this.center).lengthSq();
			var r = this.radius;
			return lenSq < r * r;
		};

		_proto.intersectsRay = function intersectsRay(ray, point) {
			var m = tmpVecA$1.copy(ray.origin).sub(this.center);
			var b = m.dot(tmpVecB.copy(ray.direction).normalize());
			var c = m.dot(m) - this.radius * this.radius;
			if (c > 0 && b > 0) return false;
			var discr = b * b - c;
			if (discr < 0) return false;
			var t = Math.abs(-b - Math.sqrt(discr));
			if (point) point.copy(ray.direction).mulScalar(t).add(ray.origin);
			return true;
		};

		_proto.intersectsBoundingSphere = function intersectsBoundingSphere(sphere) {
			tmpVecA$1.sub2(sphere.center, this.center);
			var totalRadius = sphere.radius + this.radius;

			if (tmpVecA$1.lengthSq() <= totalRadius * totalRadius) {
				return true;
			}

			return false;
		};

		return BoundingSphere;
	}();

	var BLEND_SUBTRACTIVE = 0;
	var BLEND_ADDITIVE = 1;
	var BLEND_NORMAL = 2;
	var BLEND_NONE = 3;
	var BLEND_PREMULTIPLIED = 4;
	var BLEND_MULTIPLICATIVE = 5;
	var BLEND_ADDITIVEALPHA = 6;
	var BLEND_MULTIPLICATIVE2X = 7;
	var BLEND_SCREEN = 8;
	var BLEND_MIN = 9;
	var BLEND_MAX = 10;
	var FOG_NONE = 'none';
	var FOG_LINEAR = 'linear';
	var FOG_EXP = 'exp';
	var FOG_EXP2 = 'exp2';
	var FRESNEL_NONE = 0;
	var FRESNEL_SCHLICK = 2;
	var LAYER_HUD = 0;
	var LAYER_GIZMO = 1;
	var LAYER_FX = 2;
	var LAYER_WORLD = 15;
	var LAYERID_WORLD = 0;
	var LAYERID_DEPTH = 1;
	var LAYERID_SKYBOX = 2;
	var LAYERID_IMMEDIATE = 3;
	var LAYERID_UI = 4;
	var LIGHTTYPE_DIRECTIONAL = 0;
	var LIGHTTYPE_OMNI = 1;
	var LIGHTTYPE_POINT = LIGHTTYPE_OMNI;
	var LIGHTTYPE_SPOT = 2;
	var LIGHTSHAPE_PUNCTUAL = 0;
	var LIGHTSHAPE_RECT = 1;
	var LIGHTSHAPE_DISK = 2;
	var LIGHTSHAPE_SPHERE = 3;
	var LIGHTFALLOFF_LINEAR = 0;
	var LIGHTFALLOFF_INVERSESQUARED = 1;
	var SHADOW_PCF3 = 0;
	var SHADOW_DEPTH = 0;
	var SHADOW_VSM8 = 1;
	var SHADOW_VSM16 = 2;
	var SHADOW_VSM32 = 3;
	var SHADOW_PCF5 = 4;
	var SHADOW_PCF1 = 5;
	var SHADOW_COUNT = 6;
	var shadowTypeToString = {};
	shadowTypeToString[SHADOW_PCF3] = "PCF3";
	shadowTypeToString[SHADOW_VSM8] = "VSM8";
	shadowTypeToString[SHADOW_VSM16] = "VSM16";
	shadowTypeToString[SHADOW_VSM32] = "VSM32";
	shadowTypeToString[SHADOW_PCF5] = "PCF5";
	shadowTypeToString[SHADOW_PCF1] = "PCF1";
	var BLUR_BOX = 0;
	var BLUR_GAUSSIAN = 1;
	var PARTICLESORT_NONE = 0;
	var PARTICLESORT_DISTANCE = 1;
	var PARTICLESORT_NEWER_FIRST = 2;
	var PARTICLESORT_OLDER_FIRST = 3;
	var PARTICLEMODE_GPU = 0;
	var PARTICLEMODE_CPU = 1;
	var EMITTERSHAPE_BOX = 0;
	var EMITTERSHAPE_SPHERE = 1;
	var PARTICLEORIENTATION_SCREEN = 0;
	var PARTICLEORIENTATION_WORLD = 1;
	var PARTICLEORIENTATION_EMITTER = 2;
	var PROJECTION_PERSPECTIVE = 0;
	var PROJECTION_ORTHOGRAPHIC = 1;
	var RENDERSTYLE_SOLID = 0;
	var RENDERSTYLE_WIREFRAME = 1;
	var RENDERSTYLE_POINTS = 2;
	var CUBEPROJ_NONE = 0;
	var CUBEPROJ_BOX = 1;
	var SPECULAR_PHONG = 0;
	var SPECULAR_BLINN = 1;
	var DETAILMODE_MUL = 'mul';
	var DETAILMODE_ADD = 'add';
	var DETAILMODE_SCREEN = 'screen';
	var DETAILMODE_OVERLAY = 'overlay';
	var DETAILMODE_MIN = 'min';
	var DETAILMODE_MAX = 'max';
	var GAMMA_NONE = 0;
	var GAMMA_SRGB = 1;
	var GAMMA_SRGBFAST = 2;
	var GAMMA_SRGBHDR = 3;
	var TONEMAP_LINEAR = 0;
	var TONEMAP_FILMIC = 1;
	var TONEMAP_HEJL = 2;
	var TONEMAP_ACES = 3;
	var TONEMAP_ACES2 = 4;
	var SPECOCC_NONE = 0;
	var SPECOCC_AO = 1;
	var SPECOCC_GLOSSDEPENDENT = 2;
	var SHADERDEF_NOSHADOW = 1;
	var SHADERDEF_SKIN = 2;
	var SHADERDEF_UV0 = 4;
	var SHADERDEF_UV1 = 8;
	var SHADERDEF_VCOLOR = 16;
	var SHADERDEF_INSTANCING = 32;
	var SHADERDEF_LM = 64;
	var SHADERDEF_DIRLM = 128;
	var SHADERDEF_SCREENSPACE = 256;
	var SHADERDEF_TANGENTS = 512;
	var SHADERDEF_MORPH_POSITION = 1024;
	var SHADERDEF_MORPH_NORMAL = 2048;
	var SHADERDEF_MORPH_TEXTURE_BASED = 4096;
	var SHADERDEF_LMAMBIENT = 8192;
	var LINEBATCH_WORLD = 0;
	var LINEBATCH_OVERLAY = 1;
	var LINEBATCH_GIZMO = 2;
	var SHADOWUPDATE_NONE = 0;
	var SHADOWUPDATE_THISFRAME = 1;
	var SHADOWUPDATE_REALTIME = 2;
	var SORTKEY_FORWARD = 0;
	var SORTKEY_DEPTH = 1;
	var MASK_AFFECT_DYNAMIC = 1;
	var MASK_AFFECT_LIGHTMAPPED = 2;
	var MASK_BAKE = 4;
	var SHADER_FORWARD = 0;
	var SHADER_FORWARDHDR = 1;
	var SHADER_DEPTH = 2;
	var SHADER_SHADOW = 3;
	var SHADER_PICK = 18;
	var SPRITE_RENDERMODE_SIMPLE = 0;
	var SPRITE_RENDERMODE_SLICED = 1;
	var SPRITE_RENDERMODE_TILED = 2;
	var BAKE_COLOR = 0;
	var BAKE_COLORDIR = 1;
	var VIEW_CENTER = 0;
	var VIEW_LEFT = 1;
	var VIEW_RIGHT = 2;
	var SORTMODE_NONE = 0;
	var SORTMODE_MANUAL = 1;
	var SORTMODE_MATERIALMESH = 2;
	var SORTMODE_BACK2FRONT = 3;
	var SORTMODE_FRONT2BACK = 4;
	var SORTMODE_CUSTOM = 5;
	var COMPUPDATED_INSTANCES = 1;
	var COMPUPDATED_LIGHTS = 2;
	var COMPUPDATED_CAMERAS = 4;
	var COMPUPDATED_BLEND = 8;
	var ASPECT_AUTO = 0;
	var ASPECT_MANUAL = 1;
	var ORIENTATION_HORIZONTAL = 0;
	var ORIENTATION_VERTICAL = 1;

	var _frustumPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

	var Frustum = function () {
		function Frustum() {
			this.planes = [];

			for (var i = 0; i < 6; i++) {
				this.planes[i] = [];
			}
		}

		var _proto = Frustum.prototype;

		_proto.setFromMat4 = function setFromMat4(matrix) {
			var vpm = matrix.data;
			var plane;
			var planes = this.planes;
			plane = planes[0];
			plane[0] = vpm[3] - vpm[0];
			plane[1] = vpm[7] - vpm[4];
			plane[2] = vpm[11] - vpm[8];
			plane[3] = vpm[15] - vpm[12];
			var t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[1];
			plane[0] = vpm[3] + vpm[0];
			plane[1] = vpm[7] + vpm[4];
			plane[2] = vpm[11] + vpm[8];
			plane[3] = vpm[15] + vpm[12];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[2];
			plane[0] = vpm[3] + vpm[1];
			plane[1] = vpm[7] + vpm[5];
			plane[2] = vpm[11] + vpm[9];
			plane[3] = vpm[15] + vpm[13];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[3];
			plane[0] = vpm[3] - vpm[1];
			plane[1] = vpm[7] - vpm[5];
			plane[2] = vpm[11] - vpm[9];
			plane[3] = vpm[15] - vpm[13];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[4];
			plane[0] = vpm[3] - vpm[2];
			plane[1] = vpm[7] - vpm[6];
			plane[2] = vpm[11] - vpm[10];
			plane[3] = vpm[15] - vpm[14];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[5];
			plane[0] = vpm[3] + vpm[2];
			plane[1] = vpm[7] + vpm[6];
			plane[2] = vpm[11] + vpm[10];
			plane[3] = vpm[15] + vpm[14];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
		};

		_proto.containsPoint = function containsPoint(point) {
			var p, plane;

			for (p = 0; p < 6; p++) {
				plane = this.planes[p];

				if (plane[0] * point.x + plane[1] * point.y + plane[2] * point.z + plane[3] <= 0) {
					return false;
				}
			}

			return true;
		};

		_proto.containsSphere = function containsSphere(sphere) {
			var c = 0;
			var d;
			var p;
			var sr = sphere.radius;
			var sc = sphere.center;
			var scx = sc.x;
			var scy = sc.y;
			var scz = sc.z;
			var planes = this.planes;
			var plane;

			for (p = 0; p < 6; p++) {
				plane = planes[p];
				d = plane[0] * scx + plane[1] * scy + plane[2] * scz + plane[3];
				if (d <= -sr) return 0;
				if (d > sr) c++;
			}

			return c === 6 ? 2 : 1;
		};

		Frustum.getPoints = function getPoints(camera, near, far) {
			near = near || camera._nearClip;
			far = far || camera._farClip;
			var fov = camera._fov * Math.PI / 180.0;
			var y = camera._projection === PROJECTION_PERSPECTIVE ? Math.tan(fov / 2.0) * near : camera._orthoHeight;
			var x = y * camera._aspectRatio;
			var points = _frustumPoints;
			points[0].x = x;
			points[0].y = -y;
			points[0].z = -near;
			points[1].x = x;
			points[1].y = y;
			points[1].z = -near;
			points[2].x = -x;
			points[2].y = y;
			points[2].z = -near;
			points[3].x = -x;
			points[3].y = -y;
			points[3].z = -near;

			if (camera._projection === PROJECTION_PERSPECTIVE) {
				y = Math.tan(fov / 2.0) * far;
				x = y * camera._aspectRatio;
			}

			points[4].x = x;
			points[4].y = -y;
			points[4].z = -far;
			points[5].x = x;
			points[5].y = y;
			points[5].z = -far;
			points[6].x = -x;
			points[6].y = y;
			points[6].z = -far;
			points[7].x = -x;
			points[7].y = -y;
			points[7].z = -far;
			return points;
		};

		return Frustum;
	}();

	var Ray = function () {
		function Ray(origin, direction) {
			if (origin === void 0) {
				origin = new Vec3();
			}

			if (direction === void 0) {
				direction = new Vec3(0, 0, -1);
			}

			Debug.assert(!Object.isFrozen(origin), "The constructor of 'Ray' does not accept a constant (frozen) object as a 'origin' parameter");
			Debug.assert(!Object.isFrozen(direction), "The constructor of 'Ray' does not accept a constant (frozen) object as a 'direction' parameter");
			this.origin = origin;
			this.direction = direction;
		}

		var _proto = Ray.prototype;

		_proto.set = function set(origin, direction) {
			this.origin.copy(origin);
			this.direction.copy(direction);
			return this;
		};

		return Ray;
	}();

	var tmpRay = new Ray();
	var tmpVec3$2 = new Vec3();
	var tmpSphere = new BoundingSphere();
	var tmpMat4$1 = new Mat4();

	var OrientedBox = function () {
		function OrientedBox(worldTransform, halfExtents) {
			if (worldTransform === void 0) {
				worldTransform = new Mat4();
			}

			if (halfExtents === void 0) {
				halfExtents = new Vec3(0.5, 0.5, 0.5);
			}

			Debug.assert(!Object.isFrozen(worldTransform), "The constructor of 'OrientedBox' does not accept a constant (frozen) object as a 'worldTransform' parameter");
			Debug.assert(!Object.isFrozen(halfExtents), "The constructor of 'OrientedBox' does not accept a constant (frozen) object as a 'halfExtents' parameter");
			this.halfExtents = halfExtents;
			this._modelTransform = worldTransform.clone().invert();
			this._worldTransform = worldTransform.clone();
			this._aabb = new BoundingBox(new Vec3(), this.halfExtents);
		}

		var _proto = OrientedBox.prototype;

		_proto.intersectsRay = function intersectsRay(ray, point) {
			this._modelTransform.transformPoint(ray.origin, tmpRay.origin);

			this._modelTransform.transformVector(ray.direction, tmpRay.direction);

			if (point) {
				var result = this._aabb._intersectsRay(tmpRay, point);

				tmpMat4$1.copy(this._modelTransform).invert().transformPoint(point, point);
				return result;
			}

			return this._aabb._fastIntersectsRay(tmpRay);
		};

		_proto.containsPoint = function containsPoint(point) {
			this._modelTransform.transformPoint(point, tmpVec3$2);

			return this._aabb.containsPoint(tmpVec3$2);
		};

		_proto.intersectsBoundingSphere = function intersectsBoundingSphere(sphere) {
			this._modelTransform.transformPoint(sphere.center, tmpSphere.center);

			tmpSphere.radius = sphere.radius;

			if (this._aabb.intersectsBoundingSphere(tmpSphere)) {
				return true;
			}

			return false;
		};

		_createClass(OrientedBox, [{
			key: "worldTransform",
			get: function get() {
				return this._worldTransform;
			},
			set: function set(value) {
				this._worldTransform.copy(value);

				this._modelTransform.copy(value).invert();
			}
		}]);

		return OrientedBox;
	}();

	var tmpVecA = new Vec3();

	var Plane = function () {
		function Plane(point, normal) {
			if (point === void 0) {
				point = new Vec3();
			}

			if (normal === void 0) {
				normal = new Vec3(0, 0, 1);
			}

			this.normal = normal;
			this.point = point;
		}

		var _proto = Plane.prototype;

		_proto.intersectsLine = function intersectsLine(start, end, point) {
			var d = -this.normal.dot(this.point);
			var d0 = this.normal.dot(start) + d;
			var d1 = this.normal.dot(end) + d;
			var t = d0 / (d0 - d1);
			var intersects = t >= 0 && t <= 1;
			if (intersects && point) point.lerp(start, end, t);
			return intersects;
		};

		_proto.intersectsRay = function intersectsRay(ray, point) {
			var pointToOrigin = tmpVecA.sub2(this.point, ray.origin);
			var t = this.normal.dot(pointToOrigin) / this.normal.dot(ray.direction);
			var intersects = t >= 0;
			if (intersects && point) point.copy(ray.direction).mulScalar(t).add(ray.origin);
			return intersects;
		};

		return Plane;
	}();

	var ADDRESS_REPEAT = 0;
	var ADDRESS_CLAMP_TO_EDGE = 1;
	var ADDRESS_MIRRORED_REPEAT = 2;
	var BLENDMODE_ZERO = 0;
	var BLENDMODE_ONE = 1;
	var BLENDMODE_SRC_COLOR = 2;
	var BLENDMODE_ONE_MINUS_SRC_COLOR = 3;
	var BLENDMODE_DST_COLOR = 4;
	var BLENDMODE_ONE_MINUS_DST_COLOR = 5;
	var BLENDMODE_SRC_ALPHA = 6;
	var BLENDMODE_SRC_ALPHA_SATURATE = 7;
	var BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;
	var BLENDMODE_DST_ALPHA = 9;
	var BLENDMODE_ONE_MINUS_DST_ALPHA = 10;
	var BLENDMODE_CONSTANT_COLOR = 11;
	var BLENDMODE_ONE_MINUS_CONSTANT_COLOR = 12;
	var BLENDMODE_CONSTANT_ALPHA = 13;
	var BLENDMODE_ONE_MINUS_CONSTANT_ALPHA = 14;
	var BLENDEQUATION_ADD = 0;
	var BLENDEQUATION_SUBTRACT = 1;
	var BLENDEQUATION_REVERSE_SUBTRACT = 2;
	var BLENDEQUATION_MIN = 3;
	var BLENDEQUATION_MAX = 4;
	var BUFFER_STATIC = 0;
	var BUFFER_DYNAMIC = 1;
	var BUFFER_STREAM = 2;
	var BUFFER_GPUDYNAMIC = 3;
	var CLEARFLAG_COLOR = 1;
	var CLEARFLAG_DEPTH = 2;
	var CLEARFLAG_STENCIL = 4;
	var CUBEFACE_POSX = 0;
	var CUBEFACE_NEGX = 1;
	var CUBEFACE_POSY = 2;
	var CUBEFACE_NEGY = 3;
	var CUBEFACE_POSZ = 4;
	var CUBEFACE_NEGZ = 5;
	var CULLFACE_NONE = 0;
	var CULLFACE_BACK = 1;
	var CULLFACE_FRONT = 2;
	var CULLFACE_FRONTANDBACK = 3;
	var FILTER_NEAREST = 0;
	var FILTER_LINEAR = 1;
	var FILTER_NEAREST_MIPMAP_NEAREST = 2;
	var FILTER_NEAREST_MIPMAP_LINEAR = 3;
	var FILTER_LINEAR_MIPMAP_NEAREST = 4;
	var FILTER_LINEAR_MIPMAP_LINEAR = 5;
	var FUNC_NEVER = 0;
	var FUNC_LESS = 1;
	var FUNC_EQUAL = 2;
	var FUNC_LESSEQUAL = 3;
	var FUNC_GREATER = 4;
	var FUNC_NOTEQUAL = 5;
	var FUNC_GREATEREQUAL = 6;
	var FUNC_ALWAYS = 7;
	var INDEXFORMAT_UINT8 = 0;
	var INDEXFORMAT_UINT16 = 1;
	var INDEXFORMAT_UINT32 = 2;
	var PIXELFORMAT_A8 = 0;
	var PIXELFORMAT_L8 = 1;
	var PIXELFORMAT_L8_A8 = 2;
	var PIXELFORMAT_R5_G6_B5 = 3;
	var PIXELFORMAT_R5_G5_B5_A1 = 4;
	var PIXELFORMAT_R4_G4_B4_A4 = 5;
	var PIXELFORMAT_R8_G8_B8 = 6;
	var PIXELFORMAT_R8_G8_B8_A8 = 7;
	var PIXELFORMAT_DXT1 = 8;
	var PIXELFORMAT_DXT3 = 9;
	var PIXELFORMAT_DXT5 = 10;
	var PIXELFORMAT_RGB16F = 11;
	var PIXELFORMAT_RGBA16F = 12;
	var PIXELFORMAT_RGB32F = 13;
	var PIXELFORMAT_RGBA32F = 14;
	var PIXELFORMAT_R32F = 15;
	var PIXELFORMAT_DEPTH = 16;
	var PIXELFORMAT_DEPTHSTENCIL = 17;
	var PIXELFORMAT_111110F = 18;
	var PIXELFORMAT_SRGB = 19;
	var PIXELFORMAT_SRGBA = 20;
	var PIXELFORMAT_ETC1 = 21;
	var PIXELFORMAT_ETC2_RGB = 22;
	var PIXELFORMAT_ETC2_RGBA = 23;
	var PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;
	var PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;
	var PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;
	var PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;
	var PIXELFORMAT_ASTC_4x4 = 28;
	var PIXELFORMAT_ATC_RGB = 29;
	var PIXELFORMAT_ATC_RGBA = 30;
	var PRIMITIVE_POINTS = 0;
	var PRIMITIVE_LINES = 1;
	var PRIMITIVE_LINELOOP = 2;
	var PRIMITIVE_LINESTRIP = 3;
	var PRIMITIVE_TRIANGLES = 4;
	var PRIMITIVE_TRISTRIP = 5;
	var PRIMITIVE_TRIFAN = 6;
	var SEMANTIC_POSITION = "POSITION";
	var SEMANTIC_NORMAL = "NORMAL";
	var SEMANTIC_TANGENT = "TANGENT";
	var SEMANTIC_BLENDWEIGHT = "BLENDWEIGHT";
	var SEMANTIC_BLENDINDICES = "BLENDINDICES";
	var SEMANTIC_COLOR = "COLOR";
	var SEMANTIC_TEXCOORD = "TEXCOORD";
	var SEMANTIC_TEXCOORD0 = "TEXCOORD0";
	var SEMANTIC_TEXCOORD1 = "TEXCOORD1";
	var SEMANTIC_TEXCOORD2 = "TEXCOORD2";
	var SEMANTIC_TEXCOORD3 = "TEXCOORD3";
	var SEMANTIC_TEXCOORD4 = "TEXCOORD4";
	var SEMANTIC_TEXCOORD5 = "TEXCOORD5";
	var SEMANTIC_TEXCOORD6 = "TEXCOORD6";
	var SEMANTIC_TEXCOORD7 = "TEXCOORD7";
	var SEMANTIC_ATTR = "ATTR";
	var SEMANTIC_ATTR0 = "ATTR0";
	var SEMANTIC_ATTR1 = "ATTR1";
	var SEMANTIC_ATTR2 = "ATTR2";
	var SEMANTIC_ATTR3 = "ATTR3";
	var SEMANTIC_ATTR4 = "ATTR4";
	var SEMANTIC_ATTR5 = "ATTR5";
	var SEMANTIC_ATTR6 = "ATTR6";
	var SEMANTIC_ATTR7 = "ATTR7";
	var SEMANTIC_ATTR8 = "ATTR8";
	var SEMANTIC_ATTR9 = "ATTR9";
	var SEMANTIC_ATTR10 = "ATTR10";
	var SEMANTIC_ATTR11 = "ATTR11";
	var SEMANTIC_ATTR12 = "ATTR12";
	var SEMANTIC_ATTR13 = "ATTR13";
	var SEMANTIC_ATTR14 = "ATTR14";
	var SEMANTIC_ATTR15 = "ATTR15";
	var SHADERTAG_MATERIAL = 1;
	var STENCILOP_KEEP = 0;
	var STENCILOP_ZERO = 1;
	var STENCILOP_REPLACE = 2;
	var STENCILOP_INCREMENT = 3;
	var STENCILOP_INCREMENTWRAP = 4;
	var STENCILOP_DECREMENT = 5;
	var STENCILOP_DECREMENTWRAP = 6;
	var STENCILOP_INVERT = 7;
	var TEXTURELOCK_READ = 1;
	var TEXTURELOCK_WRITE = 2;
	var TEXTURETYPE_DEFAULT = 'default';
	var TEXTURETYPE_RGBM = 'rgbm';
	var TEXTURETYPE_RGBE = 'rgbe';
	var TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';
	var TEXHINT_NONE = 0;
	var TEXHINT_SHADOWMAP = 1;
	var TEXHINT_ASSET = 2;
	var TEXHINT_LIGHTMAP = 3;
	var TEXTUREPROJECTION_NONE = "none";
	var TEXTUREPROJECTION_CUBE = "cube";
	var TEXTUREPROJECTION_EQUIRECT = "equirect";
	var TEXTUREPROJECTION_OCTAHEDRAL = "octahedral";
	var TYPE_INT8 = 0;
	var TYPE_UINT8 = 1;
	var TYPE_INT16 = 2;
	var TYPE_UINT16 = 3;
	var TYPE_INT32 = 4;
	var TYPE_UINT32 = 5;
	var TYPE_FLOAT32 = 6;
	var UNIFORMTYPE_BOOL = 0;
	var UNIFORMTYPE_INT = 1;
	var UNIFORMTYPE_FLOAT = 2;
	var UNIFORMTYPE_VEC2 = 3;
	var UNIFORMTYPE_VEC3 = 4;
	var UNIFORMTYPE_VEC4 = 5;
	var UNIFORMTYPE_IVEC2 = 6;
	var UNIFORMTYPE_IVEC3 = 7;
	var UNIFORMTYPE_IVEC4 = 8;
	var UNIFORMTYPE_BVEC2 = 9;
	var UNIFORMTYPE_BVEC3 = 10;
	var UNIFORMTYPE_BVEC4 = 11;
	var UNIFORMTYPE_MAT2 = 12;
	var UNIFORMTYPE_MAT3 = 13;
	var UNIFORMTYPE_MAT4 = 14;
	var UNIFORMTYPE_TEXTURE2D = 15;
	var UNIFORMTYPE_TEXTURECUBE = 16;
	var UNIFORMTYPE_FLOATARRAY = 17;
	var UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
	var UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
	var UNIFORMTYPE_TEXTURE3D = 20;
	var UNIFORMTYPE_VEC2ARRAY = 21;
	var UNIFORMTYPE_VEC3ARRAY = 22;
	var UNIFORMTYPE_VEC4ARRAY = 23;
	var typedArrayTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array];
	var typedArrayTypesByteSize = [1, 1, 2, 2, 4, 4, 4];
	var typedArrayToType = {
		"Int8Array": TYPE_INT8,
		"Uint8Array": TYPE_UINT8,
		"Int16Array": TYPE_INT16,
		"Uint16Array": TYPE_UINT16,
		"Int32Array": TYPE_INT32,
		"Uint32Array": TYPE_UINT32,
		"Float32Array": TYPE_FLOAT32
	};
	var typedArrayIndexFormats = [Uint8Array, Uint16Array, Uint32Array];
	var typedArrayIndexFormatsByteSize = [1, 2, 4];
	var semanticToLocation = {};
	semanticToLocation[SEMANTIC_POSITION] = 0;
	semanticToLocation[SEMANTIC_NORMAL] = 1;
	semanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;
	semanticToLocation[SEMANTIC_BLENDINDICES] = 3;
	semanticToLocation[SEMANTIC_COLOR] = 4;
	semanticToLocation[SEMANTIC_TEXCOORD0] = 5;
	semanticToLocation[SEMANTIC_TEXCOORD1] = 6;
	semanticToLocation[SEMANTIC_TEXCOORD2] = 7;
	semanticToLocation[SEMANTIC_TEXCOORD3] = 8;
	semanticToLocation[SEMANTIC_TEXCOORD4] = 9;
	semanticToLocation[SEMANTIC_TEXCOORD5] = 10;
	semanticToLocation[SEMANTIC_TEXCOORD6] = 11;
	semanticToLocation[SEMANTIC_TEXCOORD7] = 12;
	semanticToLocation[SEMANTIC_TANGENT] = 13;
	semanticToLocation[SEMANTIC_ATTR0] = 0;
	semanticToLocation[SEMANTIC_ATTR1] = 1;
	semanticToLocation[SEMANTIC_ATTR2] = 2;
	semanticToLocation[SEMANTIC_ATTR3] = 3;
	semanticToLocation[SEMANTIC_ATTR4] = 4;
	semanticToLocation[SEMANTIC_ATTR5] = 5;
	semanticToLocation[SEMANTIC_ATTR6] = 6;
	semanticToLocation[SEMANTIC_ATTR7] = 7;
	semanticToLocation[SEMANTIC_ATTR8] = 8;
	semanticToLocation[SEMANTIC_ATTR9] = 9;
	semanticToLocation[SEMANTIC_ATTR10] = 10;
	semanticToLocation[SEMANTIC_ATTR11] = 11;
	semanticToLocation[SEMANTIC_ATTR12] = 12;
	semanticToLocation[SEMANTIC_ATTR13] = 13;
	semanticToLocation[SEMANTIC_ATTR14] = 14;
	semanticToLocation[SEMANTIC_ATTR15] = 15;

	var id$3 = 0;

	var VertexBuffer = function () {
		function VertexBuffer(graphicsDevice, format, numVertices, usage, initialData) {
			if (usage === void 0) {
				usage = BUFFER_STATIC;
			}

			this.device = graphicsDevice;
			this.format = format;
			this.numVertices = numVertices;
			this.usage = usage;
			this.id = id$3++;
			this.impl = graphicsDevice.createVertexBufferImpl(this, format);
			this.instancing = false;
			this.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;
			graphicsDevice._vram.vb += this.numBytes;

			if (initialData) {
				this.setData(initialData);
			} else {
				this.storage = new ArrayBuffer(this.numBytes);
			}

			this.device.buffers.push(this);
		}

		var _proto = VertexBuffer.prototype;

		_proto.destroy = function destroy() {
			var device = this.device;
			var idx = device.buffers.indexOf(this);

			if (idx !== -1) {
				device.buffers.splice(idx, 1);
			}

			this.impl.destroy(device);
			device._vram.vb -= this.storage.byteLength;
		};

		_proto.loseContext = function loseContext() {
			this.impl.loseContext();
		};

		_proto.getFormat = function getFormat() {
			return this.format;
		};

		_proto.getUsage = function getUsage() {
			return this.usage;
		};

		_proto.getNumVertices = function getNumVertices() {
			return this.numVertices;
		};

		_proto.lock = function lock() {
			return this.storage;
		};

		_proto.unlock = function unlock() {
			this.impl.unlock(this);
		};

		_proto.setData = function setData(data) {
			if (data.byteLength !== this.numBytes) {
				Debug.error("VertexBuffer: wrong initial data size: expected " + this.numBytes + ", got " + data.byteLength);
				return false;
			}

			this.storage = data;
			this.unlock();
			return true;
		};

		return VertexBuffer;
	}();

	function hashCode(str) {
		var hash = 0;

		for (var i = 0, len = str.length; i < len; i++) {
			hash = (hash << 5) - hash + str.charCodeAt(i);
			hash |= 0;
		}

		return hash;
	}

	var VertexFormat = function () {
		function VertexFormat(graphicsDevice, description, vertexCount) {
			this._elements = [];
			this.hasUv0 = false;
			this.hasUv1 = false;
			this.hasColor = false;
			this.hasTangents = false;
			this.verticesByteSize = 0;
			this.vertexCount = vertexCount;
			this.interleaved = vertexCount === undefined;
			this.size = description.reduce(function (total, desc) {
				return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
			}, 0);
			var offset = 0,
					elementSize;

			for (var i = 0, len = description.length; i < len; i++) {
				var elementDesc = description[i];
				elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];

				if (vertexCount) {
					offset = math.roundUp(offset, elementSize);
					Debug.assert(elementSize % 4 === 0, "Non-interleaved vertex format with element size not multiple of 4 can have performance impact on some platforms. Element size: " + elementSize);
				}

				var element = {
					name: elementDesc.semantic,
					offset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,
					stride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,
					dataType: elementDesc.type,
					numComponents: elementDesc.components,
					normalize: elementDesc.normalize === undefined ? false : elementDesc.normalize,
					size: elementSize
				};

				this._elements.push(element);

				if (vertexCount) {
					offset += elementSize * vertexCount;
				} else {
					offset += Math.ceil(elementSize / 4) * 4;
				}

				if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
					this.hasUv0 = true;
				} else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
					this.hasUv1 = true;
				} else if (elementDesc.semantic === SEMANTIC_COLOR) {
					this.hasColor = true;
				} else if (elementDesc.semantic === SEMANTIC_TANGENT) {
					this.hasTangents = true;
				}
			}

			if (vertexCount) {
				this.verticesByteSize = offset;
			}

			this._evaluateHash();
		}

		var _proto = VertexFormat.prototype;

		_proto._evaluateHash = function _evaluateHash() {
			var stringElementBatch;
			var stringElementsBatch = [];
			var stringElementRender;
			var stringElementsRender = [];
			var len = this._elements.length;

			for (var i = 0; i < len; i++) {
				var element = this._elements[i];
				stringElementBatch = element.name;
				stringElementBatch += element.dataType;
				stringElementBatch += element.numComponents;
				stringElementBatch += element.normalize;
				stringElementsBatch.push(stringElementBatch);
				stringElementRender = stringElementBatch;
				stringElementRender += element.offset;
				stringElementRender += element.stride;
				stringElementRender += element.size;
				stringElementsRender.push(stringElementRender);
			}

			stringElementsBatch.sort();
			this.batchingHash = hashCode(stringElementsBatch.join());
			this.renderingingHash = hashCode(stringElementsRender.join());
		};

		_createClass(VertexFormat, [{
			key: "elements",
			get: function get() {
				return this._elements;
			}
		}], [{
			key: "defaultInstancingFormat",
			get: function get() {
				if (!VertexFormat._defaultInstancingFormat) {
					VertexFormat._defaultInstancingFormat = new VertexFormat(null, [{
						semantic: SEMANTIC_ATTR12,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR13,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR14,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR15,
						components: 4,
						type: TYPE_FLOAT32
					}]);
				}

				return VertexFormat._defaultInstancingFormat;
			}
		}]);

		return VertexFormat;
	}();

	VertexFormat._defaultInstancingFormat = null;

	var DebugGraphics = function () {
		function DebugGraphics() {}

		DebugGraphics.pushGpuMarker = function pushGpuMarker(device, name) {
			device.pushMarker(name);
		};

		DebugGraphics.popGpuMarker = function popGpuMarker(device) {
			device.popMarker();
		};

		return DebugGraphics;
	}();

	var DeviceCache = function () {
		function DeviceCache() {
			this._cache = new Map();
		}

		var _proto = DeviceCache.prototype;

		_proto.get = function get(device, onCreate) {
			var _this = this;

			if (!this._cache.has(device)) {
				this._cache.set(device, onCreate());

				device.on('destroy', function () {
					_this.remove(device);
				});
			}

			return this._cache.get(device);
		};

		_proto.remove = function remove(device) {
			var _this$_cache$get;

			(_this$_cache$get = this._cache.get(device)) == null ? void 0 : _this$_cache$get.destroy();

			this._cache.delete(device);
		};

		return DeviceCache;
	}();

	var _postEffectQuadDraw = {
		type: PRIMITIVE_TRISTRIP,
		base: 0,
		count: 4,
		indexed: false
	};
	var postEffectDeviceCache = new DeviceCache();

	function getPostEffectQuadVB(device) {
		return postEffectDeviceCache.get(device, function () {
			var vertexFormat = new VertexFormat(device, [{
				semantic: SEMANTIC_POSITION,
				components: 2,
				type: TYPE_FLOAT32
			}]);
			var positions = new Float32Array(8);
			positions.set([-1, -1, 1, -1, -1, 1, 1, 1]);
			return new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, positions);
		});
	}

	function drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend) {
		if (useBlend === void 0) {
			useBlend = false;
		}

		DebugGraphics.pushGpuMarker(device, "drawQuadWithShader");
		var oldRt = device.renderTarget;
		device.setRenderTarget(target);
		device.updateBegin();
		var x, y, w, h;
		var sx, sy, sw, sh;

		if (!rect) {
			w = target ? target.width : device.width;
			h = target ? target.height : device.height;
			x = 0;
			y = 0;
		} else {
			x = rect.x;
			y = rect.y;
			w = rect.z;
			h = rect.w;
		}

		if (!scissorRect) {
			sx = x;
			sy = y;
			sw = w;
			sh = h;
		} else {
			sx = scissorRect.x;
			sy = scissorRect.y;
			sw = scissorRect.z;
			sh = scissorRect.w;
		}

		var oldVx = device.vx;
		var oldVy = device.vy;
		var oldVw = device.vw;
		var oldVh = device.vh;
		device.setViewport(x, y, w, h);
		var oldSx = device.sx;
		var oldSy = device.sy;
		var oldSw = device.sw;
		var oldSh = device.sh;
		device.setScissor(sx, sy, sw, sh);
		var oldDepthTest = device.getDepthTest();
		var oldDepthWrite = device.getDepthWrite();
		var oldCullMode = device.getCullMode();
		var oldWR = device.writeRed;
		var oldWG = device.writeGreen;
		var oldWB = device.writeBlue;
		var oldWA = device.writeAlpha;
		device.setDepthTest(false);
		device.setDepthWrite(false);
		device.setCullMode(CULLFACE_NONE);
		device.setColorWrite(true, true, true, true);
		if (!useBlend) device.setBlending(false);
		device.setVertexBuffer(getPostEffectQuadVB(device), 0);
		device.setShader(shader);
		device.draw(_postEffectQuadDraw);
		device.setDepthTest(oldDepthTest);
		device.setDepthWrite(oldDepthWrite);
		device.setCullMode(oldCullMode);
		device.setColorWrite(oldWR, oldWG, oldWB, oldWA);
		device.updateEnd();
		device.setRenderTarget(oldRt);
		device.updateBegin();
		device.setViewport(oldVx, oldVy, oldVw, oldVh);
		device.setScissor(oldSx, oldSy, oldSw, oldSh);
		DebugGraphics.popGpuMarker(device);
	}

	function drawTexture(device, texture, target, shader, rect, scissorRect, useBlend) {
		if (useBlend === void 0) {
			useBlend = false;
		}

		shader = shader || device.getCopyShader();
		device.constantTexSource.setValue(texture);
		drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend);
	}

	var Shader = function () {
		function Shader(graphicsDevice, definition) {
			this.device = graphicsDevice;
			this.definition = definition;
			this.init();
			this.impl = graphicsDevice.createShaderImpl(this);
		}

		var _proto = Shader.prototype;

		_proto.init = function init() {
			this.ready = false;
			this.failed = false;
		};

		_proto.destroy = function destroy() {
			this.impl.destroy(this);
		};

		_proto.loseContext = function loseContext() {
			this.init();
		};

		_proto.restoreContext = function restoreContext() {
			this.impl.restoreContext(this.device, this);
		};

		return Shader;
	}();

	var alphaTestPS = "uniform float alpha_ref;\n\nvoid alphaTest(float a) {\n\tif (a < alpha_ref) discard;\n}\n";

	var ambientConstantPS = "void addAmbient() {\n\tdDiffuseLight += light_globalAmbient;\n}\n";

	var ambientEnvPS = "#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\n\nvoid addAmbient() {\n\tvec3 dir = normalize(cubeMapRotate(dNormalW) * vec3(-1.0, 1.0, 1.0));\n\tvec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n\n\tvec4 raw = texture2D(texture_envAtlas, uv);\n\tvec3 linear = $DECODE(raw);\n\tdDiffuseLight += processEnvironment(linear);\n}\n";

	var ambientSHPS = "uniform vec3 ambientSH[9];\n\nvoid addAmbient() {\n\tvec3 n = cubeMapRotate(dNormalW);\n\n\tvec3 color =\n\t\tambientSH[0] +\n\t\tambientSH[1] * n.x +\n\t\tambientSH[2] * n.y +\n\t\tambientSH[3] * n.z +\n\t\tambientSH[4] * n.x * n.z +\n\t\tambientSH[5] * n.z * n.y +\n\t\tambientSH[6] * n.y * n.x +\n\t\tambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n\t\tambientSH[8] * (n.x * n.x - n.y * n.y);\n\n\tdDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n";

	var aoPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_aoMap;\n#endif\n\nvoid getAO() {\n\tdAo = 1.0;\n\n\t#ifdef MAPTEXTURE\n\tdAo *= texture2D(texture_aoMap, $UV, textureBias).$CH;\n\t#endif\n\n\t#ifdef MAPVERTEX\n\tdAo *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

	var aoDiffuseOccPS = "void occludeDiffuse() {\n\tdDiffuseLight *= dAo;\n}\n";

	var aoSpecOccPS = "uniform float material_occludeSpecularIntensity;\n\nvoid occludeSpecular() {\n\t// approximated specular occlusion from AO\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\t// http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\tspecOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

	var aoSpecOccConstPS = "void occludeSpecular() {\n\t// approximated specular occlusion from AO\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\t// http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

	var aoSpecOccConstSimplePS = "void occludeSpecular() {\n\tdSpecularLight *= dAo;\n\tdReflection *= dAo;\n}\n";

	var aoSpecOccSimplePS = "uniform float material_occludeSpecularIntensity;\n\nvoid occludeSpecular() {\n\tfloat specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

	var bakeDirLmEndPS = "\tvec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n\n\tif (bakeDir > 0.5) {\n\t\tif (dAtten > 0.00001) {\n\t\t\tdirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n\t\t\tdAtten = saturate(dAtten);\n\t\t\tgl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n\t\t\tgl_FragColor.a = dirLm.w + dAtten;\n\t\t\tgl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n\t\t} else {\n\t\t\tgl_FragColor = dirLm;\n\t\t}\n\t} else {\n\t\tgl_FragColor.rgb = dirLm.xyz;\n\t\tgl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n\t}\n";

	var bakeLmEndPS = "\tgl_FragColor.rgb = dDiffuseLight;\n\tgl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n\tgl_FragColor.rgb /= 8.0;\n\tgl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n\tgl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n\tgl_FragColor.rgb /= gl_FragColor.a;\n";

	var basePS = "uniform vec3 view_position;\n\nuniform vec3 light_globalAmbient;\n\nfloat square(float x) {\n\treturn x*x;\n}\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 x) {\n\treturn clamp(x, vec3(0.0), vec3(1.0));\n}\n";

	var baseVS = "attribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\n\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\n\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\n";

	var baseNineSlicedPS = "#define NINESLICED\n\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\n\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n\nvec2 nineSlicedUv;\n";

	var baseNineSlicedVS = "#define NINESLICED\n\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\n\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n";

	var baseNineSlicedTiledPS = "#define NINESLICED\n#define NINESLICETILED\n\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\n\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n\nvec2 nineSlicedUv;\n";

	var biasConstPS = "#define SHADOWBIAS\n\nfloat getShadowBias(float resolution, float maxBias) {\n\treturn maxBias;\n}\n";

	var blurVSMPS = "varying vec2 vUv0;\n\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\n\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\n#endif\n\nvoid main(void) {\n\tvec3 moments = vec3(0.0);\n\tvec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n\tfor (int i=0; i<SAMPLES; i++) {\n\t\tvec4 c = texture2D(source, uv + pixelOffset * float(i));\n\n\t\t#ifdef PACKED\n\t\tc.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n\t\t#endif\n\n\t\t#ifdef GAUSS\n\t\tmoments += c.xyz * weight[i];\n\t\t#else\n\t\tmoments += c.xyz;\n\t\t#endif\n\t}\n\n\t#ifndef GAUSS\n\tmoments /= float(SAMPLES);\n\t#endif\n\n\t#ifdef PACKED\n\tgl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n\t#else\n\tgl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n\t#endif\n}\n";

	var clearCoatPS = "#ifdef MAPFLOAT\nuniform float material_clearCoat;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatMap;\n#endif\n\nvoid getClearCoat() {\n\tccSpecularity = 1.0;\n\n\t#ifdef MAPFLOAT\n\tccSpecularity *= material_clearCoat;\n\t#endif\n\n\t#ifdef MAPTEXTURE\n\tccSpecularity *= texture2D(texture_clearCoatMap, $UV, textureBias).$CH;\n\t#endif\n\n\t#ifdef MAPVERTEX\n\tccSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

	var clearCoatGlossPS = "#ifdef MAPFLOAT\nuniform float material_clearCoatGlossiness;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatGlossMap;\n#endif\n\nvoid getClearCoatGlossiness() {\n\tccGlossiness = 1.0;\n\n\t#ifdef MAPFLOAT\n\tccGlossiness *= material_clearCoatGlossiness;\n\t#endif\n\n\t#ifdef MAPTEXTURE\n\tccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV, textureBias).$CH;\n\t#endif\n\n\t#ifdef MAPVERTEX\n\tccGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\n\tccGlossiness += 0.0000001;\n}\n";

	var clearCoatNormalPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatNormalMap;\nuniform float material_clearCoatBumpiness;\n#endif\n\nvoid getClearCoatNormal() {\n\t#ifdef MAPTEXTURE\n\tvec3 normalMap = unpackNormal(texture2D(texture_clearCoatNormalMap, $UV, textureBias));\n\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness));\n\tccNormalW = dTBN * normalMap;\n\t#else\n\tccNormalW = normalize(dVertexNormalW);\n\t#endif\n\n\tccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\n}\n";

	var clusteredLightUtilsPS = "// Converts unnormalized direction vector to a cubemap face index [0..5] and uv coordinates within the face in [0..1] range.\n// Additionally offset to a tile in atlas within 3x3 subdivision is provided\nvec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\n{\n\tvec3 vAbs = abs(dir);\n\tfloat ma;\n\tvec2 uv;\n\tif (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {	 // front / back\n\n\t\tfaceIndex = dir.z < 0.0 ? 5.0 : 4.0;\n\t\tma = 0.5 / vAbs.z;\n\t\tuv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\n\n\t\ttileOffset.x = 2.0;\n\t\ttileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\n\n\t} else if(vAbs.y >= vAbs.x) {	// top index 2, bottom index 3\n\n\t\tfaceIndex = dir.y < 0.0 ? 3.0 : 2.0;\n\t\tma = 0.5 / vAbs.y;\n\t\tuv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\n\n\t\ttileOffset.x = 1.0;\n\t\ttileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\n\n\t} else {\t// left / right\n\n\t\tfaceIndex = dir.x < 0.0 ? 1.0 : 0.0;\n\t\tma = 0.5 / vAbs.x;\n\t\tuv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\n\n\t\ttileOffset.x = 0.0;\n\t\ttileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\n\n\t}\n\treturn uv * ma + 0.5;\n}\n\n// converts unnormalized direction vector to a texture coordinate for a cubemap face stored within texture atlas described by the viewport\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\n\n\tfloat faceIndex;\n\tvec2 tileOffset;\n\tvec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\n\n\t// move uv coordinates inwards inside to compensate for larger fov when rendering shadow into atlas\n\tfloat atlasFaceSize = omniAtlasViewport.z;\n\tfloat tileSize = shadowTextureResolution * atlasFaceSize;\n\tfloat offset = shadowEdgePixels / tileSize;\n\tuv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\n\n\t// scale uv coordinates to cube face area within the viewport\n\tuv *= atlasFaceSize;\n\n\t// offset into face of the atlas (3x3 grid)\n\tuv += tileOffset * atlasFaceSize;\n\n\t// offset into the atlas viewport\n\tuv += omniAtlasViewport.xy;\n\n\treturn uv;\n}\n";

	var clusteredLightCookiesPS = "vec3 _getCookieClustered(sampler2D tex, vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 pixel = mix(vec4(1.0), texture2D(tex, uv), intensity);\n\treturn isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));\n}\n\n// getCookie2D for clustered lighting including channel selector\nvec3 getCookie2DClustered(sampler2D tex, mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 projPos = transform * vec4(worldPosition, 1.0);\n\treturn _getCookieClustered(tex, projPos.xy / projPos.w, intensity, isRgb, cookieChannel);\n}\n\n// getCookie for clustered omni light with the cookie texture being stored in the cookie atlas\nvec3 getCookieCubeClustered(sampler2D tex, vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {\n\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\treturn _getCookieClustered(tex, uv, intensity, isRgb, cookieChannel);\n}\n";

	var clusteredLightShadowsPS = "// Clustered Omni Sampling using atlas\n\n#ifdef GL2\n\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n\tfloat getShadowOmniClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\treturn texture(shadowMap, vec3(uv, shadowZ));\n\t}\n\n\t#endif\n\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\n\tfloat getShadowOmniClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\tdShadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(shadowMap, shadowParams.xyz);\n\t}\n\n\t#endif\n\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n\tfloat getShadowOmniClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\tdShadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF5x5(shadowMap, shadowParams.xyz);\n\t}\n\n\t#endif\n\n#else\n\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n\tfloat getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n\t\t// no filter shadow sampling\n\t\tfloat depth = unpackFloat(texture2D(shadowMap, uv));\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\treturn depth > shadowZ ? 1.0 : 0.0;\n\t}\n\n\t#endif\n\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3) || defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n\tfloat getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n\t\t// pcf3\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\tdShadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(shadowMap, shadowParams.xyz);\n\t}\n\n\t#endif\n\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n\t// we don't have PCF5 implementation for webgl1, use PCF3\n\tfloat getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\treturn getShadowOmniClusteredPCF3(shadowMap, shadowParams, omniAtlasViewport, shadowEdgePixels, dir);\n\t}\n\n\t#endif\n\n#endif\n\n\n// Clustered Spot Sampling using atlas\n\n#ifdef GL2\n\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n\tfloat getShadowSpotClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams) {\n\t\treturn texture(shadowMap, dShadowCoord);\n\t}\n\n\t#endif\n\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\n\tfloat getShadowSpotClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(shadowMap, shadowParams);\n\t}\n\n\t#endif\n\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n\tfloat getShadowSpotClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams) {\n\t\treturn getShadowPCF5x5(shadowMap, shadowParams.xyz);\n\t}\n\t#endif\n\n#else\n\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n\tfloat getShadowSpotClusteredPCF1(sampler2D shadowMap, vec4 shadowParams) {\n\n\t\tfloat depth = unpackFloat(texture2D(shadowMap, dShadowCoord.xy));\n\n\t\treturn depth > dShadowCoord.z ? 1.0 : 0.0;\n\n\t}\n\n\t#endif\n\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3) || defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n\tfloat getShadowSpotClusteredPCF3(sampler2D shadowMap, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(shadowMap, shadowParams);\n\t}\n\n\t#endif\n\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n\t// we don't have PCF5 implementation for webgl1, use PCF3\n\tfloat getShadowSpotClusteredPCF5(sampler2D shadowMap, vec4 shadowParams) {\n\t\treturn getShadowSpotClusteredPCF3(shadowMap, shadowParams);\n\t}\n\n\t#endif\n\n#endif\n";

	var clusteredLightPS = "uniform sampler2D clusterWorldTexture;\nuniform sampler2D lightsTexture8;\nuniform highp sampler2D lightsTextureFloat;\n\n#ifdef CLUSTER_SHADOWS\n\t#ifdef GL2\n\t\t// TODO: when VSM shadow is supported, it needs to use sampler2D in webgl2\n\t\tuniform sampler2DShadow shadowAtlasTexture;\n\t#else\n\t\tuniform sampler2D shadowAtlasTexture;\n\t#endif\n#endif\n\n#ifdef CLUSTER_COOKIES\n\tuniform sampler2D cookieAtlasTexture;\n#endif\n\nuniform float clusterPixelsPerCell;\nuniform vec3 clusterCellsCountByBoundsSize;\nuniform vec4 lightsTextureInvSize;\nuniform vec3 clusterTextureSize;\nuniform vec3 clusterBoundsMin;\nuniform vec3 clusterBoundsDelta;\nuniform vec3 clusterCellsDot;\nuniform vec3 clusterCellsMax;\nuniform vec2 clusterCompressionLimit0;\nuniform vec2 shadowAtlasParams;\n\n// global variable to limit shared area light values to be evaluated only one time\nfloat LTCLightValuesEvaluated = 0.0;\n\n// structure storing light properties of a clustered light\nstruct ClusterLightData {\n\n\t// v coordinate to look up the light textures\n\tfloat lightV;\n\n\t// type of the light (spot or omni)\n\tfloat type;\n\n\t// area light shape\n\tfloat shape;\n\n\t// area light sizes / orientation\n\tvec3 halfWidth;\n\tvec3 halfHeight;\n\n\t// light follow mode\n\tfloat falloffMode;\n\n\t// 1.0 if the light is shadow casting\n\tfloat castShadows;\n\n\t// shadow bias values\n\tfloat shadowBias;\n\tfloat shadowNormalBias;\n\n\t// world space position\n\tvec3 position;\n\n\t// world space direction (spot light only)\n\tvec3 direction;\n\n\t// range of the light\n\tfloat range;\n\n\t// spot light inner and outer angle cosine\n\tfloat innerConeAngleCos;\n\tfloat outerConeAngleCos;\n\n\t// color\n\tvec3 color;\n\n\t// atlas viewport for omni light shadow and cookie (.xy is offset to the viewport slot, .z is size of the face in the atlas)\n\tvec3 omniAtlasViewport;\n\n\t// 1.0 if the light has a cookie texture\n\tfloat cookie;\n\n\t// 1.0 if cookie texture is rgb, otherwise it is using a single channel selectable by cookieChannelMask\n\tfloat cookieRgb;\n\n\t// intensity of the cookie\n\tfloat cookieIntensity;\n\n\t// channel mask - one of the channels has 1, the others are 0\n\tvec4 cookieChannelMask;\n\n\t// light mask\n\tfloat mask;\n};\n\n// Note: on some devices (tested on Pixel 3A XL), this matrix when stored inside the light struct has lower precision compared to\n// when stored outside, so we store it outside to avoid spot shadow flickering. This might need to be done to other / all members\n// of the structure if further similar issues are observed.\n\n// shadow (spot light only) / cookie projection matrix\nmat4 lightProjectionMatrix;\n\n// macros for light properties\n#define isClusteredLightCastShadow(light) ( light.castShadows > 0.5 )\n#define isClusteredLightCookie(light) (light.cookie > 0.5 )\n#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )\n#define isClusteredLightSpot(light) ( light.type > 0.5 )\n#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )\n\n// macros to test light shape\n// Note: Following functions need to be called serially in listed order as they do not test both '>' and '<'\n#define isClusteredLightArea(light) ( light.shape > 0.1 )\n#define isClusteredLightRect(light) ( light.shape < 0.3 )\n#define isClusteredLightDisk(light) ( light.shape < 0.6 )\n\n// macro to test light mask (mesh accepts dynamic vs lightmapped lights)\n#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS\n\t// accept lights marked as dynamic or both dynamic and lightmapped\n\t#define acceptLightMask(light) ( light.mask < 0.75)\n#else\n\t// accept lights marked as lightmapped or both dynamic and lightmapped\n\t#define acceptLightMask(light) ( light.mask > 0.25)\n#endif\n\nvec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {\n\treturn vec4(\n\t\tbytes2floatRange4(d0, -2.0, 2.0),\n\t\tbytes2floatRange4(d1, -2.0, 2.0),\n\t\tbytes2floatRange4(d2, -2.0, 2.0),\n\t\tbytes2floatRange4(d3, -2.0, 2.0)\n\t);\n}\n\n// use LOD sampling if supported to sample data textures as it has better chance of getting skipped inside dynamic branches\n#ifdef SUPPORTS_TEXLOD\n\t#define textureData(texture, uv) texture2DLodEXT(texture, uv, 0.0)\n#else\n\t#define textureData(texture, uv) texture2D(texture, uv)\n#endif\n\nvec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {\n\treturn textureData(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV));\n}\n\nvec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {\n\treturn textureData(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV));\n}\n\nvoid decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {\n\n\t// read omni light properties\n\tclusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;\n\n\t// shared data from 8bit texture\n\tvec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);\n\tclusterLightData.type = lightInfo.x;\n\tclusterLightData.shape = lightInfo.y;\n\tclusterLightData.falloffMode = lightInfo.z;\n\tclusterLightData.castShadows = lightInfo.w;\n\n\t// color\n\tvec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);\n\tvec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);\n\tclusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;\n\n\t// cookie\n\tclusterLightData.cookie = colorB.z;\n\n\t// light mask\n\tclusterLightData.mask = colorB.w;\n\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\n\t\tvec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);\n\t\tclusterLightData.position = lightPosRange.xyz;\n\t\tclusterLightData.range = lightPosRange.w;\n\n\t\t// spot light direction\n\t\tvec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);\n\t\tclusterLightData.direction = lightDir_Unused.xyz;\n\n\t#else	 // 8bit\n\n\t\tvec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);\n\t\tvec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);\n\t\tvec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);\n\t\tclusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;\n\n\t\tvec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);\n\t\tclusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;\n\n\t\t// spot light direction\n\t\tvec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);\n\t\tvec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);\n\t\tvec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);\n\t\tclusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;\n\n\t#endif\n}\n\nvoid decodeClusterLightSpot(inout ClusterLightData clusterLightData) {\n\n\t// spot light cos angles\n\tvec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);\n\tclusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;\n\tclusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;\n}\n\nvoid decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tclusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;\n\t#else\n\t\tvec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);\n\t\tvec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);\n\t\tclusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));\n\t#endif\n}\n\nvoid decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tclusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;\n\t\tclusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;\n\t#else\n\t\tvec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);\n\t\tvec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);\n\t\tvec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);\n\t\tclusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));\n\n\t\tvec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);\n\t\tvec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);\n\t\tvec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);\n\t\tclusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));\n\t#endif\n}\n\nvoid decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {\n\t\n\t// shadow matrix\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tvec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);\n\t\tvec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);\n\t\tvec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);\n\t\tvec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);\n\t#else\n\t\tvec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);\n\t\tvec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);\n\t\tvec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);\n\t\tvec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);\n\t\tvec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);\n\n\t\tvec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);\n\t\tvec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);\n\t\tvec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);\n\t\tvec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);\n\t\tvec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);\n\n\t\tvec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);\n\t\tvec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);\n\t\tvec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);\n\t\tvec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);\n\t\tvec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);\n\n\t\tvec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);\n\t\tvec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);\n\t\tvec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);\n\t\tvec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);\n\t\tvec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));\n\t#endif\n\t\n\tlightProjectionMatrix = mat4(m0, m1, m2, m3);\n}\n\nvoid decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {\n\t\n\t// shadow biases\n\tvec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);\n\tclusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),\n\tclusterLightData.shadowNormalBias = bytes2float2(biases.zw);\n}\n\nvoid decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {\n\n\tvec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);\n\tclusterLightData.cookieIntensity = cookieA.x;\n\tclusterLightData.cookieRgb = cookieA.y;\n\n\tclusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);\n}\n\nvoid evaluateLight(ClusterLightData light) {\n\n\tdAtten3 = vec3(1.0);\n\n\t// evaluate omni part of the light\n\tgetLightDirPoint(light.position);\n\n\t#ifdef CLUSTER_AREALIGHTS\n\n\t// distance attenuation\n\tif (isClusteredLightArea(light)) { // area light\n\n\t\t// area lights\n\t\tdecodeClusterLightAreaData(light);\n\n\t\t// evaluate material based area lights data, shared by all area lights\n\t\tif (LTCLightValuesEvaluated < 0.5) {\n\t\t\tLTCLightValuesEvaluated = 1.0;\n\t\t\tcalcLTCLightValues();\n\t\t}\n\n\t\t// handle light shape\n\t\tif (isClusteredLightRect(light)) {\n\t\t\tcalcRectLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\tcalcDiskLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else { // sphere\n\t\t\tcalcSphereLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t}\n\n\t\tdAtten = getFalloffWindow(light.range);\n\n\t} else\n\n\t#endif\n\n\t{	 // punctual light\n\n\t\tif (isClusteredLightFalloffLinear(light))\n\t\t\tdAtten = getFalloffLinear(light.range);\n\t\telse\n\t\t\tdAtten = getFalloffInvSquared(light.range);\n\t}\n\n\tif (dAtten > 0.00001) {\n\n\t\t#ifdef CLUSTER_AREALIGHTS\n\n\t\tif (isClusteredLightArea(light)) { // area light\n\n\t\t\t// handle light shape\n\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\tdAttenD = getRectLightDiffuse() * 16.0;\n\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\tdAttenD = getDiskLightDiffuse() * 16.0;\n\t\t\t} else { // sphere\n\t\t\t\tdAttenD = getSphereLightDiffuse() * 16.0;\n\t\t\t}\n\n\t\t} else\n\n\t\t#endif\n\n\t\t{\n\t\t\tdAtten *= getLightDiffuse();\n\t\t}\n\n\t\t// spot light falloff\n\t\tif (isClusteredLightSpot(light)) {\n\t\t\tdecodeClusterLightSpot(light);\n\t\t\tdAtten *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos);\n\t\t}\n\n\t\t#if defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)\n\n\t\tif (dAtten > 0.00001) {\n\n\t\t\t// shadow / cookie\n\t\t\tif (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {\n\n\t\t\t\t// shared shadow / cookie data depends on light type\n\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\tdecodeClusterLightProjectionMatrixData(light);\n\t\t\t\t} else {\n\t\t\t\t\tdecodeClusterLightOmniAtlasViewport(light);\n\t\t\t\t}\n\n\t\t\t\tfloat shadowTextureResolution = shadowAtlasParams.x;\n\t\t\t\tfloat shadowEdgePixels = shadowAtlasParams.y;\n\n\t\t\t\t#ifdef CLUSTER_COOKIES\n\n\t\t\t\t// cookie\n\t\t\t\tif (isClusteredLightCookie(light)) {\n\t\t\t\t\tdecodeClusterLightCookieData(light);\n\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\t\tdAtten3 = getCookie2DClustered(cookieAtlasTexture, lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdAtten3 = getCookieCubeClustered(cookieAtlasTexture, dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef CLUSTER_SHADOWS\n\n\t\t\t\t// shadow\n\t\t\t\tif (isClusteredLightCastShadow(light)) {\n\t\t\t\t\tdecodeClusterLightShadowData(light);\n\n\t\t\t\t\tvec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);\n\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\n\t\t\t\t\t\t// spot shadow\n\t\t\t\t\t\tgetShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams);\n\t\t\t\t\t\t\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tdAtten *= getShadowSpotClusteredPCF1(shadowAtlasTexture, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tdAtten *= getShadowSpotClusteredPCF3(shadowAtlasTexture, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tdAtten *= getShadowSpotClusteredPCF5(shadowAtlasTexture, shadowParams);\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// omni shadow\n\t\t\t\t\t\tnormalOffsetPointShadow(shadowParams);	// normalBias adjusted for distance\n\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tdAtten *= getShadowOmniClusteredPCF1(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tdAtten *= getShadowOmniClusteredPCF3(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tdAtten *= getShadowOmniClusteredPCF5(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t#endif\n\t\t\t}\n\t\t}\n\n\t\t#endif\n\n\t\t// diffuse / specular / clearcoat\n\t\t#ifdef CLUSTER_AREALIGHTS\n\n\t\tif (isClusteredLightArea(light)) { // area light\n\n\t\t\t// area light diffuse\n\t\t\t{\n\t\t\t\tvec3 areaDiffuse = (dAttenD * dAtten) * light.color * dAtten3;\n\n\t\t\t\t#if defined(CLUSTER_SPECULAR) && defined(CLUSTER_CONSERVE_ENERGY)\n\t\t\t\t\tareaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);\n\t\t\t\t#endif\n\n\t\t\t\t// area light diffuse - it does not mix diffuse lighting into specular attenuation\n\t\t\t\tdDiffuseLight += areaDiffuse;\n\t\t\t}\n\n\t\t\t// specular and clear coat are material settings and get included by a define based on the material\n\t\t\t#ifdef CLUSTER_SPECULAR\n\n\t\t\t\t// area light specular\n\t\t\t\tfloat areaLightSpecular;\n\n\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\tareaLightSpecular = getRectLightSpecular();\n\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\tareaLightSpecular = getDiskLightSpecular();\n\t\t\t\t} else { // sphere\n\t\t\t\t\tareaLightSpecular = getSphereLightSpecular();\n\t\t\t\t}\n\n\t\t\t\tdSpecularLight += dLTCSpecFres * areaLightSpecular * dAtten * light.color * dAtten3;\n\n\t\t\t\t#ifdef CLUSTER_CLEAR_COAT\n\n\t\t\t\t\t// area light specular clear coat\n\t\t\t\t\tfloat areaLightSpecularCC;\n\n\t\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getRectLightSpecularCC();\n\t\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getDiskLightSpecularCC();\n\t\t\t\t\t} else { // sphere\n\t\t\t\t\t\tareaLightSpecularCC = getSphereLightSpecularCC();\n\t\t\t\t\t}\n\n\t\t\t\t\tccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * dAtten * light.color	* dAtten3;\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t} else\n\n\t\t#endif\n\n\t\t{\t// punctual light\n\n\t\t\t// punctual light diffuse\n\t\t\t{\n\t\t\t\tvec3 punctualDiffuse = dAtten * light.color * dAtten3;\n\n\t\t\t\t#if defined(CLUSTER_AREALIGHTS) && defined(CLUSTER_SPECULAR) && defined(CLUSTER_CONSERVE_ENERGY)\n\t\t\t\t\tpunctualDiffuse = mix(punctualDiffuse, vec3(0), dSpecularity);\n\t\t\t\t#endif\n\n\t\t\t\tdDiffuseLight += punctualDiffuse;\n\t\t\t}\n	 \n\t\t\t// specular and clear coat are material settings and get included by a define based on the material\n\t\t\t#ifdef CLUSTER_SPECULAR\n\n\t\t\t\t// specular\n\t\t\t\t{\n\t\t\t\t\tvec3 punctualSpecular = getLightSpecular() * dAtten * light.color * dAtten3;\n\n\t\t\t\t\t#if defined(CLUSTER_AREALIGHTS)\n\t\t\t\t\t\tpunctualSpecular *= dSpecularity;\n\t\t\t\t\t#endif\n\n\t\t\t\t\tdSpecularLight += punctualSpecular;\n\t\t\t\t}\n\n\t\t\t\t#ifdef CLUSTER_CLEAR_COAT\n\n\t\t\t\t\tvec3 punctualCC = getLightSpecularCC() * dAtten * light.color * dAtten3;\n\n\t\t\t\t\t#if defined(CLUSTER_AREALIGHTS)\n\t\t\t\t\t\tpunctualCC *= ccSpecularity;\n\t\t\t\t\t#endif\n\n\t\t\t\t\tccSpecularLight += punctualCC;\n\t\t\t\t#endif\n\n\t\t\t#endif\n\t\t}\n\t}\n}\n\nvoid evaluateClusterLight(float lightIndex) {\n\n\t// decode core light data from textures\n\tClusterLightData clusterLightData;\n\tdecodeClusterLightCore(clusterLightData, lightIndex);\n\n\t// evaluate light if it uses accepted light mask\n\tif (acceptLightMask(clusterLightData))\n\t\tevaluateLight(clusterLightData);\n}\n\nvoid addClusteredLights() {\n\t// world space position to 3d integer cell cordinates in the cluster structure\n\tvec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);\n\n\t// no lighting when cell coordinate is out of range\n\tif (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {\n\n\t\t// cell index (mapping from 3d cell coordinates to linear memory)\n\t\tfloat cellIndex = dot(clusterCellsDot, cellCoords);\n\n\t\t// convert cell index to uv coordinates\n\t\tfloat clusterV = floor(cellIndex * clusterTextureSize.y);\n\t\tfloat clusterU = cellIndex - (clusterV * clusterTextureSize.x);\n\t\tclusterV = (clusterV + 0.5) * clusterTextureSize.z;\n\n\t\t// loop over maximum possible number of supported light cells\n\t\tconst float maxLightCells = 256.0 / 4.0;	// 8 bit index, each stores 4 lights\n\t\tfor (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {\n\n\t\t\tvec4 lightIndices = textureData(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV));\n\t\t\tvec4 indices = lightIndices * 255.0;\n\n\t\t\t// evaluate up to 4 lights. This is written using a loop instead of manually unrolling to keep shader compile time smaller\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\n\t\t\t\tif (indices.x <= 0.0)\n\t\t\t\t\treturn;\n\n\t\t\t\tevaluateClusterLight(indices.x); \n\t\t\t\tindices = indices.yzwx;\n\t\t\t}\n\n\t\t\t// end of the cell array\n\t\t\tif (lightCellIndex > clusterPixelsPerCell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n";

	var combineClearCoatPS = "vec3 combineColorCC() {\n\treturn combineColor()+(ccSpecularLight*ccSpecularity+ccReflection.rgb*ccSpecularity*ccReflection.a);\n}\n";

	var combineDiffusePS = "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight;\n}\n";

	var combineDiffuseSpecularPS = "vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight, dSpecularLight + dReflection.rgb * dReflection.a, dSpecularity);\n}\n";

	var combineDiffuseSpecularNoConservePS = "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + (dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity;\n}\n";

	var combineDiffuseSpecularNoReflPS = "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity;\n}\n";

	var combineDiffuseSpecularNoReflSeparateAmbientPS = "uniform vec3 material_ambient;\n\nvec3 combineColor() {\n\treturn (dDiffuseLight - light_globalAmbient) * dAlbedo + dSpecularLight * dSpecularity + material_ambient * light_globalAmbient;\n}\n";

	var combineDiffuseSpecularOldPS = "vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity, dReflection.rgb, dReflection.a);\n}\n";

	var cookiePS = "// light cookie functionality for non-clustered lights\nvec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\n\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\n\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\n\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\n\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n\treturn mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n";

	var cubeMapProjectBoxPS = "uniform vec3 envBoxMin, envBoxMax;\n\nvec3 cubeMapProject(vec3 nrdir) {\n\tnrdir = cubeMapRotate(nrdir);\n\n\tvec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n\tvec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n\n\tvec3 rbminmax;\n\trbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n\trbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n\trbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n\n\tfloat fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\n\tvec3 posonbox = vPositionW + nrdir * fa;\n\tvec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n\treturn normalize(posonbox - envBoxPos);\n}\n";

	var cubeMapProjectNonePS = "vec3 cubeMapProject(vec3 dir) {\n\treturn cubeMapRotate(dir);\n}\n";

	var cubeMapRotatePS = "#ifdef CUBEMAP_ROTATION\nuniform mat3 cubeMapRotationMatrix;\n#endif\n\nvec3 cubeMapRotate(vec3 refDir) {\n#ifdef CUBEMAP_ROTATION\n\treturn refDir * cubeMapRotationMatrix;\n#else\n\treturn refDir;\n#endif\n}\n";

	var decodePS = "vec3 decodeLinear(vec4 raw) {\n\treturn raw.rgb;\n}\n\nvec3 decodeGamma(vec4 raw) {\n\treturn pow(raw.xyz, vec3(2.2));\n}\n\nvec3 decodeRGBM(vec4 raw) {\n\tvec3 color = (8.0 * raw.a) * raw.rgb;\n\treturn color * color;\n}\n\nvec3 decodeRGBE(vec4 raw) {\n\tif (raw.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);\n\t}\n}\n\nconst float PI = 3.141592653589793;\n\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\n\nvec2 toSphericalUv(vec3 dir) {\n\tvec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;\n\treturn vec2(uv.x, 1.0 - uv.y);\n}\n\n// equirectangular helper functions\n\n// envAtlas is fixed at 512 pixels. every equirect is generated with 1 pixel boundary.\nconst float atlasSize = 512.0;\nconst float seamSize = 1.0 / atlasSize;\n\n// map a normalized equirect UV to the given rectangle (taking 1 pixel seam into account).\nvec2 mapUv(vec2 uv, vec4 rect) {\n\treturn vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\n\t\t\t\tmix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\n}\n\n// map a normalized equirect UV and roughness level to the correct atlas rect.\nvec2 mapRoughnessUv(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));\n}\n\n// \nvec2 mapMip(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));\n}\n";

	var detailModesPS = "vec3 detailMode_mul(vec3 c1, vec3 c2) {\n\treturn c1 * c2;\n}\n\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n\treturn c1 + c2;\n}\n\n// https://en.wikipedia.org/wiki/Blend_modes#Screen\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n\treturn 1.0 - (1.0 - c1)*(1.0 - c2);\n}\n\n// https://en.wikipedia.org/wiki/Blend_modes#Overlay\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n\treturn mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\n\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n\treturn min(c1, c2);\n}\n\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n\treturn max(c1, c2);\n}\n";

	var diffusePS = "#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseMap;\n#endif\n\nvoid getAlbedo() {\n\tdAlbedo = vec3(1.0);\n\n\t#ifdef MAPCOLOR\n\tdAlbedo *= material_diffuse.rgb;\n\t#endif\n\n\t#ifdef MAPTEXTURE\n\tdAlbedo *= gammaCorrectInput(addAlbedoDetail(texture2D(texture_diffuseMap, $UV, textureBias).$CH));\n\t#endif\n\n\t#ifdef MAPVERTEX\n\tdAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n}\n";

	var diffuseDetailMapPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseDetailMap;\n#endif\n\nvec3 addAlbedoDetail(vec3 albedo) {\n\t#ifdef MAPTEXTURE\n\tvec3 albedoDetail = vec3(texture2D(texture_diffuseDetailMap, $UV, textureBias).$CH);\n\treturn detailMode_$DETAILMODE(albedo, albedoDetail);\n\t#else\n\treturn albedo;\n\t#endif\n}\n";

	var dilatePS = "#define SHADER_NAME Dilate\n\nvarying vec2 vUv0;\n\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n\nvoid main(void) {\n\tvec4 c = texture2D(source, vUv0);\n\tc = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\n\tgl_FragColor = c;\n}\n";

	var bilateralDeNoisePS = "// bilateral filter, based on https://www.shadertoy.com/view/4dfGDH# and\n// http://people.csail.mit.edu/sparis/bf_course/course_notes.pdf\n\n// A bilateral filter is a non-linear, edge-preserving, and noise-reducing smoothing filter for images.\n// It replaces the intensity of each pixel with a weighted average of intensity values from nearby pixels.\n// This weight can be based on a Gaussian distribution. Crucially, the weights depend not only on\n// Euclidean distance of pixels, but also on the radiometric differences (e.g., range differences, such\n// as color intensity, depth distance, etc.). This preserves sharp edges.\n\n#define SHADER_NAME BilateralDeNoise\n\nfloat normpdf3(in vec3 v, in float sigma) {\n\treturn 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\n}\n\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nvec4 encodeRGBM(vec3 color) { // modified RGBM\n\tvec4 encoded;\n\tencoded.rgb = pow(color.rgb, vec3(0.5));\n\tencoded.rgb *= 1.0 / 8.0;\n\n\tencoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n\tencoded.a = ceil(encoded.a * 255.0) / 255.0;\n\n\tencoded.rgb /= encoded.a;\n\treturn encoded;\n}\n\n// filter size\n#define MSIZE 15\n\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nuniform vec2 sigmas;\nuniform float bZnorm;\nuniform float kernel[MSIZE];\n\nvoid main(void) {\n\t\n\tvec4 pixelRgbm = texture2D(source, vUv0);\n\n\t// lightmap specific optimization - skip pixels that were not baked\n\t// this also allows dilate filter that work on the output of this to work correctly, as it depends on .a being zero\n\t// to dilate, which the following blur filter would otherwise modify\n\tif (pixelRgbm.a <= 0.0) {\n\t\tgl_FragColor = pixelRgbm;\n\t\treturn ;\n\t}\n\n\t// range sigma - controls blurriness based on a pixel distance\n\tfloat sigma = sigmas.x;\n\n\t// domain sigma - controls blurriness based on a pixel similarity (to preserve edges)\n\tfloat bSigma = sigmas.y;\n\n\tvec3 pixelHdr = decodeRGBM(pixelRgbm);\n\tvec3 accumulatedHdr = vec3(0.0);\n\tfloat accumulatedFactor = 0.0;\n\n\t// read out the texels\n\tconst int kSize = (MSIZE-1)/2;\n\tfor (int i = -kSize; i <= kSize; ++i) {\n\t\tfor (int j = -kSize; j <= kSize; ++j) {\n\t\t\t\n\t\t\t// sample the pixel with offset\n\t\t\tvec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\n\t\t\tvec4 rgbm = texture2D(source, coord);\n\n\t\t\t// lightmap - only use baked pixels\n\t\t\tif (rgbm.a > 0.0) {\n\t\t\t\tvec3 hdr = decodeRGBM(rgbm);\n\n\t\t\t\t// bilateral factors\n\t\t\t\tfloat factor = kernel[kSize + j] * kernel[kSize + i];\n\t\t\t\tfactor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\n\n\t\t\t\t// accumulate\n\t\t\t\taccumulatedHdr += factor * hdr;\n\t\t\t\taccumulatedFactor += factor;\n\t\t\t}\n\t\t}\n\t}\n\n\tgl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);\n}\n";

	var emissivePS = "#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_emissiveMap;\n#endif\n\nvec3 getEmission() {\n\tvec3 emission = vec3(1.0);\n\n\t#ifdef MAPFLOAT\n\temission *= material_emissiveIntensity;\n\t#endif\n\n\t#ifdef MAPCOLOR\n\temission *= material_emissive;\n\t#endif\n\n\t#ifdef MAPTEXTURE\n\temission *= $texture2DSAMPLE(texture_emissiveMap, $UV, textureBias).$CH;\n\t#endif\n\n\t#ifdef MAPVERTEX\n\temission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n\n\treturn emission;\n}\n";

	var endPS = "\t#ifdef CLEARCOAT\n\tgl_FragColor.rgb = combineColorCC();\n\t#else\n\tgl_FragColor.rgb = combineColor();\n\t#endif \n\n\tgl_FragColor.rgb += getEmission();\n\tgl_FragColor.rgb = addFog(gl_FragColor.rgb);\n\n\t#ifndef HDR\n\tgl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n\tgl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n\t#endif\n";

	var endVS = "\n";

	var envConstPS = "vec3 processEnvironment(vec3 color) {\n\treturn color;\n}\n";

	var envMultiplyPS = "uniform float skyboxIntensity;\n\nvec3 processEnvironment(vec3 color) {\n\treturn color * skyboxIntensity;\n}\n";

	var extensionPS = "\n";

	var extensionVS = "\n";

	var falloffInvSquaredPS = "float getFalloffWindow(float lightRadius) {\n\tfloat sqrDist = dot(dLightDirW, dLightDirW);\n\tfloat invRadius = 1.0 / lightRadius;\n\treturn square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n}\n\nfloat getFalloffInvSquared(float lightRadius) {\n\tfloat sqrDist = dot(dLightDirW, dLightDirW);\n\tfloat falloff = 1.0 / (sqrDist + 1.0);\n\tfloat invRadius = 1.0 / lightRadius;\n\n\tfalloff *= 16.0;\n\tfalloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n\n\treturn falloff;\n}\n";

	var falloffLinearPS = "float getFalloffLinear(float lightRadius) {\n\tfloat d = length(dLightDirW);\n\treturn max(((lightRadius - d) / lightRadius), 0.0);\n}\n";

	var fixCubemapSeamsNonePS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\treturn vec;\n}\n\nvec3 fixSeams(vec3 vec) {\n\treturn vec;\n}\n\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\treturn vec;\n}\n\nvec3 calcSeam(vec3 vec) {\n\treturn vec3(0);\n}\n\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n\treturn vec;\n}\n";

	var fixCubemapSeamsStretchPS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\tvec3 avec = abs(vec);\n\tfloat scale = 1.0 - exp2(mipmapIndex) / 128.0;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\n\nvec3 fixSeams(vec3 vec) {\n\tvec3 avec = abs(vec);\n\tfloat scale = 1.0 - 1.0 / 128.0;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\n\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\tvec3 avec = abs(vec);\n\tfloat scale = invRecMipSize;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\n\nvec3 calcSeam(vec3 vec) {\n\tvec3 avec = abs(vec);\n\tfloat M = max(avec.x, max(avec.y, avec.z));\n\treturn vec3(avec.x != M ? 1.0 : 0.0,\n\t\t\t\tavec.y != M ? 1.0 : 0.0,\n\t\t\t\tavec.z != M ? 1.0 : 0.0);\n}\n\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n\treturn vec * (seam * -scale + vec3(1.0));\n}\n";

	var floatUnpackingPS = "// float unpacking functionality, complimentary to float-packing.js\nfloat bytes2float2(vec2 data) {\n\treturn dot(data, vec2(1.0, 1.0 / 255.0));\n}\n\nfloat bytes2float3(vec3 data) {\n\treturn dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));\n}\n\nfloat bytes2float4(vec4 data) {\n\treturn dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n}\n\nfloat bytes2floatRange2(vec2 data, float min, float max) {\n\treturn mix(min, max, bytes2float2(data));\n}\n\nfloat bytes2floatRange3(vec3 data, float min, float max) {\n\treturn mix(min, max, bytes2float3(data));\n}\n\nfloat bytes2floatRange4(vec4 data, float min, float max) {\n\treturn mix(min, max, bytes2float4(data));\n}\n\nfloat mantissaExponent2Float(vec4 pack)\n{\n\tfloat value = bytes2floatRange3(pack.xyz, -1.0, 1.0);\n\tfloat exponent = floor(pack.w * 255.0 - 127.0);\n\treturn value * exp2(exponent);\n}\n";

	var fogExpPS = "uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\n\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogExp2PS = "uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\n\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * depth * fog_density * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogLinearPS = "uniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nfloat dBlendModeFogFactor = 1.0;\n\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = (fog_end - depth) / (fog_end - fog_start);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\tfogFactor = gammaCorrectInput(fogFactor);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogNonePS = "float dBlendModeFogFactor = 1.0;\n\nvec3 addFog(vec3 color) {\n\treturn color;\n}\n";

	var fresnelSchlickPS = "// Schlick's approximation\nuniform float material_fresnelFactor; // unused\n\nvoid getFresnel() {\n\tfloat fresnel = 1.0 - max(dot(dNormalW, dViewDirW), 0.0);\n\tfloat fresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= dGlossiness * dGlossiness;\n\tdSpecularity = dSpecularity + (1.0 - dSpecularity) * fresnel;\n\n\t#ifdef CLEARCOAT\n\tfresnel = 1.0 - max(dot(ccNormalW, dViewDirW), 0.0);\n\tfresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= ccGlossiness * ccGlossiness;\n\tccSpecularity = ccSpecularity + (1.0 - ccSpecularity) * fresnel;\n\t#endif\n}\n";

	var fullscreenQuadPS = "varying vec2 vUv0;\n\nuniform sampler2D source;\n\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n";

	var fullscreenQuadVS = "attribute vec2 vertex_position;\n\nvarying vec2 vUv0;\n\nvoid main(void)\n{\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tvUv0 = vertex_position.xy*0.5+0.5;\n}\n";

	var gamma1_0PS = "vec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\treturn texture2D(tex, uv);\n}\n\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\treturn texture2D(tex, uv, bias);\n}\n\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\treturn textureCube(tex, uvw);\n}\n\nvec3 gammaCorrectOutput(vec3 color) {\n\treturn color;\n}\n\nvec3 gammaCorrectInput(vec3 color) {\n\treturn color;\n}\n\nfloat gammaCorrectInput(float color) {\n\treturn color;\n}\n\nvec4 gammaCorrectInput(vec4 color) {\n\treturn color;\n}\n";

	var gamma2_2PS = "vec3 gammaCorrectInput(vec3 color) {\n\treturn pow(color, vec3(2.2));\n}\n\nfloat gammaCorrectInput(float color) {\n\treturn pow(color, 2.2);\n}\n\nvec4 gammaCorrectInput(vec4 color) {\n\treturn vec4(pow(color.rgb, vec3(2.2)), color.a);\n}\n\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\tvec4 rgba = texture2D(tex, uv);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\n\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\tvec4 rgba = texture2D(tex, uv, bias);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\n\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\tvec4 rgba = textureCube(tex, uvw);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\n\nvec3 gammaCorrectOutput(vec3 color) {\n\t#ifdef HDR\n\treturn color;\n\t#else\n\tcolor += vec3(0.0000001);\n\treturn pow(color, vec3(0.45));\n\t#endif\n}\n";

	var gles3PS = "#define varying in\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define GL2\n#define SUPPORTS_TEXLOD\n";

	var gles3VS = "#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n";

	var glossPS = "#ifdef MAPFLOAT\nuniform float material_shininess;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_glossMap;\n#endif\n\nvoid getGlossiness() {\n\tdGlossiness = 1.0;\n\n\t#ifdef MAPFLOAT\n\tdGlossiness *= material_shininess;\n\t#endif\n\n\t#ifdef MAPTEXTURE\n\tdGlossiness *= texture2D(texture_glossMap, $UV, textureBias).$CH;\n\t#endif\n\n\t#ifdef MAPVERTEX\n\tdGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\n\tdGlossiness += 0.0000001;\n}\n";

	var instancingVS = "attribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n";

	var lightDiffuseLambertPS = "float getLightDiffuse() {\n\treturn max(dot(dNormalW, -dLightDirNormW), 0.0);\n}\n";

	var lightDirPointPS = "void getLightDirPoint(vec3 lightPosW) {\n\tdLightDirW = vPositionW - lightPosW;\n\tdLightDirNormW = normalize(dLightDirW);\n\tdLightPosW = lightPosW;\n}\n";

	var lightmapDirPS = "uniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\n\nvoid addLightMap() {\n\tvec3 color = $texture2DSAMPLE(texture_lightMap, $UV, textureBias).$CH;\n\tvec3 dir = texture2D(texture_dirLightMap, $UV, textureBias).xyz;\n\tif (dot(dir, vec3(1.0)) < 0.00001) {\n\t\tdDiffuseLight += color;\n\t} else {\n\t\tdLightDirNormW = normalize(dir * 2.0 - vec3(1.0));\n\n\t\tfloat vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\n\t\tfloat flight = saturate(dot(dLightDirNormW, -dNormalW));\n\t\tfloat nlight = (flight / max(vlight, 0.01)) * 0.5;\n\n\t\tdDiffuseLight += color * nlight * 2.0;\n\t}\n\n\tdSpecularLight += color * getLightSpecular();\n}\n";

	var lightmapSinglePS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_lightMap;\n#endif\n\nvoid addLightMap() {\n\tvec3 lm = vec3(1.0);\n\n\t#ifdef MAPTEXTURE\n\tlm *= $texture2DSAMPLE(texture_lightMap, $UV, textureBias).$CH;\n\t#endif\n\n\t#ifdef MAPVERTEX\n\tlm *= saturate(vVertexColor.$VC);\n\t#endif\n\t\n\tdDiffuseLight += lm;\n}\n";

	var lightmapSingleVertPS = "void addLightMap() {\n\tdDiffuseLight += saturate(vVertexColor.$CH);\n}\n";

	var lightSpecularAnisoGGXPS = "// Anisotropic GGX\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tfloat PI = 3.141592653589793;\n\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n\tfloat anisotropy = material_anisotropy * roughness;\n \n\tfloat at = max((roughness + anisotropy), roughness / 4.0);\n\tfloat ab = max((roughness - anisotropy), roughness / 4.0);\n\n\tvec3 h = normalize(normalize(-dLightDirNormW) + normalize(dViewDirW));\n\n\tfloat NoH = dot(tNormalW, h);\n\tfloat ToH = dot(dTBN[0], h);\n\tfloat BoH = dot(dTBN[1], h);\n\n\tfloat a2 = at * ab;\n\tvec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n\tfloat v2 = dot(v, v);\n\tfloat w2 = a2 / v2;\n\tfloat D = a2 * w2 * w2 * (1.0 / PI);\n\n\tfloat ToV = dot(dTBN[0], dViewDirW);\n\tfloat BoV = dot(dTBN[1], dViewDirW);\n\tfloat ToL = dot(dTBN[0], -dLightDirNormW);\n\tfloat BoL = dot(dTBN[1], -dLightDirNormW);\n\tfloat NoV = dot(tNormalW, dViewDirW);\n\tfloat NoL = dot(tNormalW, -dLightDirNormW);\n\n\tfloat lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n\tfloat lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n\tfloat G = 0.5 / (lambdaV + lambdaL);\n\n\treturn D * G;\n}\n\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\n\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n";

	var lightSpecularBlinnPS = "// Energy-conserving (hopefully) Blinn-Phong\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tvec3 h = normalize( -dLightDirNormW + dViewDirW );\n\tfloat nh = max( dot( h, tNormalW ), 0.0 );\n\n\tfloat specPow = exp2(tGlossiness * 11.0); // glossiness is linear, power is not; 0 - 2048\n\tspecPow = antiAliasGlossiness(specPow);\n\n\t// Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little\n\tspecPow = max(specPow, 0.0001);\n\n\treturn pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\n\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\n\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n";

	var lightSpecularPhongPS = "float calcLightSpecular(float tGlossiness, vec3 tReflDirW) {\n\tfloat specPow = tGlossiness;\n\n\tspecPow = antiAliasGlossiness(specPow);\n\n\t// Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little\n\treturn pow(max(dot(tReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\n}\n\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dReflDirW);\n}\n\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccReflDirW);\n}\n";

	var ltc = "// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\n\nstruct Coords {\n\tvec3 coord0;\n\tvec3 coord1;\n\tvec3 coord2;\n\tvec3 coord3;\n};\n\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords.coord1 - rectCoords.coord0;\n\tvec3 v2 = rectCoords.coord3 - rectCoords.coord0;\n\t\n\tvec3 lightNormal = cross( v1, v2 );\n\t// if( dot( lightNormal, P - rectCoords.coord0 ) < 0.0 ) return 0.0;\n\tfloat factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 =	factor * cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords.coord0 - P );\n\tcoords[ 1 ] = mat * ( rectCoords.coord1 - P );\n\tcoords[ 2 ] = mat * ( rectCoords.coord2 - P );\n\tcoords[ 3 ] = mat * ( rectCoords.coord3 - P );\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n\treturn result;\n}\n\nCoords dLTCCoords;\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\tCoords coords;\n\tcoords.coord0 = lightPos + halfWidth - halfHeight;\n\tcoords.coord1 = lightPos - halfWidth - halfHeight;\n\tcoords.coord2 = lightPos - halfWidth + halfHeight;\n\tcoords.coord3 = lightPos + halfWidth + halfHeight;\n\treturn coords;\n}\n\nfloat dSphereRadius;\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\t// used for simple sphere light falloff\n\t// also, the code only handles a spherical light, it cannot be non-uniformly scaled in world space, and so we enforce it here\n\tdSphereRadius = max(length(halfWidth), length(halfHeight));\n\n\t// Billboard the 2d light quad to reflection vector, as it's used for specular. This allows us to use disk math for the sphere.\n\tvec3 f = reflect(normalize(lightPos - view_position), vNormalW);\n\tvec3 w = normalize(cross(f, halfHeight));\n\tvec3 h = normalize(cross(f, w));\n\n\treturn getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\n}\n\n// used for LTC LUT texture lookup\nvec2 dLTCUV;\n#ifdef CLEARCOAT\nvec2 ccLTCUV;\n#endif\nvec2 getLTCLightUV(float tGlossiness, vec3 tNormalW)\n{\n\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n\treturn LTC_Uv( tNormalW, dViewDirW, roughness );\n}\n\n//used for energy conservation and to modulate specular\nvec3 dLTCSpecFres;\n#ifdef CLEARCOAT\nvec3 ccLTCSpecFres;\n#endif\nvec3 getLTCLightSpecFres(vec2 uv, vec3 tSpecularity)\n{\n\tvec4 t2 = texture2D( areaLightsLutTex2, uv );\n\n\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\tt2 *= vec4(0.693103,1,1,1);\n\tt2 += vec4(0.306897,0,0,0);\n\t#endif\n\n\treturn tSpecularity * t2.x + ( vec3( 1.0 ) - tSpecularity) * t2.y;\n}\n\nvoid calcLTCLightValues()\n{\n\tdLTCUV = getLTCLightUV(dGlossiness, dNormalW);\n\tdLTCSpecFres = getLTCLightSpecFres(dLTCUV, dSpecularityNoFres); \n\n#ifdef CLEARCOAT\n\tccLTCUV = getLTCLightUV(ccGlossiness, ccNormalW);\n\tccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(ccSpecularityNoFres));\n#endif\n}\n\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\n}\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tcalcRectLightValues(lightPos, halfWidth, halfHeight);\n}\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\n}\n\n// An extended version of the implementation from\n// \"How to solve a cubic equation, revisited\"\n// http://momentsingraphics.de/?p=105\nvec3 SolveCubic(vec4 Coefficient)\n{\n\tfloat pi = 3.14159;\n\t// Normalize the polynomial\n\tCoefficient.xyz /= Coefficient.w;\n\t// Divide middle coefficients by three\n\tCoefficient.yz /= 3.0;\n\n\tfloat A = Coefficient.w;\n\tfloat B = Coefficient.z;\n\tfloat C = Coefficient.y;\n\tfloat D = Coefficient.x;\n\n\t// Compute the Hessian and the discriminant\n\tvec3 Delta = vec3(\n\t\t-Coefficient.z * Coefficient.z + Coefficient.y,\n\t\t-Coefficient.y * Coefficient.z + Coefficient.x,\n\t\tdot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\n\t);\n\n\tfloat Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\n\n\tvec3 RootsA, RootsD;\n\n\tvec2 xlc, xsc;\n\n\t// Algorithm A\n\t{\n\t\tfloat A_a = 1.0;\n\t\tfloat C_a = Delta.x;\n\t\tfloat D_a = -2.0 * B * Delta.x + Delta.y;\n\n\t\t// Take the cubic root of a normalized complex number\n\t\tfloat Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\n\n\t\tfloat x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\n\t\tfloat x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\n\n\t\tfloat xl;\n\t\tif ((x_1a + x_3a) > 2.0 * B)\n\t\t\txl = x_1a;\n\t\telse\n\t\t\txl = x_3a;\n\n\t\txlc = vec2(xl - B, A);\n\t}\n\n\t// Algorithm D\n\t{\n\t\tfloat A_d = D;\n\t\tfloat C_d = Delta.z;\n\t\tfloat D_d = -D * Delta.y + 2.0 * C * Delta.z;\n\n\t\t// Take the cubic root of a normalized complex number\n\t\tfloat Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\n\n\t\tfloat x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\n\t\tfloat x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\n\n\t\tfloat xs;\n\t\tif (x_1d + x_3d < 2.0 * C)\n\t\t\txs = x_1d;\n\t\telse\n\t\t\txs = x_3d;\n\n\t\txsc = vec2(-D, xs + C);\n\t}\n\n\tfloat E =	xlc.y * xsc.y;\n\tfloat F = -xlc.x * xsc.y - xlc.y * xsc.x;\n\tfloat G =	xlc.x * xsc.x;\n\n\tvec2 xmc = vec2(C * F - B * G, -B * F + C * E);\n\n\tvec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\n\n\tif (Root.x < Root.y && Root.x < Root.z)\n\t\tRoot.xyz = Root.yxz;\n\telse if (Root.z < Root.x && Root.z < Root.y)\n\t\tRoot.xyz = Root.xzy;\n\n\treturn Root;\n}\n\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\n{\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot(V, N));\n\tT2 = cross(N, T1);\n\n\t// rotate area light in (T1, T2, N) basis\n\t//mat3 R = transpose(mat3(T1, T2, N));\n\tmat3 R = transposeMat3( mat3( T1, T2, N ) );\n\t// polygon (allocate 5 vertices for clipping)\n\tvec3 L_[ 3 ];\n\tL_[ 0 ] = R * ( points.coord0 - P );\n\tL_[ 1 ] = R * ( points.coord1 - P );\n\tL_[ 2 ] = R * ( points.coord2 - P );\n\n\tvec3 Lo_i = vec3(0);\n\n\t// init ellipse\n\tvec3 C	= 0.5 * (L_[0] + L_[2]);\n\tvec3 V1 = 0.5 * (L_[1] - L_[2]);\n\tvec3 V2 = 0.5 * (L_[1] - L_[0]);\n\n\tC	= Minv * C;\n\tV1 = Minv * V1;\n\tV2 = Minv * V2;\n\n\t//if(dot(cross(V1, V2), C) > 0.0)\n\t//\treturn 0.0;\n\n\t// compute eigenvectors of ellipse\n\tfloat a, b;\n\tfloat d11 = dot(V1, V1);\n\tfloat d22 = dot(V2, V2);\n\tfloat d12 = dot(V1, V2);\n\tif (abs(d12) / sqrt(d11 * d22) > 0.0001)\n\t{\n\t\tfloat tr = d11 + d22;\n\t\tfloat det = -d12 * d12 + d11 * d22;\n\n\t\t// use sqrt matrix to solve for eigenvalues\n\t\tdet = sqrt(det);\n\t\tfloat u = 0.5 * sqrt(tr - 2.0 * det);\n\t\tfloat v = 0.5 * sqrt(tr + 2.0 * det);\n\t\tfloat e_max = (u + v) * (u + v);\n\t\tfloat e_min = (u - v) * (u - v);\n\n\t\tvec3 V1_, V2_;\n\n\t\tif (d11 > d22)\n\t\t{\n\t\t\tV1_ = d12 * V1 + (e_max - d11) * V2;\n\t\t\tV2_ = d12 * V1 + (e_min - d11) * V2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV1_ = d12*V2 + (e_max - d22)*V1;\n\t\t\tV2_ = d12*V2 + (e_min - d22)*V1;\n\t\t}\n\n\t\ta = 1.0 / e_max;\n\t\tb = 1.0 / e_min;\n\t\tV1 = normalize(V1_);\n\t\tV2 = normalize(V2_);\n\t}\n\telse\n\t{\n\t\ta = 1.0 / dot(V1, V1);\n\t\tb = 1.0 / dot(V2, V2);\n\t\tV1 *= sqrt(a);\n\t\tV2 *= sqrt(b);\n\t}\n\n\tvec3 V3 = cross(V1, V2);\n\tif (dot(C, V3) < 0.0)\n\t\tV3 *= -1.0;\n\n\tfloat L	= dot(V3, C);\n\tfloat x0 = dot(V1, C) / L;\n\tfloat y0 = dot(V2, C) / L;\n\n\tfloat E1 = inversesqrt(a);\n\tfloat E2 = inversesqrt(b);\n\n\ta *= L * L;\n\tb *= L * L;\n\n\tfloat c0 = a * b;\n\tfloat c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\n\tfloat c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\n\tfloat c3 = 1.0;\n\n\tvec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\n\tfloat e1 = roots.x;\n\tfloat e2 = roots.y;\n\tfloat e3 = roots.z;\n\n\tvec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\n\n\tmat3 rotate = mat3(V1, V2, V3);\n\n\tavgDir = rotate * avgDir;\n\tavgDir = normalize(avgDir);\n\n\tfloat L1 = sqrt(-e2 / e3);\n\tfloat L2 = sqrt(-e2 / e1);\n\n\tfloat formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));\n\t\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\n\t// use tabulated horizon-clipped sphere\n\tvec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\n\tuv = uv*LUT_SCALE + LUT_BIAS;\n\n\tfloat scale = texture2D( areaLightsLutTex2, uv ).w;\n\n\treturn formFactor*scale;\n}\n\nfloat getRectLightDiffuse() {\n\treturn LTC_EvaluateRect( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\n\nfloat getDiskLightDiffuse() {\n\treturn LTC_EvaluateDisk( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\n\nfloat getSphereLightDiffuse() {\n\t// NB: this could be improved further with distance based wrap lighting\n\tfloat falloff = dSphereRadius / (dot(dLightDirW, dLightDirW) + dSphereRadius);\n\treturn getLightDiffuse()*falloff;\n}\n\nmat3 getLTCLightInvMat(vec2 uv)\n{\n\tvec4 t1 = texture2D( areaLightsLutTex1, uv );\n\n\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\tt1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);\n\tt1 += vec4(0.0, -0.2976, -0.01381, 0.0);\n\t#endif\n\n\treturn mat3(\n\t\tvec3( t1.x, 0, t1.y ),\n\t\tvec3(\t0, 1,\t0 ),\n\t\tvec3( t1.z, 0, t1.w )\n\t);\n}\n\nfloat calcRectLightSpecular(vec3 tNormalW, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateRect( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\n}\n\nfloat getRectLightSpecular() {\n\treturn calcRectLightSpecular(dNormalW, dLTCUV);\n}\n\n#ifdef CLEARCOAT\nfloat getRectLightSpecularCC() {\n\treturn calcRectLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\n\nfloat calcDiskLightSpecular(vec3 tNormalW, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateDisk( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\n}\n\nfloat getDiskLightSpecular() {\n\treturn calcDiskLightSpecular(dNormalW, dLTCUV);\n}\n\n#ifdef CLEARCOAT\nfloat getDiskLightSpecularCC() {\n\treturn calcDiskLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\n\nfloat getSphereLightSpecular() {\n\treturn calcDiskLightSpecular(dNormalW, dLTCUV);\n}\n\n#ifdef CLEARCOAT\nfloat getSphereLightSpecularCC() {\n\treturn calcDiskLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\n";

	var metalnessPS = "void processMetalness(float metalness) {\n\tconst float dielectricF0 = 0.04;\n\tdSpecularity = mix(vec3(dielectricF0), dAlbedo, metalness);\n\tdAlbedo *= 1.0 - metalness;\n}\n\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_metalnessMap;\n#endif\n\nvoid getSpecularity() {\n\tfloat metalness = 1.0;\n\n\t#ifdef MAPFLOAT\n\tmetalness *= material_metalness;\n\t#endif\n\n\t#ifdef MAPTEXTURE\n\tmetalness *= texture2D(texture_metalnessMap, $UV, textureBias).$CH;\n\t#endif\n\n\t#ifdef MAPVERTEX\n\tmetalness *= saturate(vVertexColor.$VC);\n\t#endif\n\n\tprocessMetalness(metalness);\n}\n";

	var msdfPS = "uniform sampler2D texture_msdfMap;\n\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n\n#ifdef GL2\n#define USE_FWIDTH\n#endif\n\nfloat median(float r, float g, float b) {\n\treturn max(min(r, g), min(max(r, g), b));\n}\n\nfloat map (float min, float max, float v) {\n\treturn (v - min) / (max - min);\n}\n\nuniform float font_sdfIntensity; // intensity is used to boost the value read from the SDF, 0 is no boost, 1.0 is max boost\nuniform float font_pxrange;\t	// the number of pixels between inside and outside the font in SDF\nuniform float font_textureWidth; // the width of the texture atlas\n\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\n\nvec4 applyMsdf(vec4 color) {\n\t// sample the field\n\tvec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n\tvec2 uvShdw = vUv0 - shadow_offset;\n\tvec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n\t// get the signed distance value\n\tfloat sigDist = median(tsample.r, tsample.g, tsample.b);\n\tfloat sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\n\t// smoothing limit - smaller value makes for sharper but more aliased text, especially on angles\n\t// too large value (0.5) creates a dark glow around the letters\n\tfloat smoothingMax = 0.2;\n\n\t#ifdef USE_FWIDTH\n\t// smoothing depends on size of texture on screen\n\tvec2 w = fwidth(vUv0);\n\tfloat smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\n\t#else\n\tfloat font_size = 16.0; // TODO fix this\n\t// smoothing gets smaller as the font size gets bigger\n\t// don't have fwidth we can approximate from font size, this doesn't account for scaling\n\t// so a big font scaled down will be wrong...\n\tfloat smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);\n\t#endif\n\n\tfloat mapMin = 0.05;\n\tfloat mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\n\t// remap to a smaller range (used on smaller font sizes)\n\tfloat sigDistInner = map(mapMin, mapMax, sigDist);\n\tfloat sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n\tsigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\n\tfloat center = 0.5;\n\t// calculate smoothing and use to generate opacity\n\tfloat inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n\tfloat outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n\tfloat shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\n\tvec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n\ttcolor = mix(tcolor, color, inside);\n\n\tvec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n\ttcolor = mix(scolor, tcolor, outline);\n\t\n\treturn tcolor;\n}\n";

	var normalVS = "#ifdef MORPHING_TEXTURE_BASED_NORMAL\nuniform highp sampler2D morphNormalTex;\n#endif\n\nvec3 getNormal() {\n\t#ifdef SKIN\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\t#elif defined(INSTANCING)\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\t#else\n\tdNormalMatrix = matrix_normal;\n\t#endif\n\n\tvec3 tempNormal = vertex_normal;\n\n\t#ifdef MORPHING\n\t#ifdef MORPHING_NRM03\n\ttempNormal += morph_weights_a[0] * morph_nrm0;\n\ttempNormal += morph_weights_a[1] * morph_nrm1;\n\ttempNormal += morph_weights_a[2] * morph_nrm2;\n\ttempNormal += morph_weights_a[3] * morph_nrm3;\n\t#endif\n\t#ifdef MORPHING_NRM47\n\ttempNormal += morph_weights_b[0] * morph_nrm4;\n\ttempNormal += morph_weights_b[1] * morph_nrm5;\n\ttempNormal += morph_weights_b[2] * morph_nrm6;\n\ttempNormal += morph_weights_b[3] * morph_nrm7;\n\t#endif\n\t#endif\n\n\t#ifdef MORPHING_TEXTURE_BASED_NORMAL\n\t// apply morph offset from texture\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;\n\ttempNormal += morphNormal;\n\t#endif\n\n\treturn normalize(dNormalMatrix * tempNormal);\n}\n";

	var normalDetailMapPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_normalDetailMap;\nuniform float material_normalDetailMapBumpiness;\n\nvec3 blendNormals(vec3 n1, vec3 n2) {\n\t// https://blog.selfshadow.com/publications/blending-in-detail/#detail-oriented\n\tn1 += vec3(0, 0, 1);\n\tn2 *= vec3(-1, -1, 1);\n\treturn normalize(n1*dot(n1, n2)/n1.z - n2);\n}\n#endif\n\nvec3 addNormalDetail(vec3 normalMap) {\n\t#ifdef MAPTEXTURE\n\tvec3 normalDetailMap = unpackNormal(texture2D(texture_normalDetailMap, $UV, textureBias));\n\tnormalDetailMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness));\n\treturn blendNormals(normalMap, normalDetailMap);\n\t#else\n\treturn normalMap;\n\t#endif\n}\n";

	var normalInstancedVS = "vec3 getNormal() {\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n";

	var normalMapPS = "uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\n\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV, textureBias));\n\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n}\n";

	var normalMapFastPS = "uniform sampler2D texture_normalMap;\n\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV, textureBias));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n}\n";

	var normalSkinnedVS = "vec3 getNormal() {\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n";

	var normalVertexPS = "void getNormal() {\n\tdNormalW = normalize(dVertexNormalW);\n}\n";

	var normalXYPS = "vec3 unpackNormal(vec4 nmap) {\n\tvec3 normal;\n\tnormal.xy = nmap.wy * 2.0 - 1.0;\n\tnormal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\treturn normal;\n}\n";

	var normalXYZPS = "vec3 unpackNormal(vec4 nmap) {\n\treturn nmap.xyz * 2.0 - 1.0;\n}\n";

	var opacityPS = "#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_opacityMap;\n#endif\n\nvoid getOpacity() {\n\tdAlpha = 1.0;\n\n\t#ifdef MAPFLOAT\n\tdAlpha *= material_opacity;\n\t#endif\n\n\t#ifdef MAPTEXTURE\n\tdAlpha *= texture2D(texture_opacityMap, $UV, textureBias).$CH;\n\t#endif\n\n\t#ifdef MAPVERTEX\n\tdAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n\t#endif\n}\n";

	var outputAlphaPS = "gl_FragColor.a = dAlpha;\n";

	var outputAlphaOpaquePS = "gl_FragColor.a = 1.0;\n";

	var outputAlphaPremulPS = "gl_FragColor.rgb *= dAlpha;\ngl_FragColor.a = dAlpha;\n";

	var outputTex2DPS = "varying vec2 vUv0;\n\nuniform sampler2D source;\n\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n";

	var packDepthPS = "// Packing a float in GLSL with multiplication and mod\n// http://blog.gradientstudios.com/2012/08/23/shadow-map-improvement\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask	= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\n\t// combination of mod and multiplication and division works better\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n";

	var parallaxPS = "uniform sampler2D texture_heightMap;\nuniform float material_heightMapFactor;\n\nvoid getParallax() {\n\tfloat parallaxScale = material_heightMapFactor;\n\n\tfloat height = texture2D(texture_heightMap, $UV, textureBias).$CH;\n\theight = height * parallaxScale - parallaxScale*0.5;\n\tvec3 viewDirT = dViewDirW * dTBN;\n\n\tviewDirT.z += 0.42;\n\tdUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n";

	var particlePS = "varying vec4 texCoordsAlphaLife;\n\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n\nuniform float softening;\nuniform float colorMult;\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\tfloat depth = dot(rgbaDepth, bitShift);\n\treturn depth;\n}\n#endif\n\nvoid main(void) {\n\tvec4 tex	= texture2DSRGB(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y));\n\tvec4 ramp = texture2DSRGB(colorParam, vec2(texCoordsAlphaLife.w, 0.0));\n\tramp.rgb *= colorMult;\n\n\tramp.a += texCoordsAlphaLife.z;\n\n\tvec3 rgb = tex.rgb * ramp.rgb;\n\tfloat a	= tex.a * ramp.a;\n";

	var particleVS = "vec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {\n\treturn mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\n\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex,tc);\n\tvec4 b = texture2D(tex,tc + graphSampleSize);\n\tfloat c = fract(tc.x*graphNumSamples);\n\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\n\treturn mix(a, b, c);\n}\n\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\n\treturn m * quadXY;\n}\n\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n\t#ifdef SCREEN_SPACE\n\t\tvec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n\t#else\n\t\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\t#endif\n\n\treturn pos;\n}\n\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\n\nvec2 safeNormalize(vec2 v) {\n\tfloat l = length(v);\n\treturn (l > 1e-06) ? v / l : v;\n}\n\nvoid main(void) {\n\tvec3 meshLocalPos = particle_vertexData.xyz;\n\tfloat id = floor(particle_vertexData.w);\n\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\n\tfloat uv = id / numParticlesPot;\n\treadInput(uv);\n\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used\n\n\tfloat particleLifetime = lifetime;\n\n\tif (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n\tvec2 quadXY = meshLocalPos.xy;\n\tfloat nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\n\tvec3 paramDiv;\n\tvec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat scale = params.y;\n\tfloat scaleDiv = paramDiv.x;\n\tfloat alphaDiv = paramDiv.z;\n\n\tscale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n\n#ifndef USE_MESH\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n\ttexCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n\n\tvec3 particlePos = inPos;\n\tvec3 particlePosMoved = vec3(0.0);\n\n\tmat2 rotMatrix;\n";

	var particleAnimFrameClampVS = "\tfloat animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n";

	var particleAnimFrameLoopVS = "\tfloat animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n";

	var particleAnimTexVS = "\tfloat animationIndex;\n\n\tif (animTexIndexParams.y == 1.0) {\n\t\tanimationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n\t} else {\n\t\tanimationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n\t}\n\n\tfloat atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n\tfloat atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n\tatlasX = fract(atlasX);\n\n\ttexCoordsAlphaLife.xy *= animTexTilesParams.xy;\n\ttexCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n";

	var particleInputFloatPS = "void readInput(float uv) {\n\tvec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n\n\tinPos = tex.xyz;\n\tinVel = tex2.xyz;\n\tinAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n\tinShow = tex.w >= 0.0;\n\tinLife = tex2.w;\n}\n";

	var particleInputRgba8PS = "//RG=X, BA=Y\n//RG=Z, BA=A\n//RGB=V, A=visMode\n//RGBA=life\n\n#define PI2 6.283185307179586\n\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\n\nuniform float maxVel;\n\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\n\nfloat decodeFloatRGBA( vec4 rgba ) {\n	return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\n\nvoid readInput(float uv) {\n\tvec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n\tvec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n\tvec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n\n\tinPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n\tinPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n\n\tinVel = tex2.xyz;\n\tinVel = (inVel - vec3(0.5)) * maxVel;\n\n\tinAngle = decodeFloatRG(tex1.ba) * PI2;\n\tinShow = tex2.a > 0.5;\n\n\tinLife = decodeFloatRGBA(tex3);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\tinLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n";

	var particleOutputFloatPS = "void writeOutput() {\n\tif (gl_FragCoord.y<1.0) {\n\t\tgl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n\t} else {\n\t\tgl_FragColor = vec4(outVel, outLife);\n\t}\n}\n";

	var particleOutputRgba8PS = "uniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\n\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\n\nvec4 encodeFloatRGBA( float v ) {\n\tvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n\treturn enc;\n}\n\nvoid writeOutput() {\n\toutPos = outPos * outBoundsMul + outBoundsAdd;\n\toutAngle = fract(outAngle / PI2);\n\n\toutVel = (outVel / maxVel) + vec3(0.5); // TODO: mul\n\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\toutLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\n\tif (gl_FragCoord.y < 1.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n\t} else if (gl_FragCoord.y < 2.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n\t} else if (gl_FragCoord.y < 3.0) {\n\t\tgl_FragColor = vec4(outVel, visMode*0.5+0.5);\n\t} else {\n\t\tgl_FragColor = encodeFloatRGBA(outLife);\n\t}\n}\n";

	var particleUpdaterAABBPS = "uniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\n\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tvec3 pos = inBounds - vec3(0.5);\n\n\tvec3 posAbs = abs(pos);\n\tvec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n\n\tvec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n\n\tpos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n\tpos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n\tpos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n\n#ifndef LOCAL_SPACE\n\treturn emitterPos + spawnBounds * pos;\n#else\n\treturn spawnBounds * pos;\n#endif\n}\n\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity -= vec3(0, 0, initialVelocity);\n}\n";

	var particleUpdaterEndPS = "\twriteOutput();\n}\n";

	var particleUpdaterInitPS = "varying vec2 vUv0;\n\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\n\nuniform mat3 emitterMatrix, emitterMatrixInv;\nuniform vec3 emitterScale;\n\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;\nuniform float startAngle, startAngle2;\nuniform float initialVelocity;\n\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\n\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n";

	var particleUpdaterNoRespawnPS = "\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = -1.0;\n\t}\n";

	var particleUpdaterOnStopPS = "\tvisMode = outLife < 0.0? -1.0: visMode;\n";

	var particleUpdaterRespawnPS = "\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = 1.0;\n\t}\n\tvisMode = outLife < 0.0? 1.0: visMode;\n";

	var particleUpdaterSpherePS = "uniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\n\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tfloat rnd4 = fract(rndFactor * 1000.0);\n\tvec3 norm = normalize(inBounds.xyz - vec3(0.5));\n\tfloat r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n\treturn emitterPos + norm * r * spawnBoundsSphere;\n#else\n\treturn norm * r * spawnBoundsSphere;\n#endif\n}\n\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n";

	var particleUpdaterStartPS = "float saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nvec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\n\nvec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex, tc);\n\tvec4 b = texture2D(tex, tc + graphSampleSize);\n\tfloat c = fract(tc.x * graphNumSamples);\n\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\n\treturn mix(a.xyz, b.xyz, c);\n}\n\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\nvoid main(void) {\n\tif (gl_FragCoord.x > numParticles) discard;\n\n\treadInput(vUv0.x);\n\tvisMode = inShow? 1.0 : -1.0;\n\n\tvec4 rndFactor = hash41(gl_FragCoord.x + seed);\n\n\tfloat particleRate = rate + rateDiv * rndFactor.x;\n\n\toutLife = inLife + delta;\n\tfloat nlife = clamp(outLife / lifetime, 0.0, 1.0);\n\n\tvec3 localVelocityDiv;\n\tvec3 velocityDiv;\n\tvec3 paramDiv;\n\tvec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\n\tvec3 velocity =\t	tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\n\tvec3 params =\t\ttex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat rotSpeed = params.x;\n\tfloat rotSpeedDiv = paramDiv.y;\n\n\tvec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);\n\tfloat radialSpeed = radialParams.x;\n\tfloat radialSpeedDiv = radialParams.y;\n\n\tbool respawn = inLife <= 0.0 || outLife >= lifetime;\n\tinPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n\tinAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n\n#ifndef LOCAL_SPACE\n\tvec3 radialVel = inPos - emitterPos;\n#else\n\tvec3 radialVel = inPos;\n#endif\n\tradialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n\tradialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n\n\tlocalVelocity +=\t(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n\tvelocity +=\t\t (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n\trotSpeed +=\t\t (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n\n\taddInitialVelocity(localVelocity, rndFactor.xyz);\n\n#ifndef LOCAL_SPACE\n\toutVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n\toutVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n\n\toutPos = inPos + outVel * delta;\n\toutAngle = inAngle + rotSpeed * delta;\n";

	var particle_billboardVS = "\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = billboard(particlePos, quadXY);\n";

	var particle_blendAddPS = "\tdBlendModeFogFactor = 0.0;\n\trgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n\tif ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n";

	var particle_blendMultiplyPS = "\trgb = mix(vec3(1.0), rgb, vec3(a));\n\tif (rgb.r + rgb.g + rgb.b > 2.99) discard;\n";

	var particle_blendNormalPS = "\tif (a < 0.01) discard;\n";

	var particle_cpuVS = "attribute vec4 particle_vertexData;	 // XYZ = world pos, W = life\nattribute vec4 particle_vertexData2;	// X = angle, Y = scale, Z = alpha, W = velocity.x\nattribute vec4 particle_vertexData3;	// XYZ = particle local pos, W = velocity.y\nattribute float particle_vertexData4; // particle id\n#ifndef USE_MESH\n#define VDATA5TYPE vec2\n#else\n#define VDATA5TYPE vec4\n#endif\nattribute VDATA5TYPE particle_vertexData5; // VDATA4TYPE depends on useMesh property. Start with X = velocity.z, Y = particle ID and for mesh particles proceeds with Z = mesh UV.x, W = mesh UV.y\n\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds, emitterScale, faceTangent, faceBinorm;\nuniform sampler2D texLifeAndSourcePosOUT;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform vec3 emitterPos;\n\nvarying vec4 texCoordsAlphaLife;\n\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\t//vec4 rotationMatrix = vec4(c, -s, s, c);\n\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\n\treturn m * quadXY;\n}\n\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\treturn pos;\n}\n\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\n\nvoid main(void)\n{\n\tvec3 particlePos = particle_vertexData.xyz;\n\tvec3 inPos = particlePos;\n\tvec3 vertPos = particle_vertexData3.xyz;\n\tvec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n\n\tfloat id = floor(particle_vertexData4);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = normalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used\n\n\tvec2 quadXY = vertPos.xy;\n\n#ifdef USE_MESH\n\ttexCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#else\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#endif\n\tmat2 rotMatrix;\n\n\tfloat inAngle = particle_vertexData2.x;\n\tvec3 particlePosMoved = vec3(0.0);\n\tvec3 meshLocalPos = particle_vertexData3.xyz;\n";

	var particle_cpu_endVS = "\tlocalPos *= particle_vertexData2.y * emitterScale;\n\tlocalPos += particlePos;\n\n\tgl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n";

	var particle_customFaceVS = "\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = customFace(particlePos, quadXY);\n";

	var particle_endPS = "\trgb = addFog(rgb);\n\trgb = toneMap(rgb);\n\trgb = gammaCorrectOutput(rgb);\n\tgl_FragColor = vec4(rgb, a);\n}\n";

	var particle_endVS = "\tlocalPos *= scale * emitterScale;\n\tlocalPos += particlePos;\n\n\t#ifdef SCREEN_SPACE\n\tgl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n\t#else\n\tgl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n\t#endif\n";

	var particle_halflambertPS = "\tvec3 negNormal = normal*0.5+0.5;\n\tvec3 posNormal = -normal*0.5+0.5;\n\tnegNormal *= negNormal;\n\tposNormal *= posNormal;\n";

	var particle_initVS = "attribute vec4 particle_vertexData; // XYZ = particle position, W = particle ID + random factor\n#ifdef USE_MESH\nattribute vec2 particle_uv;\t\t // mesh UV\n#endif\n\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nuniform float numParticles, numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\nuniform sampler2D particleTexOUT, particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\n\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n\nvarying vec4 texCoordsAlphaLife;\n\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n";

	var particle_lambertPS = "\tvec3 negNormal = max(normal, vec3(0.0));\n\tvec3 posNormal = max(-normal, vec3(0.0));\n";

	var particle_lightingPS = "\tvec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n\t\t\t\t\t\tnegNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n\t\t\t\t\t\tnegNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n\n\trgb *= light;\n";

	var particle_localShiftVS = "\tparticlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n";

	var particle_meshVS = "\tvec3 localPos = meshLocalPos;\n\tlocalPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n\tlocalPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n\n\tbillboard(particlePos, quadXY);\n";

	var particle_normalVS = "\tNormal = normalize(localPos + matrix_viewInverse[2].xyz);\n";

	var particle_normalMapPS = "\tvec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\n\tvec3 normal = ParticleMat * normalMap;\n";

	var particle_pointAlongVS = "\tinAngle = atan(velocityV.x, velocityV.y); // not the fastest way, but easier to plug in; TODO: create rot matrix right from vectors\n\n";

	var particle_softPS = "\tfloat depth = getLinearScreenDepth();\n\tfloat particleDepth = vDepth;\n\tfloat depthDiff = saturate(abs(particleDepth - depth) * softening);\n\ta *= depthDiff;\n";

	var particle_softVS = "\tvDepth = getLinearDepth(localPos);\n";

	var particle_stretchVS = "\tvec3 moveDir = inVel * stretch;\n\tvec3 posPrev = particlePos - moveDir;\n\tposPrev += particlePosMoved;\n\n\tvec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n\n\tfloat interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n\n\tparticlePos = mix(particlePos, posPrev, interpolation);\n";

	var particle_TBNVS = "\tmat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n\tParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n";

	var particle_wrapVS = "\tvec3 origParticlePos = particlePos;\n\tparticlePos -= matrix_model[3].xyz;\n\tparticlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n\tparticlePos += matrix_model[3].xyz;\n\tparticlePosMoved = particlePos - origParticlePos;\n";

	var precisionTestPS = "void main(void) {\n\tgl_FragColor = vec4(2147483648.0);\n}\n";

	var precisionTest2PS = "uniform sampler2D source;\n\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask	= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n\nvoid main(void) {\n\tfloat c = texture2D(source, vec2(0.0)).r;\n\tfloat diff = abs(c - 2147483648.0) / 2147483648.0;\n\tgl_FragColor = packFloat(diff);\n}\n";

	var reflDirPS = "void getReflDir() {\n\tdReflDirW = normalize(-reflect(dViewDirW, dNormalW));\n}\n";

	var reflDirAnisoPS = "void getReflDir() {\n\tfloat roughness = sqrt(1.0 - min(dGlossiness, 1.0));\n\tfloat anisotropy = material_anisotropy * roughness;\n\tvec3 anisotropicDirection = anisotropy >= 0.0 ? dTBN[1] : dTBN[0];\n\tvec3 anisotropicTangent = cross(anisotropicDirection, dViewDirW);\n\tvec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n\tvec3 bentNormal = normalize(mix(normalize(dNormalW), normalize(anisotropicNormal), anisotropy));\n\tdReflDirW = reflect(-dViewDirW, bentNormal);\n}\n";

	var reflectionCCPS = "#ifdef CLEARCOAT\nuniform float material_clearCoatReflectivity;\n\nvoid addReflectionCC() {\n\tccReflection += vec4(calcReflection(ccReflDirW, ccGlossiness), material_clearCoatReflectivity);\n}\n#endif\n";

	var reflectionCubePS = "uniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 lookupVec = fixSeams(cubeMapProject(tReflDirW));\n\tlookupVec.x *= -1.0;\n\treturn $DECODE(textureCube(texture_cubeMap, lookupVec));\n}\n\nvoid addReflection() {	 \n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var reflectionEnvPS = "#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform float material_reflectivity;\n\n// calculate mip level for shiny reflection given equirect coords uv.\nfloat shinyMipLevel(vec2 uv) {\n\tvec2 dx = dFdx(uv);\n\tvec2 dy = dFdy(uv);\n\n\t// calculate second dF at 180 degrees\n\tvec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\n\tvec2 dx2 = dFdx(uv2);\n\tvec2 dy2 = dFdy(uv2);\n\n\t// calculate min of both sets of dF to handle discontinuity at the azim edge\n\tfloat maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\n\n\treturn clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);\n}\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 dir = cubeMapProject(tReflDirW) * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(dir);\n\n\t// calculate roughness level\n\tfloat level = saturate(1.0 - tGlossiness) * 5.0;\n\tfloat ilevel = floor(level);\n\n\t// accessing the shiny (top level) reflection - perform manual mipmap lookup\n\tfloat level2 = shinyMipLevel(uv * atlasSize);\n\tfloat ilevel2 = floor(level2);\n\n\tvec2 uv0, uv1;\n\tfloat weight;\n\tif (ilevel == 0.0) {\n\t\tuv0 = mapMip(uv, ilevel2);\n\t\tuv1 = mapMip(uv, ilevel2 + 1.0);\n\t\tweight = level2 - ilevel2;\n\t} else {\n\t\t// accessing rough reflection - just sample the same part twice\n\t\tuv0 = uv1 = mapRoughnessUv(uv, ilevel);\n\t\tweight = 0.0;\n\t}\n\n\tvec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));\n\tvec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));\n\tvec3 linear0 = mix(linearA, linearB, weight);\n\tvec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\n\treturn processEnvironment(mix(linear0, linear1, level - ilevel));\n}\n\nvoid addReflection() {	 \n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var reflectionSpherePS = "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = (mat3(matrix_view) * tReflDirW).xyz;\n\n\tfloat m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n\tvec2 sphereMapUv = reflDirV.xy / m + 0.5;\n\n\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\n\nvoid addReflection() {	 \n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var reflectionSphereLowPS = "uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = vNormalV;\n\n\tvec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\n\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\n\nvoid addReflection() {	 \n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var refractionPS = "uniform float material_refraction, material_refractionIndex;\n\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n\tfloat vn = dot(viewVec, Normal);\n\tfloat k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n\tvec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n\treturn refrVec;\n}\n\nvoid addRefraction() {\n\t// use same reflection code with refraction vector\n\tvec3 tmp = dReflDirW;\n\tvec4 tmp2 = dReflection;\n\tdReflection = vec4(0.0);\n\tdReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\n\n\taddReflection();\n\n\tdDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, material_refraction);\n\tdReflDirW = tmp;\n\tdReflection = tmp2;\n}\n";

	var reprojectPS = "// This shader requires the following #DEFINEs:\n//\n// PROCESS_FUNC - must be one of reproject, prefilter\n// DECODE_FUNC - must be one of decodeRGBM, decodeRGBE, decodeGamma or decodeLinear\n// ENCODE_FUNC - must be one of encodeRGBM, encodeRGBE, encideGamma or encodeLinear\n// SOURCE_FUNC - must be one of sampleCubemap, sampleEquirect, sampleOctahedral\n// TARGET_FUNC - must be one of getDirectionCubemap, getDirectionEquirect, getDirectionOctahedral\n//\n// When filtering:\n// NUM_SAMPLES - number of samples\n//\n// SUPPORTS_TEXLOD - whether supports texlod is supported\n\nvarying vec2 vUv0;\n\n// source\nuniform sampler2D sourceTex;\nuniform samplerCube sourceCube;\n\n// samples\nuniform sampler2D samplesTex;\nuniform vec2 samplesTexInverseSize;\n\n// params:\n// x - target cubemap face 0..6\n// y - specular power (when prefiltering)\n// z - source cubemap seam scale (0 to disable)\n// w - target cubemap size for seam calc (0 to disable)\nuniform vec4 params;\n\n// params2:\n// x - target image total pixels\n// y - source cubemap size\nuniform vec2 params2;\n\nfloat targetFace() { return params.x; }\nfloat specularPower() { return params.y; }\nfloat sourceCubeSeamScale() { return params.z; }\nfloat targetCubeSeamScale() { return params.w; }\n\nfloat targetTotalPixels() { return params2.x; }\nfloat sourceTotalPixels() { return params2.y; }\n\nfloat PI = 3.141592653589793;\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\n//-- supported codings\n\nvec3 decodeLinear(vec4 source) {\n\treturn source.rgb;\n}\n\nvec4 encodeLinear(vec3 source) {\n\treturn vec4(source, 1.0);\n}\n\nvec3 decodeGamma(vec4 source) {\n\treturn pow(source.xyz, vec3(2.2));\n}\n\nvec4 encodeGamma(vec3 source) {\n\treturn vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\n\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\n\nvec4 encodeRGBM(vec3 source) { // modified RGBM\n\tvec4 result;\n\tresult.rgb = pow(source.rgb, vec3(0.5));\n\tresult.rgb *= 1.0 / 8.0;\n\n\tresult.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n\tresult.a = ceil(result.a * 255.0) / 255.0;\n\n\tresult.rgb /= result.a;\n\treturn result;\n}\n\nvec3 decodeRGBE(vec4 source) {\n\tif (source.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn source.xyz * pow(2.0, source.w * 255.0 - 128.0);\n\t}\n}\n\nvec4 encodeRGBE(vec3 source) {\n\tfloat maxVal = max(source.x, max(source.y, source.z));\n\tif (maxVal < 1e-32) {\n\t\treturn vec4(0, 0, 0, 0);\n\t} else {\n\t\tfloat e = ceil(log2(maxVal));\n\t\treturn vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n\t}\n}\n\n//-- supported projections\n\nvec3 modifySeams(vec3 dir, float scale) {\n\tvec3 adir = abs(dir);\n\tfloat M = max(max(adir.x, adir.y), adir.z);\n\treturn dir / M * vec3(\n\t\tadir.x == M ? 1.0 : scale,\n\t\tadir.y == M ? 1.0 : scale,\n\t\tadir.z == M ? 1.0 : scale\n\t);\n}\n\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\n\nvec3 fromSpherical(vec2 uv) {\n\treturn vec3(cos(uv.y) * sin(uv.x),\n\t\t\t\tsin(uv.y),\n\t\t\t\tcos(uv.y) * cos(uv.x));\n}\n\nvec3 getDirectionEquirect() {\n\treturn fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\n\nvec4 sampleEquirect(vec2 sph) {\n\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n}\n\nvec4 sampleEquirect(vec3 dir) {\n\treturn sampleEquirect(toSpherical(dir));\n}\n\nvec4 sampleCubemap(vec3 dir) {\n\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));\n}\n\nvec4 sampleCubemap(vec2 sph) {\n\treturn sampleCubemap(fromSpherical(sph));\n}\n\nvec4 sampleEquirect(vec2 sph, float mipLevel) {\n\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n#ifdef SUPPORTS_TEXLOD\n\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n#else\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n#endif\n}\n\nvec4 sampleEquirect(vec3 dir, float mipLevel) {\n\treturn sampleEquirect(toSpherical(dir), mipLevel);\n}\n\nvec4 sampleCubemap(vec3 dir, float mipLevel) {\n#ifdef SUPPORTS_TEXLOD\n\treturn textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);\n#else\n\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()));\n#endif\n}\n\nvec4 sampleCubemap(vec2 sph, float mipLevel) {\n\treturn sampleCubemap(fromSpherical(sph), mipLevel);\n}\n\n// octahedral code, based on http://jcgt.org/published/0003/02/01\n// \"Survey of Efficient Representations for Independent Unit Vectors\" by Cigolle, Donow, Evangelakos, Mara, McGuire, Meyer\n\nfloat signNotZero(float k){\n\treturn(k >= 0.0) ? 1.0 : -1.0;\n}\n\nvec2 signNotZero(vec2 v) {\n\treturn vec2(signNotZero(v.x), signNotZero(v.y));\n}\n\n// Returns a unit vector. Argument o is an octahedral vector packed via octEncode, on the [-1, +1] square\nvec3 octDecode(vec2 o) {\n\tvec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\n\tif (v.y < 0.0) {\n\t\tv.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);\n\t}\n\treturn normalize(v);\n}\n\nvec3 getDirectionOctahedral() {\n\treturn octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);\n}\n\n// Assumes that v is a unit vector. The result is an octahedral vector on the [-1, +1] square\nvec2 octEncode(in vec3 v) {\n\tfloat l1norm = abs(v.x) + abs(v.y) + abs(v.z);\n\tvec2 result = v.xz * (1.0 / l1norm);\n\tif (v.y < 0.0) {\n\t\tresult = (1.0 - abs(result.yx)) * signNotZero(result.xy);\n\t}\n\treturn result;\n}\n\nvec4 sampleOctahedral(vec3 dir) {\n\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n}\n\nvec4 sampleOctahedral(vec2 sph) {\n\treturn sampleOctahedral(fromSpherical(sph));\n}\n\nvec4 sampleOctahedral(vec3 dir, float mipLevel) {\n\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n#ifdef SUPPORTS_TEXLOD\n\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n#else\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n#endif\n}\n\nvec4 sampleOctahedral(vec2 sph, float mipLevel) {\n\treturn sampleOctahedral(fromSpherical(sph), mipLevel);\n}\n\n/////////////////////////////////////////////////////////////////////\n\nvec3 getDirectionCubemap() {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = targetFace();\n\n\tvec3 vec;\n\tif (face == 0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face == 1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face == 2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face == 3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face == 4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\n\treturn normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));\n}\n\nmat3 matrixFromVector(vec3 n) { // frisvad\n\tfloat a = 1.0 / (1.0 + n.z);\n\tfloat b = -n.x * n.y * a;\n\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\treturn mat3(b1, b2, n);\n}\n\nmat3 matrixFromVectorSlow(vec3 n) {\n\tvec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);\n\tvec3 x = normalize(cross(up, n));\n\tvec3 y = cross(n, x);\n\treturn mat3(x, y, n);\n}\n\nvec4 reproject() {\n\tif (NUM_SAMPLES <= 1) {\n\t\t// single sample\n\t\treturn ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\n\t} else {\n\t\t// multi sample\n\t\tvec2 sph = toSpherical(TARGET_FUNC());\n\t\tvec2 sphu = dFdx(sph);\n\t\tvec2 sphv = dFdy(sph);\n\n\t\t// TODO: check this declaration works on old devices.\n\t\t// might need to be placed globally or be made a #define\n\t\tconst float NUM_SAMPLES_SQRT = sqrt(float(NUM_SAMPLES));\n\n\t\tvec3 result = vec3(0.0);\n\t\tfor (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {\n\t\t\tfor (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {\n\t\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(sph +\n\t\t\t\t\t\t\t\t\t\t\t\t	sphu * (u / NUM_SAMPLES_SQRT - 0.5) +\n\t\t\t\t\t\t\t\t\t\t\t\t	sphv * (v / NUM_SAMPLES_SQRT - 0.5)));\n\t\t\t}\n\t\t}\n\t\treturn ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));\n\t}\n}\n\nvec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\n\nvoid unpackSample(int i, out vec3 L, out float mipLevel) {\n\tfloat u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;\n\tfloat v = (floor(u) + 0.5) * samplesTexInverseSize.y;\n\n\tvec4 raw;\n\traw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\traw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\traw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\traw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);\n\n\tL.xyz = raw.xyz * 2.0 - 1.0;\n\tmipLevel = raw.w * 8.0;\n}\n\n// convolve an environment given pre-generated samples\nvec4 prefilterSamples() {\n\t// construct vector space given target direction\n\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\n\tvec3 L;\n\tfloat mipLevel;\n\n\tvec3 result = vec3(0.0);\n\tfloat totalWeight = 0.0;\n\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\tunpackSample(i, L, mipLevel);\n\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;\n\t\ttotalWeight += L.z;\n\t}\n\n\treturn ENCODE_FUNC(result / totalWeight);\n}\n\n// unweighted version of prefilterSamples\nvec4 prefilterSamplesUnweighted() {\n\t// construct vector space given target direction\n\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\n\tvec3 L;\n\tfloat mipLevel;\n\n\tvec3 result = vec3(0.0);\n\tfloat totalWeight = 0.0;\n\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\tunpackSample(i, L, mipLevel);\n\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));\n\t}\n\n\treturn ENCODE_FUNC(result / float(NUM_SAMPLES));\n}\n\nvoid main(void) {\n\tgl_FragColor = PROCESS_FUNC();\n}\n";

	var rgbmPS = "vec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n\treturn decodeRGBM(texture2D(tex, uv));\n}\n\nvec3 texture2DRGBM(sampler2D tex, vec2 uv, float bias) {\n\treturn decodeRGBM(texture2D(tex, uv, bias));\n}\n\nvec3 textureCubeRGBM(samplerCube tex, vec3 uvw) {\n\treturn decodeRGBM(textureCube(tex, uvw));\n}\n";

	var screenDepthPS = "uniform highp sampler2D uDepthMap;\n\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params; // 1 / camera_far,\t	camera_far,\t (1 - f / n) / 2,\t\t(1 + f / n) / 2\n#endif\n\n#ifdef GL2\nfloat linearizeDepth(float z) {\n\tz = z * 2.0 - 1.0;\n\treturn 1.0 / (camera_params.z * z + camera_params.w);\n}\n#else\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#endif\n\n// Retrieves rendered linear camera depth by UV\nfloat getLinearScreenDepth(vec2 uv) {\n\t#ifdef GL2\n\treturn linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y;\n\t#else\n\treturn unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y;\n\t#endif\n}\n\n#ifndef VERTEXSHADER\n// Retrieves rendered linear camera depth under the current pixel\nfloat getLinearScreenDepth() {\n\tvec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n\treturn getLinearScreenDepth(uv);\n}\n#endif\n\n// Generates linear camera depth for the given world position\nfloat getLinearDepth(vec3 pos) {\n\treturn -(matrix_view * vec4(pos, 1.0)).z;\n}\n";

	var shadowCascadesPS = "const float maxCascades = 4.0;\n\n// shadow matrix for selected cascade\nmat4 cascadeShadowMat;\n\n// function which selects a shadow projection matrix based on cascade distances \nvoid getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {\n\n\t// depth in 0 .. far plane range\n\tfloat depth = 1.0 / gl_FragCoord.w;\n\n\t// find cascade index based on the depth (loop as there is no per component vec compare operator in webgl)\n\tfloat cascadeIndex = 0.0;\n\tfor (float i = 0.0; i < maxCascades; i++) {\n\t\tif (depth < shadowCascadeDistances[int(i)]) {\n\t\t\tcascadeIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// limit to actual number of used cascades\n\tcascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);\n\n\t// pick shadow matrix\n\t#ifdef GL2\n\t\tcascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];\n\t#else\n\t\t// webgl 1 does not allow non-cost index array lookup\n\t\tif (cascadeIndex == 0.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[0];\n\t\t}\n\t\telse if (cascadeIndex == 1.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[1];\n\t\t}\n\t\telse if (cascadeIndex == 2.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[2];\n\t\t}\n\t\telse {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[3];\n\t\t}\n\t#endif\n}\n\nvoid fadeShadow(float shadowCascadeDistances[4]) {\t\t\t\t	\n\n\t// if the pixel is past the shadow distance, remove shadow\n\t// this enforces straight line instead of corner of shadow which moves when camera rotates	\n\tfloat depth = 1.0 / gl_FragCoord.w;\n\tif (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {\n\t\tdShadowCoord.z = -9999999.0;\n\t}\n}\n";

	var shadowCommonPS = "void normalOffsetPointShadow(vec4 shadowParams) {\n\tfloat distScale = length(dLightDirW);\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale; //0.02\n\tvec3 dir = wPos - dLightPosW;\n\tdLightDirW = dir;\n}\n";

	var shadowCoordPS = "void _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n\tdShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\n\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\n\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xy /= projPos.w;\n\tdShadowCoord.xy = projPos.xy;\n\tdShadowCoord.z = length(dLightDirW) * shadowParams.w;\n\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\n\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\n\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\n\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\n\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0); //0.08\n\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n";

	var shadowCoordPerspZbufferPS = "void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xyz /= projPos.w;\n\tdShadowCoord = projPos.xyz;\n\t// depth bias is already applied on render\n}\n\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\n\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\n}\n";

	var shadowEVSMPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec3 moments = texture2D(tex, texCoords).xyz;\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\n\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

	var shadowEVSMnPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tfloat pixelSize = 1.0 / resolution;\n\ttexCoords -= vec2(pixelSize);\n\tvec3 s00 = texture2D(tex, texCoords).xyz;\n\tvec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n\tvec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n\tvec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n\tvec2 fr = fract(texCoords * resolution);\n\tvec3 h0 = mix(s00, s10, fr.x);\n\tvec3 h1 = mix(s01, s11, fr.x);\n\tvec3 moments = mix(h0, h1, fr.y);\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\n\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

	var shadowStandardPS = "vec3 lessThan2(vec3 a, vec3 b) {\n\treturn clamp((b - a)*1000.0, 0.0, 1.0); // softer version\n}\n\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n\n// ----- Direct/Spot Sampling -----\n\n#ifdef GL2\nfloat _getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\n\tfloat sum = 0.0;\n\n\tfloat uw0 = (3.0 - 2.0 * s);\n\tfloat uw1 = (1.0 + 2.0 * s);\n\n\tfloat u0 = (2.0 - s) / uw0 - 1.0;\n\tfloat u1 = s / uw1 + 1.0;\n\n\tfloat vw0 = (3.0 - 2.0 * t);\n\tfloat vw1 = (1.0 + 2.0 * t);\n\n\tfloat v0 = (2.0 - t) / vw0 - 1.0;\n\tfloat v1 = t / vw1 + 1.0;\n\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\n\tsum *= 1.0f / 16.0;\n\treturn sum;\n}\n\nfloat getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\n\nfloat getShadowSpotPCF3x3(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#else\nfloat _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\n\tmat3 shadowKernel;\n\tvec3 shadowCoord = dShadowCoord;\n\tvec3 shadowZ = vec3(shadowCoord.z);\n\tshadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n\n\tvec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\n\treturn dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\n\nfloat _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\tvec3 shadowCoord = dShadowCoord;\n\n\tfloat xoffset = 1.0 / shadowParams.x; // 1/shadow map width\n\tfloat dx0 = -xoffset;\n\tfloat dx1 = xoffset;\n\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n\tdepthKernel[0][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n\tdepthKernel[0][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n\tdepthKernel[1][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n\tdepthKernel[1][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy));\n\tdepthKernel[1][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n\tdepthKernel[2][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n\tdepthKernel[2][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n\tdepthKernel[2][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n\n\treturn _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\n}\n\nfloat getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\n\nfloat getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#endif\n\n\n// ----- Omni Sampling -----\n\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n\n\tvec3 tc = normalize(dir);\n\tvec3 tcAbs = abs(tc);\n\n\tvec4 dirX = vec4(1,0,0, tc.x);\n\tvec4 dirY = vec4(0,1,0, tc.y);\n\tfloat majorAxisLength = tc.z;\n\tif ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n\t\tdirX = vec4(0,0,1, tc.z);\n\t\tdirY = vec4(0,1,0, tc.y);\n\t\tmajorAxisLength = tc.x;\n\t} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n\t\tdirX = vec4(1,0,0, tc.x);\n\t\tdirY = vec4(0,0,1, tc.z);\n\t\tmajorAxisLength = tc.y;\n\t}\n\n\tfloat shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n\n\tvec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n\tvec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n\tvec3 dx0 = -xoffset;\n\tvec3 dy0 = -yoffset;\n\tvec3 dx1 = xoffset;\n\tvec3 dy1 = yoffset;\n\n\tmat3 shadowKernel;\n\tmat3 depthKernel;\n\n\tdepthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n\tdepthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n\tdepthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n\tdepthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n\tdepthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n\tdepthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n\tdepthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n\tdepthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n\tdepthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n\n\tvec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n\n\tshadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n\n\tvec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n\n\tvec2 fractionalCoord = fract( uv * shadowParams.x );\n\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\n\treturn 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\n\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\n\treturn _getShadowPoint(shadowMap, shadowParams, dLightDirW);\n}\n";

	var shadowStandardGL2PS = "float _getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\t// http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/\n\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\n\n\tfloat uw0 = (4.0 - 3.0 * s);\n\tfloat uw1 = 7.0;\n\tfloat uw2 = (1.0 + 3.0 * s);\n\n\tfloat u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n\tfloat u1 = (3.0 + s) / uw1;\n\tfloat u2 = s / uw2 + 2.0;\n\n\tfloat vw0 = (4.0 - 3.0 * t);\n\tfloat vw1 = 7.0;\n\tfloat vw2 = (1.0 + 3.0 * t);\n\n\tfloat v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n\tfloat v1 = (3.0 + t) / vw1;\n\tfloat v2 = t / vw2 + 2.0;\n\n\tfloat sum = 0.0;\n\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\n\tu2 = u2 * shadowMapSizeInv + base_uv.x;\n\tv2 = v2 * shadowMapSizeInv + base_uv.y;\n\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw2 * vw0 * texture(shadowMap, vec3(u2, v0, z));\n\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\tsum += uw2 * vw1 * texture(shadowMap, vec3(u2, v1, z));\n\n\tsum += uw0 * vw2 * texture(shadowMap, vec3(u0, v2, z));\n\tsum += uw1 * vw2 * texture(shadowMap, vec3(u1, v2, z));\n\tsum += uw2 * vw2 * texture(shadowMap, vec3(u2, v2, z));\n\n\tsum *= 1.0f / 144.0;\n\n\tsum = gammaCorrectInput(sum); // gives softer gradient\n\tsum = saturate(sum);\n\n\treturn sum;\n}\n\nfloat getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams);\n}\n\nfloat getShadowSpotPCF5x5(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams.xyz);\n}\n";

	var shadowVSM8PS = "float calculateVSM8(vec3 moments, float Z, float vsmBias) {\n\tfloat VSMBias = vsmBias;//0.01 * 0.25;\n\tfloat depthScale = VSMBias * Z;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\n\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\n\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec4 c = texture2D(tex, texCoords);\n\tvec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n\treturn calculateVSM8(moments, Z, vsmBias);\n}\n\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\n}\n\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n";

	var shadowVSM_commonPS = "float linstep(float a, float b, float v) {\n\treturn saturate((v - a) / (b - a));\n}\n\nfloat reduceLightBleeding(float pMax, float amount) {\n	 // Remove the [0, amount] tail and linearly rescale (amount, 1].\n	 return linstep(amount, 1.0, pMax);\n}\n\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n\t// Compute variance\n\tfloat variance = moments.y - (moments.x * moments.x);\n\tvariance = max(variance, minVariance);\n\n\t// Compute probabilistic upper bound\n\tfloat d = mean - moments.x;\n\tfloat pMax = variance / (variance + (d * d));\n\n\tpMax = reduceLightBleeding(pMax, lightBleedingReduction);\n\n\t// One-tailed Chebyshev\n\treturn (mean <= moments.x ? 1.0 : pMax);\n}\n\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n\tZ = 2.0 * Z - 1.0;\n\tfloat warpedDepth = exp(exponent * Z);\n\n\tmoments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n\n\tfloat VSMBias = vsmBias;//0.01 * 0.25;\n\tfloat depthScale = VSMBias * exponent * warpedDepth;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n";

	var skinBatchConstVS = "attribute float vertex_boneIndices;\n\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\n\nmat4 getBoneMatrix(const in float i) {\n\t// read 4x3 matrix\n\tvec4 v1 = matrix_pose[int(3.0 * i)];\n\tvec4 v2 = matrix_pose[int(3.0 * i + 1.0)];\n\tvec4 v3 = matrix_pose[int(3.0 * i + 2.0)];\n\n\t// transpose to 4x4 matrix\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n";

	var skinBatchTexVS = "attribute float vertex_boneIndices;\n\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\n\nmat4 getBoneMatrix(const in float i) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\n\t// read elements of 4x3 matrix\n\tvec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tvec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tvec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n\n\t// transpose to 4x4 matrix\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n";

	var skinConstVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\n\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\n\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\t// read 4x3 matrix\n\tv1 = matrix_pose[int(3.0 * i)];\n\tv2 = matrix_pose[int(3.0 * i + 1.0)];\n\tv3 = matrix_pose[int(3.0 * i + 2.0)];\n}\n\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\t// get 4 bone matrices\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\n\t// multiply them by weights and add up to get final 4x3 matrix\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\n\t// add up weights\n\tfloat one = dot(weights, vec4(1.0));\n\n\t// transpose to 4x4 matrix\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n";

	var skinTexVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\n\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\n\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\t\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\n\t// read elements of 4x3 matrix\n\tv1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tv2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tv3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n}\n\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\t// get 4 bone matrices\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\n\t// multiply them by weights and add up to get final 4x3 matrix\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\n\t// add up weights\n\tfloat one = dot(weights, vec4(1.0));\n\n\t// transpose to 4x4 matrix\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n";

	var skyboxEnvPS = "varying vec3 vViewDir;\n\nuniform sampler2D texture_envAtlas;\nuniform float mipLevel;\n\nvoid main(void) {\n\tvec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(normalize(dir));\n\n\tvec3 linear = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\n\n\tgl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n}\n";

	var skyboxHDRPS = "varying vec3 vViewDir;\n\nuniform samplerCube texture_cubeMap;\n\nvoid main(void) {\n\tvec3 dir=vViewDir;\n\tdir.x *= -1.0;\n\tvec3 color = processEnvironment($textureCubeSAMPLE(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)).rgb);\n\tcolor = toneMap(color);\n\tcolor = gammaCorrectOutput(color);\n\tgl_FragColor = vec4(color, 1.0);\n}\n";

	var skyboxVS = "attribute vec3 aPosition;\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nuniform mat4 matrix_projectionSkybox;\nuniform mat3 cubeMapRotationMatrix;\n\nvarying vec3 vViewDir;\n\nvoid main(void) {\n\tmat4 view = matrix_view;\n\tview[3][0] = view[3][1] = view[3][2] = 0.0;\n\tgl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\n\n\t// Force skybox to far Z, regardless of the clip planes on the camera\n\t// Subtract a tiny fudge factor to ensure floating point errors don't\n\t// still push pixels beyond far Z. See:\n\t// http://www.opengl.org/discussion_boards/showthread.php/171867-skybox-problem\n\n\tgl_Position.z = gl_Position.w - 0.00001;\n\tvViewDir = aPosition * cubeMapRotationMatrix;\n}\n";

	var specularPS = "#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularMap;\n#endif\n\nvoid getSpecularity() {\n\tdSpecularity = vec3(1.0);\n\n\t#ifdef MAPCOLOR\n\tdSpecularity *= material_specular;\n\t#endif\n\n\t#ifdef MAPTEXTURE\n\tdSpecularity *= texture2D(texture_specularMap, $UV, textureBias).$CH;\n\t#endif\n\n\t#ifdef MAPVERTEX\n\tdSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

	var specularAaNonePS = "float antiAliasGlossiness(float power) {\n\treturn power;\n}\n";

	var specularAaToksvigPS = "float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * mix(1.0, toksvig, material_bumpiness);\n}\n";

	var specularAaToksvigFastPS = "float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * toksvig;\n}\n";

	var spotPS = "float getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\n\tfloat cosAngle = dot(dLightDirNormW, lightSpotDirW);\n\treturn smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n";

	var startPS = "void main(void) {\n\tdDiffuseLight = vec3(0);\n\tdSpecularLight = vec3(0);\n\tdReflection = vec4(0);\n\tdSpecularity = vec3(0);\n\n\t#ifdef CLEARCOAT\n\tccSpecularLight = vec3(0);\n\tccReflection = vec4(0);\n\t#endif\n";

	var startVS = "void main(void) {\n\tgl_Position = getPosition();\n";

	var startNineSlicedPS = "\tnineSlicedUv = vUv0;\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n\n";

	var startNineSlicedTiledPS = "\tvec2 tileMask = step(vMask, vec2(0.99999));\n\tvec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);\n\tvec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);\n\tvec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));\n\tclampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n\tnineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n\t\n";

	var storeEVSMPS = "float exponent = VSM_EXPONENT;\n\ndepth = 2.0 * depth - 1.0;\ndepth =	exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n";

	var tangentBinormalVS = "vec3 getTangent() {\n\treturn normalize(dNormalMatrix * vertex_tangent.xyz);\n}\n\nvec3 getBinormal() {\n\treturn cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\n\nvec3 getObjectSpaceUp() {\n\treturn normalize(dNormalMatrix * vec3(0, 1, 0));\n}\n";

	var TBNPS = "void getTBN() {\n\tdTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\n}\n";

	var TBNderivativePS = "uniform float tbnBasis;\n\n// http://www.thetenthplanet.de/archives/1180\nvoid getTBN() {\n\tvec2 uv = $UV;\n\n\t// get edge vectors of the pixel triangle\n\tvec3 dp1 = dFdx( vPositionW );\n\tvec3 dp2 = dFdy( vPositionW );\n\tvec2 duv1 = dFdx( uv );\n\tvec2 duv2 = dFdy( uv );\n\n\t// solve the linear system\n\tvec3 dp2perp = cross( dp2, dVertexNormalW );\n\tvec3 dp1perp = cross( dVertexNormalW, dp1 );\n\tvec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n\tvec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\n\t// construct a scale-invariant frame\n\tfloat denom = max( dot(T,T), dot(B,B) );\n\tfloat invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );\n\tdTBN = mat3(T * invmax, -B * invmax, dVertexNormalW );\n}\n";

	var TBNfastPS = "void getTBN() {\n\tdTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\n}\n";

	var TBNObjectSpacePS = "void getTBN() {\n\n\tvec3 B = cross(dVertexNormalW, vObjectSpaceUpW);\n\tvec3 T = cross(dVertexNormalW, B);\n\n\tif (dot(B,B)==0.0) // deal with case when vObjectSpaceUpW dVertexNormalW are parallel\n\t{\n\t\tfloat major=max(max(dVertexNormalW.x, dVertexNormalW.y),dVertexNormalW.z);\n\n\t\tif (dVertexNormalW.x==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,1,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.y==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,0,1));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.z==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(1,0,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t}\n\n\tdTBN = mat3(normalize(T), normalize(B), normalize(dVertexNormalW));\n}\n";

	var tonemappingAcesPS = "uniform float exposure;\n\nvec3 toneMap(vec3 color) {\n\tfloat tA = 2.51;\n\tfloat tB = 0.03;\n\tfloat tC = 2.43;\n\tfloat tD = 0.59;\n\tfloat tE = 0.14;\n\tvec3 x = color * exposure;\n\treturn (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n";

	var tonemappingAces2PS = "uniform float exposure;\n\n// ACES approximation by Stephen Hill\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.35458, 0.04823,\n\t0.07600, 0.90834, 0.01566,\n\t0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.53108, -0.07367,\n\t-0.10208,	1.10813, -0.00605,\n\t-0.00327, -0.07276,	1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\n\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tcolor = color * ACESInputMat;\n\n\t// Apply RRT and ODT\n\tcolor = RRTAndODTFit(color);\n\tcolor = color * ACESOutputMat;\n\n\t// Clamp to [0, 1]\n\tcolor = clamp(color, 0.0, 1.0);\n\n\treturn color;\n}\n";

	var tonemappingFilmicPS = "const float A =	0.15;\nconst float B =	0.50;\nconst float C =	0.10;\nconst float D =	0.20;\nconst float E =	0.02;\nconst float F =	0.30;\nconst float W =	11.2;\n\nuniform float exposure;\n\nvec3 uncharted2Tonemap(vec3 x) {\n	 return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 toneMap(vec3 color) {\n\tcolor = uncharted2Tonemap(color * exposure);\n\tvec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n\tcolor = color * whiteScale;\n\n\treturn color;\n}\n";

	var tonemappingHejlPS = "uniform float exposure;\n\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tconst float	A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n\tconst float Scl = 1.25;\n\n\tvec3 h = max( vec3(0.0), color - vec3(0.004) );\n\treturn (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n";

	var tonemappingLinearPS = "uniform float exposure;\n\nvec3 toneMap(vec3 color) {\n\treturn color * exposure;\n}\n";

	var tonemappingNonePS = "vec3 toneMap(vec3 color) {\n\treturn color;\n}\n";

	var transformVS = "#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n\n#ifdef MORPHING\nuniform vec4 morph_weights_a;\nuniform vec4 morph_weights_b;\n#endif\n\n#ifdef MORPHING_TEXTURE_BASED\nuniform vec4 morph_tex_params;\n\nvec2 getTextureMorphCoords() {\n\tfloat vertexId = morph_vertex_id;\n\tvec2 textureSize = morph_tex_params.xy;\n\tvec2 invTextureSize = morph_tex_params.zw;\n\n\t// turn vertexId into int grid coordinates\n\tfloat morphGridV = floor(vertexId * invTextureSize.x);\n\tfloat morphGridU = vertexId - (morphGridV * textureSize.x);\n\n\t// convert grid coordinates to uv coordinates with half pixel offset\n\treturn (vec2(morphGridU, morphGridV) * invTextureSize) + (0.5 * invTextureSize);\n}\n#endif\n\n#ifdef MORPHING_TEXTURE_BASED_POSITION\nuniform highp sampler2D morphPositionTex;\n#endif\n\nmat4 getModelMatrix() {\n\t#ifdef DYNAMICBATCH\n\treturn getBoneMatrix(vertex_boneIndices);\n\t#elif defined(SKIN)\n\treturn matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n\t#elif defined(INSTANCING)\n\treturn mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n\t#else\n\treturn matrix_model;\n\t#endif\n}\n\nvec4 getPosition() {\n\tdModelMatrix = getModelMatrix();\n\tvec3 localPos = vertex_position;\n\n\t#ifdef NINESLICED\n\t// outer and inner vertices are at the same position, scale both\n\tlocalPos.xz *= outerScale;\n\n\t// offset inner vertices inside\n\t// (original vertices must be in [-1;1] range)\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tlocalPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\n\tvTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0; // uv = local pos - inner corner\n\n\tlocalPos.xz *= -0.5; // move from -1;1 to -0.5;0.5\n\tlocalPos = localPos.xzy;\n\t#endif\n\n\t#ifdef MORPHING\n\t#ifdef MORPHING_POS03\n\tlocalPos.xyz += morph_weights_a[0] * morph_pos0;\n\tlocalPos.xyz += morph_weights_a[1] * morph_pos1;\n\tlocalPos.xyz += morph_weights_a[2] * morph_pos2;\n\tlocalPos.xyz += morph_weights_a[3] * morph_pos3;\n\t#endif // MORPHING_POS03\n\t#ifdef MORPHING_POS47\n\tlocalPos.xyz += morph_weights_b[0] * morph_pos4;\n\tlocalPos.xyz += morph_weights_b[1] * morph_pos5;\n\tlocalPos.xyz += morph_weights_b[2] * morph_pos6;\n\tlocalPos.xyz += morph_weights_b[3] * morph_pos7;\n\t#endif // MORPHING_POS47\n\t#endif // MORPHING\n\n\t#ifdef MORPHING_TEXTURE_BASED_POSITION\n\t// apply morph offset from texture\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\n\tlocalPos += morphPos;\n\t#endif\n\n\tvec4 posW = dModelMatrix * vec4(localPos, 1.0);\n\t#ifdef SCREENSPACE\n\tposW.zw = vec2(0.0, 1.0);\n\t#endif\n\tdPositionW = posW.xyz;\n\n\tvec4 screenPos;\n\t#ifdef UV1LAYOUT\n\tscreenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n\t#else\n\t#ifdef SCREENSPACE\n\tscreenPos = posW;\n\t#else\n\tscreenPos = matrix_viewProjection * posW;\n\t#endif\n\n\t#ifdef PIXELSNAP\n\t// snap vertex to a pixel boundary\n\tscreenPos.xy = (screenPos.xy * 0.5) + 0.5;\n\tscreenPos.xy *= uScreenSize.xy;\n\tscreenPos.xy = floor(screenPos.xy);\n\tscreenPos.xy *= uScreenSize.zw;\n\tscreenPos.xy = (screenPos.xy * 2.0) - 1.0;\n\t#endif\n\t#endif\n\n\treturn screenPos;\n}\n\nvec3 getWorldPosition() {\n\treturn dPositionW;\n}\n";

	var transformDeclVS = "attribute vec3 vertex_position;\n\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\n\nvec3 dPositionW;\nmat4 dModelMatrix;\n";

	var uv0VS = "#ifdef NINESLICED\nvec2 getUv0() {\n\tvec2 uv = vertex_position.xz;\n\n\t// offset inner vertices inside\n\t// (original vertices must be in [-1;1] range)\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tuv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\n\tuv = uv * -0.5 + 0.5;\n\tuv = uv * atlasRect.zw + atlasRect.xy;\n\n\tvMask = vertex_texCoord0.xy;\n\n\treturn uv;\n}\n#else\nvec2 getUv0() {\n\treturn vertex_texCoord0;\n}\n#endif\n";

	var uv1VS = "vec2 getUv1() {\n\treturn vertex_texCoord1;\n}\n";

	var viewDirPS = "void getViewDir() {\n\tdViewDirW = normalize(view_position - vPositionW);\n}\n";

	var viewNormalVS = "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nvec3 getViewNormal() {\n\treturn mat3(matrix_view) * vNormalW;\n}\n";

	var shaderChunks = {
		alphaTestPS: alphaTestPS,
		ambientConstantPS: ambientConstantPS,
		ambientEnvPS: ambientEnvPS,
		ambientSHPS: ambientSHPS,
		aoPS: aoPS,
		aoDiffuseOccPS: aoDiffuseOccPS,
		aoSpecOccPS: aoSpecOccPS,
		aoSpecOccConstPS: aoSpecOccConstPS,
		aoSpecOccConstSimplePS: aoSpecOccConstSimplePS,
		aoSpecOccSimplePS: aoSpecOccSimplePS,
		bakeDirLmEndPS: bakeDirLmEndPS,
		bakeLmEndPS: bakeLmEndPS,
		basePS: basePS,
		baseVS: baseVS,
		baseNineSlicedPS: baseNineSlicedPS,
		baseNineSlicedVS: baseNineSlicedVS,
		baseNineSlicedTiledPS: baseNineSlicedTiledPS,
		biasConstPS: biasConstPS,
		blurVSMPS: blurVSMPS,
		clearCoatPS: clearCoatPS,
		clearCoatGlossPS: clearCoatGlossPS,
		clearCoatNormalPS: clearCoatNormalPS,
		clusteredLightCookiesPS: clusteredLightCookiesPS,
		clusteredLightShadowsPS: clusteredLightShadowsPS,
		clusteredLightUtilsPS: clusteredLightUtilsPS,
		clusteredLightPS: clusteredLightPS,
		combineClearCoatPS: combineClearCoatPS,
		combineDiffusePS: combineDiffusePS,
		combineDiffuseSpecularPS: combineDiffuseSpecularPS,
		combineDiffuseSpecularNoConservePS: combineDiffuseSpecularNoConservePS,
		combineDiffuseSpecularNoReflPS: combineDiffuseSpecularNoReflPS,
		combineDiffuseSpecularNoReflSeparateAmbientPS: combineDiffuseSpecularNoReflSeparateAmbientPS,
		combineDiffuseSpecularOldPS: combineDiffuseSpecularOldPS,
		cookiePS: cookiePS,
		cubeMapProjectBoxPS: cubeMapProjectBoxPS,
		cubeMapProjectNonePS: cubeMapProjectNonePS,
		cubeMapRotatePS: cubeMapRotatePS,
		detailModesPS: detailModesPS,
		diffusePS: diffusePS,
		diffuseDetailMapPS: diffuseDetailMapPS,
		dilatePS: dilatePS,
		bilateralDeNoisePS: bilateralDeNoisePS,
		decodePS: decodePS,
		emissivePS: emissivePS,
		endPS: endPS,
		endVS: endVS,
		envConstPS: envConstPS,
		envMultiplyPS: envMultiplyPS,
		extensionPS: extensionPS,
		extensionVS: extensionVS,
		falloffInvSquaredPS: falloffInvSquaredPS,
		falloffLinearPS: falloffLinearPS,
		fixCubemapSeamsNonePS: fixCubemapSeamsNonePS,
		fixCubemapSeamsStretchPS: fixCubemapSeamsStretchPS,
		floatUnpackingPS: floatUnpackingPS,
		fogExpPS: fogExpPS,
		fogExp2PS: fogExp2PS,
		fogLinearPS: fogLinearPS,
		fogNonePS: fogNonePS,
		fresnelSchlickPS: fresnelSchlickPS,
		fullscreenQuadPS: fullscreenQuadPS,
		fullscreenQuadVS: fullscreenQuadVS,
		gamma1_0PS: gamma1_0PS,
		gamma2_2PS: gamma2_2PS,
		gles3PS: gles3PS,
		gles3VS: gles3VS,
		glossPS: glossPS,
		instancingVS: instancingVS,
		lightDiffuseLambertPS: lightDiffuseLambertPS,
		lightDirPointPS: lightDirPointPS,
		lightmapDirPS: lightmapDirPS,
		lightmapSinglePS: lightmapSinglePS,
		lightmapSingleVertPS: lightmapSingleVertPS,
		lightSpecularAnisoGGXPS: lightSpecularAnisoGGXPS,
		lightSpecularBlinnPS: lightSpecularBlinnPS,
		lightSpecularPhongPS: lightSpecularPhongPS,
		ltc: ltc,
		metalnessPS: metalnessPS,
		msdfPS: msdfPS,
		normalVS: normalVS,
		normalDetailMapPS: normalDetailMapPS,
		normalInstancedVS: normalInstancedVS,
		normalMapPS: normalMapPS,
		normalMapFastPS: normalMapFastPS,
		normalSkinnedVS: normalSkinnedVS,
		normalVertexPS: normalVertexPS,
		normalXYPS: normalXYPS,
		normalXYZPS: normalXYZPS,
		opacityPS: opacityPS,
		outputAlphaPS: outputAlphaPS,
		outputAlphaOpaquePS: outputAlphaOpaquePS,
		outputAlphaPremulPS: outputAlphaPremulPS,
		outputTex2DPS: outputTex2DPS,
		packDepthPS: packDepthPS,
		parallaxPS: parallaxPS,
		particlePS: particlePS,
		particleVS: particleVS,
		particleAnimFrameClampVS: particleAnimFrameClampVS,
		particleAnimFrameLoopVS: particleAnimFrameLoopVS,
		particleAnimTexVS: particleAnimTexVS,
		particleInputFloatPS: particleInputFloatPS,
		particleInputRgba8PS: particleInputRgba8PS,
		particleOutputFloatPS: particleOutputFloatPS,
		particleOutputRgba8PS: particleOutputRgba8PS,
		particleUpdaterAABBPS: particleUpdaterAABBPS,
		particleUpdaterEndPS: particleUpdaterEndPS,
		particleUpdaterInitPS: particleUpdaterInitPS,
		particleUpdaterNoRespawnPS: particleUpdaterNoRespawnPS,
		particleUpdaterOnStopPS: particleUpdaterOnStopPS,
		particleUpdaterRespawnPS: particleUpdaterRespawnPS,
		particleUpdaterSpherePS: particleUpdaterSpherePS,
		particleUpdaterStartPS: particleUpdaterStartPS,
		particle_billboardVS: particle_billboardVS,
		particle_blendAddPS: particle_blendAddPS,
		particle_blendMultiplyPS: particle_blendMultiplyPS,
		particle_blendNormalPS: particle_blendNormalPS,
		particle_cpuVS: particle_cpuVS,
		particle_cpu_endVS: particle_cpu_endVS,
		particle_customFaceVS: particle_customFaceVS,
		particle_endPS: particle_endPS,
		particle_endVS: particle_endVS,
		particle_halflambertPS: particle_halflambertPS,
		particle_initVS: particle_initVS,
		particle_lambertPS: particle_lambertPS,
		particle_lightingPS: particle_lightingPS,
		particle_localShiftVS: particle_localShiftVS,
		particle_meshVS: particle_meshVS,
		particle_normalVS: particle_normalVS,
		particle_normalMapPS: particle_normalMapPS,
		particle_pointAlongVS: particle_pointAlongVS,
		particle_softPS: particle_softPS,
		particle_softVS: particle_softVS,
		particle_stretchVS: particle_stretchVS,
		particle_TBNVS: particle_TBNVS,
		particle_wrapVS: particle_wrapVS,
		precisionTestPS: precisionTestPS,
		precisionTest2PS: precisionTest2PS,
		reflDirPS: reflDirPS,
		reflDirAnisoPS: reflDirAnisoPS,
		reflectionCCPS: reflectionCCPS,
		reflectionCubePS: reflectionCubePS,
		reflectionEnvPS: reflectionEnvPS,
		reflectionSpherePS: reflectionSpherePS,
		reflectionSphereLowPS: reflectionSphereLowPS,
		refractionPS: refractionPS,
		reprojectPS: reprojectPS,
		rgbmPS: rgbmPS,
		screenDepthPS: screenDepthPS,
		shadowCascadesPS: shadowCascadesPS,
		shadowCommonPS: shadowCommonPS,
		shadowCoordPS: shadowCoordPS,
		shadowCoordPerspZbufferPS: shadowCoordPerspZbufferPS,
		shadowEVSMPS: shadowEVSMPS,
		shadowEVSMnPS: shadowEVSMnPS,
		shadowStandardPS: shadowStandardPS,
		shadowStandardGL2PS: shadowStandardGL2PS,
		shadowVSM8PS: shadowVSM8PS,
		shadowVSM_commonPS: shadowVSM_commonPS,
		skinBatchConstVS: skinBatchConstVS,
		skinBatchTexVS: skinBatchTexVS,
		skinConstVS: skinConstVS,
		skinTexVS: skinTexVS,
		skyboxEnvPS: skyboxEnvPS,
		skyboxHDRPS: skyboxHDRPS,
		skyboxVS: skyboxVS,
		specularPS: specularPS,
		specularAaNonePS: specularAaNonePS,
		specularAaToksvigPS: specularAaToksvigPS,
		specularAaToksvigFastPS: specularAaToksvigFastPS,
		spotPS: spotPS,
		startPS: startPS,
		startVS: startVS,
		startNineSlicedPS: startNineSlicedPS,
		startNineSlicedTiledPS: startNineSlicedTiledPS,
		storeEVSMPS: storeEVSMPS,
		tangentBinormalVS: tangentBinormalVS,
		TBNPS: TBNPS,
		TBNderivativePS: TBNderivativePS,
		TBNfastPS: TBNfastPS,
		TBNObjectSpacePS: TBNObjectSpacePS,
		tonemappingAcesPS: tonemappingAcesPS,
		tonemappingAces2PS: tonemappingAces2PS,
		tonemappingFilmicPS: tonemappingFilmicPS,
		tonemappingHejlPS: tonemappingHejlPS,
		tonemappingLinearPS: tonemappingLinearPS,
		tonemappingNonePS: tonemappingNonePS,
		transformVS: transformVS,
		transformDeclVS: transformDeclVS,
		uv0VS: uv0VS,
		uv1VS: uv1VS,
		viewDirPS: viewDirPS,
		viewNormalVS: viewNormalVS
	};

	function gammaCode(value, chunks) {
		if (!chunks) chunks = shaderChunks;

		if (value === GAMMA_SRGB || value === GAMMA_SRGBFAST) {
			return chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS;
		} else if (value === GAMMA_SRGBHDR) {
			return "#define HDR\n" + (chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS);
		}

		return chunks.gamma1_0PS ? chunks.gamma1_0PS : shaderChunks.gamma1_0PS;
	}

	function tonemapCode(value, chunks) {
		if (!chunks) chunks = shaderChunks;

		if (value === TONEMAP_FILMIC) {
			return chunks.tonemappingFilmicPS ? chunks.tonemappingFilmicPS : shaderChunks.tonemappingFilmicPS;
		} else if (value === TONEMAP_LINEAR) {
			return chunks.tonemappingLinearPS ? chunks.tonemappingLinearPS : shaderChunks.tonemappingLinearPS;
		} else if (value === TONEMAP_HEJL) {
			return chunks.tonemappingHejlPS ? chunks.tonemappingHejlPS : shaderChunks.tonemappingHejlPS;
		} else if (value === TONEMAP_ACES) {
			return chunks.tonemappingAcesPS ? chunks.tonemappingAcesPS : shaderChunks.tonemappingAcesPS;
		} else if (value === TONEMAP_ACES2) {
			return chunks.tonemappingAces2PS ? chunks.tonemappingAces2PS : shaderChunks.tonemappingAces2PS;
		}

		return chunks.tonemapingNonePS ? chunks.tonemapingNonePS : shaderChunks.tonemappingNonePS;
	}

	function fogCode(value, chunks) {
		if (!chunks) chunks = shaderChunks;

		if (value === 'linear') {
			return chunks.fogLinearPS ? chunks.fogLinearPS : shaderChunks.fogLinearPS;
		} else if (value === 'exp') {
			return chunks.fogExpPS ? chunks.fogExpPS : shaderChunks.fogExpPS;
		} else if (value === 'exp2') {
			return chunks.fogExp2PS ? chunks.fogExp2PS : shaderChunks.fogExp2PS;
		}

		return chunks.fogNonePS ? chunks.fogNonePS : shaderChunks.fogNonePS;
	}

	function skinCode(device, chunks) {
		if (!chunks) chunks = shaderChunks;

		if (device.supportsBoneTextures) {
			return chunks.skinTexVS;
		}

		return "#define BONE_LIMIT " + device.getBoneLimit() + "\n" + chunks.skinConstVS;
	}

	function precisionCode(device) {
		var pcode = 'precision ' + device.precision + ' float;\n';

		if (device.webgl2) {
			pcode += '#ifdef GL2\nprecision ' + device.precision + ' sampler2DShadow;\n#endif\n';
		}

		return pcode;
	}

	function versionCode(device) {
		return device.webgl2 ? "#version 300 es\n" : "";
	}

	function dummyFragmentCode() {
		return "void main(void) {gl_FragColor = vec4(0.0);}";
	}

	function begin() {
		return 'void main(void)\n{\n';
	}

	function end() {
		return '}\n';
	}

	var attrib2Semantic = {
		vertex_position: SEMANTIC_POSITION,
		vertex_normal: SEMANTIC_NORMAL,
		vertex_tangent: SEMANTIC_TANGENT,
		vertex_texCoord0: SEMANTIC_TEXCOORD0,
		vertex_texCoord1: SEMANTIC_TEXCOORD1,
		vertex_texCoord2: SEMANTIC_TEXCOORD2,
		vertex_texCoord3: SEMANTIC_TEXCOORD3,
		vertex_texCoord4: SEMANTIC_TEXCOORD4,
		vertex_texCoord5: SEMANTIC_TEXCOORD5,
		vertex_texCoord6: SEMANTIC_TEXCOORD6,
		vertex_texCoord7: SEMANTIC_TEXCOORD7,
		vertex_color: SEMANTIC_COLOR,
		vertex_boneIndices: SEMANTIC_BLENDINDICES,
		vertex_boneWeights: SEMANTIC_BLENDWEIGHT
	};

	function collectAttribs(vsCode) {
		var attribs = {};
		var attrs = 0;
		var found = vsCode.indexOf("attribute");

		while (found >= 0) {
			if (found > 0 && vsCode[found - 1] === "/") break;
			var endOfLine = vsCode.indexOf(';', found);
			var startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);
			var attribName = vsCode.substr(startOfAttribName + 1, endOfLine - (startOfAttribName + 1));
			var semantic = attrib2Semantic[attribName];

			if (semantic !== undefined) {
				attribs[attribName] = semantic;
			} else {
				attribs[attribName] = "ATTR" + attrs;
				attrs++;
			}

			found = vsCode.indexOf("attribute", found + 1);
		}

		return attribs;
	}

	function createShader(device, vsName, psName, useTransformFeedback) {
		if (useTransformFeedback === void 0) {
			useTransformFeedback = false;
		}

		var vsCode = shaderChunks[vsName];
		var psCode = precisionCode(device) + "\n" + shaderChunks[psName];
		var attribs = collectAttribs(vsCode);

		if (device.webgl2) {
			vsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;
			psCode = versionCode(device) + shaderChunks.gles3PS + psCode;
		}

		return new Shader(device, {
			attributes: attribs,
			vshader: vsCode,
			fshader: psCode,
			useTransformFeedback: useTransformFeedback
		});
	}

	function createShaderFromCode(device, vsCode, psCode, uName, useTransformFeedback, psPreamble) {
		if (useTransformFeedback === void 0) {
			useTransformFeedback = false;
		}

		if (psPreamble === void 0) {
			psPreamble = "";
		}

		var shaderCache = device.programLib._cache;
		var cached = shaderCache[uName];
		if (cached !== undefined) return cached;
		psCode = precisionCode(device) + "\n" + (psCode || dummyFragmentCode());
		var attribs = collectAttribs(vsCode);

		if (device.webgl2) {
			vsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;
			psCode = versionCode(device) + shaderChunks.gles3PS + psCode;
		}

		shaderCache[uName] = new Shader(device, {
			attributes: attribs,
			vshader: vsCode,
			fshader: psPreamble + psCode,
			useTransformFeedback: useTransformFeedback
		});
		return shaderCache[uName];
	}

	shaderChunks.collectAttribs = collectAttribs;
	shaderChunks.createShader = createShader;
	shaderChunks.createShaderFromCode = createShaderFromCode;

	var Version = function () {
		function Version() {
			this.globalId = 0;
			this.revision = 0;
		}

		var _proto = Version.prototype;

		_proto.equals = function equals(other) {
			return this.globalId === other.globalId && this.revision === other.revision;
		};

		_proto.copy = function copy(other) {
			this.globalId = other.globalId;
			this.revision = other.revision;
		};

		_proto.reset = function reset() {
			this.globalId = 0;
			this.revision = 0;
		};

		return Version;
	}();

	var idCounter = 0;

	var VersionedObject = function () {
		function VersionedObject() {
			idCounter++;
			this.version = new Version();
			this.version.globalId = idCounter;
		}

		var _proto = VersionedObject.prototype;

		_proto.increment = function increment() {
			this.version.revision++;
		};

		return VersionedObject;
	}();

	var ScopeId = function () {
		function ScopeId(name) {
			this.name = name;
			this.value = null;
			this.versionObject = new VersionedObject();
		}

		var _proto = ScopeId.prototype;

		_proto.setValue = function setValue(value) {
			this.value = value;
			this.versionObject.increment();
		};

		_proto.getValue = function getValue() {
			return this.value;
		};

		return ScopeId;
	}();

	var ScopeSpace = function () {
		function ScopeSpace(name) {
			this.name = name;
			this.variables = new Map();
		}

		var _proto = ScopeSpace.prototype;

		_proto.resolve = function resolve(name) {
			if (!this.variables.has(name)) {
				this.variables.set(name, new ScopeId(name));
			}

			return this.variables.get(name);
		};

		_proto.removeValue = function removeValue(value) {
			for (var uniformName in this.variables) {
				var uniform = this.variables[uniformName];

				if (uniform.value === value) {
					uniform.value = null;
				}
			}
		};

		return ScopeSpace;
	}();

	var basic = {
		generateKey: function generateKey(options) {
			var key = 'basic';
			if (options.fog) key += '_fog';
			if (options.alphaTest) key += '_atst';
			if (options.vertexColors) key += '_vcol';
			if (options.diffuseMap) key += '_diff';
			if (options.skin) key += '_skin';
			if (options.screenSpace) key += '_ss';
			if (options.useInstancing) key += '_inst';
			if (options.useMorphPosition) key += '_morphp';
			if (options.useMorphNormal) key += '_morphn';
			if (options.useMorphTextureBased) key += '_morpht';
			key += '_' + options.pass;
			return key;
		},
		createShaderDefinition: function createShaderDefinition(device, options) {
			var attributes = {
				vertex_position: SEMANTIC_POSITION
			};

			if (options.skin) {
				attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
				attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
			}

			if (options.vertexColors) {
				attributes.vertex_color = SEMANTIC_COLOR;
			}

			if (options.diffuseMap) {
				attributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;
			}

			var code = '';
			code += shaderChunks.transformDeclVS;

			if (options.skin) {
				code += skinCode(device);
				code += shaderChunks.transformSkinnedVS;
			} else {
				code += shaderChunks.transformVS;
			}

			if (options.vertexColors) {
				code += 'attribute vec4 vertex_color;\n';
				code += 'varying vec4 vColor;\n';
			}

			if (options.diffuseMap) {
				code += 'attribute vec2 vertex_texCoord0;\n';
				code += 'varying vec2 vUv0;\n';
			}

			if (options.pass === SHADER_DEPTH) {
				code += 'varying float vDepth;\n';
				code += '#ifndef VIEWMATRIX\n';
				code += '#define VIEWMATRIX\n';
				code += 'uniform mat4 matrix_view;\n';
				code += '#endif\n';
				code += '#ifndef CAMERAPLANES\n';
				code += '#define CAMERAPLANES\n';
				code += 'uniform vec4 camera_params;\n\n';
				code += '#endif\n';
			}

			code += begin();
			code += "	 gl_Position = getPosition();\n";

			if (options.pass === SHADER_DEPTH) {
				code += "		vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\n";
			}

			if (options.vertexColors) {
				code += '		vColor = vertex_color;\n';
			}

			if (options.diffuseMap) {
				code += '		vUv0 = vertex_texCoord0;\n';
			}

			code += end();
			var vshader = code;
			code = precisionCode(device);

			if (options.vertexColors) {
				code += 'varying vec4 vColor;\n';
			} else {
				code += 'uniform vec4 uColor;\n';
			}

			if (options.diffuseMap) {
				code += 'varying vec2 vUv0;\n';
				code += 'uniform sampler2D texture_diffuseMap;\n';
			}

			if (options.fog) {
				code += fogCode(options.fog);
			}

			if (options.alphatest) {
				code += shaderChunks.alphaTestPS;
			}

			if (options.pass === SHADER_DEPTH) {
				code += 'varying float vDepth;\n';
				code += shaderChunks.packDepthPS;
			}

			code += begin();

			if (options.vertexColors) {
				code += '		gl_FragColor = vColor;\n';
			} else {
				code += '		gl_FragColor = uColor;\n';
			}

			if (options.diffuseMap) {
				code += '		gl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n';
			}

			if (options.alphatest) {
				code += "	 alphaTest(gl_FragColor.a);\n";
			}

			if (options.pass !== SHADER_PICK) {
				if (options.pass === SHADER_DEPTH) {
					code += "		gl_FragColor = packFloat(vDepth);\n";
				} else {
					if (options.fog) {
						code += "	 glFragColor.rgb = addFog(gl_FragColor.rgb);\n";
					}
				}
			}

			code += end();
			var fshader = code;
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: fshader
			};
		}
	};

	var particle = {
		generateKey: function generateKey(options) {
			var key = "particle";

			for (var prop in options) {
				if (options.hasOwnProperty(prop)) {
					key += options[prop];
				}
			}

			return key;
		},
		_animTex: function _animTex(options) {
			var vshader = "";
			vshader += options.animTexLoop ? shaderChunks.particleAnimFrameLoopVS : shaderChunks.particleAnimFrameClampVS;
			vshader += shaderChunks.particleAnimTexVS;
			return vshader;
		},
		createShaderDefinition: function createShaderDefinition(device, options) {
			var vshader = "";
			var fshader = precisionCode(device) + "\n";
			fshader += '#define PARTICLE\n';

			if (device.webgl2) {
				vshader += "#define GL2\n";
				fshader += "#define GL2\n";
			}

			vshader += "#define VERTEXSHADER\n";
			if (options.mesh) vshader += "#define USE_MESH\n";
			if (options.localSpace) vshader += "#define LOCAL_SPACE\n";
			if (options.screenSpace) vshader += "#define SCREEN_SPACE\n";
			if (options.animTex) vshader += "\nuniform vec2 animTexTilesParams;\n";
			if (options.animTex) vshader += "\nuniform vec4 animTexParams;\n";
			if (options.animTex) vshader += "\nuniform vec2 animTexIndexParams;\n";
			if (options.normal === 2) vshader += "\nvarying mat3 ParticleMat;\n";
			if (options.normal === 1) vshader += "\nvarying vec3 Normal;\n";
			if (options.soft) vshader += "\nvarying float vDepth;\n";
			var faceVS = options.customFace ? shaderChunks.particle_customFaceVS : shaderChunks.particle_billboardVS;

			if (!options.useCpu) {
				vshader += shaderChunks.particle_initVS;
				vshader += options.pack8 ? shaderChunks.particleInputRgba8PS : shaderChunks.particleInputFloatPS;
				if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
				vshader += shaderChunks.particleVS;
				if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
				if (options.animTex) vshader += this._animTex(options);
				if (options.wrap) vshader += shaderChunks.particle_wrapVS;
				if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
				vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
				if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
				if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
				if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
				vshader += shaderChunks.particle_endVS;
				if (options.soft > 0) vshader += shaderChunks.particle_softVS;
			} else {
				if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
				vshader += shaderChunks.particle_cpuVS;
				if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
				if (options.animTex) vshader += this._animTex(options);
				if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
				vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
				if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
				if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
				if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
				vshader += shaderChunks.particle_cpu_endVS;
				if (options.soft > 0) vshader += shaderChunks.particle_softVS;
			}

			vshader += "}\n";

			if (options.normal > 0) {
				if (options.normal === 1) {
					fshader += "\nvarying vec3 Normal;\n";
				} else if (options.normal === 2) {
					fshader += "\nvarying mat3 ParticleMat;\n";
				}

				fshader += "\nuniform vec3 lightCube[6];\n";
			}

			if (options.soft) fshader += "\nvarying float vDepth;\n";
			if (options.normal === 0 && options.fog === "none") options.srgb = false;
			fshader += gammaCode(options.gamma);
			fshader += tonemapCode(options.toneMap);

			if (options.fog === 'linear') {
				fshader += shaderChunks.fogLinearPS;
			} else if (options.fog === 'exp') {
				fshader += shaderChunks.fogExpPS;
			} else if (options.fog === 'exp2') {
				fshader += shaderChunks.fogExp2PS;
			} else {
				fshader += shaderChunks.fogNonePS;
			}

			if (options.normal === 2) fshader += "\nuniform sampler2D normalMap;\n";
			if (options.soft > 0) fshader += shaderChunks.screenDepthPS;
			fshader += shaderChunks.particlePS;
			if (options.soft > 0) fshader += shaderChunks.particle_softPS;
			if (options.normal === 1) fshader += "\nvec3 normal = Normal;\n";
			if (options.normal === 2) fshader += shaderChunks.particle_normalMapPS;
			if (options.normal > 0) fshader += options.halflambert ? shaderChunks.particle_halflambertPS : shaderChunks.particle_lambertPS;
			if (options.normal > 0) fshader += shaderChunks.particle_lightingPS;

			if (options.blend === BLEND_NORMAL) {
				fshader += shaderChunks.particle_blendNormalPS;
			} else if (options.blend === BLEND_ADDITIVE) {
				fshader += shaderChunks.particle_blendAddPS;
			} else if (options.blend === BLEND_MULTIPLICATIVE) {
				fshader += shaderChunks.particle_blendMultiplyPS;
			}

			fshader += shaderChunks.particle_endPS;
			var attributes = collectAttribs(vshader);
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: fshader
			};
		}
	};

	var skybox = {
		generateKey: function generateKey(options) {
			return options.type === 'cubemap' ? "skybox-" + options.type + "-" + options.rgbm + "-" + options.hdr + "-" + options.fixSeams + "-" + options.toneMapping + "-" + options.gamma + "-" + options.useIntensity + "-" + options.mip : "skybox-" + options.type + "-" + options.encoding + "-" + options.useIntensity + "-" + options.gamma + "-" + options.toneMapping;
		},
		createShaderDefinition: function createShaderDefinition(device, options) {
			var fshader;

			if (options.type === 'cubemap') {
				var mip2size = [128, 64, 16, 8, 4, 2];
				fshader = precisionCode(device);
				fshader += options.mip ? shaderChunks.fixCubemapSeamsStretchPS : shaderChunks.fixCubemapSeamsNonePS;
				fshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;
				fshader += gammaCode(options.gamma);
				fshader += tonemapCode(options.toneMapping);
				fshader += shaderChunks.decodePS;
				fshader += shaderChunks.rgbmPS;
				fshader += shaderChunks.skyboxHDRPS.replace(/\$textureCubeSAMPLE/g, options.rgbm ? "textureCubeRGBM" : options.hdr ? "textureCube" : "textureCubeSRGB").replace(/\$FIXCONST/g, 1 - 1 / mip2size[options.mip] + "");
			} else {
				var decodeTable = {
					'rgbm': 'decodeRGBM',
					'rgbe': 'decodeRGBE',
					'linear': 'decodeLinear'
				};
				fshader = precisionCode(device);
				fshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;
				fshader += gammaCode(options.gamma);
				fshader += tonemapCode(options.toneMapping);
				fshader += shaderChunks.decodePS;
				fshader += shaderChunks.skyboxEnvPS.replace(/\$DECODE/g, decodeTable[options.encoding] || "decodeGamma");
			}

			return {
				attributes: {
					aPosition: SEMANTIC_POSITION
				},
				vshader: shaderChunks.skyboxVS,
				fshader: fshader
			};
		}
	};

	var checkRange = 5;
	var oneDiv255 = 1 / 255;
	var floatView = new Float32Array(1);
	var int32View = new Int32Array(floatView.buffer);

	var FloatPacking = function () {
		function FloatPacking() {}

		FloatPacking.float2Half = function float2Half(value) {
			floatView[0] = value;
			var x = int32View[0];
			var bits = x >> 16 & 0x8000;
			var m = x >> 12 & 0x07ff;
			var e = x >> 23 & 0xff;

			if (e < 103) {
				return bits;
			}

			if (e > 142) {
				bits |= 0x7c00;
				bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;
				return bits;
			}

			if (e < 113) {
				m |= 0x0800;
				bits |= (m >> 114 - e) + (m >> 113 - e & 1);
				return bits;
			}

			bits |= e - 112 << 10 | m >> 1;
			bits += m & 1;
			return bits;
		};

		FloatPacking.float2Bytes = function float2Bytes(value, array, offset, numBytes) {
			var enc1 = 255.0 * value % 1;
			array[offset + 0] = Math.round((value % 1 - oneDiv255 * enc1) * 255);

			if (numBytes > 1) {
				var enc2 = 65025.0 * value % 1;
				array[offset + 1] = Math.round((enc1 - oneDiv255 * enc2) * 255);

				if (numBytes > 2) {
					var enc3 = 16581375.0 * value % 1;
					array[offset + 2] = Math.round((enc2 - oneDiv255 * enc3) * 255);

					if (numBytes > 3) {
						array[offset + 3] = Math.round(enc3 * 255);
					}
				}
			}
		};

		FloatPacking.float2BytesRange = function float2BytesRange(value, array, offset, min, max, numBytes) {
			if (value < min || value > max) {
				if (checkRange) {
					checkRange--;
					console.warn('float2BytesRange - value to pack is out of specified range.');
				}
			}

			value = math.clamp((value - min) / (max - min), 0, 1);
			FloatPacking.float2Bytes(value, array, offset, numBytes);
		};

		FloatPacking.float2MantissaExponent = function float2MantissaExponent(value, array, offset, numBytes) {
			var exponent = Math.floor(Math.log2(Math.abs(value))) + 1;
			value /= Math.pow(2, exponent);
			FloatPacking.float2BytesRange(value, array, offset, -1, 1, numBytes - 1);
			array[offset + numBytes - 1] = Math.round(exponent + 127);
		};

		return FloatPacking;
	}();

	var _pixelSizeTable = null;
	var _blockSizeTable = null;

	var Texture = function () {
		function Texture(graphicsDevice, options) {
			this.device = graphicsDevice;
			Debug.assert(this.device, "Texture contructor requires a graphicsDevice to be valid");
			this.name = null;
			this._width = 4;
			this._height = 4;
			this._depth = 1;
			this._format = PIXELFORMAT_R8_G8_B8_A8;
			this.type = TEXTURETYPE_DEFAULT;
			this.projection = TEXTUREPROJECTION_NONE;
			this._cubemap = false;
			this._volume = false;
			this.fixCubemapSeams = false;
			this._flipY = false;
			this._premultiplyAlpha = false;
			this._isRenderTarget = false;
			this._mipmaps = true;
			this._minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
			this._magFilter = FILTER_LINEAR;
			this._anisotropy = 1;
			this._addressU = ADDRESS_REPEAT;
			this._addressV = ADDRESS_REPEAT;
			this._addressW = ADDRESS_REPEAT;
			this._compareOnRead = false;
			this._compareFunc = FUNC_LESS;
			this.profilerHint = 0;

			if (options !== undefined) {
				if (options.name !== undefined) {
					this.name = options.name;
				}

				this._width = options.width !== undefined ? options.width : this._width;
				this._height = options.height !== undefined ? options.height : this._height;
				this._format = options.format !== undefined ? options.format : this._format;

				if (options.hasOwnProperty('type')) {
					this.type = options.type;
				} else if (options.hasOwnProperty('rgbm')) {
					Debug.deprecated("options.rgbm is deprecated. Use options.type instead.");
					this.type = options.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
				} else if (options.hasOwnProperty('swizzleGGGR')) {
					Debug.deprecated("options.swizzleGGGR is deprecated. Use options.type instead.");
					this.type = options.swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
				}

				if (options.mipmaps !== undefined) {
					this._mipmaps = options.mipmaps;
				} else {
					this._mipmaps = options.autoMipmap !== undefined ? options.autoMipmap : this._mipmaps;
				}

				this._levels = options.levels;
				this._cubemap = options.cubemap !== undefined ? options.cubemap : this._cubemap;
				this.fixCubemapSeams = options.fixCubemapSeams !== undefined ? options.fixCubemapSeams : this.fixCubemapSeams;

				if (this._cubemap) {
					this.projection = TEXTUREPROJECTION_CUBE;
				} else if (options.projection && options.projection !== TEXTUREPROJECTION_CUBE) {
					this.projection = options.projection;
				}

				this._minFilter = options.minFilter !== undefined ? options.minFilter : this._minFilter;
				this._magFilter = options.magFilter !== undefined ? options.magFilter : this._magFilter;
				this._anisotropy = options.anisotropy !== undefined ? options.anisotropy : this._anisotropy;
				this._addressU = options.addressU !== undefined ? options.addressU : this._addressU;
				this._addressV = options.addressV !== undefined ? options.addressV : this._addressV;
				this._compareOnRead = options.compareOnRead !== undefined ? options.compareOnRead : this._compareOnRead;
				this._compareFunc = options._compareFunc !== undefined ? options._compareFunc : this._compareFunc;
				this._flipY = options.flipY !== undefined ? options.flipY : this._flipY;
				this._premultiplyAlpha = options.premultiplyAlpha !== undefined ? options.premultiplyAlpha : this._premultiplyAlpha;

				if (graphicsDevice.webgl2) {
					this._depth = options.depth !== undefined ? options.depth : this._depth;
					this._volume = options.volume !== undefined ? options.volume : this._volume;
					this._addressW = options.addressW !== undefined ? options.addressW : this._addressW;
				}

				this.profilerHint = options.profilerHint !== undefined ? options.profilerHint : this.profilerHint;
			}

			this._compressed = this._format === PIXELFORMAT_DXT1 || this._format === PIXELFORMAT_DXT3 || this._format === PIXELFORMAT_DXT5 || this._format >= PIXELFORMAT_ETC1;
			this._invalid = false;
			this._lockedLevel = -1;

			if (!this._levels) {
				this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];
			}

			this.dirtyAll();
			this._gpuSize = 0;
			this.impl = graphicsDevice.createTextureImpl();
			graphicsDevice.textures.push(this);
		}

		var _proto = Texture.prototype;

		_proto.destroy = function destroy() {
			if (this.device) {
				var device = this.device;
				var idx = device.textures.indexOf(this);

				if (idx !== -1) {
					device.textures.splice(idx, 1);
				}

				device.scope.removeValue(this);
				this.impl.destroy(device);
				this.adjustVramSizeTracking(device._vram, -this._gpuSize);
				this._levels = null;
				this.device = null;
			}
		};

		_proto.loseContext = function loseContext() {
			this.impl.loseContext();
			this.dirtyAll();
		};

		_proto.adjustVramSizeTracking = function adjustVramSizeTracking(vram, size) {
			vram.tex += size;

			if (this.profilerHint === TEXHINT_SHADOWMAP) {
				vram.texShadow += size;
			} else if (this.profilerHint === TEXHINT_ASSET) {
				vram.texAsset += size;
			} else if (this.profilerHint === TEXHINT_LIGHTMAP) {
				vram.texLightmap += size;
			}
		};

		Texture.calcGpuSize = function calcGpuSize(width, height, depth, format, mipmaps, cubemap) {
			if (!_pixelSizeTable) {
				_pixelSizeTable = [];
				_pixelSizeTable[PIXELFORMAT_A8] = 1;
				_pixelSizeTable[PIXELFORMAT_L8] = 1;
				_pixelSizeTable[PIXELFORMAT_L8_A8] = 2;
				_pixelSizeTable[PIXELFORMAT_R5_G6_B5] = 2;
				_pixelSizeTable[PIXELFORMAT_R5_G5_B5_A1] = 2;
				_pixelSizeTable[PIXELFORMAT_R4_G4_B4_A4] = 2;
				_pixelSizeTable[PIXELFORMAT_R8_G8_B8] = 4;
				_pixelSizeTable[PIXELFORMAT_R8_G8_B8_A8] = 4;
				_pixelSizeTable[PIXELFORMAT_RGB16F] = 8;
				_pixelSizeTable[PIXELFORMAT_RGBA16F] = 8;
				_pixelSizeTable[PIXELFORMAT_RGB32F] = 16;
				_pixelSizeTable[PIXELFORMAT_RGBA32F] = 16;
				_pixelSizeTable[PIXELFORMAT_R32F] = 4;
				_pixelSizeTable[PIXELFORMAT_DEPTH] = 4;
				_pixelSizeTable[PIXELFORMAT_DEPTHSTENCIL] = 4;
				_pixelSizeTable[PIXELFORMAT_111110F] = 4;
				_pixelSizeTable[PIXELFORMAT_SRGB] = 4;
				_pixelSizeTable[PIXELFORMAT_SRGBA] = 4;
			}

			if (!_blockSizeTable) {
				_blockSizeTable = [];
				_blockSizeTable[PIXELFORMAT_ETC1] = 8;
				_blockSizeTable[PIXELFORMAT_ETC2_RGB] = 8;
				_blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGB_1] = 8;
				_blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGBA_1] = 8;
				_blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGB_1] = 8;
				_blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGBA_1] = 8;
				_blockSizeTable[PIXELFORMAT_DXT1] = 8;
				_blockSizeTable[PIXELFORMAT_ATC_RGB] = 8;
				_blockSizeTable[PIXELFORMAT_ETC2_RGBA] = 16;
				_blockSizeTable[PIXELFORMAT_DXT3] = 16;
				_blockSizeTable[PIXELFORMAT_DXT5] = 16;
				_blockSizeTable[PIXELFORMAT_ASTC_4x4] = 16;
				_blockSizeTable[PIXELFORMAT_ATC_RGBA] = 16;
			}

			var pixelSize = _pixelSizeTable.hasOwnProperty(format) ? _pixelSizeTable[format] : 0;
			var blockSize = _blockSizeTable.hasOwnProperty(format) ? _blockSizeTable[format] : 0;
			var result = 0;

			while (1) {
				if (pixelSize > 0) {
					result += width * height * depth * pixelSize;
				} else {
					var blockWidth = Math.floor((width + 3) / 4);
					var blockHeight = Math.floor((height + 3) / 4);
					var blockDepth = Math.floor((depth + 3) / 4);

					if (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 || format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {
						blockWidth = Math.max(Math.floor(blockWidth / 2), 1);
					}

					result += blockWidth * blockHeight * blockDepth * blockSize;
				}

				if (!mipmaps || width === 1 && height === 1 && depth === 1) {
					break;
				}

				width = Math.max(Math.floor(width / 2), 1);
				height = Math.max(Math.floor(height / 2), 1);
				depth = Math.max(Math.floor(depth / 2), 1);
			}

			return result * (cubemap ? 6 : 1);
		};

		_proto.dirtyAll = function dirtyAll() {
			this._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];
			this._needsUpload = true;
			this._needsMipmapsUpload = this._mipmaps;
			this._mipmapsUploaded = false;
			this._parameterFlags = 255;
		};

		_proto.lock = function lock(options) {
			if (options === void 0) {
				options = {};
			}

			if (options.level === undefined) {
				options.level = 0;
			}

			if (options.face === undefined) {
				options.face = 0;
			}

			if (options.mode === undefined) {
				options.mode = TEXTURELOCK_WRITE;
			}

			this._lockedLevel = options.level;

			if (this._levels[options.level] === null) {
				switch (this._format) {
					case PIXELFORMAT_A8:
					case PIXELFORMAT_L8:
						this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth);
						break;

					case PIXELFORMAT_L8_A8:
						this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 2);
						break;

					case PIXELFORMAT_R5_G6_B5:
					case PIXELFORMAT_R5_G5_B5_A1:
					case PIXELFORMAT_R4_G4_B4_A4:
						this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth);
						break;

					case PIXELFORMAT_R8_G8_B8:
						this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 3);
						break;

					case PIXELFORMAT_R8_G8_B8_A8:
						this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 4);
						break;

					case PIXELFORMAT_DXT1:
						this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);
						break;

					case PIXELFORMAT_DXT3:
					case PIXELFORMAT_DXT5:
						this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);
						break;

					case PIXELFORMAT_RGB16F:
						this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 3);
						break;

					case PIXELFORMAT_RGB32F:
						this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 3);
						break;

					case PIXELFORMAT_RGBA16F:
						this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 4);
						break;

					case PIXELFORMAT_RGBA32F:
						this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 4);
						break;
				}
			}

			return this._levels[options.level];
		};

		_proto.setSource = function setSource(source, mipLevel) {
			if (mipLevel === void 0) {
				mipLevel = 0;
			}

			var invalid = false;
			var width, height;

			if (this._cubemap) {
				if (source[0]) {
					width = source[0].width || 0;
					height = source[0].height || 0;

					for (var i = 0; i < 6; i++) {
						var face = source[i];

						if (!face || face.width !== width || face.height !== height || !this.device._isBrowserInterface(face)) {
							invalid = true;
							break;
						}
					}
				} else {
					invalid = true;
				}

				if (!invalid) {
					for (var _i = 0; _i < 6; _i++) {
						if (this._levels[mipLevel][_i] !== source[_i]) this._levelsUpdated[mipLevel][_i] = true;
					}
				}
			} else {
				if (!this.device._isBrowserInterface(source)) invalid = true;

				if (!invalid) {
					if (source !== this._levels[mipLevel]) this._levelsUpdated[mipLevel] = true;
					width = source.width;
					height = source.height;
				}
			}

			if (invalid) {
				this._width = 4;
				this._height = 4;

				if (this._cubemap) {
					for (var _i2 = 0; _i2 < 6; _i2++) {
						this._levels[mipLevel][_i2] = null;
						this._levelsUpdated[mipLevel][_i2] = true;
					}
				} else {
					this._levels[mipLevel] = null;
					this._levelsUpdated[mipLevel] = true;
				}
			} else {
				if (mipLevel === 0) {
					this._width = width;
					this._height = height;
				}

				this._levels[mipLevel] = source;
			}

			if (this._invalid !== invalid || !invalid) {
				this._invalid = invalid;
				this.upload();
			}
		};

		_proto.getSource = function getSource(mipLevel) {
			if (mipLevel === void 0) {
				mipLevel = 0;
			}

			return this._levels[mipLevel];
		};

		_proto.unlock = function unlock() {
			if (this._lockedLevel === -1) {
				Debug.log("pc.Texture#unlock: Attempting to unlock a texture that is not locked.");
			}

			this.upload();
			this._lockedLevel = -1;
		};

		_proto.upload = function upload() {
			this._needsUpload = true;
			this._needsMipmapsUpload = this._mipmaps;
		};

		_proto.getDds = function getDds() {
			Debug.assert(this.format === PIXELFORMAT_R8_G8_B8_A8, "This format is not implemented yet");
			var fsize = 128;
			var idx = 0;

			while (this._levels[idx]) {
				if (!this.cubemap) {
					var mipSize = this._levels[idx].length;

					if (!mipSize) {
						Debug.error("No byte array for mip " + idx);
						return;
					}

					fsize += mipSize;
				} else {
					for (var face = 0; face < 6; face++) {
						if (!this._levels[idx][face]) {
							Debug.error("No level data for mip " + idx + ", face " + face);
							return;
						}

						var _mipSize = this._levels[idx][face].length;

						if (!_mipSize) {
							Debug.error("No byte array for mip " + idx + ", face " + face);
							return;
						}

						fsize += _mipSize;
					}
				}

				fsize += this._levels[idx].length;
				idx++;
			}

			var buff = new ArrayBuffer(fsize);
			var header = new Uint32Array(buff, 0, 128 / 4);
			var DDS_MAGIC = 542327876;
			var DDS_HEADER_SIZE = 124;
			var DDS_FLAGS_REQUIRED = 0x01 | 0x02 | 0x04 | 0x1000 | 0x80000;
			var DDS_FLAGS_MIPMAP = 0x20000;
			var DDS_PIXELFORMAT_SIZE = 32;
			var DDS_PIXELFLAGS_RGBA8 = 0x01 | 0x40;
			var DDS_CAPS_REQUIRED = 0x1000;
			var DDS_CAPS_MIPMAP = 0x400000;
			var DDS_CAPS_COMPLEX = 0x8;
			var DDS_CAPS2_CUBEMAP = 0x200 | 0x400 | 0x800 | 0x1000 | 0x2000 | 0x4000 | 0x8000;
			var flags = DDS_FLAGS_REQUIRED;
			if (this._levels.length > 1) flags |= DDS_FLAGS_MIPMAP;
			var caps = DDS_CAPS_REQUIRED;
			if (this._levels.length > 1) caps |= DDS_CAPS_MIPMAP;
			if (this._levels.length > 1 || this.cubemap) caps |= DDS_CAPS_COMPLEX;
			var caps2 = this.cubemap ? DDS_CAPS2_CUBEMAP : 0;
			header[0] = DDS_MAGIC;
			header[1] = DDS_HEADER_SIZE;
			header[2] = flags;
			header[3] = this.height;
			header[4] = this.width;
			header[5] = this.width * this.height * 4;
			header[6] = 0;
			header[7] = this._levels.length;

			for (var i = 0; i < 11; i++) {
				header[8 + i] = 0;
			}

			header[19] = DDS_PIXELFORMAT_SIZE;
			header[20] = DDS_PIXELFLAGS_RGBA8;
			header[21] = 0;
			header[22] = 32;
			header[23] = 0x00FF0000;
			header[24] = 0x0000FF00;
			header[25] = 0x000000FF;
			header[26] = 0xFF000000;
			header[27] = caps;
			header[28] = caps2;
			header[29] = 0;
			header[30] = 0;
			header[31] = 0;
			var offset = 128;

			if (!this.cubemap) {
				for (var _i3 = 0; _i3 < this._levels.length; _i3++) {
					var level = this._levels[_i3];
					var mip = new Uint8Array(buff, offset, level.length);

					for (var j = 0; j < level.length; j++) {
						mip[j] = level[j];
					}

					offset += level.length;
				}
			} else {
				for (var _face = 0; _face < 6; _face++) {
					for (var _i4 = 0; _i4 < this._levels.length; _i4++) {
						var _level = this._levels[_i4][_face];

						var _mip = new Uint8Array(buff, offset, _level.length);

						for (var _j = 0; _j < _level.length; _j++) {
							_mip[_j] = _level[_j];
						}

						offset += _level.length;
					}
				}
			}

			return buff;
		};

		_createClass(Texture, [{
			key: "minFilter",
			get: function get() {
				return this._minFilter;
			},
			set: function set(v) {
				if (this._minFilter !== v) {
					this._minFilter = v;
					this._parameterFlags |= 1;
				}
			}
		}, {
			key: "magFilter",
			get: function get() {
				return this._magFilter;
			},
			set: function set(v) {
				if (this._magFilter !== v) {
					this._magFilter = v;
					this._parameterFlags |= 2;
				}
			}
		}, {
			key: "addressU",
			get: function get() {
				return this._addressU;
			},
			set: function set(v) {
				if (this._addressU !== v) {
					this._addressU = v;
					this._parameterFlags |= 4;
				}
			}
		}, {
			key: "addressV",
			get: function get() {
				return this._addressV;
			},
			set: function set(v) {
				if (this._addressV !== v) {
					this._addressV = v;
					this._parameterFlags |= 8;
				}
			}
		}, {
			key: "addressW",
			get: function get() {
				return this._addressW;
			},
			set: function set(addressW) {
				if (!this.device.webgl2) return;

				if (!this._volume) {
					Debug.warn("pc.Texture#addressW: Can't set W addressing mode for a non-3D texture.");
					return;
				}

				if (addressW !== this._addressW) {
					this._addressW = addressW;
					this._parameterFlags |= 16;
				}
			}
		}, {
			key: "compareOnRead",
			get: function get() {
				return this._compareOnRead;
			},
			set: function set(v) {
				if (this._compareOnRead !== v) {
					this._compareOnRead = v;
					this._parameterFlags |= 32;
				}
			}
		}, {
			key: "compareFunc",
			get: function get() {
				return this._compareFunc;
			},
			set: function set(v) {
				if (this._compareFunc !== v) {
					this._compareFunc = v;
					this._parameterFlags |= 64;
				}
			}
		}, {
			key: "anisotropy",
			get: function get() {
				return this._anisotropy;
			},
			set: function set(v) {
				if (this._anisotropy !== v) {
					this._anisotropy = v;
					this._parameterFlags |= 128;
				}
			}
		}, {
			key: "autoMipmap",
			get: function get() {
				return this._mipmaps;
			},
			set: function set(v) {
				this._mipmaps = v;
			}
		}, {
			key: "mipmaps",
			get: function get() {
				return this._mipmaps;
			},
			set: function set(v) {
				if (this._mipmaps !== v) {
					this._mipmaps = v;
					if (v) this._needsMipmapsUpload = true;
				}
			}
		}, {
			key: "width",
			get: function get() {
				return this._width;
			}
		}, {
			key: "height",
			get: function get() {
				return this._height;
			}
		}, {
			key: "depth",
			get: function get() {
				return this._depth;
			}
		}, {
			key: "format",
			get: function get() {
				return this._format;
			}
		}, {
			key: "cubemap",
			get: function get() {
				return this._cubemap;
			}
		}, {
			key: "gpuSize",
			get: function get() {
				var mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);
				return Texture.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);
			}
		}, {
			key: "volume",
			get: function get() {
				return this._volume;
			}
		}, {
			key: "flipY",
			get: function get() {
				return this._flipY;
			},
			set: function set(flipY) {
				if (this._flipY !== flipY) {
					this._flipY = flipY;
					this._needsUpload = true;
				}
			}
		}, {
			key: "premultiplyAlpha",
			get: function get() {
				return this._premultiplyAlpha;
			},
			set: function set(premultiplyAlpha) {
				if (this._premultiplyAlpha !== premultiplyAlpha) {
					this._premultiplyAlpha = premultiplyAlpha;
					this._needsUpload = true;
				}
			}
		}, {
			key: "pot",
			get: function get() {
				return math.powerOfTwo(this._width) && math.powerOfTwo(this._height);
			}
		}, {
			key: "encoding",
			get: function get() {
				if (this.type === TEXTURETYPE_RGBM) {
					return 'rgbm';
				}

				if (this.type === TEXTURETYPE_RGBE) {
					return 'rgbe';
				}

				if (this.format === PIXELFORMAT_RGBA16F || this.format === PIXELFORMAT_RGBA32F) {
					return 'linear';
				}

				return 'srgb';
			}
		}]);

		return Texture;
	}();

	var _deviceCoord = new Vec3();

	var _halfSize = new Vec3();

	var _point = new Vec3();

	var _invViewProjMat = new Mat4();

	var Camera = function () {
		function Camera() {
			this._aspectRatio = 16 / 9;
			this._aspectRatioMode = ASPECT_AUTO;
			this._calculateProjection = null;
			this._calculateTransform = null;
			this._clearColor = new Color(0.75, 0.75, 0.75, 1);
			this._clearColorBuffer = true;
			this._clearDepth = 1;
			this._clearDepthBuffer = true;
			this._clearStencil = 0;
			this._clearStencilBuffer = true;
			this._cullingMask = 0xFFFFFFFF;
			this._cullFaces = true;
			this._farClip = 1000;
			this._flipFaces = false;
			this._fov = 45;
			this._frustumCulling = true;
			this._horizontalFov = false;
			this._layers = [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE];
			this._nearClip = 0.1;
			this._node = null;
			this._orthoHeight = 10;
			this._projection = PROJECTION_PERSPECTIVE;
			this._rect = new Vec4(0, 0, 1, 1);
			this._renderTarget = null;
			this._scissorRect = new Vec4(0, 0, 1, 1);
			this._scissorRectClear = false;
			this._vrDisplay = null;
			this._projMat = new Mat4();
			this._projMatDirty = true;
			this._projMatSkybox = new Mat4();
			this._viewMat = new Mat4();
			this._viewMatDirty = true;
			this._viewProjMat = new Mat4();
			this._viewProjMatDirty = true;
			this.frustum = new Frustum();
		}

		var _proto = Camera.prototype;

		_proto.clone = function clone() {
			return new Camera().copy(this);
		};

		_proto.copy = function copy(other) {
			this.aspectRatio = other.aspectRatio;
			this.aspectRatioMode = other.aspectRatioMode;
			this.calculateProjection = other.calculateProjection;
			this.calculateTransform = other.calculateTransform;
			this.clearColor = other.clearColor;
			this.clearColorBuffer = other.clearColorBuffer;
			this.clearDepth = other.clearDepth;
			this.clearDepthBuffer = other.clearDepthBuffer;
			this.clearStencil = other.clearStencil;
			this.clearStencilBuffer = other.clearStencilBuffer;
			this.cullFaces = other.cullFaces;
			this.cullingMask = other.cullingMask;
			this.farClip = other.farClip;
			this.flipFaces = other.flipFaces;
			this.fov = other.fov;
			this.frustumCulling = other.frustumCulling;
			this.horizontalFov = other.horizontalFov;
			this.layers = other.layers;
			this.nearClip = other.nearClip;
			this.orthoHeight = other.orthoHeight;
			this.projection = other.projection;
			this.rect = other.rect;
			this.renderTarget = other.renderTarget;
			this.scissorRect = other.scissorRect;
			this.vrDisplay = other.vrDisplay;
			return this;
		};

		_proto._updateViewProjMat = function _updateViewProjMat() {
			if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
				this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix);

				this._viewProjMatDirty = false;
			}
		};

		_proto.worldToScreen = function worldToScreen(worldCoord, cw, ch, screenCoord) {
			if (screenCoord === void 0) {
				screenCoord = new Vec3();
			}

			this._updateViewProjMat();

			this._viewProjMat.transformPoint(worldCoord, screenCoord);

			var vpm = this._viewProjMat.data;
			var w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];
			screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;
			screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;
			return screenCoord;
		};

		_proto.screenToWorld = function screenToWorld(x, y, z, cw, ch, worldCoord) {
			if (worldCoord === void 0) {
				worldCoord = new Vec3();
			}

			var range = this._farClip - this._nearClip;

			_deviceCoord.set(x / cw, (ch - y) / ch, z / range);

			_deviceCoord.mulScalar(2);

			_deviceCoord.sub(Vec3.ONE);

			if (this._projection === PROJECTION_PERSPECTIVE) {
				Mat4._getPerspectiveHalfSize(_halfSize, this._fov, this._aspectRatio, this._nearClip, this._horizontalFov);

				_halfSize.x *= _deviceCoord.x;
				_halfSize.y *= _deviceCoord.y;

				var invView = this._node.getWorldTransform();

				_halfSize.z = -this._nearClip;
				invView.transformPoint(_halfSize, _point);

				var cameraPos = this._node.getPosition();

				worldCoord.sub2(_point, cameraPos);
				worldCoord.normalize();
				worldCoord.mulScalar(z);
				worldCoord.add(cameraPos);
			} else {
				this._updateViewProjMat();

				_invViewProjMat.copy(this._viewProjMat).invert();

				_invViewProjMat.transformPoint(_deviceCoord, worldCoord);
			}

			return worldCoord;
		};

		_proto._evaluateProjectionMatrix = function _evaluateProjectionMatrix() {
			if (this._projMatDirty) {
				if (this._projection === PROJECTION_PERSPECTIVE) {
					this._projMat.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip, this._horizontalFov);

					this._projMatSkybox.copy(this._projMat);
				} else {
					var y = this._orthoHeight;
					var x = y * this._aspectRatio;

					this._projMat.setOrtho(-x, x, -y, y, this._nearClip, this._farClip);

					this._projMatSkybox.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip);
				}

				this._projMatDirty = false;
			}
		};

		_proto.getProjectionMatrixSkybox = function getProjectionMatrixSkybox() {
			this._evaluateProjectionMatrix();

			return this._projMatSkybox;
		};

		_proto.getScreenSize = function getScreenSize(sphere) {
			if (this._projection === PROJECTION_PERSPECTIVE) {
				var distance = this._node.getPosition().distance(sphere.center);

				if (distance < sphere.radius) {
					return 1;
				}

				var viewAngle = Math.asin(sphere.radius / distance);
				var sphereViewHeight = Math.tan(viewAngle);
				var screenViewHeight = Math.tan(this._fov / 2 * math.DEG_TO_RAD);
				return Math.min(sphereViewHeight / screenViewHeight, 1);
			}

			return math.clamp(sphere.radius / this._orthoHeight, 0, 1);
		};

		_createClass(Camera, [{
			key: "aspectRatio",
			get: function get() {
				return this._aspectRatio;
			},
			set: function set(newValue) {
				if (this._aspectRatio !== newValue) {
					this._aspectRatio = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "aspectRatioMode",
			get: function get() {
				return this._aspectRatioMode;
			},
			set: function set(newValue) {
				if (this._aspectRatioMode !== newValue) {
					this._aspectRatioMode = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "calculateProjection",
			get: function get() {
				return this._calculateProjection;
			},
			set: function set(newValue) {
				this._calculateProjection = newValue;
				this._projMatDirty = true;
			}
		}, {
			key: "calculateTransform",
			get: function get() {
				return this._calculateTransform;
			},
			set: function set(newValue) {
				this._calculateTransform = newValue;
			}
		}, {
			key: "clearColor",
			get: function get() {
				return this._clearColor;
			},
			set: function set(newValue) {
				this._clearColor.copy(newValue);
			}
		}, {
			key: "clearColorBuffer",
			get: function get() {
				return this._clearColorBuffer;
			},
			set: function set(newValue) {
				this._clearColorBuffer = newValue;
			}
		}, {
			key: "clearDepth",
			get: function get() {
				return this._clearDepth;
			},
			set: function set(newValue) {
				this._clearDepth = newValue;
			}
		}, {
			key: "clearDepthBuffer",
			get: function get() {
				return this._clearDepthBuffer;
			},
			set: function set(newValue) {
				this._clearDepthBuffer = newValue;
			}
		}, {
			key: "clearStencil",
			get: function get() {
				return this._clearStencil;
			},
			set: function set(newValue) {
				this._clearStencil = newValue;
			}
		}, {
			key: "clearStencilBuffer",
			get: function get() {
				return this._clearStencilBuffer;
			},
			set: function set(newValue) {
				this._clearStencilBuffer = newValue;
			}
		}, {
			key: "cullingMask",
			get: function get() {
				return this._cullingMask;
			},
			set: function set(newValue) {
				this._cullingMask = newValue;
			}
		}, {
			key: "cullFaces",
			get: function get() {
				return this._cullFaces;
			},
			set: function set(newValue) {
				this._cullFaces = newValue;
			}
		}, {
			key: "farClip",
			get: function get() {
				return this._farClip;
			},
			set: function set(newValue) {
				if (this._farClip !== newValue) {
					this._farClip = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "flipFaces",
			get: function get() {
				return this._flipFaces;
			},
			set: function set(newValue) {
				this._flipFaces = newValue;
			}
		}, {
			key: "fov",
			get: function get() {
				return this._fov;
			},
			set: function set(newValue) {
				if (this._fov !== newValue) {
					this._fov = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "frustumCulling",
			get: function get() {
				return this._frustumCulling;
			},
			set: function set(newValue) {
				this._frustumCulling = newValue;
			}
		}, {
			key: "horizontalFov",
			get: function get() {
				return this._horizontalFov;
			},
			set: function set(newValue) {
				if (this._horizontalFov !== newValue) {
					this._horizontalFov = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(newValue) {
				this._layers = newValue.slice(0);
			}
		}, {
			key: "nearClip",
			get: function get() {
				return this._nearClip;
			},
			set: function set(newValue) {
				if (this._nearClip !== newValue) {
					this._nearClip = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "node",
			get: function get() {
				return this._node;
			},
			set: function set(newValue) {
				this._node = newValue;
			}
		}, {
			key: "orthoHeight",
			get: function get() {
				return this._orthoHeight;
			},
			set: function set(newValue) {
				if (this._orthoHeight !== newValue) {
					this._orthoHeight = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "projection",
			get: function get() {
				return this._projection;
			},
			set: function set(newValue) {
				if (this._projection !== newValue) {
					this._projection = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "projectionMatrix",
			get: function get() {
				this._evaluateProjectionMatrix();

				return this._projMat;
			}
		}, {
			key: "rect",
			get: function get() {
				return this._rect;
			},
			set: function set(newValue) {
				this._rect.copy(newValue);
			}
		}, {
			key: "renderTarget",
			get: function get() {
				return this._renderTarget;
			},
			set: function set(newValue) {
				this._renderTarget = newValue;
			}
		}, {
			key: "scissorRect",
			get: function get() {
				return this._scissorRect;
			},
			set: function set(newValue) {
				this._scissorRect.copy(newValue);
			}
		}, {
			key: "viewMatrix",
			get: function get() {
				if (this._viewMatDirty) {
					var wtm = this._node.getWorldTransform();

					this._viewMat.copy(wtm).invert();

					this._viewMatDirty = false;
				}

				return this._viewMat;
			}
		}, {
			key: "vrDisplay",
			get: function get() {
				return this._vrDisplay;
			},
			set: function set(newValue) {
				this._vrDisplay = newValue;

				if (newValue) {
					newValue._camera = this;
				}
			}
		}]);

		return Camera;
	}();

	var scaleCompensatePosTransform = new Mat4();
	var scaleCompensatePos = new Vec3();
	var scaleCompensateRot = new Quat();
	var scaleCompensateRot2 = new Quat();
	var scaleCompensateScale = new Vec3();
	var scaleCompensateScaleForParent = new Vec3();
	var tmpMat4 = new Mat4();
	var tmpQuat = new Quat();
	var position$1 = new Vec3();
	var invParentWtm$1 = new Mat4();
	var rotation = new Quat();
	var invParentRot = new Quat();
	var matrix = new Mat4();
	var target = new Vec3();
	var up = new Vec3();

	var GraphNode = function (_EventHandler) {
		_inheritsLoose(GraphNode, _EventHandler);

		function GraphNode(name) {
			var _this;

			if (name === void 0) {
				name = 'Untitled';
			}

			_this = _EventHandler.call(this) || this;
			_this.name = name;
			_this.tags = new Tags(_assertThisInitialized(_this));
			_this._labels = {};
			_this.localPosition = new Vec3();
			_this.localRotation = new Quat();
			_this.localScale = new Vec3(1, 1, 1);
			_this.localEulerAngles = new Vec3();
			_this.position = new Vec3();
			_this.rotation = new Quat();
			_this.eulerAngles = new Vec3();
			_this._scale = null;
			_this.localTransform = new Mat4();
			_this._dirtyLocal = false;
			_this._aabbVer = 0;
			_this._frozen = false;
			_this.worldTransform = new Mat4();
			_this._dirtyWorld = false;
			_this.normalMatrix = new Mat3();
			_this._dirtyNormal = true;
			_this._right = null;
			_this._up = null;
			_this._forward = null;
			_this._parent = null;
			_this._children = [];
			_this._graphDepth = 0;
			_this._enabled = true;
			_this._enabledInHierarchy = false;
			_this.scaleCompensation = false;
			return _this;
		}

		var _proto = GraphNode.prototype;

		_proto._notifyHierarchyStateChanged = function _notifyHierarchyStateChanged(node, enabled) {
			node._onHierarchyStateChanged(enabled);

			var c = node._children;

			for (var i = 0, len = c.length; i < len; i++) {
				if (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);
			}
		};

		_proto._onHierarchyStateChanged = function _onHierarchyStateChanged(enabled) {
			this._enabledInHierarchy = enabled;
			if (enabled && !this._frozen) this._unfreezeParentToRoot();
		};

		_proto._cloneInternal = function _cloneInternal(clone) {
			clone.name = this.name;
			var tags = this.tags._list;
			clone.tags.clear();

			for (var i = 0; i < tags.length; i++) {
				clone.tags.add(tags[i]);
			}

			clone._labels = Object.assign({}, this._labels);
			clone.localPosition.copy(this.localPosition);
			clone.localRotation.copy(this.localRotation);
			clone.localScale.copy(this.localScale);
			clone.localEulerAngles.copy(this.localEulerAngles);
			clone.position.copy(this.position);
			clone.rotation.copy(this.rotation);
			clone.eulerAngles.copy(this.eulerAngles);
			clone.localTransform.copy(this.localTransform);
			clone._dirtyLocal = this._dirtyLocal;
			clone.worldTransform.copy(this.worldTransform);
			clone._dirtyWorld = this._dirtyWorld;
			clone._dirtyNormal = this._dirtyNormal;
			clone._aabbVer = this._aabbVer + 1;
			clone._enabled = this._enabled;
			clone.scaleCompensation = this.scaleCompensation;
			clone._enabledInHierarchy = false;
		};

		_proto.clone = function clone() {
			var clone = new GraphNode();

			this._cloneInternal(clone);

			return clone;
		};

		_proto.copy = function copy(source) {
			source._cloneInternal(this);

			return this;
		};

		_proto.find = function find(attr, value) {
			var result,
					results = [];
			var len = this._children.length;

			if (attr instanceof Function) {
				var fn = attr;
				result = fn(this);
				if (result) results.push(this);

				for (var i = 0; i < len; i++) {
					var descendants = this._children[i].find(fn);

					if (descendants.length) results = results.concat(descendants);
				}
			} else {
				var testValue;

				if (this[attr]) {
					if (this[attr] instanceof Function) {
						testValue = this[attr]();
					} else {
						testValue = this[attr];
					}

					if (testValue === value) results.push(this);
				}

				for (var _i = 0; _i < len; ++_i) {
					var _descendants = this._children[_i].find(attr, value);

					if (_descendants.length) results = results.concat(_descendants);
				}
			}

			return results;
		};

		_proto.findOne = function findOne(attr, value) {
			var len = this._children.length;
			var result = null;

			if (attr instanceof Function) {
				var fn = attr;
				result = fn(this);
				if (result) return this;

				for (var i = 0; i < len; i++) {
					result = this._children[i].findOne(fn);
					if (result) return result;
				}
			} else {
				var testValue;

				if (this[attr]) {
					if (this[attr] instanceof Function) {
						testValue = this[attr]();
					} else {
						testValue = this[attr];
					}

					if (testValue === value) {
						return this;
					}
				}

				for (var _i2 = 0; _i2 < len; _i2++) {
					result = this._children[_i2].findOne(attr, value);
					if (result !== null) return result;
				}
			}

			return null;
		};

		_proto.findByTag = function findByTag() {
			var query = arguments;
			var results = [];

			var queryNode = function queryNode(node, checkNode) {
				var _node$tags;

				if (checkNode && (_node$tags = node.tags).has.apply(_node$tags, query)) {
					results.push(node);
				}

				for (var i = 0; i < node._children.length; i++) {
					queryNode(node._children[i], true);
				}
			};

			queryNode(this, false);
			return results;
		};

		_proto.findByName = function findByName(name) {
			if (this.name === name) return this;

			for (var i = 0; i < this._children.length; i++) {
				var found = this._children[i].findByName(name);

				if (found !== null) return found;
			}

			return null;
		};

		_proto.findByPath = function findByPath(path) {
			var parts = Array.isArray(path) ? path : path.split('/');
			var result = this;

			var _loop = function _loop(i, imax) {
				result = result.children.find(function (c) {
					return c.name === parts[i];
				});

				if (!result) {
					return {
						v: null
					};
				}
			};

			for (var i = 0, imax = parts.length; i < imax; ++i) {
				var _ret = _loop(i);

				if (typeof _ret === "object") return _ret.v;
			}

			return result;
		};

		_proto.forEach = function forEach(callback, thisArg) {
			callback.call(thisArg, this);
			var children = this._children;

			for (var i = 0; i < children.length; i++) {
				children[i].forEach(callback, thisArg);
			}
		};

		_proto.isDescendantOf = function isDescendantOf(node) {
			var parent = this._parent;

			while (parent) {
				if (parent === node) return true;
				parent = parent._parent;
			}

			return false;
		};

		_proto.isAncestorOf = function isAncestorOf(node) {
			return node.isDescendantOf(this);
		};

		_proto.getEulerAngles = function getEulerAngles() {
			this.getWorldTransform().getEulerAngles(this.eulerAngles);
			return this.eulerAngles;
		};

		_proto.getLocalEulerAngles = function getLocalEulerAngles() {
			this.localRotation.getEulerAngles(this.localEulerAngles);
			return this.localEulerAngles;
		};

		_proto.getLocalPosition = function getLocalPosition() {
			return this.localPosition;
		};

		_proto.getLocalRotation = function getLocalRotation() {
			return this.localRotation;
		};

		_proto.getLocalScale = function getLocalScale() {
			return this.localScale;
		};

		_proto.getLocalTransform = function getLocalTransform() {
			if (this._dirtyLocal) {
				this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
				this._dirtyLocal = false;
			}

			return this.localTransform;
		};

		_proto.getPosition = function getPosition() {
			this.getWorldTransform().getTranslation(this.position);
			return this.position;
		};

		_proto.getRotation = function getRotation() {
			this.rotation.setFromMat4(this.getWorldTransform());
			return this.rotation;
		};

		_proto.getScale = function getScale() {
			if (!this._scale) {
				this._scale = new Vec3();
			}

			return this.getWorldTransform().getScale(this._scale);
		};

		_proto.getWorldTransform = function getWorldTransform() {
			if (!this._dirtyLocal && !this._dirtyWorld) return this.worldTransform;
			if (this._parent) this._parent.getWorldTransform();

			this._sync();

			return this.worldTransform;
		};

		_proto.reparent = function reparent(parent, index) {
			var current = this._parent;
			if (current) current.removeChild(this);

			if (parent) {
				if (index >= 0) {
					parent.insertChild(this, index);
				} else {
					parent.addChild(this);
				}
			}
		};

		_proto.setLocalEulerAngles = function setLocalEulerAngles(x, y, z) {
			this.localRotation.setFromEulerAngles(x, y, z);
			if (!this._dirtyLocal) this._dirtifyLocal();
		};

		_proto.setLocalPosition = function setLocalPosition(x, y, z) {
			if (x instanceof Vec3) {
				this.localPosition.copy(x);
			} else {
				this.localPosition.set(x, y, z);
			}

			if (!this._dirtyLocal) this._dirtifyLocal();
		};

		_proto.setLocalRotation = function setLocalRotation(x, y, z, w) {
			if (x instanceof Quat) {
				this.localRotation.copy(x);
			} else {
				this.localRotation.set(x, y, z, w);
			}

			if (!this._dirtyLocal) this._dirtifyLocal();
		};

		_proto.setLocalScale = function setLocalScale(x, y, z) {
			if (x instanceof Vec3) {
				this.localScale.copy(x);
			} else {
				this.localScale.set(x, y, z);
			}

			if (!this._dirtyLocal) this._dirtifyLocal();
		};

		_proto._dirtifyLocal = function _dirtifyLocal() {
			if (!this._dirtyLocal) {
				this._dirtyLocal = true;
				if (!this._dirtyWorld) this._dirtifyWorld();
			}
		};

		_proto._unfreezeParentToRoot = function _unfreezeParentToRoot() {
			var p = this._parent;

			while (p) {
				p._frozen = false;
				p = p._parent;
			}
		};

		_proto._dirtifyWorld = function _dirtifyWorld() {
			if (!this._dirtyWorld) this._unfreezeParentToRoot();

			this._dirtifyWorldInternal();
		};

		_proto._dirtifyWorldInternal = function _dirtifyWorldInternal() {
			if (!this._dirtyWorld) {
				this._frozen = false;
				this._dirtyWorld = true;

				for (var i = 0; i < this._children.length; i++) {
					if (!this._children[i]._dirtyWorld) this._children[i]._dirtifyWorldInternal();
				}
			}

			this._dirtyNormal = true;
			this._aabbVer++;
		};

		_proto.setPosition = function setPosition(x, y, z) {
			if (x instanceof Vec3) {
				position$1.copy(x);
			} else {
				position$1.set(x, y, z);
			}

			if (this._parent === null) {
				this.localPosition.copy(position$1);
			} else {
				invParentWtm$1.copy(this._parent.getWorldTransform()).invert();
				invParentWtm$1.transformPoint(position$1, this.localPosition);
			}

			if (!this._dirtyLocal) this._dirtifyLocal();
		};

		_proto.setRotation = function setRotation(x, y, z, w) {
			if (x instanceof Quat) {
				rotation.copy(x);
			} else {
				rotation.set(x, y, z, w);
			}

			if (this._parent === null) {
				this.localRotation.copy(rotation);
			} else {
				var parentRot = this._parent.getRotation();

				invParentRot.copy(parentRot).invert();
				this.localRotation.copy(invParentRot).mul(rotation);
			}

			if (!this._dirtyLocal) this._dirtifyLocal();
		};

		_proto.setEulerAngles = function setEulerAngles(x, y, z) {
			this.localRotation.setFromEulerAngles(x, y, z);

			if (this._parent !== null) {
				var parentRot = this._parent.getRotation();

				invParentRot.copy(parentRot).invert();
				this.localRotation.mul2(invParentRot, this.localRotation);
			}

			if (!this._dirtyLocal) this._dirtifyLocal();
		};

		_proto.addChild = function addChild(node) {
			if (node._parent !== null) throw new Error("GraphNode is already parented");

			this._debugInsertChild(node);

			this._children.push(node);

			this._onInsertChild(node);
		};

		_proto.addChildAndSaveTransform = function addChildAndSaveTransform(node) {
			this._debugInsertChild(node);

			var wPos = node.getPosition();
			var wRot = node.getRotation();
			var current = node._parent;
			if (current) current.removeChild(node);
			node.setPosition(tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));
			node.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));

			this._children.push(node);

			this._onInsertChild(node);
		};

		_proto.insertChild = function insertChild(node, index) {
			if (node._parent !== null) throw new Error("GraphNode is already parented");

			this._debugInsertChild(node);

			this._children.splice(index, 0, node);

			this._onInsertChild(node);
		};

		_proto._debugInsertChild = function _debugInsertChild(node) {
			if (this === node) throw new Error("GraphNode cannot be a child of itself");
			if (this.isDescendantOf(node)) throw new Error("GraphNode cannot add an ancestor as a child");
		};

		_proto._fireOnHierarchy = function _fireOnHierarchy(name, nameHierarchy, parent) {
			this.fire(name, parent);

			for (var i = 0; i < this._children.length; i++) {
				this._children[i]._fireOnHierarchy(nameHierarchy, nameHierarchy, parent);
			}
		};

		_proto._onInsertChild = function _onInsertChild(node) {
			node._parent = this;
			var enabledInHierarchy = node._enabled && this.enabled;

			if (node._enabledInHierarchy !== enabledInHierarchy) {
				node._enabledInHierarchy = enabledInHierarchy;

				node._notifyHierarchyStateChanged(node, enabledInHierarchy);
			}

			node._updateGraphDepth();

			node._dirtifyWorld();

			if (this._frozen) node._unfreezeParentToRoot();

			node._fireOnHierarchy('insert', 'inserthierarchy', this);

			if (this.fire) this.fire('childinsert', node);
		};

		_proto._updateGraphDepth = function _updateGraphDepth() {
			this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;

			for (var i = 0, len = this._children.length; i < len; i++) {
				this._children[i]._updateGraphDepth();
			}
		};

		_proto.removeChild = function removeChild(child) {
			var index = this._children.indexOf(child);

			if (index === -1) {
				return;
			}

			this._children.splice(index, 1);

			child._parent = null;

			child._fireOnHierarchy('remove', 'removehierarchy', this);

			this.fire('childremove', child);
		};

		_proto._sync = function _sync() {
			if (this._dirtyLocal) {
				this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
				this._dirtyLocal = false;
			}

			if (this._dirtyWorld) {
				if (this._parent === null) {
					this.worldTransform.copy(this.localTransform);
				} else {
					if (this.scaleCompensation) {
						var parentWorldScale;
						var parent = this._parent;
						var scale = this.localScale;
						var parentToUseScaleFrom = parent;

						if (parentToUseScaleFrom) {
							while (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {
								parentToUseScaleFrom = parentToUseScaleFrom._parent;
							}

							if (parentToUseScaleFrom) {
								parentToUseScaleFrom = parentToUseScaleFrom._parent;

								if (parentToUseScaleFrom) {
									parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();
									scaleCompensateScale.mul2(parentWorldScale, this.localScale);
									scale = scaleCompensateScale;
								}
							}
						}

						scaleCompensateRot2.setFromMat4(parent.worldTransform);
						scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);
						var tmatrix = parent.worldTransform;

						if (parent.scaleCompensation) {
							scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());
							scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);
							tmatrix = scaleCompensatePosTransform;
						}

						tmatrix.transformPoint(this.localPosition, scaleCompensatePos);
						this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);
					} else {
						this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
					}
				}

				this._dirtyWorld = false;
			}
		};

		_proto.syncHierarchy = function syncHierarchy() {
			if (!this._enabled) return;
			if (this._frozen) return;
			this._frozen = true;

			if (this._dirtyLocal || this._dirtyWorld) {
				this._sync();
			}

			var children = this._children;

			for (var i = 0, len = children.length; i < len; i++) {
				children[i].syncHierarchy();
			}
		};

		_proto.lookAt = function lookAt(x, y, z, ux, uy, uz) {
			if (ux === void 0) {
				ux = 0;
			}

			if (uy === void 0) {
				uy = 1;
			}

			if (uz === void 0) {
				uz = 0;
			}

			if (x instanceof Vec3) {
				target.copy(x);

				if (y instanceof Vec3) {
					up.copy(y);
				} else {
					up.copy(Vec3.UP);
				}
			} else if (z === undefined) {
				return;
			} else {
				target.set(x, y, z);
				up.set(ux, uy, uz);
			}

			matrix.setLookAt(this.getPosition(), target, up);
			rotation.setFromMat4(matrix);
			this.setRotation(rotation);
		};

		_proto.translate = function translate(x, y, z) {
			if (x instanceof Vec3) {
				position$1.copy(x);
			} else {
				position$1.set(x, y, z);
			}

			position$1.add(this.getPosition());
			this.setPosition(position$1);
		};

		_proto.translateLocal = function translateLocal(x, y, z) {
			if (x instanceof Vec3) {
				position$1.copy(x);
			} else {
				position$1.set(x, y, z);
			}

			this.localRotation.transformVector(position$1, position$1);
			this.localPosition.add(position$1);
			if (!this._dirtyLocal) this._dirtifyLocal();
		};

		_proto.rotate = function rotate(x, y, z) {
			rotation.setFromEulerAngles(x, y, z);

			if (this._parent === null) {
				this.localRotation.mul2(rotation, this.localRotation);
			} else {
				var rot = this.getRotation();

				var parentRot = this._parent.getRotation();

				invParentRot.copy(parentRot).invert();
				rotation.mul2(invParentRot, rotation);
				this.localRotation.mul2(rotation, rot);
			}

			if (!this._dirtyLocal) this._dirtifyLocal();
		};

		_proto.rotateLocal = function rotateLocal(x, y, z) {
			rotation.setFromEulerAngles(x, y, z);
			this.localRotation.mul(rotation);
			if (!this._dirtyLocal) this._dirtifyLocal();
		};

		_createClass(GraphNode, [{
			key: "right",
			get: function get() {
				if (!this._right) {
					this._right = new Vec3();
				}

				return this.getWorldTransform().getX(this._right).normalize();
			}
		}, {
			key: "up",
			get: function get() {
				if (!this._up) {
					this._up = new Vec3();
				}

				return this.getWorldTransform().getY(this._up).normalize();
			}
		}, {
			key: "forward",
			get: function get() {
				if (!this._forward) {
					this._forward = new Vec3();
				}

				return this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);
			}
		}, {
			key: "enabled",
			get: function get() {
				return this._enabled && this._enabledInHierarchy;
			},
			set: function set(enabled) {
				if (this._enabled !== enabled) {
					var _this$_parent;

					this._enabled = enabled;

					if (enabled && (_this$_parent = this._parent) != null && _this$_parent.enabled || !enabled) {
						this._notifyHierarchyStateChanged(this, enabled);
					}
				}
			}
		}, {
			key: "parent",
			get: function get() {
				return this._parent;
			}
		}, {
			key: "path",
			get: function get() {
				var node = this._parent;

				if (!node) {
					return '';
				}

				var result = this.name;

				while (node && node._parent) {
					result = node.name + "/" + result;
					node = node._parent;
				}

				return result;
			}
		}, {
			key: "root",
			get: function get() {
				var result = this;

				while (result._parent) {
					result = result._parent;
				}

				return result;
			}
		}, {
			key: "children",
			get: function get() {
				return this._children;
			}
		}, {
			key: "graphDepth",
			get: function get() {
				return this._graphDepth;
			}
		}]);

		return GraphNode;
	}(EventHandler);

	var _viewMat = new Mat4();

	var _viewProjMat = new Mat4();

	var _viewportMatrix = new Mat4();

	var LightCamera = function () {
		function LightCamera() {}

		LightCamera.create = function create(name, lightType, face) {
			var camera = new Camera();
			camera.node = new GraphNode(name);
			camera.aspectRatio = 1;
			camera.aspectRatioMode = ASPECT_MANUAL;
			camera._scissorRectClear = true;

			switch (lightType) {
				case LIGHTTYPE_OMNI:
					camera.node.setRotation(LightCamera.pointLightRotations[face]);
					camera.fov = 90;
					camera.projection = PROJECTION_PERSPECTIVE;
					break;

				case LIGHTTYPE_SPOT:
					camera.projection = PROJECTION_PERSPECTIVE;
					break;

				case LIGHTTYPE_DIRECTIONAL:
					camera.projection = PROJECTION_ORTHOGRAPHIC;
					break;
			}

			return camera;
		};

		LightCamera.evalSpotCookieMatrix = function evalSpotCookieMatrix(light) {
			var cookieCamera = LightCamera._spotCookieCamera;

			if (!cookieCamera) {
				cookieCamera = LightCamera.create("SpotCookieCamera", LIGHTTYPE_SPOT);
				LightCamera._spotCookieCamera = cookieCamera;
			}

			cookieCamera.fov = light._outerConeAngle * 2;
			var cookieNode = cookieCamera._node;
			cookieNode.setPosition(light._node.getPosition());
			cookieNode.setRotation(light._node.getRotation());
			cookieNode.rotateLocal(-90, 0, 0);

			_viewMat.setTRS(cookieNode.getPosition(), cookieNode.getRotation(), Vec3.ONE).invert();

			_viewProjMat.mul2(cookieCamera.projectionMatrix, _viewMat);

			var cookieMatrix = light.cookieMatrix;
			var rectViewport = light.atlasViewport;

			_viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);

			cookieMatrix.mul2(_viewportMatrix, _viewProjMat);
			return cookieMatrix;
		};

		return LightCamera;
	}();

	LightCamera.pointLightRotations = [new Quat().setFromEulerAngles(0, 90, 180), new Quat().setFromEulerAngles(0, -90, 180), new Quat().setFromEulerAngles(90, 0, 0), new Quat().setFromEulerAngles(-90, 0, 0), new Quat().setFromEulerAngles(0, 180, 180), new Quat().setFromEulerAngles(0, 0, 180)];
	LightCamera._spotCookieCamera = null;

	var epsilon$1 = 0.000001;
	var tempVec3$1 = new Vec3();
	var tempAreaLightSizes = new Float32Array(6);
	var areaHalfAxisWidth = new Vec3(-0.5, 0, 0);
	var areaHalfAxisHeight = new Vec3(0, 0, 0.5);
	var TextureIndex8 = {
		FLAGS: 0,
		COLOR_A: 1,
		COLOR_B: 2,
		SPOT_ANGLES: 3,
		SHADOW_BIAS: 4,
		COOKIE_A: 5,
		COOKIE_B: 6,
		COUNT_ALWAYS: 7,
		POSITION_X: 7,
		POSITION_Y: 8,
		POSITION_Z: 9,
		RANGE: 10,
		SPOT_DIRECTION_X: 11,
		SPOT_DIRECTION_Y: 12,
		SPOT_DIRECTION_Z: 13,
		PROJ_MAT_00: 14,
		ATLAS_VIEWPORT_A: 14,
		PROJ_MAT_01: 15,
		ATLAS_VIEWPORT_B: 15,
		PROJ_MAT_02: 16,
		PROJ_MAT_03: 17,
		PROJ_MAT_10: 18,
		PROJ_MAT_11: 19,
		PROJ_MAT_12: 20,
		PROJ_MAT_13: 21,
		PROJ_MAT_20: 22,
		PROJ_MAT_21: 23,
		PROJ_MAT_22: 24,
		PROJ_MAT_23: 25,
		PROJ_MAT_30: 26,
		PROJ_MAT_31: 27,
		PROJ_MAT_32: 28,
		PROJ_MAT_33: 29,
		AREA_DATA_WIDTH_X: 30,
		AREA_DATA_WIDTH_Y: 31,
		AREA_DATA_WIDTH_Z: 32,
		AREA_DATA_HEIGHT_X: 33,
		AREA_DATA_HEIGHT_Y: 34,
		AREA_DATA_HEIGHT_Z: 35,
		COUNT: 36
	};
	var TextureIndexFloat = {
		POSITION_RANGE: 0,
		SPOT_DIRECTION: 1,
		PROJ_MAT_0: 2,
		ATLAS_VIEWPORT: 2,
		PROJ_MAT_1: 3,
		PROJ_MAT_2: 4,
		PROJ_MAT_3: 5,
		AREA_DATA_WIDTH: 6,
		AREA_DATA_HEIGHT: 7,
		COUNT: 8
	};

	var LightsBuffer = function () {
		LightsBuffer.initShaderDefines = function initShaderDefines() {
			var clusterTextureFormat = LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT ? "FLOAT" : "8BIT";
			LightsBuffer.shaderDefines = "\n						\n#define CLUSTER_TEXTURE_" + clusterTextureFormat + "\n						" + LightsBuffer.buildShaderDefines(TextureIndex8, "CLUSTER_TEXTURE_8_") + "\n						" + LightsBuffer.buildShaderDefines(TextureIndexFloat, "CLUSTER_TEXTURE_F_") + "\n				";
		};

		LightsBuffer.buildShaderDefines = function buildShaderDefines(object, prefix) {
			var str = "";
			Object.keys(object).forEach(function (key) {
				str += "\n#define " + prefix + key + " " + object[key] + ".5";
			});
			return str;
		};

		LightsBuffer.init = function init(device) {
			LightsBuffer.lightTextureFormat = device.extTextureFloat && device.maxTextures > 8 ? LightsBuffer.FORMAT_FLOAT : LightsBuffer.FORMAT_8BIT;
			LightsBuffer.initShaderDefines();
		};

		LightsBuffer.createTexture = function createTexture(device, width, height, format, name) {
			var tex = new Texture(device, {
				name: name,
				width: width,
				height: height,
				mipmaps: false,
				format: format,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				type: TEXTURETYPE_DEFAULT,
				magFilter: FILTER_NEAREST,
				minFilter: FILTER_NEAREST,
				anisotropy: 1
			});
			return tex;
		};

		function LightsBuffer(device) {
			this.device = device;
			this.cookiesEnabled = false;
			this.shadowsEnabled = false;
			this.areaLightsEnabled = false;
			this.maxLights = 255;
			var pixelsPerLight8 = TextureIndex8.COUNT_ALWAYS;
			var pixelsPerLightFloat = 0;

			if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
				pixelsPerLightFloat = TextureIndexFloat.COUNT;
			} else {
				pixelsPerLight8 = TextureIndex8.COUNT;
			}

			this.lights8 = new Uint8ClampedArray(4 * pixelsPerLight8 * this.maxLights);
			this.lightsTexture8 = LightsBuffer.createTexture(this.device, pixelsPerLight8, this.maxLights, PIXELFORMAT_R8_G8_B8_A8, "LightsTexture8");
			this._lightsTexture8Id = this.device.scope.resolve("lightsTexture8");

			if (pixelsPerLightFloat) {
				this.lightsFloat = new Float32Array(4 * pixelsPerLightFloat * this.maxLights);
				this.lightsTextureFloat = LightsBuffer.createTexture(this.device, pixelsPerLightFloat, this.maxLights, PIXELFORMAT_RGBA32F, "LightsTextureFloat");
				this._lightsTextureFloatId = this.device.scope.resolve("lightsTextureFloat");
			} else {
				this.lightsFloat = null;
				this.lightsTextureFloat = null;
				this._lightsTextureFloatId = undefined;
			}

			this._lightsTextureInvSizeId = this.device.scope.resolve("lightsTextureInvSize");
			this._lightsTextureInvSizeData = new Float32Array(4);
			this._lightsTextureInvSizeData[0] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.width : 0;
			this._lightsTextureInvSizeData[1] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.height : 0;
			this._lightsTextureInvSizeData[2] = 1.0 / this.lightsTexture8.width;
			this._lightsTextureInvSizeData[3] = 1.0 / this.lightsTexture8.height;
			this.invMaxColorValue = 0;
			this.invMaxAttenuation = 0;
			this.boundsMin = new Vec3();
			this.boundsDelta = new Vec3();
		}

		var _proto = LightsBuffer.prototype;

		_proto.destroy = function destroy() {
			if (this.lightsTexture8) {
				this.lightsTexture8.destroy();
				this.lightsTexture8 = null;
			}

			if (this.lightsTextureFloat) {
				this.lightsTextureFloat.destroy();
				this.lightsTextureFloat = null;
			}
		};

		_proto.setCompressionRanges = function setCompressionRanges(maxAttenuation, maxColorValue) {
			this.invMaxColorValue = 1 / maxColorValue;
			this.invMaxAttenuation = 1 / maxAttenuation;
		};

		_proto.setBounds = function setBounds(min, delta) {
			this.boundsMin.copy(min);
			this.boundsDelta.copy(delta);
		};

		_proto.uploadTextures = function uploadTextures() {
			if (this.lightsTextureFloat) {
				this.lightsTextureFloat.lock().set(this.lightsFloat);
				this.lightsTextureFloat.unlock();
			}

			this.lightsTexture8.lock().set(this.lights8);
			this.lightsTexture8.unlock();
		};

		_proto.updateUniforms = function updateUniforms() {
			this._lightsTexture8Id.setValue(this.lightsTexture8);

			if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
				this._lightsTextureFloatId.setValue(this.lightsTextureFloat);
			}

			this._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData);
		};

		_proto.getSpotDirection = function getSpotDirection(direction, spot) {
			var mat = spot._node.getWorldTransform();

			mat.getY(direction).mulScalar(-1);
			direction.normalize();
		};

		_proto.getLightAreaSizes = function getLightAreaSizes(light) {
			var mat = light._node.getWorldTransform();

			mat.transformVector(areaHalfAxisWidth, tempVec3$1);
			tempAreaLightSizes[0] = tempVec3$1.x;
			tempAreaLightSizes[1] = tempVec3$1.y;
			tempAreaLightSizes[2] = tempVec3$1.z;
			mat.transformVector(areaHalfAxisHeight, tempVec3$1);
			tempAreaLightSizes[3] = tempVec3$1.x;
			tempAreaLightSizes[4] = tempVec3$1.y;
			tempAreaLightSizes[5] = tempVec3$1.z;
			return tempAreaLightSizes;
		};

		_proto.addLightDataFlags = function addLightDataFlags(data8, index, light, isSpot, castShadows) {
			data8[index + 0] = isSpot ? 255 : 0;
			data8[index + 1] = light._shape * 64;
			data8[index + 2] = light._falloffMode * 255;
			data8[index + 3] = castShadows ? 255 : 0;
		};

		_proto.addLightDataColor = function addLightDataColor(data8, index, light, gammaCorrection, isCookie) {
			var invMaxColorValue = this.invMaxColorValue;
			var color = gammaCorrection ? light._linearFinalColor : light._finalColor;
			FloatPacking.float2Bytes(color[0] * invMaxColorValue, data8, index + 0, 2);
			FloatPacking.float2Bytes(color[1] * invMaxColorValue, data8, index + 2, 2);
			FloatPacking.float2Bytes(color[2] * invMaxColorValue, data8, index + 4, 2);
			data8[index + 6] = isCookie ? 255 : 0;
			var isDynamic = !!(light.mask & MASK_AFFECT_DYNAMIC);
			var isLightmapped = !!(light.mask & MASK_AFFECT_LIGHTMAPPED);
			data8[index + 7] = isDynamic && isLightmapped ? 127 : isLightmapped ? 255 : 0;
		};

		_proto.addLightDataSpotAngles = function addLightDataSpotAngles(data8, index, light) {
			FloatPacking.float2Bytes(light._innerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 0, 2);
			FloatPacking.float2Bytes(light._outerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 2, 2);
		};

		_proto.addLightDataShadowBias = function addLightDataShadowBias(data8, index, light) {
			var lightRenderData = light.getRenderData(null, 0);

			var biases = light._getUniformBiasValues(lightRenderData);

			FloatPacking.float2BytesRange(biases.bias, data8, index, -1, 20, 2);
			FloatPacking.float2Bytes(biases.normalBias, data8, index + 2, 2);
		};

		_proto.addLightDataPositionRange = function addLightDataPositionRange(data8, index, light, pos) {
			var normPos = tempVec3$1.sub2(pos, this.boundsMin).div(this.boundsDelta);
			FloatPacking.float2Bytes(normPos.x, data8, index + 0, 4);
			FloatPacking.float2Bytes(normPos.y, data8, index + 4, 4);
			FloatPacking.float2Bytes(normPos.z, data8, index + 8, 4);
			FloatPacking.float2Bytes(light.attenuationEnd * this.invMaxAttenuation, data8, index + 12, 4);
		};

		_proto.addLightDataSpotDirection = function addLightDataSpotDirection(data8, index, light) {
			this.getSpotDirection(tempVec3$1, light);
			FloatPacking.float2Bytes(tempVec3$1.x * (0.5 - epsilon$1) + 0.5, data8, index + 0, 4);
			FloatPacking.float2Bytes(tempVec3$1.y * (0.5 - epsilon$1) + 0.5, data8, index + 4, 4);
			FloatPacking.float2Bytes(tempVec3$1.z * (0.5 - epsilon$1) + 0.5, data8, index + 8, 4);
		};

		_proto.addLightDataLightProjMatrix = function addLightDataLightProjMatrix(data8, index, lightProjectionMatrix) {
			var matData = lightProjectionMatrix.data;

			for (var m = 0; m < 12; m++) {
				FloatPacking.float2BytesRange(matData[m], data8, index + 4 * m, -2, 2, 4);
			}

			for (var _m = 12; _m < 16; _m++) {
				FloatPacking.float2MantissaExponent(matData[_m], data8, index + 4 * _m, 4);
			}
		};

		_proto.addLightDataCookies = function addLightDataCookies(data8, index, light) {
			var isRgb = light._cookieChannel === "rgb";
			data8[index + 0] = Math.floor(light.cookieIntensity * 255);
			data8[index + 1] = isRgb ? 255 : 0;

			if (!isRgb) {
				var channel = light._cookieChannel;
				data8[index + 4] = channel === "rrr" ? 255 : 0;
				data8[index + 5] = channel === "ggg" ? 255 : 0;
				data8[index + 6] = channel === "bbb" ? 255 : 0;
				data8[index + 7] = channel === "aaa" ? 255 : 0;
			}
		};

		_proto.addLightAtlasViewport = function addLightAtlasViewport(data8, index, atlasViewport) {
			FloatPacking.float2Bytes(atlasViewport.x, data8, index + 0, 2);
			FloatPacking.float2Bytes(atlasViewport.y, data8, index + 2, 2);
			FloatPacking.float2Bytes(atlasViewport.z / 3, data8, index + 4, 2);
		};

		_proto.addLightAreaSizes = function addLightAreaSizes(data8, index, light) {
			var areaSizes = this.getLightAreaSizes(light);

			for (var i = 0; i < 6; i++) {
				FloatPacking.float2MantissaExponent(areaSizes[i], data8, index + 4 * i, 4);
			}
		};

		_proto.addLightData = function addLightData(light, lightIndex, gammaCorrection) {
			var isSpot = light._type === LIGHTTYPE_SPOT;
			var hasAtlasViewport = light.atlasViewportAllocated;
			var isCookie = this.cookiesEnabled && !!light._cookie && hasAtlasViewport;
			var isArea = this.areaLightsEnabled && light.shape !== LIGHTSHAPE_PUNCTUAL;
			var castShadows = this.shadowsEnabled && light.castShadows && hasAtlasViewport;

			var pos = light._node.getPosition();

			var lightProjectionMatrix = null;
			var atlasViewport = null;

			if (isSpot) {
				if (castShadows) {
					var lightRenderData = light.getRenderData(null, 0);
					lightProjectionMatrix = lightRenderData.shadowMatrix;
				} else if (isCookie) {
					lightProjectionMatrix = LightCamera.evalSpotCookieMatrix(light);
				}
			} else {
				if (castShadows || isCookie) {
					atlasViewport = light.atlasViewport;
				}
			}

			var data8 = this.lights8;
			var data8Start = lightIndex * this.lightsTexture8.width * 4;
			this.addLightDataFlags(data8, data8Start + 4 * TextureIndex8.FLAGS, light, isSpot, castShadows);
			this.addLightDataColor(data8, data8Start + 4 * TextureIndex8.COLOR_A, light, gammaCorrection, isCookie);

			if (isSpot) {
				this.addLightDataSpotAngles(data8, data8Start + 4 * TextureIndex8.SPOT_ANGLES, light);
			}

			if (light.castShadows) {
				this.addLightDataShadowBias(data8, data8Start + 4 * TextureIndex8.SHADOW_BIAS, light);
			}

			if (isCookie) {
				this.addLightDataCookies(data8, data8Start + 4 * TextureIndex8.COOKIE_A, light);
			}

			if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
				var dataFloat = this.lightsFloat;
				var dataFloatStart = lightIndex * this.lightsTextureFloat.width * 4;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 0] = pos.x;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 1] = pos.y;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 2] = pos.z;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 3] = light.attenuationEnd;

				if (isSpot) {
					this.getSpotDirection(tempVec3$1, light);
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 0] = tempVec3$1.x;
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 1] = tempVec3$1.y;
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 2] = tempVec3$1.z;
				}

				if (lightProjectionMatrix) {
					var matData = lightProjectionMatrix.data;

					for (var m = 0; m < 16; m++) {
						dataFloat[dataFloatStart + 4 * TextureIndexFloat.PROJ_MAT_0 + m] = matData[m];
					}
				}

				if (atlasViewport) {
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 0] = atlasViewport.x;
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 1] = atlasViewport.y;
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 2] = atlasViewport.z / 3;
				}

				if (isArea) {
					var areaSizes = this.getLightAreaSizes(light);
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 0] = areaSizes[0];
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 1] = areaSizes[1];
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 2] = areaSizes[2];
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 0] = areaSizes[3];
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 1] = areaSizes[4];
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 2] = areaSizes[5];
				}
			} else {
				this.addLightDataPositionRange(data8, data8Start + 4 * TextureIndex8.POSITION_X, light, pos);

				if (isSpot) {
					this.addLightDataSpotDirection(data8, data8Start + 4 * TextureIndex8.SPOT_DIRECTION_X, light);
				}

				if (lightProjectionMatrix) {
					this.addLightDataLightProjMatrix(data8, data8Start + 4 * TextureIndex8.PROJ_MAT_00, lightProjectionMatrix);
				}

				if (atlasViewport) {
					this.addLightAtlasViewport(data8, data8Start + 4 * TextureIndex8.ATLAS_VIEWPORT_A, atlasViewport);
				}

				if (isArea) {
					this.addLightAreaSizes(data8, data8Start + 4 * TextureIndex8.AREA_DATA_WIDTH_X, light);
				}
			}
		};

		return LightsBuffer;
	}();

	LightsBuffer.FORMAT_FLOAT = 0;
	LightsBuffer.FORMAT_8BIT = 1;
	LightsBuffer.lightTextureFormat = LightsBuffer.FORMAT_8BIT;
	LightsBuffer.shaderDefines = "";

	var _matTex2D = [];
	var decodeTable = {
		'rgbm': 'decodeRGBM',
		'rgbe': 'decodeRGBE',
		'linear': 'decodeLinear'
	};
	var standard = {
		optionsContext: {},
		optionsContextMin: {},
		generateKey: function generateKey(options) {
			var buildPropertiesList = function buildPropertiesList(options) {
				var props = [];

				for (var prop in options) {
					if (options.hasOwnProperty(prop) && prop !== "chunks" && prop !== "lights") props.push(prop);
				}

				return props.sort();
			};

			var props;

			if (options === this.optionsContextMin) {
				if (!this.propsMin) this.propsMin = buildPropertiesList(options);
				props = this.propsMin;
			} else if (options === this.optionsContext) {
				if (!this.props) this.props = buildPropertiesList(options);
				props = this.props;
			} else {
				props = buildPropertiesList(options);
			}

			var key = "standard";

			for (var i = 0; i < props.length; i++) {
				if (options[props[i]]) key += props[i] + options[props[i]];
			}

			if (options.chunks) {
				var chunks = [];

				for (var p in options.chunks) {
					if (options.chunks.hasOwnProperty(p)) {
						chunks.push(p + options.chunks[p]);
					}
				}

				chunks.sort();
				key += chunks;
			}

			if (options.lights) {
				var isClustered = options.clusteredLightingEnabled;

				for (var _i = 0; _i < options.lights.length; _i++) {
					var light = options.lights[_i];

					if (!isClustered || light._type === LIGHTTYPE_DIRECTIONAL) {
						key += light.key;
					}
				}
			}

			return hashCode(key);
		},
		_correctChannel: function _correctChannel(p, chan) {
			if (_matTex2D[p] > 0) {
				if (_matTex2D[p] < chan.length) {
					return chan.substring(0, _matTex2D[p]);
				} else if (_matTex2D[p] > chan.length) {
					var str = chan;
					var chr = str.charAt(str.length - 1);
					var addLen = _matTex2D[p] - str.length;

					for (var i = 0; i < addLen; i++) {
						str += chr;
					}

					return str;
				}

				return chan;
			}
		},
		_setMapTransform: function _setMapTransform(codes, name, id, uv) {
			var varName = "texture_" + name + "MapTransform";
			var checkId = id + uv * 100;
			codes[0] += "uniform vec3 " + varName + "0;\n";
			codes[0] += "uniform vec3 " + varName + "1;\n";

			if (!codes[3][checkId]) {
				codes[1] += "varying vec2 vUV" + uv + "_" + id + ";\n";
				codes[2] += "	 vUV" + uv + "_" + id + " = vec2(dot(vec3(uv" + uv + ", 1), " + varName + "0), dot(vec3(uv" + uv + ", 1), " + varName + "1));\n";
				codes[3][checkId] = true;
			}

			return codes;
		},
		_getUvSourceExpression: function _getUvSourceExpression(transformPropName, uVPropName, options) {
			var transformId = options[transformPropName];
			var uvChannel = options[uVPropName];
			var isMainPass = options.pass === SHADER_FORWARD || options.pass === SHADER_FORWARDHDR;
			var expression;

			if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
				expression = "nineSlicedUv";
			} else if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				expression = "nineSlicedUv";
			} else {
				if (transformId === 0) {
					expression = "vUv" + uvChannel;
				} else {
					expression = "vUV" + uvChannel + "_" + transformId;
				}

				if (options.heightMap && transformPropName !== "heightMapTransform") {
					expression += " + dUvOffset";
				}
			}

			return expression;
		},
		_addMapDef: function _addMapDef(name, enabled) {
			var s = "\n#undef " + name + "\n";
			if (enabled) s += " #define " + name + "\n";
			return s;
		},
		_addMapDefs: function _addMapDefs(float, color, vertex, map) {
			var s = "";
			s += this._addMapDef("MAPFLOAT", float);
			s += this._addMapDef("MAPCOLOR", color);
			s += this._addMapDef("MAPVERTEX", vertex);
			s += this._addMapDef("MAPTEXTURE", map);
			return s;
		},
		_addMap: function _addMap(propName, chunkName, options, chunks, samplerFormat) {
			var mapPropName = propName + "Map";
			var uVPropName = mapPropName + "Uv";
			var transformPropName = mapPropName + "Transform";
			var channelPropName = mapPropName + "Channel";
			var vertexColorChannelPropName = propName + "VertexColorChannel";
			var tintPropName = propName + "Tint";
			var vertexColorPropName = propName + "VertexColor";
			var detailModePropName = propName + "Mode";
			var tintOption = options[tintPropName];
			var vertexColorOption = options[vertexColorPropName];
			var textureOption = options[mapPropName];
			var detailModeOption = options[detailModePropName];
			var subCode = chunks[chunkName];

			if (textureOption) {
				var uv = this._getUvSourceExpression(transformPropName, uVPropName, options);

				subCode = subCode.replace(/\$UV/g, uv).replace(/\$CH/g, options[channelPropName]);

				if (samplerFormat !== undefined) {
					var fmt = samplerFormat === 0 ? "texture2DSRGB" : samplerFormat === 1 ? "texture2DRGBM" : "texture2D";
					subCode = subCode.replace(/\$texture2DSAMPLE/g, fmt);
				}
			}

			if (vertexColorOption) {
				subCode = subCode.replace(/\$VC/g, options[vertexColorChannelPropName]);
			}

			if (detailModeOption) {
				subCode = subCode.replace(/\$DETAILMODE/g, detailModeOption);
			}

			var isFloatTint = !!(tintOption & 1);
			var isVecTint = !!(tintOption & 2);
			subCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption) + subCode;
			return subCode.replace(/\$/g, "");
		},
		_directionalShadowMapProjection: function _directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, coordsFunctionName) {
			var code = "";

			if (light.numCascades > 1) {
				code += "getShadowCascadeMatrix(light" + lightIndex + "_shadowMatrixPalette, light" + lightIndex + "_shadowCascadeDistances, light" + lightIndex + "_shadowCascadeCount);\n";
				shadowCoordArgs = "(cascadeShadowMat, " + shadowParamArg + ");\n";
			}

			code += coordsFunctionName + shadowCoordArgs;
			code += "fadeShadow(light" + lightIndex + "_shadowCascadeDistances);\n";
			return code;
		},
		_nonPointShadowMapProjection: function _nonPointShadowMapProjection(device, light, shadowMatArg, shadowParamArg, lightIndex) {
			var shadowCoordArgs = "(" + shadowMatArg + ", " + shadowParamArg + ");\n";

			if (!light._normalOffsetBias || light._isVsm) {
				if (light._type === LIGHTTYPE_SPOT) {
					if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
						return "			 getShadowCoordPerspZbuffer" + shadowCoordArgs;
					}

					return "			 getShadowCoordPersp" + shadowCoordArgs;
				}

				return this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, "getShadowCoordOrtho");
			}

			if (light._type === LIGHTTYPE_SPOT) {
				if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
					return "			 getShadowCoordPerspZbufferNormalOffset" + shadowCoordArgs;
				}

				return "			 getShadowCoordPerspNormalOffset" + shadowCoordArgs;
			}

			return this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, "getShadowCoordOrthoNormalOffset");
		},
		_addVaryingIfNeeded: function _addVaryingIfNeeded(code, type, name) {
			return code.indexOf(name) >= 0 ? "varying " + type + " " + name + ";\n" : "";
		},
		_getLightSourceShapeString: function _getLightSourceShapeString(shape) {
			switch (shape) {
				case LIGHTSHAPE_RECT:
					return 'Rect';

				case LIGHTSHAPE_DISK:
					return 'Disk';

				case LIGHTSHAPE_SPHERE:
					return 'Sphere';

				default:
					return '';
			}
		},
		_getPassDefineString: function _getPassDefineString(pass) {
			if (pass === SHADER_PICK) {
				return '#define PICK_PASS\n';
			} else if (pass === SHADER_DEPTH) {
				return '#define DEPTH_PASS\n';
			} else if (pass >= SHADER_SHADOW && pass <= 17) {
				return '#define SHADOW_PASS\n';
			}

			return '';
		},
		_vsAddTransformCode: function _vsAddTransformCode(code, device, chunks, options) {
			code += chunks.transformVS;
			return code;
		},
		_vsAddBaseCode: function _vsAddBaseCode(code, device, chunks, options) {
			code += chunks.baseVS;

			if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				code += chunks.baseNineSlicedVS;
			}

			return code;
		},
		_fsAddBaseCode: function _fsAddBaseCode(code, device, chunks, options) {
			code += chunks.basePS;

			if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
				code += chunks.baseNineSlicedPS;
			} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				code += chunks.baseNineSlicedTiledPS;
			}

			if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				code += "const float textureBias = -1000.0;\n";
			} else {
				code += "uniform float textureBias;\n";
			}

			return code;
		},
		_decodeFunc: function _decodeFunc(textureFormat) {
			return decodeTable[textureFormat] || 'decodeGamma';
		},
		_fsAddStartCode: function _fsAddStartCode(code, device, chunks, options) {
			code += chunks.startPS;

			if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
				code += chunks.startNineSlicedPS;
			} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				code += chunks.startNineSlicedTiledPS;
			}

			return code;
		},
		_buildShadowPassFragmentCode: function _buildShadowPassFragmentCode(code, device, chunks, options, varyings) {
			var smode = options.pass - SHADER_SHADOW;
			var numShadowModes = SHADOW_COUNT;
			var lightType = Math.floor(smode / numShadowModes);
			var shadowType = smode - lightType * numShadowModes;

			if (device.extStandardDerivatives && !device.webgl2) {
				code += 'uniform vec2 polygonOffset;\n';
			}

			if (shadowType === SHADOW_VSM32) {
				if (device.textureFloatHighPrecision) {
					code += '#define VSM_EXPONENT 15.0\n\n';
				} else {
					code += '#define VSM_EXPONENT 5.54\n\n';
				}
			} else if (shadowType === SHADOW_VSM16) {
				code += '#define VSM_EXPONENT 5.54\n\n';
			}

			if (lightType !== LIGHTTYPE_DIRECTIONAL) {
				code += 'uniform vec3 view_position;\n';
				code += 'uniform float light_radius;\n';
			}

			code += varyings;

			if (options.alphaTest) {
				code += "uniform float textureBias;";
				code += "float dAlpha;\n";
				code += this._addMap("opacity", "opacityPS", options, chunks);
				code += chunks.alphaTestPS;
			}

			if (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_OMNI)) {
				code += chunks.packDepthPS;
			} else if (shadowType === SHADOW_VSM8) {
				code += "vec2 encodeFloatRG( float v ) {\n";
				code += "		vec2 enc = vec2(1.0, 255.0) * v;\n";
				code += "		enc = fract(enc);\n";
				code += "		enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n";
				code += "		return enc;\n";
				code += "}\n\n";
			}

			code += begin();

			if (options.alphaTest) {
				code += "	 getOpacity();\n";
				code += "	 alphaTest(dAlpha);\n";
			}

			var isVsm = shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32;

			if (lightType === LIGHTTYPE_OMNI || isVsm && lightType !== LIGHTTYPE_DIRECTIONAL) {
				code += "	 float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n";
			} else {
				code += "	 float depth = gl_FragCoord.z;\n";
			}

			if (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_OMNI && !options.clusteredLightingEnabled)) {
				if (device.extStandardDerivatives && !device.webgl2) {
					code += "	 float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n";
					code += "	 depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n";
					code += "	 gl_FragColor = packFloat(depth);\n";
				} else {
					code += "	 gl_FragColor = packFloat(depth);\n";
				}
			} else if (shadowType === SHADOW_PCF3 || shadowType === SHADOW_PCF5) {
				code += "	 gl_FragColor = vec4(1.0);\n";

				if (options.clusteredLightingEnabled && lightType === LIGHTTYPE_OMNI && device.webgl2) {
					code += "	 gl_FragDepth = depth;\n";
				}
			} else if (shadowType === SHADOW_VSM8) {
				code += "	 gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n";
			} else {
				code += chunks.storeEVSMPS;
			}

			code += end();
			return code;
		},
		createShaderDefinition: function createShaderDefinition(device, options) {
			var lighting = options.lights.length > 0;

			if (options.dirLightMap) {
				lighting = true;
			}

			if (options.clusteredLightingEnabled) {
				lighting = true;
			}

			if (options.shadingModel === SPECULAR_PHONG) {
				options.fresnelModel = 0;
				options.specularAntialias = false;
				options.ambientSH = false;
			} else {
				options.fresnelModel = options.fresnelModel === 0 ? FRESNEL_SCHLICK : options.fresnelModel;
			}

			var reflections = !!options.reflectionSource;
			if (!options.useSpecular) options.specularMap = options.glossMap = null;
			var shadowPass = options.pass >= SHADER_SHADOW && options.pass <= 17;
			var needsNormal = lighting || reflections || options.ambientSH || options.heightMap || options.enableGGXSpecular || options.clusteredLightingEnabled && !shadowPass || options.clearCoatNormalMap;
			this.options = options;
			var code = '';
			var codeBody = '';
			var varyings = "";
			var chunks = shaderChunks;
			var shadowCoordArgs;
			var chunk;
			var attributes = {
				vertex_position: SEMANTIC_POSITION
			};

			if (options.chunks) {
				var customChunks = {};

				for (var p in chunks) {
					if (chunks.hasOwnProperty(p)) {
						if (!options.chunks[p]) {
							customChunks[p] = chunks[p];
						} else {
							chunk = options.chunks[p];

							if (chunk.indexOf("vertex_normal") >= 0) {
								attributes.vertex_normal = SEMANTIC_NORMAL;
							}

							if (chunk.indexOf("vertex_tangent") >= 0) {
								attributes.vertex_tangent = SEMANTIC_TANGENT;
							}

							if (chunk.indexOf("vertex_texCoord0") >= 0) {
								attributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;
							}

							if (chunk.indexOf("vertex_texCoord1") >= 0) {
								attributes.vertex_texCoord1 = SEMANTIC_TEXCOORD1;
							}

							if (chunk.indexOf("vertex_color") >= 0) {
								attributes.vertex_color = SEMANTIC_COLOR;
							}

							if (chunk.indexOf("vertex_boneWeights") >= 0) {
								attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
							}

							if (chunk.indexOf("vertex_boneIndices") >= 0) {
								attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
							}

							customChunks[p] = chunk;
						}
					}
				}

				chunks = customChunks;
			}

			code += this._getPassDefineString(options.pass);
			code = this._vsAddBaseCode(code, device, chunks, options);
			codeBody += "	 vPositionW		= getWorldPosition();\n";

			if (options.pass === SHADER_DEPTH) {
				code += 'varying float vDepth;\n';
				code += '#ifndef VIEWMATRIX\n';
				code += '#define VIEWMATRIX\n';
				code += 'uniform mat4 matrix_view;\n';
				code += '#endif\n';
				code += '#ifndef CAMERAPLANES\n';
				code += '#define CAMERAPLANES\n';
				code += 'uniform vec4 camera_params;\n\n';
				code += '#endif\n';
				codeBody += "		vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n";
			}

			if (options.useInstancing) {
				attributes.instance_line1 = SEMANTIC_ATTR12;
				attributes.instance_line2 = SEMANTIC_ATTR13;
				attributes.instance_line3 = SEMANTIC_ATTR14;
				attributes.instance_line4 = SEMANTIC_ATTR15;
				code += chunks.instancingVS;
			}

			if (needsNormal) {
				attributes.vertex_normal = SEMANTIC_NORMAL;
				codeBody += "	 vNormalW = getNormal();\n";

				if (options.reflectionSource === 'sphereMap' && device.fragmentUniformsCount <= 16) {
					code += chunks.viewNormalVS;
					codeBody += "	 vNormalV		= getViewNormal();\n";
				}

				if ((options.heightMap || options.normalMap || options.enableGGXSpecular) && options.hasTangents) {
					attributes.vertex_tangent = SEMANTIC_TANGENT;
					code += chunks.tangentBinormalVS;
					codeBody += "	 vTangentW	 = getTangent();\n";
					codeBody += "	 vBinormalW	= getBinormal();\n";
				} else if (options.enableGGXSpecular) {
					code += chunks.tangentBinormalVS;
					codeBody += "	 vObjectSpaceUpW	= getObjectSpaceUp();\n";
				}
			}

			var useUv = [];
			var useUnmodifiedUv = [];
			var maxUvSets = 2;

			for (var _p in _matTex2D) {
				var mname = _p + "Map";

				if (options[_p + "VertexColor"]) {
					var cname = _p + "VertexColorChannel";
					options[cname] = this._correctChannel(_p, options[cname]);
				}

				if (options[mname]) {
					var _cname = mname + "Channel";

					var tname = mname + "Transform";
					var uname = mname + "Uv";
					options[uname] = Math.min(options[uname], maxUvSets - 1);
					options[_cname] = this._correctChannel(_p, options[_cname]);
					var uvSet = options[uname];
					useUv[uvSet] = true;
					useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mname] && !options[tname];
				}
			}

			if (options.forceUv1) {
				useUv[1] = true;
				useUnmodifiedUv[1] = useUnmodifiedUv[1] !== undefined ? useUnmodifiedUv[1] : true;
			}

			for (var i = 0; i < maxUvSets; i++) {
				if (useUv[i]) {
					attributes["vertex_texCoord" + i] = "TEXCOORD" + i;
					code += chunks["uv" + i + "VS"];
					codeBody += "	 vec2 uv" + i + " = getUv" + i + "();\n";
				}

				if (useUnmodifiedUv[i]) {
					codeBody += "	 vUv" + i + " = uv" + i + ";\n";
				}
			}

			var codes = [code, varyings, codeBody, []];

			for (var _p2 in _matTex2D) {
				var _mname = _p2 + "Map";

				if (options[_mname]) {
					var _tname = _mname + "Transform";

					if (options[_tname]) {
						var _uname = _mname + "Uv";

						this._setMapTransform(codes, _p2, options[_tname], options[_uname]);
					}
				}
			}

			code = codes[0];
			varyings = codes[1];
			codeBody = codes[2];

			if (options.vertexColors) {
				attributes.vertex_color = SEMANTIC_COLOR;
				codeBody += "	 vVertexColor = vertex_color;\n";
			}

			if (options.useMorphPosition || options.useMorphNormal) {
				if (options.useMorphTextureBased) {
					code += "#define MORPHING_TEXTURE_BASED\n";

					if (options.useMorphPosition) {
						code += "#define MORPHING_TEXTURE_BASED_POSITION\n";
					}

					if (options.useMorphNormal) {
						code += "#define MORPHING_TEXTURE_BASED_NORMAL\n";
					}

					attributes.morph_vertex_id = SEMANTIC_ATTR15;
					code += "attribute float morph_vertex_id;\n";
				} else {
					code += "#define MORPHING\n";

					if (options.useMorphPosition) {
						attributes.morph_pos0 = SEMANTIC_ATTR8;
						attributes.morph_pos1 = SEMANTIC_ATTR9;
						attributes.morph_pos2 = SEMANTIC_ATTR10;
						attributes.morph_pos3 = SEMANTIC_ATTR11;
						code += "#define MORPHING_POS03\n";
						code += "attribute vec3 morph_pos0;\n";
						code += "attribute vec3 morph_pos1;\n";
						code += "attribute vec3 morph_pos2;\n";
						code += "attribute vec3 morph_pos3;\n";
					} else if (options.useMorphNormal) {
						attributes.morph_nrm0 = SEMANTIC_ATTR8;
						attributes.morph_nrm1 = SEMANTIC_ATTR9;
						attributes.morph_nrm2 = SEMANTIC_ATTR10;
						attributes.morph_nrm3 = SEMANTIC_ATTR11;
						code += "#define MORPHING_NRM03\n";
						code += "attribute vec3 morph_nrm0;\n";
						code += "attribute vec3 morph_nrm1;\n";
						code += "attribute vec3 morph_nrm2;\n";
						code += "attribute vec3 morph_nrm3;\n";
					}

					if (!options.useMorphNormal) {
						attributes.morph_pos4 = SEMANTIC_ATTR12;
						attributes.morph_pos5 = SEMANTIC_ATTR13;
						attributes.morph_pos6 = SEMANTIC_ATTR14;
						attributes.morph_pos7 = SEMANTIC_ATTR15;
						code += "#define MORPHING_POS47\n";
						code += "attribute vec3 morph_pos4;\n";
						code += "attribute vec3 morph_pos5;\n";
						code += "attribute vec3 morph_pos6;\n";
						code += "attribute vec3 morph_pos7;\n";
					} else {
						attributes.morph_nrm4 = SEMANTIC_ATTR12;
						attributes.morph_nrm5 = SEMANTIC_ATTR13;
						attributes.morph_nrm6 = SEMANTIC_ATTR14;
						attributes.morph_nrm7 = SEMANTIC_ATTR15;
						code += "#define MORPHING_NRM47\n";
						code += "attribute vec3 morph_nrm4;\n";
						code += "attribute vec3 morph_nrm5;\n";
						code += "attribute vec3 morph_nrm6;\n";
						code += "attribute vec3 morph_nrm7;\n";
					}
				}
			}

			if (options.skin) {
				attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
				attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
				code += skinCode(device, chunks);
				code += "#define SKIN\n";
			} else if (options.useInstancing) {
				code += "#define INSTANCING\n";
			}

			if (options.screenSpace) {
				code += "#define SCREENSPACE\n";
			}

			if (options.pixelSnap) {
				code += "#define PIXELSNAP\n";
			}

			code = this._vsAddTransformCode(code, device, chunks, options);
			if (needsNormal) code += chunks.normalVS;
			code += "\n";
			code += chunks.startVS;
			code += codeBody;
			code += chunks.endVS;
			code += "}";
			var vshader = code;
			var oldVars = varyings;
			varyings = "";
			varyings += this._addVaryingIfNeeded(code, "vec4", "vVertexColor");
			varyings += this._addVaryingIfNeeded(code, "vec3", "vPositionW");
			varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalV");
			varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalW");
			varyings += this._addVaryingIfNeeded(code, "vec3", "vTangentW");
			varyings += this._addVaryingIfNeeded(code, "vec3", "vBinormalW");
			varyings += this._addVaryingIfNeeded(code, "vec3", "vObjectSpaceUpW");
			varyings += this._addVaryingIfNeeded(code, "vec2", "vUv0");
			varyings += this._addVaryingIfNeeded(code, "vec2", "vUv1");
			varyings += oldVars;
			vshader = varyings + vshader;
			var startCode = "";

			if (device.webgl2) {
				startCode = versionCode(device);

				if (chunks.extensionVS) {
					startCode += chunks.extensionVS + "\n";
				}

				vshader = startCode + chunks.gles3VS + vshader;
			} else {
				if (chunks.extensionVS) {
					startCode = chunks.extensionVS + "\n";
				}

				vshader = startCode + vshader;
			}

			if (options.forceFragmentPrecision && options.forceFragmentPrecision !== "highp" && options.forceFragmentPrecision !== "mediump" && options.forceFragmentPrecision !== "lowp") options.forceFragmentPrecision = null;

			if (options.forceFragmentPrecision) {
				if (options.forceFragmentPrecision === "highp" && device.maxPrecision !== "highp") options.forceFragmentPrecision = "mediump";
				if (options.forceFragmentPrecision === "mediump" && device.maxPrecision === "lowp") options.forceFragmentPrecision = "lowp";
			}

			var fshader;
			code = '';

			if (device.webgl2) {
				code += versionCode(device);
			}

			if (!device.webgl2) {
				if (device.extStandardDerivatives) {
					code += "#extension GL_OES_standard_derivatives : enable\n";
				}

				if (device.extTextureLod) {
					code += "#extension GL_EXT_shader_texture_lod : enable\n";
					code += "#define SUPPORTS_TEXLOD\n";
				}
			}

			if (chunks.extensionPS) {
				code += chunks.extensionPS + "\n";
			}

			if (device.webgl2) {
				code += chunks.gles3PS;
			}

			code += options.forceFragmentPrecision ? "precision " + options.forceFragmentPrecision + " float;\n\n" : precisionCode(device);
			code += this._getPassDefineString(options.pass);

			if (options.pass === SHADER_PICK) {
				code += "uniform vec4 uColor;\n";
				code += varyings;

				if (options.alphaTest) {
					code += "uniform float textureBias;";
					code += "float dAlpha;\n";
					code += this._addMap("opacity", "opacityPS", options, chunks);
					code += chunks.alphaTestPS;
				}

				code += begin();

				if (options.alphaTest) {
					code += "	 getOpacity();\n";
					code += "	 alphaTest(dAlpha);\n";
				}

				code += "		gl_FragColor = uColor;\n";
				code += end();
				return {
					attributes: attributes,
					vshader: vshader,
					fshader: code
				};
			} else if (options.pass === SHADER_DEPTH) {
				code += 'varying float vDepth;\n';
				code += varyings;
				code += chunks.packDepthPS;

				if (options.alphaTest) {
					code += "uniform float textureBias;";
					code += "float dAlpha;\n";
					code += this._addMap("opacity", "opacityPS", options, chunks);
					code += chunks.alphaTestPS;
				}

				code += begin();

				if (options.alphaTest) {
					code += "	 getOpacity();\n";
					code += "	 alphaTest(dAlpha);\n";
				}

				code += "		gl_FragColor = packFloat(vDepth);\n";
				code += end();
				return {
					attributes: attributes,
					vshader: vshader,
					fshader: code
				};
			} else if (shadowPass) {
				return {
					attributes: attributes,
					vshader: vshader,
					fshader: this._buildShadowPassFragmentCode(code, device, chunks, options, varyings)
				};
			}

			if (options.customFragmentShader) {
				fshader = code + options.customFragmentShader;
				return {
					attributes: attributes,
					vshader: vshader,
					fshader: fshader,
					tag: SHADERTAG_MATERIAL
				};
			}

			code += varyings;
			code = this._fsAddBaseCode(code, device, chunks, options);

			if (options.detailModes) {
				code += chunks.detailModesPS;
			}

			var codeBegin = code;
			code = "";

			if (options.clearCoat > 0) {
				code += '#define CLEARCOAT\n';
				code += "#define CLUSTER_CLEAR_COAT\n";
			}

			if (options.opacityFadesSpecular === false) {
				code += 'uniform float material_alphaFade;\n';
			}

			var numShadowLights = 0;
			var shadowTypeUsed = [];
			var shadowedDirectionalLightUsed = false;
			var useVsm = false;
			var usePerspZbufferShadow = false;
			var hasAreaLights = options.lights.some(function (light) {
				return light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;
			});

			if (options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled) {
				hasAreaLights = true;
			}

			if (device.areaLightLutFormat === PIXELFORMAT_R8_G8_B8_A8) {
				code += "#define AREA_R8_G8_B8_A8_LUTS\n";
				code += "#define AREA_LUTS_PRECISION lowp\n";
			} else {
				code += "#define AREA_LUTS_PRECISION highp\n";
			}

			if (hasAreaLights || options.clusteredLightingEnabled) {
				code += "#define AREA_LIGHTS\n";
				code += "uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex1;\n";
				code += "uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex2;\n";
			}

			for (var _i2 = 0; _i2 < options.lights.length; _i2++) {
				var light = options.lights[_i2];
				var lightType = light._type;
				if (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) continue;
				var lightShape = hasAreaLights && light._shape ? light._shape : LIGHTSHAPE_PUNCTUAL;
				code += "uniform vec3 light" + _i2 + "_color;\n";

				if (lightType === LIGHTTYPE_DIRECTIONAL) {
					code += "uniform vec3 light" + _i2 + "_direction;\n";
				} else {
					code += "uniform vec3 light" + _i2 + "_position;\n";
					code += "uniform float light" + _i2 + "_radius;\n";

					if (lightType === LIGHTTYPE_SPOT) {
						code += "uniform vec3 light" + _i2 + "_direction;\n";
						code += "uniform float light" + _i2 + "_innerConeAngle;\n";
						code += "uniform float light" + _i2 + "_outerConeAngle;\n";
					}
				}

				if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
					if (lightType === LIGHTTYPE_DIRECTIONAL) {
						code += "uniform vec3 light" + _i2 + "_position;\n";
					}

					code += "uniform vec3 light" + _i2 + "_halfWidth;\n";
					code += "uniform vec3 light" + _i2 + "_halfHeight;\n";
				}

				if (light.castShadows && !options.noShadow) {
					code += "uniform mat4 light" + _i2 + "_shadowMatrix;\n";

					if (lightType === LIGHTTYPE_DIRECTIONAL) {
						code += "uniform mat4 light" + _i2 + "_shadowMatrixPalette[4];\n";
						code += "uniform float light" + _i2 + "_shadowCascadeDistances[4];\n";
						code += "uniform float light" + _i2 + "_shadowCascadeCount;\n";
					}

					if (lightType !== LIGHTTYPE_DIRECTIONAL) {
						code += "uniform vec4 light" + _i2 + "_shadowParams;\n";
					} else {
						shadowedDirectionalLightUsed = true;
						code += "uniform vec3 light" + _i2 + "_shadowParams;\n";
					}

					if (lightType === LIGHTTYPE_OMNI) {
						code += "uniform samplerCube light" + _i2 + "_shadowMap;\n";
					} else {
						if (light._isPcf && device.webgl2) {
							code += "uniform sampler2DShadow light" + _i2 + "_shadowMap;\n";
						} else {
							code += "uniform sampler2D light" + _i2 + "_shadowMap;\n";
						}
					}

					numShadowLights++;
					shadowTypeUsed[light._shadowType] = true;
					if (light._isVsm) useVsm = true;
					if (light._isPcf && (device.webgl2 || device.extStandardDerivatives) && lightType === LIGHTTYPE_SPOT) usePerspZbufferShadow = true;
				}

				if (light._cookie) {
					if (light._cookie._cubemap) {
						if (lightType === LIGHTTYPE_OMNI) {
							code += "uniform samplerCube light" + _i2 + "_cookie;\n";
							code += "uniform float light" + _i2 + "_cookieIntensity;\n";
							if (!light.castShadows || options.noShadow) code += "uniform mat4 light" + _i2 + "_shadowMatrix;\n";
						}
					} else {
						if (lightType === LIGHTTYPE_SPOT) {
							code += "uniform sampler2D light" + _i2 + "_cookie;\n";
							code += "uniform float light" + _i2 + "_cookieIntensity;\n";
							if (!light.castShadows || options.noShadow) code += "uniform mat4 light" + _i2 + "_shadowMatrix;\n";

							if (light._cookieTransform) {
								code += "uniform vec4 light" + _i2 + "_cookieMatrix;\n";
								code += "uniform vec2 light" + _i2 + "_cookieOffset;\n";
							}
						}
					}
				}
			}

			code += "\n";
			var tbn;

			if (!options.hasTangents && device.extStandardDerivatives) {
				tbn = chunks.TBNderivativePS;
			} else if (options.fastTbn) {
				tbn = chunks.TBNfastPS;
			} else {
				tbn = chunks.TBNPS;
			}

			if (needsNormal) {
				if (options.normalMap || options.clearCoatNormalMap) {
					code += options.packedNormal ? chunks.normalXYPS : chunks.normalXYZPS;

					if (!options.hasTangents) {
						var baseName = options.normalMap ? "normalMap" : "clearCoatNormalMap";

						var uv = this._getUvSourceExpression(baseName + "Transform", baseName + "Uv", options);

						tbn = tbn.replace(/\$UV/g, uv);
					}

					code += tbn;
				} else if (options.enableGGXSpecular && !options.heightMap) {
					code += chunks.normalVertexPS;
					code += chunks.TBNObjectSpacePS;
				}
			}

			if (needsNormal) {
				if (options.normalMap) {
					if (options.normalDetail) {
						code += this._addMap("normalDetail", "normalDetailMapPS", options, chunks);
					}

					var transformedNormalMapUv = this._getUvSourceExpression("normalMapTransform", "normalMapUv", options);

					if (options.normalizeNormalMap) {
						code += chunks.normalMapPS.replace(/\$UV/g, transformedNormalMapUv);
					} else {
						code += chunks.normalMapFastPS.replace(/\$UV/g, transformedNormalMapUv);
					}
				} else if (!(options.enableGGXSpecular && !options.heightMap)) {
					code += chunks.normalVertexPS;
				}
			}

			code += gammaCode(options.gamma, chunks);
			code += tonemapCode(options.toneMap, chunks);
			code += fogCode(options.fog, chunks);
			code += chunks.decodePS;
			if (options.useRgbm) code += chunks.rgbmPS;

			if (options.useCubeMapRotation) {
				code += "#define CUBEMAP_ROTATION\n";
			}

			if (needsNormal) {
				code += chunks.cubeMapRotatePS;
				code += options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS;
				code += options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS;
			}

			if (options.diffuseDetail) {
				code += this._addMap("diffuseDetail", "diffuseDetailMapPS", options, chunks);
			}

			code += this._addMap("diffuse", "diffusePS", options, chunks);

			if (options.blendType !== BLEND_NONE || options.alphaTest || options.alphaToCoverage) {
				code += this._addMap("opacity", "opacityPS", options, chunks);
			}

			code += this._addMap("emissive", "emissivePS", options, chunks, options.emissiveFormat);

			if (lighting && options.useSpecular || reflections) {
				if (options.specularAntialias && options.normalMap) {
					if (options.normalizeNormalMap && needsNormal) {
						code += chunks.specularAaToksvigPS;
					} else {
						code += chunks.specularAaToksvigFastPS;
					}
				} else {
					code += chunks.specularAaNonePS;
				}

				var specularPropName = options.useMetalness ? "metalness" : "specular";
				code += this._addMap(specularPropName, specularPropName + "PS", options, chunks);
				code += this._addMap("gloss", "glossPS", options, chunks);

				if (options.fresnelModel === FRESNEL_SCHLICK) {
					code += chunks.fresnelSchlickPS;
				}
			}

			if (options.clearCoat > 0) {
				code += this._addMap("clearCoat", "clearCoatPS", options, chunks);
				code += this._addMap("clearCoatGloss", "clearCoatGlossPS", options, chunks);
				code += this._addMap("clearCoatNormal", "clearCoatNormalPS", options, chunks);
			}

			if (options.heightMap) {
				if (!options.normalMap) {
					var transformedHeightMapUv = this._getUvSourceExpression("heightMapTransform", "heightMapUv", options);

					if (!options.hasTangents) tbn = tbn.replace(/\$UV/g, transformedHeightMapUv);
					code += tbn;
				}

				code += this._addMap("height", "parallaxPS", options, chunks);
			}

			var useAo = options.aoMap || options.aoVertexColor;

			if (useAo) {
				code += this._addMap("ao", "aoPS", options, chunks);
				code += chunks.aoDiffuseOccPS;

				if (options.occludeSpecular) {
					if (options.occludeSpecular === SPECOCC_AO) {
						code += options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS;
					} else {
						code += options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS;
					}
				}
			}

			if (options.reflectionSource === 'envAtlas') {
				code += chunks.reflectionEnvPS.replace(/\$DECODE/g, this._decodeFunc(options.reflectionEncoding));
			} else if (options.reflectionSource === 'cubeMap') {
				code += options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS;
				code += chunks.reflectionCubePS.replace(/\$DECODE/g, this._decodeFunc(options.reflectionEncoding));
			} else if (options.reflectionSource === 'sphereMap') {
				var scode = device.fragmentUniformsCount > 16 ? chunks.reflectionSpherePS : chunks.reflectionSphereLowPS;
				code += scode.replace(/\$DECODE/g, this._decodeFunc(options.reflectionEncoding));
			}

			if (reflections) {
				if (options.clearCoat > 0) {
					code += chunks.reflectionCCPS;
				}

				if (options.refraction) {
					code += chunks.refractionPS;
				}
			}

			if (options.clusteredLightingEnabled) {
				code += chunks.clusteredLightUtilsPS;
				code += chunks.clusteredLightCookiesPS;
				shadowTypeUsed[SHADOW_PCF3] = true;
				shadowTypeUsed[SHADOW_PCF5] = true;
				usePerspZbufferShadow = true;
			}

			if (numShadowLights > 0 || options.clusteredLightingEnabled) {
				if (shadowedDirectionalLightUsed) {
					code += chunks.shadowCascadesPS;
				}

				if (shadowTypeUsed[SHADOW_PCF3]) {
					code += chunks.shadowStandardPS;
				}

				if (shadowTypeUsed[SHADOW_PCF5] && device.webgl2) {
					code += chunks.shadowStandardGL2PS;
				}

				if (useVsm) {
					code += chunks.shadowVSM_commonPS;

					if (shadowTypeUsed[SHADOW_VSM8]) {
						code += chunks.shadowVSM8PS;
					}

					if (shadowTypeUsed[SHADOW_VSM16]) {
						code += device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "16") : chunks.shadowEVSMnPS.replace(/\$/g, "16");
					}

					if (shadowTypeUsed[SHADOW_VSM32]) {
						code += device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "32") : chunks.shadowEVSMnPS.replace(/\$/g, "32");
					}
				}

				if (!(device.webgl2 || device.extStandardDerivatives)) {
					code += chunks.biasConstPS;
				}

				code += chunks.shadowCoordPS + chunks.shadowCommonPS;
				if (usePerspZbufferShadow) code += chunks.shadowCoordPerspZbufferPS;
			}

			if (options.enableGGXSpecular) code += "uniform float material_anisotropy;\n";

			if (lighting) {
				code += chunks.lightDiffuseLambertPS;
				if (hasAreaLights || options.clusteredLightingEnabled) code += chunks.ltc;
			}

			code += '\n';
			var useOldAmbient = false;

			if (options.useSpecular) {
				code += "#define CLUSTER_SPECULAR\n";

				if (options.conserveEnergy) {
					code += "#define CLUSTER_CONSERVE_ENERGY\n";
				}

				if (lighting) {
					code += options.shadingModel === SPECULAR_PHONG ? chunks.lightSpecularPhongPS : options.enableGGXSpecular ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS;
				}

				if (options.fresnelModel > 0) {
					if (options.conserveEnergy && !hasAreaLights) {
						code += chunks.combineDiffuseSpecularPS;
					} else {
						code += chunks.combineDiffuseSpecularNoConservePS;
					}
				} else if (reflections) {
					code += chunks.combineDiffuseSpecularOldPS;
				} else {
					if (options.diffuseMap) {
						code += chunks.combineDiffuseSpecularNoReflPS;
					} else {
						code += chunks.combineDiffuseSpecularNoReflSeparateAmbientPS;
						useOldAmbient = true;
					}
				}
			} else {
				code += chunks.combineDiffusePS;
			}

			if (options.clearCoat > 0) {
				code += chunks.combineClearCoatPS;
			}

			var addAmbient = true;

			if (options.lightMap || options.lightVertexColor) {
				var lightmapChunkPropName = options.dirLightMap && options.useSpecular ? 'lightmapDirPS' : 'lightmapSinglePS';
				code += this._addMap("light", lightmapChunkPropName, options, chunks, options.lightMapFormat);
				addAmbient = options.lightMapWithoutAmbient;
			}

			if (addAmbient) {
				if (options.ambientSource === 'ambientSH') {
					code += chunks.ambientSHPS;
				} else if (options.ambientSource === 'envAtlas') {
					code += chunks.ambientEnvPS.replace(/\$DECODE/g, this._decodeFunc(options.ambientEncoding));
				} else {
					code += chunks.ambientConstantPS;
				}
			}

			if (options.ambientTint && !useOldAmbient) {
				code += "uniform vec3 material_ambient;\n";
			}

			if (options.alphaTest) {
				code += chunks.alphaTestPS;
			}

			if (options.msdf) {
				code += chunks.msdfPS;
			}

			if (needsNormal) {
				code += chunks.viewDirPS;

				if (options.useSpecular) {
					code += options.enableGGXSpecular ? chunks.reflDirAnisoPS : chunks.reflDirPS;
				}
			}

			var hasPointLights = false;
			var usesLinearFalloff = false;
			var usesInvSquaredFalloff = false;
			var usesSpot = false;
			var usesCookie = false;
			var usesCookieNow;

			if (options.clusteredLightingEnabled && lighting) {
				usesSpot = true;
				hasPointLights = true;
				usesLinearFalloff = true;
				usesCookie = true;
				code += chunks.floatUnpackingPS;
				if (options.lightMaskDynamic) code += "\n#define CLUSTER_MESH_DYNAMIC_LIGHTS";
				if (options.clusteredLightingCookiesEnabled) code += "\n#define CLUSTER_COOKIES";

				if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
					code += "\n#define CLUSTER_SHADOWS";
					code += "\n#define CLUSTER_SHADOW_TYPE_" + shadowTypeToString[options.clusteredLightingShadowType];
				}

				if (options.clusteredLightingAreaLightsEnabled) code += "\n#define CLUSTER_AREALIGHTS";
				code += LightsBuffer.shaderDefines;
				code += chunks.clusteredLightShadowsPS;
				code += chunks.clusteredLightPS;
			}

			if (options.twoSidedLighting) code += "uniform float twoSidedLightingNegScaleFactor;\n";
			code = this._fsAddStartCode(code, device, chunks, options);

			if (needsNormal) {
				if (!options.hasTangents && device.extStandardDerivatives && !options.fastTbn) {
					if (options.twoSidedLighting) {
						code += "	 dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);\n";
					} else {
						code += "	 dVertexNormalW = normalize(vNormalW);\n";
					}
				} else {
					if (options.twoSidedLighting) {
						code += "	 dVertexNormalW = gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor;\n";
					} else {
						code += "	 dVertexNormalW = vNormalW;\n";
					}
				}

				if ((options.heightMap || options.normalMap) && options.hasTangents) {
					if (options.twoSidedLighting) {
						code += "	 dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;\n";
						code += "	 dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;\n";
					} else {
						code += "	 dTangentW = vTangentW;\n";
						code += "	 dBinormalW = vBinormalW;\n";
					}
				}
			}

			var opacityParallax = false;

			if (options.blendType === BLEND_NONE && !options.alphaTest && !options.alphaToCoverage) {
				code += "	 dAlpha = 1.0;\n";
			} else {
				if (options.heightMap && options.opacityMap) {
					opacityParallax = true;
				} else {
					code += "	 getOpacity();\n";

					if (options.alphaTest) {
						code += "	 alphaTest(dAlpha);\n";
					}
				}
			}

			var getGlossinessCalled = false;

			if (needsNormal) {
				code += "	 getViewDir();\n";

				if (options.heightMap || options.normalMap || options.clearCoatNormalMap || options.enableGGXSpecular) {
					code += "	 getTBN();\n";
				}

				if (options.heightMap) {
					code += "	 getParallax();\n";
				}

				if (opacityParallax) {
					code += "	 getOpacity();\n";

					if (options.alphaTest) {
						code += "	 alphaTest(dAlpha);\n";
					}
				}

				code += "	 getNormal();\n";

				if (options.useSpecular) {
					if (lighting && options.enableGGXSpecular) {
						code += "	 getGlossiness();\n";
						getGlossinessCalled = true;
					}

					code += "	 getReflDir();\n";
				}
			}

			code += "	 getAlbedo();\n";

			if (options.clearCoat > 0) {
				code += "	 getClearCoat();\n";
				code += "	 getClearCoatGlossiness();\n";
				code += "	 getClearCoatNormal();\n";
			}

			if (lighting && options.useSpecular || reflections) {
				code += "	 getSpecularity();\n";
				if (!getGlossinessCalled) code += "	 getGlossiness();\n";

				if (hasAreaLights) {
					code += "	 #ifdef AREA_LIGHTS\n";
					code += "	 dSpecularityNoFres = dSpecularity;\n";
					code += "	 #ifdef CLEARCOAT\n";
					code += "	 ccSpecularityNoFres = ccSpecularity;\n";
					code += "	 #endif\n";
					code += "	 #endif\n";
				}

				if (options.fresnelModel > 0) code += "	 getFresnel();\n";
			}

			if (useAo) {
				code += "	getAO();\n";
			}

			if (addAmbient) {
				code += "	 addAmbient();\n";

				if (options.separateAmbient) {
					code += "\n										vec3 dAmbientLight = dDiffuseLight;\n										dDiffuseLight = vec3(0);\n								";
				}
			}

			if (options.ambientTint && !useOldAmbient) {
				code += "	 dDiffuseLight *= material_ambient;\n";
			}

			if (useAo && !options.occludeDirect) {
				code += "		occludeDiffuse();\n";
			}

			if (options.lightMap || options.lightVertexColor) {
				code += "	 addLightMap();\n";
			}

			if (lighting || reflections) {
				if (reflections) {
					if (options.clearCoat > 0) {
						code += "	 addReflectionCC();\n";
					}

					code += "	 addReflection();\n";
				}

				if (hasAreaLights) {
					code += "	 ccReflection.rgb *= ccSpecularity;\n";
					code += "	 dReflection.rgb *= dSpecularity;\n";
					code += "	 dSpecularLight *= dSpecularity;\n";
					code += "	 float roughness = max((1.0 - dGlossiness) * (1.0 - dGlossiness), 0.001);\n";
					code += "	 calcLTCLightValues();\n";
				}

				for (var _i3 = 0; _i3 < options.lights.length; _i3++) {
					var _light = options.lights[_i3];
					var _lightType = _light._type;

					if (options.clusteredLightingEnabled && _lightType !== LIGHTTYPE_DIRECTIONAL) {
						continue;
					}

					usesCookieNow = false;

					var _lightShape = hasAreaLights && _light._shape ? _light.shape : LIGHTSHAPE_PUNCTUAL;

					var shapeString = hasAreaLights && _light._shape ? this._getLightSourceShapeString(_lightShape) : '';

					if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
						code += "	 calc" + shapeString + "LightValues(light" + _i3 + "_position, light" + _i3 + "_halfWidth, light" + _i3 + "_halfHeight);\n";
					}

					if (_lightType === LIGHTTYPE_DIRECTIONAL) {
						code += "	 dLightDirNormW = light" + _i3 + "_direction;\n";
						code += "	 dAtten = 1.0;\n";
					} else {
						if (_light._cookie) {
							if (_lightType === LIGHTTYPE_SPOT && !_light._cookie._cubemap) {
								usesCookie = true;
								usesCookieNow = true;
							} else if (_lightType === LIGHTTYPE_OMNI && _light._cookie._cubemap) {
								usesCookie = true;
								usesCookieNow = true;
							}
						}

						code += "	 getLightDirPoint(light" + _i3 + "_position);\n";
						hasPointLights = true;

						if (usesCookieNow) {
							if (_lightType === LIGHTTYPE_SPOT) {
								code += "	 dAtten3 = getCookie2D" + (_light._cookieFalloff ? "" : "Clip") + (_light._cookieTransform ? "Xform" : "") + "(light" + _i3 + "_cookie, light" + _i3 + "_shadowMatrix, light" + _i3 + "_cookieIntensity" + (_light._cookieTransform ? ", light" + _i3 + "_cookieMatrix, light" + _i3 + "_cookieOffset" : "") + ")." + _light._cookieChannel + ";\n";
							} else {
								code += "	 dAtten3 = getCookieCube(light" + _i3 + "_cookie, light" + _i3 + "_shadowMatrix, light" + _i3 + "_cookieIntensity)." + _light._cookieChannel + ";\n";
							}
						}

						if (_lightShape === LIGHTSHAPE_PUNCTUAL) {
							if (_light._falloffMode === LIGHTFALLOFF_LINEAR) {
								code += "	 dAtten = getFalloffLinear(light" + _i3 + "_radius);\n";
								usesLinearFalloff = true;
							} else {
								code += "	 dAtten = getFalloffInvSquared(light" + _i3 + "_radius);\n";
								usesInvSquaredFalloff = true;
							}
						} else {
							code += "	 dAtten = getFalloffWindow(light" + _i3 + "_radius);\n";
							usesInvSquaredFalloff = true;
						}

						code += "	 if (dAtten > 0.00001) {\n";

						if (_lightType === LIGHTTYPE_SPOT) {
							if (!(usesCookieNow && !_light._cookieFalloff)) {
								code += "			 dAtten *= getSpotEffect(light" + _i3 + "_direction, light" + _i3 + "_innerConeAngle, light" + _i3 + "_outerConeAngle);\n";
								usesSpot = true;
							}
						}
					}

					if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
						if (_lightType === LIGHTTYPE_DIRECTIONAL) {
							code += "			 dAttenD = getLightDiffuse();\n";
						} else {
							code += "			 dAttenD = get" + shapeString + "LightDiffuse() * 16.0;\n";
						}
					} else {
						code += "			 dAtten *= getLightDiffuse();\n";
					}

					if (_light.castShadows && !options.noShadow) {
						var shadowReadMode = null;
						var evsmExp = void 0;

						if (_light._shadowType === SHADOW_VSM8) {
							shadowReadMode = "VSM8";
							evsmExp = "0.0";
						} else if (_light._shadowType === SHADOW_VSM16) {
							shadowReadMode = "VSM16";
							evsmExp = "5.54";
						} else if (_light._shadowType === SHADOW_VSM32) {
							shadowReadMode = "VSM32";

							if (device.textureFloatHighPrecision) {
								evsmExp = "15.0";
							} else {
								evsmExp = "5.54";
							}
						} else if (_light._shadowType === SHADOW_PCF5) {
							shadowReadMode = "PCF5x5";
						} else {
							shadowReadMode = "PCF3x3";
						}

						if (shadowReadMode !== null) {
							if (_lightType === LIGHTTYPE_OMNI) {
								shadowCoordArgs = "(light" + _i3 + "_shadowMap, light" + _i3 + "_shadowParams);\n";

								if (_light._normalOffsetBias) {
									code += "			 normalOffsetPointShadow(light" + _i3 + "_shadowParams);\n";
								}

								code += "			 dAtten *= getShadowPoint" + shadowReadMode + shadowCoordArgs;
							} else {
								var shadowMatArg = "light" + _i3 + "_shadowMatrix";
								var shadowParamArg = "light" + _i3 + "_shadowParams";
								code += this._nonPointShadowMapProjection(device, options.lights[_i3], shadowMatArg, shadowParamArg, _i3);
								if (_lightType === LIGHTTYPE_SPOT) shadowReadMode = "Spot" + shadowReadMode;
								code += "			 dAtten *= getShadow" + shadowReadMode + "(light" + _i3 + "_shadowMap, light" + _i3 + "_shadowParams" + (_light._isVsm ? ", " + evsmExp : "") + ");\n";
							}
						}
					}

					if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
						if (options.conserveEnergy && options.useSpecular) {
							code += "			 dDiffuseLight += mix((dAttenD * dAtten) * light" + _i3 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ", vec3(0), dLTCSpecFres);\n";
						} else {
							code += "			 dDiffuseLight += (dAttenD * dAtten) * light" + _i3 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
						}
					} else {
						if (hasAreaLights && options.conserveEnergy && options.useSpecular) {
							code += "			 dDiffuseLight += mix(dAtten * light" + _i3 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ", vec3(0), dSpecularity);\n";
						} else {
							code += "			 dDiffuseLight += dAtten * light" + _i3 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
						}
					}

					if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
						if (options.clearCoat > 0) code += "			 ccSpecularLight += ccLTCSpecFres * get" + shapeString + "LightSpecularCC() * dAtten * light" + _i3 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
						if (options.useSpecular) code += "			 dSpecularLight += dLTCSpecFres * get" + shapeString + "LightSpecular() * dAtten * light" + _i3 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					} else {
						if (hasAreaLights) {
							if (options.clearCoat > 0) code += "			 ccSpecularLight += ccSpecularity * getLightSpecularCC() * dAtten * light" + _i3 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
							if (options.useSpecular) code += "			 dSpecularLight += dSpecularity * getLightSpecular() * dAtten * light" + _i3 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
						} else {
							if (options.clearCoat > 0) code += "			 ccSpecularLight += getLightSpecularCC() * dAtten * light" + _i3 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
							if (options.useSpecular) code += "			 dSpecularLight += getLightSpecular() * dAtten * light" + _i3 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
						}
					}

					if (_lightType !== LIGHTTYPE_DIRECTIONAL) {
						code += "	 }\n";
					}

					code += "\n";
				}

				if (options.clusteredLightingEnabled && lighting) {
					usesLinearFalloff = true;
					usesInvSquaredFalloff = true;
					hasPointLights = true;
					code += '	 addClusteredLights();\n';
				}

				if (hasAreaLights) {
					if (options.clearCoat > 0) {
						code += "	 ccSpecularity = 1.0;\n";
					}

					if (options.useSpecular) {
						code += "	 dSpecularity = vec3(1);\n";
					}
				}

				if (reflections && options.refraction) {
					code += "	 addRefraction();\n";
				}
			}

			code += "\n";

			if (useAo) {
				if (options.occludeDirect) {
					code += "		occludeDiffuse();\n";
				}

				if (options.occludeSpecular) {
					code += "		occludeSpecular();\n";
				}
			}

			if (options.opacityFadesSpecular === false) {
				if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_PREMULTIPLIED) {
					code += "float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\n";
					code += "#ifdef CLEARCOAT\n specLum += dot(ccSpecularLight * ccSpecularity + ccReflection.rgb * ccReflection.a * ccSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif\n";
					code += "dAlpha = clamp(dAlpha + gammaCorrectInput(specLum), 0.0, 1.0);\n";
				}

				code += "dAlpha *= material_alphaFade;\n";
			}

			code += chunks.endPS;

			if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_ADDITIVEALPHA || options.alphaToCoverage) {
				code += chunks.outputAlphaPS;
			} else if (options.blendType === BLEND_PREMULTIPLIED) {
				code += chunks.outputAlphaPremulPS;
			} else {
				code += chunks.outputAlphaOpaquePS;
			}

			if (options.msdf) {
				code += "	 gl_FragColor = applyMsdf(gl_FragColor);\n";
			}

			code += "\n";
			code += end();

			if (hasPointLights) {
				code = chunks.lightDirPointPS + code;
			}

			if (usesLinearFalloff) {
				code = chunks.falloffLinearPS + code;
			}

			if (usesInvSquaredFalloff) {
				code = chunks.falloffInvSquaredPS + code;
			}

			if (usesSpot) {
				code = chunks.spotPS + code;
			}

			if (usesCookie) {
				code = chunks.cookiePS + code;
			}

			var structCode = "";
			if (code.includes("dReflection")) structCode += "vec4 dReflection;\n";
			if (code.includes("dTBN")) structCode += "mat3 dTBN;\n";
			if (code.includes("dAlbedo")) structCode += "vec3 dAlbedo;\n";
			if (code.includes("dEmission")) structCode += "vec3 dEmission;\n";
			if (code.includes("dNormalW")) structCode += "vec3 dNormalW;\n";
			if (code.includes("dVertexNormalW")) structCode += "vec3 dVertexNormalW;\n";
			if (code.includes("dTangentW")) structCode += "vec3 dTangentW;\n";
			if (code.includes("dBinormalW")) structCode += "vec3 dBinormalW;\n";
			if (code.includes("dViewDirW")) structCode += "vec3 dViewDirW;\n";
			if (code.includes("dReflDirW")) structCode += "vec3 dReflDirW;\n";
			if (code.includes("dDiffuseLight")) structCode += "vec3 dDiffuseLight;\n";
			if (code.includes("dSpecularLight")) structCode += "vec3 dSpecularLight;\n";
			if (code.includes("dLightDirNormW")) structCode += "vec3 dLightDirNormW;\n";
			if (code.includes("dLightDirW")) structCode += "vec3 dLightDirW;\n";
			if (code.includes("dLightPosW")) structCode += "vec3 dLightPosW;\n";
			if (code.includes("dShadowCoord")) structCode += "vec3 dShadowCoord;\n";
			if (code.includes("dNormalMap")) structCode += "vec3 dNormalMap;\n";
			if (code.includes("dSpecularity")) structCode += "vec3 dSpecularity;\n";
			if (code.includes("dSpecularityNoFres")) structCode += "vec3 dSpecularityNoFres;\n";
			if (code.includes("dUvOffset")) structCode += "vec2 dUvOffset;\n";
			if (code.includes("dGlossiness")) structCode += "float dGlossiness;\n";
			if (code.includes("dAlpha")) structCode += "float dAlpha;\n";
			if (code.includes("dAtten")) structCode += "float dAtten;\n";
			if (code.includes("dAttenD")) structCode += "float dAttenD;\n";
			if (code.includes("dAtten3")) structCode += "vec3 dAtten3;\n";
			if (code.includes("dAo")) structCode += "float dAo;\n";
			if (code.includes("dMsdf")) structCode += "vec4 dMsdf;\n";
			if (code.includes("ccReflection")) structCode += "vec4 ccReflection;\n";
			if (code.includes("ccNormalW")) structCode += "vec3 ccNormalW;\n";
			if (code.includes("ccReflDirW")) structCode += "vec3 ccReflDirW;\n";
			if (code.includes("ccSpecularLight")) structCode += "vec3 ccSpecularLight;\n";
			if (code.includes("ccSpecularity")) structCode += "float ccSpecularity;\n";
			if (code.includes("ccSpecularityNoFres")) structCode += "float ccSpecularityNoFres;\n";
			if (code.includes("ccGlossiness")) structCode += "float ccGlossiness;\n";
			code = codeBegin + structCode + code;
			fshader = code;
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: fshader,
				tag: SHADERTAG_MATERIAL
			};
		}
	};

	var programlib = {
		begin: begin,
		dummyFragmentCode: dummyFragmentCode,
		end: end,
		fogCode: fogCode,
		gammaCode: gammaCode,
		precisionCode: precisionCode,
		skinCode: skinCode,
		tonemapCode: tonemapCode,
		versionCode: versionCode,
		basic: basic,
		particle: particle,
		skybox: skybox,
		standard: standard
	};

	var _goldenAngle = 2.399963229728653;
	var random = {
		circlePoint: function circlePoint(point) {
			var r = Math.sqrt(Math.random());
			var theta = Math.random() * 2 * Math.PI;
			point.x = r * Math.cos(theta);
			point.y = r * Math.sin(theta);
		},
		circlePointDeterministic: function circlePointDeterministic(point, index, numPoints) {
			var theta = index * _goldenAngle;
			var r = Math.sqrt(index) / Math.sqrt(numPoints);
			point.x = r * Math.cos(theta);
			point.y = r * Math.sin(theta);
		},
		spherePointDeterministic: function spherePointDeterministic(point, index, numPoints, start, end) {
			if (start === void 0) {
				start = 0;
			}

			if (end === void 0) {
				end = 1;
			}

			start = 1 - 2 * start;
			end = 1 - 2 * end;
			var y = math.lerp(start, end, index / numPoints);
			var radius = Math.sqrt(1 - y * y);
			var theta = _goldenAngle * index;
			point.x = Math.cos(theta) * radius;
			point.y = y;
			point.z = Math.sin(theta) * radius;
		},
		radicalInverse: function radicalInverse(i) {
			var bits = (i << 16 | i >>> 16) >>> 0;
			bits = ((bits & 0x55555555) << 1 | (bits & 0xAAAAAAAA) >>> 1) >>> 0;
			bits = ((bits & 0x33333333) << 2 | (bits & 0xCCCCCCCC) >>> 2) >>> 0;
			bits = ((bits & 0x0F0F0F0F) << 4 | (bits & 0xF0F0F0F0) >>> 4) >>> 0;
			bits = ((bits & 0x00FF00FF) << 8 | (bits & 0xFF00FF00) >>> 8) >>> 0;
			return bits * 2.3283064365386963e-10;
		}
	};

	var getCoding = function getCoding(texture) {
		switch (texture.type) {
			case TEXTURETYPE_RGBM:
				return "RGBM";

			case TEXTURETYPE_RGBE:
				return "RGBE";

			default:
				switch (texture.format) {
					case PIXELFORMAT_RGB16F:
					case PIXELFORMAT_RGB32F:
					case PIXELFORMAT_RGBA16F:
					case PIXELFORMAT_RGBA32F:
						return "Linear";

					default:
						return "Gamma";
				}

		}
	};

	var getProjectionName = function getProjectionName(projection) {
		if (projection === TEXTUREPROJECTION_NONE) {
			projection = TEXTUREPROJECTION_EQUIRECT;
		}

		switch (projection) {
			case TEXTUREPROJECTION_CUBE:
				return "Cubemap";

			case TEXTUREPROJECTION_EQUIRECT:
				return "Equirect";

			case TEXTUREPROJECTION_OCTAHEDRAL:
				return "Octahedral";
		}
	};

	var packFloat32ToRGBA8 = function packFloat32ToRGBA8(value, array, offset) {
		if (value <= 0) {
			array[offset + 0] = 0;
			array[offset + 1] = 0;
			array[offset + 2] = 0;
			array[offset + 3] = 0;
		} else if (value >= 1.0) {
			array[offset + 0] = 255;
			array[offset + 1] = 0;
			array[offset + 2] = 0;
			array[offset + 3] = 0;
		} else {
			var encX = 1 * value % 1;
			var encY = 255 * value % 1;
			var encZ = 65025 * value % 1;
			var encW = 16581375.0 * value % 1;
			encX -= encY / 255;
			encY -= encZ / 255;
			encZ -= encW / 255;
			array[offset + 0] = Math.min(255, Math.floor(encX * 256));
			array[offset + 1] = Math.min(255, Math.floor(encY * 256));
			array[offset + 2] = Math.min(255, Math.floor(encZ * 256));
			array[offset + 3] = Math.min(255, Math.floor(encW * 256));
		}
	};

	var packSamples = function packSamples(samples) {
		var numSamples = samples.length;
		var w = Math.min(numSamples, 512);
		var h = Math.ceil(numSamples / w);
		var data = new Uint8Array(w * h * 4);
		var off = 0;

		for (var i = 0; i < numSamples; ++i) {
			packFloat32ToRGBA8(samples[i * 4 + 0] * 0.5 + 0.5, data, off + 0);
			packFloat32ToRGBA8(samples[i * 4 + 1] * 0.5 + 0.5, data, off + 4);
			packFloat32ToRGBA8(samples[i * 4 + 2] * 0.5 + 0.5, data, off + 8);
			packFloat32ToRGBA8(samples[i * 4 + 3] / 8, data, off + 12);
			off += 16;
		}

		return {
			width: w,
			height: h,
			data: data
		};
	};

	var hemisphereSamplePhong = function hemisphereSamplePhong(dstVec, x, y, specularPower) {
		var phi = y * 2 * Math.PI;
		var cosTheta = Math.pow(1 - x, 1 / (specularPower + 1));
		var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
	};

	var hemisphereSampleLambert = function hemisphereSampleLambert(dstVec, x, y) {
		var phi = y * 2 * Math.PI;
		var cosTheta = Math.sqrt(1 - x);
		var sinTheta = Math.sqrt(x);
		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
	};

	var hemisphereSampleGGX = function hemisphereSampleGGX(dstVec, x, y, a) {
		var phi = y * 2 * Math.PI;
		var cosTheta = Math.sqrt((1 - x) / (1 + (a * a - 1) * x));
		var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
	};

	var D_GGX = function D_GGX(NoH, linearRoughness) {
		var a = NoH * linearRoughness;
		var k = linearRoughness / (1.0 - NoH * NoH + a * a);
		return k * k * (1 / Math.PI);
	};

	var generatePhongSamples = function generatePhongSamples(numSamples, specularPower) {
		var H = new Vec3();
		var result = [];

		for (var i = 0; i < numSamples; ++i) {
			hemisphereSamplePhong(H, i / numSamples, random.radicalInverse(i), specularPower);
			result.push(H.x, H.y, H.z, 0);
		}

		return result;
	};

	var generateLambertSamples = function generateLambertSamples(numSamples, sourceTotalPixels) {
		var pixelsPerSample = sourceTotalPixels / numSamples;
		var H = new Vec3();
		var result = [];

		for (var i = 0; i < numSamples; ++i) {
			hemisphereSampleLambert(H, i / numSamples, random.radicalInverse(i));
			var pdf = H.z / Math.PI;
			var mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
			result.push(H.x, H.y, H.z, mipLevel);
		}

		return result;
	};

	var requiredSamplesGGX = {
		"16": {
			"2": 26,
			"8": 20,
			"32": 17,
			"128": 16,
			"512": 16
		},
		"32": {
			"2": 53,
			"8": 40,
			"32": 34,
			"128": 32,
			"512": 32
		},
		"128": {
			"2": 214,
			"8": 163,
			"32": 139,
			"128": 130,
			"512": 128
		},
		"1024": {
			"2": 1722,
			"8": 1310,
			"32": 1114,
			"128": 1041,
			"512": 1025
		}
	};

	var getRequiredSamplesGGX = function getRequiredSamplesGGX(numSamples, specularPower) {
		var table = requiredSamplesGGX[numSamples];
		return table && table[specularPower] || numSamples;
	};

	var generateGGXSamples = function generateGGXSamples(numSamples, specularPower, sourceTotalPixels) {
		var pixelsPerSample = sourceTotalPixels / numSamples;
		var roughness = 1 - Math.log2(specularPower) / 11.0;
		var a = roughness * roughness;
		var H = new Vec3();
		var L = new Vec3();
		var N = new Vec3(0, 0, 1);
		var result = [];
		var requiredSamples = getRequiredSamplesGGX(numSamples, specularPower);

		for (var i = 0; i < requiredSamples; ++i) {
			hemisphereSampleGGX(H, i / requiredSamples, random.radicalInverse(i), a);
			var NoH = H.z;
			L.set(H.x, H.y, H.z).mulScalar(2 * NoH).sub(N);

			if (L.z > 0) {
				var pdf = D_GGX(Math.min(1, NoH), a) / 4 + 0.001;
				var mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
				result.push(L.x, L.y, L.z, mipLevel);
			}
		}

		while (result.length < numSamples * 4) {
			result.push(0, 0, 0, 0);
		}

		return result;
	};

	var createSamplesTex = function createSamplesTex(device, name, samples) {
		var packedSamples = packSamples(samples);
		return new Texture(device, {
			name: name,
			width: packedSamples.width,
			height: packedSamples.height,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			levels: [packedSamples.data]
		});
	};

	var SimpleCache = function () {
		function SimpleCache(destroyContent) {
			if (destroyContent === void 0) {
				destroyContent = true;
			}

			this.map = new Map();
			this.destroyContent = destroyContent;
		}

		var _proto = SimpleCache.prototype;

		_proto.destroy = function destroy() {
			if (this.destroyContent) {
				this.map.forEach(function (value, key) {
					value.destroy();
				});
			}
		};

		_proto.get = function get(key, missFunc) {
			if (!this.map.has(key)) {
				var result = missFunc();
				this.map.set(key, result);
				return result;
			}

			return this.map.get(key);
		};

		return SimpleCache;
	}();

	var samplesCache = new SimpleCache(false);
	var deviceCache$1 = new DeviceCache();

	var getCachedTexture = function getCachedTexture(device, key, getSamplesFnc) {
		var cache = deviceCache$1.get(device, function () {
			return new SimpleCache();
		});
		return cache.get(key, function () {
			return createSamplesTex(device, key, samplesCache.get(key, getSamplesFnc));
		});
	};

	var generateLambertSamplesTex = function generateLambertSamplesTex(device, numSamples, sourceTotalPixels) {
		var key = "lambert-samples-" + numSamples + "-" + sourceTotalPixels;
		return getCachedTexture(device, key, function () {
			return generateLambertSamples(numSamples, sourceTotalPixels);
		});
	};

	var generatePhongSamplesTex = function generatePhongSamplesTex(device, numSamples, specularPower) {
		var key = "phong-samples-" + numSamples + "-" + specularPower;
		return getCachedTexture(device, key, function () {
			return generatePhongSamples(numSamples, specularPower);
		});
	};

	var generateGGXSamplesTex = function generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) {
		var key = "ggx-samples-" + numSamples + "-" + specularPower + "-" + sourceTotalPixels;
		return getCachedTexture(device, key, function () {
			return generateGGXSamples(numSamples, specularPower, sourceTotalPixels);
		});
	};

	var vsCode = "\nattribute vec2 vertex_position;\n\nuniform vec4 uvMod;\n\nvarying vec2 vUv0;\n\nvoid main(void) {\n		gl_Position = vec4(vertex_position, 0.5, 1.0);\n		vUv0 = (vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw;\n}\n";

	function reprojectTexture(source, target, options) {
		var _options;

		if (options === void 0) {
			options = {};
		}

		if (source instanceof GraphicsDevice) {
			source = arguments[1];
			target = arguments[2];
			options = {};

			if (arguments[3] !== undefined) {
				options.specularPower = arguments[3];
			}

			if (arguments[4] !== undefined) {
				options.numSamples = arguments[4];
			}

			Debug.deprecated('please use the updated pc.reprojectTexture API.');
		}

		var funcNames = {
			'none': 'reproject',
			'lambert': 'prefilterSamplesUnweighted',
			'phong': 'prefilterSamplesUnweighted',
			'ggx': 'prefilterSamples'
		};
		var specularPower = options.hasOwnProperty('specularPower') ? options.specularPower : 1;
		var face = options.hasOwnProperty('face') ? options.face : null;
		var distribution = options.hasOwnProperty('distribution') ? options.distribution : specularPower === 1 ? 'none' : 'phong';
		var processFunc = funcNames[distribution] || 'reproject';
		var decodeFunc = "decode" + getCoding(source);
		var encodeFunc = "encode" + getCoding(target);
		var sourceFunc = "sample" + getProjectionName(source.projection);
		var targetFunc = "getDirection" + getProjectionName(target.projection);
		var numSamples = options.hasOwnProperty('numSamples') ? options.numSamples : 1024;
		var shaderKey = processFunc + "_" + decodeFunc + "_" + encodeFunc + "_" + sourceFunc + "_" + targetFunc + "_" + numSamples;
		var device = source.device;
		var shader = device.programLib._cache[shaderKey];

		if (!shader) {
			var defines = "#define PROCESS_FUNC " + processFunc + "\n" + ("#define DECODE_FUNC " + decodeFunc + "\n") + ("#define ENCODE_FUNC " + encodeFunc + "\n") + ("#define SOURCE_FUNC " + sourceFunc + "\n") + ("#define TARGET_FUNC " + targetFunc + "\n") + ("#define NUM_SAMPLES " + numSamples + "\n") + (device.extTextureLod ? "#define SUPPORTS_TEXLOD\n" : '');
			var extensions = '';

			if (!device.webgl2) {
				extensions = '#extension GL_OES_standard_derivatives: enable\n';

				if (device.extTextureLod) {
					extensions += '#extension GL_EXT_shader_texture_lod: enable\n\n';
				}
			}

			shader = createShaderFromCode(device, vsCode, defines + "\n" + shaderChunks.reprojectPS, shaderKey, false, extensions);
		}

		DebugGraphics.pushGpuMarker(device, "ReprojectTexture");
		var constantSource = device.scope.resolve(source.cubemap ? "sourceCube" : "sourceTex");
		constantSource.setValue(source);
		var constantParams = device.scope.resolve("params");
		var constantParams2 = device.scope.resolve("params2");
		var uvModParam = device.scope.resolve("uvMod");

		if ((_options = options) != null && _options.seamPixels) {
			var p = options.seamPixels;
			var w = options.rect ? options.rect.z : target.width;
			var h = options.rect ? options.rect.w : target.height;
			var innerWidth = w - p * 2;
			var innerHeight = h - p * 2;
			uvModParam.setValue([(innerWidth + p * 2) / innerWidth, (innerHeight + p * 2) / innerHeight, -p / innerWidth, -p / innerHeight]);
		} else {
			uvModParam.setValue([1, 1, 0, 0]);
		}

		var params = [0, specularPower, source.fixCubemapSeams ? 1.0 / source.width : 0.0, target.fixCubemapSeams ? 1.0 / target.width : 0.0];
		var params2 = [target.width * target.height * (target.cubemap ? 6 : 1), source.width * source.height * (source.cubemap ? 6 : 1)];

		if (processFunc.startsWith('prefilterSamples')) {
			var sourceTotalPixels = source.width * source.height * (source.cubemap ? 6 : 1);
			var samplesTex = distribution === 'ggx' ? generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) : distribution === 'lambert' ? generateLambertSamplesTex(device, numSamples, sourceTotalPixels) : generatePhongSamplesTex(device, numSamples, specularPower);
			device.scope.resolve("samplesTex").setValue(samplesTex);
			device.scope.resolve("samplesTexInverseSize").setValue([1.0 / samplesTex.width, 1.0 / samplesTex.height]);
		}

		for (var f = 0; f < (target.cubemap ? 6 : 1); f++) {
			if (face === null || f === face) {
				var _options2;

				var renderTarget = new RenderTarget({
					colorBuffer: target,
					face: f,
					depth: false
				});
				params[0] = f;
				constantParams.setValue(params);
				constantParams2.setValue(params2);
				drawQuadWithShader(device, renderTarget, shader, (_options2 = options) == null ? void 0 : _options2.rect);
				renderTarget.destroy();
			}
		}

		DebugGraphics.popGpuMarker(device);
	}

	var fixCubemapSeams = true;

	var calcLevels = function calcLevels(width, height) {
		if (height === void 0) {
			height = 0;
		}

		return 1 + Math.floor(Math.log2(Math.max(width, height)));
	};

	var supportsFloat16 = function supportsFloat16(device) {
		return device.extTextureHalfFloat && device.textureHalfFloatRenderable;
	};

	var supportsFloat32 = function supportsFloat32(device) {
		return device.extTextureFloat && device.textureFloatRenderable;
	};

	var lightingSourcePixelFormat = function lightingSourcePixelFormat(device) {
		return supportsFloat16(device) ? PIXELFORMAT_RGBA16F : supportsFloat32(device) ? PIXELFORMAT_RGBA32F : PIXELFORMAT_R8_G8_B8_A8;
	};

	var lightingPixelFormat = function lightingPixelFormat(device) {
		return PIXELFORMAT_R8_G8_B8_A8;
	};

	var createCubemap = function createCubemap(device, size, format, mipmaps) {
		return new Texture(device, {
			name: "lighting-" + size,
			cubemap: true,
			width: size,
			height: size,
			format: format,
			type: format === PIXELFORMAT_R8_G8_B8_A8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			fixCubemapSeams: fixCubemapSeams,
			mipmaps: !!mipmaps
		});
	};

	var EnvLighting = function () {
		function EnvLighting() {}

		EnvLighting.generateSkyboxCubemap = function generateSkyboxCubemap(source, size) {
			var device = source.device;
			DebugGraphics.pushGpuMarker(device, "genSkyboxCubemap");
			var result = createCubemap(device, size || (source.cubemap ? source.width : source.width / 4), PIXELFORMAT_R8_G8_B8_A8, false);
			reprojectTexture(source, result, {
				numSamples: 1024
			});
			DebugGraphics.popGpuMarker(device);
			return result;
		};

		EnvLighting.generateLightingSource = function generateLightingSource(source, options) {
			var _options, _options2, _options3;

			if (options === void 0) {
				options = null;
			}

			var device = source.device;
			DebugGraphics.pushGpuMarker(device, "genLightingSource");
			var format = lightingSourcePixelFormat(device);
			var result = ((_options = options) == null ? void 0 : _options.target) || new Texture(device, {
				name: "lighting-source",
				cubemap: true,
				width: ((_options2 = options) == null ? void 0 : _options2.size) || 128,
				height: ((_options3 = options) == null ? void 0 : _options3.size) || 128,
				format: format,
				type: format === PIXELFORMAT_R8_G8_B8_A8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				fixCubemapSeams: false,
				mipmaps: true
			});
			reprojectTexture(source, result, {
				numSamples: source.mipmaps ? 1 : 1024
			});
			DebugGraphics.popGpuMarker(device);
			return result;
		};

		EnvLighting.generateAtlas = function generateAtlas(source, options) {
			var _options4, _options5, _options6, _options9;

			if (options === void 0) {
				options = null;
			}

			var device = source.device;
			var format = lightingPixelFormat();
			DebugGraphics.pushGpuMarker(device, "genAtlas");
			var result = ((_options4 = options) == null ? void 0 : _options4.target) || new Texture(device, {
				width: ((_options5 = options) == null ? void 0 : _options5.size) || 512,
				height: ((_options6 = options) == null ? void 0 : _options6.size) || 512,
				format: format,
				type: TEXTURETYPE_RGBM ,
				projection: TEXTUREPROJECTION_EQUIRECT,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				mipmaps: false
			});
			DebugGraphics.pushGpuMarker(device, "mipmaps");
			var s = result.width / 512;
			var rect = new Vec4(0, 0, 512 * s, 256 * s);
			var levels = calcLevels(256) - calcLevels(4);

			for (var i = 0; i < levels; ++i) {
				reprojectTexture(source, result, {
					numSamples: 1,
					rect: rect,
					seamPixels: s
				});
				rect.x += rect.w;
				rect.y += rect.w;
				rect.z = Math.max(1, Math.floor(rect.z * 0.5));
				rect.w = Math.max(1, Math.floor(rect.w * 0.5));
			}

			DebugGraphics.popGpuMarker(device);
			DebugGraphics.pushGpuMarker(device, "reflections");
			rect.set(0, 256 * s, 256 * s, 128 * s);

			for (var _i = 1; _i < 7; ++_i) {
				var _options7, _options8;

				reprojectTexture(source, result, {
					numSamples: ((_options7 = options) == null ? void 0 : _options7.numReflectionSamples) || 1024,
					distribution: ((_options8 = options) == null ? void 0 : _options8.distribution) || 'ggx',
					specularPower: Math.max(1, 2048 >> _i * 2),
					rect: rect,
					seamPixels: s
				});
				rect.y += rect.w;
				rect.z = Math.max(1, Math.floor(rect.z * 0.5));
				rect.w = Math.max(1, Math.floor(rect.w * 0.5));
			}

			DebugGraphics.popGpuMarker(device);
			DebugGraphics.pushGpuMarker(device, "ambient");
			rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);
			reprojectTexture(source, result, {
				numSamples: ((_options9 = options) == null ? void 0 : _options9.numAmbientSamples) || 2048,
				distribution: 'lambert',
				rect: rect,
				seamPixels: s
			});
			DebugGraphics.popGpuMarker(device);
			DebugGraphics.popGpuMarker(device);
			return result;
		};

		EnvLighting.generatePrefilteredAtlas = function generatePrefilteredAtlas(sources, options) {
			var _options10, _options11, _options12, _options13;

			if (options === void 0) {
				options = null;
			}

			var device = sources[0].device;
			var format = lightingPixelFormat();
			DebugGraphics.pushGpuMarker(device, "genPrefilteredAtlas");
			var result = ((_options10 = options) == null ? void 0 : _options10.target) || new Texture(device, {
				width: ((_options11 = options) == null ? void 0 : _options11.size) || 512,
				height: ((_options12 = options) == null ? void 0 : _options12.size) || 512,
				format: format,
				type: TEXTURETYPE_RGBM ,
				projection: TEXTUREPROJECTION_EQUIRECT,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				mipmaps: false
			});
			DebugGraphics.pushGpuMarker(device, "mipmaps");
			var s = result.width / 512;
			var rect = new Vec4(0, 0, 512 * s, 256 * s);
			var levels = calcLevels(512);

			for (var i = 0; i < levels; ++i) {
				reprojectTexture(sources[0], result, {
					numSamples: 1,
					rect: rect,
					seamPixels: s
				});
				rect.x += rect.w;
				rect.y += rect.w;
				rect.z = Math.max(1, Math.floor(rect.z * 0.5));
				rect.w = Math.max(1, Math.floor(rect.w * 0.5));
			}

			DebugGraphics.popGpuMarker(device);
			DebugGraphics.pushGpuMarker(device, "reflections");
			rect.set(0, 256 * s, 256 * s, 128 * s);

			for (var _i2 = 1; _i2 < sources.length; ++_i2) {
				reprojectTexture(sources[_i2], result, {
					numSamples: 1,
					rect: rect,
					seamPixels: s
				});
				rect.y += rect.w;
				rect.z = Math.max(1, Math.floor(rect.z * 0.5));
				rect.w = Math.max(1, Math.floor(rect.w * 0.5));
			}

			DebugGraphics.popGpuMarker(device);
			DebugGraphics.pushGpuMarker(device, "ambient");
			rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);

			if ((_options13 = options) != null && _options13.legacyAmbient) {
				reprojectTexture(sources[5], result, {
					numSamples: 1,
					rect: rect,
					seamPixels: s
				});
			} else {
				var _options14;

				reprojectTexture(sources[0], result, {
					numSamples: ((_options14 = options) == null ? void 0 : _options14.numSamples) || 2048,
					distribution: 'lambert',
					rect: rect,
					seamPixels: s
				});
			}

			DebugGraphics.popGpuMarker(device);
			DebugGraphics.popGpuMarker(device);
			return result;
		};

		return EnvLighting;
	}();

	var defaultMaterialDeviceCache = new DeviceCache();

	function getDefaultMaterial(device) {
		return defaultMaterialDeviceCache.get(device);
	}

	function setDefaultMaterial(device, material) {
		defaultMaterialDeviceCache.get(device, function () {
			return material;
		});
	}

	var id$2 = 0;

	var Material = function () {
		function Material() {
			this.name = "Untitled";
			this.id = id$2++;
			this._shader = null;
			this.variants = {};
			this.parameters = {};
			this.alphaTest = 0;
			this.alphaToCoverage = false;
			this.blend = false;
			this.blendSrc = BLENDMODE_ONE;
			this.blendDst = BLENDMODE_ZERO;
			this.blendEquation = BLENDEQUATION_ADD;
			this.separateAlphaBlend = false;
			this.blendSrcAlpha = BLENDMODE_ONE;
			this.blendDstAlpha = BLENDMODE_ZERO;
			this.blendAlphaEquation = BLENDEQUATION_ADD;
			this.cull = CULLFACE_BACK;
			this.depthTest = true;
			this.depthFunc = FUNC_LESSEQUAL;
			this.depthWrite = true;
			this.stencilFront = null;
			this.stencilBack = null;
			this.depthBias = 0;
			this.slopeDepthBias = 0;
			this.redWrite = true;
			this.greenWrite = true;
			this.blueWrite = true;
			this.alphaWrite = true;
			this.meshInstances = [];
			this._shaderVersion = 0;
			this._scene = null;
			this._dirtyBlend = false;
			this.dirty = true;
		}

		var _proto = Material.prototype;

		_proto.copy = function copy(source) {
			this.name = source.name;
			this.shader = source.shader;
			this.alphaTest = source.alphaTest;
			this.alphaToCoverage = source.alphaToCoverage;
			this.blend = source.blend;
			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.separateAlphaBlend = source.separateAlphaBlend;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendAlphaEquation = source.blendAlphaEquation;
			this.cull = source.cull;
			this.depthTest = source.depthTest;
			this.depthFunc = source.depthFunc;
			this.depthWrite = source.depthWrite;
			this.depthBias = source.depthBias;
			this.slopeDepthBias = source.slopeDepthBias;
			if (source.stencilFront) this.stencilFront = source.stencilFront.clone();

			if (source.stencilBack) {
				if (source.stencilFront === source.stencilBack) {
					this.stencilBack = this.stencilFront;
				} else {
					this.stencilBack = source.stencilBack.clone();
				}
			}

			this.redWrite = source.redWrite;
			this.greenWrite = source.greenWrite;
			this.blueWrite = source.blueWrite;
			this.alphaWrite = source.alphaWrite;
			return this;
		};

		_proto.clone = function clone() {
			var clone = new this.constructor();
			return clone.copy(this);
		};

		_proto._updateMeshInstanceKeys = function _updateMeshInstanceKeys() {
			var meshInstances = this.meshInstances;

			for (var i = 0; i < meshInstances.length; i++) {
				meshInstances[i].updateKey();
			}
		};

		_proto.updateUniforms = function updateUniforms(device, scene) {};

		_proto.updateShader = function updateShader(device, scene, objDefs, staticLightList, pass, sortedLights) {};

		_proto.update = function update() {
			this.dirty = true;
			if (this._shader) this._shader.failed = false;
		};

		_proto.clearParameters = function clearParameters() {
			this.parameters = {};
		};

		_proto.getParameters = function getParameters() {
			return this.parameters;
		};

		_proto.clearVariants = function clearVariants() {
			this.variants = {};

			for (var i = 0; i < this.meshInstances.length; i++) {
				var meshInstance = this.meshInstances[i];

				for (var j = 0; j < meshInstance._shader.length; j++) {
					meshInstance._shader[j] = null;
				}
			}
		};

		_proto.getParameter = function getParameter(name) {
			return this.parameters[name];
		};

		_proto.setParameter = function setParameter(name, data) {
			if (data === undefined && typeof name === 'object') {
				var uniformObject = name;

				if (uniformObject.length) {
					for (var i = 0; i < uniformObject.length; i++) {
						this.setParameter(uniformObject[i]);
					}

					return;
				}

				name = uniformObject.name;
				data = uniformObject.value;
			}

			var param = this.parameters[name];

			if (param) {
				param.data = data;
			} else {
				this.parameters[name] = {
					scopeId: null,
					data: data
				};
			}
		};

		_proto.deleteParameter = function deleteParameter(name) {
			if (this.parameters[name]) {
				delete this.parameters[name];
			}
		};

		_proto.setParameters = function setParameters(device, names) {
			var parameters = this.parameters;
			if (names === undefined) names = parameters;

			for (var paramName in names) {
				var parameter = parameters[paramName];

				if (parameter) {
					if (!parameter.scopeId) {
						parameter.scopeId = device.scope.resolve(paramName);
					}

					parameter.scopeId.setValue(parameter.data);
				}
			}
		};

		_proto.destroy = function destroy() {
			this.variants = {};
			this.shader = null;

			for (var i = 0; i < this.meshInstances.length; i++) {
				var meshInstance = this.meshInstances[i];

				for (var j = 0; j < meshInstance._shader.length; j++) {
					meshInstance._shader[j] = null;
				}

				meshInstance._material = null;

				if (meshInstance.mesh) {
					var defaultMaterial = getDefaultMaterial(meshInstance.mesh.device);

					if (this !== defaultMaterial) {
						meshInstance.material = defaultMaterial;
					}
				} else {
					Debug.warn('pc.Material: MeshInstance mesh is null, default material cannot be assigned to the MeshInstance');
				}
			}
		};

		_proto.addMeshInstanceRef = function addMeshInstanceRef(meshInstance) {
			this.meshInstances.push(meshInstance);
		};

		_proto.removeMeshInstanceRef = function removeMeshInstanceRef(meshInstance) {
			var meshInstances = this.meshInstances;
			var i = meshInstances.indexOf(meshInstance);

			if (i !== -1) {
				meshInstances.splice(i, 1);
			}
		};

		_createClass(Material, [{
			key: "shader",
			get: function get() {
				return this._shader;
			},
			set: function set(shader) {
				this._shader = shader;
			}
		}, {
			key: "transparent",
			get: function get() {
				return this.blend || this.blendSrc !== BLENDMODE_ONE || this.blendDst !== BLENDMODE_ZERO || this.blendEquation !== BLENDEQUATION_ADD;
			}
		}, {
			key: "blendType",
			get: function get() {
				if (!this.transparent) {
					return BLEND_NONE;
				} else if (this.blend && this.blendSrc === BLENDMODE_SRC_ALPHA && this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === BLENDEQUATION_ADD) {
					return BLEND_NORMAL;
				} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {
					return BLEND_ADDITIVE;
				} else if (this.blend && this.blendSrc === BLENDMODE_SRC_ALPHA && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {
					return BLEND_ADDITIVEALPHA;
				} else if (this.blend && this.blendSrc === BLENDMODE_DST_COLOR && this.blendDst === BLENDMODE_SRC_COLOR && this.blendEquation === BLENDEQUATION_ADD) {
					return BLEND_MULTIPLICATIVE2X;
				} else if (this.blend && this.blendSrc === BLENDMODE_ONE_MINUS_DST_COLOR && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {
					return BLEND_SCREEN;
				} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_MIN) {
					return BLEND_MIN;
				} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_MAX) {
					return BLEND_MAX;
				} else if (this.blend && this.blendSrc === BLENDMODE_DST_COLOR && this.blendDst === BLENDMODE_ZERO && this.blendEquation === BLENDEQUATION_ADD) {
					return BLEND_MULTIPLICATIVE;
				} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === BLENDEQUATION_ADD) {
					return BLEND_PREMULTIPLIED;
				}

				return BLEND_NORMAL;
			},
			set: function set(type) {
				var prevBlend = this.blend;

				switch (type) {
					case BLEND_NONE:
						this.blend = false;
						this.blendSrc = BLENDMODE_ONE;
						this.blendDst = BLENDMODE_ZERO;
						this.blendEquation = BLENDEQUATION_ADD;
						break;

					case BLEND_NORMAL:
						this.blend = true;
						this.blendSrc = BLENDMODE_SRC_ALPHA;
						this.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;
						this.blendEquation = BLENDEQUATION_ADD;
						break;

					case BLEND_PREMULTIPLIED:
						this.blend = true;
						this.blendSrc = BLENDMODE_ONE;
						this.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;
						this.blendEquation = BLENDEQUATION_ADD;
						break;

					case BLEND_ADDITIVE:
						this.blend = true;
						this.blendSrc = BLENDMODE_ONE;
						this.blendDst = BLENDMODE_ONE;
						this.blendEquation = BLENDEQUATION_ADD;
						break;

					case BLEND_ADDITIVEALPHA:
						this.blend = true;
						this.blendSrc = BLENDMODE_SRC_ALPHA;
						this.blendDst = BLENDMODE_ONE;
						this.blendEquation = BLENDEQUATION_ADD;
						break;

					case BLEND_MULTIPLICATIVE2X:
						this.blend = true;
						this.blendSrc = BLENDMODE_DST_COLOR;
						this.blendDst = BLENDMODE_SRC_COLOR;
						this.blendEquation = BLENDEQUATION_ADD;
						break;

					case BLEND_SCREEN:
						this.blend = true;
						this.blendSrc = BLENDMODE_ONE_MINUS_DST_COLOR;
						this.blendDst = BLENDMODE_ONE;
						this.blendEquation = BLENDEQUATION_ADD;
						break;

					case BLEND_MULTIPLICATIVE:
						this.blend = true;
						this.blendSrc = BLENDMODE_DST_COLOR;
						this.blendDst = BLENDMODE_ZERO;
						this.blendEquation = BLENDEQUATION_ADD;
						break;

					case BLEND_MIN:
						this.blend = true;
						this.blendSrc = BLENDMODE_ONE;
						this.blendDst = BLENDMODE_ONE;
						this.blendEquation = BLENDEQUATION_MIN;
						break;

					case BLEND_MAX:
						this.blend = true;
						this.blendSrc = BLENDMODE_ONE;
						this.blendDst = BLENDMODE_ONE;
						this.blendEquation = BLENDEQUATION_MAX;
						break;
				}

				if (prevBlend !== this.blend) {
					if (this._scene) {
						this._scene.layers._dirtyBlend = true;
					} else {
						this._dirtyBlend = true;
					}
				}

				this._updateMeshInstanceKeys();
			}
		}]);

		return Material;
	}();

	var arraysEqual = function arraysEqual(a, b) {
		if (a.length !== b.length) {
			return false;
		}

		for (var i = 0; i < a.length; ++i) {
			if (a[i] !== b[i]) {
				return false;
			}
		}

		return true;
	};

	var notWhite = function notWhite(color) {
		return color.r !== 1 || color.g !== 1 || color.b !== 1;
	};

	var notBlack = function notBlack(color) {
		return color.r !== 0 || color.g !== 0 || color.b !== 0;
	};

	var StandardMaterialOptionsBuilder = function () {
		function StandardMaterialOptionsBuilder() {
			this._mapXForms = null;
		}

		var _proto = StandardMaterialOptionsBuilder.prototype;

		_proto.updateMinRef = function updateMinRef(options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {
			this._updateSharedOptions(options, scene, stdMat, objDefs, pass);

			this._updateMinOptions(options, stdMat);

			this._updateUVOptions(options, stdMat, objDefs, true);
		};

		_proto.updateRef = function updateRef(options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {
			this._updateSharedOptions(options, scene, stdMat, objDefs, pass);

			this._updateEnvOptions(options, device, stdMat, scene);

			this._updateMaterialOptions(options, stdMat);

			if (pass === SHADER_FORWARDHDR) {
				if (options.gamma) options.gamma = GAMMA_SRGBHDR;
				options.toneMap = TONEMAP_LINEAR;
			}

			options.hasTangents = objDefs && stdMat.normalMap && (objDefs & SHADERDEF_TANGENTS) !== 0;

			this._updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList);

			this._updateUVOptions(options, stdMat, objDefs, false);
		};

		_proto._updateSharedOptions = function _updateSharedOptions(options, scene, stdMat, objDefs, pass) {
			options.pass = pass;
			options.alphaTest = stdMat.alphaTest > 0;
			options.forceFragmentPrecision = stdMat.forceFragmentPrecision || "";
			options.chunks = stdMat.chunks || "";
			options.blendType = stdMat.blendType;
			options.forceUv1 = stdMat.forceUv1;
			options.separateAmbient = false;
			options.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
			options.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
			options.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
			options.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
			options.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
			options.useMorphTextureBased = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0;
			options.nineSlicedMode = stdMat.nineSlicedMode || 0;

			if (scene.clusteredLightingEnabled) {
				options.clusteredLightingEnabled = true;
				options.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
				options.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
				options.clusteredLightingShadowType = scene.lighting.shadowType;
				options.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
			}
		};

		_proto._updateUVOptions = function _updateUVOptions(options, stdMat, objDefs, minimalOptions) {
			var hasUv0 = false;
			var hasUv1 = false;
			var hasVcolor = false;

			if (objDefs) {
				hasUv0 = (objDefs & SHADERDEF_UV0) !== 0;
				hasUv1 = (objDefs & SHADERDEF_UV1) !== 0;
				hasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;
			}

			options.vertexColors = false;
			this._mapXForms = [];

			for (var p in _matTex2D) {
				this._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions);
			}

			this._mapXForms = null;
		};

		_proto._updateMinOptions = function _updateMinOptions(options, stdMat) {
			options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE;
			options.lights = [];
		};

		_proto._updateMaterialOptions = function _updateMaterialOptions(options, stdMat) {
			var diffuseTint = (stdMat.diffuseTint || !stdMat.diffuseMap && !stdMat.diffuseVertexColor) && notWhite(stdMat.diffuse);
			var useSpecular = !!(stdMat.useMetalness || stdMat.specularMap || stdMat.sphereMap || stdMat.cubeMap || notBlack(stdMat.specular) || stdMat.enableGGXSpecular || stdMat.clearCoat > 0);
			var specularTint = useSpecular && !stdMat.useMetalness && (stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && notWhite(stdMat.specular);
			var emissiveTintColor = !stdMat.emissiveMap || notWhite(stdMat.emissive) && stdMat.emissiveTint;
			var emissiveTintIntensity = stdMat.emissiveIntensity !== 1;
			var isPackedNormalMap = stdMat.normalMap ? stdMat.normalMap.format === PIXELFORMAT_DXT5 || stdMat.normalMap.type === TEXTURETYPE_SWIZZLEGGGR : false;
			options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE ? 1 : 0;
			options.blendMapsWithColors = true;
			options.ambientTint = stdMat.ambientTint;
			options.diffuseTint = diffuseTint ? 2 : 0;
			options.specularTint = specularTint ? 2 : 0;
			options.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1 ? 1 : 0;
			options.glossTint = 1;
			options.emissiveTint = (emissiveTintColor ? 2 : 0) + (emissiveTintIntensity ? 1 : 0);
			options.alphaToCoverage = stdMat.alphaToCoverage;
			options.normalizeNormalMap = stdMat.normalizeNormalMap;
			options.ambientSH = !!stdMat.ambientSH;
			options.useSpecular = useSpecular;
			options.emissiveFormat = stdMat.emissiveMap ? stdMat.emissiveMap.type === TEXTURETYPE_RGBM ? 1 : stdMat.emissiveMap.format === PIXELFORMAT_RGBA32F ? 2 : 0 : null;
			options.lightMapFormat = stdMat.lightMap ? stdMat.lightMap.type === TEXTURETYPE_RGBM ? 1 : stdMat.lightMap.format === PIXELFORMAT_RGBA32F ? 2 : 0 : null;
			options.specularAntialias = stdMat.specularAntialias && !!stdMat.normalMap && !!stdMat.normalMap.mipmaps && !isPackedNormalMap;
			options.conserveEnergy = stdMat.conserveEnergy;
			options.opacityFadesSpecular = stdMat.opacityFadesSpecular;
			options.alphaFade = stdMat.alphaFade;
			options.occludeSpecular = stdMat.occludeSpecular;
			options.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1.0;
			options.occludeDirect = stdMat.occludeDirect;
			options.shadingModel = stdMat.shadingModel;
			options.fresnelModel = stdMat.fresnelModel;
			options.packedNormal = isPackedNormalMap;
			options.fastTbn = stdMat.fastTbn;
			options.cubeMapProjection = stdMat.cubeMapProjection;
			options.customFragmentShader = stdMat.customFragmentShader;
			options.refraction = !!stdMat.refraction;
			options.useMetalness = stdMat.useMetalness;
			options.enableGGXSpecular = stdMat.enableGGXSpecular;
			options.msdf = !!stdMat.msdfMap;
			options.twoSidedLighting = stdMat.twoSidedLighting;
			options.pixelSnap = stdMat.pixelSnap;
			options.aoMapUv = stdMat.aoUvSet;
			options.diffuseDetail = !!stdMat.diffuseMap;
			options.normalDetail = !!stdMat.normalMap;
			options.diffuseDetailMode = stdMat.diffuseDetailMode;
			options.detailModes = !!options.diffuseDetail;
			options.clearCoat = !!stdMat.clearCoat;
			options.clearCoatTint = stdMat.clearCoat !== 1.0 ? 1 : 0;
			options.clearCoatGlossiness = !!stdMat.clearCoatGlossiness;
			options.clearCoatGlossTint = stdMat.clearCoatGlossiness !== 1.0 ? 1 : 0;
		};

		_proto._updateEnvOptions = function _updateEnvOptions(options, device, stdMat, scene) {
			options.fog = stdMat.useFog ? scene.fog : "none";
			options.gamma = stdMat.useGammaTonemap ? scene.gammaCorrection : GAMMA_NONE;
			options.toneMap = stdMat.useGammaTonemap ? scene.toneMapping : -1;
			options.useRgbm = stdMat.emissiveMap && stdMat.emissiveMap.type === TEXTURETYPE_RGBM || stdMat.lightMap && stdMat.lightMap.type === TEXTURETYPE_RGBM;
			options.fixSeams = stdMat.cubeMap ? stdMat.cubeMap.fixCubemapSeams : false;
			var isPhong = stdMat.shadingModel === SPECULAR_PHONG;
			var usingSceneEnv = false;

			if (stdMat.envAtlas && !isPhong) {
				options.reflectionSource = 'envAtlas';
				options.reflectionEncoding = stdMat.envAtlas.encoding;
			} else if (stdMat.cubeMap) {
				options.reflectionSource = 'cubeMap';
				options.reflectionEncoding = stdMat.cubeMap.encoding;
			} else if (stdMat.sphereMap) {
				options.reflectionSource = 'sphereMap';
				options.reflectionEncoding = stdMat.sphereMap.encoding;
			} else if (stdMat.useSkybox && scene.envAtlas && !isPhong) {
				options.reflectionSource = 'envAtlas';
				options.reflectionEncoding = scene.envAtlas.encoding;
				usingSceneEnv = true;
			} else {
				options.reflectionSource = null;
				options.reflectionEncoding = null;
			}

			if (stdMat.ambientSH && !isPhong) {
				options.ambientSource = 'ambientSH';
				options.ambientEncoding = null;
			} else {
				var envAtlas = stdMat.envAtlas || (stdMat.useSkybox && scene.envAtlas ? scene.envAtlas : null);

				if (envAtlas && !isPhong) {
					options.ambientSource = 'envAtlas';
					options.ambientEncoding = envAtlas.encoding;
				} else {
					options.ambientSource = 'constant';
					options.ambientEncoding = null;
				}
			}

			options.skyboxIntensity = usingSceneEnv && scene.skyboxIntensity !== 1;
			options.useCubeMapRotation = usingSceneEnv && scene.skyboxRotation && !scene.skyboxRotation.equals(Quat.IDENTITY);
		};

		_proto._updateLightOptions = function _updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList) {
			options.lightMap = false;
			options.lightMapChannel = "";
			options.lightMapUv = 0;
			options.lightMapTransform = 0;
			options.lightMapWithoutAmbient = false;
			options.dirLightMap = false;

			if (objDefs) {
				options.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;

				if ((objDefs & SHADERDEF_LM) !== 0) {
					options.lightMapFormat = 1;
					options.lightMap = true;
					options.lightMapChannel = "rgb";
					options.lightMapUv = 1;
					options.lightMapTransform = 0;
					options.lightMapWithoutAmbient = !stdMat.lightMap;
					options.useRgbm = true;

					if ((objDefs & SHADERDEF_DIRLM) !== 0) {
						options.dirLightMap = true;
					}

					if ((objDefs & SHADERDEF_LMAMBIENT) !== 0) {
						options.lightMapWithoutAmbient = false;
					}
				}
			}

			if (stdMat.useLighting) {
				var lightsFiltered = [];
				var mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
				options.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);

				if (sortedLights) {
					this._collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);

					this._collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask, staticLightList);

					this._collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask, staticLightList);
				}

				options.lights = lightsFiltered;
			} else {
				options.lights = [];
			}

			if (options.lights.length === 0) {
				options.noShadow = true;
			}
		};

		_proto._updateTexOptions = function _updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions) {
			var mname = p + "Map";
			var vname = p + "VertexColor";
			var vcname = p + "VertexColorChannel";
			var cname = mname + "Channel";
			var tname = mname + "Transform";
			var uname = mname + "Uv";

			if (p !== "light") {
				options[mname] = false;
				options[cname] = "";
				options[tname] = 0;
				options[uname] = 0;
			}

			options[vname] = false;
			options[vcname] = "";
			var isOpacity = p === "opacity";
			if (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage) return options;

			if (!minimalOptions || isOpacity) {
				if (p !== "height" && stdMat[vname]) {
					if (hasVcolor) {
						options[vname] = stdMat[vname];
						options[vcname] = stdMat[vcname];
						options.vertexColors = true;
					}
				}

				if (stdMat[mname]) {
					var allow = true;
					if (stdMat[uname] === 0 && !hasUv0) allow = false;
					if (stdMat[uname] === 1 && !hasUv1) allow = false;

					if (allow) {
						options[mname] = !!stdMat[mname];
						options[tname] = this._getMapTransformID(stdMat.getUniform(tname), stdMat[uname]);
						options[cname] = stdMat[cname];
						options[uname] = stdMat[uname];
					}
				}
			}
		};

		_proto._collectLights = function _collectLights(lType, lights, lightsFiltered, mask, staticLightList) {
			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];

				if (light.enabled) {
					if (light.mask & mask) {
						if (lType !== LIGHTTYPE_DIRECTIONAL) {
							if (light.isStatic) {
								continue;
							}
						}

						lightsFiltered.push(light);
					}
				}
			}

			if (staticLightList) {
				for (var _i = 0; _i < staticLightList.length; _i++) {
					var _light = staticLightList[_i];

					if (_light._type === lType) {
						lightsFiltered.push(_light);
					}
				}
			}
		};

		_proto._getMapTransformID = function _getMapTransformID(xform, uv) {
			if (!xform) return 0;
			var xforms = this._mapXForms[uv];

			if (!xforms) {
				xforms = [];
				this._mapXForms[uv] = xforms;
			}

			for (var i = 0; i < xforms.length; i++) {
				if (arraysEqual(xforms[i][0].value, xform[0].value) && arraysEqual(xforms[i][1].value, xform[1].value)) {
					return i + 1;
				}
			}

			return xforms.push(xform);
		};

		return StandardMaterialOptionsBuilder;
	}();

	var standardMaterialParameterTypes = {
		name: 'string',
		chunks: 'chunks',
		mappingFormat: 'string',
		_engine: 'boolean',
		ambient: 'rgb',
		ambientTint: 'boolean',
		aoVertexColor: 'boolean',
		aoVertexColorChannel: 'string',
		aoMap: 'texture',
		aoMapChannel: 'string',
		aoMapUv: 'number',
		aoMapTiling: 'vec2',
		aoMapOffset: 'vec2',
		aoMapRotation: 'number',
		diffuse: 'rgb',
		diffuseTint: 'boolean',
		diffuseVertexColor: 'boolean',
		diffuseVertexColorChannel: 'string',
		diffuseMap: 'texture',
		diffuseMapChannel: 'string',
		diffuseMapUv: 'number',
		diffuseMapTiling: 'vec2',
		diffuseMapOffset: 'vec2',
		diffuseMapRotation: 'number',
		diffuseDetailMap: 'texture',
		diffuseDetailMapChannel: 'string',
		diffuseDetailMapUv: 'number',
		diffuseDetailMapTiling: 'vec2',
		diffuseDetailMapOffset: 'vec2',
		diffuseDetailMapRotation: 'number',
		diffuseDetailMode: 'string',
		specular: 'rgb',
		specularTint: 'boolean',
		specularVertexColor: 'boolean',
		specularVertexColorChannel: 'string',
		specularMap: 'texture',
		specularMapChannel: 'string',
		specularMapUv: 'number',
		specularMapTiling: 'vec2',
		specularMapOffset: 'vec2',
		specularMapRotation: 'number',
		specularAntialias: 'boolean',
		occludeSpecular: 'enum:occludeSpecular',
		useMetalness: 'boolean',
		metalness: 'number',
		enableGGXSpecular: 'boolean',
		anisotropy: 'number',
		metalnessTint: 'boolean',
		metalnessVertexColor: 'boolean',
		metalnessVertexColorChannel: 'string',
		metalnessMap: 'texture',
		metalnessMapChannel: 'string',
		metalnessMapUv: 'number',
		metalnessMapTiling: 'vec2',
		metalnessMapOffset: 'vec2',
		netalnessMapRotation: 'number',
		conserveEnergy: 'boolean',
		shininess: 'number',
		glossVertexColor: 'boolean',
		glossVertexColorChannel: 'string',
		glossMap: 'texture',
		glossMapChannel: 'string',
		glossMapUv: 'number',
		glossMapTiling: 'vec2',
		glossMapOffset: 'vec2',
		glossMapRotation: 'number',
		clearCoat: 'number',
		clearCoatVertexColor: 'boolean',
		clearCoatVertexColorChannel: 'string',
		clearCoatMap: 'texture',
		clearCoatMapChannel: 'string',
		clearCoatMapUv: 'number',
		clearCoatMapTiling: 'vec2',
		clearCoatMapOffset: 'vec2',
		clearCoatMapRotation: 'number',
		clearCoatGlossiness: 'number',
		clearCoatGlossVertexColor: 'boolean',
		clearCoatGlossVertexColorChannel: 'string',
		clearCoatGlossMap: 'texture',
		clearCoatGlossMapChannel: 'string',
		clearCoatGlossMapUv: 'number',
		clearCoatGlossMapTiling: 'vec2',
		clearCoatGlossMapOffset: 'vec2',
		clearCoatGlossMapRotation: 'number',
		clearCoatBumpiness: 'number',
		clearCoatNormalMap: 'texture',
		clearCoatNormalMapUv: 'number',
		clearCoatNormalMapTiling: 'vec2',
		clearCoatNormalMapOffset: 'vec2',
		clearCoatNormalMapRotation: 'number',
		fresnelModel: 'number',
		emissive: 'rgb',
		emissiveTint: 'boolean',
		emissiveVertexColor: 'boolean',
		emissiveVertexColorChannel: 'string',
		emissiveMap: 'texture',
		emissiveMapChannel: 'string',
		emissiveMapUv: 'number',
		emissiveMapTiling: 'vec2',
		emissiveMapOffset: 'vec2',
		emissiveMapMapRotation: 'number',
		emissiveIntensity: 'number',
		normalMap: 'texture',
		normalMapTiling: 'vec2',
		normalMapOffset: 'vec2',
		normalMapRotation: 'number',
		normalMapUv: 'number',
		bumpiness: 'number',
		normalDetailMap: 'texture',
		normalDetailMapTiling: 'vec2',
		normalDetailMapOffset: 'vec2',
		normalDetailMapRotation: 'number',
		normalDetailMapUv: 'number',
		normalDetailMapBumpiness: 'number',
		heightMap: 'texture',
		heightMapChannel: 'string',
		heightMapUv: 'number',
		heightMapTiling: 'vec2',
		heightMapOffset: 'vec2',
		heightMapRotation: 'number',
		heightMapFactor: 'number',
		alphaToCoverage: 'boolean',
		alphaTest: 'number',
		alphaFade: 'number',
		opacity: 'number',
		opacityVertexColor: 'boolean',
		opacityVertexColorChannel: 'string',
		opacityMap: 'texture',
		opacityMapChannel: 'string',
		opacityMapUv: 'number',
		opacityMapTiling: 'vec2',
		opacityMapOffset: 'vec2',
		opacityMapRotation: 'number',
		opacityFadesSpecular: 'boolean',
		reflectivity: 'number',
		refraction: 'number',
		refractionIndex: 'number',
		sphereMap: 'texture',
		cubeMap: 'cubemap',
		cubeMapProjection: 'number',
		cubeMapProjectionBox: 'boundingbox',
		lightVertexColor: 'boolean',
		lightVertexColorChannel: 'string',
		lightMap: 'texture',
		lightMapChannel: 'string',
		lightMapUv: 'number',
		lightMapTiling: 'vec2',
		lightMapOffset: 'vec2',
		lightMapRotation: 'number',
		depthTest: 'boolean',
		depthFunc: 'enum:depthFunc',
		depthWrite: 'boolean',
		depthBias: 'number',
		slopeDepthBias: 'number',
		cull: 'enum:cull',
		blendType: 'enum:blendType',
		shadingModel: 'enum:shadingModel',
		useFog: 'boolean',
		useLighting: 'boolean',
		useSkybox: 'boolean',
		useGammaTonemap: 'boolean',
		envAtlas: 'texture'
	};
	var standardMaterialTextureParameters = [];

	for (var key in standardMaterialParameterTypes) {
		var type = standardMaterialParameterTypes[key];

		if (type === 'texture') {
			standardMaterialTextureParameters.push(key);
		}
	}

	var standardMaterialCubemapParameters = [];

	for (var _key in standardMaterialParameterTypes) {
		var _type = standardMaterialParameterTypes[_key];

		if (_type === 'cubemap') {
			standardMaterialCubemapParameters.push(_key);
		}
	}

	var _props = {};
	var _uniforms = {};

	var _params = new Set();

	var StandardMaterial = function (_Material) {
		_inheritsLoose(StandardMaterial, _Material);

		function StandardMaterial() {
			var _this;

			_this = _Material.call(this) || this;
			_this._dirtyShader = true;
			_this._assetReferences = {};
			_this._activeParams = new Set();
			_this._activeLightingParams = new Set();
			_this.shaderOptBuilder = new StandardMaterialOptionsBuilder();

			_this.reset();

			return _this;
		}

		var _proto = StandardMaterial.prototype;

		_proto.reset = function reset() {
			var _this2 = this;

			Object.keys(_props).forEach(function (name) {
				_this2["_" + name] = _props[name].value();
			});
			this._chunks = {};
			this._uniformCache = {};
		};

		_proto.copy = function copy(source) {
			var _this3 = this;

			_Material.prototype.copy.call(this, source);

			Object.keys(_props).forEach(function (k) {
				_this3[k] = source[k];
			});

			for (var p in source._chunks) {
				if (source._chunks.hasOwnProperty(p)) this._chunks[p] = source._chunks[p];
			}

			return this;
		};

		_proto._setParameter = function _setParameter(name, value) {
			_params.add(name);

			this.setParameter(name, value);
		};

		_proto._setParameters = function _setParameters(parameters) {
			var _this4 = this;

			parameters.forEach(function (v) {
				_this4._setParameter(v.name, v.value);
			});
		};

		_proto._processParameters = function _processParameters(paramsName) {
			var _this5 = this;

			var prevParams = this[paramsName];
			prevParams.forEach(function (param) {
				if (!_params.has(param)) {
					delete _this5.parameters[param];
				}
			});
			this[paramsName] = _params;
			_params = prevParams;

			_params.clear();
		};

		_proto._updateMap = function _updateMap(p) {
			var mname = p + "Map";
			var map = this[mname];

			if (map) {
				this._setParameter("texture_" + mname, map);

				var tname = mname + "Transform";
				var uniform = this.getUniform(tname);

				if (uniform) {
					this._setParameters(uniform);
				}
			}
		};

		_proto._allocUniform = function _allocUniform(name, allocFunc) {
			var uniform = this._uniformCache[name];

			if (!uniform) {
				uniform = allocFunc();
				this._uniformCache[name] = uniform;
			}

			return uniform;
		};

		_proto.getUniform = function getUniform(name, device, scene) {
			return _uniforms[name](this, device, scene);
		};

		_proto.updateUniforms = function updateUniforms(device, scene) {
			var _this6 = this;

			var getUniform = function getUniform(name) {
				return _this6.getUniform(name, device, scene);
			};

			this._setParameter('material_ambient', getUniform('ambient'));

			if (!this.diffuseMap || this.diffuseTint) {
				this._setParameter('material_diffuse', getUniform('diffuse'));
			}

			if (!this.useMetalness) {
				if (!this.specularMap || this.specularTint) {
					this._setParameter('material_specular', getUniform('specular'));
				}
			} else {
				if (!this.metalnessMap || this.metalness < 1) {
					this._setParameter('material_metalness', this.metalness);
				}
			}

			if (this.enableGGXSpecular) {
				this._setParameter('material_anisotropy', this.anisotropy);
			}

			if (this.clearCoat > 0) {
				this._setParameter('material_clearCoat', this.clearCoat);

				this._setParameter('material_clearCoatGlossiness', this.clearCoatGlossiness);

				this._setParameter('material_clearCoatReflectivity', this.clearCoat);

				this._setParameter('material_clearCoatBumpiness', this.clearCoatBumpiness);
			}

			this._setParameter("material_shininess", getUniform('shininess'));

			if (!this.emissiveMap || this.emissiveTint) {
				this._setParameter('material_emissive', getUniform('emissive'));
			}

			if (this.emissiveIntensity !== 1) {
				this._setParameter('material_emissiveIntensity', this.emissiveIntensity);
			}

			if (this.refraction > 0) {
				this._setParameter('material_refraction', this.refraction);

				this._setParameter('material_refractionIndex', this.refractionIndex);
			}

			this._setParameter('material_opacity', this.opacity);

			if (this.opacityFadesSpecular === false) {
				this._setParameter('material_alphaFade', this.alphaFade);
			}

			if (this.occludeSpecular) {
				this._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);
			}

			if (this.cubeMapProjection === CUBEPROJ_BOX) {
				this._setParameter(getUniform("cubeMapProjectionBox"));
			}

			for (var p in _matTex2D) {
				this._updateMap(p);
			}

			if (this.ambientSH) {
				this._setParameter('ambientSH[0]', this.ambientSH);
			}

			if (this.normalMap) {
				this._setParameter('material_bumpiness', this.bumpiness);
			}

			if (this.normalMap && this.normalDetailMap) {
				this._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);
			}

			if (this.heightMap) {
				this._setParameter('material_heightMapFactor', getUniform('heightMapFactor'));
			}

			if (this.cubeMap) {
				this._setParameter('texture_cubeMap', this.cubeMap);
			}

			if (this.sphereMap) {
				this._setParameter('texture_sphereMap', this.sphereMap);
			}

			this._setParameter('material_reflectivity', this.reflectivity);

			this._processParameters('_activeParams');

			if (this._dirtyShader) {
				this.shader = null;
				this.clearVariants();
			}
		};

		_proto.updateEnvUniforms = function updateEnvUniforms(device, scene) {
			var envAtlas = this.envAtlas || (this.useSkybox ? scene.envAtlas : null);

			if (envAtlas) {
				this._setParameter('texture_envAtlas', envAtlas);

				if (this.useSkybox && !scene.skyboxRotation.equals(Quat.IDENTITY) && scene._skyboxRotationMat3) {
					this._setParameter('cubeMapRotationMatrix', scene._skyboxRotationMat3.data);
				}
			}

			this._processParameters('_activeLightingParams');
		};

		_proto.updateShader = function updateShader(device, scene, objDefs, staticLightList, pass, sortedLights) {
			this.updateEnvUniforms(device, scene);
			var minimalOptions = pass > SHADER_FORWARDHDR && pass <= SHADER_PICK;
			var options = minimalOptions ? standard.optionsContextMin : standard.optionsContext;
			if (minimalOptions) this.shaderOptBuilder.updateMinRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights);else this.shaderOptBuilder.updateRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights);

			if (this.onUpdateShader) {
				options = this.onUpdateShader(options);
			}

			var library = device.getProgramLibrary();
			this.shader = library.getProgram('standard', options);

			if (!objDefs) {
				this.clearVariants();
				this.variants[0] = this.shader;
			}

			this._dirtyShader = false;
		};

		_proto.destroy = function destroy() {
			for (var asset in this._assetReferences) {
				this._assetReferences[asset]._unbind();
			}

			this._assetReferences = null;

			_Material.prototype.destroy.call(this);
		};

		_createClass(StandardMaterial, [{
			key: "chunks",
			get: function get() {
				this._dirtyShader = true;
				return this._chunks;
			},
			set: function set(value) {
				this._dirtyShader = true;
				this._chunks = value;
			}
		}]);

		return StandardMaterial;
	}(Material);

	StandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;
	StandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;

	var defineUniform = function defineUniform(name, getUniformFunc) {
		_uniforms[name] = getUniformFunc;
	};

	var definePropInternal = function definePropInternal(name, constructorFunc, setterFunc, getterFunc) {
		Object.defineProperty(StandardMaterial.prototype, name, {
			get: getterFunc || function () {
				return this["_" + name];
			},
			set: setterFunc
		});
		_props[name] = {
			value: constructorFunc
		};
	};

	var defineValueProp = function defineValueProp(prop) {
		var internalName = "_" + prop.name;

		var dirtyShaderFunc = prop.dirtyShaderFunc || function () {
			return true;
		};

		var setterFunc = function setterFunc(value) {
			var oldValue = this[internalName];

			if (oldValue !== value) {
				this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
				this[internalName] = value;
			}
		};

		definePropInternal(prop.name, function () {
			return prop.defaultValue;
		}, setterFunc, prop.getterFunc);
	};

	var defineAggProp = function defineAggProp(prop) {
		var internalName = "_" + prop.name;

		var dirtyShaderFunc = prop.dirtyShaderFunc || function () {
			return true;
		};

		var setterFunc = function setterFunc(value) {
			var oldValue = this[internalName];

			if (!oldValue.equals(value)) {
				this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
				this[internalName] = oldValue.copy(value);
			}
		};

		definePropInternal(prop.name, function () {
			return prop.defaultValue.clone();
		}, setterFunc, prop.getterFunc);
	};

	var defineProp = function defineProp(prop) {
		return prop.defaultValue && prop.defaultValue.clone ? defineAggProp(prop) : defineValueProp(prop);
	};

	function _defineTex2D(name, uv, channels, defChannel, vertexColor, detailMode) {
		_matTex2D[name] = channels;
		defineProp({
			name: name + "Map",
			defaultValue: null,
			dirtyShaderFunc: function dirtyShaderFunc(oldValue, newValue) {
				return !!oldValue !== !!newValue || oldValue && (oldValue.type !== newValue.type || oldValue.fixCubemapSeams !== newValue.fixCubemapSeams || oldValue.format !== newValue.format);
			}
		});
		defineProp({
			name: name + "MapTiling",
			defaultValue: new Vec2(1, 1)
		});
		defineProp({
			name: name + "MapOffset",
			defaultValue: new Vec2(0, 0)
		});
		defineProp({
			name: name + "MapRotation",
			defaultValue: 0
		});
		defineProp({
			name: name + "MapUv",
			defaultValue: uv
		});

		if (channels > 0) {
			defineProp({
				name: name + "MapChannel",
				defaultValue: defChannel ? defChannel : channels > 1 ? "rgb" : "g"
			});
		}

		if (vertexColor) {
			defineProp({
				name: name + "VertexColor",
				defaultValue: false
			});

			if (channels > 0) {
				defineProp({
					name: name + "VertexColorChannel",
					defaultValue: defChannel ? defChannel : channels > 1 ? "rgb" : "g"
				});
			}
		}

		if (detailMode) {
			defineProp({
				name: name + "Mode",
				defaultValue: DETAILMODE_MUL
			});
		}

		var mapTiling = name + "MapTiling";
		var mapOffset = name + "MapOffset";
		var mapRotation = name + "MapRotation";
		var mapTransform = name + "MapTransform";
		defineUniform(mapTransform, function (material, device, scene) {
			var tiling = material[mapTiling];
			var offset = material[mapOffset];
			var rotation = material[mapRotation];

			if (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0 && rotation === 0) {
				return null;
			}

			var uniform = material._allocUniform(mapTransform, function () {
				return [{
					name: "texture_" + mapTransform + "0",
					value: new Float32Array(3)
				}, {
					name: "texture_" + mapTransform + "1",
					value: new Float32Array(3)
				}];
			});

			var cr = Math.cos(rotation * math.DEG_TO_RAD);
			var sr = Math.sin(rotation * math.DEG_TO_RAD);
			var uniform0 = uniform[0].value;
			uniform0[0] = cr * tiling.x;
			uniform0[1] = -sr * tiling.y;
			uniform0[2] = offset.x;
			var uniform1 = uniform[1].value;
			uniform1[0] = sr * tiling.x;
			uniform1[1] = cr * tiling.y;
			uniform1[2] = 1.0 - tiling.y - offset.y;
			return uniform;
		});
	}

	function _defineColor(name, defaultValue) {
		defineProp({
			name: name,
			defaultValue: defaultValue,
			getterFunc: function getterFunc() {
				this._dirtyShader = true;
				return this["_" + name];
			}
		});
		defineUniform(name, function (material, device, scene) {
			var uniform = material._allocUniform(name, function () {
				return new Float32Array(3);
			});

			var color = material[name];
			var gamma = material.useGammaTonemap && scene.gammaCorrection;

			if (gamma) {
				uniform[0] = Math.pow(color.r, 2.2);
				uniform[1] = Math.pow(color.g, 2.2);
				uniform[2] = Math.pow(color.b, 2.2);
			} else {
				uniform[0] = color.r;
				uniform[1] = color.g;
				uniform[2] = color.b;
			}

			return uniform;
		});
	}

	function _defineFloat(name, defaultValue, getUniformFunc) {
		defineProp({
			name: name,
			defaultValue: defaultValue,
			dirtyShaderFunc: function dirtyShaderFunc(oldValue, newValue) {
				return (oldValue === 0 || oldValue === 1) !== (newValue === 0 || newValue === 1);
			}
		});
		defineUniform(name, getUniformFunc);
	}

	function _defineObject(name, getUniformFunc) {
		defineProp({
			name: name,
			defaultValue: null,
			dirtyShaderFunc: function dirtyShaderFunc(oldValue, newValue) {
				return !!oldValue === !!newValue;
			}
		});
		defineUniform(name, getUniformFunc);
	}

	function _defineFlag(name, defaultValue) {
		defineProp({
			name: name,
			defaultValue: defaultValue
		});
	}

	function _defineMaterialProps() {
		_defineColor("ambient", new Color(0.7, 0.7, 0.7));

		_defineColor("diffuse", new Color(1, 1, 1));

		_defineColor("specular", new Color(0, 0, 0));

		_defineColor("emissive", new Color(0, 0, 0));

		_defineFloat("emissiveIntensity", 1);

		_defineFloat("shininess", 25, function (material, device, scene) {
			return material.shadingModel === SPECULAR_PHONG ? Math.pow(2, material.shininess * 0.01 * 11) : material.shininess * 0.01;
		});

		_defineFloat("heightMapFactor", 1, function (material, device, scene) {
			return material.heightMapFactor * 0.025;
		});

		_defineFloat("opacity", 1);

		_defineFloat("alphaFade", 1);

		_defineFloat("alphaTest", 0);

		_defineFloat("bumpiness", 1);

		_defineFloat("normalDetailMapBumpiness", 1);

		_defineFloat("reflectivity", 1);

		_defineFloat("occludeSpecularIntensity", 1);

		_defineFloat("refraction", 0);

		_defineFloat("refractionIndex", 1.0 / 1.5);

		_defineFloat("metalness", 1);

		_defineFloat("anisotropy", 0);

		_defineFloat("clearCoat", 0);

		_defineFloat("clearCoatGlossiness", 1);

		_defineFloat("clearCoatBumpiness", 1);

		_defineFloat("aoUvSet", 0, null);

		_defineObject("ambientSH");

		_defineObject("cubeMapProjectionBox", function (material, device, scene) {
			var uniform = material._allocUniform('cubeMapProjectionBox', function () {
				return [{
					name: 'envBoxMin',
					value: new Float32Array(3)
				}, {
					name: 'envBoxMax',
					value: new Float32Array(3)
				}];
			});

			var bboxMin = material.cubeMapProjectionBox.getMin();
			var minUniform = uniform[0].value;
			minUniform[0] = bboxMin.x;
			minUniform[1] = bboxMin.y;
			minUniform[2] = bboxMin.z;
			var bboxMax = material.cubeMapProjectionBox.getMax();
			var maxUniform = uniform[1].value;
			maxUniform[0] = bboxMax.x;
			maxUniform[1] = bboxMax.y;
			maxUniform[2] = bboxMax.z;
			return uniform;
		});

		_defineFlag("ambientTint", false);

		_defineFlag("diffuseTint", false);

		_defineFlag("specularTint", false);

		_defineFlag("emissiveTint", false);

		_defineFlag("fastTbn", false);

		_defineFlag("specularAntialias", false);

		_defineFlag("useMetalness", false);

		_defineFlag("enableGGXSpecular", false);

		_defineFlag("occludeDirect", false);

		_defineFlag("normalizeNormalMap", true);

		_defineFlag("conserveEnergy", true);

		_defineFlag("opacityFadesSpecular", true);

		_defineFlag("occludeSpecular", SPECOCC_AO);

		_defineFlag("shadingModel", SPECULAR_BLINN);

		_defineFlag("fresnelModel", FRESNEL_SCHLICK);

		_defineFlag("cubeMapProjection", CUBEPROJ_NONE);

		_defineFlag("customFragmentShader", null);

		_defineFlag("forceFragmentPrecision", null);

		_defineFlag("useFog", true);

		_defineFlag("useLighting", true);

		_defineFlag("useGammaTonemap", true);

		_defineFlag("useSkybox", true);

		_defineFlag("forceUv1", false);

		_defineFlag("pixelSnap", false);

		_defineFlag("twoSidedLighting", false);

		_defineFlag("nineSlicedMode", undefined);

		_defineTex2D("diffuse", 0, 3, "", true);

		_defineTex2D("specular", 0, 3, "", true);

		_defineTex2D("emissive", 0, 3, "", true);

		_defineTex2D("normal", 0, -1, "", false);

		_defineTex2D("metalness", 0, 1, "", true);

		_defineTex2D("gloss", 0, 1, "", true);

		_defineTex2D("opacity", 0, 1, "a", true);

		_defineTex2D("height", 0, 1, "", false);

		_defineTex2D("ao", 0, 1, "", true);

		_defineTex2D("light", 1, 3, "", true);

		_defineTex2D("msdf", 0, 3, "", false);

		_defineTex2D("diffuseDetail", 0, 3, "", false, true);

		_defineTex2D("normalDetail", 0, -1, "", false);

		_defineTex2D("clearCoat", 0, 1, "", true);

		_defineTex2D("clearCoatGloss", 0, 1, "", true);

		_defineTex2D("clearCoatNormal", 0, -1, "", false);

		_defineObject("cubeMap");

		_defineObject("sphereMap");

		_defineObject("envAtlas");

		var getterFunc = function getterFunc() {
			return this._prefilteredCubemaps;
		};

		var setterFunc = function setterFunc(value) {
			var cubemaps = this._prefilteredCubemaps;
			value = value || [];
			var changed = false;
			var complete = true;

			for (var i = 0; i < 6; ++i) {
				var v = value[i] || null;

				if (cubemaps[i] !== v) {
					cubemaps[i] = v;
					changed = true;
				}

				complete = complete && !!cubemaps[i];
			}

			if (changed) {
				if (complete) {
					this.envAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {
						target: this.envAtlas
					});
				} else {
					if (this.envAtlas) {
						this.envAtlas.destroy();
						this.envAtlas = null;
					}
				}

				this._dirtyShader = true;
			}
		};

		var empty = [null, null, null, null, null, null];
		definePropInternal("prefilteredCubemaps", function () {
			return empty.slice();
		}, setterFunc, getterFunc);
	}

	_defineMaterialProps();

	var ProgramLibrary = function () {
		function ProgramLibrary(device) {
			this._device = device;
			this._cache = {};
			this._generators = {};
			this._isClearingCache = false;
			this._precached = false;
			this._programsCollection = [];
			this._defaultStdMatOption = {};
			this._defaultStdMatOptionMin = {};
			var m = new StandardMaterial();
			m.shaderOptBuilder.updateRef(this._defaultStdMatOption, device, {}, m, null, [], SHADER_FORWARD, null, null);
			m.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, device, {}, m, null, [], SHADER_SHADOW, null, null);
		}

		var _proto = ProgramLibrary.prototype;

		_proto.register = function register(name, generator) {
			if (!this.isRegistered(name)) {
				this._generators[name] = generator;
			}
		};

		_proto.unregister = function unregister(name) {
			if (this.isRegistered(name)) {
				delete this._generators[name];
			}
		};

		_proto.isRegistered = function isRegistered(name) {
			var generator = this._generators[name];
			return generator !== undefined;
		};

		_proto.getProgram = function getProgram(name, options) {
			var generator = this._generators[name];

			if (generator === undefined) {
				Debug.warn("ProgramLibrary#getProgram: No program library functions registered for: " + name);
				return null;
			}

			var gd = this._device;
			var key = generator.generateKey(options);
			var shader = this._cache[key];

			if (!shader) {
				var lights;

				if (options.lights) {
					lights = options.lights;
					options.lights = lights.map(function (l) {
						var lcopy = l.clone ? l.clone() : l;
						lcopy.key = l.key;
						return lcopy;
					});
				}

				this.storeNewProgram(name, options);
				if (options.lights) options.lights = lights;
				if (this._precached) console.warn("ProgramLibrary#getProgram: Cache miss for shader " + name + " key " + key + " after shaders precaching");
				var shaderDefinition = generator.createShaderDefinition(gd, options);
				shader = this._cache[key] = new Shader(gd, shaderDefinition);
			}

			return shader;
		};

		_proto.storeNewProgram = function storeNewProgram(name, options) {
			var opt = {};

			if (name === "standard") {
				var defaultMat = this._getDefaultStdMatOptions(options.pass);

				for (var p in options) {
					if (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === "pass") opt[p] = options[p];
				}
			} else {
				opt = options;
			}

			this._programsCollection.push(JSON.stringify({
				name: name,
				options: opt
			}));
		};

		_proto.dumpPrograms = function dumpPrograms() {
			var text = 'let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n';
			text += 'let shaders = [';
			if (this._programsCollection[0]) text += '\n\t' + this._programsCollection[0];

			for (var i = 1; i < this._programsCollection.length; ++i) {
				text += ',\n\t' + this._programsCollection[i];
			}

			text += '\n];\n';
			text += 'device.programLib.precompile(shaders);\n';
			text += 'if (pc.version != \"' + version + '\" || pc.revision != \"' + revision + '\")\n';
			text += '\tconsole.warn(\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\");';
			var element = document.createElement('a');
			element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
			element.setAttribute('download', 'precompile-shaders.js');
			element.style.display = 'none';
			document.body.appendChild(element);
			element.click();
			document.body.removeChild(element);
		};

		_proto.clearCache = function clearCache() {
			var cache = this._cache;
			this._isClearingCache = true;

			for (var key in cache) {
				if (cache.hasOwnProperty(key)) {
					cache[key].destroy();
				}
			}

			this._cache = {};
			this._isClearingCache = false;
		};

		_proto.removeFromCache = function removeFromCache(shader) {
			if (this._isClearingCache) return;
			var cache = this._cache;

			for (var key in cache) {
				if (cache.hasOwnProperty(key)) {
					if (cache[key] === shader) {
						delete cache[key];
						break;
					}
				}
			}
		};

		_proto._getDefaultStdMatOptions = function _getDefaultStdMatOptions(pass) {
			return pass > SHADER_FORWARDHDR && pass <= SHADER_PICK ? this._defaultStdMatOptionMin : this._defaultStdMatOption;
		};

		_proto.precompile = function precompile(cache) {
			if (cache) {
				var shaders = new Array(cache.length);

				for (var i = 0; i < cache.length; i++) {
					if (cache[i].name === "standard") {
						var opt = cache[i].options;

						var defaultMat = this._getDefaultStdMatOptions(opt.pass);

						for (var p in defaultMat) {
							if (defaultMat.hasOwnProperty(p) && opt[p] === undefined) opt[p] = defaultMat[p];
						}
					}

					shaders[i] = this.getProgram(cache[i].name, cache[i].options);
				}
			}

			this._precached = true;
		};

		return ProgramLibrary;
	}();

	var EVENT_RESIZE = 'resizecanvas';

	var GraphicsDevice = function (_EventHandler) {
		_inheritsLoose(GraphicsDevice, _EventHandler);

		function GraphicsDevice(canvas) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.canvas = void 0;
			_this.scope = void 0;
			_this.maxAnisotropy = void 0;
			_this.maxCubeMapSize = void 0;
			_this.maxTextureSize = void 0;
			_this.maxVolumeSize = void 0;
			_this.precision = void 0;
			_this.supportsInstancing = void 0;
			_this.textureFloatRenderable = void 0;
			_this.textureHalfFloatRenderable = void 0;
			_this.canvas = canvas;
			_this._width = 0;
			_this._height = 0;
			_this._maxPixelRatio = 1;
			_this.shaders = [];
			_this.buffers = [];
			_this.textures = [];
			_this.targets = [];
			_this._vram = {
				texShadow: 0,
				texAsset: 0,
				texLightmap: 0,
				tex: 0,
				vb: 0,
				ib: 0
			};
			_this._shaderStats = {
				vsCompiled: 0,
				fsCompiled: 0,
				linked: 0,
				materialShaders: 0,
				compileTime: 0
			};

			_this.initializeContextCaches();

			_this._drawCallsPerFrame = 0;
			_this._shaderSwitchesPerFrame = 0;
			_this._primsPerFrame = [];

			for (var i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++) {
				_this._primsPerFrame[i] = 0;
			}

			_this._renderTargetCreationTime = 0;
			_this.scope = new ScopeSpace("Device");
			_this.programLib = new ProgramLibrary(_assertThisInitialized(_this));

			for (var generator in programlib) {
				_this.programLib.register(generator, programlib[generator]);
			}

			return _this;
		}

		var _proto = GraphicsDevice.prototype;

		_proto.destroy = function destroy() {
			this.fire('destroy');
		};

		_proto.postDestroy = function postDestroy() {
			this.scope = null;
			this.canvas = null;
		};

		_proto.toJSON = function toJSON(key) {
			return undefined;
		};

		_proto.initializeContextCaches = function initializeContextCaches() {
			this.indexBuffer = null;
			this.vertexBuffers = [];
			this.shader = null;
			this.renderTarget = null;
		};

		_proto.getProgramLibrary = function getProgramLibrary() {
			return this.programLib;
		};

		_proto.setProgramLibrary = function setProgramLibrary(programLib) {
			this.programLib = programLib;
		};

		_proto.setRenderTarget = function setRenderTarget(renderTarget) {
			this.renderTarget = renderTarget;
		};

		_proto.getRenderTarget = function getRenderTarget() {
			return this.renderTarget;
		};

		_proto._isBrowserInterface = function _isBrowserInterface(texture) {
			return typeof HTMLCanvasElement !== 'undefined' && texture instanceof HTMLCanvasElement || typeof HTMLImageElement !== 'undefined' && texture instanceof HTMLImageElement || typeof HTMLVideoElement !== 'undefined' && texture instanceof HTMLVideoElement || typeof ImageBitmap !== 'undefined' && texture instanceof ImageBitmap;
		};

		_proto.resizeCanvas = function resizeCanvas(width, height) {
			this._width = width;
			this._height = height;
			var ratio = Math.min(this._maxPixelRatio, platform.browser ? window.devicePixelRatio : 1);
			width = Math.floor(width * ratio);
			height = Math.floor(height * ratio);

			if (this.canvas.width !== width || this.canvas.height !== height) {
				this.canvas.width = width;
				this.canvas.height = height;
				this.fire(EVENT_RESIZE, width, height);
			}
		};

		_proto.setResolution = function setResolution(width, height) {
			this._width = width;
			this._height = height;
			this.canvas.width = width;
			this.canvas.height = height;
			this.fire(EVENT_RESIZE, width, height);
		};

		_proto.updateClientRect = function updateClientRect() {
			this.clientRect = this.canvas.getBoundingClientRect();
		};

		_createClass(GraphicsDevice, [{
			key: "width",
			get: function get() {
				Debug.error("GraphicsDevice.width is not implemented on current device.");
				return this.canvas.width;
			}
		}, {
			key: "height",
			get: function get() {
				Debug.error("GraphicsDevice.height is not implemented on current device.");
				return this.canvas.height;
			}
		}, {
			key: "fullscreen",
			get: function get() {
				Debug.error("GraphicsDevice.fullscreen is not implemented on current device.");
				return false;
			},
			set: function set(fullscreen) {
				Debug.error("GraphicsDevice.fullscreen is not implemented on current device.");
			}
		}, {
			key: "maxPixelRatio",
			get: function get() {
				return this._maxPixelRatio;
			},
			set: function set(ratio) {
				this._maxPixelRatio = ratio;
				this.resizeCanvas(this._width, this._height);
			}
		}]);

		return GraphicsDevice;
	}(EventHandler);

	var defaultOptions = {
		depth: true,
		face: 0
	};

	var RenderTarget = function () {
		function RenderTarget(options) {
			var _this$_colorBuffer, _this$_depthBuffer;

			var _arg2 = arguments[1];
			var _arg3 = arguments[2];

			if (options instanceof GraphicsDevice) {
				this._colorBuffer = _arg2;
				options = _arg3;
				Debug.deprecated('pc.RenderTarget constructor no longer accepts GraphicsDevice parameter.');
			} else {
				this._colorBuffer = options.colorBuffer;
			}

			if (this._colorBuffer) {
				this._colorBuffer._isRenderTarget = true;
			}

			options = options !== undefined ? options : defaultOptions;
			this._depthBuffer = options.depthBuffer;
			this._face = options.face !== undefined ? options.face : 0;

			if (this._depthBuffer) {
				var format = this._depthBuffer._format;

				if (format === PIXELFORMAT_DEPTH) {
					this._depth = true;
					this._stencil = false;
				} else if (format === PIXELFORMAT_DEPTHSTENCIL) {
					this._depth = true;
					this._stencil = true;
				} else {
					Debug.warn('Incorrect depthBuffer format. Must be pc.PIXELFORMAT_DEPTH or pc.PIXELFORMAT_DEPTHSTENCIL');
					this._depth = false;
					this._stencil = false;
				}
			} else {
				this._depth = options.depth !== undefined ? options.depth : true;
				this._stencil = options.stencil !== undefined ? options.stencil : false;
			}

			this._device = ((_this$_colorBuffer = this._colorBuffer) == null ? void 0 : _this$_colorBuffer.device) || ((_this$_depthBuffer = this._depthBuffer) == null ? void 0 : _this$_depthBuffer.device);
			Debug.assert(this._device, "Failed to obtain the device, colorBuffer nor depthBuffer store it.");
			this._samples = options.samples !== undefined ? Math.min(options.samples, this._device.maxSamples) : 1;
			this.autoResolve = options.autoResolve !== undefined ? options.autoResolve : true;
			this.name = options.name;

			if (!this.name) {
				var _this$_colorBuffer2;

				this.name = (_this$_colorBuffer2 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer2.name;
			}

			if (!this.name) {
				var _this$_depthBuffer2;

				this.name = (_this$_depthBuffer2 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer2.name;
			}

			if (!this.name) {
				this.name = "Untitled";
			}

			this.flipY = !!options.flipY;
			this.impl = this._device.createRenderTargetImpl(this);
		}

		var _proto = RenderTarget.prototype;

		_proto.destroy = function destroy() {
			var device = this._device;

			if (device) {
				var idx = device.targets.indexOf(this);

				if (idx !== -1) {
					device.targets.splice(idx, 1);
				}

				this.destroyFrameBuffers();
			}
		};

		_proto.destroyFrameBuffers = function destroyFrameBuffers() {
			var device = this._device;

			if (device) {
				this.impl.destroy(device);
			}
		};

		_proto.destroyTextureBuffers = function destroyTextureBuffers() {
			if (this._depthBuffer) {
				this._depthBuffer.destroy();

				this._depthBuffer = null;
			}

			if (this._colorBuffer) {
				this._colorBuffer.destroy();

				this._colorBuffer = null;
			}
		};

		_proto.init = function init() {
			this.impl.init(this._device, this);
		};

		_proto.loseContext = function loseContext() {
			this.impl.loseContext();
		};

		_proto.resolve = function resolve(color, depth) {
			if (color === void 0) {
				color = true;
			}

			if (depth === void 0) {
				depth = !!this._depthBuffer;
			}

			if (this._device) {
				this.impl.resolve(this._device, this, color, depth);
			}
		};

		_proto.copy = function copy(source, color, depth) {
			if (!this._device) {
				if (source._device) {
					this._device = source._device;
				} else {
					Debug.error("Render targets are not initialized");
					return false;
				}
			}

			return this._device.copyRenderTarget(source, this, color, depth);
		};

		_createClass(RenderTarget, [{
			key: "colorBuffer",
			get: function get() {
				return this._colorBuffer;
			}
		}, {
			key: "depthBuffer",
			get: function get() {
				return this._depthBuffer;
			}
		}, {
			key: "face",
			get: function get() {
				return this._face;
			}
		}, {
			key: "width",
			get: function get() {
				return this._colorBuffer ? this._colorBuffer.width : this._depthBuffer.width;
			}
		}, {
			key: "height",
			get: function get() {
				return this._colorBuffer ? this._colorBuffer.height : this._depthBuffer.height;
			}
		}]);

		return RenderTarget;
	}();

	function areaElement(x, y) {
		return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
	}

	function texelCoordSolidAngle(u, v, size) {
		var _u = 2.0 * (u + 0.5) / size - 1.0;

		var _v = 2.0 * (v + 0.5) / size - 1.0;

		_u *= 1.0 - 1.0 / size;
		_v *= 1.0 - 1.0 / size;
		var invResolution = 1.0 / size;
		var x0 = _u - invResolution;
		var y0 = _v - invResolution;
		var x1 = _u + invResolution;
		var y1 = _v + invResolution;
		var solidAngle = areaElement(x0, y0) - areaElement(x0, y1) - areaElement(x1, y0) + areaElement(x1, y1);

		if (u === 0 && v === 0 || u === size - 1 && v === 0 || u === 0 && v === size - 1 || u === size - 1 && v === size - 1) {
			solidAngle /= 3;
		} else if (u === 0 || v === 0 || u === size - 1 || v === size - 1) {
			solidAngle *= 0.5;
		}

		return solidAngle;
	}

	function shFromCubemap(device, source, dontFlipX) {
		if (source.format !== PIXELFORMAT_R8_G8_B8_A8) {
			Debug.error("ERROR: SH: cubemap must be RGBA8");
			return null;
		}

		if (!source._levels[0] || !source._levels[0][0]) {
			Debug.error("ERROR: SH: cubemap must be synced to CPU");
			return null;
		}

		var cubeSize = source.width;

		if (!source._levels[0][0].length) {
			if (source._levels[0][0] instanceof HTMLImageElement) {
				var shader = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.fullscreenQuadPS, "fsQuadSimple");
				var constantTexSource = device.scope.resolve("source");

				for (var face = 0; face < 6; face++) {
					var img = source._levels[0][face];
					var tex = new Texture(device, {
						cubemap: false,
						type: TEXTURETYPE_DEFAULT,
						format: source.format,
						width: cubeSize,
						height: cubeSize,
						mipmaps: false
					});
					tex.name = 'prefiltered-cube';
					tex._levels[0] = img;
					tex.upload();
					var tex2 = new Texture(device, {
						cubemap: false,
						type: TEXTURETYPE_DEFAULT,
						format: source.format,
						width: cubeSize,
						height: cubeSize,
						mipmaps: false
					});
					tex2.name = 'prefiltered-cube';
					var targ = new RenderTarget({
						colorBuffer: tex2,
						depth: false
					});
					constantTexSource.setValue(tex);
					drawQuadWithShader(device, targ, shader);
					var gl = device.gl;
					gl.bindFramebuffer(gl.FRAMEBUFFER, targ.impl._glFrameBuffer);
					var pixels = new Uint8Array(cubeSize * cubeSize * 4);
					gl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
					source._levels[0][face] = pixels;
				}
			} else {
				Debug.error("ERROR: SH: cubemap must be composed of arrays or images");
				return null;
			}
		}

		var dirs = [];

		for (var y = 0; y < cubeSize; y++) {
			for (var x = 0; x < cubeSize; x++) {
				var u = x / (cubeSize - 1) * 2 - 1;
				var v = y / (cubeSize - 1) * 2 - 1;
				dirs[y * cubeSize + x] = new Vec3(u, v, 1.0).normalize();
			}
		}

		var sh = new Float32Array(9 * 3);
		var coef1 = 0;
		var coef2 = 1 * 3;
		var coef3 = 2 * 3;
		var coef4 = 3 * 3;
		var coef5 = 4 * 3;
		var coef6 = 5 * 3;
		var coef7 = 6 * 3;
		var coef8 = 7 * 3;
		var coef9 = 8 * 3;
		var nx = 0;
		var px = 1;
		var ny = 2;
		var py = 3;
		var nz = 4;
		var pz = 5;
		var accum = 0;

		for (var _face = 0; _face < 6; _face++) {
			for (var _y = 0; _y < cubeSize; _y++) {
				for (var _x = 0; _x < cubeSize; _x++) {
					var addr = _y * cubeSize + _x;
					var weight = texelCoordSolidAngle(_x, _y, cubeSize);
					var weight1 = weight * 4 / 17;
					var weight2 = weight * 8 / 17;
					var weight3 = weight * 15 / 17;
					var weight4 = weight * 5 / 68;
					var weight5 = weight * 15 / 68;
					var dir = dirs[addr];
					var dx = void 0,
							dy = void 0,
							dz = void 0;

					if (_face === nx) {
						dx = dir.z;
						dy = -dir.y;
						dz = -dir.x;
					} else if (_face === px) {
						dx = -dir.z;
						dy = -dir.y;
						dz = dir.x;
					} else if (_face === ny) {
						dx = dir.x;
						dy = dir.z;
						dz = dir.y;
					} else if (_face === py) {
						dx = dir.x;
						dy = -dir.z;
						dz = -dir.y;
					} else if (_face === nz) {
						dx = dir.x;
						dy = -dir.y;
						dz = dir.z;
					} else if (_face === pz) {
						dx = -dir.x;
						dy = -dir.y;
						dz = -dir.z;
					}

					if (!dontFlipX) dx = -dx;
					var a = source._levels[0][_face][addr * 4 + 3] / 255.0;

					for (var c = 0; c < 3; c++) {
						var value = source._levels[0][_face][addr * 4 + c] / 255.0;

						if (source.type === TEXTURETYPE_RGBM) {
							value *= a * 8.0;
							value *= value;
						} else {
							value = Math.pow(value, 2.2);
						}

						sh[coef1 + c] += value * weight1;
						sh[coef2 + c] += value * weight2 * dx;
						sh[coef3 + c] += value * weight2 * dy;
						sh[coef4 + c] += value * weight2 * dz;
						sh[coef5 + c] += value * weight3 * dx * dz;
						sh[coef6 + c] += value * weight3 * dz * dy;
						sh[coef7 + c] += value * weight3 * dy * dx;
						sh[coef8 + c] += value * weight4 * (3.0 * dz * dz - 1.0);
						sh[coef9 + c] += value * weight5 * (dx * dx - dy * dy);
						accum += weight;
					}
				}
			}
		}

		for (var _c = 0; _c < sh.length; _c++) {
			sh[_c] *= 4 * Math.PI / accum;
		}

		return sh;
	}

	var IndexBuffer = function () {
		function IndexBuffer(graphicsDevice, format, numIndices, usage, initialData) {
			if (usage === void 0) {
				usage = BUFFER_STATIC;
			}

			this.device = graphicsDevice;
			this.format = format;
			this.numIndices = numIndices;
			this.usage = usage;
			this.impl = graphicsDevice.createIndexBufferImpl(this);
			var bytesPerIndex = typedArrayIndexFormatsByteSize[format];
			this.bytesPerIndex = bytesPerIndex;
			this.numBytes = this.numIndices * bytesPerIndex;

			if (initialData) {
				this.setData(initialData);
			} else {
				this.storage = new ArrayBuffer(this.numBytes);
			}

			graphicsDevice._vram.ib += this.numBytes;
			this.device.buffers.push(this);
		}

		var _proto = IndexBuffer.prototype;

		_proto.destroy = function destroy() {
			var device = this.device;
			var idx = device.buffers.indexOf(this);

			if (idx !== -1) {
				device.buffers.splice(idx, 1);
			}

			if (this.device.indexBuffer === this) {
				this.device.indexBuffer = null;
			}

			this.impl.destroy(device);
			this.device._vram.ib -= this.storage.byteLength;
		};

		_proto.loseContext = function loseContext() {
			this.impl.loseContext();
		};

		_proto.getFormat = function getFormat() {
			return this.format;
		};

		_proto.getNumIndices = function getNumIndices() {
			return this.numIndices;
		};

		_proto.lock = function lock() {
			return this.storage;
		};

		_proto.unlock = function unlock() {
			this.impl.unlock(this);
		};

		_proto.setData = function setData(data) {
			if (data.byteLength !== this.numBytes) {
				Debug.error("IndexBuffer: wrong initial data size: expected " + this.numBytes + ", got " + data.byteLength);
				return false;
			}

			this.storage = data;
			this.unlock();
			return true;
		};

		_proto._lockTypedArray = function _lockTypedArray() {
			var lock = this.lock();
			var indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) : this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock);
			return indices;
		};

		_proto.writeData = function writeData(data, count) {
			var indices = this._lockTypedArray();

			if (data.length > count) {
				if (ArrayBuffer.isView(data)) {
					data = data.subarray(0, count);
					indices.set(data);
				} else {
					for (var i = 0; i < count; i++) {
						indices[i] = data[i];
					}
				}
			} else {
				indices.set(data);
			}

			this.unlock();
		};

		_proto.readData = function readData(data) {
			var indices = this._lockTypedArray();

			var count = this.numIndices;

			if (ArrayBuffer.isView(data)) {
				data.set(indices);
			} else {
				data.length = 0;

				for (var i = 0; i < count; i++) {
					data[i] = indices[i];
				}
			}

			return count;
		};

		return IndexBuffer;
	}();

	function set1(a) {
		this.array[this.index] = a;
	}

	function set2(a, b) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
	}

	function set3(a, b, c) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
		this.array[this.index + 2] = c;
	}

	function set4(a, b, c, d) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
		this.array[this.index + 2] = c;
		this.array[this.index + 3] = d;
	}

	function arraySet1(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
	}

	function arraySet2(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
	}

	function arraySet3(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
		this.array[index + 2] = inputArray[inputIndex + 2];
	}

	function arraySet4(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
		this.array[index + 2] = inputArray[inputIndex + 2];
		this.array[index + 3] = inputArray[inputIndex + 3];
	}

	function arrayGet1(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
	}

	function arrayGet2(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
	}

	function arrayGet3(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
		outputArray[outputIndex + 2] = this.array[offset + 2];
	}

	function arrayGet4(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
		outputArray[outputIndex + 2] = this.array[offset + 2];
		outputArray[outputIndex + 3] = this.array[offset + 3];
	}

	var VertexIteratorAccessor = function () {
		function VertexIteratorAccessor(buffer, vertexElement, vertexFormat) {
			this.index = 0;
			this.numComponents = vertexElement.numComponents;

			if (vertexFormat.interleaved) {
				this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);
			} else {
				this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);
			}

			this.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;

			switch (vertexElement.numComponents) {
				case 1:
					this.set = set1;
					this.getToArray = arrayGet1;
					this.setFromArray = arraySet1;
					break;

				case 2:
					this.set = set2;
					this.getToArray = arrayGet2;
					this.setFromArray = arraySet2;
					break;

				case 3:
					this.set = set3;
					this.getToArray = arrayGet3;
					this.setFromArray = arraySet3;
					break;

				case 4:
					this.set = set4;
					this.getToArray = arrayGet4;
					this.setFromArray = arraySet4;
					break;
			}
		}

		var _proto = VertexIteratorAccessor.prototype;

		_proto.get = function get(offset) {
			return this.array[this.index + offset];
		};

		_proto.set = function set(a, b, c, d) {};

		_proto.getToArray = function getToArray(offset, outputArray, outputIndex) {};

		_proto.setFromArray = function setFromArray(index, inputArray, inputIndex) {};

		return VertexIteratorAccessor;
	}();

	var VertexIterator = function () {
		function VertexIterator(vertexBuffer) {
			this.vertexBuffer = vertexBuffer;
			this.vertexFormatSize = vertexBuffer.getFormat().size;
			this.buffer = this.vertexBuffer.lock();
			this.accessors = [];
			this.element = {};
			var vertexFormat = this.vertexBuffer.getFormat();

			for (var i = 0; i < vertexFormat.elements.length; i++) {
				var vertexElement = vertexFormat.elements[i];
				this.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);
				this.element[vertexElement.name] = this.accessors[i];
			}
		}

		var _proto2 = VertexIterator.prototype;

		_proto2.next = function next(count) {
			if (count === void 0) {
				count = 1;
			}

			var i = 0;
			var accessors = this.accessors;
			var numAccessors = this.accessors.length;

			while (i < numAccessors) {
				var accessor = accessors[i++];
				accessor.index += count * accessor.stride;
			}
		};

		_proto2.end = function end() {
			this.vertexBuffer.unlock();
		};

		_proto2.writeData = function writeData(semantic, data, numVertices) {
			var element = this.element[semantic];

			if (element) {
				if (numVertices > this.vertexBuffer.numVertices) {
					Debug.error("NumVertices provided to setData: " + numVertices + " is larger than space in VertexBuffer: " + this.vertexBuffer.numVertices);
					numVertices = this.vertexBuffer.numVertices;
				}

				var numComponents = element.numComponents;

				if (this.vertexBuffer.getFormat().interleaved) {
					var index = 0;

					for (var i = 0; i < numVertices; i++) {
						element.setFromArray(index, data, i * numComponents);
						index += element.stride;
					}
				} else {
					if (data.length > numVertices * numComponents) {
						var copyCount = numVertices * numComponents;

						if (ArrayBuffer.isView(data)) {
							data = data.subarray(0, copyCount);
							element.array.set(data);
						} else {
							for (var _i = 0; _i < copyCount; _i++) {
								element.array[_i] = data[_i];
							}
						}
					} else {
						element.array.set(data);
					}
				}
			}
		};

		_proto2.readData = function readData(semantic, data) {
			var element = this.element[semantic];
			var count = 0;

			if (element) {
				count = this.vertexBuffer.numVertices;
				var i;
				var numComponents = element.numComponents;

				if (this.vertexBuffer.getFormat().interleaved) {
					if (Array.isArray(data)) data.length = 0;
					element.index = 0;
					var offset = 0;

					for (i = 0; i < count; i++) {
						element.getToArray(offset, data, i * numComponents);
						offset += element.stride;
					}
				} else {
					if (ArrayBuffer.isView(data)) {
						data.set(element.array);
					} else {
						data.length = 0;
						var copyCount = count * numComponents;

						for (i = 0; i < copyCount; i++) {
							data[i] = element.array[i];
						}
					}
				}
			}

			return count;
		};

		return VertexIterator;
	}();

	var primitive = {
		type: PRIMITIVE_TRISTRIP,
		base: 0,
		count: 4,
		indexed: false
	};

	var PostEffect$1 = function () {
		function PostEffect(graphicsDevice) {
			this.device = graphicsDevice;
			this.shader = null;
			this.vertexBuffer = createFullscreenQuad(graphicsDevice);
			this.needsDepthBuffer = false;
			this.depthMap = null;
		}

		var _proto = PostEffect.prototype;

		_proto.render = function render(inputTarget, outputTarget, rect) {};

		return PostEffect;
	}();

	function createFullscreenQuad(device) {
		var vertexFormat = new VertexFormat(device, [{
			semantic: SEMANTIC_POSITION,
			components: 2,
			type: TYPE_FLOAT32
		}]);
		var vertexBuffer = new VertexBuffer(device, vertexFormat, 4);
		var iterator = new VertexIterator(vertexBuffer);
		iterator.element[SEMANTIC_POSITION].set(-1.0, -1.0);
		iterator.next();
		iterator.element[SEMANTIC_POSITION].set(1.0, -1.0);
		iterator.next();
		iterator.element[SEMANTIC_POSITION].set(-1.0, 1.0);
		iterator.next();
		iterator.element[SEMANTIC_POSITION].set(1.0, 1.0);
		iterator.end();
		return vertexBuffer;
	}

	function drawFullscreenQuad(device, target, vertexBuffer, shader, rect) {
		var oldRt = device.getRenderTarget();
		device.setRenderTarget(target);
		device.updateBegin();
		var w = target ? target.width : device.width;
		var h = target ? target.height : device.height;
		var x = 0;
		var y = 0;

		if (rect) {
			x = rect.x * w;
			y = rect.y * h;
			w *= rect.z;
			h *= rect.w;
		}

		var oldVx = device.vx;
		var oldVy = device.vy;
		var oldVw = device.vw;
		var oldVh = device.vh;
		device.setViewport(x, y, w, h);
		var oldSx = device.sx;
		var oldSy = device.sy;
		var oldSw = device.sw;
		var oldSh = device.sh;
		device.setScissor(x, y, w, h);
		var oldBlending = device.getBlending();
		var oldDepthTest = device.getDepthTest();
		var oldDepthWrite = device.getDepthWrite();
		var oldCullMode = device.getCullMode();
		var oldWR = device.writeRed;
		var oldWG = device.writeGreen;
		var oldWB = device.writeBlue;
		var oldWA = device.writeAlpha;
		device.setBlending(false);
		device.setDepthTest(false);
		device.setDepthWrite(false);
		device.setCullMode(CULLFACE_NONE);
		device.setColorWrite(true, true, true, true);
		device.setVertexBuffer(vertexBuffer, 0);
		device.setShader(shader);
		device.draw(primitive);
		device.setBlending(oldBlending);
		device.setDepthTest(oldDepthTest);
		device.setDepthWrite(oldDepthWrite);
		device.setCullMode(oldCullMode);
		device.setColorWrite(oldWR, oldWG, oldWB, oldWA);
		device.updateEnd();
		device.setRenderTarget(oldRt);
		device.updateBegin();
		device.setViewport(oldVx, oldVy, oldVw, oldVh);
		device.setScissor(oldSx, oldSy, oldSw, oldSh);
	}

	var TransformFeedback = function () {
		function TransformFeedback(inputBuffer, usage) {
			if (usage === void 0) {
				usage = BUFFER_GPUDYNAMIC;
			}

			this.device = inputBuffer.device;
			var gl = this.device.gl;
			Debug.assert(inputBuffer.format.interleaved || inputBuffer.format.elements.length <= 1, "Vertex buffer used by TransformFeedback needs to be interleaved.");
			this._inputBuffer = inputBuffer;

			if (usage === BUFFER_GPUDYNAMIC && inputBuffer.usage !== usage) {
				gl.bindBuffer(gl.ARRAY_BUFFER, inputBuffer.impl.bufferId);
				gl.bufferData(gl.ARRAY_BUFFER, inputBuffer.storage, gl.DYNAMIC_COPY);
			}

			this._outputBuffer = new VertexBuffer(inputBuffer.device, inputBuffer.format, inputBuffer.numVertices, usage, inputBuffer.storage);
		}

		TransformFeedback.createShader = function createShader(graphicsDevice, vsCode, name) {
			return createShaderFromCode(graphicsDevice, vsCode, null, name, true);
		};

		var _proto = TransformFeedback.prototype;

		_proto.destroy = function destroy() {
			this._outputBuffer.destroy();
		};

		_proto.process = function process(shader, swap) {
			if (swap === void 0) {
				swap = true;
			}

			var device = this.device;
			DebugGraphics.pushGpuMarker(device, "TransformFeedback");
			var oldRt = device.getRenderTarget();
			device.setRenderTarget(null);
			device.updateBegin();
			device.setVertexBuffer(this._inputBuffer, 0);
			device.setRaster(false);
			device.setTransformFeedbackBuffer(this._outputBuffer);
			device.setShader(shader);
			device.draw({
				type: PRIMITIVE_POINTS,
				base: 0,
				count: this._inputBuffer.numVertices,
				indexed: false
			});
			device.setTransformFeedbackBuffer(null);
			device.setRaster(true);
			device.updateEnd();
			device.setRenderTarget(oldRt);
			DebugGraphics.popGpuMarker(device);

			if (swap) {
				var tmp = this._inputBuffer.impl.bufferId;
				this._inputBuffer.impl.bufferId = this._outputBuffer.impl.bufferId;
				this._outputBuffer.impl.bufferId = tmp;
				tmp = this._inputBuffer.impl.vao;
				this._inputBuffer.impl.vao = this._outputBuffer.impl.vao;
				this._outputBuffer.impl.vao = tmp;
			}
		};

		_createClass(TransformFeedback, [{
			key: "inputBuffer",
			get: function get() {
				return this._inputBuffer;
			}
		}, {
			key: "outputBuffer",
			get: function get() {
				return this._outputBuffer;
			}
		}]);

		return TransformFeedback;
	}();

	var GrabPass = function () {
		function GrabPass(device, useAlpha) {
			this.device = device;
			this.useAlpha = useAlpha;
			this.useMipmaps = device.webgl2;
			this.texture = null;
			this.renderTarget = null;
			this.textureId = null;
		}

		var _proto = GrabPass.prototype;

		_proto.destroy = function destroy() {
			this.textureId = null;

			if (this.renderTarget) {
				this.renderTarget.destroy();
				this.renderTarget = null;
			}

			if (this.texture) {
				this.texture.destroy();
				this.texture = null;
			}
		};

		_proto.create = function create() {
			if (!this.texture) {
				var texture = new Texture(this.device, {
					name: 'texture_grabPass',
					format: this.useAlpha ? PIXELFORMAT_R8_G8_B8_A8 : PIXELFORMAT_R8_G8_B8,
					minFilter: this.useMipmaps ? FILTER_LINEAR_MIPMAP_LINEAR : FILTER_LINEAR,
					magFilter: FILTER_LINEAR,
					addressU: ADDRESS_CLAMP_TO_EDGE,
					addressV: ADDRESS_CLAMP_TO_EDGE,
					mipmaps: this.useMipmaps
				});
				this.texture = texture;
				this.renderTarget = new RenderTarget({
					colorBuffer: texture,
					depth: false
				});
				this.textureId = this.device.scope.resolve(texture.name);
				this.textureId.setValue(texture);
			}
		};

		_proto.update = function update() {
			var device = this.device;
			var gl = device.gl;

			if (!device.grabPassAvailable) {
				Debug.error("texture_grabPass cannot be used when rendering shadows and similar passes, exclude your object from rendering to them");
				return false;
			}

			var renderTarget = device.renderTarget;
			var resolveRenderTarget = renderTarget && renderTarget.impl._glResolveFrameBuffer;
			var texture = this.texture;
			var width = device.width;
			var height = device.height;
			DebugGraphics.pushGpuMarker(device, "grabPass");

			if (device.webgl2 && !device._tempMacChromeBlitFramebufferWorkaround && width === texture._width && height === texture._height) {
				if (resolveRenderTarget) {
					renderTarget.resolve(true);
				}

				var currentFrameBuffer = renderTarget ? renderTarget.impl._glFrameBuffer : null;
				var resolvedFrameBuffer = renderTarget ? renderTarget.impl._glResolveFrameBuffer || renderTarget.impl._glFrameBuffer : null;
				device.initRenderTarget(this.renderTarget);
				var grabPassFrameBuffer = this.renderTarget.impl._glFrameBuffer;
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, resolvedFrameBuffer);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, grabPassFrameBuffer);
				gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, currentFrameBuffer);
			} else {
				if (resolveRenderTarget) {
					renderTarget.resolve(true);
					gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.impl._glResolveFrameBuffer);
				}

				var format = texture.impl._glFormat;
				gl.copyTexImage2D(gl.TEXTURE_2D, 0, format, 0, 0, width, height, 0);
				texture._width = width;
				texture._height = height;

				if (resolveRenderTarget) {
					gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.impl._glFrameBuffer);
				}
			}

			DebugGraphics.popGpuMarker(device);
			return true;
		};

		_proto.generateMipmaps = function generateMipmaps() {
			if (this.useMipmaps) {
				this.device.gl.generateMipmap(this.texture.impl._glTarget);
			}
		};

		_proto.prepareTexture = function prepareTexture() {
			var updated = this.update();

			if (updated) {
				this.generateMipmaps();
			}

			return updated;
		};

		return GrabPass;
	}();

	var WebglBuffer = function () {
		function WebglBuffer() {
			this.bufferId = null;
		}

		var _proto = WebglBuffer.prototype;

		_proto.destroy = function destroy(device) {
			if (this.bufferId) {
				device.gl.deleteBuffer(this.bufferId);
				this.bufferId = null;
			}
		};

		_proto.loseContext = function loseContext() {
			this.bufferId = null;
		};

		_proto.unlock = function unlock(device, usage, target, storage) {
			var gl = device.gl;

			if (!this.bufferId) {
				this.bufferId = gl.createBuffer();
			}

			var glUsage;

			switch (usage) {
				case BUFFER_STATIC:
					glUsage = gl.STATIC_DRAW;
					break;

				case BUFFER_DYNAMIC:
					glUsage = gl.DYNAMIC_DRAW;
					break;

				case BUFFER_STREAM:
					glUsage = gl.STREAM_DRAW;
					break;

				case BUFFER_GPUDYNAMIC:
					if (device.webgl2) {
						glUsage = gl.DYNAMIC_COPY;
					} else {
						glUsage = gl.STATIC_DRAW;
					}

					break;
			}

			gl.bindBuffer(target, this.bufferId);
			gl.bufferData(target, storage, glUsage);
		};

		return WebglBuffer;
	}();

	var WebglVertexBuffer = function (_WebglBuffer) {
		_inheritsLoose(WebglVertexBuffer, _WebglBuffer);

		function WebglVertexBuffer() {
			var _this;

			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			_this = _WebglBuffer.call.apply(_WebglBuffer, [this].concat(args)) || this;
			_this.vao = null;
			return _this;
		}

		var _proto = WebglVertexBuffer.prototype;

		_proto.destroy = function destroy(device) {
			_WebglBuffer.prototype.destroy.call(this, device);

			device.boundVao = null;
			device.gl.bindVertexArray(null);
		};

		_proto.loseContext = function loseContext() {
			_WebglBuffer.prototype.loseContext.call(this);

			this.vao = null;
		};

		_proto.unlock = function unlock(vertexBuffer) {
			var device = vertexBuffer.device;

			_WebglBuffer.prototype.unlock.call(this, device, vertexBuffer.usage, device.gl.ARRAY_BUFFER, vertexBuffer.storage);
		};

		return WebglVertexBuffer;
	}(WebglBuffer);

	var WebglIndexBuffer = function (_WebglBuffer) {
		_inheritsLoose(WebglIndexBuffer, _WebglBuffer);

		function WebglIndexBuffer(indexBuffer) {
			var _this;

			_this = _WebglBuffer.call(this) || this;
			var gl = indexBuffer.device.gl;
			var format = indexBuffer.format;

			if (format === INDEXFORMAT_UINT8) {
				_this.glFormat = gl.UNSIGNED_BYTE;
			} else if (format === INDEXFORMAT_UINT16) {
				_this.glFormat = gl.UNSIGNED_SHORT;
			} else if (format === INDEXFORMAT_UINT32) {
				_this.glFormat = gl.UNSIGNED_INT;
			}

			return _this;
		}

		var _proto = WebglIndexBuffer.prototype;

		_proto.unlock = function unlock(indexBuffer) {
			var device = indexBuffer.device;

			_WebglBuffer.prototype.unlock.call(this, device, indexBuffer.usage, device.gl.ELEMENT_ARRAY_BUFFER, indexBuffer.storage);
		};

		return WebglIndexBuffer;
	}(WebglBuffer);

	var ShaderInput = function ShaderInput(graphicsDevice, name, type, locationId) {
		this.locationId = locationId;
		this.scopeId = graphicsDevice.scope.resolve(name);
		this.version = new Version();

		if (name.substr(name.length - 3) === "[0]") {
			switch (type) {
				case UNIFORMTYPE_FLOAT:
					type = UNIFORMTYPE_FLOATARRAY;
					break;

				case UNIFORMTYPE_VEC2:
					type = UNIFORMTYPE_VEC2ARRAY;
					break;

				case UNIFORMTYPE_VEC3:
					type = UNIFORMTYPE_VEC3ARRAY;
					break;

				case UNIFORMTYPE_VEC4:
					type = UNIFORMTYPE_VEC4ARRAY;
					break;
			}
		}

		this.dataType = type;
		this.value = [null, null, null, null];
		this.array = [];
	};

	var WebglShader = function () {
		function WebglShader(shader) {
			this.uniforms = [];
			this.samplers = [];
			this.attributes = [];
			this.glProgram = null;
			this.glVertexShader = null;
			this.glFragmentShader = null;
			this.compileAndLink(shader.device, shader);
			shader.device.shaders.push(shader);
		}

		var _proto = WebglShader.prototype;

		_proto.destroy = function destroy(shader) {
			var device = shader.device;
			var idx = device.shaders.indexOf(shader);

			if (idx !== -1) {
				device.shaders.splice(idx, 1);
			}

			if (this.glProgram) {
				device.gl.deleteProgram(this.glProgram);
				this.glProgram = null;
				device.removeShaderFromCache(shader);
			}
		};

		_proto.restoreContext = function restoreContext(device, shader) {
			this.compileAndLink(device, shader);
		};

		_proto.compileAndLink = function compileAndLink(device, shader) {
			var definition = shader.definition;
			Debug.assert(definition.vshader, 'No vertex shader has been specified when creating a shader.');
			Debug.assert(definition.fshader, 'No fragment shader has been specified when creating a shader.');

			var glVertexShader = this._compileShaderSource(device, definition.vshader, true);

			var glFragmentShader = this._compileShaderSource(device, definition.fshader, false);

			var gl = device.gl;
			var glProgram = gl.createProgram();
			gl.attachShader(glProgram, glVertexShader);
			gl.attachShader(glProgram, glFragmentShader);
			var attrs = definition.attributes;

			if (device.webgl2 && definition.useTransformFeedback) {
				var outNames = [];

				for (var attr in attrs) {
					if (attrs.hasOwnProperty(attr)) {
						outNames.push("out_" + attr);
					}
				}

				gl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);
			}

			var locations = {};

			for (var _attr in attrs) {
				if (attrs.hasOwnProperty(_attr)) {
					var semantic = attrs[_attr];
					var loc = semanticToLocation[semantic];
					Debug.assert(!locations.hasOwnProperty(loc), "WARNING: Two attribues are mapped to the same location in a shader: " + locations[loc] + " and " + _attr);
					locations[loc] = _attr;
					gl.bindAttribLocation(glProgram, loc, _attr);
				}
			}

			gl.linkProgram(glProgram);
			this.glVertexShader = glVertexShader;
			this.glFragmentShader = glFragmentShader;
			this.glProgram = glProgram;
			device._shaderStats.linked++;

			if (definition.tag === SHADERTAG_MATERIAL) {
				device._shaderStats.materialShaders++;
			}
		};

		_proto._compileShaderSource = function _compileShaderSource(device, src, isVertexShader) {
			var gl = device.gl;
			var shaderCache = isVertexShader ? device.vertexShaderCache : device.fragmentShaderCache;
			var glShader = shaderCache[src];

			if (!glShader) {
				var startTime = now();
				device.fire('shader:compile:start', {
					timestamp: startTime,
					target: device
				});
				glShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
				gl.shaderSource(glShader, src);
				gl.compileShader(glShader);
				shaderCache[src] = glShader;
				var endTime = now();
				device.fire('shader:compile:end', {
					timestamp: endTime,
					target: device
				});
				device._shaderStats.compileTime += endTime - startTime;

				if (isVertexShader) {
					device._shaderStats.vsCompiled++;
				} else {
					device._shaderStats.fsCompiled++;
				}
			}

			return glShader;
		};

		_proto.postLink = function postLink(device, shader) {
			var gl = device.gl;
			var glProgram = this.glProgram;
			var definition = shader.definition;
			var startTime = now();
			device.fire('shader:link:start', {
				timestamp: startTime,
				target: device
			});
			if (!this._isCompiled(device, shader, this.glVertexShader, definition.vshader, "vertex")) return false;
			if (!this._isCompiled(device, shader, this.glFragmentShader, definition.fshader, "fragment")) return false;

			if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
				var message = "Failed to link shader program. Error: " + gl.getProgramInfoLog(glProgram);
				console.error(message, definition);
				return false;
			}

			var i, info, location, shaderInput;
			i = 0;
			var numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);

			while (i < numAttributes) {
				info = gl.getActiveAttrib(glProgram, i++);
				location = gl.getAttribLocation(glProgram, info.name);

				if (definition.attributes[info.name] === undefined) {
					console.error("Vertex shader attribute \"" + info.name + "\" is not mapped to a semantic in shader definition.");
				}

				shaderInput = new ShaderInput(device, definition.attributes[info.name], device.pcUniformType[info.type], location);
				this.attributes.push(shaderInput);
			}

			i = 0;
			var numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);

			while (i < numUniforms) {
				info = gl.getActiveUniform(glProgram, i++);
				location = gl.getUniformLocation(glProgram, info.name);
				shaderInput = new ShaderInput(device, info.name, device.pcUniformType[info.type], location);

				if (info.type === gl.SAMPLER_2D || info.type === gl.SAMPLER_CUBE || device.webgl2 && (info.type === gl.SAMPLER_2D_SHADOW || info.type === gl.SAMPLER_CUBE_SHADOW || info.type === gl.SAMPLER_3D)) {
					this.samplers.push(shaderInput);
				} else {
					this.uniforms.push(shaderInput);
				}
			}

			shader.ready = true;
			var endTime = now();
			device.fire('shader:link:end', {
				timestamp: endTime,
				target: device
			});
			device._shaderStats.compileTime += endTime - startTime;
			return true;
		};

		_proto._isCompiled = function _isCompiled(device, shader, glShader, source, shaderType) {
			var gl = device.gl;

			if (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {
				var infoLog = gl.getShaderInfoLog(glShader);

				var _this$_processError = this._processError(source, infoLog),
						code = _this$_processError[0],
						error = _this$_processError[1];

				var message = "Failed to compile " + shaderType + " shader:\n\n" + infoLog + "\n" + code;
				error.shader = shader;
				console.error(message, error);
				return false;
			}

			return true;
		};

		_proto._processError = function _processError(src, infoLog) {
			if (!src) return "";
			var lines = src.split('\n');
			var error = {};
			var code = '';
			var from = 0;
			var to = lines.length;

			if (infoLog && infoLog.startsWith('ERROR:')) {
				var match = infoLog.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);

				if (match) {
					error.message = match[3];
					error.line = parseInt(match[2], 10);
					from = Math.max(0, error.line - 6);
					to = Math.min(lines.length, error.line + 5);
				}
			}

			for (var i = from; i < to; i++) {
				code += i + 1 + ":\t" + lines[i] + '\n';
			}

			error.source = src;
			return [code, error];
		};

		return WebglShader;
	}();

	function downsampleImage(image, size) {
		var srcW = image.width;
		var srcH = image.height;

		if (srcW > size || srcH > size) {
			var scale = size / Math.max(srcW, srcH);
			var dstW = Math.floor(srcW * scale);
			var dstH = Math.floor(srcH * scale);
			Debug.warn("Image dimensions larger than max supported texture size of " + size + ". Resizing from " + srcW + ", " + srcH + " to " + dstW + ", " + dstH + ".");
			var canvas = document.createElement('canvas');
			canvas.width = dstW;
			canvas.height = dstH;
			var context = canvas.getContext('2d');
			context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);
			return canvas;
		}

		return image;
	}

	var WebglTexture = function () {
		function WebglTexture() {
			this._glTexture = null;
			this._glTarget = void 0;
			this._glFormat = void 0;
			this._glInternalFormat = void 0;
			this._glPixelType = void 0;
		}

		var _proto = WebglTexture.prototype;

		_proto.destroy = function destroy(device) {
			if (this._glTexture) {
				for (var i = 0; i < device.textureUnits.length; i++) {
					var textureUnit = device.textureUnits[i];

					for (var j = 0; j < textureUnit.length; j++) {
						if (textureUnit[j] === this._glTexture) {
							textureUnit[j] = null;
						}
					}
				}

				device.gl.deleteTexture(this._glTexture);
				this._glTexture = null;
			}
		};

		_proto.loseContext = function loseContext() {
			this._glTexture = null;
		};

		_proto.initialize = function initialize(device, texture) {
			var gl = device.gl;
			var ext;
			this._glTexture = gl.createTexture();
			this._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : gl.TEXTURE_2D;

			switch (texture._format) {
				case PIXELFORMAT_A8:
					this._glFormat = gl.ALPHA;
					this._glInternalFormat = gl.ALPHA;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;

				case PIXELFORMAT_L8:
					this._glFormat = gl.LUMINANCE;
					this._glInternalFormat = gl.LUMINANCE;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;

				case PIXELFORMAT_L8_A8:
					this._glFormat = gl.LUMINANCE_ALPHA;
					this._glInternalFormat = gl.LUMINANCE_ALPHA;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;

				case PIXELFORMAT_R5_G6_B5:
					this._glFormat = gl.RGB;
					this._glInternalFormat = gl.RGB;
					this._glPixelType = gl.UNSIGNED_SHORT_5_6_5;
					break;

				case PIXELFORMAT_R5_G5_B5_A1:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = gl.RGBA;
					this._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;
					break;

				case PIXELFORMAT_R4_G4_B4_A4:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = gl.RGBA;
					this._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;
					break;

				case PIXELFORMAT_R8_G8_B8:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.webgl2 ? gl.RGB8 : gl.RGB;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;

				case PIXELFORMAT_R8_G8_B8_A8:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.webgl2 ? gl.RGBA8 : gl.RGBA;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;

				case PIXELFORMAT_DXT1:
					ext = device.extCompressedTextureS3TC;
					this._glFormat = gl.RGB;
					this._glInternalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
					break;

				case PIXELFORMAT_DXT3:
					ext = device.extCompressedTextureS3TC;
					this._glFormat = gl.RGBA;
					this._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					break;

				case PIXELFORMAT_DXT5:
					ext = device.extCompressedTextureS3TC;
					this._glFormat = gl.RGBA;
					this._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;
					break;

				case PIXELFORMAT_ETC1:
					ext = device.extCompressedTextureETC1;
					this._glFormat = gl.RGB;
					this._glInternalFormat = ext.COMPRESSED_RGB_ETC1_WEBGL;
					break;

				case PIXELFORMAT_PVRTC_2BPP_RGB_1:
					ext = device.extCompressedTexturePVRTC;
					this._glFormat = gl.RGB;
					this._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					break;

				case PIXELFORMAT_PVRTC_2BPP_RGBA_1:
					ext = device.extCompressedTexturePVRTC;
					this._glFormat = gl.RGBA;
					this._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
					break;

				case PIXELFORMAT_PVRTC_4BPP_RGB_1:
					ext = device.extCompressedTexturePVRTC;
					this._glFormat = gl.RGB;
					this._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					break;

				case PIXELFORMAT_PVRTC_4BPP_RGBA_1:
					ext = device.extCompressedTexturePVRTC;
					this._glFormat = gl.RGBA;
					this._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					break;

				case PIXELFORMAT_ETC2_RGB:
					ext = device.extCompressedTextureETC;
					this._glFormat = gl.RGB;
					this._glInternalFormat = ext.COMPRESSED_RGB8_ETC2;
					break;

				case PIXELFORMAT_ETC2_RGBA:
					ext = device.extCompressedTextureETC;
					this._glFormat = gl.RGBA;
					this._glInternalFormat = ext.COMPRESSED_RGBA8_ETC2_EAC;
					break;

				case PIXELFORMAT_ASTC_4x4:
					ext = device.extCompressedTextureASTC;
					this._glFormat = gl.RGBA;
					this._glInternalFormat = ext.COMPRESSED_RGBA_ASTC_4x4_KHR;
					break;

				case PIXELFORMAT_ATC_RGB:
					ext = device.extCompressedTextureATC;
					this._glFormat = gl.RGB;
					this._glInternalFormat = ext.COMPRESSED_RGB_ATC_WEBGL;
					break;

				case PIXELFORMAT_ATC_RGBA:
					ext = device.extCompressedTextureATC;
					this._glFormat = gl.RGBA;
					this._glInternalFormat = ext.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
					break;

				case PIXELFORMAT_RGB16F:
					ext = device.extTextureHalfFloat;
					this._glFormat = gl.RGB;

					if (device.webgl2) {
						this._glInternalFormat = gl.RGB16F;
						this._glPixelType = gl.HALF_FLOAT;
					} else {
						this._glInternalFormat = gl.RGB;
						this._glPixelType = ext.HALF_FLOAT_OES;
					}

					break;

				case PIXELFORMAT_RGBA16F:
					ext = device.extTextureHalfFloat;
					this._glFormat = gl.RGBA;

					if (device.webgl2) {
						this._glInternalFormat = gl.RGBA16F;
						this._glPixelType = gl.HALF_FLOAT;
					} else {
						this._glInternalFormat = gl.RGBA;
						this._glPixelType = ext.HALF_FLOAT_OES;
					}

					break;

				case PIXELFORMAT_RGB32F:
					this._glFormat = gl.RGB;

					if (device.webgl2) {
						this._glInternalFormat = gl.RGB32F;
					} else {
						this._glInternalFormat = gl.RGB;
					}

					this._glPixelType = gl.FLOAT;
					break;

				case PIXELFORMAT_RGBA32F:
					this._glFormat = gl.RGBA;

					if (device.webgl2) {
						this._glInternalFormat = gl.RGBA32F;
					} else {
						this._glInternalFormat = gl.RGBA;
					}

					this._glPixelType = gl.FLOAT;
					break;

				case PIXELFORMAT_R32F:
					this._glFormat = gl.RED;
					this._glInternalFormat = gl.R32F;
					this._glPixelType = gl.FLOAT;
					break;

				case PIXELFORMAT_DEPTH:
					if (device.webgl2) {
						this._glFormat = gl.DEPTH_COMPONENT;
						this._glInternalFormat = gl.DEPTH_COMPONENT32F;
						this._glPixelType = gl.FLOAT;
					} else {
						this._glFormat = gl.DEPTH_COMPONENT;
						this._glInternalFormat = gl.DEPTH_COMPONENT;
						this._glPixelType = gl.UNSIGNED_SHORT;
					}

					break;

				case PIXELFORMAT_DEPTHSTENCIL:
					this._glFormat = gl.DEPTH_STENCIL;
					this._glInternalFormat = gl.DEPTH24_STENCIL8;
					this._glPixelType = gl.UNSIGNED_INT_24_8;
					break;

				case PIXELFORMAT_111110F:
					this._glFormat = gl.RGB;
					this._glInternalFormat = gl.R11F_G11F_B10F;
					this._glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;
					break;

				case PIXELFORMAT_SRGB:
					this._glFormat = gl.RGB;
					this._glInternalFormat = gl.SRGB8;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;

				case PIXELFORMAT_SRGBA:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = gl.SRGB8_ALPHA8;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
			}
		};

		_proto.upload = function upload(device, texture) {
			Debug.assert(texture.device, "Attempting to use a texture that has been destroyed.");
			var gl = device.gl;
			if (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture.pot)) return;
			var mipLevel = 0;
			var mipObject;
			var resMult;
			var requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;

			while (texture._levels[mipLevel] || mipLevel === 0) {
				if (!texture._needsUpload && mipLevel === 0) {
					mipLevel++;
					continue;
				} else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {
					break;
				}

				mipObject = texture._levels[mipLevel];

				if (mipLevel === 1 && !texture._compressed && texture._levels.length < requiredMipLevels) {
					gl.generateMipmap(this._glTarget);
					texture._mipmapsUploaded = true;
				}

				if (texture._cubemap) {
					var face = void 0;

					if (device._isBrowserInterface(mipObject[0])) {
						for (face = 0; face < 6; face++) {
							if (!texture._levelsUpdated[0][face]) continue;
							var src = mipObject[face];

							if (src instanceof HTMLImageElement) {
								if (src.width > device.maxCubeMapSize || src.height > device.maxCubeMapSize) {
									src = downsampleImage(src, device.maxCubeMapSize);

									if (mipLevel === 0) {
										texture._width = src.width;
										texture._height = src.height;
									}
								}
							}

							device.setUnpackFlipY(false);
							device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
							gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, src);
						}
					} else {
						resMult = 1 / Math.pow(2, mipLevel);

						for (face = 0; face < 6; face++) {
							if (!texture._levelsUpdated[0][face]) continue;
							var texData = mipObject[face];

							if (texture._compressed) {
								gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);
							} else {
								device.setUnpackFlipY(false);
								device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
								gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, texData);
							}
						}
					}
				} else if (texture._volume) {
					resMult = 1 / Math.pow(2, mipLevel);

					if (texture._compressed) {
						gl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);
					} else {
						device.setUnpackFlipY(false);
						device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
						gl.texImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
					}
				} else {
					if (device._isBrowserInterface(mipObject)) {
						if (mipObject instanceof HTMLImageElement) {
							if (mipObject.width > device.maxTextureSize || mipObject.height > device.maxTextureSize) {
								mipObject = downsampleImage(mipObject, device.maxTextureSize);

								if (mipLevel === 0) {
									texture._width = mipObject.width;
									texture._height = mipObject.height;
								}
							}
						}

						device.setUnpackFlipY(texture._flipY);
						device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
						gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, mipObject);
					} else {
						resMult = 1 / Math.pow(2, mipLevel);

						if (texture._compressed) {
							gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 0, mipObject);
						} else {
							device.setUnpackFlipY(false);
							device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
							gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
						}
					}

					if (mipLevel === 0) {
						texture._mipmapsUploaded = false;
					} else {
						texture._mipmapsUploaded = true;
					}
				}

				mipLevel++;
			}

			if (texture._needsUpload) {
				if (texture._cubemap) {
					for (var i = 0; i < 6; i++) {
						texture._levelsUpdated[0][i] = false;
					}
				} else {
					texture._levelsUpdated[0] = false;
				}
			}

			if (!texture._compressed && texture._mipmaps && texture._needsMipmapsUpload && (texture.pot || device.webgl2) && texture._levels.length === 1) {
				gl.generateMipmap(this._glTarget);
				texture._mipmapsUploaded = true;
			}

			if (texture._gpuSize) {
				texture.adjustVramSizeTracking(device._vram, -texture._gpuSize);
			}

			texture._gpuSize = texture.gpuSize;
			texture.adjustVramSizeTracking(device._vram, texture._gpuSize);
		};

		return WebglTexture;
	}();

	var WebglRenderTarget = function () {
		function WebglRenderTarget() {
			this._glFrameBuffer = null;
			this._glDepthBuffer = null;
			this._glResolveFrameBuffer = null;
			this._glMsaaColorBuffer = null;
			this._glMsaaDepthBuffer = null;
		}

		var _proto = WebglRenderTarget.prototype;

		_proto.destroy = function destroy(device) {
			var gl = device.gl;

			if (this._glFrameBuffer) {
				gl.deleteFramebuffer(this._glFrameBuffer);
				this._glFrameBuffer = null;
			}

			if (this._glDepthBuffer) {
				gl.deleteRenderbuffer(this._glDepthBuffer);
				this._glDepthBuffer = null;
			}

			if (this._glResolveFrameBuffer) {
				gl.deleteFramebuffer(this._glResolveFrameBuffer);
				this._glResolveFrameBuffer = null;
			}

			if (this._glMsaaColorBuffer) {
				gl.deleteRenderbuffer(this._glMsaaColorBuffer);
				this._glMsaaColorBuffer = null;
			}

			if (this._glMsaaDepthBuffer) {
				gl.deleteRenderbuffer(this._glMsaaDepthBuffer);
				this._glMsaaDepthBuffer = null;
			}
		};

		_proto.init = function init(device, target) {
			var gl = device.gl;
			this._glFrameBuffer = gl.createFramebuffer();
			device.setFramebuffer(this._glFrameBuffer);
			var colorBuffer = target._colorBuffer;

			if (colorBuffer) {
				if (!colorBuffer.impl._glTexture) {
					colorBuffer._width = Math.min(colorBuffer.width, device.maxRenderBufferSize);
					colorBuffer._height = Math.min(colorBuffer.height, device.maxRenderBufferSize);
					device.setTexture(colorBuffer, 0);
				}

				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, 0);
			}

			var depthBuffer = target._depthBuffer;

			if (depthBuffer && device.webgl2) {
				if (!depthBuffer.impl._glTexture) {
					depthBuffer._width = Math.min(depthBuffer.width, device.maxRenderBufferSize);
					depthBuffer._height = Math.min(depthBuffer.height, device.maxRenderBufferSize);
					device.setTexture(depthBuffer, 0);
				}

				if (target._stencil) {
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, 0);
				} else {
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, 0);
				}
			} else if (target._depth) {
				var willRenderMsaa = target._samples > 1 && device.webgl2;

				if (!willRenderMsaa) {
					if (!this._glDepthBuffer) {
						this._glDepthBuffer = gl.createRenderbuffer();
					}

					gl.bindRenderbuffer(gl.RENDERBUFFER, this._glDepthBuffer);

					if (target._stencil) {
						gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target.width, target.height);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._glDepthBuffer);
					} else {
						var depthFormat = device.webgl2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16;
						gl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, target.width, target.height);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._glDepthBuffer);
					}

					gl.bindRenderbuffer(gl.RENDERBUFFER, null);
				}
			}

			this._checkFbo(device);

			if (device.webgl2 && target._samples > 1) {
				this._glResolveFrameBuffer = this._glFrameBuffer;
				this._glFrameBuffer = gl.createFramebuffer();
				device.setFramebuffer(this._glFrameBuffer);

				if (colorBuffer) {
					if (!this._glMsaaColorBuffer) {
						this._glMsaaColorBuffer = gl.createRenderbuffer();
					}

					gl.bindRenderbuffer(gl.RENDERBUFFER, this._glMsaaColorBuffer);
					gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer.impl._glInternalFormat, target.width, target.height);
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this._glMsaaColorBuffer);
				}

				if (target._depth) {
					if (!this._glMsaaDepthBuffer) {
						this._glMsaaDepthBuffer = gl.createRenderbuffer();
					}

					gl.bindRenderbuffer(gl.RENDERBUFFER, this._glMsaaDepthBuffer);

					if (target._stencil) {
						gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH24_STENCIL8, target.width, target.height);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._glMsaaDepthBuffer);
					} else {
						gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH_COMPONENT32F, target.width, target.height);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._glMsaaDepthBuffer);
					}
				}

				this._checkFbo(device);
			}
		};

		_proto._checkFbo = function _checkFbo(device) {
			var gl = device.gl;
			var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

			switch (status) {
				case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
					console.error("ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
					break;

				case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
					console.error("ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
					break;

				case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
					console.error("ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
					break;

				case gl.FRAMEBUFFER_UNSUPPORTED:
					console.error("ERROR: FRAMEBUFFER_UNSUPPORTED");
					break;

				case gl.FRAMEBUFFER_COMPLETE:
					break;
			}
		};

		_proto.loseContext = function loseContext() {
			this._glFrameBuffer = null;
			this._glDepthBuffer = null;
			this._glResolveFrameBuffer = null;
			this._glMsaaColorBuffer = null;
			this._glMsaaDepthBuffer = null;
		};

		_proto.resolve = function resolve(device, target, color, depth) {
			if (device.webgl2) {
				var gl = device.gl;
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._glFrameBuffer);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer);
				gl.blitFramebuffer(0, 0, target.width, target.height, 0, 0, target.width, target.height, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
				gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
			}
		};

		return WebglRenderTarget;
	}();

	function testRenderable(gl, pixelFormat) {
		var result = true;
		var texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, null);
		var framebuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

		if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
			result = false;
		}

		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.deleteTexture(texture);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.deleteFramebuffer(framebuffer);
		return result;
	}

	function testTextureHalfFloatUpdatable(gl, pixelFormat) {
		var result = true;
		var texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		var data = new Uint16Array(4 * 2 * 2);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, data);

		if (gl.getError() !== gl.NO_ERROR) {
			result = false;
			console.log("Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support");
		}

		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.deleteTexture(texture);
		return result;
	}

	function testTextureFloatHighPrecision(device) {
		if (!device.textureFloatRenderable) return false;
		var test1 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTestPS, "ptest1");
		var test2 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTest2PS, "ptest2");
		var textureOptions = {
			format: PIXELFORMAT_RGBA32F,
			width: 1,
			height: 1,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST
		};
		var tex1 = new Texture(device, textureOptions);
		tex1.name = 'testFHP';
		var targ1 = new RenderTarget({
			colorBuffer: tex1,
			depth: false
		});
		drawQuadWithShader(device, targ1, test1);
		textureOptions.format = PIXELFORMAT_R8_G8_B8_A8;
		var tex2 = new Texture(device, textureOptions);
		tex2.name = 'testFHP';
		var targ2 = new RenderTarget({
			colorBuffer: tex2,
			depth: false
		});
		device.constantTexSource.setValue(tex1);
		drawQuadWithShader(device, targ2, test2);
		var prevFramebuffer = device.activeFramebuffer;
		device.setFramebuffer(targ2.impl._glFrameBuffer);
		var pixels = new Uint8Array(4);
		device.readPixels(0, 0, 1, 1, pixels);
		device.setFramebuffer(prevFramebuffer);
		var x = pixels[0] / 255;
		var y = pixels[1] / 255;
		var z = pixels[2] / 255;
		var w = pixels[3] / 255;
		var f = x / (256 * 256 * 256) + y / (256 * 256) + z / 256 + w;
		tex1.destroy();
		targ1.destroy();
		tex2.destroy();
		targ2.destroy();
		return f === 0;
	}

	var WebglGraphicsDevice = function (_GraphicsDevice) {
		_inheritsLoose(WebglGraphicsDevice, _GraphicsDevice);

		function WebglGraphicsDevice(canvas, options) {
			var _this;

			if (options === void 0) {
				options = {};
			}

			_this = _GraphicsDevice.call(this, canvas) || this;
			_this.gl = void 0;
			_this.webgl2 = void 0;
			_this.defaultFramebuffer = null;

			_this.updateClientRect();

			_this.contextLost = false;

			_this._contextLostHandler = function (event) {
				event.preventDefault();
				_this.contextLost = true;

				_this.loseContext();

				Debug.log('pc.GraphicsDevice: WebGL context lost.');

				_this.fire('devicelost');
			};

			_this._contextRestoredHandler = function () {
				Debug.log('pc.GraphicsDevice: WebGL context restored.');

				_this.restoreContext();

				_this.contextLost = false;

				_this.fire('devicerestored');
			};

			options.stencil = true;

			if (!options.powerPreference) {
				options.powerPreference = 'high-performance';
			}

			var ua = typeof navigator !== 'undefined' && navigator.userAgent;
			_this.forceDisableMultisampling = ua && ua.includes('AppleWebKit') && (ua.includes('15.4') || ua.includes('15_4'));

			if (_this.forceDisableMultisampling) {
				options.antialias = false;
				Debug.log("Antialiasing has been turned off due to rendering issues on AppleWebKit 15.4");
			}

			var preferWebGl2 = options.preferWebGl2 !== undefined ? options.preferWebGl2 : true;
			var names = preferWebGl2 ? ["webgl2", "webgl", "experimental-webgl"] : ["webgl", "experimental-webgl"];
			var gl = null;

			for (var i = 0; i < names.length; i++) {
				gl = canvas.getContext(names[i], options);

				if (gl) {
					_this.webgl2 = names[i] === 'webgl2';
					break;
				}
			}

			if (!gl) {
				throw new Error("WebGL not supported");
			}

			var isChrome = platform.browser && !!window.chrome;
			var isMac = platform.browser && navigator.appVersion.indexOf("Mac") !== -1;
			_this.gl = gl;
			_this._tempEnableSafariTextureUnitWorkaround = platform.browser && !!window.safari;
			_this._tempMacChromeBlitFramebufferWorkaround = isMac && isChrome && !options.alpha;

			if (!_this.webgl2) {
				setupVertexArrayObject(gl);
			}

			canvas.addEventListener("webglcontextlost", _this._contextLostHandler, false);
			canvas.addEventListener("webglcontextrestored", _this._contextRestoredHandler, false);

			_this.initializeExtensions();

			_this.initializeCapabilities();

			_this.initializeRenderState();

			_this.initializeContextCaches();

			_this.defaultClearOptions = {
				color: [0, 0, 0, 1],
				depth: 1,
				stencil: 0,
				flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
			};
			_this.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];
			_this.glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, _this.webgl2 ? gl.MIN : _this.extBlendMinmax ? _this.extBlendMinmax.MIN_EXT : gl.FUNC_ADD, _this.webgl2 ? gl.MAX : _this.extBlendMinmax ? _this.extBlendMinmax.MAX_EXT : gl.FUNC_ADD];
			_this.glBlendFunction = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.CONSTANT_COLOR, gl.ONE_MINUS_CONSTANT_COLOR, gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA];
			_this.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];
			_this.glStencilOp = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INCR, gl.INCR_WRAP, gl.DECR, gl.DECR_WRAP, gl.INVERT];
			_this.glClearFlag = [0, gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT];
			_this.glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];
			_this.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];
			_this.glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];
			_this.glType = [gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT];
			_this.pcUniformType = {};
			_this.pcUniformType[gl.BOOL] = UNIFORMTYPE_BOOL;
			_this.pcUniformType[gl.INT] = UNIFORMTYPE_INT;
			_this.pcUniformType[gl.FLOAT] = UNIFORMTYPE_FLOAT;
			_this.pcUniformType[gl.FLOAT_VEC2] = UNIFORMTYPE_VEC2;
			_this.pcUniformType[gl.FLOAT_VEC3] = UNIFORMTYPE_VEC3;
			_this.pcUniformType[gl.FLOAT_VEC4] = UNIFORMTYPE_VEC4;
			_this.pcUniformType[gl.INT_VEC2] = UNIFORMTYPE_IVEC2;
			_this.pcUniformType[gl.INT_VEC3] = UNIFORMTYPE_IVEC3;
			_this.pcUniformType[gl.INT_VEC4] = UNIFORMTYPE_IVEC4;
			_this.pcUniformType[gl.BOOL_VEC2] = UNIFORMTYPE_BVEC2;
			_this.pcUniformType[gl.BOOL_VEC3] = UNIFORMTYPE_BVEC3;
			_this.pcUniformType[gl.BOOL_VEC4] = UNIFORMTYPE_BVEC4;
			_this.pcUniformType[gl.FLOAT_MAT2] = UNIFORMTYPE_MAT2;
			_this.pcUniformType[gl.FLOAT_MAT3] = UNIFORMTYPE_MAT3;
			_this.pcUniformType[gl.FLOAT_MAT4] = UNIFORMTYPE_MAT4;
			_this.pcUniformType[gl.SAMPLER_2D] = UNIFORMTYPE_TEXTURE2D;
			_this.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;

			if (_this.webgl2) {
				_this.pcUniformType[gl.SAMPLER_2D_SHADOW] = UNIFORMTYPE_TEXTURE2D_SHADOW;
				_this.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;
				_this.pcUniformType[gl.SAMPLER_3D] = UNIFORMTYPE_TEXTURE3D;
			}

			_this.targetToSlot = {};
			_this.targetToSlot[gl.TEXTURE_2D] = 0;
			_this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;
			_this.targetToSlot[gl.TEXTURE_3D] = 2;
			var scopeX, scopeY, scopeZ, scopeW;
			var uniformValue;
			_this.commitFunction = [];

			_this.commitFunction[UNIFORMTYPE_BOOL] = function (uniform, value) {
				if (uniform.value !== value) {
					gl.uniform1i(uniform.locationId, value);
					uniform.value = value;
				}
			};

			_this.commitFunction[UNIFORMTYPE_INT] = _this.commitFunction[UNIFORMTYPE_BOOL];

			_this.commitFunction[UNIFORMTYPE_FLOAT] = function (uniform, value) {
				if (uniform.value !== value) {
					gl.uniform1f(uniform.locationId, value);
					uniform.value = value;
				}
			};

			_this.commitFunction[UNIFORMTYPE_VEC2] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];

				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
					gl.uniform2fv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
				}
			};

			_this.commitFunction[UNIFORMTYPE_VEC3] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];

				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
					gl.uniform3fv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
				}
			};

			_this.commitFunction[UNIFORMTYPE_VEC4] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];
				scopeW = value[3];

				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
					gl.uniform4fv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
					uniformValue[3] = scopeW;
				}
			};

			_this.commitFunction[UNIFORMTYPE_IVEC2] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];

				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
					gl.uniform2iv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
				}
			};

			_this.commitFunction[UNIFORMTYPE_BVEC2] = _this.commitFunction[UNIFORMTYPE_IVEC2];

			_this.commitFunction[UNIFORMTYPE_IVEC3] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];

				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
					gl.uniform3iv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
				}
			};

			_this.commitFunction[UNIFORMTYPE_BVEC3] = _this.commitFunction[UNIFORMTYPE_IVEC3];

			_this.commitFunction[UNIFORMTYPE_IVEC4] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];
				scopeW = value[3];

				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
					gl.uniform4iv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
					uniformValue[3] = scopeW;
				}
			};

			_this.commitFunction[UNIFORMTYPE_BVEC4] = _this.commitFunction[UNIFORMTYPE_IVEC4];

			_this.commitFunction[UNIFORMTYPE_MAT2] = function (uniform, value) {
				gl.uniformMatrix2fv(uniform.locationId, false, value);
			};

			_this.commitFunction[UNIFORMTYPE_MAT3] = function (uniform, value) {
				gl.uniformMatrix3fv(uniform.locationId, false, value);
			};

			_this.commitFunction[UNIFORMTYPE_MAT4] = function (uniform, value) {
				gl.uniformMatrix4fv(uniform.locationId, false, value);
			};

			_this.commitFunction[UNIFORMTYPE_FLOATARRAY] = function (uniform, value) {
				gl.uniform1fv(uniform.locationId, value);
			};

			_this.commitFunction[UNIFORMTYPE_VEC2ARRAY] = function (uniform, value) {
				gl.uniform2fv(uniform.locationId, value);
			};

			_this.commitFunction[UNIFORMTYPE_VEC3ARRAY] = function (uniform, value) {
				gl.uniform3fv(uniform.locationId, value);
			};

			_this.commitFunction[UNIFORMTYPE_VEC4ARRAY] = function (uniform, value) {
				gl.uniform4fv(uniform.locationId, value);
			};

			_this.supportsBoneTextures = _this.extTextureFloat && _this.maxVertexTextures > 0;
			var numUniforms = _this.vertexUniformsCount;
			numUniforms -= 4 * 4;
			numUniforms -= 8;
			numUniforms -= 1;
			numUniforms -= 4 * 4;
			_this.boneLimit = Math.floor(numUniforms / 3);
			_this.boneLimit = Math.min(_this.boneLimit, 128);

			if (_this.unmaskedRenderer === 'Mali-450 MP') {
				_this.boneLimit = 34;
			}

			_this.constantTexSource = _this.scope.resolve("source");
			_this.textureBias = _this.scope.resolve("textureBias");

			_this.textureBias.setValue(0.0);

			if (_this.extTextureFloat) {
				if (_this.webgl2) {
					_this.textureFloatRenderable = !!_this.extColorBufferFloat;
				} else {
					_this.textureFloatRenderable = testRenderable(gl, gl.FLOAT);
				}
			} else {
				_this.textureFloatRenderable = false;
			}

			if (_this.extColorBufferHalfFloat) {
				_this.textureHalfFloatRenderable = !!_this.extColorBufferHalfFloat;
			} else if (_this.extTextureHalfFloat) {
				if (_this.webgl2) {
					_this.textureHalfFloatRenderable = !!_this.extColorBufferFloat;
				} else {
					_this.textureHalfFloatRenderable = testRenderable(gl, _this.extTextureHalfFloat.HALF_FLOAT_OES);
				}
			} else {
				_this.textureHalfFloatRenderable = false;
			}

			_this.supportsMorphTargetTexturesCore = _this.maxPrecision === "highp" && _this.maxVertexTextures >= 2;
			_this._textureFloatHighPrecision = undefined;
			_this._textureHalfFloatUpdatable = undefined;
			_this._spectorMarkers = [];
			_this._spectorCurrentMarker = "";
			_this.grabPassAvailable = true;
			_this.grabPass = new GrabPass(_assertThisInitialized(_this), options.alpha);

			_this.grabPass.create();

			_this.areaLightLutFormat = PIXELFORMAT_R8_G8_B8_A8;

			if (_this.extTextureHalfFloat && _this.textureHalfFloatUpdatable && _this.extTextureHalfFloatLinear) {
				_this.areaLightLutFormat = PIXELFORMAT_RGBA16F;
			} else if (_this.extTextureFloat && _this.extTextureFloatLinear) {
				_this.areaLightLutFormat = PIXELFORMAT_RGBA32F;
			}

			return _this;
		}

		var _proto = WebglGraphicsDevice.prototype;

		_proto.destroy = function destroy() {
			_GraphicsDevice.prototype.destroy.call(this);

			var gl = this.gl;
			this.grabPass.destroy();

			if (this.webgl2 && this.feedback) {
				gl.deleteTransformFeedback(this.feedback);
			}

			this.clearShaderCache();
			this.clearVertexArrayObjectCache();
			this.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);
			this.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);
			this._contextLostHandler = null;
			this._contextRestoredHandler = null;
			this.gl = null;

			_GraphicsDevice.prototype.postDestroy.call(this);
		};

		_proto.createVertexBufferImpl = function createVertexBufferImpl(vertexBuffer, format) {
			return new WebglVertexBuffer();
		};

		_proto.createIndexBufferImpl = function createIndexBufferImpl(indexBuffer) {
			return new WebglIndexBuffer(indexBuffer);
		};

		_proto.createShaderImpl = function createShaderImpl(shader) {
			return new WebglShader(shader);
		};

		_proto.createTextureImpl = function createTextureImpl() {
			return new WebglTexture();
		};

		_proto.createRenderTargetImpl = function createRenderTargetImpl(renderTarget) {
			return new WebglRenderTarget(renderTarget);
		};

		_proto.updateMarker = function updateMarker() {
			this._spectorCurrentMarker = this._spectorMarkers.join(" | ") + " # ";
		};

		_proto.pushMarker = function pushMarker(name) {
			if (window.spector) {
				this._spectorMarkers.push(name);

				this.updateMarker();
				window.spector.setMarker(this._spectorCurrentMarker);
			}
		};

		_proto.popMarker = function popMarker() {
			if (window.spector) {
				if (this._spectorMarkers.length) {
					this._spectorMarkers.pop();

					this.updateMarker();
					if (this._spectorMarkers.length) window.spector.setMarker(this._spectorCurrentMarker);else window.spector.clearMarker();
				}
			}
		};

		_proto.getPrecision = function getPrecision() {
			var gl = this.gl;
			var precision = "highp";

			if (gl.getShaderPrecisionFormat) {
				var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
				var vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
				var fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
				var fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
				var highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
				var mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;

				if (!highpAvailable) {
					if (mediumpAvailable) {
						precision = "mediump";
						Debug.warn("WARNING: highp not supported, using mediump");
					} else {
						precision = "lowp";
						Debug.warn("WARNING: highp and mediump not supported, using lowp");
					}
				}
			}

			return precision;
		};

		_proto.initializeExtensions = function initializeExtensions() {
			var gl = this.gl;
			var supportedExtensions = gl.getSupportedExtensions();

			var getExtension = function getExtension() {
				for (var i = 0; i < arguments.length; i++) {
					if (supportedExtensions.indexOf(arguments[i]) !== -1) {
						return gl.getExtension(arguments[i]);
					}
				}

				return null;
			};

			if (this.webgl2) {
				this.extBlendMinmax = true;
				this.extDrawBuffers = true;
				this.extInstancing = true;
				this.extStandardDerivatives = true;
				this.extTextureFloat = true;
				this.extTextureHalfFloat = true;
				this.extTextureLod = true;
				this.extUintElement = true;
				this.extVertexArrayObject = true;
				this.extColorBufferFloat = getExtension('EXT_color_buffer_float');
				this.extDisjointTimerQuery = getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');
				this.extDepthTexture = true;
			} else {
				this.extBlendMinmax = getExtension("EXT_blend_minmax");
				this.extDrawBuffers = getExtension('EXT_draw_buffers');
				this.extInstancing = getExtension("ANGLE_instanced_arrays");

				if (this.extInstancing) {
					var ext = this.extInstancing;
					gl.drawArraysInstanced = ext.drawArraysInstancedANGLE.bind(ext);
					gl.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);
					gl.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);
				}

				this.extStandardDerivatives = getExtension("OES_standard_derivatives");
				this.extTextureFloat = getExtension("OES_texture_float");
				this.extTextureHalfFloat = getExtension("OES_texture_half_float");
				this.extTextureLod = getExtension('EXT_shader_texture_lod');
				this.extUintElement = getExtension("OES_element_index_uint");
				this.extVertexArrayObject = getExtension("OES_vertex_array_object");

				if (this.extVertexArrayObject) {
					var _ext = this.extVertexArrayObject;
					gl.createVertexArray = _ext.createVertexArrayOES.bind(_ext);
					gl.deleteVertexArray = _ext.deleteVertexArrayOES.bind(_ext);
					gl.isVertexArray = _ext.isVertexArrayOES.bind(_ext);
					gl.bindVertexArray = _ext.bindVertexArrayOES.bind(_ext);
				}

				this.extColorBufferFloat = null;
				this.extDisjointTimerQuery = null;
				this.extDepthTexture = gl.getExtension('WEBGL_depth_texture');
			}

			this.extDebugRendererInfo = getExtension('WEBGL_debug_renderer_info');
			this.extTextureFloatLinear = getExtension("OES_texture_float_linear");
			this.extTextureHalfFloatLinear = getExtension("OES_texture_half_float_linear");
			this.extFloatBlend = getExtension("EXT_float_blend");
			this.extTextureFilterAnisotropic = getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');
			this.extCompressedTextureETC1 = getExtension('WEBGL_compressed_texture_etc1');
			this.extCompressedTextureETC = getExtension('WEBGL_compressed_texture_etc');
			this.extCompressedTexturePVRTC = getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');
			this.extCompressedTextureS3TC = getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');
			this.extCompressedTextureATC = getExtension('WEBGL_compressed_texture_atc');
			this.extCompressedTextureASTC = getExtension('WEBGL_compressed_texture_astc');
			this.extParallelShaderCompile = getExtension('KHR_parallel_shader_compile');
			this.extColorBufferHalfFloat = getExtension("EXT_color_buffer_half_float");
		};

		_proto.initializeCapabilities = function initializeCapabilities() {
			var gl = this.gl;
			var ext;
			var userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : "";
			this.maxPrecision = this.precision = this.getPrecision();
			var contextAttribs = gl.getContextAttributes();
			this.supportsMsaa = contextAttribs.antialias;
			this.supportsStencil = contextAttribs.stencil;
			this.supportsInstancing = !!this.extInstancing;
			this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
			this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
			this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
			this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
			this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
			this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
			this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
			this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);

			if (this.webgl2) {
				this.maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);
				this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
				this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
			} else {
				ext = this.extDrawBuffers;
				this.maxDrawBuffers = ext ? gl.getParameter(ext.MAX_DRAW_BUFFERS_EXT) : 1;
				this.maxColorAttachments = ext ? gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_EXT) : 1;
				this.maxVolumeSize = 1;
			}

			ext = this.extDebugRendererInfo;
			this.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';
			this.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';
			var samsungModelRegex = /SM-[a-zA-Z0-9]+\)/;
			this.supportsGpuParticles = !(this.unmaskedVendor === 'ARM' && userAgent.match(samsungModelRegex));
			ext = this.extTextureFilterAnisotropic;
			this.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
			this.samples = gl.getParameter(gl.SAMPLES);
			this.maxSamples = this.webgl2 && !this.forceDisableMultisampling ? gl.getParameter(gl.MAX_SAMPLES) : 1;
			this.supportsAreaLights = this.webgl2 || !platform.android;

			if (this.maxTextures <= 8) {
				this.supportsAreaLights = false;
			}
		};

		_proto.initializeRenderState = function initializeRenderState() {
			var gl = this.gl;
			this.blending = false;
			gl.disable(gl.BLEND);
			this.blendSrc = BLENDMODE_ONE;
			this.blendDst = BLENDMODE_ZERO;
			this.blendSrcAlpha = BLENDMODE_ONE;
			this.blendDstAlpha = BLENDMODE_ZERO;
			this.separateAlphaBlend = false;
			this.blendEquation = BLENDEQUATION_ADD;
			this.blendAlphaEquation = BLENDEQUATION_ADD;
			this.separateAlphaEquation = false;
			gl.blendFunc(gl.ONE, gl.ZERO);
			gl.blendEquation(gl.FUNC_ADD);
			this.blendColor = new Color(0, 0, 0, 0);
			gl.blendColor(0, 0, 0, 0);
			this.writeRed = true;
			this.writeGreen = true;
			this.writeBlue = true;
			this.writeAlpha = true;
			gl.colorMask(true, true, true, true);
			this.cullMode = CULLFACE_BACK;
			gl.enable(gl.CULL_FACE);
			gl.cullFace(gl.BACK);
			this.depthTest = true;
			gl.enable(gl.DEPTH_TEST);
			this.depthFunc = FUNC_LESSEQUAL;
			gl.depthFunc(gl.LEQUAL);
			this.depthWrite = true;
			gl.depthMask(true);
			this.stencil = false;
			gl.disable(gl.STENCIL_TEST);
			this.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;
			this.stencilRefFront = this.stencilRefBack = 0;
			this.stencilMaskFront = this.stencilMaskBack = 0xFF;
			gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
			this.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;
			this.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;
			this.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;
			this.stencilWriteMaskFront = 0xFF;
			this.stencilWriteMaskBack = 0xFF;
			gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
			gl.stencilMask(0xFF);
			this.alphaToCoverage = false;
			this.raster = true;

			if (this.webgl2) {
				gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
				gl.disable(gl.RASTERIZER_DISCARD);
			}

			this.depthBiasEnabled = false;
			gl.disable(gl.POLYGON_OFFSET_FILL);
			this.clearDepth = 1;
			gl.clearDepth(1);
			this.clearColor = new Color(0, 0, 0, 0);
			gl.clearColor(0, 0, 0, 0);
			this.clearStencil = 0;
			gl.clearStencil(0);
			this.vx = this.vy = this.vw = this.vh = 0;
			this.sx = this.sy = this.sw = this.sh = 0;

			if (this.webgl2) {
				gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
			} else {
				if (this.extStandardDerivatives) {
					gl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, gl.NICEST);
				}
			}

			gl.enable(gl.SCISSOR_TEST);
			gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
			this.unpackFlipY = false;
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
			this.unpackPremultiplyAlpha = false;
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		};

		_proto.initializeContextCaches = function initializeContextCaches() {
			_GraphicsDevice.prototype.initializeContextCaches.call(this);

			this.vertexShaderCache = {};
			this.fragmentShaderCache = {};
			this._vaoMap = new Map();
			this.boundVao = null;
			this.activeFramebuffer = null;
			this.feedback = null;
			this.transformFeedbackBuffer = null;
			this.textureUnit = 0;
			this.textureUnits = [];

			for (var i = 0; i < this.maxCombinedTextures; i++) {
				this.textureUnits.push([null, null, null]);
			}
		};

		_proto.loseContext = function loseContext() {
			for (var _iterator = _createForOfIteratorHelperLoose(this.shaders), _step; !(_step = _iterator()).done;) {
				var shader = _step.value;
				shader.loseContext();
			}

			this.grabPass.destroy();

			for (var _iterator2 = _createForOfIteratorHelperLoose(this.textures), _step2; !(_step2 = _iterator2()).done;) {
				var texture = _step2.value;
				texture.loseContext();
			}

			for (var _iterator3 = _createForOfIteratorHelperLoose(this.buffers), _step3; !(_step3 = _iterator3()).done;) {
				var buffer = _step3.value;
				buffer.loseContext();
			}

			for (var _iterator4 = _createForOfIteratorHelperLoose(this.targets), _step4; !(_step4 = _iterator4()).done;) {
				var target = _step4.value;
				target.loseContext();
			}
		};

		_proto.restoreContext = function restoreContext() {
			this.initializeExtensions();
			this.initializeCapabilities();
			this.initializeRenderState();
			this.initializeContextCaches();

			for (var _iterator5 = _createForOfIteratorHelperLoose(this.shaders), _step5; !(_step5 = _iterator5()).done;) {
				var shader = _step5.value;
				shader.restoreContext();
			}

			for (var _iterator6 = _createForOfIteratorHelperLoose(this.buffers), _step6; !(_step6 = _iterator6()).done;) {
				var buffer = _step6.value;
				buffer.unlock();
			}

			this.grabPass.create();
		};

		_proto.setViewport = function setViewport(x, y, w, h) {
			if (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {
				this.gl.viewport(x, y, w, h);
				this.vx = x;
				this.vy = y;
				this.vw = w;
				this.vh = h;
			}
		};

		_proto.setScissor = function setScissor(x, y, w, h) {
			if (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {
				this.gl.scissor(x, y, w, h);
				this.sx = x;
				this.sy = y;
				this.sw = w;
				this.sh = h;
			}
		};

		_proto.setFramebuffer = function setFramebuffer(fb) {
			if (this.activeFramebuffer !== fb) {
				var gl = this.gl;
				gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
				this.activeFramebuffer = fb;
			}
		};

		_proto.copyRenderTarget = function copyRenderTarget(source, dest, color, depth) {
			var gl = this.gl;

			if (!this.webgl2 && depth) {
				Debug.error("Depth is not copyable on WebGL 1.0");
				return false;
			}

			if (color) {
				if (!dest) {
					if (!source._colorBuffer) {
						Debug.error("Can't copy empty color buffer to backbuffer");
						return false;
					}
				} else {
					if (!source._colorBuffer || !dest._colorBuffer) {
						Debug.error("Can't copy color buffer, because one of the render targets doesn't have it");
						return false;
					}

					if (source._colorBuffer._format !== dest._colorBuffer._format) {
						Debug.error("Can't copy render targets of different color formats");
						return false;
					}
				}
			}

			if (depth) {
				if (!source._depthBuffer || !dest._depthBuffer) {
					Debug.error("Can't copy depth buffer, because one of the render targets doesn't have it");
					return false;
				}

				if (source._depthBuffer._format !== dest._depthBuffer._format) {
					Debug.error("Can't copy render targets of different depth formats");
					return false;
				}
			}

			if (this.webgl2 && dest) {
				var prevRt = this.renderTarget;
				this.renderTarget = dest;
				this.updateBegin();
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, source ? source.impl._glFrameBuffer : null);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dest.impl._glFrameBuffer);
				var w = source ? source.width : dest.width;
				var h = source ? source.height : dest.height;
				gl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
				this.renderTarget = prevRt;
				gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt.impl._glFrameBuffer : null);
			} else {
				var shader = this.getCopyShader();
				this.constantTexSource.setValue(source._colorBuffer);
				drawQuadWithShader(this, dest, shader);
			}

			return true;
		};

		_proto.initRenderTarget = function initRenderTarget(target) {
			if (target.impl._glFrameBuffer) return;
			var startTime = now();
			this.fire('fbo:create', {
				timestamp: startTime,
				target: this
			});
			target.init();
			this.targets.push(target);
			this._renderTargetCreationTime += now() - startTime;
		};

		_proto.getCopyShader = function getCopyShader() {
			if (!this._copyShader) {
				var vs = shaderChunks.fullscreenQuadVS;
				var fs = shaderChunks.outputTex2DPS;
				this._copyShader = createShaderFromCode(this, vs, fs, "outputTex2D");
			}

			return this._copyShader;
		};

		_proto.updateBegin = function updateBegin() {
			this.boundVao = null;

			if (this._tempEnableSafariTextureUnitWorkaround) {
				for (var unit = 0; unit < this.textureUnits.length; ++unit) {
					for (var slot = 0; slot < 3; ++slot) {
						this.textureUnits[unit][slot] = null;
					}
				}
			}

			var target = this.renderTarget;

			if (target) {
				if (!target.impl._glFrameBuffer) {
					this.initRenderTarget(target);
				} else {
					this.setFramebuffer(target.impl._glFrameBuffer);
				}
			} else {
				this.setFramebuffer(this.defaultFramebuffer);
			}
		};

		_proto.updateEnd = function updateEnd() {
			var gl = this.gl;

			if (this.boundVao) {
				this.boundVao = null;
				this.gl.bindVertexArray(null);
			}

			var target = this.renderTarget;

			if (target) {
				var colorBuffer = target._colorBuffer;

				if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps && (colorBuffer.pot || this.webgl2)) {
					this.activeTexture(this.maxCombinedTextures - 1);
					this.bindTexture(colorBuffer);
					gl.generateMipmap(colorBuffer.impl._glTarget);
				}

				if (this.webgl2 && target._samples > 1 && target.autoResolve) {
					target.resolve();
				}
			}
		};

		_proto.setUnpackFlipY = function setUnpackFlipY(flipY) {
			if (this.unpackFlipY !== flipY) {
				this.unpackFlipY = flipY;
				var gl = this.gl;
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
			}
		};

		_proto.setUnpackPremultiplyAlpha = function setUnpackPremultiplyAlpha(premultiplyAlpha) {
			if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {
				this.unpackPremultiplyAlpha = premultiplyAlpha;
				var gl = this.gl;
				gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
			}
		};

		_proto.activeTexture = function activeTexture(textureUnit) {
			if (this.textureUnit !== textureUnit) {
				this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
				this.textureUnit = textureUnit;
			}
		};

		_proto.bindTexture = function bindTexture(texture) {
			var impl = texture.impl;
			var textureTarget = impl._glTarget;
			var textureObject = impl._glTexture;
			var textureUnit = this.textureUnit;
			var slot = this.targetToSlot[textureTarget];

			if (this.textureUnits[textureUnit][slot] !== textureObject) {
				this.gl.bindTexture(textureTarget, textureObject);
				this.textureUnits[textureUnit][slot] = textureObject;
			}
		};

		_proto.bindTextureOnUnit = function bindTextureOnUnit(texture, textureUnit) {
			var impl = texture.impl;
			var textureTarget = impl._glTarget;
			var textureObject = impl._glTexture;
			var slot = this.targetToSlot[textureTarget];

			if (this.textureUnits[textureUnit][slot] !== textureObject) {
				this.activeTexture(textureUnit);
				this.gl.bindTexture(textureTarget, textureObject);
				this.textureUnits[textureUnit][slot] = textureObject;
			}
		};

		_proto.setTextureParameters = function setTextureParameters(texture) {
			var gl = this.gl;
			var flags = texture._parameterFlags;
			var target = texture.impl._glTarget;

			if (flags & 1) {
				var filter = texture._minFilter;

				if (!texture.pot && !this.webgl2 || !texture._mipmaps || texture._compressed && texture._levels.length === 1) {
					if (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {
						filter = FILTER_NEAREST;
					} else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {
						filter = FILTER_LINEAR;
					}
				}

				gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);
			}

			if (flags & 2) {
				gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);
			}

			if (flags & 4) {
				if (this.webgl2) {
					gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);
				} else {
					gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture.pot ? texture._addressU : ADDRESS_CLAMP_TO_EDGE]);
				}
			}

			if (flags & 8) {
				if (this.webgl2) {
					gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);
				} else {
					gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture.pot ? texture._addressV : ADDRESS_CLAMP_TO_EDGE]);
				}
			}

			if (flags & 16) {
				if (this.webgl2) {
					gl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);
				}
			}

			if (flags & 32) {
				if (this.webgl2) {
					gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
				}
			}

			if (flags & 64) {
				if (this.webgl2) {
					gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);
				}
			}

			if (flags & 128) {
				var ext = this.extTextureFilterAnisotropic;

				if (ext) {
					gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(texture._anisotropy), this.maxAnisotropy)));
				}
			}
		};

		_proto.setTexture = function setTexture(texture, textureUnit) {
			if (!texture.impl._glTexture) texture.impl.initialize(this, texture);

			if (texture._parameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload || texture === this.grabPass.texture) {
				this.activeTexture(textureUnit);
				this.bindTexture(texture);

				if (texture._parameterFlags) {
					this.setTextureParameters(texture);
					texture._parameterFlags = 0;
				}

				var processed = texture === this.grabPass.texture && this.grabPass.prepareTexture();

				if (!processed && (texture._needsUpload || texture._needsMipmapsUpload)) {
					texture.impl.upload(this, texture);
					texture._needsUpload = false;
					texture._needsMipmapsUpload = false;
				}
			} else {
				this.bindTextureOnUnit(texture, textureUnit);
			}
		};

		_proto.createVertexArray = function createVertexArray(vertexBuffers) {
			var key, vao;
			var useCache = vertexBuffers.length > 1;

			if (useCache) {
				key = "";

				for (var i = 0; i < vertexBuffers.length; i++) {
					var vertexBuffer = vertexBuffers[i];
					key += vertexBuffer.id + vertexBuffer.format.renderingingHash;
				}

				vao = this._vaoMap.get(key);
			}

			if (!vao) {
				var gl = this.gl;
				vao = gl.createVertexArray();
				gl.bindVertexArray(vao);
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
				var locZero = false;

				for (var _i = 0; _i < vertexBuffers.length; _i++) {
					var _vertexBuffer = vertexBuffers[_i];
					gl.bindBuffer(gl.ARRAY_BUFFER, _vertexBuffer.impl.bufferId);
					var elements = _vertexBuffer.format.elements;

					for (var j = 0; j < elements.length; j++) {
						var e = elements[j];
						var loc = semanticToLocation[e.name];

						if (loc === 0) {
							locZero = true;
						}

						gl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);
						gl.enableVertexAttribArray(loc);

						if (_vertexBuffer.instancing) {
							gl.vertexAttribDivisor(loc, 1);
						}
					}
				}

				gl.bindVertexArray(null);
				gl.bindBuffer(gl.ARRAY_BUFFER, null);

				if (useCache) {
					this._vaoMap.set(key, vao);
				}

				if (!locZero) {
					Debug.warn("No vertex attribute is mapped to location 0, which might cause compatibility issues on Safari on MacOS - please use attribute SEMANTIC_POSITION or SEMANTIC_ATTR15");
				}
			}

			return vao;
		};

		_proto.setBuffers = function setBuffers() {
			var gl = this.gl;
			var vao;

			if (this.vertexBuffers.length === 1) {
				var vertexBuffer = this.vertexBuffers[0];
				Debug.assert(vertexBuffer.device === this, "The VertexBuffer was not created using current GraphicsDevice");

				if (!vertexBuffer.impl.vao) {
					vertexBuffer.impl.vao = this.createVertexArray(this.vertexBuffers);
				}

				vao = vertexBuffer.impl.vao;
			} else {
				vao = this.createVertexArray(this.vertexBuffers);
			}

			if (this.boundVao !== vao) {
				this.boundVao = vao;
				gl.bindVertexArray(vao);
			}

			this.vertexBuffers.length = 0;
			var bufferId = this.indexBuffer ? this.indexBuffer.impl.bufferId : null;
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);
		};

		_proto.draw = function draw(primitive, numInstances, keepBuffers) {
			var gl = this.gl;
			var sampler, samplerValue, texture, numTextures;
			var uniform, scopeId, uniformVersion, programVersion;
			var shader = this.shader;
			if (!shader) return;
			var samplers = shader.impl.samplers;
			var uniforms = shader.impl.uniforms;

			if (!keepBuffers) {
				this.setBuffers();
			}

			var textureUnit = 0;

			for (var i = 0, len = samplers.length; i < len; i++) {
				sampler = samplers[i];
				samplerValue = sampler.scopeId.value;

				if (!samplerValue) {
					continue;
				}

				if (samplerValue instanceof Texture) {
					texture = samplerValue;
					this.setTexture(texture, textureUnit);

					if (this.renderTarget) {
						if (this.renderTarget._samples < 2) {
							if (this.renderTarget.colorBuffer && this.renderTarget.colorBuffer === texture) {
								Debug.error("Trying to bind current color buffer as a texture");
							} else if (this.renderTarget.depthBuffer && this.renderTarget.depthBuffer === texture) {
								Debug.error("Trying to bind current depth buffer as a texture");
							}
						}
					}

					if (sampler.slot !== textureUnit) {
						gl.uniform1i(sampler.locationId, textureUnit);
						sampler.slot = textureUnit;
					}

					textureUnit++;
				} else {
					sampler.array.length = 0;
					numTextures = samplerValue.length;

					for (var j = 0; j < numTextures; j++) {
						texture = samplerValue[j];
						this.setTexture(texture, textureUnit);
						sampler.array[j] = textureUnit;
						textureUnit++;
					}

					gl.uniform1iv(sampler.locationId, sampler.array);
				}
			}

			for (var _i2 = 0, _len = uniforms.length; _i2 < _len; _i2++) {
				uniform = uniforms[_i2];
				scopeId = uniform.scopeId;
				uniformVersion = uniform.version;
				programVersion = scopeId.versionObject.version;

				if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {
					uniformVersion.globalId = programVersion.globalId;
					uniformVersion.revision = programVersion.revision;

					if (scopeId.value !== null) {
						this.commitFunction[uniform.dataType](uniform, scopeId.value);
					}
				}
			}

			if (this.webgl2 && this.transformFeedbackBuffer) {
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.impl.bufferId);
				gl.beginTransformFeedback(gl.POINTS);
			}

			var mode = this.glPrimitive[primitive.type];
			var count = primitive.count;

			if (primitive.indexed) {
				var indexBuffer = this.indexBuffer;
				Debug.assert(indexBuffer.device === this, "The IndexBuffer was not created using current GraphicsDevice");
				var format = indexBuffer.impl.glFormat;
				var offset = primitive.base * indexBuffer.bytesPerIndex;

				if (numInstances > 0) {
					gl.drawElementsInstanced(mode, count, format, offset, numInstances);
				} else {
					gl.drawElements(mode, count, format, offset);
				}
			} else {
				var first = primitive.base;

				if (numInstances > 0) {
					gl.drawArraysInstanced(mode, first, count, numInstances);
				} else {
					gl.drawArrays(mode, first, count);
				}
			}

			if (this.webgl2 && this.transformFeedbackBuffer) {
				gl.endTransformFeedback();
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
			}

			this._drawCallsPerFrame++;
			this._primsPerFrame[primitive.type] += primitive.count * (numInstances > 1 ? numInstances : 1);
		};

		_proto.clear = function clear(options) {
			var defaultOptions = this.defaultClearOptions;
			options = options || defaultOptions;
			var flags = options.flags == undefined ? defaultOptions.flags : options.flags;

			if (flags !== 0) {
				var gl = this.gl;

				if (flags & CLEARFLAG_COLOR) {
					var color = options.color == undefined ? defaultOptions.color : options.color;
					this.setClearColor(color[0], color[1], color[2], color[3]);
				}

				if (flags & CLEARFLAG_DEPTH) {
					var depth = options.depth == undefined ? defaultOptions.depth : options.depth;
					this.setClearDepth(depth);

					if (!this.depthWrite) {
						gl.depthMask(true);
					}
				}

				if (flags & CLEARFLAG_STENCIL) {
					var stencil = options.stencil == undefined ? defaultOptions.stencil : options.stencil;
					this.setClearStencil(stencil);
				}

				gl.clear(this.glClearFlag[flags]);

				if (flags & CLEARFLAG_DEPTH) {
					if (!this.depthWrite) {
						gl.depthMask(false);
					}
				}
			}
		};

		_proto.readPixels = function readPixels(x, y, w, h, pixels) {
			var gl = this.gl;
			gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
		};

		_proto.setClearDepth = function setClearDepth(depth) {
			if (depth !== this.clearDepth) {
				this.gl.clearDepth(depth);
				this.clearDepth = depth;
			}
		};

		_proto.setClearColor = function setClearColor(r, g, b, a) {
			var c = this.clearColor;

			if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
				this.gl.clearColor(r, g, b, a);
				this.clearColor.set(r, g, b, a);
			}
		};

		_proto.setClearStencil = function setClearStencil(value) {
			if (value !== this.clearStencil) {
				this.gl.clearStencil(value);
				this.clearStencil = value;
			}
		};

		_proto.getDepthTest = function getDepthTest() {
			return this.depthTest;
		};

		_proto.setDepthTest = function setDepthTest(depthTest) {
			if (this.depthTest !== depthTest) {
				var gl = this.gl;

				if (depthTest) {
					gl.enable(gl.DEPTH_TEST);
				} else {
					gl.disable(gl.DEPTH_TEST);
				}

				this.depthTest = depthTest;
			}
		};

		_proto.setDepthFunc = function setDepthFunc(func) {
			if (this.depthFunc === func) return;
			this.gl.depthFunc(this.glComparison[func]);
			this.depthFunc = func;
		};

		_proto.getDepthWrite = function getDepthWrite() {
			return this.depthWrite;
		};

		_proto.setDepthWrite = function setDepthWrite(writeDepth) {
			if (this.depthWrite !== writeDepth) {
				this.gl.depthMask(writeDepth);
				this.depthWrite = writeDepth;
			}
		};

		_proto.setColorWrite = function setColorWrite(writeRed, writeGreen, writeBlue, writeAlpha) {
			if (this.writeRed !== writeRed || this.writeGreen !== writeGreen || this.writeBlue !== writeBlue || this.writeAlpha !== writeAlpha) {
				this.gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);
				this.writeRed = writeRed;
				this.writeGreen = writeGreen;
				this.writeBlue = writeBlue;
				this.writeAlpha = writeAlpha;
			}
		};

		_proto.setAlphaToCoverage = function setAlphaToCoverage(state) {
			if (!this.webgl2) return;
			if (this.alphaToCoverage === state) return;
			this.alphaToCoverage = state;

			if (state) {
				this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
			} else {
				this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
			}
		};

		_proto.setTransformFeedbackBuffer = function setTransformFeedbackBuffer(tf) {
			if (this.transformFeedbackBuffer === tf) return;
			this.transformFeedbackBuffer = tf;

			if (this.webgl2) {
				var gl = this.gl;

				if (tf) {
					if (!this.feedback) {
						this.feedback = gl.createTransformFeedback();
					}

					gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);
				} else {
					gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
				}
			}
		};

		_proto.setRaster = function setRaster(on) {
			if (this.raster === on) return;
			this.raster = on;

			if (this.webgl2) {
				if (on) {
					this.gl.disable(this.gl.RASTERIZER_DISCARD);
				} else {
					this.gl.enable(this.gl.RASTERIZER_DISCARD);
				}
			}
		};

		_proto.setDepthBias = function setDepthBias(on) {
			if (this.depthBiasEnabled === on) return;
			this.depthBiasEnabled = on;

			if (on) {
				this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
			} else {
				this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
			}
		};

		_proto.setDepthBiasValues = function setDepthBiasValues(constBias, slopeBias) {
			this.gl.polygonOffset(slopeBias, constBias);
		};

		_proto.getBlending = function getBlending() {
			return this.blending;
		};

		_proto.setBlending = function setBlending(blending) {
			if (this.blending !== blending) {
				var gl = this.gl;

				if (blending) {
					gl.enable(gl.BLEND);
				} else {
					gl.disable(gl.BLEND);
				}

				this.blending = blending;
			}
		};

		_proto.setStencilTest = function setStencilTest(enable) {
			if (this.stencil !== enable) {
				var gl = this.gl;

				if (enable) {
					gl.enable(gl.STENCIL_TEST);
				} else {
					gl.disable(gl.STENCIL_TEST);
				}

				this.stencil = enable;
			}
		};

		_proto.setStencilFunc = function setStencilFunc(func, ref, mask) {
			if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
				var gl = this.gl;
				gl.stencilFunc(this.glComparison[func], ref, mask);
				this.stencilFuncFront = this.stencilFuncBack = func;
				this.stencilRefFront = this.stencilRefBack = ref;
				this.stencilMaskFront = this.stencilMaskBack = mask;
			}
		};

		_proto.setStencilFuncFront = function setStencilFuncFront(func, ref, mask) {
			if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {
				var gl = this.gl;
				gl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);
				this.stencilFuncFront = func;
				this.stencilRefFront = ref;
				this.stencilMaskFront = mask;
			}
		};

		_proto.setStencilFuncBack = function setStencilFuncBack(func, ref, mask) {
			if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
				var gl = this.gl;
				gl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);
				this.stencilFuncBack = func;
				this.stencilRefBack = ref;
				this.stencilMaskBack = mask;
			}
		};

		_proto.setStencilOperation = function setStencilOperation(fail, zfail, zpass, writeMask) {
			if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
				this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
				this.stencilFailFront = this.stencilFailBack = fail;
				this.stencilZfailFront = this.stencilZfailBack = zfail;
				this.stencilZpassFront = this.stencilZpassBack = zpass;
			}

			if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {
				this.gl.stencilMask(writeMask);
				this.stencilWriteMaskFront = writeMask;
				this.stencilWriteMaskBack = writeMask;
			}
		};

		_proto.setStencilOperationFront = function setStencilOperationFront(fail, zfail, zpass, writeMask) {
			if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {
				this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
				this.stencilFailFront = fail;
				this.stencilZfailFront = zfail;
				this.stencilZpassFront = zpass;
			}

			if (this.stencilWriteMaskFront !== writeMask) {
				this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);
				this.stencilWriteMaskFront = writeMask;
			}
		};

		_proto.setStencilOperationBack = function setStencilOperationBack(fail, zfail, zpass, writeMask) {
			if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
				this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
				this.stencilFailBack = fail;
				this.stencilZfailBack = zfail;
				this.stencilZpassBack = zpass;
			}

			if (this.stencilWriteMaskBack !== writeMask) {
				this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);
				this.stencilWriteMaskBack = writeMask;
			}
		};

		_proto.setBlendFunction = function setBlendFunction(blendSrc, blendDst) {
			if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.separateAlphaBlend) {
				this.gl.blendFunc(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst]);
				this.blendSrc = blendSrc;
				this.blendDst = blendDst;
				this.separateAlphaBlend = false;
			}
		};

		_proto.setBlendFunctionSeparate = function setBlendFunctionSeparate(blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {
			if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.blendSrcAlpha !== blendSrcAlpha || this.blendDstAlpha !== blendDstAlpha || !this.separateAlphaBlend) {
				this.gl.blendFuncSeparate(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst], this.glBlendFunction[blendSrcAlpha], this.glBlendFunction[blendDstAlpha]);
				this.blendSrc = blendSrc;
				this.blendDst = blendDst;
				this.blendSrcAlpha = blendSrcAlpha;
				this.blendDstAlpha = blendDstAlpha;
				this.separateAlphaBlend = true;
			}
		};

		_proto.setBlendEquation = function setBlendEquation(blendEquation) {
			if (this.blendEquation !== blendEquation || this.separateAlphaEquation) {
				this.gl.blendEquation(this.glBlendEquation[blendEquation]);
				this.blendEquation = blendEquation;
				this.separateAlphaEquation = false;
			}
		};

		_proto.setBlendEquationSeparate = function setBlendEquationSeparate(blendEquation, blendAlphaEquation) {
			if (this.blendEquation !== blendEquation || this.blendAlphaEquation !== blendAlphaEquation || !this.separateAlphaEquation) {
				this.gl.blendEquationSeparate(this.glBlendEquation[blendEquation], this.glBlendEquation[blendAlphaEquation]);
				this.blendEquation = blendEquation;
				this.blendAlphaEquation = blendAlphaEquation;
				this.separateAlphaEquation = true;
			}
		};

		_proto.setBlendColor = function setBlendColor(r, g, b, a) {
			var c = this.blendColor;

			if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
				this.gl.blendColor(r, g, b, a);
				c.set(r, g, b, a);
			}
		};

		_proto.setCullMode = function setCullMode(cullMode) {
			if (this.cullMode !== cullMode) {
				if (cullMode === CULLFACE_NONE) {
					this.gl.disable(this.gl.CULL_FACE);
				} else {
					if (this.cullMode === CULLFACE_NONE) {
						this.gl.enable(this.gl.CULL_FACE);
					}

					var mode = this.glCull[cullMode];

					if (this.cullFace !== mode) {
						this.gl.cullFace(mode);
						this.cullFace = mode;
					}
				}

				this.cullMode = cullMode;
			}
		};

		_proto.getCullMode = function getCullMode() {
			return this.cullMode;
		};

		_proto.setIndexBuffer = function setIndexBuffer(indexBuffer) {
			this.indexBuffer = indexBuffer;
		};

		_proto.setVertexBuffer = function setVertexBuffer(vertexBuffer) {
			if (vertexBuffer) {
				this.vertexBuffers.push(vertexBuffer);
			}
		};

		_proto.setShader = function setShader(shader) {
			if (shader !== this.shader) {
				if (shader.failed) {
					return false;
				} else if (!shader.ready && !shader.impl.postLink(this, shader)) {
					shader.failed = true;
					return false;
				}

				this.shader = shader;
				this.gl.useProgram(shader.impl.glProgram);
				this._shaderSwitchesPerFrame++;
				this.attributesInvalidated = true;
			}

			return true;
		};

		_proto.getHdrFormat = function getHdrFormat() {
			if (this.textureHalfFloatRenderable) {
				return PIXELFORMAT_RGBA16F;
			} else if (this.textureFloatRenderable) {
				return PIXELFORMAT_RGBA32F;
			}

			return PIXELFORMAT_R8_G8_B8_A8;
		};

		_proto.getBoneLimit = function getBoneLimit() {
			return this.boneLimit;
		};

		_proto.setBoneLimit = function setBoneLimit(maxBones) {
			this.boneLimit = maxBones;
		};

		_proto.clearShaderCache = function clearShaderCache() {
			var gl = this.gl;

			for (var shaderSrc in this.fragmentShaderCache) {
				gl.deleteShader(this.fragmentShaderCache[shaderSrc]);
				delete this.fragmentShaderCache[shaderSrc];
			}

			for (var _shaderSrc in this.vertexShaderCache) {
				gl.deleteShader(this.vertexShaderCache[_shaderSrc]);
				delete this.vertexShaderCache[_shaderSrc];
			}

			this.programLib.clearCache();
		};

		_proto.clearVertexArrayObjectCache = function clearVertexArrayObjectCache() {
			var gl = this.gl;

			this._vaoMap.forEach(function (item, key, mapObj) {
				gl.deleteVertexArray(item);
			});

			this._vaoMap.clear();
		};

		_proto.removeShaderFromCache = function removeShaderFromCache(shader) {
			this.programLib.removeFromCache(shader);
		};

		_createClass(WebglGraphicsDevice, [{
			key: "width",
			get: function get() {
				return this.gl.drawingBufferWidth || this.canvas.width;
			}
		}, {
			key: "height",
			get: function get() {
				return this.gl.drawingBufferHeight || this.canvas.height;
			}
		}, {
			key: "fullscreen",
			get: function get() {
				return !!document.fullscreenElement;
			},
			set: function set(fullscreen) {
				if (fullscreen) {
					var canvas = this.gl.canvas;
					canvas.requestFullscreen();
				} else {
					document.exitFullscreen();
				}
			}
		}, {
			key: "textureFloatHighPrecision",
			get: function get() {
				if (this._textureFloatHighPrecision === undefined) {
					this._textureFloatHighPrecision = testTextureFloatHighPrecision(this);
				}

				return this._textureFloatHighPrecision;
			}
		}, {
			key: "textureHalfFloatUpdatable",
			get: function get() {
				if (this._textureHalfFloatUpdatable === undefined) {
					if (this.webgl2) {
						this._textureHalfFloatUpdatable = true;
					} else {
						this._textureHalfFloatUpdatable = testTextureHalfFloatUpdatable(this.gl, this.extTextureHalfFloat.HALF_FLOAT_OES);
					}
				}

				return this._textureHalfFloatUpdatable;
			}
		}]);

		return WebglGraphicsDevice;
	}(GraphicsDevice);

	var RefCountedObject = function () {
		function RefCountedObject() {
			this._refCount = 0;
		}

		var _proto = RefCountedObject.prototype;

		_proto.incRefCount = function incRefCount() {
			this._refCount++;
		};

		_proto.decRefCount = function decRefCount() {
			this._refCount--;
		};

		_createClass(RefCountedObject, [{
			key: "refCount",
			get: function get() {
				return this._refCount;
			}
		}]);

		return RefCountedObject;
	}();

	var currentApplication;

	function getApplication() {
		return currentApplication;
	}

	function setApplication(app) {
		currentApplication = app;
	}

	var id$1 = 0;

	var GeometryData = function () {
		function GeometryData() {
			this.initDefaults();
		}

		var _proto = GeometryData.prototype;

		_proto.initDefaults = function initDefaults() {
			this.recreate = false;
			this.verticesUsage = BUFFER_STATIC;
			this.indicesUsage = BUFFER_STATIC;
			this.maxVertices = 0;
			this.maxIndices = 0;
			this.vertexCount = 0;
			this.indexCount = 0;
			this.vertexStreamsUpdated = false;
			this.indexStreamUpdated = false;
			this.vertexStreamDictionary = {};
			this.indices = null;
		};

		_proto._changeVertexCount = function _changeVertexCount(count, semantic) {
			if (!this.vertexCount) {
				this.vertexCount = count;
			} else {
				Debug.assert(this.vertexCount === count, "Vertex stream " + semantic + " has " + count + " vertices, which does not match already set streams with " + this.vertexCount + " vertices.");
			}
		};

		return GeometryData;
	}();

	GeometryData.DEFAULT_COMPONENTS_POSITION = 3;
	GeometryData.DEFAULT_COMPONENTS_NORMAL = 3;
	GeometryData.DEFAULT_COMPONENTS_UV = 2;
	GeometryData.DEFAULT_COMPONENTS_COLORS = 4;

	var GeometryVertexStream = function GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize) {
		this.data = data;
		this.componentCount = componentCount;
		this.dataType = dataType;
		this.dataTypeNormalize = dataTypeNormalize;
	};

	var Mesh = function (_RefCountedObject) {
		_inheritsLoose(Mesh, _RefCountedObject);

		function Mesh(graphicsDevice) {
			var _this;

			_this = _RefCountedObject.call(this) || this;
			_this.id = id$1++;
			_this.device = graphicsDevice || getApplication().graphicsDevice;
			_this.vertexBuffer = null;
			_this.indexBuffer = [null];
			_this.primitive = [{
				type: 0,
				base: 0,
				count: 0
			}];
			_this.skin = null;
			_this._morph = null;
			_this._geometryData = null;
			_this._aabb = new BoundingBox();
			_this.boneAabb = null;
			return _this;
		}

		var _proto2 = Mesh.prototype;

		_proto2.destroy = function destroy() {
			var morph = this.morph;

			if (morph) {
				this.morph = null;

				if (morph.refCount < 1) {
					morph.destroy();
				}
			}

			if (this.vertexBuffer) {
				this.vertexBuffer.destroy();
				this.vertexBuffer = null;
			}

			for (var j = 0; j < this.indexBuffer.length; j++) {
				this._destroyIndexBuffer(j);
			}

			this.indexBuffer.length = 0;
			this._geometryData = null;
		};

		_proto2._destroyIndexBuffer = function _destroyIndexBuffer(index) {
			if (this.indexBuffer[index]) {
				this.indexBuffer[index].destroy();
				this.indexBuffer[index] = null;
			}
		};

		_proto2._initBoneAabbs = function _initBoneAabbs(morphTargets) {
			this.boneAabb = [];
			this.boneUsed = [];
			var x, y, z;
			var bMax, bMin;
			var boneMin = [];
			var boneMax = [];
			var boneUsed = this.boneUsed;
			var numBones = this.skin.boneNames.length;
			var maxMorphX, maxMorphY, maxMorphZ;

			for (var i = 0; i < numBones; i++) {
				boneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
				boneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
			}

			var iterator = new VertexIterator(this.vertexBuffer);
			var posElement = iterator.element[SEMANTIC_POSITION];
			var weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];
			var indicesElement = iterator.element[SEMANTIC_BLENDINDICES];
			var numVerts = this.vertexBuffer.numVertices;

			for (var j = 0; j < numVerts; j++) {
				for (var k = 0; k < 4; k++) {
					var boneWeight = weightsElement.array[weightsElement.index + k];

					if (boneWeight > 0) {
						var boneIndex = indicesElement.array[indicesElement.index + k];
						boneUsed[boneIndex] = true;
						x = posElement.array[posElement.index];
						y = posElement.array[posElement.index + 1];
						z = posElement.array[posElement.index + 2];
						bMax = boneMax[boneIndex];
						bMin = boneMin[boneIndex];
						if (bMin.x > x) bMin.x = x;
						if (bMin.y > y) bMin.y = y;
						if (bMin.z > z) bMin.z = z;
						if (bMax.x < x) bMax.x = x;
						if (bMax.y < y) bMax.y = y;
						if (bMax.z < z) bMax.z = z;

						if (morphTargets) {
							var minMorphX = maxMorphX = x;
							var minMorphY = maxMorphY = y;
							var minMorphZ = maxMorphZ = z;

							for (var l = 0; l < morphTargets.length; l++) {
								var target = morphTargets[l];
								var dx = target.deltaPositions[j * 3];
								var dy = target.deltaPositions[j * 3 + 1];
								var dz = target.deltaPositions[j * 3 + 2];

								if (dx < 0) {
									minMorphX += dx;
								} else {
									maxMorphX += dx;
								}

								if (dy < 0) {
									minMorphY += dy;
								} else {
									maxMorphY += dy;
								}

								if (dz < 0) {
									minMorphZ += dz;
								} else {
									maxMorphZ += dz;
								}
							}

							if (bMin.x > minMorphX) bMin.x = minMorphX;
							if (bMin.y > minMorphY) bMin.y = minMorphY;
							if (bMin.z > minMorphZ) bMin.z = minMorphZ;
							if (bMax.x < maxMorphX) bMax.x = maxMorphX;
							if (bMax.y < maxMorphY) bMax.y = maxMorphY;
							if (bMax.z < maxMorphZ) bMax.z = maxMorphZ;
						}
					}
				}

				iterator.next();
			}

			var positionElement = this.vertexBuffer.getFormat().elements.find(function (e) {
				return e.name === SEMANTIC_POSITION;
			});

			if (positionElement && positionElement.normalize) {
				var func = function () {
					switch (positionElement.dataType) {
						case TYPE_INT8:
							return function (x) {
								return Math.max(x / 127.0, -1.0);
							};

						case TYPE_UINT8:
							return function (x) {
								return x / 255.0;
							};

						case TYPE_INT16:
							return function (x) {
								return Math.max(x / 32767.0, -1.0);
							};

						case TYPE_UINT16:
							return function (x) {
								return x / 65535.0;
							};

						default:
							return function (x) {
								return x;
							};
					}
				}();

				for (var _i = 0; _i < numBones; _i++) {
					if (boneUsed[_i]) {
						var min = boneMin[_i];
						var max = boneMax[_i];
						min.set(func(min.x), func(min.y), func(min.z));
						max.set(func(max.x), func(max.y), func(max.z));
					}
				}
			}

			for (var _i2 = 0; _i2 < numBones; _i2++) {
				var aabb = new BoundingBox();
				aabb.setMinMax(boneMin[_i2], boneMax[_i2]);
				this.boneAabb.push(aabb);
			}
		};

		_proto2._initGeometryData = function _initGeometryData() {
			if (!this._geometryData) {
				this._geometryData = new GeometryData();

				if (this.vertexBuffer) {
					this._geometryData.vertexCount = this.vertexBuffer.numVertices;
					this._geometryData.maxVertices = this.vertexBuffer.numVertices;
				}

				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					this._geometryData.indexCount = this.indexBuffer[0].numIndices;
					this._geometryData.maxIndices = this.indexBuffer[0].numIndices;
				}
			}
		};

		_proto2.clear = function clear(verticesDynamic, indicesDynamic, maxVertices, maxIndices) {
			if (maxVertices === void 0) {
				maxVertices = 0;
			}

			if (maxIndices === void 0) {
				maxIndices = 0;
			}

			this._initGeometryData();

			this._geometryData.initDefaults();

			this._geometryData.recreate = true;
			this._geometryData.maxVertices = maxVertices;
			this._geometryData.maxIndices = maxIndices;
			this._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
			this._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
		};

		_proto2.setVertexStream = function setVertexStream(semantic, data, componentCount, numVertices, dataType, dataTypeNormalize) {
			if (dataType === void 0) {
				dataType = TYPE_FLOAT32;
			}

			if (dataTypeNormalize === void 0) {
				dataTypeNormalize = false;
			}

			this._initGeometryData();

			var vertexCount = numVertices || data.length / componentCount;

			this._geometryData._changeVertexCount(vertexCount, semantic);

			this._geometryData.vertexStreamsUpdated = true;
			this._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize);
		};

		_proto2.getVertexStream = function getVertexStream(semantic, data) {
			var count = 0;
			var done = false;

			if (this._geometryData) {
				var stream = this._geometryData.vertexStreamDictionary[semantic];

				if (stream) {
					done = true;
					count = this._geometryData.vertexCount;

					if (ArrayBuffer.isView(data)) {
						data.set(stream.data);
					} else {
						data.length = 0;
						data.push(stream.data);
					}
				}
			}

			if (!done) {
				if (this.vertexBuffer) {
					var iterator = new VertexIterator(this.vertexBuffer);
					count = iterator.readData(semantic, data);
				}
			}

			return count;
		};

		_proto2.setPositions = function setPositions(positions, componentCount, numVertices) {
			if (componentCount === void 0) {
				componentCount = GeometryData.DEFAULT_COMPONENTS_POSITION;
			}

			this.setVertexStream(SEMANTIC_POSITION, positions, componentCount, numVertices, TYPE_FLOAT32, false);
		};

		_proto2.setNormals = function setNormals(normals, componentCount, numVertices) {
			if (componentCount === void 0) {
				componentCount = GeometryData.DEFAULT_COMPONENTS_NORMAL;
			}

			this.setVertexStream(SEMANTIC_NORMAL, normals, componentCount, numVertices, TYPE_FLOAT32, false);
		};

		_proto2.setUvs = function setUvs(channel, uvs, componentCount, numVertices) {
			if (componentCount === void 0) {
				componentCount = GeometryData.DEFAULT_COMPONENTS_UV;
			}

			this.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount, numVertices, TYPE_FLOAT32, false);
		};

		_proto2.setColors = function setColors(colors, componentCount, numVertices) {
			if (componentCount === void 0) {
				componentCount = GeometryData.DEFAULT_COMPONENTS_COLORS;
			}

			this.setVertexStream(SEMANTIC_COLOR, colors, componentCount, numVertices, TYPE_FLOAT32, false);
		};

		_proto2.setColors32 = function setColors32(colors, numVertices) {
			this.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);
		};

		_proto2.setIndices = function setIndices(indices, numIndices) {
			this._initGeometryData();

			this._geometryData.indexStreamUpdated = true;
			this._geometryData.indices = indices;
			this._geometryData.indexCount = numIndices || indices.length;
		};

		_proto2.getPositions = function getPositions(positions) {
			return this.getVertexStream(SEMANTIC_POSITION, positions);
		};

		_proto2.getNormals = function getNormals(normals) {
			return this.getVertexStream(SEMANTIC_NORMAL, normals);
		};

		_proto2.getUvs = function getUvs(channel, uvs) {
			return this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);
		};

		_proto2.getColors = function getColors(colors) {
			return this.getVertexStream(SEMANTIC_COLOR, colors);
		};

		_proto2.getIndices = function getIndices(indices) {
			var count = 0;

			if (this._geometryData && this._geometryData.indices) {
				var streamIndices = this._geometryData.indices;
				count = this._geometryData.indexCount;

				if (ArrayBuffer.isView(indices)) {
					indices.set(streamIndices);
				} else {
					indices.length = 0;
					indices.push(streamIndices);
				}
			} else {
				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					var indexBuffer = this.indexBuffer[0];
					count = indexBuffer.readData(indices);
				}
			}

			return count;
		};

		_proto2.update = function update(primitiveType, updateBoundingBox) {
			if (primitiveType === void 0) {
				primitiveType = PRIMITIVE_TRIANGLES;
			}

			if (updateBoundingBox === void 0) {
				updateBoundingBox = true;
			}

			if (this._geometryData) {
				if (updateBoundingBox) {
					var stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];

					if (stream) {
						if (stream.componentCount === 3) {
							this._aabb.compute(stream.data, this._geometryData.vertexCount);
						}
					}
				}

				var destroyVB = this._geometryData.recreate;

				if (this._geometryData.vertexCount > this._geometryData.maxVertices) {
					destroyVB = true;
					this._geometryData.maxVertices = this._geometryData.vertexCount;
				}

				if (destroyVB) {
					if (this.vertexBuffer) {
						this.vertexBuffer.destroy();
						this.vertexBuffer = null;
					}
				}

				var destroyIB = this._geometryData.recreate;

				if (this._geometryData.indexCount > this._geometryData.maxIndices) {
					destroyIB = true;
					this._geometryData.maxIndices = this._geometryData.indexCount;
				}

				if (destroyIB) {
					if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
						this.indexBuffer[0].destroy();
						this.indexBuffer[0] = null;
					}
				}

				if (this._geometryData.vertexStreamsUpdated) {
					this._updateVertexBuffer();
				}

				if (this._geometryData.indexStreamUpdated) {
					this._updateIndexBuffer();
				}

				this.primitive[0].type = primitiveType;

				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					if (this._geometryData.indexStreamUpdated) {
						this.primitive[0].count = this._geometryData.indexCount;
						this.primitive[0].indexed = true;
					}
				} else {
					if (this._geometryData.vertexStreamsUpdated) {
						this.primitive[0].count = this._geometryData.vertexCount;
						this.primitive[0].indexed = false;
					}
				}

				this._geometryData.vertexCount = 0;
				this._geometryData.indexCount = 0;
				this._geometryData.vertexStreamsUpdated = false;
				this._geometryData.indexStreamUpdated = false;
				this._geometryData.recreate = false;
				this.updateRenderStates();
			}
		};

		_proto2._buildVertexFormat = function _buildVertexFormat(vertexCount) {
			var vertexDesc = [];

			for (var semantic in this._geometryData.vertexStreamDictionary) {
				var stream = this._geometryData.vertexStreamDictionary[semantic];
				vertexDesc.push({
					semantic: semantic,
					components: stream.componentCount,
					type: stream.dataType,
					normalize: stream.dataTypeNormalize
				});
			}

			return new VertexFormat(this.device, vertexDesc, vertexCount);
		};

		_proto2._updateVertexBuffer = function _updateVertexBuffer() {
			if (!this.vertexBuffer) {
				var allocateVertexCount = this._geometryData.maxVertices;

				var format = this._buildVertexFormat(allocateVertexCount);

				this.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, this._geometryData.verticesUsage);
			}

			var iterator = new VertexIterator(this.vertexBuffer);
			var numVertices = this._geometryData.vertexCount;

			for (var semantic in this._geometryData.vertexStreamDictionary) {
				var stream = this._geometryData.vertexStreamDictionary[semantic];
				iterator.writeData(semantic, stream.data, numVertices);
				delete this._geometryData.vertexStreamDictionary[semantic];
			}

			iterator.end();
		};

		_proto2._updateIndexBuffer = function _updateIndexBuffer() {
			if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
				var createFormat = this._geometryData.maxVertices > 0xffff ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
				this.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage);
			}

			var srcIndices = this._geometryData.indices;

			if (srcIndices) {
				var indexBuffer = this.indexBuffer[0];
				indexBuffer.writeData(srcIndices, this._geometryData.indexCount);
				this._geometryData.indices = null;
			}
		};

		_proto2.prepareRenderState = function prepareRenderState(renderStyle) {
			if (renderStyle === RENDERSTYLE_WIREFRAME) {
				this.generateWireframe();
			} else if (renderStyle === RENDERSTYLE_POINTS) {
				this.primitive[RENDERSTYLE_POINTS] = {
					type: PRIMITIVE_POINTS,
					base: 0,
					count: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,
					indexed: false
				};
			}
		};

		_proto2.updateRenderStates = function updateRenderStates() {
			if (this.primitive[RENDERSTYLE_POINTS]) {
				this.prepareRenderState(RENDERSTYLE_POINTS);
			}

			if (this.primitive[RENDERSTYLE_WIREFRAME]) {
				this.prepareRenderState(RENDERSTYLE_WIREFRAME);
			}
		};

		_proto2.generateWireframe = function generateWireframe() {
			this._destroyIndexBuffer(RENDERSTYLE_WIREFRAME);

			var lines = [];
			var format;

			if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
				var offsets = [[0, 1], [1, 2], [2, 0]];
				var base = this.primitive[RENDERSTYLE_SOLID].base;
				var count = this.primitive[RENDERSTYLE_SOLID].count;
				var indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];
				var srcIndices = new typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);
				var uniqueLineIndices = {};

				for (var j = base; j < base + count; j += 3) {
					for (var k = 0; k < 3; k++) {
						var i1 = srcIndices[j + offsets[k][0]];
						var i2 = srcIndices[j + offsets[k][1]];
						var line = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;

						if (uniqueLineIndices[line] === undefined) {
							uniqueLineIndices[line] = 0;
							lines.push(i1, i2);
						}
					}
				}

				format = indexBuffer.format;
			} else {
				for (var i = 0; i < this.vertexBuffer.numVertices; i += 3) {
					lines.push(i, i + 1, i + 1, i + 2, i + 2, i);
				}

				format = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
			}

			var wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);
			var dstIndices = new typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);
			dstIndices.set(lines);
			wireBuffer.unlock();
			this.primitive[RENDERSTYLE_WIREFRAME] = {
				type: PRIMITIVE_LINES,
				base: 0,
				count: lines.length,
				indexed: true
			};
			this.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;
		};

		_createClass(Mesh, [{
			key: "morph",
			get: function get() {
				return this._morph;
			},
			set: function set(morph) {
				if (morph !== this._morph) {
					if (this._morph) {
						this._morph.decRefCount();
					}

					this._morph = morph;

					if (morph) {
						morph.incRefCount();
					}
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				return this._aabb;
			},
			set: function set(aabb) {
				this._aabb = aabb;
			}
		}]);

		return Mesh;
	}(RefCountedObject);

	var primitiveUv1Padding = 4.0 / 64;
	var primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;
	var shapePrimitives = [];

	function calculateNormals(positions, indices) {
		var triangleCount = indices.length / 3;
		var vertexCount = positions.length / 3;
		var p1 = new Vec3();
		var p2 = new Vec3();
		var p3 = new Vec3();
		var p1p2 = new Vec3();
		var p1p3 = new Vec3();
		var faceNormal = new Vec3();
		var normals = [];

		for (var i = 0; i < positions.length; i++) {
			normals[i] = 0;
		}

		for (var _i = 0; _i < triangleCount; _i++) {
			var i1 = indices[_i * 3];
			var i2 = indices[_i * 3 + 1];
			var i3 = indices[_i * 3 + 2];
			p1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
			p2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
			p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
			p1p2.sub2(p2, p1);
			p1p3.sub2(p3, p1);
			faceNormal.cross(p1p2, p1p3).normalize();
			normals[i1 * 3] += faceNormal.x;
			normals[i1 * 3 + 1] += faceNormal.y;
			normals[i1 * 3 + 2] += faceNormal.z;
			normals[i2 * 3] += faceNormal.x;
			normals[i2 * 3 + 1] += faceNormal.y;
			normals[i2 * 3 + 2] += faceNormal.z;
			normals[i3 * 3] += faceNormal.x;
			normals[i3 * 3 + 1] += faceNormal.y;
			normals[i3 * 3 + 2] += faceNormal.z;
		}

		for (var _i2 = 0; _i2 < vertexCount; _i2++) {
			var nx = normals[_i2 * 3];
			var ny = normals[_i2 * 3 + 1];
			var nz = normals[_i2 * 3 + 2];
			var invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
			normals[_i2 * 3] *= invLen;
			normals[_i2 * 3 + 1] *= invLen;
			normals[_i2 * 3 + 2] *= invLen;
		}

		return normals;
	}

	function calculateTangents(positions, normals, uvs, indices) {
		var triangleCount = indices.length / 3;
		var vertexCount = positions.length / 3;
		var v1 = new Vec3();
		var v2 = new Vec3();
		var v3 = new Vec3();
		var w1 = new Vec2();
		var w2 = new Vec2();
		var w3 = new Vec2();
		var sdir = new Vec3();
		var tdir = new Vec3();
		var tan1 = new Float32Array(vertexCount * 3);
		var tan2 = new Float32Array(vertexCount * 3);
		var tangents = [];

		for (var i = 0; i < triangleCount; i++) {
			var i1 = indices[i * 3];
			var i2 = indices[i * 3 + 1];
			var i3 = indices[i * 3 + 2];
			v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
			v2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
			v3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
			w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);
			w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);
			w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);
			var x1 = v2.x - v1.x;
			var x2 = v3.x - v1.x;
			var y1 = v2.y - v1.y;
			var y2 = v3.y - v1.y;
			var z1 = v2.z - v1.z;
			var z2 = v3.z - v1.z;
			var s1 = w2.x - w1.x;
			var s2 = w3.x - w1.x;

			var _t = w2.y - w1.y;

			var _t2 = w3.y - w1.y;

			var area = s1 * _t2 - s2 * _t;

			if (area === 0) {
				sdir.set(0, 1, 0);
				tdir.set(1, 0, 0);
			} else {
				var r = 1 / area;
				sdir.set((_t2 * x1 - _t * x2) * r, (_t2 * y1 - _t * y2) * r, (_t2 * z1 - _t * z2) * r);
				tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
			}

			tan1[i1 * 3 + 0] += sdir.x;
			tan1[i1 * 3 + 1] += sdir.y;
			tan1[i1 * 3 + 2] += sdir.z;
			tan1[i2 * 3 + 0] += sdir.x;
			tan1[i2 * 3 + 1] += sdir.y;
			tan1[i2 * 3 + 2] += sdir.z;
			tan1[i3 * 3 + 0] += sdir.x;
			tan1[i3 * 3 + 1] += sdir.y;
			tan1[i3 * 3 + 2] += sdir.z;
			tan2[i1 * 3 + 0] += tdir.x;
			tan2[i1 * 3 + 1] += tdir.y;
			tan2[i1 * 3 + 2] += tdir.z;
			tan2[i2 * 3 + 0] += tdir.x;
			tan2[i2 * 3 + 1] += tdir.y;
			tan2[i2 * 3 + 2] += tdir.z;
			tan2[i3 * 3 + 0] += tdir.x;
			tan2[i3 * 3 + 1] += tdir.y;
			tan2[i3 * 3 + 2] += tdir.z;
		}

		var t1 = new Vec3();
		var t2 = new Vec3();
		var n = new Vec3();
		var temp = new Vec3();

		for (var _i3 = 0; _i3 < vertexCount; _i3++) {
			n.set(normals[_i3 * 3], normals[_i3 * 3 + 1], normals[_i3 * 3 + 2]);
			t1.set(tan1[_i3 * 3], tan1[_i3 * 3 + 1], tan1[_i3 * 3 + 2]);
			t2.set(tan2[_i3 * 3], tan2[_i3 * 3 + 1], tan2[_i3 * 3 + 2]);
			var ndott = n.dot(t1);
			temp.copy(n).mulScalar(ndott);
			temp.sub2(t1, temp).normalize();
			tangents[_i3 * 4] = temp.x;
			tangents[_i3 * 4 + 1] = temp.y;
			tangents[_i3 * 4 + 2] = temp.z;
			temp.cross(n, t1);
			tangents[_i3 * 4 + 3] = temp.dot(t2) < 0.0 ? -1.0 : 1.0;
		}

		return tangents;
	}

	function createMesh$1(device, positions, opts) {
		var mesh = new Mesh(device);
		mesh.setPositions(positions);

		if (opts) {
			if (opts.normals) {
				mesh.setNormals(opts.normals);
			}

			if (opts.tangents) {
				mesh.setVertexStream(SEMANTIC_TANGENT, opts.tangents, 4);
			}

			if (opts.colors) {
				mesh.setColors32(opts.colors);
			}

			if (opts.uvs) {
				mesh.setUvs(0, opts.uvs);
			}

			if (opts.uvs1) {
				mesh.setUvs(1, opts.uvs1);
			}

			if (opts.blendIndices) {
				mesh.setVertexStream(SEMANTIC_BLENDINDICES, opts.blendIndices, 4, opts.blendIndices.length / 4, TYPE_UINT8);
			}

			if (opts.blendWeights) {
				mesh.setVertexStream(SEMANTIC_BLENDWEIGHT, opts.blendWeights, 4);
			}

			if (opts.indices) {
				mesh.setIndices(opts.indices);
			}
		}

		mesh.update();
		return mesh;
	}

	function createTorus(device, opts) {
		var rc = opts && opts.tubeRadius !== undefined ? opts.tubeRadius : 0.2;
		var rt = opts && opts.ringRadius !== undefined ? opts.ringRadius : 0.3;
		var segments = opts && opts.segments !== undefined ? opts.segments : 30;
		var sides = opts && opts.sides !== undefined ? opts.sides : 20;
		var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
		var positions = [];
		var normals = [];
		var uvs = [];
		var indices = [];

		for (var i = 0; i <= sides; i++) {
			for (var j = 0; j <= segments; j++) {
				var x = Math.cos(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
				var y = Math.sin(2 * Math.PI * i / sides) * rc;
				var z = Math.sin(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
				var nx = Math.cos(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);
				var ny = Math.sin(2 * Math.PI * i / sides);
				var nz = Math.sin(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);
				var u = i / sides;
				var v = 1 - j / segments;
				positions.push(x, y, z);
				normals.push(nx, ny, nz);
				uvs.push(u, 1.0 - v);

				if (i < sides && j < segments) {
					var first = i * (segments + 1) + j;
					var second = (i + 1) * (segments + 1) + j;
					var third = i * (segments + 1) + (j + 1);
					var fourth = (i + 1) * (segments + 1) + (j + 1);
					indices.push(first, second, third);
					indices.push(second, fourth, third);
				}
			}
		}

		var options = {
			normals: normals,
			uvs: uvs,
			indices: indices
		};

		if (calcTangents) {
			options.tangents = calculateTangents(positions, normals, uvs, indices);
		}

		return createMesh$1(device, positions, options);
	}

	function _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {
		var pos = new Vec3();
		var bottomToTop = new Vec3();
		var norm = new Vec3();
		var top = new Vec3();
		var bottom = new Vec3();
		var tangent = new Vec3();
		var positions = [];
		var normals = [];
		var uvs = [];
		var uvs1 = [];
		var indices = [];
		var offset;

		if (height > 0) {
			for (var i = 0; i <= heightSegments; i++) {
				for (var j = 0; j <= capSegments; j++) {
					var theta = j / capSegments * 2 * Math.PI - Math.PI;
					var sinTheta = Math.sin(theta);
					var cosTheta = Math.cos(theta);
					bottom.set(sinTheta * baseRadius, -height / 2, cosTheta * baseRadius);
					top.set(sinTheta * peakRadius, height / 2, cosTheta * peakRadius);
					pos.lerp(bottom, top, i / heightSegments);
					bottomToTop.sub2(top, bottom).normalize();
					tangent.set(cosTheta, 0, -sinTheta);
					norm.cross(tangent, bottomToTop).normalize();
					positions.push(pos.x, pos.y, pos.z);
					normals.push(norm.x, norm.y, norm.z);
					var u = j / capSegments;
					var v = i / heightSegments;
					uvs.push(u, 1 - v);
					var _v = v;
					v = u;
					u = _v;
					u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
					v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
					u /= 3;
					uvs1.push(u, 1 - v);

					if (i < heightSegments && j < capSegments) {
						var first = i * (capSegments + 1) + j;
						var second = i * (capSegments + 1) + (j + 1);
						var third = (i + 1) * (capSegments + 1) + j;
						var fourth = (i + 1) * (capSegments + 1) + (j + 1);
						indices.push(first, second, third);
						indices.push(second, fourth, third);
					}
				}
			}
		}

		if (roundedCaps) {
			var latitudeBands = Math.floor(capSegments / 2);
			var longitudeBands = capSegments;
			var capOffset = height / 2;

			for (var lat = 0; lat <= latitudeBands; lat++) {
				var _theta = lat * Math.PI * 0.5 / latitudeBands;

				var _sinTheta = Math.sin(_theta);

				var _cosTheta = Math.cos(_theta);

				for (var lon = 0; lon <= longitudeBands; lon++) {
					var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
					var sinPhi = Math.sin(phi);
					var cosPhi = Math.cos(phi);
					var x = cosPhi * _sinTheta;
					var y = _cosTheta;
					var z = sinPhi * _sinTheta;

					var _u = 1 - lon / longitudeBands;

					var _v2 = 1 - lat / latitudeBands;

					positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);
					normals.push(x, y, z);
					uvs.push(_u, 1 - _v2);
					_u = _u * primitiveUv1PaddingScale + primitiveUv1Padding;
					_v2 = _v2 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_u /= 3;
					_v2 /= 3;
					_u += 1.0 / 3;
					uvs1.push(_u, 1 - _v2);
				}
			}

			offset = (heightSegments + 1) * (capSegments + 1);

			for (var _lat = 0; _lat < latitudeBands; ++_lat) {
				for (var _lon = 0; _lon < longitudeBands; ++_lon) {
					var _first = _lat * (longitudeBands + 1) + _lon;

					var _second = _first + longitudeBands + 1;

					indices.push(offset + _first + 1, offset + _second, offset + _first);
					indices.push(offset + _first + 1, offset + _second + 1, offset + _second);
				}
			}

			for (var _lat2 = 0; _lat2 <= latitudeBands; _lat2++) {
				var _theta2 = Math.PI * 0.5 + _lat2 * Math.PI * 0.5 / latitudeBands;

				var _sinTheta2 = Math.sin(_theta2);

				var _cosTheta2 = Math.cos(_theta2);

				for (var _lon2 = 0; _lon2 <= longitudeBands; _lon2++) {
					var _phi = _lon2 * 2 * Math.PI / longitudeBands - Math.PI / 2;

					var _sinPhi = Math.sin(_phi);

					var _cosPhi = Math.cos(_phi);

					var _x = _cosPhi * _sinTheta2;

					var _y = _cosTheta2;

					var _z = _sinPhi * _sinTheta2;

					var _u2 = 1 - _lon2 / longitudeBands;

					var _v3 = 1 - _lat2 / latitudeBands;

					positions.push(_x * peakRadius, _y * peakRadius - capOffset, _z * peakRadius);
					normals.push(_x, _y, _z);
					uvs.push(_u2, 1 - _v3);
					_u2 = _u2 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_v3 = _v3 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_u2 /= 3;
					_v3 /= 3;
					_u2 += 2.0 / 3;
					uvs1.push(_u2, 1 - _v3);
				}
			}

			offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);

			for (var _lat3 = 0; _lat3 < latitudeBands; ++_lat3) {
				for (var _lon3 = 0; _lon3 < longitudeBands; ++_lon3) {
					var _first2 = _lat3 * (longitudeBands + 1) + _lon3;

					var _second2 = _first2 + longitudeBands + 1;

					indices.push(offset + _first2 + 1, offset + _second2, offset + _first2);
					indices.push(offset + _first2 + 1, offset + _second2 + 1, offset + _second2);
				}
			}
		} else {
			offset = (heightSegments + 1) * (capSegments + 1);

			if (baseRadius > 0) {
				for (var _i4 = 0; _i4 < capSegments; _i4++) {
					var _theta3 = _i4 / capSegments * 2 * Math.PI;

					var _x2 = Math.sin(_theta3);

					var _y2 = -height / 2;

					var _z2 = Math.cos(_theta3);

					var _u3 = 1 - (_x2 + 1) / 2;

					var _v4 = (_z2 + 1) / 2;

					positions.push(_x2 * baseRadius, _y2, _z2 * baseRadius);
					normals.push(0, -1, 0);
					uvs.push(_u3, 1 - _v4);
					_u3 = _u3 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_v4 = _v4 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_u3 /= 3;
					_v4 /= 3;
					_u3 += 1 / 3;
					uvs1.push(_u3, 1 - _v4);

					if (_i4 > 1) {
						indices.push(offset, offset + _i4, offset + _i4 - 1);
					}
				}
			}

			offset += capSegments;

			if (peakRadius > 0) {
				for (var _i5 = 0; _i5 < capSegments; _i5++) {
					var _theta4 = _i5 / capSegments * 2 * Math.PI;

					var _x3 = Math.sin(_theta4);

					var _y3 = height / 2;

					var _z3 = Math.cos(_theta4);

					var _u4 = 1 - (_x3 + 1) / 2;

					var _v5 = (_z3 + 1) / 2;

					positions.push(_x3 * peakRadius, _y3, _z3 * peakRadius);
					normals.push(0, 1, 0);
					uvs.push(_u4, 1 - _v5);
					_u4 = _u4 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_v5 = _v5 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_u4 /= 3;
					_v5 /= 3;
					_u4 += 2 / 3;
					uvs1.push(_u4, 1 - _v5);

					if (_i5 > 1) {
						indices.push(offset, offset + _i5 - 1, offset + _i5);
					}
				}
			}
		}

		return {
			positions: positions,
			normals: normals,
			uvs: uvs,
			uvs1: uvs1,
			indices: indices
		};
	}

	function createCylinder(device, opts) {
		if (opts && opts.hasOwnProperty('baseRadius') && !opts.hasOwnProperty('radius')) {
			Debug.deprecated('"baseRadius" in arguments, use "radius" instead');
		}

		var radius = opts && (opts.radius || opts.baseRadius);
		radius = radius !== undefined ? radius : 0.5;
		var height = opts && opts.height !== undefined ? opts.height : 1.0;
		var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
		var capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 20;
		var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

		var options = _createConeData(radius, radius, height, heightSegments, capSegments, false);

		if (calcTangents) {
			options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
		}

		return createMesh$1(device, options.positions, options);
	}

	function createCapsule(device, opts) {
		var radius = opts && opts.radius !== undefined ? opts.radius : 0.3;
		var height = opts && opts.height !== undefined ? opts.height : 1.0;
		var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
		var sides = opts && opts.sides !== undefined ? opts.sides : 20;
		var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

		var options = _createConeData(radius, radius, height - 2 * radius, heightSegments, sides, true);

		if (calcTangents) {
			options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
		}

		return createMesh$1(device, options.positions, options);
	}

	function createCone(device, opts) {
		var baseRadius = opts && opts.baseRadius !== undefined ? opts.baseRadius : 0.5;
		var peakRadius = opts && opts.peakRadius !== undefined ? opts.peakRadius : 0.0;
		var height = opts && opts.height !== undefined ? opts.height : 1.0;
		var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
		var capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 18;
		var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

		var options = _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, false);

		if (calcTangents) {
			options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
		}

		return createMesh$1(device, options.positions, options);
	}

	function createSphere(device, opts) {
		var radius = opts && opts.radius !== undefined ? opts.radius : 0.5;
		var latitudeBands = opts && opts.latitudeBands !== undefined ? opts.latitudeBands : 16;
		var longitudeBands = opts && opts.longitudeBands !== undefined ? opts.longitudeBands : 16;
		var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
		var positions = [];
		var normals = [];
		var uvs = [];
		var indices = [];

		for (var lat = 0; lat <= latitudeBands; lat++) {
			var theta = lat * Math.PI / latitudeBands;
			var sinTheta = Math.sin(theta);
			var cosTheta = Math.cos(theta);

			for (var lon = 0; lon <= longitudeBands; lon++) {
				var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
				var sinPhi = Math.sin(phi);
				var cosPhi = Math.cos(phi);
				var x = cosPhi * sinTheta;
				var y = cosTheta;
				var z = sinPhi * sinTheta;
				var u = 1 - lon / longitudeBands;
				var v = 1 - lat / latitudeBands;
				positions.push(x * radius, y * radius, z * radius);
				normals.push(x, y, z);
				uvs.push(u, 1 - v);
			}
		}

		for (var _lat4 = 0; _lat4 < latitudeBands; ++_lat4) {
			for (var _lon4 = 0; _lon4 < longitudeBands; ++_lon4) {
				var first = _lat4 * (longitudeBands + 1) + _lon4;
				var second = first + longitudeBands + 1;
				indices.push(first + 1, second, first);
				indices.push(first + 1, second + 1, second);
			}
		}

		var options = {
			normals: normals,
			uvs: uvs,
			uvs1: uvs,
			indices: indices
		};

		if (calcTangents) {
			options.tangents = calculateTangents(positions, normals, uvs, indices);
		}

		return createMesh$1(device, positions, options);
	}

	function createPlane(device, opts) {
		var he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec2(0.5, 0.5);
		var ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 5;
		var ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 5;
		var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
		var positions = [];
		var normals = [];
		var uvs = [];
		var indices = [];
		var vcounter = 0;

		for (var i = 0; i <= ws; i++) {
			for (var j = 0; j <= ls; j++) {
				var x = -he.x + 2 * he.x * i / ws;
				var y = 0.0;
				var z = -(-he.y + 2 * he.y * j / ls);
				var u = i / ws;
				var v = j / ls;
				positions.push(x, y, z);
				normals.push(0, 1, 0);
				uvs.push(u, 1 - v);

				if (i < ws && j < ls) {
					indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
					indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
				}

				vcounter++;
			}
		}

		var options = {
			normals: normals,
			uvs: uvs,
			uvs1: uvs,
			indices: indices
		};

		if (calcTangents) {
			options.tangents = calculateTangents(positions, normals, uvs, indices);
		}

		return createMesh$1(device, positions, options);
	}

	function createBox(device, opts) {
		var he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec3(0.5, 0.5, 0.5);
		var ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 1;
		var ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 1;
		var hs = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
		var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
		var corners = [new Vec3(-he.x, -he.y, he.z), new Vec3(he.x, -he.y, he.z), new Vec3(he.x, he.y, he.z), new Vec3(-he.x, he.y, he.z), new Vec3(he.x, -he.y, -he.z), new Vec3(-he.x, -he.y, -he.z), new Vec3(-he.x, he.y, -he.z), new Vec3(he.x, he.y, -he.z)];
		var faceAxes = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]];
		var faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];
		var sides = {
			FRONT: 0,
			BACK: 1,
			TOP: 2,
			BOTTOM: 3,
			RIGHT: 4,
			LEFT: 5
		};
		var positions = [];
		var normals = [];
		var uvs = [];
		var uvs1 = [];
		var indices = [];
		var vcounter = 0;

		var generateFace = function generateFace(side, uSegments, vSegments) {
			var temp1 = new Vec3();
			var temp2 = new Vec3();
			var temp3 = new Vec3();
			var r = new Vec3();

			for (var i = 0; i <= uSegments; i++) {
				for (var j = 0; j <= vSegments; j++) {
					temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
					temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
					temp3.sub2(temp2, corners[faceAxes[side][0]]);
					r.add2(temp1, temp3);
					var u = i / uSegments;
					var v = j / vSegments;
					positions.push(r.x, r.y, r.z);
					normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
					uvs.push(u, 1 - v);
					u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
					v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
					u /= 3;
					v /= 3;
					u += side % 3 / 3;
					v += Math.floor(side / 3) / 3;
					uvs1.push(u, 1 - v);

					if (i < uSegments && j < vSegments) {
						indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
						indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
					}

					vcounter++;
				}
			}
		};

		generateFace(sides.FRONT, ws, hs);
		generateFace(sides.BACK, ws, hs);
		generateFace(sides.TOP, ws, ls);
		generateFace(sides.BOTTOM, ws, ls);
		generateFace(sides.RIGHT, ls, hs);
		generateFace(sides.LEFT, ls, hs);
		var options = {
			normals: normals,
			uvs: uvs,
			uvs1: uvs1,
			indices: indices
		};

		if (calcTangents) {
			options.tangents = calculateTangents(positions, normals, uvs, indices);
		}

		return createMesh$1(device, positions, options);
	}

	function getShapePrimitive(device, type) {
		var primData = null;

		for (var i = 0; i < shapePrimitives.length; i++) {
			if (shapePrimitives[i].type === type && shapePrimitives[i].device === device) {
				primData = shapePrimitives[i].primData;
			}
		}

		if (!primData) {
			var mesh, area;

			switch (type) {
				case 'box':
					mesh = createBox(device, {
						halfExtents: new Vec3(0.5, 0.5, 0.5)
					});
					area = {
						x: 2,
						y: 2,
						z: 2,
						uv: 2.0 / 3
					};
					break;

				case 'capsule':
					mesh = createCapsule(device, {
						radius: 0.5,
						height: 2
					});
					area = {
						x: Math.PI * 2,
						y: Math.PI,
						z: Math.PI * 2,
						uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
					};
					break;

				case 'cone':
					mesh = createCone(device, {
						baseRadius: 0.5,
						peakRadius: 0,
						height: 1
					});
					area = {
						x: 2.54,
						y: 2.54,
						z: 2.54,
						uv: 1.0 / 3 + 1.0 / 3 / 3
					};
					break;

				case 'cylinder':
					mesh = createCylinder(device, {
						radius: 0.5,
						height: 1
					});
					area = {
						x: Math.PI,
						y: 0.79 * 2,
						z: Math.PI,
						uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
					};
					break;

				case 'plane':
					mesh = createPlane(device, {
						halfExtents: new Vec2(0.5, 0.5),
						widthSegments: 1,
						lengthSegments: 1
					});
					area = {
						x: 0,
						y: 1,
						z: 0,
						uv: 1
					};
					break;

				case 'sphere':
					mesh = createSphere(device, {
						radius: 0.5
					});
					area = {
						x: Math.PI,
						y: Math.PI,
						z: Math.PI,
						uv: 1
					};
					break;

				default:
					throw new Error("Invalid primitive type: " + type);
			}

			mesh.incRefCount();
			primData = {
				mesh: mesh,
				area: area
			};
			shapePrimitives.push({
				type: type,
				device: device,
				primData: primData
			});
		}

		return primData;
	}

	var BasicMaterial = function (_Material) {
		_inheritsLoose(BasicMaterial, _Material);

		function BasicMaterial() {
			var _this;

			_this = _Material.call(this) || this;
			_this.color = new Color(1, 1, 1, 1);
			_this.colorUniform = new Float32Array(4);
			_this.colorMap = null;
			_this.vertexColors = false;
			return _this;
		}

		var _proto = BasicMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.color.copy(source.color);
			this.colorMap = source.colorMap;
			this.vertexColors = source.vertexColors;
			return this;
		};

		_proto.updateUniforms = function updateUniforms(device, scene) {
			this.clearParameters();
			this.colorUniform[0] = this.color.r;
			this.colorUniform[1] = this.color.g;
			this.colorUniform[2] = this.color.b;
			this.colorUniform[3] = this.color.a;
			this.setParameter('uColor', this.colorUniform);

			if (this.colorMap) {
				this.setParameter('texture_diffuseMap', this.colorMap);
			}
		};

		_proto.updateShader = function updateShader(device, scene, objDefs, staticLightList, pass, sortedLights) {
			var options = {
				skin: objDefs && (objDefs & SHADERDEF_SKIN) !== 0,
				screenSpace: objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0,
				useInstancing: objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0,
				useMorphPosition: objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0,
				useMorphNormal: objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,
				useMorphTextureBased: objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0,
				vertexColors: this.vertexColors,
				diffuseMap: !!this.colorMap,
				pass: pass
			};
			var library = device.getProgramLibrary();
			this.shader = library.getProgram('basic', options);
		};

		return BasicMaterial;
	}(Material);

	var Batch = function () {
		function Batch(meshInstances, dynamic, batchGroupId) {
			this.origMeshInstances = meshInstances;
			this._aabb = new BoundingBox();
			this.meshInstance = null;
			this.dynamic = dynamic;
			this.batchGroupId = batchGroupId;
		}

		var _proto = Batch.prototype;

		_proto.destroy = function destroy(scene, layers) {
			if (this.meshInstance) {
				this.removeFromLayers(scene, layers);
				this.meshInstance.destroy();
			}
		};

		_proto.addToLayers = function addToLayers(scene, layers) {
			for (var i = 0; i < layers.length; i++) {
				var layer = scene.layers.getLayerById(layers[i]);

				if (layer) {
					layer.addMeshInstances([this.meshInstance]);
				}
			}
		};

		_proto.removeFromLayers = function removeFromLayers(scene, layers) {
			for (var i = 0; i < layers.length; i++) {
				var layer = scene.layers.getLayerById(layers[i]);

				if (layer) {
					layer.removeMeshInstances([this.meshInstance]);
				}
			}
		};

		_proto.updateBoundingBox = function updateBoundingBox() {
			this._aabb.copy(this.origMeshInstances[0].aabb);

			for (var i = 1; i < this.origMeshInstances.length; i++) {
				this._aabb.add(this.origMeshInstances[i].aabb);
			}

			this.meshInstance.aabb = this._aabb;
			this.meshInstance._aabbVer = 0;
		};

		return Batch;
	}();

	var BatchGroup = function BatchGroup(id, name, dynamic, maxAabbSize, layers) {
		if (layers === void 0) {
			layers = [LAYERID_WORLD];
		}

		this.dynamic = dynamic;
		this.maxAabbSize = maxAabbSize;
		this.id = id;
		this.name = name;
		this.layers = layers;
		this._ui = false;
		this._sprite = false;
		this._obj = {
			model: [],
			element: [],
			sprite: [],
			render: []
		};
	};

	BatchGroup.MODEL = 'model';
	BatchGroup.ELEMENT = 'element';
	BatchGroup.SPRITE = 'sprite';
	BatchGroup.RENDER = 'render';

	var _invMatrix = new Mat4();

	var SkinInstance = function () {
		function SkinInstance(skin) {
			this.bones = void 0;
			this._dirty = true;
			this._rootBone = null;
			this._skinUpdateIndex = -1;
			this._updateBeforeCull = true;

			if (skin) {
				this.initSkin(skin);
			}
		}

		var _proto = SkinInstance.prototype;

		_proto.init = function init(device, numBones) {
			if (device.supportsBoneTextures) {
				var numPixels = numBones * 3;
				var width = Math.ceil(Math.sqrt(numPixels));
				width = math.roundUp(width, 3);
				var height = Math.ceil(numPixels / width);
				this.boneTexture = new Texture(device, {
					width: width,
					height: height,
					format: PIXELFORMAT_RGBA32F,
					mipmaps: false,
					minFilter: FILTER_NEAREST,
					magFilter: FILTER_NEAREST
				});
				this.boneTexture.name = 'skin';
				this.matrixPalette = this.boneTexture.lock();
			} else {
				this.matrixPalette = new Float32Array(numBones * 12);
			}
		};

		_proto.destroy = function destroy() {
			if (this.boneTexture) {
				this.boneTexture.destroy();
				this.boneTexture = null;
			}
		};

		_proto.resolve = function resolve(rootBone, entity) {
			this.rootBone = rootBone;
			var skin = this.skin;
			var bones = [];

			for (var j = 0; j < skin.boneNames.length; j++) {
				var boneName = skin.boneNames[j];
				var bone = rootBone.findByName(boneName);

				if (!bone) {
					Debug.error("Failed to find bone [" + boneName + "] in the entity hierarchy, RenderComponent on " + entity.name + ", rootBone: " + rootBone.entity.name);
					bone = entity;
				}

				bones.push(bone);
			}

			this.bones = bones;
		};

		_proto.initSkin = function initSkin(skin) {
			this.skin = skin;
			this.bones = [];
			var numBones = skin.inverseBindPose.length;
			this.init(skin.device, numBones);
			this.matrices = [];

			for (var i = 0; i < numBones; i++) {
				this.matrices[i] = new Mat4();
			}
		};

		_proto.uploadBones = function uploadBones(device) {
			if (device.supportsBoneTextures) {
				this.boneTexture.lock();
				this.boneTexture.unlock();
			}
		};

		_proto._updateMatrices = function _updateMatrices(rootNode, skinUpdateIndex) {
			if (this._skinUpdateIndex !== skinUpdateIndex) {
				this._skinUpdateIndex = skinUpdateIndex;

				_invMatrix.copy(rootNode.getWorldTransform()).invert();

				for (var i = this.bones.length - 1; i >= 0; i--) {
					this.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());
					this.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);
				}
			}
		};

		_proto.updateMatrices = function updateMatrices(rootNode, skinUpdateIndex) {
			if (this._updateBeforeCull) {
				this._updateMatrices(rootNode, skinUpdateIndex);
			}
		};

		_proto.updateMatrixPalette = function updateMatrixPalette(rootNode, skinUpdateIndex) {
			this._updateMatrices(rootNode, skinUpdateIndex);

			var mp = this.matrixPalette;
			var count = this.bones.length;

			for (var i = 0; i < count; i++) {
				var pe = this.matrices[i].data;
				var base = i * 12;
				mp[base] = pe[0];
				mp[base + 1] = pe[4];
				mp[base + 2] = pe[8];
				mp[base + 3] = pe[12];
				mp[base + 4] = pe[1];
				mp[base + 5] = pe[5];
				mp[base + 6] = pe[9];
				mp[base + 7] = pe[13];
				mp[base + 8] = pe[2];
				mp[base + 9] = pe[6];
				mp[base + 10] = pe[10];
				mp[base + 11] = pe[14];
			}

			this.uploadBones(this.skin.device);
		};

		_createClass(SkinInstance, [{
			key: "rootBone",
			get: function get() {
				return this._rootBone;
			},
			set: function set(rootBone) {
				this._rootBone = rootBone;
			}
		}]);

		return SkinInstance;
	}();

	var SkinBatchInstance = function (_SkinInstance) {
		_inheritsLoose(SkinBatchInstance, _SkinInstance);

		function SkinBatchInstance(device, nodes, rootNode) {
			var _this;

			_this = _SkinInstance.call(this) || this;
			var numBones = nodes.length;

			_this.init(device, numBones);

			_this.device = device;
			_this.rootNode = rootNode;
			_this.bones = nodes;
			return _this;
		}

		var _proto = SkinBatchInstance.prototype;

		_proto.updateMatrices = function updateMatrices(rootNode, skinUpdateIndex) {};

		_proto.updateMatrixPalette = function updateMatrixPalette(rootNode, skinUpdateIndex) {
			var mp = this.matrixPalette;
			var count = this.bones.length;

			for (var i = 0; i < count; i++) {
				var pe = this.bones[i].getWorldTransform().data;
				var base = i * 12;
				mp[base] = pe[0];
				mp[base + 1] = pe[4];
				mp[base + 2] = pe[8];
				mp[base + 3] = pe[12];
				mp[base + 4] = pe[1];
				mp[base + 5] = pe[5];
				mp[base + 6] = pe[9];
				mp[base + 7] = pe[13];
				mp[base + 8] = pe[2];
				mp[base + 9] = pe[6];
				mp[base + 10] = pe[10];
				mp[base + 11] = pe[14];
			}

			this.uploadBones(this.device);
		};

		return SkinBatchInstance;
	}(SkinInstance);

	var RefCountedCache = function () {
		function RefCountedCache() {
			this.cache = new Map();
		}

		var _proto = RefCountedCache.prototype;

		_proto.destroy = function destroy() {
			this.cache.forEach(function (refCount, object) {
				object.destroy();
			});
			this.cache.clear();
		};

		_proto.incRef = function incRef(object) {
			var refCount = (this.cache.get(object) || 0) + 1;
			this.cache.set(object, refCount);
		};

		_proto.decRef = function decRef(object) {
			if (object) {
				var refCount = this.cache.get(object);

				if (refCount) {
					refCount--;

					if (refCount === 0) {
						this.cache.delete(object);
						object.destroy();
					} else {
						this.cache.set(object, refCount);
					}
				}
			}
		};

		return RefCountedCache;
	}();

	var LightmapCache = function () {
		function LightmapCache() {}

		LightmapCache.incRef = function incRef(texture) {
			this.cache.incRef(texture);
		};

		LightmapCache.decRef = function decRef(texture) {
			this.cache.decRef(texture);
		};

		LightmapCache.destroy = function destroy() {
			this.cache.destroy();
		};

		return LightmapCache;
	}();

	LightmapCache.cache = new RefCountedCache();

	var _tmpAabb = new BoundingBox();

	var _tempBoneAabb = new BoundingBox();

	var _tempSphere = new BoundingSphere();

	var _meshSet = new Set();

	var InstancingData = function InstancingData(numObjects) {
		this.vertexBuffer = null;
		this.count = numObjects;
	};

	var Command = function () {
		function Command(layer, blendType, command) {
			this._key = [];
			this._key[SORTKEY_FORWARD] = getKey(layer, blendType, true, 0);
			this.command = command;
		}

		_createClass(Command, [{
			key: "key",
			get: function get() {
				return this._key[SORTKEY_FORWARD];
			},
			set: function set(val) {
				this._key[SORTKEY_FORWARD] = val;
			}
		}]);

		return Command;
	}();

	var MeshInstance = function () {
		function MeshInstance(mesh, material, node) {
			if (node === void 0) {
				node = null;
			}

			this._material = void 0;

			if (mesh instanceof GraphNode) {
				var temp = mesh;
				mesh = material;
				material = node;
				node = temp;
			}

			this._key = [0, 0];
			this._shader = [null, null, null];
			this.isStatic = false;
			this._staticLightList = null;
			this._staticSource = null;
			this.node = node;
			this._mesh = mesh;
			mesh.incRefCount();
			this.material = material;
			this._shaderDefs = MASK_AFFECT_DYNAMIC << 16;
			this._shaderDefs |= mesh.vertexBuffer.format.hasUv0 ? SHADERDEF_UV0 : 0;
			this._shaderDefs |= mesh.vertexBuffer.format.hasUv1 ? SHADERDEF_UV1 : 0;
			this._shaderDefs |= mesh.vertexBuffer.format.hasColor ? SHADERDEF_VCOLOR : 0;
			this._shaderDefs |= mesh.vertexBuffer.format.hasTangents ? SHADERDEF_TANGENTS : 0;
			this._lightHash = 0;
			this.visible = true;
			this.layer = LAYER_WORLD;
			this._renderStyle = RENDERSTYLE_SOLID;
			this.castShadow = false;
			this._receiveShadow = true;
			this._screenSpace = false;
			this._noDepthDrawGl1 = false;
			this.cull = true;
			this.pick = true;
			this._updateAabb = true;
			this._updateAabbFunc = null;
			this._calculateSortDistance = null;
			this.updateKey();
			this._skinInstance = null;
			this._morphInstance = null;
			this.instancingData = null;
			this._customAabb = null;
			this.aabb = new BoundingBox();
			this._aabbVer = -1;
			this.drawOrder = 0;
			this.visibleThisFrame = false;
			this.isVisibleFunc = null;
			this.parameters = {};
			this.stencilFront = null;
			this.stencilBack = null;
			this.flipFaces = false;
		}

		var _proto = MeshInstance.prototype;

		_proto.destroy = function destroy() {
			var mesh = this.mesh;

			if (mesh) {
				this.mesh = null;

				if (mesh.refCount < 1) {
					mesh.destroy();
				}
			}

			this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
			this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);

			if (this._skinInstance) {
				this._skinInstance.destroy();

				this._skinInstance = null;
			}

			if (this.morphInstance) {
				this.morphInstance.destroy();
				this.morphInstance = null;
			}

			this.material = null;
		};

		MeshInstance._prepareRenderStyleForArray = function _prepareRenderStyleForArray(meshInstances, renderStyle) {
			if (meshInstances) {
				for (var i = 0; i < meshInstances.length; i++) {
					meshInstances[i]._renderStyle = renderStyle;
					var mesh = meshInstances[i].mesh;

					if (!_meshSet.has(mesh)) {
						_meshSet.add(mesh);

						mesh.prepareRenderState(renderStyle);
					}
				}

				_meshSet.clear();
			}
		};

		_proto._isVisible = function _isVisible(camera) {
			if (this.visible) {
				if (this.isVisibleFunc) {
					return this.isVisibleFunc(camera);
				}

				_tempSphere.center = this.aabb.center;
				_tempSphere.radius = this._aabb.halfExtents.length();
				return camera.frustum.containsSphere(_tempSphere);
			}

			return false;
		};

		_proto.updateKey = function updateKey() {
			var material = this.material;
			this._key[SORTKEY_FORWARD] = getKey(this.layer, material.alphaToCoverage || material.alphaTest ? BLEND_NORMAL : material.blendType, false, material.id);
		};

		_proto.setInstancing = function setInstancing(vertexBuffer) {
			if (vertexBuffer) {
				this.instancingData = new InstancingData(vertexBuffer.numVertices);
				this.instancingData.vertexBuffer = vertexBuffer;
				vertexBuffer.instancing = true;
				this.cull = false;
			} else {
				this.instancingData = null;
				this.cull = true;
			}
		};

		_proto.clearParameters = function clearParameters() {
			this.parameters = {};
		};

		_proto.getParameters = function getParameters() {
			return this.parameters;
		};

		_proto.getParameter = function getParameter(name) {
			return this.parameters[name];
		};

		_proto.setParameter = function setParameter(name, data, passFlags) {
			if (passFlags === void 0) {
				passFlags = -262141;
			}

			if (data === undefined && typeof name === 'object') {
				var uniformObject = name;

				if (uniformObject.length) {
					for (var i = 0; i < uniformObject.length; i++) {
						this.setParameter(uniformObject[i]);
					}

					return;
				}

				name = uniformObject.name;
				data = uniformObject.value;
			}

			var param = this.parameters[name];

			if (param) {
				param.data = data;
				param.passFlags = passFlags;
			} else {
				this.parameters[name] = {
					scopeId: null,
					data: data,
					passFlags: passFlags
				};
			}
		};

		_proto.setRealtimeLightmap = function setRealtimeLightmap(name, texture) {
			var old = this.getParameter(name);
			if (old === texture) return;

			if (old) {
				LightmapCache.decRef(old.data);
			}

			if (texture) {
				LightmapCache.incRef(texture);
				this.setParameter(name, texture);
			} else {
				this.deleteParameter(name);
			}
		};

		_proto.deleteParameter = function deleteParameter(name) {
			if (this.parameters[name]) {
				delete this.parameters[name];
			}
		};

		_proto.setParameters = function setParameters(device, passFlag) {
			var parameters = this.parameters;

			for (var paramName in parameters) {
				var parameter = parameters[paramName];

				if (parameter.passFlags & passFlag) {
					if (!parameter.scopeId) {
						parameter.scopeId = device.scope.resolve(paramName);
					}

					parameter.scopeId.setValue(parameter.data);
				}
			}
		};

		_proto.setLightmapped = function setLightmapped(value) {
			if (value) {
				this.mask = (this.mask | MASK_AFFECT_LIGHTMAPPED) & ~(MASK_AFFECT_DYNAMIC | MASK_BAKE);
			} else {
				this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
				this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);
				this._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM | SHADERDEF_LMAMBIENT);
				this.mask = (this.mask | MASK_AFFECT_DYNAMIC) & ~(MASK_AFFECT_LIGHTMAPPED | MASK_BAKE);
			}
		};

		_proto.setCustomAabb = function setCustomAabb(aabb) {
			if (aabb) {
				if (this._customAabb) {
					this._customAabb.copy(aabb);
				} else {
					this._customAabb = aabb.clone();
				}
			} else {
				this._customAabb = null;
				this._aabbVer = -1;
			}

			this._setupSkinUpdate();
		};

		_proto._setupSkinUpdate = function _setupSkinUpdate() {
			if (this._skinInstance) {
				this._skinInstance._updateBeforeCull = !this._customAabb;
			}
		};

		_createClass(MeshInstance, [{
			key: "renderStyle",
			get: function get() {
				return this._renderStyle;
			},
			set: function set(renderStyle) {
				this._renderStyle = renderStyle;
				this.mesh.prepareRenderState(renderStyle);
			}
		}, {
			key: "mesh",
			get: function get() {
				return this._mesh;
			},
			set: function set(mesh) {
				if (mesh === this._mesh) return;

				if (this._mesh) {
					this._mesh.decRefCount();
				}

				this._mesh = mesh;

				if (mesh) {
					mesh.incRefCount();
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				if (!this._updateAabb) {
					return this._aabb;
				}

				if (this._updateAabbFunc) {
					return this._updateAabbFunc(this._aabb);
				}

				var localAabb = this._customAabb;
				var toWorldSpace = !!localAabb;

				if (!localAabb) {
					localAabb = _tmpAabb;

					if (this.skinInstance) {
						if (!this.mesh.boneAabb) {
							var morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;

							this.mesh._initBoneAabbs(morphTargets);
						}

						var boneUsed = this.mesh.boneUsed;
						var first = true;

						for (var i = 0; i < this.mesh.boneAabb.length; i++) {
							if (boneUsed[i]) {
								_tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);

								if (first) {
									first = false;
									localAabb.center.copy(_tempBoneAabb.center);
									localAabb.halfExtents.copy(_tempBoneAabb.halfExtents);
								} else {
									localAabb.add(_tempBoneAabb);
								}
							}
						}

						toWorldSpace = true;
					} else if (this.node._aabbVer !== this._aabbVer) {
						if (this.mesh) {
							localAabb.center.copy(this.mesh.aabb.center);
							localAabb.halfExtents.copy(this.mesh.aabb.halfExtents);
						} else {
							localAabb.center.set(0, 0, 0);
							localAabb.halfExtents.set(0, 0, 0);
						}

						if (this.mesh && this.mesh.morph) {
							localAabb._expand(this.mesh.morph.aabb.getMin(), this.mesh.morph.aabb.getMax());
						}

						toWorldSpace = true;
						this._aabbVer = this.node._aabbVer;
					}
				}

				if (toWorldSpace) {
					this._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());
				}

				return this._aabb;
			},
			set: function set(aabb) {
				this._aabb = aabb;
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(material) {
				for (var i = 0; i < this._shader.length; i++) {
					this._shader[i] = null;
				}

				var prevMat = this._material;

				if (prevMat) {
					prevMat.removeMeshInstanceRef(this);
				}

				this._material = material;

				if (this._material) {
					this._material.addMeshInstanceRef(this);

					this.updateKey();
					var prevBlend = prevMat && prevMat.blendType !== BLEND_NONE;
					var thisBlend = this._material.blendType !== BLEND_NONE;

					if (prevBlend !== thisBlend) {
						var scene = this._material._scene;
						if (!scene && prevMat && prevMat._scene) scene = prevMat._scene;

						if (scene) {
							scene.layers._dirtyBlend = true;
						} else {
							this._material._dirtyBlend = true;
						}
					}
				}
			}
		}, {
			key: "layer",
			get: function get() {
				return this._layer;
			},
			set: function set(layer) {
				this._layer = layer;
				this.updateKey();
			}
		}, {
			key: "calculateSortDistance",
			get: function get() {
				return this._calculateSortDistance;
			},
			set: function set(calculateSortDistance) {
				this._calculateSortDistance = calculateSortDistance;
			}
		}, {
			key: "receiveShadow",
			get: function get() {
				return this._receiveShadow;
			},
			set: function set(val) {
				this._receiveShadow = val;
				this._shaderDefs = val ? this._shaderDefs & ~SHADERDEF_NOSHADOW : this._shaderDefs | SHADERDEF_NOSHADOW;
				this._shader[SHADER_FORWARD] = null;
				this._shader[SHADER_FORWARDHDR] = null;
			}
		}, {
			key: "skinInstance",
			get: function get() {
				return this._skinInstance;
			},
			set: function set(val) {
				this._skinInstance = val;
				this._shaderDefs = val ? this._shaderDefs | SHADERDEF_SKIN : this._shaderDefs & ~SHADERDEF_SKIN;

				for (var i = 0; i < this._shader.length; i++) {
					this._shader[i] = null;
				}

				this._setupSkinUpdate();
			}
		}, {
			key: "morphInstance",
			get: function get() {
				return this._morphInstance;
			},
			set: function set(val) {
				this._morphInstance = val;

				if (this._morphInstance) {
					this._morphInstance.meshInstance = this;
				}

				this._shaderDefs = val && val.morph.useTextureMorph ? this._shaderDefs | SHADERDEF_MORPH_TEXTURE_BASED : this._shaderDefs & ~SHADERDEF_MORPH_TEXTURE_BASED;
				this._shaderDefs = val && val.morph.morphPositions ? this._shaderDefs | SHADERDEF_MORPH_POSITION : this._shaderDefs & ~SHADERDEF_MORPH_POSITION;
				this._shaderDefs = val && val.morph.morphNormals ? this._shaderDefs | SHADERDEF_MORPH_NORMAL : this._shaderDefs & ~SHADERDEF_MORPH_NORMAL;

				for (var i = 0; i < this._shader.length; i++) {
					this._shader[i] = null;
				}
			}
		}, {
			key: "screenSpace",
			get: function get() {
				return this._screenSpace;
			},
			set: function set(val) {
				this._screenSpace = val;
				this._shaderDefs = val ? this._shaderDefs | SHADERDEF_SCREENSPACE : this._shaderDefs & ~SHADERDEF_SCREENSPACE;
				this._shader[SHADER_FORWARD] = null;
			}
		}, {
			key: "key",
			get: function get() {
				return this._key[SORTKEY_FORWARD];
			},
			set: function set(val) {
				this._key[SORTKEY_FORWARD] = val;
			}
		}, {
			key: "mask",
			get: function get() {
				return this._shaderDefs >> 16;
			},
			set: function set(val) {
				var toggles = this._shaderDefs & 0x0000FFFF;
				this._shaderDefs = toggles | val << 16;
				this._shader[SHADER_FORWARD] = null;
				this._shader[SHADER_FORWARDHDR] = null;
			}
		}, {
			key: "instancingCount",
			get: function get() {
				return this.instancingData ? this.instancingData.count : 0;
			},
			set: function set(value) {
				if (this.instancingData) this.instancingData.count = value;
			}
		}]);

		return MeshInstance;
	}();

	MeshInstance.lightmapParamNames = ["texture_lightMap", "texture_dirLightMap"];

	function getKey(layer, blendType, isCommand, materialId) {
		return (layer & 0x0f) << 27 | (blendType === BLEND_NONE ? 1 : 0) << 26 | (isCommand ? 1 : 0) << 25 | (materialId & 0x1ffffff) << 0;
	}

	function paramsIdentical(a, b) {
		if (a && !b) return false;
		if (!a && b) return false;
		a = a.data;
		b = b.data;
		if (a === b) return true;

		if (a instanceof Float32Array && b instanceof Float32Array) {
			if (a.length !== b.length) return false;

			for (var i = 0; i < a.length; i++) {
				if (a[i] !== b[i]) return false;
			}

			return true;
		}

		return false;
	}

	function equalParamSets(params1, params2) {
		for (var param in params1) {
			if (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) return false;
		}

		for (var _param in params2) {
			if (params2.hasOwnProperty(_param) && !paramsIdentical(params2[_param], params1[_param])) return false;
		}

		return true;
	}

	function equalLightLists(lightList1, lightList2) {
		for (var k = 0; k < lightList1.length; k++) {
			if (lightList2.indexOf(lightList1[k]) < 0) return false;
		}

		for (var _k = 0; _k < lightList2.length; _k++) {
			if (lightList1.indexOf(lightList2[_k]) < 0) return false;
		}

		return true;
	}

	var mat3 = new Mat3();
	var worldMatX$1 = new Vec3();
	var worldMatY$1 = new Vec3();
	var worldMatZ$1 = new Vec3();

	function getScaleSign(mi) {
		var wt = mi.node.worldTransform;
		wt.getX(worldMatX$1);
		wt.getY(worldMatY$1);
		wt.getZ(worldMatZ$1);
		worldMatX$1.cross(worldMatX$1, worldMatY$1);
		return worldMatX$1.dot(worldMatZ$1) >= 0 ? 1 : -1;
	}

	var BatchManager = function () {
		function BatchManager(device, root, scene) {
			this.device = device;
			this.rootNode = root;
			this.scene = scene;
			this._init = false;
			this._batchGroups = {};
			this._batchGroupCounter = 0;
			this._batchList = [];
			this._dirtyGroups = [];
			this._stats = {
				createTime: 0,
				updateLastFrameTime: 0
			};
		}

		var _proto = BatchManager.prototype;

		_proto.destroy = function destroy() {
			this.device = null;
			this.rootNode = null;
			this.scene = null;
			this._batchGroups = {};
			this._batchList = [];
			this._dirtyGroups = [];
		};

		_proto.addGroup = function addGroup(name, dynamic, maxAabbSize, id, layers) {
			if (id === undefined) {
				id = this._batchGroupCounter;
				this._batchGroupCounter++;
			}

			if (this._batchGroups[id]) {
				Debug.error("batch group with id " + id + " already exists");
				return;
			}

			var group = new BatchGroup(id, name, dynamic, maxAabbSize, layers);
			this._batchGroups[id] = group;
			return group;
		};

		_proto.removeGroup = function removeGroup(id) {
			if (!this._batchGroups[id]) {
				Debug.error("batch group with id " + id + " doesn't exist");
				return;
			}

			var newBatchList = [];

			for (var i = 0; i < this._batchList.length; i++) {
				if (this._batchList[i].batchGroupId === id) {
					this.destroyBatch(this._batchList[i]);
				} else {
					newBatchList.push(this._batchList[i]);
				}
			}

			this._batchList = newBatchList;

			this._removeModelsFromBatchGroup(this.rootNode, id);

			delete this._batchGroups[id];
		};

		_proto.markGroupDirty = function markGroupDirty(id) {
			if (this._dirtyGroups.indexOf(id) < 0) {
				this._dirtyGroups.push(id);
			}
		};

		_proto.getGroupByName = function getGroupByName(name) {
			var groups = this._batchGroups;

			for (var group in groups) {
				if (!groups.hasOwnProperty(group)) continue;

				if (groups[group].name === name) {
					return groups[group];
				}
			}

			return null;
		};

		_proto.getBatches = function getBatches(batchGroupId) {
			var results = [];
			var len = this._batchList.length;

			for (var i = 0; i < len; i++) {
				var batch = this._batchList[i];

				if (batch.batchGroupId === batchGroupId) {
					results.push(batch);
				}
			}

			return results;
		};

		_proto._removeModelsFromBatchGroup = function _removeModelsFromBatchGroup(node, id) {
			if (!node.enabled) return;

			if (node.model && node.model.batchGroupId === id) {
				node.model.batchGroupId = -1;
			}

			if (node.render && node.render.batchGroupId === id) {
				node.render.batchGroupId = -1;
			}

			if (node.element && node.element.batchGroupId === id) {
				node.element.batchGroupId = -1;
			}

			if (node.sprite && node.sprite.batchGroupId === id) {
				node.sprite.batchGroupId = -1;
			}

			for (var i = 0; i < node._children.length; i++) {
				this._removeModelsFromBatchGroup(node._children[i], id);
			}
		};

		_proto.insert = function insert(type, groupId, node) {
			var group = this._batchGroups[groupId];
			Debug.assert(group, "Invalid batch " + groupId + " insertion");

			if (group) {
				if (group._obj[type].indexOf(node) < 0) {
					group._obj[type].push(node);

					this.markGroupDirty(groupId);
				}
			}
		};

		_proto.remove = function remove(type, groupId, node) {
			var group = this._batchGroups[groupId];
			Debug.assert(group, "Invalid batch " + groupId + " insertion");

			if (group) {
				var idx = group._obj[type].indexOf(node);

				if (idx >= 0) {
					group._obj[type].splice(idx, 1);

					this.markGroupDirty(groupId);
				}
			}
		};

		_proto._extractRender = function _extractRender(node, arr, group, groupMeshInstances) {
			if (node.render) {
				if (node.render.isStatic) {
					var drawCalls = this.scene.drawCalls;
					var nodeMeshInstances = node.render.meshInstances;

					for (var i = 0; i < drawCalls.length; i++) {
						if (!drawCalls[i]._staticSource) continue;
						if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;
						arr.push(drawCalls[i]);
					}

					for (var _i = 0; _i < nodeMeshInstances.length; _i++) {
						if (drawCalls.indexOf(nodeMeshInstances[_i]) >= 0) {
							arr.push(nodeMeshInstances[_i]);
						}
					}
				} else {
					arr = groupMeshInstances[node.render.batchGroupId] = arr.concat(node.render.meshInstances);
				}

				node.render.removeFromLayers();
			}

			return arr;
		};

		_proto._extractModel = function _extractModel(node, arr, group, groupMeshInstances) {
			if (node.model && node.model.model) {
				if (node.model.isStatic) {
					var drawCalls = this.scene.drawCalls;
					var nodeMeshInstances = node.model.meshInstances;

					for (var i = 0; i < drawCalls.length; i++) {
						if (!drawCalls[i]._staticSource) continue;
						if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;
						arr.push(drawCalls[i]);
					}

					for (var _i2 = 0; _i2 < nodeMeshInstances.length; _i2++) {
						if (drawCalls.indexOf(nodeMeshInstances[_i2]) >= 0) {
							arr.push(nodeMeshInstances[_i2]);
						}
					}
				} else {
					arr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);
				}

				node.model.removeModelFromLayers();
				node.model._batchGroup = group;
			}

			return arr;
		};

		_proto._extractElement = function _extractElement(node, arr, group) {
			if (!node.element) return;
			var valid = false;

			if (node.element._text && node.element._text._model.meshInstances.length > 0) {
				arr.push(node.element._text._model.meshInstances[0]);
				node.element.removeModelFromLayers(node.element._text._model);
				valid = true;
			} else if (node.element._image) {
				arr.push(node.element._image._renderable.meshInstance);
				node.element.removeModelFromLayers(node.element._image._renderable.model);

				if (node.element._image._renderable.unmaskMeshInstance) {
					arr.push(node.element._image._renderable.unmaskMeshInstance);

					if (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {
						node.element._dirtifyMask();

						node.element._onPrerender();
					}
				}

				valid = true;
			}

			if (valid) {
				group._ui = true;
				node.element._batchGroup = group;
			}
		};

		_proto._collectAndRemoveMeshInstances = function _collectAndRemoveMeshInstances(groupMeshInstances, groupIds) {
			for (var g = 0; g < groupIds.length; g++) {
				var id = groupIds[g];
				var group = this._batchGroups[id];
				if (!group) continue;
				var arr = groupMeshInstances[id];
				if (!arr) arr = groupMeshInstances[id] = [];

				for (var m = 0; m < group._obj.model.length; m++) {
					arr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);
				}

				for (var r = 0; r < group._obj.render.length; r++) {
					arr = this._extractRender(group._obj.render[r], arr, group, groupMeshInstances);
				}

				for (var e = 0; e < group._obj.element.length; e++) {
					this._extractElement(group._obj.element[e], arr, group);
				}

				for (var s = 0; s < group._obj.sprite.length; s++) {
					var node = group._obj.sprite[s];

					if (node.sprite && node.sprite._meshInstance && (group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {
						arr.push(node.sprite._meshInstance);
						node.sprite.removeModelFromLayers();
						group._sprite = true;
						node.sprite._batchGroup = group;
					}
				}
			}
		};

		_proto.generate = function generate(groupIds) {
			var groupMeshInstances = {};

			if (!groupIds) {
				groupIds = Object.keys(this._batchGroups);
			}

			var newBatchList = [];

			for (var i = 0; i < this._batchList.length; i++) {
				if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {
					newBatchList.push(this._batchList[i]);
					continue;
				}

				this.destroyBatch(this._batchList[i]);
			}

			this._batchList = newBatchList;

			this._collectAndRemoveMeshInstances(groupMeshInstances, groupIds);

			if (groupIds === this._dirtyGroups) {
				this._dirtyGroups.length = 0;
			} else {
				var newDirtyGroups = [];

				for (var _i3 = 0; _i3 < this._dirtyGroups.length; _i3++) {
					if (groupIds.indexOf(this._dirtyGroups[_i3]) < 0) newDirtyGroups.push(this._dirtyGroups[_i3]);
				}

				this._dirtyGroups = newDirtyGroups;
			}

			var group, lists, groupData, batch;

			for (var groupId in groupMeshInstances) {
				if (!groupMeshInstances.hasOwnProperty(groupId)) continue;
				group = groupMeshInstances[groupId];
				groupData = this._batchGroups[groupId];

				if (!groupData) {
					Debug.error("batch group " + groupId + " not found");
					continue;
				}

				lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);

				for (var _i4 = 0; _i4 < lists.length; _i4++) {
					batch = this.create(lists[_i4], groupData.dynamic, parseInt(groupId, 10));

					if (batch) {
						batch.addToLayers(this.scene, groupData.layers);
					}
				}
			}
		};

		_proto.prepare = function prepare(meshInstances, dynamic, maxAabbSize, translucent) {
			if (maxAabbSize === void 0) {
				maxAabbSize = Number.POSITIVE_INFINITY;
			}

			if (meshInstances.length === 0) return [];
			var halfMaxAabbSize = maxAabbSize * 0.5;
			var maxInstanceCount = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit;
			var maxNumVertices = this.device.extUintElement ? 0xffffffff : 0xffff;
			var aabb = new BoundingBox();
			var testAabb = new BoundingBox();
			var skipTranslucentAabb = null;
			var sf;
			var lists = [];
			var j = 0;

			if (translucent) {
				meshInstances.sort(function (a, b) {
					return a.drawOrder - b.drawOrder;
				});
			}

			var meshInstancesLeftA = meshInstances;
			var meshInstancesLeftB;
			var skipMesh = translucent ? function (mi) {
				if (skipTranslucentAabb) {
					skipTranslucentAabb.add(mi.aabb);
				} else {
					skipTranslucentAabb = mi.aabb.clone();
				}

				meshInstancesLeftB.push(mi);
			} : function (mi) {
				meshInstancesLeftB.push(mi);
			};

			while (meshInstancesLeftA.length > 0) {
				lists[j] = [meshInstancesLeftA[0]];
				meshInstancesLeftB = [];
				var material = meshInstancesLeftA[0].material;
				var layer = meshInstancesLeftA[0].layer;
				var defs = meshInstancesLeftA[0]._shaderDefs;
				var params = meshInstancesLeftA[0].parameters;
				var stencil = meshInstancesLeftA[0].stencilFront;
				var lightList = meshInstancesLeftA[0]._staticLightList;
				var vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();
				var drawOrder = meshInstancesLeftA[0].drawOrder;
				aabb.copy(meshInstancesLeftA[0].aabb);
				var scaleSign = getScaleSign(meshInstancesLeftA[0]);
				var vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;
				var indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;
				skipTranslucentAabb = null;

				for (var i = 1; i < meshInstancesLeftA.length; i++) {
					var mi = meshInstancesLeftA[i];

					if (dynamic && lists[j].length >= maxInstanceCount) {
						meshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));
						break;
					}

					if (material !== mi.material || layer !== mi.layer || vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash || indexed !== mi.mesh.primitive[0].indexed || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices) {
						skipMesh(mi);
						continue;
					}

					testAabb.copy(aabb);
					testAabb.add(mi.aabb);

					if (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {
						skipMesh(mi);
						continue;
					}

					if (stencil) {
						if (!(sf = mi.stencilFront) || stencil.func !== sf.func || stencil.zpass !== sf.zpass) {
							skipMesh(mi);
							continue;
						}
					}

					if (scaleSign !== getScaleSign(mi)) {
						skipMesh(mi);
						continue;
					}

					if (!equalParamSets(params, mi.parameters)) {
						skipMesh(mi);
						continue;
					}

					var staticLights = mi._staticLightList;

					if (lightList && staticLights) {
						if (!equalLightLists(lightList, staticLights)) {
							skipMesh(mi);
							continue;
						}
					} else if (lightList || staticLights) {
						skipMesh(mi);
						continue;
					}

					if (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {
						skipMesh(mi);
						continue;
					}

					aabb.add(mi.aabb);
					vertCount += mi.mesh.vertexBuffer.getNumVertices();
					lists[j].push(mi);
				}

				j++;
				meshInstancesLeftA = meshInstancesLeftB;
			}

			return lists;
		};

		_proto.collectBatchedMeshData = function collectBatchedMeshData(meshInstances, dynamic) {
			var streams = null;
			var batchNumVerts = 0;
			var batchNumIndices = 0;
			var material = null;

			for (var i = 0; i < meshInstances.length; i++) {
				if (meshInstances[i].visible) {
					var mesh = meshInstances[i].mesh;
					var numVerts = mesh.vertexBuffer.numVertices;
					batchNumVerts += numVerts;
					batchNumIndices += mesh.primitive[0].indexed ? mesh.primitive[0].count : mesh.primitive[0].type === PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4 ? 6 : 0;

					if (!streams) {
						material = meshInstances[i].material;
						streams = {};
						var elems = mesh.vertexBuffer.format.elements;

						for (var j = 0; j < elems.length; j++) {
							var semantic = elems[j].name;
							streams[semantic] = {
								numComponents: elems[j].numComponents,
								dataType: elems[j].dataType,
								normalize: elems[j].normalize,
								count: 0
							};
						}

						if (dynamic) {
							streams[SEMANTIC_BLENDINDICES] = {
								numComponents: 1,
								dataType: TYPE_FLOAT32,
								normalize: false,
								count: 0
							};
						}
					}
				}
			}

			return {
				streams: streams,
				batchNumVerts: batchNumVerts,
				batchNumIndices: batchNumIndices,
				material: material
			};
		};

		_proto.create = function create(meshInstances, dynamic, batchGroupId) {
			var time = now();

			if (!this._init) {
				var boneLimit = "#define BONE_LIMIT " + this.device.getBoneLimit() + "\n";
				this.transformVS = boneLimit + "#define DYNAMICBATCH\n" + shaderChunks.transformVS;
				this.skinTexVS = shaderChunks.skinBatchTexVS;
				this.skinConstVS = shaderChunks.skinBatchConstVS;
				this.vertexFormats = {};
				this._init = true;
			}

			var stream = null;
			var semantic;
			var mesh, numVerts;
			var batch = null;
			var batchData = this.collectBatchedMeshData(meshInstances, dynamic);

			if (batchData.streams) {
				var streams = batchData.streams;
				var material = batchData.material;
				var batchNumVerts = batchData.batchNumVerts;
				var batchNumIndices = batchData.batchNumIndices;
				batch = new Batch(meshInstances, dynamic, batchGroupId);

				this._batchList.push(batch);

				var indexBase, numIndices, indexData;
				var verticesOffset = 0;
				var indexOffset = 0;
				var transform;
				var vec = new Vec3();
				var indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;
				var indices = new indexArrayType(batchNumIndices);

				for (semantic in streams) {
					stream = streams[semantic];
					stream.typeArrayType = typedArrayTypes[stream.dataType];
					stream.elementByteSize = typedArrayTypesByteSize[stream.dataType];
					stream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);
				}

				for (var i = 0; i < meshInstances.length; i++) {
					if (!meshInstances[i].visible) continue;
					mesh = meshInstances[i].mesh;
					numVerts = mesh.vertexBuffer.numVertices;

					if (!dynamic) {
						transform = meshInstances[i].node.getWorldTransform();
					}

					for (semantic in streams) {
						if (semantic !== SEMANTIC_BLENDINDICES) {
							stream = streams[semantic];
							var subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);
							var totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;
							stream.count += totalComponents;

							if (!dynamic && stream.numComponents >= 3) {
								if (semantic === SEMANTIC_POSITION) {
									for (var j = 0; j < totalComponents; j += stream.numComponents) {
										vec.set(subarray[j], subarray[j + 1], subarray[j + 2]);
										transform.transformPoint(vec, vec);
										subarray[j] = vec.x;
										subarray[j + 1] = vec.y;
										subarray[j + 2] = vec.z;
									}
								} else if (semantic === SEMANTIC_NORMAL || semantic === SEMANTIC_TANGENT) {
									transform.invertTo3x3(mat3);
									mat3.transpose();

									for (var _j = 0; _j < totalComponents; _j += stream.numComponents) {
										vec.set(subarray[_j], subarray[_j + 1], subarray[_j + 2]);
										mat3.transformVector(vec, vec);
										subarray[_j] = vec.x;
										subarray[_j + 1] = vec.y;
										subarray[_j + 2] = vec.z;
									}
								}
							}
						}
					}

					if (dynamic) {
						stream = streams[SEMANTIC_BLENDINDICES];

						for (var _j2 = 0; _j2 < numVerts; _j2++) {
							stream.buffer[stream.count++] = i;
						}
					}

					if (mesh.primitive[0].indexed) {
						indexBase = mesh.primitive[0].base;
						numIndices = mesh.primitive[0].count;
						var srcFormat = mesh.indexBuffer[0].getFormat();
						indexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);
					} else if (mesh.primitive[0].type === PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4) {
						indexBase = 0;
						numIndices = 6;
						indexData = [0, 1, 3, 2, 3, 1];
					} else {
						numIndices = 0;
						continue;
					}

					for (var _j3 = 0; _j3 < numIndices; _j3++) {
						indices[_j3 + indexOffset] = indexData[indexBase + _j3] + verticesOffset;
					}

					indexOffset += numIndices;
					verticesOffset += numVerts;
				}

				mesh = new Mesh(this.device);

				for (semantic in streams) {
					stream = streams[semantic];
					mesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);
				}

				if (indices.length > 0) mesh.setIndices(indices);
				mesh.update(PRIMITIVE_TRIANGLES, false);

				if (dynamic) {
					material = material.clone();
					material.chunks.transformVS = this.transformVS;
					material.chunks.skinTexVS = this.skinTexVS;
					material.chunks.skinConstVS = this.skinConstVS;
					material.update();
				}

				var meshInstance = new MeshInstance(mesh, material, this.rootNode);
				meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
				meshInstance.parameters = batch.origMeshInstances[0].parameters;
				meshInstance.isStatic = batch.origMeshInstances[0].isStatic;
				meshInstance.layer = batch.origMeshInstances[0].layer;
				meshInstance._staticLightList = batch.origMeshInstances[0]._staticLightList;
				meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;
				meshInstance.cull = batch.origMeshInstances[0].cull;
				var batchGroup = this._batchGroups[batchGroupId];
				if (batchGroup && batchGroup._ui) meshInstance.cull = false;

				if (dynamic) {
					var nodes = [];

					for (var _i5 = 0; _i5 < batch.origMeshInstances.length; _i5++) {
						nodes.push(batch.origMeshInstances[_i5].node);
					}

					meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
				}

				meshInstance._updateAabb = false;
				meshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;
				meshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;
				meshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;
				meshInstance.flipFaces = getScaleSign(batch.origMeshInstances[0]) < 0;
				meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
				batch.meshInstance = meshInstance;
				batch.updateBoundingBox();
			}

			this._stats.createTime += now() - time;
			return batch;
		};

		_proto.updateAll = function updateAll() {
			if (this._dirtyGroups.length > 0) {
				this.generate(this._dirtyGroups);
			}

			var time = now();

			for (var i = 0; i < this._batchList.length; i++) {
				if (!this._batchList[i].dynamic) continue;

				this._batchList[i].updateBoundingBox();
			}

			this._stats.updateLastFrameTime = now() - time;
		};

		_proto.clone = function clone(batch, clonedMeshInstances) {
			var batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);

			this._batchList.push(batch2);

			var nodes = [];

			for (var i = 0; i < clonedMeshInstances.length; i++) {
				nodes.push(clonedMeshInstances[i].node);
			}

			batch2.meshInstance = new MeshInstance(batch.meshInstance.mesh, batch.meshInstance.material, batch.meshInstance.node);
			batch2.meshInstance._updateAabb = false;
			batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;
			batch2.meshInstance.isStatic = clonedMeshInstances[0].isStatic;
			batch2.meshInstance.cull = clonedMeshInstances[0].cull;
			batch2.meshInstance.layer = clonedMeshInstances[0].layer;
			batch2.meshInstance._staticLightList = clonedMeshInstances[0]._staticLightList;

			if (batch.dynamic) {
				batch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
			}

			batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
			batch2.meshInstance._shader = batch.meshInstance._shader;
			batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
			return batch2;
		};

		_proto.destroyBatch = function destroyBatch(batch) {
			batch.destroy(this.scene, this._batchGroups[batch.batchGroupId].layers);
		};

		return BatchManager;
	}();

	var tempVec3 = new Vec3();
	var tempMin3 = new Vec3();
	var tempMax3 = new Vec3();
	var tempBox = new BoundingBox();
	var epsilon = 0.000001;
	var maxTextureSize = 4096;

	var ClusterLight = function ClusterLight() {
		this.light = null;
		this.min = new Vec3();
		this.max = new Vec3();
	};

	var WorldClusters = function () {
		function WorldClusters(device) {
			this.device = device;
			this.name = "Untitled";
			this.reportCount = 0;
			this.boundsMin = new Vec3();
			this.boundsMax = new Vec3();
			this.boundsDelta = new Vec3();
			this._cells = new Vec3(1, 1, 1);
			this._cellsLimit = new Vec3();
			this.cells = this._cells;
			this._maxCellLightCount = 0;
			this._pixelsPerCellCount = 0;
			this.maxCellLightCount = 4;
			this._maxAttenuation = 0;
			this._maxColorValue = 0;
			this._usedLights = [];

			this._usedLights.push(new ClusterLight());

			this.lightsBuffer = new LightsBuffer(device);
			this.registerUniforms(device);
		}

		var _proto = WorldClusters.prototype;

		_proto.destroy = function destroy() {
			this.lightsBuffer.destroy();
			this.releaseClusterTexture();
		};

		_proto.releaseClusterTexture = function releaseClusterTexture() {
			if (this.clusterTexture) {
				this.clusterTexture.destroy();
				this.clusterTexture = null;
			}
		};

		_proto.registerUniforms = function registerUniforms(device) {
			this._clusterWorldTextureId = device.scope.resolve("clusterWorldTexture");
			this._clusterPixelsPerCellId = device.scope.resolve("clusterPixelsPerCell");
			this._clusterTextureSizeId = device.scope.resolve("clusterTextureSize");
			this._clusterTextureSizeData = new Float32Array(3);
			this._clusterBoundsMinId = device.scope.resolve("clusterBoundsMin");
			this._clusterBoundsMinData = new Float32Array(3);
			this._clusterBoundsDeltaId = device.scope.resolve("clusterBoundsDelta");
			this._clusterBoundsDeltaData = new Float32Array(3);
			this._clusterCellsCountByBoundsSizeId = device.scope.resolve("clusterCellsCountByBoundsSize");
			this._clusterCellsCountByBoundsSizeData = new Float32Array(3);
			this._clusterCellsDotId = device.scope.resolve("clusterCellsDot");
			this._clusterCellsDotData = new Float32Array(3);
			this._clusterCellsMaxId = device.scope.resolve("clusterCellsMax");
			this._clusterCellsMaxData = new Float32Array(3);
			this._clusterCompressionLimit0Id = device.scope.resolve("clusterCompressionLimit0");
			this._clusterCompressionLimit0Data = new Float32Array(2);
		};

		_proto.updateParams = function updateParams(lightingParams) {
			if (lightingParams) {
				this.cells = lightingParams.cells;
				this.maxCellLightCount = lightingParams.maxLightsPerCell;
				this.lightsBuffer.cookiesEnabled = lightingParams.cookiesEnabled;
				this.lightsBuffer.shadowsEnabled = lightingParams.shadowsEnabled;
				this.lightsBuffer.areaLightsEnabled = lightingParams.areaLightsEnabled;
			}
		};

		_proto.updateCells = function updateCells() {
			if (this._cellsDirty) {
				this._cellsDirty = false;
				var cx = this._cells.x;
				var cy = this._cells.y;
				var cz = this._cells.z;
				var numCells = cx * cy * cz;
				var totalPixels = this._pixelsPerCellCount * numCells;
				var width = Math.ceil(Math.sqrt(totalPixels));
				width = math.roundUp(width, this._pixelsPerCellCount);
				var height = Math.ceil(totalPixels / width);
				Debug.assert(width <= maxTextureSize && height <= maxTextureSize, "Clustered lights parameters cause the texture size to be over the limit, please adjust them.");
				this._clusterCellsMaxData[0] = cx;
				this._clusterCellsMaxData[1] = cy;
				this._clusterCellsMaxData[2] = cz;
				this._clusterCellsDotData[0] = this._pixelsPerCellCount;
				this._clusterCellsDotData[1] = cx * cz * this._pixelsPerCellCount;
				this._clusterCellsDotData[2] = cx * this._pixelsPerCellCount;
				this.clusters = new Uint8ClampedArray(4 * totalPixels);
				this.counts = new Int32Array(numCells);
				this._clusterTextureSizeData[0] = width;
				this._clusterTextureSizeData[1] = 1.0 / width;
				this._clusterTextureSizeData[2] = 1.0 / height;
				this.releaseClusterTexture();
				this.clusterTexture = LightsBuffer.createTexture(this.device, width, height, PIXELFORMAT_R8_G8_B8_A8, "ClusterTexture");
			}
		};

		_proto.uploadTextures = function uploadTextures() {
			this.clusterTexture.lock().set(this.clusters);
			this.clusterTexture.unlock();
			this.lightsBuffer.uploadTextures();
		};

		_proto.updateUniforms = function updateUniforms() {
			this.lightsBuffer.updateUniforms();

			this._clusterWorldTextureId.setValue(this.clusterTexture);

			var boundsDelta = this.boundsDelta;
			this._clusterCellsCountByBoundsSizeData[0] = this._cells.x / boundsDelta.x;
			this._clusterCellsCountByBoundsSizeData[1] = this._cells.y / boundsDelta.y;
			this._clusterCellsCountByBoundsSizeData[2] = this._cells.z / boundsDelta.z;

			this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);

			this._clusterBoundsMinData[0] = this.boundsMin.x;
			this._clusterBoundsMinData[1] = this.boundsMin.y;
			this._clusterBoundsMinData[2] = this.boundsMin.z;
			this._clusterBoundsDeltaData[0] = boundsDelta.x;
			this._clusterBoundsDeltaData[1] = boundsDelta.y;
			this._clusterBoundsDeltaData[2] = boundsDelta.z;
			this._clusterCompressionLimit0Data[0] = this._maxAttenuation;
			this._clusterCompressionLimit0Data[1] = this._maxColorValue;

			this._clusterPixelsPerCellId.setValue(this._pixelsPerCellCount);

			this._clusterTextureSizeId.setValue(this._clusterTextureSizeData);

			this._clusterBoundsMinId.setValue(this._clusterBoundsMinData);

			this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);

			this._clusterCellsDotId.setValue(this._clusterCellsDotData);

			this._clusterCellsMaxId.setValue(this._clusterCellsMaxData);

			this._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data);
		};

		_proto.evalLightCellMinMax = function evalLightCellMinMax(clusteredLight, min, max) {
			min.copy(clusteredLight.min);
			min.sub(this.boundsMin);
			min.div(this.boundsDelta);
			min.mul2(min, this.cells);
			min.floor();
			max.copy(clusteredLight.max);
			max.sub(this.boundsMin);
			max.div(this.boundsDelta);
			max.mul2(max, this.cells);
			max.ceil();
			min.max(Vec3.ZERO);
			max.min(this._cellsLimit);
		};

		_proto.collectLights = function collectLights(lights) {
			var maxLights = this.lightsBuffer.maxLights;
			var usedLights = this._usedLights;
			var lightIndex = 1;

			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];
				var runtimeLight = !!(light.mask & (MASK_AFFECT_DYNAMIC | MASK_AFFECT_LIGHTMAPPED));

				if (light.enabled && light.type !== LIGHTTYPE_DIRECTIONAL && light.visibleThisFrame && light.intensity > 0 && runtimeLight) {
					if (lightIndex < maxLights) {
						var clusteredLight = void 0;

						if (lightIndex < usedLights.length) {
							clusteredLight = usedLights[lightIndex];
						} else {
							clusteredLight = new ClusterLight();
							usedLights.push(clusteredLight);
						}

						clusteredLight.light = light;
						light.getBoundingBox(tempBox);
						clusteredLight.min.copy(tempBox.getMin());
						clusteredLight.max.copy(tempBox.getMax());
						lightIndex++;
					} else {
						console.warn("Clustered lighting: more than " + (maxLights - 1) + " lights in the frame, ignoring some.");
						break;
					}
				}
			}

			usedLights.length = lightIndex;
		};

		_proto.evaluateBounds = function evaluateBounds() {
			var usedLights = this._usedLights;
			var min = this.boundsMin;
			var max = this.boundsMax;

			if (usedLights.length > 1) {
				min.copy(usedLights[1].min);
				max.copy(usedLights[1].max);

				for (var i = 2; i < usedLights.length; i++) {
					min.min(usedLights[i].min);
					max.max(usedLights[i].max);
				}
			} else {
				min.set(0, 0, 0);
				max.set(1, 1, 1);
			}

			this.boundsDelta.sub2(max, min);
			this.lightsBuffer.setBounds(min, this.boundsDelta);
		};

		_proto.evaluateCompressionLimits = function evaluateCompressionLimits(gammaCorrection) {
			var maxAttenuation = 0;
			var maxColorValue = 0;
			var usedLights = this._usedLights;

			for (var i = 1; i < usedLights.length; i++) {
				var light = usedLights[i].light;
				maxAttenuation = Math.max(light.attenuationEnd, maxAttenuation);
				var color = gammaCorrection ? light._linearFinalColor : light._finalColor;
				maxColorValue = Math.max(color[0], maxColorValue);
				maxColorValue = Math.max(color[1], maxColorValue);
				maxColorValue = Math.max(color[2], maxColorValue);
			}

			this._maxAttenuation = maxAttenuation + epsilon;
			this._maxColorValue = maxColorValue + epsilon;
			this.lightsBuffer.setCompressionRanges(this._maxAttenuation, this._maxColorValue);
		};

		_proto.updateClusters = function updateClusters(gammaCorrection) {
			this.counts.fill(0);
			this.clusters.fill(0);
			var divX = this._cells.x;
			var divZ = this._cells.z;
			var counts = this.counts;
			var limit = this._maxCellLightCount;
			var clusters = this.clusters;
			var pixelsPerCellCount = this._pixelsPerCellCount;
			var tooManyLights = false;
			var usedLights = this._usedLights;

			for (var i = 1; i < usedLights.length; i++) {
				var clusteredLight = usedLights[i];
				var light = clusteredLight.light;
				this.lightsBuffer.addLightData(light, i, gammaCorrection);
				this.evalLightCellMinMax(clusteredLight, tempMin3, tempMax3);
				var xStart = tempMin3.x;
				var xEnd = tempMax3.x;
				var yStart = tempMin3.y;
				var yEnd = tempMax3.y;
				var zStart = tempMin3.z;
				var zEnd = tempMax3.z;

				for (var x = xStart; x <= xEnd; x++) {
					for (var z = zStart; z <= zEnd; z++) {
						for (var y = yStart; y <= yEnd; y++) {
							var clusterIndex = x + divX * (z + y * divZ);
							var count = counts[clusterIndex];

							if (count < limit) {
								clusters[pixelsPerCellCount * clusterIndex * 4 + count] = i;
								counts[clusterIndex] = count + 1;
							} else {
								tooManyLights = true;
							}
						}
					}
				}
			}

			if (tooManyLights) {
				var reportLimit = 5;

				if (this.reportCount < reportLimit) {
					console.warn("Too many lights in light cluster " + this.name + ", please adjust parameters." + (this.reportCount == reportLimit - 1 ? " Giving up on reporting it." : ""));
					this.reportCount++;
				}
			}
		};

		_proto.update = function update(lights, gammaCorrection, lightingParams) {
			this.updateParams(lightingParams);
			this.updateCells();
			this.collectLights(lights);
			this.evaluateBounds();
			this.evaluateCompressionLimits(gammaCorrection);
			this.updateClusters(gammaCorrection);
			this.uploadTextures();
		};

		_proto.activate = function activate() {
			this.updateUniforms();
		};

		_createClass(WorldClusters, [{
			key: "maxCellLightCount",
			get: function get() {
				return this._maxCellLightCount;
			},
			set: function set(count) {
				var maxCellLightCount = math.roundUp(count, 4);

				if (maxCellLightCount !== this._maxCellLightCount) {
					this._maxCellLightCount = maxCellLightCount;
					this._pixelsPerCellCount = this._maxCellLightCount / 4;
					this._cellsDirty = true;
				}
			}
		}, {
			key: "cells",
			get: function get() {
				return this._cells;
			},
			set: function set(value) {
				tempVec3.copy(value).floor();

				if (!this._cells.equals(tempVec3)) {
					this._cells.copy(tempVec3);

					this._cellsLimit.copy(tempVec3).sub(Vec3.ONE);

					this._cellsDirty = true;
				}
			}
		}]);

		return WorldClusters;
	}();

	var textureBlitVertexShader = "\n		attribute vec2 vertex_position;\n		varying vec2 uv0;\n		void main(void) {\n				gl_Position = vec4(vertex_position, 0.5, 1.0);\n				uv0 = vertex_position.xy * 0.5 + 0.5;\n		}";
	var textureBlitFragmentShader = "\n		varying vec2 uv0;\n		uniform sampler2D blitTexture;\n		void main(void) {\n				gl_FragColor = texture2D(blitTexture, uv0);\n		}";
	var textureCubeBlitFragmentShader = "\n		varying vec2 uv0;\n		uniform samplerCube blitTexture;\n		uniform mat4 invViewProj;\n		void main(void) {\n				vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);\n				vec4 worldPos = invViewProj * projPos;\n				gl_FragColor = textureCube(blitTexture, worldPos.xyz);\n		}";

	var _viewport$1 = new Vec4();

	var CookieRenderer = function () {
		function CookieRenderer(device, lightTextureAtlas) {
			this.device = device;
			this.lightTextureAtlas = lightTextureAtlas;
			this.blitShader2d = null;
			this.blitShaderCube = null;
			this.blitTextureId = null;
			this.invViewProjId = null;
		}

		var _proto = CookieRenderer.prototype;

		_proto.destroy = function destroy() {};

		_proto.getShader = function getShader(shader, fragment) {
			if (!this[shader]) this[shader] = createShaderFromCode(this.device, textureBlitVertexShader, fragment, "cookie_renderer_" + shader);
			if (!this.blitTextureId) this.blitTextureId = this.device.scope.resolve("blitTexture");
			if (!this.invViewProjId) this.invViewProjId = this.device.scope.resolve("invViewProj");
			return this[shader];
		};

		CookieRenderer.createTexture = function createTexture(device, resolution) {
			var texture = new Texture(device, {
				name: "CookieAtlas",
				width: resolution,
				height: resolution,
				format: PIXELFORMAT_R8_G8_B8_A8,
				cubemap: false,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			return texture;
		};

		_proto.initInvViewProjMatrices = function initInvViewProjMatrices() {
			if (!CookieRenderer._invViewProjMatrices) {
				CookieRenderer._invViewProjMatrices = [];

				for (var face = 0; face < 6; face++) {
					var camera = LightCamera.create(null, LIGHTTYPE_OMNI, face);
					var projMat = camera.projectionMatrix;
					var viewMat = camera.node.getLocalTransform().clone().invert();
					CookieRenderer._invViewProjMatrices[face] = new Mat4().mul2(projMat, viewMat).invert();
				}
			}
		};

		_proto.render = function render(light, renderTarget) {
			if (light.enabled && light.cookie && light.visibleThisFrame) {
				DebugGraphics.pushGpuMarker(this.device, "COOKIE " + light._node.name);
				var faceCount = light.numShadowFaces;
				var shader = faceCount > 1 ? this.shaderCube : this.shader2d;
				var device = this.device;

				if (faceCount > 1) {
					this.initInvViewProjMatrices();
				}

				this.blitTextureId.setValue(light.cookie);

				for (var face = 0; face < faceCount; face++) {
					_viewport$1.copy(light.atlasViewport);

					if (faceCount > 1) {
						var smallSize = _viewport$1.z / 3;
						var offset = this.lightTextureAtlas.cubeSlotsOffsets[face];
						_viewport$1.x += smallSize * offset.x;
						_viewport$1.y += smallSize * offset.y;
						_viewport$1.z = smallSize;
						_viewport$1.w = smallSize;
						this.invViewProjId.setValue(CookieRenderer._invViewProjMatrices[face].data);
					}

					_viewport$1.mulScalar(renderTarget.colorBuffer.width);

					drawQuadWithShader(device, renderTarget, shader, _viewport$1);
				}

				DebugGraphics.popGpuMarker(this.device);
			}
		};

		_createClass(CookieRenderer, [{
			key: "shader2d",
			get: function get() {
				return this.getShader("blitShader2d", textureBlitFragmentShader);
			}
		}, {
			key: "shaderCube",
			get: function get() {
				return this.getShader("blitShaderCube", textureCubeBlitFragmentShader);
			}
		}]);

		return CookieRenderer;
	}();

	CookieRenderer._invViewProjMatrices = null;

	var ShadowMap = function () {
		function ShadowMap(texture, targets) {
			this.texture = texture;
			this.cached = false;
			this.renderTargets = targets;
		}

		var _proto = ShadowMap.prototype;

		_proto.destroy = function destroy() {
			if (this.texture) {
				this.texture.destroy();
				this.texture = null;
			}

			var targets = this.renderTargets;

			for (var i = 0; i < targets.length; i++) {
				targets[i].destroy();
			}

			this.renderTargets.length = 0;
		};

		ShadowMap.getShadowFormat = function getShadowFormat(device, shadowType) {
			if (shadowType === SHADOW_VSM32) {
				return PIXELFORMAT_RGBA32F;
			} else if (shadowType === SHADOW_VSM16) {
				return PIXELFORMAT_RGBA16F;
			} else if (shadowType === SHADOW_PCF5) {
				return PIXELFORMAT_DEPTH;
			} else if (shadowType === SHADOW_PCF3 && device.webgl2) {
				return PIXELFORMAT_DEPTH;
			}

			return PIXELFORMAT_R8_G8_B8_A8;
		};

		ShadowMap.getShadowFiltering = function getShadowFiltering(device, shadowType) {
			if (shadowType === SHADOW_PCF3 && !device.webgl2) {
				return FILTER_NEAREST;
			} else if (shadowType === SHADOW_VSM32) {
				return device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
			} else if (shadowType === SHADOW_VSM16) {
				return device.extTextureHalfFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
			}

			return FILTER_LINEAR;
		};

		ShadowMap.create = function create(device, light) {
			var shadowMap = null;

			if (light._type === LIGHTTYPE_OMNI) {
				shadowMap = this.createCubemap(device, light._shadowResolution);
			} else {
				shadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);
			}

			return shadowMap;
		};

		ShadowMap.createAtlas = function createAtlas(device, resolution, shadowType) {
			var shadowMap = this.create2dMap(device, resolution, shadowType);
			var targets = shadowMap.renderTargets;
			var rt = targets[0];

			for (var i = 0; i < 5; i++) {
				targets.push(rt);
			}

			return shadowMap;
		};

		ShadowMap.create2dMap = function create2dMap(device, size, shadowType) {
			var format = this.getShadowFormat(device, shadowType);
			var filter = this.getShadowFiltering(device, shadowType);
			var texture = new Texture(device, {
				profilerHint: TEXHINT_SHADOWMAP,
				format: format,
				width: size,
				height: size,
				mipmaps: false,
				minFilter: filter,
				magFilter: filter,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			texture.name = 'ShadowMap2D';
			var target = null;

			if (shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF3 && device.webgl2) {
				texture.compareOnRead = true;
				texture.compareFunc = FUNC_LESS;
				target = new RenderTarget({
					depthBuffer: texture
				});
			} else {
				target = new RenderTarget({
					colorBuffer: texture,
					depth: true
				});
			}

			return new ShadowMap(texture, [target]);
		};

		ShadowMap.createCubemap = function createCubemap(device, size) {
			var cubemap = new Texture(device, {
				profilerHint: TEXHINT_SHADOWMAP,
				format: PIXELFORMAT_R8_G8_B8_A8,
				width: size,
				height: size,
				cubemap: true,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			cubemap.name = 'ShadowMapCube';
			var targets = [];

			for (var i = 0; i < 6; i++) {
				var target = new RenderTarget({
					colorBuffer: cubemap,
					face: i,
					depth: true
				});
				targets.push(target);
			}

			return new ShadowMap(cubemap, targets);
		};

		return ShadowMap;
	}();

	var _tempArray = [];
	var _tempArray2 = [];

	var _viewport = new Vec4();

	var _scissor = new Vec4();

	var Slot = function Slot(rect) {
		this.size = Math.floor(rect.w * 1024);
		this.used = false;
		this.lightId = -1;
		this.rect = rect;
	};

	var LightTextureAtlas = function () {
		function LightTextureAtlas(device) {
			this.device = device;
			this.version = 1;
			this.shadowAtlasResolution = 2048;
			this.shadowAtlas = null;
			this.shadowEdgePixels = 3;
			this.cookieAtlasResolution = 2048;
			this.cookieAtlas = null;
			this.cookieRenderTarget = null;
			this.slots = [];
			this.atlasSplit = [];
			this.cubeSlotsOffsets = [new Vec2(0, 0), new Vec2(0, 1), new Vec2(1, 0), new Vec2(1, 1), new Vec2(2, 0), new Vec2(2, 1)];
			this.scissorVec = new Vec4();
			this.allocateShadowAtlas(1);
			this.allocateCookieAtlas(1);
			this.allocateUniforms();
		}

		var _proto = LightTextureAtlas.prototype;

		_proto.destroy = function destroy() {
			this.destroyShadowAtlas();
			this.destroyCookieAtlas();
		};

		_proto.destroyShadowAtlas = function destroyShadowAtlas() {
			if (this.shadowAtlas) {
				this.shadowAtlas.destroy();
				this.shadowAtlas = null;
			}
		};

		_proto.destroyCookieAtlas = function destroyCookieAtlas() {
			if (this.cookieAtlas) {
				this.cookieAtlas.destroy();
				this.cookieAtlas = null;
			}

			if (this.cookieRenderTarget) {
				this.cookieRenderTarget.destroy();
				this.cookieRenderTarget = null;
			}
		};

		_proto.allocateShadowAtlas = function allocateShadowAtlas(resolution) {
			if (!this.shadowAtlas || this.shadowAtlas.texture.width !== resolution) {
				this.version++;
				this.destroyShadowAtlas();
				this.shadowAtlas = ShadowMap.createAtlas(this.device, resolution, SHADOW_PCF3);
				this.shadowAtlas.cached = true;
				var scissorOffset = 4 / this.shadowAtlasResolution;
				this.scissorVec.set(scissorOffset, scissorOffset, -2 * scissorOffset, -2 * scissorOffset);
			}
		};

		_proto.allocateCookieAtlas = function allocateCookieAtlas(resolution) {
			if (!this.cookieAtlas || this.cookieAtlas.width !== resolution) {
				this.version++;
				this.destroyCookieAtlas();
				this.cookieAtlas = CookieRenderer.createTexture(this.device, resolution);
				this.cookieRenderTarget = new RenderTarget({
					colorBuffer: this.cookieAtlas,
					depth: false,
					flipY: true
				});
			}
		};

		_proto.allocateUniforms = function allocateUniforms() {
			this._shadowAtlasTextureId = this.device.scope.resolve("shadowAtlasTexture");
			this._shadowAtlasParamsId = this.device.scope.resolve("shadowAtlasParams");
			this._shadowAtlasParams = new Float32Array(2);
			this._cookieAtlasTextureId = this.device.scope.resolve("cookieAtlasTexture");
		};

		_proto.updateUniforms = function updateUniforms() {
			var isShadowFilterPcf = true;
			var rt = this.shadowAtlas.renderTargets[0];
			var shadowBuffer = this.device.webgl2 && isShadowFilterPcf ? rt.depthBuffer : rt.colorBuffer;

			this._shadowAtlasTextureId.setValue(shadowBuffer);

			this._shadowAtlasParams[0] = this.shadowAtlasResolution;
			this._shadowAtlasParams[1] = this.shadowEdgePixels;

			this._shadowAtlasParamsId.setValue(this._shadowAtlasParams);

			this._cookieAtlasTextureId.setValue(this.cookieAtlas);
		};

		_proto.subdivide = function subdivide(numLights, lightingParams) {
			var atlasSplit = lightingParams.atlasSplit;

			if (!atlasSplit) {
				var gridSize = Math.ceil(Math.sqrt(numLights));
				atlasSplit = _tempArray2;
				atlasSplit[0] = gridSize;
				atlasSplit.length = 1;
			}

			var arraysEqual = function arraysEqual(a, b) {
				return a.length === b.length && a.every(function (v, i) {
					return v === b[i];
				});
			};

			if (!arraysEqual(atlasSplit, this.atlasSplit)) {
				var _this$atlasSplit;

				this.version++;
				this.slots.length = 0;
				this.atlasSplit.length = 0;

				(_this$atlasSplit = this.atlasSplit).push.apply(_this$atlasSplit, atlasSplit);

				var splitCount = this.atlasSplit[0];

				if (splitCount > 1) {
					var invSize = 1 / splitCount;

					for (var i = 0; i < splitCount; i++) {
						for (var j = 0; j < splitCount; j++) {
							var rect = new Vec4(i * invSize, j * invSize, invSize, invSize);
							var nextLevelSplit = this.atlasSplit[1 + i * splitCount + j];

							if (nextLevelSplit > 1) {
								for (var x = 0; x < nextLevelSplit; x++) {
									for (var y = 0; y < nextLevelSplit; y++) {
										var invSizeNext = invSize / nextLevelSplit;
										var rectNext = new Vec4(rect.x + x * invSizeNext, rect.y + y * invSizeNext, invSizeNext, invSizeNext);
										this.slots.push(new Slot(rectNext));
									}
								}
							} else {
								this.slots.push(new Slot(rect));
							}
						}
					}
				} else {
					this.slots.push(new Slot(new Vec4(0, 0, 1, 1)));
				}

				this.slots.sort(function (a, b) {
					return b.size - a.size;
				});
			}
		};

		_proto.collectLights = function collectLights(spotLights, omniLights, lightingParams) {
			var cookiesEnabled = lightingParams.cookiesEnabled;
			var shadowsEnabled = lightingParams.shadowsEnabled;
			var needsShadowAtlas = false;
			var needsCookieAtlas = false;
			var lights = _tempArray;
			lights.length = 0;

			var processLights = function processLights(list) {
				for (var i = 0; i < list.length; i++) {
					var light = list[i];

					if (light.visibleThisFrame) {
						var lightShadow = shadowsEnabled && light.castShadows;
						var lightCookie = cookiesEnabled && !!light.cookie;
						needsShadowAtlas || (needsShadowAtlas = lightShadow);
						needsCookieAtlas || (needsCookieAtlas = lightCookie);

						if (lightShadow || lightCookie) {
							lights.push(light);
						}
					}
				}
			};

			if (cookiesEnabled || shadowsEnabled) {
				processLights(spotLights);
				processLights(omniLights);
			}

			lights.sort(function (a, b) {
				return b.maxScreenSize - a.maxScreenSize;
			});

			if (needsShadowAtlas) {
				this.allocateShadowAtlas(this.shadowAtlasResolution);
			}

			if (needsCookieAtlas) {
				this.allocateCookieAtlas(this.cookieAtlasResolution);
			}

			if (needsShadowAtlas || needsCookieAtlas) {
				this.subdivide(lights.length, lightingParams);
			}

			return lights;
		};

		_proto.setupSlot = function setupSlot(light, rect) {
			light.atlasViewport.copy(rect);
			var faceCount = light.numShadowFaces;

			for (var face = 0; face < faceCount; face++) {
				if (light.castShadows || light._cookie) {
					_viewport.copy(rect);

					_scissor.copy(rect);

					if (light._type === LIGHTTYPE_SPOT) {
						_viewport.add(this.scissorVec);
					}

					if (light._type === LIGHTTYPE_OMNI) {
						var smallSize = _viewport.z / 3;
						var offset = this.cubeSlotsOffsets[face];
						_viewport.x += smallSize * offset.x;
						_viewport.y += smallSize * offset.y;
						_viewport.z = smallSize;
						_viewport.w = smallSize;

						_scissor.copy(_viewport);
					}

					if (light.castShadows) {
						var lightRenderData = light.getRenderData(null, face);
						lightRenderData.shadowViewport.copy(_viewport);
						lightRenderData.shadowScissor.copy(_scissor);
					}
				}
			}
		};

		_proto.assignSlot = function assignSlot(light, slotIndex, slotReassigned) {
			light.atlasViewportAllocated = true;
			var slot = this.slots[slotIndex];
			slot.lightId = light.id;
			slot.used = true;

			if (slotReassigned) {
				light.atlasSlotUpdated = true;
				light.atlasVersion = this.version;
				light.atlasSlotIndex = slotIndex;
			}
		};

		_proto.update = function update(spotLights, omniLights, lightingParams) {
			this.shadowAtlasResolution = lightingParams.shadowAtlasResolution;
			this.cookieAtlasResolution = lightingParams.cookieAtlasResolution;
			var lights = this.collectLights(spotLights, omniLights, lightingParams);

			if (lights.length > 0) {
				var slots = this.slots;

				for (var i = 0; i < slots.length; i++) {
					slots[i].used = false;
				}

				var assignCount = Math.min(lights.length, slots.length);

				for (var _i = 0; _i < assignCount; _i++) {
					var light = lights[_i];
					if (light.castShadows) light._shadowMap = this.shadowAtlas;
					var previousSlot = slots[light.atlasSlotIndex];

					if (light.atlasVersion === this.version && light.id === (previousSlot == null ? void 0 : previousSlot.lightId)) {
						var _previousSlot = slots[light.atlasSlotIndex];

						if (_previousSlot.size === slots[_i].size && !_previousSlot.used) {
							this.assignSlot(light, light.atlasSlotIndex, false);
						}
					}
				}

				var usedCount = 0;

				for (var _i2 = 0; _i2 < assignCount; _i2++) {
					while (usedCount < slots.length && slots[usedCount].used) {
						usedCount++;
					}

					var _light = lights[_i2];

					if (!_light.atlasViewportAllocated) {
						this.assignSlot(_light, usedCount, true);
					}

					var slot = slots[_light.atlasSlotIndex];
					this.setupSlot(_light, slot.rect);
				}
			}

			this.updateUniforms();
		};

		return LightTextureAtlas;
	}();

	var ShadowMapCache = function () {
		function ShadowMapCache() {
			this.shadowMapCache = new Map();
		}

		var _proto = ShadowMapCache.prototype;

		_proto.destroy = function destroy() {
			this.clear();
			this.shadowMapCache = null;
		};

		_proto.clear = function clear() {
			this.shadowMapCache.forEach(function (shadowMaps) {
				shadowMaps.forEach(function (shadowMap) {
					shadowMap.destroy();
				});
			});
			this.shadowMapCache.clear();
		};

		_proto.getKey = function getKey(light) {
			var isCubeMap = light._type === LIGHTTYPE_OMNI;
			var shadowType = light._shadowType;
			var resolution = light._shadowResolution;
			return isCubeMap + "-" + shadowType + "-" + resolution;
		};

		_proto.get = function get(device, light) {
			var key = this.getKey(light);
			var shadowMaps = this.shadowMapCache.get(key);

			if (shadowMaps && shadowMaps.length) {
				return shadowMaps.pop();
			}

			var shadowMap = ShadowMap.create(device, light);
			shadowMap.cached = true;
			return shadowMap;
		};

		_proto.add = function add(light, shadowMap) {
			var key = this.getKey(light);
			var shadowMaps = this.shadowMapCache.get(key);

			if (shadowMaps) {
				shadowMaps.push(shadowMap);
			} else {
				this.shadowMapCache.set(key, [shadowMap]);
			}
		};

		return ShadowMapCache;
	}();

	var aabbPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
	var _depthRange = {
		min: 0,
		max: 0
	};

	function getDepthRange(cameraViewMatrix, aabbMin, aabbMax) {
		aabbPoints[0].x = aabbPoints[1].x = aabbPoints[2].x = aabbPoints[3].x = aabbMin.x;
		aabbPoints[1].y = aabbPoints[3].y = aabbPoints[7].y = aabbPoints[5].y = aabbMin.y;
		aabbPoints[2].z = aabbPoints[3].z = aabbPoints[6].z = aabbPoints[7].z = aabbMin.z;
		aabbPoints[4].x = aabbPoints[5].x = aabbPoints[6].x = aabbPoints[7].x = aabbMax.x;
		aabbPoints[0].y = aabbPoints[2].y = aabbPoints[4].y = aabbPoints[6].y = aabbMax.y;
		aabbPoints[0].z = aabbPoints[1].z = aabbPoints[4].z = aabbPoints[5].z = aabbMax.z;
		var minz = 9999999999;
		var maxz = -9999999999;

		for (var i = 0; i < 8; ++i) {
			cameraViewMatrix.transformPoint(aabbPoints[i], aabbPoints[i]);
			var z = aabbPoints[i].z;
			if (z < minz) minz = z;
			if (z > maxz) maxz = z;
		}

		_depthRange.min = minz;
		_depthRange.max = maxz;
		return _depthRange;
	}

	function gauss(x, sigma) {
		return Math.exp(-(x * x) / (2.0 * sigma * sigma));
	}

	var maxBlurSize = 25;

	function gaussWeights(kernelSize) {
		if (kernelSize > maxBlurSize) {
			kernelSize = maxBlurSize;
		}

		var sigma = (kernelSize - 1) / (2 * 3);
		var halfWidth = (kernelSize - 1) * 0.5;
		var values = new Array(kernelSize);
		var sum = 0.0;

		for (var i = 0; i < kernelSize; ++i) {
			values[i] = gauss(i - halfWidth, sigma);
			sum += values[i];
		}

		for (var _i = 0; _i < kernelSize; ++_i) {
			values[_i] /= sum;
		}

		return values;
	}

	var visibleSceneAabb = new BoundingBox();
	var shadowCamView = new Mat4();
	var shadowCamViewProj = new Mat4();
	var pixelOffset = new Float32Array(2);
	var blurScissorRect = new Vec4(1, 1, 0, 0);
	var opChanId = {
		r: 1,
		g: 2,
		b: 3,
		a: 4
	};
	var center = new Vec3();
	var viewportMatrix = new Mat4();

	function getDepthKey(meshInstance) {
		var material = meshInstance.material;
		var x = meshInstance.skinInstance ? 10 : 0;
		var y = 0;

		if (material.opacityMap) {
			var opChan = material.opacityMapChannel;

			if (opChan) {
				y = opChanId[opChan];
			}
		}

		return x + y;
	}

	var ShadowRenderer = function () {
		function ShadowRenderer(forwardRenderer, lightTextureAtlas) {
			this.device = forwardRenderer.device;
			this.forwardRenderer = forwardRenderer;
			this.lightTextureAtlas = lightTextureAtlas;
			var scope = this.device.scope;
			this.polygonOffsetId = scope.resolve("polygonOffset");
			this.polygonOffset = new Float32Array(2);
			this.sourceId = scope.resolve("source");
			this.pixelOffsetId = scope.resolve("pixelOffset");
			this.weightId = scope.resolve("weight[0]");
			this.blurVsmShaderCode = [shaderChunks.blurVSMPS, "#define GAUSS\n" + shaderChunks.blurVSMPS];
			var packed = "#define PACKED\n";
			this.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];
			this.blurVsmShader = [{}, {}];
			this.blurPackedVsmShader = [{}, {}];
			this.blurVsmWeights = {};
			this.shadowMapLightRadiusId = scope.resolve('light_radius');
			this.shadowMapCache = new ShadowMapCache();
		}

		var _proto = ShadowRenderer.prototype;

		_proto.destroy = function destroy() {
			this.shadowMapCache.destroy();
			this.shadowMapCache = null;
		};

		ShadowRenderer.createShadowCamera = function createShadowCamera(device, shadowType, type, face) {
			var shadowCam = LightCamera.create("ShadowCamera", type, face);

			if (shadowType >= SHADOW_VSM8 && shadowType <= SHADOW_VSM32) {
				shadowCam.clearColor = new Color(0, 0, 0, 0);
			} else {
				shadowCam.clearColor = new Color(1, 1, 1, 1);
			}

			shadowCam.clearDepthBuffer = true;
			shadowCam.clearStencilBuffer = false;
			return shadowCam;
		};

		ShadowRenderer.setShadowCameraSettings = function setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered) {
			var hwPcf = shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF3 && device.webgl2;

			if (type === LIGHTTYPE_OMNI && !isClustered) {
				hwPcf = false;
			}

			shadowCam.clearColorBuffer = !hwPcf;
		};

		_proto.cullShadowCasters = function cullShadowCasters(meshInstances, visible, camera) {
			var count = 0;
			var numInstances = meshInstances.length;

			for (var i = 0; i < numInstances; i++) {
				var meshInstance = meshInstances[i];

				if (!meshInstance.cull || meshInstance._isVisible(camera)) {
					meshInstance.visibleThisFrame = true;
					visible[count] = meshInstance;
					count++;
				}
			}

			visible.length = count;
			visible.sort(this.forwardRenderer.depthSortCompare);
		};

		_proto.cullLocal = function cullLocal(light, drawCalls) {
			var isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;
			light.visibleThisFrame = true;

			if (!isClustered) {
				if (!light._shadowMap) {
					light._shadowMap = ShadowMap.create(this.device, light);
				}
			}

			var type = light._type;
			var faceCount = type === LIGHTTYPE_SPOT ? 1 : 6;

			for (var face = 0; face < faceCount; face++) {
				var lightRenderData = light.getRenderData(null, face);
				var shadowCam = lightRenderData.shadowCamera;
				shadowCam.nearClip = light.attenuationEnd / 1000;
				shadowCam.farClip = light.attenuationEnd;
				var shadowCamNode = shadowCam._node;
				var lightNode = light._node;
				shadowCamNode.setPosition(lightNode.getPosition());

				if (type === LIGHTTYPE_SPOT) {
					shadowCam.fov = light._outerConeAngle * 2;
					shadowCamNode.setRotation(lightNode.getRotation());
					shadowCamNode.rotateLocal(-90, 0, 0);
				} else if (type === LIGHTTYPE_OMNI) {
					if (isClustered) {
						var tileSize = this.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3;
						var texelSize = 2 / tileSize;
						var filterSize = texelSize * this.lightTextureAtlas.shadowEdgePixels;
						shadowCam.fov = Math.atan(1 + filterSize) * math.RAD_TO_DEG * 2;
					} else {
						shadowCam.fov = 90;
					}
				}

				this.forwardRenderer.updateCameraFrustum(shadowCam);
				this.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);
			}
		};

		_proto.generateSplitDistances = function generateSplitDistances(light, nearDist, farDist) {
			light._shadowCascadeDistances.fill(farDist);

			for (var i = 1; i < light.numCascades; i++) {
				var fraction = i / light.numCascades;
				var linearDist = nearDist + (farDist - nearDist) * fraction;
				var logDist = nearDist * Math.pow(farDist / nearDist, fraction);
				var dist = math.lerp(linearDist, logDist, light.cascadeDistribution);
				light._shadowCascadeDistances[i - 1] = dist;
			}
		};

		_proto.cullDirectional = function cullDirectional(light, drawCalls, camera) {
			light.visibleThisFrame = true;

			if (!light._shadowMap) {
				light._shadowMap = ShadowMap.create(this.device, light);
			}

			var nearDist = camera._nearClip;
			this.generateSplitDistances(light, nearDist, light.shadowDistance);

			for (var cascade = 0; cascade < light.numCascades; cascade++) {
				var lightRenderData = light.getRenderData(camera, cascade);
				var shadowCam = lightRenderData.shadowCamera;
				shadowCam.renderTarget = light._shadowMap.renderTargets[0];
				lightRenderData.shadowViewport.copy(light.cascades[cascade]);
				lightRenderData.shadowScissor.copy(light.cascades[cascade]);
				var shadowCamNode = shadowCam._node;
				var lightNode = light._node;
				shadowCamNode.setPosition(lightNode.getPosition());
				shadowCamNode.setRotation(lightNode.getRotation());
				shadowCamNode.rotateLocal(-90, 0, 0);
				var frustumNearDist = cascade === 0 ? nearDist : light._shadowCascadeDistances[cascade - 1];
				var frustumFarDist = light._shadowCascadeDistances[cascade];
				var frustumPoints = Frustum.getPoints(camera, frustumNearDist, frustumFarDist);
				center.set(0, 0, 0);
				var cameraWorldMat = camera.node.getWorldTransform();

				for (var i = 0; i < 8; i++) {
					cameraWorldMat.transformPoint(frustumPoints[i], frustumPoints[i]);
					center.add(frustumPoints[i]);
				}

				center.mulScalar(1 / 8);
				var radius = 0;

				for (var _i2 = 0; _i2 < 8; _i2++) {
					var dist = frustumPoints[_i2].sub(center).length();

					if (dist > radius) radius = dist;
				}

				var right = shadowCamNode.right;
				var up = shadowCamNode.up;
				var lightDir = shadowCamNode.forward;
				var sizeRatio = 0.25 * light._shadowResolution / radius;
				var x = Math.ceil(center.dot(up) * sizeRatio) / sizeRatio;
				var y = Math.ceil(center.dot(right) * sizeRatio) / sizeRatio;
				var scaledUp = up.mulScalar(x);
				var scaledRight = right.mulScalar(y);
				var dot = center.dot(lightDir);
				var scaledDir = lightDir.mulScalar(dot);
				center.add2(scaledUp, scaledRight).add(scaledDir);
				shadowCamNode.setPosition(center);
				shadowCamNode.translateLocal(0, 0, 1000000);
				shadowCam.nearClip = 0;
				shadowCam.farClip = 2000000;
				shadowCam.orthoHeight = radius;
				this.forwardRenderer.updateCameraFrustum(shadowCam);
				this.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);
				var emptyAabb = true;
				var visibleCasters = lightRenderData.visibleCasters;

				for (var _i3 = 0; _i3 < visibleCasters.length; _i3++) {
					var meshInstance = visibleCasters[_i3];

					if (emptyAabb) {
						emptyAabb = false;
						visibleSceneAabb.copy(meshInstance.aabb);
					} else {
						visibleSceneAabb.add(meshInstance.aabb);
					}
				}

				shadowCamView.copy(shadowCamNode.getWorldTransform()).invert();
				var depthRange = getDepthRange(shadowCamView, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());
				shadowCamNode.translateLocal(0, 0, depthRange.max + 0.1);
				shadowCam.farClip = depthRange.max - depthRange.min + 0.2;
			}
		};

		_proto.setupRenderState = function setupRenderState(device, light) {
			var isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;

			if (device.webgl2) {
				if (light._type === LIGHTTYPE_OMNI && !isClustered) {
					device.setDepthBias(false);
				} else {
					device.setDepthBias(true);
					device.setDepthBiasValues(light.shadowBias * -1000.0, light.shadowBias * -1000.0);
				}
			} else if (device.extStandardDerivatives) {
				if (light._type === LIGHTTYPE_OMNI) {
					this.polygonOffset[0] = 0;
					this.polygonOffset[1] = 0;
					this.polygonOffsetId.setValue(this.polygonOffset);
				} else {
					this.polygonOffset[0] = light.shadowBias * -1000.0;
					this.polygonOffset[1] = light.shadowBias * -1000.0;
					this.polygonOffsetId.setValue(this.polygonOffset);
				}
			}

			device.setBlending(false);
			device.setDepthWrite(true);
			device.setDepthTest(true);
			device.setDepthFunc(FUNC_LESSEQUAL);
			var useShadowSampler = isClustered ? light._isPcf && device.webgl2 : light._isPcf && device.webgl2 && light._type !== LIGHTTYPE_OMNI;

			if (useShadowSampler) {
				device.setColorWrite(false, false, false, false);
			} else {
				device.setColorWrite(true, true, true, true);
			}
		};

		_proto.restoreRenderState = function restoreRenderState(device) {
			if (device.webgl2) {
				device.setDepthBias(false);
			} else if (device.extStandardDerivatives) {
				this.polygonOffset[0] = 0;
				this.polygonOffset[1] = 0;
				this.polygonOffsetId.setValue(this.polygonOffset);
			}
		};

		_proto.dispatchUniforms = function dispatchUniforms(light, shadowCam, lightRenderData, face) {
			var shadowCamNode = shadowCam._node;

			if (light._type !== LIGHTTYPE_DIRECTIONAL) {
				this.forwardRenderer.dispatchViewPos(shadowCamNode.getPosition());
				this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
			}

			shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();
			shadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);
			var rectViewport = lightRenderData.shadowViewport;
			shadowCam.rect = rectViewport;
			shadowCam.scissorRect = lightRenderData.shadowScissor;
			viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
			lightRenderData.shadowMatrix.mul2(viewportMatrix, shadowCamViewProj);

			if (light._type === LIGHTTYPE_DIRECTIONAL) {
				light._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data, face * 16);
			}
		};

		_proto.submitCasters = function submitCasters(visibleCasters, light) {
			var device = this.device;
			var forwardRenderer = this.forwardRenderer;
			var shadowPass = 1 << SHADER_SHADOW;
			var shadowType = light._shadowType;
			var smode = shadowType + light._type * SHADOW_COUNT;
			var count = visibleCasters.length;

			for (var i = 0; i < count; i++) {
				var meshInstance = visibleCasters[i];
				var mesh = meshInstance.mesh;
				var material = meshInstance.material;
				forwardRenderer.setBaseConstants(device, material);
				forwardRenderer.setSkinning(device, meshInstance, material);

				if (material.dirty) {
					material.updateUniforms(device, forwardRenderer.scene);
					material.dirty = false;
				}

				if (material.chunks) {
					forwardRenderer.setCullMode(true, false, meshInstance);
					material.setParameters(device);
					meshInstance.setParameters(device, shadowPass);
				}

				var shadowShader = meshInstance._shader[SHADER_SHADOW + smode];

				if (!shadowShader) {
					forwardRenderer.updateShader(meshInstance, meshInstance._shaderDefs, null, SHADER_SHADOW + smode);
					shadowShader = meshInstance._shader[SHADER_SHADOW + smode];
					meshInstance._key[SORTKEY_DEPTH] = getDepthKey(meshInstance);
				}

				device.setShader(shadowShader);
				forwardRenderer.setVertexBuffers(device, mesh);
				forwardRenderer.setMorphing(device, meshInstance.morphInstance);
				var style = meshInstance.renderStyle;
				device.setIndexBuffer(mesh.indexBuffer[style]);
				forwardRenderer.drawInstance(device, meshInstance, mesh, style);
				forwardRenderer._shadowDrawCalls++;
			}
		};

		_proto.render = function render(light, camera) {
			if (light.enabled && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame) {
				var device = this.device;

				if (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) {
					light.shadowUpdateMode = SHADOWUPDATE_NONE;
				}

				var type = light._type;
				var shadowType = light._shadowType;
				var faceCount = light.numShadowFaces;
				var forwardRenderer = this.forwardRenderer;
				forwardRenderer._shadowMapUpdates += faceCount;
				var isClustered = forwardRenderer.scene.clusteredLightingEnabled;
				DebugGraphics.pushGpuMarker(device, "SHADOW " + light._node.name);
				this.setupRenderState(device, light);

				for (var face = 0; face < faceCount; face++) {
					DebugGraphics.pushGpuMarker(device, "FACE " + face);
					var lightRenderData = light.getRenderData(type === LIGHTTYPE_DIRECTIONAL ? camera : null, face);
					var shadowCam = lightRenderData.shadowCamera;
					ShadowRenderer.setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered);
					var renderTargetIndex = type === LIGHTTYPE_DIRECTIONAL ? 0 : face;
					shadowCam.renderTarget = light._shadowMap.renderTargets[renderTargetIndex];
					this.dispatchUniforms(light, shadowCam, lightRenderData, face);
					forwardRenderer.setCamera(shadowCam, shadowCam.renderTarget, true);
					this.submitCasters(lightRenderData.visibleCasters, light);
					DebugGraphics.popGpuMarker(device);
				}

				if (light._isVsm && light._vsmBlurSize > 1) {
					var _isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;

					if (!_isClustered || type === LIGHTTYPE_DIRECTIONAL) {
						this.applyVsmBlur(light, camera);
					}
				}

				this.restoreRenderState(device);
				DebugGraphics.popGpuMarker(device);
			}
		};

		_proto.getVsmBlurShader = function getVsmBlurShader(isVsm8, blurMode, filterSize) {
			var blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];

			if (!blurShader) {
				this.blurVsmWeights[filterSize] = gaussWeights(filterSize);
				var blurVS = shaderChunks.fullscreenQuadVS;
				var blurFS = "#define SAMPLES " + filterSize + "\n";

				if (isVsm8) {
					blurFS += this.blurPackedVsmShaderCode[blurMode];
				} else {
					blurFS += this.blurVsmShaderCode[blurMode];
				}

				var blurShaderName = "blurVsm" + blurMode + "" + filterSize + "" + isVsm8;
				blurShader = createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);

				if (isVsm8) {
					this.blurPackedVsmShader[blurMode][filterSize] = blurShader;
				} else {
					this.blurVsmShader[blurMode][filterSize] = blurShader;
				}
			}

			return blurShader;
		};

		_proto.applyVsmBlur = function applyVsmBlur(light, camera) {
			var device = this.device;
			DebugGraphics.pushGpuMarker(device, "VSM");
			var lightRenderData = light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, 0);
			var shadowCam = lightRenderData.shadowCamera;
			var origShadowMap = shadowCam.renderTarget;
			var tempShadowMap = this.shadowMapCache.get(device, light);
			var tempRt = tempShadowMap.renderTargets[0];
			var isVsm8 = light._shadowType === SHADOW_VSM8;
			var blurMode = light.vsmBlurMode;
			var filterSize = light._vsmBlurSize;
			var blurShader = this.getVsmBlurShader(isVsm8, blurMode, filterSize);
			blurScissorRect.z = light._shadowResolution - 2;
			blurScissorRect.w = blurScissorRect.z;
			this.sourceId.setValue(origShadowMap.colorBuffer);
			pixelOffset[0] = 1 / light._shadowResolution;
			pixelOffset[1] = 0;
			this.pixelOffsetId.setValue(pixelOffset);
			if (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);
			drawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);
			this.sourceId.setValue(tempRt.colorBuffer);
			pixelOffset[1] = pixelOffset[0];
			pixelOffset[0] = 0;
			this.pixelOffsetId.setValue(pixelOffset);
			drawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);
			this.shadowMapCache.add(light, tempShadowMap);
			DebugGraphics.popGpuMarker(device);
		};

		return ShadowRenderer;
	}();

	var tempSphere$2 = new BoundingSphere();

	var StaticMeshes = function () {
		function StaticMeshes() {}

		StaticMeshes.lightCompare = function lightCompare(lightA, lightB) {
			return lightA.key - lightB.key;
		};

		StaticMeshes.prepare = function prepare(device, scene, meshInstances, lights) {
			var prepareTime = now();
			var searchTime = 0;
			var subSearchTime = 0;
			var triAabbTime = 0;
			var subTriAabbTime = 0;
			var writeMeshTime = 0;
			var subWriteMeshTime = 0;
			var combineTime = 0;
			var subCombineTime = 0;
			var drawCalls = meshInstances;
			var drawCallsCount = drawCalls.length;
			var newDrawCalls = [];
			var minVec = new Vec3();
			var maxVec = new Vec3();
			var localLightBounds = new BoundingBox();
			var invMatrix = new Mat4();
			var triLightComb = [];
			var lightAabb = [];
			var triBounds = [];
			var staticLights = [];

			for (var i = 0; i < drawCallsCount; i++) {
				var drawCall = drawCalls[i];

				if (!drawCall.isStatic) {
					newDrawCalls.push(drawCall);
				} else {
					var aabb = drawCall.aabb;
					staticLights.length = 0;

					for (var lightTypePass = LIGHTTYPE_OMNI; lightTypePass <= LIGHTTYPE_SPOT; lightTypePass++) {
						for (var j = 0; j < lights.length; j++) {
							var light = lights[j];
							if (light._type !== lightTypePass) continue;

							if (light.enabled) {
								if (light.mask & drawCall.mask) {
									if (light.isStatic) {
										if (!lightAabb[j]) {
											lightAabb[j] = new BoundingBox();

											light._node.getWorldTransform();

											light.getBoundingSphere(tempSphere$2);
											lightAabb[j].center.copy(tempSphere$2.center);
											lightAabb[j].halfExtents.set(tempSphere$2.radius, tempSphere$2.radius, tempSphere$2.radius);
										}

										if (!lightAabb[j].intersects(aabb)) continue;
										staticLights.push(j);
									}
								}
							}
						}
					}

					if (staticLights.length === 0) {
						newDrawCalls.push(drawCall);
						continue;
					}

					var mesh = drawCall.mesh;
					var vertexBuffer = mesh.vertexBuffer;
					var indexBuffer = mesh.indexBuffer[drawCall.renderStyle];
					var indices = indexBuffer.bytesPerIndex === 2 ? new Uint16Array(indexBuffer.lock()) : new Uint32Array(indexBuffer.lock());
					var numTris = mesh.primitive[drawCall.renderStyle].count / 3;
					var baseIndex = mesh.primitive[drawCall.renderStyle].base;
					var elems = vertexBuffer.format.elements;
					var vertSize = vertexBuffer.format.size / 4;
					var verts = new Float32Array(vertexBuffer.storage);
					var offsetP = void 0;

					for (var k = 0; k < elems.length; k++) {
						if (elems[k].name === SEMANTIC_POSITION) {
							offsetP = elems[k].offset / 4;
						}
					}

					subTriAabbTime = now();
					triLightComb.length = numTris;

					for (var _k = 0; _k < numTris; _k++) {
						triLightComb[_k] = 0;
					}

					var triLightCombUsed = false;
					triBounds.length = numTris * 6;

					for (var _k2 = 0; _k2 < numTris; _k2++) {
						var minx = Number.MAX_VALUE;
						var miny = Number.MAX_VALUE;
						var minz = Number.MAX_VALUE;
						var maxx = -Number.MAX_VALUE;
						var maxy = -Number.MAX_VALUE;
						var maxz = -Number.MAX_VALUE;

						for (var v = 0; v < 3; v++) {
							var _index = indices[_k2 * 3 + v + baseIndex];
							_index = _index * vertSize + offsetP;
							var _x = verts[_index];
							var _y = verts[_index + 1];
							var _z = verts[_index + 2];
							if (_x < minx) minx = _x;
							if (_y < miny) miny = _y;
							if (_z < minz) minz = _z;
							if (_x > maxx) maxx = _x;
							if (_y > maxy) maxy = _y;
							if (_z > maxz) maxz = _z;
						}

						var index = _k2 * 6;
						triBounds[index] = minx;
						triBounds[index + 1] = miny;
						triBounds[index + 2] = minz;
						triBounds[index + 3] = maxx;
						triBounds[index + 4] = maxy;
						triBounds[index + 5] = maxz;
					}

					triAabbTime += now() - subTriAabbTime;
					subSearchTime = now();

					for (var s = 0; s < staticLights.length; s++) {
						var _j = staticLights[s];
						invMatrix.copy(drawCall.node.worldTransform).invert();
						localLightBounds.setFromTransformedAabb(lightAabb[_j], invMatrix);
						var minv = localLightBounds.getMin();
						var maxv = localLightBounds.getMax();
						var bit = 1 << s;

						for (var _k3 = 0; _k3 < numTris; _k3++) {
							var _index2 = _k3 * 6;

							if (triBounds[_index2] <= maxv.x && triBounds[_index2 + 3] >= minv.x && triBounds[_index2 + 1] <= maxv.y && triBounds[_index2 + 4] >= minv.y && triBounds[_index2 + 2] <= maxv.z && triBounds[_index2 + 5] >= minv.z) {
								triLightComb[_k3] |= bit;
								triLightCombUsed = true;
							}
						}
					}

					searchTime += now() - subSearchTime;

					if (triLightCombUsed) {
						subCombineTime = now();
						var combIndices = {};

						for (var _k4 = 0; _k4 < numTris; _k4++) {
							var _j2 = _k4 * 3 + baseIndex;

							var combIbName = triLightComb[_k4];
							if (!combIndices[combIbName]) combIndices[combIbName] = [];
							var combIb = combIndices[combIbName];
							combIb.push(indices[_j2]);
							combIb.push(indices[_j2 + 1]);
							combIb.push(indices[_j2 + 2]);
						}

						combineTime += now() - subCombineTime;
						subWriteMeshTime = now();

						for (var _combIbName in combIndices) {
							var _combIb = combIndices[_combIbName];
							var ib = new IndexBuffer(device, indexBuffer.format, _combIb.length, indexBuffer.usage);
							var ib2 = ib.bytesPerIndex === 2 ? new Uint16Array(ib.lock()) : new Uint32Array(ib.lock());
							ib2.set(_combIb);
							ib.unlock();
							var _minx = Number.MAX_VALUE;
							var _miny = Number.MAX_VALUE;
							var _minz = Number.MAX_VALUE;

							var _maxx = -Number.MAX_VALUE;

							var _maxy = -Number.MAX_VALUE;

							var _maxz = -Number.MAX_VALUE;

							for (var _k5 = 0; _k5 < _combIb.length; _k5++) {
								var _index3 = _combIb[_k5];
								var _x2 = verts[_index3 * vertSize + offsetP];
								var _y2 = verts[_index3 * vertSize + offsetP + 1];
								var _z2 = verts[_index3 * vertSize + offsetP + 2];
								if (_x2 < _minx) _minx = _x2;
								if (_y2 < _miny) _miny = _y2;
								if (_z2 < _minz) _minz = _z2;
								if (_x2 > _maxx) _maxx = _x2;
								if (_y2 > _maxy) _maxy = _y2;
								if (_z2 > _maxz) _maxz = _z2;
							}

							minVec.set(_minx, _miny, _minz);
							maxVec.set(_maxx, _maxy, _maxz);
							var chunkAabb = new BoundingBox();
							chunkAabb.setMinMax(minVec, maxVec);
							var mesh2 = new Mesh(device);
							mesh2.vertexBuffer = vertexBuffer;
							mesh2.indexBuffer[0] = ib;
							mesh2.primitive[0].type = PRIMITIVE_TRIANGLES;
							mesh2.primitive[0].base = 0;
							mesh2.primitive[0].count = _combIb.length;
							mesh2.primitive[0].indexed = true;
							mesh2.aabb = chunkAabb;
							var instance = new MeshInstance(mesh2, drawCall.material, drawCall.node);
							instance.isStatic = drawCall.isStatic;
							instance.visible = drawCall.visible;
							instance.layer = drawCall.layer;
							instance.castShadow = drawCall.castShadow;
							instance._receiveShadow = drawCall._receiveShadow;
							instance.cull = drawCall.cull;
							instance.pick = drawCall.pick;
							instance.mask = drawCall.mask;
							instance.parameters = drawCall.parameters;
							instance._shaderDefs = drawCall._shaderDefs;
							instance._staticSource = drawCall;

							if (drawCall._staticLightList) {
								instance._staticLightList = drawCall._staticLightList;
							} else {
								instance._staticLightList = [];
							}

							for (var _k6 = 0; _k6 < staticLights.length; _k6++) {
								var _bit = 1 << _k6;

								if (_combIbName & _bit) {
									var lht = lights[staticLights[_k6]];

									if (instance._staticLightList.indexOf(lht) < 0) {
										instance._staticLightList.push(lht);
									}
								}
							}

							instance._staticLightList.sort(StaticMeshes.lightCompare);

							newDrawCalls.push(instance);
						}

						writeMeshTime += now() - subWriteMeshTime;
					} else {
						newDrawCalls.push(drawCall);
					}
				}
			}

			meshInstances.length = newDrawCalls.length;

			for (var _i = 0; _i < newDrawCalls.length; _i++) {
				meshInstances[_i] = newDrawCalls[_i];
			}

			scene._stats.lastStaticPrepareFullTime = now() - prepareTime;
			scene._stats.lastStaticPrepareSearchTime = searchTime;
			scene._stats.lastStaticPrepareWriteTime = writeMeshTime;
			scene._stats.lastStaticPrepareTriAabbTime = triAabbTime;
			scene._stats.lastStaticPrepareCombineTime = combineTime;
		};

		StaticMeshes.revert = function revert(meshInstances) {
			var drawCalls = meshInstances;
			var drawCallsCount = drawCalls.length;
			var newDrawCalls = [];
			var prevStaticSource;

			for (var i = 0; i < drawCallsCount; i++) {
				var drawCall = drawCalls[i];

				if (drawCall._staticSource) {
					if (drawCall._staticSource !== prevStaticSource) {
						newDrawCalls.push(drawCall._staticSource);
						prevStaticSource = drawCall._staticSource;
					}
				} else {
					newDrawCalls.push(drawCall);
				}
			}

			meshInstances.length = newDrawCalls.length;

			for (var _i2 = 0; _i2 < newDrawCalls.length; _i2++) {
				meshInstances[_i2] = newDrawCalls[_i2];
			}
		};

		return StaticMeshes;
	}();

	var WorldClustersDebug = function () {
		function WorldClustersDebug() {}

		WorldClustersDebug.render = function render(worldClusters, scene) {
			var device = scene.device;
			var cells = worldClusters.cells;
			var lightsBuffer = worldClusters.lightsBuffer;
			var boundsMin = lightsBuffer.boundsMin;
			var boundsDelta = lightsBuffer.boundsDelta;
			var boundsMax = boundsMin.clone().add(boundsDelta);
			var cellDelta = lightsBuffer.boundsDelta.clone().div(cells);
			var gridPositions = WorldClustersDebug.gridPositions;
			var gridColors = WorldClustersDebug.gridColors;
			var c1 = new Color(0.3, 0.3, 0.3);

			var renderCellLines = function renderCellLines(countA, countB, minA, deltaA, minB, deltaB, minC, maxC, order) {
				for (var a = 0; a <= countA; a++) {
					for (var b = 0; b <= countB; b++) {
						var aa = minA + a * deltaA;
						var bb = minB + b * deltaB;
						if (order === 0) gridPositions.push(aa, minC, bb, aa, maxC, bb);else if (order === 1) gridPositions.push(aa, bb, minC, aa, bb, maxC);else if (order === 2) gridPositions.push(minC, aa, bb, maxC, aa, bb);
					}
				}
			};

			renderCellLines(cells.x, cells.z, boundsMin.x, cellDelta.x, boundsMin.z, cellDelta.z, boundsMin.y, boundsMax.y, 0);
			renderCellLines(cells.x, cells.y, boundsMin.x, cellDelta.x, boundsMin.y, cellDelta.y, boundsMin.z, boundsMax.z, 1);
			renderCellLines(cells.y, cells.z, boundsMin.y, cellDelta.y, boundsMin.z, cellDelta.z, boundsMin.x, boundsMax.x, 2);

			if (gridPositions.length) {
				var numVerts = gridPositions.length / 3;

				if (numVerts !== gridColors.length / 4) {
					gridColors.length = 0;

					for (var i = 0; i < numVerts; i++) {
						gridColors.push(c1.r, c1.g, c1.b, c1.a);
					}
				}

				scene.drawLineArrays(gridPositions, gridColors);
				gridPositions.length = 0;
			}

			var mesh = WorldClustersDebug.mesh;

			if (!mesh) {
				mesh = new Mesh(device);
				mesh.clear(true, true);
				WorldClustersDebug.mesh = mesh;
			}

			var positions = [];
			var colors = [];
			var indices = [];
			var divX = worldClusters._cells.x;
			var divZ = worldClusters._cells.z;
			var counts = worldClusters.counts;
			var limit = worldClusters._maxCellLightCount;
			var min = new Vec3();
			var max = new Vec3();
			var col = new Vec3();
			var step = boundsDelta.clone().div(cells);
			var cubes = 0;

			for (var x = 0; x < cells.x; x++) {
				for (var z = 0; z < cells.z; z++) {
					for (var y = 0; y < cells.y; y++) {
						var clusterIndex = x + divX * (z + y * divZ);
						var count = counts[clusterIndex];

						if (count > 0) {
							min.x = boundsMin.x + step.x * x;
							min.y = boundsMin.y + step.y * y;
							min.z = boundsMin.z + step.z * z;
							max.add2(min, step);
							positions.push(min.x, min.y, max.z);
							positions.push(max.x, min.y, max.z);
							positions.push(max.x, max.y, max.z);
							positions.push(min.x, max.y, max.z);
							positions.push(max.x, min.y, min.z);
							positions.push(min.x, min.y, min.z);
							positions.push(min.x, max.y, min.z);
							positions.push(max.x, max.y, min.z);
							col.lerp(WorldClustersDebug.colorLow, WorldClustersDebug.colorHigh, count / limit).round();

							for (var c = 0; c < 8; c++) {
								colors.push(col.x, col.y, col.z, 1);
							}

							indices.push(cubes * 8 + 0, cubes * 8 + 1, cubes * 8 + 3);
							indices.push(cubes * 8 + 3, cubes * 8 + 1, cubes * 8 + 2);
							indices.push(cubes * 8 + 4, cubes * 8 + 5, cubes * 8 + 7);
							indices.push(cubes * 8 + 7, cubes * 8 + 5, cubes * 8 + 6);
							indices.push(cubes * 8 + 3, cubes * 8 + 2, cubes * 8 + 6);
							indices.push(cubes * 8 + 2, cubes * 8 + 7, cubes * 8 + 6);
							indices.push(cubes * 8 + 1, cubes * 8 + 0, cubes * 8 + 4);
							indices.push(cubes * 8 + 0, cubes * 8 + 5, cubes * 8 + 4);
							indices.push(cubes * 8 + 1, cubes * 8 + 4, cubes * 8 + 2);
							indices.push(cubes * 8 + 4, cubes * 8 + 7, cubes * 8 + 2);
							indices.push(cubes * 8 + 5, cubes * 8 + 0, cubes * 8 + 6);
							indices.push(cubes * 8 + 0, cubes * 8 + 3, cubes * 8 + 6);
							cubes++;
						}
					}
				}
			}

			if (cubes) {
				mesh.setPositions(positions);
				mesh.setColors32(colors);
				mesh.setIndices(indices);
				mesh.update(PRIMITIVE_TRIANGLES, false);

				if (!WorldClustersDebug.meshInstance) {
					var material = new StandardMaterial();
					material.useLighting = false;
					material.emissive = new Color(1, 1, 1);
					material.emissiveVertexColor = true;
					material.emissiveTint = false;
					material.blendType = BLEND_ADDITIVEALPHA;
					material.depthWrite = false;
					material.update();
					var node = new GraphNode("WorldClustersDebug");
					node.worldTransform = Mat4.IDENTITY;
					node._dirtyWorld = node._dirtyNormal = false;
					WorldClustersDebug.meshInstance = new MeshInstance(mesh, material, node);
					WorldClustersDebug.meshInstance.cull = false;
				}

				var meshInstance = WorldClustersDebug.meshInstance;
				scene.immediate.drawMesh(meshInstance.material, meshInstance.node.worldTransform, null, meshInstance, scene.defaultDrawLayer);
			}
		};

		return WorldClustersDebug;
	}();

	WorldClustersDebug.gridPositions = [];
	WorldClustersDebug.gridColors = [];
	WorldClustersDebug.mesh = null;
	WorldClustersDebug.meshInstance = null;
	WorldClustersDebug.colorLow = new Vec3(1, 1, 1);
	WorldClustersDebug.colorHigh = new Vec3(40, 0, 0);

	var viewInvMat = new Mat4();
	var viewMat = new Mat4();
	var viewMat3 = new Mat3();
	var viewProjMat = new Mat4();
	var projMat;
	var flipYMat = new Mat4().setScale(1, -1, 1);
	var flippedViewProjMat = new Mat4();
	var flippedSkyboxProjMat = new Mat4();
	var viewInvL = new Mat4();
	var viewInvR = new Mat4();
	var viewL = new Mat4();
	var viewR = new Mat4();
	var viewPosL = new Vec3();
	var viewPosR = new Vec3();
	var projL, projR;
	var viewMat3L = new Mat3();
	var viewMat3R = new Mat3();
	var viewProjMatL = new Mat4();
	var viewProjMatR = new Mat4();
	var worldMatX = new Vec3();
	var worldMatY = new Vec3();
	var worldMatZ = new Vec3();
	var tempSphere$1 = new BoundingSphere();
	var boneTextureSize = [0, 0, 0, 0];
	var boneTexture, instancingData, modelMatrix, normalMatrix;
	var keyA$1, keyB$1;
	var _skinUpdateIndex = 0;
	var _drawCallList = {
		drawCalls: [],
		isNewMaterial: [],
		lightMaskChanged: []
	};

	var _tempMaterialSet = new Set();

	var ForwardRenderer = function () {
		function ForwardRenderer(graphicsDevice) {
			this.device = graphicsDevice;
			this.scene = null;
			this._shadowDrawCalls = 0;
			this._forwardDrawCalls = 0;
			this._skinDrawCalls = 0;
			this._numDrawCallsCulled = 0;
			this._instancedDrawCalls = 0;
			this._camerasRendered = 0;
			this._materialSwitches = 0;
			this._shadowMapUpdates = 0;
			this._shadowMapTime = 0;
			this._depthMapTime = 0;
			this._forwardTime = 0;
			this._cullTime = 0;
			this._sortTime = 0;
			this._skinTime = 0;
			this._morphTime = 0;
			this._layerCompositionUpdateTime = 0;
			this._lightClustersTime = 0;
			this._lightClusters = 0;
			var device = this.device;
			this.library = device.getProgramLibrary();
			this.lightTextureAtlas = new LightTextureAtlas(device);
			this._shadowRenderer = new ShadowRenderer(this, this.lightTextureAtlas);
			this._cookieRenderer = new CookieRenderer(device, this.lightTextureAtlas);
			var scope = device.scope;
			this.projId = scope.resolve('matrix_projection');
			this.projSkyboxId = scope.resolve('matrix_projectionSkybox');
			this.viewId = scope.resolve('matrix_view');
			this.viewId3 = scope.resolve('matrix_view3');
			this.viewInvId = scope.resolve('matrix_viewInverse');
			this.viewProjId = scope.resolve('matrix_viewProjection');
			this.viewPos = new Float32Array(3);
			this.viewPosId = scope.resolve('view_position');
			this.nearClipId = scope.resolve('camera_near');
			this.farClipId = scope.resolve('camera_far');
			this.cameraParamsId = scope.resolve('camera_params');
			this.tbnBasis = scope.resolve('tbnBasis');
			this.fogColorId = scope.resolve('fog_color');
			this.fogStartId = scope.resolve('fog_start');
			this.fogEndId = scope.resolve('fog_end');
			this.fogDensityId = scope.resolve('fog_density');
			this.modelMatrixId = scope.resolve('matrix_model');
			this.normalMatrixId = scope.resolve('matrix_normal');
			this.poseMatrixId = scope.resolve('matrix_pose[0]');
			this.boneTextureId = scope.resolve('texture_poseMap');
			this.boneTextureSizeId = scope.resolve('texture_poseMapSize');
			this.morphWeightsA = scope.resolve('morph_weights_a');
			this.morphWeightsB = scope.resolve('morph_weights_b');
			this.morphPositionTex = scope.resolve('morphPositionTex');
			this.morphNormalTex = scope.resolve('morphNormalTex');
			this.morphTexParams = scope.resolve('morph_tex_params');
			this.alphaTestId = scope.resolve('alpha_ref');
			this.opacityMapId = scope.resolve('texture_opacityMap');
			this.ambientId = scope.resolve("light_globalAmbient");
			this.exposureId = scope.resolve("exposure");
			this.skyboxIntensityId = scope.resolve("skyboxIntensity");
			this.lightColorId = [];
			this.lightDir = [];
			this.lightDirId = [];
			this.lightShadowMapId = [];
			this.lightShadowMatrixId = [];
			this.lightShadowParamsId = [];
			this.lightRadiusId = [];
			this.lightPos = [];
			this.lightPosId = [];
			this.lightWidth = [];
			this.lightWidthId = [];
			this.lightHeight = [];
			this.lightHeightId = [];
			this.lightInAngleId = [];
			this.lightOutAngleId = [];
			this.lightCookieId = [];
			this.lightCookieIntId = [];
			this.lightCookieMatrixId = [];
			this.lightCookieOffsetId = [];
			this.shadowMatrixPaletteId = [];
			this.shadowCascadeDistancesId = [];
			this.shadowCascadeCountId = [];
			this.depthMapId = scope.resolve('uDepthMap');
			this.screenSizeId = scope.resolve('uScreenSize');
			this._screenSize = new Float32Array(4);
			this.twoSidedLightingNegScaleFactorId = scope.resolve("twoSidedLightingNegScaleFactor");
			this.fogColor = new Float32Array(3);
			this.ambientColor = new Float32Array(3);
			this.cameraParams = new Float32Array(4);
		}

		var _proto = ForwardRenderer.prototype;

		_proto.destroy = function destroy() {
			this._shadowRenderer.destroy();

			this._shadowRenderer = null;

			this._cookieRenderer.destroy();

			this._cookieRenderer = null;
			this.lightTextureAtlas.destroy();
			this.lightTextureAtlas = null;
		};

		_proto.sortCompare = function sortCompare(drawCallA, drawCallB) {
			if (drawCallA.layer === drawCallB.layer) {
				if (drawCallA.drawOrder && drawCallB.drawOrder) {
					return drawCallA.drawOrder - drawCallB.drawOrder;
				} else if (drawCallA.zdist && drawCallB.zdist) {
					return drawCallB.zdist - drawCallA.zdist;
				} else if (drawCallA.zdist2 && drawCallB.zdist2) {
					return drawCallA.zdist2 - drawCallB.zdist2;
				}
			}

			return drawCallB._key[SORTKEY_FORWARD] - drawCallA._key[SORTKEY_FORWARD];
		};

		_proto.sortCompareMesh = function sortCompareMesh(drawCallA, drawCallB) {
			if (drawCallA.layer === drawCallB.layer) {
				if (drawCallA.drawOrder && drawCallB.drawOrder) {
					return drawCallA.drawOrder - drawCallB.drawOrder;
				} else if (drawCallA.zdist && drawCallB.zdist) {
					return drawCallB.zdist - drawCallA.zdist;
				}
			}

			keyA$1 = drawCallA._key[SORTKEY_FORWARD];
			keyB$1 = drawCallB._key[SORTKEY_FORWARD];

			if (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {
				return drawCallB.mesh.id - drawCallA.mesh.id;
			}

			return keyB$1 - keyA$1;
		};

		_proto.depthSortCompare = function depthSortCompare(drawCallA, drawCallB) {
			keyA$1 = drawCallA._key[SORTKEY_DEPTH];
			keyB$1 = drawCallB._key[SORTKEY_DEPTH];

			if (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {
				return drawCallB.mesh.id - drawCallA.mesh.id;
			}

			return keyB$1 - keyA$1;
		};

		_proto.updateCameraFrustum = function updateCameraFrustum(camera) {
			if (camera.vrDisplay && camera.vrDisplay.presenting) {
				projMat = camera.vrDisplay.combinedProj;
				var parent = camera._node.parent;

				if (parent) {
					viewMat.copy(parent.getWorldTransform()).mul(camera.vrDisplay.combinedViewInv).invert();
				} else {
					viewMat.copy(camera.vrDisplay.combinedView);
				}

				viewInvMat.copy(viewMat).invert();
				this.viewInvId.setValue(viewInvMat.data);
				viewProjMat.mul2(projMat, viewMat);
				camera.frustum.setFromMat4(viewProjMat);
			} else if (camera.xr && camera.xr.views.length) {
				var view = camera.xr.views[0];
				viewProjMat.mul2(view.projMat, view.viewOffMat);
				camera.frustum.setFromMat4(viewProjMat);
				return;
			}

			projMat = camera.projectionMatrix;

			if (camera.calculateProjection) {
				camera.calculateProjection(projMat, VIEW_CENTER);
			}

			if (camera.calculateTransform) {
				camera.calculateTransform(viewInvMat, VIEW_CENTER);
			} else {
				var pos = camera._node.getPosition();

				var rot = camera._node.getRotation();

				viewInvMat.setTRS(pos, rot, Vec3.ONE);
				this.viewInvId.setValue(viewInvMat.data);
			}

			viewMat.copy(viewInvMat).invert();
			viewProjMat.mul2(projMat, viewMat);
			camera.frustum.setFromMat4(viewProjMat);
		};

		_proto.setCamera = function setCamera(camera, target, clear) {
			var vrDisplay = camera.vrDisplay;
			var transform;

			if (vrDisplay && vrDisplay.presenting) {
				projL = vrDisplay.leftProj;
				projR = vrDisplay.rightProj;
				projMat = vrDisplay.combinedProj;

				if (camera.calculateProjection) {
					camera.calculateProjection(projL, VIEW_LEFT);
					camera.calculateProjection(projR, VIEW_RIGHT);
					camera.calculateProjection(projMat, VIEW_CENTER);
				}

				if (camera.calculateTransform) {
					camera.calculateTransform(viewInvL, VIEW_LEFT);
					camera.calculateTransform(viewInvR, VIEW_RIGHT);
					camera.calculateTransform(viewInvMat, VIEW_CENTER);
					viewL.copy(viewInvL).invert();
					viewR.copy(viewInvR).invert();
					viewMat.copy(viewInvMat).invert();
				} else {
					var parent = camera._node.parent;

					if (parent) {
						transform = parent.getWorldTransform();
						viewInvL.mul2(transform, vrDisplay.leftViewInv);
						viewInvR.mul2(transform, vrDisplay.rightViewInv);
						viewL.copy(viewInvL).invert();
						viewR.copy(viewInvR).invert();
						viewMat.copy(parent.getWorldTransform()).mul(vrDisplay.combinedViewInv).invert();
					} else {
						viewInvL.copy(vrDisplay.leftViewInv);
						viewInvR.copy(vrDisplay.rightViewInv);
						viewL.copy(vrDisplay.leftView);
						viewR.copy(vrDisplay.rightView);
						viewMat.copy(vrDisplay.combinedView);
					}
				}

				viewMat3L.setFromMat4(viewL);
				viewMat3R.setFromMat4(viewR);
				viewProjMatL.mul2(projL, viewL);
				viewProjMatR.mul2(projR, viewR);
				viewPosL.x = viewInvL.data[12];
				viewPosL.y = viewInvL.data[13];
				viewPosL.z = viewInvL.data[14];
				viewPosR.x = viewInvR.data[12];
				viewPosR.y = viewInvR.data[13];
				viewPosR.z = viewInvR.data[14];
				viewProjMat.mul2(projMat, viewMat);
				camera.frustum.setFromMat4(viewProjMat);
			} else if (camera.xr && camera.xr.session) {
				var _parent = camera._node.parent;
				if (_parent) transform = _parent.getWorldTransform();
				var views = camera.xr.views;

				for (var v = 0; v < views.length; v++) {
					var view = views[v];

					if (_parent) {
						view.viewInvOffMat.mul2(transform, view.viewInvMat);
						view.viewOffMat.copy(view.viewInvOffMat).invert();
					} else {
						view.viewInvOffMat.copy(view.viewInvMat);
						view.viewOffMat.copy(view.viewMat);
					}

					view.viewMat3.setFromMat4(view.viewOffMat);
					view.projViewOffMat.mul2(view.projMat, view.viewOffMat);
					view.position[0] = view.viewInvOffMat.data[12];
					view.position[1] = view.viewInvOffMat.data[13];
					view.position[2] = view.viewInvOffMat.data[14];
					camera.frustum.setFromMat4(view.projViewOffMat);
				}
			} else {
				projMat = camera.projectionMatrix;

				if (camera.calculateProjection) {
					camera.calculateProjection(projMat, VIEW_CENTER);
				}

				this.projId.setValue(projMat.data);
				this.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);

				if (camera.calculateTransform) {
					camera.calculateTransform(viewInvMat, VIEW_CENTER);
				} else {
					var pos = camera._node.getPosition();

					var rot = camera._node.getRotation();

					viewInvMat.setTRS(pos, rot, Vec3.ONE);
				}

				this.viewInvId.setValue(viewInvMat.data);
				viewMat.copy(viewInvMat).invert();
				this.viewId.setValue(viewMat.data);
				viewMat3.setFromMat4(viewMat);
				this.viewId3.setValue(viewMat3.data);
				viewProjMat.mul2(projMat, viewMat);

				if (target && target.flipY) {
					flippedViewProjMat.mul2(flipYMat, viewProjMat);
					flippedSkyboxProjMat.mul2(flipYMat, camera.getProjectionMatrixSkybox());
					this.viewProjId.setValue(flippedViewProjMat.data);
					this.projSkyboxId.setValue(flippedSkyboxProjMat.data);
				} else {
					this.viewProjId.setValue(viewProjMat.data);
					this.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);
				}

				this.dispatchViewPos(camera._node.getPosition());
				camera.frustum.setFromMat4(viewProjMat);
			}

			this.tbnBasis.setValue(target && target.flipY ? -1 : 1);
			this.nearClipId.setValue(camera._nearClip);
			this.farClipId.setValue(camera._farClip);
			var n = camera._nearClip;
			var f = camera._farClip;
			this.cameraParams[0] = 1 / f;
			this.cameraParams[1] = f;
			this.cameraParams[2] = (1 - f / n) * 0.5;
			this.cameraParams[3] = (1 + f / n) * 0.5;
			this.cameraParamsId.setValue(this.cameraParams);
			this.clearView(camera, target, clear, false);
		};

		_proto.clearView = function clearView(camera, target, clear, forceWrite, options) {
			var device = this.device;
			device.setRenderTarget(target);
			device.updateBegin();

			if (forceWrite) {
				device.setColorWrite(true, true, true, true);
				device.setDepthWrite(true);
			}

			var pixelWidth = target ? target.width : device.width;
			var pixelHeight = target ? target.height : device.height;
			var rect = camera.rect;
			var x = Math.floor(rect.x * pixelWidth);
			var y = Math.floor(rect.y * pixelHeight);
			var w = Math.floor(rect.z * pixelWidth);
			var h = Math.floor(rect.w * pixelHeight);
			device.setViewport(x, y, w, h);

			if (camera._scissorRectClear) {
				var scissorRect = camera.scissorRect;
				x = Math.floor(scissorRect.x * pixelWidth);
				y = Math.floor(scissorRect.y * pixelHeight);
				w = Math.floor(scissorRect.z * pixelWidth);
				h = Math.floor(scissorRect.w * pixelHeight);
			}

			device.setScissor(x, y, w, h);

			if (clear) {
				if (!options) options = camera._clearOptions;
				device.clear(options ? options : {
					color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],
					depth: camera._clearDepth,
					flags: (camera._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (camera._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (camera._clearStencilBuffer ? CLEARFLAG_STENCIL : 0),
					stencil: camera._clearStencil
				});
			}
		};

		_proto.dispatchGlobalLights = function dispatchGlobalLights(scene) {
			this.ambientColor[0] = scene.ambientLight.r;
			this.ambientColor[1] = scene.ambientLight.g;
			this.ambientColor[2] = scene.ambientLight.b;

			if (scene.gammaCorrection) {
				for (var i = 0; i < 3; i++) {
					this.ambientColor[i] = Math.pow(this.ambientColor[i], 2.2);
				}
			}

			this.ambientId.setValue(this.ambientColor);
			this.exposureId.setValue(scene.exposure);
			if (scene.skyboxModel) this.skyboxIntensityId.setValue(scene.skyboxIntensity);
		};

		_proto._resolveLight = function _resolveLight(scope, i) {
			var light = "light" + i;
			this.lightColorId[i] = scope.resolve(light + "_color");
			this.lightDir[i] = new Float32Array(3);
			this.lightDirId[i] = scope.resolve(light + "_direction");
			this.lightShadowMapId[i] = scope.resolve(light + "_shadowMap");
			this.lightShadowMatrixId[i] = scope.resolve(light + "_shadowMatrix");
			this.lightShadowParamsId[i] = scope.resolve(light + "_shadowParams");
			this.lightRadiusId[i] = scope.resolve(light + "_radius");
			this.lightPos[i] = new Float32Array(3);
			this.lightPosId[i] = scope.resolve(light + "_position");
			this.lightWidth[i] = new Float32Array(3);
			this.lightWidthId[i] = scope.resolve(light + "_halfWidth");
			this.lightHeight[i] = new Float32Array(3);
			this.lightHeightId[i] = scope.resolve(light + "_halfHeight");
			this.lightInAngleId[i] = scope.resolve(light + "_innerConeAngle");
			this.lightOutAngleId[i] = scope.resolve(light + "_outerConeAngle");
			this.lightCookieId[i] = scope.resolve(light + "_cookie");
			this.lightCookieIntId[i] = scope.resolve(light + "_cookieIntensity");
			this.lightCookieMatrixId[i] = scope.resolve(light + "_cookieMatrix");
			this.lightCookieOffsetId[i] = scope.resolve(light + "_cookieOffset");
			this.shadowMatrixPaletteId[i] = scope.resolve(light + "_shadowMatrixPalette[0]");
			this.shadowCascadeDistancesId[i] = scope.resolve(light + "_shadowCascadeDistances[0]");
			this.shadowCascadeCountId[i] = scope.resolve(light + "_shadowCascadeCount");
		};

		_proto.setLTCDirectionalLight = function setLTCDirectionalLight(wtm, cnt, dir, campos, far) {
			this.lightPos[cnt][0] = campos.x - dir.x * far;
			this.lightPos[cnt][1] = campos.y - dir.y * far;
			this.lightPos[cnt][2] = campos.z - dir.z * far;
			this.lightPosId[cnt].setValue(this.lightPos[cnt]);
			var hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
			this.lightWidth[cnt][0] = hWidth.x * far;
			this.lightWidth[cnt][1] = hWidth.y * far;
			this.lightWidth[cnt][2] = hWidth.z * far;
			this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
			var hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
			this.lightHeight[cnt][0] = hHeight.x * far;
			this.lightHeight[cnt][1] = hHeight.y * far;
			this.lightHeight[cnt][2] = hHeight.z * far;
			this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
		};

		_proto.dispatchDirectLights = function dispatchDirectLights(dirs, scene, mask, camera) {
			var cnt = 0;
			var scope = this.device.scope;

			for (var i = 0; i < dirs.length; i++) {
				if (!(dirs[i].mask & mask)) continue;
				var directional = dirs[i];

				var wtm = directional._node.getWorldTransform();

				if (!this.lightColorId[cnt]) {
					this._resolveLight(scope, cnt);
				}

				this.lightColorId[cnt].setValue(scene.gammaCorrection ? directional._linearFinalColor : directional._finalColor);
				wtm.getY(directional._direction).mulScalar(-1);

				directional._direction.normalize();

				this.lightDir[cnt][0] = directional._direction.x;
				this.lightDir[cnt][1] = directional._direction.y;
				this.lightDir[cnt][2] = directional._direction.z;
				this.lightDirId[cnt].setValue(this.lightDir[cnt]);

				if (directional.shape !== LIGHTSHAPE_PUNCTUAL) {
					this.setLTCDirectionalLight(wtm, cnt, directional._direction, camera._node.getPosition(), camera.farClip);
				}

				if (directional.castShadows) {
					var lightRenderData = directional.getRenderData(camera, 0);

					var biases = directional._getUniformBiasValues(lightRenderData);

					this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
					this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
					this.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);
					this.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);
					this.shadowCascadeCountId[cnt].setValue(directional.numCascades);
					var params = directional._shadowRenderParams;
					params.length = 3;
					params[0] = directional._shadowResolution;
					params[1] = biases.normalBias;
					params[2] = biases.bias;
					this.lightShadowParamsId[cnt].setValue(params);
				}

				cnt++;
			}

			return cnt;
		};

		_proto.setLTCPositionalLight = function setLTCPositionalLight(wtm, cnt) {
			var hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
			this.lightWidth[cnt][0] = hWidth.x;
			this.lightWidth[cnt][1] = hWidth.y;
			this.lightWidth[cnt][2] = hWidth.z;
			this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
			var hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
			this.lightHeight[cnt][0] = hHeight.x;
			this.lightHeight[cnt][1] = hHeight.y;
			this.lightHeight[cnt][2] = hHeight.z;
			this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
		};

		_proto.dispatchOmniLight = function dispatchOmniLight(scene, scope, omni, cnt) {
			var wtm = omni._node.getWorldTransform();

			if (!this.lightColorId[cnt]) {
				this._resolveLight(scope, cnt);
			}

			this.lightRadiusId[cnt].setValue(omni.attenuationEnd);
			this.lightColorId[cnt].setValue(scene.gammaCorrection ? omni._linearFinalColor : omni._finalColor);
			wtm.getTranslation(omni._position);
			this.lightPos[cnt][0] = omni._position.x;
			this.lightPos[cnt][1] = omni._position.y;
			this.lightPos[cnt][2] = omni._position.z;
			this.lightPosId[cnt].setValue(this.lightPos[cnt]);

			if (omni.shape !== LIGHTSHAPE_PUNCTUAL) {
				this.setLTCPositionalLight(wtm, cnt);
			}

			if (omni.castShadows) {
				var lightRenderData = omni.getRenderData(null, 0);
				this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);

				var biases = omni._getUniformBiasValues(lightRenderData);

				var params = omni._shadowRenderParams;
				params.length = 4;
				params[0] = omni._shadowResolution;
				params[1] = biases.normalBias;
				params[2] = biases.bias;
				params[3] = 1.0 / omni.attenuationEnd;
				this.lightShadowParamsId[cnt].setValue(params);
			}

			if (omni._cookie) {
				this.lightCookieId[cnt].setValue(omni._cookie);
				this.lightShadowMatrixId[cnt].setValue(wtm.data);
				this.lightCookieIntId[cnt].setValue(omni.cookieIntensity);
			}
		};

		_proto.dispatchSpotLight = function dispatchSpotLight(scene, scope, spot, cnt) {
			var wtm = spot._node.getWorldTransform();

			if (!this.lightColorId[cnt]) {
				this._resolveLight(scope, cnt);
			}

			this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);
			this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);
			this.lightRadiusId[cnt].setValue(spot.attenuationEnd);
			this.lightColorId[cnt].setValue(scene.gammaCorrection ? spot._linearFinalColor : spot._finalColor);
			wtm.getTranslation(spot._position);
			this.lightPos[cnt][0] = spot._position.x;
			this.lightPos[cnt][1] = spot._position.y;
			this.lightPos[cnt][2] = spot._position.z;
			this.lightPosId[cnt].setValue(this.lightPos[cnt]);

			if (spot.shape !== LIGHTSHAPE_PUNCTUAL) {
				this.setLTCPositionalLight(wtm, cnt);
			}

			wtm.getY(spot._direction).mulScalar(-1);

			spot._direction.normalize();

			this.lightDir[cnt][0] = spot._direction.x;
			this.lightDir[cnt][1] = spot._direction.y;
			this.lightDir[cnt][2] = spot._direction.z;
			this.lightDirId[cnt].setValue(this.lightDir[cnt]);

			if (spot.castShadows) {
				var lightRenderData = spot.getRenderData(null, 0);
				this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
				this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);

				var biases = spot._getUniformBiasValues(lightRenderData);

				var params = spot._shadowRenderParams;
				params.length = 4;
				params[0] = spot._shadowResolution;
				params[1] = biases.normalBias;
				params[2] = biases.bias;
				params[3] = 1.0 / spot.attenuationEnd;
				this.lightShadowParamsId[cnt].setValue(params);
			}

			if (spot._cookie) {
				if (!spot.castShadows) {
					var cookieMatrix = LightCamera.evalSpotCookieMatrix(spot);
					this.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);
				}

				this.lightCookieId[cnt].setValue(spot._cookie);
				this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);

				if (spot._cookieTransform) {
					spot._cookieTransformUniform[0] = spot._cookieTransform.x;
					spot._cookieTransformUniform[1] = spot._cookieTransform.y;
					spot._cookieTransformUniform[2] = spot._cookieTransform.z;
					spot._cookieTransformUniform[3] = spot._cookieTransform.w;
					this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);
					spot._cookieOffsetUniform[0] = spot._cookieOffset.x;
					spot._cookieOffsetUniform[1] = spot._cookieOffset.y;
					this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);
				}
			}
		};

		_proto.dispatchLocalLights = function dispatchLocalLights(sortedLights, scene, mask, usedDirLights, staticLightList) {
			var cnt = usedDirLights;
			var scope = this.device.scope;
			var omnis = sortedLights[LIGHTTYPE_OMNI];
			var numOmnis = omnis.length;

			for (var i = 0; i < numOmnis; i++) {
				var omni = omnis[i];
				if (!(omni.mask & mask)) continue;
				if (omni.isStatic) continue;
				this.dispatchOmniLight(scene, scope, omni, cnt);
				cnt++;
			}

			var staticId = 0;

			if (staticLightList) {
				var _omni = staticLightList[staticId];

				while (_omni && _omni._type === LIGHTTYPE_OMNI) {
					this.dispatchOmniLight(scene, scope, _omni, cnt);
					cnt++;
					staticId++;
					_omni = staticLightList[staticId];
				}
			}

			var spts = sortedLights[LIGHTTYPE_SPOT];
			var numSpts = spts.length;

			for (var _i = 0; _i < numSpts; _i++) {
				var spot = spts[_i];
				if (!(spot.mask & mask)) continue;
				if (spot.isStatic) continue;
				this.dispatchSpotLight(scene, scope, spot, cnt);
				cnt++;
			}

			if (staticLightList) {
				var _spot = staticLightList[staticId];

				while (_spot && _spot._type === LIGHTTYPE_SPOT) {
					this.dispatchSpotLight(scene, scope, _spot, cnt);
					cnt++;
					staticId++;
					_spot = staticLightList[staticId];
				}
			}
		};

		_proto.cull = function cull(camera, drawCalls, visibleList) {
			var cullTime = now();
			var numDrawCallsCulled = 0;
			var visibleLength = 0;
			var drawCallsCount = drawCalls.length;
			var cullingMask = camera.cullingMask || 0xFFFFFFFF;

			if (!camera.frustumCulling) {
				for (var i = 0; i < drawCallsCount; i++) {
					var drawCall = drawCalls[i];
					if (!drawCall.visible && !drawCall.command) continue;
					if (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;
					visibleList[visibleLength] = drawCall;
					visibleLength++;
					drawCall.visibleThisFrame = true;
				}

				return visibleLength;
			}

			for (var _i2 = 0; _i2 < drawCallsCount; _i2++) {
				var _drawCall = drawCalls[_i2];

				if (!_drawCall.command) {
					if (!_drawCall.visible) continue;
					var visible = true;
					if (_drawCall.mask && (_drawCall.mask & cullingMask) === 0) continue;

					if (_drawCall.cull) {
						visible = _drawCall._isVisible(camera);
						numDrawCallsCulled++;
					}

					if (visible) {
						visibleList[visibleLength] = _drawCall;
						visibleLength++;
						_drawCall.visibleThisFrame = true;
					}
				} else {
					visibleList[visibleLength] = _drawCall;
					visibleLength++;
					_drawCall.visibleThisFrame = true;
				}
			}

			this._cullTime += now() - cullTime;
			this._numDrawCallsCulled += numDrawCallsCulled;
			return visibleLength;
		};

		_proto.cullLights = function cullLights(camera, lights) {
			var clusteredLightingEnabled = this.scene.clusteredLightingEnabled;

			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];

				if (light.enabled) {
					if (light._type !== LIGHTTYPE_DIRECTIONAL) {
						light.getBoundingSphere(tempSphere$1);

						if (camera.frustum.containsSphere(tempSphere$1)) {
							light.visibleThisFrame = true;
							var screenSize = camera.getScreenSize(tempSphere$1);
							light.maxScreenSize = Math.max(light.maxScreenSize, screenSize);
						} else {
							if (!clusteredLightingEnabled) {
								if (light.castShadows && !light.shadowMap) {
									light.visibleThisFrame = true;
								}
							}
						}
					}
				}
			}
		};

		_proto.updateCpuSkinMatrices = function updateCpuSkinMatrices(drawCalls) {
			_skinUpdateIndex++;
			var drawCallsCount = drawCalls.length;
			if (drawCallsCount === 0) return;
			var skinTime = now();

			for (var i = 0; i < drawCallsCount; i++) {
				var si = drawCalls[i].skinInstance;

				if (si) {
					si.updateMatrices(drawCalls[i].node, _skinUpdateIndex);
					si._dirty = true;
				}
			}

			this._skinTime += now() - skinTime;
		};

		_proto.updateGpuSkinMatrices = function updateGpuSkinMatrices(drawCalls) {
			var skinTime = now();
			var drawCallsCount = drawCalls.length;

			for (var i = 0; i < drawCallsCount; i++) {
				if (!drawCalls[i].visibleThisFrame) continue;
				var skin = drawCalls[i].skinInstance;

				if (skin) {
					if (skin._dirty) {
						skin.updateMatrixPalette(drawCalls[i].node, _skinUpdateIndex);
						skin._dirty = false;
					}
				}
			}

			this._skinTime += now() - skinTime;
		};

		_proto.updateMorphing = function updateMorphing(drawCalls) {
			var morphTime = now();
			var drawCallsCount = drawCalls.length;

			for (var i = 0; i < drawCallsCount; i++) {
				var morphInst = drawCalls[i].morphInstance;

				if (morphInst && morphInst._dirty && drawCalls[i].visibleThisFrame) {
					morphInst.update();
				}
			}

			this._morphTime += now() - morphTime;
		};

		_proto.setBaseConstants = function setBaseConstants(device, material) {
			device.setCullMode(material.cull);

			if (material.opacityMap) {
				this.opacityMapId.setValue(material.opacityMap);
				this.alphaTestId.setValue(material.alphaTest);
			}
		};

		_proto.setSkinning = function setSkinning(device, meshInstance, material) {
			if (meshInstance.skinInstance) {
				this._skinDrawCalls++;

				if (device.supportsBoneTextures) {
					boneTexture = meshInstance.skinInstance.boneTexture;
					this.boneTextureId.setValue(boneTexture);
					boneTextureSize[0] = boneTexture.width;
					boneTextureSize[1] = boneTexture.height;
					boneTextureSize[2] = 1.0 / boneTexture.width;
					boneTextureSize[3] = 1.0 / boneTexture.height;
					this.boneTextureSizeId.setValue(boneTextureSize);
				} else {
					this.poseMatrixId.setValue(meshInstance.skinInstance.matrixPalette);
				}
			}
		};

		_proto.drawInstance = function drawInstance(device, meshInstance, mesh, style, normal) {
			DebugGraphics.pushGpuMarker(device, meshInstance.node.name);
			instancingData = meshInstance.instancingData;

			if (instancingData) {
				if (instancingData.count > 0) {
					this._instancedDrawCalls++;
					device.setVertexBuffer(instancingData.vertexBuffer);
					device.draw(mesh.primitive[style], instancingData.count);
				}
			} else {
				modelMatrix = meshInstance.node.worldTransform;
				this.modelMatrixId.setValue(modelMatrix.data);

				if (normal) {
					normalMatrix = meshInstance.node.normalMatrix;

					if (meshInstance.node._dirtyNormal) {
						modelMatrix.invertTo3x3(normalMatrix);
						normalMatrix.transpose();
						meshInstance.node._dirtyNormal = false;
					}

					this.normalMatrixId.setValue(normalMatrix.data);
				}

				device.draw(mesh.primitive[style]);
			}

			DebugGraphics.popGpuMarker(device);
		};

		_proto.drawInstance2 = function drawInstance2(device, meshInstance, mesh, style) {
			DebugGraphics.pushGpuMarker(device, meshInstance.node.name);
			instancingData = meshInstance.instancingData;

			if (instancingData) {
				if (instancingData.count > 0) {
					this._instancedDrawCalls++;
					device.draw(mesh.primitive[style], instancingData.count, true);
				}
			} else {
				device.draw(mesh.primitive[style], undefined, true);
			}

			DebugGraphics.popGpuMarker(device);
		};

		_proto.renderShadows = function renderShadows(lights, camera) {
			var isClustered = this.scene.clusteredLightingEnabled;
			var device = this.device;
			device.grabPassAvailable = false;
			var shadowMapStartTime = now();

			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];

				if (isClustered && light._type !== LIGHTTYPE_DIRECTIONAL) {
					if (!light.atlasViewportAllocated) {
						continue;
					}

					if (light.atlasSlotUpdated && light.shadowUpdateMode === SHADOWUPDATE_NONE) {
						light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
					}
				}

				this._shadowRenderer.render(light, camera);
			}

			device.grabPassAvailable = true;
			this._shadowMapTime += now() - shadowMapStartTime;
		};

		_proto.renderCookies = function renderCookies(lights) {
			var cookieRenderTarget = this.lightTextureAtlas.cookieRenderTarget;

			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];
				if (!light.atlasViewportAllocated) continue;
				if (!light.atlasSlotUpdated) continue;

				this._cookieRenderer.render(light, cookieRenderTarget);
			}
		};

		_proto.updateShader = function updateShader(meshInstance, objDefs, staticLightList, pass, sortedLights) {
			meshInstance.material._scene = this.scene;

			if (meshInstance.material._dirtyBlend) {
				this.scene.layers._dirtyBlend = true;
			}

			meshInstance.material.updateShader(this.device, this.scene, objDefs, staticLightList, pass, sortedLights);
			meshInstance._shader[pass] = meshInstance.material.shader;
		};

		_proto.setCullMode = function setCullMode(cullFaces, flip, drawCall) {
			var material = drawCall.material;
			var mode = CULLFACE_NONE;

			if (cullFaces) {
				var flipFaces = 1;

				if (material.cull > CULLFACE_NONE && material.cull < CULLFACE_FRONTANDBACK) {
					if (drawCall.flipFaces) flipFaces *= -1;
					if (flip) flipFaces *= -1;
					var wt = drawCall.node.worldTransform;
					wt.getX(worldMatX);
					wt.getY(worldMatY);
					wt.getZ(worldMatZ);
					worldMatX.cross(worldMatX, worldMatY);

					if (worldMatX.dot(worldMatZ) < 0) {
						flipFaces *= -1;
					}
				}

				if (flipFaces < 0) {
					mode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;
				} else {
					mode = material.cull;
				}
			}

			this.device.setCullMode(mode);

			if (mode === CULLFACE_NONE && material.cull === CULLFACE_NONE) {
				var wt2 = drawCall.node.worldTransform;
				wt2.getX(worldMatX);
				wt2.getY(worldMatY);
				wt2.getZ(worldMatZ);
				worldMatX.cross(worldMatX, worldMatY);

				if (worldMatX.dot(worldMatZ) < 0) {
					this.twoSidedLightingNegScaleFactorId.setValue(-1.0);
				} else {
					this.twoSidedLightingNegScaleFactorId.setValue(1.0);
				}
			}
		};

		_proto.setVertexBuffers = function setVertexBuffers(device, mesh) {
			device.setVertexBuffer(mesh.vertexBuffer);
		};

		_proto.setMorphing = function setMorphing(device, morphInstance) {
			if (morphInstance) {
				if (morphInstance.morph.useTextureMorph) {
					device.setVertexBuffer(morphInstance.morph.vertexBufferIds);
					this.morphPositionTex.setValue(morphInstance.texturePositions);
					this.morphNormalTex.setValue(morphInstance.textureNormals);
					this.morphTexParams.setValue(morphInstance._textureParams);
				} else {
					for (var t = 0; t < morphInstance._activeVertexBuffers.length; t++) {
						var vb = morphInstance._activeVertexBuffers[t];

						if (vb) {
							var semantic = SEMANTIC_ATTR + (t + 8);
							vb.format.elements[0].name = semantic;
							vb.format.elements[0].scopeId = device.scope.resolve(semantic);
							vb.format.update();
							device.setVertexBuffer(vb);
						}
					}

					this.morphWeightsA.setValue(morphInstance._shaderMorphWeightsA);
					this.morphWeightsB.setValue(morphInstance._shaderMorphWeightsB);
				}
			}
		};

		_proto.dispatchViewPos = function dispatchViewPos(position) {
			var vp = this.viewPos;
			vp[0] = position.x;
			vp[1] = position.y;
			vp[2] = position.z;
			this.viewPosId.setValue(vp);
		};

		_proto.renderForwardPrepareMaterials = function renderForwardPrepareMaterials(camera, drawCalls, drawCallsCount, sortedLights, cullingMask, layer, pass) {
			var addCall = function addCall(drawCall, isNewMaterial, lightMaskChanged) {
				_drawCallList.drawCalls.push(drawCall);

				_drawCallList.isNewMaterial.push(isNewMaterial);

				_drawCallList.lightMaskChanged.push(lightMaskChanged);
			};

			_drawCallList.drawCalls.length = 0;
			_drawCallList.isNewMaterial.length = 0;
			_drawCallList.lightMaskChanged.length = 0;
			var device = this.device;
			var scene = this.scene;
			var lightHash = layer ? layer._lightHash : 0;
			var prevMaterial = null,
					prevObjDefs,
					prevStatic,
					prevLightMask;

			for (var i = 0; i < drawCallsCount; i++) {
				var drawCall = drawCalls[i];
				if (cullingMask && drawCall.mask && !(cullingMask & drawCall.mask)) continue;

				if (drawCall.command) {
					addCall(drawCall, false, false);
				} else {
					if (camera === ForwardRenderer.skipRenderCamera) {
						if (ForwardRenderer._skipRenderCounter >= ForwardRenderer.skipRenderAfter) continue;
						ForwardRenderer._skipRenderCounter++;
					}

					if (layer) {
						if (layer._skipRenderCounter >= layer.skipRenderAfter) continue;
						layer._skipRenderCounter++;
					}

					if (!drawCall.material) drawCall.material = getDefaultMaterial(device);
					var material = drawCall.material;
					var objDefs = drawCall._shaderDefs;
					var lightMask = drawCall.mask;

					if (material && material === prevMaterial && objDefs !== prevObjDefs) {
						prevMaterial = null;
					}

					if (drawCall.isStatic || prevStatic) {
						prevMaterial = null;
					}

					if (material !== prevMaterial) {
						this._materialSwitches++;

						if (material.dirty) {
							material.updateUniforms(device, scene);
							material.dirty = false;
						}

						if (!drawCall._shader[pass] || drawCall._shaderDefs !== objDefs || drawCall._lightHash !== lightHash) {
							if (!drawCall.isStatic) {
								var variantKey = pass + "_" + objDefs + "_" + lightHash;
								drawCall._shader[pass] = material.variants[variantKey];

								if (!drawCall._shader[pass]) {
									this.updateShader(drawCall, objDefs, null, pass, sortedLights);
									material.variants[variantKey] = drawCall._shader[pass];
								}
							} else {
								this.updateShader(drawCall, objDefs, drawCall._staticLightList, pass, sortedLights);
							}

							drawCall._shaderDefs = objDefs;
							drawCall._lightHash = lightHash;
						}
					}

					addCall(drawCall, material !== prevMaterial, !prevMaterial || lightMask !== prevLightMask);
					prevMaterial = material;
					prevObjDefs = objDefs;
					prevLightMask = lightMask;
					prevStatic = drawCall.isStatic;
				}
			}

			return _drawCallList;
		};

		_proto.renderForward = function renderForward(camera, allDrawCalls, allDrawCallsCount, sortedLights, pass, cullingMask, drawCallback, layer, flipFaces) {
			var device = this.device;
			var scene = this.scene;
			var vrDisplay = camera.vrDisplay;
			var passFlag = 1 << pass;
			var halfWidth = device.width * 0.5;
			var forwardStartTime = now();
			var preparedCalls = this.renderForwardPrepareMaterials(camera, allDrawCalls, allDrawCallsCount, sortedLights, cullingMask, layer, pass);
			var preparedCallsCount = preparedCalls.drawCalls.length;

			for (var i = 0; i < preparedCallsCount; i++) {
				var drawCall = preparedCalls.drawCalls[i];

				if (drawCall.command) {
					drawCall.command();
				} else {
					var newMaterial = preparedCalls.isNewMaterial[i];
					var lightMaskChanged = preparedCalls.lightMaskChanged[i];
					var material = drawCall.material;
					var objDefs = drawCall._shaderDefs;
					var lightMask = drawCall.mask;

					if (newMaterial) {
						var shader = drawCall._shader[pass];

						if (!shader.failed && !device.setShader(shader)) {
							Debug.error("Error in material \"" + material.name + "\" with flags " + objDefs);
						}

						material.setParameters(device);

						if (lightMaskChanged) {
							var usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], scene, lightMask, camera);
							this.dispatchLocalLights(sortedLights, scene, lightMask, usedDirLights, drawCall._staticLightList);
						}

						this.alphaTestId.setValue(material.alphaTest);
						device.setBlending(material.blend);

						if (material.blend) {
							if (material.separateAlphaBlend) {
								device.setBlendFunctionSeparate(material.blendSrc, material.blendDst, material.blendSrcAlpha, material.blendDstAlpha);
								device.setBlendEquationSeparate(material.blendEquation, material.blendAlphaEquation);
							} else {
								device.setBlendFunction(material.blendSrc, material.blendDst);
								device.setBlendEquation(material.blendEquation);
							}
						}

						device.setColorWrite(material.redWrite, material.greenWrite, material.blueWrite, material.alphaWrite);
						device.setDepthWrite(material.depthWrite);

						if (material.depthWrite && !material.depthTest) {
							device.setDepthFunc(FUNC_ALWAYS);
							device.setDepthTest(true);
						} else {
							device.setDepthFunc(material.depthFunc);
							device.setDepthTest(material.depthTest);
						}

						device.setAlphaToCoverage(material.alphaToCoverage);

						if (material.depthBias || material.slopeDepthBias) {
							device.setDepthBias(true);
							device.setDepthBiasValues(material.depthBias, material.slopeDepthBias);
						} else {
							device.setDepthBias(false);
						}
					}

					this.setCullMode(camera._cullFaces, flipFaces, drawCall);
					var stencilFront = drawCall.stencilFront || material.stencilFront;
					var stencilBack = drawCall.stencilBack || material.stencilBack;

					if (stencilFront || stencilBack) {
						device.setStencilTest(true);

						if (stencilFront === stencilBack) {
							device.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);
							device.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
						} else {
							if (stencilFront) {
								device.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);
								device.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
							} else {
								device.setStencilFuncFront(FUNC_ALWAYS, 0, 0xFF);
								device.setStencilOperationFront(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);
							}

							if (stencilBack) {
								device.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);
								device.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);
							} else {
								device.setStencilFuncBack(FUNC_ALWAYS, 0, 0xFF);
								device.setStencilOperationBack(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);
							}
						}
					} else {
						device.setStencilTest(false);
					}

					var mesh = drawCall.mesh;
					drawCall.setParameters(device, passFlag);
					this.setVertexBuffers(device, mesh);
					this.setMorphing(device, drawCall.morphInstance);
					this.setSkinning(device, drawCall, material);
					var style = drawCall.renderStyle;
					device.setIndexBuffer(mesh.indexBuffer[style]);

					if (drawCallback) {
						drawCallback(drawCall, i);
					}

					if (vrDisplay && vrDisplay.presenting) {
						device.setViewport(0, 0, halfWidth, device.height);
						this.projId.setValue(projL.data);
						this.projSkyboxId.setValue(projL.data);
						this.viewInvId.setValue(viewInvL.data);
						this.viewId.setValue(viewL.data);
						this.viewId3.setValue(viewMat3L.data);
						this.viewProjId.setValue(viewProjMatL.data);
						this.dispatchViewPos(viewPosL);
						this.drawInstance(device, drawCall, mesh, style, true);
						this._forwardDrawCalls++;
						device.setViewport(halfWidth, 0, halfWidth, device.height);
						this.projId.setValue(projR.data);
						this.projSkyboxId.setValue(projR.data);
						this.viewInvId.setValue(viewInvR.data);
						this.viewId.setValue(viewR.data);
						this.viewId3.setValue(viewMat3R.data);
						this.viewProjId.setValue(viewProjMatR.data);
						this.dispatchViewPos(viewPosR);
						this.drawInstance2(device, drawCall, mesh, style);
						this._forwardDrawCalls++;
					} else if (camera.xr && camera.xr.session && camera.xr.views.length) {
						var views = camera.xr.views;

						for (var v = 0; v < views.length; v++) {
							var view = views[v];
							device.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);
							this.projId.setValue(view.projMat.data);
							this.projSkyboxId.setValue(view.projMat.data);
							this.viewId.setValue(view.viewOffMat.data);
							this.viewInvId.setValue(view.viewInvOffMat.data);
							this.viewId3.setValue(view.viewMat3.data);
							this.viewProjId.setValue(view.projViewOffMat.data);
							this.viewPosId.setValue(view.position);

							if (v === 0) {
								this.drawInstance(device, drawCall, mesh, style, true);
							} else {
								this.drawInstance2(device, drawCall, mesh, style);
							}

							this._forwardDrawCalls++;
						}
					} else {
						this.drawInstance(device, drawCall, mesh, style, true);
						this._forwardDrawCalls++;
					}

					if (i < preparedCallsCount - 1 && !preparedCalls.isNewMaterial[i + 1]) {
						material.setParameters(device, drawCall.parameters);
					}
				}
			}

			device.updateEnd();
			_drawCallList.length = 0;
			this._forwardTime += now() - forwardStartTime;
		};

		_proto.updateShaders = function updateShaders(drawCalls, onlyLitShaders) {
			var count = drawCalls.length;

			for (var i = 0; i < count; i++) {
				var mat = drawCalls[i].material;

				if (mat) {
					if (!_tempMaterialSet.has(mat)) {
						_tempMaterialSet.add(mat);

						if (mat.updateShader !== Material.prototype.updateShader) {
							if (onlyLitShaders) {
								if (!mat.useLighting || mat.emitter && !mat.emitter.lighting) continue;
							}

							mat.clearVariants();
							mat.shader = null;
						}
					}
				}
			}

			_tempMaterialSet.clear();
		};

		_proto.beginFrame = function beginFrame(comp, lightsChanged) {
			var meshInstances = comp._meshInstances;
			var scene = this.scene;

			if (scene.updateShaders || lightsChanged) {
				var onlyLitShaders = !scene.updateShaders && lightsChanged;
				this.updateShaders(meshInstances, onlyLitShaders);
				scene.updateShaders = false;
				scene._shaderVersion++;
			}

			this.updateCpuSkinMatrices(meshInstances);
			var miCount = meshInstances.length;

			for (var i = 0; i < miCount; i++) {
				meshInstances[i].visibleThisFrame = false;
			}

			var lights = comp._lights;
			var lightCount = lights.length;

			for (var _i3 = 0; _i3 < lightCount; _i3++) {
				lights[_i3].beginFrame();
			}
		};

		_proto.beginLayers = function beginLayers(comp) {
			var len = comp.layerList.length;

			for (var i = 0; i < len; i++) {
				comp.layerList[i]._postRenderCounter = 0;
			}

			var scene = this.scene;
			var shaderVersion = scene._shaderVersion;

			for (var _i4 = 0; _i4 < len; _i4++) {
				var layer = comp.layerList[_i4];
				layer._shaderVersion = shaderVersion;
				layer._skipRenderCounter = 0;
				layer._forwardDrawCalls = 0;
				layer._shadowDrawCalls = 0;
				layer._renderTime = 0;
				layer._preRenderCalledForCameras = 0;
				layer._postRenderCalledForCameras = 0;
				var transparent = comp.subLayerList[_i4];

				if (transparent) {
					layer._postRenderCounter |= 2;
				} else {
					layer._postRenderCounter |= 1;
				}

				layer._postRenderCounterMax = layer._postRenderCounter;

				for (var j = 0; j < layer.cameras.length; j++) {
					layer.instances.prepare(j);
				}

				if (layer._needsStaticPrepare && layer._staticLightHash && !this.scene.clusteredLightingEnabled) {
					if (layer._staticPrepareDone) {
						StaticMeshes.revert(layer.opaqueMeshInstances);
						StaticMeshes.revert(layer.transparentMeshInstances);
					}

					StaticMeshes.prepare(this.device, scene, layer.opaqueMeshInstances, layer._lights);
					StaticMeshes.prepare(this.device, scene, layer.transparentMeshInstances, layer._lights);
					comp._dirty = true;
					scene.updateShaders = true;
					layer._needsStaticPrepare = false;
					layer._staticPrepareDone = true;
				}
			}
		};

		_proto.gpuUpdate = function gpuUpdate(drawCalls) {
			this.updateGpuSkinMatrices(drawCalls);
			this.updateMorphing(drawCalls);
		};

		_proto.setSceneConstants = function setSceneConstants() {
			var scene = this.scene;
			this.dispatchGlobalLights(scene);

			if (scene.fog !== FOG_NONE) {
				this.fogColor[0] = scene.fogColor.r;
				this.fogColor[1] = scene.fogColor.g;
				this.fogColor[2] = scene.fogColor.b;

				if (scene.gammaCorrection) {
					for (var i = 0; i < 3; i++) {
						this.fogColor[i] = Math.pow(this.fogColor[i], 2.2);
					}
				}

				this.fogColorId.setValue(this.fogColor);

				if (scene.fog === FOG_LINEAR) {
					this.fogStartId.setValue(scene.fogStart);
					this.fogEndId.setValue(scene.fogEnd);
				} else {
					this.fogDensityId.setValue(scene.fogDensity);
				}
			}

			var device = this.device;
			this._screenSize[0] = device.width;
			this._screenSize[1] = device.height;
			this._screenSize[2] = 1 / device.width;
			this._screenSize[3] = 1 / device.height;
			this.screenSizeId.setValue(this._screenSize);
		};

		_proto.updateLightStats = function updateLightStats(comp, compUpdatedFlags) {
			var scene = this.scene;

			if (compUpdatedFlags & COMPUPDATED_LIGHTS || !scene._statsUpdated) {
				var stats = scene._stats;
				stats.lights = comp._lights.length;
				stats.dynamicLights = 0;
				stats.bakedLights = 0;

				for (var i = 0; i < stats.lights; i++) {
					var l = comp._lights[i];

					if (l.enabled) {
						if (l.mask & MASK_AFFECT_DYNAMIC || l.mask & MASK_AFFECT_LIGHTMAPPED) {
							stats.dynamicLights++;
						}

						if (l.mask & MASK_BAKE) {
							stats.bakedLights++;
						}
					}
				}
			}

			if (compUpdatedFlags & COMPUPDATED_INSTANCES || !scene._statsUpdated) {
				scene._stats.meshInstances = comp._meshInstances.length;
			}

			scene._statsUpdated = true;
		};

		_proto.cullShadowmaps = function cullShadowmaps(comp) {
			for (var i = 0; i < comp._lights.length; i++) {
				var light = comp._lights[i];

				if (light._type !== LIGHTTYPE_DIRECTIONAL) {
					if (light.visibleThisFrame && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {
						var casters = comp._lightCompositionData[i].shadowCastersList;

						this._shadowRenderer.cullLocal(light, casters);
					}
				}
			}

			var renderActions = comp._renderActions;

			for (var _i5 = 0; _i5 < renderActions.length; _i5++) {
				var renderAction = renderActions[_i5];
				var count = renderAction.directionalLightsIndices.length;

				for (var j = 0; j < count; j++) {
					var lightIndex = renderAction.directionalLightsIndices[j];
					var _light = comp._lights[lightIndex];
					var _casters = comp._lightCompositionData[lightIndex].shadowCastersList;

					this._shadowRenderer.cullDirectional(_light, _casters, renderAction.camera.camera);
				}
			}
		};

		_proto.cullComposition = function cullComposition(comp) {
			var cullTime = now();
			var renderActions = comp._renderActions;

			for (var i = 0; i < renderActions.length; i++) {
				var renderAction = renderActions[i];
				var layerIndex = renderAction.layerIndex;
				var layer = comp.layerList[layerIndex];
				if (!layer.enabled || !comp.subLayerEnabled[layerIndex]) continue;
				var transparent = comp.subLayerList[layerIndex];
				var cameraPass = renderAction.cameraIndex;
				var camera = layer.cameras[cameraPass];

				if (camera) {
					camera.frameBegin(renderAction.renderTarget);

					if (renderAction.firstCameraUse) {
						this.updateCameraFrustum(camera.camera);
						this._camerasRendered++;
					}

					this.cullLights(camera.camera, layer._lights);
					var objects = layer.instances;
					var visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];

					if (!visible.done) {
						if (layer.onPreCull) {
							layer.onPreCull(cameraPass);
						}

						var drawCalls = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;
						visible.length = this.cull(camera.camera, drawCalls, visible.list);
						visible.done = true;

						if (layer.onPostCull) {
							layer.onPostCull(cameraPass);
						}
					}

					camera.frameEnd();
				}
			}

			this.cullShadowmaps(comp);
			this._cullTime += now() - cullTime;
		};

		_proto.updateLightTextureAtlas = function updateLightTextureAtlas(comp) {
			this.lightTextureAtlas.update(comp._splitLights[LIGHTTYPE_SPOT], comp._splitLights[LIGHTTYPE_OMNI], this.scene.lighting);
		};

		_proto.updateClusters = function updateClusters(comp) {
			var startTime = now();

			for (var i = 0; i < comp._worldClusters.length; i++) {
				var cluster = comp._worldClusters[i];
				cluster.update(comp._lights, this.scene.gammaCorrection, this.scene.lighting);
			}

			this._lightClustersTime += now() - startTime;
			this._lightClusters = comp._worldClusters.length;
		};

		_proto.renderComposition = function renderComposition(comp) {
			var device = this.device;
			var clusteredLightingEnabled = this.scene.clusteredLightingEnabled;

			this.scene._updateSkybox(this.device);

			this.beginLayers(comp);
			var layerCompositionUpdateTime = now();

			var updated = comp._update(device, clusteredLightingEnabled);

			var lightsChanged = (updated & COMPUPDATED_LIGHTS) !== 0;
			this._layerCompositionUpdateTime += now() - layerCompositionUpdateTime;
			this.updateLightStats(comp, updated);
			this.beginFrame(comp, lightsChanged);
			this.setSceneConstants();
			this.cullComposition(comp);
			this.gpuUpdate(comp._meshInstances);

			if (clusteredLightingEnabled) {
				this.updateLightTextureAtlas(comp);

				if (this.scene.lighting.cookiesEnabled) {
					this.renderCookies(comp._splitLights[LIGHTTYPE_SPOT]);
					this.renderCookies(comp._splitLights[LIGHTTYPE_OMNI]);
				}
			}

			if (!clusteredLightingEnabled || clusteredLightingEnabled && this.scene.lighting.shadowsEnabled) {
				this.renderShadows(comp._splitLights[LIGHTTYPE_SPOT]);
				this.renderShadows(comp._splitLights[LIGHTTYPE_OMNI]);
			}

			if (clusteredLightingEnabled) {
				this.updateClusters(comp);
			}

			var sortTime, drawTime;
			var clustersDebugRendered = false;
			var renderActions = comp._renderActions;

			for (var i = 0; i < renderActions.length; i++) {
				var renderAction = renderActions[i];
				var layerIndex = renderAction.layerIndex;
				var layer = comp.layerList[layerIndex];
				var transparent = comp.subLayerList[layerIndex];
				var cameraPass = renderAction.cameraIndex;
				var camera = layer.cameras[cameraPass];

				if (renderAction.directionalLights.length > 0) {
					this.renderShadows(renderAction.directionalLights, camera.camera);
				}

				if (!layer.enabled || !comp.subLayerEnabled[layerIndex]) {
					continue;
				}

				DebugGraphics.pushGpuMarker(this.device, camera ? camera.entity.name : "noname");
				DebugGraphics.pushGpuMarker(this.device, layer.name);
				drawTime = now();

				if (camera) {
					camera.frameBegin(renderAction.renderTarget);

					if (renderAction.firstCameraUse && camera.onPreRender) {
						camera.onPreRender();
					}
				}

				if (!transparent && layer.onPreRenderOpaque) {
					layer.onPreRenderOpaque(cameraPass);
				} else if (transparent && layer.onPreRenderTransparent) {
					layer.onPreRenderTransparent(cameraPass);
				}

				if (!(layer._preRenderCalledForCameras & 1 << cameraPass)) {
					if (layer.onPreRender) {
						layer.onPreRender(cameraPass);
					}

					layer._preRenderCalledForCameras |= 1 << cameraPass;
				}

				if (camera) {
					var _renderAction$renderT;

					if (renderAction.clearColor || renderAction.clearDepth || renderAction.clearStencil) {
						var backupColor = camera.camera._clearColorBuffer;
						var backupDepth = camera.camera._clearDepthBuffer;
						var backupStencil = camera.camera._clearStencilBuffer;
						camera.camera._clearColorBuffer = renderAction.clearColor;
						camera.camera._clearDepthBuffer = renderAction.clearDepth;
						camera.camera._clearStencilBuffer = renderAction.clearStencil;
						this.clearView(camera.camera, renderAction.renderTarget, true, true);
						camera.camera._clearColorBuffer = backupColor;
						camera.camera._clearDepthBuffer = backupDepth;
						camera.camera._clearStencilBuffer = backupStencil;
					}

					sortTime = now();

					layer._sortVisible(transparent, camera.camera.node, cameraPass);

					this._sortTime += now() - sortTime;
					var objects = layer.instances;
					var visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];
					this.scene.immediate.onPreRenderLayer(layer, visible, transparent);
					this.scene._activeCamera = camera.camera;
					this.setCamera(camera.camera, renderAction.renderTarget);

					if (clusteredLightingEnabled && renderAction.lightClusters) {
						renderAction.lightClusters.activate(this.lightTextureAtlas);

						if (!clustersDebugRendered && this.scene.lighting.debugLayer === layer.id) {
							clustersDebugRendered = true;
							WorldClustersDebug.render(renderAction.lightClusters, this.scene);
						}
					}

					var flipFaces = !!(camera.camera._flipFaces ^ (renderAction == null ? void 0 : (_renderAction$renderT = renderAction.renderTarget) == null ? void 0 : _renderAction$renderT.flipY));
					var draws = this._forwardDrawCalls;
					this.renderForward(camera.camera, visible.list, visible.length, layer._splitLights, layer.shaderPass, layer.cullingMask, layer.onDrawCall, layer, flipFaces);
					layer._forwardDrawCalls += this._forwardDrawCalls - draws;
					device.setColorWrite(true, true, true, true);
					device.setStencilTest(false);
					device.setAlphaToCoverage(false);
					device.setDepthBias(false);
					camera.frameEnd();

					if (renderAction.lastCameraUse && camera.onPostRender) {
						camera.onPostRender();
					}

					if (renderAction.triggerPostprocess && camera.onPostprocessing) {
						camera.onPostprocessing();
					}
				}

				if (!transparent && layer.onPostRenderOpaque) {
					layer.onPostRenderOpaque(cameraPass);
				} else if (transparent && layer.onPostRenderTransparent) {
					layer.onPostRenderTransparent(cameraPass);
				}

				if (layer.onPostRender && !(layer._postRenderCalledForCameras & 1 << cameraPass)) {
					layer._postRenderCounter &= ~(transparent ? 2 : 1);

					if (layer._postRenderCounter === 0) {
						layer.onPostRender(cameraPass);
						layer._postRenderCalledForCameras |= 1 << cameraPass;
						layer._postRenderCounter = layer._postRenderCounterMax;
					}
				}

				DebugGraphics.popGpuMarker(this.device);
				DebugGraphics.popGpuMarker(this.device);
				layer._renderTime += now() - drawTime;
			}
		};

		return ForwardRenderer;
	}();

	ForwardRenderer.skipRenderCamera = null;
	ForwardRenderer._skipRenderCounter = 0;
	ForwardRenderer.skipRenderAfter = 0;

	var keyA, keyB, sortPos, sortDir;

	function sortManual(drawCallA, drawCallB) {
		return drawCallA.drawOrder - drawCallB.drawOrder;
	}

	function sortMaterialMesh(drawCallA, drawCallB) {
		keyA = drawCallA._key[SORTKEY_FORWARD];
		keyB = drawCallB._key[SORTKEY_FORWARD];

		if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
			return drawCallB.mesh.id - drawCallA.mesh.id;
		}

		return keyB - keyA;
	}

	function sortBackToFront(drawCallA, drawCallB) {
		return drawCallB.zdist - drawCallA.zdist;
	}

	function sortFrontToBack(drawCallA, drawCallB) {
		return drawCallA.zdist - drawCallB.zdist;
	}

	var sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];

	function sortLights(lightA, lightB) {
		return lightB.key - lightA.key;
	}

	var layerCounter = 0;

	var VisibleInstanceList = function VisibleInstanceList() {
		this.list = [];
		this.length = 0;
		this.done = false;
	};

	var InstanceList = function () {
		function InstanceList() {
			this.opaqueMeshInstances = [];
			this.transparentMeshInstances = [];
			this.shadowCasters = [];
			this.visibleOpaque = [];
			this.visibleTransparent = [];
		}

		var _proto = InstanceList.prototype;

		_proto.prepare = function prepare(index) {
			if (!this.visibleOpaque[index]) {
				this.visibleOpaque[index] = new VisibleInstanceList();
			}

			if (!this.visibleTransparent[index]) {
				this.visibleTransparent[index] = new VisibleInstanceList();
			}

			this.visibleOpaque[index].done = false;
			this.visibleTransparent[index].done = false;
		};

		_proto.delete = function _delete(index) {
			if (index < this.visibleOpaque.length) {
				this.visibleOpaque.splice(index, 1);
			}

			if (index < this.visibleTransparent.length) {
				this.visibleTransparent.splice(index, 1);
			}
		};

		return InstanceList;
	}();

	var Layer = function () {
		function Layer(options) {
			if (options === void 0) {
				options = {};
			}

			if (options.id !== undefined) {
				this.id = options.id;
				layerCounter = Math.max(this.id + 1, layerCounter);
			} else {
				this.id = layerCounter++;
			}

			this.name = options.name;
			this._enabled = options.enabled === undefined ? true : options.enabled;
			this._refCounter = this._enabled ? 1 : 0;
			this.opaqueSortMode = options.opaqueSortMode === undefined ? SORTMODE_MATERIALMESH : options.opaqueSortMode;
			this.transparentSortMode = options.transparentSortMode === undefined ? SORTMODE_BACK2FRONT : options.transparentSortMode;
			this.renderTarget = options.renderTarget;
			this.shaderPass = options.shaderPass === undefined ? SHADER_FORWARD : options.shaderPass;
			this.passThrough = options.passThrough === undefined ? false : options.passThrough;
			this._clearColorBuffer = options.clearColorBuffer ? options.clearColorBuffer : false;
			this._clearDepthBuffer = options.clearDepthBuffer ? options.clearDepthBuffer : false;
			this._clearStencilBuffer = options.clearStencilBuffer ? options.clearStencilBuffer : false;
			this.onPreCull = options.onPreCull;
			this.onPreRender = options.onPreRender;
			this.onPreRenderOpaque = options.onPreRenderOpaque;
			this.onPreRenderTransparent = options.onPreRenderTransparent;
			this.onPostCull = options.onPostCull;
			this.onPostRender = options.onPostRender;
			this.onPostRenderOpaque = options.onPostRenderOpaque;
			this.onPostRenderTransparent = options.onPostRenderTransparent;
			this.onDrawCall = options.onDrawCall;
			this.onEnable = options.onEnable;
			this.onDisable = options.onDisable;

			if (this._enabled && this.onEnable) {
				this.onEnable();
			}

			this.layerReference = options.layerReference;
			this.instances = options.layerReference ? options.layerReference.instances : new InstanceList();
			this.cullingMask = options.cullingMask ? options.cullingMask : 0xFFFFFFFF;
			this.opaqueMeshInstances = this.instances.opaqueMeshInstances;
			this.transparentMeshInstances = this.instances.transparentMeshInstances;
			this.shadowCasters = this.instances.shadowCasters;
			this.customSortCallback = null;
			this.customCalculateSortValues = null;
			this._lights = [];
			this._lightsSet = new Set();
			this._clusteredLightsSet = new Set();
			this._splitLights = [[], [], []];
			this.cameras = [];
			this._dirty = false;
			this._dirtyLights = false;
			this._dirtyCameras = false;
			this._lightHash = 0;
			this._staticLightHash = 0;
			this._needsStaticPrepare = true;
			this._staticPrepareDone = false;
			this.skipRenderAfter = Number.MAX_VALUE;
			this._skipRenderCounter = 0;
			this._renderTime = 0;
			this._forwardDrawCalls = 0;
			this._shadowDrawCalls = 0;
			this._shaderVersion = -1;
			this._lightCube = null;
		}

		var _proto2 = Layer.prototype;

		_proto2.incrementCounter = function incrementCounter() {
			if (this._refCounter === 0) {
				this._enabled = true;
				if (this.onEnable) this.onEnable();
			}

			this._refCounter++;
		};

		_proto2.decrementCounter = function decrementCounter() {
			if (this._refCounter === 1) {
				this._enabled = false;
				if (this.onDisable) this.onDisable();
			} else if (this._refCounter === 0) {
				Debug.warn("Trying to decrement layer counter below 0");
				return;
			}

			this._refCounter--;
		};

		_proto2.addMeshInstances = function addMeshInstances(meshInstances, skipShadowCasters) {
			var sceneShaderVer = this._shaderVersion;
			var casters = this.shadowCasters;

			for (var i = 0; i < meshInstances.length; i++) {
				var m = meshInstances[i];
				var mat = m.material;
				var arr = mat.blendType === BLEND_NONE ? this.opaqueMeshInstances : this.transparentMeshInstances;

				if (this.opaqueMeshInstances.indexOf(m) < 0 && this.transparentMeshInstances.indexOf(m) < 0) {
					arr.push(m);
				}

				if (!skipShadowCasters && m.castShadow && casters.indexOf(m) < 0) casters.push(m);

				if (!this.passThrough && sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {
					if (mat.updateShader !== Material.prototype.updateShader) {
						mat.clearVariants();
						mat.shader = null;
					}

					mat._shaderVersion = sceneShaderVer;
				}
			}

			if (!this.passThrough) this._dirty = true;
		};

		_proto2.removeMeshInstanceFromArray = function removeMeshInstanceFromArray(m, arr) {
			var spliceOffset = -1;
			var spliceCount = 0;
			var len = arr.length;

			for (var j = 0; j < len; j++) {
				var drawCall = arr[j];

				if (drawCall === m) {
					spliceOffset = j;
					spliceCount = 1;
					break;
				}

				if (drawCall._staticSource === m) {
					if (spliceOffset < 0) spliceOffset = j;
					spliceCount++;
				} else if (spliceOffset >= 0) {
					break;
				}
			}

			if (spliceOffset >= 0) {
				arr.splice(spliceOffset, spliceCount);
			}
		};

		_proto2.removeMeshInstances = function removeMeshInstances(meshInstances, skipShadowCasters) {
			var opaque = this.opaqueMeshInstances;
			var transparent = this.transparentMeshInstances;
			var casters = this.shadowCasters;

			for (var i = 0; i < meshInstances.length; i++) {
				var m = meshInstances[i];
				this.removeMeshInstanceFromArray(m, opaque);
				this.removeMeshInstanceFromArray(m, transparent);

				if (!skipShadowCasters) {
					var j = casters.indexOf(m);
					if (j >= 0) casters.splice(j, 1);
				}
			}

			this._dirty = true;
		};

		_proto2.clearMeshInstances = function clearMeshInstances(skipShadowCasters) {
			if (this.opaqueMeshInstances.length === 0 && this.transparentMeshInstances.length === 0) {
				if (skipShadowCasters || this.shadowCasters.length === 0) return;
			}

			this.opaqueMeshInstances.length = 0;
			this.transparentMeshInstances.length = 0;
			if (!skipShadowCasters) this.shadowCasters.length = 0;
			if (!this.passThrough) this._dirty = true;
		};

		_proto2.addLight = function addLight(light) {
			var l = light.light;

			if (!this._lightsSet.has(l)) {
				this._lightsSet.add(l);

				if (l.type !== LIGHTTYPE_DIRECTIONAL) {
					this._clusteredLightsSet.add(l);
				}

				this._lights.push(l);

				this._dirtyLights = true;

				this._generateLightHash();
			}
		};

		_proto2.removeLight = function removeLight(light) {
			var l = light.light;

			if (this._lightsSet.has(l)) {
				this._lightsSet.delete(l);

				if (l.type !== LIGHTTYPE_DIRECTIONAL) {
					this._clusteredLightsSet.delete(l);
				}

				this._lights.splice(this._lights.indexOf(l), 1);

				this._dirtyLights = true;

				this._generateLightHash();
			}
		};

		_proto2.clearLights = function clearLights() {
			this._lightsSet.clear();

			this._clusteredLightsSet.clear();

			this._lights.length = 0;
			this._dirtyLights = true;
		};

		_proto2.addShadowCasters = function addShadowCasters(meshInstances) {
			var arr = this.shadowCasters;

			for (var i = 0; i < meshInstances.length; i++) {
				var m = meshInstances[i];
				if (!m.castShadow) continue;
				if (arr.indexOf(m) < 0) arr.push(m);
			}

			this._dirtyLights = true;
		};

		_proto2.removeShadowCasters = function removeShadowCasters(meshInstances) {
			var arr = this.shadowCasters;

			for (var i = 0; i < meshInstances.length; i++) {
				var id = arr.indexOf(meshInstances[i]);
				if (id >= 0) arr.splice(id, 1);
			}

			this._dirtyLights = true;
		};

		_proto2._generateLightHash = function _generateLightHash() {
			if (this._lights.length > 0) {
				this._lights.sort(sortLights);

				var str = "";
				var strStatic = "";

				for (var i = 0; i < this._lights.length; i++) {
					if (this._lights[i].isStatic) {
						strStatic += this._lights[i].key;
					} else {
						str += this._lights[i].key;
					}
				}

				if (str.length === 0) {
					this._lightHash = 0;
				} else {
					this._lightHash = hashCode(str);
				}

				if (strStatic.length === 0) {
					this._staticLightHash = 0;
				} else {
					this._staticLightHash = hashCode(strStatic);
				}
			} else {
				this._lightHash = 0;
				this._staticLightHash = 0;
			}
		};

		_proto2.addCamera = function addCamera(camera) {
			if (this.cameras.indexOf(camera) >= 0) return;
			this.cameras.push(camera);
			this._dirtyCameras = true;
		};

		_proto2.removeCamera = function removeCamera(camera) {
			var index = this.cameras.indexOf(camera);

			if (index >= 0) {
				this.cameras.splice(index, 1);
				this._dirtyCameras = true;
				this.instances.delete(index);
			}
		};

		_proto2.clearCameras = function clearCameras() {
			this.cameras.length = 0;
			this._dirtyCameras = true;
		};

		_proto2._calculateSortDistances = function _calculateSortDistances(drawCalls, drawCallsCount, camPos, camFwd) {
			for (var i = 0; i < drawCallsCount; i++) {
				var drawCall = drawCalls[i];
				if (drawCall.command) continue;
				if (drawCall.layer <= LAYER_FX) continue;

				if (drawCall.calculateSortDistance) {
					drawCall.zdist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);
					continue;
				}

				var meshPos = drawCall.aabb.center;
				var tempx = meshPos.x - camPos.x;
				var tempy = meshPos.y - camPos.y;
				var tempz = meshPos.z - camPos.z;
				drawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;
			}
		};

		_proto2._sortVisible = function _sortVisible(transparent, cameraNode, cameraPass) {
			var objects = this.instances;
			var sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;
			if (sortMode === SORTMODE_NONE) return;
			var visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];

			if (sortMode === SORTMODE_CUSTOM) {
				sortPos = cameraNode.getPosition();
				sortDir = cameraNode.forward;

				if (this.customCalculateSortValues) {
					this.customCalculateSortValues(visible.list, visible.length, sortPos, sortDir);
				}

				if (visible.list.length !== visible.length) {
					visible.list.length = visible.length;
				}

				if (this.customSortCallback) {
					visible.list.sort(this.customSortCallback);
				}
			} else {
				if (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {
					sortPos = cameraNode.getPosition();
					sortDir = cameraNode.forward;

					this._calculateSortDistances(visible.list, visible.length, sortPos, sortDir);
				}

				if (visible.list.length !== visible.length) {
					visible.list.length = visible.length;
				}

				visible.list.sort(sortCallbacks[sortMode]);
			}
		};

		_createClass(Layer, [{
			key: "renderTarget",
			get: function get() {
				return this._renderTarget;
			},
			set: function set(rt) {
				this._renderTarget = rt;
				this._dirtyCameras = true;
			}
		}, {
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(val) {
				if (val !== this._enabled) {
					this._enabled = val;

					if (val) {
						this.incrementCounter();
						if (this.onEnable) this.onEnable();
					} else {
						this.decrementCounter();
						if (this.onDisable) this.onDisable();
					}
				}
			}
		}, {
			key: "clearColor",
			get: function get() {
				return this._clearColor;
			},
			set: function set(val) {
				this._clearColor.copy(val);
			}
		}, {
			key: "clearColorBuffer",
			get: function get() {
				return this._clearColorBuffer;
			},
			set: function set(val) {
				this._clearColorBuffer = val;
				this._dirtyCameras = true;
			}
		}, {
			key: "clearDepthBuffer",
			get: function get() {
				return this._clearDepthBuffer;
			},
			set: function set(val) {
				this._clearDepthBuffer = val;
				this._dirtyCameras = true;
			}
		}, {
			key: "clearStencilBuffer",
			get: function get() {
				return this._clearStencilBuffer;
			},
			set: function set(val) {
				this._clearStencilBuffer = val;
				this._dirtyCameras = true;
			}
		}, {
			key: "clusteredLightsSet",
			get: function get() {
				return this._clusteredLightsSet;
			}
		}]);

		return Layer;
	}();

	var set = {
		equals: function equals(set1, set2) {
			if (set1.size !== set2.size) {
				return false;
			}

			for (var _iterator = _createForOfIteratorHelperLoose(set1), _step; !(_step = _iterator()).done;) {
				var item = _step.value;

				if (!set2.has(item)) {
					return false;
				}
			}

			return true;
		}
	};

	var cmpPriority = function cmpPriority(a, b) {
		return a.priority - b.priority;
	};

	var sortPriority = function sortPriority(arr) {
		return arr.sort(cmpPriority);
	};

	var RenderAction = function () {
		function RenderAction() {
			this.layerIndex = 0;
			this.cameraIndex = 0;
			this.camera = null;
			this.renderTarget = null;
			this.lightClusters = null;
			this.clearColor = false;
			this.clearDepth = false;
			this.clearStencil = false;
			this.triggerPostprocess = false;
			this.firstCameraUse = false;
			this.lastCameraUse = false;
			this.directionalLightsSet = new Set();
			this.directionalLights = [];
			this.directionalLightsIndices = [];
		}

		var _proto = RenderAction.prototype;

		_proto.reset = function reset() {
			this.lightClusters = null;
			this.directionalLightsSet.clear();
			this.directionalLights.length = 0;
			this.directionalLightsIndices.length = 0;
		};

		_proto.collectDirectionalLights = function collectDirectionalLights(cameraLayers, dirLights, allLights) {
			this.directionalLightsSet.clear();
			this.directionalLights.length = 0;
			this.directionalLightsIndices.length = 0;

			for (var i = 0; i < dirLights.length; i++) {
				var light = dirLights[i];

				if (light.castShadows) {
					for (var l = 0; l < cameraLayers.length; l++) {
						if (cameraLayers[l]._splitLights[LIGHTTYPE_DIRECTIONAL].indexOf(light) >= 0) {
							if (!this.directionalLightsSet.has(light)) {
								this.directionalLightsSet.add(light);
								this.directionalLights.push(light);
								var lightIndex = allLights.indexOf(light);
								this.directionalLightsIndices.push(lightIndex);
							}
						}
					}
				}
			}
		};

		return RenderAction;
	}();

	var LightCompositionData = function () {
		function LightCompositionData() {
			this.shadowCastersSet = new Set();
			this.shadowCastersList = [];
		}

		var _proto = LightCompositionData.prototype;

		_proto.clearShadowCasters = function clearShadowCasters() {
			this.shadowCastersSet.clear();
			this.shadowCastersList.length = 0;
		};

		_proto.addShadowCasters = function addShadowCasters(casters) {
			for (var i = 0; i < casters.length; i++) {
				var item = casters[i];

				if (!this.shadowCastersSet.has(item)) {
					this.shadowCastersSet.add(item);
					this.shadowCastersList.push(item);
				}
			}
		};

		return LightCompositionData;
	}();

	var tempSet$1 = new Set();
	var tempClusterArray = [];

	var LayerComposition = function (_EventHandler) {
		_inheritsLoose(LayerComposition, _EventHandler);

		function LayerComposition(name) {
			var _this;

			if (name === void 0) {
				name = "Untitled";
			}

			_this = _EventHandler.call(this) || this;
			_this.name = name;
			_this.logRenderActions = false;
			_this.layerList = [];
			_this.subLayerList = [];
			_this.subLayerEnabled = [];
			_this._opaqueOrder = {};
			_this._transparentOrder = {};
			_this._dirty = false;
			_this._dirtyBlend = false;
			_this._dirtyLights = false;
			_this._dirtyCameras = false;
			_this._meshInstances = [];
			_this._meshInstancesSet = new Set();
			_this._lights = [];
			_this._lightsMap = new Map();
			_this._lightCompositionData = [];
			_this._splitLights = [[], [], []];
			_this.cameras = [];
			_this._renderActions = [];
			_this._worldClusters = [];
			_this._emptyWorldClusters = null;
			return _this;
		}

		var _proto = LayerComposition.prototype;

		_proto.destroy = function destroy() {
			if (this._emptyWorldClusters) {
				this._emptyWorldClusters.destroy();

				this._emptyWorldClusters = null;
			}

			this._worldClusters.forEach(function (cluster) {
				cluster.destroy();
			});

			this._worldClusters = null;
		};

		_proto.getEmptyWorldClusters = function getEmptyWorldClusters(device) {
			if (!this._emptyWorldClusters) {
				this._emptyWorldClusters = new WorldClusters(device);
				this._emptyWorldClusters.name = "ClusterEmpty";

				this._emptyWorldClusters.update([], false, null);
			}

			return this._emptyWorldClusters;
		};

		_proto._splitLightsArray = function _splitLightsArray(target) {
			var lights = target._lights;
			target._splitLights[LIGHTTYPE_DIRECTIONAL].length = 0;
			target._splitLights[LIGHTTYPE_OMNI].length = 0;
			target._splitLights[LIGHTTYPE_SPOT].length = 0;

			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];

				if (light.enabled) {
					target._splitLights[light._type].push(light);
				}
			}
		};

		_proto._update = function _update(device, clusteredLightingEnabled) {
			if (clusteredLightingEnabled === void 0) {
				clusteredLightingEnabled = false;
			}

			var len = this.layerList.length;
			var result = 0;

			if (!this._dirty || !this._dirtyLights || !this._dirtyCameras) {
				for (var i = 0; i < len; i++) {
					var layer = this.layerList[i];

					if (layer._dirty) {
						this._dirty = true;
					}

					if (layer._dirtyLights) {
						this._dirtyLights = true;
					}

					if (layer._dirtyCameras) {
						this._dirtyCameras = true;
					}
				}
			}

			function addUniqueMeshInstance(destArray, destSet, srcArray) {
				var dirtyBlend = false;
				var srcLen = srcArray.length;

				for (var s = 0; s < srcLen; s++) {
					var meshInst = srcArray[s];

					if (!destSet.has(meshInst)) {
						destSet.add(meshInst);
						destArray.push(meshInst);
						var material = meshInst.material;

						if (material && material._dirtyBlend) {
							dirtyBlend = true;
							material._dirtyBlend = false;
						}
					}
				}

				return dirtyBlend;
			}

			if (this._dirty) {
				result |= COMPUPDATED_INSTANCES;
				this._meshInstances.length = 0;

				this._meshInstancesSet.clear();

				for (var _i = 0; _i < len; _i++) {
					var _layer = this.layerList[_i];

					if (!_layer.passThrough) {
						this._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, _layer.opaqueMeshInstances) || this._dirtyBlend;
						this._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, _layer.transparentMeshInstances) || this._dirtyBlend;
					}

					_layer._dirty = false;
				}

				this._dirty = false;
			}

			function moveByBlendType(dest, src, moveTransparent) {
				for (var s = 0; s < src.length;) {
					var _src$s$material;

					if (((_src$s$material = src[s].material) == null ? void 0 : _src$s$material.transparent) === moveTransparent) {
						dest.push(src[s]);
						src[s] = src[src.length - 1];
						src.length--;
					} else {
						s++;
					}
				}
			}

			if (this._dirtyBlend) {
				result |= COMPUPDATED_BLEND;

				for (var _i2 = 0; _i2 < len; _i2++) {
					var _layer2 = this.layerList[_i2];

					if (!_layer2.passThrough) {
						moveByBlendType(_layer2.opaqueMeshInstances, _layer2.transparentMeshInstances, false);
						moveByBlendType(_layer2.transparentMeshInstances, _layer2.opaqueMeshInstances, true);
					}
				}

				this._dirtyBlend = false;
			}

			if (this._dirtyLights) {
				result |= COMPUPDATED_LIGHTS;
				this._dirtyLights = false;
				this.updateLights();
			}

			if (result) {
				this.updateShadowCasters();
			}

			if (this._dirtyCameras || result & COMPUPDATED_LIGHTS) {
				this._dirtyCameras = false;
				result |= COMPUPDATED_CAMERAS;
				this.cameras.length = 0;

				for (var _i3 = 0; _i3 < len; _i3++) {
					var _layer3 = this.layerList[_i3];
					_layer3._dirtyCameras = false;

					for (var j = 0; j < _layer3.cameras.length; j++) {
						var camera = _layer3.cameras[j];
						var index = this.cameras.indexOf(camera);

						if (index < 0) {
							this.cameras.push(camera);
						}
					}
				}

				if (this.cameras.length > 1) {
					sortPriority(this.cameras);
				}

				var cameraLayers = [];
				var renderActionCount = 0;

				for (var _i4 = 0; _i4 < this.cameras.length; _i4++) {
					var _camera = this.cameras[_i4];
					cameraLayers.length = 0;
					var cameraFirstRenderAction = true;
					var cameraFirstRenderActionIndex = renderActionCount;
					var lastRenderAction = null;
					var postProcessMarked = false;

					for (var _j = 0; _j < len; _j++) {
						var _layer4 = this.layerList[_j];

						if (_layer4) {
							if (_layer4.cameras.length > 0) {
								if (_camera.layers.indexOf(_layer4.id) >= 0) {
									cameraLayers.push(_layer4);

									if (!postProcessMarked && _layer4.id === _camera.disablePostEffectsLayer) {
										postProcessMarked = true;

										if (lastRenderAction) {
											lastRenderAction.triggerPostprocess = true;
										}
									}

									var cameraIndex = _layer4.cameras.indexOf(_camera);

									if (cameraIndex >= 0) {
										lastRenderAction = this.addRenderAction(this._renderActions, renderActionCount, _layer4, _j, cameraIndex, cameraFirstRenderAction, postProcessMarked);
										renderActionCount++;
										cameraFirstRenderAction = false;
									}
								}
							}
						}
					}

					if (cameraFirstRenderActionIndex < renderActionCount) {
						this._renderActions[cameraFirstRenderActionIndex].collectDirectionalLights(cameraLayers, this._splitLights[LIGHTTYPE_DIRECTIONAL], this._lights);

						lastRenderAction.lastCameraUse = true;
					}

					if (!postProcessMarked && lastRenderAction) {
						lastRenderAction.triggerPostprocess = true;
					}

					if (_camera.renderTarget && _camera.postEffectsEnabled) {
						this.propagateRenderTarget(cameraFirstRenderActionIndex - 1, _camera);
					}
				}

				this._renderActions.length = renderActionCount;

				if (clusteredLightingEnabled) {
					this.allocateLightClusters(device);
				}
			}

			if (result & COMPUPDATED_LIGHTS || result & COMPUPDATED_CAMERAS) {
				this._logRenderActions();
			}

			return result;
		};

		_proto.updateShadowCasters = function updateShadowCasters() {
			var lightCount = this._lights.length;

			for (var i = 0; i < lightCount; i++) {
				this._lightCompositionData[i].clearShadowCasters();
			}

			var len = this.layerList.length;

			for (var _i5 = 0; _i5 < len; _i5++) {
				var layer = this.layerList[_i5];

				if (!tempSet$1.has(layer)) {
					tempSet$1.add(layer);
					var lights = layer._lights;

					for (var j = 0; j < lights.length; j++) {
						if (lights[j].castShadows) {
							var lightIndex = this._lightsMap.get(lights[j]);

							var lightCompData = this._lightCompositionData[lightIndex];
							lightCompData.addShadowCasters(layer.shadowCasters);
						}
					}
				}
			}

			tempSet$1.clear();
		};

		_proto.updateLights = function updateLights() {
			this._lights.length = 0;

			this._lightsMap.clear();

			var count = this.layerList.length;

			for (var i = 0; i < count; i++) {
				var layer = this.layerList[i];

				if (!tempSet$1.has(layer)) {
					tempSet$1.add(layer);
					var lights = layer._lights;

					for (var j = 0; j < lights.length; j++) {
						var light = lights[j];

						var lightIndex = this._lightsMap.get(light);

						if (lightIndex === undefined) {
							lightIndex = this._lights.length;

							this._lightsMap.set(light, lightIndex);

							this._lights.push(light);

							var lightCompData = this._lightCompositionData[lightIndex];

							if (!lightCompData) {
								lightCompData = new LightCompositionData();
								this._lightCompositionData[lightIndex] = lightCompData;
							}
						}
					}
				}

				this._splitLightsArray(layer);

				layer._dirtyLights = false;
			}

			tempSet$1.clear();

			this._splitLightsArray(this);

			var lightCount = this._lights.length;
			this._lightCompositionData.length = lightCount;
		};

		_proto.findCompatibleCluster = function findCompatibleCluster(layer, renderActionCount) {
			for (var i = 0; i < renderActionCount; i++) {
				var ra = this._renderActions[i];
				var raLayer = this.layerList[ra.layerIndex];

				if (layer === raLayer) {
					return ra.lightClusters;
				}

				if (ra.lightClusters) {
					if (set.equals(layer._clusteredLightsSet, raLayer._clusteredLightsSet)) {
						return ra.lightClusters;
					}
				}
			}

			return null;
		};

		_proto.allocateLightClusters = function allocateLightClusters(device) {
			tempClusterArray.push.apply(tempClusterArray, this._worldClusters);
			this._worldClusters.length = 0;
			var count = this._renderActions.length;

			for (var i = 0; i < count; i++) {
				var ra = this._renderActions[i];
				var layer = this.layerList[ra.layerIndex];

				if (layer._clusteredLightsSet.size) {
					var transparent = this.subLayerList[ra.layerIndex];
					var meshInstances = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;

					if (meshInstances.length) {
						var clusters = this.findCompatibleCluster(layer, i);

						if (!clusters) {
							if (tempClusterArray.length) {
								clusters = tempClusterArray.pop();
							}

							if (!clusters) {
								clusters = new WorldClusters(device);
							}

							clusters.name = "Cluster-" + this._worldClusters.length;

							this._worldClusters.push(clusters);
						}

						ra.lightClusters = clusters;
					}
				}

				if (!ra.lightClusters) {
					ra.lightClusters = this.getEmptyWorldClusters(device);
				}
			}

			tempClusterArray.forEach(function (item) {
				item.destroy();
			});
			tempClusterArray.length = 0;
		};

		_proto.addRenderAction = function addRenderAction(renderActions, renderActionIndex, layer, layerIndex, cameraIndex, cameraFirstRenderAction, postProcessMarked) {
			var renderAction = renderActions[renderActionIndex];

			if (!renderAction) {
				renderAction = renderActions[renderActionIndex] = new RenderAction();
			}

			var rt = layer.renderTarget;
			var camera = layer.cameras[cameraIndex];

			if (camera && camera.renderTarget) {
				if (layer.id !== LAYERID_DEPTH) {
					rt = camera.renderTarget;
				}
			}

			var used = false;

			for (var i = renderActionIndex - 1; i >= 0; i--) {
				if (renderActions[i].camera === camera && renderActions[i].renderTarget === rt) {
					used = true;
					break;
				}
			}

			var needsClear = cameraFirstRenderAction || !used;
			var clearColor = needsClear ? camera.clearColorBuffer : false;
			var clearDepth = needsClear ? camera.clearDepthBuffer : false;
			var clearStencil = needsClear ? camera.clearStencilBuffer : false;
			clearColor |= layer.clearColorBuffer;
			clearDepth |= layer.clearDepthBuffer;
			clearStencil |= layer.clearStencilBuffer;

			if (postProcessMarked && camera.postEffectsEnabled) {
				rt = null;
			}

			renderAction.reset();
			renderAction.triggerPostprocess = false;
			renderAction.layerIndex = layerIndex;
			renderAction.cameraIndex = cameraIndex;
			renderAction.camera = camera;
			renderAction.renderTarget = rt;
			renderAction.clearColor = clearColor;
			renderAction.clearDepth = clearDepth;
			renderAction.clearStencil = clearStencil;
			renderAction.firstCameraUse = cameraFirstRenderAction;
			renderAction.lastCameraUse = false;
			return renderAction;
		};

		_proto.propagateRenderTarget = function propagateRenderTarget(startIndex, fromCamera) {
			for (var a = startIndex; a >= 0; a--) {
				var ra = this._renderActions[a];
				var layer = this.layerList[ra.layerIndex];

				if (ra.renderTarget && layer.id !== LAYERID_DEPTH) {
					break;
				}

				if (layer.id === LAYERID_DEPTH) {
					continue;
				}

				var thisCamera = ra == null ? void 0 : ra.camera.camera;

				if (thisCamera) {
					if (!fromCamera.camera.rect.equals(thisCamera.rect) || !fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)) {
						break;
					}
				}

				ra.renderTarget = fromCamera.renderTarget;
			}
		};

		_proto._logRenderActions = function _logRenderActions() {
			if (this.logRenderActions) {
				Debug.log("Render Actions for composition: " + this.name);

				for (var i = 0; i < this._renderActions.length; i++) {
					var ra = this._renderActions[i];
					var layerIndex = ra.layerIndex;
					var layer = this.layerList[layerIndex];
					var enabled = layer.enabled && this.subLayerEnabled[layerIndex];
					var transparent = this.subLayerList[layerIndex];
					var camera = layer.cameras[ra.cameraIndex];
					var dirLightCount = ra.directionalLights.length;
					var clear = (ra.clearColor ? "Color " : "..... ") + (ra.clearDepth ? "Depth " : "..... ") + (ra.clearStencil ? "Stencil" : ".......");
					Debug.log(i + (" Cam: " + (camera ? camera.entity.name : "-")).padEnd(22, " ") + (" Lay: " + layer.name).padEnd(22, " ") + (transparent ? " TRANSP" : " OPAQUE") + (enabled ? " ENABLED " : " DISABLED") + " Meshes: ", (transparent ? layer.transparentMeshInstances.length : layer.opaqueMeshInstances.length) + (" RT: " + (ra.renderTarget ? ra.renderTarget.name : "-")).padEnd(30, " ") + " Clear: " + clear + " Lights: (" + layer._clusteredLightsSet.size + "/" + layer._lightsSet.size + ")" + " " + (ra.lightClusters !== this._emptyWorldClusters ? ra.lightClusters.name : "").padEnd(10, " ") + (ra.firstCameraUse ? " CAM-FIRST" : "") + (ra.lastCameraUse ? " CAM-LAST" : "") + (ra.triggerPostprocess ? " POSTPROCESS" : "") + (dirLightCount ? " DirLights: " + dirLightCount : ""));
				}
			}
		};

		_proto._isLayerAdded = function _isLayerAdded(layer) {
			if (this.layerList.indexOf(layer) >= 0) {
				Debug.error("Layer is already added.");
				return true;
			}

			return false;
		};

		_proto._isSublayerAdded = function _isSublayerAdded(layer, transparent) {
			for (var i = 0; i < this.layerList.length; i++) {
				if (this.layerList[i] === layer && this.subLayerList[i] === transparent) {
					Debug.error("Sublayer is already added.");
					return true;
				}
			}

			return false;
		};

		_proto.push = function push(layer) {
			if (this._isLayerAdded(layer)) return;
			this.layerList.push(layer);
			this.layerList.push(layer);
			this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
			this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
			this.subLayerEnabled.push(true);
			this.subLayerEnabled.push(true);
			this._dirty = true;
			this._dirtyLights = true;
			this._dirtyCameras = true;
			this.fire("add", layer);
		};

		_proto.insert = function insert(layer, index) {
			if (this._isLayerAdded(layer)) return;
			this.layerList.splice(index, 0, layer, layer);
			this.subLayerList.splice(index, 0, false, true);
			var count = this.layerList.length;

			this._updateOpaqueOrder(index, count - 1);

			this._updateTransparentOrder(index, count - 1);

			this.subLayerEnabled.splice(index, 0, true, true);
			this._dirty = true;
			this._dirtyLights = true;
			this._dirtyCameras = true;
			this.fire("add", layer);
		};

		_proto.remove = function remove(layer) {
			var id = this.layerList.indexOf(layer);
			delete this._opaqueOrder[id];
			delete this._transparentOrder[id];

			while (id >= 0) {
				this.layerList.splice(id, 1);
				this.subLayerList.splice(id, 1);
				this.subLayerEnabled.splice(id, 1);
				id = this.layerList.indexOf(layer);
				this._dirty = true;
				this._dirtyLights = true;
				this._dirtyCameras = true;
				this.fire("remove", layer);
			}

			var count = this.layerList.length;

			this._updateOpaqueOrder(0, count - 1);

			this._updateTransparentOrder(0, count - 1);
		};

		_proto.pushOpaque = function pushOpaque(layer) {
			if (this._isSublayerAdded(layer, false)) return;
			this.layerList.push(layer);
			this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
			this.subLayerEnabled.push(true);
			this._dirty = true;
			this._dirtyLights = true;
			this._dirtyCameras = true;
			this.fire("add", layer);
		};

		_proto.insertOpaque = function insertOpaque(layer, index) {
			if (this._isSublayerAdded(layer, false)) return;
			this.layerList.splice(index, 0, layer);
			this.subLayerList.splice(index, 0, false);
			var count = this.subLayerList.length;

			this._updateOpaqueOrder(index, count - 1);

			this.subLayerEnabled.splice(index, 0, true);
			this._dirty = true;
			this._dirtyLights = true;
			this._dirtyCameras = true;
			this.fire("add", layer);
		};

		_proto.removeOpaque = function removeOpaque(layer) {
			for (var i = 0, len = this.layerList.length; i < len; i++) {
				if (this.layerList[i] === layer && !this.subLayerList[i]) {
					this.layerList.splice(i, 1);
					this.subLayerList.splice(i, 1);
					len--;

					this._updateOpaqueOrder(i, len - 1);

					this.subLayerEnabled.splice(i, 1);
					this._dirty = true;
					this._dirtyLights = true;
					this._dirtyCameras = true;

					if (this.layerList.indexOf(layer) < 0) {
						this.fire("remove", layer);
					}

					return;
				}
			}
		};

		_proto.pushTransparent = function pushTransparent(layer) {
			if (this._isSublayerAdded(layer, true)) return;
			this.layerList.push(layer);
			this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
			this.subLayerEnabled.push(true);
			this._dirty = true;
			this._dirtyLights = true;
			this._dirtyCameras = true;
			this.fire("add", layer);
		};

		_proto.insertTransparent = function insertTransparent(layer, index) {
			if (this._isSublayerAdded(layer, true)) return;
			this.layerList.splice(index, 0, layer);
			this.subLayerList.splice(index, 0, true);
			var count = this.subLayerList.length;

			this._updateTransparentOrder(index, count - 1);

			this.subLayerEnabled.splice(index, 0, true);
			this._dirty = true;
			this._dirtyLights = true;
			this._dirtyCameras = true;
			this.fire("add", layer);
		};

		_proto.removeTransparent = function removeTransparent(layer) {
			for (var i = 0, len = this.layerList.length; i < len; i++) {
				if (this.layerList[i] === layer && this.subLayerList[i]) {
					this.layerList.splice(i, 1);
					this.subLayerList.splice(i, 1);
					len--;

					this._updateTransparentOrder(i, len - 1);

					this.subLayerEnabled.splice(i, 1);
					this._dirty = true;
					this._dirtyLights = true;
					this._dirtyCameras = true;

					if (this.layerList.indexOf(layer) < 0) {
						this.fire("remove", layer);
					}

					return;
				}
			}
		};

		_proto._getSublayerIndex = function _getSublayerIndex(layer, transparent) {
			var id = this.layerList.indexOf(layer);
			if (id < 0) return -1;

			if (this.subLayerList[id] !== transparent) {
				id = this.layerList.indexOf(layer, id + 1);
				if (id < 0) return -1;

				if (this.subLayerList[id] !== transparent) {
					return -1;
				}
			}

			return id;
		};

		_proto.getOpaqueIndex = function getOpaqueIndex(layer) {
			return this._getSublayerIndex(layer, false);
		};

		_proto.getTransparentIndex = function getTransparentIndex(layer) {
			return this._getSublayerIndex(layer, true);
		};

		_proto.getLayerById = function getLayerById(id) {
			for (var i = 0; i < this.layerList.length; i++) {
				if (this.layerList[i].id === id) return this.layerList[i];
			}

			return null;
		};

		_proto.getLayerByName = function getLayerByName(name) {
			for (var i = 0; i < this.layerList.length; i++) {
				if (this.layerList[i].name === name) return this.layerList[i];
			}

			return null;
		};

		_proto._updateOpaqueOrder = function _updateOpaqueOrder(startIndex, endIndex) {
			for (var i = startIndex; i <= endIndex; i++) {
				if (this.subLayerList[i] === false) {
					this._opaqueOrder[this.layerList[i].id] = i;
				}
			}
		};

		_proto._updateTransparentOrder = function _updateTransparentOrder(startIndex, endIndex) {
			for (var i = startIndex; i <= endIndex; i++) {
				if (this.subLayerList[i] === true) {
					this._transparentOrder[this.layerList[i].id] = i;
				}
			}
		};

		_proto._sortLayersDescending = function _sortLayersDescending(layersA, layersB, order) {
			var topLayerA = -1;
			var topLayerB = -1;

			for (var i = 0, len = layersA.length; i < len; i++) {
				var id = layersA[i];

				if (order.hasOwnProperty(id)) {
					topLayerA = Math.max(topLayerA, order[id]);
				}
			}

			for (var _i6 = 0, _len = layersB.length; _i6 < _len; _i6++) {
				var _id = layersB[_i6];

				if (order.hasOwnProperty(_id)) {
					topLayerB = Math.max(topLayerB, order[_id]);
				}
			}

			if (topLayerA === -1 && topLayerB !== -1) {
				return 1;
			} else if (topLayerB === -1 && topLayerA !== -1) {
				return -1;
			}

			return topLayerB - topLayerA;
		};

		_proto.sortTransparentLayers = function sortTransparentLayers(layersA, layersB) {
			return this._sortLayersDescending(layersA, layersB, this._transparentOrder);
		};

		_proto.sortOpaqueLayers = function sortOpaqueLayers(layersA, layersB) {
			return this._sortLayersDescending(layersA, layersB, this._opaqueOrder);
		};

		return LayerComposition;
	}(EventHandler);

	var spotCenter = new Vec3();
	var spotEndPoint = new Vec3();
	var tmpVec = new Vec3();
	var tmpBiases = {
		bias: 0,
		normalBias: 0
	};
	var chanId = {
		r: 0,
		g: 1,
		b: 2,
		a: 3
	};
	var directionalCascades = [[new Vec4(0, 0, 1, 1)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5), new Vec4(0.5, 0.5, 0.5, 0.5)]];
	var id = 0;

	var LightRenderData = function () {
		function LightRenderData(device, camera, face, light) {
			this.light = light;
			this.camera = camera;
			this.shadowCamera = ShadowRenderer.createShadowCamera(device, light._shadowType, light._type, face);
			this.shadowMatrix = new Mat4();
			this.shadowViewport = new Vec4(0, 0, 1, 1);
			this.shadowScissor = new Vec4(0, 0, 1, 1);
			this.face = face;
			this.visibleCasters = [];
		}

		_createClass(LightRenderData, [{
			key: "shadowBuffer",
			get: function get() {
				var rt = this.shadowCamera.renderTarget;

				if (rt) {
					var light = this.light;

					if (light._type === LIGHTTYPE_OMNI) {
						return rt.colorBuffer;
					}

					return light._isPcf && light.device.webgl2 ? rt.depthBuffer : rt.colorBuffer;
				}

				return null;
			}
		}]);

		return LightRenderData;
	}();

	var Light = function () {
		function Light(graphicsDevice) {
			this.device = graphicsDevice;
			this.id = id++;
			this._type = LIGHTTYPE_DIRECTIONAL;
			this._color = new Color(0.8, 0.8, 0.8);
			this._intensity = 1;
			this._castShadows = false;
			this._enabled = false;
			this.mask = MASK_AFFECT_DYNAMIC;
			this.isStatic = false;
			this.key = 0;
			this.bakeDir = true;
			this.bakeNumSamples = 1;
			this.bakeArea = 0;
			this.attenuationStart = 10;
			this.attenuationEnd = 10;
			this._falloffMode = LIGHTFALLOFF_LINEAR;
			this._shadowType = SHADOW_PCF3;
			this._vsmBlurSize = 11;
			this.vsmBlurMode = BLUR_GAUSSIAN;
			this.vsmBias = 0.01 * 0.25;
			this._cookie = null;
			this.cookieIntensity = 1;
			this._cookieFalloff = true;
			this._cookieChannel = "rgb";
			this._cookieTransform = null;
			this._cookieTransformUniform = new Float32Array(4);
			this._cookieOffset = null;
			this._cookieOffsetUniform = new Float32Array(2);
			this._cookieTransformSet = false;
			this._cookieOffsetSet = false;
			this._innerConeAngle = 40;
			this._outerConeAngle = 45;
			this.cascades = null;
			this._shadowMatrixPalette = null;
			this._shadowCascadeDistances = null;
			this.numCascades = 1;
			this.cascadeDistribution = 0.5;
			this._shape = LIGHTSHAPE_PUNCTUAL;
			this._finalColor = new Float32Array([0.8, 0.8, 0.8]);
			var c = Math.pow(this._finalColor[0], 2.2);
			this._linearFinalColor = new Float32Array([c, c, c]);
			this._position = new Vec3(0, 0, 0);
			this._direction = new Vec3(0, 0, 0);
			this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
			this._outerConeAngleCos = Math.cos(this._outerConeAngle * Math.PI / 180);
			this._shadowMap = null;
			this._shadowRenderParams = [];
			this.shadowDistance = 40;
			this._shadowResolution = 1024;
			this.shadowBias = -0.0005;
			this._normalOffsetBias = 0.0;
			this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
			this._isVsm = false;
			this._isPcf = true;
			this._cookieMatrix = null;
			this._atlasViewport = null;
			this.atlasViewportAllocated = false;
			this.atlasVersion = 0;
			this.atlasSlotIndex = 0;
			this.atlasSlotUpdated = false;
			this._scene = null;
			this._node = null;
			this._renderData = [];
			this.visibleThisFrame = false;
			this.maxScreenSize = 0;
		}

		var _proto = Light.prototype;

		_proto.destroy = function destroy() {
			this._destroyShadowMap();

			this._renderData = null;
		};

		_proto.beginFrame = function beginFrame() {
			this.visibleThisFrame = this._type === LIGHTTYPE_DIRECTIONAL && this._enabled;
			this.maxScreenSize = 0;
			this.atlasViewportAllocated = false;
			this.atlasSlotUpdated = false;
		};

		_proto._destroyShadowMap = function _destroyShadowMap() {
			if (this._renderData) {
				this._renderData.length = 0;
			}

			if (this._shadowMap) {
				if (!this._shadowMap.cached) {
					this._shadowMap.destroy();
				}

				this._shadowMap = null;
			}

			if (this.shadowUpdateMode === SHADOWUPDATE_NONE) {
				this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
			}
		};

		_proto.getRenderData = function getRenderData(camera, face) {
			for (var i = 0; i < this._renderData.length; i++) {
				var current = this._renderData[i];

				if (current.camera === camera && current.face === face) {
					return current;
				}
			}

			var rd = new LightRenderData(this.device, camera, face, this);

			this._renderData.push(rd);

			return rd;
		};

		_proto.clone = function clone() {
			var clone = new Light(this.device);
			clone.type = this._type;
			clone.setColor(this._color);
			clone.intensity = this._intensity;
			clone.castShadows = this.castShadows;
			clone._enabled = this._enabled;
			clone.attenuationStart = this.attenuationStart;
			clone.attenuationEnd = this.attenuationEnd;
			clone.falloffMode = this._falloffMode;
			clone.shadowType = this._shadowType;
			clone.vsmBlurSize = this._vsmBlurSize;
			clone.vsmBlurMode = this.vsmBlurMode;
			clone.vsmBias = this.vsmBias;
			clone.shadowUpdateMode = this.shadowUpdateMode;
			clone.mask = this.mask;
			clone.innerConeAngle = this._innerConeAngle;
			clone.outerConeAngle = this._outerConeAngle;
			clone.numCascades = this.numCascades;
			clone.cascadeDistribution = this.cascadeDistribution;
			clone.shape = this._shape;
			clone.shadowBias = this.shadowBias;
			clone.normalOffsetBias = this._normalOffsetBias;
			clone.shadowResolution = this._shadowResolution;
			clone.shadowDistance = this.shadowDistance;
			return clone;
		};

		_proto._getUniformBiasValues = function _getUniformBiasValues(lightRenderData) {
			var farClip = lightRenderData.shadowCamera._farClip;

			switch (this._type) {
				case LIGHTTYPE_OMNI:
					tmpBiases.bias = this.shadowBias;
					tmpBiases.normalBias = this._normalOffsetBias;
					break;

				case LIGHTTYPE_SPOT:
					if (this._isVsm) {
						tmpBiases.bias = -0.00001 * 20;
					} else {
						tmpBiases.bias = this.shadowBias * 20;
						if (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;
					}

					tmpBiases.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7.0) : this._normalOffsetBias;
					break;

				case LIGHTTYPE_DIRECTIONAL:
					if (this._isVsm) {
						tmpBiases.bias = -0.00001 * 20;
					} else {
						tmpBiases.bias = this.shadowBias / farClip * 100;
						if (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;
					}

					tmpBiases.normalBias = this._isVsm ? this.vsmBias / (farClip / 7.0) : this._normalOffsetBias;
					break;
			}

			return tmpBiases;
		};

		_proto.getColor = function getColor() {
			return this._color;
		};

		_proto.getBoundingSphere = function getBoundingSphere(sphere) {
			if (this._type === LIGHTTYPE_SPOT) {
				var range = this.attenuationEnd;
				var angle = this._outerConeAngle;
				var f = Math.cos(angle * math.DEG_TO_RAD);
				var node = this._node;
				spotCenter.copy(node.up);
				spotCenter.mulScalar(-range * 0.5 * f);
				spotCenter.add(node.getPosition());
				sphere.center = spotCenter;
				spotEndPoint.copy(node.up);
				spotEndPoint.mulScalar(-range);
				tmpVec.copy(node.right);
				tmpVec.mulScalar(Math.sin(angle * math.DEG_TO_RAD) * range);
				spotEndPoint.add(tmpVec);
				sphere.radius = spotEndPoint.length() * 0.5;
			} else if (this._type === LIGHTTYPE_OMNI) {
				sphere.center = this._node.getPosition();
				sphere.radius = this.attenuationEnd;
			}
		};

		_proto.getBoundingBox = function getBoundingBox(box) {
			if (this._type === LIGHTTYPE_SPOT) {
				var range = this.attenuationEnd;
				var angle = this._outerConeAngle;
				var node = this._node;
				var scl = Math.abs(Math.sin(angle * math.DEG_TO_RAD) * range);
				box.center.set(0, -range * 0.5, 0);
				box.halfExtents.set(scl, range * 0.5, scl);
				box.setFromTransformedAabb(box, node.getWorldTransform(), true);
			} else if (this._type === LIGHTTYPE_OMNI) {
				box.center.copy(this._node.getPosition());
				box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);
			}
		};

		_proto._updateFinalColor = function _updateFinalColor() {
			var color = this._color;
			var r = color.r;
			var g = color.g;
			var b = color.b;
			var i = this._intensity;
			var finalColor = this._finalColor;
			var linearFinalColor = this._linearFinalColor;
			finalColor[0] = r * i;
			finalColor[1] = g * i;
			finalColor[2] = b * i;

			if (i >= 1) {
				linearFinalColor[0] = Math.pow(r, 2.2) * i;
				linearFinalColor[1] = Math.pow(g, 2.2) * i;
				linearFinalColor[2] = Math.pow(b, 2.2) * i;
			} else {
				linearFinalColor[0] = Math.pow(finalColor[0], 2.2);
				linearFinalColor[1] = Math.pow(finalColor[1], 2.2);
				linearFinalColor[2] = Math.pow(finalColor[2], 2.2);
			}
		};

		_proto.setColor = function setColor() {
			if (arguments.length === 1) {
				this._color.set(arguments[0].r, arguments[0].g, arguments[0].b);
			} else if (arguments.length === 3) {
				this._color.set(arguments[0], arguments[1], arguments[2]);
			}

			this._updateFinalColor();
		};

		_proto.updateShadow = function updateShadow() {
			if (this.shadowUpdateMode !== SHADOWUPDATE_REALTIME) {
				this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
			}
		};

		_proto.layersDirty = function layersDirty() {
			var _this$_scene;

			if ((_this$_scene = this._scene) != null && _this$_scene.layers) {
				this._scene.layers._dirtyLights = true;
			}
		};

		_proto.updateKey = function updateKey() {
			var key = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | this.numCascades - 1 << 8;

			if (this._cookieChannel.length === 3) {
				key |= chanId[this._cookieChannel.charAt(1)] << 16;
				key |= chanId[this._cookieChannel.charAt(2)] << 14;
			}

			if (key !== this.key && this._scene !== null) {
				this.layersDirty();
			}

			this.key = key;
		};

		_createClass(Light, [{
			key: "numCascades",
			get: function get() {
				return this.cascades.length;
			},
			set: function set(value) {
				if (!this.cascades || this.numCascades != value) {
					this.cascades = directionalCascades[value - 1];
					this._shadowMatrixPalette = new Float32Array(4 * 16);
					this._shadowCascadeDistances = new Float32Array(4);

					this._destroyShadowMap();

					this.updateKey();
				}
			}
		}, {
			key: "shadowMap",
			get: function get() {
				return this._shadowMap;
			},
			set: function set(shadowMap) {
				if (this._shadowMap !== shadowMap) {
					this._destroyShadowMap();

					this._shadowMap = shadowMap;
				}
			}
		}, {
			key: "numShadowFaces",
			get: function get() {
				var type = this._type;

				if (type === LIGHTTYPE_DIRECTIONAL) {
					return this.numCascades;
				} else if (type === LIGHTTYPE_OMNI) {
					return 6;
				}

				return 1;
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (this._type === value) return;
				this._type = value;

				this._destroyShadowMap();

				this.updateKey();
				var stype = this._shadowType;
				this._shadowType = null;
				this.shadowType = stype;
			}
		}, {
			key: "shape",
			get: function get() {
				return this._shape;
			},
			set: function set(value) {
				if (this._shape === value) return;
				this._shape = value;

				this._destroyShadowMap();

				this.updateKey();
				var stype = this._shadowType;
				this._shadowType = null;
				this.shadowType = stype;
			}
		}, {
			key: "shadowType",
			get: function get() {
				return this._shadowType;
			},
			set: function set(value) {
				if (this._shadowType === value) return;
				var device = this.device;
				if (this._type === LIGHTTYPE_OMNI) value = SHADOW_PCF3;

				if (value === SHADOW_PCF5 && !device.webgl2) {
					value = SHADOW_PCF3;
				}

				if (value === SHADOW_VSM32 && !device.textureFloatRenderable) value = SHADOW_VSM16;
				if (value === SHADOW_VSM16 && !device.textureHalfFloatRenderable) value = SHADOW_VSM8;
				this._isVsm = value >= SHADOW_VSM8 && value <= SHADOW_VSM32;
				this._isPcf = value === SHADOW_PCF5 || value === SHADOW_PCF3;
				this._shadowType = value;

				this._destroyShadowMap();

				this.updateKey();
			}
		}, {
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				if (this._enabled !== value) {
					this._enabled = value;
					this.layersDirty();
				}
			}
		}, {
			key: "castShadows",
			get: function get() {
				return this._castShadows && this.mask !== MASK_BAKE && this.mask !== 0;
			},
			set: function set(value) {
				if (this._castShadows !== value) {
					this._castShadows = value;

					this._destroyShadowMap();

					this.layersDirty();
					this.updateKey();
				}
			}
		}, {
			key: "shadowResolution",
			get: function get() {
				return this._shadowResolution;
			},
			set: function set(value) {
				if (this._shadowResolution !== value) {
					if (this._type === LIGHTTYPE_OMNI) {
						value = Math.min(value, this.device.maxCubeMapSize);
					} else {
						value = Math.min(value, this.device.maxTextureSize);
					}

					this._shadowResolution = value;

					this._destroyShadowMap();
				}
			}
		}, {
			key: "vsmBlurSize",
			get: function get() {
				return this._vsmBlurSize;
			},
			set: function set(value) {
				if (this._vsmBlurSize === value) return;
				if (value % 2 === 0) value++;
				this._vsmBlurSize = value;
			}
		}, {
			key: "normalOffsetBias",
			get: function get() {
				return this._normalOffsetBias;
			},
			set: function set(value) {
				if (this._normalOffsetBias === value) return;

				if (!this._normalOffsetBias && value || this._normalOffsetBias && !value) {
					this.updateKey();
				}

				this._normalOffsetBias = value;
			}
		}, {
			key: "falloffMode",
			get: function get() {
				return this._falloffMode;
			},
			set: function set(value) {
				if (this._falloffMode === value) return;
				this._falloffMode = value;
				this.updateKey();
			}
		}, {
			key: "innerConeAngle",
			get: function get() {
				return this._innerConeAngle;
			},
			set: function set(value) {
				if (this._innerConeAngle === value) return;
				this._innerConeAngle = value;
				this._innerConeAngleCos = Math.cos(value * Math.PI / 180);
			}
		}, {
			key: "outerConeAngle",
			get: function get() {
				return this._outerConeAngle;
			},
			set: function set(value) {
				if (this._outerConeAngle === value) return;
				this._outerConeAngle = value;
				this._outerConeAngleCos = Math.cos(value * Math.PI / 180);
			}
		}, {
			key: "intensity",
			get: function get() {
				return this._intensity;
			},
			set: function set(value) {
				if (this._intensity !== value) {
					this._intensity = value;

					this._updateFinalColor();
				}
			}
		}, {
			key: "cookieMatrix",
			get: function get() {
				if (!this._cookieMatrix) {
					this._cookieMatrix = new Mat4();
				}

				return this._cookieMatrix;
			}
		}, {
			key: "atlasViewport",
			get: function get() {
				if (!this._atlasViewport) {
					this._atlasViewport = new Vec4(0, 0, 1, 1);
				}

				return this._atlasViewport;
			}
		}, {
			key: "cookie",
			get: function get() {
				return this._cookie;
			},
			set: function set(value) {
				if (this._cookie === value) return;
				this._cookie = value;
				this.updateKey();
			}
		}, {
			key: "cookieFalloff",
			get: function get() {
				return this._cookieFalloff;
			},
			set: function set(value) {
				if (this._cookieFalloff === value) return;
				this._cookieFalloff = value;
				this.updateKey();
			}
		}, {
			key: "cookieChannel",
			get: function get() {
				return this._cookieChannel;
			},
			set: function set(value) {
				if (this._cookieChannel === value) return;

				if (value.length < 3) {
					var chr = value.charAt(value.length - 1);
					var addLen = 3 - value.length;

					for (var i = 0; i < addLen; i++) {
						value += chr;
					}
				}

				this._cookieChannel = value;
				this.updateKey();
			}
		}, {
			key: "cookieTransform",
			get: function get() {
				return this._cookieTransform;
			},
			set: function set(value) {
				if (this._cookieTransform === value) return;
				this._cookieTransform = value;
				this._cookieTransformSet = !!value;

				if (value && !this._cookieOffset) {
					this.cookieOffset = new Vec2();
					this._cookieOffsetSet = false;
				}

				this.updateKey();
			}
		}, {
			key: "cookieOffset",
			get: function get() {
				return this._cookieOffset;
			},
			set: function set(value) {
				if (this._cookieOffset === value) return;
				var xformNew = !!(this._cookieTransformSet || value);

				if (xformNew && !value && this._cookieOffset) {
					this._cookieOffset.set(0, 0);
				} else {
					this._cookieOffset = value;
				}

				this._cookieOffsetSet = !!value;

				if (value && !this._cookieTransform) {
					this.cookieTransform = new Vec4(1, 1, 0, 0);
					this._cookieTransformSet = false;
				}

				this.updateKey();
			}
		}]);

		return Light;
	}();

	var LightingParams = function () {
		function LightingParams(supportsAreaLights, maxTextureSize, dirtyLightsFnc) {
			this._maxTextureSize = maxTextureSize;
			this._supportsAreaLights = supportsAreaLights;
			this._dirtyLightsFnc = dirtyLightsFnc;
			this._areaLightsEnabled = false;
			this._cells = new Vec3(10, 3, 10);
			this._maxLightsPerCell = 255;
			this._shadowsEnabled = true;
			this._shadowType = SHADOW_PCF3;
			this._shadowAtlasResolution = 2048;
			this._cookiesEnabled = false;
			this._cookieAtlasResolution = 2048;
			this.atlasSplit = null;
			this.debugLayer = undefined;
		}

		_createClass(LightingParams, [{
			key: "cells",
			get: function get() {
				return this._cells;
			},
			set: function set(value) {
				this._cells.copy(value);
			}
		}, {
			key: "maxLightsPerCell",
			get: function get() {
				return this._maxLightsPerCell;
			},
			set: function set(value) {
				this._maxLightsPerCell = math.clamp(value, 1, 255);
			}
		}, {
			key: "cookieAtlasResolution",
			get: function get() {
				return this._cookieAtlasResolution;
			},
			set: function set(value) {
				this._cookieAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
			}
		}, {
			key: "shadowAtlasResolution",
			get: function get() {
				return this._shadowAtlasResolution;
			},
			set: function set(value) {
				this._shadowAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
			}
		}, {
			key: "shadowType",
			get: function get() {
				return this._shadowType;
			},
			set: function set(value) {
				if (this._shadowType !== value) {
					this._shadowType = value;

					this._dirtyLightsFnc();
				}
			}
		}, {
			key: "cookiesEnabled",
			get: function get() {
				return this._cookiesEnabled;
			},
			set: function set(value) {
				if (this._cookiesEnabled !== value) {
					this._cookiesEnabled = value;

					this._dirtyLightsFnc();
				}
			}
		}, {
			key: "areaLightsEnabled",
			get: function get() {
				return this._areaLightsEnabled;
			},
			set: function set(value) {
				if (this._supportsAreaLights) {
					if (this._areaLightsEnabled !== value) {
						this._areaLightsEnabled = value;

						this._dirtyLightsFnc();
					}
				}
			}
		}, {
			key: "shadowsEnabled",
			get: function get() {
				return this._shadowsEnabled;
			},
			set: function set(value) {
				if (this._shadowsEnabled !== value) {
					this._shadowsEnabled = value;

					this._dirtyLightsFnc();
				}
			}
		}]);

		return LightingParams;
	}();

	var tempSphere = new BoundingSphere();

	var BakeLight = function () {
		function BakeLight(scene, light) {
			this.scene = scene;
			this.light = light;
			this.store();
			light.numCascades = 1;

			if (light.type !== LIGHTTYPE_DIRECTIONAL) {
				light._node.getWorldTransform();

				light.getBoundingSphere(tempSphere);
				this.lightBounds = new BoundingBox();
				this.lightBounds.center.copy(tempSphere.center);
				this.lightBounds.halfExtents.set(tempSphere.radius, tempSphere.radius, tempSphere.radius);
			}
		}

		var _proto = BakeLight.prototype;

		_proto.store = function store() {
			this.mask = this.light.mask;
			this.shadowUpdateMode = this.light.shadowUpdateMode;
			this.enabled = this.light.enabled;
			this.intensity = this.light.intensity;
			this.rotation = this.light._node.getLocalRotation().clone();
			this.numCascades = this.light.numCascades;
		};

		_proto.restore = function restore() {
			var light = this.light;
			light.mask = this.mask;
			light.shadowUpdateMode = this.shadowUpdateMode;
			light.enabled = this.enabled;
			light.intensity = this.intensity;

			light._node.setLocalRotation(this.rotation);

			light.numCascades = this.numCascades;
		};

		_proto.startBake = function startBake() {
			this.light.enabled = true;

			this.light._destroyShadowMap();
		};

		_proto.endBake = function endBake(shadowMapCache) {
			var light = this.light;
			light.enabled = false;

			if (light.shadowMap) {
				if (light.shadowMap.cached) shadowMapCache.add(light, light.shadowMap);
				light.shadowMap = null;
			}
		};

		return BakeLight;
	}();

	var _tempPoint$1 = new Vec2();

	var BakeLightSimple = function (_BakeLight) {
		_inheritsLoose(BakeLightSimple, _BakeLight);

		function BakeLightSimple() {
			return _BakeLight.apply(this, arguments) || this;
		}

		var _proto = BakeLightSimple.prototype;

		_proto.prepareVirtualLight = function prepareVirtualLight(index, numVirtualLights) {
			var light = this.light;

			light._node.setLocalRotation(this.rotation);

			if (index > 0) {
				var directionalSpreadAngle = light.bakeArea;
				random.circlePointDeterministic(_tempPoint$1, index, numVirtualLights);

				_tempPoint$1.mulScalar(directionalSpreadAngle * 0.5);

				light._node.rotateLocal(_tempPoint$1.x, 0, _tempPoint$1.y);
			}

			light._node.getWorldTransform();

			var gamma = this.scene.gammaCorrection ? 2.2 : 1;
			var linearIntensity = Math.pow(this.intensity, gamma);
			light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
		};

		_createClass(BakeLightSimple, [{
			key: "numVirtualLights",
			get: function get() {
				if (this.light.type === LIGHTTYPE_DIRECTIONAL) {
					return this.light.bakeNumSamples;
				}

				return 1;
			}
		}]);

		return BakeLightSimple;
	}(BakeLight);

	var AreaLightCacheEntry = function () {
		function AreaLightCacheEntry(texture0, texture1) {
			this.texture0 = texture0;
			this.texture1 = texture1;
		}

		var _proto = AreaLightCacheEntry.prototype;

		_proto.destroy = function destroy() {
			var _this$texture, _this$texture2;

			(_this$texture = this.texture0) == null ? void 0 : _this$texture.destroy();
			(_this$texture2 = this.texture1) == null ? void 0 : _this$texture2.destroy();
		};

		return AreaLightCacheEntry;
	}();

	var deviceCache = new DeviceCache();

	var AreaLightLuts = function () {
		function AreaLightLuts() {}

		AreaLightLuts.createTexture = function createTexture(device, format, size, postfix) {
			if (postfix === void 0) {
				postfix = "";
			}

			var tex = new Texture(device, {
				width: size,
				height: size,
				format: format,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				type: TEXTURETYPE_DEFAULT,
				magFilter: FILTER_LINEAR,
				minFilter: FILTER_NEAREST,
				anisotropy: 1
			});
			tex.name = "AreaLightLUT" + postfix;
			return tex;
		};

		AreaLightLuts.applyTextures = function applyTextures(device, texture1, texture2) {
			deviceCache.remove(device);
			deviceCache.get(device, function () {
				return new AreaLightCacheEntry(texture1, texture1 === texture2 ? null : texture2);
			});
			device.scope.resolve('areaLightsLutTex1').setValue(texture1);
			device.scope.resolve('areaLightsLutTex2').setValue(texture2);
		};

		AreaLightLuts.createPlaceholder = function createPlaceholder(device) {
			var texture = AreaLightLuts.createTexture(device, PIXELFORMAT_R8_G8_B8_A8, 2, "placeholder");
			var pixels = texture.lock();
			pixels.fill(0);
			texture.unlock();
			AreaLightLuts.applyTextures(device, texture, texture);
		};

		AreaLightLuts.set = function set(device, resource) {
			function buildTexture(device, data, format) {
				var texture = AreaLightLuts.createTexture(device, format, 64);
				texture.lock().set(data);
				texture.unlock();
				texture.upload();
				return texture;
			}

			function offsetScale(data, offset, scale) {
				var count = data.length;
				var ret = new Float32Array(count);

				for (var i = 0; i < count; i++) {
					var n = i % 4;
					ret[i] = (data[i] + offset[n]) * scale[n];
				}

				return ret;
			}

			function convertToHalfFloat(data) {
				var count = data.length;
				var ret = new Uint16Array(count);
				var float2Half = FloatPacking.float2Half;

				for (var i = 0; i < count; i++) {
					ret[i] = float2Half(data[i]);
				}

				return ret;
			}

			function convertToUint(data) {
				var count = data.length;
				var ret = new Uint8ClampedArray(count);

				for (var i = 0; i < count; i++) {
					ret[i] = data[i] * 255;
				}

				return ret;
			}

			var versions = new Int16Array(resource, 0, 2);
			var majorVersion = versions[0];
			var minorVersion = versions[1];

			if (majorVersion !== 0 || minorVersion !== 1) {
				Debug.warn("areaLightLuts asset version: " + majorVersion + "." + minorVersion + " is not supported in current engine version!");
			} else {
				var srcData1 = new Float32Array(resource, 4, 16384);
				var srcData2 = new Float32Array(resource, 4 + 16384 * 4, 16384);
				var data1, data2;
				var format = device.areaLightLutFormat;

				if (format === PIXELFORMAT_RGBA32F) {
					data1 = srcData1;
					data2 = srcData2;
				} else if (format === PIXELFORMAT_RGBA16F) {
					data1 = convertToHalfFloat(srcData1);
					data2 = convertToHalfFloat(srcData2);
				} else {
					var o1 = [0.0, 0.2976, 0.01381, 0.0];
					var s1 = [0.999, 3.08737, 1.6546, 0.603249];
					var o2 = [-0.306897, 0.0, 0.0, 0.0];
					var s2 = [1.442787, 1.0, 1.0, 1.0];
					data1 = convertToUint(offsetScale(srcData1, o1, s1));
					data2 = convertToUint(offsetScale(srcData2, o2, s2));
				}

				var tex1 = buildTexture(device, data1, format);
				var tex2 = buildTexture(device, data2, format);
				AreaLightLuts.applyTextures(device, tex1, tex2);
			}
		};

		return AreaLightLuts;
	}();

	var _floatRounding = 0.2;

	var Morph = function (_RefCountedObject) {
		_inheritsLoose(Morph, _RefCountedObject);

		function Morph(targets, graphicsDevice) {
			var _this;

			_this = _RefCountedObject.call(this) || this;
			_this.device = graphicsDevice || getApplication().graphicsDevice;
			_this._targets = targets;

			if (_this.device.supportsMorphTargetTexturesCore) {
				if (_this.device.extTextureHalfFloat && _this.device.textureHalfFloatRenderable) {
					_this._renderTextureFormat = Morph.FORMAT_HALF_FLOAT;
				} else if (_this.device.extTextureFloat && _this.device.textureFloatRenderable) {
					_this._renderTextureFormat = Morph.FORMAT_FLOAT;
				}

				if (_this.device.extTextureHalfFloat && _this.device.textureHalfFloatUpdatable) {
					_this._textureFormat = Morph.FORMAT_HALF_FLOAT;
				} else if (_this.device.extTextureFloat) {
					_this._textureFormat = Morph.FORMAT_FLOAT;
				}

				if (_this._renderTextureFormat !== undefined && _this._textureFormat !== undefined) {
					_this._useTextureMorph = true;
				}
			}

			_this._init();

			_this._updateMorphFlags();

			_this._calculateAabb();

			return _this;
		}

		var _proto = Morph.prototype;

		_proto._init = function _init() {
			if (this._useTextureMorph) {
				this._useTextureMorph = this._initTextureBased();
			}

			if (!this._useTextureMorph) {
				for (var i = 0; i < this._targets.length; i++) {
					this._targets[i]._initVertexBuffers(this.device);
				}
			}

			for (var _i = 0; _i < this._targets.length; _i++) {
				this._targets[_i]._postInit();
			}
		};

		_proto._initTextureBased = function _initTextureBased() {
			var deltaArrays = [],
					deltaInfos = [];

			for (var i = 0; i < this._targets.length; i++) {
				var target = this._targets[i];

				if (target.options.deltaPositions) {
					deltaArrays.push(target.options.deltaPositions);
					deltaInfos.push({
						target: target,
						name: 'texturePositions'
					});
				}

				if (target.options.deltaNormals) {
					deltaArrays.push(target.options.deltaNormals);
					deltaInfos.push({
						target: target,
						name: 'textureNormals'
					});
				}
			}

			var ids = [],
					usedDataIndices = [];
			var freeIndex = 1;
			var dataCount = deltaArrays[0].length;

			for (var v = 0; v < dataCount; v += 3) {
				var vertexUsed = false;

				for (var _i2 = 0; _i2 < deltaArrays.length; _i2++) {
					var data = deltaArrays[_i2];

					if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {
						vertexUsed = true;
						break;
					}
				}

				if (vertexUsed) {
					ids.push(freeIndex + _floatRounding);
					usedDataIndices.push(v / 3);
					freeIndex++;
				} else {
					ids.push(0 + _floatRounding);
				}
			}

			var maxTextureSize = Math.min(this.device.maxTextureSize, 4096);
			var morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
			morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
			var morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);

			if (morphTextureHeight > maxTextureSize) {
				return false;
			}

			this.morphTextureWidth = morphTextureWidth;
			this.morphTextureHeight = morphTextureHeight;
			var halfFloat = false;
			var numComponents = 3;
			var float2Half = FloatPacking.float2Half;

			if (this._textureFormat === Morph.FORMAT_HALF_FLOAT) {
				halfFloat = true;
				numComponents = 4;
			}

			var arraySize = this.morphTextureWidth * this.morphTextureHeight * numComponents;
			var packedDeltas = halfFloat ? new Uint16Array(arraySize) : new Float32Array(arraySize);

			for (var _i3 = 0; _i3 < deltaArrays.length; _i3++) {
				var _data = deltaArrays[_i3];

				for (var _v = 0; _v < usedDataIndices.length; _v++) {
					var index = usedDataIndices[_v];

					if (halfFloat) {
						packedDeltas[_v * numComponents + numComponents] = float2Half(_data[index * 3]);
						packedDeltas[_v * numComponents + numComponents + 1] = float2Half(_data[index * 3 + 1]);
						packedDeltas[_v * numComponents + numComponents + 2] = float2Half(_data[index * 3 + 2]);
					} else {
						packedDeltas[_v * numComponents + numComponents] = _data[index * 3];
						packedDeltas[_v * numComponents + numComponents + 1] = _data[index * 3 + 1];
						packedDeltas[_v * numComponents + numComponents + 2] = _data[index * 3 + 2];
					}
				}

				var _target = deltaInfos[_i3].target;
				var format = this._textureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGB32F : PIXELFORMAT_RGBA16F;

				_target._setTexture(deltaInfos[_i3].name, this._createTexture("MorphTarget", format, packedDeltas));
			}

			var formatDesc = [{
				semantic: SEMANTIC_ATTR15,
				components: 1,
				type: TYPE_FLOAT32
			}];
			this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc), ids.length, BUFFER_STATIC, new Float32Array(ids));
			return true;
		};

		_proto.destroy = function destroy() {
			if (this.vertexBufferIds) {
				this.vertexBufferIds.destroy();
				this.vertexBufferIds = null;
			}

			for (var i = 0; i < this._targets.length; i++) {
				this._targets[i].destroy();
			}

			this._targets.length = 0;
		};

		_proto._updateMorphFlags = function _updateMorphFlags() {
			this._morphPositions = false;
			this._morphNormals = false;

			for (var i = 0; i < this._targets.length; i++) {
				var target = this._targets[i];

				if (target.morphPositions) {
					this._morphPositions = true;
				}

				if (target.morphNormals) {
					this._morphNormals = true;
				}
			}
		};

		_proto._calculateAabb = function _calculateAabb() {
			var min = new Vec3();
			var max = new Vec3();

			for (var i = 0; i < this._targets.length; i++) {
				var targetAabb = this._targets[i].aabb;
				min.min(targetAabb.getMin());
				max.max(targetAabb.getMax());
			}

			this.aabb = new BoundingBox();
			this.aabb.setMinMax(min, max);
		};

		_proto._createTexture = function _createTexture(name, format, pixelData) {
			var texture = new Texture(this.device, {
				width: this.morphTextureWidth,
				height: this.morphTextureHeight,
				format: format,
				cubemap: false,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			texture.name = name;

			if (pixelData) {
				texture.lock().set(pixelData);
				texture.unlock();
			}

			return texture;
		};

		_createClass(Morph, [{
			key: "morphPositions",
			get: function get() {
				return this._morphPositions;
			}
		}, {
			key: "morphNormals",
			get: function get() {
				return this._morphNormals;
			}
		}, {
			key: "maxActiveTargets",
			get: function get() {
				if (this._useTextureMorph) return this._targets.length;
				return this._morphPositions && this._morphNormals ? 4 : 8;
			}
		}, {
			key: "useTextureMorph",
			get: function get() {
				return this._useTextureMorph;
			}
		}, {
			key: "targets",
			get: function get() {
				return this._targets;
			}
		}]);

		return Morph;
	}(RefCountedObject);

	Morph.FORMAT_FLOAT = 0;
	Morph.FORMAT_HALF_FLOAT = 1;

	var textureMorphVertexShader = "\n		attribute vec2 vertex_position;\n		varying vec2 uv0;\n		void main(void) {\n				gl_Position = vec4(vertex_position, 0.5, 1.0);\n				uv0 = vertex_position.xy * 0.5 + 0.5;\n		}\n		";

	var MorphInstance = function () {
		function MorphInstance(morph) {
			var _this = this;

			this.morph = morph;
			morph.incRefCount();
			this.device = morph.device;
			this.meshInstance = null;
			this._weights = [];

			for (var v = 0; v < morph._targets.length; v++) {
				this.setWeight(v, morph._targets[v].defaultWeight);
			}

			this._activeTargets = [];

			if (morph.useTextureMorph) {
				this.shaderCache = {};
				this.maxSubmitCount = this.device.maxTextures;
				this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);

				var createRT = function createRT(name, textureVar) {
					var format = morph._renderTextureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA16F;
					_this[textureVar] = morph._createTexture(name, format);
					return new RenderTarget({
						colorBuffer: _this[textureVar],
						depth: false
					});
				};

				if (morph.morphPositions) {
					this.rtPositions = createRT("MorphRTPos", "texturePositions");
				}

				if (morph.morphNormals) {
					this.rtNormals = createRT("MorphRTNrm", "textureNormals");
				}

				this._textureParams = new Float32Array([morph.morphTextureWidth, morph.morphTextureHeight, 1 / morph.morphTextureWidth, 1 / morph.morphTextureHeight]);

				for (var i = 0; i < this.maxSubmitCount; i++) {
					this["morphBlendTex" + i] = this.device.scope.resolve("morphBlendTex" + i);
				}

				this.morphFactor = this.device.scope.resolve("morphFactor[0]");
				this.zeroTextures = false;
			} else {
				this.maxSubmitCount = 8;
				this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
				this._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer, 0, 4);
				this._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer, 4 * 4, 4);
				this._activeVertexBuffers = new Array(this.maxSubmitCount);
			}
		}

		var _proto = MorphInstance.prototype;

		_proto.destroy = function destroy() {
			this.meshInstance = null;
			this.shader = null;
			var morph = this.morph;

			if (morph) {
				this.morph = null;
				morph.decRefCount();

				if (morph.refCount < 1) {
					morph.destroy();
				}
			}

			if (this.rtPositions) {
				this.rtPositions.destroy();
				this.rtPositions = null;
			}

			if (this.texturePositions) {
				this.texturePositions.destroy();
				this.texturePositions = null;
			}

			if (this.rtNormals) {
				this.rtNormals.destroy();
				this.rtNormals = null;
			}

			if (this.textureNormals) {
				this.textureNormals.destroy();
				this.textureNormals = null;
			}
		};

		_proto.clone = function clone() {
			var clone = new MorphInstance(this.morph);
			return clone;
		};

		_proto.getWeight = function getWeight(index) {
			return this._weights[index];
		};

		_proto.setWeight = function setWeight(index, weight) {
			this._weights[index] = weight;
			this._dirty = true;
		};

		_proto._getFragmentShader = function _getFragmentShader(numTextures) {
			var fragmentShader = '';

			if (numTextures > 0) {
				fragmentShader += 'varying vec2 uv0;\n' + 'uniform highp float morphFactor[' + numTextures + '];\n';
			}

			for (var i = 0; i < numTextures; i++) {
				fragmentShader += 'uniform highp sampler2D morphBlendTex' + i + ';\n';
			}

			fragmentShader += 'void main (void) {\n' + '		highp vec4 color = vec4(0, 0, 0, 1);\n';

			for (var _i = 0; _i < numTextures; _i++) {
				fragmentShader += '		color.xyz += morphFactor[' + _i + '] * texture2D(morphBlendTex' + _i + ', uv0).xyz;\n';
			}

			fragmentShader += '		gl_FragColor = color;\n' + '}\n';
			return fragmentShader;
		};

		_proto._getShader = function _getShader(count) {
			var shader = this.shaderCache[count];

			if (!shader) {
				var fs = this._getFragmentShader(count);

				shader = createShaderFromCode(this.device, textureMorphVertexShader, fs, "textureMorph" + count);
				this.shaderCache[count] = shader;
			}

			return shader;
		};

		_proto._updateTextureRenderTarget = function _updateTextureRenderTarget(renderTarget, srcTextureName) {
			var _this2 = this;

			var device = this.device;

			var submitBatch = function submitBatch(usedCount, blending) {
				_this2.morphFactor.setValue(_this2._shaderMorphWeights);

				device.setBlending(blending);

				if (blending) {
					device.setBlendFunction(BLENDMODE_ONE, BLENDMODE_ONE);
					device.setBlendEquation(BLENDEQUATION_ADD);
				}

				var shader = _this2._getShader(usedCount);

				drawQuadWithShader(device, renderTarget, shader, undefined, undefined, blending);
			};

			var usedCount = 0;
			var blending = false;
			var count = this._activeTargets.length;

			for (var i = 0; i < count; i++) {
				var activeTarget = this._activeTargets[i];
				var tex = activeTarget.target[srcTextureName];

				if (tex) {
					this["morphBlendTex" + usedCount].setValue(tex);
					this._shaderMorphWeights[usedCount] = activeTarget.weight;
					usedCount++;

					if (usedCount >= this.maxSubmitCount) {
						submitBatch(usedCount, blending);
						usedCount = 0;
						blending = true;
					}
				}
			}

			if (usedCount > 0 || count === 0 && !this.zeroTextures) {
				submitBatch(usedCount, blending);
			}
		};

		_proto._updateTextureMorph = function _updateTextureMorph() {
			var device = this.device;
			DebugGraphics.pushGpuMarker(device, "MorphUpdate");

			if (this._activeTargets.length > 0 || !this.zeroTextures) {
				this._updateTextureRenderTarget(this.rtPositions, 'texturePositions');

				this._updateTextureRenderTarget(this.rtNormals, 'textureNormals');

				this.zeroTextures = this._activeTargets.length === 0;
			}

			DebugGraphics.popGpuMarker(device);
		};

		_proto._updateVertexMorph = function _updateVertexMorph() {
			var count = this.maxSubmitCount;

			for (var i = 0; i < count; i++) {
				this._shaderMorphWeights[i] = 0;
				this._activeVertexBuffers[i] = null;
			}

			var posIndex = 0;
			var nrmIndex = this.morph.morphPositions ? 4 : 0;

			for (var _i2 = 0; _i2 < this._activeTargets.length; _i2++) {
				var target = this._activeTargets[_i2].target;

				if (target._vertexBufferPositions) {
					this._activeVertexBuffers[posIndex] = target._vertexBufferPositions;
					this._shaderMorphWeights[posIndex] = this._activeTargets[_i2].weight;
					posIndex++;
				}

				if (target._vertexBufferNormals) {
					this._activeVertexBuffers[nrmIndex] = target._vertexBufferNormals;
					this._shaderMorphWeights[nrmIndex] = this._activeTargets[_i2].weight;
					nrmIndex++;
				}
			}
		};

		_proto.update = function update() {
			this._dirty = false;
			var targets = this.morph._targets;
			var activeCount = 0;
			var epsilon = 0.00001;

			for (var i = 0; i < targets.length; i++) {
				var absWeight = Math.abs(this.getWeight(i));

				if (absWeight > epsilon) {
					if (this._activeTargets.length <= activeCount) {
						this._activeTargets[activeCount] = {};
					}

					var activeTarget = this._activeTargets[activeCount++];
					activeTarget.absWeight = absWeight;
					activeTarget.weight = this.getWeight(i);
					activeTarget.target = targets[i];
				}
			}

			this._activeTargets.length = activeCount;
			var maxActiveTargets = this.morph.maxActiveTargets;

			if (this._activeTargets.length > maxActiveTargets) {
				this._activeTargets.sort(function (l, r) {
					return l.absWeight < r.absWeight ? 1 : r.absWeight < l.absWeight ? -1 : 0;
				});

				this._activeTargets.length = maxActiveTargets;
			}

			if (this.morph.useTextureMorph) {
				this._updateTextureMorph();
			} else {
				this._updateVertexMorph();
			}
		};

		return MorphInstance;
	}();

	var Model = function () {
		function Model() {
			this.graph = null;
			this.meshInstances = [];
			this.skinInstances = [];
			this.morphInstances = [];
			this.cameras = [];
			this.lights = [];
			this._shadersVersion = 0;
			this._immutable = false;
		}

		var _proto = Model.prototype;

		_proto.getGraph = function getGraph() {
			return this.graph;
		};

		_proto.setGraph = function setGraph(graph) {
			this.graph = graph;
		};

		_proto.getCameras = function getCameras() {
			return this.cameras;
		};

		_proto.setCameras = function setCameras(cameras) {
			this.cameras = cameras;
		};

		_proto.getLights = function getLights() {
			return this.lights;
		};

		_proto.setLights = function setLights(lights) {
			this.lights = lights;
		};

		_proto.getMaterials = function getMaterials() {
			var materials = [];

			for (var i = 0; i < this.meshInstances.length; i++) {
				var meshInstance = this.meshInstances[i];

				if (materials.indexOf(meshInstance.material) === -1) {
					materials.push(meshInstance.material);
				}
			}

			return materials;
		};

		_proto.clone = function clone() {
			var srcNodes = [];
			var cloneNodes = [];

			var _duplicate = function _duplicate(node) {
				var newNode = node.clone();
				srcNodes.push(node);
				cloneNodes.push(newNode);

				for (var idx = 0; idx < node._children.length; idx++) {
					newNode.addChild(_duplicate(node._children[idx]));
				}

				return newNode;
			};

			var cloneGraph = _duplicate(this.graph);

			var cloneMeshInstances = [];
			var cloneSkinInstances = [];
			var cloneMorphInstances = [];

			for (var i = 0; i < this.skinInstances.length; i++) {
				var skin = this.skinInstances[i].skin;
				var cloneSkinInstance = new SkinInstance(skin);
				var bones = [];

				for (var j = 0; j < skin.boneNames.length; j++) {
					var boneName = skin.boneNames[j];
					var bone = cloneGraph.findByName(boneName);
					bones.push(bone);
				}

				cloneSkinInstance.bones = bones;
				cloneSkinInstances.push(cloneSkinInstance);
			}

			for (var _i = 0; _i < this.morphInstances.length; _i++) {
				var morph = this.morphInstances[_i].morph;
				var cloneMorphInstance = new MorphInstance(morph);
				cloneMorphInstances.push(cloneMorphInstance);
			}

			for (var _i2 = 0; _i2 < this.meshInstances.length; _i2++) {
				var meshInstance = this.meshInstances[_i2];
				var nodeIndex = srcNodes.indexOf(meshInstance.node);
				var cloneMeshInstance = new MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);

				if (meshInstance.skinInstance) {
					var skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
					cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
				}

				if (meshInstance.morphInstance) {
					var morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
					cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
				}

				cloneMeshInstances.push(cloneMeshInstance);
			}

			var clone = new Model();
			clone.graph = cloneGraph;
			clone.meshInstances = cloneMeshInstances;
			clone.skinInstances = cloneSkinInstances;
			clone.morphInstances = cloneMorphInstances;
			clone.getGraph().syncHierarchy();
			return clone;
		};

		_proto.destroy = function destroy() {
			var meshInstances = this.meshInstances;

			for (var i = 0; i < meshInstances.length; i++) {
				meshInstances[i].destroy();
			}

			this.meshInstances.length = 0;
		};

		_proto.generateWireframe = function generateWireframe() {
			MeshInstance._prepareRenderStyleForArray(this.meshInstances, RENDERSTYLE_WIREFRAME);
		};

		return Model;
	}();

	var identityGraphNode = new GraphNode();
	identityGraphNode.worldTransform = Mat4.IDENTITY;
	identityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;

	var ImmediateBatch = function () {
		function ImmediateBatch(device, material, layer) {
			this.material = material;
			this.layer = layer;
			this.positions = [];
			this.colors = [];
			this.mesh = new Mesh(device);
			this.meshInstance = null;
		}

		var _proto = ImmediateBatch.prototype;

		_proto.addLines = function addLines(positions, color) {
			var destPos = this.positions;
			var count = positions.length;

			for (var i = 0; i < count; i++) {
				var pos = positions[i];
				destPos.push(pos.x, pos.y, pos.z);
			}

			var destCol = this.colors;

			if (color.length) {
				for (var _i = 0; _i < count; _i++) {
					var col = color[_i];
					destCol.push(col.r, col.g, col.b, col.a);
				}
			} else {
				for (var _i2 = 0; _i2 < count; _i2++) {
					destCol.push(color.r, color.g, color.b, color.a);
				}
			}
		};

		_proto.addLinesArrays = function addLinesArrays(positions, color) {
			var _this$positions;

			(_this$positions = this.positions).push.apply(_this$positions, positions);

			var destCol = this.colors;

			if (color.length) {
				destCol.push.apply(destCol, color);
			} else {
				var count = positions.length / 3;

				for (var i = 0; i < count; i++) {
					destCol.push(color.r, color.g, color.b, color.a);
				}
			}
		};

		_proto.onPreRender = function onPreRender(visibleList, transparent) {
			if (this.positions.length > 0 && this.material.transparent === transparent) {
				this.mesh.setPositions(this.positions);
				this.mesh.setColors(this.colors);
				this.mesh.update(PRIMITIVE_LINES, false);

				if (!this.meshInstance) {
					this.meshInstance = new MeshInstance(this.mesh, this.material, identityGraphNode);
				}

				this.positions.length = 0;
				this.colors.length = 0;
				visibleList.list.push(this.meshInstance);
				visibleList.length++;
			}
		};

		return ImmediateBatch;
	}();

	var ImmediateBatches = function () {
		function ImmediateBatches(device) {
			this.device = device;
			this.map = new Map();
		}

		var _proto = ImmediateBatches.prototype;

		_proto.getBatch = function getBatch(material, layer) {
			var batch = this.map.get(material);

			if (!batch) {
				batch = new ImmediateBatch(this.device, material, layer);
				this.map.set(material, batch);
			}

			return batch;
		};

		_proto.onPreRender = function onPreRender(visibleList, transparent) {
			this.map.forEach(function (batch) {
				batch.onPreRender(visibleList, transparent);
			});
		};

		return ImmediateBatches;
	}();

	var tempPoints = [];

	var Immediate = function () {
		function Immediate(device) {
			this.device = device;
			this.quadMesh = null;
			this.textureShader = null;
			this.depthTextureShader = null;
			this.cubeLocalPos = null;
			this.cubeWorldPos = null;
			this.batchesMap = new Map();
			this.allBatches = new Set();
			this.updatedLayers = new Set();
			this._materialDepth = null;
			this._materialNoDepth = null;
			this.layerMeshInstances = new Map();
		}

		var _proto = Immediate.prototype;

		_proto.createMaterial = function createMaterial(depthTest) {
			var material = new BasicMaterial();
			material.vertexColors = true;
			material.blend = true;
			material.blendType = BLEND_NORMAL;
			material.depthTest = depthTest;
			material.update();
			return material;
		};

		_proto.getBatch = function getBatch(layer, depthTest) {
			var batches = this.batchesMap.get(layer);

			if (!batches) {
				batches = new ImmediateBatches(this.device);
				this.batchesMap.set(layer, batches);
			}

			this.allBatches.add(batches);
			var material = depthTest ? this.materialDepth : this.materialNoDepth;
			return batches.getBatch(material, layer);
		};

		Immediate.getTextureVS = function getTextureVS() {
			return "\n						attribute vec2 aPosition;\n						uniform mat4 matrix_model;\n						varying vec2 uv0;\n						void main(void) {\n								gl_Position = matrix_model * vec4(aPosition, 0, 1);\n								uv0 = aPosition.xy + 0.5;\n						}\n				";
		};

		_proto.getTextureShader = function getTextureShader() {
			if (!this.textureShader) {
				var shaderDefinition = {
					attributes: {
						aPosition: SEMANTIC_POSITION
					},
					vshader: Immediate.getTextureVS(),
					fshader: "\n										precision lowp float;\n										varying vec2 uv0;\n										uniform sampler2D colorMap;\n										void main (void) {\n												gl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);\n										}\n								"
				};
				this.textureShader = new Shader(this.device, shaderDefinition);
			}

			return this.textureShader;
		};

		_proto.getDepthTextureShader = function getDepthTextureShader() {
			if (!this.depthTextureShader) {
				var gl2 = this.device.webgl2 ? "#define GL2" : "";
				var shaderDefinition = {
					attributes: {
						aPosition: SEMANTIC_POSITION
					},
					vshader: Immediate.getTextureVS(),
					fshader: "\n										precision " + this.device.precision + " float;\n										" + gl2 + "\n										" + shaderChunks.screenDepthPS + "\n										varying vec2 uv0;\n										void main() {\n												float depth = getLinearScreenDepth(uv0) * camera_params.x;\n												gl_FragColor = vec4(vec3(depth), 1.0);\n										}\n										"
				};
				this.depthTextureShader = new Shader(this.device, shaderDefinition);
			}

			return this.depthTextureShader;
		};

		_proto.getQuadMesh = function getQuadMesh() {
			if (!this.quadMesh) {
				this.quadMesh = new Mesh(this.device);
				this.quadMesh.setPositions([-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0]);
				this.quadMesh.update(PRIMITIVE_TRISTRIP);
			}

			return this.quadMesh;
		};

		_proto.drawMesh = function drawMesh(material, matrix, mesh, meshInstance, layer) {
			if (!meshInstance) {
				var graphNode = this.getGraphNode(matrix);
				meshInstance = new MeshInstance(mesh, material, graphNode);
			}

			var layerMeshInstances = this.layerMeshInstances.get(layer);

			if (!layerMeshInstances) {
				layerMeshInstances = [];
				this.layerMeshInstances.set(layer, layerMeshInstances);
			}

			layerMeshInstances.push(meshInstance);
		};

		_proto.drawWireAlignedBox = function drawWireAlignedBox(min, max, color, depthTest, layer) {
			tempPoints.push(min.x, min.y, min.z, min.x, max.y, min.z, min.x, max.y, min.z, max.x, max.y, min.z, max.x, max.y, min.z, max.x, min.y, min.z, max.x, min.y, min.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, max.z, min.x, max.y, max.z, max.x, max.y, max.z, max.x, max.y, max.z, max.x, min.y, max.z, max.x, min.y, max.z, min.x, min.y, max.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, min.z, min.x, max.y, max.z, max.x, max.y, min.z, max.x, max.y, max.z, max.x, min.y, min.z, max.x, min.y, max.z);
			var batch = this.getBatch(layer, depthTest);
			batch.addLinesArrays(tempPoints, color);
			tempPoints.length = 0;
		};

		_proto.drawWireSphere = function drawWireSphere(center, radius, color, numSegments, depthTest, layer) {
			var step = 2 * Math.PI / numSegments;
			var angle = 0;

			for (var i = 0; i < numSegments; i++) {
				var sin0 = Math.sin(angle);
				var cos0 = Math.cos(angle);
				angle += step;
				var sin1 = Math.sin(angle);
				var cos1 = Math.cos(angle);
				tempPoints.push(center.x + radius * sin0, center.y, center.z + radius * cos0);
				tempPoints.push(center.x + radius * sin1, center.y, center.z + radius * cos1);
				tempPoints.push(center.x + radius * sin0, center.y + radius * cos0, center.z);
				tempPoints.push(center.x + radius * sin1, center.y + radius * cos1, center.z);
				tempPoints.push(center.x, center.y + radius * sin0, center.z + radius * cos0);
				tempPoints.push(center.x, center.y + radius * sin1, center.z + radius * cos1);
			}

			var batch = this.getBatch(layer, depthTest);
			batch.addLinesArrays(tempPoints, color);
			tempPoints.length = 0;
		};

		_proto.getGraphNode = function getGraphNode(matrix) {
			var graphNode = new GraphNode();
			graphNode.worldTransform = matrix;
			graphNode._dirtyWorld = graphNode._dirtyNormal = false;
			return graphNode;
		};

		_proto.onPreRenderLayer = function onPreRenderLayer(layer, visibleList, transparent) {
			this.batchesMap.forEach(function (batches, batchLayer) {
				if (batchLayer === layer) {
					batches.onPreRender(visibleList, transparent);
				}
			});

			if (!this.updatedLayers.has(layer)) {
				this.updatedLayers.add(layer);
				var meshInstances = this.layerMeshInstances.get(layer);

				if (meshInstances) {
					for (var i = 0; i < meshInstances.length; i++) {
						visibleList.list[visibleList.length + i] = meshInstances[i];
					}

					visibleList.length += meshInstances.length;
					meshInstances.length = 0;
				}
			}
		};

		_proto.onPostRender = function onPostRender() {
			this.allBatches.clear();
			this.updatedLayers.clear();
		};

		_createClass(Immediate, [{
			key: "materialDepth",
			get: function get() {
				if (!this._materialDepth) {
					this._materialDepth = this.createMaterial(true);
				}

				return this._materialDepth;
			}
		}, {
			key: "materialNoDepth",
			get: function get() {
				if (!this._materialNoDepth) {
					this._materialNoDepth = this.createMaterial(false);
				}

				return this._materialNoDepth;
			}
		}]);

		return Immediate;
	}();

	var Scene = function (_EventHandler) {
		_inheritsLoose(Scene, _EventHandler);

		function Scene(graphicsDevice) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.ambientBake = false;
			_this.ambientBakeOcclusionBrightness = 0;
			_this.ambientBakeOcclusionContrast = 0;
			_this.ambientLight = new Color(0, 0, 0);
			_this.exposure = 1;
			_this.fogColor = new Color(0, 0, 0);
			_this.fogDensity = 0;
			_this.fogEnd = 1000;
			_this.fogStart = 1;
			_this.lightmapSizeMultiplier = 1;
			_this.lightmapMaxResolution = 2048;
			_this.lightmapMode = BAKE_COLORDIR;
			_this.lightmapFilterEnabled = false;
			_this.root = null;
			_this.device = graphicsDevice || getApplication().graphicsDevice;
			_this._gravity = new Vec3(0, -9.8, 0);
			_this._layers = null;
			_this._fog = FOG_NONE;
			_this._gammaCorrection = GAMMA_SRGB;
			_this._toneMapping = 0;
			_this._skyboxCubeMap = null;
			_this._prefilteredCubemaps = [null, null, null, null, null, null];
			_this._envAtlas = null;
			_this._internalEnvAtlas = null;
			_this.skyboxModel = null;
			_this._skyboxIntensity = 1;
			_this._skyboxMip = 0;
			_this._skyboxRotation = new Quat();
			_this._skyboxRotationMat3 = null;
			_this._skyboxRotationMat4 = null;
			_this._ambientBakeNumSamples = 1;
			_this._ambientBakeSpherePart = 0.4;
			_this._lightmapFilterRange = 10;
			_this._lightmapFilterSmoothness = 0.2;
			_this._clusteredLightingEnabled = false;
			_this._lightingParams = new LightingParams(_this.device.supportsAreaLights, _this.device.maxTextureSize, function () {
				_this._layers._dirtyLights = true;
			});
			_this._stats = {
				meshInstances: 0,
				lights: 0,
				dynamicLights: 0,
				bakedLights: 0,
				lastStaticPrepareFullTime: 0,
				lastStaticPrepareSearchTime: 0,
				lastStaticPrepareWriteTime: 0,
				lastStaticPrepareTriAabbTime: 0,
				lastStaticPrepareCombineTime: 0,
				updateShadersTime: 0
			};
			_this.updateShaders = true;
			_this._shaderVersion = 0;
			_this._statsUpdated = false;
			_this._models = [];
			_this.immediate = new Immediate(_this.device);
			return _this;
		}

		var _proto = Scene.prototype;

		_proto.destroy = function destroy() {
			this._resetSkyboxModel();

			this.root = null;
			this.off();
		};

		_proto.drawLine = function drawLine(start, end, color, depthTest, layer) {
			if (color === void 0) {
				color = Color.WHITE;
			}

			if (depthTest === void 0) {
				depthTest = true;
			}

			if (layer === void 0) {
				layer = this.defaultDrawLayer;
			}

			var batch = this.immediate.getBatch(layer, depthTest);
			batch.addLines([start, end], [color, color]);
		};

		_proto.drawLines = function drawLines(positions, colors, depthTest, layer) {
			if (depthTest === void 0) {
				depthTest = true;
			}

			if (layer === void 0) {
				layer = this.defaultDrawLayer;
			}

			var batch = this.immediate.getBatch(layer, depthTest);
			batch.addLines(positions, colors);
		};

		_proto.drawLineArrays = function drawLineArrays(positions, colors, depthTest, layer) {
			if (depthTest === void 0) {
				depthTest = true;
			}

			if (layer === void 0) {
				layer = this.defaultDrawLayer;
			}

			var batch = this.immediate.getBatch(layer, depthTest);
			batch.addLinesArrays(positions, colors);
		};

		_proto.applySettings = function applySettings(settings) {
			var _this2 = this;

			var physics = settings.physics;
			var render = settings.render;

			this._gravity.set(physics.gravity[0], physics.gravity[1], physics.gravity[2]);

			this.ambientLight.set(render.global_ambient[0], render.global_ambient[1], render.global_ambient[2]);
			this._fog = render.fog;
			this.fogColor.set(render.fog_color[0], render.fog_color[1], render.fog_color[2]);
			this.fogStart = render.fog_start;
			this.fogEnd = render.fog_end;
			this.fogDensity = render.fog_density;
			this._gammaCorrection = render.gamma_correction;
			this._toneMapping = render.tonemapping;
			this.lightmapSizeMultiplier = render.lightmapSizeMultiplier;
			this.lightmapMaxResolution = render.lightmapMaxResolution;
			this.lightmapMode = render.lightmapMode;
			this.exposure = render.exposure;
			this._skyboxIntensity = render.skyboxIntensity === undefined ? 1 : render.skyboxIntensity;
			this._skyboxMip = render.skyboxMip === undefined ? 0 : render.skyboxMip;

			if (render.skyboxRotation) {
				this._skyboxRotation.setFromEulerAngles(render.skyboxRotation[0], render.skyboxRotation[1], render.skyboxRotation[2]);
			}

			['lightmapFilterEnabled', 'lightmapFilterRange', 'lightmapFilterSmoothness', 'ambientBake', 'ambientBakeNumSamples', 'ambientBakeSpherePart', 'ambientBakeOcclusionBrightness', 'ambientBakeOcclusionContrast'].forEach(function (setting) {
				if (render.hasOwnProperty(setting)) {
					_this2[setting] = render[setting];
				}
			});

			this._resetSkyboxModel();
		};

		_proto._getSkyboxTex = function _getSkyboxTex() {
			var cubemaps = this._prefilteredCubemaps;

			if (this._skyboxMip) {
				var skyboxMapping = [0, 1, 3, 4, 5, 6];
				return cubemaps[skyboxMapping[this._skyboxMip]] || this._envAtlas || cubemaps[0] || this._skyboxCubeMap;
			}

			return this._skyboxCubeMap || cubemaps[0] || this._envAtlas;
		};

		_proto._updateSkybox = function _updateSkybox(device) {
			if (this.skyboxModel) {
				return;
			}

			var skyboxTex = this._getSkyboxTex();

			if (!skyboxTex) {
				return;
			}

			var material = new Material();
			var scene = this;

			material.updateShader = function (dev, sc, defs, staticLightList, pass) {
				var library = device.getProgramLibrary();

				if (skyboxTex.cubemap) {
					this.shader = library.getProgram('skybox', {
						type: 'cubemap',
						rgbm: skyboxTex.type === TEXTURETYPE_RGBM,
						hdr: skyboxTex.type === TEXTURETYPE_RGBM || skyboxTex.format === PIXELFORMAT_RGBA32F,
						useIntensity: scene.skyboxIntensity !== 1,
						mip: skyboxTex.fixCubemapSeams ? scene.skyboxMip : 0,
						fixSeams: skyboxTex.fixCubemapSeams,
						gamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,
						toneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping
					});
				} else {
					this.shader = library.getProgram('skybox', {
						type: 'envAtlas',
						encoding: skyboxTex.encoding,
						useIntensity: scene.skyboxIntensity !== 1,
						gamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,
						toneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping
					});
				}
			};

			material.updateShader();

			if (skyboxTex.cubemap) {
				material.setParameter("texture_cubeMap", skyboxTex);
			} else {
				material.setParameter("texture_envAtlas", skyboxTex);
				material.setParameter("mipLevel", this._skyboxMip);
			}

			if (!this.skyboxRotation.equals(Quat.IDENTITY)) {
				if (!this._skyboxRotationMat4) this._skyboxRotationMat4 = new Mat4();
				if (!this._skyboxRotationMat3) this._skyboxRotationMat3 = new Mat3();

				this._skyboxRotationMat4.setTRS(Vec3.ZERO, this._skyboxRotation, Vec3.ONE);

				this._skyboxRotationMat4.invertTo3x3(this._skyboxRotationMat3);

				material.setParameter("cubeMapRotationMatrix", this._skyboxRotationMat3.data);
			} else {
				material.setParameter("cubeMapRotationMatrix", Mat3.IDENTITY.data);
			}

			material.cull = CULLFACE_FRONT;
			material.depthWrite = false;
			var skyLayer = this.layers.getLayerById(LAYERID_SKYBOX);

			if (skyLayer) {
				var node = new GraphNode("Skybox");
				var mesh = createBox(device);
				var meshInstance = new MeshInstance(mesh, material, node);
				meshInstance.cull = false;
				meshInstance._noDepthDrawGl1 = true;
				meshInstance.pick = false;
				var model = new Model();
				model.graph = node;
				model.meshInstances = [meshInstance];
				this.skyboxModel = model;
				skyLayer.addMeshInstances(model.meshInstances);
				this.skyLayer = skyLayer;
				this.fire("set:skybox", skyboxTex);
			}
		};

		_proto._resetSkyboxModel = function _resetSkyboxModel() {
			if (this.skyboxModel) {
				this.skyLayer.removeMeshInstances(this.skyboxModel.meshInstances);
				this.skyboxModel.destroy();
			}

			this.skyboxModel = null;
			this.updateShaders = true;
		};

		_proto.setSkybox = function setSkybox(cubemaps) {
			if (!cubemaps) {
				this.skybox = null;
				this.prefilteredCubemaps = [null, null, null, null, null, null];
			} else {
				this.skybox = cubemaps[0] || null;
				this.prefilteredCubemaps = cubemaps.slice(1);
			}
		};

		_proto.addModel = function addModel(model) {
			if (this.containsModel(model)) return;
			var layer = this.layers.getLayerById(LAYERID_WORLD);
			if (!layer) return;
			layer.addMeshInstances(model.meshInstances);

			this._models.push(model);
		};

		_proto.addShadowCaster = function addShadowCaster(model) {
			var layer = this.layers.getLayerById(LAYERID_WORLD);
			if (!layer) return;
			layer.addShadowCasters(model.meshInstances);
		};

		_proto.removeModel = function removeModel(model) {
			var index = this._models.indexOf(model);

			if (index !== -1) {
				var layer = this.layers.getLayerById(LAYERID_WORLD);
				if (!layer) return;
				layer.removeMeshInstances(model.meshInstances);

				this._models.splice(index, 1);
			}
		};

		_proto.removeShadowCasters = function removeShadowCasters(model) {
			var layer = this.layers.getLayerById(LAYERID_WORLD);
			if (!layer) return;
			layer.removeShadowCasters(model.meshInstances);
		};

		_proto.containsModel = function containsModel(model) {
			return this._models.indexOf(model) >= 0;
		};

		_proto.getModels = function getModels(model) {
			return this._models;
		};

		_createClass(Scene, [{
			key: "defaultDrawLayer",
			get: function get() {
				return this.layers.getLayerById(LAYERID_IMMEDIATE);
			}
		}, {
			key: "ambientBakeNumSamples",
			get: function get() {
				return this._ambientBakeNumSamples;
			},
			set: function set(value) {
				this._ambientBakeNumSamples = math.clamp(Math.floor(value), 1, 255);
			}
		}, {
			key: "ambientBakeSpherePart",
			get: function get() {
				return this._ambientBakeSpherePart;
			},
			set: function set(value) {
				this._ambientBakeSpherePart = math.clamp(value, 0.001, 1);
			}
		}, {
			key: "clusteredLightingEnabled",
			get: function get() {
				return this._clusteredLightingEnabled;
			},
			set: function set(value) {
				if (this._clusteredLightingEnabled && !value) {
					console.error("Turning off enabled clustered lighting is not currently supported");
					return;
				}

				this._clusteredLightingEnabled = value;
			}
		}, {
			key: "drawCalls",
			get: function get() {
				var drawCalls = this.layers._meshInstances;

				if (!drawCalls.length) {
					this.layers._update(this.device, this.clusteredLightingEnabled);

					drawCalls = this.layers._meshInstances;
				}

				return drawCalls;
			},
			set: function set(value) {}
		}, {
			key: "envAtlas",
			get: function get() {
				return this._envAtlas;
			},
			set: function set(value) {
				if (value !== this._envAtlas) {
					this._envAtlas = value;
					this.updateShaders = true;
				}
			}
		}, {
			key: "fog",
			get: function get() {
				return this._fog;
			},
			set: function set(type) {
				if (type !== this._fog) {
					this._fog = type;
					this.updateShaders = true;
				}
			}
		}, {
			key: "gammaCorrection",
			get: function get() {
				return this._gammaCorrection;
			},
			set: function set(value) {
				if (value !== this._gammaCorrection) {
					this._gammaCorrection = value;
					this.updateShaders = true;
				}
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(layers) {
				var prev = this._layers;
				this._layers = layers;
				this.fire("set:layers", prev, layers);
			}
		}, {
			key: "lighting",
			get: function get() {
				return this._lightingParams;
			}
		}, {
			key: "lightmapFilterRange",
			get: function get() {
				return this._lightmapFilterRange;
			},
			set: function set(value) {
				this._lightmapFilterRange = Math.max(value, 0.001);
			}
		}, {
			key: "lightmapFilterSmoothness",
			get: function get() {
				return this._lightmapFilterSmoothness;
			},
			set: function set(value) {
				this._lightmapFilterSmoothness = Math.max(value, 0.001);
			}
		}, {
			key: "prefilteredCubemaps",
			get: function get() {
				return this._prefilteredCubemaps;
			},
			set: function set(value) {
				var cubemaps = this._prefilteredCubemaps;
				value = value || [];
				var changed = false;
				var complete = true;

				for (var i = 0; i < 6; ++i) {
					var v = value[i] || null;

					if (cubemaps[i] !== v) {
						cubemaps[i] = v;
						changed = true;
					}

					complete = complete && !!cubemaps[i];
				}

				if (changed) {
					this._resetSkyboxModel();

					if (complete) {
						this._internalEnvAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {
							target: this._internalEnvAtlas
						});

						if (!this._envAtlas) {
							this.envAtlas = this._internalEnvAtlas;
						}
					} else if (this._internalEnvAtlas) {
						if (this._envAtlas === this._internalEnvAtlas) {
							this.envAtlas = null;
						}

						this._internalEnvAtlas.destroy();

						this._internalEnvAtlas = null;
					}
				}
			}
		}, {
			key: "skybox",
			get: function get() {
				return this._skyboxCubeMap;
			},
			set: function set(value) {
				if (value !== this._skyboxCubeMap) {
					this._skyboxCubeMap = value;

					this._resetSkyboxModel();
				}
			}
		}, {
			key: "skyboxIntensity",
			get: function get() {
				return this._skyboxIntensity;
			},
			set: function set(value) {
				if (value !== this._skyboxIntensity) {
					this._skyboxIntensity = value;

					this._resetSkyboxModel();
				}
			}
		}, {
			key: "skyboxMip",
			get: function get() {
				return this._skyboxMip;
			},
			set: function set(value) {
				if (value !== this._skyboxMip) {
					this._skyboxMip = value;

					this._resetSkyboxModel();
				}
			}
		}, {
			key: "skyboxRotation",
			get: function get() {
				return this._skyboxRotation;
			},
			set: function set(value) {
				if (!this._skyboxRotation.equals(value)) {
					this._skyboxRotation.copy(value);

					this._resetSkyboxModel();
				}
			}
		}, {
			key: "toneMapping",
			get: function get() {
				return this._toneMapping;
			},
			set: function set(value) {
				if (value !== this._toneMapping) {
					this._toneMapping = value;
					this.updateShaders = true;
				}
			}
		}]);

		return Scene;
	}(EventHandler);

	function hasAudioContext() {
		return !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');
	}

	var Channel = function () {
		function Channel(manager, sound, options) {
			if (options === void 0) {
				options = {};
			}

			this.volume = options.volume === undefined ? 1 : options.volume;
			this.loop = options.loop === undefined ? false : options.loop;
			this.pitch = options.pitch === undefined ? 1 : options.pitch;
			this.sound = sound;
			this.paused = false;
			this.suspended = false;
			this.manager = manager;
			this.source = null;

			if (hasAudioContext()) {
				this.startTime = 0;
				this.startOffset = 0;
				var context = manager.context;
				this.gain = context.createGain();
			} else if (sound.audio) {
				this.source = sound.audio.cloneNode(false);
				this.source.pause();
			}
		}

		var _proto = Channel.prototype;

		_proto.getVolume = function getVolume() {
			return this.volume;
		};

		_proto.getLoop = function getLoop() {
			return this.loop;
		};

		_proto.setLoop = function setLoop(loop) {
			this.loop = loop;

			if (this.source) {
				this.source.loop = loop;
			}
		};

		_proto.getPitch = function getPitch() {
			return this.pitch;
		};

		_proto.onManagerVolumeChange = function onManagerVolumeChange() {
			this.setVolume(this.getVolume());
		};

		_proto.onManagerSuspend = function onManagerSuspend() {
			if (this.isPlaying() && !this.suspended) {
				this.suspended = true;
				this.pause();
			}
		};

		_proto.onManagerResume = function onManagerResume() {
			if (this.suspended) {
				this.suspended = false;
				this.unpause();
			}
		};

		_proto.play = function play() {
			if (this.source) {
				throw new Error('Call stop() before calling play()');
			}

			this._createSource();

			if (!this.source) {
				return;
			}

			this.startTime = this.manager.context.currentTime;
			this.source.start(0, this.startOffset % this.source.buffer.duration);
			this.setVolume(this.volume);
			this.setLoop(this.loop);
			this.setPitch(this.pitch);
			this.manager.on('volumechange', this.onManagerVolumeChange, this);
			this.manager.on('suspend', this.onManagerSuspend, this);
			this.manager.on('resume', this.onManagerResume, this);
			if (this.manager.suspended) this.onManagerSuspend();
		};

		_proto.pause = function pause() {
			if (this.source) {
				this.paused = true;
				this.startOffset += this.manager.context.currentTime - this.startTime;
				this.source.stop(0);
				this.source = null;
			}
		};

		_proto.unpause = function unpause() {
			if (this.source || !this.paused) {
				console.warn('Call pause() before unpausing.');
				return;
			}

			this._createSource();

			if (!this.source) {
				return;
			}

			this.startTime = this.manager.context.currentTime;
			this.source.start(0, this.startOffset % this.source.buffer.duration);
			this.setVolume(this.volume);
			this.setLoop(this.loop);
			this.setPitch(this.pitch);
			this.paused = false;
		};

		_proto.stop = function stop() {
			if (this.source) {
				this.source.stop(0);
				this.source = null;
			}

			this.manager.off('volumechange', this.onManagerVolumeChange, this);
			this.manager.off('suspend', this.onManagerSuspend, this);
			this.manager.off('resume', this.onManagerResume, this);
		};

		_proto.setVolume = function setVolume(volume) {
			volume = math.clamp(volume, 0, 1);
			this.volume = volume;

			if (this.gain) {
				this.gain.gain.value = volume * this.manager.volume;
			}
		};

		_proto.setPitch = function setPitch(pitch) {
			this.pitch = pitch;

			if (this.source) {
				this.source.playbackRate.value = pitch;
			}
		};

		_proto.isPlaying = function isPlaying() {
			return !this.paused && this.source.playbackState === this.source.PLAYING_STATE;
		};

		_proto.getDuration = function getDuration() {
			return this.source ? this.source.buffer.duration : 0;
		};

		_proto._createSource = function _createSource() {
			var context = this.manager.context;

			if (this.sound.buffer) {
				this.source = context.createBufferSource();
				this.source.buffer = this.sound.buffer;
				this.source.connect(this.gain);
				this.gain.connect(context.destination);

				if (!this.loop) {
					this.source.onended = this.pause.bind(this);
				}
			}
		};

		return Channel;
	}();

	if (!hasAudioContext()) {
		Object.assign(Channel.prototype, {
			play: function play() {
				if (this.source) {
					this.paused = false;
					this.setVolume(this.volume);
					this.setLoop(this.loop);
					this.setPitch(this.pitch);
					this.source.play();
				}

				this.manager.on('volumechange', this.onManagerVolumeChange, this);
				this.manager.on('suspend', this.onManagerSuspend, this);
				this.manager.on('resume', this.onManagerResume, this);
				if (this.manager.suspended) this.onManagerSuspend();
			},
			pause: function pause() {
				if (this.source) {
					this.paused = true;
					this.source.pause();
				}
			},
			unpause: function unpause() {
				if (this.source) {
					this.paused = false;
					this.source.play();
				}
			},
			stop: function stop() {
				if (this.source) {
					this.source.pause();
				}

				this.manager.off('volumechange', this.onManagerVolumeChange, this);
				this.manager.off('suspend', this.onManagerSuspend, this);
				this.manager.off('resume', this.onManagerResume, this);
			},
			setVolume: function setVolume(volume) {
				volume = math.clamp(volume, 0, 1);
				this.volume = volume;

				if (this.source) {
					this.source.volume = volume * this.manager.volume;
				}
			},
			setPitch: function setPitch(pitch) {
				this.pitch = pitch;

				if (this.source) {
					this.source.playbackRate = pitch;
				}
			},
			getDuration: function getDuration() {
				return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;
			},
			isPlaying: function isPlaying() {
				return !this.source.paused;
			}
		});
	}

	var DISTANCE_LINEAR = 'linear';
	var DISTANCE_INVERSE = 'inverse';
	var DISTANCE_EXPONENTIAL = 'exponential';

	var MAX_DISTANCE$1 = 10000;

	var Channel3d = function (_Channel) {
		_inheritsLoose(Channel3d, _Channel);

		function Channel3d(manager, sound, options) {
			var _this;

			_this = _Channel.call(this, manager, sound, options) || this;
			_this.position = new Vec3();
			_this.velocity = new Vec3();

			if (hasAudioContext()) {
				_this.panner = manager.context.createPanner();
			} else {
				_this.maxDistance = MAX_DISTANCE$1;
				_this.minDistance = 1;
				_this.rollOffFactor = 1;
				_this.distanceModel = DISTANCE_INVERSE;
			}

			return _this;
		}

		var _proto = Channel3d.prototype;

		_proto.getPosition = function getPosition() {
			return this.position;
		};

		_proto.setPosition = function setPosition(position) {
			this.position.copy(position);
			var panner = this.panner;

			if ('positionX' in panner) {
				panner.positionX.value = position.x;
				panner.positionY.value = position.y;
				panner.positionZ.value = position.z;
			} else if (panner.setPosition) {
				panner.setPosition(position.x, position.y, position.z);
			}
		};

		_proto.getVelocity = function getVelocity() {
			Debug.warn('Channel3d#getVelocity is not implemented.');
			return this.velocity;
		};

		_proto.setVelocity = function setVelocity(velocity) {
			Debug.warn('Channel3d#setVelocity is not implemented.');
			this.velocity.copy(velocity);
		};

		_proto.getMaxDistance = function getMaxDistance() {
			return this.panner.maxDistance;
		};

		_proto.setMaxDistance = function setMaxDistance(max) {
			this.panner.maxDistance = max;
		};

		_proto.getMinDistance = function getMinDistance() {
			return this.panner.refDistance;
		};

		_proto.setMinDistance = function setMinDistance(min) {
			this.panner.refDistance = min;
		};

		_proto.getRollOffFactor = function getRollOffFactor() {
			return this.panner.rolloffFactor;
		};

		_proto.setRollOffFactor = function setRollOffFactor(factor) {
			this.panner.rolloffFactor = factor;
		};

		_proto.getDistanceModel = function getDistanceModel() {
			return this.panner.distanceModel;
		};

		_proto.setDistanceModel = function setDistanceModel(distanceModel) {
			this.panner.distanceModel = distanceModel;
		};

		_proto._createSource = function _createSource() {
			var context = this.manager.context;
			this.source = context.createBufferSource();
			this.source.buffer = this.sound.buffer;
			this.source.connect(this.panner);
			this.panner.connect(this.gain);
			this.gain.connect(context.destination);

			if (!this.loop) {
				this.source.onended = this.pause.bind(this);
			}
		};

		return Channel3d;
	}(Channel);

	if (!hasAudioContext()) {
		var offset$1 = new Vec3();

		var fallOff$1 = function fallOff(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {
			offset$1 = offset$1.sub2(posOne, posTwo);
			var distance = offset$1.length();

			if (distance < refDistance) {
				return 1;
			} else if (distance > maxDistance) {
				return 0;
			}

			var result = 0;

			if (distanceModel === DISTANCE_LINEAR) {
				result = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);
			} else if (distanceModel === DISTANCE_INVERSE) {
				result = refDistance / (refDistance + rolloffFactor * (distance - refDistance));
			} else if (distanceModel === DISTANCE_EXPONENTIAL) {
				result = Math.pow(distance / refDistance, -rolloffFactor);
			}

			return math.clamp(result, 0, 1);
		};

		Object.assign(Channel3d.prototype, {
			setPosition: function setPosition(position) {
				this.position.copy(position);

				if (this.source) {
					var listener = this.manager.listener;
					var lpos = listener.getPosition();
					var factor = fallOff$1(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
					var v = this.getVolume();
					this.source.volume = v * factor;
				}
			},
			getMaxDistance: function getMaxDistance() {
				return this.maxDistance;
			},
			setMaxDistance: function setMaxDistance(max) {
				this.maxDistance = max;
			},
			getMinDistance: function getMinDistance() {
				return this.minDistance;
			},
			setMinDistance: function setMinDistance(min) {
				this.minDistance = min;
			},
			getRollOffFactor: function getRollOffFactor() {
				return this.rollOffFactor;
			},
			setRollOffFactor: function setRollOffFactor(factor) {
				this.rollOffFactor = factor;
			},
			getDistanceModel: function getDistanceModel() {
				return this.distanceModel;
			},
			setDistanceModel: function setDistanceModel(distanceModel) {
				this.distanceModel = distanceModel;
			}
		});
	}

	var Listener = function () {
		function Listener(manager) {
			this._manager = manager;
			this.position = new Vec3();
			this.velocity = new Vec3();
			this.orientation = new Mat4();
		}

		var _proto = Listener.prototype;

		_proto.getPosition = function getPosition() {
			return this.position;
		};

		_proto.setPosition = function setPosition(position) {
			this.position.copy(position);
			var listener = this.listener;

			if (listener) {
				if ('positionX' in listener) {
					listener.positionX.value = position.x;
					listener.positionY.value = position.y;
					listener.positionZ.value = position.z;
				} else if (listener.setPosition) {
					listener.setPosition(position.x, position.y, position.z);
				}
			}
		};

		_proto.getVelocity = function getVelocity() {
			Debug.warn('Listener#getVelocity is not implemented.');
			return this.velocity;
		};

		_proto.setVelocity = function setVelocity(velocity) {
			Debug.warn('Listener#setVelocity is not implemented.');
		};

		_proto.setOrientation = function setOrientation(orientation) {
			this.orientation.copy(orientation);
			var listener = this.listener;

			if (listener) {
				var m = orientation.data;

				if ('forwardX' in listener) {
					listener.forwardX.value = -m[8];
					listener.forwardY.value = -m[9];
					listener.forwardZ.value = -m[10];
					listener.upX.value = m[4];
					listener.upY.value = m[5];
					listener.upZ.value = m[6];
				} else if (listener.setOrientation) {
					listener.setOrientation(-m[8], -m[9], -m[10], m[4], m[5], m[6]);
				}
			}
		};

		_proto.getOrientation = function getOrientation() {
			return this.orientation;
		};

		_createClass(Listener, [{
			key: "listener",
			get: function get() {
				var context = this._manager.context;
				return context ? context.listener : null;
			}
		}]);

		return Listener;
	}();

	var CONTEXT_STATE_NOT_CREATED = 'not created';
	var CONTEXT_STATE_RUNNING = 'running';
	var CONTEXT_STATE_SUSPENDED = 'suspended';
	var CONTEXT_STATE_INTERRUPTED = 'interrupted';
	var USER_INPUT_EVENTS = ['click', 'contextmenu', 'auxclick', 'dblclick', 'mousedown', 'mouseup', 'pointerup', 'touchend', 'keydown', 'keyup'];

	var SoundManager = function (_EventHandler) {
		_inheritsLoose(SoundManager, _EventHandler);

		function SoundManager(options) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._context = null;
			_this._state = CONTEXT_STATE_NOT_CREATED;
			_this._forceWebAudioApi = options.forceWebAudioApi;
			_this._resumeContext = null;
			_this._resumeContextAttached = false;
			_this._unlock = null;
			_this._unlockAttached = false;

			if (hasAudioContext() || _this._forceWebAudioApi) {
				_this._addAudioContextUserInteractionListeners();
			} else {
				console.warn('No support for 3D audio found');
			}

			_this.listener = new Listener(_assertThisInitialized(_this));
			_this._volume = 1;
			_this.suspended = false;
			return _this;
		}

		var _proto = SoundManager.prototype;

		_proto.suspend = function suspend() {
			this.suspended = true;
			this.fire('suspend');
		};

		_proto.resume = function resume() {
			this.suspended = false;
			this.fire('resume');

			if (this.context && (this._state === CONTEXT_STATE_INTERRUPTED || this._state === CONTEXT_STATE_SUSPENDED)) {
				this._safelyResumeContext();
			}
		};

		_proto.destroy = function destroy() {
			var _this2 = this;

			if (this._resumeContext && this._resumeContextAttached) {
				USER_INPUT_EVENTS.forEach(function (eventName) {
					window.removeEventListener(eventName, _this2._resumeContext);
				});
			}

			if (this._unlock && this._unlockAttached) {
				window.removeEventListener('touchend', this._unlock);
			}

			this.fire('destroy');

			if (this._context && this._context.close) {
				this._context.close();

				this._context = null;
			}
		};

		_proto.playSound = function playSound(sound, options) {
			if (options === void 0) {
				options = {};
			}

			var channel = null;

			if (Channel) {
				channel = new Channel(this, sound, options);
				channel.play();
			}

			return channel;
		};

		_proto.playSound3d = function playSound3d(sound, position, options) {
			if (options === void 0) {
				options = {};
			}

			var channel = null;

			if (Channel3d) {
				channel = new Channel3d(this, sound, options);
				channel.setPosition(position);

				if (options.volume) {
					channel.setVolume(options.volume);
				}

				if (options.loop) {
					channel.setLoop(options.loop);
				}

				if (options.maxDistance) {
					channel.setMaxDistance(options.maxDistance);
				}

				if (options.minDistance) {
					channel.setMinDistance(options.minDistance);
				}

				if (options.rollOffFactor) {
					channel.setRollOffFactor(options.rollOffFactor);
				}

				if (options.distanceModel) {
					channel.setDistanceModel(options.distanceModel);
				}

				channel.play();
			}

			return channel;
		};

		_proto._safelyResumeContext = function _safelyResumeContext() {
			var _this3 = this;

			if (!this._context) return;

			this._context.resume().then(function () {
				if (_this3._context.state !== CONTEXT_STATE_RUNNING) {
					_this3._addAudioContextUserInteractionListeners();
				}
			}).catch(function () {
				_this3._addAudioContextUserInteractionListeners();
			});
		};

		_proto._addAudioContextUserInteractionListeners = function _addAudioContextUserInteractionListeners() {
			var _this4 = this;

			if (!this._resumeContext) {
				this._resumeContext = function () {
					if (!_this4.context || _this4.context.state === CONTEXT_STATE_RUNNING) {
						USER_INPUT_EVENTS.forEach(function (eventName) {
							window.removeEventListener(eventName, _this4._resumeContext);
						});
						_this4._resumeContextAttached = false;
					} else {
						_this4.context.resume();
					}
				};
			}

			if (!this._resumeContextAttached) {
				USER_INPUT_EVENTS.forEach(function (eventName) {
					window.addEventListener(eventName, _this4._resumeContext);
				});
				this._resumeContextAttached = true;
			}

			if (platform.ios) {
				if (!this._unlock) {
					this._unlock = function () {
						window.removeEventListener('touchend', _this4._unlock);
						_this4._unlockAttached = false;
						var context = _this4.context;

						if (context) {
							var buffer = context.createBuffer(1, 1, 44100);
							var source = context.createBufferSource();
							source.buffer = buffer;
							source.connect(context.destination);
							source.start(0);
							source.disconnect();
						}
					};
				}

				if (!this._unlockAttached) {
					window.addEventListener('touchend', this._unlock);
					this._unlockAttached = true;
				}
			}
		};

		_createClass(SoundManager, [{
			key: "volume",
			get: function get() {
				return this._volume;
			},
			set: function set(volume) {
				volume = math.clamp(volume, 0, 1);
				this._volume = volume;
				this.fire('volumechange', volume);
			}
		}, {
			key: "context",
			get: function get() {
				var _this5 = this;

				if (!this._context) {
					if (hasAudioContext() || this._forceWebAudioApi) {
						if (typeof AudioContext !== 'undefined') {
							this._context = new AudioContext();
						} else if (typeof webkitAudioContext !== 'undefined') {
							this._context = new webkitAudioContext();
						}

						if (this._context) {
							this._state = this._context.state;

							this._context.onstatechange = function () {
								if (!_this5._context) return;

								if (_this5._state === CONTEXT_STATE_INTERRUPTED || _this5._state === CONTEXT_STATE_SUSPENDED) {
									_this5._safelyResumeContext();
								}

								_this5._state = _this5._context.state;
							};
						}
					}
				}

				return this._context;
			}
		}]);

		return SoundManager;
	}(EventHandler);

	var Key = function Key(time, position, rotation, scale) {
		this.time = time;
		this.position = position;
		this.rotation = rotation;
		this.scale = scale;
	};

	var Node = function Node() {
		this._name = "";
		this._keys = [];
	};

	var Animation = function () {
		function Animation() {
			this.name = '';
			this.duration = 0;
			this._nodes = [];
			this._nodeDict = {};
		}

		var _proto = Animation.prototype;

		_proto.getNode = function getNode(name) {
			return this._nodeDict[name];
		};

		_proto.addNode = function addNode(node) {
			this._nodes.push(node);

			this._nodeDict[node._name] = node;
		};

		_createClass(Animation, [{
			key: "nodes",
			get: function get() {
				return this._nodes;
			}
		}]);

		return Animation;
	}();

	var MorphTarget = function () {
		function MorphTarget(options) {
			if (arguments.length === 2) {
				Debug.deprecated('Passing graphicsDevice to MorphTarget is deprecated, please remove the parameter.');
				options = arguments[1];
			}

			this.options = options;
			this._name = options.name;
			this._defaultWeight = options.defaultWeight || 0;
			this.aabb = options.aabb;

			if (!this.aabb) {
				this.aabb = new BoundingBox();
				if (options.deltaPositions) this.aabb.compute(options.deltaPositions);
			}

			this.deltaPositions = options.deltaPositions;
		}

		var _proto = MorphTarget.prototype;

		_proto._postInit = function _postInit() {
			this.options = null;
		};

		_proto._initVertexBuffers = function _initVertexBuffers(graphicsDevice) {
			var options = this.options;
			this._vertexBufferPositions = this._createVertexBuffer(graphicsDevice, options.deltaPositions, options.deltaPositionsType);
			this._vertexBufferNormals = this._createVertexBuffer(graphicsDevice, options.deltaNormals, options.deltaNormalsType);

			if (this._vertexBufferPositions) {
				this.deltaPositions = this._vertexBufferPositions.lock();
			}
		};

		_proto._createVertexBuffer = function _createVertexBuffer(device, data, dataType) {
			if (dataType === void 0) {
				dataType = TYPE_FLOAT32;
			}

			if (data) {
				var formatDesc = [{
					semantic: SEMANTIC_ATTR0,
					components: 3,
					type: dataType
				}];
				return new VertexBuffer(device, new VertexFormat(device, formatDesc), data.length / 3, BUFFER_STATIC, data);
			}

			return null;
		};

		_proto._setTexture = function _setTexture(name, texture) {
			this[name] = texture;
		};

		_proto.destroy = function destroy() {
			if (this._vertexBufferPositions) {
				this._vertexBufferPositions.destroy();

				this._vertexBufferPositions = null;
			}

			if (this._vertexBufferNormals) {
				this._vertexBufferNormals.destroy();

				this._vertexBufferNormals = null;
			}

			if (this.texturePositions) {
				this.texturePositions.destroy();
				this.texturePositions = null;
			}

			if (this.textureNormals) {
				this.textureNormals.destroy();
				this.textureNormals = null;
			}
		};

		_createClass(MorphTarget, [{
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "defaultWeight",
			get: function get() {
				return this._defaultWeight;
			}
		}, {
			key: "morphPositions",
			get: function get() {
				return !!this._vertexBufferPositions || !!this.texturePositions;
			}
		}, {
			key: "morphNormals",
			get: function get() {
				return !!this._vertexBufferNormals || !!this.textureNormals;
			}
		}]);

		return MorphTarget;
	}();

	var Skin = function Skin(graphicsDevice, ibp, boneNames) {
		this.device = graphicsDevice;
		this.inverseBindPose = ibp;
		this.boneNames = boneNames;
	};

	var Render = function (_EventHandler) {
		_inheritsLoose(Render, _EventHandler);

		function Render() {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._meshes = null;
			return _this;
		}

		var _proto = Render.prototype;

		_proto.destroy = function destroy() {
			this.meshes = null;
		};

		_proto.decRefMeshes = function decRefMeshes() {
			if (this._meshes) {
				var count = this._meshes.length;

				for (var i = 0; i < count; i++) {
					var mesh = this._meshes[i];

					if (mesh) {
						mesh.decRefCount();

						if (mesh.refCount < 1) {
							mesh.destroy();
							this._meshes[i] = null;
						}
					}
				}
			}
		};

		_proto.incRefMeshes = function incRefMeshes() {
			if (this._meshes) {
				var count = this._meshes.length;

				for (var i = 0; i < count; i++) {
					if (this._meshes[i]) {
						this._meshes[i].incRefCount();
					}
				}
			}
		};

		_createClass(Render, [{
			key: "meshes",
			get: function get() {
				return this._meshes;
			},
			set: function set(value) {
				this.decRefMeshes();
				this._meshes = value;
				this.incRefMeshes();
				this.fire('set:meshes', value);
			}
		}]);

		return Render;
	}(EventHandler);

	var AnimCurve = function () {
		function AnimCurve(paths, input, output, interpolation) {
			this._paths = paths;
			this._input = input;
			this._output = output;
			this._interpolation = interpolation;
		}

		_createClass(AnimCurve, [{
			key: "paths",
			get: function get() {
				return this._paths;
			}
		}, {
			key: "input",
			get: function get() {
				return this._input;
			}
		}, {
			key: "output",
			get: function get() {
				return this._output;
			}
		}, {
			key: "interpolation",
			get: function get() {
				return this._interpolation;
			}
		}]);

		return AnimCurve;
	}();

	var AnimData = function () {
		function AnimData(components, data) {
			this._components = components;
			this._data = data;
		}

		_createClass(AnimData, [{
			key: "components",
			get: function get() {
				return this._components;
			}
		}, {
			key: "data",
			get: function get() {
				return this._data;
			}
		}]);

		return AnimData;
	}();

	var AnimEvents = function () {
		function AnimEvents(events) {
			this._events = [].concat(events);

			this._events.sort(function (a, b) {
				return a.time - b.time;
			});
		}

		_createClass(AnimEvents, [{
			key: "events",
			get: function get() {
				return this._events;
			}
		}]);

		return AnimEvents;
	}();

	var AnimTrack = function () {
		function AnimTrack(name, duration, inputs, outputs, curves, animEvents) {
			if (animEvents === void 0) {
				animEvents = new AnimEvents([]);
			}

			this._name = name;
			this._duration = duration;
			this._inputs = inputs;
			this._outputs = outputs;
			this._curves = curves;
			this._animEvents = animEvents;
		}

		var _proto = AnimTrack.prototype;

		_proto.eval = function _eval(time, snapshot) {
			snapshot._time = time;
			var inputs = this._inputs;
			var outputs = this._outputs;
			var curves = this._curves;
			var cache = snapshot._cache;
			var results = snapshot._results;

			for (var i = 0; i < inputs.length; ++i) {
				cache[i].update(time, inputs[i]._data);
			}

			for (var _i = 0; _i < curves.length; ++_i) {
				var curve = curves[_i];
				var output = outputs[curve._output];
				var result = results[_i];

				cache[curve._input].eval(result, curve._interpolation, output);
			}
		};

		_createClass(AnimTrack, [{
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "duration",
			get: function get() {
				return this._duration;
			}
		}, {
			key: "inputs",
			get: function get() {
				return this._inputs;
			}
		}, {
			key: "outputs",
			get: function get() {
				return this._outputs;
			}
		}, {
			key: "curves",
			get: function get() {
				return this._curves;
			}
		}, {
			key: "events",
			get: function get() {
				return this._animEvents.events;
			},
			set: function set(animEvents) {
				this._animEvents = animEvents;
			}
		}]);

		return AnimTrack;
	}();

	var INTERPOLATION_STEP = 0;
	var INTERPOLATION_LINEAR = 1;
	var INTERPOLATION_CUBIC = 2;

	var DEFAULT_LOCALE = 'en-US';
	var DEFAULT_LOCALE_FALLBACKS = {
		'en': 'en-US',
		'es': 'en-ES',
		'zh': 'zh-CN',
		'zh-HK': 'zh-TW',
		'zh-TW': 'zh-HK',
		'zh-MO': 'zh-HK',
		'fr': 'fr-FR',
		'de': 'de-DE',
		'it': 'it-IT',
		'ru': 'ru-RU',
		'ja': 'ja-JP'
	};

	var PLURALS = {};

	function definePluralFn(locales, fn) {
		for (var i = 0, len = locales.length; i < len; i++) {
			PLURALS[locales[i]] = fn;
		}
	}

	function getLang(locale) {
		var idx = locale.indexOf('-');

		if (idx !== -1) {
			return locale.substring(0, idx);
		}

		return locale;
	}

	function replaceLang(locale, desiredLang) {
		var idx = locale.indexOf('-');

		if (idx !== -1) {
			return desiredLang + locale.substring(idx);
		}

		return desiredLang;
	}

	function findAvailableLocale(desiredLocale, availableLocales) {
		if (availableLocales[desiredLocale]) {
			return desiredLocale;
		}

		var fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];

		if (fallback && availableLocales[fallback]) {
			return fallback;
		}

		var lang = getLang(desiredLocale);
		fallback = DEFAULT_LOCALE_FALLBACKS[lang];

		if (availableLocales[fallback]) {
			return fallback;
		}

		if (availableLocales[lang]) {
			return lang;
		}

		return DEFAULT_LOCALE;
	}

	definePluralFn(['ja', 'ko', 'th', 'vi', 'zh', 'id'], function (n) {
		return 0;
	});
	definePluralFn(['fa', 'hi'], function (n) {
		if (n >= 0 && n <= 1) {
			return 0;
		}

		return 1;
	});
	definePluralFn(['fr', 'pt'], function (n) {
		if (n >= 0 && n < 2) {
			return 0;
		}

		return 1;
	});
	definePluralFn(['da'], function (n) {
		if (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {
			return 0;
		}

		return 1;
	});
	definePluralFn(['de', 'en', 'it', 'el', 'es', 'tr', 'fi', 'sv', 'nb', 'no', 'ur'], function (n) {
		if (n === 1) {
			return 0;
		}

		return 1;
	});
	definePluralFn(['ru', 'uk'], function (n) {
		if (Number.isInteger(n)) {
			var mod10 = n % 10;
			var mod100 = n % 100;

			if (mod10 === 1 && mod100 !== 11) {
				return 0;
			} else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
				return 1;
			} else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {
				return 2;
			}
		}

		return 3;
	});
	definePluralFn(['pl'], function (n) {
		if (Number.isInteger(n)) {
			if (n === 1) {
				return 0;
			}

			var mod10 = n % 10;
			var mod100 = n % 100;

			if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
				return 1;
			} else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {
				return 2;
			}
		}

		return 3;
	});
	definePluralFn(['ar'], function (n) {
		if (n === 0) {
			return 0;
		} else if (n === 1) {
			return 1;
		} else if (n === 2) {
			return 2;
		}

		if (Number.isInteger(n)) {
			var mod100 = n % 100;

			if (mod100 >= 3 && mod100 <= 10) {
				return 3;
			} else if (mod100 >= 11 && mod100 <= 99) {
				return 4;
			}
		}

		return 5;
	});
	var DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];

	function getPluralFn(lang) {
		return PLURALS[lang] || DEFAULT_PLURAL_FN;
	}

	var ABSOLUTE_URL = new RegExp('^' + '\\s*' + '(?:' + '(?:' + '[a-z]+[a-z0-9\\-\\+\\.]*' + ':' + ')?' + '//' + '|' + 'data:' + '|blob:' + ')', 'i');
	var ASSET_ANIMATION = 'animation';
	var ASSET_AUDIO = 'audio';
	var ASSET_IMAGE = 'image';
	var ASSET_JSON = 'json';
	var ASSET_MODEL = 'model';
	var ASSET_MATERIAL = 'material';
	var ASSET_TEXT = 'text';
	var ASSET_TEXTURE = 'texture';
	var ASSET_CUBEMAP = 'cubemap';
	var ASSET_SHADER = 'shader';
	var ASSET_CSS = 'css';
	var ASSET_HTML = 'html';
	var ASSET_SCRIPT = 'script';
	var ASSET_CONTAINER = 'container';

	var AssetFile = function () {
		function AssetFile(url, filename, hash, size, opt, contents) {
			this.url = url || '';
			this.filename = filename || '';
			this.hash = hash === undefined ? null : hash;
			this.size = size === undefined ? null : size;
			this.opt = opt === undefined ? null : opt;
			this.contents = contents || null;
		}

		var _proto = AssetFile.prototype;

		_proto.equals = function equals(other) {
			return this.url === other.url && this.filename === other.filename && this.hash === other.hash && this.size === other.size && this.opt === other.opt && this.contents === other.contents;
		};

		return AssetFile;
	}();

	var assetIdCounter = -1;
	var VARIANT_SUPPORT = {
		pvr: 'extCompressedTexturePVRTC',
		dxt: 'extCompressedTextureS3TC',
		etc2: 'extCompressedTextureETC',
		etc1: 'extCompressedTextureETC1',
		basis: 'canvas'
	};
	var VARIANT_DEFAULT_PRIORITY = ['pvr', 'dxt', 'etc2', 'etc1', 'basis'];

	var Asset = function (_EventHandler) {
		_inheritsLoose(Asset, _EventHandler);

		function Asset(name, type, file, data, options) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._id = assetIdCounter--;
			_this.name = name || '';
			_this.type = type;
			_this.tags = new Tags(_assertThisInitialized(_this));
			_this._preload = false;
			_this._file = null;
			_this._data = data || {};
			_this.options = options || {};
			_this._resources = [];
			_this._i18n = {};
			_this.loaded = false;
			_this.loading = false;
			_this.registry = null;
			if (file) _this.file = file;
			return _this;
		}

		var _proto = Asset.prototype;

		_proto.getFileUrl = function getFileUrl() {
			var file = this.file;
			if (!file || !file.url) return null;
			var url = file.url;
			if (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) url = this.registry.prefix + url;

			if (this.type !== 'script' && file.hash) {
				var separator = url.indexOf('?') !== -1 ? '&' : '?';
				url += separator + 't=' + file.hash;
			}

			return url;
		};

		_proto.getAbsoluteUrl = function getAbsoluteUrl(relativePath) {
			if (relativePath.startsWith('blob:') || relativePath.startsWith('data:')) {
				return relativePath;
			}

			var base = path.getDirectory(this.file.url);
			return path.join(base, relativePath);
		};

		_proto.getLocalizedAssetId = function getLocalizedAssetId(locale) {
			locale = findAvailableLocale(locale, this._i18n);
			return this._i18n[locale] || null;
		};

		_proto.addLocalizedAssetId = function addLocalizedAssetId(locale, assetId) {
			this._i18n[locale] = assetId;
			this.fire('add:localized', locale, assetId);
		};

		_proto.removeLocalizedAssetId = function removeLocalizedAssetId(locale) {
			var assetId = this._i18n[locale];

			if (assetId) {
				delete this._i18n[locale];
				this.fire('remove:localized', locale, assetId);
			}
		};

		_proto.ready = function ready(callback, scope) {
			scope = scope || this;

			if (this.resource) {
				callback.call(scope, this);
			} else {
				this.once("load", function (asset) {
					callback.call(scope, asset);
				});
			}
		};

		_proto.reload = function reload() {
			if (this.loaded) {
				this.loaded = false;
				this.registry.load(this);
			}
		};

		_proto.unload = function unload() {
			if (!this.loaded && this._resources.length === 0) return;
			this.fire('unload', this);
			this.registry.fire('unload:' + this.id, this);
			var old = this._resources;
			this.resources = [];
			this.loaded = false;

			if (this.file) {
				this.registry._loader.clearCache(this.getFileUrl(), this.type);
			}

			for (var i = 0; i < old.length; ++i) {
				var resource = old[i];

				if (resource && resource.destroy) {
					resource.destroy();
				}
			}
		};

		Asset.fetchArrayBuffer = function fetchArrayBuffer(loadUrl, callback, asset, maxRetries) {
			var _asset$file;

			if (maxRetries === void 0) {
				maxRetries = 0;
			}

			if (asset != null && (_asset$file = asset.file) != null && _asset$file.contents) {
				setTimeout(function () {
					callback(null, asset.file.contents);
				});
			} else {
				http.get(loadUrl, {
					cache: true,
					responseType: 'arraybuffer',
					retry: maxRetries > 0,
					maxRetries: maxRetries
				}, callback);
			}
		};

		_createClass(Asset, [{
			key: "id",
			get: function get() {
				return this._id;
			},
			set: function set(value) {
				this._id = value;
			}
		}, {
			key: "file",
			get: function get() {
				return this._file;
			},
			set: function set(value) {
				var _this2 = this;

				if (value && value.variants && ['texture', 'textureatlas', 'bundle'].indexOf(this.type) !== -1) {
					var _this$registry, _this$registry$_loade;

					var app = ((_this$registry = this.registry) == null ? void 0 : (_this$registry$_loade = _this$registry._loader) == null ? void 0 : _this$registry$_loade._app) || getApplication();
					var device = app == null ? void 0 : app.graphicsDevice;

					if (device) {
						var _loop = function _loop(i, len) {
							var variant = VARIANT_DEFAULT_PRIORITY[i];

							if (value.variants[variant] && device[VARIANT_SUPPORT[variant]]) {
								value = value.variants[variant];
								return "break";
							}

							if (app.enableBundles) {
								var bundles = app.bundles.listBundlesForAsset(_this2);

								if (bundles && bundles.find(function (b) {
									var _b$file;

									return b == null ? void 0 : (_b$file = b.file) == null ? void 0 : _b$file.variants[variant];
								})) {
									return "break";
								}
							}
						};

						for (var i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {
							var _ret = _loop(i, len);

							if (_ret === "break") break;
						}
					}
				}

				var oldFile = this._file;
				var newFile = value ? new AssetFile(value.url, value.filename, value.hash, value.size, value.opt, value.contents) : null;

				if (!!newFile !== !!oldFile || newFile && !newFile.equals(oldFile)) {
					this._file = newFile;
					this.fire('change', this, 'file', newFile, oldFile);
					this.reload();
				}
			}
		}, {
			key: "data",
			get: function get() {
				return this._data;
			},
			set: function set(value) {
				var old = this._data;
				this._data = value;

				if (value !== old) {
					this.fire('change', this, 'data', value, old);
					if (this.loaded) this.registry._loader.patch(this, this.registry);
				}
			}
		}, {
			key: "resource",
			get: function get() {
				return this._resources[0];
			},
			set: function set(value) {
				var _old = this._resources[0];
				this._resources[0] = value;
				this.fire('change', this, 'resource', value, _old);
			}
		}, {
			key: "resources",
			get: function get() {
				return this._resources;
			},
			set: function set(value) {
				var _old = this._resources;
				this._resources = value;
				this.fire('change', this, 'resources', value, _old);
			}
		}, {
			key: "preload",
			get: function get() {
				return this._preload;
			},
			set: function set(value) {
				value = !!value;
				if (this._preload === value) return;
				this._preload = value;
				if (this._preload && !this.loaded && !this.loading && this.registry) this.registry.load(this);
			}
		}, {
			key: "loadFaces",
			get: function get() {
				return this._loadFaces;
			},
			set: function set(value) {
				value = !!value;

				if (!this.hasOwnProperty('_loadFaces') || value !== this._loadFaces) {
					this._loadFaces = value;
					if (this.loaded) this.registry._loader.patch(this, this.registry);
				}
			}
		}]);

		return Asset;
	}(EventHandler);

	var SkinInstanceCachedObject = function (_RefCountedObject) {
		_inheritsLoose(SkinInstanceCachedObject, _RefCountedObject);

		function SkinInstanceCachedObject(skin, skinInstance) {
			var _this;

			_this = _RefCountedObject.call(this) || this;
			_this.skin = skin;
			_this.skinInstance = skinInstance;
			return _this;
		}

		return SkinInstanceCachedObject;
	}(RefCountedObject);

	var SkinInstanceCache = function () {
		function SkinInstanceCache() {}

		SkinInstanceCache.logCachedSkinInstances = function logCachedSkinInstances() {
			console.log("CachedSkinInstances");

			SkinInstanceCache._skinInstanceCache.forEach(function (array, rootBone) {
				console.log(rootBone.name + ": Array(" + array.length + ")");

				for (var i = 0; i < array.length; i++) {
					console.log("	" + i + ": RefCount " + array[i].refCount);
				}
			});
		};

		SkinInstanceCache.createCachedSkinInstance = function createCachedSkinInstance(skin, rootBone, entity) {
			var skinInst = SkinInstanceCache.getCachedSkinInstance(skin, rootBone);

			if (!skinInst) {
				skinInst = new SkinInstance(skin);
				skinInst.resolve(rootBone, entity);
				SkinInstanceCache.addCachedSkinInstance(skin, rootBone, skinInst);
			}

			return skinInst;
		};

		SkinInstanceCache.getCachedSkinInstance = function getCachedSkinInstance(skin, rootBone) {
			var skinInstance = null;

			var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);

			if (cachedObjArray) {
				var cachedObj = cachedObjArray.find(function (element) {
					return element.skin === skin;
				});

				if (cachedObj) {
					cachedObj.incRefCount();
					skinInstance = cachedObj.skinInstance;
				}
			}

			return skinInstance;
		};

		SkinInstanceCache.addCachedSkinInstance = function addCachedSkinInstance(skin, rootBone, skinInstance) {
			var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);

			if (!cachedObjArray) {
				cachedObjArray = [];

				SkinInstanceCache._skinInstanceCache.set(rootBone, cachedObjArray);
			}

			var cachedObj = cachedObjArray.find(function (element) {
				return element.skin === skin;
			});

			if (!cachedObj) {
				cachedObj = new SkinInstanceCachedObject(skin, skinInstance);
				cachedObjArray.push(cachedObj);
			}

			cachedObj.incRefCount();
		};

		SkinInstanceCache.removeCachedSkinInstance = function removeCachedSkinInstance(skinInstance) {
			if (skinInstance) {
				var rootBone = skinInstance.rootBone;

				if (rootBone) {
					var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);

					if (cachedObjArray) {
						var cachedObjIndex = cachedObjArray.findIndex(function (element) {
							return element.skinInstance === skinInstance;
						});

						if (cachedObjIndex >= 0) {
							var cachedObj = cachedObjArray[cachedObjIndex];
							cachedObj.decRefCount();

							if (cachedObj.refCount === 0) {
								cachedObjArray.splice(cachedObjIndex, 1);

								if (!cachedObjArray.length) {
									SkinInstanceCache._skinInstanceCache.delete(rootBone);
								}

								if (skinInstance) {
									skinInstance.destroy();
									cachedObj.skinInstance = null;
								}
							}
						}
					}
				}
			}
		};

		return SkinInstanceCache;
	}();

	SkinInstanceCache._skinInstanceCache = new Map();

	var GlbContainerResource = function () {
		function GlbContainerResource(data, asset, assets, defaultMaterial) {
			var createAsset = function createAsset(type, resource, index) {
				var subAsset = GlbContainerResource.createAsset(asset.name, type, resource, index);
				assets.add(subAsset);
				return subAsset;
			};

			var renders = [];

			for (var i = 0; i < data.renders.length; ++i) {
				renders.push(createAsset('render', data.renders[i], i));
			}

			var materials = [];

			for (var _i = 0; _i < data.materials.length; ++_i) {
				materials.push(createAsset('material', data.materials[_i], _i));
			}

			var animations = [];

			for (var _i2 = 0; _i2 < data.animations.length; ++_i2) {
				animations.push(createAsset('animation', data.animations[_i2], _i2));
			}

			this.data = data;
			this._model = null;
			this._assetName = asset.name;
			this._assets = assets;
			this._defaultMaterial = defaultMaterial;
			this.renders = renders;
			this.materials = materials;
			this.textures = data.textures;
			this.animations = animations;
		}

		GlbContainerResource.createAsset = function createAsset(assetName, type, resource, index) {
			var subAsset = new Asset(assetName + '/' + type + '/' + index, type, {
				url: ''
			});
			subAsset.resource = resource;
			subAsset.loaded = true;
			return subAsset;
		};

		var _proto = GlbContainerResource.prototype;

		_proto.instantiateModelEntity = function instantiateModelEntity(options) {
			var entity = new Entity();
			entity.addComponent("model", Object.assign({
				type: "asset",
				asset: this.model
			}, options));
			return entity;
		};

		_proto.instantiateRenderEntity = function instantiateRenderEntity(options) {
			var _this = this;

			var defaultMaterial = this._defaultMaterial;
			var skinnedMeshInstances = [];

			var createMeshInstance = function createMeshInstance(root, entity, mesh, materials, skins, gltfNode) {
				var material = mesh.materialIndex === undefined ? defaultMaterial : materials[mesh.materialIndex];
				var meshInstance = new MeshInstance(mesh, material);

				if (mesh.morph) {
					meshInstance.morphInstance = new MorphInstance(mesh.morph);
				}

				if (gltfNode.hasOwnProperty('skin')) {
					skinnedMeshInstances.push({
						meshInstance: meshInstance,
						rootBone: root,
						entity: entity
					});
				}

				return meshInstance;
			};

			var cloneHierarchy = function cloneHierarchy(root, node, glb) {
				var entity = new Entity();

				node._cloneInternal(entity);

				if (!root) root = entity;
				var attachedMi = null;
				var renderAsset = null;

				for (var i = 0; i < glb.nodes.length; i++) {
					var glbNode = glb.nodes[i];

					if (glbNode === node) {
						var gltfNode = glb.gltf.nodes[i];

						if (gltfNode.hasOwnProperty('mesh')) {
							var meshGroup = glb.renders[gltfNode.mesh].meshes;
							renderAsset = _this.renders[gltfNode.mesh];

							for (var mi = 0; mi < meshGroup.length; mi++) {
								var mesh = meshGroup[mi];

								if (mesh) {
									var cloneMi = createMeshInstance(root, entity, mesh, glb.materials, glb.skins, gltfNode);

									if (!attachedMi) {
										attachedMi = [];
									}

									attachedMi.push(cloneMi);
								}
							}
						}

						if (glb.lights) {
							var lightEntity = glb.lights.get(gltfNode);

							if (lightEntity) {
								entity.addChild(lightEntity.clone());
							}
						}

						if (glb.cameras) {
							var cameraEntity = glb.cameras.get(gltfNode);

							if (cameraEntity) {
								cameraEntity.camera.system.cloneComponent(cameraEntity, entity);
							}
						}
					}
				}

				if (attachedMi) {
					entity.addComponent("render", Object.assign({
						type: "asset",
						meshInstances: attachedMi,
						rootBone: root
					}, options));
					entity.render.assignAsset(renderAsset);
				}

				var children = node.children;

				for (var _i3 = 0; _i3 < children.length; _i3++) {
					var childClone = cloneHierarchy(root, children[_i3], glb);
					entity.addChild(childClone);
				}

				return entity;
			};

			var sceneClones = [];

			for (var _iterator = _createForOfIteratorHelperLoose(this.data.scenes), _step; !(_step = _iterator()).done;) {
				var scene = _step.value;
				sceneClones.push(cloneHierarchy(null, scene, this.data));
			}

			skinnedMeshInstances.forEach(function (data) {
				data.meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(data.meshInstance.mesh.skin, data.rootBone, data.entity);
			});
			return GlbContainerResource.createSceneHierarchy(sceneClones, "Entity");
		};

		GlbContainerResource.createSceneHierarchy = function createSceneHierarchy(sceneNodes, nodeType) {
			var root = null;

			if (sceneNodes.length === 1) {
				root = sceneNodes[0];
			} else {
				root = new nodeType('SceneGroup');

				for (var _iterator2 = _createForOfIteratorHelperLoose(sceneNodes), _step2; !(_step2 = _iterator2()).done;) {
					var scene = _step2.value;
					root.addChild(scene);
				}
			}

			return root;
		};

		GlbContainerResource.createModel = function createModel(glb, defaultMaterial) {
			var createMeshInstance = function createMeshInstance(model, mesh, skins, skinInstances, materials, node, gltfNode) {
				var material = mesh.materialIndex === undefined ? defaultMaterial : materials[mesh.materialIndex];
				var meshInstance = new MeshInstance(mesh, material, node);

				if (mesh.morph) {
					var morphInstance = new MorphInstance(mesh.morph);
					meshInstance.morphInstance = morphInstance;
					model.morphInstances.push(morphInstance);
				}

				if (gltfNode.hasOwnProperty('skin')) {
					var skinIndex = gltfNode.skin;
					var skin = skins[skinIndex];
					mesh.skin = skin;
					var skinInstance = skinInstances[skinIndex];
					meshInstance.skinInstance = skinInstance;
					model.skinInstances.push(skinInstance);
				}

				model.meshInstances.push(meshInstance);
			};

			var model = new Model();
			var skinInstances = [];

			for (var _iterator3 = _createForOfIteratorHelperLoose(glb.skins), _step3; !(_step3 = _iterator3()).done;) {
				var skin = _step3.value;
				var skinInstance = new SkinInstance(skin);
				skinInstance.bones = skin.bones;
				skinInstances.push(skinInstance);
			}

			model.graph = GlbContainerResource.createSceneHierarchy(glb.scenes, "GraphNode");

			for (var i = 0; i < glb.nodes.length; i++) {
				var node = glb.nodes[i];

				if (node.root === model.graph) {
					var gltfNode = glb.gltf.nodes[i];

					if (gltfNode.hasOwnProperty('mesh')) {
						var meshGroup = glb.renders[gltfNode.mesh].meshes;

						for (var mi = 0; mi < meshGroup.length; mi++) {
							var mesh = meshGroup[mi];

							if (mesh) {
								createMeshInstance(model, mesh, glb.skins, skinInstances, glb.materials, node, gltfNode);
							}
						}
					}
				}
			}

			return model;
		};

		_proto.destroy = function destroy() {
			var registry = this._assets;

			var destroyAsset = function destroyAsset(asset) {
				registry.remove(asset);
				asset.unload();
			};

			var destroyAssets = function destroyAssets(assets) {
				assets.forEach(function (asset) {
					destroyAsset(asset);
				});
			};

			if (this.animations) {
				destroyAssets(this.animations);
				this.animations = null;
			}

			if (this.textures) {
				destroyAssets(this.textures);
				this.textures = null;
			}

			if (this.materials) {
				destroyAssets(this.materials);
				this.materials = null;
			}

			if (this.renders) {
				destroyAssets(this.renders);
				this.renders = null;
			}

			if (this._model) {
				destroyAsset(this._model);
				this._model = null;
			}

			this.data = null;
			this.assets = null;
		};

		_createClass(GlbContainerResource, [{
			key: "model",
			get: function get() {
				if (!this._model) {
					var model = GlbContainerResource.createModel(this.data, this._defaultMaterial);
					var modelAsset = GlbContainerResource.createAsset(this._assetName, 'model', model, 0);

					this._assets.add(modelAsset);

					this._model = modelAsset;
				}

				return this._model;
			}
		}]);

		return GlbContainerResource;
	}();

	var GlbResources = function () {
		function GlbResources(gltf) {
			this.gltf = gltf;
			this.nodes = null;
			this.scenes = null;
			this.animations = null;
			this.textures = null;
			this.materials = null;
			this.renders = null;
			this.skins = null;
			this.lights = null;
			this.cameras = null;
		}

		var _proto = GlbResources.prototype;

		_proto.destroy = function destroy() {
			if (this.renders) {
				this.renders.forEach(function (render) {
					render.meshes = null;
				});
			}
		};

		return GlbResources;
	}();

	var isDataURI = function isDataURI(uri) {
		return /^data:.*,.*$/i.test(uri);
	};

	var getDataURIMimeType = function getDataURIMimeType(uri) {
		return uri.substring(uri.indexOf(":") + 1, uri.indexOf(";"));
	};

	var getNumComponents = function getNumComponents(accessorType) {
		switch (accessorType) {
			case 'SCALAR':
				return 1;

			case 'VEC2':
				return 2;

			case 'VEC3':
				return 3;

			case 'VEC4':
				return 4;

			case 'MAT2':
				return 4;

			case 'MAT3':
				return 9;

			case 'MAT4':
				return 16;

			default:
				return 3;
		}
	};

	var getComponentType = function getComponentType(componentType) {
		switch (componentType) {
			case 5120:
				return TYPE_INT8;

			case 5121:
				return TYPE_UINT8;

			case 5122:
				return TYPE_INT16;

			case 5123:
				return TYPE_UINT16;

			case 5124:
				return TYPE_INT32;

			case 5125:
				return TYPE_UINT32;

			case 5126:
				return TYPE_FLOAT32;

			default:
				return 0;
		}
	};

	var getComponentSizeInBytes = function getComponentSizeInBytes(componentType) {
		switch (componentType) {
			case 5120:
				return 1;

			case 5121:
				return 1;

			case 5122:
				return 2;

			case 5123:
				return 2;

			case 5124:
				return 4;

			case 5125:
				return 4;

			case 5126:
				return 4;

			default:
				return 0;
		}
	};

	var getComponentDataType = function getComponentDataType(componentType) {
		switch (componentType) {
			case 5120:
				return Int8Array;

			case 5121:
				return Uint8Array;

			case 5122:
				return Int16Array;

			case 5123:
				return Uint16Array;

			case 5124:
				return Int32Array;

			case 5125:
				return Uint32Array;

			case 5126:
				return Float32Array;

			default:
				return null;
		}
	};

	var gltfToEngineSemanticMap = {
		'POSITION': SEMANTIC_POSITION,
		'NORMAL': SEMANTIC_NORMAL,
		'TANGENT': SEMANTIC_TANGENT,
		'COLOR_0': SEMANTIC_COLOR,
		'JOINTS_0': SEMANTIC_BLENDINDICES,
		'WEIGHTS_0': SEMANTIC_BLENDWEIGHT,
		'TEXCOORD_0': SEMANTIC_TEXCOORD0,
		'TEXCOORD_1': SEMANTIC_TEXCOORD1,
		'TEXCOORD_2': SEMANTIC_TEXCOORD2,
		'TEXCOORD_3': SEMANTIC_TEXCOORD3,
		'TEXCOORD_4': SEMANTIC_TEXCOORD4,
		'TEXCOORD_5': SEMANTIC_TEXCOORD5,
		'TEXCOORD_6': SEMANTIC_TEXCOORD6,
		'TEXCOORD_7': SEMANTIC_TEXCOORD7
	};

	var getDequantizeFunc = function getDequantizeFunc(srcType) {
		switch (srcType) {
			case TYPE_INT8:
				return function (x) {
					return Math.max(x / 127.0, -1.0);
				};

			case TYPE_UINT8:
				return function (x) {
					return x / 255.0;
				};

			case TYPE_INT16:
				return function (x) {
					return Math.max(x / 32767.0, -1.0);
				};

			case TYPE_UINT16:
				return function (x) {
					return x / 65535.0;
				};

			default:
				return function (x) {
					return x;
				};
		}
	};

	var dequantizeArray = function dequantizeArray(dstArray, srcArray, srcType) {
		var convFunc = getDequantizeFunc(srcType);
		var len = srcArray.length;

		for (var i = 0; i < len; ++i) {
			dstArray[i] = convFunc(srcArray[i]);
		}

		return dstArray;
	};

	var getAccessorData = function getAccessorData(gltfAccessor, bufferViews, flatten) {
		if (flatten === void 0) {
			flatten = false;
		}

		var numComponents = getNumComponents(gltfAccessor.type);
		var dataType = getComponentDataType(gltfAccessor.componentType);

		if (!dataType) {
			return null;
		}

		var bufferView = bufferViews[gltfAccessor.bufferView];
		var result;

		if (gltfAccessor.sparse) {
			var sparse = gltfAccessor.sparse;
			var indicesAccessor = {
				count: sparse.count,
				type: "SCALAR"
			};
			var indices = getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews, true);
			var valuesAccessor = {
				count: sparse.count,
				type: gltfAccessor.scalar,
				componentType: gltfAccessor.componentType
			};
			var values = getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews, true);

			if (gltfAccessor.hasOwnProperty('bufferView')) {
				var baseAccessor = {
					bufferView: gltfAccessor.bufferView,
					byteOffset: gltfAccessor.byteOffset,
					componentType: gltfAccessor.componentType,
					count: gltfAccessor.count,
					type: gltfAccessor.type
				};
				result = getAccessorData(baseAccessor, bufferViews, true).slice();
			} else {
				result = new dataType(gltfAccessor.count * numComponents);
			}

			for (var i = 0; i < sparse.count; ++i) {
				var targetIndex = indices[i];

				for (var j = 0; j < numComponents; ++j) {
					result[targetIndex * numComponents + j] = values[i * numComponents + j];
				}
			}
		} else if (flatten && bufferView.hasOwnProperty('byteStride')) {
			var bytesPerElement = numComponents * dataType.BYTES_PER_ELEMENT;
			var storage = new ArrayBuffer(gltfAccessor.count * bytesPerElement);
			var tmpArray = new Uint8Array(storage);
			var dstOffset = 0;

			for (var _i = 0; _i < gltfAccessor.count; ++_i) {
				var srcOffset = (gltfAccessor.byteOffset || 0) + _i * bufferView.byteStride;

				for (var b = 0; b < bytesPerElement; ++b) {
					tmpArray[dstOffset++] = bufferView[srcOffset++];
				}
			}

			result = new dataType(storage);
		} else {
			result = new dataType(bufferView.buffer, bufferView.byteOffset + (gltfAccessor.byteOffset || 0), gltfAccessor.count * numComponents);
		}

		return result;
	};

	var getAccessorDataFloat32 = function getAccessorDataFloat32(gltfAccessor, bufferViews) {
		var data = getAccessorData(gltfAccessor, bufferViews, true);

		if (data instanceof Float32Array || !gltfAccessor.normalized) {
			return data;
		}

		var float32Data = new Float32Array(data.length);
		dequantizeArray(float32Data, data, getComponentType(gltfAccessor.componentType));
		return float32Data;
	};

	var getAccessorBoundingBox = function getAccessorBoundingBox(gltfAccessor) {
		var min = gltfAccessor.min;
		var max = gltfAccessor.max;

		if (!min || !max) {
			return null;
		}

		if (gltfAccessor.normalized) {
			var ctype = getComponentType(gltfAccessor.componentType);
			min = dequantizeArray([], min, ctype);
			max = dequantizeArray([], max, ctype);
		}

		return new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
	};

	var getPrimitiveType = function getPrimitiveType(primitive) {
		if (!primitive.hasOwnProperty('mode')) {
			return PRIMITIVE_TRIANGLES;
		}

		switch (primitive.mode) {
			case 0:
				return PRIMITIVE_POINTS;

			case 1:
				return PRIMITIVE_LINES;

			case 2:
				return PRIMITIVE_LINELOOP;

			case 3:
				return PRIMITIVE_LINESTRIP;

			case 4:
				return PRIMITIVE_TRIANGLES;

			case 5:
				return PRIMITIVE_TRISTRIP;

			case 6:
				return PRIMITIVE_TRIFAN;

			default:
				return PRIMITIVE_TRIANGLES;
		}
	};

	var generateIndices = function generateIndices(numVertices) {
		var dummyIndices = new Uint16Array(numVertices);

		for (var i = 0; i < numVertices; i++) {
			dummyIndices[i] = i;
		}

		return dummyIndices;
	};

	var generateNormals = function generateNormals(sourceDesc, indices) {
		var p = sourceDesc[SEMANTIC_POSITION];

		if (!p || p.components !== 3) {
			return;
		}

		var positions;

		if (p.size !== p.stride) {
			var srcStride = p.stride / typedArrayTypesByteSize[p.type];
			var src = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);
			positions = new typedArrayTypes[p.type](p.count * 3);

			for (var i = 0; i < p.count; ++i) {
				positions[i * 3 + 0] = src[i * srcStride + 0];
				positions[i * 3 + 1] = src[i * srcStride + 1];
				positions[i * 3 + 2] = src[i * srcStride + 2];
			}
		} else {
			positions = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);
		}

		var numVertices = p.count;

		if (!indices) {
			indices = generateIndices(numVertices);
		}

		var normalsTemp = calculateNormals(positions, indices);
		var normals = new Float32Array(normalsTemp.length);
		normals.set(normalsTemp);
		sourceDesc[SEMANTIC_NORMAL] = {
			buffer: normals.buffer,
			size: 12,
			offset: 0,
			stride: 12,
			count: numVertices,
			components: 3,
			type: TYPE_FLOAT32
		};
	};

	var flipTexCoordVs = function flipTexCoordVs(vertexBuffer) {
		var i, j;
		var floatOffsets = [];
		var shortOffsets = [];
		var byteOffsets = [];

		for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
			var element = vertexBuffer.format.elements[i];

			if (element.name === SEMANTIC_TEXCOORD0 || element.name === SEMANTIC_TEXCOORD1) {
				switch (element.dataType) {
					case TYPE_FLOAT32:
						floatOffsets.push({
							offset: element.offset / 4 + 1,
							stride: element.stride / 4
						});
						break;

					case TYPE_UINT16:
						shortOffsets.push({
							offset: element.offset / 2 + 1,
							stride: element.stride / 2
						});
						break;

					case TYPE_UINT8:
						byteOffsets.push({
							offset: element.offset + 1,
							stride: element.stride
						});
						break;
				}
			}
		}

		var flip = function flip(offsets, type, one) {
			var typedArray = new type(vertexBuffer.storage);

			for (i = 0; i < offsets.length; ++i) {
				var index = offsets[i].offset;
				var stride = offsets[i].stride;

				for (j = 0; j < vertexBuffer.numVertices; ++j) {
					typedArray[index] = one - typedArray[index];
					index += stride;
				}
			}
		};

		if (floatOffsets.length > 0) {
			flip(floatOffsets, Float32Array, 1.0);
		}

		if (shortOffsets.length > 0) {
			flip(shortOffsets, Uint16Array, 65535);
		}

		if (byteOffsets.length > 0) {
			flip(byteOffsets, Uint8Array, 255);
		}
	};

	var cloneTexture = function cloneTexture(texture) {
		var shallowCopyLevels = function shallowCopyLevels(texture) {
			var result = [];

			for (var mip = 0; mip < texture._levels.length; ++mip) {
				var level = [];

				if (texture.cubemap) {
					for (var face = 0; face < 6; ++face) {
						level.push(texture._levels[mip][face]);
					}
				} else {
					level = texture._levels[mip];
				}

				result.push(level);
			}

			return result;
		};

		var result = new Texture(texture.device, texture);
		result._levels = shallowCopyLevels(texture);
		return result;
	};

	var cloneTextureAsset = function cloneTextureAsset(src) {
		var result = new Asset(src.name + '_clone', src.type, src.file, src.data, src.options);
		result.loaded = true;
		result.resource = cloneTexture(src.resource);
		src.registry.add(result);
		return result;
	};

	var createVertexBufferInternal = function createVertexBufferInternal(device, sourceDesc, flipV) {
		var positionDesc = sourceDesc[SEMANTIC_POSITION];

		if (!positionDesc) {
			return null;
		}

		var numVertices = positionDesc.count;
		var vertexDesc = [];

		for (var semantic in sourceDesc) {
			if (sourceDesc.hasOwnProperty(semantic)) {
				vertexDesc.push({
					semantic: semantic,
					components: sourceDesc[semantic].components,
					type: sourceDesc[semantic].type,
					normalize: !!sourceDesc[semantic].normalize
				});
			}
		}

		var elementOrder = [SEMANTIC_POSITION, SEMANTIC_NORMAL, SEMANTIC_TANGENT, SEMANTIC_COLOR, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1];
		vertexDesc.sort(function (lhs, rhs) {
			var lhsOrder = elementOrder.indexOf(lhs.semantic);
			var rhsOrder = elementOrder.indexOf(rhs.semantic);
			return lhsOrder < rhsOrder ? -1 : rhsOrder < lhsOrder ? 1 : 0;
		});
		var i, j, k;
		var source, target, sourceOffset;
		var vertexFormat = new VertexFormat(device, vertexDesc);
		var isCorrectlyInterleaved = true;

		for (i = 0; i < vertexFormat.elements.length; ++i) {
			target = vertexFormat.elements[i];
			source = sourceDesc[target.name];
			sourceOffset = source.offset - positionDesc.offset;

			if (source.buffer !== positionDesc.buffer || source.stride !== target.stride || source.size !== target.size || sourceOffset !== target.offset) {
				isCorrectlyInterleaved = false;
				break;
			}
		}

		var vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices, BUFFER_STATIC);
		var vertexData = vertexBuffer.lock();
		var targetArray = new Uint32Array(vertexData);
		var sourceArray;

		if (isCorrectlyInterleaved) {
			sourceArray = new Uint32Array(positionDesc.buffer, positionDesc.offset, numVertices * vertexBuffer.format.size / 4);
			targetArray.set(sourceArray);
		} else {
			var targetStride, sourceStride;

			for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
				target = vertexBuffer.format.elements[i];
				targetStride = target.stride / 4;
				source = sourceDesc[target.name];
				sourceStride = source.stride / 4;
				sourceArray = new Uint32Array(source.buffer, source.offset, (source.count - 1) * sourceStride + (source.size + 3) / 4);
				var src = 0;
				var dst = target.offset / 4;
				var kend = Math.floor((source.size + 3) / 4);

				for (j = 0; j < numVertices; ++j) {
					for (k = 0; k < kend; ++k) {
						targetArray[dst + k] = sourceArray[src + k];
					}

					src += sourceStride;
					dst += targetStride;
				}
			}
		}

		if (flipV) {
			flipTexCoordVs(vertexBuffer);
		}

		vertexBuffer.unlock();
		return vertexBuffer;
	};

	var createVertexBuffer = function createVertexBuffer(device, attributes, indices, accessors, bufferViews, flipV, vertexBufferDict) {
		var useAttributes = {};
		var attribIds = [];

		for (var attrib in attributes) {
			if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
				useAttributes[attrib] = attributes[attrib];
				attribIds.push(attrib + ":" + attributes[attrib]);
			}
		}

		attribIds.sort();
		var vbKey = attribIds.join();
		var vb = vertexBufferDict[vbKey];

		if (!vb) {
			var sourceDesc = {};

			for (var _attrib in useAttributes) {
				var accessor = accessors[attributes[_attrib]];
				var accessorData = getAccessorData(accessor, bufferViews);
				var bufferView = bufferViews[accessor.bufferView];
				var semantic = gltfToEngineSemanticMap[_attrib];
				var size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);
				var stride = bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size;
				sourceDesc[semantic] = {
					buffer: accessorData.buffer,
					size: size,
					offset: accessorData.byteOffset,
					stride: stride,
					count: accessor.count,
					components: getNumComponents(accessor.type),
					type: getComponentType(accessor.componentType),
					normalize: accessor.normalized
				};
			}

			if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
				generateNormals(sourceDesc, indices);
			}

			vb = createVertexBufferInternal(device, sourceDesc, flipV);
			vertexBufferDict[vbKey] = vb;
		}

		return vb;
	};

	var createVertexBufferDraco = function createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV) {
		var numPoints = outputGeometry.num_points();

		var extractDracoAttributeInfo = function extractDracoAttributeInfo(uniqueId) {
			var attribute = decoder.GetAttributeByUniqueId(outputGeometry, uniqueId);
			var numValues = numPoints * attribute.num_components();
			var dracoFormat = attribute.data_type();
			var ptr, values, componentSizeInBytes, storageType;

			switch (dracoFormat) {
				case decoderModule.DT_UINT8:
					storageType = TYPE_UINT8;
					componentSizeInBytes = 1;
					ptr = decoderModule._malloc(numValues * componentSizeInBytes);
					decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT8, numValues * componentSizeInBytes, ptr);
					values = new Uint8Array(decoderModule.HEAPU8.buffer, ptr, numValues).slice();
					break;

				case decoderModule.DT_UINT16:
					storageType = TYPE_UINT16;
					componentSizeInBytes = 2;
					ptr = decoderModule._malloc(numValues * componentSizeInBytes);
					decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT16, numValues * componentSizeInBytes, ptr);
					values = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numValues).slice();
					break;

				case decoderModule.DT_FLOAT32:
				default:
					storageType = TYPE_FLOAT32;
					componentSizeInBytes = 4;
					ptr = decoderModule._malloc(numValues * componentSizeInBytes);
					decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_FLOAT32, numValues * componentSizeInBytes, ptr);
					values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues).slice();
					break;
			}

			decoderModule._free(ptr);

			return {
				values: values,
				numComponents: attribute.num_components(),
				componentSizeInBytes: componentSizeInBytes,
				storageType: storageType,
				normalized: attribute.normalized()
			};
		};

		var sourceDesc = {};
		var attributes = extDraco.attributes;

		for (var attrib in attributes) {
			if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
				var semantic = gltfToEngineSemanticMap[attrib];
				var attributeInfo = extractDracoAttributeInfo(attributes[attrib]);
				var size = attributeInfo.numComponents * attributeInfo.componentSizeInBytes;
				sourceDesc[semantic] = {
					values: attributeInfo.values,
					buffer: attributeInfo.values.buffer,
					size: size,
					offset: 0,
					stride: size,
					count: numPoints,
					components: attributeInfo.numComponents,
					type: attributeInfo.storageType,
					normalize: attributeInfo.normalized
				};
			}
		}

		if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
			generateNormals(sourceDesc, indices);
		}

		return createVertexBufferInternal(device, sourceDesc, flipV);
	};

	var createSkin = function createSkin(device, gltfSkin, accessors, bufferViews, nodes, glbSkins) {
		var i, j, bindMatrix;
		var joints = gltfSkin.joints;
		var numJoints = joints.length;
		var ibp = [];

		if (gltfSkin.hasOwnProperty('inverseBindMatrices')) {
			var inverseBindMatrices = gltfSkin.inverseBindMatrices;
			var ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews, true);
			var ibmValues = [];

			for (i = 0; i < numJoints; i++) {
				for (j = 0; j < 16; j++) {
					ibmValues[j] = ibmData[i * 16 + j];
				}

				bindMatrix = new Mat4();
				bindMatrix.set(ibmValues);
				ibp.push(bindMatrix);
			}
		} else {
			for (i = 0; i < numJoints; i++) {
				bindMatrix = new Mat4();
				ibp.push(bindMatrix);
			}
		}

		var boneNames = [];

		for (i = 0; i < numJoints; i++) {
			boneNames[i] = nodes[joints[i]].name;
		}

		var key = boneNames.join("#");
		var skin = glbSkins.get(key);

		if (!skin) {
			skin = new Skin(device, ibp, boneNames);
			glbSkins.set(key, skin);
		}

		return skin;
	};

	var tempMat = new Mat4();
	var tempVec$1 = new Vec3();

	var createMesh = function createMesh(device, gltfMesh, accessors, bufferViews, callback, flipV, vertexBufferDict) {
		var meshes = [];
		gltfMesh.primitives.forEach(function (primitive) {
			var primitiveType, vertexBuffer, numIndices;
			var indices = null;
			var canUseMorph = true;

			if (primitive.hasOwnProperty('extensions')) {
				var extensions = primitive.extensions;

				if (extensions.hasOwnProperty('KHR_draco_mesh_compression')) {
					var decoderModule = window.DracoDecoderModule;

					if (decoderModule) {
						var extDraco = extensions.KHR_draco_mesh_compression;

						if (extDraco.hasOwnProperty('attributes')) {
							var uint8Buffer = bufferViews[extDraco.bufferView];
							var buffer = new decoderModule.DecoderBuffer();
							buffer.Init(uint8Buffer, uint8Buffer.length);
							var decoder = new decoderModule.Decoder();
							var geometryType = decoder.GetEncodedGeometryType(buffer);
							var outputGeometry, status;

							switch (geometryType) {
								case decoderModule.POINT_CLOUD:
									primitiveType = PRIMITIVE_POINTS;
									outputGeometry = new decoderModule.PointCloud();
									status = decoder.DecodeBufferToPointCloud(buffer, outputGeometry);
									break;

								case decoderModule.TRIANGULAR_MESH:
									primitiveType = PRIMITIVE_TRIANGLES;
									outputGeometry = new decoderModule.Mesh();
									status = decoder.DecodeBufferToMesh(buffer, outputGeometry);
									break;

								case decoderModule.INVALID_GEOMETRY_TYPE:
							}

							if (!status || !status.ok() || outputGeometry.ptr == 0) {
								callback("Failed to decode draco compressed asset: " + (status ? status.error_msg() : 'Mesh asset - invalid draco compressed geometry type: ' + geometryType));
								return;
							}

							var numFaces = outputGeometry.num_faces();

							if (geometryType === decoderModule.TRIANGULAR_MESH) {
								var bit32 = outputGeometry.num_points() > 65535;
								numIndices = numFaces * 3;
								var dataSize = numIndices * (bit32 ? 4 : 2);

								var ptr = decoderModule._malloc(dataSize);

								if (bit32) {
									decoder.GetTrianglesUInt32Array(outputGeometry, dataSize, ptr);
									indices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();
								} else {
									decoder.GetTrianglesUInt16Array(outputGeometry, dataSize, ptr);
									indices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();
								}

								decoderModule._free(ptr);
							}

							vertexBuffer = createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV);
							decoderModule.destroy(outputGeometry);
							decoderModule.destroy(decoder);
							decoderModule.destroy(buffer);
							canUseMorph = false;
						}
					} else {
						Debug.warn("File contains draco compressed data, but DracoDecoderModule is not configured.");
					}
				}
			}

			if (!vertexBuffer) {
				indices = primitive.hasOwnProperty('indices') ? getAccessorData(accessors[primitive.indices], bufferViews, true) : null;
				vertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, flipV, vertexBufferDict);
				primitiveType = getPrimitiveType(primitive);
			}

			var mesh = null;

			if (vertexBuffer) {
				mesh = new Mesh(device);
				mesh.vertexBuffer = vertexBuffer;
				mesh.primitive[0].type = primitiveType;
				mesh.primitive[0].base = 0;
				mesh.primitive[0].indexed = indices !== null;

				if (indices !== null) {
					var indexFormat;

					if (indices instanceof Uint8Array) {
						indexFormat = INDEXFORMAT_UINT8;
					} else if (indices instanceof Uint16Array) {
						indexFormat = INDEXFORMAT_UINT16;
					} else {
						indexFormat = INDEXFORMAT_UINT32;
					}

					if (indexFormat === INDEXFORMAT_UINT32 && !device.extUintElement) {
						if (vertexBuffer.numVertices > 0xFFFF) {
							console.warn("Glb file contains 32bit index buffer but these are not supported by this device - it may be rendered incorrectly.");
						}

						indexFormat = INDEXFORMAT_UINT16;
						indices = new Uint16Array(indices);
					}

					var indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);
					mesh.indexBuffer[0] = indexBuffer;
					mesh.primitive[0].count = indices.length;
				} else {
					mesh.primitive[0].count = vertexBuffer.numVertices;
				}

				mesh.materialIndex = primitive.material;
				var accessor = accessors[primitive.attributes.POSITION];
				mesh.aabb = getAccessorBoundingBox(accessor);

				if (canUseMorph && primitive.hasOwnProperty('targets')) {
					var targets = [];
					primitive.targets.forEach(function (target, index) {
						var options = {};

						if (target.hasOwnProperty('POSITION')) {
							accessor = accessors[target.POSITION];
							options.deltaPositions = getAccessorDataFloat32(accessor, bufferViews);
							options.deltaPositionsType = TYPE_FLOAT32;
							options.aabb = getAccessorBoundingBox(accessor);
						}

						if (target.hasOwnProperty('NORMAL')) {
							accessor = accessors[target.NORMAL];
							options.deltaNormals = getAccessorDataFloat32(accessor, bufferViews);
							options.deltaNormalsType = TYPE_FLOAT32;
						}

						if (gltfMesh.hasOwnProperty('extras') && gltfMesh.extras.hasOwnProperty('targetNames')) {
							options.name = gltfMesh.extras.targetNames[index];
						} else {
							options.name = index.toString(10);
						}

						if (gltfMesh.hasOwnProperty('weights')) {
							options.defaultWeight = gltfMesh.weights[index];
						}

						targets.push(new MorphTarget(options));
					});
					mesh.morph = new Morph(targets, device);
				}
			}

			meshes.push(mesh);
		});
		return meshes;
	};

	var createMaterial = function createMaterial(gltfMaterial, textures, flipV) {
		var glossChunk = ["#ifdef MAPFLOAT", "uniform float material_shininess;", "#endif", "", "#ifdef MAPTEXTURE", "uniform sampler2D texture_glossMap;", "#endif", "", "void getGlossiness() {", "		dGlossiness = 1.0;", "", "#ifdef MAPFLOAT", "		dGlossiness *= material_shininess;", "#endif", "", "#ifdef MAPTEXTURE", "		dGlossiness *= texture2D(texture_glossMap, $UV, textureBias).$CH;", "#endif", "", "#ifdef MAPVERTEX", "		dGlossiness *= saturate(vVertexColor.$VC);", "#endif", "", "		dGlossiness = 1.0 - dGlossiness;", "", "		dGlossiness += 0.0000001;", "}"].join('\n');
		var specularChunk = ["#ifdef MAPCOLOR", "uniform vec3 material_specular;", "#endif", "", "#ifdef MAPTEXTURE", "uniform sampler2D texture_specularMap;", "#endif", "", "void getSpecularity() {", "		dSpecularity = vec3(1.0);", "", "		#ifdef MAPCOLOR", "				dSpecularity *= material_specular;", "		#endif", "", "		#ifdef MAPTEXTURE", "				vec3 srgb = texture2D(texture_specularMap, $UV, textureBias).$CH;", "				dSpecularity *= vec3(pow(srgb.r, 2.2), pow(srgb.g, 2.2), pow(srgb.b, 2.2));", "		#endif", "", "		#ifdef MAPVERTEX", "				dSpecularity *= saturate(vVertexColor.$VC);", "		#endif", "}"].join('\n');
		var clearCoatGlossChunk = ["#ifdef MAPFLOAT", "uniform float material_clearCoatGlossiness;", "#endif", "", "#ifdef MAPTEXTURE", "uniform sampler2D texture_clearCoatGlossMap;", "#endif", "", "void getClearCoatGlossiness() {", "		ccGlossiness = 1.0;", "", "#ifdef MAPFLOAT", "		ccGlossiness *= material_clearCoatGlossiness;", "#endif", "", "#ifdef MAPTEXTURE", "		ccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV, textureBias).$CH;", "#endif", "", "#ifdef MAPVERTEX", "		ccGlossiness *= saturate(vVertexColor.$VC);", "#endif", "", "		ccGlossiness = 1.0 - ccGlossiness;", "", "		ccGlossiness += 0.0000001;", "}"].join('\n');
		var zeros = [0, 0];
		var ones = [1, 1];

		var extractTextureTransform = function extractTextureTransform(source, material, maps) {
			var _source$extensions;

			var map;
			var texCoord = source.texCoord;

			if (texCoord) {
				for (map = 0; map < maps.length; ++map) {
					material[maps[map] + 'MapUv'] = texCoord;
				}
			}

			var textureTransform = (_source$extensions = source.extensions) == null ? void 0 : _source$extensions.KHR_texture_transform;

			if (textureTransform) {
				var offset = textureTransform.offset || zeros;
				var scale = textureTransform.scale || ones;
				var rotation = textureTransform.rotation ? -textureTransform.rotation * math.RAD_TO_DEG : 0;
				var tilingVec = new Vec2(scale[0], scale[1]);
				var offsetVec = new Vec2(offset[0], 1.0 - scale[1] - offset[1]);

				for (map = 0; map < maps.length; ++map) {
					material[maps[map] + "MapTiling"] = tilingVec;
					material[maps[map] + "MapOffset"] = offsetVec;
					material[maps[map] + "MapRotation"] = rotation;
				}
			}
		};

		var material = new StandardMaterial();
		material.occludeSpecular = true;
		material.diffuseTint = true;
		material.diffuseVertexColor = true;
		material.specularTint = true;
		material.specularVertexColor = true;

		if (gltfMaterial.hasOwnProperty('name')) {
			material.name = gltfMaterial.name;
		}

		var color, texture;

		if (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_pbrSpecularGlossiness')) {
			var specData = gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness;

			if (specData.hasOwnProperty('diffuseFactor')) {
				color = specData.diffuseFactor;
				material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
				material.opacity = color[3];
			} else {
				material.diffuse.set(1, 1, 1);
				material.opacity = 1;
			}

			if (specData.hasOwnProperty('diffuseTexture')) {
				var diffuseTexture = specData.diffuseTexture;
				texture = textures[diffuseTexture.index];
				material.diffuseMap = texture;
				material.diffuseMapChannel = 'rgb';
				material.opacityMap = texture;
				material.opacityMapChannel = 'a';
				extractTextureTransform(diffuseTexture, material, ['diffuse', 'opacity']);
			}

			material.useMetalness = false;

			if (specData.hasOwnProperty('specularFactor')) {
				color = specData.specularFactor;
				material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
			} else {
				material.specular.set(1, 1, 1);
			}

			if (specData.hasOwnProperty('glossinessFactor')) {
				material.shininess = 100 * specData.glossinessFactor;
			} else {
				material.shininess = 100;
			}

			if (specData.hasOwnProperty('specularGlossinessTexture')) {
				var specularGlossinessTexture = specData.specularGlossinessTexture;
				material.specularMap = material.glossMap = textures[specularGlossinessTexture.index];
				material.specularMapChannel = 'rgb';
				material.glossMapChannel = 'a';
				extractTextureTransform(specularGlossinessTexture, material, ['gloss', 'metalness']);
			}

			material.chunks.specularPS = specularChunk;
		} else if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {
			var pbrData = gltfMaterial.pbrMetallicRoughness;

			if (pbrData.hasOwnProperty('baseColorFactor')) {
				color = pbrData.baseColorFactor;
				material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
				material.opacity = color[3];
			} else {
				material.diffuse.set(1, 1, 1);
				material.opacity = 1;
			}

			if (pbrData.hasOwnProperty('baseColorTexture')) {
				var baseColorTexture = pbrData.baseColorTexture;
				texture = textures[baseColorTexture.index];
				material.diffuseMap = texture;
				material.diffuseMapChannel = 'rgb';
				material.opacityMap = texture;
				material.opacityMapChannel = 'a';
				extractTextureTransform(baseColorTexture, material, ['diffuse', 'opacity']);
			}

			material.useMetalness = true;

			if (pbrData.hasOwnProperty('metallicFactor')) {
				material.metalness = pbrData.metallicFactor;
			} else {
				material.metalness = 1;
			}

			if (pbrData.hasOwnProperty('roughnessFactor')) {
				material.shininess = 100 * pbrData.roughnessFactor;
			} else {
				material.shininess = 100;
			}

			if (pbrData.hasOwnProperty('metallicRoughnessTexture')) {
				var metallicRoughnessTexture = pbrData.metallicRoughnessTexture;
				material.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];
				material.metalnessMapChannel = 'b';
				material.glossMapChannel = 'g';
				extractTextureTransform(metallicRoughnessTexture, material, ['gloss', 'metalness']);
			}

			material.chunks.glossPS = glossChunk;
		}

		if (gltfMaterial.hasOwnProperty('normalTexture')) {
			var normalTexture = gltfMaterial.normalTexture;
			material.normalMap = textures[normalTexture.index];
			extractTextureTransform(normalTexture, material, ['normal']);

			if (normalTexture.hasOwnProperty('scale')) {
				material.bumpiness = normalTexture.scale;
			}
		}

		if (gltfMaterial.hasOwnProperty('occlusionTexture')) {
			var occlusionTexture = gltfMaterial.occlusionTexture;
			material.aoMap = textures[occlusionTexture.index];
			material.aoMapChannel = 'r';
			extractTextureTransform(occlusionTexture, material, ['ao']);
		}

		if (gltfMaterial.hasOwnProperty('emissiveFactor')) {
			color = gltfMaterial.emissiveFactor;
			material.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
			material.emissiveTint = true;
		} else {
			material.emissive.set(0, 0, 0);
			material.emissiveTint = false;
		}

		if (gltfMaterial.hasOwnProperty('emissiveTexture')) {
			var emissiveTexture = gltfMaterial.emissiveTexture;
			material.emissiveMap = textures[emissiveTexture.index];
			extractTextureTransform(emissiveTexture, material, ['emissive']);
		}

		if (gltfMaterial.hasOwnProperty('alphaMode')) {
			switch (gltfMaterial.alphaMode) {
				case 'MASK':
					material.blendType = BLEND_NONE;

					if (gltfMaterial.hasOwnProperty('alphaCutoff')) {
						material.alphaTest = gltfMaterial.alphaCutoff;
					} else {
						material.alphaTest = 0.5;
					}

					break;

				case 'BLEND':
					material.blendType = BLEND_NORMAL;
					material.depthWrite = false;
					break;

				default:
				case 'OPAQUE':
					material.blendType = BLEND_NONE;
					break;
			}
		} else {
			material.blendType = BLEND_NONE;
		}

		if (gltfMaterial.hasOwnProperty('doubleSided')) {
			material.twoSidedLighting = gltfMaterial.doubleSided;
			material.cull = gltfMaterial.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;
		} else {
			material.twoSidedLighting = false;
			material.cull = CULLFACE_BACK;
		}

		if (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_clearcoat')) {
			var ccData = gltfMaterial.extensions.KHR_materials_clearcoat;

			if (ccData.hasOwnProperty('clearcoatFactor')) {
				material.clearCoat = ccData.clearcoatFactor * 0.25;
			} else {
				material.clearCoat = 0;
			}

			if (ccData.hasOwnProperty('clearcoatTexture')) {
				var clearcoatTexture = ccData.clearcoatTexture;
				material.clearCoatMap = textures[clearcoatTexture.index];
				material.clearCoatMapChannel = 'r';
				extractTextureTransform(clearcoatTexture, material, ['clearCoat']);
			}

			if (ccData.hasOwnProperty('clearcoatRoughnessFactor')) {
				material.clearCoatGlossiness = ccData.clearcoatRoughnessFactor;
			} else {
				material.clearCoatGlossiness = 0;
			}

			if (ccData.hasOwnProperty('clearcoatRoughnessTexture')) {
				var clearcoatRoughnessTexture = ccData.clearcoatRoughnessTexture;
				material.clearCoatGlossMap = textures[clearcoatRoughnessTexture.index];
				material.clearCoatGlossMapChannel = 'g';
				extractTextureTransform(clearcoatRoughnessTexture, material, ['clearCoatGloss']);
			}

			if (ccData.hasOwnProperty('clearcoatNormalTexture')) {
				var clearcoatNormalTexture = ccData.clearcoatNormalTexture;
				material.clearCoatNormalMap = textures[clearcoatNormalTexture.index];
				extractTextureTransform(clearcoatNormalTexture, material, ['clearCoatNormal']);

				if (clearcoatNormalTexture.hasOwnProperty('scale')) {
					material.clearCoatBumpiness = clearcoatNormalTexture.scale;
				}
			}

			material.chunks.clearCoatGlossPS = clearCoatGlossChunk;
		}

		if (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_unlit')) {
			material.useLighting = false;
			material.emissive.copy(material.diffuse);
			material.emissiveTint = material.diffuseTint;
			material.emissiveMap = material.diffuseMap;
			material.emissiveMapUv = material.diffuseMapUv;
			material.emissiveMapTiling.copy(material.diffuseMapTiling);
			material.emissiveMapOffset.copy(material.diffuseMapOffset);
			material.emissiveMapChannel = material.diffuseMapChannel;
			material.emissiveVertexColor = material.diffuseVertexColor;
			material.emissiveVertexColorChannel = material.diffuseVertexColorChannel;
			material.diffuse.set(0, 0, 0);
			material.diffuseTint = false;
			material.diffuseMap = null;
			material.diffuseVertexColor = false;
		}

		material.update();
		return material;
	};

	var createAnimation = function createAnimation(gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes) {
		var createAnimData = function createAnimData(gltfAccessor) {
			return new AnimData(getNumComponents(gltfAccessor.type), getAccessorDataFloat32(gltfAccessor, bufferViews));
		};

		var interpMap = {
			"STEP": INTERPOLATION_STEP,
			"LINEAR": INTERPOLATION_LINEAR,
			"CUBICSPLINE": INTERPOLATION_CUBIC
		};
		var inputMap = {};
		var inputs = [];
		var outputMap = {};
		var outputs = [];
		var curves = [];
		var i;

		for (i = 0; i < gltfAnimation.samplers.length; ++i) {
			var sampler = gltfAnimation.samplers[i];

			if (!inputMap.hasOwnProperty(sampler.input)) {
				inputMap[sampler.input] = inputs.length;
				inputs.push(createAnimData(gltfAccessors[sampler.input]));
			}

			if (!outputMap.hasOwnProperty(sampler.output)) {
				outputMap[sampler.output] = outputs.length;
				outputs.push(createAnimData(gltfAccessors[sampler.output]));
			}

			var interpolation = sampler.hasOwnProperty('interpolation') && interpMap.hasOwnProperty(sampler.interpolation) ? interpMap[sampler.interpolation] : INTERPOLATION_LINEAR;
			curves.push(new AnimCurve([], inputMap[sampler.input], outputMap[sampler.output], interpolation));
		}

		var quatArrays = [];
		var transformSchema = {
			'translation': 'localPosition',
			'rotation': 'localRotation',
			'scale': 'localScale',
			'weights': 'weights'
		};

		var constructNodePath = function constructNodePath(node) {
			var path = [];

			while (node) {
				path.unshift(node.name);
				node = node.parent;
			}

			return path;
		};

		for (i = 0; i < gltfAnimation.channels.length; ++i) {
			var channel = gltfAnimation.channels[i];
			var target = channel.target;
			var curve = curves[channel.sampler];
			var node = nodes[target.node];
			var entityPath = constructNodePath(node);

			curve._paths.push({
				entityPath: entityPath,
				component: 'graph',
				propertyPath: [transformSchema[target.path]]
			});

			if (target.path.startsWith('rotation') && curve.interpolation !== INTERPOLATION_CUBIC) {
				quatArrays.push(curve.output);
			} else if (target.path.startsWith('weights')) {
				outputs[curve.output]._components = outputs[curve.output].data.length / inputs[curve.input].data.length;
			}
		}

		quatArrays.sort();
		var prevIndex = null;
		var data;

		for (i = 0; i < quatArrays.length; ++i) {
			var index = quatArrays[i];

			if (i === 0 || index !== prevIndex) {
				data = outputs[index];

				if (data.components === 4) {
					var d = data.data;
					var len = d.length - 4;

					for (var j = 0; j < len; j += 4) {
						var dp = d[j + 0] * d[j + 4] + d[j + 1] * d[j + 5] + d[j + 2] * d[j + 6] + d[j + 3] * d[j + 7];

						if (dp < 0) {
							d[j + 4] *= -1;
							d[j + 5] *= -1;
							d[j + 6] *= -1;
							d[j + 7] *= -1;
						}
					}
				}

				prevIndex = index;
			}
		}

		var duration = 0;

		for (i = 0; i < inputs.length; i++) {
			data = inputs[i]._data;
			duration = Math.max(duration, data.length === 0 ? 0 : data[data.length - 1]);
		}

		return new AnimTrack(gltfAnimation.hasOwnProperty('name') ? gltfAnimation.name : "animation_" + animationIndex, duration, inputs, outputs, curves);
	};

	var createNode = function createNode(gltfNode, nodeIndex) {
		var entity = new GraphNode();

		if (gltfNode.hasOwnProperty('name') && gltfNode.name.length > 0) {
			entity.name = gltfNode.name;
		} else {
			entity.name = "node_" + nodeIndex;
		}

		if (gltfNode.hasOwnProperty('matrix')) {
			tempMat.data.set(gltfNode.matrix);
			tempMat.getTranslation(tempVec$1);
			entity.setLocalPosition(tempVec$1);
			tempMat.getEulerAngles(tempVec$1);
			entity.setLocalEulerAngles(tempVec$1);
			tempMat.getScale(tempVec$1);
			entity.setLocalScale(tempVec$1);
		}

		if (gltfNode.hasOwnProperty('rotation')) {
			var r = gltfNode.rotation;
			entity.setLocalRotation(r[0], r[1], r[2], r[3]);
		}

		if (gltfNode.hasOwnProperty('translation')) {
			var t = gltfNode.translation;
			entity.setLocalPosition(t[0], t[1], t[2]);
		}

		if (gltfNode.hasOwnProperty('scale')) {
			var s = gltfNode.scale;
			entity.setLocalScale(s[0], s[1], s[2]);
		}

		return entity;
	};

	var createCamera = function createCamera(gltfCamera, node) {
		var projection = gltfCamera.type === "orthographic" ? PROJECTION_ORTHOGRAPHIC : PROJECTION_PERSPECTIVE;
		var gltfProperties = projection === PROJECTION_ORTHOGRAPHIC ? gltfCamera.orthographic : gltfCamera.perspective;
		var componentData = {
			enabled: false,
			projection: projection,
			nearClip: gltfProperties.znear,
			aspectRatioMode: ASPECT_AUTO
		};

		if (gltfProperties.zfar) {
			componentData.farClip = gltfProperties.zfar;
		}

		if (projection === PROJECTION_ORTHOGRAPHIC) {
			componentData.orthoHeight = 0.5 * gltfProperties.ymag;

			if (gltfProperties.ymag) {
				componentData.aspectRatioMode = ASPECT_MANUAL;
				componentData.aspectRatio = gltfProperties.xmag / gltfProperties.ymag;
			}
		} else {
			componentData.fov = gltfProperties.yfov * math.RAD_TO_DEG;

			if (gltfProperties.aspectRatio) {
				componentData.aspectRatioMode = ASPECT_MANUAL;
				componentData.aspectRatio = gltfProperties.aspectRatio;
			}
		}

		var cameraEntity = new Entity(gltfCamera.name);
		cameraEntity.addComponent("camera", componentData);
		return cameraEntity;
	};

	var createLight = function createLight(gltfLight, node) {
		var lightProps = {
			enabled: false,
			type: gltfLight.type === "point" ? "omni" : gltfLight.type,
			color: gltfLight.hasOwnProperty('color') ? new Color(gltfLight.color) : Color.WHITE,
			range: gltfLight.hasOwnProperty('range') ? gltfLight.range : 9999,
			falloffMode: LIGHTFALLOFF_INVERSESQUARED,
			intensity: gltfLight.hasOwnProperty('intensity') ? math.clamp(gltfLight.intensity, 0, 2) : 1
		};

		if (gltfLight.hasOwnProperty('spot')) {
			lightProps.innerConeAngle = gltfLight.spot.hasOwnProperty('innerConeAngle') ? gltfLight.spot.innerConeAngle * math.RAD_TO_DEG : 0;
			lightProps.outerConeAngle = gltfLight.spot.hasOwnProperty('outerConeAngle') ? gltfLight.spot.outerConeAngle * math.RAD_TO_DEG : Math.PI / 4;
		}

		var lightEntity = new Entity(node.name);
		lightEntity.rotateLocal(90, 0, 0);
		lightEntity.addComponent("light", lightProps);
		return lightEntity;
	};

	var createSkins = function createSkins(device, gltf, nodes, bufferViews) {
		if (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {
			return [];
		}

		var glbSkins = new Map();
		return gltf.skins.map(function (gltfSkin) {
			return createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes, glbSkins);
		});
	};

	var createMeshes = function createMeshes(device, gltf, bufferViews, callback, flipV) {
		if (!gltf.hasOwnProperty('meshes') || gltf.meshes.length === 0 || !gltf.hasOwnProperty('accessors') || gltf.accessors.length === 0 || !gltf.hasOwnProperty('bufferViews') || gltf.bufferViews.length === 0) {
			return [];
		}

		var vertexBufferDict = {};
		return gltf.meshes.map(function (gltfMesh) {
			return createMesh(device, gltfMesh, gltf.accessors, bufferViews, callback, flipV, vertexBufferDict);
		});
	};

	var createMaterials = function createMaterials(gltf, textures, options, flipV) {
		if (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {
			return [];
		}

		var preprocess = options && options.material && options.material.preprocess;
		var process = options && options.material && options.material.process || createMaterial;
		var postprocess = options && options.material && options.material.postprocess;
		return gltf.materials.map(function (gltfMaterial) {
			if (preprocess) {
				preprocess(gltfMaterial);
			}

			var material = process(gltfMaterial, textures, flipV);

			if (postprocess) {
				postprocess(gltfMaterial, material);
			}

			return material;
		});
	};

	var createAnimations = function createAnimations(gltf, nodes, bufferViews, options) {
		if (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {
			return [];
		}

		var preprocess = options && options.animation && options.animation.preprocess;
		var postprocess = options && options.animation && options.animation.postprocess;
		return gltf.animations.map(function (gltfAnimation, index) {
			if (preprocess) {
				preprocess(gltfAnimation);
			}

			var animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes);

			if (postprocess) {
				postprocess(gltfAnimation, animation);
			}

			return animation;
		});
	};

	var createNodes = function createNodes(gltf, options) {
		if (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {
			return [];
		}

		var preprocess = options && options.node && options.node.preprocess;
		var process = options && options.node && options.node.process || createNode;
		var postprocess = options && options.node && options.node.postprocess;
		var nodes = gltf.nodes.map(function (gltfNode, index) {
			if (preprocess) {
				preprocess(gltfNode);
			}

			var node = process(gltfNode, index);

			if (postprocess) {
				postprocess(gltfNode, node);
			}

			return node;
		});

		for (var i = 0; i < gltf.nodes.length; ++i) {
			var gltfNode = gltf.nodes[i];

			if (gltfNode.hasOwnProperty('children')) {
				var parent = nodes[i];
				var uniqueNames = {};

				for (var j = 0; j < gltfNode.children.length; ++j) {
					var child = nodes[gltfNode.children[j]];

					if (!child.parent) {
						if (uniqueNames.hasOwnProperty(child.name)) {
							child.name += uniqueNames[child.name]++;
						} else {
							uniqueNames[child.name] = 1;
						}

						parent.addChild(child);
					}
				}
			}
		}

		return nodes;
	};

	var createScenes = function createScenes(gltf, nodes) {
		var _gltf$scenes$0$nodes;

		var scenes = [];
		var count = gltf.scenes.length;

		if (count === 1 && ((_gltf$scenes$0$nodes = gltf.scenes[0].nodes) == null ? void 0 : _gltf$scenes$0$nodes.length) === 1) {
			var nodeIndex = gltf.scenes[0].nodes[0];
			scenes.push(nodes[nodeIndex]);
		} else {
			for (var i = 0; i < count; i++) {
				var scene = gltf.scenes[i];

				if (scene.nodes) {
					var sceneRoot = new GraphNode(scene.name);

					for (var n = 0; n < scene.nodes.length; n++) {
						var childNode = nodes[scene.nodes[n]];
						sceneRoot.addChild(childNode);
					}

					scenes.push(sceneRoot);
				}
			}
		}

		return scenes;
	};

	var createCameras = function createCameras(gltf, nodes, options) {
		var cameras = null;

		if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('cameras') && gltf.cameras.length > 0) {
			var preprocess = options && options.camera && options.camera.preprocess;
			var process = options && options.camera && options.camera.process || createCamera;
			var postprocess = options && options.camera && options.camera.postprocess;
			gltf.nodes.forEach(function (gltfNode, nodeIndex) {
				if (gltfNode.hasOwnProperty('camera')) {
					var gltfCamera = gltf.cameras[gltfNode.camera];

					if (gltfCamera) {
						if (preprocess) {
							preprocess(gltfCamera);
						}

						var camera = process(gltfCamera, nodes[nodeIndex]);

						if (postprocess) {
							postprocess(gltfCamera, camera);
						}

						if (camera) {
							if (!cameras) cameras = new Map();
							cameras.set(gltfNode, camera);
						}
					}
				}
			});
		}

		return cameras;
	};

	var createLights = function createLights(gltf, nodes, options) {
		var lights = null;

		if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('extensions') && gltf.extensions.hasOwnProperty('KHR_lights_punctual') && gltf.extensions.KHR_lights_punctual.hasOwnProperty('lights')) {
			var gltfLights = gltf.extensions.KHR_lights_punctual.lights;

			if (gltfLights.length) {
				var preprocess = options && options.light && options.light.preprocess;
				var process = options && options.light && options.light.process || createLight;
				var postprocess = options && options.light && options.light.postprocess;
				gltf.nodes.forEach(function (gltfNode, nodeIndex) {
					if (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.hasOwnProperty('KHR_lights_punctual') && gltfNode.extensions.KHR_lights_punctual.hasOwnProperty('light')) {
						var lightIndex = gltfNode.extensions.KHR_lights_punctual.light;
						var gltfLight = gltfLights[lightIndex];

						if (gltfLight) {
							if (preprocess) {
								preprocess(gltfLight);
							}

							var light = process(gltfLight, nodes[nodeIndex]);

							if (postprocess) {
								postprocess(gltfLight, light);
							}

							if (light) {
								if (!lights) lights = new Map();
								lights.set(gltfNode, light);
							}
						}
					}
				});
			}
		}

		return lights;
	};

	var linkSkins = function linkSkins(gltf, renders, skins) {
		gltf.nodes.forEach(function (gltfNode) {
			if (gltfNode.hasOwnProperty('mesh') && gltfNode.hasOwnProperty('skin')) {
				var meshGroup = renders[gltfNode.mesh].meshes;
				meshGroup.forEach(function (mesh) {
					mesh.skin = skins[gltfNode.skin];
				});
			}
		});
	};

	var createResources = function createResources(device, gltf, bufferViews, textureAssets, options, callback) {
		var preprocess = options && options.global && options.global.preprocess;
		var postprocess = options && options.global && options.global.postprocess;

		if (preprocess) {
			preprocess(gltf);
		}

		var flipV = gltf.asset && gltf.asset.generator === 'PlayCanvas';
		var nodes = createNodes(gltf, options);
		var scenes = createScenes(gltf, nodes);
		var lights = createLights(gltf, nodes, options);
		var cameras = createCameras(gltf, nodes, options);
		var animations = createAnimations(gltf, nodes, bufferViews, options);
		var materials = createMaterials(gltf, textureAssets.map(function (textureAsset) {
			return textureAsset.resource;
		}), options, flipV);
		var meshes = createMeshes(device, gltf, bufferViews, callback, flipV);
		var skins = createSkins(device, gltf, nodes, bufferViews);
		var renders = [];

		for (var i = 0; i < meshes.length; i++) {
			renders[i] = new Render();
			renders[i].meshes = meshes[i];
		}

		linkSkins(gltf, renders, skins);
		var result = new GlbResources(gltf);
		result.nodes = nodes;
		result.scenes = scenes;
		result.animations = animations;
		result.textures = textureAssets;
		result.materials = materials;
		result.renders = renders;
		result.skins = skins;
		result.lights = lights;
		result.cameras = cameras;

		if (postprocess) {
			postprocess(gltf, result);
		}

		callback(null, result);
	};

	var applySampler = function applySampler(texture, gltfSampler) {
		var getFilter = function getFilter(filter, defaultValue) {
			switch (filter) {
				case 9728:
					return FILTER_NEAREST;

				case 9729:
					return FILTER_LINEAR;

				case 9984:
					return FILTER_NEAREST_MIPMAP_NEAREST;

				case 9985:
					return FILTER_LINEAR_MIPMAP_NEAREST;

				case 9986:
					return FILTER_NEAREST_MIPMAP_LINEAR;

				case 9987:
					return FILTER_LINEAR_MIPMAP_LINEAR;

				default:
					return defaultValue;
			}
		};

		var getWrap = function getWrap(wrap, defaultValue) {
			switch (wrap) {
				case 33071:
					return ADDRESS_CLAMP_TO_EDGE;

				case 33648:
					return ADDRESS_MIRRORED_REPEAT;

				case 10497:
					return ADDRESS_REPEAT;

				default:
					return defaultValue;
			}
		};

		if (texture) {
			gltfSampler = gltfSampler || {};
			texture.minFilter = getFilter(gltfSampler.minFilter, FILTER_LINEAR_MIPMAP_LINEAR);
			texture.magFilter = getFilter(gltfSampler.magFilter, FILTER_LINEAR);
			texture.addressU = getWrap(gltfSampler.wrapS, ADDRESS_REPEAT);
			texture.addressV = getWrap(gltfSampler.wrapT, ADDRESS_REPEAT);
		}
	};

	var gltfTextureUniqueId = 0;

	var loadImageAsync = function loadImageAsync(gltfImage, index, bufferViews, urlBase, registry, options, callback) {
		var preprocess = options && options.image && options.image.preprocess;

		var processAsync = options && options.image && options.image.processAsync || function (gltfImage, callback) {
			callback(null, null);
		};

		var postprocess = options && options.image && options.image.postprocess;

		var onLoad = function onLoad(textureAsset) {
			if (postprocess) {
				postprocess(gltfImage, textureAsset);
			}

			callback(null, textureAsset);
		};

		var mimeTypeFileExtensions = {
			'image/png': 'png',
			'image/jpeg': 'jpg',
			'image/basis': 'basis',
			'image/ktx': 'ktx',
			'image/ktx2': 'ktx2',
			'image/vnd-ms.dds': 'dds'
		};

		var loadTexture = function loadTexture(url, bufferView, mimeType, options) {
			var name = (gltfImage.name || 'gltf-texture') + '-' + gltfTextureUniqueId++;
			var file = {
				url: url || name
			};

			if (bufferView) {
				file.contents = bufferView.slice(0).buffer;
			}

			if (mimeType) {
				var extension = mimeTypeFileExtensions[mimeType];

				if (extension) {
					file.filename = file.url + '.' + extension;
				}
			}

			var asset = new Asset(name, 'texture', file, null, options);
			asset.on('load', onLoad);
			asset.on('error', callback);
			registry.add(asset);
			registry.load(asset);
		};

		if (preprocess) {
			preprocess(gltfImage);
		}

		processAsync(gltfImage, function (err, textureAsset) {
			if (err) {
				callback(err);
			} else if (textureAsset) {
				onLoad(textureAsset);
			} else {
				if (gltfImage.hasOwnProperty('uri')) {
					if (isDataURI(gltfImage.uri)) {
						loadTexture(gltfImage.uri, null, getDataURIMimeType(gltfImage.uri), null);
					} else {
						loadTexture(path.join(urlBase, gltfImage.uri), null, null, {
							crossOrigin: "anonymous"
						});
					}
				} else if (gltfImage.hasOwnProperty('bufferView') && gltfImage.hasOwnProperty('mimeType')) {
					loadTexture(null, bufferViews[gltfImage.bufferView], gltfImage.mimeType, null);
				} else {
					callback("Invalid image found in gltf (neither uri or bufferView found). index=" + index);
				}
			}
		});
	};

	var loadTexturesAsync = function loadTexturesAsync(gltf, bufferViews, urlBase, registry, options, callback) {
		if (!gltf.hasOwnProperty('images') || gltf.images.length === 0 || !gltf.hasOwnProperty('textures') || gltf.textures.length === 0) {
			callback(null, []);
			return;
		}

		var preprocess = options && options.texture && options.texture.preprocess;

		var processAsync = options && options.texture && options.texture.processAsync || function (gltfTexture, gltfImages, callback) {
			callback(null, null);
		};

		var postprocess = options && options.texture && options.texture.postprocess;
		var assets = [];
		var textures = [];
		var remaining = gltf.textures.length;

		var onLoad = function onLoad(textureIndex, imageIndex) {
			if (!textures[imageIndex]) {
				textures[imageIndex] = [];
			}

			textures[imageIndex].push(textureIndex);

			if (--remaining === 0) {
				var result = [];
				textures.forEach(function (textureList, imageIndex) {
					textureList.forEach(function (textureIndex, index) {
						var textureAsset = index === 0 ? assets[imageIndex] : cloneTextureAsset(assets[imageIndex]);
						applySampler(textureAsset.resource, (gltf.samplers || [])[gltf.textures[textureIndex].sampler]);
						result[textureIndex] = textureAsset;

						if (postprocess) {
							postprocess(gltf.textures[textureIndex], textureAsset);
						}
					});
				});
				callback(null, result);
			}
		};

		for (var i = 0; i < gltf.textures.length; ++i) {
			var gltfTexture = gltf.textures[i];

			if (preprocess) {
				preprocess(gltfTexture);
			}

			processAsync(gltfTexture, gltf.images, function (i, gltfTexture, err, gltfImageIndex) {
				if (err) {
					callback(err);
				} else {
					if (gltfImageIndex === undefined || gltfImageIndex === null) {
						var _gltfTexture$extensio, _gltfTexture$extensio2;

						gltfImageIndex = gltfTexture == null ? void 0 : (_gltfTexture$extensio = gltfTexture.extensions) == null ? void 0 : (_gltfTexture$extensio2 = _gltfTexture$extensio.KHR_texture_basisu) == null ? void 0 : _gltfTexture$extensio2.source;

						if (gltfImageIndex === undefined) {
							gltfImageIndex = gltfTexture.source;
						}
					}

					if (assets[gltfImageIndex]) {
						onLoad(i, gltfImageIndex);
					} else {
						var gltfImage = gltf.images[gltfImageIndex];
						loadImageAsync(gltfImage, i, bufferViews, urlBase, registry, options, function (err, textureAsset) {
							if (err) {
								callback(err);
							} else {
								assets[gltfImageIndex] = textureAsset;
								onLoad(i, gltfImageIndex);
							}
						});
					}
				}
			}.bind(null, i, gltfTexture));
		}
	};

	var loadBuffersAsync = function loadBuffersAsync(gltf, binaryChunk, urlBase, options, callback) {
		var result = [];

		if (!gltf.buffers || gltf.buffers.length === 0) {
			callback(null, result);
			return;
		}

		var preprocess = options && options.buffer && options.buffer.preprocess;

		var processAsync = options && options.buffer && options.buffer.processAsync || function (gltfBuffer, callback) {
			callback(null, null);
		};

		var postprocess = options && options.buffer && options.buffer.postprocess;
		var remaining = gltf.buffers.length;

		var onLoad = function onLoad(index, buffer) {
			result[index] = buffer;

			if (postprocess) {
				postprocess(gltf.buffers[index], buffer);
			}

			if (--remaining === 0) {
				callback(null, result);
			}
		};

		for (var i = 0; i < gltf.buffers.length; ++i) {
			var gltfBuffer = gltf.buffers[i];

			if (preprocess) {
				preprocess(gltfBuffer);
			}

			processAsync(gltfBuffer, function (i, gltfBuffer, err, arrayBuffer) {
				if (err) {
					callback(err);
				} else if (arrayBuffer) {
					onLoad(i, new Uint8Array(arrayBuffer));
				} else {
					if (gltfBuffer.hasOwnProperty('uri')) {
						if (isDataURI(gltfBuffer.uri)) {
							var byteString = atob(gltfBuffer.uri.split(',')[1]);
							var binaryArray = new Uint8Array(byteString.length);

							for (var j = 0; j < byteString.length; j++) {
								binaryArray[j] = byteString.charCodeAt(j);
							}

							onLoad(i, binaryArray);
						} else {
							http.get(path.join(urlBase, gltfBuffer.uri), {
								cache: true,
								responseType: 'arraybuffer',
								retry: false
							}, function (i, err, result) {
								if (err) {
									callback(err);
								} else {
									onLoad(i, new Uint8Array(result));
								}
							}.bind(null, i));
						}
					} else {
						onLoad(i, binaryChunk);
					}
				}
			}.bind(null, i, gltfBuffer));
		}
	};

	var parseGltf = function parseGltf(gltfChunk, callback) {
		var decodeBinaryUtf8 = function decodeBinaryUtf8(array) {
			if (typeof TextDecoder !== 'undefined') {
				return new TextDecoder().decode(array);
			}

			var str = "";

			for (var i = 0; i < array.length; i++) {
				str += String.fromCharCode(array[i]);
			}

			return decodeURIComponent(escape(str));
		};

		var gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));

		if (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {
			callback("Invalid gltf version. Expected version 2.0 or above but found version '" + gltf.asset.version + "'.");
			return;
		}

		callback(null, gltf);
	};

	var parseGlb = function parseGlb(glbData, callback) {
		var data = glbData instanceof ArrayBuffer ? new DataView(glbData) : new DataView(glbData.buffer, glbData.byteOffset, glbData.byteLength);
		var magic = data.getUint32(0, true);
		var version = data.getUint32(4, true);
		var length = data.getUint32(8, true);

		if (magic !== 0x46546C67) {
			callback("Invalid magic number found in glb header. Expected 0x46546C67, found 0x" + magic.toString(16));
			return;
		}

		if (version !== 2) {
			callback("Invalid version number found in glb header. Expected 2, found " + version);
			return;
		}

		if (length <= 0 || length > data.byteLength) {
			callback("Invalid length found in glb header. Found " + length);
			return;
		}

		var chunks = [];
		var offset = 12;

		while (offset < length) {
			var chunkLength = data.getUint32(offset, true);

			if (offset + chunkLength + 8 > data.byteLength) {
				throw new Error("Invalid chunk length found in glb. Found " + chunkLength);
			}

			var chunkType = data.getUint32(offset + 4, true);
			var chunkData = new Uint8Array(data.buffer, data.byteOffset + offset + 8, chunkLength);
			chunks.push({
				length: chunkLength,
				type: chunkType,
				data: chunkData
			});
			offset += chunkLength + 8;
		}

		if (chunks.length !== 1 && chunks.length !== 2) {
			callback("Invalid number of chunks found in glb file.");
			return;
		}

		if (chunks[0].type !== 0x4E4F534A) {
			callback("Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x" + chunks[0].type.toString(16));
			return;
		}

		if (chunks.length > 1 && chunks[1].type !== 0x004E4942) {
			callback("Invalid chunk type found in glb file. Expected 0x004E4942, found 0x" + chunks[1].type.toString(16));
			return;
		}

		callback(null, {
			gltfChunk: chunks[0].data,
			binaryChunk: chunks.length === 2 ? chunks[1].data : null
		});
	};

	var parseChunk = function parseChunk(filename, data, callback) {
		if (filename && filename.toLowerCase().endsWith('.glb')) {
			parseGlb(data, callback);
		} else {
			callback(null, {
				gltfChunk: data,
				binaryChunk: null
			});
		}
	};

	var parseBufferViewsAsync = function parseBufferViewsAsync(gltf, buffers, options, callback) {
		var result = [];
		var preprocess = options && options.bufferView && options.bufferView.preprocess;

		var processAsync = options && options.bufferView && options.bufferView.processAsync || function (gltfBufferView, buffers, callback) {
			callback(null, null);
		};

		var postprocess = options && options.bufferView && options.bufferView.postprocess;
		var remaining = gltf.bufferViews ? gltf.bufferViews.length : 0;

		if (!remaining) {
			callback(null, null);
			return;
		}

		var onLoad = function onLoad(index, bufferView) {
			var gltfBufferView = gltf.bufferViews[index];

			if (gltfBufferView.hasOwnProperty('byteStride')) {
				bufferView.byteStride = gltfBufferView.byteStride;
			}

			result[index] = bufferView;

			if (postprocess) {
				postprocess(gltfBufferView, bufferView);
			}

			if (--remaining === 0) {
				callback(null, result);
			}
		};

		for (var i = 0; i < gltf.bufferViews.length; ++i) {
			var gltfBufferView = gltf.bufferViews[i];

			if (preprocess) {
				preprocess(gltfBufferView);
			}

			processAsync(gltfBufferView, buffers, function (i, gltfBufferView, err, result) {
				if (err) {
					callback(err);
				} else if (result) {
					onLoad(i, result);
				} else {
					var buffer = buffers[gltfBufferView.buffer];
					var typedArray = new Uint8Array(buffer.buffer, buffer.byteOffset + (gltfBufferView.byteOffset || 0), gltfBufferView.byteLength);
					onLoad(i, typedArray);
				}
			}.bind(null, i, gltfBufferView));
		}
	};

	var GlbParser = function () {
		GlbParser.parseAsync = function parseAsync(filename, urlBase, data, device, registry, options, callback) {
			parseChunk(filename, data, function (err, chunks) {
				if (err) {
					callback(err);
					return;
				}

				parseGltf(chunks.gltfChunk, function (err, gltf) {
					if (err) {
						callback(err);
						return;
					}

					loadBuffersAsync(gltf, chunks.binaryChunk, urlBase, options, function (err, buffers) {
						if (err) {
							callback(err);
							return;
						}

						parseBufferViewsAsync(gltf, buffers, options, function (err, bufferViews) {
							if (err) {
								callback(err);
								return;
							}

							loadTexturesAsync(gltf, bufferViews, urlBase, registry, options, function (err, textureAssets) {
								if (err) {
									callback(err);
									return;
								}

								createResources(device, gltf, bufferViews, textureAssets, options, callback);
							});
						});
					});
				});
			});
		};

		GlbParser.parse = function parse(filename, data, device, options) {
			var result = null;
			options = options || {};
			parseChunk(filename, data, function (err, chunks) {
				if (err) {
					console.error(err);
				} else {
					parseGltf(chunks.gltfChunk, function (err, gltf) {
						if (err) {
							console.error(err);
						} else {
							parseBufferViewsAsync(gltf, [chunks.binaryChunk], options, function (err, bufferViews) {
								if (err) {
									console.error(err);
								} else {
									createResources(device, gltf, bufferViews, [], options, function (err, result_) {
										if (err) {
											console.error(err);
										} else {
											result = result_;
										}
									});
								}
							});
						}
					});
				}
			});
			return result;
		};

		function GlbParser(device, assets, maxRetries) {
			this._device = device;
			this._assets = assets;
			this._defaultMaterial = getDefaultMaterial(device);
			this._maxRetries = maxRetries;
		}

		var _proto2 = GlbParser.prototype;

		_proto2._getUrlWithoutParams = function _getUrlWithoutParams(url) {
			return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		};

		_proto2.load = function load(url, callback, asset) {
			var _this = this;

			Asset.fetchArrayBuffer(url.load, function (err, result) {
				if (err) {
					callback(err);
				} else {
					GlbParser.parseAsync(_this._getUrlWithoutParams(url.original), path.extractPath(url.load), result, _this._device, asset.registry, asset.options, function (err, result) {
						if (err) {
							callback(err);
						} else {
							callback(null, new GlbContainerResource(result, asset, _this._assets, _this._defaultMaterial));
						}
					});
				}
			}, asset, this._maxRetries);
		};

		_proto2.open = function open(url, data, asset) {
			return data;
		};

		_proto2.patch = function patch(asset, assets) {};

		return GlbParser;
	}();

	var AnimationHandler = function () {
		function AnimationHandler() {
			this.maxRetries = 0;
		}

		var _proto = AnimationHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};

			if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
				if (path.getExtension(url.original).toLowerCase() === '.glb') {
					options.responseType = Http.ResponseType.ARRAY_BUFFER;
				} else {
					options.responseType = Http.ResponseType.JSON;
				}
			}

			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error loading animation resource: " + url.original + " [" + err + "]");
				} else {
					callback(null, response);
				}
			});
		};

		_proto.open = function open(url, data) {
			if (path.getExtension(url).toLowerCase() === '.glb') {
				var glbResources = GlbParser.parse("filename.glb", data, null);

				if (glbResources) {
					var animations = glbResources.animations;
					glbResources.destroy();
					return animations;
				}

				return null;
			}

			return this["_parseAnimationV" + data.animation.version](data);
		};

		_proto.patch = function patch(asset, assets) {};

		_proto._parseAnimationV3 = function _parseAnimationV3(data) {
			var animData = data.animation;
			var anim = new Animation();
			anim.name = animData.name;
			anim.duration = animData.duration;

			for (var i = 0; i < animData.nodes.length; i++) {
				var node = new Node();
				var n = animData.nodes[i];
				node._name = n.name;

				for (var j = 0; j < n.keys.length; j++) {
					var k = n.keys[j];
					var t = k.time;
					var p = k.pos;
					var r = k.rot;
					var s = k.scale;
					var pos = new Vec3(p[0], p[1], p[2]);
					var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
					var scl = new Vec3(s[0], s[1], s[2]);
					var key = new Key(t, pos, rot, scl);

					node._keys.push(key);
				}

				anim.addNode(node);
			}

			return anim;
		};

		_proto._parseAnimationV4 = function _parseAnimationV4(data) {
			var animData = data.animation;
			var anim = new Animation();
			anim.name = animData.name;
			anim.duration = animData.duration;

			for (var i = 0; i < animData.nodes.length; i++) {
				var node = new Node();
				var n = animData.nodes[i];
				node._name = n.name;
				var defPos = n.defaults.p;
				var defRot = n.defaults.r;
				var defScl = n.defaults.s;

				for (var j = 0; j < n.keys.length; j++) {
					var k = n.keys[j];
					var t = k.t;
					var p = defPos ? defPos : k.p;
					var r = defRot ? defRot : k.r;
					var s = defScl ? defScl : k.s;
					var pos = new Vec3(p[0], p[1], p[2]);
					var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
					var scl = new Vec3(s[0], s[1], s[2]);
					var key = new Key(t, pos, rot, scl);

					node._keys.push(key);
				}

				anim.addNode(node);
			}

			return anim;
		};

		return AnimationHandler;
	}();

	var AnimClipHandler = function () {
		function AnimClipHandler() {
			this.maxRetries = 0;
		}

		var _proto = AnimClipHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};

			if (url.load.startsWith('blob:')) {
				options.responseType = Http.ResponseType.JSON;
			}

			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error loading animation clip resource: " + url.original + " [" + err + "]");
				} else {
					callback(null, response);
				}
			});
		};

		_proto.open = function open(url, data) {
			var name = data.name;
			var duration = data.duration;
			var inputs = data.inputs.map(function (input) {
				return new AnimData(1, input);
			});
			var outputs = data.outputs.map(function (output) {
				return new AnimData(output.components, output.data);
			});
			var curves = data.curves.map(function (curve) {
				return new AnimCurve([curve.path], curve.inputIndex, curve.outputIndex, curve.interpolation);
			});
			return new AnimTrack(name, duration, inputs, outputs, curves);
		};

		_proto.patch = function patch(asset, assets) {};

		return AnimClipHandler;
	}();

	var AnimStateGraph = function () {
		function AnimStateGraph(data) {
			this._layers = [];
			this._parameters = {};

			if (!Array.isArray(data.layers)) {
				for (var layerId in data.layers) {
					var dataLayer = data.layers[layerId];
					var layer = {
						name: dataLayer.name,
						blendType: dataLayer.blendType,
						weight: dataLayer.weight,
						states: [],
						transitions: []
					};

					for (var i = 0; i < dataLayer.states.length; i++) {
						layer.states.push(data.states[dataLayer.states[i]]);
					}

					for (var _i = 0; _i < dataLayer.transitions.length; _i++) {
						var dataLayerTransition = data.transitions[dataLayer.transitions[_i]];

						if (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {
							var conditionKeys = Object.keys(dataLayerTransition.conditions);
							var conditions = [];

							for (var j = 0; j < conditionKeys.length; j++) {
								var condition = dataLayerTransition.conditions[conditionKeys[j]];

								if (condition.parameterName) {
									conditions.push(condition);
								}
							}

							dataLayerTransition.conditions = conditions;
						}

						if (Number.isInteger(dataLayerTransition.from)) {
							dataLayerTransition.from = data.states[dataLayerTransition.from].name;
						}

						if (Number.isInteger(dataLayerTransition.to)) {
							dataLayerTransition.to = data.states[dataLayerTransition.to].name;
						}

						layer.transitions.push(dataLayerTransition);
					}

					this._layers.push(layer);
				}
			} else {
				this._layers = data.layers;
			}

			for (var paramId in data.parameters) {
				var param = data.parameters[paramId];
				this._parameters[param.name] = {
					type: param.type,
					value: param.value
				};
			}
		}

		_createClass(AnimStateGraph, [{
			key: "parameters",
			get: function get() {
				return Object.assign({}, this._parameters);
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			}
		}]);

		return AnimStateGraph;
	}();

	var AnimStateGraphHandler = function () {
		function AnimStateGraphHandler() {
			this.maxRetries = 0;
		}

		var _proto = AnimStateGraphHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};

			if (url.load.startsWith('blob:')) {
				options.responseType = Http.ResponseType.JSON;
			}

			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error loading animation state graph resource: " + url.original + " [" + err + "]");
				} else {
					callback(null, response);
				}
			});
		};

		_proto.open = function open(url, data) {
			return new AnimStateGraph(data);
		};

		_proto.patch = function patch(asset, assets) {};

		return AnimStateGraphHandler;
	}();

	var Sound = function () {
		function Sound(resource) {
			this.audio = void 0;
			this.buffer = void 0;

			if (resource instanceof Audio) {
				this.audio = resource;
			} else {
				this.buffer = resource;
			}
		}

		_createClass(Sound, [{
			key: "duration",
			get: function get() {
				var duration = 0;

				if (this.buffer) {
					duration = this.buffer.duration;
				} else if (this.audio) {
					duration = this.audio.duration;
				}

				return duration || 0;
			}
		}]);

		return Sound;
	}();

	var ie = function () {
		if (typeof window === 'undefined') {
			return false;
		}

		var ua = window.navigator.userAgent;
		var msie = ua.indexOf('MSIE ');

		if (msie > 0) {
			return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
		}

		var trident = ua.indexOf('Trident/');

		if (trident > 0) {
			var rv = ua.indexOf('rv:');
			return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
		}

		return false;
	}();

	var toMIME = {
		'.ogg': 'audio/ogg',
		'.mp3': 'audio/mpeg',
		'.wav': 'audio/x-wav',
		'.mp4a': 'audio/mp4',
		'.m4a': 'audio/mp4',
		'.mp4': 'audio/mp4',
		'.aac': 'audio/aac'
	};

	var AudioHandler = function () {
		function AudioHandler(manager) {
			this.manager = manager;
			this.maxRetries = 0;
		}

		var _proto = AudioHandler.prototype;

		_proto._isSupported = function _isSupported(url) {
			var ext = path.getExtension(url);

			if (toMIME[ext]) {
				return true;
			}

			return false;
		};

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			var success = function success(resource) {
				callback(null, new Sound(resource));
			};

			var error = function error(err) {
				var msg = 'Error loading audio url: ' + url.original;

				if (err) {
					msg += ': ' + (err.message || err);
				}

				console.warn(msg);
				callback(msg);
			};

			if (this._createSound) {
				if (!this._isSupported(url.original)) {
					error("Audio format for " + url.original + " not supported");
					return;
				}

				this._createSound(url.load, success, error);
			} else {
				error(null);
			}
		};

		_proto.open = function open(url, data) {
			return data;
		};

		_proto.patch = function patch(asset, assets) {};

		_proto._createSound = function _createSound(url, success, error) {
			if (hasAudioContext()) {
				var manager = this.manager;

				if (!manager.context) {
					error('Audio manager has no audio context');
					return;
				}

				var options = {
					retry: this.maxRetries > 0,
					maxRetries: this.maxRetries
				};

				if (url.startsWith('blob:') || url.startsWith('data:')) {
					options.responseType = Http.ResponseType.ARRAY_BUFFER;
				}

				http.get(url, options, function (err, response) {
					if (err) {
						error(err);
						return;
					}

					manager.context.decodeAudioData(response, success, error);
				});
			} else {
				var audio = null;

				try {
					audio = new Audio();
				} catch (e) {
					error("No support for Audio element");
					return;
				}

				if (ie) {
					document.body.appendChild(audio);
				}

				var onReady = function onReady() {
					audio.removeEventListener('canplaythrough', onReady);

					if (ie) {
						document.body.removeChild(audio);
					}

					success(audio);
				};

				audio.onerror = function () {
					audio.onerror = null;

					if (ie) {
						document.body.removeChild(audio);
					}

					error();
				};

				audio.addEventListener('canplaythrough', onReady);
				audio.src = url;
			}
		};

		return AudioHandler;
	}();

	var BinaryHandler = function () {
		function BinaryHandler() {
			this.maxRetries = 0;
		}

		var _proto = BinaryHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			http.get(url.load, {
				responseType: Http.ResponseType.ARRAY_BUFFER,
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading binary resource: " + url.original + " [" + err + "]");
				}
			});
		};

		_proto.open = function open(url, data) {
			return data;
		};

		_proto.patch = function patch(asset, assets) {};

		return BinaryHandler;
	}();

	var Bundle = function () {
		function Bundle(files) {
			this._blobUrls = {};

			for (var i = 0, len = files.length; i < len; i++) {
				if (files[i].url) {
					this._blobUrls[files[i].name] = files[i].url;
				}
			}
		}

		var _proto = Bundle.prototype;

		_proto.hasBlobUrl = function hasBlobUrl(url) {
			return !!this._blobUrls[url];
		};

		_proto.getBlobUrl = function getBlobUrl(url) {
			return this._blobUrls[url];
		};

		_proto.destroy = function destroy() {
			for (var key in this._blobUrls) {
				URL.revokeObjectURL(this._blobUrls[key]);
			}

			this._blobUrls = null;
		};

		return Bundle;
	}();

	var Untar;

	function UntarScope(isWorker) {
		var utfDecoder;
		var asciiDecoder;

		if (typeof TextDecoder !== 'undefined') {
			try {
				utfDecoder = new TextDecoder('utf-8');
				asciiDecoder = new TextDecoder('windows-1252');
			} catch (e) {
				console.warn('TextDecoder not supported - pc.Untar module will not work');
			}
		} else {
			console.warn('TextDecoder not supported - pc.Untar module will not work');
		}

		function PaxHeader(fields) {
			this._fields = fields;
		}

		PaxHeader.parse = function (buffer, start, length) {
			var paxArray = new Uint8Array(buffer, start, length);
			var bytesRead = 0;
			var fields = [];

			while (bytesRead < length) {
				var spaceIndex = void 0;

				for (spaceIndex = bytesRead; spaceIndex < length; spaceIndex++) {
					if (paxArray[spaceIndex] === 0x20) break;
				}

				if (spaceIndex >= length) {
					throw new Error('Invalid PAX header data format.');
				}

				var fieldLength = parseInt(utfDecoder.decode(new Uint8Array(buffer, start + bytesRead, spaceIndex - bytesRead)), 10);
				var fieldText = utfDecoder.decode(new Uint8Array(buffer, start + spaceIndex + 1, fieldLength - (spaceIndex - bytesRead) - 2));
				var field = fieldText.split('=');

				if (field.length !== 2) {
					throw new Error('Invalid PAX header data format.');
				}

				if (field[1].length === 0) {
					field[1] = null;
				}

				fields.push({
					name: field[0],
					value: field[1]
				});
				bytesRead += fieldLength;
			}

			return new PaxHeader(fields);
		};

		PaxHeader.prototype.applyHeader = function (file) {
			for (var i = 0; i < this._fields.length; i++) {
				var fieldName = this._fields[i].name;
				var fieldValue = this._fields[i].value;

				if (fieldName === 'path') {
					fieldName = 'name';
				}

				if (fieldValue === null) {
					delete file[fieldName];
				} else {
					file[fieldName] = fieldValue;
				}
			}
		};

		function UntarInternal(arrayBuffer) {
			this._arrayBuffer = arrayBuffer || new ArrayBuffer(0);
			this._bufferView = new DataView(this._arrayBuffer);
			this._globalPaxHeader = null;
			this._paxHeader = null;
			this._bytesRead = 0;
		}

		if (!isWorker) {
			Untar = UntarInternal;
		}

		UntarInternal.prototype._hasNext = function () {
			return this._bytesRead + 4 < this._arrayBuffer.byteLength && this._bufferView.getUint32(this._bytesRead) !== 0;
		};

		UntarInternal.prototype._readNextFile = function () {
			var headersDataView = new DataView(this._arrayBuffer, this._bytesRead, 512);
			var headers = asciiDecoder.decode(headersDataView);
			this._bytesRead += 512;
			var name = headers.substr(0, 100).replace(/\0/g, '');
			var ustarFormat = headers.substr(257, 6);
			var size = parseInt(headers.substr(124, 12), 8);
			var type = headers.substr(156, 1);
			var start = this._bytesRead;
			var url = null;
			var normalFile = false;

			switch (type) {
				case "0":
				case "":
					normalFile = true;

					if (!isWorker) {
						var blob = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + size)]);
						url = URL.createObjectURL(blob);
					}

					break;

				case "g":
					this._globalPaxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
					break;

				case "x":
					this._paxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
					break;
			}

			this._bytesRead += size;
			var remainder = size % 512;

			if (remainder !== 0) {
				this._bytesRead += 512 - remainder;
			}

			if (!normalFile) {
				return null;
			}

			if (ustarFormat.indexOf("ustar") !== -1) {
				var namePrefix = headers.substr(345, 155).replace(/\0/g, '');

				if (namePrefix.length > 0) {
					name = namePrefix.trim() + name.trim();
				}
			}

			var file = {
				name: name,
				start: start,
				size: size,
				url: url
			};

			if (this._globalPaxHeader) {
				this._globalPaxHeader.applyHeader(file);
			}

			if (this._paxHeader) {
				this._paxHeader.applyHeader(file);

				this._paxHeader = null;
			}

			return file;
		};

		UntarInternal.prototype.untar = function (filenamePrefix) {
			if (!utfDecoder) {
				console.error('Cannot untar because TextDecoder interface is not available for this platform.');
				return [];
			}

			var files = [];

			while (this._hasNext()) {
				var file = this._readNextFile();

				if (!file) continue;

				if (filenamePrefix && file.name) {
					file.name = filenamePrefix + file.name;
				}

				files.push(file);
			}

			return files;
		};

		if (isWorker) {
			self.onmessage = function (e) {
				var id = e.data.id;

				try {
					var archive = new UntarInternal(e.data.arrayBuffer);
					var files = archive.untar(e.data.prefix);
					postMessage({
						id: id,
						files: files,
						arrayBuffer: e.data.arrayBuffer
					}, [e.data.arrayBuffer]);
				} catch (err) {
					postMessage({
						id: id,
						error: err.toString()
					});
				}
			};
		}
	}

	var workerUrl = null;

	function getWorkerUrl() {
		if (!workerUrl) {
			var code = '(' + UntarScope.toString() + ')(true)\n\n';
			var blob = new Blob([code], {
				type: 'application/javascript'
			});
			workerUrl = URL.createObjectURL(blob);
		}

		return workerUrl;
	}

	var UntarWorker = function () {
		function UntarWorker(filenamePrefix) {
			this._requestId = 0;
			this._pendingRequests = {};
			this._filenamePrefix = filenamePrefix;
			this._worker = new Worker(getWorkerUrl());

			this._worker.addEventListener('message', this._onMessage.bind(this));
		}

		var _proto = UntarWorker.prototype;

		_proto._onMessage = function _onMessage(e) {
			var id = e.data.id;
			if (!this._pendingRequests[id]) return;
			var callback = this._pendingRequests[id];
			delete this._pendingRequests[id];

			if (e.data.error) {
				callback(e.data.error);
			} else {
				var arrayBuffer = e.data.arrayBuffer;

				for (var i = 0, len = e.data.files.length; i < len; i++) {
					var file = e.data.files[i];
					var blob = new Blob([arrayBuffer.slice(file.start, file.start + file.size)]);
					file.url = URL.createObjectURL(blob);
				}

				callback(null, e.data.files);
			}
		};

		_proto.untar = function untar(arrayBuffer, callback) {
			var id = this._requestId++;
			this._pendingRequests[id] = callback;

			this._worker.postMessage({
				id: id,
				prefix: this._filenamePrefix,
				arrayBuffer: arrayBuffer
			}, [arrayBuffer]);
		};

		_proto.hasPendingRequests = function hasPendingRequests() {
			return Object.keys(this._pendingRequests).length > 0;
		};

		_proto.destroy = function destroy() {
			if (this._worker) {
				this._worker.terminate();

				this._worker = null;
				this._pendingRequests = null;
			}
		};

		return UntarWorker;
	}();

	UntarScope();

	var BundleHandler = function () {
		function BundleHandler(assets) {
			this._assets = assets;
			this._worker = null;
			this.maxRetries = 0;
		}

		var _proto = BundleHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			var self = this;
			http.get(url.load, {
				responseType: Http.ResponseType.ARRAY_BUFFER,
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					try {
						self._untar(response, callback);
					} catch (ex) {
						callback("Error loading bundle resource " + url.original + ": " + ex);
					}
				} else {
					callback("Error loading bundle resource " + url.original + ": " + err);
				}
			});
		};

		_proto._untar = function _untar(response, callback) {
			var self = this;

			if (platform.workers) {
				if (!self._worker) {
					self._worker = new UntarWorker(self._assets.prefix);
				}

				self._worker.untar(response, function (err, files) {
					callback(err, files);

					if (!self._worker.hasPendingRequests()) {
						self._worker.destroy();

						self._worker = null;
					}
				});
			} else {
				var archive = new Untar(response);
				var files = archive.untar(self._assets.prefix);
				callback(null, files);
			}
		};

		_proto.open = function open(url, data) {
			return new Bundle(data);
		};

		_proto.patch = function patch(asset, assets) {};

		return BundleHandler;
	}();

	var ContainerResource = function () {
		function ContainerResource() {}

		var _proto = ContainerResource.prototype;

		_proto.instantiateModelEntity = function instantiateModelEntity(options) {
			return null;
		};

		_proto.instantiateRenderEntity = function instantiateRenderEntity(options) {
			return null;
		};

		return ContainerResource;
	}();

	var ContainerHandler = function () {
		function ContainerHandler(device, assets) {
			this.glbParser = new GlbParser(device, assets, 0);
			this.parsers = {};
		}

		var _proto2 = ContainerHandler.prototype;

		_proto2._getUrlWithoutParams = function _getUrlWithoutParams(url) {
			return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		};

		_proto2._getParser = function _getParser(url) {
			var ext = url ? path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '') : null;
			return this.parsers[ext] || this.glbParser;
		};

		_proto2.load = function load(url, callback, asset) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			this._getParser(url.original).load(url, callback, asset);
		};

		_proto2.open = function open(url, data, asset) {
			return this._getParser(url).open(url, data, asset);
		};

		_proto2.patch = function patch(asset, assets) {};

		return ContainerHandler;
	}();

	var CssHandler = function () {
		function CssHandler() {
			this.maxRetries = 0;
		}

		var _proto = CssHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading css resource: " + url.original + " [" + err + "]");
				}
			});
		};

		_proto.open = function open(url, data) {
			return data;
		};

		_proto.patch = function patch(asset, assets) {};

		return CssHandler;
	}();

	function createStyle(cssString) {
		var result = document.createElement('style');
		result.type = 'text/css';

		if (result.styleSheet) {
			result.styleSheet.cssText = cssString;
		} else {
			result.appendChild(document.createTextNode(cssString));
		}

		return result;
	}

	var CubemapHandler = function () {
		function CubemapHandler(device, assets, loader) {
			this._device = device;
			this._registry = assets;
			this._loader = loader;
		}

		var _proto = CubemapHandler.prototype;

		_proto.load = function load(url, callback, asset) {
			this.loadAssets(asset, callback);
		};

		_proto.open = function open(url, data, asset) {
			return asset ? asset.resource : null;
		};

		_proto.patch = function patch(asset, registry) {
			this.loadAssets(asset, function (err, result) {
				if (err) {
					registry.fire('error', asset);
					registry.fire('error:' + asset.id, err, asset);
					asset.fire('error', asset);
				}
			});
		};

		_proto.getAssetIds = function getAssetIds(cubemapAsset) {
			var result = [];
			result[0] = cubemapAsset.file;

			if ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {
				for (var i = 0; i < 6; ++i) {
					result[i + 1] = cubemapAsset.data.textures[i];
				}
			} else {
				result[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;
			}

			return result;
		};

		_proto.compareAssetIds = function compareAssetIds(assetIdA, assetIdB) {
			if (assetIdA && assetIdB) {
				if (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === "string") {
					return assetIdA === assetIdB;
				}

				return assetIdA.url === assetIdB.url;
			}

			return assetIdA !== null === (assetIdB !== null);
		};

		_proto.update = function update(cubemapAsset, assetIds, assets) {
			var assetData = cubemapAsset.data || {};
			var oldAssets = cubemapAsset._handlerState.assets;
			var oldResources = cubemapAsset._resources;
			var tex, mip, i;
			var resources = [null, null, null, null, null, null, null];

			var getType = function getType() {
				if (assetData.hasOwnProperty('type')) {
					return assetData.type;
				}

				if (assetData.hasOwnProperty('rgbm')) {
					return assetData.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
				}

				return null;
			};

			if (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {
				if (assets[0]) {
					tex = assets[0].resource;

					for (i = 0; i < 6; ++i) {
						resources[i + 1] = new Texture(this._device, {
							name: cubemapAsset.name + '_prelitCubemap' + (tex.width >> i),
							cubemap: true,
							type: getType() || tex.type,
							width: tex.width >> i,
							height: tex.height >> i,
							format: tex.format,
							levels: [tex._levels[i]],
							fixCubemapSeams: true,
							addressU: ADDRESS_CLAMP_TO_EDGE,
							addressV: ADDRESS_CLAMP_TO_EDGE,
							mipmaps: i === 0
						});
					}
				}
			} else {
				resources[1] = oldResources[1] || null;
				resources[2] = oldResources[2] || null;
				resources[3] = oldResources[3] || null;
				resources[4] = oldResources[4] || null;
				resources[5] = oldResources[5] || null;
				resources[6] = oldResources[6] || null;
			}

			var faceAssets = assets.slice(1);

			if (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {
				if (faceAssets.indexOf(null) === -1) {
					var faceTextures = faceAssets.map(function (asset) {
						return asset.resource;
					});
					var faceLevels = [];

					for (mip = 0; mip < faceTextures[0]._levels.length; ++mip) {
						faceLevels.push(faceTextures.map(function (faceTexture) {
							return faceTexture._levels[mip];
						}));
					}

					var format = faceTextures[0].format;
					var faces = new Texture(this._device, {
						name: cubemapAsset.name + '_faces',
						cubemap: true,
						type: getType() || faceTextures[0].type,
						width: faceTextures[0].width,
						height: faceTextures[0].height,
						format: format === PIXELFORMAT_R8_G8_B8 ? PIXELFORMAT_R8_G8_B8_A8 : format,
						levels: faceLevels,
						minFilter: assetData.hasOwnProperty('minFilter') ? assetData.minFilter : faceTextures[0].minFilter,
						magFilter: assetData.hasOwnProperty('magFilter') ? assetData.magFilter : faceTextures[0].magFilter,
						anisotropy: assetData.hasOwnProperty('anisotropy') ? assetData.anisotropy : 1,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						fixCubemapSeams: !!assets[0]
					});
					resources[0] = faces;
				}
			} else {
				resources[0] = oldResources[0] || null;
			}

			if (!this.cmpArrays(resources, oldResources)) {
				cubemapAsset.resources = resources;
				cubemapAsset._handlerState.assetIds = assetIds;
				cubemapAsset._handlerState.assets = assets;

				for (i = 0; i < oldResources.length; ++i) {
					if (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {
						oldResources[i].destroy();
					}
				}
			}

			for (i = 0; i < oldAssets.length; ++i) {
				if (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {
					oldAssets[i].unload();
				}
			}
		};

		_proto.cmpArrays = function cmpArrays(arr1, arr2) {
			if (arr1.length !== arr2.length) {
				return false;
			}

			for (var i = 0; i < arr1.length; ++i) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}

			return true;
		};

		_proto.resolveId = function resolveId(value) {
			var valueInt = parseInt(value, 10);
			return valueInt === value || valueInt.toString() === value ? valueInt : value;
		};

		_proto.loadAssets = function loadAssets(cubemapAsset, callback) {
			if (!cubemapAsset.hasOwnProperty('_handlerState')) {
				cubemapAsset._handlerState = {
					assetIds: [null, null, null, null, null, null, null],
					assets: [null, null, null, null, null, null, null]
				};
			}

			var self = this;
			var assetIds = self.getAssetIds(cubemapAsset);
			var assets = [null, null, null, null, null, null, null];
			var loadedAssetIds = cubemapAsset._handlerState.assetIds;
			var loadedAssets = cubemapAsset._handlerState.assets;
			var registry = self._registry;
			var awaiting = 7;

			var onLoad = function onLoad(index, asset) {
				assets[index] = asset;
				awaiting--;

				if (awaiting === 0) {
					self.update(cubemapAsset, assetIds, assets);
					callback(null, cubemapAsset.resources);
				}
			};

			var onError = function onError(index, err, asset) {
				callback(err);
			};

			var processTexAsset = function processTexAsset(index, texAsset) {
				if (texAsset.loaded) {
					onLoad(index, texAsset);
				} else {
					registry.once('load:' + texAsset.id, onLoad.bind(self, index));
					registry.once('error:' + texAsset.id, onError.bind(self, index));

					if (!texAsset.loading) {
						registry.load(texAsset);
					}
				}
			};

			var texAsset;

			for (var i = 0; i < 7; ++i) {
				var assetId = this.resolveId(assetIds[i]);

				if (!assetId) {
					onLoad(i, null);
				} else if (self.compareAssetIds(assetId, loadedAssetIds[i])) {
					onLoad(i, loadedAssets[i]);
				} else if (parseInt(assetId, 10) === assetId) {
					texAsset = registry.get(assetId);

					if (texAsset) {
						processTexAsset(i, texAsset);
					} else {
						setTimeout(function (index, assetId_) {
							var texAsset = registry.get(assetId_);

							if (texAsset) {
								processTexAsset(index, texAsset);
							} else {
								onError(index, "failed to find dependent cubemap asset=" + assetId_);
							}
						}.bind(null, i, assetId));
					}
				} else {
					var file = typeof assetId === "string" ? {
						url: assetId,
						filename: assetId
					} : assetId;
					texAsset = new Asset(cubemapAsset.name + "_part_" + i, "texture", file);
					registry.add(texAsset);
					registry.once('load:' + texAsset.id, onLoad.bind(self, i));
					registry.once('error:' + texAsset.id, onError.bind(self, i));
					registry.load(texAsset);
				}
			}
		};

		return CubemapHandler;
	}();

	var FolderHandler = function () {
		function FolderHandler() {}

		var _proto = FolderHandler.prototype;

		_proto.load = function load(url, callback) {
			callback(null, null);
		};

		_proto.open = function open(url, data) {
			return data;
		};

		return FolderHandler;
	}();

	var FONT_MSDF = 'msdf';
	var FONT_BITMAP = 'bitmap';

	var Font = function () {
		function Font(textures, data) {
			this.type = data ? data.type || FONT_MSDF : FONT_MSDF;
			this.em = 1;
			this.textures = textures;
			this.intensity = 0.0;
			this._data = null;
			this.data = data;
		}

		_createClass(Font, [{
			key: "data",
			get: function get() {
				return this._data;
			},
			set: function set(value) {
				this._data = value;
				if (!value) return;

				if (this._data.intensity !== undefined) {
					this.intensity = this._data.intensity;
				}

				if (!this._data.info) this._data.info = {};

				if (!this._data.version || this._data.version < 2) {
					this._data.info.maps = [{
						width: this._data.info.width,
						height: this._data.info.height
					}];

					if (this._data.chars) {
						for (var key in this._data.chars) {
							this._data.chars[key].map = 0;
						}
					}
				}
			}
		}]);

		return Font;
	}();

	function upgradeDataSchema(data) {
		if (data.version < 3) {
			if (data.version < 2) {
				data.info.maps = data.info.maps || [{
					width: data.info.width,
					height: data.info.height
				}];
			}

			data.chars = Object.keys(data.chars || {}).reduce(function (newChars, key) {
				var existing = data.chars[key];
				var newKey = existing.letter !== undefined ? existing.letter : string.fromCodePoint(key);

				if (data.version < 2) {
					existing.map = existing.map || 0;
				}

				newChars[newKey] = existing;
				return newChars;
			}, {});
			data.version = 3;
		}

		return data;
	}

	var FontHandler = function () {
		function FontHandler(loader) {
			this._loader = loader;
			this.maxRetries = 0;
		}

		var _proto = FontHandler.prototype;

		_proto.load = function load(url, callback, asset) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			var self = this;

			if (path.getExtension(url.original) === '.json') {
				http.get(url.load, {
					retry: this.maxRetries > 0,
					maxRetries: this.maxRetries
				}, function (err, response) {
					if (!err) {
						var data = upgradeDataSchema(response);

						self._loadTextures(url.load.replace('.json', '.png'), data, function (err, textures) {
							if (err) return callback(err);
							callback(null, {
								data: data,
								textures: textures
							});
						});
					} else {
						callback("Error loading font resource: " + url.original + " [" + err + "]");
					}
				});
			} else {
				if (asset && asset.data) {
					asset.data = upgradeDataSchema(asset.data);
				}

				this._loadTextures(url.load, asset && asset.data, callback);
			}
		};

		_proto._loadTextures = function _loadTextures(url, data, callback) {
			var numTextures = data.info.maps.length;
			var numLoaded = 0;
			var error = null;
			var textures = new Array(numTextures);
			var loader = this._loader;

			var loadTexture = function loadTexture(index) {
				var onLoaded = function onLoaded(err, texture) {
					if (error) return;

					if (err) {
						error = err;
						return callback(err);
					}

					texture.upload();
					textures[index] = texture;
					numLoaded++;

					if (numLoaded === numTextures) {
						callback(null, textures);
					}
				};

				if (index === 0) {
					loader.load(url, "texture", onLoaded);
				} else {
					loader.load(url.replace('.png', index + '.png'), "texture", onLoaded);
				}
			};

			for (var i = 0; i < numTextures; i++) {
				loadTexture(i);
			}
		};

		_proto.open = function open(url, data, asset) {
			var font;

			if (data.textures) {
				font = new Font(data.textures, data.data);
			} else {
				font = new Font(data, null);
			}

			return font;
		};

		_proto.patch = function patch(asset, assets) {
			var font = asset.resource;

			if (!font.data && asset.data) {
				font.data = asset.data;
			} else if (!asset.data && font.data) {
				asset.data = font.data;
			}

			if (asset.data) {
				asset.data = upgradeDataSchema(asset.data);
			}
		};

		return FontHandler;
	}();

	var CompressUtils = {
		setCompressedPRS: function setCompressedPRS(entity, data, compressed) {
			var a = compressed.singleVecs;
			var b, i;
			var v = data.___1;

			if (!v) {
				b = compressed.tripleVecs;
				i = data.___2;
			}

			var n = v ? v[0] : b[i];
			entity.setLocalPosition(a[n], a[n + 1], a[n + 2]);
			n = v ? v[1] : b[i + 1];
			entity.setLocalEulerAngles(a[n], a[n + 1], a[n + 2]);
			n = v ? v[2] : b[i + 2];
			entity.setLocalScale(a[n], a[n + 1], a[n + 2]);
		},
		oneCharToKey: function oneCharToKey(s, data) {
			var i = s.charCodeAt(0) - data.fieldFirstCode;
			return data.fieldArray[i];
		},
		multCharToKey: function multCharToKey(s, data) {
			var ind = 0;

			for (var i = 0; i < s.length; i++) {
				ind = ind * data.fieldCodeBase + s.charCodeAt(i) - data.fieldFirstCode;
			}

			return data.fieldArray[ind];
		}
	};

	var Decompress = function () {
		function Decompress(node, data) {
			this._node = node;
			this._data = data;
		}

		var _proto = Decompress.prototype;

		_proto.run = function run() {
			var type = Object.prototype.toString.call(this._node);

			if (type === '[object Object]') {
				this._handleMap();
			} else if (type === '[object Array]') {
				this._handleArray();
			} else {
				this._result = this._node;
			}

			return this._result;
		};

		_proto._handleMap = function _handleMap() {
			this._result = {};
			var a = Object.keys(this._node);
			a.forEach(this._handleKey, this);
		};

		_proto._handleKey = function _handleKey(origKey) {
			var newKey = origKey;
			var len = origKey.length;

			if (len === 1) {
				newKey = CompressUtils.oneCharToKey(origKey, this._data);
			} else if (len === 2) {
				newKey = CompressUtils.multCharToKey(origKey, this._data);
			}

			this._result[newKey] = new Decompress(this._node[origKey], this._data).run();
		};

		_proto._handleArray = function _handleArray() {
			this._result = [];

			this._node.forEach(this._handleArElt, this);
		};

		_proto._handleArElt = function _handleArElt(elt) {
			var v = new Decompress(elt, this._data).run();

			this._result.push(v);
		};

		return Decompress;
	}();

	var SceneParser = function () {
		function SceneParser(app, isTemplate) {
			this._app = app;
			this._isTemplate = isTemplate;
		}

		var _proto = SceneParser.prototype;

		_proto.parse = function parse(data) {
			var entities = {};
			var parent = null;
			var compressed = data.compressedFormat;

			if (compressed && !data.entDecompressed) {
				data.entDecompressed = true;
				data.entities = new Decompress(data.entities, compressed).run();
			}

			for (var id in data.entities) {
				var curData = data.entities[id];

				var curEnt = this._createEntity(curData, compressed);

				entities[id] = curEnt;

				if (curData.parent === null) {
					parent = curEnt;
				}
			}

			for (var _id in data.entities) {
				var _curEnt = entities[_id];
				var children = data.entities[_id].children;
				var len = children.length;

				for (var i = 0; i < len; i++) {
					var childEnt = entities[children[i]];

					if (childEnt) {
						_curEnt.addChild(childEnt);
					}
				}
			}

			this._openComponentData(parent, data.entities);

			return parent;
		};

		_proto._createEntity = function _createEntity(data, compressed) {
			var entity = new Entity(data.name, this._app);
			entity.setGuid(data.resource_id);

			this._setPosRotScale(entity, data, compressed);

			entity._enabled = data.enabled !== undefined ? data.enabled : true;

			if (this._isTemplate) {
				entity._template = true;
			} else {
				entity._enabledInHierarchy = entity._enabled;
			}

			entity.template = data.template;

			if (data.tags) {
				for (var i = 0; i < data.tags.length; i++) {
					entity.tags.add(data.tags[i]);
				}
			}

			if (data.labels) {
				data.labels.forEach(function (label) {
					entity.addLabel(label);
				});
			}

			return entity;
		};

		_proto._setPosRotScale = function _setPosRotScale(entity, data, compressed) {
			if (compressed) {
				CompressUtils.setCompressedPRS(entity, data, compressed);
			} else {
				var p = data.position;
				var r = data.rotation;
				var s = data.scale;
				entity.setLocalPosition(p[0], p[1], p[2]);
				entity.setLocalEulerAngles(r[0], r[1], r[2]);
				entity.setLocalScale(s[0], s[1], s[2]);
			}
		};

		_proto._openComponentData = function _openComponentData(entity, entities) {
			var systemsList = this._app.systems.list;
			var len = systemsList.length;
			var entityData = entities[entity.getGuid()];

			for (var i = 0; i < len; i++) {
				var system = systemsList[i];
				var componentData = entityData.components[system.id];

				if (componentData) {
					system.addComponent(entity, componentData);
				}
			}

			len = entityData.children.length;
			var children = entity._children;

			for (var _i = 0; _i < len; _i++) {
				children[_i] = this._openComponentData(children[_i], entities);
			}

			return entity;
		};

		return SceneParser;
	}();

	var SceneUtils = {
		load: function load(url, maxRetries, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			http.get(url.load, {
				retry: maxRetries > 0,
				maxRetries: maxRetries
			}, function (err, response) {
				if (!err) {
					callback(err, response);
				} else {
					var errMsg = 'Error while loading scene JSON ' + url.original;

					if (err.message) {
						errMsg += ': ' + err.message;

						if (err.stack) {
							errMsg += '\n' + err.stack;
						}
					} else {
						errMsg += ': ' + err;
					}

					callback(errMsg);
				}
			});
		}
	};

	var HierarchyHandler = function () {
		function HierarchyHandler(app) {
			this._app = app;
			this.maxRetries = 0;
		}

		var _proto = HierarchyHandler.prototype;

		_proto.load = function load(url, callback) {
			SceneUtils.load(url, this.maxRetries, callback);
		};

		_proto.open = function open(url, data) {
			this._app.systems.script.preloading = true;
			var parser = new SceneParser(this._app, false);
			var parent = parser.parse(data);
			this._app.systems.script.preloading = false;
			return parent;
		};

		return HierarchyHandler;
	}();

	var HtmlHandler = function () {
		function HtmlHandler() {
			this.maxRetries = 0;
		}

		var _proto = HtmlHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading html resource: " + url.original + " [" + err + "]");
				}
			});
		};

		_proto.open = function open(url, data) {
			return data;
		};

		_proto.patch = function patch(asset, assets) {};

		return HtmlHandler;
	}();

	var JsonHandler = function () {
		function JsonHandler() {
			this.maxRetries = 0;
		}

		var _proto = JsonHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};

			if (url.load.startsWith('blob:')) {
				options.responseType = Http.ResponseType.JSON;
			}

			http.get(url.load, options, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading JSON resource: " + url.original + " [" + err + "]");
				}
			});
		};

		_proto.open = function open(url, data) {
			return data;
		};

		_proto.patch = function patch(asset, assets) {};

		return JsonHandler;
	}();

	var AssetReference = function () {
		function AssetReference(propertyName, parent, registry, callbacks, scope) {
			this.propertyName = propertyName;
			this.parent = parent;
			this._scope = scope;
			this._registry = registry;
			this.id = null;
			this.url = null;
			this.asset = null;
			this._onAssetLoad = callbacks.load;
			this._onAssetAdd = callbacks.add;
			this._onAssetRemove = callbacks.remove;
			this._onAssetUnload = callbacks.unload;
		}

		var _proto = AssetReference.prototype;

		_proto._bind = function _bind() {
			if (this.id) {
				if (this._onAssetLoad) this._registry.on("load:" + this.id, this._onLoad, this);
				if (this._onAssetAdd) this._registry.once("add:" + this.id, this._onAdd, this);
				if (this._onAssetRemove) this._registry.on("remove:" + this.id, this._onRemove, this);
				if (this._onAssetUnload) this._registry.on("unload:" + this.id, this._onUnload, this);
			}

			if (this.url) {
				if (this._onAssetLoad) this._registry.on("load:url:" + this.url, this._onLoad, this);
				if (this._onAssetAdd) this._registry.once("add:url:" + this.url, this._onAdd, this);
				if (this._onAssetRemove) this._registry.on("remove:url:" + this.url, this._onRemove, this);
			}
		};

		_proto._unbind = function _unbind() {
			if (this.id) {
				if (this._onAssetLoad) this._registry.off('load:' + this.id, this._onLoad, this);
				if (this._onAssetAdd) this._registry.off('add:' + this.id, this._onAdd, this);
				if (this._onAssetRemove) this._registry.off('remove:' + this.id, this._onRemove, this);
				if (this._onAssetUnload) this._registry.off("unload:" + this.id, this._onUnload, this);
			}

			if (this.url) {
				if (this._onAssetLoad) this._registry.off('load:' + this.url, this._onLoad, this);
				if (this._onAssetAdd) this._registry.off('add:' + this.url, this._onAdd, this);
				if (this._onAssetRemove) this._registry.off('remove:' + this.url, this._onRemove, this);
			}
		};

		_proto._onLoad = function _onLoad(asset) {
			this._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);
		};

		_proto._onAdd = function _onAdd(asset) {
			this.asset = asset;

			this._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);
		};

		_proto._onRemove = function _onRemove(asset) {
			this._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);

			this.asset = null;
		};

		_proto._onUnload = function _onUnload(asset) {
			this._onAssetUnload.call(this._scope, this.propertyName, this.parent, asset);
		};

		_createClass(AssetReference, [{
			key: "id",
			get: function get() {
				return this._id;
			},
			set: function set(value) {
				if (this.url) throw Error("Can't set id and url");

				this._unbind();

				this._id = value;
				this.asset = this._registry.get(this._id);

				this._bind();
			}
		}, {
			key: "url",
			get: function get() {
				return this._url;
			},
			set: function set(value) {
				if (this.id) throw Error("Can't set id and url");

				this._unbind();

				this._url = value;
				this.asset = this._registry.getByUrl(this._url);

				this._bind();
			}
		}]);

		return AssetReference;
	}();

	var StandardMaterialValidator = function () {
		function StandardMaterialValidator() {
			this.removeInvalid = true;
			this.valid = true;
			this.enumValidators = {
				occludeSpecular: this._createEnumValidator([SPECOCC_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT]),
				cull: this._createEnumValidator([CULLFACE_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK]),
				blendType: this._createEnumValidator([BLEND_SUBTRACTIVE, BLEND_ADDITIVE, BLEND_NORMAL, BLEND_NONE, BLEND_PREMULTIPLIED, BLEND_MULTIPLICATIVE, BLEND_ADDITIVEALPHA, BLEND_MULTIPLICATIVE2X, BLEND_SCREEN, BLEND_MIN, BLEND_MAX]),
				depthFunc: this._createEnumValidator([FUNC_NEVER, FUNC_LESS, FUNC_EQUAL, FUNC_LESSEQUAL, FUNC_GREATER, FUNC_NOTEQUAL, FUNC_GREATEREQUAL, FUNC_ALWAYS]),
				shadingModel: this._createEnumValidator([SPECULAR_PHONG, SPECULAR_BLINN])
			};
		}

		var _proto = StandardMaterialValidator.prototype;

		_proto.setInvalid = function setInvalid(key, data) {
			this.valid = false;
			Debug.warn("Ignoring invalid StandardMaterial property: " + key, data[key]);

			if (this.removeInvalid) {
				delete data[key];
			}
		};

		_proto.validate = function validate(data) {
			var TYPES = standardMaterialParameterTypes;
			var pathMapping = data.mappingFormat === "path";

			for (var key in data) {
				var type = TYPES[key];

				if (!type) {
					Debug.warn("Ignoring unsupported input property to standard material: " + key);
					this.valid = false;
					continue;
				}

				if (type.startsWith("enum")) {
					var enumType = type.split(":")[1];

					if (this.enumValidators[enumType]) {
						if (!this.enumValidators[enumType](data[key])) {
							this.setInvalid(key, data);
						}
					}
				} else if (type === 'number') {
					if (typeof data[key] !== 'number') {
						this.setInvalid(key, data);
					}
				} else if (type === 'boolean') {
					if (typeof data[key] !== 'boolean') {
						this.setInvalid(key, data);
					}
				} else if (type === 'string') {
					if (typeof data[key] !== 'string') {
						this.setInvalid(key, data);
					}
				} else if (type === 'vec2') {
					if (!(data[key] instanceof Array && data[key].length === 2)) {
						this.setInvalid(key, data);
					}
				} else if (type === 'rgb') {
					if (!(data[key] instanceof Array && data[key].length === 3)) {
						this.setInvalid(key, data);
					}
				} else if (type === 'texture') {
					if (!pathMapping) {
						if (!(typeof data[key] === 'number' || data[key] === null)) {
							if (!(data[key] instanceof Texture)) {
								this.setInvalid(key, data);
							}
						}
					} else {
						if (!(typeof data[key] === 'string' || data[key] === null)) {
							if (!(data[key] instanceof Texture)) {
								this.setInvalid(key, data);
							}
						}
					}
				} else if (type === 'boundingbox') {
					if (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {
						this.setInvalid(key, data);
					}

					if (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {
						this.setInvalid(key, data);
					}
				} else if (type === 'cubemap') {
					if (!(typeof data[key] === 'number' || data[key] === null || data[key] === undefined)) {
						if (!(data[key] instanceof Texture && data[key].cubemap)) {
							this.setInvalid(key, data);
						}
					}
				} else if (type === 'chunks') {
					var chunkNames = Object.keys(data[key]);

					for (var i = 0; i < chunkNames.length; i++) {
						if (typeof data[key][chunkNames[i]] !== 'string') {
							this.setInvalid(chunkNames[i], data[key]);
						}
					}
				} else {
					console.error("Unknown material type: " + type);
				}
			}

			data.validated = true;
			return this.valid;
		};

		_proto._createEnumValidator = function _createEnumValidator(values) {
			return function (value) {
				return values.indexOf(value) >= 0;
			};
		};

		return StandardMaterialValidator;
	}();

	var JsonStandardMaterialParser = function () {
		function JsonStandardMaterialParser() {
			this._validator = null;
		}

		var _proto = JsonStandardMaterialParser.prototype;

		_proto.parse = function parse(input) {
			var migrated = this.migrate(input);

			var validated = this._validate(migrated);

			var material = new StandardMaterial();
			this.initialize(material, validated);
			return material;
		};

		_proto.initialize = function initialize(material, data) {
			if (!data.validated) {
				data = this._validate(data);
			}

			if (data.chunks) {
				material.chunks = _extends({}, data.chunks);
			}

			for (var key in data) {
				var type = standardMaterialParameterTypes[key];
				var value = data[key];

				if (type === 'vec2') {
					material[key] = new Vec2(value[0], value[1]);
				} else if (type === 'rgb') {
					material[key] = new Color(value[0], value[1], value[2]);
				} else if (type === 'texture') {
					if (value instanceof Texture) {
						material[key] = value;
					} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
						material[key] = null;
					}
				} else if (type === 'cubemap') {
					if (value instanceof Texture) {
						material[key] = value;
					} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
						material[key] = null;
					}

					if (key === 'cubeMap' && !value) {
						material.prefilteredCubemaps = null;
					}
				} else if (type === 'boundingbox') {
					var center = new Vec3(value.center[0], value.center[1], value.center[2]);
					var halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);
					material[key] = new BoundingBox(center, halfExtents);
				} else {
					material[key] = data[key];
				}
			}

			material.update();
		};

		_proto.migrate = function migrate(data) {
			if (data.shadingModel === undefined) {
				if (data.shader === 'blinn') {
					data.shadingModel = SPECULAR_BLINN;
				} else {
					data.shadingModel = SPECULAR_PHONG;
				}
			}

			if (data.shader) delete data.shader;

			if (data.mapping_format) {
				data.mappingFormat = data.mapping_format;
				delete data.mapping_format;
			}

			var i;
			var RENAMED_PROPERTIES = [["bumpMapFactor", "bumpiness"], ["aoUvSet", "aoMapUv"], ["aoMapVertexColor", "aoVertexColor"], ["diffuseMapVertexColor", "diffuseVertexColor"], ["emissiveMapVertexColor", "emissiveVertexColor"], ["specularMapVertexColor", "specularVertexColor"], ["metalnessMapVertexColor", "metalnessVertexColor"], ["opacityMapVertexColor", "opacityVertexColor"], ["glossMapVertexColor", "glossVertexColor"], ["lightMapVertexColor", "lightVertexColor"], ["diffuseMapTint", "diffuseTint"], ["specularMapTint", "specularTint"], ["emissiveMapTint", "emissiveTint"], ["metalnessMapTint", "metalnessTint"]];

			for (i = 0; i < RENAMED_PROPERTIES.length; i++) {
				var _old = RENAMED_PROPERTIES[i][0];
				var _new = RENAMED_PROPERTIES[i][1];

				if (data[_old] !== undefined && !(data[_new] !== undefined)) {
					data[_new] = data[_old];
					delete data[_old];
				}
			}

			var DEPRECATED_PROPERTIES = ['fresnelFactor', 'shadowSampleType'];

			for (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {
				var name = DEPRECATED_PROPERTIES[i];

				if (data.hasOwnProperty(name)) {
					delete data[name];
				}
			}

			return data;
		};

		_proto._validate = function _validate(data) {
			if (!data.validated) {
				if (!this._validator) {
					this._validator = new StandardMaterialValidator();
				}

				this._validator.validate(data);
			}

			return data;
		};

		return JsonStandardMaterialParser;
	}();

	var PLACEHOLDER_MAP = {
		aoMap: 'white',
		diffuseMap: 'gray',
		specularMap: 'gray',
		metalnessMap: 'black',
		glossMap: 'gray',
		emissiveMap: 'gray',
		normalMap: 'normal',
		heightMap: 'gray',
		opacityMap: 'gray',
		sphereMap: 'gray',
		lightMap: 'white'
	};

	var MaterialHandler = function () {
		function MaterialHandler(app) {
			this._assets = app.assets;
			this._device = app.graphicsDevice;
			this._placeholderTextures = null;
			this._parser = new JsonStandardMaterialParser();
			this.maxRetries = 0;
		}

		var _proto = MaterialHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					if (callback) {
						response._engine = true;
						callback(null, response);
					}
				} else {
					if (callback) {
						callback("Error loading material: " + url.original + " [" + err + "]");
					}
				}
			});
		};

		_proto.open = function open(url, data) {
			var material = this._parser.parse(data);

			if (data._engine) {
				material._data = data;
				delete data._engine;
			}

			return material;
		};

		_proto._createPlaceholders = function _createPlaceholders() {
			this._placeholderTextures = {};
			var textures = {
				white: [255, 255, 255, 255],
				gray: [128, 128, 128, 255],
				black: [0, 0, 0, 255],
				normal: [128, 128, 255, 255]
			};

			for (var key in textures) {
				if (!textures.hasOwnProperty(key)) continue;
				this._placeholderTextures[key] = new Texture(this._device, {
					width: 2,
					height: 2,
					format: PIXELFORMAT_R8_G8_B8_A8
				});
				this._placeholderTextures[key].name = 'placeholder';

				var pixels = this._placeholderTextures[key].lock();

				for (var i = 0; i < 4; i++) {
					for (var c = 0; c < 4; c++) {
						pixels[i * 4 + c] = textures[key][c];
					}
				}

				this._placeholderTextures[key].unlock();
			}
		};

		_proto.patch = function patch(asset, assets) {
			if (asset.resource._data) {
				asset._data = asset.resource._data;
				delete asset.resource._data;
			}

			asset.data.name = asset.name;
			asset.resource.name = asset.name;

			this._bindAndAssignAssets(asset, assets);

			asset.off('unload', this._onAssetUnload, this);
			asset.on('unload', this._onAssetUnload, this);
		};

		_proto._onAssetUnload = function _onAssetUnload(asset) {
			delete asset.data.parameters;
			delete asset.data.chunks;
			delete asset.data.name;
		};

		_proto._assignTexture = function _assignTexture(parameterName, materialAsset, texture) {
			materialAsset.resource[parameterName] = texture;
		};

		_proto._getPlaceholderTexture = function _getPlaceholderTexture(parameterName) {
			if (!this._placeholderTextures) {
				this._createPlaceholders();
			}

			var placeholder = PLACEHOLDER_MAP[parameterName];
			var texture = this._placeholderTextures[placeholder];
			return texture;
		};

		_proto._assignPlaceholderTexture = function _assignPlaceholderTexture(parameterName, materialAsset) {
			materialAsset.resource[parameterName] = this._getPlaceholderTexture(parameterName);
		};

		_proto._onTextureLoad = function _onTextureLoad(parameterName, materialAsset, textureAsset) {
			this._assignTexture(parameterName, materialAsset, textureAsset.resource);

			materialAsset.resource.update();
		};

		_proto._onTextureAdd = function _onTextureAdd(parameterName, materialAsset, textureAsset) {
			this._assets.load(textureAsset);
		};

		_proto._onTextureRemoveOrUnload = function _onTextureRemoveOrUnload(parameterName, materialAsset, textureAsset) {
			var material = materialAsset.resource;

			if (material) {
				if (materialAsset.resource[parameterName] === textureAsset.resource) {
					this._assignPlaceholderTexture(parameterName, materialAsset);

					material.update();
				}
			}
		};

		_proto._assignCubemap = function _assignCubemap(parameterName, materialAsset, textures) {
			materialAsset.resource[parameterName] = textures[0];

			if (parameterName === 'cubeMap') {
				materialAsset.resource.prefilteredCubemaps = textures.slice(1);
			}
		};

		_proto._onCubemapLoad = function _onCubemapLoad(parameterName, materialAsset, cubemapAsset) {
			this._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);

			this._parser.initialize(materialAsset.resource, materialAsset.data);
		};

		_proto._onCubemapAdd = function _onCubemapAdd(parameterName, materialAsset, cubemapAsset) {
			if (materialAsset.data.shadingModel === SPECULAR_PHONG) {
				materialAsset.loadFaces = true;
			}

			this._assets.load(cubemapAsset);
		};

		_proto._onCubemapRemoveOrUnload = function _onCubemapRemoveOrUnload(parameterName, materialAsset, cubemapAsset) {
			var material = materialAsset.resource;

			if (materialAsset.data.prefilteredCubeMap128 === cubemapAsset.resources[1]) {
				this._assignCubemap(parameterName, materialAsset, [null, null, null, null, null, null, null]);

				material.update();
			}
		};

		_proto._bindAndAssignAssets = function _bindAndAssignAssets(materialAsset, assets) {
			var data = this._parser.migrate(materialAsset.data);

			var material = materialAsset.resource;
			var pathMapping = data.mappingFormat === "path";
			var TEXTURES = standardMaterialTextureParameters;
			var i, name, assetReference;

			for (i = 0; i < TEXTURES.length; i++) {
				name = TEXTURES[i];
				assetReference = material._assetReferences[name];
				var dataAssetId = data[name];
				var materialTexture = material[name];

				var isPlaceHolderTexture = materialTexture === this._getPlaceholderTexture(name);

				var dataValidated = data.validated;

				if (dataAssetId && (!materialTexture || !dataValidated || isPlaceHolderTexture)) {
					if (!assetReference) {
						assetReference = new AssetReference(name, materialAsset, assets, {
							load: this._onTextureLoad,
							add: this._onTextureAdd,
							remove: this._onTextureRemoveOrUnload,
							unload: this._onTextureRemoveOrUnload
						}, this);
						material._assetReferences[name] = assetReference;
					}

					if (pathMapping) {
						assetReference.url = materialAsset.getAbsoluteUrl(dataAssetId);
					} else {
						assetReference.id = dataAssetId;
					}

					if (assetReference.asset) {
						if (assetReference.asset.resource) {
							this._assignTexture(name, materialAsset, assetReference.asset.resource);
						} else {
							this._assignPlaceholderTexture(name, materialAsset);
						}

						assets.load(assetReference.asset);
					}
				} else {
					if (assetReference) {
						if (pathMapping) {
							assetReference.url = null;
						} else {
							assetReference.id = null;
						}
					}
				}
			}

			var CUBEMAPS = standardMaterialCubemapParameters;

			for (i = 0; i < CUBEMAPS.length; i++) {
				name = CUBEMAPS[i];
				assetReference = material._assetReferences[name];

				if (data[name] && !materialAsset.data.prefilteredCubeMap128) {
					if (!assetReference) {
						assetReference = new AssetReference(name, materialAsset, assets, {
							load: this._onCubemapLoad,
							add: this._onCubemapAdd,
							remove: this._onCubemapRemoveOrUnload,
							unload: this._onCubemapRemoveOrUnload
						}, this);
						material._assetReferences[name] = assetReference;
					}

					if (pathMapping) {
						assetReference.url = data[name];
					} else {
						assetReference.id = data[name];
					}

					if (assetReference.asset) {
						if (assetReference.asset.loaded) {
							this._assignCubemap(name, materialAsset, assetReference.asset.resources);
						}

						assets.load(assetReference.asset);
					}
				}
			}

			this._parser.initialize(material, data);
		};

		return MaterialHandler;
	}();

	var GlbModelParser = function () {
		function GlbModelParser(device, defaultMaterial) {
			this._device = device;
			this._defaultMaterial = defaultMaterial;
		}

		var _proto = GlbModelParser.prototype;

		_proto.parse = function parse(data) {
			var glbResources = GlbParser.parse("filename.glb", data, this._device);

			if (glbResources) {
				var model = GlbContainerResource.createModel(glbResources, this._defaultMaterial);
				glbResources.destroy();
				return model;
			}

			return null;
		};

		return GlbModelParser;
	}();

	var PartitionedVertex = function PartitionedVertex() {
		this.index = 0;
		this.boneIndices = [0, 0, 0, 0];
	};

	var SkinPartition = function () {
		function SkinPartition() {
			this.partition = 0;
			this.vertexStart = 0;
			this.vertexCount = 0;
			this.indexStart = 0;
			this.indexCount = 0;
			this.boneIndices = [];
			this.vertices = [];
			this.indices = [];
			this.indexMap = {};
			this.originalMesh = null;
		}

		var _proto = SkinPartition.prototype;

		_proto.addVertex = function addVertex(vertex, idx, vertexArray) {
			var remappedIndex = -1;

			if (this.indexMap[idx] !== undefined) {
				remappedIndex = this.indexMap[idx];
				this.indices.push(remappedIndex);
			} else {
				for (var influence = 0; influence < 4; influence++) {
					if (vertexArray.blendWeight.data[idx * 4 + influence] === 0) continue;
					var originalBoneIndex = vertexArray.blendIndices.data[vertex.index * 4 + influence];
					vertex.boneIndices[influence] = this.getBoneRemap(originalBoneIndex);
				}

				remappedIndex = this.vertices.length;
				this.indices.push(remappedIndex);
				this.vertices.push(vertex);
				this.indexMap[idx] = remappedIndex;
			}
		};

		_proto.addPrimitive = function addPrimitive(vertices, vertexIndices, vertexArray, boneLimit) {
			var bonesToAdd = [];
			var bonesToAddCount = 0;
			var vertexCount = vertices.length;

			for (var i = 0; i < vertexCount; i++) {
				var vertex = vertices[i];
				var idx = vertex.index;

				for (var influence = 0; influence < 4; influence++) {
					if (vertexArray.blendWeight.data[idx * 4 + influence] > 0) {
						var boneIndex = vertexArray.blendIndices.data[idx * 4 + influence];
						var needToAdd = true;

						for (var j = 0; j < bonesToAddCount; j++) {
							if (bonesToAdd[j] === boneIndex) {
								needToAdd = false;
								break;
							}
						}

						if (needToAdd) {
							bonesToAdd[bonesToAddCount] = boneIndex;
							var boneRemap = this.getBoneRemap(boneIndex);
							bonesToAddCount += boneRemap === -1 ? 1 : 0;
						}
					}
				}
			}

			if (this.boneIndices.length + bonesToAddCount > boneLimit) {
				return false;
			}

			for (var _i = 0; _i < bonesToAddCount; _i++) {
				this.boneIndices.push(bonesToAdd[_i]);
			}

			for (var _i2 = 0; _i2 < vertexCount; _i2++) {
				this.addVertex(vertices[_i2], vertexIndices[_i2], vertexArray);
			}

			return true;
		};

		_proto.getBoneRemap = function getBoneRemap(boneIndex) {
			for (var i = 0; i < this.boneIndices.length; i++) {
				if (this.boneIndices[i] === boneIndex) {
					return i;
				}
			}

			return -1;
		};

		return SkinPartition;
	}();

	function indicesToReferences(model) {
		var vertices = model.vertices;
		var skins = model.skins;
		var meshes = model.meshes;
		var meshInstances = model.meshInstances;

		for (var i = 0; i < meshes.length; i++) {
			meshes[i].vertices = vertices[meshes[i].vertices];

			if (meshes[i].skin !== undefined) {
				meshes[i].skin = skins[meshes[i].skin];
			}
		}

		for (var _i3 = 0; _i3 < meshInstances.length; _i3++) {
			meshInstances[_i3].mesh = meshes[meshInstances[_i3].mesh];
		}
	}

	function referencesToIndices(model) {
		var vertices = model.vertices;
		var skins = model.skins;
		var meshes = model.meshes;
		var meshInstances = model.meshInstances;

		for (var i = 0; i < meshes.length; i++) {
			meshes[i].vertices = vertices.indexOf(meshes[i].vertices);

			if (meshes[i].skin !== undefined) {
				meshes[i].skin = skins.indexOf(meshes[i].skin);
			}
		}

		for (var _i4 = 0; _i4 < meshInstances.length; _i4++) {
			meshInstances[_i4].mesh = meshes.indexOf(meshInstances[_i4].mesh);
		}
	}

	function partitionSkin(model, materialMappings, boneLimit) {
		var i, j, k, index;
		indicesToReferences(model);
		var vertexArrays = model.vertices;
		var skins = model.skins;
		var mesh;
		var meshes = model.meshes;
		var meshInstances = model.meshInstances;

		var getVertex = function getVertex(idx) {
			var vert = new PartitionedVertex();
			vert.index = idx;
			return vert;
		};

		for (i = skins.length - 1; i >= 0; i--) {
			if (skins[i].boneNames.length > boneLimit) {
				var skin = skins.splice(i, 1)[0];
				var meshesToSplit = [];

				for (j = 0; j < meshes.length; j++) {
					if (meshes[j].skin === skin) {
						meshesToSplit.push(meshes[j]);
					}
				}

				for (j = 0; j < meshesToSplit.length; j++) {
					index = meshes.indexOf(meshesToSplit[j]);

					if (index !== -1) {
						meshes.splice(index, 1);
					}
				}

				if (meshesToSplit.length === 0) {
					throw new Error('partitionSkin: There should be at least one mesh that references a skin');
				}

				var vertexArray = meshesToSplit[0].vertices;

				for (j = 1; j < meshesToSplit.length; j++) {
					if (meshesToSplit[j].vertices !== vertexArray) {
						throw new Error('partitionSkin: All meshes that share a skin should also share the same vertex buffer');
					}
				}

				var partition = void 0;
				var partitions = [];
				var primitiveVertices = [];
				var primitiveIndices = [];
				var basePartition = 0;

				for (j = 0; j < meshesToSplit.length; j++) {
					mesh = meshesToSplit[j];
					var indices = mesh.indices;

					for (var iIndex = mesh.base; iIndex < mesh.base + mesh.count;) {
						index = indices[iIndex++];
						primitiveVertices[0] = getVertex(index);
						primitiveIndices[0] = index;
						index = indices[iIndex++];
						primitiveVertices[1] = getVertex(index);
						primitiveIndices[1] = index;
						index = indices[iIndex++];
						primitiveVertices[2] = getVertex(index);
						primitiveIndices[2] = index;
						var added = false;

						for (var iBonePartition = basePartition; iBonePartition < partitions.length; iBonePartition++) {
							partition = partitions[iBonePartition];

							if (partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit)) {
								added = true;
								break;
							}
						}

						if (!added) {
							partition = new SkinPartition();
							partition.originalMesh = mesh;
							partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit);
							partitions.push(partition);
						}
					}

					basePartition = partitions.length;
				}

				var partitionedVertices = [];
				var partitionedIndices = [];

				for (j = 0; j < partitions.length; j++) {
					partition = partitions[j];

					if (partition.vertices.length && partition.indices.length) {
						var vertexStart = partitionedVertices.length;
						var vertexCount = partition.vertices.length;
						var indexStart = partitionedIndices.length;
						var indexCount = partition.indices.length;
						partition.partition = j;
						partition.vertexStart = vertexStart;
						partition.vertexCount = vertexCount;
						partition.indexStart = indexStart;
						partition.indexCount = indexCount;
						var iSour = void 0;
						var iDest = void 0;
						iSour = 0;
						iDest = vertexStart;

						while (iSour < vertexCount) {
							partitionedVertices[iDest++] = partition.vertices[iSour++];
						}

						iSour = 0;
						iDest = indexStart;

						while (iSour < indexCount) {
							partitionedIndices[iDest++] = partition.indices[iSour++] + vertexStart;
						}
					}
				}

				var splitSkins = [];

				for (j = 0; j < partitions.length; j++) {
					partition = partitions[j];
					var ibp = [];
					var boneNames = [];

					for (k = 0; k < partition.boneIndices.length; k++) {
						ibp.push(skin.inverseBindMatrices[partition.boneIndices[k]]);
						boneNames.push(skin.boneNames[partition.boneIndices[k]]);
					}

					var splitSkin = {
						inverseBindMatrices: ibp,
						boneNames: boneNames
					};
					splitSkins.push(splitSkin);
					skins.push(splitSkin);
				}

				var attrib = void 0,
						attribName = void 0,
						data = void 0,
						components = void 0;
				var splitVertexArray = {};

				for (attribName in vertexArray) {
					splitVertexArray[attribName] = {
						components: vertexArray[attribName].components,
						data: [],
						type: vertexArray[attribName].type
					};
				}

				for (attribName in vertexArray) {
					if (attribName === 'blendIndices') {
						var dstBoneIndices = splitVertexArray[attribName].data;

						for (j = 0; j < partitionedVertices.length; j++) {
							var srcBoneIndices = partitionedVertices[j].boneIndices;
							dstBoneIndices.push(srcBoneIndices[0], srcBoneIndices[1], srcBoneIndices[2], srcBoneIndices[3]);
						}
					} else {
						attrib = vertexArray[attribName];
						data = attrib.data;
						components = attrib.components;

						for (j = 0; j < partitionedVertices.length; j++) {
							index = partitionedVertices[j].index;

							for (k = 0; k < components; k++) {
								splitVertexArray[attribName].data.push(data[index * components + k]);
							}
						}
					}
				}

				vertexArrays[vertexArrays.indexOf(vertexArray)] = splitVertexArray;

				for (j = 0; j < partitions.length; j++) {
					partition = partitions[j];
					mesh = {
						aabb: {
							min: [0, 0, 0],
							max: [0, 0, 0]
						},
						vertices: splitVertexArray,
						skin: splitSkins[j],
						indices: partitionedIndices.splice(0, partition.indexCount),
						type: 'triangles',
						base: 0,
						count: partition.indexCount
					};
					meshes.push(mesh);

					for (k = meshInstances.length - 1; k >= 0; k--) {
						if (meshInstances[k].mesh === partition.originalMesh) {
							meshInstances.push({
								mesh: mesh,
								node: meshInstances[k].node
							});

							if (materialMappings) {
								materialMappings.push({
									material: materialMappings[k].material,
									path: materialMappings[k].path
								});
							}
						}
					}
				}

				for (j = 0; j < partitions.length; j++) {
					partition = partitions[j];

					for (k = meshInstances.length - 1; k >= 0; k--) {
						if (meshInstances[k].mesh === partition.originalMesh) {
							meshInstances.splice(k, 1);

							if (materialMappings) {
								materialMappings.splice(k, 1);
							}
						}
					}
				}
			}
		}

		referencesToIndices(model);
	}

	var JSON_PRIMITIVE_TYPE = {
		"points": PRIMITIVE_POINTS,
		"lines": PRIMITIVE_LINES,
		"lineloop": PRIMITIVE_LINELOOP,
		"linestrip": PRIMITIVE_LINESTRIP,
		"triangles": PRIMITIVE_TRIANGLES,
		"trianglestrip": PRIMITIVE_TRISTRIP,
		"trianglefan": PRIMITIVE_TRIFAN
	};
	var JSON_VERTEX_ELEMENT_TYPE = {
		"int8": TYPE_INT8,
		"uint8": TYPE_UINT8,
		"int16": TYPE_INT16,
		"uint16": TYPE_UINT16,
		"int32": TYPE_INT32,
		"uint32": TYPE_UINT32,
		"float32": TYPE_FLOAT32
	};

	var JsonModelParser = function () {
		function JsonModelParser(device, defaultMaterial) {
			this._device = device;
			this._defaultMaterial = defaultMaterial;
		}

		var _proto = JsonModelParser.prototype;

		_proto.parse = function parse(data) {
			var modelData = data.model;

			if (!modelData) {
				return null;
			}

			if (modelData.version <= 1) {
				Debug.warn("JsonModelParser#parse: Trying to parse unsupported model format.");
				return null;
			}

			var nodes = this._parseNodes(data);

			var skins = this._parseSkins(data, nodes);

			var vertexBuffers = this._parseVertexBuffers(data);

			var indices = this._parseIndexBuffers(data, vertexBuffers);

			var morphs = this._parseMorphs(data, nodes, vertexBuffers);

			var meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);

			var meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);

			var model = new Model();
			model.graph = nodes[0];
			model.meshInstances = meshInstances;
			model.skinInstances = skins.instances;
			model.morphInstances = morphs.instances;
			model.getGraph().syncHierarchy();
			return model;
		};

		_proto._parseNodes = function _parseNodes(data) {
			var modelData = data.model;
			var nodes = [];
			var i;

			for (i = 0; i < modelData.nodes.length; i++) {
				var nodeData = modelData.nodes[i];
				var node = new GraphNode(nodeData.name);
				node.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);
				node.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);
				node.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);
				node.scaleCompensation = !!nodeData.scaleCompensation;
				nodes.push(node);
			}

			for (i = 1; i < modelData.parents.length; i++) {
				nodes[modelData.parents[i]].addChild(nodes[i]);
			}

			return nodes;
		};

		_proto._parseSkins = function _parseSkins(data, nodes) {
			var modelData = data.model;
			var skins = [];
			var skinInstances = [];
			var i, j;

			if (!this._device.supportsBoneTextures && modelData.skins.length > 0) {
				var boneLimit = this._device.getBoneLimit();

				partitionSkin(modelData, null, boneLimit);
			}

			for (i = 0; i < modelData.skins.length; i++) {
				var skinData = modelData.skins[i];
				var inverseBindMatrices = [];

				for (j = 0; j < skinData.inverseBindMatrices.length; j++) {
					var ibm = skinData.inverseBindMatrices[j];
					inverseBindMatrices[j] = new Mat4().set(ibm);
				}

				var skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);
				skins.push(skin);
				var skinInstance = new SkinInstance(skin);
				var bones = [];

				for (j = 0; j < skin.boneNames.length; j++) {
					var boneName = skin.boneNames[j];
					var bone = nodes[0].findByName(boneName);
					bones.push(bone);
				}

				skinInstance.bones = bones;
				skinInstances.push(skinInstance);
			}

			return {
				skins: skins,
				instances: skinInstances
			};
		};

		_proto._getMorphVertexCount = function _getMorphVertexCount(modelData, morphIndex, vertexBuffers) {
			for (var i = 0; i < modelData.meshes.length; i++) {
				var meshData = modelData.meshes[i];

				if (meshData.morph === morphIndex) {
					var vertexBuffer = vertexBuffers[meshData.vertices];
					return vertexBuffer.numVertices;
				}
			}

			return undefined;
		};

		_proto._parseMorphs = function _parseMorphs(data, nodes, vertexBuffers) {
			var modelData = data.model;
			var morphs = [];
			var morphInstances = [];
			var i, j, vertexCount;
			var targets, morphTarget, morphTargetArray;

			if (modelData.morphs) {
				var sparseToFull = function sparseToFull(data, indices, totalCount) {
					var full = new Float32Array(totalCount * 3);

					for (var s = 0; s < indices.length; s++) {
						var dstIndex = indices[s] * 3;
						full[dstIndex] = data[s * 3];
						full[dstIndex + 1] = data[s * 3 + 1];
						full[dstIndex + 2] = data[s * 3 + 2];
					}

					return full;
				};

				for (i = 0; i < modelData.morphs.length; i++) {
					targets = modelData.morphs[i].targets;
					morphTargetArray = [];
					vertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);

					for (j = 0; j < targets.length; j++) {
						var targetAabb = targets[j].aabb;
						var min = targetAabb.min;
						var max = targetAabb.max;
						var aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
						var indices = targets[j].indices;
						var deltaPositions = targets[j].deltaPositions;
						var deltaNormals = targets[j].deltaNormals;

						if (indices) {
							deltaPositions = sparseToFull(deltaPositions, indices, vertexCount);
							deltaNormals = sparseToFull(deltaNormals, indices, vertexCount);
						}

						morphTarget = new MorphTarget({
							deltaPositions: deltaPositions,
							deltaNormals: deltaNormals,
							name: targets[j].name,
							aabb: aabb
						});
						morphTargetArray.push(morphTarget);
					}

					var morph = new Morph(morphTargetArray, this._device);
					morphs.push(morph);
					var morphInstance = new MorphInstance(morph);
					morphInstances.push(morphInstance);
				}
			}

			return {
				morphs: morphs,
				instances: morphInstances
			};
		};

		_proto._parseVertexBuffers = function _parseVertexBuffers(data) {
			var modelData = data.model;
			var vertexBuffers = [];
			var attributeMap = {
				position: SEMANTIC_POSITION,
				normal: SEMANTIC_NORMAL,
				tangent: SEMANTIC_TANGENT,
				blendWeight: SEMANTIC_BLENDWEIGHT,
				blendIndices: SEMANTIC_BLENDINDICES,
				color: SEMANTIC_COLOR,
				texCoord0: SEMANTIC_TEXCOORD0,
				texCoord1: SEMANTIC_TEXCOORD1,
				texCoord2: SEMANTIC_TEXCOORD2,
				texCoord3: SEMANTIC_TEXCOORD3,
				texCoord4: SEMANTIC_TEXCOORD4,
				texCoord5: SEMANTIC_TEXCOORD5,
				texCoord6: SEMANTIC_TEXCOORD6,
				texCoord7: SEMANTIC_TEXCOORD7
			};

			for (var i = 0; i < modelData.vertices.length; i++) {
				var vertexData = modelData.vertices[i];
				var formatDesc = [];

				for (var attributeName in vertexData) {
					var attribute = vertexData[attributeName];
					formatDesc.push({
						semantic: attributeMap[attributeName],
						components: attribute.components,
						type: JSON_VERTEX_ELEMENT_TYPE[attribute.type],
						normalize: attributeMap[attributeName] === SEMANTIC_COLOR
					});
				}

				var vertexFormat = new VertexFormat(this._device, formatDesc);
				var numVertices = vertexData.position.data.length / vertexData.position.components;
				var vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);
				var iterator = new VertexIterator(vertexBuffer);

				for (var j = 0; j < numVertices; j++) {
					for (var _attributeName in vertexData) {
						var _attribute = vertexData[_attributeName];

						switch (_attribute.components) {
							case 1:
								iterator.element[attributeMap[_attributeName]].set(_attribute.data[j]);

								break;

							case 2:
								iterator.element[attributeMap[_attributeName]].set(_attribute.data[j * 2], 1.0 - _attribute.data[j * 2 + 1]);

								break;

							case 3:
								iterator.element[attributeMap[_attributeName]].set(_attribute.data[j * 3], _attribute.data[j * 3 + 1], _attribute.data[j * 3 + 2]);

								break;

							case 4:
								iterator.element[attributeMap[_attributeName]].set(_attribute.data[j * 4], _attribute.data[j * 4 + 1], _attribute.data[j * 4 + 2], _attribute.data[j * 4 + 3]);

								break;
						}
					}

					iterator.next();
				}

				iterator.end();
				vertexBuffers.push(vertexBuffer);
			}

			return vertexBuffers;
		};

		_proto._parseIndexBuffers = function _parseIndexBuffers(data, vertexBuffers) {
			var modelData = data.model;
			var indexBuffer = null;
			var indexData = null;
			var i;
			var numIndices = 0;

			for (i = 0; i < modelData.meshes.length; i++) {
				var meshData = modelData.meshes[i];

				if (meshData.indices !== undefined) {
					numIndices += meshData.indices.length;
				}
			}

			var maxVerts = 0;

			for (i = 0; i < vertexBuffers.length; i++) {
				maxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);
			}

			if (numIndices > 0) {
				if (maxVerts > 0xFFFF && this._device.extUintElement) {
					indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);
					indexData = new Uint32Array(indexBuffer.lock());
				} else {
					indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);
					indexData = new Uint16Array(indexBuffer.lock());
				}
			}

			return {
				buffer: indexBuffer,
				data: indexData
			};
		};

		_proto._parseMeshes = function _parseMeshes(data, skins, morphs, vertexBuffers, indexBuffer, indexData) {
			var modelData = data.model;
			var meshes = [];
			var indexBase = 0;

			for (var i = 0; i < modelData.meshes.length; i++) {
				var meshData = modelData.meshes[i];
				var meshAabb = meshData.aabb;
				var min = meshAabb.min;
				var max = meshAabb.max;
				var aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
				var indexed = meshData.indices !== undefined;
				var mesh = new Mesh(this._device);
				mesh.vertexBuffer = vertexBuffers[meshData.vertices];
				mesh.indexBuffer[0] = indexed ? indexBuffer : null;
				mesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];
				mesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;
				mesh.primitive[0].count = meshData.count;
				mesh.primitive[0].indexed = indexed;
				mesh.skin = meshData.skin !== undefined ? skins[meshData.skin] : null;
				mesh.morph = meshData.morph !== undefined ? morphs[meshData.morph] : null;
				mesh.aabb = aabb;

				if (indexed) {
					indexData.set(meshData.indices, indexBase);
					indexBase += meshData.indices.length;
				}

				meshes.push(mesh);
			}

			if (indexBuffer !== null) {
				indexBuffer.unlock();
			}

			return meshes;
		};

		_proto._parseMeshInstances = function _parseMeshInstances(data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {
			var modelData = data.model;
			var meshInstances = [];
			var i;

			for (i = 0; i < modelData.meshInstances.length; i++) {
				var meshInstanceData = modelData.meshInstances[i];
				var node = nodes[meshInstanceData.node];
				var mesh = meshes[meshInstanceData.mesh];
				var meshInstance = new MeshInstance(mesh, this._defaultMaterial, node);

				if (mesh.skin) {
					var skinIndex = skins.indexOf(mesh.skin);

					if (skinIndex === -1) {
						throw new Error('Mesh\'s skin does not appear in skin array.');
					}

					meshInstance.skinInstance = skinInstances[skinIndex];
				}

				if (mesh.morph) {
					var morphIndex = morphs.indexOf(mesh.morph);

					if (morphIndex === -1) {
						throw new Error('Mesh\'s morph does not appear in morph array.');
					}

					meshInstance.morphInstance = morphInstances[morphIndex];
				}

				meshInstances.push(meshInstance);
			}

			return meshInstances;
		};

		return JsonModelParser;
	}();

	var ModelHandler = function () {
		function ModelHandler(device) {
			this._device = device;
			this._parsers = [];
			this._defaultMaterial = getDefaultMaterial(device);
			this.maxRetries = 0;
			this.addParser(new JsonModelParser(this._device, this._defaultMaterial), function (url, data) {
				return path.getExtension(url) === '.json';
			});
			this.addParser(new GlbModelParser(this._device, this._defaultMaterial), function (url, data) {
				return path.getExtension(url) === '.glb';
			});
		}

		var _proto = ModelHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};

			if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
				if (path.getExtension(url.original).toLowerCase() === '.glb') {
					options.responseType = Http.ResponseType.ARRAY_BUFFER;
				} else {
					options.responseType = Http.ResponseType.JSON;
				}
			}

			http.get(url.load, options, function (err, response) {
				if (!callback) return;

				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading model: " + url.original + " [" + err + "]");
				}
			});
		};

		_proto.open = function open(url, data) {
			for (var i = 0; i < this._parsers.length; i++) {
				var p = this._parsers[i];

				if (p.decider(url, data)) {
					return p.parser.parse(data);
				}
			}

			Debug.warn("pc.ModelHandler#open: No model parser found for: " + url);
			return null;
		};

		_proto.patch = function patch(asset, assets) {
			if (!asset.resource) return;
			var data = asset.data;
			var self = this;
			asset.resource.meshInstances.forEach(function (meshInstance, i) {
				if (data.mapping) {
					var handleMaterial = function handleMaterial(asset) {
						if (asset.resource) {
							meshInstance.material = asset.resource;
						} else {
							asset.once('load', handleMaterial);
							assets.load(asset);
						}

						asset.once('remove', function (asset) {
							if (meshInstance.material === asset.resource) {
								meshInstance.material = self._defaultMaterial;
							}
						});
					};

					if (!data.mapping[i]) {
						meshInstance.material = self._defaultMaterial;
						return;
					}

					var id = data.mapping[i].material;
					var url = data.mapping[i].path;
					var material;

					if (id !== undefined) {
						if (!id) {
							meshInstance.material = self._defaultMaterial;
						} else {
							material = assets.get(id);

							if (material) {
								handleMaterial(material);
							} else {
								assets.once('add:' + id, handleMaterial);
							}
						}
					} else if (url) {
						var _path = asset.getAbsoluteUrl(data.mapping[i].path);

						material = assets.getByUrl(_path);

						if (material) {
							handleMaterial(material);
						} else {
							assets.once('add:url:' + _path, handleMaterial);
						}
					}
				}
			});
		};

		_proto.addParser = function addParser(parser, decider) {
			this._parsers.push({
				parser: parser,
				decider: decider
			});
		};

		return ModelHandler;
	}();

	function onContainerAssetLoaded(containerAsset) {
		var renderAsset = this;
		if (!renderAsset.resource) return;
		var containerResource = containerAsset.resource;
		var render = containerResource.renders && containerResource.renders[renderAsset.data.renderIndex];

		if (render) {
			renderAsset.resource.meshes = render.resource.meshes;
		}
	}

	function onContainerAssetAdded(containerAsset) {
		var renderAsset = this;
		renderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);
		renderAsset.registry.on('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);
		renderAsset.registry.off('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);
		renderAsset.registry.once('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);

		if (!containerAsset.resource) {
			renderAsset.registry.load(containerAsset);
		} else {
			onContainerAssetLoaded.call(renderAsset, containerAsset);
		}
	}

	function onContainerAssetRemoved(containerAsset) {
		var renderAsset = this;
		renderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);

		if (renderAsset.resource) {
			renderAsset.resource.destroy();
		}
	}

	var RenderHandler = function () {
		function RenderHandler(assets) {
			this._registry = assets;
		}

		var _proto = RenderHandler.prototype;

		_proto.load = function load(url, callback, asset) {};

		_proto.open = function open(url, data) {
			return new Render();
		};

		_proto.patch = function patch(asset, registry) {
			if (!asset.data.containerAsset) return;
			var containerAsset = registry.get(asset.data.containerAsset);

			if (!containerAsset) {
				registry.once('add:' + asset.data.containerAsset, onContainerAssetAdded, asset);
				return;
			}

			onContainerAssetAdded.call(asset, containerAsset);
		};

		return RenderHandler;
	}();

	var ResourceLoader = function () {
		function ResourceLoader(app) {
			this._handlers = {};
			this._requests = {};
			this._cache = {};
			this._app = app;
		}

		var _proto = ResourceLoader.prototype;

		_proto.addHandler = function addHandler(type, handler) {
			this._handlers[type] = handler;
			handler._loader = this;
		};

		_proto.removeHandler = function removeHandler(type) {
			delete this._handlers[type];
		};

		_proto.getHandler = function getHandler(type) {
			return this._handlers[type];
		};

		_proto.load = function load(url, type, callback, asset) {
			var handler = this._handlers[type];

			if (!handler) {
				var err = "No handler for asset type: " + type;
				callback(err);
				return;
			}

			if (!url) {
				this._loadNull(handler, callback, asset);

				return;
			}

			var key = url + type;

			if (this._cache[key] !== undefined) {
				callback(null, this._cache[key]);
			} else if (this._requests[key]) {
				this._requests[key].push(callback);
			} else {
				this._requests[key] = [callback];
				var self = this;

				var handleLoad = function handleLoad(err, urlObj) {
					if (err) {
						self._onFailure(key, err);

						return;
					}

					handler.load(urlObj, function (err, data, extra) {
						if (!self._requests[key]) {
							return;
						}

						if (err) {
							self._onFailure(key, err);

							return;
						}

						try {
							self._onSuccess(key, handler.open(urlObj.original, data, asset), extra);
						} catch (e) {
							self._onFailure(key, e);
						}
					}, asset);
				};

				var normalizedUrl = url.split('?')[0];

				if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl)) {
					if (!this._app.bundles.canLoadUrl(normalizedUrl)) {
						handleLoad("Bundle for " + url + " not loaded yet");
						return;
					}

					this._app.bundles.loadUrl(normalizedUrl, function (err, fileUrlFromBundle) {
						handleLoad(err, {
							load: fileUrlFromBundle,
							original: normalizedUrl
						});
					});
				} else {
					handleLoad(null, {
						load: url,
						original: asset && asset.file.filename || url
					});
				}
			}
		};

		_proto._loadNull = function _loadNull(handler, callback, asset) {
			var onLoad = function onLoad(err, data, extra) {
				if (err) {
					callback(err);
				} else {
					try {
						callback(null, handler.open(null, data, asset), extra);
					} catch (e) {
						callback(e);
					}
				}
			};

			handler.load(null, onLoad, asset);
		};

		_proto._onSuccess = function _onSuccess(key, result, extra) {
			this._cache[key] = result;

			for (var i = 0; i < this._requests[key].length; i++) {
				this._requests[key][i](null, result, extra);
			}

			delete this._requests[key];
		};

		_proto._onFailure = function _onFailure(key, err) {
			console.error(err);

			if (this._requests[key]) {
				for (var i = 0; i < this._requests[key].length; i++) {
					this._requests[key][i](err);
				}

				delete this._requests[key];
			}
		};

		_proto.open = function open(type, data) {
			var handler = this._handlers[type];

			if (!handler) {
				console.warn("No resource handler found for: " + type);
				return data;
			}

			return handler.open(null, data);
		};

		_proto.patch = function patch(asset, assets) {
			var handler = this._handlers[asset.type];

			if (!handler) {
				console.warn("No resource handler found for: " + asset.type);
				return;
			}

			if (handler.patch) {
				handler.patch(asset, assets);
			}
		};

		_proto.clearCache = function clearCache(url, type) {
			delete this._cache[url + type];
		};

		_proto.getFromCache = function getFromCache(url, type) {
			if (this._cache[url + type]) {
				return this._cache[url + type];
			}
		};

		_proto.enableRetry = function enableRetry(maxRetries) {
			if (maxRetries === void 0) {
				maxRetries = 5;
			}

			maxRetries = Math.max(0, maxRetries) || 0;

			for (var key in this._handlers) {
				this._handlers[key].maxRetries = maxRetries;
			}
		};

		_proto.disableRetry = function disableRetry() {
			for (var key in this._handlers) {
				this._handlers[key].maxRetries = 0;
			}
		};

		_proto.destroy = function destroy() {
			this._handlers = {};
			this._requests = {};
			this._cache = {};
		};

		return ResourceLoader;
	}();

	var SceneHandler = function () {
		function SceneHandler(app) {
			this._app = app;
			this.maxRetries = 0;
		}

		var _proto = SceneHandler.prototype;

		_proto.load = function load(url, callback) {
			SceneUtils.load(url, this.maxRetries, callback);
		};

		_proto.open = function open(url, data) {
			this._app.systems.script.preloading = true;
			var parser = new SceneParser(this._app, false);
			var parent = parser.parse(data);
			var scene = this._app.scene;
			scene.root = parent;

			this._app.applySceneSettings(data.settings);

			this._app.systems.script.preloading = false;
			return scene;
		};

		_proto.patch = function patch(asset, assets) {};

		return SceneHandler;
	}();

	var _legacy = false;
	var _createdLoadingScreen = false;
	var script = {
		app: null,
		create: function create(name, callback) {
			if (!_legacy) return;
			var ScriptType = callback(script.app);
			ScriptType._pcScriptName = name;

			ScriptHandler._push(ScriptType);

			this.fire("created", name, callback);
		},
		attribute: function attribute(name, type, defaultValue, options) {},
		createLoadingScreen: function createLoadingScreen(callback) {
			if (_createdLoadingScreen) return;
			_createdLoadingScreen = true;
			var app = getApplication();
			callback(app);
		}
	};
	Object.defineProperty(script, 'legacy', {
		get: function get() {
			return _legacy;
		},
		set: function set(value) {
			_legacy = value;
		}
	});
	events.attach(script);

	var ScriptHandler = function () {
		function ScriptHandler(app) {
			this._app = app;
			this._scripts = {};
			this._cache = {};
		}

		ScriptHandler._push = function _push(Type) {
			if (script.legacy && ScriptHandler._types.length > 0) {
				console.assert("Script Ordering Error. Contact support@playcanvas.com");
			} else {
				ScriptHandler._types.push(Type);
			}
		};

		var _proto = ScriptHandler.prototype;

		_proto.load = function load(url, callback) {
			var _this = this;

			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			var self = this;
			script.app = this._app;

			this._loadScript(url.load, function (err, url, extra) {
				if (!err) {
					if (script.legacy) {
						var Type = null;

						if (ScriptHandler._types.length) {
							Type = ScriptHandler._types.pop();
						}

						if (Type) {
							_this._scripts[url] = Type;
						} else {
							Type = null;
						}

						callback(null, Type, extra);
					} else {
						var obj = {};

						for (var i = 0; i < ScriptHandler._types.length; i++) {
							obj[ScriptHandler._types[i].name] = ScriptHandler._types[i];
						}

						ScriptHandler._types.length = 0;
						callback(null, obj, extra);
						delete self._loader._cache[url + 'script'];
					}
				} else {
					callback(err);
				}
			});
		};

		_proto.open = function open(url, data) {
			return data;
		};

		_proto.patch = function patch(asset, assets) {};

		_proto._loadScript = function _loadScript(url, callback) {
			var head = document.head;
			var element = document.createElement('script');
			this._cache[url] = element;
			element.async = false;
			element.addEventListener('error', function (e) {
				callback("Script: " + e.target.src + " failed to load");
			}, false);
			var done = false;

			element.onload = element.onreadystatechange = function () {
				if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
					done = true;
					callback(null, url, element);
				}
			};

			element.src = url;
			head.appendChild(element);
		};

		return ScriptHandler;
	}();

	ScriptHandler._types = [];

	var ShaderHandler = function () {
		function ShaderHandler() {
			this.maxRetries = 0;
		}

		var _proto = ShaderHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading shader resource: " + url.original + " [" + err + "]");
				}
			});
		};

		_proto.open = function open(url, data) {
			return data;
		};

		_proto.patch = function patch(asset, assets) {};

		return ShaderHandler;
	}();

	var spriteNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
	var spriteIndices = [0, 1, 3, 2, 3, 1];

	var Sprite = function (_EventHandler) {
		_inheritsLoose(Sprite, _EventHandler);

		function Sprite(device, options) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._device = device;
			_this._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;
			_this._renderMode = options && options.renderMode !== undefined ? options.renderMode : SPRITE_RENDERMODE_SIMPLE;
			_this._atlas = options && options.atlas !== undefined ? options.atlas : null;
			_this._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;
			_this._meshes = [];
			_this._updatingProperties = false;
			_this._meshesDirty = false;

			if (_this._atlas && _this._frameKeys) {
				_this._createMeshes();
			}

			return _this;
		}

		var _proto = Sprite.prototype;

		_proto._createMeshes = function _createMeshes() {
			var len = this._meshes.length;

			for (var i = 0; i < len; i++) {
				var mesh = this._meshes[i];

				if (mesh) {
					mesh.destroy();
				}
			}

			var count = this._frameKeys.length;
			this._meshes = new Array(count);
			var createMeshFunc = this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;

			for (var _i = 0; _i < count; _i++) {
				var frame = this._atlas.frames[this._frameKeys[_i]];
				this._meshes[_i] = frame ? createMeshFunc.call(this, frame) : null;
			}

			this.fire('set:meshes');
		};

		_proto._createSimpleMesh = function _createSimpleMesh(frame) {
			var rect = frame.rect;
			var texWidth = this._atlas.texture.width;
			var texHeight = this._atlas.texture.height;
			var w = rect.z / this._pixelsPerUnit;
			var h = rect.w / this._pixelsPerUnit;
			var hp = frame.pivot.x;
			var vp = frame.pivot.y;
			var positions = [-hp * w, -vp * h, 0, (1 - hp) * w, -vp * h, 0, (1 - hp) * w, (1 - vp) * h, 0, -hp * w, (1 - vp) * h, 0];
			var lu = rect.x / texWidth;
			var bv = 1.0 - rect.y / texHeight;
			var ru = (rect.x + rect.z) / texWidth;
			var tv = 1.0 - (rect.y + rect.w) / texHeight;
			var uvs = [lu, bv, ru, bv, ru, tv, lu, tv];
			var mesh = createMesh$1(this._device, positions, {
				uvs: uvs,
				normals: spriteNormals,
				indices: spriteIndices
			});
			return mesh;
		};

		_proto._create9SliceMesh = function _create9SliceMesh() {
			var he = Vec2.ONE;
			var ws = 3;
			var ls = 3;
			var positions = [];
			var normals = [];
			var uvs = [];
			var indices = [];
			var vcounter = 0;

			for (var i = 0; i <= ws; i++) {
				var u = i === 0 || i === ws ? 0 : 1;

				for (var j = 0; j <= ls; j++) {
					var x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;
					var y = 0.0;
					var z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);
					var v = j === 0 || j === ls ? 0 : 1;
					positions.push(-x, y, z);
					normals.push(0.0, 1.0, 0.0);
					uvs.push(u, v);

					if (i < ws && j < ls) {
						indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
						indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
					}

					vcounter++;
				}
			}

			var options = {
				normals: normals,
				uvs: uvs,
				indices: indices
			};
			return createMesh$1(this._device, positions, options);
		};

		_proto._onSetFrames = function _onSetFrames(frames) {
			if (this._updatingProperties) {
				this._meshesDirty = true;
			} else {
				this._createMeshes();
			}
		};

		_proto._onFrameChanged = function _onFrameChanged(frameKey, frame) {
			var idx = this._frameKeys.indexOf(frameKey);

			if (idx < 0) return;

			if (frame) {
				if (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
					this._meshes[idx] = this._createSimpleMesh(frame);
				}
			} else {
				this._meshes[idx] = null;
			}

			this.fire('set:meshes');
		};

		_proto._onFrameRemoved = function _onFrameRemoved(frameKey) {
			var idx = this._frameKeys.indexOf(frameKey);

			if (idx < 0) return;
			this._meshes[idx] = null;
			this.fire('set:meshes');
		};

		_proto.startUpdate = function startUpdate() {
			this._updatingProperties = true;
			this._meshesDirty = false;
		};

		_proto.endUpdate = function endUpdate() {
			this._updatingProperties = false;

			if (this._meshesDirty && this._atlas && this._frameKeys) {
				this._createMeshes();
			}

			this._meshesDirty = false;
		};

		_proto.destroy = function destroy() {
			for (var _iterator = _createForOfIteratorHelperLoose(this._meshes), _step; !(_step = _iterator()).done;) {
				var mesh = _step.value;
				if (mesh) mesh.destroy();
			}

			this._meshes.length = 0;
		};

		_createClass(Sprite, [{
			key: "frameKeys",
			get: function get() {
				return this._frameKeys;
			},
			set: function set(value) {
				this._frameKeys = value;

				if (this._atlas && this._frameKeys) {
					if (this._updatingProperties) {
						this._meshesDirty = true;
					} else {
						this._createMeshes();
					}
				}

				this.fire('set:frameKeys', value);
			}
		}, {
			key: "atlas",
			get: function get() {
				return this._atlas;
			},
			set: function set(value) {
				if (value === this._atlas) return;

				if (this._atlas) {
					this._atlas.off('set:frames', this._onSetFrames, this);

					this._atlas.off('set:frame', this._onFrameChanged, this);

					this._atlas.off('remove:frame', this._onFrameRemoved, this);
				}

				this._atlas = value;

				if (this._atlas && this._frameKeys) {
					this._atlas.on('set:frames', this._onSetFrames, this);

					this._atlas.on('set:frame', this._onFrameChanged, this);

					this._atlas.on('remove:frame', this._onFrameRemoved, this);

					if (this._updatingProperties) {
						this._meshesDirty = true;
					} else {
						this._createMeshes();
					}
				}

				this.fire('set:atlas', value);
			}
		}, {
			key: "pixelsPerUnit",
			get: function get() {
				return this._pixelsPerUnit;
			},
			set: function set(value) {
				if (this._pixelsPerUnit === value) return;
				this._pixelsPerUnit = value;
				this.fire('set:pixelsPerUnit', value);

				if (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
					if (this._updatingProperties) {
						this._meshesDirty = true;
					} else {
						this._createMeshes();
					}
				}
			}
		}, {
			key: "renderMode",
			get: function get() {
				return this._renderMode;
			},
			set: function set(value) {
				if (this._renderMode === value) return;
				var prev = this._renderMode;
				this._renderMode = value;
				this.fire('set:renderMode', value);

				if (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {
					if (this._atlas && this._frameKeys) {
						if (this._updatingProperties) {
							this._meshesDirty = true;
						} else {
							this._createMeshes();
						}
					}
				}
			}
		}, {
			key: "meshes",
			get: function get() {
				return this._meshes;
			}
		}]);

		return Sprite;
	}(EventHandler);

	function onTextureAtlasLoaded(atlasAsset) {
		var spriteAsset = this;

		if (spriteAsset.resource) {
			spriteAsset.resource.atlas = atlasAsset.resource;
		}
	}

	function onTextureAtlasAdded(atlasAsset) {
		var spriteAsset = this;
		spriteAsset.registry.load(atlasAsset);
	}

	var SpriteHandler = function () {
		function SpriteHandler(assets, device) {
			this._assets = assets;
			this._device = device;
			this.maxRetries = 0;
		}

		var _proto = SpriteHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			if (path.getExtension(url.original) === '.json') {
				http.get(url.load, {
					retry: this.maxRetries > 0,
					maxRetries: this.maxRetries
				}, function (err, response) {
					if (!err) {
						callback(null, response);
					} else {
						callback(err);
					}
				});
			}
		};

		_proto.open = function open(url, data) {
			var sprite = new Sprite(this._device);

			if (url) {
				sprite.__data = data;
			}

			return sprite;
		};

		_proto.patch = function patch(asset, assets) {
			var sprite = asset.resource;

			if (sprite.__data) {
				asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;
				asset.data.renderMode = sprite.__data.renderMode;
				asset.data.frameKeys = sprite.__data.frameKeys;

				if (sprite.__data.textureAtlasAsset) {
					var atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);

					if (atlas) {
						asset.data.textureAtlasAsset = atlas.id;
					} else {
						console.warn("Could not find textureatlas with url: " + sprite.__data.textureAtlasAsset);
					}
				}
			}

			sprite.startUpdate();
			sprite.renderMode = asset.data.renderMode;
			sprite.pixelsPerUnit = asset.data.pixelsPerUnit;
			sprite.frameKeys = asset.data.frameKeys;

			this._updateAtlas(asset);

			sprite.endUpdate();
			asset.off('change', this._onAssetChange, this);
			asset.on('change', this._onAssetChange, this);
		};

		_proto._updateAtlas = function _updateAtlas(asset) {
			var sprite = asset.resource;

			if (!asset.data.textureAtlasAsset) {
				sprite.atlas = null;
				return;
			}

			this._assets.off('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);

			this._assets.on('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);

			var atlasAsset = this._assets.get(asset.data.textureAtlasAsset);

			if (atlasAsset && atlasAsset.resource) {
				sprite.atlas = atlasAsset.resource;
			} else {
				if (!atlasAsset) {
					this._assets.off('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);

					this._assets.on('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
				} else {
					this._assets.load(atlasAsset);
				}
			}
		};

		_proto._onAssetChange = function _onAssetChange(asset, attribute, value, oldValue) {
			if (attribute === 'data') {
				if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {
					this._assets.off('load:' + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);

					this._assets.off('add:' + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);
				}
			}
		};

		return SpriteHandler;
	}();

	var Template = function () {
		function Template(app, data) {
			this._app = app;
			this._data = data;
			this._templateRoot = null;
		}

		var _proto = Template.prototype;

		_proto.instantiate = function instantiate() {
			if (!this._templateRoot) {
				this._parseTemplate();
			}

			return this._templateRoot.clone();
		};

		_proto._parseTemplate = function _parseTemplate() {
			var parser = new SceneParser(this._app, true);
			this._templateRoot = parser.parse(this._data);
		};

		return Template;
	}();

	var TemplateHandler = function () {
		function TemplateHandler(app) {
			this._app = app;
			this.maxRetries = 0;
		}

		var _proto = TemplateHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error requesting template: " + url.original);
				} else {
					callback(err, response);
				}
			});
		};

		_proto.open = function open(url, data) {
			return new Template(this._app, data);
		};

		return TemplateHandler;
	}();

	var TextHandler = function () {
		function TextHandler() {
			this.maxRetries = 0;
		}

		var _proto = TextHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading text resource: " + url.original + " [" + err + "]");
				}
			});
		};

		_proto.open = function open(url, data) {
			return data;
		};

		_proto.patch = function patch(asset, assets) {};

		return TextHandler;
	}();

	var TextureAtlas = function (_EventHandler) {
		_inheritsLoose(TextureAtlas, _EventHandler);

		function TextureAtlas() {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._texture = null;
			_this._frames = null;
			return _this;
		}

		var _proto = TextureAtlas.prototype;

		_proto.setFrame = function setFrame(key, data) {
			var frame = this._frames[key];

			if (!frame) {
				frame = {
					rect: data.rect.clone(),
					pivot: data.pivot.clone(),
					border: data.border.clone()
				};
				this._frames[key] = frame;
			} else {
				frame.rect.copy(data.rect);
				frame.pivot.copy(data.pivot);
				frame.border.copy(data.border);
			}

			this.fire('set:frame', key.toString(), frame);
		};

		_proto.removeFrame = function removeFrame(key) {
			var frame = this._frames[key];

			if (frame) {
				delete this._frames[key];
				this.fire('remove:frame', key.toString(), frame);
			}
		};

		_proto.destroy = function destroy() {
			if (this._texture) {
				this._texture.destroy();
			}
		};

		_createClass(TextureAtlas, [{
			key: "texture",
			get: function get() {
				return this._texture;
			},
			set: function set(value) {
				this._texture = value;
				this.fire('set:texture', value);
			}
		}, {
			key: "frames",
			get: function get() {
				return this._frames;
			},
			set: function set(value) {
				this._frames = value;
				this.fire('set:frames', value);
			}
		}]);

		return TextureAtlas;
	}(EventHandler);

	var JSON_ADDRESS_MODE$1 = {
		"repeat": ADDRESS_REPEAT,
		"clamp": ADDRESS_CLAMP_TO_EDGE,
		"mirror": ADDRESS_MIRRORED_REPEAT
	};
	var JSON_FILTER_MODE$1 = {
		"nearest": FILTER_NEAREST,
		"linear": FILTER_LINEAR,
		"nearest_mip_nearest": FILTER_NEAREST_MIPMAP_NEAREST,
		"linear_mip_nearest": FILTER_LINEAR_MIPMAP_NEAREST,
		"nearest_mip_linear": FILTER_NEAREST_MIPMAP_LINEAR,
		"linear_mip_linear": FILTER_LINEAR_MIPMAP_LINEAR
	};
	var regexFrame = /^data\.frames\.(\d+)$/;

	var TextureAtlasHandler = function () {
		function TextureAtlasHandler(loader) {
			this._loader = loader;
			this.maxRetries = 0;
		}

		var _proto = TextureAtlasHandler.prototype;

		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			var self = this;

			var handler = this._loader.getHandler("texture");

			if (path.getExtension(url.original) === '.json') {
				http.get(url.load, {
					retry: this.maxRetries > 0,
					maxRetries: this.maxRetries
				}, function (err, response) {
					if (!err) {
						var textureUrl = url.original.replace('.json', '.png');

						self._loader.load(textureUrl, "texture", function (err, texture) {
							if (err) {
								callback(err);
							} else {
								callback(null, {
									data: response,
									texture: texture
								});
							}
						});
					} else {
						callback(err);
					}
				});
			} else {
				return handler.load(url, callback);
			}
		};

		_proto.open = function open(url, data) {
			var resource = new TextureAtlas();

			if (data.texture && data.data) {
				resource.texture = data.texture;
				resource.__data = data.data;
			} else {
				var handler = this._loader.getHandler("texture");

				var texture = handler.open(url, data);
				if (!texture) return null;
				resource.texture = texture;
			}

			return resource;
		};

		_proto.patch = function patch(asset, assets) {
			if (asset.resource.__data) {
				if (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;
				if (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;
				if (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;
				if (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;
				if (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;
				if (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;
				if (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;
				asset.data.frames = asset.resource.__data.frames;
				delete asset.resource.__data;
			}

			var texture = asset.resource.texture;

			if (texture) {
				texture.name = asset.name;
				if (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE$1[asset.data.minfilter]) texture.minFilter = JSON_FILTER_MODE$1[asset.data.minfilter];
				if (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE$1[asset.data.magfilter]) texture.magFilter = JSON_FILTER_MODE$1[asset.data.magfilter];
				if (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE$1[asset.data.addressu]) texture.addressU = JSON_ADDRESS_MODE$1[asset.data.addressu];
				if (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE$1[asset.data.addressv]) texture.addressV = JSON_ADDRESS_MODE$1[asset.data.addressv];
				if (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps) texture.mipmaps = asset.data.mipmaps;
				if (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy) texture.anisotropy = asset.data.anisotropy;

				if (asset.data.hasOwnProperty('rgbm')) {
					var type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;

					if (texture.type !== type) {
						texture.type = type;
					}
				}
			}

			asset.resource.texture = texture;
			var frames = {};

			for (var key in asset.data.frames) {
				var frame = asset.data.frames[key];
				frames[key] = {
					rect: new Vec4(frame.rect),
					pivot: new Vec2(frame.pivot),
					border: new Vec4(frame.border)
				};
			}

			asset.resource.frames = frames;
			asset.off('change', this._onAssetChange, this);
			asset.on('change', this._onAssetChange, this);
		};

		_proto._onAssetChange = function _onAssetChange(asset, attribute, value) {
			var frame;

			if (attribute === 'data' || attribute === 'data.frames') {
				var frames = {};

				for (var key in value.frames) {
					frame = value.frames[key];
					frames[key] = {
						rect: new Vec4(frame.rect),
						pivot: new Vec2(frame.pivot),
						border: new Vec4(frame.border)
					};
				}

				asset.resource.frames = frames;
			} else {
				var match = attribute.match(regexFrame);

				if (match) {
					var frameKey = match[1];

					if (value) {
						if (!asset.resource.frames[frameKey]) {
							asset.resource.frames[frameKey] = {
								rect: new Vec4(value.rect),
								pivot: new Vec2(value.pivot),
								border: new Vec4(value.border)
							};
						} else {
							frame = asset.resource.frames[frameKey];
							frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);
							frame.pivot.set(value.pivot[0], value.pivot[1]);
							frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);
						}

						asset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);
					} else {
						if (asset.resource.frames[frameKey]) {
							delete asset.resource.frames[frameKey];
							asset.resource.fire('remove:frame', frameKey);
						}
					}
				}
			}
		};

		return TextureAtlasHandler;
	}();

	function BasisWorker() {
		var BASIS_FORMAT = {
			cTFETC1: 0,
			cTFETC2: 1,
			cTFBC1: 2,
			cTFBC3: 3,
			cTFPVRTC1_4_RGB: 8,
			cTFPVRTC1_4_RGBA: 9,
			cTFASTC_4x4: 10,
			cTFATC_RGB: 11,
			cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
			cTFRGBA32: 13,
			cTFRGB565: 14,
			cTFRGBA4444: 16
		};
		var opaqueMapping = {
			astc: BASIS_FORMAT.cTFASTC_4x4,
			dxt: BASIS_FORMAT.cTFBC1,
			etc1: BASIS_FORMAT.cTFETC1,
			etc2: BASIS_FORMAT.cTFETC1,
			pvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,
			atc: BASIS_FORMAT.cTFATC_RGB,
			none: BASIS_FORMAT.cTFRGB565
		};
		var alphaMapping = {
			astc: BASIS_FORMAT.cTFASTC_4x4,
			dxt: BASIS_FORMAT.cTFBC3,
			etc1: BASIS_FORMAT.cTFRGBA4444,
			etc2: BASIS_FORMAT.cTFETC2,
			pvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,
			atc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,
			none: BASIS_FORMAT.cTFRGBA4444
		};
		var PIXEL_FORMAT = {
			ETC1: 21,
			ETC2_RGB: 22,
			ETC2_RGBA: 23,
			DXT1: 8,
			DXT5: 10,
			PVRTC_4BPP_RGB_1: 26,
			PVRTC_4BPP_RGBA_1: 27,
			ASTC_4x4: 28,
			ATC_RGB: 29,
			ATC_RGBA: 30,
			R8_G8_B8_A8: 7,
			R5_G6_B5: 3,
			R4_G4_B4_A4: 5
		};

		var basisToEngineMapping = function basisToEngineMapping(basisFormat, deviceDetails) {
			switch (basisFormat) {
				case BASIS_FORMAT.cTFETC1:
					return deviceDetails.formats.etc1 ? PIXEL_FORMAT.ETC1 : PIXEL_FORMAT.ETC2_RGB;

				case BASIS_FORMAT.cTFETC2:
					return PIXEL_FORMAT.ETC2_RGBA;

				case BASIS_FORMAT.cTFBC1:
					return PIXEL_FORMAT.DXT1;

				case BASIS_FORMAT.cTFBC3:
					return PIXEL_FORMAT.DXT5;

				case BASIS_FORMAT.cTFPVRTC1_4_RGB:
					return PIXEL_FORMAT.PVRTC_4BPP_RGB_1;

				case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
					return PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;

				case BASIS_FORMAT.cTFASTC_4x4:
					return PIXEL_FORMAT.ASTC_4x4;

				case BASIS_FORMAT.cTFATC_RGB:
					return PIXEL_FORMAT.ATC_RGB;

				case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
					return PIXEL_FORMAT.ATC_RGBA;

				case BASIS_FORMAT.cTFRGBA32:
					return PIXEL_FORMAT.R8_G8_B8_A8;

				case BASIS_FORMAT.cTFRGB565:
					return PIXEL_FORMAT.R5_G6_B5;

				case BASIS_FORMAT.cTFRGBA4444:
					return PIXEL_FORMAT.R4_G4_B4_A4;
			}
		};

		var unswizzleGGGR = function unswizzleGGGR(data) {
			var genB = function genB(R, G) {
				var r = R * (2.0 / 255.0) - 1.0;
				var g = G * (2.0 / 255.0) - 1.0;
				var b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));
				return Math.max(0, Math.min(255, Math.floor((b + 1.0) * 0.5 * 255.0)));
			};

			for (var offset = 0; offset < data.length; offset += 4) {
				var R = data[offset + 3];
				var G = data[offset + 1];
				data[offset + 0] = R;
				data[offset + 2] = genB(R, G);
				data[offset + 3] = 255;
			}

			return data;
		};

		var pack565 = function pack565(data) {
			var result = new Uint16Array(data.length / 4);

			for (var offset = 0; offset < data.length; offset += 4) {
				var R = data[offset + 0];
				var G = data[offset + 1];
				var B = data[offset + 2];
				result[offset / 4] = (R & 0xf8) << 8 | (G & 0xfc) << 3 | B >> 3;
			}

			return result;
		};

		var isPOT = function isPOT(width, height) {
			return (width & width - 1) === 0 && (height & height - 1) === 0;
		};

		var performanceNow = function performanceNow() {
			return typeof performance !== 'undefined' ? performance.now() : 0;
		};

		var basis;
		var rgbPriority;
		var rgbaPriority;

		var chooseTargetFormat = function chooseTargetFormat(deviceDetails, hasAlpha, isUASTC) {
			if (isUASTC) {
				if (deviceDetails.formats.astc) {
					return 'astc';
				}
			} else {
				if (hasAlpha) {
					if (deviceDetails.formats.etc2) {
						return 'etc2';
					}
				} else {
					if (deviceDetails.formats.etc1 || deviceDetails.formats.etc2) {
						return 'etc1';
					}
				}
			}

			var testInOrder = function testInOrder(priority) {
				for (var i = 0; i < priority.length; ++i) {
					var format = priority[i];

					if (deviceDetails.formats[format]) {
						return format;
					}
				}

				return 'none';
			};

			return testInOrder(hasAlpha ? rgbaPriority : rgbPriority);
		};

		var dimensionsValid = function dimensionsValid(width, height, format, webgl2) {
			switch (format) {
				case BASIS_FORMAT.cTFETC1:
				case BASIS_FORMAT.cTFETC2:
					return true;

				case BASIS_FORMAT.cTFBC1:
				case BASIS_FORMAT.cTFBC3:
					return (width & 0x3) === 0 && (height & 0x3) === 0;

				case BASIS_FORMAT.cTFPVRTC1_4_RGB:
				case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
					return isPOT(width, height) && (width === height || webgl2);

				case BASIS_FORMAT.cTFASTC_4x4:
					return true;

				case BASIS_FORMAT.cTFATC_RGB:
				case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
					return true;
			}
		};

		var transcodeKTX2 = function transcodeKTX2(url, data, options) {
			if (!basis.KTX2File) {
				throw new Error('Basis transcoder module does not include support for KTX2.');
			}

			var funcStart = performanceNow();
			var basisFile = new basis.KTX2File(new Uint8Array(data));
			var width = basisFile.getWidth();
			var height = basisFile.getHeight();
			var levels = basisFile.getLevels();
			var hasAlpha = !!basisFile.getHasAlpha();
			var isUASTC = basisFile.isUASTC && basisFile.isUASTC();

			if (!width || !height || !levels) {
				basisFile.close();
				basisFile.delete();
				throw new Error("Invalid image dimensions url=" + url + " width=" + width + " height=" + height + " levels=" + levels);
			}

			var format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
			var unswizzle = !!options.isGGGR && format === 'pvr';
			var basisFormat;

			if (unswizzle) {
				basisFormat = BASIS_FORMAT.cTFRGBA32;
			} else {
				basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];

				if (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {
					basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
				}
			}

			if (!basisFile.startTranscoding()) {
				basisFile.close();
				basisFile.delete();
				throw new Error('Failed to start transcoding url=' + url);
			}

			var i;
			var levelData = [];

			for (var mip = 0; mip < levels; ++mip) {
				var dstSize = basisFile.getImageTranscodedSizeInBytes(mip, 0, 0, basisFormat);
				var dst = new Uint8Array(dstSize);

				if (!basisFile.transcodeImage(dst, mip, 0, 0, basisFormat, 0, -1, -1)) {
					basisFile.close();
					basisFile.delete();
					throw new Error('Failed to transcode image url=' + url);
				}

				var is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
				levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
			}

			basisFile.close();
			basisFile.delete();

			if (unswizzle) {
				basisFormat = BASIS_FORMAT.cTFRGB565;

				for (i = 0; i < levelData.length; ++i) {
					levelData[i] = pack565(unswizzleGGGR(levelData[i]));
				}
			}

			return {
				format: basisToEngineMapping(basisFormat, options.deviceDetails),
				width: width,
				height: height,
				levels: levelData,
				cubemap: false,
				transcodeTime: performanceNow() - funcStart,
				url: url,
				unswizzledGGGR: unswizzle
			};
		};

		var transcodeBasis = function transcodeBasis(url, data, options) {
			var funcStart = performanceNow();
			var basisFile = new basis.BasisFile(new Uint8Array(data));
			var width = basisFile.getImageWidth(0, 0);
			var height = basisFile.getImageHeight(0, 0);
			var images = basisFile.getNumImages();
			var levels = basisFile.getNumLevels(0);
			var hasAlpha = !!basisFile.getHasAlpha();
			var isUASTC = basisFile.isUASTC && basisFile.isUASTC();

			if (!width || !height || !images || !levels) {
				basisFile.close();
				basisFile.delete();
				throw new Error("Invalid image dimensions url=" + url + " width=" + width + " height=" + height + " images=" + images + " levels=" + levels);
			}

			var format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
			var unswizzle = !!options.isGGGR && format === 'pvr';
			var basisFormat;

			if (unswizzle) {
				basisFormat = BASIS_FORMAT.cTFRGBA32;
			} else {
				basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];

				if (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {
					basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
				}
			}

			if (!basisFile.startTranscoding()) {
				basisFile.close();
				basisFile.delete();
				throw new Error('Failed to start transcoding url=' + url);
			}

			var i;
			var levelData = [];

			for (var mip = 0; mip < levels; ++mip) {
				var dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);
				var dst = new Uint8Array(dstSize);

				if (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 0, 0)) {
					basisFile.close();
					basisFile.delete();
					throw new Error('Failed to transcode image url=' + url);
				}

				var is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
				levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
			}

			basisFile.close();
			basisFile.delete();

			if (unswizzle) {
				basisFormat = BASIS_FORMAT.cTFRGB565;

				for (i = 0; i < levelData.length; ++i) {
					levelData[i] = pack565(unswizzleGGGR(levelData[i]));
				}
			}

			return {
				format: basisToEngineMapping(basisFormat, options.deviceDetails),
				width: width,
				height: height,
				levels: levelData,
				cubemap: false,
				transcodeTime: performanceNow() - funcStart,
				url: url,
				unswizzledGGGR: unswizzle
			};
		};

		var transcode = function transcode(url, data, options) {
			return options.isKTX2 ? transcodeKTX2(url, data, options) : transcodeBasis(url, data, options);
		};

		var workerTranscode = function workerTranscode(url, data, options) {
			try {
				var result = transcode(url, data, options);
				result.levels = result.levels.map(function (v) {
					return v.buffer;
				});
				self.postMessage({
					url: url,
					data: result
				}, result.levels);
			} catch (err) {
				self.postMessage({
					url: url,
					err: err
				}, null);
			}
		};

		var workerInit = function workerInit(config, callback) {
			self.importScripts(config.basisUrl);

			var instantiateWasmFunc = function instantiateWasmFunc(imports, successCallback) {
				WebAssembly.instantiate(config.module, imports).then(function (result) {
					successCallback(result);
				}).catch(function (reason) {
					console.error('instantiate failed + ' + reason);
				});
				return {};
			};

			self.BASIS(config.module ? {
				instantiateWasm: instantiateWasmFunc
			} : null).then(function (instance) {
				instance.initializeBasis();
				basis = instance;
				rgbPriority = config.rgbPriority;
				rgbaPriority = config.rgbaPriority;
				callback(null);
			});
		};

		var queue = [];

		self.onmessage = function (message) {
			var data = message.data;

			switch (data.type) {
				case 'init':
					workerInit(data.config, function () {
						for (var i = 0; i < queue.length; ++i) {
							workerTranscode(queue[i].url, queue[i].data, queue[i].options);
						}

						queue.length = 0;
					});
					break;

				case 'transcode':
					if (basis) {
						workerTranscode(data.url, data.data, data.options);
					} else {
						queue.push(data);
					}

					break;
			}
		};
	}

	var getCompressionFormats = function getCompressionFormats(device) {
		return {
			astc: !!device.extCompressedTextureASTC,
			atc: !!device.extCompressedTextureATC,
			dxt: !!device.extCompressedTextureS3TC,
			etc1: !!device.extCompressedTextureETC1,
			etc2: !!device.extCompressedTextureETC,
			pvr: !!device.extCompressedTexturePVRTC
		};
	};

	var prepareWorkerModules = function prepareWorkerModules(config, callback) {
		var getWorkerBlob = function getWorkerBlob() {
			var code = '(' + BasisWorker.toString() + ')()\n\n';
			return new Blob([code], {
				type: 'application/javascript'
			});
		};

		var wasmSupported = function wasmSupported() {
			try {
				if (typeof WebAssembly === "object" && typeof WebAssembly.instantiate === "function") {
					var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
					if (module instanceof WebAssembly.Module) return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
				}
			} catch (e) {}

			return false;
		};

		var sendResponse = function sendResponse(basisCode, module) {
			callback(null, {
				workerUrl: URL.createObjectURL(getWorkerBlob()),
				basisUrl: URL.createObjectURL(basisCode),
				module: module,
				rgbPriority: config.rgbPriority,
				rgbaPriority: config.rgbaPriority
			});
		};

		var options = {
			responseType: 'blob',
			retry: config.maxRetries > 0,
			maxRetries: config.maxRetries
		};

		if (config.glueUrl && config.wasmUrl && wasmSupported()) {
			var basisCode = null;
			var module = null;
			http.get(config.glueUrl, options, function (err, response) {
				if (err) {
					callback(err);
				} else {
					if (module) {
						sendResponse(response, module);
					} else {
						basisCode = response;
					}
				}
			});
			var fetchPromise = fetch(config.wasmUrl);

			var compileManual = function compileManual() {
				fetchPromise.then(function (result) {
					return result.arrayBuffer();
				}).then(function (buffer) {
					return WebAssembly.compile(buffer);
				}).then(function (module_) {
					if (basisCode) {
						sendResponse(basisCode, module_);
					} else {
						module = module_;
					}
				}).catch(function (err) {
					callback(err, null);
				});
			};

			if (WebAssembly.compileStreaming) {
				WebAssembly.compileStreaming(fetchPromise).then(function (module_) {
					if (basisCode) {
						sendResponse(basisCode, module_);
					} else {
						module = module_;
					}
				}).catch(function (err) {
					Debug.warn("compileStreaming() failed for " + config.wasmUrl + " (" + err + "), falling back to arraybuffer download.");
					compileManual();
				});
			} else {
				compileManual();
			}
		} else {
			http.get(config.fallbackUrl, options, function (err, response) {
				if (err) {
					callback(err, null);
				} else {
					sendResponse(response, null);
				}
			});
		}
	};

	var BasisQueue = function () {
		function BasisQueue() {
			this.callbacks = {};
			this.queue = [];
			this.clients = [];
		}

		var _proto = BasisQueue.prototype;

		_proto.enqueueJob = function enqueueJob(url, data, callback, options) {
			if (this.callbacks.hasOwnProperty(url)) {
				this.callbacks[url].push(callback);
			} else {
				this.callbacks[url] = [callback];
				var job = {
					url: url,
					data: data,
					options: options
				};

				if (this.clients.length > 0) {
					this.clients.shift().run(job);
				} else {
					this.queue.push(job);
				}
			}
		};

		_proto.enqueueClient = function enqueueClient(client) {
			if (this.queue.length > 0) {
				client.run(this.queue.shift());
			} else {
				this.clients.push(client);
			}
		};

		_proto.handleResponse = function handleResponse(url, err, data) {
			var callback = this.callbacks[url];

			if (err) {
				for (var i = 0; i < callback.length; ++i) {
					callback[i](err);
				}
			} else {
				if (data.format === PIXELFORMAT_R5_G6_B5 || data.format === PIXELFORMAT_R4_G4_B4_A4) {
					data.levels = data.levels.map(function (v) {
						return new Uint16Array(v);
					});
				} else {
					data.levels = data.levels.map(function (v) {
						return new Uint8Array(v);
					});
				}

				for (var _i = 0; _i < callback.length; ++_i) {
					callback[_i](null, data);
				}
			}

			delete this.callbacks[url];
		};

		return BasisQueue;
	}();

	var BasisClient = function () {
		function BasisClient(queue, config, eager) {
			var _this = this;

			this.queue = queue;
			this.worker = new Worker(config.workerUrl);
			this.worker.addEventListener('message', function (message) {
				var data = message.data;

				_this.queue.handleResponse(data.url, data.err, data.data);

				if (!_this.eager) {
					_this.queue.enqueueClient(_this);
				}
			});
			this.worker.postMessage({
				type: 'init',
				config: config
			});
			this.eager = eager;
		}

		var _proto2 = BasisClient.prototype;

		_proto2.run = function run(job) {
			var transfer = [];

			if (job.data instanceof ArrayBuffer) {
				transfer.push(job.data);
			}

			this.worker.postMessage({
				type: 'transcode',
				url: job.url,
				format: job.format,
				data: job.data,
				options: job.options
			}, transfer);

			if (this.eager) {
				this.queue.enqueueClient(this);
			}
		};

		return BasisClient;
	}();

	var defaultNumWorkers = 1;
	var defaultRgbPriority = ['etc1', 'etc2', 'astc', 'dxt', 'pvr', 'atc'];
	var defaultRgbaPriority = ['astc', 'dxt', 'etc2', 'pvr', 'atc'];
	var defaultMaxRetries = 5;
	var queue = new BasisQueue();
	var lazyConfig = null;
	var initializing = false;

	function basisInitialize(config) {
		if (initializing) {
			return;
		}

		if (!config) {
			config = lazyConfig || {};
		} else if (config.lazyInit) {
			lazyConfig = config;
			return;
		}

		if (!config.glueUrl || !config.wasmUrl || !config.fallbackUrl) {
			var modules = (window.config ? window.config.wasmModules : window.PRELOAD_MODULES) || [];
			var wasmModule = modules.find(function (m) {
				return m.moduleName === 'BASIS';
			});

			if (wasmModule) {
				var urlBase = window.ASSET_PREFIX || "";

				if (!config.glueUrl) {
					config.glueUrl = urlBase + wasmModule.glueUrl;
				}

				if (!config.wasmUrl) {
					config.wasmUrl = urlBase + wasmModule.wasmUrl;
				}

				if (!config.fallbackUrl) {
					config.fallbackUrl = urlBase + wasmModule.fallbackUrl;
				}
			}
		}

		if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
			initializing = true;
			var numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));
			var eagerWorkers = config.numWorkers === 1 || (config.hasOwnProperty('eagerWorkers') ? config.eagerWorkers : true);
			config.rgbPriority = config.rgbPriority || defaultRgbPriority;
			config.rgbaPriority = config.rgbaPriority || defaultRgbaPriority;
			config.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : defaultMaxRetries;
			prepareWorkerModules(config, function (err, clientConfig) {
				if (err) {
					console.error("failed to initialize basis worker: " + err);
				} else {
					for (var i = 0; i < numWorkers; ++i) {
						queue.enqueueClient(new BasisClient(queue, clientConfig, eagerWorkers));
					}
				}
			});
		}
	}

	var deviceDetails = null;

	function basisTranscode(device, url, data, callback, options) {
		basisInitialize();

		if (!deviceDetails) {
			deviceDetails = {
				webgl2: device.webgl2,
				formats: getCompressionFormats(device)
			};
		}

		queue.enqueueJob(url, data, callback, {
			deviceDetails: deviceDetails,
			isGGGR: !!(options != null && options.isGGGR),
			isKTX2: !!(options != null && options.isKTX2)
		});
		return initializing;
	}

	var BasisParser = function () {
		function BasisParser(registry, device) {
			this.device = device;
			this.maxRetries = 0;
		}

		var _proto = BasisParser.prototype;

		_proto.load = function load(url, callback, asset) {
			var device = this.device;

			var transcode = function transcode(data) {
				var _asset$file, _asset$file$variants, _asset$file$variants$;

				var basisModuleFound = basisTranscode(device, url.load, data, callback, {
					isGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0
				});

				if (!basisModuleFound) {
					callback("Basis module not found. Asset '" + asset.name + "' basis texture variant will not be loaded.");
				}
			};

			Asset.fetchArrayBuffer(url.load, function (err, result) {
				if (err) {
					callback(err);
				} else {
					transcode(result);
				}
			}, asset, this.maxRetries);
		};

		_proto.open = function open(url, data, device) {
			var texture = new Texture(device, {
				name: url,
				profilerHint: TEXHINT_ASSET,
				addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: data.width,
				height: data.height,
				format: data.format,
				cubemap: data.cubemap,
				levels: data.levels
			});
			texture.upload();
			return texture;
		};

		return BasisParser;
	}();

	var ImgParser = function () {
		function ImgParser(registry) {
			this.crossOrigin = registry.prefix ? 'anonymous' : null;
			this.maxRetries = 0;
			this.useImageBitmap = false  ;
		}

		var _proto = ImgParser.prototype;

		_proto.load = function load(url, callback, asset) {
			var _asset$file;

			var hasContents = !!(asset != null && (_asset$file = asset.file) != null && _asset$file.contents);

			if (hasContents) {
				url = {
					load: URL.createObjectURL(new Blob([asset.file.contents])),
					original: url.original
				};
			}

			var handler = function handler(err, result) {
				if (hasContents) {
					URL.revokeObjectURL(url.load);
				}

				callback(err, result);
			};

			var crossOrigin;

			if (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {
				crossOrigin = asset.options.crossOrigin;
			} else if (ABSOLUTE_URL.test(url.load)) {
				crossOrigin = this.crossOrigin;
			}

			if (this.useImageBitmap) {
				this._loadImageBitmap(url.load, url.original, crossOrigin, handler);
			} else {
				this._loadImage(url.load, url.original, crossOrigin, handler);
			}
		};

		_proto.open = function open(url, data, device) {
			var ext = path.getExtension(url).toLowerCase();
			var format = ext === ".jpg" || ext === ".jpeg" ? PIXELFORMAT_R8_G8_B8 : PIXELFORMAT_R8_G8_B8_A8;
			var texture = new Texture(device, {
				name: url,
				profilerHint: TEXHINT_ASSET,
				width: data.width,
				height: data.height,
				format: format
			});
			texture.setSource(data);
			return texture;
		};

		_proto._loadImage = function _loadImage(url, originalUrl, crossOrigin, callback) {
			var image = new Image();

			if (crossOrigin) {
				image.crossOrigin = crossOrigin;
			}

			var retries = 0;
			var maxRetries = this.maxRetries;
			var retryTimeout;

			image.onload = function () {
				callback(null, image);
			};

			image.onerror = function () {
				if (retryTimeout) return;

				if (maxRetries > 0 && ++retries <= maxRetries) {
					var retryDelay = Math.pow(2, retries) * 100;
					console.log("Error loading Texture from: '" + originalUrl + "' - Retrying in " + retryDelay + "ms...");
					var idx = url.indexOf('?');
					var separator = idx >= 0 ? '&' : '?';
					retryTimeout = setTimeout(function () {
						image.src = url + separator + 'retry=' + Date.now();
						retryTimeout = null;
					}, retryDelay);
				} else {
					callback("Error loading Texture from: '" + originalUrl + "'");
				}
			};

			image.src = url;
		};

		_proto._loadImageBitmap = function _loadImageBitmap(url, originalUrl, crossOrigin, callback) {
			var options = {
				cache: true,
				responseType: "blob",
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			http.get(url, options, function (err, blob) {
				if (err) {
					callback(err);
				} else {
					createImageBitmap(blob, {
						premultiplyAlpha: 'none'
					}).then(function (imageBitmap) {
						callback(null, imageBitmap);
					}).catch(function (e) {
						callback(e);
					});
				}
			});
		};

		return ImgParser;
	}();

	var IDENTIFIER = [0x58544BAB, 0xBB313120, 0x0A1A0A0D];
	var KNOWN_FORMATS = {
		0x83F0: PIXELFORMAT_DXT1,
		0x83F2: PIXELFORMAT_DXT3,
		0x83F3: PIXELFORMAT_DXT5,
		0x8D64: PIXELFORMAT_ETC1,
		0x9274: PIXELFORMAT_ETC2_RGB,
		0x9278: PIXELFORMAT_ETC2_RGBA,
		0x8C00: PIXELFORMAT_PVRTC_4BPP_RGB_1,
		0x8C01: PIXELFORMAT_PVRTC_2BPP_RGB_1,
		0x8C02: PIXELFORMAT_PVRTC_4BPP_RGBA_1,
		0x8C03: PIXELFORMAT_PVRTC_2BPP_RGBA_1,
		0x8051: PIXELFORMAT_R8_G8_B8,
		0x8058: PIXELFORMAT_R8_G8_B8_A8,
		0x8C41: PIXELFORMAT_SRGB,
		0x8C43: PIXELFORMAT_SRGBA,
		0x8C3A: PIXELFORMAT_111110F,
		0x881B: PIXELFORMAT_RGB16F,
		0x881A: PIXELFORMAT_RGBA16F
	};

	function createContainer(pixelFormat, buffer, byteOffset, byteSize) {
		return pixelFormat === PIXELFORMAT_111110F ? new Uint32Array(buffer, byteOffset, byteSize / 4) : new Uint8Array(buffer, byteOffset, byteSize);
	}

	var KtxParser = function () {
		function KtxParser(registry) {
			this.maxRetries = 0;
		}

		var _proto = KtxParser.prototype;

		_proto.load = function load(url, callback, asset) {
			Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
		};

		_proto.open = function open(url, data, device) {
			var textureData = this.parse(data);

			if (!textureData) {
				return null;
			}

			var texture = new Texture(device, {
				name: url,
				profilerHint: TEXHINT_ASSET,
				addressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: textureData.width,
				height: textureData.height,
				format: textureData.format,
				cubemap: textureData.cubemap,
				levels: textureData.levels
			});
			texture.upload();
			return texture;
		};

		_proto.parse = function parse(data) {
			var dataU32 = new Uint32Array(data);

			if (IDENTIFIER[0] !== dataU32[0] || IDENTIFIER[1] !== dataU32[1] || IDENTIFIER[2] !== dataU32[2]) {
				Debug.warn("Invalid definition header found in KTX file. Expected 0xAB4B5458, 0x203131BB, 0x0D0A1A0A");
				return null;
			}

			var header = {
				endianness: dataU32[3],
				glType: dataU32[4],
				glTypeSize: dataU32[5],
				glFormat: dataU32[6],
				glInternalFormat: dataU32[7],
				glBaseInternalFormat: dataU32[8],
				pixelWidth: dataU32[9],
				pixelHeight: dataU32[10],
				pixelDepth: dataU32[11],
				numberOfArrayElements: dataU32[12],
				numberOfFaces: dataU32[13],
				numberOfMipmapLevels: dataU32[14],
				bytesOfKeyValueData: dataU32[15]
			};

			if (header.pixelDepth > 1) {
				Debug.warn("More than 1 pixel depth not supported!");
				return null;
			}

			if (header.numberOfArrayElements !== 0) {
				Debug.warn("Array texture not supported!");
				return null;
			}

			var format = KNOWN_FORMATS[header.glInternalFormat];

			if (format === undefined) {
				Debug.warn("Unknown glInternalFormat: " + header.glInternalFormat);
				return null;
			}

			var offset = 16 + header.bytesOfKeyValueData / 4;
			var isCubemap = header.numberOfFaces > 1;
			var levels = [];

			for (var mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++) {
				var imageSizeInBytes = dataU32[offset++];

				if (isCubemap) {
					levels.push([]);
				}

				var target = isCubemap ? levels[mipmapLevel] : levels;

				for (var face = 0; face < (isCubemap ? 6 : 1); ++face) {
					target.push(createContainer(format, data, offset * 4, imageSizeInBytes));
					offset += imageSizeInBytes + 3 >> 2;
				}
			}

			return {
				format: format,
				width: header.pixelWidth,
				height: header.pixelHeight,
				levels: levels,
				cubemap: isCubemap
			};
		};

		return KtxParser;
	}();

	var KHRConstants = {
		KHR_DF_MODEL_ETC1S: 163,
		KHR_DF_MODEL_UASTC: 166
	};

	var Ktx2Parser = function () {
		function Ktx2Parser(registry, device) {
			this.maxRetries = 0;
			this.device = device;
		}

		var _proto = Ktx2Parser.prototype;

		_proto.load = function load(url, callback, asset) {
			var _this = this;

			Asset.fetchArrayBuffer(url.load, function (err, result) {
				if (err) {
					callback(err, result);
				} else {
					_this.parse(result, url, callback, asset);
				}
			}, asset, this.maxRetries);
		};

		_proto.open = function open(url, data, device) {
			var texture = new Texture(device, {
				name: url,
				profilerHint: TEXHINT_ASSET,
				addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: data.width,
				height: data.height,
				format: data.format,
				cubemap: data.cubemap,
				levels: data.levels
			});
			texture.upload();
			return texture;
		};

		_proto.parse = function parse(arraybuffer, url, callback, asset) {
			var rs = new ReadStream(arraybuffer);
			var magic = [rs.readU32be(), rs.readU32be(), rs.readU32be()];

			if (magic[0] !== 0xAB4B5458 || magic[1] !== 0x203230BB || magic[2] !== 0x0D0A1A0A) {
				Debug.warn("Invalid definition header found in KTX2 file. Expected 0xAB4B5458, 0x203131BB, 0x0D0A1A0A");
				return null;
			}

			var header = {
				vkFormat: rs.readU32(),
				typeSize: rs.readU32(),
				pixelWidth: rs.readU32(),
				pixelHeight: rs.readU32(),
				pixelDepth: rs.readU32(),
				layerCount: rs.readU32(),
				faceCount: rs.readU32(),
				levelCount: rs.readU32(),
				supercompressionScheme: rs.readU32()
			};
			var index = {
				dfdByteOffset: rs.readU32(),
				dfdByteLength: rs.readU32(),
				kvdByteOffset: rs.readU32(),
				kvdByteLength: rs.readU32(),
				sgdByteOffset: rs.readU64(),
				sgdByteLength: rs.readU64()
			};
			var levels = [];

			for (var i = 0; i < Math.max(1, header.levelCount); ++i) {
				levels.push({
					byteOffset: rs.readU64(),
					byteLength: rs.readU64(),
					uncompressedByteLength: rs.readU64()
				});
			}

			var dfdTotalSize = rs.readU32();

			if (dfdTotalSize !== index.kvdByteOffset - index.dfdByteOffset) {
				Debug.warn("Invalid file data encountered.");
				return null;
			}

			rs.skip(8);
			var colorModel = rs.readU8();
			rs.skip(index.dfdByteLength - 9);
			rs.skip(index.kvdByteLength);

			if (header.supercompressionScheme === 1 || colorModel === KHRConstants.KHR_DF_MODEL_UASTC) {
				var _asset$file, _asset$file$variants, _asset$file$variants$;

				var basisModuleFound = basisTranscode(this.device, url.load, arraybuffer, callback, {
					isGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0,
					isKTX2: true
				});

				if (!basisModuleFound) {
					callback('Basis module not found. Asset "' + asset.name + '" basis texture variant will not be loaded.');
				}
			} else {
				callback('unsupported KTX2 pixel format');
			}
		};

		return Ktx2Parser;
	}();

	var DdsParser = function () {
		function DdsParser(registry) {
			this.maxRetries = 0;
		}

		var _proto = DdsParser.prototype;

		_proto.load = function load(url, callback, asset) {
			Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
		};

		_proto.open = function open(url, data, device) {
			var header = new Uint32Array(data, 0, 128 / 4);
			var width = header[4];
			var height = header[3];
			var mips = Math.max(header[7], 1);
			var isFourCc = header[20] === 4;
			var fcc = header[21];
			var bpp = header[22];
			var isCubemap = header[28] === 65024;
			var FCC_DXT1 = 827611204;
			var FCC_DXT5 = 894720068;
			var FCC_FP16 = 113;
			var FCC_FP32 = 116;
			var FCC_ETC1 = 826496069;
			var FCC_PVRTC_2BPP_RGB_1 = 825438800;
			var FCC_PVRTC_2BPP_RGBA_1 = 825504336;
			var FCC_PVRTC_4BPP_RGB_1 = 825439312;
			var FCC_PVRTC_4BPP_RGBA_1 = 825504848;
			var compressed = false;
			var etc1 = false;
			var pvrtc2 = false;
			var pvrtc4 = false;
			var format = null;
			var componentSize = 1;
			var texture;

			if (isFourCc) {
				if (fcc === FCC_DXT1) {
					format = PIXELFORMAT_DXT1;
					compressed = true;
				} else if (fcc === FCC_DXT5) {
					format = PIXELFORMAT_DXT5;
					compressed = true;
				} else if (fcc === FCC_FP16) {
					format = PIXELFORMAT_RGBA16F;
					componentSize = 2;
				} else if (fcc === FCC_FP32) {
					format = PIXELFORMAT_RGBA32F;
					componentSize = 4;
				} else if (fcc === FCC_ETC1) {
					format = PIXELFORMAT_ETC1;
					compressed = true;
					etc1 = true;
				} else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
					format = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;
					compressed = true;
					pvrtc2 = true;
				} else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
					format = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;
					compressed = true;
					pvrtc4 = true;
				}
			} else {
				if (bpp === 32) {
					format = PIXELFORMAT_R8_G8_B8_A8;
				}
			}

			if (!format) {
				Debug.error("This DDS pixel format is currently unsupported. Empty texture will be created instead.");
				texture = new Texture(device, {
					width: 4,
					height: 4,
					format: PIXELFORMAT_R8_G8_B8
				});
				texture.name = 'dds-legacy-empty';
				return texture;
			}

			texture = new Texture(device, {
				name: url,
				profilerHint: TEXHINT_ASSET,
				addressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: width,
				height: height,
				format: format,
				cubemap: isCubemap,
				mipmaps: mips > 1
			});
			var offset = 128;
			var faces = isCubemap ? 6 : 1;
			var mipSize;
			var DXT_BLOCK_WIDTH = 4;
			var DXT_BLOCK_HEIGHT = 4;
			var blockSize = fcc === FCC_DXT1 ? 8 : 16;
			var numBlocksAcross, numBlocksDown, numBlocks;

			for (var face = 0; face < faces; face++) {
				var mipWidth = width;
				var mipHeight = height;

				for (var i = 0; i < mips; i++) {
					if (compressed) {
						if (etc1) {
							mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;
						} else if (pvrtc2) {
							mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
						} else if (pvrtc4) {
							mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
						} else {
							numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
							numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
							numBlocks = numBlocksAcross * numBlocksDown;
							mipSize = numBlocks * blockSize;
						}
					} else {
						mipSize = mipWidth * mipHeight * 4;
					}

					var mipBuff = format === PIXELFORMAT_RGBA32F ? new Float32Array(data, offset, mipSize) : format === PIXELFORMAT_RGBA16F ? new Uint16Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);

					if (!isCubemap) {
						texture._levels[i] = mipBuff;
					} else {
						if (!texture._levels[i]) texture._levels[i] = [];
						texture._levels[i][face] = mipBuff;
					}

					offset += mipSize * componentSize;
					mipWidth = Math.max(mipWidth * 0.5, 1);
					mipHeight = Math.max(mipHeight * 0.5, 1);
				}
			}

			texture.upload();
			return texture;
		};

		return DdsParser;
	}();

	var HdrParser = function () {
		function HdrParser(registry) {
			this.maxRetries = 0;
		}

		var _proto = HdrParser.prototype;

		_proto.load = function load(url, callback, asset) {
			Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
		};

		_proto.open = function open(url, data, device) {
			var textureData = this.parse(data);

			if (!textureData) {
				return null;
			}

			var texture = new Texture(device, {
				name: url,
				profilerHint: TEXHINT_ASSET,
				addressU: ADDRESS_REPEAT,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				minFilter: FILTER_NEAREST_MIPMAP_NEAREST,
				magFilter: FILTER_NEAREST,
				width: textureData.width,
				height: textureData.height,
				levels: textureData.levels,
				format: PIXELFORMAT_R8_G8_B8_A8,
				type: TEXTURETYPE_RGBE,
				mipmaps: false
			});
			texture.upload();
			return texture;
		};

		_proto.parse = function parse(data) {
			var readStream = new ReadStream(data);
			var magic = readStream.readLine();

			if (!magic.startsWith('#?RADIANCE')) {
				Debug.error("radiance header has invalid magic");
				return null;
			}

			var variables = {};

			while (true) {
				var line = readStream.readLine();

				if (line.length === 0) {
					break;
				} else {
					var parts = line.split('=');

					if (parts.length === 2) {
						variables[parts[0]] = parts[1];
					}
				}
			}

			if (!variables.hasOwnProperty('FORMAT')) {
				Debug.error("radiance header missing FORMAT variable");
				return null;
			}

			var resolution = readStream.readLine().split(' ');

			if (resolution.length !== 4) {
				Debug.error("radiance header has invalid resolution");
				return null;
			}

			var height = parseInt(resolution[1], 10);
			var width = parseInt(resolution[3], 10);

			var pixels = this._readPixels(readStream, width, height, resolution[0] === '-Y');

			if (!pixels) {
				return null;
			}

			return {
				width: width,
				height: height,
				levels: [pixels]
			};
		};

		_proto._readPixels = function _readPixels(readStream, width, height, flipY) {
			if (width < 8 || width > 0x7fff) {
				return this._readPixelsFlat(readStream, width, height);
			}

			var rgbe = [0, 0, 0, 0];
			readStream.readArray(rgbe);

			if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
				readStream.skip(-4);
				return this._readPixelsFlat(readStream, width, height);
			}

			var buffer = new ArrayBuffer(width * height * 4);
			var view = new Uint8Array(buffer);
			var scanstart = flipY ? 0 : width * 4 * (height - 1);
			var x, y, i, channel, count, value;

			for (y = 0; y < height; ++y) {
				if (y) {
					readStream.readArray(rgbe);
				}

				if ((rgbe[2] << 8) + rgbe[3] !== width) {
					Debug.error("radiance has invalid scanline width");
					return null;
				}

				for (channel = 0; channel < 4; ++channel) {
					x = 0;

					while (x < width) {
						count = readStream.readU8();

						if (count > 128) {
							count -= 128;

							if (x + count > width) {
								Debug.error("radiance has invalid scanline data");
								return null;
							}

							value = readStream.readU8();

							for (i = 0; i < count; ++i) {
								view[scanstart + channel + 4 * x++] = value;
							}
						} else {
							if (count === 0 || x + count > width) {
								Debug.error("radiance has invalid scanline data");
								return null;
							}

							for (i = 0; i < count; ++i) {
								view[scanstart + channel + 4 * x++] = readStream.readU8();
							}
						}
					}
				}

				scanstart += width * 4 * (flipY ? 1 : -1);
			}

			return view;
		};

		_proto._readPixelsFlat = function _readPixelsFlat(readStream, width, height) {
			return readStream.remainingBytes === width * height * 4 ? new Uint8Array(readStream.arraybuffer, readStream.offset) : null;
		};

		return HdrParser;
	}();

	var JSON_ADDRESS_MODE = {
		"repeat": ADDRESS_REPEAT,
		"clamp": ADDRESS_CLAMP_TO_EDGE,
		"mirror": ADDRESS_MIRRORED_REPEAT
	};
	var JSON_FILTER_MODE = {
		"nearest": FILTER_NEAREST,
		"linear": FILTER_LINEAR,
		"nearest_mip_nearest": FILTER_NEAREST_MIPMAP_NEAREST,
		"linear_mip_nearest": FILTER_LINEAR_MIPMAP_NEAREST,
		"nearest_mip_linear": FILTER_NEAREST_MIPMAP_LINEAR,
		"linear_mip_linear": FILTER_LINEAR_MIPMAP_LINEAR
	};
	var JSON_TEXTURE_TYPE = {
		"default": TEXTURETYPE_DEFAULT,
		"rgbm": TEXTURETYPE_RGBM,
		"rgbe": TEXTURETYPE_RGBE,
		"swizzleGGGR": TEXTURETYPE_SWIZZLEGGGR
	};

	var TextureParser = function () {
		function TextureParser() {}

		var _proto = TextureParser.prototype;

		_proto.load = function load(url, callback, asset) {
			throw new Error('not implemented');
		};

		_proto.open = function open(url, data, device) {
			throw new Error('not implemented');
		};

		return TextureParser;
	}();

	var _completePartialMipmapChain = function _completePartialMipmapChain(texture) {
		var requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;

		var isHtmlElement = function isHtmlElement(object) {
			return object instanceof HTMLCanvasElement || object instanceof HTMLImageElement || object instanceof HTMLVideoElement;
		};

		if (!(texture._format === PIXELFORMAT_R8_G8_B8_A8 || texture._format === PIXELFORMAT_RGBA32F) || texture._volume || texture._compressed || texture._levels.length === 1 || texture._levels.length === requiredMipLevels || isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {
			return;
		}

		var downsample = function downsample(width, height, data) {
			var sampledWidth = Math.max(1, width >> 1);
			var sampledHeight = Math.max(1, height >> 1);
			var sampledData = new data.constructor(sampledWidth * sampledHeight * 4);
			var xs = Math.floor(width / sampledWidth);
			var ys = Math.floor(height / sampledHeight);
			var xsys = xs * ys;

			for (var y = 0; y < sampledHeight; ++y) {
				for (var x = 0; x < sampledWidth; ++x) {
					for (var e = 0; e < 4; ++e) {
						var sum = 0;

						for (var sy = 0; sy < ys; ++sy) {
							for (var sx = 0; sx < xs; ++sx) {
								sum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];
							}
						}

						sampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;
					}
				}
			}

			return sampledData;
		};

		for (var level = texture._levels.length; level < requiredMipLevels; ++level) {
			var width = Math.max(1, texture._width >> level - 1);
			var height = Math.max(1, texture._height >> level - 1);

			if (texture._cubemap) {
				var mips = [];

				for (var face = 0; face < 6; ++face) {
					mips.push(downsample(width, height, texture._levels[level - 1][face]));
				}

				texture._levels.push(mips);
			} else {
				texture._levels.push(downsample(width, height, texture._levels[level - 1]));
			}
		}

		texture._levelsUpdated = texture._cubemap ? [[true, true, true, true, true, true]] : [true];
	};

	var TextureHandler = function () {
		function TextureHandler(device, assets, loader) {
			this._device = device;
			this._assets = assets;
			this._loader = loader;
			this.imgParser = new ImgParser(assets);
			this.parsers = {
				dds: new DdsParser(assets),
				ktx: new KtxParser(assets),
				ktx2: new Ktx2Parser(assets, device),
				basis: new BasisParser(assets, device),
				hdr: new HdrParser(assets)
			};
		}

		var _proto2 = TextureHandler.prototype;

		_proto2._getUrlWithoutParams = function _getUrlWithoutParams(url) {
			return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		};

		_proto2._getParser = function _getParser(url) {
			var ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');
			return this.parsers[ext] || this.imgParser;
		};

		_proto2.load = function load(url, callback, asset) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}

			this._getParser(url.original).load(url, callback, asset);
		};

		_proto2.open = function open(url, data, asset) {
			if (!url) return;

			var texture = this._getParser(url).open(url, data, this._device);

			if (texture === null) {
				texture = new Texture(this._device, {
					width: 4,
					height: 4,
					format: PIXELFORMAT_R8_G8_B8
				});
			} else {
				_completePartialMipmapChain(texture);

				if (data.unswizzledGGGR) {
					asset.file.variants.basis.opt &= ~8;
				}
			}

			return texture;
		};

		_proto2.patch = function patch(asset, assets) {
			var texture = asset.resource;

			if (!texture) {
				return;
			}

			if (asset.name && asset.name.length > 0) {
				texture.name = asset.name;
			}

			var assetData = asset.data;

			if (assetData.hasOwnProperty('minfilter')) {
				texture.minFilter = JSON_FILTER_MODE[assetData.minfilter];
			}

			if (assetData.hasOwnProperty('magfilter')) {
				texture.magFilter = JSON_FILTER_MODE[assetData.magfilter];
			}

			if (!texture.cubemap) {
				if (assetData.hasOwnProperty('addressu')) {
					texture.addressU = JSON_ADDRESS_MODE[assetData.addressu];
				}

				if (assetData.hasOwnProperty('addressv')) {
					texture.addressV = JSON_ADDRESS_MODE[assetData.addressv];
				}
			}

			if (assetData.hasOwnProperty('mipmaps')) {
				texture.mipmaps = assetData.mipmaps;
			}

			if (assetData.hasOwnProperty('anisotropy')) {
				texture.anisotropy = assetData.anisotropy;
			}

			if (assetData.hasOwnProperty('flipY')) {
				texture.flipY = !!assetData.flipY;
			}

			if (assetData.hasOwnProperty('type')) {
				texture.type = JSON_TEXTURE_TYPE[assetData.type];
			} else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {
				texture.type = TEXTURETYPE_RGBM;
			} else if (asset.file && (asset.file.opt & 8) !== 0) {
				texture.type = TEXTURETYPE_SWIZZLEGGGR;
			}
		};

		_createClass(TextureHandler, [{
			key: "crossOrigin",
			get: function get() {
				return this.imgParser.crossOrigin;
			},
			set: function set(value) {
				this.imgParser.crossOrigin = value;
			}
		}, {
			key: "maxRetries",
			get: function get() {
				return this.imgParser.maxRetries;
			},
			set: function set(value) {
				this.imgParser.maxRetries = value;

				for (var parser in this.parsers) {
					if (this.parsers.hasOwnProperty(parser)) {
						this.parsers[parser].maxRetries = value;
					}
				}
			}
		}]);

		return TextureHandler;
	}();

	var TagsCache = function () {
		function TagsCache(key) {
			if (key === void 0) {
				key = null;
			}

			this._index = {};
			this._key = key;
		}

		var _proto = TagsCache.prototype;

		_proto.addItem = function addItem(item) {
			var tags = item.tags._list;

			for (var _iterator = _createForOfIteratorHelperLoose(tags), _step; !(_step = _iterator()).done;) {
				var tag = _step.value;
				this.add(tag, item);
			}
		};

		_proto.removeItem = function removeItem(item) {
			var tags = item.tags._list;

			for (var _iterator2 = _createForOfIteratorHelperLoose(tags), _step2; !(_step2 = _iterator2()).done;) {
				var tag = _step2.value;
				this.remove(tag, item);
			}
		};

		_proto.add = function add(tag, item) {
			if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) return;

			if (!this._index[tag]) {
				this._index[tag] = {
					list: []
				};
				if (this._key) this._index[tag].keys = {};
			}

			this._index[tag].list.push(item);

			if (this._key) this._index[tag].keys[item[this._key]] = item;
		};

		_proto.remove = function remove(tag, item) {
			if (!this._index[tag]) return;

			if (this._key) {
				if (!this._index[tag].keys[item[this._key]]) return;
			}

			var ind = this._index[tag].list.indexOf(item);

			if (ind === -1) return;

			this._index[tag].list.splice(ind, 1);

			if (this._key) delete this._index[tag].keys[item[this._key]];
			if (this._index[tag].list.length === 0) delete this._index[tag];
		};

		_proto.find = function find(args) {
			var _this = this;

			var index = {};
			var items = [];
			var item, tag, tags, tagsRest, missingIndex;

			var sort = function sort(a, b) {
				return _this._index[a].list.length - _this._index[b].list.length;
			};

			for (var i = 0; i < args.length; i++) {
				tag = args[i];

				if (tag instanceof Array) {
					if (tag.length === 0) continue;

					if (tag.length === 1) {
						tag = tag[0];
					} else {
						missingIndex = false;

						for (var t = 0; t < tag.length; t++) {
							if (!this._index[tag[t]]) {
								missingIndex = true;
								break;
							}
						}

						if (missingIndex) continue;
						tags = tag.slice(0).sort(sort);
						tagsRest = tags.slice(1);
						if (tagsRest.length === 1) tagsRest = tagsRest[0];

						for (var n = 0; n < this._index[tags[0]].list.length; n++) {
							item = this._index[tags[0]].list[n];

							if ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {
								if (this._key) index[item[this._key]] = true;
								items.push(item);
							}
						}

						continue;
					}
				}

				if (tag && typeof tag === 'string' && this._index[tag]) {
					for (var _n = 0; _n < this._index[tag].list.length; _n++) {
						item = this._index[tag].list[_n];

						if (this._key) {
							if (!index[item[this._key]]) {
								index[item[this._key]] = true;
								items.push(item);
							}
						} else if (items.indexOf(item) === -1) {
							items.push(item);
						}
					}
				}
			}

			return items;
		};

		return TagsCache;
	}();

	var AssetRegistry = function (_EventHandler) {
		_inheritsLoose(AssetRegistry, _EventHandler);

		function AssetRegistry(loader) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._loader = loader;
			_this._assets = [];
			_this._cache = {};
			_this._names = {};
			_this._tags = new TagsCache('_id');
			_this._urls = {};
			_this.prefix = null;
			return _this;
		}

		var _proto = AssetRegistry.prototype;

		_proto.list = function list(filters) {
			filters = filters || {};
			return this._assets.filter(function (asset) {
				var include = true;

				if (filters.preload !== undefined) {
					include = asset.preload === filters.preload;
				}

				return include;
			});
		};

		_proto.add = function add(asset) {
			var index = this._assets.push(asset) - 1;
			var url;
			this._cache[asset.id] = index;
			if (!this._names[asset.name]) this._names[asset.name] = [];

			this._names[asset.name].push(index);

			if (asset.file) {
				url = asset.file.url;
				this._urls[url] = index;
			}

			asset.registry = this;

			this._tags.addItem(asset);

			asset.tags.on('add', this._onTagAdd, this);
			asset.tags.on('remove', this._onTagRemove, this);
			this.fire("add", asset);
			this.fire("add:" + asset.id, asset);
			if (url) this.fire("add:url:" + url, asset);
			if (asset.preload) this.load(asset);
		};

		_proto.remove = function remove(asset) {
			var idx = this._cache[asset.id];
			var url = asset.file ? asset.file.url : null;

			if (idx !== undefined) {
				this._assets.splice(idx, 1);

				delete this._cache[asset.id];
				this._names = {};
				this._urls = [];

				for (var i = 0, l = this._assets.length; i < l; i++) {
					var a = this._assets[i];
					this._cache[a.id] = i;

					if (!this._names[a.name]) {
						this._names[a.name] = [];
					}

					this._names[a.name].push(i);

					if (a.file) {
						this._urls[a.file.url] = i;
					}
				}

				this._tags.removeItem(asset);

				asset.tags.off('add', this._onTagAdd, this);
				asset.tags.off('remove', this._onTagRemove, this);
				asset.fire("remove", asset);
				this.fire("remove", asset);
				this.fire("remove:" + asset.id, asset);
				if (url) this.fire("remove:url:" + url, asset);
				return true;
			}

			return false;
		};

		_proto.get = function get(id) {
			var idx = this._cache[id];
			return this._assets[idx];
		};

		_proto.getByUrl = function getByUrl(url) {
			var idx = this._urls[url];
			return this._assets[idx];
		};

		_proto.load = function load(asset) {
			var _this2 = this;

			if (asset.loading || asset.loaded) {
				return;
			}

			var file = asset.file;

			var _opened = function _opened(resource) {
				if (resource instanceof Array) {
					asset.resources = resource;
				} else {
					asset.resource = resource;
				}

				_this2._loader.patch(asset, _this2);

				_this2.fire("load", asset);

				_this2.fire("load:" + asset.id, asset);

				if (file && file.url) _this2.fire("load:url:" + file.url, asset);
				asset.fire("load", asset);
			};

			var _loaded = function _loaded(err, resource, extra) {
				asset.loaded = true;
				asset.loading = false;

				if (err) {
					_this2.fire("error", err, asset);

					_this2.fire("error:" + asset.id, err, asset);

					asset.fire("error", err, asset);
				} else {
					if (!script.legacy && asset.type === 'script') {
						var handler = _this2._loader.getHandler('script');

						if (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {
							document.head.removeChild(handler._cache[asset.id]);
						}

						handler._cache[asset.id] = extra;
					}

					_opened(resource);
				}
			};

			if (file || asset.type === 'cubemap') {
				this.fire("load:start", asset);
				this.fire("load:" + asset.id + ":start", asset);
				asset.loading = true;

				this._loader.load(asset.getFileUrl(), asset.type, _loaded, asset);
			} else {
				var resource = this._loader.open(asset.type, asset.data);

				asset.loaded = true;

				_opened(resource);
			}
		};

		_proto.loadFromUrl = function loadFromUrl(url, type, callback) {
			this.loadFromUrlAndFilename(url, null, type, callback);
		};

		_proto.loadFromUrlAndFilename = function loadFromUrlAndFilename(url, filename, type, callback) {
			var _this3 = this;

			var name = path.getBasename(filename || url);
			var file = {
				filename: filename || name,
				url: url
			};
			var asset = this.getByUrl(url);

			if (!asset) {
				asset = new Asset(name, type, file);
				this.add(asset);
			} else if (asset.loaded) {
				callback(asset.loadFromUrlError || null, asset);
				return;
			}

			var startLoad = function startLoad(asset) {
				asset.once("load", function (loadedAsset) {
					if (type === 'material') {
						_this3._loadTextures(loadedAsset, function (err, textures) {
							callback(err, loadedAsset);
						});
					} else {
						callback(null, loadedAsset);
					}
				});
				asset.once("error", function (err) {
					if (err) {
						_this3.loadFromUrlError = err;
					}

					callback(err, asset);
				});

				_this3.load(asset);
			};

			if (asset.resource) {
				callback(null, asset);
			} else if (type === 'model') {
				this._loadModel(asset, startLoad);
			} else {
				startLoad(asset);
			}
		};

		_proto._loadModel = function _loadModel(modelAsset, continuation) {
			var _this4 = this;

			var url = modelAsset.getFileUrl();
			var ext = path.getExtension(url);

			if (ext === '.json' || ext === '.glb') {
				var dir = path.getDirectory(url);
				var basename = path.getBasename(url);
				var mappingUrl = path.join(dir, basename.replace(ext, ".mapping.json"));

				this._loader.load(mappingUrl, 'json', function (err, data) {
					if (err) {
						modelAsset.data = {
							mapping: []
						};
						continuation(modelAsset);
					} else {
						_this4._loadMaterials(modelAsset, data, function (e, materials) {
							modelAsset.data = data;
							continuation(modelAsset);
						});
					}
				});
			} else {
				continuation(modelAsset);
			}
		};

		_proto._loadMaterials = function _loadMaterials(modelAsset, mapping, callback) {
			var _this5 = this;

			var materials = [];
			var count = 0;

			var onMaterialLoaded = function onMaterialLoaded(err, materialAsset) {
				_this5._loadTextures(materialAsset, function (err, textures) {
					materials.push(materialAsset);

					if (materials.length === count) {
						callback(null, materials);
					}
				});
			};

			for (var i = 0; i < mapping.mapping.length; i++) {
				var _path = mapping.mapping[i].path;

				if (_path) {
					count++;
					var url = modelAsset.getAbsoluteUrl(_path);
					this.loadFromUrl(url, "material", onMaterialLoaded);
				}
			}

			if (count === 0) {
				callback(null, materials);
			}
		};

		_proto._loadTextures = function _loadTextures(materialAsset, callback) {
			var textures = [];
			var count = 0;
			var data = materialAsset.data;

			if (data.mappingFormat !== 'path') {
				Debug.warn("Skipping: " + materialAsset.name + ", material files must be mappingFormat: \"path\" to be loaded from URL");
				callback(null, textures);
				return;
			}

			var onTextureLoaded = function onTextureLoaded(err, texture) {
				if (err) console.error(err);
				textures.push(texture);

				if (textures.length === count) {
					callback(null, textures);
				}
			};

			var texParams = standardMaterialTextureParameters;

			for (var i = 0; i < texParams.length; i++) {
				var _path2 = data[texParams[i]];

				if (_path2 && typeof _path2 === 'string') {
					count++;
					var url = materialAsset.getAbsoluteUrl(_path2);
					this.loadFromUrl(url, "texture", onTextureLoaded);
				}
			}

			if (count === 0) {
				callback(null, textures);
			}
		};

		_proto.findAll = function findAll(name, type) {
			var _this6 = this;

			var idxs = this._names[name];

			if (idxs) {
				var assets = idxs.map(function (idx) {
					return _this6._assets[idx];
				});

				if (type) {
					return assets.filter(function (asset) {
						return asset.type === type;
					});
				}

				return assets;
			}

			return [];
		};

		_proto._onTagAdd = function _onTagAdd(tag, asset) {
			this._tags.add(tag, asset);
		};

		_proto._onTagRemove = function _onTagRemove(tag, asset) {
			this._tags.remove(tag, asset);
		};

		_proto.findByTag = function findByTag() {
			return this._tags.find(arguments);
		};

		_proto.filter = function filter(callback) {
			return this._assets.filter(function (asset) {
				return callback(asset);
			});
		};

		_proto.find = function find(name, type) {
			var asset = this.findAll(name, type);
			return asset.length > 0 ? asset[0] : null;
		};

		return AssetRegistry;
	}(EventHandler);

	var BundleRegistry = function () {
		function BundleRegistry(assets) {
			this._assets = assets;
			this._bundleAssets = {};
			this._assetsInBundles = {};
			this._urlsInBundles = {};
			this._fileRequests = {};

			this._assets.on('add', this._onAssetAdded, this);

			this._assets.on('remove', this._onAssetRemoved, this);
		}

		var _proto = BundleRegistry.prototype;

		_proto._onAssetAdded = function _onAssetAdded(asset) {
			if (asset.type === 'bundle') {
				this._bundleAssets[asset.id] = asset;

				this._registerBundleEventListeners(asset.id);

				for (var i = 0, len = asset.data.assets.length; i < len; i++) {
					this._indexAssetInBundle(asset.data.assets[i], asset);
				}
			} else {
				if (this._assetsInBundles[asset.id]) {
					this._indexAssetFileUrls(asset);
				}
			}
		};

		_proto._registerBundleEventListeners = function _registerBundleEventListeners(bundleAssetId) {
			this._assets.on('load:' + bundleAssetId, this._onBundleLoaded, this);

			this._assets.on('error:' + bundleAssetId, this._onBundleError, this);
		};

		_proto._unregisterBundleEventListeners = function _unregisterBundleEventListeners(bundleAssetId) {
			this._assets.off('load:' + bundleAssetId, this._onBundleLoaded, this);

			this._assets.off('error:' + bundleAssetId, this._onBundleError, this);
		};

		_proto._indexAssetInBundle = function _indexAssetInBundle(assetId, bundleAsset) {
			if (!this._assetsInBundles[assetId]) {
				this._assetsInBundles[assetId] = [bundleAsset];
			} else {
				var bundles = this._assetsInBundles[assetId];
				var idx = bundles.indexOf(bundleAsset);

				if (idx === -1) {
					bundles.push(bundleAsset);
				}
			}

			var asset = this._assets.get(assetId);

			if (asset) {
				this._indexAssetFileUrls(asset);
			}
		};

		_proto._indexAssetFileUrls = function _indexAssetFileUrls(asset) {
			var urls = this._getAssetFileUrls(asset);

			if (!urls) return;

			for (var i = 0, len = urls.length; i < len; i++) {
				var url = urls[i];
				this._urlsInBundles[url] = this._assetsInBundles[asset.id];
			}
		};

		_proto._getAssetFileUrls = function _getAssetFileUrls(asset) {
			var url = asset.getFileUrl();
			if (!url) return null;
			url = this._normalizeUrl(url);
			var urls = [url];

			if (asset.type === 'font') {
				var numFiles = asset.data.info.maps.length;

				for (var i = 1; i < numFiles; i++) {
					urls.push(url.replace('.png', i + '.png'));
				}
			}

			return urls;
		};

		_proto._normalizeUrl = function _normalizeUrl(url) {
			return url && url.split('?')[0];
		};

		_proto._onAssetRemoved = function _onAssetRemoved(asset) {
			if (asset.type === 'bundle') {
				delete this._bundleAssets[asset.id];

				this._unregisterBundleEventListeners(asset.id);

				for (var id in this._assetsInBundles) {
					var array = this._assetsInBundles[id];
					var idx = array.indexOf(asset);

					if (idx !== -1) {
						array.splice(idx, 1);

						if (!array.length) {
							delete this._assetsInBundles[id];

							for (var url in this._urlsInBundles) {
								if (this._urlsInBundles[url] === array) {
									delete this._urlsInBundles[url];
								}
							}
						}
					}
				}

				this._onBundleError("Bundle " + asset.id + " was removed", asset);
			} else if (this._assetsInBundles[asset.id]) {
				delete this._assetsInBundles[asset.id];

				var urls = this._getAssetFileUrls(asset);

				for (var i = 0, len = urls.length; i < len; i++) {
					delete this._urlsInBundles[urls[i]];
				}
			}
		};

		_proto._onBundleLoaded = function _onBundleLoaded(bundleAsset) {
			var _this = this;

			if (!bundleAsset.resource) {
				this._onBundleError("Bundle " + bundleAsset.id + " failed to load", bundleAsset);

				return;
			}

			requestAnimationFrame(function () {
				if (!_this._fileRequests) {
					return;
				}

				for (var url in _this._fileRequests) {
					var bundles = _this._urlsInBundles[url];
					if (!bundles || bundles.indexOf(bundleAsset) === -1) continue;
					var decodedUrl = decodeURIComponent(url);
					var err = null;

					if (!bundleAsset.resource.hasBlobUrl(decodedUrl)) {
						err = "Bundle " + bundleAsset.id + " does not contain URL " + url;
					}

					var requests = _this._fileRequests[url];

					for (var i = 0, len = requests.length; i < len; i++) {
						if (err) {
							requests[i](err);
						} else {
							requests[i](null, bundleAsset.resource.getBlobUrl(decodedUrl));
						}
					}

					delete _this._fileRequests[url];
				}
			});
		};

		_proto._onBundleError = function _onBundleError(err, bundleAsset) {
			for (var url in this._fileRequests) {
				var bundle = this._findLoadedOrLoadingBundleForUrl(url);

				if (!bundle) {
					var requests = this._fileRequests[url];

					for (var i = 0, len = requests.length; i < len; i++) {
						requests[i](err);
					}

					delete this._fileRequests[url];
				}
			}
		};

		_proto._findLoadedOrLoadingBundleForUrl = function _findLoadedOrLoadingBundleForUrl(url) {
			var bundles = this._urlsInBundles[url];
			if (!bundles) return null;
			var len = bundles.length;

			for (var i = 0; i < len; i++) {
				if (bundles[i].loaded && bundles[i].resource) {
					return bundles[i];
				}
			}

			for (var _i = 0; _i < len; _i++) {
				if (bundles[_i].loading) {
					return bundles[_i];
				}
			}

			return null;
		};

		_proto.listBundlesForAsset = function listBundlesForAsset(asset) {
			return this._assetsInBundles[asset.id] || null;
		};

		_proto.list = function list() {
			var result = [];

			for (var id in this._bundleAssets) {
				result.push(this._bundleAssets[id]);
			}

			return result;
		};

		_proto.hasUrl = function hasUrl(url) {
			return !!this._urlsInBundles[url];
		};

		_proto.canLoadUrl = function canLoadUrl(url) {
			return !!this._findLoadedOrLoadingBundleForUrl(url);
		};

		_proto.loadUrl = function loadUrl(url, callback) {
			var bundle = this._findLoadedOrLoadingBundleForUrl(url);

			if (!bundle) {
				callback("URL " + url + " not found in any bundles");
				return;
			}

			if (bundle.loaded) {
				var decodedUrl = decodeURIComponent(url);

				if (!bundle.resource.hasBlobUrl(decodedUrl)) {
					callback("Bundle " + bundle.id + " does not contain URL " + url);
					return;
				}

				callback(null, bundle.resource.getBlobUrl(decodedUrl));
			} else if (this._fileRequests.hasOwnProperty(url)) {
				this._fileRequests[url].push(callback);
			} else {
				this._fileRequests[url] = [callback];
			}
		};

		_proto.destroy = function destroy() {
			this._assets.off('add', this._onAssetAdded, this);

			this._assets.off('remove', this._onAssetRemoved, this);

			for (var id in this._bundleAssets) {
				this._unregisterBundleEventListeners(id);
			}

			this._assets = null;
			this._bundleAssets = null;
			this._assetsInBundles = null;
			this._urlsInBundles = null;
			this._fileRequests = null;
		};

		return BundleRegistry;
	}();

	var components = ['x', 'y', 'z', 'w'];
	var vecLookup = [undefined, undefined, Vec2, Vec3, Vec4];

	function rawToValue(app, args, value, old) {
		switch (args.type) {
			case 'boolean':
				return !!value;

			case 'number':
				if (typeof value === 'number') {
					return value;
				} else if (typeof value === 'string') {
					var v = parseInt(value, 10);
					if (isNaN(v)) return null;
					return v;
				} else if (typeof value === 'boolean') {
					return 0 + value;
				}

				return null;

			case 'json':
				{
					var result = {};

					if (Array.isArray(args.schema)) {
						if (!value || typeof value !== 'object') {
							value = {};
						}

						for (var i = 0; i < args.schema.length; i++) {
							var field = args.schema[i];
							if (!field.name) continue;

							if (field.array) {
								result[field.name] = [];
								var arr = Array.isArray(value[field.name]) ? value[field.name] : [];

								for (var j = 0; j < arr.length; j++) {
									result[field.name].push(rawToValue(app, field, arr[j]));
								}
							} else {
								var val = value.hasOwnProperty(field.name) ? value[field.name] : field.default;
								result[field.name] = rawToValue(app, field, val);
							}
						}
					}

					return result;
				}

			case 'asset':
				if (value instanceof Asset) {
					return value;
				} else if (typeof value === 'number') {
					return app.assets.get(value) || null;
				} else if (typeof value === 'string') {
					return app.assets.get(parseInt(value, 10)) || null;
				}

				return null;

			case 'entity':
				if (value instanceof GraphNode) {
					return value;
				} else if (typeof value === 'string') {
					return app.getEntityFromIndex(value);
				}

				return null;

			case 'rgb':
			case 'rgba':
				if (value instanceof Color) {
					if (old instanceof Color) {
						old.copy(value);
						return old;
					}

					return value.clone();
				} else if (value instanceof Array && value.length >= 3 && value.length <= 4) {
					for (var _i = 0; _i < value.length; _i++) {
						if (typeof value[_i] !== 'number') return null;
					}

					if (!old) old = new Color();
					old.r = value[0];
					old.g = value[1];
					old.b = value[2];
					old.a = value.length === 3 ? 1 : value[3];
					return old;
				} else if (typeof value === 'string' && /#([0-9abcdef]{2}){3,4}/i.test(value)) {
					if (!old) old = new Color();
					old.fromString(value);
					return old;
				}

				return null;

			case 'vec2':
			case 'vec3':
			case 'vec4':
				{
					var len = parseInt(args.type.slice(3), 10);
					var vecType = vecLookup[len];

					if (value instanceof vecType) {
						if (old instanceof vecType) {
							old.copy(value);
							return old;
						}

						return value.clone();
					} else if (value instanceof Array && value.length === len) {
						for (var _i2 = 0; _i2 < value.length; _i2++) {
							if (typeof value[_i2] !== 'number') return null;
						}

						if (!old) old = new vecType();

						for (var _i3 = 0; _i3 < len; _i3++) {
							old[components[_i3]] = value[_i3];
						}

						return old;
					}

					return null;
				}

			case 'curve':
				if (value) {
					var curve;

					if (value instanceof Curve || value instanceof CurveSet) {
						curve = value.clone();
					} else {
						var CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;
						curve = new CurveType(value.keys);
						curve.type = value.type;
					}

					return curve;
				}

				break;
		}

		return value;
	}

	var ScriptAttributes = function () {
		function ScriptAttributes(scriptType) {
			this.scriptType = scriptType;
			this.index = {};
		}

		var _proto = ScriptAttributes.prototype;

		_proto.add = function add(name, args) {
			if (this.index[name]) {
				Debug.warn("attribute '" + name + "' is already defined for script type '" + this.scriptType.name + "'");
				return;
			} else if (ScriptAttributes.reservedNames.has(name)) {
				Debug.warn("attribute '" + name + "' is a reserved attribute name");
				return;
			}

			this.index[name] = args;
			Object.defineProperty(this.scriptType.prototype, name, {
				get: function get() {
					return this.__attributes[name];
				},
				set: function set(raw) {
					var evt = 'attr';
					var evtName = 'attr:' + name;
					var old = this.__attributes[name];
					var oldCopy = old;

					if (old && args.type !== 'json' && old.clone) {
						if (this._callbacks[evt] || this._callbacks[evtName]) {
							oldCopy = old.clone();
						}
					}

					if (args.array) {
						this.__attributes[name] = [];

						if (raw) {
							for (var i = 0, len = raw.length; i < len; i++) {
								this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));
							}
						}
					} else {
						this.__attributes[name] = rawToValue(this.app, args, raw, old);
					}

					this.fire(evt, name, this.__attributes[name], oldCopy);
					this.fire(evtName, this.__attributes[name], oldCopy);
				}
			});
		};

		_proto.remove = function remove(name) {
			if (!this.index[name]) return false;
			delete this.index[name];
			delete this.scriptType.prototype[name];
			return true;
		};

		_proto.has = function has(name) {
			return !!this.index[name];
		};

		_proto.get = function get(name) {
			return this.index[name] || null;
		};

		return ScriptAttributes;
	}();

	ScriptAttributes.reservedNames = new Set(['app', 'entity', 'enabled', '_enabled', '_enabledOld', '_destroyed', '__attributes', '__attributesRaw', '__scriptType', '__executionOrder', '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);

	var Component = function (_EventHandler) {
		_inheritsLoose(Component, _EventHandler);

		function Component(system, entity) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.system = void 0;
			_this.entity = void 0;
			_this.system = system;
			_this.entity = entity;

			if (_this.system.schema && !_this._accessorsBuilt) {
				_this.buildAccessors(_this.system.schema);
			}

			_this.on("set", function (name, oldValue, newValue) {
				this.fire("set_" + name, name, oldValue, newValue);
			});

			_this.on('set_enabled', _this.onSetEnabled, _assertThisInitialized(_this));

			return _this;
		}

		Component._buildAccessors = function _buildAccessors(obj, schema) {
			schema.forEach(function (descriptor) {
				var name = typeof descriptor === 'object' ? descriptor.name : descriptor;
				Object.defineProperty(obj, name, {
					get: function get() {
						return this.data[name];
					},
					set: function set(value) {
						var data = this.data;
						var oldValue = data[name];
						data[name] = value;
						this.fire('set', name, oldValue, value);
					},
					configurable: true
				});
			});
			obj._accessorsBuilt = true;
		};

		var _proto = Component.prototype;

		_proto.buildAccessors = function buildAccessors(schema) {
			Component._buildAccessors(this, schema);
		};

		_proto.onSetEnabled = function onSetEnabled(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.entity.enabled) {
					if (newValue) {
						this.onEnable();
					} else {
						this.onDisable();
					}
				}
			}
		};

		_proto.onEnable = function onEnable() {};

		_proto.onDisable = function onDisable() {};

		_proto.onPostStateChange = function onPostStateChange() {};

		_createClass(Component, [{
			key: "data",
			get: function get() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
			}
		}]);

		return Component;
	}(EventHandler);

	var ScriptComponent = function (_Component) {
		_inheritsLoose(ScriptComponent, _Component);

		function ScriptComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._scripts = [];
			_this._updateList = new SortedLoopArray({
				sortBy: '__executionOrder'
			});
			_this._postUpdateList = new SortedLoopArray({
				sortBy: '__executionOrder'
			});
			_this._scriptsIndex = {};
			_this._destroyedScripts = [];
			_this._destroyed = false;
			_this._scriptsData = null;
			_this._oldState = true;
			_this._enabled = true;
			_this._beingEnabled = false;
			_this._isLoopingThroughScripts = false;
			_this._executionOrder = -1;

			_this.on('set_enabled', _this._onSetEnabled, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = ScriptComponent.prototype;

		_proto.onEnable = function onEnable() {
			this._beingEnabled = true;

			this._checkState();

			if (!this.entity._beingEnabled) {
				this.onPostStateChange();
			}

			this._beingEnabled = false;
		};

		_proto.onDisable = function onDisable() {
			this._checkState();
		};

		_proto.onPostStateChange = function onPostStateChange() {
			var wasLooping = this._beginLooping();

			for (var i = 0, len = this.scripts.length; i < len; i++) {
				var script = this.scripts[i];

				if (script._initialized && !script._postInitialized && script.enabled) {
					script._postInitialized = true;
					if (script.postInitialize) this._scriptMethod(script, ScriptComponent.scriptMethods.postInitialize);
				}
			}

			this._endLooping(wasLooping);
		};

		_proto._beginLooping = function _beginLooping() {
			var looping = this._isLoopingThroughScripts;
			this._isLoopingThroughScripts = true;
			return looping;
		};

		_proto._endLooping = function _endLooping(wasLoopingBefore) {
			this._isLoopingThroughScripts = wasLoopingBefore;

			if (!this._isLoopingThroughScripts) {
				this._removeDestroyedScripts();
			}
		};

		_proto._onSetEnabled = function _onSetEnabled(prop, old, value) {
			this._beingEnabled = true;

			this._checkState();

			this._beingEnabled = false;
		};

		_proto._checkState = function _checkState() {
			var state = this.enabled && this.entity.enabled;
			if (state === this._oldState) return;
			this._oldState = state;
			this.fire(state ? 'enable' : 'disable');
			this.fire('state', state);

			if (state) {
				this.system._addComponentToEnabled(this);
			} else {
				this.system._removeComponentFromEnabled(this);
			}

			var wasLooping = this._beginLooping();

			for (var i = 0, len = this.scripts.length; i < len; i++) {
				var script = this.scripts[i];
				script.enabled = script._enabled;
			}

			this._endLooping(wasLooping);
		};

		_proto._onBeforeRemove = function _onBeforeRemove() {
			this.fire('remove');

			var wasLooping = this._beginLooping();

			for (var i = 0; i < this.scripts.length; i++) {
				var script = this.scripts[i];
				if (!script) continue;
				this.destroy(script.__scriptType.__name);
			}

			this._endLooping(wasLooping);
		};

		_proto._removeDestroyedScripts = function _removeDestroyedScripts() {
			var len = this._destroyedScripts.length;
			if (!len) return;

			for (var i = 0; i < len; i++) {
				var script = this._destroyedScripts[i];

				this._removeScriptInstance(script);
			}

			this._destroyedScripts.length = 0;

			this._resetExecutionOrder(0, this._scripts.length);
		};

		_proto._onInitializeAttributes = function _onInitializeAttributes() {
			for (var i = 0, len = this.scripts.length; i < len; i++) {
				this.scripts[i].__initializeAttributes();
			}
		};

		_proto._scriptMethod = function _scriptMethod(script, method, arg) {
			try {
				script[method](arg);
			} catch (ex) {
				script.enabled = false;

				if (!script._callbacks || !script._callbacks.error) {
					console.warn("unhandled exception while calling \"" + method + "\" for \"" + script.__scriptType.__name + "\" script: ", ex);
					console.error(ex);
				}

				script.fire('error', ex, method);
				this.fire('error', script, ex, method);
			}
		};

		_proto._onInitialize = function _onInitialize() {
			var scripts = this._scripts;

			var wasLooping = this._beginLooping();

			for (var i = 0, len = scripts.length; i < len; i++) {
				var script = scripts[i];

				if (!script._initialized && script.enabled) {
					script._initialized = true;
					if (script.initialize) this._scriptMethod(script, ScriptComponent.scriptMethods.initialize);
				}
			}

			this._endLooping(wasLooping);
		};

		_proto._onPostInitialize = function _onPostInitialize() {
			this.onPostStateChange();
		};

		_proto._onUpdate = function _onUpdate(dt) {
			var list = this._updateList;
			if (!list.length) return;

			var wasLooping = this._beginLooping();

			for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
				var script = list.items[list.loopIndex];

				if (script.enabled) {
					this._scriptMethod(script, ScriptComponent.scriptMethods.update, dt);
				}
			}

			this._endLooping(wasLooping);
		};

		_proto._onPostUpdate = function _onPostUpdate(dt) {
			var list = this._postUpdateList;
			if (!list.length) return;

			var wasLooping = this._beginLooping();

			for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
				var script = list.items[list.loopIndex];

				if (script.enabled) {
					this._scriptMethod(script, ScriptComponent.scriptMethods.postUpdate, dt);
				}
			}

			this._endLooping(wasLooping);
		};

		_proto._insertScriptInstance = function _insertScriptInstance(scriptInstance, index, scriptsLength) {
			if (index === -1) {
				this._scripts.push(scriptInstance);

				scriptInstance.__executionOrder = scriptsLength;

				if (scriptInstance.update) {
					this._updateList.append(scriptInstance);
				}

				if (scriptInstance.postUpdate) {
					this._postUpdateList.append(scriptInstance);
				}
			} else {
				this._scripts.splice(index, 0, scriptInstance);

				scriptInstance.__executionOrder = index;

				this._resetExecutionOrder(index + 1, scriptsLength + 1);

				if (scriptInstance.update) {
					this._updateList.insert(scriptInstance);
				}

				if (scriptInstance.postUpdate) {
					this._postUpdateList.insert(scriptInstance);
				}
			}
		};

		_proto._removeScriptInstance = function _removeScriptInstance(scriptInstance) {
			var idx = this._scripts.indexOf(scriptInstance);

			if (idx === -1) return idx;

			this._scripts.splice(idx, 1);

			if (scriptInstance.update) {
				this._updateList.remove(scriptInstance);
			}

			if (scriptInstance.postUpdate) {
				this._postUpdateList.remove(scriptInstance);
			}

			return idx;
		};

		_proto._resetExecutionOrder = function _resetExecutionOrder(startIndex, scriptsLength) {
			for (var i = startIndex; i < scriptsLength; i++) {
				this._scripts[i].__executionOrder = i;
			}
		};

		_proto._resolveEntityScriptAttribute = function _resolveEntityScriptAttribute(attribute, attributeName, oldValue, useGuid, newAttributes, duplicatedIdsMap) {
			if (attribute.array) {
				var len = oldValue.length;

				if (!len) {
					return;
				}

				var newGuidArray = oldValue.slice();

				for (var i = 0; i < len; i++) {
					var guid = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];

					if (duplicatedIdsMap[guid]) {
						newGuidArray[i] = useGuid ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];
					}
				}

				newAttributes[attributeName] = newGuidArray;
			} else {
				if (oldValue instanceof Entity) {
					oldValue = oldValue.getGuid();
				} else if (typeof oldValue !== 'string') {
					return;
				}

				if (duplicatedIdsMap[oldValue]) {
					newAttributes[attributeName] = duplicatedIdsMap[oldValue];
				}
			}
		};

		_proto.has = function has(nameOrType) {
			if (typeof nameOrType === 'string') {
				return !!this._scriptsIndex[nameOrType];
			}

			if (!nameOrType) return false;
			var scriptType = nameOrType;
			var scriptName = scriptType.__name;
			var scriptData = this._scriptsIndex[scriptName];
			var scriptInstance = scriptData && scriptData.instance;
			return scriptInstance instanceof scriptType;
		};

		_proto.get = function get(nameOrType) {
			if (typeof nameOrType === 'string') {
				var data = this._scriptsIndex[nameOrType];
				return data ? data.instance : null;
			}

			if (!nameOrType) return null;
			var scriptType = nameOrType;
			var scriptName = scriptType.__name;
			var scriptData = this._scriptsIndex[scriptName];
			var scriptInstance = scriptData && scriptData.instance;
			return scriptInstance instanceof scriptType ? scriptInstance : null;
		};

		_proto.create = function create(nameOrType, args) {
			if (args === void 0) {
				args = {};
			}

			var self = this;
			var scriptType = nameOrType;
			var scriptName = nameOrType;

			if (typeof scriptType === 'string') {
				scriptType = this.system.app.scripts.get(scriptType);
			} else if (scriptType) {
				scriptName = scriptType.__name;
			}

			if (scriptType) {
				if (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {
					var scriptInstance = new scriptType({
						app: this.system.app,
						entity: this.entity,
						enabled: args.hasOwnProperty('enabled') ? args.enabled : true,
						attributes: args.attributes
					});
					var len = this._scripts.length;
					var ind = -1;
					if (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind) ind = args.ind;

					this._insertScriptInstance(scriptInstance, ind, len);

					this._scriptsIndex[scriptName] = {
						instance: scriptInstance,
						onSwap: function onSwap() {
							self.swap(scriptName);
						}
					};
					this[scriptName] = scriptInstance;
					if (!args.preloading) scriptInstance.__initializeAttributes();
					this.fire('create', scriptName, scriptInstance);
					this.fire('create:' + scriptName, scriptInstance);
					this.system.app.scripts.on('swap:' + scriptName, this._scriptsIndex[scriptName].onSwap);

					if (!args.preloading) {
						if (scriptInstance.enabled && !scriptInstance._initialized) {
							scriptInstance._initialized = true;
							if (scriptInstance.initialize) this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.initialize);
						}

						if (scriptInstance.enabled && !scriptInstance._postInitialized) {
							scriptInstance._postInitialized = true;
							if (scriptInstance.postInitialize) this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.postInitialize);
						}
					}

					return scriptInstance;
				}

				Debug.warn("script '" + scriptName + "' is already added to entity '" + this.entity.name + "'");
			} else {
				this._scriptsIndex[scriptName] = {
					awaiting: true,
					ind: this._scripts.length
				};
				Debug.warn("script '" + scriptName + "' is not found, awaiting it to be added to registry");
			}

			return null;
		};

		_proto.destroy = function destroy(nameOrType) {
			var scriptName = nameOrType;
			var scriptType = nameOrType;

			if (typeof scriptType === 'string') {
				scriptType = this.system.app.scripts.get(scriptType);
			} else if (scriptType) {
				scriptName = scriptType.__name;
			}

			var scriptData = this._scriptsIndex[scriptName];
			delete this._scriptsIndex[scriptName];
			if (!scriptData) return false;
			var scriptInstance = scriptData.instance;

			if (scriptInstance && !scriptInstance._destroyed) {
				scriptInstance.enabled = false;
				scriptInstance._destroyed = true;

				if (!this._isLoopingThroughScripts) {
					var ind = this._removeScriptInstance(scriptInstance);

					if (ind >= 0) {
						this._resetExecutionOrder(ind, this._scripts.length);
					}
				} else {
					this._destroyedScripts.push(scriptInstance);
				}
			}

			this.system.app.scripts.off('swap:' + scriptName, scriptData.onSwap);
			delete this[scriptName];
			this.fire('destroy', scriptName, scriptInstance || null);
			this.fire('destroy:' + scriptName, scriptInstance || null);
			if (scriptInstance) scriptInstance.fire('destroy');
			return true;
		};

		_proto.swap = function swap(nameOrType) {
			var scriptName = nameOrType;
			var scriptType = nameOrType;

			if (typeof scriptType === 'string') {
				scriptType = this.system.app.scripts.get(scriptType);
			} else if (scriptType) {
				scriptName = scriptType.__name;
			}

			var old = this._scriptsIndex[scriptName];
			if (!old || !old.instance) return false;
			var scriptInstanceOld = old.instance;

			var ind = this._scripts.indexOf(scriptInstanceOld);

			var scriptInstance = new scriptType({
				app: this.system.app,
				entity: this.entity,
				enabled: scriptInstanceOld.enabled,
				attributes: scriptInstanceOld.__attributes
			});
			if (!scriptInstance.swap) return false;

			scriptInstance.__initializeAttributes();

			this._scripts[ind] = scriptInstance;
			this._scriptsIndex[scriptName].instance = scriptInstance;
			this[scriptName] = scriptInstance;
			scriptInstance.__executionOrder = ind;

			if (scriptInstanceOld.update) {
				this._updateList.remove(scriptInstanceOld);
			}

			if (scriptInstanceOld.postUpdate) {
				this._postUpdateList.remove(scriptInstanceOld);
			}

			if (scriptInstance.update) {
				this._updateList.insert(scriptInstance);
			}

			if (scriptInstance.postUpdate) {
				this._postUpdateList.insert(scriptInstance);
			}

			this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.swap, scriptInstanceOld);

			this.fire('swap', scriptName, scriptInstance);
			this.fire('swap:' + scriptName, scriptInstance);
			return true;
		};

		_proto.resolveDuplicatedEntityReferenceProperties = function resolveDuplicatedEntityReferenceProperties(oldScriptComponent, duplicatedIdsMap) {
			var newScriptComponent = this.entity.script;

			for (var scriptName in oldScriptComponent._scriptsIndex) {
				var scriptType = this.system.app.scripts.get(scriptName);

				if (!scriptType) {
					continue;
				}

				var script = oldScriptComponent._scriptsIndex[scriptName];

				if (!script || !script.instance) {
					continue;
				}

				var newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;
				var newAttributes = newScriptComponent[scriptName].__attributes;

				if (!newAttributesRaw && !newAttributes) {
					continue;
				}

				var useGuid = !!newAttributesRaw;
				var oldAttributes = script.instance.__attributes;

				for (var attributeName in oldAttributes) {
					if (!oldAttributes[attributeName]) {
						continue;
					}

					var attribute = scriptType.attributes.get(attributeName);

					if (!attribute) {
						continue;
					}

					if (attribute.type === 'entity') {
						this._resolveEntityScriptAttribute(attribute, attributeName, oldAttributes[attributeName], useGuid, newAttributesRaw || newAttributes, duplicatedIdsMap);
					} else if (attribute.type === 'json' && Array.isArray(attribute.schema)) {
						var oldValue = oldAttributes[attributeName];
						var newJsonValue = newAttributesRaw ? newAttributesRaw[attributeName] : newAttributes[attributeName];

						for (var i = 0; i < attribute.schema.length; i++) {
							var field = attribute.schema[i];

							if (field.type !== 'entity') {
								continue;
							}

							if (attribute.array) {
								for (var j = 0; j < oldValue.length; j++) {
									this._resolveEntityScriptAttribute(field, field.name, oldValue[j][field.name], useGuid, newJsonValue[j], duplicatedIdsMap);
								}
							} else {
								this._resolveEntityScriptAttribute(field, field.name, oldValue[field.name], useGuid, newJsonValue, duplicatedIdsMap);
							}
						}
					}
				}
			}
		};

		_proto.move = function move(nameOrType, ind) {
			var len = this._scripts.length;
			if (ind >= len || ind < 0) return false;
			var scriptType = nameOrType;
			var scriptName = nameOrType;

			if (typeof scriptName !== 'string') {
				scriptName = nameOrType.__name;
			} else {
				scriptType = null;
			}

			var scriptData = this._scriptsIndex[scriptName];
			if (!scriptData || !scriptData.instance) return false;
			var scriptInstance = scriptData.instance;
			if (scriptType && !(scriptInstance instanceof scriptType)) return false;

			var indOld = this._scripts.indexOf(scriptInstance);

			if (indOld === -1 || indOld === ind) return false;

			this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);

			this._resetExecutionOrder(0, len);

			this._updateList.sort();

			this._postUpdateList.sort();

			this.fire('move', scriptName, scriptInstance, ind, indOld);
			this.fire('move:' + scriptName, scriptInstance, ind, indOld);
			return true;
		};

		_createClass(ScriptComponent, [{
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				var oldValue = this._enabled;
				this._enabled = value;
				this.fire('set', 'enabled', oldValue, value);
			}
		}, {
			key: "scripts",
			get: function get() {
				return this._scripts;
			},
			set: function set(value) {
				this._scriptsData = value;

				for (var key in value) {
					if (!value.hasOwnProperty(key)) continue;
					var script = this._scriptsIndex[key];

					if (script) {
						if (typeof value[key].enabled === 'boolean') script.enabled = !!value[key].enabled;

						if (typeof value[key].attributes === 'object') {
							for (var attr in value[key].attributes) {
								if (ScriptAttributes.reservedNames.has(attr)) continue;

								if (!script.__attributes.hasOwnProperty(attr)) {
									var scriptType = this.system.app.scripts.get(key);
									if (scriptType) scriptType.attributes.add(attr, {});
								}

								script[attr] = value[key].attributes[attr];
							}
						}
					} else {
						console.log(this.order);
					}
				}
			}
		}]);

		return ScriptComponent;
	}(Component);

	ScriptComponent.scriptMethods = {
		initialize: 'initialize',
		postInitialize: 'postInitialize',
		update: 'update',
		postUpdate: 'postUpdate',
		swap: 'swap'
	};

	var funcNameRegex = new RegExp('^\\s*function(?:\\s|\\s*\\/\\*.*\\*\\/\\s*)+([^\\(\\s\\/]*)\\s*');

	var ScriptType = function (_EventHandler) {
		_inheritsLoose(ScriptType, _EventHandler);

		function ScriptType(args) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.app = void 0;
			_this.entity = void 0;
			_this._enabled = void 0;
			_this._enabledOld = void 0;
			_this._initialized = void 0;
			_this._postInitialized = void 0;
			_this.__destroyed = void 0;
			_this.__attributes = void 0;
			_this.__attributesRaw = void 0;
			_this.__scriptType = void 0;
			_this.__executionOrder = void 0;

			_this.initScriptType(args);

			return _this;
		}

		var _proto = ScriptType.prototype;

		_proto.initScriptType = function initScriptType(args) {
			var script = this.constructor;
			Debug.assert(args && args.app && args.entity, "script [" + script.__name + "] has missing arguments in constructor");
			this.app = args.app;
			this.entity = args.entity;
			this._enabled = typeof args.enabled === 'boolean' ? args.enabled : true;
			this._enabledOld = this.enabled;
			this.__destroyed = false;
			this.__attributes = {};
			this.__attributesRaw = args.attributes || {};
			this.__scriptType = script;
			this.__executionOrder = -1;
		};

		ScriptType.__getScriptName = function __getScriptName(constructorFn) {
			if (typeof constructorFn !== 'function') return undefined;
			if ('name' in Function.prototype) return constructorFn.name;
			if (constructorFn === Function || constructorFn === Function.prototype.constructor) return 'Function';
			var match = ("" + constructorFn).match(funcNameRegex);
			return match ? match[1] : undefined;
		};

		_proto.__initializeAttributes = function __initializeAttributes(force) {
			if (!force && !this.__attributesRaw) return;

			for (var key in this.__scriptType.attributes.index) {
				if (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {
					this[key] = this.__attributesRaw[key];
				} else if (!this.__attributes.hasOwnProperty(key)) {
					if (this.__scriptType.attributes.index[key].hasOwnProperty('default')) {
						this[key] = this.__scriptType.attributes.index[key].default;
					} else {
						this[key] = null;
					}
				}
			}

			this.__attributesRaw = null;
		};

		ScriptType.extend = function extend(methods) {
			for (var key in methods) {
				if (!methods.hasOwnProperty(key)) continue;
				this.prototype[key] = methods[key];
			}
		};

		_createClass(ScriptType, [{
			key: "enabled",
			get: function get() {
				return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;
			},
			set: function set(value) {
				this._enabled = !!value;
				if (this.enabled === this._enabledOld) return;
				this._enabledOld = this.enabled;
				this.fire(this.enabled ? 'enable' : 'disable');
				this.fire('state', this.enabled);

				if (!this._initialized && this.enabled) {
					this._initialized = true;

					this.__initializeAttributes(true);

					if (this.initialize) this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.initialize);
				}

				if (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {
					this._postInitialized = true;
					if (this.postInitialize) this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.postInitialize);
				}
			}
		}], [{
			key: "scriptName",
			get: function get() {
				return this.__name;
			}
		}, {
			key: "attributes",
			get: function get() {
				if (!this.hasOwnProperty('__attributes')) this.__attributes = new ScriptAttributes(this);
				return this.__attributes;
			}
		}]);

		return ScriptType;
	}(EventHandler);

	ScriptType.__name = null;

	var ScriptRegistry = function (_EventHandler) {
		_inheritsLoose(ScriptRegistry, _EventHandler);

		function ScriptRegistry(app) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.app = app;
			_this._scripts = {};
			_this._list = [];
			return _this;
		}

		var _proto = ScriptRegistry.prototype;

		_proto.destroy = function destroy() {
			this.app = null;
			this.off();
		};

		_proto.add = function add(script) {
			var _this2 = this;

			var scriptName = script.__name;

			if (this._scripts.hasOwnProperty(scriptName)) {
				setTimeout(function () {
					if (script.prototype.swap) {
						var old = _this2._scripts[scriptName];

						var ind = _this2._list.indexOf(old);

						_this2._list[ind] = script;
						_this2._scripts[scriptName] = script;

						_this2.fire('swap', scriptName, script);

						_this2.fire('swap:' + scriptName, script);
					} else {
						console.warn("script registry already has '" + scriptName + "' script, define 'swap' method for new script type to enable code hot swapping");
					}
				});
				return false;
			}

			this._scripts[scriptName] = script;

			this._list.push(script);

			this.fire('add', scriptName, script);
			this.fire('add:' + scriptName, script);
			setTimeout(function () {
				if (!_this2._scripts.hasOwnProperty(scriptName)) return;

				if (!_this2.app || !_this2.app.systems || !_this2.app.systems.script) {
					return;
				}

				var components = _this2.app.systems.script._components;
				var attributes;
				var scriptInstances = [];
				var scriptInstancesInitialized = [];

				for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
					var component = components.items[components.loopIndex];

					if (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {
						if (component._scriptsData && component._scriptsData[scriptName]) attributes = component._scriptsData[scriptName].attributes;
						var scriptInstance = component.create(scriptName, {
							preloading: true,
							ind: component._scriptsIndex[scriptName].ind,
							attributes: attributes
						});
						if (scriptInstance) scriptInstances.push(scriptInstance);
					}
				}

				for (var i = 0; i < scriptInstances.length; i++) {
					scriptInstances[i].__initializeAttributes();
				}

				for (var _i = 0; _i < scriptInstances.length; _i++) {
					if (scriptInstances[_i].enabled) {
						scriptInstances[_i]._initialized = true;
						scriptInstancesInitialized.push(scriptInstances[_i]);
						if (scriptInstances[_i].initialize) scriptInstances[_i].initialize();
					}
				}

				for (var _i2 = 0; _i2 < scriptInstancesInitialized.length; _i2++) {
					if (!scriptInstancesInitialized[_i2].enabled || scriptInstancesInitialized[_i2]._postInitialized) {
						continue;
					}

					scriptInstancesInitialized[_i2]._postInitialized = true;
					if (scriptInstancesInitialized[_i2].postInitialize) scriptInstancesInitialized[_i2].postInitialize();
				}
			});
			return true;
		};

		_proto.remove = function remove(nameOrType) {
			var scriptType = nameOrType;
			var scriptName = nameOrType;

			if (typeof scriptName !== 'string') {
				scriptName = scriptType.__name;
			} else {
				scriptType = this.get(scriptName);
			}

			if (this.get(scriptName) !== scriptType) return false;
			delete this._scripts[scriptName];

			var ind = this._list.indexOf(scriptType);

			this._list.splice(ind, 1);

			this.fire('remove', scriptName, scriptType);
			this.fire('remove:' + scriptName, scriptType);
			return true;
		};

		_proto.get = function get(name) {
			return this._scripts[name] || null;
		};

		_proto.has = function has(nameOrType) {
			if (typeof nameOrType === 'string') {
				return this._scripts.hasOwnProperty(nameOrType);
			}

			if (!nameOrType) return false;
			var scriptName = nameOrType.__name;
			return this._scripts[scriptName] === nameOrType;
		};

		_proto.list = function list() {
			return this._list;
		};

		return ScriptRegistry;
	}(EventHandler);

	var I18nParser = function () {
		function I18nParser() {}

		var _proto = I18nParser.prototype;

		_proto._validate = function _validate(data) {
			if (!data.header) {
				throw new Error('pc.I18n#addData: Missing "header" field');
			}

			if (!data.header.version) {
				throw new Error('pc.I18n#addData: Missing "header.version" field');
			}

			if (data.header.version !== 1) {
				throw new Error('pc.I18n#addData: Invalid "header.version" field');
			}

			if (!data.data) {
				throw new Error('pc.I18n#addData: Missing "data" field');
			} else if (!Array.isArray(data.data)) {
				throw new Error('pc.I18n#addData: "data" field must be an array');
			}

			for (var i = 0, len = data.data.length; i < len; i++) {
				var entry = data.data[i];

				if (!entry.info) {
					throw new Error("pc.I18n#addData: missing \"data[" + i + "].info\" field");
				}

				if (!entry.info.locale) {
					throw new Error("pc.I18n#addData: missing \"data[" + i + "].info.locale\" field");
				}

				if (typeof entry.info.locale !== 'string') {
					throw new Error("pc.I18n#addData: \"data[" + i + "].info.locale\" must be a string");
				}

				if (!entry.messages) {
					throw new Error("pc.I18n#addData: missing \"data[" + i + "].messages\" field");
				}
			}
		};

		_proto.parse = function parse(data) {
			this._validate(data);

			return data.data;
		};

		return I18nParser;
	}();

	var I18n = function (_EventHandler) {
		_inheritsLoose(I18n, _EventHandler);

		function I18n(app) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.locale = DEFAULT_LOCALE;
			_this._translations = {};
			_this._availableLangs = {};
			_this._app = app;
			_this._assets = [];
			_this._parser = new I18nParser();
			return _this;
		}

		I18n.findAvailableLocale = function findAvailableLocale$1(desiredLocale, availableLocales) {
			return findAvailableLocale(desiredLocale, availableLocales);
		};

		var _proto = I18n.prototype;

		_proto.findAvailableLocale = function findAvailableLocale(desiredLocale) {
			if (this._translations[desiredLocale]) {
				return desiredLocale;
			}

			var lang = getLang(desiredLocale);
			return this._findFallbackLocale(desiredLocale, lang);
		};

		_proto.getText = function getText(key, locale) {
			var result = key;
			var lang;

			if (!locale) {
				locale = this._locale;
				lang = this._lang;
			}

			var translations = this._translations[locale];

			if (!translations) {
				if (!lang) {
					lang = getLang(locale);
				}

				locale = this._findFallbackLocale(locale, lang);
				translations = this._translations[locale];
			}

			if (translations && translations.hasOwnProperty(key)) {
				result = translations[key];

				if (Array.isArray(result)) {
					result = result[0];
				}

				if (result === null || result === undefined) {
					result = key;
				}
			}

			return result;
		};

		_proto.getPluralText = function getPluralText(key, n, locale) {
			var result = key;
			var lang;
			var pluralFn;

			if (!locale) {
				locale = this._locale;
				lang = this._lang;
				pluralFn = this._pluralFn;
			} else {
				lang = getLang(locale);
				pluralFn = getPluralFn(lang);
			}

			var translations = this._translations[locale];

			if (!translations) {
				locale = this._findFallbackLocale(locale, lang);
				lang = getLang(locale);
				pluralFn = getPluralFn(lang);
				translations = this._translations[locale];
			}

			if (translations && translations[key] && pluralFn) {
				var index = pluralFn(n);
				result = translations[key][index];

				if (result === null || result === undefined) {
					result = key;
				}
			}

			return result;
		};

		_proto.addData = function addData(data) {
			var parsed;

			try {
				parsed = this._parser.parse(data);
			} catch (err) {
				console.error(err);
				return;
			}

			for (var i = 0, len = parsed.length; i < len; i++) {
				var entry = parsed[i];
				var locale = entry.info.locale;
				var messages = entry.messages;

				if (!this._translations[locale]) {
					this._translations[locale] = {};
					var lang = getLang(locale);

					if (!this._availableLangs[lang]) {
						this._availableLangs[lang] = locale;
					}
				}

				Object.assign(this._translations[locale], messages);
				this.fire('data:add', locale, messages);
			}
		};

		_proto.removeData = function removeData(data) {
			var parsed;

			try {
				parsed = this._parser.parse(data);
			} catch (err) {
				console.error(err);
				return;
			}

			for (var i = 0, len = parsed.length; i < len; i++) {
				var entry = parsed[i];
				var locale = entry.info.locale;
				var translations = this._translations[locale];
				if (!translations) continue;
				var messages = entry.messages;

				for (var key in messages) {
					delete translations[key];
				}

				if (Object.keys(translations).length === 0) {
					delete this._translations[locale];
					delete this._availableLangs[getLang(locale)];
				}

				this.fire('data:remove', locale, messages);
			}
		};

		_proto.destroy = function destroy() {
			this._translations = null;
			this._availableLangs = null;
			this._assets = null;
			this._parser = null;
			this.off();
		};

		_proto._findFallbackLocale = function _findFallbackLocale(locale, lang) {
			var result = DEFAULT_LOCALE_FALLBACKS[locale];

			if (result && this._translations[result]) {
				return result;
			}

			result = DEFAULT_LOCALE_FALLBACKS[lang];

			if (result && this._translations[result]) {
				return result;
			}

			result = this._availableLangs[lang];

			if (result && this._translations[result]) {
				return result;
			}

			return DEFAULT_LOCALE;
		};

		_proto._onAssetAdd = function _onAssetAdd(asset) {
			asset.on('load', this._onAssetLoad, this);
			asset.on('change', this._onAssetChange, this);
			asset.on('remove', this._onAssetRemove, this);
			asset.on('unload', this._onAssetUnload, this);

			if (asset.resource) {
				this._onAssetLoad(asset);
			}
		};

		_proto._onAssetLoad = function _onAssetLoad(asset) {
			this.addData(asset.resource);
		};

		_proto._onAssetChange = function _onAssetChange(asset) {
			if (asset.resource) {
				this.addData(asset.resource);
			}
		};

		_proto._onAssetRemove = function _onAssetRemove(asset) {
			asset.off('load', this._onAssetLoad, this);
			asset.off('change', this._onAssetChange, this);
			asset.off('remove', this._onAssetRemove, this);
			asset.off('unload', this._onAssetUnload, this);

			if (asset.resource) {
				this.removeData(asset.resource);
			}

			this._app.assets.once('add:' + asset.id, this._onAssetAdd, this);
		};

		_proto._onAssetUnload = function _onAssetUnload(asset) {
			if (asset.resource) {
				this.removeData(asset.resource);
			}
		};

		_createClass(I18n, [{
			key: "assets",
			get: function get() {
				return this._assets;
			},
			set: function set(value) {
				var index = {};

				for (var _i = 0, len = value.length; _i < len; _i++) {
					var id = value[_i] instanceof Asset ? value[_i].id : value[_i];
					index[id] = true;
				}

				var i = this._assets.length;

				while (i--) {
					var _id = this._assets[i];

					if (!index[_id]) {
						this._app.assets.off('add:' + _id, this._onAssetAdd, this);

						var asset = this._app.assets.get(_id);

						if (asset) {
							this._onAssetRemove(asset);
						}

						this._assets.splice(i, 1);
					}
				}

				for (var _id2 in index) {
					var idNum = parseInt(_id2, 10);
					if (this._assets.indexOf(idNum) !== -1) continue;

					this._assets.push(idNum);

					var _asset = this._app.assets.get(idNum);

					if (!_asset) {
						this._app.assets.once('add:' + idNum, this._onAssetAdd, this);
					} else {
						this._onAssetAdd(_asset);
					}
				}
			}
		}, {
			key: "locale",
			get: function get() {
				return this._locale;
			},
			set: function set(value) {
				if (this._locale === value) {
					return;
				}

				var lang = getLang(value);

				if (lang === 'in') {
					lang = 'id';
					value = replaceLang(value, lang);

					if (this._locale === value) {
						return;
					}
				}

				var old = this._locale;
				this._locale = value;
				this._lang = lang;
				this._pluralFn = getPluralFn(this._lang);
				this.fire('set:locale', value, old);
			}
		}]);

		return I18n;
	}(EventHandler);

	var FILLMODE_NONE = 'NONE';
	var FILLMODE_FILL_WINDOW = 'FILL_WINDOW';
	var FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';
	var RESOLUTION_AUTO = 'AUTO';
	var RESOLUTION_FIXED = 'FIXED';

	var VrDisplay = function (_EventHandler) {
		_inheritsLoose(VrDisplay, _EventHandler);

		function VrDisplay(app, display) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.id = void 0;
			_this.display = void 0;
			_this.presenting = false;
			_this._app = app;
			_this._device = app.graphicsDevice;
			_this.id = display.displayId;
			_this._frameData = null;

			if (window.VRFrameData) {
				_this._frameData = new window.VRFrameData();
			}

			_this.display = display;
			_this._camera = null;
			_this.sitToStandInv = new Mat4();
			_this.leftView = new Mat4();
			_this.leftProj = new Mat4();
			_this.leftViewInv = new Mat4();
			_this.leftPos = new Vec3();
			_this.rightView = new Mat4();
			_this.rightProj = new Mat4();
			_this.rightViewInv = new Mat4();
			_this.rightPos = new Vec3();
			_this.combinedPos = new Vec3();
			_this.combinedView = new Mat4();
			_this.combinedProj = new Mat4();
			_this.combinedViewInv = new Mat4();
			_this.combinedFov = 0;
			_this.combinedAspect = 0;

			_this._presentChange = function (event) {
				var display;

				if (event.display) {
					display = event.display;
				} else if (event.detail && event.detail.display) {
					display = event.detail.display;
				} else if (event.detail && event.detail.vrdisplay) {
					display = event.detail.vrdisplay;
				} else {
					display = _this.display;
				}

				if (display === _this.display) {
					_this.presenting = _this.display && _this.display.isPresenting;

					if (_this.presenting) {
						var leftEye = _this.display.getEyeParameters("left");

						var rightEye = _this.display.getEyeParameters("right");

						var w = Math.max(leftEye.renderWidth, rightEye.renderWidth) * 2;
						var h = Math.max(leftEye.renderHeight, rightEye.renderHeight);

						_this._app.graphicsDevice.setResolution(w, h);

						_this._app._allowResize = false;
					} else {
						_this._app.setCanvasResolution(RESOLUTION_AUTO);

						_this._app._allowResize = true;
					}

					_this.fire('beforepresentchange', _assertThisInitialized(_this));

					_this.fire('presentchange', _assertThisInitialized(_this));
				}
			};

			window.addEventListener('vrdisplaypresentchange', _this._presentChange, false);
			return _this;
		}

		var _proto = VrDisplay.prototype;

		_proto.destroy = function destroy() {
			window.removeEventListener('vrdisplaypresentchange', this._presentChange);
			if (this._camera) this._camera.vrDisplay = null;
			this._camera = null;
		};

		_proto.poll = function poll() {
			if (this.display) {
				this.display.getFrameData(this._frameData);
				this.leftProj.data = this._frameData.leftProjectionMatrix;
				this.rightProj.data = this._frameData.rightProjectionMatrix;
				var stage = this.display.stageParameters;

				if (stage) {
					this.sitToStandInv.set(stage.sittingToStandingTransform).invert();
					this.combinedView.set(this._frameData.leftViewMatrix);
					this.leftView.mul2(this.combinedView, this.sitToStandInv);
					this.combinedView.set(this._frameData.rightViewMatrix);
					this.rightView.mul2(this.combinedView, this.sitToStandInv);
				} else {
					this.leftView.set(this._frameData.leftViewMatrix);
					this.rightView.set(this._frameData.rightViewMatrix);
				}

				var nx = this.leftProj.data[3] + this.leftProj.data[0];
				var nz = this.leftProj.data[11] + this.leftProj.data[8];
				var l = 1.0 / Math.sqrt(nx * nx + nz * nz);
				nx *= l;
				nz *= l;
				var maxFov = -Math.atan2(nz, nx);
				nx = this.rightProj.data[3] + this.rightProj.data[0];
				nz = this.rightProj.data[11] + this.rightProj.data[8];
				l = 1.0 / Math.sqrt(nx * nx + nz * nz);
				nx *= l;
				nz *= l;
				maxFov = Math.max(maxFov, -Math.atan2(nz, nx));
				maxFov *= 2.0;
				this.combinedFov = maxFov;
				var aspect = this.rightProj.data[5] / this.rightProj.data[0];
				this.combinedAspect = aspect;
				var view = this.combinedView;
				view.copy(this.leftView);
				view.invert();
				this.leftViewInv.copy(view);
				var pos = this.combinedPos;
				pos.x = this.leftPos.x = view.data[12];
				pos.y = this.leftPos.y = view.data[13];
				pos.z = this.leftPos.z = view.data[14];
				view.copy(this.rightView);
				view.invert();
				this.rightViewInv.copy(view);
				var deltaX = pos.x - view.data[12];
				var deltaY = pos.y - view.data[13];
				var deltaZ = pos.z - view.data[14];
				var dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
				this.rightPos.x = view.data[12];
				this.rightPos.y = view.data[13];
				this.rightPos.z = view.data[14];
				pos.x += view.data[12];
				pos.y += view.data[13];
				pos.z += view.data[14];
				pos.x *= 0.5;
				pos.y *= 0.5;
				pos.z *= 0.5;
				var b = Math.PI * 0.5;
				var c = maxFov * 0.5;
				var a = Math.PI - (b + c);
				var offset = dist * 0.5 * Math.sin(a);
				var fwdX = view.data[8];
				var fwdY = view.data[9];
				var fwdZ = view.data[10];
				view.data[12] = pos.x + fwdX * offset;
				view.data[13] = pos.y + fwdY * offset;
				view.data[14] = pos.z + fwdZ * offset;
				this.combinedViewInv.copy(view);
				view.invert();
				this.combinedProj.setPerspective(maxFov * math.RAD_TO_DEG, aspect, this.display.depthNear + offset, this.display.depthFar + offset, true);
			}
		};

		_proto.requestPresent = function requestPresent(callback) {
			if (!this.display) {
				if (callback) callback(new Error("No VrDisplay to requestPresent"));
				return;
			}

			if (this.presenting) {
				if (callback) callback(new Error("VrDisplay already presenting"));
				return;
			}

			this.display.requestPresent([{
				source: this._device.canvas
			}]).then(function () {
				if (callback) callback();
			}, function (err) {
				if (callback) callback(err);
			});
		};

		_proto.exitPresent = function exitPresent(callback) {
			if (!this.display) {
				if (callback) callback(new Error("No VrDisplay to exitPresent"));
			}

			if (!this.presenting) {
				if (callback) callback(new Error("VrDisplay not presenting"));
				return;
			}

			this.display.exitPresent().then(function () {
				if (callback) callback();
			}, function () {
				if (callback) callback(new Error("exitPresent failed"));
			});
		};

		_proto.requestAnimationFrame = function requestAnimationFrame(fn) {
			if (this.display) this.display.requestAnimationFrame(fn);
		};

		_proto.submitFrame = function submitFrame() {
			if (this.display) this.display.submitFrame();
		};

		_proto.reset = function reset() {
			if (this.display) this.display.resetPose();
		};

		_proto.setClipPlanes = function setClipPlanes(n, f) {
			if (this.display) {
				this.display.depthNear = n;
				this.display.depthFar = f;
			}
		};

		_proto.getFrameData = function getFrameData() {
			if (this.display) return this._frameData;
		};

		_createClass(VrDisplay, [{
			key: "capabilities",
			get: function get() {
				if (this.display) return this.display.capabilities;
				return {};
			}
		}]);

		return VrDisplay;
	}(EventHandler);

	var VrManager = function (_EventHandler) {
		_inheritsLoose(VrManager, _EventHandler);

		function VrManager(app) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.displays = [];
			_this.display = null;
			_this.isSupported = void 0;
			_this._index = {};
			_this._app = app;
			_this.isSupported = VrManager.isSupported;
			_this._onDisplayConnect = _this._onDisplayConnect.bind(_assertThisInitialized(_this));
			_this._onDisplayDisconnect = _this._onDisplayDisconnect.bind(_assertThisInitialized(_this));

			_this._attach();

			_this._getDisplays(function (err, displays) {
				if (err) {
					_this.fire('error', err);
				} else {
					for (var i = 0; i < displays.length; i++) {
						_this._addDisplay(displays[i]);
					}

					_this.fire('ready', _this.displays);
				}
			});

			return _this;
		}

		var _proto = VrManager.prototype;

		_proto._attach = function _attach() {
			window.addEventListener('vrdisplayconnect', this._onDisplayConnect);
			window.addEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);
		};

		_proto._detach = function _detach() {
			window.removeEventListener('vrdisplayconnect', this._onDisplayConnect);
			window.removeEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);
		};

		_proto.destroy = function destroy() {
			this._detach();
		};

		_proto.poll = function poll() {
			var l = this.displays.length;
			if (!l) return;

			for (var i = 0; i < l; i++) {
				if (this.displays[i]._camera) this.displays[i].poll();
			}
		};

		_proto._getDisplays = function _getDisplays(callback) {
			if (navigator.getVRDisplays) {
				navigator.getVRDisplays().then(function (displays) {
					if (callback) callback(null, displays);
				});
			} else {
				if (callback) callback(new Error('WebVR not supported'));
			}
		};

		_proto._addDisplay = function _addDisplay(vrDisplay) {
			if (this._index[vrDisplay.displayId]) return;
			var display = new VrDisplay(this._app, vrDisplay);
			this._index[display.id] = display;
			this.displays.push(display);
			if (!this.display) this.display = display;
			this.fire('displayconnect', display);
		};

		_proto._onDisplayConnect = function _onDisplayConnect(e) {
			if (e.detail && e.detail.display) {
				this._addDisplay(e.detail.display);
			} else {
				this._addDisplay(e.display);
			}
		};

		_proto._onDisplayDisconnect = function _onDisplayDisconnect(e) {
			var id;

			if (e.detail && e.detail.display) {
				id = e.detail.display.displayId;
			} else {
				id = e.display.displayId;
			}

			var display = this._index[id];
			if (!display) return;
			display.destroy();
			delete this._index[display.id];
			var ind = this.displays.indexOf(display);
			this.displays.splice(ind, 1);

			if (this.display === display) {
				if (this.displays.length) {
					this.display = this.displays[0];
				} else {
					this.display = null;
				}
			}

			this.fire('displaydisconnect', display);
		};

		return VrManager;
	}(EventHandler);

	VrManager.isSupported = typeof navigator !== 'undefined' ? !!navigator.getVRDisplays : false;

	var XRTYPE_INLINE = 'inline';
	var XRTYPE_VR = 'immersive-vr';
	var XRTYPE_AR = 'immersive-ar';
	var XRSPACE_VIEWER = 'viewer';
	var XRSPACE_LOCAL = 'local';
	var XRSPACE_LOCALFLOOR = 'local-floor';
	var XRSPACE_BOUNDEDFLOOR = 'bounded-floor';
	var XRSPACE_UNBOUNDED = 'unbounded';
	var XRTARGETRAY_GAZE = 'gaze';
	var XRTARGETRAY_SCREEN = 'screen';
	var XRTARGETRAY_POINTER = 'tracked-pointer';
	var XRHAND_NONE = 'none';
	var XRHAND_LEFT = 'left';
	var XRHAND_RIGHT = 'right';
	var XRTRACKABLE_POINT = 'point';
	var XRTRACKABLE_PLANE = 'plane';
	var XRTRACKABLE_MESH = 'mesh';
	var XRDEPTHSENSINGUSAGE_CPU = 'cpu-optimized';
	var XRDEPTHSENSINGUSAGE_GPU = 'gpu-optimized';
	var XRDEPTHSENSINGFORMAT_L8A8 = 'luminance-alpha';
	var XRDEPTHSENSINGFORMAT_F32 = 'float32';

	var poolVec3 = [];
	var poolQuat = [];

	var XrHitTestSource = function (_EventHandler) {
		_inheritsLoose(XrHitTestSource, _EventHandler);

		function XrHitTestSource(manager, xrHitTestSource, transient) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.manager = void 0;
			_this._xrHitTestSource = void 0;
			_this._transient = void 0;
			_this.manager = manager;
			_this._xrHitTestSource = xrHitTestSource;
			_this._transient = transient;
			return _this;
		}

		var _proto = XrHitTestSource.prototype;

		_proto.remove = function remove() {
			if (!this._xrHitTestSource) return;
			var sources = this.manager.hitTest.sources;
			var ind = sources.indexOf(this);
			if (ind !== -1) sources.splice(ind, 1);
			this.onStop();
		};

		_proto.onStop = function onStop() {
			this._xrHitTestSource.cancel();

			this._xrHitTestSource = null;
			this.fire('remove');
			this.manager.hitTest.fire('remove', this);
		};

		_proto.update = function update(frame) {
			if (this._transient) {
				var transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);

				for (var i = 0; i < transientResults.length; i++) {
					var transientResult = transientResults[i];
					var inputSource = void 0;
					if (transientResult.inputSource) inputSource = this.manager.input._getByInputSource(transientResult.inputSource);
					this.updateHitResults(transientResult.results, inputSource);
				}
			} else {
				this.updateHitResults(frame.getHitTestResults(this._xrHitTestSource));
			}
		};

		_proto.updateHitResults = function updateHitResults(results, inputSource) {
			for (var i = 0; i < results.length; i++) {
				var pose = results[i].getPose(this.manager._referenceSpace);
				var position = poolVec3.pop();
				if (!position) position = new Vec3();
				position.copy(pose.transform.position);
				var rotation = poolQuat.pop();
				if (!rotation) rotation = new Quat();
				rotation.copy(pose.transform.orientation);
				this.fire('result', position, rotation, inputSource);
				this.manager.hitTest.fire('result', this, position, rotation, inputSource);
				poolVec3.push(position);
				poolQuat.push(rotation);
			}
		};

		return XrHitTestSource;
	}(EventHandler);

	var XrHitTest = function (_EventHandler) {
		_inheritsLoose(XrHitTest, _EventHandler);

		function XrHitTest(manager) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.manager = void 0;
			_this._supported = platform.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource);
			_this._session = null;
			_this.sources = [];
			_this.manager = manager;

			if (_this._supported) {
				_this.manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));

				_this.manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
			}

			return _this;
		}

		var _proto = XrHitTest.prototype;

		_proto._onSessionStart = function _onSessionStart() {
			if (this.manager.type !== XRTYPE_AR) return;
			this._session = this.manager.session;
		};

		_proto._onSessionEnd = function _onSessionEnd() {
			if (!this._session) return;
			this._session = null;

			for (var i = 0; i < this.sources.length; i++) {
				this.sources[i].onStop();
			}

			this.sources = [];
		};

		_proto.isAvailable = function isAvailable(callback, fireError) {
			var err;
			if (!this._supported) err = new Error('XR HitTest is not supported');
			if (!this._session) err = new Error('XR Session is not started (1)');
			if (this.manager.type !== XRTYPE_AR) err = new Error('XR HitTest is available only for AR');

			if (err) {
				if (callback) callback(err);
				if (fireError) fireError.fire('error', err);
				return false;
			}

			return true;
		};

		_proto.start = function start(options) {
			var _this2 = this;

			if (options === void 0) {
				options = {};
			}

			if (!this.isAvailable(options.callback, this)) return;
			if (!options.profile && !options.spaceType) options.spaceType = XRSPACE_VIEWER;
			var xrRay;
			var offsetRay = options.offsetRay;
			if (offsetRay) xrRay = new XRRay(new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z), new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z));
			var callback = options.callback;

			if (options.spaceType) {
				this._session.requestReferenceSpace(options.spaceType).then(function (referenceSpace) {
					if (!_this2._session) {
						var err = new Error('XR Session is not started (2)');
						if (callback) callback(err);

						_this2.fire('error', err);

						return;
					}

					_this2._session.requestHitTestSource({
						space: referenceSpace,
						entityTypes: options.entityTypes || undefined,
						offsetRay: xrRay
					}).then(function (xrHitTestSource) {
						_this2._onHitTestSource(xrHitTestSource, false, callback);
					}).catch(function (ex) {
						if (callback) callback(ex);

						_this2.fire('error', ex);
					});
				}).catch(function (ex) {
					if (callback) callback(ex);

					_this2.fire('error', ex);
				});
			} else {
				this._session.requestHitTestSourceForTransientInput({
					profile: options.profile,
					entityTypes: options.entityTypes || undefined,
					offsetRay: xrRay
				}).then(function (xrHitTestSource) {
					_this2._onHitTestSource(xrHitTestSource, true, callback);
				}).catch(function (ex) {
					if (callback) callback(ex);

					_this2.fire('error', ex);
				});
			}
		};

		_proto._onHitTestSource = function _onHitTestSource(xrHitTestSource, transient, callback) {
			if (!this._session) {
				xrHitTestSource.cancel();
				var err = new Error('XR Session is not started (3)');
				if (callback) callback(err);
				this.fire('error', err);
				return;
			}

			var hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, transient);
			this.sources.push(hitTestSource);
			if (callback) callback(null, hitTestSource);
			this.fire('add', hitTestSource);
		};

		_proto.update = function update(frame) {
			for (var i = 0; i < this.sources.length; i++) {
				this.sources[i].update(frame);
			}
		};

		_createClass(XrHitTest, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}]);

		return XrHitTest;
	}(EventHandler);

	var XrFinger = function () {
		function XrFinger(index, hand) {
			this._index = void 0;
			this._hand = void 0;
			this._joints = [];
			this._tip = null;
			this._index = index;
			this._hand = hand;

			this._hand._fingers.push(this);
		}

		_createClass(XrFinger, [{
			key: "index",
			get: function get() {
				return this._index;
			}
		}, {
			key: "hand",
			get: function get() {
				return this._hand;
			}
		}, {
			key: "joints",
			get: function get() {
				return this._joints;
			}
		}, {
			key: "tip",
			get: function get() {
				return this._tip;
			}
		}]);

		return XrFinger;
	}();

	var tipJointIds = platform.browser && window.XRHand ? ['thumb-tip', 'index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-finger-tip'] : [];
	var tipJointIdsIndex = {};

	for (var i = 0; i < tipJointIds.length; i++) {
		tipJointIdsIndex[tipJointIds[i]] = true;
	}

	var XrJoint = function () {
		function XrJoint(index, id, hand, finger) {
			if (finger === void 0) {
				finger = null;
			}

			this._index = void 0;
			this._id = void 0;
			this._hand = void 0;
			this._finger = void 0;
			this._wrist = void 0;
			this._tip = void 0;
			this._radius = null;
			this._localTransform = new Mat4();
			this._worldTransform = new Mat4();
			this._localPosition = new Vec3();
			this._localRotation = new Quat();
			this._position = new Vec3();
			this._rotation = new Quat();
			this._dirtyLocal = true;
			this._index = index;
			this._id = id;
			this._hand = hand;
			this._finger = finger;
			this._wrist = id === 'wrist';
			this._tip = this._finger && !!tipJointIdsIndex[id];
		}

		var _proto = XrJoint.prototype;

		_proto.update = function update(pose) {
			this._dirtyLocal = true;
			this._radius = pose.radius;

			this._localPosition.copy(pose.transform.position);

			this._localRotation.copy(pose.transform.orientation);
		};

		_proto._updateTransforms = function _updateTransforms() {
			if (this._dirtyLocal) {
				this._dirtyLocal = false;

				this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
			}

			var manager = this._hand._manager;
			var parent = manager.camera.parent;

			if (parent) {
				this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
			} else {
				this._worldTransform.copy(this._localTransform);
			}
		};

		_proto.getPosition = function getPosition() {
			this._updateTransforms();

			this._worldTransform.getTranslation(this._position);

			return this._position;
		};

		_proto.getRotation = function getRotation() {
			this._updateTransforms();

			this._rotation.setFromMat4(this._worldTransform);

			return this._rotation;
		};

		_createClass(XrJoint, [{
			key: "index",
			get: function get() {
				return this._index;
			}
		}, {
			key: "hand",
			get: function get() {
				return this._hand;
			}
		}, {
			key: "finger",
			get: function get() {
				return this._finger;
			}
		}, {
			key: "wrist",
			get: function get() {
				return this._wrist;
			}
		}, {
			key: "tip",
			get: function get() {
				return this._tip;
			}
		}, {
			key: "radius",
			get: function get() {
				return this._radius || 0.005;
			}
		}]);

		return XrJoint;
	}();

	var fingerJointIds = [];
	var vecA$2 = new Vec3();
	var vecB$2 = new Vec3();
	var vecC = new Vec3();

	if (platform.browser && window.XRHand) {
		fingerJointIds = [['thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip'], ['index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip'], ['middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip'], ['ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip'], ['pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip']];
	}

	var XrHand = function (_EventHandler) {
		_inheritsLoose(XrHand, _EventHandler);

		function XrHand(inputSource) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._inputSource = void 0;
			_this._tracking = false;
			_this._fingers = [];
			_this._joints = [];
			_this._jointsById = {};
			_this._tips = [];
			_this._wrist = null;
			var xrHand = inputSource._xrInputSource.hand;
			_this._manager = inputSource._manager;
			_this._inputSource = inputSource;

			if (xrHand.get('wrist')) {
				var joint = new XrJoint(0, 'wrist', _assertThisInitialized(_this), null);
				_this._wrist = joint;

				_this._joints.push(joint);

				_this._jointsById.wrist = joint;
			}

			for (var f = 0; f < fingerJointIds.length; f++) {
				var finger = new XrFinger(f, _assertThisInitialized(_this));

				for (var j = 0; j < fingerJointIds[f].length; j++) {
					var jointId = fingerJointIds[f][j];
					if (!xrHand.get(jointId)) continue;

					var _joint = new XrJoint(j, jointId, _assertThisInitialized(_this), finger);

					_this._joints.push(_joint);

					_this._jointsById[jointId] = _joint;

					if (_joint.tip) {
						_this._tips.push(_joint);

						finger._tip = _joint;
					}

					finger._joints.push(_joint);
				}
			}

			return _this;
		}

		var _proto = XrHand.prototype;

		_proto.update = function update(frame) {
			var xrInputSource = this._inputSource._xrInputSource;

			for (var j = 0; j < this._joints.length; j++) {
				var joint = this._joints[j];
				var jointSpace = xrInputSource.hand.get(joint._id);

				if (jointSpace) {
					var pose = void 0;
					if (frame.session.visibilityState !== 'hidden') pose = frame.getJointPose(jointSpace, this._manager._referenceSpace);

					if (pose) {
						joint.update(pose);

						if (joint.wrist && !this._tracking) {
							this._tracking = true;
							this.fire('tracking');
						}
					} else if (joint.wrist) {
						if (this._tracking) {
							this._tracking = false;
							this.fire('trackinglost');
						}

						break;
					}
				}
			}

			var j1 = this._jointsById['thumb-metacarpal'];
			var j4 = this._jointsById['thumb-tip'];
			var j6 = this._jointsById['index-finger-phalanx-proximal'];
			var j9 = this._jointsById['index-finger-tip'];
			var j16 = this._jointsById['ring-finger-phalanx-proximal'];
			var j21 = this._jointsById['pinky-finger-phalanx-proximal'];

			if (j1 && j4 && j6 && j9 && j16 && j21) {
				this._inputSource._dirtyRay = true;

				this._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);

				var jointL = j1;
				var jointR = j21;

				if (this._inputSource.handedness === XRHAND_LEFT) {
					var t = jointL;
					jointL = jointR;
					jointR = t;
				}

				vecA$2.sub2(jointL._localPosition, this._wrist._localPosition);
				vecB$2.sub2(jointR._localPosition, this._wrist._localPosition);
				vecC.cross(vecA$2, vecB$2).normalize();
				vecA$2.lerp(j6._localPosition, j16._localPosition, 0.5);
				vecA$2.sub(this._wrist._localPosition).normalize();

				this._inputSource._rayLocal.direction.lerp(vecC, vecA$2, 0.5).normalize();
			}

			var squeezing = this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4);

			if (squeezing) {
				if (!this._inputSource._squeezing) {
					this._inputSource._squeezing = true;

					this._inputSource.fire('squeezestart');

					this._manager.input.fire('squeezestart', this._inputSource);
				}
			} else {
				if (this._inputSource._squeezing) {
					this._inputSource._squeezing = false;

					this._inputSource.fire('squeeze');

					this._manager.input.fire('squeeze', this._inputSource);

					this._inputSource.fire('squeezeend');

					this._manager.input.fire('squeezeend', this._inputSource);
				}
			}
		};

		_proto._fingerIsClosed = function _fingerIsClosed(index) {
			var finger = this._fingers[index];
			vecA$2.sub2(finger.joints[0]._localPosition, finger.joints[1]._localPosition).normalize();
			vecB$2.sub2(finger.joints[2]._localPosition, finger.joints[3]._localPosition).normalize();
			return vecA$2.dot(vecB$2) < -0.8;
		};

		_proto.getJointById = function getJointById(id) {
			return this._jointsById[id] || null;
		};

		_createClass(XrHand, [{
			key: "fingers",
			get: function get() {
				return this._fingers;
			}
		}, {
			key: "joints",
			get: function get() {
				return this._joints;
			}
		}, {
			key: "tips",
			get: function get() {
				return this._tips;
			}
		}, {
			key: "wrist",
			get: function get() {
				return this._wrist;
			}
		}, {
			key: "tracking",
			get: function get() {
				return this._tracking;
			}
		}]);

		return XrHand;
	}(EventHandler);

	var quat$1 = new Quat();
	var ids$1 = 0;

	var XrInputSource = function (_EventHandler) {
		_inheritsLoose(XrInputSource, _EventHandler);

		function XrInputSource(manager, xrInputSource) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._id = void 0;
			_this._manager = void 0;
			_this._xrInputSource = void 0;
			_this._ray = new Ray();
			_this._rayLocal = new Ray();
			_this._grip = false;
			_this._hand = null;
			_this._localTransform = null;
			_this._worldTransform = null;
			_this._position = new Vec3();
			_this._rotation = new Quat();
			_this._localPosition = null;
			_this._localRotation = null;
			_this._dirtyLocal = true;
			_this._dirtyRay = false;
			_this._selecting = false;
			_this._squeezing = false;
			_this._elementInput = true;
			_this._elementEntity = null;
			_this._hitTestSources = [];
			_this._id = ++ids$1;
			_this._manager = manager;
			_this._xrInputSource = xrInputSource;
			if (xrInputSource.hand) _this._hand = new XrHand(_assertThisInitialized(_this));
			return _this;
		}

		var _proto = XrInputSource.prototype;

		_proto.update = function update(frame) {
			if (this._hand) {
				this._hand.update(frame);
			} else {
				if (this._xrInputSource.gripSpace) {
					var gripPose = frame.getPose(this._xrInputSource.gripSpace, this._manager._referenceSpace);

					if (gripPose) {
						if (!this._grip) {
							this._grip = true;
							this._localTransform = new Mat4();
							this._worldTransform = new Mat4();
							this._localPosition = new Vec3();
							this._localRotation = new Quat();
						}

						this._dirtyLocal = true;

						this._localPosition.copy(gripPose.transform.position);

						this._localRotation.copy(gripPose.transform.orientation);
					}
				}

				var targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);

				if (targetRayPose) {
					this._dirtyRay = true;

					this._rayLocal.origin.copy(targetRayPose.transform.position);

					this._rayLocal.direction.set(0, 0, -1);

					quat$1.copy(targetRayPose.transform.orientation);
					quat$1.transformVector(this._rayLocal.direction, this._rayLocal.direction);
				}
			}
		};

		_proto._updateTransforms = function _updateTransforms() {
			if (this._dirtyLocal) {
				this._dirtyLocal = false;

				this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
			}

			var parent = this._manager.camera.parent;

			if (parent) {
				this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
			} else {
				this._worldTransform.copy(this._localTransform);
			}
		};

		_proto._updateRayTransforms = function _updateRayTransforms() {
			var dirty = this._dirtyRay;
			this._dirtyRay = false;
			var parent = this._manager.camera.parent;

			if (parent) {
				var parentTransform = this._manager.camera.parent.getWorldTransform();

				parentTransform.getTranslation(this._position);

				this._rotation.setFromMat4(parentTransform);

				this._rotation.transformVector(this._rayLocal.origin, this._ray.origin);

				this._ray.origin.add(this._position);

				this._rotation.transformVector(this._rayLocal.direction, this._ray.direction);
			} else if (dirty) {
				this._ray.origin.copy(this._rayLocal.origin);

				this._ray.direction.copy(this._rayLocal.direction);
			}
		};

		_proto.getPosition = function getPosition() {
			if (!this._position) return null;

			this._updateTransforms();

			this._worldTransform.getTranslation(this._position);

			return this._position;
		};

		_proto.getLocalPosition = function getLocalPosition() {
			return this._localPosition;
		};

		_proto.getRotation = function getRotation() {
			if (!this._rotation) return null;

			this._updateTransforms();

			this._rotation.setFromMat4(this._worldTransform);

			return this._rotation;
		};

		_proto.getLocalRotation = function getLocalRotation() {
			return this._localRotation;
		};

		_proto.getOrigin = function getOrigin() {
			this._updateRayTransforms();

			return this._ray.origin;
		};

		_proto.getDirection = function getDirection() {
			this._updateRayTransforms();

			return this._ray.direction;
		};

		_proto.hitTestStart = function hitTestStart(options) {
			var _this2 = this;

			if (options === void 0) {
				options = {};
			}

			options.profile = this._xrInputSource.profiles[0];
			var callback = options.callback;

			options.callback = function (err, hitTestSource) {
				if (hitTestSource) _this2.onHitTestSourceAdd(hitTestSource);
				if (callback) callback(err, hitTestSource);
			};

			this._manager.hitTest.start(options);
		};

		_proto.onHitTestSourceAdd = function onHitTestSourceAdd(hitTestSource) {
			this._hitTestSources.push(hitTestSource);

			this.fire('hittest:add', hitTestSource);
			hitTestSource.on('result', function (position, rotation, inputSource) {
				if (inputSource !== this) return;
				this.fire('hittest:result', hitTestSource, position, rotation);
			}, this);
			hitTestSource.once('remove', function () {
				this.onHitTestSourceRemove(hitTestSource);
				this.fire('hittest:remove', hitTestSource);
			}, this);
		};

		_proto.onHitTestSourceRemove = function onHitTestSourceRemove(hitTestSource) {
			var ind = this._hitTestSources.indexOf(hitTestSource);

			if (ind !== -1) this._hitTestSources.splice(ind, 1);
		};

		_createClass(XrInputSource, [{
			key: "id",
			get: function get() {
				return this._id;
			}
		}, {
			key: "inputSource",
			get: function get() {
				return this._xrInputSource;
			}
		}, {
			key: "targetRayMode",
			get: function get() {
				return this._xrInputSource.targetRayMode;
			}
		}, {
			key: "handedness",
			get: function get() {
				return this._xrInputSource.handedness;
			}
		}, {
			key: "profiles",
			get: function get() {
				return this._xrInputSource.profiles;
			}
		}, {
			key: "grip",
			get: function get() {
				return this._grip;
			}
		}, {
			key: "hand",
			get: function get() {
				return this._hand;
			}
		}, {
			key: "gamepad",
			get: function get() {
				return this._xrInputSource.gamepad || null;
			}
		}, {
			key: "selecting",
			get: function get() {
				return this._selecting;
			}
		}, {
			key: "squeezing",
			get: function get() {
				return this._squeezing;
			}
		}, {
			key: "elementInput",
			get: function get() {
				return this._elementInput;
			},
			set: function set(value) {
				if (this._elementInput === value) return;
				this._elementInput = value;
				if (!this._elementInput) this._elementEntity = null;
			}
		}, {
			key: "elementEntity",
			get: function get() {
				return this._elementEntity;
			}
		}, {
			key: "hitTestSources",
			get: function get() {
				return this._hitTestSources;
			}
		}]);

		return XrInputSource;
	}(EventHandler);

	var XrInput = function (_EventHandler) {
		_inheritsLoose(XrInput, _EventHandler);

		function XrInput(manager) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.manager = void 0;
			_this._inputSources = [];
			_this._onInputSourcesChangeEvt = void 0;
			_this.manager = manager;

			_this._onInputSourcesChangeEvt = function (evt) {
				_this._onInputSourcesChange(evt);
			};

			_this.manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));

			_this.manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = XrInput.prototype;

		_proto._onSessionStart = function _onSessionStart() {
			var _this2 = this;

			var session = this.manager.session;
			session.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
			session.addEventListener('select', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);

				inputSource.update(evt.frame);
				inputSource.fire('select', evt);

				_this2.fire('select', inputSource, evt);
			});
			session.addEventListener('selectstart', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);

				inputSource.update(evt.frame);
				inputSource._selecting = true;
				inputSource.fire('selectstart', evt);

				_this2.fire('selectstart', inputSource, evt);
			});
			session.addEventListener('selectend', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);

				inputSource.update(evt.frame);
				inputSource._selecting = false;
				inputSource.fire('selectend', evt);

				_this2.fire('selectend', inputSource, evt);
			});
			session.addEventListener('squeeze', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);

				inputSource.update(evt.frame);
				inputSource.fire('squeeze', evt);

				_this2.fire('squeeze', inputSource, evt);
			});
			session.addEventListener('squeezestart', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);

				inputSource.update(evt.frame);
				inputSource._squeezing = true;
				inputSource.fire('squeezestart', evt);

				_this2.fire('squeezestart', inputSource, evt);
			});
			session.addEventListener('squeezeend', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);

				inputSource.update(evt.frame);
				inputSource._squeezing = false;
				inputSource.fire('squeezeend', evt);

				_this2.fire('squeezeend', inputSource, evt);
			});
			var inputSources = session.inputSources;

			for (var i = 0; i < inputSources.length; i++) {
				this._addInputSource(inputSources[i]);
			}
		};

		_proto._onSessionEnd = function _onSessionEnd() {
			var i = this._inputSources.length;

			while (i--) {
				var inputSource = this._inputSources[i];

				this._inputSources.splice(i, 1);

				inputSource.fire('remove');
				this.fire('remove', inputSource);
			}

			var session = this.manager.session;
			session.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
		};

		_proto._onInputSourcesChange = function _onInputSourcesChange(evt) {
			for (var i = 0; i < evt.removed.length; i++) {
				this._removeInputSource(evt.removed[i]);
			}

			for (var _i = 0; _i < evt.added.length; _i++) {
				this._addInputSource(evt.added[_i]);
			}
		};

		_proto._getByInputSource = function _getByInputSource(xrInputSource) {
			for (var i = 0; i < this._inputSources.length; i++) {
				if (this._inputSources[i].inputSource === xrInputSource) {
					return this._inputSources[i];
				}
			}

			return null;
		};

		_proto._addInputSource = function _addInputSource(xrInputSource) {
			if (this._getByInputSource(xrInputSource)) return;
			var inputSource = new XrInputSource(this.manager, xrInputSource);

			this._inputSources.push(inputSource);

			this.fire('add', inputSource);
		};

		_proto._removeInputSource = function _removeInputSource(xrInputSource) {
			for (var i = 0; i < this._inputSources.length; i++) {
				if (this._inputSources[i].inputSource !== xrInputSource) continue;
				var inputSource = this._inputSources[i];

				this._inputSources.splice(i, 1);

				var h = inputSource.hitTestSources.length;

				while (h--) {
					inputSource.hitTestSources[h].remove();
				}

				inputSource.fire('remove');
				this.fire('remove', inputSource);
				return;
			}
		};

		_proto.update = function update(frame) {
			for (var i = 0; i < this._inputSources.length; i++) {
				this._inputSources[i].update(frame);
			}
		};

		_createClass(XrInput, [{
			key: "inputSources",
			get: function get() {
				return this._inputSources;
			}
		}]);

		return XrInput;
	}(EventHandler);

	var vec3A = new Vec3();
	var vec3B = new Vec3();
	var mat4A = new Mat4();
	var mat4B = new Mat4();

	var XrLightEstimation = function (_EventHandler) {
		_inheritsLoose(XrLightEstimation, _EventHandler);

		function XrLightEstimation(manager) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._supported = false;
			_this._available = false;
			_this._lightProbeRequested = false;
			_this._lightProbe = null;
			_this._intensity = 0;
			_this._rotation = new Quat();
			_this._color = new Color();
			_this._sphericalHarmonics = new Float32Array(27);
			_this._manager = manager;

			_this._manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));

			_this._manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = XrLightEstimation.prototype;

		_proto._onSessionStart = function _onSessionStart() {
			var supported = !!this._manager.session.requestLightProbe;
			if (!supported) return;
			this._supported = true;
		};

		_proto._onSessionEnd = function _onSessionEnd() {
			this._supported = false;
			this._available = false;
			this._lightProbeRequested = false;
			this._lightProbe = null;
		};

		_proto.start = function start() {
			var _this2 = this;

			var err;
			if (!this._manager.session) err = new Error('XR session is not running');
			if (!err && this._manager.type !== XRTYPE_AR) err = new Error('XR session type is not AR');
			if (!err && !this._supported) err = new Error('light-estimation is not supported');
			if (!err && this._lightProbe || this._lightProbeRequested) err = new Error('light estimation is already requested');

			if (err) {
				this.fire('error', err);
				return;
			}

			this._lightProbeRequested = true;

			this._manager.session.requestLightProbe().then(function (lightProbe) {
				var wasRequested = _this2._lightProbeRequested;
				_this2._lightProbeRequested = false;

				if (_this2._manager.active) {
					if (wasRequested) {
						_this2._lightProbe = lightProbe;
					}
				} else {
					_this2.fire('error', new Error('XR session is not active'));
				}
			}).catch(function (ex) {
				_this2._lightProbeRequested = false;

				_this2.fire('error', ex);
			});
		};

		_proto.end = function end() {
			this._lightProbeRequested = false;
			this._lightProbe = null;
			this._available = false;
		};

		_proto.update = function update(frame) {
			if (!this._lightProbe) return;
			var lightEstimate = frame.getLightEstimate(this._lightProbe);
			if (!lightEstimate) return;

			if (!this._available) {
				this._available = true;
				this.fire('available');
			}

			var pli = lightEstimate.primaryLightIntensity;
			this._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));
			vec3A.copy(pli).mulScalar(1 / this._intensity);

			this._color.set(vec3A.x, vec3A.y, vec3A.z);

			vec3A.set(0, 0, 0);
			vec3B.copy(lightEstimate.primaryLightDirection);
			mat4A.setLookAt(vec3B, vec3A, Vec3.UP);
			mat4B.setFromAxisAngle(Vec3.RIGHT, 90);
			mat4A.mul(mat4B);

			this._rotation.setFromMat4(mat4A);

			this._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);
		};

		_createClass(XrLightEstimation, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}, {
			key: "intensity",
			get: function get() {
				return this._available ? this._intensity : null;
			}
		}, {
			key: "color",
			get: function get() {
				return this._available ? this._color : null;
			}
		}, {
			key: "rotation",
			get: function get() {
				return this._available ? this._rotation : null;
			}
		}, {
			key: "sphericalHarmonics",
			get: function get() {
				return this._available ? this._sphericalHarmonics : null;
			}
		}]);

		return XrLightEstimation;
	}(EventHandler);

	var XrTrackedImage = function (_EventHandler) {
		_inheritsLoose(XrTrackedImage, _EventHandler);

		function XrTrackedImage(image, width) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._image = void 0;
			_this._width = void 0;
			_this._bitmap = null;
			_this._measuredWidth = 0;
			_this._trackable = false;
			_this._tracking = false;
			_this._emulated = false;
			_this._pose = null;
			_this._position = new Vec3();
			_this._rotation = new Quat();
			_this._image = image;
			_this._width = width;
			return _this;
		}

		var _proto = XrTrackedImage.prototype;

		_proto.prepare = function prepare() {
			var _this2 = this;

			if (this._bitmap) {
				return {
					image: this._bitmap,
					widthInMeters: this._width
				};
			}

			return createImageBitmap(this._image).then(function (bitmap) {
				_this2._bitmap = bitmap;
				return {
					image: _this2._bitmap,
					widthInMeters: _this2._width
				};
			});
		};

		_proto.destroy = function destroy() {
			this._image = null;
			this._pose = null;

			if (this._bitmap) {
				this._bitmap.close();

				this._bitmap = null;
			}
		};

		_proto.getPosition = function getPosition() {
			if (this._pose) this._position.copy(this._pose.transform.position);
			return this._position;
		};

		_proto.getRotation = function getRotation() {
			if (this._pose) this._rotation.copy(this._pose.transform.orientation);
			return this._rotation;
		};

		_createClass(XrTrackedImage, [{
			key: "image",
			get: function get() {
				return this._image;
			}
		}, {
			key: "width",
			get: function get() {
				return this._width;
			},
			set: function set(value) {
				this._width = value;
			}
		}, {
			key: "trackable",
			get: function get() {
				return this._trackable;
			}
		}, {
			key: "tracking",
			get: function get() {
				return this._tracking;
			}
		}, {
			key: "emulated",
			get: function get() {
				return this._emulated;
			}
		}]);

		return XrTrackedImage;
	}(EventHandler);

	var XrImageTracking = function (_EventHandler) {
		_inheritsLoose(XrImageTracking, _EventHandler);

		function XrImageTracking(manager) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._supported = platform.browser && !!window.XRImageTrackingResult;
			_this._available = false;
			_this._images = [];
			_this._manager = manager;

			if (_this._supported) {
				_this._manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));

				_this._manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
			}

			return _this;
		}

		var _proto = XrImageTracking.prototype;

		_proto.add = function add(image, width) {
			if (!this._supported || this._manager.active) return null;
			var trackedImage = new XrTrackedImage(image, width);

			this._images.push(trackedImage);

			return trackedImage;
		};

		_proto.remove = function remove(trackedImage) {
			if (this._manager.active) return;

			var ind = this._images.indexOf(trackedImage);

			if (ind !== -1) {
				trackedImage.destroy();

				this._images.splice(ind, 1);
			}
		};

		_proto._onSessionStart = function _onSessionStart() {
			var _this2 = this;

			this._manager.session.getTrackedImageScores().then(function (images) {
				_this2._available = true;

				for (var i = 0; i < images.length; i++) {
					_this2._images[i]._trackable = images[i] === 'trackable';
				}
			}).catch(function (err) {
				_this2._available = false;

				_this2.fire('error', err);
			});
		};

		_proto._onSessionEnd = function _onSessionEnd() {
			this._available = false;

			for (var i = 0; i < this._images.length; i++) {
				var image = this._images[i];
				image._pose = null;
				image._measuredWidth = 0;

				if (image._tracking) {
					image._tracking = false;
					image.fire('untracked');
				}
			}
		};

		_proto.prepareImages = function prepareImages(callback) {
			if (this._images.length) {
				Promise.all(this._images.map(function (trackedImage) {
					return trackedImage.prepare();
				})).then(function (bitmaps) {
					callback(null, bitmaps);
				}).catch(function (err) {
					callback(err, null);
				});
			} else {
				callback(null, null);
			}
		};

		_proto.update = function update(frame) {
			if (!this._available) return;
			var results = frame.getImageTrackingResults();
			var index = {};

			for (var i = 0; i < results.length; i++) {
				index[results[i].index] = results[i];
				var trackedImage = this._images[results[i].index];
				trackedImage._emulated = results[i].trackingState === 'emulated';
				trackedImage._measuredWidth = results[i].measuredWidthInMeters;
				trackedImage._pose = frame.getPose(results[i].imageSpace, this._manager._referenceSpace);
			}

			for (var _i = 0; _i < this._images.length; _i++) {
				if (this._images[_i]._tracking && !index[_i]) {
					this._images[_i]._tracking = false;

					this._images[_i].fire('untracked');
				} else if (!this._images[_i]._tracking && index[_i]) {
					this._images[_i]._tracking = true;

					this._images[_i].fire('tracked');
				}
			}
		};

		_createClass(XrImageTracking, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}, {
			key: "images",
			get: function get() {
				return this._images;
			}
		}]);

		return XrImageTracking;
	}(EventHandler);

	var XrDomOverlay = function () {
		function XrDomOverlay(manager) {
			this._manager = void 0;
			this._supported = platform.browser && !!window.XRDOMOverlayState;
			this._root = null;
			this._manager = manager;
		}

		_createClass(XrDomOverlay, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._supported && this._manager.active && this._manager._session.domOverlayState !== null;
			}
		}, {
			key: "state",
			get: function get() {
				if (!this._supported || !this._manager.active || !this._manager._session.domOverlayState) return null;
				return this._manager._session.domOverlayState.type;
			}
		}, {
			key: "root",
			get: function get() {
				return this._root;
			},
			set: function set(value) {
				if (!this._supported || this._manager.active) return;
				this._root = value;
			}
		}]);

		return XrDomOverlay;
	}();

	var XrDepthSensing = function (_EventHandler) {
		_inheritsLoose(XrDepthSensing, _EventHandler);

		function XrDepthSensing(manager) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._available = false;
			_this._depthInfoCpu = null;
			_this._depthInfoGpu = null;
			_this._usage = null;
			_this._dataFormat = null;
			_this._matrixDirty = false;
			_this._matrix = new Mat4();
			_this._emptyBuffer = new Uint8Array(32);
			_this._depthBuffer = null;
			_this._texture = void 0;
			_this._manager = manager;
			_this._texture = new Texture(_this._manager.app.graphicsDevice, {
				format: PIXELFORMAT_L8_A8,
				mipmaps: false,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				minFilter: FILTER_LINEAR,
				magFilter: FILTER_LINEAR
			});

			if (_this.supported) {
				_this._manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));

				_this._manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
			}

			return _this;
		}

		var _proto = XrDepthSensing.prototype;

		_proto._onSessionStart = function _onSessionStart() {
			var session = this._manager.session;

			try {
				this._usage = session.depthUsage;
				this._dataFormat = session.depthDataFormat;
			} catch (ex) {
				this._usage = null;
				this._dataFormat = null;
				this._available = false;
				this.fire('error', ex);
			}
		};

		_proto._onSessionEnd = function _onSessionEnd() {
			this._depthInfoCpu = null;
			this._depthInfoGpu = null;
			this._usage = null;
			this._dataFormat = null;

			if (this._available) {
				this._available = false;
				this.fire('unavailable');
			}

			this._depthBuffer = null;
			this._texture._width = 4;
			this._texture._height = 4;
			this._texture._levels[0] = this._emptyBuffer;

			this._texture.upload();
		};

		_proto._updateTexture = function _updateTexture() {
			var depthInfo = this._depthInfoCpu || this._depthInfoGpu;

			if (depthInfo) {
				var resized = false;

				if (depthInfo.width !== this._texture.width || depthInfo.height !== this._texture.height) {
					this._texture._width = depthInfo.width;
					this._texture._height = depthInfo.height;
					this._matrixDirty = true;
					resized = true;
				}

				if (this._depthInfoCpu) {
					var dataBuffer = this._depthInfoCpu.data;
					this._depthBuffer = new Uint8Array(dataBuffer);
					this._texture._levels[0] = this._depthBuffer;

					this._texture.upload();
				} else if (this._depthInfoGpu) {
					this._texture._levels[0] = this._depthInfoGpu.texture;

					this._texture.upload();
				}

				if (resized) this.fire('resize', depthInfo.width, depthInfo.height);
			} else if (this._depthBuffer) {
				this._depthBuffer = null;
				this._texture._width = 4;
				this._texture._height = 4;
				this._texture._levels[0] = this._emptyBuffer;

				this._texture.upload();
			}
		};

		_proto.update = function update(frame, view) {
			if (!this._usage) return;
			var depthInfoCpu = null;
			var depthInfoGpu = null;

			if (this._usage === XRDEPTHSENSINGUSAGE_CPU && view) {
				depthInfoCpu = frame.getDepthInformation(view);
			} else if (this._usage === XRDEPTHSENSINGUSAGE_GPU && view) {
				depthInfoGpu = frame.getDepthInformation(view);
			}

			if (this._depthInfoCpu && !depthInfoCpu || !this._depthInfoCpu && depthInfoCpu || this.depthInfoGpu && !depthInfoGpu || !this._depthInfoGpu && depthInfoGpu) {
				this._matrixDirty = true;
			}

			this._depthInfoCpu = depthInfoCpu;
			this._depthInfoGpu = depthInfoGpu;

			this._updateTexture();

			if (this._matrixDirty) {
				this._matrixDirty = false;
				var depthInfo = this._depthInfoCpu || this._depthInfoGpu;

				if (depthInfo) {
					this._matrix.data.set(depthInfo.normDepthBufferFromNormView.matrix);
				} else {
					this._matrix.setIdentity();
				}
			}

			if ((this._depthInfoCpu || this._depthInfoGpu) && !this._available) {
				this._available = true;
				this.fire('available');
			} else if (!this._depthInfoCpu && !this._depthInfoGpu && this._available) {
				this._available = false;
				this.fire('unavailable');
			}
		};

		_proto.getDepth = function getDepth(u, v) {
			if (!this._depthInfoCpu) return null;
			return this._depthInfoCpu.getDepthInMeters(u, v);
		};

		_createClass(XrDepthSensing, [{
			key: "supported",
			get: function get() {
				return platform.browser && !!window.XRDepthInformation;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}, {
			key: "usage",
			get: function get() {
				return this._usage;
			}
		}, {
			key: "dataFormat",
			get: function get() {
				return this._dataFormat;
			}
		}, {
			key: "width",
			get: function get() {
				var depthInfo = this._depthInfoCpu || this._depthInfoGpu;
				return depthInfo && depthInfo.width || 0;
			}
		}, {
			key: "height",
			get: function get() {
				var depthInfo = this._depthInfoCpu || this._depthInfoGpu;
				return depthInfo && depthInfo.height || 0;
			}
		}, {
			key: "texture",
			get: function get() {
				return this._texture;
			}
		}, {
			key: "uvMatrix",
			get: function get() {
				return this._matrix;
			}
		}, {
			key: "rawValueToMeters",
			get: function get() {
				var depthInfo = this._depthInfoCpu || this._depthInfoGpu;
				return depthInfo && depthInfo.rawValueToMeters || 0;
			}
		}]);

		return XrDepthSensing;
	}(EventHandler);

	var ids = 0;

	var XrPlane = function (_EventHandler) {
		_inheritsLoose(XrPlane, _EventHandler);

		function XrPlane(planeDetection, xrPlane) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._id = void 0;
			_this._planeDetection = void 0;
			_this._xrPlane = void 0;
			_this._lastChangedTime = void 0;
			_this._orientation = void 0;
			_this._position = new Vec3();
			_this._rotation = new Quat();
			_this._id = ++ids;
			_this._planeDetection = planeDetection;
			_this._xrPlane = xrPlane;
			_this._lastChangedTime = xrPlane.lastChangedTime;
			_this._orientation = xrPlane.orientation;
			return _this;
		}

		var _proto = XrPlane.prototype;

		_proto.destroy = function destroy() {
			this.fire('remove');
		};

		_proto.update = function update(frame) {
			var manager = this._planeDetection._manager;
			var pose = frame.getPose(this._xrPlane.planeSpace, manager._referenceSpace);

			if (pose) {
				this._position.copy(pose.transform.position);

				this._rotation.copy(pose.transform.orientation);
			}

			if (this._lastChangedTime !== this._xrPlane.lastChangedTime) {
				this._lastChangedTime = this._xrPlane.lastChangedTime;
				this.fire('change');
			}
		};

		_proto.getPosition = function getPosition() {
			return this._position;
		};

		_proto.getRotation = function getRotation() {
			return this._rotation;
		};

		_createClass(XrPlane, [{
			key: "id",
			get: function get() {
				return this._id;
			}
		}, {
			key: "orientation",
			get: function get() {
				return this._orientation;
			}
		}, {
			key: "points",
			get: function get() {
				return this._xrPlane.polygon;
			}
		}]);

		return XrPlane;
	}(EventHandler);

	var XrPlaneDetection = function (_EventHandler) {
		_inheritsLoose(XrPlaneDetection, _EventHandler);

		function XrPlaneDetection(manager) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._supported = platform.browser && !!window.XRPlane;
			_this._available = false;
			_this._planesIndex = new Map();
			_this._planes = null;
			_this._manager = manager;

			if (_this._supported) {
				_this._manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
			}

			return _this;
		}

		var _proto = XrPlaneDetection.prototype;

		_proto._onSessionEnd = function _onSessionEnd() {
			if (this._planes) {
				for (var i = 0; i < this._planes.length; i++) {
					this._planes[i].destroy();
				}
			}

			this._planesIndex.clear();

			this._planes = null;

			if (this._available) {
				this._available = false;
				this.fire('unavailable');
			}
		};

		_proto.update = function update(frame) {
			var detectedPlanes;

			if (!this._available) {
				try {
					detectedPlanes = frame.detectedPlanes;
					this._planes = [];
					this._available = true;
					this.fire('available');
				} catch (ex) {
					return;
				}
			} else {
				detectedPlanes = frame.detectedPlanes;
			}

			for (var _iterator = _createForOfIteratorHelperLoose(this._planesIndex), _step; !(_step = _iterator()).done;) {
				var _step$value = _step.value,
						xrPlane = _step$value[0],
						plane = _step$value[1];
				if (detectedPlanes.has(xrPlane)) continue;

				this._planesIndex.delete(xrPlane);

				this._planes.splice(this._planes.indexOf(plane), 1);

				plane.destroy();
				this.fire('remove', plane);
			}

			for (var _iterator2 = _createForOfIteratorHelperLoose(detectedPlanes), _step2; !(_step2 = _iterator2()).done;) {
				var _xrPlane = _step2.value;

				var _plane = this._planesIndex.get(_xrPlane);

				if (!_plane) {
					_plane = new XrPlane(this, _xrPlane);

					this._planesIndex.set(_xrPlane, _plane);

					this._planes.push(_plane);

					_plane.update(frame);

					this.fire('add', _plane);
				} else {
					_plane.update(frame);
				}
			}
		};

		_createClass(XrPlaneDetection, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}, {
			key: "planes",
			get: function get() {
				return this._planes;
			}
		}]);

		return XrPlaneDetection;
	}(EventHandler);

	var XrManager = function (_EventHandler) {
		_inheritsLoose(XrManager, _EventHandler);

		function XrManager(app) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.app = void 0;
			_this._supported = platform.browser && !!navigator.xr;
			_this._available = {};
			_this._type = null;
			_this._spaceType = null;
			_this._session = null;
			_this._baseLayer = null;
			_this._referenceSpace = null;
			_this.depthSensing = void 0;
			_this.domOverlay = void 0;
			_this.hitTest = void 0;
			_this.imageTracking = void 0;
			_this.planeDetection = void 0;
			_this.input = void 0;
			_this.lightEstimation = void 0;
			_this._camera = null;
			_this.views = [];
			_this.viewsPool = [];
			_this._localPosition = new Vec3();
			_this._localRotation = new Quat();
			_this._depthNear = 0.1;
			_this._depthFar = 1000;
			_this._width = 0;
			_this._height = 0;
			_this.app = app;
			_this._available[XRTYPE_INLINE] = false;
			_this._available[XRTYPE_VR] = false;
			_this._available[XRTYPE_AR] = false;
			_this.depthSensing = new XrDepthSensing(_assertThisInitialized(_this));
			_this.domOverlay = new XrDomOverlay(_assertThisInitialized(_this));
			_this.hitTest = new XrHitTest(_assertThisInitialized(_this));
			_this.imageTracking = new XrImageTracking(_assertThisInitialized(_this));
			_this.planeDetection = new XrPlaneDetection(_assertThisInitialized(_this));
			_this.input = new XrInput(_assertThisInitialized(_this));
			_this.lightEstimation = new XrLightEstimation(_assertThisInitialized(_this));

			if (_this._supported) {
				navigator.xr.addEventListener('devicechange', function () {
					_this._deviceAvailabilityCheck();
				});

				_this._deviceAvailabilityCheck();
			}

			return _this;
		}

		var _proto = XrManager.prototype;

		_proto.start = function start(camera, type, spaceType, options) {
			var _this2 = this;

			var callback = options;
			if (typeof options === 'object') callback = options.callback;

			if (!this._available[type]) {
				if (callback) callback(new Error('XR is not available'));
				return;
			}

			if (this._session) {
				if (callback) callback(new Error('XR session is already started'));
				return;
			}

			this._camera = camera;
			this._camera.camera.xr = this;
			this._type = type;
			this._spaceType = spaceType;

			this._setClipPlanes(camera.nearClip, camera.farClip);

			var opts = {
				requiredFeatures: [spaceType],
				optionalFeatures: []
			};

			if (type === XRTYPE_AR) {
				opts.optionalFeatures.push('light-estimation');
				opts.optionalFeatures.push('hit-test');

				if (options) {
					if (options.imageTracking && this.imageTracking.supported) opts.optionalFeatures.push('image-tracking');
					if (options.planeDetection) opts.optionalFeatures.push('plane-detection');
				}

				if (this.domOverlay.supported && this.domOverlay.root) {
					opts.optionalFeatures.push('dom-overlay');
					opts.domOverlay = {
						root: this.domOverlay.root
					};
				}

				if (options && options.depthSensing && this.depthSensing.supported) {
					opts.optionalFeatures.push('depth-sensing');
					var usagePreference = [XRDEPTHSENSINGUSAGE_CPU];
					var dataFormatPreference = [XRDEPTHSENSINGFORMAT_L8A8];

					if (options.depthSensing.usagePreference) {
						var ind = usagePreference.indexOf(options.depthSensing.usagePreference);
						if (ind !== -1) usagePreference.splice(ind, 1);
						usagePreference.unshift(options.depthSensing.usagePreference);
					}

					if (options.depthSensing.dataFormatPreference) {
						var _ind = dataFormatPreference.indexOf(options.depthSensing.dataFormatPreference);

						if (_ind !== -1) dataFormatPreference.splice(_ind, 1);
						dataFormatPreference.unshift(options.depthSensing.dataFormatPreference);
					}

					opts.depthSensing = {
						usagePreference: usagePreference,
						dataFormatPreference: dataFormatPreference
					};
				}
			} else if (type === XRTYPE_VR) {
				opts.optionalFeatures.push('hand-tracking');
			}

			if (options && options.optionalFeatures) opts.optionalFeatures = opts.optionalFeatures.concat(options.optionalFeatures);

			if (this.imageTracking.supported && this.imageTracking.images.length) {
				this.imageTracking.prepareImages(function (err, trackedImages) {
					if (err) {
						if (callback) callback(err);

						_this2.fire('error', err);

						return;
					}

					if (trackedImages !== null) opts.trackedImages = trackedImages;

					_this2._onStartOptionsReady(type, spaceType, opts, callback);
				});
			} else {
				this._onStartOptionsReady(type, spaceType, opts, callback);
			}
		};

		_proto._onStartOptionsReady = function _onStartOptionsReady(type, spaceType, options, callback) {
			var _this3 = this;

			navigator.xr.requestSession(type, options).then(function (session) {
				_this3._onSessionStart(session, spaceType, callback);
			}).catch(function (ex) {
				_this3._camera.camera.xr = null;
				_this3._camera = null;
				_this3._type = null;
				_this3._spaceType = null;
				if (callback) callback(ex);

				_this3.fire('error', ex);
			});
		};

		_proto.end = function end(callback) {
			if (!this._session) {
				if (callback) callback(new Error('XR Session is not initialized'));
				return;
			}

			if (callback) this.once('end', callback);

			this._session.end();
		};

		_proto.isAvailable = function isAvailable(type) {
			return this._available[type];
		};

		_proto._deviceAvailabilityCheck = function _deviceAvailabilityCheck() {
			for (var key in this._available) {
				this._sessionSupportCheck(key);
			}
		};

		_proto._sessionSupportCheck = function _sessionSupportCheck(type) {
			var _this4 = this;

			navigator.xr.isSessionSupported(type).then(function (available) {
				if (_this4._available[type] === available) return;
				_this4._available[type] = available;

				_this4.fire('available', type, available);

				_this4.fire('available:' + type, available);
			}).catch(function (ex) {
				_this4.fire('error', ex);
			});
		};

		_proto._onSessionStart = function _onSessionStart(session, spaceType, callback) {
			var _this5 = this;

			var failed = false;
			this._session = session;

			var onVisibilityChange = function onVisibilityChange() {
				_this5.fire('visibility:change', session.visibilityState);
			};

			var onClipPlanesChange = function onClipPlanesChange() {
				_this5._setClipPlanes(_this5._camera.nearClip, _this5._camera.farClip);
			};

			var onEnd = function onEnd() {
				if (_this5._camera) {
					_this5._camera.off('set_nearClip', onClipPlanesChange);

					_this5._camera.off('set_farClip', onClipPlanesChange);

					_this5._camera.camera.xr = null;
					_this5._camera = null;
				}

				session.removeEventListener('end', onEnd);
				session.removeEventListener('visibilitychange', onVisibilityChange);
				if (!failed) _this5.fire('end');
				_this5._session = null;
				_this5._referenceSpace = null;
				_this5.views = [];
				_this5._width = 0;
				_this5._height = 0;
				_this5._type = null;
				_this5._spaceType = null;

				_this5.app.tick();
			};

			session.addEventListener('end', onEnd);
			session.addEventListener('visibilitychange', onVisibilityChange);

			this._camera.on('set_nearClip', onClipPlanesChange);

			this._camera.on('set_farClip', onClipPlanesChange);

			this._baseLayer = new XRWebGLLayer(session, this.app.graphicsDevice.gl, {
				alpha: true,
				depth: true,
				stencil: true
			});
			session.updateRenderState({
				baseLayer: this._baseLayer,
				depthNear: this._depthNear,
				depthFar: this._depthFar
			});
			session.requestReferenceSpace(spaceType).then(function (referenceSpace) {
				_this5._referenceSpace = referenceSpace;

				_this5.app.tick();

				if (callback) callback(null);

				_this5.fire('start');
			}).catch(function (ex) {
				failed = true;
				session.end();
				if (callback) callback(ex);

				_this5.fire('error', ex);
			});
		};

		_proto._setClipPlanes = function _setClipPlanes(near, far) {
			if (this._depthNear === near && this._depthFar === far) return;
			this._depthNear = near;
			this._depthFar = far;
			if (!this._session) return;

			this._session.updateRenderState({
				depthNear: this._depthNear,
				depthFar: this._depthFar
			});
		};

		_proto.update = function update(frame) {
			if (!this._session) return;
			var width = frame.session.renderState.baseLayer.framebufferWidth;
			var height = frame.session.renderState.baseLayer.framebufferHeight;

			if (this._width !== width || this._height !== height) {
				this._width = width;
				this._height = height;
				this.app.graphicsDevice.setResolution(width, height);
			}

			var pose = frame.getViewerPose(this._referenceSpace);
			var lengthNew = pose ? pose.views.length : 0;

			if (lengthNew > this.views.length) {
				for (var i = 0; i <= lengthNew - this.views.length; i++) {
					var view = this.viewsPool.pop();

					if (!view) {
						view = {
							viewport: new Vec4(),
							projMat: new Mat4(),
							viewMat: new Mat4(),
							viewOffMat: new Mat4(),
							viewInvMat: new Mat4(),
							viewInvOffMat: new Mat4(),
							projViewOffMat: new Mat4(),
							viewMat3: new Mat3(),
							position: new Float32Array(3),
							rotation: new Quat()
						};
					}

					this.views.push(view);
				}
			} else if (lengthNew <= this.views.length) {
				for (var _i = 0; _i < this.views.length - lengthNew; _i++) {
					this.viewsPool.push(this.views.pop());
				}
			}

			if (pose) {
				var posePosition = pose.transform.position;
				var poseOrientation = pose.transform.orientation;

				this._localPosition.set(posePosition.x, posePosition.y, posePosition.z);

				this._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);

				var layer = frame.session.renderState.baseLayer;

				for (var _i2 = 0; _i2 < pose.views.length; _i2++) {
					var viewRaw = pose.views[_i2];
					var _view = this.views[_i2];
					var viewport = layer.getViewport(viewRaw);
					_view.viewport.x = viewport.x;
					_view.viewport.y = viewport.y;
					_view.viewport.z = viewport.width;
					_view.viewport.w = viewport.height;

					_view.projMat.set(viewRaw.projectionMatrix);

					_view.viewMat.set(viewRaw.transform.inverse.matrix);

					_view.viewInvMat.set(viewRaw.transform.matrix);
				}
			}

			this._camera.camera._node.setLocalPosition(this._localPosition);

			this._camera.camera._node.setLocalRotation(this._localRotation);

			this.input.update(frame);

			if (this._type === XRTYPE_AR) {
				if (this.hitTest.supported) this.hitTest.update(frame);
				if (this.lightEstimation.supported) this.lightEstimation.update(frame);
				if (this.depthSensing.supported) this.depthSensing.update(frame, pose && pose.views[0]);
				if (this.imageTracking.supported) this.imageTracking.update(frame);
				if (this.planeDetection.supported) this.planeDetection.update(frame);
			}

			this.fire('update', frame);
		};

		_createClass(XrManager, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "active",
			get: function get() {
				return !!this._session;
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			}
		}, {
			key: "spaceType",
			get: function get() {
				return this._spaceType;
			}
		}, {
			key: "session",
			get: function get() {
				return this._session;
			}
		}, {
			key: "camera",
			get: function get() {
				return this._camera ? this._camera.entity : null;
			}
		}, {
			key: "visibilityState",
			get: function get() {
				if (!this._session) return null;
				return this._session.visibilityState;
			}
		}]);

		return XrManager;
	}(EventHandler);

	var ComponentSystem = function (_EventHandler) {
		_inheritsLoose(ComponentSystem, _EventHandler);

		function ComponentSystem(app) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.app = app;
			_this.store = {};
			_this.schema = [];
			return _this;
		}

		var _proto = ComponentSystem.prototype;

		_proto.addComponent = function addComponent(entity, data) {
			if (data === void 0) {
				data = {};
			}

			var component = new this.ComponentType(this, entity);
			var componentData = new this.DataType();
			this.store[entity.getGuid()] = {
				entity: entity,
				data: componentData
			};
			entity[this.id] = component;
			entity.c[this.id] = component;
			this.initializeComponentData(component, data, []);
			this.fire('add', entity, component);
			return component;
		};

		_proto.removeComponent = function removeComponent(entity) {
			var record = this.store[entity.getGuid()];
			var component = entity.c[this.id];
			this.fire('beforeremove', entity, component);
			delete this.store[entity.getGuid()];
			entity[this.id] = undefined;
			delete entity.c[this.id];
			this.fire('remove', entity, record.data);
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var src = this.store[entity.getGuid()];
			return this.addComponent(clone, src.data);
		};

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data === void 0) {
				data = {};
			}

			for (var i = 0, len = properties.length; i < len; i++) {
				var descriptor = properties[i];
				var name = void 0,
						type = void 0;

				if (typeof descriptor === 'object') {
					name = descriptor.name;
					type = descriptor.type;
				} else {
					name = descriptor;
					type = undefined;
				}

				var value = data[name];

				if (value !== undefined) {
					if (type !== undefined) {
						value = convertValue(value, type);
					}

					component[name] = value;
				} else {
					component[name] = component.data[name];
				}
			}

			if (component.enabled && component.entity.enabled) {
				component.onEnable();
			}
		};

		_proto.getPropertiesOfType = function getPropertiesOfType(type) {
			var matchingProperties = [];
			var schema = this.schema || [];
			schema.forEach(function (descriptor) {
				if (descriptor && typeof descriptor === 'object' && descriptor.type === type) {
					matchingProperties.push(descriptor);
				}
			});
			return matchingProperties;
		};

		_proto.destroy = function destroy() {
			this.off();
		};

		return ComponentSystem;
	}(EventHandler);

	function convertValue(value, type) {
		if (!value) {
			return value;
		}

		switch (type) {
			case 'rgb':
				if (value instanceof Color) {
					return value.clone();
				}

				return new Color(value[0], value[1], value[2]);

			case 'rgba':
				if (value instanceof Color) {
					return value.clone();
				}

				return new Color(value[0], value[1], value[2], value[3]);

			case 'vec2':
				if (value instanceof Vec2) {
					return value.clone();
				}

				return new Vec2(value[0], value[1]);

			case 'vec3':
				if (value instanceof Vec3) {
					return value.clone();
				}

				return new Vec3(value[0], value[1], value[2]);

			case 'vec4':
				if (value instanceof Vec4) {
					return value.clone();
				}

				return new Vec4(value[0], value[1], value[2], value[3]);

			case 'boolean':
			case 'number':
			case 'string':
				return value;

			case 'entity':
				return value;

			default:
				throw new Error('Could not convert unhandled type: ' + type);
		}
	}

	var AnimCache = function () {
		function AnimCache() {
			this._left = Infinity;
			this._right = -Infinity;
			this._len = 0;
			this._recip = 0;
			this._p0 = 0;
			this._p1 = 0;
			this._t = 0;
			this._hermite = {
				valid: false,
				p0: 0,
				m0: 0,
				p1: 0,
				m1: 0
			};
		}

		var _proto = AnimCache.prototype;

		_proto.update = function update(time, input) {
			if (time < this._left || time >= this._right) {
				var len = input.length;

				if (!len) {
					this._left = -Infinity;
					this._right = Infinity;
					this._len = 0;
					this._recip = 0;
					this._p0 = this._p1 = 0;
				} else {
					if (time < input[0]) {
						this._left = -Infinity;
						this._right = input[0];
						this._len = 0;
						this._recip = 0;
						this._p0 = this._p1 = 0;
					} else if (time >= input[len - 1]) {
						this._left = input[len - 1];
						this._right = Infinity;
						this._len = 0;
						this._recip = 0;
						this._p0 = this._p1 = len - 1;
					} else {
						var index = this._findKey(time, input);

						this._left = input[index];
						this._right = input[index + 1];
						this._len = this._right - this._left;
						var diff = 1.0 / this._len;
						this._recip = isFinite(diff) ? diff : 0;
						this._p0 = index;
						this._p1 = index + 1;
					}
				}
			}

			this._t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
			this._hermite.valid = false;
		};

		_proto._findKey = function _findKey(time, input) {
			var index = 0;

			while (time >= input[index + 1]) {
				index++;
			}

			return index;
		};

		_proto.eval = function _eval(result, interpolation, output) {
			var data = output._data;
			var comp = output._components;
			var idx0 = this._p0 * comp;

			if (interpolation === INTERPOLATION_STEP) {
				for (var i = 0; i < comp; ++i) {
					result[i] = data[idx0 + i];
				}
			} else {
				var t = this._t;
				var idx1 = this._p1 * comp;

				switch (interpolation) {
					case INTERPOLATION_LINEAR:
						for (var _i = 0; _i < comp; ++_i) {
							result[_i] = math.lerp(data[idx0 + _i], data[idx1 + _i], t);
						}

						break;

					case INTERPOLATION_CUBIC:
						{
							var hermite = this._hermite;

							if (!hermite.valid) {
								var t2 = t * t;
								var twot = t + t;
								var omt = 1 - t;
								var omt2 = omt * omt;
								hermite.valid = true;
								hermite.p0 = (1 + twot) * omt2;
								hermite.m0 = t * omt2;
								hermite.p1 = t2 * (3 - twot);
								hermite.m1 = t2 * (t - 1);
							}

							var p0 = (this._p0 * 3 + 1) * comp;
							var m0 = (this._p0 * 3 + 2) * comp;
							var p1 = (this._p1 * 3 + 1) * comp;
							var m1 = (this._p1 * 3 + 0) * comp;

							for (var _i2 = 0; _i2 < comp; ++_i2) {
								result[_i2] = hermite.p0 * data[p0 + _i2] + hermite.m0 * data[m0 + _i2] * this._len + hermite.p1 * data[p1 + _i2] + hermite.m1 * data[m1 + _i2] * this._len;
							}

							break;
						}
				}
			}
		};

		return AnimCache;
	}();

	var AnimSnapshot = function AnimSnapshot(animTrack) {
		this._name = animTrack.name + 'Snapshot';
		this._time = -1;
		this._cache = [];
		this._results = [];

		for (var i = 0; i < animTrack._inputs.length; ++i) {
			this._cache[i] = new AnimCache();
		}

		var curves = animTrack._curves;
		var outputs = animTrack._outputs;

		for (var _i = 0; _i < curves.length; ++_i) {
			var curve = curves[_i];
			var output = outputs[curve._output];
			var storage = [];

			for (var j = 0; j < output._components; ++j) {
				storage[j] = 0;
			}

			this._results[_i] = storage;
		}
	};

	var AnimClip = function () {
		function AnimClip(track, time, speed, playing, loop, eventHandler) {
			this._name = track.name;
			this._track = track;
			this._snapshot = new AnimSnapshot(track);
			this._playing = playing;
			this._time = time;
			this._speed = speed;
			this._loop = loop;
			this._blendWeight = 1.0;
			this._blendOrder = 0.0;
			this._eventHandler = eventHandler;
			this._eventCursor = 0;

			while (this._track.events[this._eventCursor] && this._track.events[this._eventCursor].time < this.time) {
				this._eventCursor++;
			}
		}

		var _proto = AnimClip.prototype;

		_proto.activeEventsForFrame = function activeEventsForFrame(frameStartTime, frameEndTime) {
			if (frameStartTime === 0) {
				this.eventCursor = 0;
			}

			var clippedFrameDuration;

			if (frameEndTime > this.track.duration) {
				clippedFrameDuration = frameEndTime - this.track.duration;
				frameEndTime = this.track.duration;
			}

			while (this.track.events[this.eventCursor] && this.track.events[this.eventCursor].time >= frameStartTime && (frameEndTime === this.track.duration ? this.track.events[this.eventCursor].time <= frameEndTime : this.track.events[this.eventCursor].time < frameEndTime)) {
				var event = this.track.events[this.eventCursor];

				this._eventHandler.fire(event.name, _extends({
					track: this.track
				}, event));

				this.eventCursor++;
			}

			if (Number.isFinite(clippedFrameDuration)) {
				this.activeEventsForFrame(0, clippedFrameDuration);
			}
		};

		_proto._update = function _update(deltaTime) {
			if (this._playing) {
				var time = this._time;
				var duration = this._track.duration;
				var speed = this._speed;
				var loop = this._loop;

				if (this._track.events.length > 0 && duration > 0) {
					this.activeEventsForFrame(time, time + speed * deltaTime);
				}

				time += speed * deltaTime;

				if (speed >= 0) {
					if (time > duration) {
						if (loop) {
							time = time % duration || 0;
						} else {
							time = this._track.duration;
							this.pause();
						}
					}
				} else {
					if (time < 0) {
						if (loop) {
							time = duration + (time % duration || 0);
						} else {
							time = 0;
							this.pause();
						}
					}
				}

				this._time = time;
			}

			if (this._time !== this._snapshot._time) {
				this._track.eval(this._time, this._snapshot);
			}
		};

		_proto.play = function play() {
			this._playing = true;
			this._time = 0;
		};

		_proto.stop = function stop() {
			this._playing = false;
			this._time = 0;
		};

		_proto.pause = function pause() {
			this._playing = false;
		};

		_proto.resume = function resume() {
			this._playing = true;
		};

		_proto.reset = function reset() {
			this._time = 0;
		};

		_createClass(AnimClip, [{
			key: "name",
			get: function get() {
				return this._name;
			},
			set: function set(name) {
				this._name = name;
			}
		}, {
			key: "track",
			get: function get() {
				return this._track;
			}
		}, {
			key: "snapshot",
			get: function get() {
				return this._snapshot;
			}
		}, {
			key: "time",
			get: function get() {
				return this._time;
			},
			set: function set(time) {
				this._time = time;
			}
		}, {
			key: "speed",
			get: function get() {
				return this._speed;
			},
			set: function set(speed) {
				this._speed = speed;
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(loop) {
				this._loop = loop;
			}
		}, {
			key: "blendWeight",
			get: function get() {
				return this._blendWeight;
			},
			set: function set(blendWeight) {
				this._blendWeight = blendWeight;
			}
		}, {
			key: "blendOrder",
			get: function get() {
				return this._blendOrder;
			},
			set: function set(blendOrder) {
				this._blendOrder = blendOrder;
			}
		}, {
			key: "eventCursor",
			get: function get() {
				return this._eventCursor;
			},
			set: function set(value) {
				this._eventCursor = value;
			}
		}]);

		return AnimClip;
	}();

	var ANIM_INTERRUPTION_NONE = 'NONE';
	var ANIM_INTERRUPTION_PREV = 'PREV_STATE';
	var ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';
	var ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';
	var ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';
	var ANIM_GREATER_THAN = 'GREATER_THAN';
	var ANIM_LESS_THAN = 'LESS_THAN';
	var ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';
	var ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';
	var ANIM_EQUAL_TO = 'EQUAL_TO';
	var ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';
	var ANIM_PARAMETER_INTEGER = 'INTEGER';
	var ANIM_PARAMETER_FLOAT = 'FLOAT';
	var ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';
	var ANIM_PARAMETER_TRIGGER = 'TRIGGER';
	var ANIM_BLEND_1D = '1D';
	var ANIM_BLEND_2D_DIRECTIONAL = '2D_DIRECTIONAL';
	var ANIM_BLEND_2D_CARTESIAN = '2D_CARTESIAN';
	var ANIM_BLEND_DIRECT = 'DIRECT';
	var ANIM_STATE_START = 'START';
	var ANIM_STATE_END = 'END';
	var ANIM_STATE_ANY = 'ANY';
	var ANIM_CONTROL_STATES = [ANIM_STATE_START, ANIM_STATE_END, ANIM_STATE_ANY];
	var ANIM_LAYER_OVERWRITE = 'OVERWRITE';
	var ANIM_LAYER_ADDITIVE = 'ADDITIVE';

	var AnimTargetValue = function () {
		function AnimTargetValue(component, type) {
			this._component = component;
			this.mask = new Int8Array(component.layers.length);
			this.weights = new Float32Array(component.layers.length);
			this.totalWeight = 0;
			this.counter = 0;
			this.layerCounter = 0;
			this.valueType = type;
			this.dirty = true;
			this.value = [0, 0, 0, 1];
			this.baseValue = null;
			this.setter = null;
		}

		var _proto = AnimTargetValue.prototype;

		_proto.getWeight = function getWeight(index) {
			if (this.dirty) this.updateWeights();

			if (this._normalizeWeights && this.totalWeight === 0 || !this.mask[index]) {
				return 0;
			} else if (this._normalizeWeights) {
				return this.weights[index] / this.totalWeight;
			}

			return math.clamp(this.weights[index], 0, 1);
		};

		_proto._layerBlendType = function _layerBlendType(index) {
			return this._component.layers[index].blendType;
		};

		_proto.setMask = function setMask(index, value) {
			this.mask[index] = value;

			if (this._normalizeWeights) {
				if (this._component.layers[index].blendType === ANIM_LAYER_OVERWRITE) {
					this.mask = this.mask.fill(0, 0, index);
				}

				this.dirty = true;
			}
		};

		_proto.updateWeights = function updateWeights() {
			this.totalWeight = 0;

			for (var i = 0; i < this.weights.length; i++) {
				this.weights[i] = this._component.layers[i].weight;
				this.totalWeight += this.mask[i] * this.weights[i];
			}

			this.dirty = false;
		};

		_proto.updateValue = function updateValue(index, value) {
			if (this.counter === 0) {
				AnimEvaluator._set(this.value, AnimTargetValue.IDENTITY_QUAT_ARR, this.valueType);

				if (!this._normalizeWeights) {
					AnimEvaluator._blend(this.value, this.baseValue, 1, this.valueType);
				}
			}

			if (!this.mask[index] || this.getWeight(index) === 0) return;

			if (this._layerBlendType(index) === ANIM_LAYER_ADDITIVE && !this._normalizeWeights) {
				if (this.valueType === AnimTargetValue.TYPE_QUAT) {
					var v = AnimTargetValue.q1.set(this.value[0], this.value[1], this.value[2], this.value[3]);
					var aV1 = AnimTargetValue.q2.set(this.baseValue[0], this.baseValue[1], this.baseValue[2], this.baseValue[3]);
					var aV2 = AnimTargetValue.q3.set(value[0], value[1], value[2], value[3]);
					var aV = aV1.invert().mul(aV2);
					aV.slerp(Quat.IDENTITY, aV, this.getWeight(index));
					v.mul(aV);
					AnimTargetValue.quatArr[0] = v.x;
					AnimTargetValue.quatArr[1] = v.y;
					AnimTargetValue.quatArr[2] = v.z;
					AnimTargetValue.quatArr[3] = v.w;

					AnimEvaluator._set(this.value, AnimTargetValue.quatArr, this.valueType);
				} else {
					AnimTargetValue.vecArr[0] = value[0] - this.baseValue[0];
					AnimTargetValue.vecArr[1] = value[1] - this.baseValue[1];
					AnimTargetValue.vecArr[2] = value[2] - this.baseValue[2];

					AnimEvaluator._blend(this.value, AnimTargetValue.vecArr, this.getWeight(index), this.valueType, true);
				}
			} else {
				AnimEvaluator._blend(this.value, value, this.getWeight(index), this.valueType);
			}

			this.setter(this.value);
		};

		_proto.unbind = function unbind() {
			if (!this._normalizeWeights) {
				this.setter(this.baseValue);
			}
		};

		_createClass(AnimTargetValue, [{
			key: "_normalizeWeights",
			get: function get() {
				return this._component.normalizeWeights;
			}
		}]);

		return AnimTargetValue;
	}();

	AnimTargetValue.TYPE_QUAT = 'quaternion';
	AnimTargetValue.TYPE_VEC3 = 'vector3';
	AnimTargetValue.q1 = new Quat();
	AnimTargetValue.q2 = new Quat();
	AnimTargetValue.q3 = new Quat();
	AnimTargetValue.quatArr = [0, 0, 0, 1];
	AnimTargetValue.vecArr = [0, 0, 0];
	AnimTargetValue.IDENTITY_QUAT_ARR = [0, 0, 0, 1];

	var AnimEvaluator = function () {
		function AnimEvaluator(binder) {
			this._binder = binder;
			this._clips = [];
			this._inputs = [];
			this._outputs = [];
			this._targets = {};
		}

		AnimEvaluator._dot = function _dot(a, b) {
			var len = a.length;
			var result = 0;

			for (var i = 0; i < len; ++i) {
				result += a[i] * b[i];
			}

			return result;
		};

		AnimEvaluator._normalize = function _normalize(a) {
			var l = AnimEvaluator._dot(a, a);

			if (l > 0) {
				l = 1.0 / Math.sqrt(l);
				var len = a.length;

				for (var i = 0; i < len; ++i) {
					a[i] *= l;
				}
			}
		};

		AnimEvaluator._set = function _set(a, b, type) {
			var len = a.length;

			if (type === 'quaternion') {
				var l = AnimEvaluator._dot(b, b);

				if (l > 0) {
					l = 1.0 / Math.sqrt(l);
				}

				for (var i = 0; i < len; ++i) {
					a[i] = b[i] * l;
				}
			} else {
				for (var _i = 0; _i < len; ++_i) {
					a[_i] = b[_i];
				}
			}
		};

		AnimEvaluator._blendVec = function _blendVec(a, b, t, additive) {
			var it = additive ? 1.0 : 1.0 - t;
			var len = a.length;

			for (var i = 0; i < len; ++i) {
				a[i] = a[i] * it + b[i] * t;
			}
		};

		AnimEvaluator._blendQuat = function _blendQuat(a, b, t, additive) {
			var len = a.length;
			var it = additive ? 1.0 : 1.0 - t;

			if (AnimEvaluator._dot(a, b) < 0) {
				t = -t;
			}

			for (var i = 0; i < len; ++i) {
				a[i] = a[i] * it + b[i] * t;
			}

			if (!additive) {
				AnimEvaluator._normalize(a);
			}
		};

		AnimEvaluator._blend = function _blend(a, b, t, type, additive) {
			if (type === 'quaternion') {
				AnimEvaluator._blendQuat(a, b, t, additive);
			} else {
				AnimEvaluator._blendVec(a, b, t, additive);
			}
		};

		AnimEvaluator._stableSort = function _stableSort(a, lessFunc) {
			var len = a.length;

			for (var i = 0; i < len - 1; ++i) {
				for (var j = i + 1; j < len; ++j) {
					if (lessFunc(a[j], a[i])) {
						var tmp = a[i];
						a[i] = a[j];
						a[j] = tmp;
					}
				}
			}
		};

		var _proto = AnimEvaluator.prototype;

		_proto.addClip = function addClip(clip) {
			var targets = this._targets;
			var binder = this._binder;
			var curves = clip.track.curves;
			var snapshot = clip.snapshot;
			var inputs = [];
			var outputs = [];

			for (var i = 0; i < curves.length; ++i) {
				var curve = curves[i];
				var paths = curve.paths;

				for (var j = 0; j < paths.length; ++j) {
					var path = paths[j];
					var resolved = binder.resolve(path);
					var target = targets[resolved && resolved.targetPath || null];

					if (!target && resolved) {
						target = {
							target: resolved,
							value: [],
							curves: 0,
							blendCounter: 0
						};

						for (var k = 0; k < target.target.components; ++k) {
							target.value.push(0);
						}

						targets[resolved.targetPath] = target;

						if (binder.animComponent) {
							if (!binder.animComponent.targets[resolved.targetPath]) {
								var type = void 0;

								if (resolved.targetPath.substring(resolved.targetPath.length - 13) === 'localRotation') {
									type = AnimTargetValue.TYPE_QUAT;
								} else {
									type = AnimTargetValue.TYPE_VEC3;
								}

								binder.animComponent.targets[resolved.targetPath] = new AnimTargetValue(binder.animComponent, type);
							}

							binder.animComponent.targets[resolved.targetPath].layerCounter++;
							binder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex, 1);
						}
					}

					if (target) {
						target.curves++;
						inputs.push(snapshot._results[i]);
						outputs.push(target);
					}
				}
			}

			this._clips.push(clip);

			this._inputs.push(inputs);

			this._outputs.push(outputs);
		};

		_proto.removeClip = function removeClip(index) {
			var targets = this._targets;
			var binder = this._binder;
			var clips = this._clips;
			var clip = clips[index];
			var curves = clip.track.curves;

			for (var i = 0; i < curves.length; ++i) {
				var curve = curves[i];
				var paths = curve.paths;

				for (var j = 0; j < paths.length; ++j) {
					var path = paths[j];

					var target = this._binder.resolve(path);

					if (target) {
						target.curves--;

						if (target.curves === 0) {
							binder.unresolve(path);
							delete targets[target.targetPath];

							if (binder.animComponent) {
								binder.animComponent.targets[target.targetPath].layerCounter--;
							}
						}
					}
				}
			}

			clips.splice(index, 1);

			this._inputs.splice(index, 1);

			this._outputs.splice(index, 1);
		};

		_proto.removeClips = function removeClips() {
			while (this._clips.length > 0) {
				this.removeClip(0);
			}
		};

		_proto.findClip = function findClip(name) {
			var clips = this._clips;

			for (var i = 0; i < clips.length; ++i) {
				var clip = clips[i];

				if (clip.name === name) {
					return clip;
				}
			}

			return null;
		};

		_proto.rebind = function rebind() {
			var _this = this;

			this._binder.rebind();

			this._targets = {};
			var clips = [].concat(this.clips);
			this.removeClips();
			clips.forEach(function (clip) {
				_this.addClip(clip);
			});
		};

		_proto.assignMask = function assignMask(mask) {
			return this._binder.assignMask(mask);
		};

		_proto.update = function update(deltaTime) {
			var clips = this._clips;
			var order = clips.map(function (c, i) {
				return i;
			});

			AnimEvaluator._stableSort(order, function (a, b) {
				return clips[a].blendOrder < clips[b].blendOrder;
			});

			for (var i = 0; i < order.length; ++i) {
				var index = order[i];
				var clip = clips[index];
				var inputs = this._inputs[index];
				var outputs = this._outputs[index];
				var blendWeight = clip.blendWeight;

				if (blendWeight > 0.0) {
					clip._update(deltaTime);
				}

				var input = void 0;
				var output = void 0;
				var value = void 0;

				if (blendWeight >= 1.0) {
					for (var j = 0; j < inputs.length; ++j) {
						input = inputs[j];
						output = outputs[j];
						value = output.value;

						AnimEvaluator._set(value, input, output.target.type);

						output.blendCounter++;
					}
				} else if (blendWeight > 0.0) {
					for (var _j = 0; _j < inputs.length; ++_j) {
						input = inputs[_j];
						output = outputs[_j];
						value = output.value;

						if (output.blendCounter === 0) {
							AnimEvaluator._set(value, input, output.target.type);
						} else {
							AnimEvaluator._blend(value, input, blendWeight, output.target.type);
						}

						output.blendCounter++;
					}
				}
			}

			var targets = this._targets;
			var binder = this._binder;

			for (var path in targets) {
				if (targets.hasOwnProperty(path)) {
					var target = targets[path];

					if (binder.animComponent && target.target.isTransform) {
						var animTarget = binder.animComponent.targets[path];

						if (animTarget.counter === animTarget.layerCounter) {
							animTarget.counter = 0;
						}

						if (!animTarget.path) {
							animTarget.path = path;
							animTarget.baseValue = target.target.get();
							animTarget.setter = target.target.set;
						}

						animTarget.updateValue(binder.layerIndex, target.value);
						animTarget.counter++;
					} else {
						target.target.set(target.value);
					}

					target.blendCounter = 0;
				}
			}

			binder.update(deltaTime);
		};

		_createClass(AnimEvaluator, [{
			key: "clips",
			get: function get() {
				return this._clips;
			}
		}]);

		return AnimEvaluator;
	}();

	var AnimBinder = function () {
		function AnimBinder() {}

		AnimBinder.joinPath = function joinPath(pathSegments, character) {
			character = character || '.';

			var escape = function escape(string) {
				return string.replace(/\\/g, '\\\\').replace(new RegExp('\\' + character, 'g'), '\\' + character);
			};

			return pathSegments.map(escape).join(character);
		};

		AnimBinder.splitPath = function splitPath(path, character) {
			character = character || '.';
			var result = [];
			var curr = "";
			var i = 0;

			while (i < path.length) {
				var c = path[i++];

				if (c === '\\' && i < path.length) {
					c = path[i++];

					if (c === '\\' || c === character) {
						curr += c;
					} else {
						curr += '\\' + c;
					}
				} else if (c === character) {
					result.push(curr);
					curr = '';
				} else {
					curr += c;
				}
			}

			if (curr.length > 0) {
				result.push(curr);
			}

			return result;
		};

		AnimBinder.encode = function encode(entityPath, component, propertyPath) {
			return (Array.isArray(entityPath) ? entityPath.join('/') : entityPath) + "/" + component + "/" + (Array.isArray(propertyPath) ? propertyPath.join('/') : propertyPath);
		};

		var _proto = AnimBinder.prototype;

		_proto.resolve = function resolve(path) {
			return null;
		};

		_proto.unresolve = function unresolve(path) {};

		_proto.update = function update(deltaTime) {};

		return AnimBinder;
	}();

	var AnimTarget = function () {
		function AnimTarget(func, type, components, targetPath) {
			if (func.set) {
				this._set = func.set;
				this._get = func.get;
			} else {
				this._set = func;
			}

			this._type = type;
			this._components = components;
			this._targetPath = targetPath;
			this._isTransform = this._targetPath.substring(this._targetPath.length - 13) === 'localRotation' || this._targetPath.substring(this._targetPath.length - 13) === 'localPosition' || this._targetPath.substring(this._targetPath.length - 10) === 'localScale';
		}

		_createClass(AnimTarget, [{
			key: "set",
			get: function get() {
				return this._set;
			}
		}, {
			key: "get",
			get: function get() {
				return this._get;
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			}
		}, {
			key: "components",
			get: function get() {
				return this._components;
			}
		}, {
			key: "targetPath",
			get: function get() {
				return this._targetPath;
			}
		}, {
			key: "isTransform",
			get: function get() {
				return this._isTransform;
			}
		}]);

		return AnimTarget;
	}();

	var DefaultAnimBinder = function () {
		function DefaultAnimBinder(graph) {
			var _this = this;

			this._isPathInMask = function (path, checkMaskValue) {
				var maskItem = _this._mask[path];
				if (!maskItem) return false;else if (maskItem.children || checkMaskValue && maskItem.value !== false) return true;
				return false;
			};

			this.graph = graph;
			if (!graph) return;
			this._mask = null;
			var nodes = {};

			var flatten = function flatten(node) {
				nodes[node.name] = node;

				for (var i = 0; i < node.children.length; ++i) {
					flatten(node.children[i]);
				}
			};

			flatten(graph);
			this.nodes = nodes;
			this.targetCache = {};
			this.visitedFallbackGraphPaths = {};

			var findMeshInstances = function findMeshInstances(node) {
				var object = node;

				while (object && !(object instanceof Entity)) {
					object = object.parent;
				}

				var meshInstances;

				if (object) {
					if (object.render) {
						meshInstances = object.render.meshInstances;
					} else if (object.model) {
						meshInstances = object.model.meshInstances;
					}
				}

				return meshInstances;
			};

			this.nodeCounts = {};
			this.activeNodes = [];
			this.handlers = {
				'localPosition': function localPosition(node) {
					var object = node.localPosition;

					var func = function func(value) {
						object.set.apply(object, value);
					};

					return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localPosition');
				},
				'localRotation': function localRotation(node) {
					var object = node.localRotation;

					var func = function func(value) {
						object.set.apply(object, value);
					};

					return DefaultAnimBinder.createAnimTarget(func, 'quaternion', 4, node, 'localRotation');
				},
				'localScale': function localScale(node) {
					var object = node.localScale;

					var func = function func(value) {
						object.set.apply(object, value);
					};

					return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localScale');
				},
				'weights': function weights(node) {
					var meshInstances = findMeshInstances(node);

					if (meshInstances) {
						var morphInstances = [];

						for (var i = 0; i < meshInstances.length; ++i) {
							if (meshInstances[i].node.name === node.name && meshInstances[i].morphInstance) {
								morphInstances.push(meshInstances[i].morphInstance);
							}
						}

						if (morphInstances.length > 0) {
							var func = function func(value) {
								for (var _i = 0; _i < value.length; ++_i) {
									for (var j = 0; j < morphInstances.length; j++) {
										morphInstances[j].setWeight(_i, value[_i]);
									}
								}
							};

							return DefaultAnimBinder.createAnimTarget(func, 'vector', morphInstances[0].morph._targets.length, node, 'weights');
						}
					}

					return null;
				},
				'materialTexture': function materialTexture(node, textureName) {
					var meshInstances = findMeshInstances(node);

					if (meshInstances) {
						var meshInstance;

						for (var i = 0; i < meshInstances.length; ++i) {
							if (meshInstances[i].node.name === node.name) {
								meshInstance = meshInstances[i];
								break;
							}
						}

						if (meshInstance) {
							var func = function func(value) {
								var textureAsset = _this.animComponent.system.app.assets.get(value[0]);

								if (textureAsset && textureAsset.resource && textureAsset.type === 'texture') {
									meshInstance.material[textureName] = textureAsset.resource;
									meshInstance.material.update();
								}
							};

							return DefaultAnimBinder.createAnimTarget(func, 'vector', 1, node, 'materialTexture', 'material');
						}
					}

					return null;
				}
			};
		}

		var _proto = DefaultAnimBinder.prototype;

		_proto._isPathActive = function _isPathActive(path) {
			if (!this._mask) return true;
			var rootNodeNames = [path.entityPath[0], this.graph.name];

			for (var j = 0; j < rootNodeNames.length; ++j) {
				var currEntityPath = rootNodeNames[j];
				if (this._isPathInMask(currEntityPath, path.entityPath.length === 1)) return true;

				for (var i = 1; i < path.entityPath.length; i++) {
					currEntityPath += '/' + path.entityPath[i];
					if (this._isPathInMask(currEntityPath, i === path.entityPath.length - 1)) return true;
				}
			}

			return false;
		};

		_proto.findNode = function findNode(path) {
			if (!this._isPathActive(path)) {
				return null;
			}

			var node;

			if (this.graph) {
				node = this.graph.findByPath(path.entityPath);
			}

			if (!node) {
				node = this.nodes[path.entityPath[path.entityPath.length - 1] || ""];
				var fallbackGraphPath = AnimBinder.encode(path.entityPath[path.entityPath.length - 1] || "", 'graph', path.propertyPath);

				if (this.visitedFallbackGraphPaths[fallbackGraphPath] === 1) {
					Debug.warn("Anim Binder: Multiple animation curves with the path " + fallbackGraphPath + " are present in the " + this.graph.path + " graph which may result in the incorrect binding of animations");
				}

				if (!Number.isFinite(this.visitedFallbackGraphPaths[fallbackGraphPath])) {
					this.visitedFallbackGraphPaths[fallbackGraphPath] = 0;
				} else {
					this.visitedFallbackGraphPaths[fallbackGraphPath]++;
				}
			}

			return node;
		};

		DefaultAnimBinder.createAnimTarget = function createAnimTarget(func, type, valueCount, node, propertyPath, componentType) {
			var targetPath = AnimBinder.encode(node.path, componentType ? componentType : 'entity', propertyPath);
			return new AnimTarget(func, type, valueCount, targetPath);
		};

		_proto.resolve = function resolve(path) {
			var encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
			var target = this.targetCache[encodedPath];
			if (target) return target;
			var node = this.findNode(path);

			if (!node) {
				return null;
			}

			var handler = this.handlers[path.propertyPath];

			if (!handler) {
				return null;
			}

			target = handler(node);

			if (!target) {
				return null;
			}

			this.targetCache[encodedPath] = target;

			if (!this.nodeCounts[node.path]) {
				this.activeNodes.push(node);
				this.nodeCounts[node.path] = 1;
			} else {
				this.nodeCounts[node.path]++;
			}

			return target;
		};

		_proto.unresolve = function unresolve(path) {
			if (path.component !== 'graph') return;
			var node = this.nodes[path.entityPath[path.entityPath.length - 1] || ""];
			this.nodeCounts[node.path]--;

			if (this.nodeCounts[node.path] === 0) {
				var activeNodes = this.activeNodes;
				var i = activeNodes.indexOf(node.node);
				var len = activeNodes.length;

				if (i < len - 1) {
					activeNodes[i] = activeNodes[len - 1];
				}

				activeNodes.pop();
			}
		};

		_proto.update = function update(deltaTime) {
			var activeNodes = this.activeNodes;

			for (var i = 0; i < activeNodes.length; ++i) {
				activeNodes[i]._dirtifyLocal();
			}
		};

		_proto.assignMask = function assignMask(mask) {
			if (mask !== this._mask) {
				this._mask = mask;
				return true;
			}

			return false;
		};

		return DefaultAnimBinder;
	}();

	var InterpolatedKey = function () {
		function InterpolatedKey() {
			this._written = false;
			this._name = "";
			this._keyFrames = [];
			this._quat = new Quat();
			this._pos = new Vec3();
			this._scale = new Vec3();
			this._targetNode = null;
		}

		var _proto = InterpolatedKey.prototype;

		_proto.getTarget = function getTarget() {
			return this._targetNode;
		};

		_proto.setTarget = function setTarget(node) {
			this._targetNode = node;
		};

		return InterpolatedKey;
	}();

	var Skeleton = function () {
		function Skeleton(graph) {
			var _this = this;

			this.looping = true;
			this._animation = null;
			this._time = 0;
			this._interpolatedKeys = [];
			this._interpolatedKeyDict = {};
			this._currKeyIndices = {};
			this.graph = null;

			var addInterpolatedKeys = function addInterpolatedKeys(node) {
				var interpKey = new InterpolatedKey();
				interpKey._name = node.name;

				_this._interpolatedKeys.push(interpKey);

				_this._interpolatedKeyDict[node.name] = interpKey;
				_this._currKeyIndices[node.name] = 0;

				for (var i = 0; i < node._children.length; i++) {
					addInterpolatedKeys(node._children[i]);
				}
			};

			addInterpolatedKeys(graph);
		}

		var _proto2 = Skeleton.prototype;

		_proto2.addTime = function addTime(delta) {
			if (this._animation !== null) {
				var nodes = this._animation._nodes;
				var duration = this._animation.duration;

				if (this._time === duration && !this.looping) {
					return;
				}

				this._time += delta;

				if (this._time > duration) {
					this._time = this.looping ? 0.0 : duration;

					for (var i = 0; i < nodes.length; i++) {
						var node = nodes[i];
						var nodeName = node._name;
						this._currKeyIndices[nodeName] = 0;
					}
				} else if (this._time < 0) {
					this._time = this.looping ? duration : 0.0;

					for (var _i = 0; _i < nodes.length; _i++) {
						var _node = nodes[_i];
						var _nodeName = _node._name;
						this._currKeyIndices[_nodeName] = _node._keys.length - 2;
					}
				}

				var offset = delta >= 0 ? 1 : -1;

				for (var _i2 = 0; _i2 < nodes.length; _i2++) {
					var _node2 = nodes[_i2];
					var _nodeName2 = _node2._name;
					var keys = _node2._keys;
					var interpKey = this._interpolatedKeyDict[_nodeName2];

					if (interpKey === undefined) {
						Debug.warn("Unknown skeleton node name: " + _nodeName2);
						continue;
					}

					var foundKey = false;

					if (keys.length !== 1) {
						for (var currKeyIndex = this._currKeyIndices[_nodeName2]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset) {
							var k1 = keys[currKeyIndex];
							var k2 = keys[currKeyIndex + 1];

							if (k1.time <= this._time && k2.time >= this._time) {
								var alpha = (this._time - k1.time) / (k2.time - k1.time);

								interpKey._pos.lerp(k1.position, k2.position, alpha);

								interpKey._quat.slerp(k1.rotation, k2.rotation, alpha);

								interpKey._scale.lerp(k1.scale, k2.scale, alpha);

								interpKey._written = true;
								this._currKeyIndices[_nodeName2] = currKeyIndex;
								foundKey = true;
								break;
							}
						}
					}

					if (keys.length === 1 || !foundKey && this._time === 0.0 && this.looping) {
						interpKey._pos.copy(keys[0].position);

						interpKey._quat.copy(keys[0].rotation);

						interpKey._scale.copy(keys[0].scale);

						interpKey._written = true;
					}
				}
			}
		};

		_proto2.blend = function blend(skel1, skel2, alpha) {
			var numNodes = this._interpolatedKeys.length;

			for (var i = 0; i < numNodes; i++) {
				var key1 = skel1._interpolatedKeys[i];
				var key2 = skel2._interpolatedKeys[i];
				var dstKey = this._interpolatedKeys[i];

				if (key1._written && key2._written) {
					dstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);

					dstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);

					dstKey._scale.lerp(key1._scale, key2._scale, alpha);

					dstKey._written = true;
				} else if (key1._written) {
					dstKey._quat.copy(key1._quat);

					dstKey._pos.copy(key1._pos);

					dstKey._scale.copy(key1._scale);

					dstKey._written = true;
				} else if (key2._written) {
					dstKey._quat.copy(key2._quat);

					dstKey._pos.copy(key2._pos);

					dstKey._scale.copy(key2._scale);

					dstKey._written = true;
				}
			}
		};

		_proto2.setGraph = function setGraph(graph) {
			this.graph = graph;

			if (graph) {
				for (var i = 0; i < this._interpolatedKeys.length; i++) {
					var interpKey = this._interpolatedKeys[i];
					var graphNode = graph.findByName(interpKey._name);

					this._interpolatedKeys[i].setTarget(graphNode);
				}
			} else {
				for (var _i3 = 0; _i3 < this._interpolatedKeys.length; _i3++) {
					this._interpolatedKeys[_i3].setTarget(null);
				}
			}
		};

		_proto2.updateGraph = function updateGraph() {
			if (this.graph) {
				for (var i = 0; i < this._interpolatedKeys.length; i++) {
					var interpKey = this._interpolatedKeys[i];

					if (interpKey._written) {
						var transform = interpKey.getTarget();
						transform.localPosition.copy(interpKey._pos);
						transform.localRotation.copy(interpKey._quat);
						transform.localScale.copy(interpKey._scale);
						if (!transform._dirtyLocal) transform._dirtifyLocal();
						interpKey._written = false;
					}
				}
			}
		};

		_createClass(Skeleton, [{
			key: "animation",
			get: function get() {
				return this._animation;
			},
			set: function set(value) {
				this._animation = value;
				this.currentTime = 0;
			}
		}, {
			key: "currentTime",
			get: function get() {
				return this._time;
			},
			set: function set(value) {
				this._time = value;
				var numNodes = this._interpolatedKeys.length;

				for (var i = 0; i < numNodes; i++) {
					var node = this._interpolatedKeys[i];
					var nodeName = node._name;
					this._currKeyIndices[nodeName] = 0;
				}

				this.addTime(0);
				this.updateGraph();
			}
		}, {
			key: "numNodes",
			get: function get() {
				return this._interpolatedKeys.length;
			}
		}]);

		return Skeleton;
	}();

	var AnimationComponent = function (_Component) {
		_inheritsLoose(AnimationComponent, _Component);

		function AnimationComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this.animationsIndex = {};

			_this.on('set_animations', _this.onSetAnimations, _assertThisInitialized(_this));

			_this.on('set_assets', _this.onSetAssets, _assertThisInitialized(_this));

			_this.on('set_loop', _this.onSetLoop, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = AnimationComponent.prototype;

		_proto.play = function play(name, blendTime) {
			if (blendTime === void 0) {
				blendTime = 0;
			}

			if (!this.enabled || !this.entity.enabled) {
				return;
			}

			var data = this.data;

			if (!data.animations[name]) {
				Debug.error("Trying to play animation '" + name + "' which doesn't exist");
				return;
			}

			data.prevAnim = data.currAnim;
			data.currAnim = name;

			if (data.model) {
				if (!data.skeleton && !data.animEvaluator) {
					this._createAnimationController();
				}

				var prevAnim = data.animations[data.prevAnim];
				var currAnim = data.animations[data.currAnim];
				data.blending = blendTime > 0 && data.prevAnim;

				if (data.blending) {
					data.blend = 0;
					data.blendSpeed = 1.0 / blendTime;
				}

				if (data.skeleton) {
					if (data.blending) {
						data.fromSkel.animation = prevAnim;
						data.fromSkel.addTime(data.skeleton._time);
						data.toSkel.animation = currAnim;
					} else {
						data.skeleton.animation = currAnim;
					}
				}

				if (data.animEvaluator) {
					var animEvaluator = data.animEvaluator;

					if (data.blending) {
						while (animEvaluator.clips.length > 1) {
							animEvaluator.removeClip(0);
						}
					} else {
						data.animEvaluator.removeClips();
					}

					var clip = new AnimClip(data.animations[data.currAnim], 0, 1.0, true, data.loop);
					clip.name = data.currAnim;
					clip.blendWeight = data.blending ? 0 : 1;
					clip.reset();
					data.animEvaluator.addClip(clip);
				}
			}

			data.playing = true;
		};

		_proto.getAnimation = function getAnimation(name) {
			return this.data.animations[name];
		};

		_proto.setModel = function setModel(model) {
			var data = this.data;

			if (model !== data.model) {
				this._resetAnimationController();

				data.model = model;

				if (data.animations && data.currAnim && data.animations[data.currAnim]) {
					this.play(data.currAnim);
				}
			}
		};

		_proto._resetAnimationController = function _resetAnimationController() {
			var data = this.data;
			data.skeleton = null;
			data.fromSkel = null;
			data.toSkel = null;
			data.animEvaluator = null;
		};

		_proto._createAnimationController = function _createAnimationController() {
			var data = this.data;
			var model = data.model;
			var animations = data.animations;
			var hasJson = false;
			var hasGlb = false;

			for (var animation in animations) {
				if (animations.hasOwnProperty(animation)) {
					var anim = animations[animation];

					if (anim.constructor === AnimTrack) {
						hasGlb = true;
					} else {
						hasJson = true;
					}
				}
			}

			var graph = model.getGraph();

			if (hasJson) {
				data.fromSkel = new Skeleton(graph);
				data.toSkel = new Skeleton(graph);
				data.skeleton = new Skeleton(graph);
				data.skeleton.looping = data.loop;
				data.skeleton.setGraph(graph);
			} else if (hasGlb) {
				data.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(this.entity));
			}
		};

		_proto.loadAnimationAssets = function loadAnimationAssets(ids) {
			var _this2 = this;

			if (!ids || !ids.length) return;
			var assets = this.system.app.assets;

			var onAssetReady = function onAssetReady(asset) {
				if (asset.resources.length > 1) {
					for (var i = 0; i < asset.resources.length; i++) {
						_this2.animations[asset.resources[i].name] = asset.resources[i];
						_this2.animationsIndex[asset.id] = asset.resources[i].name;
					}
				} else {
					_this2.animations[asset.name] = asset.resource;
					_this2.animationsIndex[asset.id] = asset.name;
				}

				_this2.animations = _this2.animations;
			};

			var onAssetAdd = function onAssetAdd(asset) {
				asset.off('change', _this2.onAssetChanged, _this2);
				asset.on('change', _this2.onAssetChanged, _this2);
				asset.off('remove', _this2.onAssetRemoved, _this2);
				asset.on('remove', _this2.onAssetRemoved, _this2);

				if (asset.resource) {
					onAssetReady(asset);
				} else {
					asset.once('load', onAssetReady, _this2);
					if (_this2.enabled && _this2.entity.enabled) assets.load(asset);
				}
			};

			for (var i = 0, l = ids.length; i < l; i++) {
				var asset = assets.get(ids[i]);

				if (asset) {
					onAssetAdd(asset);
				} else {
					assets.on('add:' + ids[i], onAssetAdd);
				}
			}
		};

		_proto.onAssetChanged = function onAssetChanged(asset, attribute, newValue, oldValue) {
			if (attribute === 'resource' || attribute === 'resources') {
				if (attribute === 'resources' && newValue && newValue.length === 0) {
					newValue = null;
				}

				if (newValue) {
					var restarted = false;

					if (newValue.length > 1) {
						if (oldValue && oldValue.length > 1) {
							for (var i = 0; i < oldValue.length; i++) {
								delete this.animations[oldValue[i].name];
							}
						} else {
							delete this.animations[asset.name];
						}

						restarted = false;

						for (var _i = 0; _i < newValue.length; _i++) {
							this.animations[newValue[_i].name] = newValue[_i];

							if (!restarted && this.data.currAnim === newValue[_i].name) {
								if (this.data.playing && this.data.enabled && this.entity.enabled) {
									restarted = true;
									this.play(newValue[_i].name);
								}
							}
						}

						if (!restarted) {
							this._stopCurrentAnimation();

							this.onSetAnimations();
						}
					} else {
						if (oldValue && oldValue.length > 1) {
							for (var _i2 = 0; _i2 < oldValue.length; _i2++) {
								delete this.animations[oldValue[_i2].name];
							}
						}

						this.animations[asset.name] = newValue[0] || newValue;
						restarted = false;

						if (this.data.currAnim === asset.name) {
							if (this.data.playing && this.data.enabled && this.entity.enabled) {
								restarted = true;
								this.play(asset.name);
							}
						}

						if (!restarted) {
							this._stopCurrentAnimation();

							this.onSetAnimations();
						}
					}

					this.animationsIndex[asset.id] = asset.name;
				} else {
					if (oldValue.length > 1) {
						for (var _i3 = 0; _i3 < oldValue.length; _i3++) {
							delete this.animations[oldValue[_i3].name];

							if (this.data.currAnim === oldValue[_i3].name) {
								this._stopCurrentAnimation();
							}
						}
					} else {
						delete this.animations[asset.name];

						if (this.data.currAnim === asset.name) {
							this._stopCurrentAnimation();
						}
					}

					delete this.animationsIndex[asset.id];
				}
			}
		};

		_proto.onAssetRemoved = function onAssetRemoved(asset) {
			asset.off('remove', this.onAssetRemoved, this);

			if (this.animations) {
				if (asset.resources.length > 1) {
					for (var i = 0; i < asset.resources.length; i++) {
						delete this.animations[asset.resources[i].name];
						if (this.data.currAnim === asset.resources[i].name) this._stopCurrentAnimation();
					}
				} else {
					delete this.animations[asset.name];
					if (this.data.currAnim === asset.name) this._stopCurrentAnimation();
				}

				delete this.animationsIndex[asset.id];
			}
		};

		_proto._stopCurrentAnimation = function _stopCurrentAnimation() {
			var data = this.data;
			data.currAnim = null;
			data.playing = false;

			if (data.skeleton) {
				data.skeleton.currentTime = 0;
				data.skeleton.animation = null;
			}

			if (data.animEvaluator) {
				for (var i = 0; i < data.animEvaluator.clips.length; ++i) {
					data.animEvaluator.clips[i].stop();
				}

				data.animEvaluator.update(0);
				data.animEvaluator.removeClips();
			}
		};

		_proto.onSetAnimations = function onSetAnimations(name, oldValue, newValue) {
			var data = this.data;
			var modelComponent = this.entity.model;

			if (modelComponent) {
				var m = modelComponent.model;

				if (m && m !== data.model) {
					this.setModel(m);
				}
			}

			if (!data.currAnim && data.activate && data.enabled && this.entity.enabled) {
				var animationNames = Object.keys(data.animations);

				if (animationNames.length > 0) {
					this.play(animationNames[0]);
				}
			}
		};

		_proto.onSetAssets = function onSetAssets(name, oldValue, newValue) {
			if (oldValue && oldValue.length) {
				for (var i = 0; i < oldValue.length; i++) {
					if (oldValue[i]) {
						var asset = this.system.app.assets.get(oldValue[i]);

						if (asset) {
							asset.off('change', this.onAssetChanged, this);
							asset.off('remove', this.onAssetRemoved, this);
							var animName = this.animationsIndex[asset.id];
							if (this.data.currAnim === animName) this._stopCurrentAnimation();
							delete this.animations[animName];
							delete this.animationsIndex[asset.id];
						}
					}
				}
			}

			var ids = newValue.map(function (value) {
				return value instanceof Asset ? value.id : value;
			});
			this.loadAnimationAssets(ids);
		};

		_proto.onSetLoop = function onSetLoop(name, oldValue, newValue) {
			var data = this.data;

			if (data.skeleton) {
				data.skeleton.looping = data.loop;
			}

			if (data.animEvaluator) {
				for (var i = 0; i < data.animEvaluator.clips.length; ++i) {
					data.animEvaluator.clips[i].loop = data.loop;
				}
			}
		};

		_proto.onEnable = function onEnable() {
			_Component.prototype.onEnable.call(this);

			var data = this.data;
			var assets = data.assets;
			var registry = this.system.app.assets;

			if (assets) {
				for (var i = 0, len = assets.length; i < len; i++) {
					var asset = assets[i];
					if (!(asset instanceof Asset)) asset = registry.get(asset);
					if (asset && !asset.resource) registry.load(asset);
				}
			}

			if (data.activate && !data.currAnim) {
				var animationNames = Object.keys(data.animations);

				if (animationNames.length > 0) {
					this.play(animationNames[0]);
				}
			}
		};

		_proto.onBeforeRemove = function onBeforeRemove() {
			for (var i = 0; i < this.assets.length; i++) {
				var asset = this.assets[i];

				if (typeof asset === 'number') {
					asset = this.system.app.assets.get(asset);
				}

				if (!asset) continue;
				asset.off('change', this.onAssetChanged, this);
				asset.off('remove', this.onAssetRemoved, this);
			}

			var data = this.data;
			delete data.animation;
			delete data.skeleton;
			delete data.fromSkel;
			delete data.toSkel;
			delete data.animEvaluator;
		};

		_createClass(AnimationComponent, [{
			key: "currentTime",
			get: function get() {
				var data = this.data;

				if (data.skeleton) {
					return this.data.skeleton._time;
				}

				if (data.animEvaluator) {
					var clips = data.animEvaluator.clips;

					if (clips.length > 0) {
						return clips[clips.length - 1].time;
					}
				}

				return 0;
			},
			set: function set(currentTime) {
				var data = this.data;

				if (data.skeleton) {
					var skeleton = data.skeleton;
					skeleton.currentTime = currentTime;
					skeleton.addTime(0);
					skeleton.updateGraph();
				}

				if (data.animEvaluator) {
					var animEvaluator = data.animEvaluator;

					for (var i = 0; i < animEvaluator.clips.length; ++i) {
						animEvaluator.clips[i].time = currentTime;
					}
				}
			}
		}, {
			key: "duration",
			get: function get() {
				return this.data.animations[this.data.currAnim].duration;
			}
		}]);

		return AnimationComponent;
	}(Component);

	var AnimationComponentData = function AnimationComponentData() {
		this.assets = [];
		this.speed = 1.0;
		this.loop = true;
		this.activate = true;
		this.enabled = true;
		this.animations = {};
		this.model = null;
		this.prevAnim = null;
		this.currAnim = null;
		this.blending = false;
		this.blend = 0;
		this.blendSpeed = 0;
		this.playing = false;
		this.skeleton = null;
		this.fromSkel = null;
		this.toSkel = null;
		this.animEvaluator = null;
	};

	var _schema$l = ['enabled', 'assets', 'speed', 'loop', 'activate', 'animations', 'skeleton', 'model', 'prevAnim', 'currAnim', 'fromSkel', 'toSkel', 'blending', 'blendTimeRemaining', 'playing'];

	var AnimationComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(AnimationComponentSystem, _ComponentSystem);

		function AnimationComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'animation';
			_this.ComponentType = AnimationComponent;
			_this.DataType = AnimationComponentData;
			_this.schema = _schema$l;

			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = AnimationComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['activate', 'enabled', 'loop', 'speed', 'assets'];

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			this.addComponent(clone, {});
			clone.animation.assets = entity.animation.assets.slice();
			clone.animation.data.speed = entity.animation.speed;
			clone.animation.data.loop = entity.animation.loop;
			clone.animation.data.activate = entity.animation.activate;
			clone.animation.data.enabled = entity.animation.enabled;
			var clonedAnimations = {};
			var animations = entity.animation.animations;

			for (var key in animations) {
				if (animations.hasOwnProperty(key)) {
					clonedAnimations[key] = animations[key];
				}
			}

			clone.animation.animations = clonedAnimations;
			var clonedAnimationsIndex = {};
			var animationsIndex = entity.animation.animationsIndex;

			for (var _key in animationsIndex) {
				if (animationsIndex.hasOwnProperty(_key)) {
					clonedAnimationsIndex[_key] = animationsIndex[_key];
				}
			}

			clone.animation.animationsIndex = clonedAnimationsIndex;
			return clone.animation;
		};

		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			component.onBeforeRemove();
		};

		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;

			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					var componentData = component.data;

					if (componentData.enabled && component.entity.enabled) {
						if (componentData.blending) {
							componentData.blend += dt * componentData.blendSpeed;

							if (componentData.blend >= 1.0) {
								componentData.blend = 1.0;
							}
						}

						if (componentData.playing) {
							var skeleton = componentData.skeleton;

							if (skeleton !== null && componentData.model !== null) {
								if (componentData.blending) {
									skeleton.blend(componentData.fromSkel, componentData.toSkel, componentData.blend);
								} else {
									var delta = dt * componentData.speed;
									skeleton.addTime(delta);

									if (componentData.speed > 0 && skeleton._time === skeleton._animation.duration && !componentData.loop) {
										componentData.playing = false;
									} else if (componentData.speed < 0 && skeleton._time === 0 && !componentData.loop) {
										componentData.playing = false;
									}
								}

								if (componentData.blending && componentData.blend === 1.0) {
									skeleton.animation = componentData.toSkel._animation;
								}

								skeleton.updateGraph();
							}
						}

						var animEvaluator = componentData.animEvaluator;

						if (animEvaluator) {
							for (var i = 0; i < animEvaluator.clips.length; ++i) {
								var clip = animEvaluator.clips[i];
								clip.speed = componentData.speed;

								if (!componentData.playing) {
									clip.pause();
								} else {
									clip.resume();
								}
							}

							if (componentData.blending && animEvaluator.clips.length > 1) {
								animEvaluator.clips[1].blendWeight = componentData.blend;
							}

							animEvaluator.update(dt);
						}

						if (componentData.blending && componentData.blend === 1.0) {
							componentData.blending = false;
						}
					}
				}
			}
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off('update', this.onUpdate, this);
		};

		return AnimationComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(AnimationComponent.prototype, _schema$l);

	var AnimNode = function () {
		function AnimNode(state, parent, name, point, speed) {
			if (speed === void 0) {
				speed = 1;
			}

			this._state = state;
			this._parent = parent;
			this._name = name;

			if (Array.isArray(point)) {
				this._point = new Vec2(point[0], point[1]);
				this._pointLength = this._point.length();
			} else {
				this._point = point;
				this._pointLength = point;
			}

			this._speed = speed;
			this._weightedSpeed = 1.0;
			this._weight = 1.0;
			this._animTrack = null;
		}

		_createClass(AnimNode, [{
			key: "parent",
			get: function get() {
				return this._parent;
			}
		}, {
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "path",
			get: function get() {
				return this._parent ? this._parent.path + '.' + this._name : this._name;
			}
		}, {
			key: "point",
			get: function get() {
				return this._point;
			}
		}, {
			key: "pointLength",
			get: function get() {
				return this._pointLength;
			}
		}, {
			key: "weight",
			get: function get() {
				return this._parent ? this._parent.weight * this._weight : this._weight;
			},
			set: function set(value) {
				this._weight = value;
			}
		}, {
			key: "normalizedWeight",
			get: function get() {
				var totalWeight = this._state.totalWeight;
				if (totalWeight === 0.0) return 0.0;
				return this.weight / totalWeight;
			}
		}, {
			key: "speed",
			get: function get() {
				return this._weightedSpeed * this._speed;
			}
		}, {
			key: "absoluteSpeed",
			get: function get() {
				return Math.abs(this._speed);
			}
		}, {
			key: "weightedSpeed",
			get: function get() {
				return this._weightedSpeed;
			},
			set: function set(weightedSpeed) {
				this._weightedSpeed = weightedSpeed;
			}
		}, {
			key: "animTrack",
			get: function get() {
				return this._animTrack;
			},
			set: function set(value) {
				this._animTrack = value;
			}
		}]);

		return AnimNode;
	}();

	var AnimBlendTree = function (_AnimNode) {
		_inheritsLoose(AnimBlendTree, _AnimNode);

		function AnimBlendTree(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
			var _this;

			_this = _AnimNode.call(this, state, parent, name, point) || this;
			_this._parameters = parameters;
			_this._parameterValues = new Array(parameters.length);
			_this._children = [];
			_this._findParameter = findParameter;
			_this._syncAnimations = syncAnimations !== false;
			_this._pointCache = {};

			for (var i = 0; i < children.length; i++) {
				var child = children[i];

				if (child.children) {
					_this._children.push(createTree(child.type, _assertThisInitialized(_this), null, name, 1.0, child.parameter ? [child.parameter] : child.parameters, child.children, createTree, findParameter));
				} else {
					_this._children.push(new AnimNode(state, _assertThisInitialized(_this), child.name, child.point, child.speed));
				}
			}

			return _this;
		}

		var _proto = AnimBlendTree.prototype;

		_proto.getChild = function getChild(name) {
			for (var i = 0; i < this._children.length; i++) {
				if (this._children[i].name === name) return this._children[i];
			}

			return null;
		};

		_proto.updateParameterValues = function updateParameterValues() {
			var paramsEqual = true;

			for (var i = 0; i < this._parameterValues.length; i++) {
				var updatedParameter = this._findParameter(this._parameters[i]).value;

				if (this._parameterValues[i] !== updatedParameter) {
					this._parameterValues[i] = updatedParameter;
					paramsEqual = false;
				}
			}

			return paramsEqual;
		};

		_proto.getNodeWeightedDuration = function getNodeWeightedDuration(i) {
			return this._children[i].animTrack.duration / this._children[i].speedMultiplier * this._children[i].weight;
		};

		_proto.getNodeCount = function getNodeCount() {
			var count = 0;

			for (var i = 0; i < this._children.length; i++) {
				var child = this._children[i];

				if (child.constructor === AnimBlendTree) {
					count += this._children[i].getNodeCount();
				} else {
					count++;
				}
			}

			return count;
		};

		_createClass(AnimBlendTree, [{
			key: "weight",
			get: function get() {
				this.calculateWeights();
				return this._parent ? this._parent.weight * this._weight : this._weight;
			}
		}, {
			key: "syncAnimations",
			get: function get() {
				return this._syncAnimations;
			}
		}]);

		return AnimBlendTree;
	}(AnimNode);

	var AnimBlendTree1D = function (_AnimBlendTree) {
		_inheritsLoose(AnimBlendTree1D, _AnimBlendTree);

		function AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
			children.sort(function (a, b) {
				return a.point - b.point;
			});
			return _AnimBlendTree.call(this, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) || this;
		}

		var _proto = AnimBlendTree1D.prototype;

		_proto.calculateWeights = function calculateWeights() {
			if (this.updateParameterValues()) return;
			var weightedDurationSum = 0.0;
			this._children[0].weight = 0.0;

			for (var i = 0; i < this._children.length; i++) {
				var c1 = this._children[i];

				if (i !== this._children.length - 1) {
					var c2 = this._children[i + 1];

					if (c1.point === c2.point) {
						c1.weight = 0.5;
						c2.weight = 0.5;
					} else if (math.between(this._parameterValues[0], c1.point, c2.point, true)) {
						var child2Distance = Math.abs(c1.point - c2.point);
						var parameterDistance = Math.abs(c1.point - this._parameterValues[0]);
						var weight = (child2Distance - parameterDistance) / child2Distance;
						c1.weight = weight;
						c2.weight = 1.0 - weight;
					} else {
						c2.weight = 0.0;
					}
				}

				if (this._syncAnimations) {
					weightedDurationSum += c1.animTrack.duration / c1.absoluteSpeed * c1.weight;
				}
			}

			if (this._syncAnimations) {
				for (var _i = 0; _i < this._children.length; _i++) {
					var child = this._children[_i];
					child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
				}
			}
		};

		return AnimBlendTree1D;
	}(AnimBlendTree);

	var AnimBlendTreeCartesian2D = function (_AnimBlendTree) {
		_inheritsLoose(AnimBlendTreeCartesian2D, _AnimBlendTree);

		function AnimBlendTreeCartesian2D() {
			return _AnimBlendTree.apply(this, arguments) || this;
		}

		var _proto = AnimBlendTreeCartesian2D.prototype;

		_proto.pointDistanceCache = function pointDistanceCache(i, j) {
			var pointKey = "" + i + j;

			if (!this._pointCache[pointKey]) {
				this._pointCache[pointKey] = this._children[j].point.clone().sub(this._children[i].point);
			}

			return this._pointCache[pointKey];
		};

		_proto.calculateWeights = function calculateWeights() {
			var _AnimBlendTreeCartesi;

			if (this.updateParameterValues()) return;
			var weightSum, weightedDurationSum;

			(_AnimBlendTreeCartesi = AnimBlendTreeCartesian2D._p).set.apply(_AnimBlendTreeCartesi, this._parameterValues);

			weightSum = 0.0;
			weightedDurationSum = 0.0;

			for (var i = 0; i < this._children.length; i++) {
				var child = this._children[i];
				var pi = child.point;

				AnimBlendTreeCartesian2D._pip.set(AnimBlendTreeCartesian2D._p.x, AnimBlendTreeCartesian2D._p.y).sub(pi);

				var minj = Number.MAX_VALUE;

				for (var j = 0; j < this._children.length; j++) {
					if (i === j) continue;
					var pipj = this.pointDistanceCache(i, j);
					var result = math.clamp(1.0 - AnimBlendTreeCartesian2D._pip.dot(pipj) / pipj.lengthSq(), 0.0, 1.0);
					if (result < minj) minj = result;
				}

				child.weight = minj;
				weightSum += minj;

				if (this._syncAnimations) {
					weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
				}
			}

			for (var _i = 0; _i < this._children.length; _i++) {
				var _child = this._children[_i];
				_child.weight = _child._weight / weightSum;

				if (this._syncAnimations) {
					_child.weightedSpeed = _child.animTrack.duration / _child.absoluteSpeed / weightedDurationSum;
				}
			}
		};

		return AnimBlendTreeCartesian2D;
	}(AnimBlendTree);

	AnimBlendTreeCartesian2D._p = new Vec2();
	AnimBlendTreeCartesian2D._pip = new Vec2();

	var AnimBlendTreeDirectional2D = function (_AnimBlendTree) {
		_inheritsLoose(AnimBlendTreeDirectional2D, _AnimBlendTree);

		function AnimBlendTreeDirectional2D() {
			return _AnimBlendTree.apply(this, arguments) || this;
		}

		var _proto = AnimBlendTreeDirectional2D.prototype;

		_proto.pointCache = function pointCache(i, j) {
			var pointKey = "" + i + j;

			if (!this._pointCache[pointKey]) {
				this._pointCache[pointKey] = new Vec2((this._children[j].pointLength - this._children[i].pointLength) / ((this._children[j].pointLength + this._children[i].pointLength) / 2), Vec2.angleRad(this._children[i].point, this._children[j].point) * 2.0);
			}

			return this._pointCache[pointKey];
		};

		_proto.calculateWeights = function calculateWeights() {
			var _AnimBlendTreeDirecti;

			if (this.updateParameterValues()) return;
			var weightSum, weightedDurationSum;

			(_AnimBlendTreeDirecti = AnimBlendTreeDirectional2D._p).set.apply(_AnimBlendTreeDirecti, this._parameterValues);

			var pLength = AnimBlendTreeDirectional2D._p.length();

			weightSum = 0.0;
			weightedDurationSum = 0.0;

			for (var i = 0; i < this._children.length; i++) {
				var child = this._children[i];
				var pi = child.point;
				var piLength = child.pointLength;
				var minj = Number.MAX_VALUE;

				for (var j = 0; j < this._children.length; j++) {
					if (i === j) continue;
					var pipj = this.pointCache(i, j);
					var pjLength = this._children[j].pointLength;

					AnimBlendTreeDirectional2D._pip.set((pLength - piLength) / ((pjLength + piLength) / 2), Vec2.angleRad(pi, AnimBlendTreeDirectional2D._p) * 2.0);

					var result = math.clamp(1.0 - Math.abs(AnimBlendTreeDirectional2D._pip.dot(pipj) / pipj.lengthSq()), 0.0, 1.0);
					if (result < minj) minj = result;
				}

				child.weight = minj;
				weightSum += minj;

				if (this._syncAnimations) {
					weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
				}
			}

			for (var _i = 0; _i < this._children.length; _i++) {
				var _child = this._children[_i];
				_child.weight = _child._weight / weightSum;

				if (this._syncAnimations) {
					var weightedChildDuration = _child.animTrack.duration / weightedDurationSum * weightSum;
					_child.weightedSpeed = _child.absoluteSpeed * weightedChildDuration;
				}
			}
		};

		return AnimBlendTreeDirectional2D;
	}(AnimBlendTree);

	AnimBlendTreeDirectional2D._p = new Vec2();
	AnimBlendTreeDirectional2D._pip = new Vec2();

	var AnimBlendTreeDirect = function (_AnimBlendTree) {
		_inheritsLoose(AnimBlendTreeDirect, _AnimBlendTree);

		function AnimBlendTreeDirect() {
			return _AnimBlendTree.apply(this, arguments) || this;
		}

		var _proto = AnimBlendTreeDirect.prototype;

		_proto.calculateWeights = function calculateWeights() {
			if (this.updateParameterValues()) return;
			var weightSum = 0.0;
			var weightedDurationSum = 0.0;

			for (var i = 0; i < this._children.length; i++) {
				weightSum += Math.max(this._parameterValues[i], 0.0);

				if (this._syncAnimations) {
					var child = this._children[i];
					weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
				}
			}

			for (var _i = 0; _i < this._children.length; _i++) {
				var _child = this._children[_i];
				_child.weight = Math.max(this._parameterValues[_i], 0.0) / weightSum;

				if (this._syncAnimations) {
					_child.weightedSpeed = _child.animTrack.duration / _child.absoluteSpeed / weightedDurationSum;
				}
			}
		};

		return AnimBlendTreeDirect;
	}(AnimBlendTree);

	var AnimState = function () {
		function AnimState(controller, name, speed, loop, blendTree) {
			this._controller = controller;
			this._name = name;
			this._animations = {};
			this._animationList = [];
			this._speed = speed || 1.0;
			this._loop = loop === undefined ? true : loop;

			var findParameter = this._controller.findParameter.bind(this._controller);

			if (blendTree) {
				this._blendTree = this._createTree(blendTree.type, this, null, name, 1.0, blendTree.parameter ? [blendTree.parameter] : blendTree.parameters, blendTree.children, blendTree.syncAnimations, this._createTree, findParameter);
			} else {
				this._blendTree = new AnimNode(this, null, name, 1.0, speed);
			}
		}

		var _proto = AnimState.prototype;

		_proto._createTree = function _createTree(type, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
			switch (type) {
				case ANIM_BLEND_1D:
					return new AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);

				case ANIM_BLEND_2D_CARTESIAN:
					return new AnimBlendTreeCartesian2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);

				case ANIM_BLEND_2D_DIRECTIONAL:
					return new AnimBlendTreeDirectional2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);

				case ANIM_BLEND_DIRECT:
					return new AnimBlendTreeDirect(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
			}
		};

		_proto._getNodeFromPath = function _getNodeFromPath(path) {
			var currNode = this._blendTree;

			for (var i = 1; i < path.length; i++) {
				currNode = currNode.getChild(path[i]);
			}

			return currNode;
		};

		_proto.addAnimation = function addAnimation(path, animTrack) {
			var pathString = path.join('.');

			var indexOfAnimation = this._animationList.findIndex(function (animation) {
				return animation.path === pathString;
			});

			if (indexOfAnimation >= 0) {
				this._animationList[indexOfAnimation].animTrack = animTrack;
			} else {
				var node = this._getNodeFromPath(path);

				node.animTrack = animTrack;

				this._animationList.push(node);
			}
		};

		_createClass(AnimState, [{
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "animations",
			get: function get() {
				return this._animationList;
			},
			set: function set(value) {
				this._animationList = value;
			}
		}, {
			key: "speed",
			get: function get() {
				return this._speed;
			},
			set: function set(value) {
				this._speed = value;
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(value) {
				this._loop = value;
			}
		}, {
			key: "nodeCount",
			get: function get() {
				if (!this._blendTree || this._blendTree.constructor === AnimNode) return 1;
				return this._blendTree.getNodeCount();
			}
		}, {
			key: "playable",
			get: function get() {
				return ANIM_CONTROL_STATES.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;
			}
		}, {
			key: "looping",
			get: function get() {
				if (this.animations.length > 0) {
					var trackClipName = this.name + '.' + this.animations[0].animTrack.name;

					var trackClip = this._controller.animEvaluator.findClip(trackClipName);

					if (trackClip) {
						return trackClip.loop;
					}
				}

				return false;
			}
		}, {
			key: "totalWeight",
			get: function get() {
				var sum = 0;

				for (var i = 0; i < this.animations.length; i++) {
					sum += this.animations[i].weight;
				}

				return sum;
			}
		}, {
			key: "timelineDuration",
			get: function get() {
				var duration = 0;

				for (var i = 0; i < this.animations.length; i++) {
					var animation = this.animations[i];

					if (animation.animTrack.duration > duration) {
						duration = animation.animTrack.duration;
					}
				}

				return duration;
			}
		}]);

		return AnimState;
	}();

	var AnimTransition = function () {
		function AnimTransition(_ref) {
			var from = _ref.from,
					to = _ref.to,
					_ref$time = _ref.time,
					time = _ref$time === void 0 ? 0 : _ref$time,
					_ref$priority = _ref.priority,
					priority = _ref$priority === void 0 ? 0 : _ref$priority,
					_ref$conditions = _ref.conditions,
					conditions = _ref$conditions === void 0 ? [] : _ref$conditions,
					_ref$exitTime = _ref.exitTime,
					exitTime = _ref$exitTime === void 0 ? null : _ref$exitTime,
					_ref$transitionOffset = _ref.transitionOffset,
					transitionOffset = _ref$transitionOffset === void 0 ? null : _ref$transitionOffset,
					_ref$interruptionSour = _ref.interruptionSource,
					interruptionSource = _ref$interruptionSour === void 0 ? ANIM_INTERRUPTION_NONE : _ref$interruptionSour;
			this._from = from;
			this._to = to;
			this._time = time;
			this._priority = priority;
			this._conditions = conditions;
			this._exitTime = exitTime;
			this._transitionOffset = transitionOffset;
			this._interruptionSource = interruptionSource;
		}

		_createClass(AnimTransition, [{
			key: "from",
			get: function get() {
				return this._from;
			}
		}, {
			key: "to",
			get: function get() {
				return this._to;
			},
			set: function set(value) {
				this._to = value;
			}
		}, {
			key: "time",
			get: function get() {
				return this._time;
			}
		}, {
			key: "priority",
			get: function get() {
				return this._priority;
			}
		}, {
			key: "conditions",
			get: function get() {
				return this._conditions;
			}
		}, {
			key: "exitTime",
			get: function get() {
				return this._exitTime;
			}
		}, {
			key: "transitionOffset",
			get: function get() {
				return this._transitionOffset;
			}
		}, {
			key: "interruptionSource",
			get: function get() {
				return this._interruptionSource;
			}
		}, {
			key: "hasExitTime",
			get: function get() {
				return !!this.exitTime;
			}
		}]);

		return AnimTransition;
	}();

	var AnimController = function () {
		function AnimController(animEvaluator, states, transitions, parameters, activate, eventHandler, consumedTriggers) {
			this._animEvaluator = animEvaluator;
			this._states = {};
			this._stateNames = [];
			this._eventHandler = eventHandler;
			this._consumedTriggers = consumedTriggers;

			for (var i = 0; i < states.length; i++) {
				this._states[states[i].name] = new AnimState(this, states[i].name, states[i].speed, states[i].loop, states[i].blendTree);

				this._stateNames.push(states[i].name);
			}

			this._transitions = transitions.map(function (transition) {
				return new AnimTransition(_extends({}, transition));
			});
			this._findTransitionsFromStateCache = {};
			this._findTransitionsBetweenStatesCache = {};
			this._parameters = parameters;
			this._previousStateName = null;
			this._activeStateName = ANIM_STATE_START;
			this._playing = false;
			this._activate = activate;
			this._currTransitionTime = 1.0;
			this._totalTransitionTime = 1.0;
			this._isTransitioning = false;
			this._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;
			this._transitionPreviousStates = [];
			this._timeInState = 0;
			this._timeInStateBefore = 0;
		}

		var _proto = AnimController.prototype;

		_proto.assignMask = function assignMask(mask) {
			return this._animEvaluator.assignMask(mask);
		};

		_proto._findState = function _findState(stateName) {
			return this._states[stateName];
		};

		_proto._getActiveStateProgressForTime = function _getActiveStateProgressForTime(time) {
			if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END || this.activeStateName === ANIM_STATE_ANY) return 1.0;

			var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);

			if (activeClip) {
				return time / activeClip.track.duration;
			}

			return null;
		};

		_proto._findTransitionsFromState = function _findTransitionsFromState(stateName) {
			var transitions = this._findTransitionsFromStateCache[stateName];

			if (!transitions) {
				transitions = this._transitions.filter(function (transition) {
					return transition.from === stateName;
				});
				sortPriority(transitions);
				this._findTransitionsFromStateCache[stateName] = transitions;
			}

			return transitions;
		};

		_proto._findTransitionsBetweenStates = function _findTransitionsBetweenStates(sourceStateName, destinationStateName) {
			var transitions = this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName];

			if (!transitions) {
				transitions = this._transitions.filter(function (transition) {
					return transition.from === sourceStateName && transition.to === destinationStateName;
				});
				sortPriority(transitions);
				this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName] = transitions;
			}

			return transitions;
		};

		_proto._transitionHasConditionsMet = function _transitionHasConditionsMet(transition) {
			var conditions = transition.conditions;

			for (var i = 0; i < conditions.length; i++) {
				var condition = conditions[i];
				var parameter = this.findParameter(condition.parameterName);

				switch (condition.predicate) {
					case ANIM_GREATER_THAN:
						if (!(parameter.value > condition.value)) return false;
						break;

					case ANIM_LESS_THAN:
						if (!(parameter.value < condition.value)) return false;
						break;

					case ANIM_GREATER_THAN_EQUAL_TO:
						if (!(parameter.value >= condition.value)) return false;
						break;

					case ANIM_LESS_THAN_EQUAL_TO:
						if (!(parameter.value <= condition.value)) return false;
						break;

					case ANIM_EQUAL_TO:
						if (!(parameter.value === condition.value)) return false;
						break;

					case ANIM_NOT_EQUAL_TO:
						if (!(parameter.value !== condition.value)) return false;
						break;
				}
			}

			return true;
		};

		_proto._findTransition = function _findTransition(from, to) {
			var _this = this;

			var transitions = [];

			if (from && to) {
				transitions = transitions.concat(this._findTransitionsBetweenStates(from, to));
			} else {
				if (!this._isTransitioning) {
					transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
					transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
				} else {
					switch (this._transitionInterruptionSource) {
						case ANIM_INTERRUPTION_PREV:
							transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
							transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
							break;

						case ANIM_INTERRUPTION_NEXT:
							transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
							transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
							break;

						case ANIM_INTERRUPTION_PREV_NEXT:
							transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
							transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
							transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
							break;

						case ANIM_INTERRUPTION_NEXT_PREV:
							transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
							transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
							transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
							break;
					}
				}
			}

			transitions = transitions.filter(function (transition) {
				if (transition.to === _this.activeStateName) {
					return false;
				}

				if (transition.hasExitTime) {
					var progressBefore = _this._getActiveStateProgressForTime(_this._timeInStateBefore);

					var progress = _this._getActiveStateProgressForTime(_this._timeInState);

					if (transition.exitTime < 1.0 && _this.activeState.loop) {
						progressBefore -= Math.floor(progressBefore);
						progress -= Math.floor(progress);
					}

					if (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {
						return null;
					}
				}

				return _this._transitionHasConditionsMet(transition);
			});

			if (transitions.length > 0) {
				var transition = transitions[0];

				if (transition.to === ANIM_STATE_END) {
					var startTransition = this._findTransitionsFromState(ANIM_STATE_START)[0];

					transition.to = startTransition.to;
				}

				return transition;
			}

			return null;
		};

		_proto.updateStateFromTransition = function updateStateFromTransition(transition) {
			var state;
			var animation;
			var clip;
			this.previousState = transition.from ? this.activeStateName : null;
			this.activeState = transition.to;

			for (var i = 0; i < transition.conditions.length; i++) {
				var condition = transition.conditions[i];
				var parameter = this.findParameter(condition.parameterName);

				if (parameter.type === ANIM_PARAMETER_TRIGGER) {
					this._consumedTriggers.add(condition.parameterName);
				}
			}

			if (this.previousState) {
				if (!this._isTransitioning) {
					this._transitionPreviousStates = [];
				}

				this._transitionPreviousStates.push({
					name: this._previousStateName,
					weight: 1
				});

				var interpolatedTime = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1.0);

				for (var _i = 0; _i < this._transitionPreviousStates.length; _i++) {
					if (!this._isTransitioning) {
						this._transitionPreviousStates[_i].weight = 1.0;
					} else if (_i !== this._transitionPreviousStates.length - 1) {
						this._transitionPreviousStates[_i].weight *= 1.0 - interpolatedTime;
					} else {
						this._transitionPreviousStates[_i].weight = interpolatedTime;
					}

					state = this._findState(this._transitionPreviousStates[_i].name);

					for (var j = 0; j < state.animations.length; j++) {
						animation = state.animations[j];
						clip = this._animEvaluator.findClip(animation.name + '.previous.' + _i);

						if (!clip) {
							clip = this._animEvaluator.findClip(animation.name);
							clip.name = animation.name + '.previous.' + _i;
						}

						if (_i !== this._transitionPreviousStates.length - 1) {
							clip.pause();
						}
					}
				}
			}

			this._isTransitioning = true;
			this._totalTransitionTime = transition.time;
			this._currTransitionTime = 0;
			this._transitionInterruptionSource = transition.interruptionSource;
			var activeState = this.activeState;
			var hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;
			var timeInState = 0;
			var timeInStateBefore = 0;

			if (hasTransitionOffset) {
				var offsetTime = activeState.timelineDuration * transition.transitionOffset;
				timeInState = offsetTime;
				timeInStateBefore = offsetTime;
			}

			this._timeInState = timeInState;
			this._timeInStateBefore = timeInStateBefore;

			for (var _i2 = 0; _i2 < activeState.animations.length; _i2++) {
				clip = this._animEvaluator.findClip(activeState.animations[_i2].name);

				if (!clip) {
					var speed = Number.isFinite(activeState.animations[_i2].speed) ? activeState.animations[_i2].speed : activeState.speed;
					clip = new AnimClip(activeState.animations[_i2].animTrack, this._timeInState, speed, true, activeState.loop, this._eventHandler);
					clip.name = activeState.animations[_i2].name;

					this._animEvaluator.addClip(clip);
				} else {
					clip.reset();
				}

				if (transition.time > 0) {
					clip.blendWeight = 0.0;
				} else {
					clip.blendWeight = activeState.animations[_i2].normalizedWeight;
				}

				clip.play();

				if (hasTransitionOffset) {
					clip.time = activeState.timelineDuration * transition.transitionOffset;
				} else {
					var startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;
					clip.time = startTime;
				}
			}
		};

		_proto._transitionToState = function _transitionToState(newStateName) {
			if (!this._findState(newStateName)) {
				return;
			}

			var transition = this._findTransition(this._activeStateName, newStateName);

			if (!transition) {
				this._animEvaluator.removeClips();

				transition = new AnimTransition({
					from: null,
					to: newStateName
				});
			}

			this.updateStateFromTransition(transition);
		};

		_proto.assignAnimation = function assignAnimation(pathString, animTrack, speed, loop) {
			var path = pathString.split('.');

			var state = this._findState(path[0]);

			if (!state) {
				state = new AnimState(this, path[0], 1.0);
				this._states[path[0]] = state;

				this._stateNames.push(path[0]);
			}

			state.addAnimation(path, animTrack);

			if (speed !== undefined) {
				state.speed = speed;
			}

			if (loop !== undefined) {
				state.loop = loop;
			}

			if (!this._playing && this._activate && this.playable) {
				this.play();
			}
		};

		_proto.removeNodeAnimations = function removeNodeAnimations(nodeName) {
			if (ANIM_CONTROL_STATES.indexOf(nodeName) !== -1) {
				return;
			}

			var state = this._findState(nodeName);

			if (!state) {
				Debug.error('Attempting to unassign animation tracks from a state that does not exist.');
				return;
			}

			state.animations = [];
			return true;
		};

		_proto.play = function play(stateName) {
			if (stateName) {
				this._transitionToState(stateName);
			}

			this._playing = true;
		};

		_proto.pause = function pause() {
			this._playing = false;
		};

		_proto.reset = function reset() {
			this._previousStateName = null;
			this._activeStateName = ANIM_STATE_START;
			this._playing = false;
			this._currTransitionTime = 1.0;
			this._totalTransitionTime = 1.0;
			this._isTransitioning = false;
			this._timeInState = 0;
			this._timeInStateBefore = 0;

			this._animEvaluator.removeClips();
		};

		_proto.rebind = function rebind() {
			this._animEvaluator.rebind();
		};

		_proto.update = function update(dt) {
			if (!this._playing) {
				return;
			}

			var state;
			var animation;
			var clip;
			this._timeInStateBefore = this._timeInState;
			this._timeInState += dt;

			var transition = this._findTransition(this._activeStateName);

			if (transition) this.updateStateFromTransition(transition);

			if (this._isTransitioning) {
				this._currTransitionTime += dt;

				if (this._currTransitionTime <= this._totalTransitionTime) {
					var interpolatedTime = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;

					for (var i = 0; i < this._transitionPreviousStates.length; i++) {
						state = this._findState(this._transitionPreviousStates[i].name);
						var stateWeight = this._transitionPreviousStates[i].weight;

						for (var j = 0; j < state.animations.length; j++) {
							animation = state.animations[j];
							clip = this._animEvaluator.findClip(animation.name + '.previous.' + i);

							if (clip) {
								clip.blendWeight = (1.0 - interpolatedTime) * animation.normalizedWeight * stateWeight;
							}
						}
					}

					state = this.activeState;

					for (var _i3 = 0; _i3 < state.animations.length; _i3++) {
						animation = state.animations[_i3];
						this._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.normalizedWeight;
					}
				} else {
					this._isTransitioning = false;
					var activeClips = this.activeStateAnimations.length;
					var totalClips = this._animEvaluator.clips.length;

					for (var _i4 = 0; _i4 < totalClips - activeClips; _i4++) {
						this._animEvaluator.removeClip(0);
					}

					this._transitionPreviousStates = [];
					state = this.activeState;

					for (var _i5 = 0; _i5 < state.animations.length; _i5++) {
						animation = state.animations[_i5];
						clip = this._animEvaluator.findClip(animation.name);

						if (clip) {
							clip.blendWeight = animation.normalizedWeight;
						}
					}
				}
			} else {
				if (this.activeState._blendTree.constructor !== AnimNode) {
					state = this.activeState;

					for (var _i6 = 0; _i6 < state.animations.length; _i6++) {
						animation = state.animations[_i6];
						clip = this._animEvaluator.findClip(animation.name);

						if (clip) {
							clip.blendWeight = animation.normalizedWeight;

							if (animation.parent.syncAnimations) {
								clip.speed = animation.speed;
							}
						}
					}
				}
			}

			this._animEvaluator.update(dt);
		};

		_proto.findParameter = function findParameter(name) {
			return this._parameters[name];
		};

		_createClass(AnimController, [{
			key: "animEvaluator",
			get: function get() {
				return this._animEvaluator;
			}
		}, {
			key: "activeState",
			get: function get() {
				return this._findState(this._activeStateName);
			},
			set: function set(stateName) {
				this._activeStateName = stateName;
			}
		}, {
			key: "activeStateName",
			get: function get() {
				return this._activeStateName;
			}
		}, {
			key: "activeStateAnimations",
			get: function get() {
				return this.activeState.animations;
			}
		}, {
			key: "previousState",
			get: function get() {
				return this._findState(this._previousStateName);
			},
			set: function set(stateName) {
				this._previousStateName = stateName;
			}
		}, {
			key: "previousStateName",
			get: function get() {
				return this._previousStateName;
			}
		}, {
			key: "playable",
			get: function get() {
				var playable = true;

				for (var i = 0; i < this._stateNames.length; i++) {
					if (!this._states[this._stateNames[i]].playable) {
						playable = false;
					}
				}

				return playable;
			}
		}, {
			key: "playing",
			get: function get() {
				return this._playing;
			},
			set: function set(value) {
				this._playing = value;
			}
		}, {
			key: "activeStateProgress",
			get: function get() {
				return this._getActiveStateProgressForTime(this._timeInState);
			}
		}, {
			key: "activeStateDuration",
			get: function get() {
				if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END) return 0.0;
				var maxDuration = 0.0;

				for (var i = 0; i < this.activeStateAnimations.length; i++) {
					var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);

					if (activeClip) {
						maxDuration = Math.max(maxDuration, activeClip.track.duration);
					}
				}

				return maxDuration;
			}
		}, {
			key: "activeStateCurrentTime",
			get: function get() {
				return this._timeInState;
			},
			set: function set(time) {
				this._timeInStateBefore = time;
				this._timeInState = time;

				for (var i = 0; i < this.activeStateAnimations.length; i++) {
					var clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);

					if (clip) {
						clip.time = time;
					}
				}
			}
		}, {
			key: "transitioning",
			get: function get() {
				return this._isTransitioning;
			}
		}, {
			key: "transitionProgress",
			get: function get() {
				return this._currTransitionTime / this._totalTransitionTime;
			}
		}, {
			key: "states",
			get: function get() {
				return this._stateNames;
			}
		}]);

		return AnimController;
	}();

	var v2 = new Vec2();
	var v3 = new Vec3();
	var v4 = new Vec4();
	var c = new Color();
	var q = new Quat();

	var AnimComponentBinder = function (_DefaultAnimBinder) {
		_inheritsLoose(AnimComponentBinder, _DefaultAnimBinder);

		function AnimComponentBinder(animComponent, graph, layerName, mask, layerIndex) {
			var _this;

			_this = _DefaultAnimBinder.call(this, graph) || this;
			_this.animComponent = animComponent;
			_this._mask = mask;
			_this.layerName = layerName;
			_this.layerIndex = layerIndex;
			return _this;
		}

		AnimComponentBinder._packFloat = function _packFloat(values) {
			return values[0];
		};

		AnimComponentBinder._packBoolean = function _packBoolean(values) {
			return !!values[0];
		};

		AnimComponentBinder._packVec2 = function _packVec2(values) {
			v2.x = values[0];
			v2.y = values[1];
			return v2;
		};

		AnimComponentBinder._packVec3 = function _packVec3(values) {
			v3.x = values[0];
			v3.y = values[1];
			v3.z = values[2];
			return v3;
		};

		AnimComponentBinder._packVec4 = function _packVec4(values) {
			v4.x = values[0];
			v4.y = values[1];
			v4.z = values[2];
			v4.w = values[3];
			return v4;
		};

		AnimComponentBinder._packColor = function _packColor(values) {
			c.r = values[0];
			c.g = values[1];
			c.b = values[2];
			c.a = values[3];
			return c;
		};

		AnimComponentBinder._packQuat = function _packQuat(values) {
			q.x = values[0];
			q.y = values[1];
			q.z = values[2];
			q.w = values[3];
			return q;
		};

		var _proto = AnimComponentBinder.prototype;

		_proto.resolve = function resolve(path) {
			var encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
			var target = this.targetCache[encodedPath];
			if (target) return target;
			var entity;
			var propertyComponent;
			var targetPath;

			switch (path.component) {
				case 'entity':
					entity = this._getEntityFromHierarchy(path.entityPath);
					targetPath = AnimBinder.encode(entity.path, 'entity', path.propertyPath);
					propertyComponent = entity;
					break;

				case 'graph':
					propertyComponent = this.findNode(path);
					if (!propertyComponent) return null;
					targetPath = AnimBinder.encode(propertyComponent.path, 'graph', path.propertyPath);
					break;

				default:
					entity = this._getEntityFromHierarchy(path.entityPath);
					propertyComponent = entity.findComponent(path.component);
					if (!propertyComponent) return null;
					targetPath = AnimBinder.encode(entity.path, path.component, path.propertyPath);
					break;
			}

			target = this._createAnimTargetForProperty(propertyComponent, path.propertyPath, targetPath);
			this.targetCache[encodedPath] = target;
			return target;
		};

		_proto.update = function update(deltaTime) {
			var activeNodes = this.activeNodes;

			if (activeNodes) {
				for (var i = 0; i < activeNodes.length; i++) {
					activeNodes[i]._dirtifyLocal();
				}
			}
		};

		_proto._getEntityFromHierarchy = function _getEntityFromHierarchy(entityHierarchy) {
			if (!this.animComponent.entity.name === entityHierarchy[0]) {
				return null;
			}

			var currEntity = this.animComponent.entity;

			if (entityHierarchy.length === 1) {
				return currEntity;
			}

			return currEntity._parent.findByPath(entityHierarchy);
		};

		_proto._resolvePath = function _resolvePath(object, path, resolveLeaf) {
			var steps = path.length - (resolveLeaf ? 0 : 1);

			for (var i = 0; i < steps; i++) {
				object = object[path[i]];
			}

			return object;
		};

		_proto._setter = function _setter(object, path, packFunc) {
			var obj = this._resolvePath(object, path);

			var key = path[path.length - 1];
			var setterFuncName = "set" + key.substring(0, 1).toUpperCase() + key.substring(1);

			if (obj[setterFuncName]) {
				var getterFunc = obj["get" + key.substring(0, 1).toUpperCase() + key.substring(1)].bind(obj);
				var baseValues = getterFunc();
				baseValues = [baseValues.x, baseValues.y, baseValues.z, baseValues.w];
				var setterFunc = obj[setterFuncName].bind(obj);
				return {
					set: function set(values) {
						setterFunc(packFunc(values));
					},
					get: function get() {
						return baseValues;
					}
				};
			}

			var prop = obj[key];

			if (typeof prop === 'object' && prop.hasOwnProperty('copy')) {
				return function (values) {
					prop.copy(packFunc(values));
				};
			}

			if ([Vec2, Vec3, Vec4, Color, Quat].indexOf(obj.constructor) !== -1 && path.length > 1) {
				var parent = path.length > 2 ? this._resolvePath(object, path.slice(0, -1)) : object;
				var objKey = path[path.length - 2];
				return function (values) {
					obj[key] = packFunc(values);
					parent[objKey] = obj;
				};
			}

			return function (values) {
				obj[key] = packFunc(values);
			};
		};

		_proto._createAnimTargetForProperty = function _createAnimTargetForProperty(propertyComponent, propertyHierarchy, targetPath) {
			if (this.handlers && propertyHierarchy[0] === 'weights') {
				return this.handlers.weights(propertyComponent);
			} else if (this.handlers && propertyHierarchy[0] === 'material' && propertyHierarchy.length === 2) {
				var materialPropertyName = propertyHierarchy[1];

				if (materialPropertyName.endsWith('Map')) {
					return this.handlers.materialTexture(propertyComponent, materialPropertyName);
				}
			}

			var property = this._resolvePath(propertyComponent, propertyHierarchy, true);

			if (typeof property === 'undefined') return null;
			var setter;
			var animDataType;
			var animDataComponents;

			if (typeof property === 'number') {
				setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packFloat);
				animDataType = 'vector';
				animDataComponents = 1;
			} else if (typeof property === 'boolean') {
				setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packBoolean);
				animDataType = 'vector';
				animDataComponents = 1;
			} else if (typeof property === 'object') {
				switch (property.constructor) {
					case Vec2:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec2);
						animDataType = 'vector';
						animDataComponents = 2;
						break;

					case Vec3:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec3);
						animDataType = 'vector';
						animDataComponents = 3;
						break;

					case Vec4:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec4);
						animDataType = 'vector';
						animDataComponents = 4;
						break;

					case Color:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packColor);
						animDataType = 'vector';
						animDataComponents = 4;
						break;

					case Quat:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packQuat);
						animDataType = 'quaternion';
						animDataComponents = 4;
						break;

					default:
						return null;
				}
			}

			if (propertyHierarchy.indexOf('material') !== -1) {
				return new AnimTarget(function (values) {
					setter(values);
					propertyComponent.material.update();
				}, animDataType, animDataComponents, targetPath);
			}

			return new AnimTarget(setter, animDataType, animDataComponents, targetPath);
		};

		_proto.rebind = function rebind() {
			this.targetCache = {};
			this.visitedFallbackGraphPaths = {};

			if (this.animComponent.rootBone) {
				this.graph = this.animComponent.rootBone;
			} else {
				this.graph = this.animComponent.entity;
			}

			var nodes = {};

			var flatten = function flatten(node) {
				nodes[node.name] = node;

				for (var i = 0; i < node.children.length; ++i) {
					flatten(node.children[i]);
				}
			};

			flatten(this.graph);
			this.nodes = nodes;
		};

		return AnimComponentBinder;
	}(DefaultAnimBinder);

	var AnimComponentLayer = function () {
		function AnimComponentLayer(name, controller, component, weight, blendType, normalizedWeight) {
			if (weight === void 0) {
				weight = 1;
			}

			if (blendType === void 0) {
				blendType = ANIM_LAYER_OVERWRITE;
			}

			if (normalizedWeight === void 0) {
				normalizedWeight = true;
			}

			this._name = name;
			this._controller = controller;
			this._component = component;
			this._weight = weight;
			this._blendType = blendType;
			this._normalizedWeight = normalizedWeight;
			this._mask = null;
			this._blendTime = 0;
			this._blendTimeElapsed = 0;
			this._startingWeight = 0;
			this._targetWeight = 0;
		}

		var _proto = AnimComponentLayer.prototype;

		_proto.play = function play(name) {
			this._controller.play(name);
		};

		_proto.pause = function pause() {
			this._controller.pause();
		};

		_proto.reset = function reset() {
			this._controller.reset();
		};

		_proto.rebind = function rebind() {
			this._controller.rebind();
		};

		_proto.update = function update(dt) {
			if (this._blendTime) {
				if (this._blendTimeElapsed < this._blendTime) {
					this.weight = math.lerp(this._startingWeight, this._targetWeight, this._blendTimeElapsed / this._blendTime);
					this._blendTimeElapsed += dt;
				} else {
					this.weight = this._targetWeight;
					this._blendTime = 0;
					this._blendTimeElapsed = 0;
					this._startingWeight = 0;
					this._targetWeight = 0;
				}
			}

			this._controller.update(dt);
		};

		_proto.blendToWeight = function blendToWeight(weight, time) {
			this._startingWeight = this.weight;
			this._targetWeight = weight;
			this._blendTime = Math.max(0, time);
			this._blendTimeElapsed = 0;
		};

		_proto.assignMask = function assignMask(mask) {
			Debug.deprecated('The pc.AnimComponentLayer#assignMask function is now deprecated. Assign masks to the pc.AnimComponentLayer#mask property instead.');

			if (this._controller.assignMask(mask)) {
				this._component.rebind();
			}

			this._mask = mask;
		};

		_proto.assignAnimation = function assignAnimation(nodePath, animTrack, speed, loop) {
			if (animTrack.constructor !== AnimTrack) {
				Debug.error('assignAnimation: animTrack supplied to function was not of type AnimTrack');
				return;
			}

			this._controller.assignAnimation(nodePath, animTrack, speed, loop);

			if (this._controller._transitions.length === 0) {
				this._controller._transitions.push(new AnimTransition({
					from: 'START',
					to: nodePath
				}));
			}

			if (this._component.activate && this._component.playable) {
				this._component.playing = true;
			}
		};

		_proto.removeNodeAnimations = function removeNodeAnimations(nodeName) {
			if (this._controller.removeNodeAnimations(nodeName)) {
				this._component.playing = false;
			}
		};

		_proto.getAnimationAsset = function getAnimationAsset(stateName) {
			return this._component.animationAssets[this.name + ":" + stateName];
		};

		_proto.transition = function transition(to, time, transitionOffset) {
			if (time === void 0) {
				time = 0;
			}

			if (transitionOffset === void 0) {
				transitionOffset = null;
			}

			this._controller.updateStateFromTransition(new AnimTransition({
				from: this._controller.activeStateName,
				to: to,
				time: time,
				transitionOffset: transitionOffset
			}));
		};

		_createClass(AnimComponentLayer, [{
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "playing",
			get: function get() {
				return this._controller.playing;
			},
			set: function set(value) {
				this._controller.playing = value;
			}
		}, {
			key: "playable",
			get: function get() {
				return this._controller.playable;
			}
		}, {
			key: "activeState",
			get: function get() {
				return this._controller.activeStateName;
			}
		}, {
			key: "previousState",
			get: function get() {
				return this._controller.previousStateName;
			}
		}, {
			key: "activeStateProgress",
			get: function get() {
				return this._controller.activeStateProgress;
			}
		}, {
			key: "activeStateDuration",
			get: function get() {
				return this._controller.activeStateDuration;
			}
		}, {
			key: "activeStateCurrentTime",
			get: function get() {
				return this._controller.activeStateCurrentTime;
			},
			set: function set(time) {
				var controller = this._controller;
				var layerPlaying = controller.playing;
				controller.playing = true;
				controller.activeStateCurrentTime = time;

				if (!layerPlaying) {
					controller.update(0);
				}

				controller.playing = layerPlaying;
			}
		}, {
			key: "transitioning",
			get: function get() {
				return this._controller.transitioning;
			}
		}, {
			key: "transitionProgress",
			get: function get() {
				if (this.transitioning) {
					return this._controller.transitionProgress;
				}

				return null;
			}
		}, {
			key: "states",
			get: function get() {
				return this._controller.states;
			}
		}, {
			key: "weight",
			get: function get() {
				return this._weight;
			},
			set: function set(value) {
				this._weight = value;

				this._component.dirtifyTargets();
			}
		}, {
			key: "blendType",
			get: function get() {
				return this._blendType;
			},
			set: function set(value) {
				if (value !== this._blendType) {
					this._blendType = value;

					if (this._controller.normalizeWeights) {
						this._component.rebind();
					}
				}
			}
		}, {
			key: "mask",
			get: function get() {
				return this._mask;
			},
			set: function set(value) {
				if (this._controller.assignMask(value)) {
					this._component.rebind();
				}

				this._mask = value;
			}
		}]);

		return AnimComponentLayer;
	}();

	var AnimComponent = function (_Component) {
		_inheritsLoose(AnimComponent, _Component);

		function AnimComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._stateGraphAsset = null;
			_this._animationAssets = {};
			_this._speed = 1.0;
			_this._activate = true;
			_this._playing = false;
			_this._rootBone = null;
			_this._stateGraph = null;
			_this._layers = [];
			_this._layerIndices = {};
			_this._parameters = {};
			_this._targets = {};
			_this._consumedTriggers = new Set();
			_this._normalizeWeights = false;
			return _this;
		}

		var _proto = AnimComponent.prototype;

		_proto._onStateGraphAssetChangeEvent = function _onStateGraphAssetChangeEvent(asset) {
			var prevAnimationAssets = this.animationAssets;
			var prevMasks = this.layers.map(function (layer) {
				return layer.mask;
			});
			this.removeStateGraph();
			this._stateGraph = new AnimStateGraph(asset._data);
			this.loadStateGraph(this._stateGraph);
			this.animationAssets = prevAnimationAssets;
			this.loadAnimationAssets();
			this.layers.forEach(function (layer, i) {
				layer.mask = prevMasks[i];
			});
			this.rebind();
		};

		_proto.dirtifyTargets = function dirtifyTargets() {
			var targets = Object.values(this._targets);

			for (var i = 0; i < targets.length; i++) {
				targets[i].dirty = true;
			}
		};

		_proto._addLayer = function _addLayer(_ref) {
			var name = _ref.name,
					states = _ref.states,
					transitions = _ref.transitions,
					weight = _ref.weight,
					mask = _ref.mask,
					blendType = _ref.blendType;
			var graph;

			if (this.rootBone) {
				graph = this.rootBone;
			} else {
				graph = this.entity;
			}

			var layerIndex = this._layers.length;
			var animBinder = new AnimComponentBinder(this, graph, name, mask, layerIndex);
			var animEvaluator = new AnimEvaluator(animBinder);
			var controller = new AnimController(animEvaluator, states, transitions, this._parameters, this._activate, this, this._consumedTriggers);

			this._layers.push(new AnimComponentLayer(name, controller, this, weight, blendType));

			this._layerIndices[name] = layerIndex;
			return this._layers[layerIndex];
		};

		_proto.addLayer = function addLayer(name, weight, mask, blendType) {
			var layer = this.findAnimationLayer(name);
			if (layer) return layer;
			var states = [{
				"name": "START",
				"speed": 1
			}];
			var transitions = [];
			return this._addLayer({
				name: name,
				states: states,
				transitions: transitions,
				weight: weight,
				mask: mask,
				blendType: blendType
			});
		};

		_proto.loadStateGraph = function loadStateGraph(stateGraph) {
			this._stateGraph = stateGraph;
			this._parameters = {};
			var paramKeys = Object.keys(stateGraph.parameters);

			for (var i = 0; i < paramKeys.length; i++) {
				var paramKey = paramKeys[i];
				this._parameters[paramKey] = {
					type: stateGraph.parameters[paramKey].type,
					value: stateGraph.parameters[paramKey].value
				};
			}

			this._layers = [];

			for (var _i = 0; _i < stateGraph.layers.length; _i++) {
				var layer = stateGraph.layers[_i];

				this._addLayer.bind(this)(_extends({}, layer));
			}

			this.setupAnimationAssets();
		};

		_proto.setupAnimationAssets = function setupAnimationAssets() {
			for (var i = 0; i < this._layers.length; i++) {
				var layer = this._layers[i];
				var layerName = layer.name;

				for (var j = 0; j < layer.states.length; j++) {
					var stateName = layer.states[j];

					if (ANIM_CONTROL_STATES.indexOf(stateName) === -1) {
						var stateKey = layerName + ':' + stateName;

						if (!this._animationAssets[stateKey]) {
							this._animationAssets[stateKey] = {
								asset: null
							};
						}
					}
				}
			}

			this.loadAnimationAssets();
		};

		_proto.loadAnimationAssets = function loadAnimationAssets() {
			for (var i = 0; i < this._layers.length; i++) {
				var layer = this._layers[i];

				for (var j = 0; j < layer.states.length; j++) {
					var stateName = layer.states[j];
					if (ANIM_CONTROL_STATES.indexOf(stateName) !== -1) continue;
					var animationAsset = this._animationAssets[layer.name + ':' + stateName];

					if (!animationAsset || !animationAsset.asset) {
						this.removeNodeAnimations(stateName, layer.name);
						continue;
					}

					var assetId = animationAsset.asset;
					var asset = this.system.app.assets.get(assetId);

					if (asset) {
						if (asset.resource) {
							this.onAnimationAssetLoaded(layer.name, stateName, asset);
						} else {
							asset.once('load', function (layerName, stateName) {
								return function (asset) {
									this.onAnimationAssetLoaded(layerName, stateName, asset);
								}.bind(this);
							}.bind(this)(layer.name, stateName));
							this.system.app.assets.load(asset);
						}
					}
				}
			}
		};

		_proto.onAnimationAssetLoaded = function onAnimationAssetLoaded(layerName, stateName, asset) {
			var animTrack = asset.resource;

			if (asset.data.events) {
				animTrack.events = new AnimEvents(Object.values(asset.data.events));
			}

			this.findAnimationLayer(layerName).assignAnimation(stateName, asset.resource);
		};

		_proto.removeStateGraph = function removeStateGraph() {
			this._stateGraph = null;
			this._stateGraphAsset = null;
			this._animationAssets = {};
			this._layers = [];
			this._layerIndices = {};
			this._parameters = {};
			this._playing = false;
			this.unbind();
			this._targets = {};
		};

		_proto.reset = function reset() {
			this._parameters = Object.assign({}, this._stateGraph.parameters);

			for (var i = 0; i < this._layers.length; i++) {
				var layerPlaying = this._layers[i].playing;

				this._layers[i].reset();

				this._layers[i].playing = layerPlaying;
			}
		};

		_proto.unbind = function unbind() {
			var _this2 = this;

			if (!this._normalizeWeights) {
				Object.keys(this._targets).forEach(function (targetKey) {
					_this2._targets[targetKey].unbind();
				});
			}
		};

		_proto.rebind = function rebind() {
			this._targets = {};

			for (var i = 0; i < this._layers.length; i++) {
				this._layers[i].rebind();
			}
		};

		_proto.findAnimationLayer = function findAnimationLayer(name) {
			var layerIndex = this._layerIndices[name];
			return this._layers[layerIndex] || null;
		};

		_proto.addAnimationState = function addAnimationState(nodeName, animTrack, speed, loop, layerName) {
			if (speed === void 0) {
				speed = 1;
			}

			if (loop === void 0) {
				loop = true;
			}

			if (layerName === void 0) {
				layerName = 'Base';
			}

			if (!this._stateGraph) {
				this.loadStateGraph(new AnimStateGraph({
					"layers": [{
						"name": layerName,
						"states": [{
							"name": "START",
							"speed": 1
						}, {
							"name": nodeName,
							"speed": speed,
							"loop": loop,
							"defaultState": true
						}],
						"transitions": [{
							"from": 'START',
							"to": nodeName
						}]
					}],
					"parameters": {}
				}));
			}

			var layer = this.findAnimationLayer(layerName);

			if (layer) {
				layer.assignAnimation(nodeName, animTrack, speed, loop);
			} else {
				var _this$addLayer;

				(_this$addLayer = this.addLayer(layerName)) == null ? void 0 : _this$addLayer.assignAnimation(nodeName, animTrack, speed, loop);
			}
		};

		_proto.assignAnimation = function assignAnimation(nodePath, animTrack, layerName, speed, loop) {
			if (speed === void 0) {
				speed = 1;
			}

			if (loop === void 0) {
				loop = true;
			}

			if (!this._stateGraph && nodePath.indexOf('.') === -1) {
				this.loadStateGraph(new AnimStateGraph({
					"layers": [{
						"name": "Base",
						"states": [{
							"name": "START",
							"speed": 1
						}, {
							"name": nodePath,
							"speed": speed,
							"loop": loop,
							"defaultState": true
						}],
						"transitions": [{
							"from": 'START',
							"to": nodePath
						}]
					}],
					"parameters": {}
				}));
				this.baseLayer.assignAnimation(nodePath, animTrack);
				return;
			}

			var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;

			if (!layer) {
				Debug.error('assignAnimation: Trying to assign an anim track to a layer that doesn\'t exist');
				return;
			}

			layer.assignAnimation(nodePath, animTrack, speed, loop);
		};

		_proto.removeNodeAnimations = function removeNodeAnimations(nodeName, layerName) {
			var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;

			if (!layer) {
				Debug.error('removeStateAnimations: Trying to remove animation tracks from a state before the state graph has been loaded. Have you called loadStateGraph?');
				return;
			}

			layer.removeNodeAnimations(nodeName);
		};

		_proto.getParameterValue = function getParameterValue(name, type) {
			var param = this._parameters[name];

			if (param && param.type === type) {
				return param.value;
			}

			Debug.log("Cannot get parameter value. No parameter found in anim controller named \"" + name + "\" of type \"" + type + "\"");
		};

		_proto.setParameterValue = function setParameterValue(name, type, value) {
			var param = this._parameters[name];

			if (param && param.type === type) {
				param.value = value;
				return;
			}

			Debug.log("Cannot set parameter value. No parameter found in anim controller named \"" + name + "\" of type \"" + type + "\"");
		};

		_proto.getFloat = function getFloat(name) {
			return this.getParameterValue(name, ANIM_PARAMETER_FLOAT);
		};

		_proto.setFloat = function setFloat(name, value) {
			this.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);
		};

		_proto.getInteger = function getInteger(name) {
			return this.getParameterValue(name, ANIM_PARAMETER_INTEGER);
		};

		_proto.setInteger = function setInteger(name, value) {
			if (typeof value === 'number' && value % 1 === 0) {
				this.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);
			} else {
				Debug.error('Attempting to assign non integer value to integer parameter');
			}
		};

		_proto.getBoolean = function getBoolean(name) {
			return this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);
		};

		_proto.setBoolean = function setBoolean(name, value) {
			this.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);
		};

		_proto.getTrigger = function getTrigger(name) {
			return this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);
		};

		_proto.setTrigger = function setTrigger(name, singleFrame) {
			if (singleFrame === void 0) {
				singleFrame = false;
			}

			this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);

			if (singleFrame) {
				this._consumedTriggers.add(name);
			}
		};

		_proto.resetTrigger = function resetTrigger(name) {
			this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);
		};

		_proto.onBeforeRemove = function onBeforeRemove() {
			if (Number.isFinite(this._stateGraphAsset)) {
				var stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
				stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
			}
		};

		_proto.update = function update(dt) {
			var _this3 = this;

			for (var i = 0; i < this.layers.length; i++) {
				this.layers[i].update(dt * this.speed);
			}

			this._consumedTriggers.forEach(function (trigger) {
				_this3.parameters[trigger].value = false;
			});

			this._consumedTriggers.clear();
		};

		_proto.resolveDuplicatedEntityReferenceProperties = function resolveDuplicatedEntityReferenceProperties(oldAnim, duplicatedIdsMap) {
			if (oldAnim.rootBone && duplicatedIdsMap[oldAnim.rootBone.getGuid()]) {
				this.rootBone = duplicatedIdsMap[oldAnim.rootBone.getGuid()];
			} else {
				this.rebind();
			}
		};

		_createClass(AnimComponent, [{
			key: "stateGraphAsset",
			get: function get() {
				return this._stateGraphAsset;
			},
			set: function set(value) {
				var _this4 = this;

				if (value === null) {
					this.removeStateGraph();
					return;
				}

				if (this._stateGraphAsset) {
					var stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
					stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
				}

				var _id;

				var _asset;

				if (value instanceof Asset) {
					_id = value.id;
					_asset = this.system.app.assets.get(_id);

					if (!_asset) {
						this.system.app.assets.add(value);
						_asset = this.system.app.assets.get(_id);
					}
				} else {
					_id = value;
					_asset = this.system.app.assets.get(_id);
				}

				if (!_asset || this._stateGraphAsset === _id) {
					return;
				}

				if (_asset.resource) {
					this._stateGraph = _asset.resource;
					this.loadStateGraph(this._stateGraph);

					_asset.on('change', this._onStateGraphAssetChangeEvent, this);
				} else {
					_asset.once('load', function (asset) {
						_this4._stateGraph = asset.resource;

						_this4.loadStateGraph(_this4._stateGraph);
					});

					_asset.on('change', this._onStateGraphAssetChangeEvent, this);

					this.system.app.assets.load(_asset);
				}

				this._stateGraphAsset = _id;
			}
		}, {
			key: "normalizeWeights",
			get: function get() {
				return this._normalizeWeights;
			},
			set: function set(value) {
				this._normalizeWeights = value;
				this.unbind();
			}
		}, {
			key: "animationAssets",
			get: function get() {
				return this._animationAssets;
			},
			set: function set(value) {
				this._animationAssets = value;
				this.loadAnimationAssets();
			}
		}, {
			key: "speed",
			get: function get() {
				return this._speed;
			},
			set: function set(value) {
				this._speed = value;
			}
		}, {
			key: "activate",
			get: function get() {
				return this._activate;
			},
			set: function set(value) {
				this._activate = value;
			}
		}, {
			key: "playing",
			get: function get() {
				return this._playing;
			},
			set: function set(value) {
				this._playing = value;
			}
		}, {
			key: "rootBone",
			get: function get() {
				return this._rootBone;
			},
			set: function set(value) {
				if (typeof value === 'string') {
					var entity = this.entity.root.findByGuid(value);
					Debug.assert(entity, "rootBone entity for supplied guid:" + value + " cannot be found in the scene");
					this._rootBone = entity;
				} else if (value instanceof Entity) {
					this._rootBone = value;
				} else {
					this._rootBone = null;
				}

				this.rebind();
			}
		}, {
			key: "stateGraph",
			get: function get() {
				return this._stateGraph;
			},
			set: function set(value) {
				this._stateGraph = value;
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			}
		}, {
			key: "layerIndices",
			get: function get() {
				return this._layerIndices;
			},
			set: function set(value) {
				this._layerIndices = value;
			}
		}, {
			key: "parameters",
			get: function get() {
				return this._parameters;
			},
			set: function set(value) {
				this._parameters = value;
			}
		}, {
			key: "targets",
			get: function get() {
				return this._targets;
			},
			set: function set(value) {
				this._targets = value;
			}
		}, {
			key: "playable",
			get: function get() {
				for (var i = 0; i < this._layers.length; i++) {
					if (!this._layers[i].playable) {
						return false;
					}
				}

				return true;
			}
		}, {
			key: "baseLayer",
			get: function get() {
				if (this._layers.length > 0) {
					return this._layers[0];
				}

				return null;
			}
		}]);

		return AnimComponent;
	}(Component);

	var AnimComponentData = function AnimComponentData() {
		this.enabled = true;
	};

	var _schema$k = ['enabled'];

	var AnimComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(AnimComponentSystem, _ComponentSystem);

		function AnimComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'anim';
			_this.ComponentType = AnimComponent;
			_this.DataType = AnimComponentData;
			_this.schema = _schema$k;

			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

			_this.app.systems.on('animationUpdate', _this.onAnimationUpdate, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = AnimComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$k);

			var complexProperties = ['animationAssets', 'stateGraph', 'layers', 'masks'];
			Object.keys(data).forEach(function (key) {
				if (complexProperties.includes(key)) return;
				component[key] = data[key];
			});

			if (data.stateGraph) {
				component.stateGraph = data.stateGraph;
				component.loadStateGraph(component.stateGraph);
			}

			if (data.layers) {
				data.layers.forEach(function (layer, i) {
					layer._controller.states.forEach(function (stateKey) {
						layer._controller._states[stateKey]._animationList.forEach(function (node) {
							component.layers[i].assignAnimation(node.name, node.animTrack);
						});
					});
				});
			} else if (data.animationAssets) {
				component.animationAssets = Object.assign(component.animationAssets, data.animationAssets);
			}

			if (data.masks) {
				Object.keys(data.masks).forEach(function (key) {
					if (component.layers[key]) {
						var maskData = data.masks[key].mask;
						var mask = {};
						Object.keys(maskData).forEach(function (maskKey) {
							mask[decodeURI(maskKey)] = maskData[maskKey];
						});
						component.layers[key].mask = mask;
					}
				});
			}
		};

		_proto.onAnimationUpdate = function onAnimationUpdate(dt) {
			var components = this.store;

			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id].entity.anim;
					var componentData = component.data;

					if (componentData.enabled && component.entity.enabled && component.playing) {
						component.update(dt);
					}
				}
			}
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var masks;

			if (!entity.anim.rootBone || entity.anim.rootBone === entity) {
				masks = {};
				entity.anim.layers.forEach(function (layer, i) {
					if (layer.mask) {
						var mask = {};
						Object.keys(layer.mask).forEach(function (path) {
							var pathArr = path.split('/');
							pathArr.shift();
							var clonePath = [clone.name].concat(pathArr).join('/');
							mask[clonePath] = layer.mask[path];
						});
						masks[i] = {
							mask: mask
						};
					}
				});
			}

			var data = {
				stateGraphAsset: entity.anim.stateGraphAsset,
				animationAssets: entity.anim.animationAssets,
				speed: entity.anim.speed,
				activate: entity.anim.activate,
				playing: entity.anim.playing,
				rootBone: entity.anim.rootBone,
				stateGraph: entity.anim.stateGraph,
				layers: entity.anim.layers,
				layerIndices: entity.anim.layerIndices,
				parameters: entity.anim.parameters,
				normalizeWeights: entity.anim.normalizeWeights,
				masks: masks
			};
			return this.addComponent(clone, data);
		};

		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			component.onBeforeRemove();
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off('animationUpdate', this.onAnimationUpdate, this);
		};

		return AnimComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(AnimComponent.prototype, _schema$k);

	var AudioListenerComponent = function (_Component) {
		_inheritsLoose(AudioListenerComponent, _Component);

		function AudioListenerComponent(system, entity) {
			return _Component.call(this, system, entity) || this;
		}

		var _proto = AudioListenerComponent.prototype;

		_proto.setCurrentListener = function setCurrentListener() {
			if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
				this.system.current = this.entity;
				var position = this.system.current.getPosition();
				this.system.manager.listener.setPosition(position);
			}
		};

		_proto.onEnable = function onEnable() {
			this.setCurrentListener();
		};

		_proto.onDisable = function onDisable() {
			if (this.system.current === this.entity) {
				this.system.current = null;
			}
		};

		return AudioListenerComponent;
	}(Component);

	var AudioListenerComponentData = function AudioListenerComponentData() {
		this.enabled = true;
	};

	var _schema$j = ['enabled'];

	var AudioListenerComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(AudioListenerComponentSystem, _ComponentSystem);

		function AudioListenerComponentSystem(app, manager) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = "audiolistener";
			_this.ComponentType = AudioListenerComponent;
			_this.DataType = AudioListenerComponentData;
			_this.schema = _schema$j;
			_this.manager = manager;
			_this.current = null;

			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = AudioListenerComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['enabled'];

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};

		_proto.onUpdate = function onUpdate(dt) {
			if (this.current) {
				var position = this.current.getPosition();
				this.manager.listener.setPosition(position);
				var wtm = this.current.getWorldTransform();
				this.manager.listener.setOrientation(wtm);
			}
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off('update', this.onUpdate, this);
		};

		return AudioListenerComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(AudioListenerComponent.prototype, _schema$j);

	var AudioSourceComponent = function (_Component) {
		_inheritsLoose(AudioSourceComponent, _Component);

		function AudioSourceComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;

			_this.on("set_assets", _this.onSetAssets, _assertThisInitialized(_this));

			_this.on("set_loop", _this.onSetLoop, _assertThisInitialized(_this));

			_this.on("set_volume", _this.onSetVolume, _assertThisInitialized(_this));

			_this.on("set_pitch", _this.onSetPitch, _assertThisInitialized(_this));

			_this.on("set_minDistance", _this.onSetMinDistance, _assertThisInitialized(_this));

			_this.on("set_maxDistance", _this.onSetMaxDistance, _assertThisInitialized(_this));

			_this.on("set_rollOffFactor", _this.onSetRollOffFactor, _assertThisInitialized(_this));

			_this.on("set_distanceModel", _this.onSetDistanceModel, _assertThisInitialized(_this));

			_this.on("set_3d", _this.onSet3d, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = AudioSourceComponent.prototype;

		_proto.play = function play(name) {
			if (!this.enabled || !this.entity.enabled) {
				return;
			}

			if (this.channel) {
				this.stop();
			}

			var channel;
			var componentData = this.data;

			if (componentData.sources[name]) {
				if (!componentData['3d']) {
					channel = this.system.manager.playSound(componentData.sources[name], componentData);
					componentData.currentSource = name;
					componentData.channel = channel;
				} else {
					var pos = this.entity.getPosition();
					channel = this.system.manager.playSound3d(componentData.sources[name], pos, componentData);
					componentData.currentSource = name;
					componentData.channel = channel;
				}
			}
		};

		_proto.pause = function pause() {
			if (this.channel) {
				this.channel.pause();
			}
		};

		_proto.unpause = function unpause() {
			if (this.channel && this.channel.paused) {
				this.channel.unpause();
			}
		};

		_proto.stop = function stop() {
			if (this.channel) {
				this.channel.stop();
				this.channel = null;
			}
		};

		_proto.onSetAssets = function onSetAssets(name, oldValue, newValue) {
			var newAssets = [];
			var len = newValue.length;

			if (oldValue && oldValue.length) {
				for (var i = 0; i < oldValue.length; i++) {
					if (oldValue[i]) {
						var asset = this.system.app.assets.get(oldValue[i]);

						if (asset) {
							asset.off('change', this.onAssetChanged, this);
							asset.off('remove', this.onAssetRemoved, this);

							if (this.currentSource === asset.name) {
								this.stop();
							}
						}
					}
				}
			}

			if (len) {
				for (var _i = 0; _i < len; _i++) {
					if (oldValue.indexOf(newValue[_i]) < 0) {
						if (newValue[_i] instanceof Asset) {
							newAssets.push(newValue[_i].id);
						} else {
							newAssets.push(newValue[_i]);
						}
					}
				}
			}

			if (!this.system._inTools && newAssets.length) {
				this.loadAudioSourceAssets(newAssets);
			}
		};

		_proto.onAssetChanged = function onAssetChanged(asset, attribute, newValue, oldValue) {
			if (attribute === 'resource') {
				var sources = this.data.sources;

				if (sources) {
					this.data.sources[asset.name] = newValue;

					if (this.data.currentSource === asset.name) {
						if (this.channel) {
							if (this.channel.paused) {
								this.play(asset.name);
								this.pause();
							} else {
								this.play(asset.name);
							}
						}
					}
				}
			}
		};

		_proto.onAssetRemoved = function onAssetRemoved(asset) {
			asset.off('remove', this.onAssetRemoved, this);

			if (this.data.sources[asset.name]) {
				delete this.data.sources[asset.name];

				if (this.data.currentSource === asset.name) {
					this.stop();
					this.data.currentSource = null;
				}
			}
		};

		_proto.onSetLoop = function onSetLoop(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel) {
					this.channel.setLoop(newValue);
				}
			}
		};

		_proto.onSetVolume = function onSetVolume(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel) {
					this.channel.setVolume(newValue);
				}
			}
		};

		_proto.onSetPitch = function onSetPitch(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel) {
					this.channel.setPitch(newValue);
				}
			}
		};

		_proto.onSetMaxDistance = function onSetMaxDistance(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel instanceof Channel3d) {
					this.channel.setMaxDistance(newValue);
				}
			}
		};

		_proto.onSetMinDistance = function onSetMinDistance(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel instanceof Channel3d) {
					this.channel.setMinDistance(newValue);
				}
			}
		};

		_proto.onSetRollOffFactor = function onSetRollOffFactor(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel instanceof Channel3d) {
					this.channel.setRollOffFactor(newValue);
				}
			}
		};

		_proto.onSetDistanceModel = function onSetDistanceModel(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel instanceof Channel3d) {
					this.channel.setDistanceModel(newValue);
				}
			}
		};

		_proto.onSet3d = function onSet3d(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.system.initialized && this.currentSource) {
					var paused = false;
					var suspended = false;

					if (this.channel) {
						paused = this.channel.paused;
						suspended = this.channel.suspended;
					}

					this.play(this.currentSource);

					if (this.channel) {
						this.channel.paused = paused;
						this.channel.suspended = suspended;
					}
				}
			}
		};

		_proto.onEnable = function onEnable() {
			var assets = this.data.assets;

			if (assets) {
				var registry = this.system.app.assets;

				for (var i = 0, len = assets.length; i < len; i++) {
					var asset = assets[i];
					if (!(asset instanceof Asset)) asset = registry.get(asset);

					if (asset && !asset.resource) {
						registry.load(asset);
					}
				}
			}

			if (this.system.initialized) {
				if (this.data.activate && !this.channel) {
					this.play(this.currentSource);
				} else {
					this.unpause();
				}
			}
		};

		_proto.onDisable = function onDisable() {
			this.pause();
		};

		_proto.loadAudioSourceAssets = function loadAudioSourceAssets(ids) {
			var _this2 = this;

			var assets = ids.map(function (id) {
				return _this2.system.app.assets.get(id);
			});
			var sources = {};
			var currentSource = null;
			var count = assets.length;

			var _error = function _error(e) {
				count--;
			};

			var _done = function _done() {
				_this2.data.sources = sources;
				_this2.data.currentSource = currentSource;

				if (_this2.enabled && _this2.activate && currentSource) {
					_this2.onEnable();
				}
			};

			assets.forEach(function (asset, index) {
				if (asset) {
					currentSource = currentSource || asset.name;
					asset.off('change', _this2.onAssetChanged, _this2);
					asset.on('change', _this2.onAssetChanged, _this2);
					asset.off('remove', _this2.onAssetRemoved, _this2);
					asset.on('remove', _this2.onAssetRemoved, _this2);
					asset.off('error', _error, _this2);
					asset.on('error', _error, _this2);
					asset.ready(function (asset) {
						sources[asset.name] = asset.resource;
						count--;

						if (count === 0) {
							_done();
						}
					});
					if (!asset.resource && _this2.enabled && _this2.entity.enabled) _this2.system.app.assets.load(asset);
				} else {
					count--;

					if (count === 0) {
						_done();
					}

					_this2.system.app.assets.on("add:" + ids[index], function (asset) {
						asset.ready(function (asset) {
							_this2.data.sources[asset.name] = asset.resource;
						});
						if (!asset.resource) _this2.system.app.assets.load(asset);
					});
				}
			});
		};

		return AudioSourceComponent;
	}(Component);

	var AudioSourceComponentData = function AudioSourceComponentData() {
		this.enabled = true;
		this.assets = [];
		this.activate = true;
		this.volume = 1;
		this.pitch = 1;
		this.loop = false;
		this['3d'] = true;
		this.minDistance = 1;
		this.maxDistance = 10000;
		this.rollOffFactor = 1;
		this.distanceModel = DISTANCE_INVERSE;
		this.paused = true;
		this.sources = {};
		this.currentSource = null;
		this.channel = null;
	};

	var _schema$i = ['enabled', 'assets', 'volume', 'pitch', 'loop', 'activate', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'sources', 'currentSource', 'channel'];

	var AudioSourceComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(AudioSourceComponentSystem, _ComponentSystem);

		function AudioSourceComponentSystem(app, manager) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = "audiosource";
			_this.ComponentType = AudioSourceComponent;
			_this.DataType = AudioSourceComponentData;
			_this.schema = _schema$i;
			_this.manager = manager;
			_this.initialized = false;

			_this.app.systems.on('initialize', _this.onInitialize, _assertThisInitialized(_this));

			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

			_this.on('remove', _this.onRemove, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = AudioSourceComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['activate', 'volume', 'pitch', 'loop', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'enabled', 'assets'];

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);

			component.paused = !(component.enabled && component.activate);
		};

		_proto.onInitialize = function onInitialize(root) {
			if (root.audiosource && root.enabled && root.audiosource.enabled && root.audiosource.activate) {
				root.audiosource.play(root.audiosource.currentSource);
			}

			var children = root._children;

			for (var i = 0, len = children.length; i < len; i++) {
				if (children[i] instanceof Entity) {
					this.onInitialize(children[i]);
				}
			}

			this.initialized = true;
		};

		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;

			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					var entity = component.entity;
					var componentData = component.data;

					if (componentData.enabled && entity.enabled && componentData.channel instanceof Channel3d) {
						var pos = entity.getPosition();
						componentData.channel.setPosition(pos);
					}
				}
			}
		};

		_proto.onRemove = function onRemove(entity, data) {
			if (data.channel) {
				data.channel.stop();
				data.channel = null;
			}
		};

		_proto.setVolume = function setVolume(volume) {
			this.manager.setVolume(volume);
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off('initialize', this.onInitialize, this);
			this.app.systems.off('update', this.onUpdate, this);
		};

		return AudioSourceComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(AudioSourceComponent.prototype, _schema$i);

	var EntityReference = function (_EventHandler) {
		_inheritsLoose(EntityReference, _EventHandler);

		function EntityReference(parentComponent, entityPropertyName, eventConfig) {
			var _this;

			_this = _EventHandler.call(this) || this;

			if (!parentComponent || !(parentComponent instanceof Component)) {
				throw new Error('The parentComponent argument is required and must be a Component');
			} else if (!entityPropertyName || typeof entityPropertyName !== 'string') {
				throw new Error('The propertyName argument is required and must be a string');
			} else if (eventConfig && typeof eventConfig !== 'object') {
				throw new Error('If provided, the eventConfig argument must be an object');
			}

			_this._parentComponent = parentComponent;
			_this._entityPropertyName = entityPropertyName;
			_this._entity = null;
			_this._app = parentComponent.system.app;

			_this._configureEventListeners(eventConfig || {}, {
				'entity#destroy': _this._onEntityDestroy
			});

			_this._toggleLifecycleListeners('on');

			return _this;
		}

		var _proto = EntityReference.prototype;

		_proto._configureEventListeners = function _configureEventListeners(externalEventConfig, internalEventConfig) {
			var externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, 'external', this._parentComponent);

			var internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, 'internal', this);

			this._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);
			this._listenerStatusFlags = {};
			this._gainListeners = {};
			this._loseListeners = {};
		};

		_proto._parseEventListenerConfig = function _parseEventListenerConfig(eventConfig, prefix, scope) {
			return Object.keys(eventConfig).map(function (listenerDescription, index) {
				var listenerDescriptionParts = listenerDescription.split('#');
				var sourceName = listenerDescriptionParts[0];
				var eventName = listenerDescriptionParts[1];
				var callback = eventConfig[listenerDescription];

				if (listenerDescriptionParts.length !== 2 || typeof sourceName !== 'string' || sourceName.length === 0 || typeof eventName !== 'string' || eventName.length === 0) {
					throw new Error('Invalid event listener description: `' + listenerDescription + '`');
				}

				if (typeof callback !== 'function') {
					throw new Error('Invalid or missing callback for event listener `' + listenerDescription + '`');
				}

				return {
					id: prefix + '_' + index + '_' + listenerDescription,
					sourceName: sourceName,
					eventName: eventName,
					callback: callback,
					scope: scope
				};
			}, this);
		};

		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff) {
			this._parentComponent[onOrOff]('set_' + this._entityPropertyName, this._onSetEntity, this);

			this._parentComponent.system[onOrOff]('beforeremove', this._onParentComponentRemove, this);

			this._app.systems[onOrOff]('postPostInitialize', this._updateEntityReference, this);

			this._app[onOrOff]('tools:sceneloaded', this._onSceneLoaded, this);

			var allComponentSystems = [];

			for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
				var config = this._eventListenerConfigs[i];
				var componentSystem = this._app.systems[config.sourceName];

				if (componentSystem) {
					if (allComponentSystems.indexOf(componentSystem) === -1) {
						allComponentSystems.push(componentSystem);
					}

					if (componentSystem && config.eventName === 'gain') {
						this._gainListeners[config.sourceName] = config;
					}

					if (componentSystem && config.eventName === 'lose') {
						this._loseListeners[config.sourceName] = config;
					}
				}
			}

			for (var _i = 0; _i < allComponentSystems.length; ++_i) {
				allComponentSystems[_i][onOrOff]('add', this._onComponentAdd, this);

				allComponentSystems[_i][onOrOff]('beforeremove', this._onComponentRemove, this);
			}
		};

		_proto._onSetEntity = function _onSetEntity(name, oldValue, newValue) {
			if (newValue instanceof Entity) {
				this._updateEntityReference();
			} else {
				if (newValue !== null && newValue !== undefined && typeof newValue !== 'string') {
					console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + typeof newValue + "'");
					return;
				}

				if (oldValue !== newValue) {
					this._updateEntityReference();
				}
			}
		};

		_proto.onParentComponentEnable = function onParentComponentEnable() {
			if (!this._entity) {
				this._updateEntityReference();
			}
		};

		_proto._onSceneLoaded = function _onSceneLoaded() {
			this._updateEntityReference();
		};

		_proto._updateEntityReference = function _updateEntityReference() {
			var nextEntityGuid = this._parentComponent.data[this._entityPropertyName];
			var nextEntity;

			if (nextEntityGuid instanceof Entity) {
				nextEntity = nextEntityGuid;
				nextEntityGuid = nextEntity.getGuid();
				this._parentComponent.data[this._entityPropertyName] = nextEntityGuid;
			} else {
				var root = this._parentComponent.system.app.root;

				var isOnSceneGraph = this._parentComponent.entity.isDescendantOf(root);

				nextEntity = isOnSceneGraph && nextEntityGuid ? root.findByGuid(nextEntityGuid) : null;
			}

			var hasChanged = this._entity !== nextEntity;

			if (hasChanged) {
				if (this._entity) {
					this._onBeforeEntityChange();
				}

				this._entity = nextEntity;

				if (this._entity) {
					this._onAfterEntityChange();
				}

				this.fire('set:entity', this._entity);
			}
		};

		_proto._onBeforeEntityChange = function _onBeforeEntityChange() {
			this._toggleEntityListeners('off');

			this._callAllGainOrLoseListeners(this._loseListeners);
		};

		_proto._onAfterEntityChange = function _onAfterEntityChange() {
			this._toggleEntityListeners('on');

			this._callAllGainOrLoseListeners(this._gainListeners);
		};

		_proto._onComponentAdd = function _onComponentAdd(entity, component) {
			var componentName = component.system.id;

			if (entity === this._entity) {
				this._callGainOrLoseListener(componentName, this._gainListeners);

				this._toggleComponentListeners('on', componentName);
			}
		};

		_proto._onComponentRemove = function _onComponentRemove(entity, component) {
			var componentName = component.system.id;

			if (entity === this._entity) {
				this._callGainOrLoseListener(componentName, this._loseListeners);

				this._toggleComponentListeners('off', componentName, true);
			}
		};

		_proto._callAllGainOrLoseListeners = function _callAllGainOrLoseListeners(listenerMap) {
			for (var componentName in this._entity.c) {
				this._callGainOrLoseListener(componentName, listenerMap);
			}
		};

		_proto._callGainOrLoseListener = function _callGainOrLoseListener(componentName, listenerMap) {
			if (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {
				var config = listenerMap[componentName];
				config.callback.call(config.scope);
			}
		};

		_proto._toggleEntityListeners = function _toggleEntityListeners(onOrOff, isDestroying) {
			if (this._entity) {
				for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
					this._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);
				}
			}
		};

		_proto._toggleComponentListeners = function _toggleComponentListeners(onOrOff, componentName, isDestroying) {
			for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
				var config = this._eventListenerConfigs[i];

				if (config.sourceName === componentName) {
					this._safeToggleListener(onOrOff, config, isDestroying);
				}
			}
		};

		_proto._safeToggleListener = function _safeToggleListener(onOrOff, config, isDestroying) {
			var isAdding = onOrOff === 'on';

			if (isAdding && this._listenerStatusFlags[config.id]) {
				return;
			}

			var source = this._getEventSource(config.sourceName, isDestroying);

			if (source) {
				source[onOrOff](config.eventName, config.callback, config.scope);
				this._listenerStatusFlags[config.id] = isAdding;
			}
		};

		_proto._getEventSource = function _getEventSource(sourceName, isDestroying) {
			if (sourceName === 'entity') {
				return this._entity;
			}

			var component = this._entity[sourceName];

			if (component) {
				return component;
			}

			if (!isDestroying) {
				console.warn('Entity has no component with name ' + sourceName);
			}

			return null;
		};

		_proto._onEntityDestroy = function _onEntityDestroy(entity) {
			if (this._entity === entity) {
				this._toggleEntityListeners('off', true);

				this._entity = null;
			}
		};

		_proto._onParentComponentRemove = function _onParentComponentRemove(entity, component) {
			if (component === this._parentComponent) {
				this._toggleLifecycleListeners('off');

				this._toggleEntityListeners('off', true);
			}
		};

		_proto.hasComponent = function hasComponent(componentName) {
			return this._entity && this._entity.c ? !!this._entity.c[componentName] : false;
		};

		_createClass(EntityReference, [{
			key: "entity",
			get: function get() {
				return this._entity;
			}
		}]);

		return EntityReference;
	}(EventHandler);

	var BUTTON_TRANSITION_MODE_TINT = 0;
	var BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;

	var ELEMENTTYPE_GROUP = 'group';
	var ELEMENTTYPE_IMAGE = 'image';
	var ELEMENTTYPE_TEXT = 'text';

	var VisualState = {
		DEFAULT: 'DEFAULT',
		HOVER: 'HOVER',
		PRESSED: 'PRESSED',
		INACTIVE: 'INACTIVE'
	};
	var STATES_TO_TINT_NAMES = {};
	STATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';
	STATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';
	STATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';
	STATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';
	var STATES_TO_SPRITE_ASSET_NAMES = {};
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';
	var STATES_TO_SPRITE_FRAME_NAMES = {};
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';

	var ButtonComponent = function (_Component) {
		_inheritsLoose(ButtonComponent, _Component);

		function ButtonComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._visualState = VisualState.DEFAULT;
			_this._isHovering = false;
			_this._hoveringCounter = 0;
			_this._isPressed = false;
			_this._defaultTint = new Color(1, 1, 1, 1);
			_this._defaultSpriteAsset = null;
			_this._defaultSpriteFrame = 0;
			_this._imageReference = new EntityReference(_assertThisInitialized(_this), 'imageEntity', {
				'element#gain': _this._onImageElementGain,
				'element#lose': _this._onImageElementLose,
				'element#set:color': _this._onSetColor,
				'element#set:opacity': _this._onSetOpacity,
				'element#set:spriteAsset': _this._onSetSpriteAsset,
				'element#set:spriteFrame': _this._onSetSpriteFrame
			});

			_this._toggleLifecycleListeners('on', system);

			return _this;
		}

		var _proto = ButtonComponent.prototype;

		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff, system) {
			this[onOrOff]('set_active', this._onSetActive, this);
			this[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);
			this[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);
			this[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);
			this[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);
			this[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);
			this[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);
			this[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);
			this[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);
			this[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);
			this[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);
			system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
			system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
		};

		_proto._onSetActive = function _onSetActive(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this._updateVisualState();
			}
		};

		_proto._onSetTransitionMode = function _onSetTransitionMode(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this._cancelTween();

				this._resetToDefaultVisualState(oldValue);

				this._forceReapplyVisualState();
			}
		};

		_proto._onSetTransitionValue = function _onSetTransitionValue(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this._forceReapplyVisualState();
			}
		};

		_proto._onElementComponentRemove = function _onElementComponentRemove(entity) {
			if (this.entity === entity) {
				this._toggleHitElementListeners('off');
			}
		};

		_proto._onElementComponentAdd = function _onElementComponentAdd(entity) {
			if (this.entity === entity) {
				this._toggleHitElementListeners('on');
			}
		};

		_proto._onImageElementLose = function _onImageElementLose() {
			this._cancelTween();

			this._resetToDefaultVisualState(this.transitionMode);
		};

		_proto._onImageElementGain = function _onImageElementGain() {
			this._storeDefaultVisualState();

			this._forceReapplyVisualState();
		};

		_proto._toggleHitElementListeners = function _toggleHitElementListeners(onOrOff) {
			if (this.entity.element) {
				var isAdding = onOrOff === 'on';

				if (isAdding && this._hasHitElementListeners) {
					return;
				}

				this.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);
				this.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);
				this.entity.element[onOrOff]('mousedown', this._onMouseDown, this);
				this.entity.element[onOrOff]('mouseup', this._onMouseUp, this);
				this.entity.element[onOrOff]('touchstart', this._onTouchStart, this);
				this.entity.element[onOrOff]('touchend', this._onTouchEnd, this);
				this.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);
				this.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);
				this.entity.element[onOrOff]('selectstart', this._onSelectStart, this);
				this.entity.element[onOrOff]('selectend', this._onSelectEnd, this);
				this.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);
				this.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);
				this.entity.element[onOrOff]('click', this._onClick, this);
				this._hasHitElementListeners = isAdding;
			}
		};

		_proto._storeDefaultVisualState = function _storeDefaultVisualState() {
			if (this._imageReference.hasComponent('element')) {
				var element = this._imageReference.entity.element;

				if (element.type !== ELEMENTTYPE_GROUP) {
					this._storeDefaultColor(element.color);

					this._storeDefaultOpacity(element.opacity);

					this._storeDefaultSpriteAsset(element.spriteAsset);

					this._storeDefaultSpriteFrame(element.spriteFrame);
				}
			}
		};

		_proto._storeDefaultColor = function _storeDefaultColor(color) {
			this._defaultTint.r = color.r;
			this._defaultTint.g = color.g;
			this._defaultTint.b = color.b;
		};

		_proto._storeDefaultOpacity = function _storeDefaultOpacity(opacity) {
			this._defaultTint.a = opacity;
		};

		_proto._storeDefaultSpriteAsset = function _storeDefaultSpriteAsset(spriteAsset) {
			this._defaultSpriteAsset = spriteAsset;
		};

		_proto._storeDefaultSpriteFrame = function _storeDefaultSpriteFrame(spriteFrame) {
			this._defaultSpriteFrame = spriteFrame;
		};

		_proto._onSetColor = function _onSetColor(color) {
			if (!this._isApplyingTint) {
				this._storeDefaultColor(color);

				this._forceReapplyVisualState();
			}
		};

		_proto._onSetOpacity = function _onSetOpacity(opacity) {
			if (!this._isApplyingTint) {
				this._storeDefaultOpacity(opacity);

				this._forceReapplyVisualState();
			}
		};

		_proto._onSetSpriteAsset = function _onSetSpriteAsset(spriteAsset) {
			if (!this._isApplyingSprite) {
				this._storeDefaultSpriteAsset(spriteAsset);

				this._forceReapplyVisualState();
			}
		};

		_proto._onSetSpriteFrame = function _onSetSpriteFrame(spriteFrame) {
			if (!this._isApplyingSprite) {
				this._storeDefaultSpriteFrame(spriteFrame);

				this._forceReapplyVisualState();
			}
		};

		_proto._onMouseEnter = function _onMouseEnter(event) {
			this._isHovering = true;

			this._updateVisualState();

			this._fireIfActive('mouseenter', event);
		};

		_proto._onMouseLeave = function _onMouseLeave(event) {
			this._isHovering = false;
			this._isPressed = false;

			this._updateVisualState();

			this._fireIfActive('mouseleave', event);
		};

		_proto._onMouseDown = function _onMouseDown(event) {
			this._isPressed = true;

			this._updateVisualState();

			this._fireIfActive('mousedown', event);
		};

		_proto._onMouseUp = function _onMouseUp(event) {
			this._isPressed = false;

			this._updateVisualState();

			this._fireIfActive('mouseup', event);
		};

		_proto._onTouchStart = function _onTouchStart(event) {
			this._isPressed = true;

			this._updateVisualState();

			this._fireIfActive('touchstart', event);
		};

		_proto._onTouchEnd = function _onTouchEnd(event) {
			event.event.preventDefault();
			this._isPressed = false;

			this._updateVisualState();

			this._fireIfActive('touchend', event);
		};

		_proto._onTouchLeave = function _onTouchLeave(event) {
			this._isPressed = false;

			this._updateVisualState();

			this._fireIfActive('touchleave', event);
		};

		_proto._onTouchCancel = function _onTouchCancel(event) {
			this._isPressed = false;

			this._updateVisualState();

			this._fireIfActive('touchcancel', event);
		};

		_proto._onSelectStart = function _onSelectStart(event) {
			this._isPressed = true;

			this._updateVisualState();

			this._fireIfActive('selectstart', event);
		};

		_proto._onSelectEnd = function _onSelectEnd(event) {
			this._isPressed = false;

			this._updateVisualState();

			this._fireIfActive('selectend', event);
		};

		_proto._onSelectEnter = function _onSelectEnter(event) {
			this._hoveringCounter++;

			if (this._hoveringCounter === 1) {
				this._isHovering = true;

				this._updateVisualState();
			}

			this._fireIfActive('selectenter', event);
		};

		_proto._onSelectLeave = function _onSelectLeave(event) {
			this._hoveringCounter--;

			if (this._hoveringCounter === 0) {
				this._isHovering = false;
				this._isPressed = false;

				this._updateVisualState();
			}

			this._fireIfActive('selectleave', event);
		};

		_proto._onClick = function _onClick(event) {
			this._fireIfActive('click', event);
		};

		_proto._fireIfActive = function _fireIfActive(name, event) {
			if (this.data.active) {
				this.fire(name, event);
			}
		};

		_proto._updateVisualState = function _updateVisualState(force) {
			var oldVisualState = this._visualState;

			var newVisualState = this._determineVisualState();

			if ((oldVisualState !== newVisualState || force) && this.enabled) {
				this._visualState = newVisualState;

				if (oldVisualState === VisualState.HOVER) {
					this._fireIfActive('hoverend');
				}

				if (oldVisualState === VisualState.PRESSED) {
					this._fireIfActive('pressedend');
				}

				if (newVisualState === VisualState.HOVER) {
					this._fireIfActive('hoverstart');
				}

				if (newVisualState === VisualState.PRESSED) {
					this._fireIfActive('pressedstart');
				}

				switch (this.transitionMode) {
					case BUTTON_TRANSITION_MODE_TINT:
						{
							var tintName = STATES_TO_TINT_NAMES[this._visualState];
							var tintColor = this[tintName];

							this._applyTint(tintColor);

							break;
						}

					case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
						{
							var spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];
							var spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];
							var spriteAsset = this[spriteAssetName];
							var spriteFrame = this[spriteFrameName];

							this._applySprite(spriteAsset, spriteFrame);

							break;
						}
				}
			}
		};

		_proto._forceReapplyVisualState = function _forceReapplyVisualState() {
			this._updateVisualState(true);
		};

		_proto._resetToDefaultVisualState = function _resetToDefaultVisualState(transitionMode) {
			if (this._imageReference.hasComponent('element')) {
				switch (transitionMode) {
					case BUTTON_TRANSITION_MODE_TINT:
						this._cancelTween();

						this._applyTintImmediately(this._defaultTint);

						break;

					case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
						this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);

						break;
				}
			}
		};

		_proto._determineVisualState = function _determineVisualState() {
			if (!this.active) {
				return VisualState.INACTIVE;
			} else if (this._isPressed) {
				return VisualState.PRESSED;
			} else if (this._isHovering) {
				return VisualState.HOVER;
			}

			return VisualState.DEFAULT;
		};

		_proto._applySprite = function _applySprite(spriteAsset, spriteFrame) {
			spriteFrame = spriteFrame || 0;

			if (this._imageReference.hasComponent('element')) {
				this._isApplyingSprite = true;

				if (this._imageReference.entity.element.spriteAsset !== spriteAsset) {
					this._imageReference.entity.element.spriteAsset = spriteAsset;
				}

				if (this._imageReference.entity.element.spriteFrame !== spriteFrame) {
					this._imageReference.entity.element.spriteFrame = spriteFrame;
				}

				this._isApplyingSprite = false;
			}
		};

		_proto._applyTint = function _applyTint(tintColor) {
			this._cancelTween();

			if (this.fadeDuration === 0) {
				this._applyTintImmediately(tintColor);
			} else {
				this._applyTintWithTween(tintColor);
			}
		};

		_proto._applyTintImmediately = function _applyTintImmediately(tintColor) {
			if (!tintColor || !this._imageReference.hasComponent('element') || this._imageReference.entity.element.type === ELEMENTTYPE_GROUP) return;
			var color3 = toColor3(tintColor);
			this._isApplyingTint = true;
			if (!color3.equals(this._imageReference.entity.element.color)) this._imageReference.entity.element.color = color3;
			if (this._imageReference.entity.element.opacity != tintColor.a) this._imageReference.entity.element.opacity = tintColor.a;
			this._isApplyingTint = false;
		};

		_proto._applyTintWithTween = function _applyTintWithTween(tintColor) {
			if (!tintColor || !this._imageReference.hasComponent('element') || this._imageReference.entity.element.type === ELEMENTTYPE_GROUP) return;
			var color3 = toColor3(tintColor);
			var color = this._imageReference.entity.element.color;
			var opacity = this._imageReference.entity.element.opacity;
			if (color3.equals(color) && tintColor.a == opacity) return;
			this._tweenInfo = {
				startTime: now(),
				from: new Color(color.r, color.g, color.b, opacity),
				to: tintColor.clone(),
				lerpColor: new Color()
			};
		};

		_proto._updateTintTween = function _updateTintTween() {
			var elapsedTime = now() - this._tweenInfo.startTime;

			var elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;
			elapsedProportion = math.clamp(elapsedProportion, 0, 1);

			if (Math.abs(elapsedProportion - 1) > 1e-5) {
				var lerpColor = this._tweenInfo.lerpColor;
				lerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);

				this._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));
			} else {
				this._applyTintImmediately(this._tweenInfo.to);

				this._cancelTween();
			}
		};

		_proto._cancelTween = function _cancelTween() {
			delete this._tweenInfo;
		};

		_proto.onUpdate = function onUpdate() {
			if (this._tweenInfo) {
				this._updateTintTween();
			}
		};

		_proto.onEnable = function onEnable() {
			this._isHovering = false;
			this._hoveringCounter = 0;
			this._isPressed = false;

			this._imageReference.onParentComponentEnable();

			this._toggleHitElementListeners('on');

			this._forceReapplyVisualState();
		};

		_proto.onDisable = function onDisable() {
			this._toggleHitElementListeners('off');

			this._resetToDefaultVisualState(this.transitionMode);
		};

		_proto.onRemove = function onRemove() {
			this._toggleLifecycleListeners('off', this.system);

			this.onDisable();
		};

		return ButtonComponent;
	}(Component);

	function toColor3(color4) {
		return new Color(color4.r, color4.g, color4.b);
	}

	var ButtonComponentData = function ButtonComponentData() {
		this.enabled = true;
		this.active = true;
		this.imageEntity = null;
		this.hitPadding = new Vec4();
		this.transitionMode = BUTTON_TRANSITION_MODE_TINT;
		this.hoverTint = new Color(0.75, 0.75, 0.75);
		this.pressedTint = new Color(0.5, 0.5, 0.5);
		this.inactiveTint = new Color(0.25, 0.25, 0.25);
		this.fadeDuration = 0;
		this.hoverSpriteAsset = null;
		this.hoverSpriteFrame = 0;
		this.pressedSpriteAsset = null;
		this.pressedSpriteFrame = 0;
		this.inactiveSpriteAsset = null;
		this.inactiveSpriteFrame = 0;
	};

	var _schema$h = ['enabled', 'active', {
		name: 'imageEntity',
		type: 'entity'
	}, {
		name: 'hitPadding',
		type: 'vec4'
	}, 'transitionMode', {
		name: 'hoverTint',
		type: 'rgba'
	}, {
		name: 'pressedTint',
		type: 'rgba'
	}, {
		name: 'inactiveTint',
		type: 'rgba'
	}, 'fadeDuration', 'hoverSpriteAsset', 'hoverSpriteFrame', 'pressedSpriteAsset', 'pressedSpriteFrame', 'inactiveSpriteAsset', 'inactiveSpriteFrame'];

	var ButtonComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ButtonComponentSystem, _ComponentSystem);

		function ButtonComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'button';
			_this.ComponentType = ButtonComponent;
			_this.DataType = ButtonComponentData;
			_this.schema = _schema$h;

			_this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));

			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = ButtonComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$h);
		};

		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;

			for (var id in components) {
				var entity = components[id].entity;
				var component = entity.button;

				if (component.enabled && entity.enabled) {
					component.onUpdate();
				}
			}
		};

		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off('update', this.onUpdate, this);
		};

		return ButtonComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ButtonComponent.prototype, _schema$h);

	var depthLayer$1;

	var PostEffect = function PostEffect(effect, inputTarget) {
		this.effect = effect;
		this.inputTarget = inputTarget;
		this.outputTarget = null;
		this.name = effect.constructor.name;
	};

	var PostEffectQueue = function () {
		function PostEffectQueue(app, camera) {
			var _this = this;

			this.app = app;
			this.camera = camera;
			this.destinationRenderTarget = null;
			this.effects = [];
			this.enabled = false;
			this.depthTarget = null;
			this.renderTargetScale = 1;
			this.resizeTimeout = null;
			this.resizeLast = 0;

			this._resizeTimeoutCallback = function () {
				_this.resizeRenderTargets();
			};

			camera.on('set:rect', this.onCameraRectChanged, this);
		}

		var _proto = PostEffectQueue.prototype;

		_proto._allocateColorBuffer = function _allocateColorBuffer(format, name) {
			var rect = this.camera.rect;
			var width = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
			var height = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
			var colorBuffer = new Texture(this.app.graphicsDevice, {
				name: name,
				format: format,
				width: width,
				height: height,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			return colorBuffer;
		};

		_proto._createOffscreenTarget = function _createOffscreenTarget(useDepth, hdr) {
			var device = this.app.graphicsDevice;
			var format = hdr ? device.getHdrFormat() : PIXELFORMAT_R8_G8_B8_A8;
			var name = this.camera.entity.name + '-posteffect-' + this.effects.length;

			var colorBuffer = this._allocateColorBuffer(format, name);

			var useStencil = this.app.graphicsDevice.supportsStencil;
			var samples = useDepth ? device.samples : 1;
			return new RenderTarget({
				colorBuffer: colorBuffer,
				depth: useDepth,
				stencil: useStencil,
				samples: samples
			});
		};

		_proto._resizeOffscreenTarget = function _resizeOffscreenTarget(rt) {
			var format = rt.colorBuffer.format;
			var name = rt.colorBuffer.name;
			rt.destroyFrameBuffers();
			rt.destroyTextureBuffers();
			rt._colorBuffer = this._allocateColorBuffer(format, name);
		};

		_proto._destroyOffscreenTarget = function _destroyOffscreenTarget(rt) {
			rt.destroyTextureBuffers();
			rt.destroy();
		};

		_proto.setRenderTargetScale = function setRenderTargetScale(scale) {
			this.renderTargetScale = scale;
			this.resizeRenderTargets();
		};

		_proto.addEffect = function addEffect(effect) {
			var effects = this.effects;
			var isFirstEffect = effects.length === 0;

			var inputTarget = this._createOffscreenTarget(isFirstEffect, effect.hdr);

			var newEntry = new PostEffect(effect, inputTarget);
			effects.push(newEntry);
			this._sourceTarget = newEntry.inputTarget;

			if (effects.length > 1) {
				effects[effects.length - 2].outputTarget = newEntry.inputTarget;
			}

			this._newPostEffect = effect;

			if (effect.needsDepthBuffer) {
				this._requestDepthMap();
			}

			this.enable();
			this._newPostEffect = undefined;
		};

		_proto.removeEffect = function removeEffect(effect) {
			var index = -1;

			for (var i = 0, len = this.effects.length; i < len; i++) {
				if (this.effects[i].effect === effect) {
					index = i;
					break;
				}
			}

			if (index >= 0) {
				if (index > 0) {
					this.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;
				} else {
					if (this.effects.length > 1) {
						if (!this.effects[1].inputTarget._depth) {
							this._destroyOffscreenTarget(this.effects[1].inputTarget);

							this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);
							this._sourceTarget = this.effects[1].inputTarget;
						}

						this.camera.renderTarget = this.effects[1].inputTarget;
					}
				}

				this._destroyOffscreenTarget(this.effects[index].inputTarget);

				this.effects.splice(index, 1);
			}

			if (this.enabled) {
				if (effect.needsDepthBuffer) {
					this._releaseDepthMap();
				}
			}

			if (this.effects.length === 0) {
				this.disable();
			}
		};

		_proto._requestDepthMaps = function _requestDepthMaps() {
			for (var i = 0, len = this.effects.length; i < len; i++) {
				var effect = this.effects[i].effect;
				if (this._newPostEffect === effect) continue;

				if (effect.needsDepthBuffer) {
					this._requestDepthMap();
				}
			}
		};

		_proto._releaseDepthMaps = function _releaseDepthMaps() {
			for (var i = 0, len = this.effects.length; i < len; i++) {
				var effect = this.effects[i].effect;

				if (effect.needsDepthBuffer) {
					this._releaseDepthMap();
				}
			}
		};

		_proto._requestDepthMap = function _requestDepthMap() {
			if (!depthLayer$1) depthLayer$1 = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
			if (depthLayer$1) depthLayer$1.incrementCounter();
		};

		_proto._releaseDepthMap = function _releaseDepthMap() {
			if (depthLayer$1) depthLayer$1.decrementCounter();
		};

		_proto.destroy = function destroy() {
			for (var i = 0, len = this.effects.length; i < len; i++) {
				this.effects[i].inputTarget.destroy();
			}

			this.effects.length = 0;
			this.disable();
		};

		_proto.enable = function enable() {
			var _this2 = this;

			if (!this.enabled && this.effects.length) {
				this.enabled = true;

				this._requestDepthMaps();

				this.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);
				this.destinationRenderTarget = this.camera.renderTarget;
				this.camera.renderTarget = this.effects[0].inputTarget;

				this.camera.onPostprocessing = function () {
					if (_this2.enabled) {
						var rect = null;
						var len = _this2.effects.length;

						if (len) {
							DebugGraphics.pushGpuMarker(_this2.app.graphicsDevice, "Postprocess");

							for (var i = 0; i < len; i++) {
								var fx = _this2.effects[i];
								var destTarget = fx.outputTarget;

								if (i === len - 1) {
									rect = _this2.camera.rect;

									if (_this2.destinationRenderTarget) {
										destTarget = _this2.destinationRenderTarget;
									}
								}

								DebugGraphics.pushGpuMarker(_this2.app.graphicsDevice, fx.name);
								fx.effect.render(fx.inputTarget, destTarget, rect);
								DebugGraphics.popGpuMarker(_this2.app.graphicsDevice);
							}

							DebugGraphics.popGpuMarker(_this2.app.graphicsDevice);
						}
					}
				};
			}
		};

		_proto.disable = function disable() {
			if (this.enabled) {
				this.enabled = false;
				this.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);

				this._releaseDepthMaps();

				this._destroyOffscreenTarget(this._sourceTarget);

				this.camera.renderTarget = null;
				this.camera.onPostprocessing = null;
			}
		};

		_proto._onCanvasResized = function _onCanvasResized(width, height) {
			var rect = this.camera.rect;
			var device = this.app.graphicsDevice;
			this.camera.camera.aspectRatio = device.width * rect.z / (device.height * rect.w);
			if (this.resizeTimeout) return;

			if (now() - this.resizeLast > 100) {
				this.resizeRenderTargets();
			} else {
				this.resizeTimeout = setTimeout(this._resizeTimeoutCallback, 100);
			}
		};

		_proto.resizeRenderTargets = function resizeRenderTargets() {
			if (this.resizeTimeout) {
				clearTimeout(this.resizeTimeout);
				this.resizeTimeout = null;
			}

			this.resizeLast = now();
			var rect = this.camera.rect;
			var desiredWidth = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
			var desiredHeight = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
			var effects = this.effects;

			for (var i = 0, len = effects.length; i < len; i++) {
				var fx = effects[i];

				if (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {
					this._resizeOffscreenTarget(fx.inputTarget);
				}
			}
		};

		_proto.onCameraRectChanged = function onCameraRectChanged(name, oldValue, newValue) {
			if (this.enabled) {
				this.resizeRenderTargets();
			}
		};

		return PostEffectQueue;
	}();

	var properties$1 = [{
		name: 'aspectRatio',
		readonly: false
	}, {
		name: 'aspectRatioMode',
		readonly: false
	}, {
		name: 'calculateProjection',
		readonly: false
	}, {
		name: 'calculateTransform',
		readonly: false
	}, {
		name: 'clearColor',
		readonly: false
	}, {
		name: 'cullFaces',
		readonly: false
	}, {
		name: 'farClip',
		readonly: false
	}, {
		name: 'flipFaces',
		readonly: false
	}, {
		name: 'fov',
		readonly: false
	}, {
		name: 'frustumCulling',
		readonly: false
	}, {
		name: 'horizontalFov',
		readonly: false
	}, {
		name: 'nearClip',
		readonly: false
	}, {
		name: 'orthoHeight',
		readonly: false
	}, {
		name: 'projection',
		readonly: false
	}, {
		name: 'scissorRect',
		readonly: false
	}, {
		name: 'vrDisplay',
		readonly: false
	}];

	var CameraComponent = function (_Component) {
		_inheritsLoose(CameraComponent, _Component);

		function CameraComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this.onPostprocessing = null;
			_this.onPreRender = null;
			_this.onPostRender = null;
			_this._camera = new Camera();
			_this._camera.node = entity;
			_this._priority = 0;
			_this._disablePostEffectsLayer = LAYERID_UI;
			_this._postEffects = new PostEffectQueue(system.app, _assertThisInitialized(_this));
			return _this;
		}

		var _proto = CameraComponent.prototype;

		_proto.dirtyLayerCompositionCameras = function dirtyLayerCompositionCameras() {
			var layerComp = this.system.app.scene.layers;
			layerComp._dirtyCameras = true;
		};

		_proto.screenToWorld = function screenToWorld(screenx, screeny, cameraz, worldCoord) {
			var device = this.system.app.graphicsDevice;
			var w = device.clientRect.width;
			var h = device.clientRect.height;
			return this._camera.screenToWorld(screenx, screeny, cameraz, w, h, worldCoord);
		};

		_proto.worldToScreen = function worldToScreen(worldCoord, screenCoord) {
			var device = this.system.app.graphicsDevice;
			var w = device.clientRect.width;
			var h = device.clientRect.height;
			return this._camera.worldToScreen(worldCoord, w, h, screenCoord);
		};

		_proto.onAppPrerender = function onAppPrerender() {
			this._camera._viewMatDirty = true;
			this._camera._viewProjMatDirty = true;
		};

		_proto.addCameraToLayers = function addCameraToLayers() {
			var layers = this.layers;

			for (var i = 0; i < layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(layers[i]);

				if (layer) {
					layer.addCamera(this);
				}
			}
		};

		_proto.removeCameraFromLayers = function removeCameraFromLayers() {
			var layers = this.layers;

			for (var i = 0; i < layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(layers[i]);

				if (layer) {
					layer.removeCamera(this);
				}
			}
		};

		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addCameraToLayers();
			oldComp.off("add", this.onLayerAdded, this);
			oldComp.off("remove", this.onLayerRemoved, this);
			newComp.on("add", this.onLayerAdded, this);
			newComp.on("remove", this.onLayerRemoved, this);
		};

		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addCamera(this);
		};

		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeCamera(this);
		};

		_proto.onEnable = function onEnable() {
			var system = this.system;
			var scene = system.app.scene;
			var layers = scene.layers;
			system.addCamera(this);
			scene.on("set:layers", this.onLayersChanged, this);

			if (layers) {
				layers.on("add", this.onLayerAdded, this);
				layers.on("remove", this.onLayerRemoved, this);
			}

			if (this.enabled && this.entity.enabled) {
				this.addCameraToLayers();
			}

			this.postEffects.enable();
		};

		_proto.onDisable = function onDisable() {
			var system = this.system;
			var scene = system.app.scene;
			var layers = scene.layers;
			this.postEffects.disable();
			this.removeCameraFromLayers();
			scene.off("set:layers", this.onLayersChanged, this);

			if (layers) {
				layers.off("add", this.onLayerAdded, this);
				layers.off("remove", this.onLayerRemoved, this);
			}

			system.removeCamera(this);
		};

		_proto.onRemove = function onRemove() {
			this.onDisable();
			this.off();
		};

		_proto.calculateAspectRatio = function calculateAspectRatio(rt) {
			var src = rt ? rt : this.system.app.graphicsDevice;
			var rect = this.rect;
			return src.width * rect.z / (src.height * rect.w);
		};

		_proto.frameBegin = function frameBegin(rt) {
			if (this.aspectRatioMode === ASPECT_AUTO) {
				this.aspectRatio = this.calculateAspectRatio(rt);
			}
		};

		_proto.frameEnd = function frameEnd() {};

		_proto.enterVr = function enterVr(display, callback) {
			if (display instanceof Function && !callback) {
				callback = display;
				display = null;
			}

			if (!this.system.app.vr) {
				callback("VrManager not created. Enable VR in project settings.");
				return;
			}

			if (!display) {
				display = this.system.app.vr.display;
			}

			if (display) {
				var self = this;

				if (display.capabilities.canPresent) {
					display.requestPresent(function (err) {
						if (!err) {
							self.vrDisplay = display;
							self.vrDisplay.once('beforepresentchange', function (display) {
								if (!display.presenting) {
									self.vrDisplay = null;
								}
							});
						}

						callback(err);
					});
				} else {
					self.vrDisplay = display;
					callback();
				}
			} else {
				callback("No pc.VrDisplay to present");
			}
		};

		_proto.exitVr = function exitVr(callback) {
			if (this.vrDisplay) {
				if (this.vrDisplay.capabilities.canPresent) {
					var display = this.vrDisplay;
					this.vrDisplay = null;
					display.exitPresent(callback);
				} else {
					this.vrDisplay = null;
					callback();
				}
			} else {
				callback("Not presenting VR");
			}
		};

		_proto.startXr = function startXr(type, spaceType, options) {
			this.system.app.xr.start(this, type, spaceType, options);
		};

		_proto.endXr = function endXr(callback) {
			if (!this._camera.xr) {
				if (callback) callback(new Error("Camera is not in XR"));
				return;
			}

			this._camera.xr.end(callback);
		};

		_proto.copy = function copy(source) {
			var _this2 = this;

			properties$1.forEach(function (property) {
				if (!property.readonly) {
					var name = property.name;
					_this2[name] = source[name];
				}
			});
			this.clearColorBuffer = source.clearColorBuffer;
			this.clearDepthBuffer = source.clearDepthBuffer;
			this.clearStencilBuffer = source.clearStencilBuffer;
			this.disablePostEffectsLayer = source.disablePostEffectsLayer;
			this.layers = source.layers;
			this.priority = source.priority;
			this.renderTarget = source.renderTarget;
			this.rect = source.rect;
		};

		_createClass(CameraComponent, [{
			key: "camera",
			get: function get() {
				return this._camera;
			}
		}, {
			key: "clearColorBuffer",
			get: function get() {
				return this._camera.clearColorBuffer;
			},
			set: function set(value) {
				this._camera.clearColorBuffer = value;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "clearDepthBuffer",
			get: function get() {
				return this._camera.clearDepthBuffer;
			},
			set: function set(value) {
				this._camera.clearDepthBuffer = value;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "clearStencilBuffer",
			get: function get() {
				return this._camera.clearStencilBuffer;
			},
			set: function set(value) {
				this._camera.clearStencilBuffer = value;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "disablePostEffectsLayer",
			get: function get() {
				return this._disablePostEffectsLayer;
			},
			set: function set(layer) {
				this._disablePostEffectsLayer = layer;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "frustum",
			get: function get() {
				return this._camera.frustum;
			}
		}, {
			key: "layers",
			get: function get() {
				return this._camera.layers;
			},
			set: function set(newValue) {
				var layers = this._camera.layers;

				for (var i = 0; i < layers.length; i++) {
					var layer = this.system.app.scene.layers.getLayerById(layers[i]);
					if (!layer) continue;
					layer.removeCamera(this);
				}

				this._camera.layers = newValue;
				if (!this.enabled || !this.entity.enabled) return;

				for (var _i = 0; _i < newValue.length; _i++) {
					var _layer = this.system.app.scene.layers.getLayerById(newValue[_i]);

					if (!_layer) continue;

					_layer.addCamera(this);
				}
			}
		}, {
			key: "postEffectsEnabled",
			get: function get() {
				return this._postEffects.enabled;
			}
		}, {
			key: "postEffects",
			get: function get() {
				return this._postEffects;
			}
		}, {
			key: "priority",
			get: function get() {
				return this._priority;
			},
			set: function set(newValue) {
				this._priority = newValue;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "projectionMatrix",
			get: function get() {
				return this._camera.projectionMatrix;
			}
		}, {
			key: "rect",
			get: function get() {
				return this._camera.rect;
			},
			set: function set(value) {
				this._camera.rect = value;
				this.fire('set:rect', this._camera.rect);
			}
		}, {
			key: "renderTarget",
			get: function get() {
				return this._camera.renderTarget;
			},
			set: function set(value) {
				this._camera.renderTarget = value;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "viewMatrix",
			get: function get() {
				return this._camera.viewMatrix;
			}
		}]);

		return CameraComponent;
	}(Component);

	properties$1.forEach(function (property) {
		var name = property.name;
		var options = {};

		options.get = function () {
			return this._camera[name];
		};

		if (!property.readonly) {
			options.set = function (newValue) {
				this._camera[name] = newValue;
			};
		}

		Object.defineProperty(CameraComponent.prototype, name, options);
	});

	var CameraComponentData = function CameraComponentData() {
		this.enabled = true;
	};

	var _schema$g = ['enabled'];

	var CameraComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(CameraComponentSystem, _ComponentSystem);

		function CameraComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.cameras = [];
			_this.id = 'camera';
			_this.ComponentType = CameraComponent;
			_this.DataType = CameraComponentData;
			_this.schema = _schema$g;

			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

			_this.app.on('prerender', _this.onAppPrerender, _assertThisInitialized(_this));

			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = CameraComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['aspectRatio', 'aspectRatioMode', 'calculateProjection', 'calculateTransform', 'clearColor', 'clearColorBuffer', 'clearDepthBuffer', 'clearStencilBuffer', 'cullFaces', 'farClip', 'flipFaces', 'fov', 'frustumCulling', 'horizontalFov', 'layers', 'renderTarget', 'nearClip', 'orthoHeight', 'projection', 'priority', 'rect', 'scissorRect'];

			for (var i = 0; i < properties.length; i++) {
				var property = properties[i];

				if (data.hasOwnProperty(property)) {
					var value = data[property];

					switch (property) {
						case 'rect':
						case 'scissorRect':
							if (Array.isArray(value)) {
								component[property] = new Vec4(value[0], value[1], value[2], value[3]);
							} else {
								component[property] = value;
							}

							break;

						case 'clearColor':
							if (Array.isArray(value)) {
								component[property] = new Color(value[0], value[1], value[2], value[3]);
							} else {
								component[property] = value;
							}

							break;

						default:
							component[property] = value;
							break;
					}
				}
			}

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var c = entity.camera;
			return this.addComponent(clone, {
				aspectRatio: c.aspectRatio,
				aspectRatioMode: c.aspectRatioMode,
				calculateProjection: c.calculateProjection,
				calculateTransform: c.calculateTransform,
				clearColor: c.clearColor,
				clearColorBuffer: c.clearColorBuffer,
				clearDepthBuffer: c.clearDepthBuffer,
				clearStencilBuffer: c.clearStencilBuffer,
				cullFaces: c.cullFaces,
				enabled: c.enabled,
				farClip: c.farClip,
				flipFaces: c.flipFaces,
				fov: c.fov,
				frustumCulling: c.frustumCulling,
				horizontalFov: c.horizontalFov,
				layers: c.layers,
				renderTarget: c.renderTarget,
				nearClip: c.nearClip,
				orthoHeight: c.orthoHeight,
				projection: c.projection,
				priority: c.priority,
				rect: c.rect,
				scissorRect: c.scissorRect
			});
		};

		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			this.removeCamera(component);
		};

		_proto.onUpdate = function onUpdate(dt) {
			if (this.app.vr) {
				var components = this.store;

				for (var id in components) {
					var component = components[id];

					if (component.data.enabled && component.entity.enabled) {
						var cameraComponent = component.entity.camera;
						var vrDisplay = cameraComponent.vrDisplay;

						if (vrDisplay) {
							vrDisplay.setClipPlanes(cameraComponent.nearClip, cameraComponent.farClip);

							if (component.entity) {
								component.entity.localTransform.copy(vrDisplay.combinedViewInv);
								component.entity._dirtyLocal = false;

								component.entity._dirtifyWorld();
							}
						}
					}
				}
			}
		};

		_proto.onAppPrerender = function onAppPrerender() {
			for (var i = 0, len = this.cameras.length; i < len; i++) {
				this.cameras[i].onAppPrerender();
			}
		};

		_proto.addCamera = function addCamera(camera) {
			this.cameras.push(camera);
			sortPriority(this.cameras);
		};

		_proto.removeCamera = function removeCamera(camera) {
			var index = this.cameras.indexOf(camera);

			if (index >= 0) {
				this.cameras.splice(index, 1);
				sortPriority(this.cameras);
			}
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off('update', this.onUpdate, this);
		};

		return CameraComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(CameraComponent.prototype, _schema$g);

	var CollisionComponent = function (_Component) {
		_inheritsLoose(CollisionComponent, _Component);

		function CollisionComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._compoundParent = null;

			_this.entity.on('insert', _this._onInsert, _assertThisInitialized(_this));

			_this.on('set_type', _this.onSetType, _assertThisInitialized(_this));

			_this.on('set_halfExtents', _this.onSetHalfExtents, _assertThisInitialized(_this));

			_this.on('set_radius', _this.onSetRadius, _assertThisInitialized(_this));

			_this.on('set_height', _this.onSetHeight, _assertThisInitialized(_this));

			_this.on('set_axis', _this.onSetAxis, _assertThisInitialized(_this));

			_this.on("set_asset", _this.onSetAsset, _assertThisInitialized(_this));

			_this.on("set_renderAsset", _this.onSetRenderAsset, _assertThisInitialized(_this));

			_this.on("set_model", _this.onSetModel, _assertThisInitialized(_this));

			_this.on("set_render", _this.onSetRender, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = CollisionComponent.prototype;

		_proto.onSetType = function onSetType(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this.system.changeType(this, oldValue, newValue);
			}
		};

		_proto.onSetHalfExtents = function onSetHalfExtents(name, oldValue, newValue) {
			var t = this.data.type;

			if (this.data.initialized && t === 'box') {
				this.system.recreatePhysicalShapes(this);
			}
		};

		_proto.onSetRadius = function onSetRadius(name, oldValue, newValue) {
			var t = this.data.type;

			if (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {
				this.system.recreatePhysicalShapes(this);
			}
		};

		_proto.onSetHeight = function onSetHeight(name, oldValue, newValue) {
			var t = this.data.type;

			if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
				this.system.recreatePhysicalShapes(this);
			}
		};

		_proto.onSetAxis = function onSetAxis(name, oldValue, newValue) {
			var t = this.data.type;

			if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
				this.system.recreatePhysicalShapes(this);
			}
		};

		_proto.onSetAsset = function onSetAsset(name, oldValue, newValue) {
			var assets = this.system.app.assets;

			if (oldValue) {
				var asset = assets.get(oldValue);

				if (asset) {
					asset.off('remove', this.onAssetRemoved, this);
				}
			}

			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.asset = newValue.id;
				}

				var _asset = assets.get(this.data.asset);

				if (_asset) {
					_asset.off('remove', this.onAssetRemoved, this);

					_asset.on('remove', this.onAssetRemoved, this);
				}
			}

			if (this.data.initialized && this.data.type === 'mesh') {
				if (!newValue) {
					this.data.model = null;
				}

				this.system.recreatePhysicalShapes(this);
			}
		};

		_proto.onSetRenderAsset = function onSetRenderAsset(name, oldValue, newValue) {
			var assets = this.system.app.assets;

			if (oldValue) {
				var asset = assets.get(oldValue);

				if (asset) {
					asset.off('remove', this.onRenderAssetRemoved, this);
				}
			}

			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.renderAsset = newValue.id;
				}

				var _asset2 = assets.get(this.data.renderAsset);

				if (_asset2) {
					_asset2.off('remove', this.onRenderAssetRemoved, this);

					_asset2.on('remove', this.onRenderAssetRemoved, this);
				}
			}

			if (this.data.initialized && this.data.type === 'mesh') {
				if (!newValue) {
					this.data.render = null;
				}

				this.system.recreatePhysicalShapes(this);
			}
		};

		_proto.onSetModel = function onSetModel(name, oldValue, newValue) {
			if (this.data.initialized && this.data.type === 'mesh') {
				this.system.implementations.mesh.doRecreatePhysicalShape(this);
			}
		};

		_proto.onSetRender = function onSetRender(name, oldValue, newValue) {
			this.onSetModel(name, oldValue, newValue);
		};

		_proto.onAssetRemoved = function onAssetRemoved(asset) {
			asset.off('remove', this.onAssetRemoved, this);

			if (this.data.asset === asset.id) {
				this.asset = null;
			}
		};

		_proto.onRenderAssetRemoved = function onRenderAssetRemoved(asset) {
			asset.off('remove', this.onRenderAssetRemoved, this);

			if (this.data.renderAsset === asset.id) {
				this.renderAsset = null;
			}
		};

		_proto._getCompoundChildShapeIndex = function _getCompoundChildShapeIndex(shape) {
			var compound = this.data.shape;
			var shapes = compound.getNumChildShapes();

			for (var i = 0; i < shapes; i++) {
				var childShape = compound.getChildShape(i);

				if (childShape.ptr === shape.ptr) {
					return i;
				}
			}

			return null;
		};

		_proto._onInsert = function _onInsert(parent) {
			if (typeof Ammo === 'undefined') return;

			if (this._compoundParent) {
				this.system.recreatePhysicalShapes(this);
			} else if (!this.entity.rigidbody) {
				var ancestor = this.entity.parent;

				while (ancestor) {
					if (ancestor.collision && ancestor.collision.type === 'compound') {
						if (ancestor.collision.shape.getNumChildShapes() === 0) {
							this.system.recreatePhysicalShapes(ancestor.collision);
						} else {
							this.system.recreatePhysicalShapes(this);
						}

						break;
					}

					ancestor = ancestor.parent;
				}
			}
		};

		_proto._updateCompound = function _updateCompound() {
			var entity = this.entity;

			if (entity._dirtyWorld) {
				var dirty = entity._dirtyLocal;
				var parent = entity;

				while (parent && !dirty) {
					if (parent.collision && parent.collision === this._compoundParent) break;
					if (parent._dirtyLocal) dirty = true;
					parent = parent.parent;
				}

				if (dirty) {
					entity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);
					var bodyComponent = this._compoundParent.entity.rigidbody;
					if (bodyComponent) bodyComponent.activate();
				}
			}
		};

		_proto.onEnable = function onEnable() {
			if (this.data.type === 'mesh' && (this.data.asset || this.data.renderAsset) && this.data.initialized) {
				var asset = this.system.app.assets.get(this.data.asset || this.data.renderAsset);

				if (asset && (!asset.resource || !this.data.shape)) {
					this.system.recreatePhysicalShapes(this);
					return;
				}
			}

			if (this.entity.rigidbody) {
				if (this.entity.rigidbody.enabled) {
					this.entity.rigidbody.enableSimulation();
				}
			} else if (this._compoundParent && this !== this._compoundParent) {
				if (this._compoundParent.shape.getNumChildShapes() === 0) {
					this.system.recreatePhysicalShapes(this._compoundParent);
				} else {
					var transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);

					this._compoundParent.shape.addChildShape(transform, this.data.shape);

					Ammo.destroy(transform);
					if (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();
				}
			} else if (this.entity.trigger) {
				this.entity.trigger.enable();
			}
		};

		_proto.onDisable = function onDisable() {
			if (this.entity.rigidbody) {
				this.entity.rigidbody.disableSimulation();
			} else if (this._compoundParent && this !== this._compoundParent) {
				if (!this._compoundParent.entity._destroying) {
					this.system._removeCompoundChild(this._compoundParent, this.data.shape);

					if (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();
				}
			} else if (this.entity.trigger) {
				this.entity.trigger.disable();
			}
		};

		_proto.onBeforeRemove = function onBeforeRemove() {
			if (this.asset) {
				this.asset = null;
			}

			if (this.renderAsset) {
				this.renderAsset = null;
			}

			this.entity.off('insert', this._onInsert, this);
			this.off();
		};

		return CollisionComponent;
	}(Component);

	var CollisionComponentData = function CollisionComponentData() {
		this.enabled = true;
		this.type = 'box';
		this.halfExtents = new Vec3(0.5, 0.5, 0.5);
		this.radius = 0.5;
		this.axis = 1;
		this.height = 2;
		this.asset = null;
		this.renderAsset = null;
		this.shape = null;
		this.model = null;
		this.render = null;
		this.initialized = false;
	};

	var BODYTYPE_STATIC = 'static';
	var BODYTYPE_DYNAMIC = 'dynamic';
	var BODYTYPE_KINEMATIC = 'kinematic';
	var BODYFLAG_STATIC_OBJECT = 1;
	var BODYFLAG_KINEMATIC_OBJECT = 2;
	var BODYFLAG_NORESPONSE_OBJECT = 4;
	var BODYSTATE_ACTIVE_TAG = 1;
	var BODYSTATE_ISLAND_SLEEPING = 2;
	var BODYSTATE_WANTS_DEACTIVATION = 3;
	var BODYSTATE_DISABLE_DEACTIVATION = 4;
	var BODYSTATE_DISABLE_SIMULATION = 5;
	var BODYGROUP_NONE = 0;
	var BODYGROUP_DEFAULT = 1;
	var BODYGROUP_DYNAMIC = 1;
	var BODYGROUP_STATIC = 2;
	var BODYGROUP_KINEMATIC = 4;
	var BODYGROUP_ENGINE_1 = 8;
	var BODYGROUP_TRIGGER = 16;
	var BODYGROUP_ENGINE_2 = 32;
	var BODYGROUP_ENGINE_3 = 64;
	var BODYGROUP_USER_1 = 128;
	var BODYGROUP_USER_2 = 256;
	var BODYGROUP_USER_3 = 512;
	var BODYGROUP_USER_4 = 1024;
	var BODYGROUP_USER_5 = 2048;
	var BODYGROUP_USER_6 = 4096;
	var BODYGROUP_USER_7 = 8192;
	var BODYGROUP_USER_8 = 16384;
	var BODYMASK_NONE = 0;
	var BODYMASK_ALL = 65535;
	var BODYMASK_STATIC = 2;
	var BODYMASK_NOT_STATIC = 65535 ^ 2;
	var BODYMASK_NOT_STATIC_KINEMATIC = 65535 ^ (2 | 4);

	var ammoVec1$1, ammoQuat$1, ammoTransform$1;

	var Trigger = function () {
		function Trigger(app, component, data) {
			this.entity = component.entity;
			this.component = component;
			this.app = app;

			if (typeof Ammo !== 'undefined' && !ammoVec1$1) {
				ammoVec1$1 = new Ammo.btVector3();
				ammoQuat$1 = new Ammo.btQuaternion();
				ammoTransform$1 = new Ammo.btTransform();
			}

			this.initialize(data);
		}

		var _proto = Trigger.prototype;

		_proto.initialize = function initialize(data) {
			var entity = this.entity;
			var shape = data.shape;

			if (shape && typeof Ammo !== 'undefined') {
				if (entity.trigger) {
					entity.trigger.destroy();
				}

				var mass = 1;
				var pos = entity.getPosition();
				var rot = entity.getRotation();
				ammoVec1$1.setValue(pos.x, pos.y, pos.z);
				ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
				ammoTransform$1.setOrigin(ammoVec1$1);
				ammoTransform$1.setRotation(ammoQuat$1);
				var body = this.app.systems.rigidbody.createBody(mass, shape, ammoTransform$1);
				body.setRestitution(0);
				body.setFriction(0);
				body.setDamping(0, 0);
				ammoVec1$1.setValue(0, 0, 0);
				body.setLinearFactor(ammoVec1$1);
				body.setAngularFactor(ammoVec1$1);
				body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);
				body.entity = entity;
				this.body = body;

				if (this.component.enabled && entity.enabled) {
					this.enable();
				}
			}
		};

		_proto.destroy = function destroy() {
			var body = this.body;
			if (!body) return;
			this.disable();
			this.app.systems.rigidbody.destroyBody(body);
		};

		_proto._getEntityTransform = function _getEntityTransform(transform) {
			var pos = this.entity.getPosition();
			var rot = this.entity.getRotation();
			ammoVec1$1.setValue(pos.x, pos.y, pos.z);
			ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
			transform.setOrigin(ammoVec1$1);
			transform.setRotation(ammoQuat$1);
		};

		_proto.updateTransform = function updateTransform() {
			this._getEntityTransform(ammoTransform$1);

			var body = this.body;
			body.setWorldTransform(ammoTransform$1);
			body.activate();
		};

		_proto.enable = function enable() {
			var body = this.body;
			if (!body) return;
			var systems = this.app.systems;
			systems.rigidbody.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);

			systems.rigidbody._triggers.push(this);

			body.forceActivationState(BODYSTATE_ACTIVE_TAG);
			this.updateTransform();
		};

		_proto.disable = function disable() {
			var body = this.body;
			if (!body) return;
			var systems = this.app.systems;

			var idx = systems.rigidbody._triggers.indexOf(this);

			if (idx > -1) {
				systems.rigidbody._triggers.splice(idx, 1);
			}

			systems.rigidbody.removeBody(body);
			body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
		};

		return Trigger;
	}();

	var mat4 = new Mat4();
	var vec3 = new Vec3();
	var quat = new Quat();
	var tempGraphNode = new GraphNode();
	var _schema$f = ['enabled', 'type', 'halfExtents', 'radius', 'axis', 'height', 'asset', 'renderAsset', 'shape', 'model', 'render'];

	var CollisionSystemImpl = function () {
		function CollisionSystemImpl(system) {
			this.system = system;
		}

		var _proto = CollisionSystemImpl.prototype;

		_proto.beforeInitialize = function beforeInitialize(component, data) {
			data.shape = null;
			data.model = new Model();
			data.model.graph = new GraphNode();
		};

		_proto.afterInitialize = function afterInitialize(component, data) {
			this.recreatePhysicalShapes(component);
			component.data.initialized = true;
		};

		_proto.reset = function reset(component, data) {
			this.beforeInitialize(component, data);
			this.afterInitialize(component, data);
		};

		_proto.recreatePhysicalShapes = function recreatePhysicalShapes(component) {
			var entity = component.entity;
			var data = component.data;

			if (typeof Ammo !== 'undefined') {
				if (entity.trigger) {
					entity.trigger.destroy();
					delete entity.trigger;
				}

				if (data.shape) {
					if (component._compoundParent) {
						this.system._removeCompoundChild(component._compoundParent, data.shape);

						if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
					}

					Ammo.destroy(data.shape);
					data.shape = null;
				}

				data.shape = this.createPhysicalShape(component.entity, data);
				var firstCompoundChild = !component._compoundParent;

				if (data.type === 'compound' && (!component._compoundParent || component === component._compoundParent)) {
					component._compoundParent = component;
					entity.forEach(this._addEachDescendant, component);
				} else if (data.type !== 'compound') {
					if (component._compoundParent && component === component._compoundParent) {
						entity.forEach(this.system.implementations.compound._updateEachDescendant, component);
					}

					if (!component.rigidbody) {
						component._compoundParent = null;
						var parent = entity.parent;

						while (parent) {
							if (parent.collision && parent.collision.type === 'compound') {
								component._compoundParent = parent.collision;
								break;
							}

							parent = parent.parent;
						}
					}
				}

				if (component._compoundParent) {
					if (component !== component._compoundParent) {
						if (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {
							this.system.recreatePhysicalShapes(component._compoundParent);
						} else {
							this.system.updateCompoundChildTransform(entity);
							if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
						}
					}
				}

				if (entity.rigidbody) {
					entity.rigidbody.disableSimulation();
					entity.rigidbody.createBody();

					if (entity.enabled && entity.rigidbody.enabled) {
						entity.rigidbody.enableSimulation();
					}
				} else if (!component._compoundParent) {
					if (!entity.trigger) {
						entity.trigger = new Trigger(this.system.app, component, data);
					} else {
						entity.trigger.initialize(data);
					}
				}
			}
		};

		_proto.createPhysicalShape = function createPhysicalShape(entity, data) {
			return undefined;
		};

		_proto.updateTransform = function updateTransform(component, position, rotation, scale) {
			if (component.entity.trigger) {
				component.entity.trigger.updateTransform();
			}
		};

		_proto.beforeRemove = function beforeRemove(entity, component) {
			if (component.data.shape) {
				if (component._compoundParent && !component._compoundParent.entity._destroying) {
					this.system._removeCompoundChild(component._compoundParent, component.data.shape);

					if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
				}

				component._compoundParent = null;
				Ammo.destroy(component.data.shape);
				component.data.shape = null;
			}
		};

		_proto.remove = function remove(entity, data) {
			var app = this.system.app;

			if (entity.rigidbody && entity.rigidbody.body) {
				entity.rigidbody.disableSimulation();
			}

			if (entity.trigger) {
				entity.trigger.destroy();
				delete entity.trigger;
			}

			if (app.scene.containsModel(data.model)) {
				app.root.removeChild(data.model.graph);
				app.scene.removeModel(data.model);
			}
		};

		_proto.clone = function clone(entity, _clone) {
			var src = this.system.store[entity.getGuid()];
			var data = {
				enabled: src.data.enabled,
				type: src.data.type,
				halfExtents: [src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z],
				radius: src.data.radius,
				axis: src.data.axis,
				height: src.data.height,
				asset: src.data.asset,
				renderAsset: src.data.renderAsset,
				model: src.data.model,
				render: src.data.render
			};
			return this.system.addComponent(_clone, data);
		};

		return CollisionSystemImpl;
	}();

	var CollisionBoxSystemImpl = function (_CollisionSystemImpl) {
		_inheritsLoose(CollisionBoxSystemImpl, _CollisionSystemImpl);

		function CollisionBoxSystemImpl() {
			return _CollisionSystemImpl.apply(this, arguments) || this;
		}

		var _proto2 = CollisionBoxSystemImpl.prototype;

		_proto2.createPhysicalShape = function createPhysicalShape(entity, data) {
			if (typeof Ammo !== 'undefined') {
				var he = data.halfExtents;
				var ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);
				var shape = new Ammo.btBoxShape(ammoHe);
				Ammo.destroy(ammoHe);
				return shape;
			}

			return undefined;
		};

		return CollisionBoxSystemImpl;
	}(CollisionSystemImpl);

	var CollisionSphereSystemImpl = function (_CollisionSystemImpl2) {
		_inheritsLoose(CollisionSphereSystemImpl, _CollisionSystemImpl2);

		function CollisionSphereSystemImpl() {
			return _CollisionSystemImpl2.apply(this, arguments) || this;
		}

		var _proto3 = CollisionSphereSystemImpl.prototype;

		_proto3.createPhysicalShape = function createPhysicalShape(entity, data) {
			if (typeof Ammo !== 'undefined') {
				return new Ammo.btSphereShape(data.radius);
			}

			return undefined;
		};

		return CollisionSphereSystemImpl;
	}(CollisionSystemImpl);

	var CollisionCapsuleSystemImpl = function (_CollisionSystemImpl3) {
		_inheritsLoose(CollisionCapsuleSystemImpl, _CollisionSystemImpl3);

		function CollisionCapsuleSystemImpl() {
			return _CollisionSystemImpl3.apply(this, arguments) || this;
		}

		var _proto4 = CollisionCapsuleSystemImpl.prototype;

		_proto4.createPhysicalShape = function createPhysicalShape(entity, data) {
			var axis = data.axis !== undefined ? data.axis : 1;
			var radius = data.radius || 0.5;
			var height = Math.max((data.height || 2) - 2 * radius, 0);
			var shape = null;

			if (typeof Ammo !== 'undefined') {
				switch (axis) {
					case 0:
						shape = new Ammo.btCapsuleShapeX(radius, height);
						break;

					case 1:
						shape = new Ammo.btCapsuleShape(radius, height);
						break;

					case 2:
						shape = new Ammo.btCapsuleShapeZ(radius, height);
						break;
				}
			}

			return shape;
		};

		return CollisionCapsuleSystemImpl;
	}(CollisionSystemImpl);

	var CollisionCylinderSystemImpl = function (_CollisionSystemImpl4) {
		_inheritsLoose(CollisionCylinderSystemImpl, _CollisionSystemImpl4);

		function CollisionCylinderSystemImpl() {
			return _CollisionSystemImpl4.apply(this, arguments) || this;
		}

		var _proto5 = CollisionCylinderSystemImpl.prototype;

		_proto5.createPhysicalShape = function createPhysicalShape(entity, data) {
			var axis = data.axis !== undefined ? data.axis : 1;
			var radius = data.radius !== undefined ? data.radius : 0.5;
			var height = data.height !== undefined ? data.height : 1;
			var halfExtents = null;
			var shape = null;

			if (typeof Ammo !== 'undefined') {
				switch (axis) {
					case 0:
						halfExtents = new Ammo.btVector3(height * 0.5, radius, radius);
						shape = new Ammo.btCylinderShapeX(halfExtents);
						break;

					case 1:
						halfExtents = new Ammo.btVector3(radius, height * 0.5, radius);
						shape = new Ammo.btCylinderShape(halfExtents);
						break;

					case 2:
						halfExtents = new Ammo.btVector3(radius, radius, height * 0.5);
						shape = new Ammo.btCylinderShapeZ(halfExtents);
						break;
				}
			}

			if (halfExtents) Ammo.destroy(halfExtents);
			return shape;
		};

		return CollisionCylinderSystemImpl;
	}(CollisionSystemImpl);

	var CollisionConeSystemImpl = function (_CollisionSystemImpl5) {
		_inheritsLoose(CollisionConeSystemImpl, _CollisionSystemImpl5);

		function CollisionConeSystemImpl() {
			return _CollisionSystemImpl5.apply(this, arguments) || this;
		}

		var _proto6 = CollisionConeSystemImpl.prototype;

		_proto6.createPhysicalShape = function createPhysicalShape(entity, data) {
			var axis = data.axis !== undefined ? data.axis : 1;
			var radius = data.radius !== undefined ? data.radius : 0.5;
			var height = data.height !== undefined ? data.height : 1;
			var shape = null;

			if (typeof Ammo !== 'undefined') {
				switch (axis) {
					case 0:
						shape = new Ammo.btConeShapeX(radius, height);
						break;

					case 1:
						shape = new Ammo.btConeShape(radius, height);
						break;

					case 2:
						shape = new Ammo.btConeShapeZ(radius, height);
						break;
				}
			}

			return shape;
		};

		return CollisionConeSystemImpl;
	}(CollisionSystemImpl);

	var CollisionMeshSystemImpl = function (_CollisionSystemImpl6) {
		_inheritsLoose(CollisionMeshSystemImpl, _CollisionSystemImpl6);

		function CollisionMeshSystemImpl() {
			return _CollisionSystemImpl6.apply(this, arguments) || this;
		}

		var _proto7 = CollisionMeshSystemImpl.prototype;

		_proto7.beforeInitialize = function beforeInitialize(component, data) {};

		_proto7.createAmmoMesh = function createAmmoMesh(mesh, node, shape) {
			var triMesh;

			if (this.system._triMeshCache[mesh.id]) {
				triMesh = this.system._triMeshCache[mesh.id];
			} else {
				var vb = mesh.vertexBuffer;
				var format = vb.getFormat();
				var stride;
				var positions;

				for (var i = 0; i < format.elements.length; i++) {
					var element = format.elements[i];

					if (element.name === SEMANTIC_POSITION) {
						positions = new Float32Array(vb.lock(), element.offset);
						stride = element.stride / 4;
						break;
					}
				}

				var indices = [];
				mesh.getIndices(indices);
				var numTriangles = mesh.primitive[0].count / 3;
				var v1 = new Ammo.btVector3();
				var v2 = new Ammo.btVector3();
				var v3 = new Ammo.btVector3();
				var i1, i2, i3;
				var base = mesh.primitive[0].base;
				triMesh = new Ammo.btTriangleMesh();
				this.system._triMeshCache[mesh.id] = triMesh;

				for (var _i = 0; _i < numTriangles; _i++) {
					i1 = indices[base + _i * 3] * stride;
					i2 = indices[base + _i * 3 + 1] * stride;
					i3 = indices[base + _i * 3 + 2] * stride;
					v1.setValue(positions[i1], positions[i1 + 1], positions[i1 + 2]);
					v2.setValue(positions[i2], positions[i2 + 1], positions[i2 + 2]);
					v3.setValue(positions[i3], positions[i3 + 1], positions[i3 + 2]);
					triMesh.addTriangle(v1, v2, v3, true);
				}

				Ammo.destroy(v1);
				Ammo.destroy(v2);
				Ammo.destroy(v3);
			}

			var useQuantizedAabbCompression = true;
			var triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, useQuantizedAabbCompression);

			var scaling = this.system._getNodeScaling(node);

			triMeshShape.setLocalScaling(scaling);
			Ammo.destroy(scaling);

			var transform = this.system._getNodeTransform(node);

			shape.addChildShape(transform, triMeshShape);
			Ammo.destroy(transform);
		};

		_proto7.createPhysicalShape = function createPhysicalShape(entity, data) {
			if (typeof Ammo === 'undefined') return;

			if (data.model || data.render) {
				var shape = new Ammo.btCompoundShape();

				if (data.model) {
					var meshInstances = data.model.meshInstances;

					for (var i = 0; i < meshInstances.length; i++) {
						this.createAmmoMesh(meshInstances[i].mesh, meshInstances[i].node, shape);
					}
				} else if (data.render) {
					var meshes = data.render.meshes;

					for (var _i2 = 0; _i2 < meshes.length; _i2++) {
						this.createAmmoMesh(meshes[_i2], tempGraphNode, shape);
					}
				}

				var entityTransform = entity.getWorldTransform();
				var scale = entityTransform.getScale();
				var vec = new Ammo.btVector3(scale.x, scale.y, scale.z);
				shape.setLocalScaling(vec);
				Ammo.destroy(vec);
				return shape;
			}
		};

		_proto7.recreatePhysicalShapes = function recreatePhysicalShapes(component) {
			var data = component.data;

			if (data.renderAsset || data.asset) {
				if (component.enabled && component.entity.enabled) {
					this.loadAsset(component, data.renderAsset || data.asset, data.renderAsset ? 'render' : 'model');
					return;
				}
			}

			this.doRecreatePhysicalShape(component);
		};

		_proto7.loadAsset = function loadAsset(component, id, property) {
			var _this = this;

			var data = component.data;
			var assets = this.system.app.assets;
			var asset = assets.get(id);

			if (asset) {
				asset.ready(function (asset) {
					data[property] = asset.resource;

					_this.doRecreatePhysicalShape(component);
				});
				assets.load(asset);
			} else {
				assets.once("add:" + id, function (asset) {
					asset.ready(function (asset) {
						data[property] = asset.resource;

						_this.doRecreatePhysicalShape(component);
					});
					assets.load(asset);
				});
			}
		};

		_proto7.doRecreatePhysicalShape = function doRecreatePhysicalShape(component) {
			var entity = component.entity;
			var data = component.data;

			if (data.model || data.render) {
				this.destroyShape(data);
				data.shape = this.createPhysicalShape(entity, data);

				if (entity.rigidbody) {
					entity.rigidbody.disableSimulation();
					entity.rigidbody.createBody();

					if (entity.enabled && entity.rigidbody.enabled) {
						entity.rigidbody.enableSimulation();
					}
				} else {
					if (!entity.trigger) {
						entity.trigger = new Trigger(this.system.app, component, data);
					} else {
						entity.trigger.initialize(data);
					}
				}
			} else {
				this.beforeRemove(entity, component);
				this.remove(entity, data);
			}
		};

		_proto7.updateTransform = function updateTransform(component, position, rotation, scale) {
			if (component.shape) {
				var entityTransform = component.entity.getWorldTransform();
				var worldScale = entityTransform.getScale();
				var previousScale = component.shape.getLocalScaling();

				if (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {
					this.doRecreatePhysicalShape(component);
				}
			}

			_CollisionSystemImpl6.prototype.updateTransform.call(this, component, position, rotation, scale);
		};

		_proto7.destroyShape = function destroyShape(data) {
			if (!data.shape) return;
			var numShapes = data.shape.getNumChildShapes();

			for (var i = 0; i < numShapes; i++) {
				var shape = data.shape.getChildShape(i);
				Ammo.destroy(shape);
			}

			Ammo.destroy(data.shape);
			data.shape = null;
		};

		_proto7.remove = function remove(entity, data) {
			this.destroyShape(data);

			_CollisionSystemImpl6.prototype.remove.call(this, entity, data);
		};

		return CollisionMeshSystemImpl;
	}(CollisionSystemImpl);

	var CollisionCompoundSystemImpl = function (_CollisionSystemImpl7) {
		_inheritsLoose(CollisionCompoundSystemImpl, _CollisionSystemImpl7);

		function CollisionCompoundSystemImpl() {
			return _CollisionSystemImpl7.apply(this, arguments) || this;
		}

		var _proto8 = CollisionCompoundSystemImpl.prototype;

		_proto8.createPhysicalShape = function createPhysicalShape(entity, data) {
			if (typeof Ammo !== 'undefined') {
				return new Ammo.btCompoundShape();
			}

			return undefined;
		};

		_proto8._addEachDescendant = function _addEachDescendant(entity) {
			if (!entity.collision || entity.rigidbody) return;
			entity.collision._compoundParent = this;

			if (entity !== this.entity) {
				entity.collision.system.recreatePhysicalShapes(entity.collision);
			}
		};

		_proto8._updateEachDescendant = function _updateEachDescendant(entity) {
			if (!entity.collision) return;
			if (entity.collision._compoundParent !== this) return;
			entity.collision._compoundParent = null;

			if (entity !== this.entity && !entity.rigidbody) {
				entity.collision.system.recreatePhysicalShapes(entity.collision);
			}
		};

		_proto8._updateEachDescendantTransform = function _updateEachDescendantTransform(entity) {
			if (!entity.collision || entity.collision._compoundParent !== this.collision._compoundParent) return;
			this.collision.system.updateCompoundChildTransform(entity);
		};

		return CollisionCompoundSystemImpl;
	}(CollisionSystemImpl);

	var CollisionComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(CollisionComponentSystem, _ComponentSystem);

		function CollisionComponentSystem(app) {
			var _this2;

			_this2 = _ComponentSystem.call(this, app) || this;
			_this2.id = "collision";
			_this2.ComponentType = CollisionComponent;
			_this2.DataType = CollisionComponentData;
			_this2.schema = _schema$f;
			_this2.implementations = {};
			_this2._triMeshCache = {};

			_this2.on('beforeremove', _this2.onBeforeRemove, _assertThisInitialized(_this2));

			_this2.on('remove', _this2.onRemove, _assertThisInitialized(_this2));

			return _this2;
		}

		var _proto9 = CollisionComponentSystem.prototype;

		_proto9.initializeComponentData = function initializeComponentData(component, _data, properties) {
			properties = ['type', 'halfExtents', 'radius', 'axis', 'height', 'shape', 'model', 'asset', 'render', 'renderAsset', 'enabled'];
			var data = {};

			for (var i = 0, len = properties.length; i < len; i++) {
				var property = properties[i];
				data[property] = _data[property];
			}

			var idx;

			if (_data.hasOwnProperty('asset')) {
				idx = properties.indexOf('model');

				if (idx !== -1) {
					properties.splice(idx, 1);
				}

				idx = properties.indexOf('render');

				if (idx !== -1) {
					properties.splice(idx, 1);
				}
			} else if (_data.hasOwnProperty('model')) {
				idx = properties.indexOf('asset');

				if (idx !== -1) {
					properties.splice(idx, 1);
				}
			}

			if (!data.type) {
				data.type = component.data.type;
			}

			component.data.type = data.type;

			if (data.halfExtents && Array.isArray(data.halfExtents)) {
				data.halfExtents = new Vec3(data.halfExtents[0], data.halfExtents[1], data.halfExtents[2]);
			}

			var impl = this._createImplementation(data.type);

			impl.beforeInitialize(component, data);

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);

			impl.afterInitialize(component, data);
		};

		_proto9._createImplementation = function _createImplementation(type) {
			if (this.implementations[type] === undefined) {
				var impl;

				switch (type) {
					case 'box':
						impl = new CollisionBoxSystemImpl(this);
						break;

					case 'sphere':
						impl = new CollisionSphereSystemImpl(this);
						break;

					case 'capsule':
						impl = new CollisionCapsuleSystemImpl(this);
						break;

					case 'cylinder':
						impl = new CollisionCylinderSystemImpl(this);
						break;

					case 'cone':
						impl = new CollisionConeSystemImpl(this);
						break;

					case 'mesh':
						impl = new CollisionMeshSystemImpl(this);
						break;

					case 'compound':
						impl = new CollisionCompoundSystemImpl(this);
						break;

					default:
						Debug.error("_createImplementation: Invalid collision system type: " + type);
				}

				this.implementations[type] = impl;
			}

			return this.implementations[type];
		};

		_proto9._getImplementation = function _getImplementation(entity) {
			return this.implementations[entity.collision.data.type];
		};

		_proto9.cloneComponent = function cloneComponent(entity, clone) {
			return this._getImplementation(entity).clone(entity, clone);
		};

		_proto9.onBeforeRemove = function onBeforeRemove(entity, component) {
			this.implementations[component.data.type].beforeRemove(entity, component);
			component.onBeforeRemove();
		};

		_proto9.onRemove = function onRemove(entity, data) {
			this.implementations[data.type].remove(entity, data);
		};

		_proto9.updateCompoundChildTransform = function updateCompoundChildTransform(entity) {
			this._removeCompoundChild(entity.collision._compoundParent, entity.collision.data.shape);

			if (entity.enabled && entity.collision.enabled) {
				var transform = this._getNodeTransform(entity, entity.collision._compoundParent.entity);

				entity.collision._compoundParent.shape.addChildShape(transform, entity.collision.data.shape);

				Ammo.destroy(transform);
			}
		};

		_proto9._removeCompoundChild = function _removeCompoundChild(collision, shape) {
			if (collision.shape.removeChildShape) {
				collision.shape.removeChildShape(shape);
			} else {
				var ind = collision._getCompoundChildShapeIndex(shape);

				if (ind !== null) {
					collision.shape.removeChildShapeByIndex(ind);
				}
			}
		};

		_proto9.onTransformChanged = function onTransformChanged(component, position, rotation, scale) {
			this.implementations[component.data.type].updateTransform(component, position, rotation, scale);
		};

		_proto9.changeType = function changeType(component, previousType, newType) {
			this.implementations[previousType].beforeRemove(component.entity, component);
			this.implementations[previousType].remove(component.entity, component.data);

			this._createImplementation(newType).reset(component, component.data);
		};

		_proto9.recreatePhysicalShapes = function recreatePhysicalShapes(component) {
			this.implementations[component.data.type].recreatePhysicalShapes(component);
		};

		_proto9._calculateNodeRelativeTransform = function _calculateNodeRelativeTransform(node, relative) {
			if (node === relative) {
				var scale = node.getWorldTransform().getScale();
				mat4.setScale(scale.x, scale.y, scale.z);
			} else {
				this._calculateNodeRelativeTransform(node.parent, relative);

				mat4.mul(node.getLocalTransform());
			}
		};

		_proto9._getNodeScaling = function _getNodeScaling(node) {
			var wtm = node.getWorldTransform();
			var scl = wtm.getScale();
			return new Ammo.btVector3(scl.x, scl.y, scl.z);
		};

		_proto9._getNodeTransform = function _getNodeTransform(node, relative) {
			var pos, rot;

			if (relative) {
				this._calculateNodeRelativeTransform(node, relative);

				pos = vec3;
				rot = quat;
				mat4.getTranslation(pos);
				rot.setFromMat4(mat4);
			} else {
				pos = node.getPosition();
				rot = node.getRotation();
			}

			var transform = new Ammo.btTransform();
			transform.setIdentity();
			var origin = transform.getOrigin();
			origin.setValue(pos.x, pos.y, pos.z);
			var ammoQuat = new Ammo.btQuaternion();
			ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
			transform.setRotation(ammoQuat);
			Ammo.destroy(ammoQuat);
			Ammo.destroy(origin);
			return transform;
		};

		_proto9.destroy = function destroy() {
			for (var key in this._triMeshCache) {
				Ammo.destroy(this._triMeshCache[key]);
			}

			this._triMeshCache = null;

			_ComponentSystem.prototype.destroy.call(this);
		};

		return CollisionComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(CollisionComponent.prototype, _schema$f);

	var ComponentSystemRegistry = function (_EventHandler) {
		_inheritsLoose(ComponentSystemRegistry, _EventHandler);

		function ComponentSystemRegistry() {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.anim = void 0;
			_this.animation = void 0;
			_this.audiolistener = void 0;
			_this.audiosource = void 0;
			_this.button = void 0;
			_this.camera = void 0;
			_this.collision = void 0;
			_this.element = void 0;
			_this.joint = void 0;
			_this.layoutchild = void 0;
			_this.layoutgroup = void 0;
			_this.light = void 0;
			_this.model = void 0;
			_this.particlesystem = void 0;
			_this.render = void 0;
			_this.rigidbody = void 0;
			_this.screen = void 0;
			_this.script = void 0;
			_this.scrollbar = void 0;
			_this.scrollview = void 0;
			_this.sound = void 0;
			_this.sprite = void 0;
			_this.zone = void 0;
			_this.list = [];
			return _this;
		}

		var _proto = ComponentSystemRegistry.prototype;

		_proto.add = function add(system) {
			var id = system.id;

			if (this[id]) {
				throw new Error("ComponentSystem name '" + id + "' already registered or not allowed");
			}

			this[id] = system;
			this.list.push(system);
		};

		_proto.remove = function remove(system) {
			var id = system.id;

			if (!this[id]) {
				throw new Error("No ComponentSystem named '" + id + "' registered");
			}

			delete this[id];
			var index = this.list.indexOf(this[id]);

			if (index !== -1) {
				this.list.splice(index, 1);
			}
		};

		_proto.destroy = function destroy() {
			this.off();

			for (var i = 0; i < this.list.length; i++) {
				this.list[i].destroy();
			}
		};

		return ComponentSystemRegistry;
	}(EventHandler);

	var StencilParameters = function () {
		function StencilParameters(options) {
			this.func = options.func === undefined ? FUNC_ALWAYS : options.func;
			this.ref = options.ref || 0;
			this.readMask = options.readMask === undefined ? 0xFF : options.readMask;
			this.writeMask = options.writeMask === undefined ? 0xFF : options.writeMask;
			this.fail = options.fail || STENCILOP_KEEP;
			this.zfail = options.zfail || STENCILOP_KEEP;
			this.zpass = options.zpass || STENCILOP_KEEP;
		}

		var _proto = StencilParameters.prototype;

		_proto.clone = function clone() {
			return new StencilParameters({
				func: this.func,
				ref: this.ref,
				readMask: this.readMask,
				writeMask: this.writeMask,
				fail: this.fail,
				zfail: this.zfail,
				zpass: this.zpass
			});
		};

		return StencilParameters;
	}();

	var ImageRenderable = function () {
		function ImageRenderable(entity, mesh, material) {
			this._entity = entity;
			this._element = entity.element;
			this.model = new Model();
			this.node = new GraphNode();
			this.model.graph = this.node;
			this.mesh = mesh;
			this.meshInstance = new MeshInstance(this.mesh, material, this.node);
			this.meshInstance.name = 'ImageElement: ' + entity.name;
			this.meshInstance.castShadow = false;
			this.meshInstance.receiveShadow = false;
			this._meshDirty = false;
			this.model.meshInstances.push(this.meshInstance);

			this._entity.addChild(this.model.graph);

			this.model._entity = this._entity;
			this.unmaskMeshInstance = null;
		}

		var _proto = ImageRenderable.prototype;

		_proto.destroy = function destroy() {
			this.setMaterial(null);

			this._element.removeModelFromLayers(this.model);

			this.model.destroy();
			this.model = null;
			this.node = null;
			this.mesh = null;
			this.meshInstance = null;
			this._entity = null;
			this._element = null;
		};

		_proto.setMesh = function setMesh(mesh) {
			if (!this.meshInstance) return;
			this.mesh = mesh;
			this.meshInstance.mesh = mesh;
			this.meshInstance.visible = !!mesh;

			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.mesh = mesh;
			}

			this.forceUpdateAabb();
		};

		_proto.setMask = function setMask(mask) {
			if (!this.meshInstance) return;

			if (mask) {
				this.unmaskMeshInstance = new MeshInstance(this.mesh, this.meshInstance.material, this.node);
				this.unmaskMeshInstance.name = 'Unmask: ' + this._entity.name;
				this.unmaskMeshInstance.castShadow = false;
				this.unmaskMeshInstance.receiveShadow = false;
				this.unmaskMeshInstance.pick = false;
				this.model.meshInstances.push(this.unmaskMeshInstance);

				for (var name in this.meshInstance.parameters) {
					this.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);
				}
			} else {
				var idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);

				if (idx >= 0) {
					this.model.meshInstances.splice(idx, 1);
				}

				this.unmaskMeshInstance = null;
			}

			if (this._entity.enabled && this._element.enabled) {
				this._element.removeModelFromLayers(this.model);

				this._element.addModelToLayers(this.model);
			}
		};

		_proto.setMaterial = function setMaterial(material) {
			if (!this.meshInstance) return;
			this.meshInstance.material = material;

			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.material = material;
			}
		};

		_proto.setParameter = function setParameter(name, value) {
			if (!this.meshInstance) return;
			this.meshInstance.setParameter(name, value);

			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.setParameter(name, value);
			}
		};

		_proto.deleteParameter = function deleteParameter(name) {
			if (!this.meshInstance) return;
			this.meshInstance.deleteParameter(name);

			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.deleteParameter(name);
			}
		};

		_proto.setUnmaskDrawOrder = function setUnmaskDrawOrder() {
			if (!this.meshInstance) return;

			var getLastChild = function getLastChild(e) {
				var last;
				var c = e.children;
				var l = c.length;

				if (l) {
					for (var i = 0; i < l; i++) {
						if (c[i].element) {
							last = c[i];
						}
					}

					if (!last) return null;
					var child = getLastChild(last);

					if (child) {
						return child;
					}

					return last;
				}

				return null;
			};

			if (this.unmaskMeshInstance) {
				var lastChild = getLastChild(this._entity);

				if (lastChild && lastChild.element) {
					this.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();
				} else {
					this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();
				}
			}
		};

		_proto.setDrawOrder = function setDrawOrder(drawOrder) {
			if (!this.meshInstance) return;
			this.meshInstance.drawOrder = drawOrder;
		};

		_proto.setCull = function setCull(cull) {
			if (!this.meshInstance) return;
			var element = this._element;
			var visibleFn = null;

			if (cull && element._isScreenCulled()) {
				visibleFn = function visibleFn(camera) {
					return element.isVisibleForCamera(camera);
				};
			}

			this.meshInstance.cull = cull;
			this.meshInstance.isVisibleFunc = visibleFn;

			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.cull = cull;
				this.unmaskMeshInstance.isVisibleFunc = visibleFn;
			}
		};

		_proto.setScreenSpace = function setScreenSpace(screenSpace) {
			if (!this.meshInstance) return;
			this.meshInstance.screenSpace = screenSpace;

			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.screenSpace = screenSpace;
			}
		};

		_proto.setLayer = function setLayer(layer) {
			if (!this.meshInstance) return;
			this.meshInstance.layer = layer;

			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.layer = layer;
			}
		};

		_proto.forceUpdateAabb = function forceUpdateAabb(mask) {
			if (!this.meshInstance) return;
			this.meshInstance._aabbVer = -1;

			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance._aabbVer = -1;
			}
		};

		_proto.setAabbFunc = function setAabbFunc(fn) {
			if (!this.meshInstance) return;
			this.meshInstance._updateAabbFunc = fn;

			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance._updateAabbFunc = fn;
			}
		};

		return ImageRenderable;
	}();

	var ImageElement = function () {
		function ImageElement(element) {
			this._element = element;
			this._entity = element.entity;
			this._system = element.system;
			this._textureAsset = null;
			this._texture = null;
			this._materialAsset = null;
			this._material = null;
			this._spriteAsset = null;
			this._sprite = null;
			this._spriteFrame = 0;
			this._pixelsPerUnit = null;
			this._rect = new Vec4(0, 0, 1, 1);
			this._mask = false;
			this._maskRef = 0;
			this._outerScale = new Vec2();
			this._outerScaleUniform = new Float32Array(2);
			this._innerOffset = new Vec4();
			this._innerOffsetUniform = new Float32Array(4);
			this._atlasRect = new Vec4();
			this._atlasRectUniform = new Float32Array(4);
			this._defaultMesh = this._createMesh();
			this._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);
			this._color = new Color(1, 1, 1, 1);
			this._colorUniform = new Float32Array([1, 1, 1]);

			this._renderable.setParameter('material_emissive', this._colorUniform);

			this._renderable.setParameter('material_opacity', 1);

			this._updateAabbFunc = this._updateAabb.bind(this);

			this._onScreenChange(this._element.screen);

			this._element.on('resize', this._onParentResizeOrPivotChange, this);

			this._element.on('set:pivot', this._onParentResizeOrPivotChange, this);

			this._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);

			this._element.on('set:screen', this._onScreenChange, this);

			this._element.on('set:draworder', this._onDrawOrderChange, this);

			this._element.on('screen:set:resolution', this._onResolutionChange, this);
		}

		var _proto2 = ImageElement.prototype;

		_proto2.destroy = function destroy() {
			this.textureAsset = null;
			this.spriteAsset = null;
			this.materialAsset = null;

			this._renderable.setMesh(this._defaultMesh);

			this._renderable.destroy();

			this._defaultMesh = null;

			this._element.off('resize', this._onParentResizeOrPivotChange, this);

			this._element.off('set:pivot', this._onParentResizeOrPivotChange, this);

			this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);

			this._element.off('set:screen', this._onScreenChange, this);

			this._element.off('set:draworder', this._onDrawOrderChange, this);

			this._element.off('screen:set:resolution', this._onResolutionChange, this);
		};

		_proto2._onResolutionChange = function _onResolutionChange(res) {};

		_proto2._onParentResizeOrPivotChange = function _onParentResizeOrPivotChange() {
			if (this._renderable.mesh) {
				this._updateMesh(this._renderable.mesh);
			}
		};

		_proto2._onScreenSpaceChange = function _onScreenSpaceChange(value) {
			this._updateMaterial(value);
		};

		_proto2._onScreenChange = function _onScreenChange(screen, previous) {
			if (screen) {
				this._updateMaterial(screen.screen.screenSpace);
			} else {
				this._updateMaterial(false);
			}
		};

		_proto2._onDrawOrderChange = function _onDrawOrderChange(order) {
			this._renderable.setDrawOrder(order);

			if (this.mask && this._element.screen) {
				this._element.screen.screen.once('syncdraworder', function () {
					this._renderable.setUnmaskDrawOrder();
				}, this);
			}
		};

		_proto2._hasUserMaterial = function _hasUserMaterial() {
			return !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;
		};

		_proto2._use9Slicing = function _use9Slicing() {
			return this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
		};

		_proto2._updateMaterial = function _updateMaterial(screenSpace) {
			var mask = !!this._mask;
			var nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);
			var nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);

			if (!this._hasUserMaterial()) {
				this._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);
			}

			if (this._renderable) {
				this._renderable.setCull(true);

				this._renderable.setMaterial(this._material);

				this._renderable.setScreenSpace(screenSpace);

				this._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);
			}
		};

		_proto2._createMesh = function _createMesh() {
			var element = this._element;
			var w = element.calculatedWidth;
			var h = element.calculatedHeight;
			var r = this._rect;
			var vertexData = new ArrayBuffer(4 * 8 * 4);
			var vertexDataF32 = new Float32Array(vertexData);
			vertexDataF32[5] = 1;
			vertexDataF32[6] = r.x;
			vertexDataF32[7] = 1.0 - r.y;
			vertexDataF32[8] = w;
			vertexDataF32[13] = 1;
			vertexDataF32[14] = r.x + r.z;
			vertexDataF32[15] = 1.0 - r.y;
			vertexDataF32[16] = w;
			vertexDataF32[17] = h;
			vertexDataF32[21] = 1;
			vertexDataF32[22] = r.x + r.z;
			vertexDataF32[23] = 1.0 - (r.y + r.w);
			vertexDataF32[25] = h;
			vertexDataF32[29] = 1;
			vertexDataF32[30] = r.x;
			vertexDataF32[31] = 1.0 - (r.y + r.w);
			var vertexDesc = [{
				semantic: SEMANTIC_POSITION,
				components: 3,
				type: TYPE_FLOAT32
			}, {
				semantic: SEMANTIC_NORMAL,
				components: 3,
				type: TYPE_FLOAT32
			}, {
				semantic: SEMANTIC_TEXCOORD0,
				components: 2,
				type: TYPE_FLOAT32
			}];
			var device = this._system.app.graphicsDevice;
			var vertexFormat = new VertexFormat(device, vertexDesc);
			var vertexBuffer = new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, vertexData);
			var mesh = new Mesh(device);
			mesh.vertexBuffer = vertexBuffer;
			mesh.primitive[0].type = PRIMITIVE_TRIFAN;
			mesh.primitive[0].base = 0;
			mesh.primitive[0].count = 4;
			mesh.primitive[0].indexed = false;
			mesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h, 0));

			this._updateMesh(mesh);

			return mesh;
		};

		_proto2._updateMesh = function _updateMesh(mesh) {
			var element = this._element;
			var w = element.calculatedWidth;
			var h = element.calculatedHeight;

			var screenSpace = element._isScreenSpace();

			this._updateMaterial(screenSpace);

			if (this._renderable) this._renderable.forceUpdateAabb();

			if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
				var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
				var borderWidthScale = 2 / frameData.rect.z;
				var borderHeightScale = 2 / frameData.rect.w;

				this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);

				var tex = this.sprite.atlas.texture;

				this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);

				var ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;
				var scaleMulX = frameData.rect.z / ppu;
				var scaleMulY = frameData.rect.w / ppu;

				this._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));

				var scaleX = scaleMulX;
				var scaleY = scaleMulY;
				this._outerScale.x /= scaleMulX;
				this._outerScale.y /= scaleMulY;
				scaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);
				scaleY *= math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);

				if (this._renderable) {
					this._innerOffsetUniform[0] = this._innerOffset.x;
					this._innerOffsetUniform[1] = this._innerOffset.y;
					this._innerOffsetUniform[2] = this._innerOffset.z;
					this._innerOffsetUniform[3] = this._innerOffset.w;

					this._renderable.setParameter('innerOffset', this._innerOffsetUniform);

					this._atlasRectUniform[0] = this._atlasRect.x;
					this._atlasRectUniform[1] = this._atlasRect.y;
					this._atlasRectUniform[2] = this._atlasRect.z;
					this._atlasRectUniform[3] = this._atlasRect.w;

					this._renderable.setParameter('atlasRect', this._atlasRectUniform);

					this._outerScaleUniform[0] = this._outerScale.x;
					this._outerScaleUniform[1] = this._outerScale.y;

					this._renderable.setParameter('outerScale', this._outerScaleUniform);

					this._renderable.setAabbFunc(this._updateAabbFunc);

					this._renderable.node.setLocalScale(scaleX, scaleY, 1);

					this._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);
				}
			} else {
				var vb = mesh.vertexBuffer;
				var vertexDataF32 = new Float32Array(vb.lock());
				var hp = element.pivot.x;
				var vp = element.pivot.y;
				vertexDataF32[0] = 0 - hp * w;
				vertexDataF32[1] = 0 - vp * h;
				vertexDataF32[8] = w - hp * w;
				vertexDataF32[9] = 0 - vp * h;
				vertexDataF32[16] = w - hp * w;
				vertexDataF32[17] = h - vp * h;
				vertexDataF32[24] = 0 - hp * w;
				vertexDataF32[25] = h - vp * h;
				var atlasTextureWidth = 1;
				var atlasTextureHeight = 1;
				var rect = this._rect;

				if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
					var frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];

					if (frame) {
						rect = frame.rect;
						atlasTextureWidth = this._sprite.atlas.texture.width;
						atlasTextureHeight = this._sprite.atlas.texture.height;
					}
				}

				vertexDataF32[6] = rect.x / atlasTextureWidth;
				vertexDataF32[7] = 1.0 - rect.y / atlasTextureHeight;
				vertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;
				vertexDataF32[15] = 1.0 - rect.y / atlasTextureHeight;
				vertexDataF32[22] = (rect.x + rect.z) / atlasTextureWidth;
				vertexDataF32[23] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
				vertexDataF32[30] = rect.x / atlasTextureWidth;
				vertexDataF32[31] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
				vb.unlock();
				var min = new Vec3(0 - hp * w, 0 - vp * h, 0);
				var max = new Vec3(w - hp * w, h - vp * h, 0);
				mesh.aabb.setMinMax(min, max);

				if (this._renderable) {
					this._renderable.node.setLocalScale(1, 1, 1);

					this._renderable.node.setLocalPosition(0, 0, 0);

					this._renderable.setAabbFunc(null);
				}
			}

			this._meshDirty = false;
		};

		_proto2._updateSprite = function _updateSprite() {
			var nineSlice = false;
			var mesh = null;

			if (this._sprite && this._sprite.atlas) {
				mesh = this._sprite.meshes[this.spriteFrame];
				nineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;
			}

			this.mesh = nineSlice ? mesh : this._defaultMesh;

			if (this.mesh) {
				if (!this._element._beingInitialized) {
					this._updateMesh(this.mesh);
				} else {
					this._meshDirty = true;
				}
			}
		};

		_proto2._updateAabb = function _updateAabb(aabb) {
			aabb.center.set(0, 0, 0);
			aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
			aabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());
			return aabb;
		};

		_proto2._toggleMask = function _toggleMask() {
			this._element._dirtifyMask();

			var screenSpace = this._element._isScreenSpace();

			this._updateMaterial(screenSpace);

			this._renderable.setMask(!!this._mask);
		};

		_proto2._onMaterialLoad = function _onMaterialLoad(asset) {
			this.material = asset.resource;
		};

		_proto2._onMaterialAdded = function _onMaterialAdded(asset) {
			this._system.app.assets.off('add:' + asset.id, this._onMaterialAdded, this);

			if (this._materialAsset === asset.id) {
				this._bindMaterialAsset(asset);
			}
		};

		_proto2._bindMaterialAsset = function _bindMaterialAsset(asset) {
			if (!this._entity.enabled) return;
			asset.on("load", this._onMaterialLoad, this);
			asset.on("change", this._onMaterialChange, this);
			asset.on("remove", this._onMaterialRemove, this);

			if (asset.resource) {
				this._onMaterialLoad(asset);
			} else {
				this._system.app.assets.load(asset);
			}
		};

		_proto2._unbindMaterialAsset = function _unbindMaterialAsset(asset) {
			asset.off("load", this._onMaterialLoad, this);
			asset.off("change", this._onMaterialChange, this);
			asset.off("remove", this._onMaterialRemove, this);
		};

		_proto2._onMaterialChange = function _onMaterialChange() {};

		_proto2._onMaterialRemove = function _onMaterialRemove() {};

		_proto2._onTextureAdded = function _onTextureAdded(asset) {
			this._system.app.assets.off('add:' + asset.id, this._onTextureAdded, this);

			if (this._textureAsset === asset.id) {
				this._bindTextureAsset(asset);
			}
		};

		_proto2._bindTextureAsset = function _bindTextureAsset(asset) {
			if (!this._entity.enabled) return;
			asset.on("load", this._onTextureLoad, this);
			asset.on("change", this._onTextureChange, this);
			asset.on("remove", this._onTextureRemove, this);

			if (asset.resource) {
				this._onTextureLoad(asset);
			} else {
				this._system.app.assets.load(asset);
			}
		};

		_proto2._unbindTextureAsset = function _unbindTextureAsset(asset) {
			asset.off("load", this._onTextureLoad, this);
			asset.off("change", this._onTextureChange, this);
			asset.off("remove", this._onTextureRemove, this);
		};

		_proto2._onTextureLoad = function _onTextureLoad(asset) {
			this.texture = asset.resource;
		};

		_proto2._onTextureChange = function _onTextureChange(asset) {};

		_proto2._onTextureRemove = function _onTextureRemove(asset) {};

		_proto2._onSpriteAssetAdded = function _onSpriteAssetAdded(asset) {
			this._system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);

			if (this._spriteAsset === asset.id) {
				this._bindSpriteAsset(asset);
			}
		};

		_proto2._bindSpriteAsset = function _bindSpriteAsset(asset) {
			if (!this._entity.enabled) return;
			asset.on("load", this._onSpriteAssetLoad, this);
			asset.on("change", this._onSpriteAssetChange, this);
			asset.on("remove", this._onSpriteAssetRemove, this);

			if (asset.resource) {
				this._onSpriteAssetLoad(asset);
			} else {
				this._system.app.assets.load(asset);
			}
		};

		_proto2._unbindSpriteAsset = function _unbindSpriteAsset(asset) {
			asset.off("load", this._onSpriteAssetLoad, this);
			asset.off("change", this._onSpriteAssetChange, this);
			asset.off("remove", this._onSpriteAssetRemove, this);

			if (asset.data.textureAtlasAsset) {
				this._system.app.assets.off("load:" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
			}
		};

		_proto2._onSpriteAssetLoad = function _onSpriteAssetLoad(asset) {
			if (!asset || !asset.resource) {
				this.sprite = null;
			} else {
				if (!asset.resource.atlas) {
					var atlasAssetId = asset.data.textureAtlasAsset;

					if (atlasAssetId) {
						var assets = this._system.app.assets;
						assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
						assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
					}
				} else {
					this.sprite = asset.resource;
				}
			}
		};

		_proto2._onSpriteAssetChange = function _onSpriteAssetChange(asset) {
			this._onSpriteAssetLoad(asset);
		};

		_proto2._onSpriteAssetRemove = function _onSpriteAssetRemove(asset) {};

		_proto2._bindSprite = function _bindSprite(sprite) {
			sprite.on('set:meshes', this._onSpriteMeshesChange, this);
			sprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);
			sprite.on('set:atlas', this._onAtlasTextureChange, this);

			if (sprite.atlas) {
				sprite.atlas.on('set:texture', this._onAtlasTextureChange, this);
			}
		};

		_proto2._unbindSprite = function _unbindSprite(sprite) {
			sprite.off('set:meshes', this._onSpriteMeshesChange, this);
			sprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);
			sprite.off('set:atlas', this._onAtlasTextureChange, this);

			if (sprite.atlas) {
				sprite.atlas.off('set:texture', this._onAtlasTextureChange, this);
			}
		};

		_proto2._onSpriteMeshesChange = function _onSpriteMeshesChange() {
			if (this._sprite) {
				this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
			}

			this._updateSprite();
		};

		_proto2._onSpritePpuChange = function _onSpritePpuChange() {
			if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {
				this._updateSprite();
			}
		};

		_proto2._onAtlasTextureChange = function _onAtlasTextureChange() {
			if (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {
				this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);

				this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
			} else {
				this._renderable.deleteParameter('texture_emissiveMap');

				this._renderable.deleteParameter('texture_opacityMap');
			}
		};

		_proto2._onTextureAtlasLoad = function _onTextureAtlasLoad(atlasAsset) {
			var spriteAsset = this._spriteAsset;

			if (spriteAsset instanceof Asset) {
				this._onSpriteAssetLoad(spriteAsset);
			} else {
				this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));
			}
		};

		_proto2.onEnable = function onEnable() {
			if (this._materialAsset) {
				var asset = this._system.app.assets.get(this._materialAsset);

				if (asset && asset.resource !== this._material) {
					this._bindMaterialAsset(asset);
				}
			}

			if (this._textureAsset) {
				var _asset = this._system.app.assets.get(this._textureAsset);

				if (_asset && _asset.resource !== this._texture) {
					this._bindTextureAsset(_asset);
				}
			}

			if (this._spriteAsset) {
				var _asset2 = this._system.app.assets.get(this._spriteAsset);

				if (_asset2 && _asset2.resource !== this._sprite) {
					this._bindSpriteAsset(_asset2);
				}
			}

			this._element.addModelToLayers(this._renderable.model);
		};

		_proto2.onDisable = function onDisable() {
			this._element.removeModelFromLayers(this._renderable.model);
		};

		_proto2._setStencil = function _setStencil(stencilParams) {
			this._renderable.meshInstance.stencilFront = stencilParams;
			this._renderable.meshInstance.stencilBack = stencilParams;
			var ref = 0;

			if (this._element.maskedBy) {
				ref = this._element.maskedBy.element._image._maskRef;
			}

			if (this._renderable.unmaskMeshInstance) {
				var sp = new StencilParameters({
					ref: ref + 1,
					func: FUNC_EQUAL,
					zpass: STENCILOP_DECREMENT
				});
				this._renderable.unmaskMeshInstance.stencilFront = sp;
				this._renderable.unmaskMeshInstance.stencilBack = sp;
			}
		};

		_createClass(ImageElement, [{
			key: "color",
			get: function get() {
				return this._color;
			},
			set: function set(value) {
				var r = value.r;
				var g = value.g;
				var b = value.b;

				if (this._color === value) {
					Debug.warn("Setting element.color to itself will have no effect");
				}

				if (this._color.r !== r || this._color.g !== g || this._color.b !== b) {
					this._color.r = r;
					this._color.g = g;
					this._color.b = b;
					this._colorUniform[0] = r;
					this._colorUniform[1] = g;
					this._colorUniform[2] = b;

					this._renderable.setParameter('material_emissive', this._colorUniform);
				}

				if (this._element) {
					this._element.fire('set:color', this._color);
				}
			}
		}, {
			key: "opacity",
			get: function get() {
				return this._color.a;
			},
			set: function set(value) {
				if (value !== this._color.a) {
					this._color.a = value;

					this._renderable.setParameter('material_opacity', value);
				}

				if (this._element) {
					this._element.fire('set:opacity', value);
				}
			}
		}, {
			key: "rect",
			get: function get() {
				return this._rect;
			},
			set: function set(value) {
				if (this._rect === value) {
					console.warn('Setting element.rect to itself will have no effect');
				}

				var x, y, z, w;

				if (value instanceof Vec4) {
					x = value.x;
					y = value.y;
					z = value.z;
					w = value.w;
				} else {
					x = value[0];
					y = value[1];
					z = value[2];
					w = value[3];
				}

				if (x === this._rect.x && y === this._rect.y && z === this._rect.z && w === this._rect.w) {
					return;
				}

				this._rect.set(x, y, z, w);

				if (this._renderable.mesh) {
					if (!this._element._beingInitialized) {
						this._updateMesh(this._renderable.mesh);
					} else {
						this._meshDirty = true;
					}
				}
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(value) {
				if (this._material === value) return;

				if (!value) {
					var screenSpace = this._element._isScreenSpace();

					if (this.mask) {
						value = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;
					} else {
						value = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;
					}
				}

				this._material = value;

				if (value) {
					this._renderable.setMaterial(value);

					if (this._hasUserMaterial()) {
						this._renderable.deleteParameter('material_opacity');

						this._renderable.deleteParameter('material_emissive');
					} else {
						this._colorUniform[0] = this._color.r;
						this._colorUniform[1] = this._color.g;
						this._colorUniform[2] = this._color.b;

						this._renderable.setParameter('material_emissive', this._colorUniform);

						this._renderable.setParameter('material_opacity', this._color.a);
					}
				}
			}
		}, {
			key: "materialAsset",
			get: function get() {
				return this._materialAsset;
			},
			set: function set(value) {
				var assets = this._system.app.assets;
				var _id = value;

				if (value instanceof Asset) {
					_id = value.id;
				}

				if (this._materialAsset !== _id) {
					if (this._materialAsset) {
						assets.off('add:' + this._materialAsset, this._onMaterialAdded, this);

						var _prev = assets.get(this._materialAsset);

						if (_prev) {
							_prev.off("load", this._onMaterialLoad, this);

							_prev.off("change", this._onMaterialChange, this);

							_prev.off("remove", this._onMaterialRemove, this);
						}
					}

					this._materialAsset = _id;

					if (this._materialAsset) {
						var asset = assets.get(this._materialAsset);

						if (!asset) {
							this.material = null;
							assets.on('add:' + this._materialAsset, this._onMaterialAdded, this);
						} else {
							this._bindMaterialAsset(asset);
						}
					} else {
						this.material = null;
					}
				}
			}
		}, {
			key: "texture",
			get: function get() {
				return this._texture;
			},
			set: function set(value) {
				if (this._texture === value) return;

				if (this._textureAsset) {
					var textureAsset = this._system.app.assets.get(this._textureAsset);

					if (textureAsset && textureAsset.resource !== value) {
						this.textureAsset = null;
					}
				}

				this._texture = value;

				if (value) {
					if (this._spriteAsset) {
						this.spriteAsset = null;
					}

					this._renderable.setParameter("texture_emissiveMap", this._texture);

					this._renderable.setParameter("texture_opacityMap", this._texture);

					this._colorUniform[0] = this._color.r;
					this._colorUniform[1] = this._color.g;
					this._colorUniform[2] = this._color.b;

					this._renderable.setParameter("material_emissive", this._colorUniform);

					this._renderable.setParameter("material_opacity", this._color.a);
				} else {
					this._renderable.deleteParameter("texture_emissiveMap");

					this._renderable.deleteParameter("texture_opacityMap");
				}
			}
		}, {
			key: "textureAsset",
			get: function get() {
				return this._textureAsset;
			},
			set: function set(value) {
				var assets = this._system.app.assets;
				var _id = value;

				if (value instanceof Asset) {
					_id = value.id;
				}

				if (this._textureAsset !== _id) {
					if (this._textureAsset) {
						assets.off('add:' + this._textureAsset, this._onTextureAdded, this);

						var _prev = assets.get(this._textureAsset);

						if (_prev) {
							_prev.off("load", this._onTextureLoad, this);

							_prev.off("change", this._onTextureChange, this);

							_prev.off("remove", this._onTextureRemove, this);
						}
					}

					this._textureAsset = _id;

					if (this._textureAsset) {
						var asset = assets.get(this._textureAsset);

						if (!asset) {
							this.texture = null;
							assets.on('add:' + this._textureAsset, this._onTextureAdded, this);
						} else {
							this._bindTextureAsset(asset);
						}
					} else {
						this.texture = null;
					}
				}
			}
		}, {
			key: "spriteAsset",
			get: function get() {
				return this._spriteAsset;
			},
			set: function set(value) {
				var assets = this._system.app.assets;
				var _id = value;

				if (value instanceof Asset) {
					_id = value.id;
				}

				if (this._spriteAsset !== _id) {
					if (this._spriteAsset) {
						assets.off('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);

						var _prev = assets.get(this._spriteAsset);

						if (_prev) {
							this._unbindSpriteAsset(_prev);
						}
					}

					this._spriteAsset = _id;

					if (this._spriteAsset) {
						var asset = assets.get(this._spriteAsset);

						if (!asset) {
							this.sprite = null;
							assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
						} else {
							this._bindSpriteAsset(asset);
						}
					} else {
						this.sprite = null;
					}
				}

				if (this._element) {
					this._element.fire('set:spriteAsset', _id);
				}
			}
		}, {
			key: "sprite",
			get: function get() {
				return this._sprite;
			},
			set: function set(value) {
				if (this._sprite === value) return;

				if (this._sprite) {
					this._unbindSprite(this._sprite);
				}

				if (this._spriteAsset) {
					var spriteAsset = this._system.app.assets.get(this._spriteAsset);

					if (spriteAsset && spriteAsset.resource !== value) {
						this.spriteAsset = null;
					}
				}

				this._sprite = value;

				if (this._sprite) {
					this._bindSprite(this._sprite);

					if (this._textureAsset) {
						this.textureAsset = null;
					}
				}

				if (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {
					this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture);

					this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture);
				} else {
					this._renderable.deleteParameter("texture_emissiveMap");

					this._renderable.deleteParameter("texture_opacityMap");
				}

				if (this._sprite) {
					this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
				}

				this._updateSprite();
			}
		}, {
			key: "spriteFrame",
			get: function get() {
				return this._spriteFrame;
			},
			set: function set(value) {
				var oldValue = this._spriteFrame;

				if (this._sprite) {
					this._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
				} else {
					this._spriteFrame = value;
				}

				if (this._spriteFrame !== oldValue) {
					this._updateSprite();
				}

				if (this._element) {
					this._element.fire('set:spriteFrame', value);
				}
			}
		}, {
			key: "mesh",
			get: function get() {
				return this._renderable.mesh;
			},
			set: function set(value) {
				this._renderable.setMesh(value);

				if (this._defaultMesh === value) {
					this._renderable.setAabbFunc(null);
				} else {
					this._renderable.setAabbFunc(this._updateAabbFunc);
				}
			}
		}, {
			key: "mask",
			get: function get() {
				return this._mask;
			},
			set: function set(value) {
				if (this._mask !== value) {
					this._mask = value;

					this._toggleMask();
				}
			}
		}, {
			key: "pixelsPerUnit",
			get: function get() {
				return this._pixelsPerUnit;
			},
			set: function set(value) {
				if (this._pixelsPerUnit === value) return;
				this._pixelsPerUnit = value;

				if (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
					this._updateSprite();
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				if (this._renderable.meshInstance) {
					return this._renderable.meshInstance.aabb;
				}

				return null;
			}
		}]);

		return ImageElement;
	}();

	var LocalizedAsset = function (_EventHandler) {
		_inheritsLoose(LocalizedAsset, _EventHandler);

		function LocalizedAsset(app) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._app = app;
			app.i18n.on('set:locale', _this._onSetLocale, _assertThisInitialized(_this));
			_this._autoLoad = false;
			_this._disableLocalization = false;
			_this._defaultAsset = null;
			_this._localizedAsset = null;
			return _this;
		}

		var _proto = LocalizedAsset.prototype;

		_proto._bindDefaultAsset = function _bindDefaultAsset() {
			var asset = this._app.assets.get(this._defaultAsset);

			if (!asset) {
				this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
			} else {
				this._onDefaultAssetAdd(asset);
			}
		};

		_proto._unbindDefaultAsset = function _unbindDefaultAsset() {
			if (!this._defaultAsset) return;

			this._app.assets.off('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);

			var asset = this._app.assets.get(this._defaultAsset);

			if (!asset) return;
			asset.off('add:localized', this._onLocaleAdd, this);
			asset.off('remove:localized', this._onLocaleRemove, this);
			asset.off('remove', this._onDefaultAssetRemove, this);
		};

		_proto._onDefaultAssetAdd = function _onDefaultAssetAdd(asset) {
			if (this._defaultAsset !== asset.id) return;
			asset.on('add:localized', this._onLocaleAdd, this);
			asset.on('remove:localized', this._onLocaleRemove, this);
			asset.once('remove', this._onDefaultAssetRemove, this);
		};

		_proto._onDefaultAssetRemove = function _onDefaultAssetRemove(asset) {
			if (this._defaultAsset !== asset.id) return;
			asset.off('add:localized', this._onLocaleAdd, this);
			asset.off('remove:localized', this._onLocaleAdd, this);

			this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
		};

		_proto._bindLocalizedAsset = function _bindLocalizedAsset() {
			if (!this._autoLoad) return;

			var asset = this._app.assets.get(this._localizedAsset);

			if (!asset) return;
			asset.on("load", this._onLocalizedAssetLoad, this);
			asset.on("change", this._onLocalizedAssetChange, this);
			asset.on("remove", this._onLocalizedAssetRemove, this);

			if (asset.resource) {
				this._onLocalizedAssetLoad(asset);
			} else {
				this._app.assets.load(asset);
			}
		};

		_proto._unbindLocalizedAsset = function _unbindLocalizedAsset() {
			var asset = this._app.assets.get(this._localizedAsset);

			if (!asset) return;
			asset.off("load", this._onLocalizedAssetLoad, this);
			asset.off("change", this._onLocalizedAssetChange, this);
			asset.off("remove", this._onLocalizedAssetRemove, this);
		};

		_proto._onLocalizedAssetAdd = function _onLocalizedAssetAdd(asset) {
			if (this._localizedAsset !== asset.id) return;

			this._bindLocalizedAsset();
		};

		_proto._onLocalizedAssetLoad = function _onLocalizedAssetLoad(asset) {
			this.fire('load', asset);
		};

		_proto._onLocalizedAssetChange = function _onLocalizedAssetChange(asset, name, newValue, oldValue) {
			this.fire('change', asset, name, newValue, oldValue);
		};

		_proto._onLocalizedAssetRemove = function _onLocalizedAssetRemove(asset) {
			if (this._localizedAsset === asset.id) {
				this.localizedAsset = this._defaultAsset;
			}

			this.fire('remove', asset);
		};

		_proto._onLocaleAdd = function _onLocaleAdd(locale, assetId) {
			if (this._app.i18n.locale !== locale) return;

			this._onSetLocale(locale);
		};

		_proto._onLocaleRemove = function _onLocaleRemove(locale, assetId) {
			if (this._app.i18n.locale !== locale) return;

			this._onSetLocale(locale);
		};

		_proto._onSetLocale = function _onSetLocale(locale) {
			if (!this._defaultAsset) {
				this.localizedAsset = null;
				return;
			}

			var asset = this._app.assets.get(this._defaultAsset);

			if (!asset || this._disableLocalization) {
				this.localizedAsset = this._defaultAsset;
				return;
			}

			var localizedAssetId = asset.getLocalizedAssetId(locale);

			if (!localizedAssetId) {
				this.localizedAsset = this._defaultAsset;
				return;
			}

			this.localizedAsset = localizedAssetId;
		};

		_proto.destroy = function destroy() {
			this.defaultAsset = null;

			this._app.i18n.off('set:locale', this._onSetLocale, this);

			this.off();
		};

		_createClass(LocalizedAsset, [{
			key: "defaultAsset",
			get: function get() {
				return this._defaultAsset;
			},
			set: function set(value) {
				var id = value instanceof Asset ? value.id : value;
				if (this._defaultAsset === id) return;

				if (this._defaultAsset) {
					this._unbindDefaultAsset();
				}

				this._defaultAsset = id;

				if (this._defaultAsset) {
					this._bindDefaultAsset();
				}

				this._onSetLocale(this._app.i18n.locale);
			}
		}, {
			key: "localizedAsset",
			get: function get() {
				return this._localizedAsset;
			},
			set: function set(value) {
				var id = value instanceof Asset ? value.id : value;

				if (this._localizedAsset === id) {
					return;
				}

				if (this._localizedAsset) {
					this._app.assets.off('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);

					this._unbindLocalizedAsset();

					this._localizedAsset = null;
				}

				this._localizedAsset = id;

				if (this._localizedAsset) {
					var asset = this._app.assets.get(this._localizedAsset);

					if (!asset) {
						this._app.assets.once('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);
					} else {
						this._bindLocalizedAsset();
					}
				}
			}
		}, {
			key: "autoLoad",
			get: function get() {
				return this._autoLoad;
			},
			set: function set(value) {
				if (this._autoLoad === value) return;
				this._autoLoad = value;

				if (this._autoLoad && this._localizedAsset) {
					this._unbindLocalizedAsset();

					this._bindLocalizedAsset();
				}
			}
		}, {
			key: "disableLocalization",
			get: function get() {
				return this._disableLocalization;
			},
			set: function set(value) {
				if (this._disableLocalization === value) return;
				this._disableLocalization = value;

				this._onSetLocale(this._app.i18n.locale);
			}
		}]);

		return LocalizedAsset;
	}(EventHandler);

	var EOF_TOKEN = 0;
	var ERROR_TOKEN = 1;
	var TEXT_TOKEN = 2;
	var OPEN_BRACKET_TOKEN = 3;
	var CLOSE_BRACKET_TOKEN = 4;
	var EQUALS_TOKEN = 5;
	var STRING_TOKEN = 6;
	var IDENTIFIER_TOKEN = 7;
	var WHITESPACE_TOKEN = 8;
	var WHITESPACE_CHARS = " \t\n\r\v\f";
	var IDENTIFIER_REGEX = /[A-Z|a-z|0-9|_|-|/]/;

	var Scanner = function () {
		function Scanner(symbols) {
			this._symbols = symbols;
			this._index = 0;
			this._last = 0;
			this._cur = this._symbols.length > 0 ? this._symbols[0] : null;
			this._buf = [];
			this._mode = "text";
			this._error = null;
		}

		var _proto = Scanner.prototype;

		_proto.read = function read() {
			var token = this._read();

			while (token === WHITESPACE_TOKEN) {
				token = this._read();
			}

			if (token !== EOF_TOKEN && token !== ERROR_TOKEN) {
				this._last = this._index;
			}

			return token;
		};

		_proto.buf = function buf() {
			return this._buf;
		};

		_proto.last = function last() {
			return this._last;
		};

		_proto.error = function error() {
			return this._error;
		};

		_proto.debugPrint = function debugPrint() {
			var tokenStrings = ["EOF", "ERROR", "TEXT", "OPEN_BRACKET", "CLOSE_BRACKET", "EQUALS", "STRING", "IDENTIFIER", "WHITESPACE"];
			var token = this.read();
			var result = "";

			while (true) {
				result += (result.length > 0 ? "\n" : "") + tokenStrings[token] + " '" + this.buf().join("") + "'";

				if (token === EOF_TOKEN || token === ERROR_TOKEN) {
					break;
				}

				token = this.read();
			}

			return result;
		};

		_proto._read = function _read() {
			this._buf = [];

			if (this._eof()) {
				return EOF_TOKEN;
			}

			return this._mode === "text" ? this._text() : this._tag();
		};

		_proto._text = function _text() {
			while (true) {
				switch (this._cur) {
					case null:
						return this._buf.length > 0 ? TEXT_TOKEN : EOF_TOKEN;

					case "[":
						this._mode = "tag";
						return this._buf.length > 0 ? TEXT_TOKEN : this._tag();

					case "\\":
						this._next();

						switch (this._cur) {
							case "[":
								this._store();

								break;

							default:
								this._output("\\");

								break;
						}

						break;

					default:
						this._store();

						break;
				}
			}
		};

		_proto._tag = function _tag() {
			switch (this._cur) {
				case null:
					this._error = "unexpected end of input reading tag";
					return ERROR_TOKEN;

				case "[":
					this._store();

					return OPEN_BRACKET_TOKEN;

				case "]":
					this._store();

					this._mode = "text";
					return CLOSE_BRACKET_TOKEN;

				case "=":
					this._store();

					return EQUALS_TOKEN;

				case " ":
				case "\t":
				case "\n":
				case "\r":
				case "\v":
				case "\f":
					return this._whitespace();

				case "\"":
					return this._string();

				default:
					if (!this._isIdentifierSymbol(this._cur)) {
						this._error = "unrecognized character";
						return ERROR_TOKEN;
					}

					return this._identifier();
			}
		};

		_proto._whitespace = function _whitespace() {
			this._store();

			while (WHITESPACE_CHARS.indexOf(this._cur) !== -1) {
				this._store();
			}

			return WHITESPACE_TOKEN;
		};

		_proto._string = function _string() {
			this._next();

			while (true) {
				switch (this._cur) {
					case null:
						this._error = "unexpected end of input reading string";
						return ERROR_TOKEN;

					case "\"":
						this._next();

						return STRING_TOKEN;

					default:
						this._store();

						break;
				}
			}
		};

		_proto._identifier = function _identifier() {
			this._store();

			while (this._cur !== null && this._isIdentifierSymbol(this._cur)) {
				this._store();
			}

			return IDENTIFIER_TOKEN;
		};

		_proto._isIdentifierSymbol = function _isIdentifierSymbol(s) {
			return s.length === 1 && s.match(IDENTIFIER_REGEX) !== null;
		};

		_proto._eof = function _eof() {
			return this._cur === null;
		};

		_proto._next = function _next() {
			if (!this._eof()) {
				this._index++;
				this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null;
			}

			return this._cur;
		};

		_proto._store = function _store() {
			this._buf.push(this._cur);

			return this._next();
		};

		_proto._output = function _output(c) {
			this._buf.push(c);
		};

		return Scanner;
	}();

	var Parser = function () {
		function Parser(symbols) {
			this._scanner = new Scanner(symbols);
			this._error = null;
		}

		var _proto2 = Parser.prototype;

		_proto2.parse = function parse(symbols, tags) {
			while (true) {
				var token = this._scanner.read();

				switch (token) {
					case EOF_TOKEN:
						return true;

					case ERROR_TOKEN:
						return false;

					case TEXT_TOKEN:
						Array.prototype.push.apply(symbols, this._scanner.buf());
						break;

					case OPEN_BRACKET_TOKEN:
						if (!this._parseTag(symbols, tags)) {
							return false;
						}

						break;

					default:
						return false;
				}
			}
		};

		_proto2.error = function error() {
			return "Error evaluating markup at #" + this._scanner.last().toString() + " (" + (this._scanner.error() || this._error) + ")";
		};

		_proto2._parseTag = function _parseTag(symbols, tags) {
			var token = this._scanner.read();

			if (token !== IDENTIFIER_TOKEN) {
				this._error = "expected identifier";
				return false;
			}

			var name = this._scanner.buf().join("");

			if (name[0] === "/") {
				for (var index = tags.length - 1; index >= 0; --index) {
					if (name === "/" + tags[index].name && tags[index].end === null) {
						tags[index].end = symbols.length;
						token = this._scanner.read();

						if (token !== CLOSE_BRACKET_TOKEN) {
							this._error = "expected close bracket";
							return false;
						}

						return true;
					}
				}

				this._error = "failed to find matching tag";
				return false;
			}

			var tag = {
				name: name,
				value: null,
				attributes: {},
				start: symbols.length,
				end: null
			};
			token = this._scanner.read();

			if (token === EQUALS_TOKEN) {
				token = this._scanner.read();

				if (token !== STRING_TOKEN) {
					this._error = "expected string";
					return false;
				}

				tag.value = this._scanner.buf().join("");
				token = this._scanner.read();
			}

			while (true) {
				switch (token) {
					case CLOSE_BRACKET_TOKEN:
						tags.push(tag);
						return true;

					case IDENTIFIER_TOKEN:
						{
							var identifier = this._scanner.buf().join("");

							token = this._scanner.read();

							if (token !== EQUALS_TOKEN) {
								this._error = "expected equals";
								return false;
							}

							token = this._scanner.read();

							if (token !== STRING_TOKEN) {
								this._error = "expected string";
								return false;
							}

							var value = this._scanner.buf().join("");

							tag.attributes[identifier] = value;
							break;
						}

					default:
						this._error = "expected close bracket or identifier";
						return false;
				}

				token = this._scanner.read();
			}
		};

		return Parser;
	}();

	function merge(target, source) {
		for (var key in source) {
			if (!source.hasOwnProperty(key)) {
				continue;
			}

			var value = source[key];

			if (value instanceof Object) {
				if (!target.hasOwnProperty(key)) {
					target[key] = {};
				}

				merge(target[key], source[key]);
			} else {
				target[key] = value;
			}
		}
	}

	function combineTags(tags) {
		if (tags.length === 0) {
			return null;
		}

		var result = {};

		for (var index = 0; index < tags.length; ++index) {
			var tag = tags[index];
			var tmp = {};
			tmp[tag.name] = {
				value: tag.value,
				attributes: tag.attributes
			};
			merge(result, tmp);
		}

		return result;
	}

	function resolveMarkupTags(tags, numSymbols) {
		if (tags.length === 0) {
			return null;
		}

		var edges = {};

		for (var index = 0; index < tags.length; ++index) {
			var tag = tags[index];

			if (!edges.hasOwnProperty(tag.start)) {
				edges[tag.start] = {
					open: [tag],
					close: null
				};
			} else {
				if (edges[tag.start].open === null) {
					edges[tag.start].open = [tag];
				} else {
					edges[tag.start].open.push(tag);
				}
			}

			if (!edges.hasOwnProperty(tag.end)) {
				edges[tag.end] = {
					open: null,
					close: [tag]
				};
			} else {
				if (edges[tag.end].close === null) {
					edges[tag.end].close = [tag];
				} else {
					edges[tag.end].close.push(tag);
				}
			}
		}

		var tagStack = [];

		function removeTags(tags) {
			tagStack = tagStack.filter(function (tag) {
				return tags.find(function (t) {
					return t === tag;
				}) === undefined;
			});
		}

		function addTags(tags) {
			for (var _index = 0; _index < tags.length; ++_index) {
				tagStack.push(tags[_index]);
			}
		}

		var edgeKeys = Object.keys(edges).sort(function (a, b) {
			return a - b;
		});
		var resolvedTags = [];

		for (var _index2 = 0; _index2 < edgeKeys.length; ++_index2) {
			var edge = edges[edgeKeys[_index2]];

			if (edge.close !== null) {
				removeTags(edge.close);
			}

			if (edge.open !== null) {
				addTags(edge.open);
			}

			resolvedTags.push({
				start: edgeKeys[_index2],
				tags: combineTags(tagStack)
			});
		}

		var result = [];
		var prevTag = null;

		for (var _index3 = 0; _index3 < resolvedTags.length; ++_index3) {
			var resolvedTag = resolvedTags[_index3];

			while (result.length < resolvedTag.start) {
				result.push(prevTag ? prevTag.tags : null);
			}

			prevTag = resolvedTag;
		}

		while (result.length < numSymbols) {
			result.push(null);
		}

		return result;
	}

	function evaluateMarkup(symbols) {
		var parser = new Parser(symbols);
		var stripped_symbols = [];
		var tags = [];

		if (!parser.parse(stripped_symbols, tags)) {
			console.warn(parser.error());
			return {
				symbols: symbols,
				tags: null
			};
		}

		var invalidTag = tags.find(function (t) {
			return t.end === null;
		});

		if (invalidTag) {
			console.warn("Markup error: found unclosed tag='" + invalidTag.name + "'");
			return {
				symbols: symbols,
				tags: null
			};
		}

		var resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);
		return {
			symbols: stripped_symbols,
			tags: resolved_tags
		};
	}

	var Markup = function () {
		function Markup() {}

		Markup.evaluate = function evaluate(symbols) {
			return evaluateMarkup(symbols);
		};

		return Markup;
	}();

	var MeshInfo = function MeshInfo() {
		this.count = 0;
		this.quad = 0;
		this.lines = {};
		this.positions = [];
		this.normals = [];
		this.uvs = [];
		this.colors = [];
		this.indices = [];
		this.meshInstance = null;
	};

	var LINE_BREAK_CHAR = /^[\r\n]$/;
	var WHITESPACE_CHAR = /^[ \t]$/;
	var WORD_BOUNDARY_CHAR = /^[ \t\-]|[\u200b]$/;
	var ALPHANUMERIC_CHAR = /^[a-z0-9]$/i;
	var CJK_CHAR = /^[\u1100-\u11ff]|[\u3000-\u9fff]|[\ua960-\ua97f]|[\uac00-\ud7ff]$/;
	var NO_LINE_BREAK_CJK_CHAR = /^[〕〉》」』】〙〗〟ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻]$/;
	var CONTROL_CHARS = ["\u200B", "\u061C", "\u200E", "\u200F", "\u202A", "\u202B", "\u202C", "\u202D", "\u202E", "\u2066", "\u2067", "\u2068", "\u2069"];
	var CONTROL_GLYPH_DATA = {
		width: 0,
		height: 0,
		xadvance: 0,
		xoffset: 0,
		yoffset: 0
	};

	var TextElement = function () {
		function TextElement(element) {
			this._element = element;
			this._system = element.system;
			this._entity = element.entity;
			this._text = "";
			this._symbols = [];
			this._colorPalette = [];
			this._symbolColors = null;
			this._i18nKey = null;
			this._fontAsset = new LocalizedAsset(this._system.app);
			this._fontAsset.disableLocalization = true;

			this._fontAsset.on('load', this._onFontLoad, this);

			this._fontAsset.on('change', this._onFontChange, this);

			this._fontAsset.on('remove', this._onFontRemove, this);

			this._font = null;
			this._color = new Color(1, 1, 1, 1);
			this._colorUniform = new Float32Array(3);
			this._spacing = 1;
			this._fontSize = 32;
			this._fontMinY = 0;
			this._fontMaxY = 0;
			this._originalFontSize = 32;
			this._maxFontSize = 32;
			this._minFontSize = 8;
			this._autoFitWidth = false;
			this._autoFitHeight = false;
			this._maxLines = -1;
			this._lineHeight = 32;
			this._scaledLineHeight = 32;
			this._wrapLines = false;
			this._drawOrder = 0;
			this._alignment = new Vec2(0.5, 0.5);
			this._autoWidth = true;
			this._autoHeight = true;
			this.width = 0;
			this.height = 0;
			this._node = new GraphNode();
			this._model = new Model();
			this._model.graph = this._node;

			this._entity.addChild(this._node);

			this._meshInfo = [];
			this._material = null;
			this._aabbDirty = true;
			this._aabb = new BoundingBox();
			this._noResize = false;
			this._currentMaterialType = null;
			this._maskedMaterialSrc = null;
			this._rtlReorder = false;
			this._unicodeConverter = false;
			this._rtl = false;
			this._outlineColor = new Color(0, 0, 0, 1);
			this._outlineColorUniform = new Float32Array(4);
			this._outlineThicknessScale = 0.2;
			this._outlineThickness = 0.0;
			this._shadowColor = new Color(0, 0, 0, 1);
			this._shadowColorUniform = new Float32Array(4);
			this._shadowOffsetScale = 0.005;
			this._shadowOffset = new Vec2(0, 0);
			this._shadowOffsetUniform = new Float32Array(2);
			this._enableMarkup = false;

			this._onScreenChange(this._element.screen);

			element.on('resize', this._onParentResize, this);
			element.on('set:screen', this._onScreenChange, this);
			element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
			element.on('set:draworder', this._onDrawOrderChange, this);
			element.on('set:pivot', this._onPivotChange, this);

			this._system.app.i18n.on('set:locale', this._onLocaleSet, this);

			this._system.app.i18n.on('data:add', this._onLocalizationData, this);

			this._system.app.i18n.on('data:remove', this._onLocalizationData, this);

			this._rangeStart = 0;
			this._rangeEnd = 0;
		}

		var _proto = TextElement.prototype;

		_proto.destroy = function destroy() {
			this._setMaterial(null);

			if (this._model) {
				this._element.removeModelFromLayers(this._model);

				this._model.destroy();

				this._model = null;
			}

			this._fontAsset.destroy();

			this.font = null;

			this._element.off('resize', this._onParentResize, this);

			this._element.off('set:screen', this._onScreenChange, this);

			this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);

			this._element.off('set:draworder', this._onDrawOrderChange, this);

			this._element.off('set:pivot', this._onPivotChange, this);

			this._system.app.i18n.off('set:locale', this._onLocaleSet, this);

			this._system.app.i18n.off('data:add', this._onLocalizationData, this);

			this._system.app.i18n.off('data:remove', this._onLocalizationData, this);
		};

		_proto._onParentResize = function _onParentResize(width, height) {
			if (this._noResize) return;
			if (this._font) this._updateText();
		};

		_proto._onScreenChange = function _onScreenChange(screen) {
			if (screen) {
				this._updateMaterial(screen.screen.screenSpace);
			} else {
				this._updateMaterial(false);
			}
		};

		_proto._onScreenSpaceChange = function _onScreenSpaceChange(value) {
			this._updateMaterial(value);
		};

		_proto._onDrawOrderChange = function _onDrawOrderChange(order) {
			this._drawOrder = order;

			if (this._model) {
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					this._model.meshInstances[i].drawOrder = order;
				}
			}
		};

		_proto._onPivotChange = function _onPivotChange(pivot) {
			if (this._font) this._updateText();
		};

		_proto._onLocaleSet = function _onLocaleSet(locale) {
			if (!this._i18nKey) return;

			if (this.fontAsset) {
				var asset = this._system.app.assets.get(this.fontAsset);

				if (!asset || !asset.resource || asset.resource !== this._font) {
					this.font = null;
				}
			}

			this._resetLocalizedText();
		};

		_proto._onLocalizationData = function _onLocalizationData(locale, messages) {
			if (this._i18nKey && messages[this._i18nKey]) {
				this._resetLocalizedText();
			}
		};

		_proto._resetLocalizedText = function _resetLocalizedText() {
			this._setText(this._system.app.i18n.getText(this._i18nKey));
		};

		_proto._setText = function _setText(text) {
			if (this.unicodeConverter) {
				var unicodeConverterFunc = this._system.getUnicodeConverter();

				if (unicodeConverterFunc) {
					text = unicodeConverterFunc(text);
				} else {
					console.warn('Element created with unicodeConverter option but no unicodeConverter function registered');
				}
			}

			if (this._text !== text) {
				if (this._font) {
					this._updateText(text);
				}

				this._text = text;
			}
		};

		_proto._updateText = function _updateText(text) {
			var tags;
			if (text === undefined) text = this._text;
			this._symbols = string.getSymbols(text.normalize ? text.normalize('NFC') : text);

			if (this._symbols.length === 0) {
				this._symbols = [" "];
			}

			if (this._enableMarkup) {
				var results = Markup.evaluate(this._symbols);
				this._symbols = results.symbols;
				tags = results.tags;
			}

			if (this._rtlReorder) {
				var rtlReorderFunc = this._system.app.systems.element.getRtlReorder();

				if (rtlReorderFunc) {
					var _results = rtlReorderFunc(this._symbols);

					this._rtl = _results.rtl;
					this._symbols = _results.mapping.map(function (v) {
						return this._symbols[v];
					}, this);

					if (tags) {
						tags = _results.mapping.map(function (v) {
							return tags[v];
						});
					}
				} else {
					console.warn('Element created with rtlReorder option but no rtlReorder function registered');
				}
			} else {
				this._rtl = false;
			}

			if (tags) {
				var paletteMap = {};
				this._colorPalette = [Math.round(this._color.r * 255), Math.round(this._color.g * 255), Math.round(this._color.b * 255)];
				this._symbolColors = [];
				paletteMap[this._color.toString(false).toLowerCase()] = 0;

				for (var i = 0, len = this._symbols.length; i < len; ++i) {
					var tag = tags[i];
					var color = 0;

					if (tag && tag.color && tag.color.value) {
						var c = tag.color.value;

						if (c.length === 7 && c[0] === "#") {
							var hex = c.substring(1).toLowerCase();

							if (paletteMap.hasOwnProperty(hex)) {
								color = paletteMap[hex];
							} else {
								if (/^([0-9a-f]{2}){3}$/.test(hex)) {
									color = this._colorPalette.length / 3;
									paletteMap[hex] = color;

									this._colorPalette.push(parseInt(hex.substring(0, 2), 16));

									this._colorPalette.push(parseInt(hex.substring(2, 4), 16));

									this._colorPalette.push(parseInt(hex.substring(4, 6), 16));
								}
							}
						}
					}

					this._symbolColors.push(color);
				}
			} else {
				this._colorPalette = [];
				this._symbolColors = null;
			}

			var charactersPerTexture = this._calculateCharsPerTexture();

			var removedModel = false;
			var element = this._element;

			var screenSpace = element._isScreenSpace();

			var screenCulled = element._isScreenCulled();

			var visibleFn = function visibleFn(camera) {
				return element.isVisibleForCamera(camera);
			};

			for (var _i = 0, _len = this._meshInfo.length; _i < _len; _i++) {
				var l = charactersPerTexture[_i] || 0;
				var meshInfo = this._meshInfo[_i];

				if (meshInfo.count !== l) {
					if (!removedModel) {
						element.removeModelFromLayers(this._model);
						removedModel = true;
					}

					meshInfo.count = l;
					meshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;
					meshInfo.indices.length = l * 3 * 2;
					meshInfo.uvs.length = l * 2 * 4;
					meshInfo.colors.length = l * 4 * 4;

					if (meshInfo.meshInstance) {
						this._removeMeshInstance(meshInfo.meshInstance);
					}

					if (l === 0) {
						meshInfo.meshInstance = null;
						continue;
					}

					for (var v = 0; v < l; v++) {
						meshInfo.indices[v * 3 * 2 + 0] = v * 4;
						meshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;
						meshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;
						meshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;
						meshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;
						meshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;
						meshInfo.normals[v * 4 * 3 + 0] = 0;
						meshInfo.normals[v * 4 * 3 + 1] = 0;
						meshInfo.normals[v * 4 * 3 + 2] = -1;
						meshInfo.normals[v * 4 * 3 + 3] = 0;
						meshInfo.normals[v * 4 * 3 + 4] = 0;
						meshInfo.normals[v * 4 * 3 + 5] = -1;
						meshInfo.normals[v * 4 * 3 + 6] = 0;
						meshInfo.normals[v * 4 * 3 + 7] = 0;
						meshInfo.normals[v * 4 * 3 + 8] = -1;
						meshInfo.normals[v * 4 * 3 + 9] = 0;
						meshInfo.normals[v * 4 * 3 + 10] = 0;
						meshInfo.normals[v * 4 * 3 + 11] = -1;
					}

					var mesh = createMesh$1(this._system.app.graphicsDevice, meshInfo.positions, {
						uvs: meshInfo.uvs,
						normals: meshInfo.normals,
						colors: meshInfo.colors,
						indices: meshInfo.indices
					});
					var mi = new MeshInstance(mesh, this._material, this._node);
					mi.name = "Text Element: " + this._entity.name;
					mi.castShadow = false;
					mi.receiveShadow = false;
					mi.cull = !screenSpace;
					mi.screenSpace = screenSpace;
					mi.drawOrder = this._drawOrder;

					if (screenCulled) {
						mi.cull = true;
						mi.isVisibleFunc = visibleFn;
					}

					this._setTextureParams(mi, this._font.textures[_i]);

					if (this._symbolColors) {
						this._colorUniform[0] = 1;
						this._colorUniform[1] = 1;
						this._colorUniform[2] = 1;
					} else {
						this._colorUniform[0] = this._color.r;
						this._colorUniform[1] = this._color.g;
						this._colorUniform[2] = this._color.b;
					}

					mi.setParameter("material_emissive", this._colorUniform);
					mi.setParameter("material_opacity", this._color.a);
					mi.setParameter("font_sdfIntensity", this._font.intensity);
					mi.setParameter("font_pxrange", this._getPxRange(this._font));
					mi.setParameter("font_textureWidth", this._font.data.info.maps[_i].width);
					this._outlineColorUniform[0] = this._outlineColor.r;
					this._outlineColorUniform[1] = this._outlineColor.g;
					this._outlineColorUniform[2] = this._outlineColor.b;
					this._outlineColorUniform[3] = this._outlineColor.a;
					mi.setParameter("outline_color", this._outlineColorUniform);
					mi.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
					this._shadowColorUniform[0] = this._shadowColor.r;
					this._shadowColorUniform[1] = this._shadowColor.g;
					this._shadowColorUniform[2] = this._shadowColor.b;
					this._shadowColorUniform[3] = this._shadowColor.a;
					mi.setParameter("shadow_color", this._shadowColorUniform);
					var ratio = -this._font.data.info.maps[_i].width / this._font.data.info.maps[_i].height;
					this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
					this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
					mi.setParameter("shadow_offset", this._shadowOffsetUniform);
					meshInfo.meshInstance = mi;

					this._model.meshInstances.push(mi);
				}
			}

			if (this._element.maskedBy) {
				this._element._setMaskedBy(this._element.maskedBy);
			}

			if (removedModel && this._element.enabled && this._entity.enabled) {
				this._element.addModelToLayers(this._model);
			}

			this._updateMeshes();

			this._rangeStart = 0;
			this._rangeEnd = this._symbols.length;

			this._updateRenderRange();
		};

		_proto._removeMeshInstance = function _removeMeshInstance(meshInstance) {
			meshInstance.destroy();

			var idx = this._model.meshInstances.indexOf(meshInstance);

			if (idx !== -1) this._model.meshInstances.splice(idx, 1);
		};

		_proto._setMaterial = function _setMaterial(material) {
			this._material = material;

			if (this._model) {
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					var mi = this._model.meshInstances[i];
					mi.material = material;
				}
			}
		};

		_proto._updateMaterial = function _updateMaterial(screenSpace) {
			var element = this._element;

			var screenCulled = element._isScreenCulled();

			var visibleFn = function visibleFn(camera) {
				return element.isVisibleForCamera(camera);
			};

			var msdf = this._font && this._font.type === FONT_MSDF;
			this._material = this._system.getTextElementMaterial(screenSpace, msdf);

			if (this._model) {
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					var mi = this._model.meshInstances[i];
					mi.cull = !screenSpace;
					mi.material = this._material;
					mi.screenSpace = screenSpace;

					if (screenCulled) {
						mi.cull = true;
						mi.isVisibleFunc = visibleFn;
					} else {
						mi.isVisibleFunc = null;
					}
				}
			}
		};

		_proto._isWordBoundary = function _isWordBoundary(char) {
			return WORD_BOUNDARY_CHAR.test(char);
		};

		_proto._isValidNextChar = function _isValidNextChar(nextchar) {
			return nextchar !== null && !NO_LINE_BREAK_CJK_CHAR.test(nextchar);
		};

		_proto._isNextCJKBoundary = function _isNextCJKBoundary(char, nextchar) {
			return CJK_CHAR.test(char) && (WORD_BOUNDARY_CHAR.test(nextchar) || ALPHANUMERIC_CHAR.test(nextchar));
		};

		_proto._isNextCJKWholeWord = function _isNextCJKWholeWord(nextchar) {
			return CJK_CHAR.test(nextchar);
		};

		_proto._updateMeshes = function _updateMeshes() {
			var json = this._font.data;
			var self = this;
			var minFont = Math.min(this._minFontSize, this._maxFontSize);
			var maxFont = this._maxFontSize;

			var autoFit = this._shouldAutoFit();

			if (autoFit) {
				this._fontSize = this._maxFontSize;
			}

			var MAGIC = 32;
			var l = this._symbols.length;
			var _x = 0;
			var _y = 0;
			var _z = 0;
			var _xMinusTrailingWhitespace = 0;
			var lines = 1;
			var wordStartX = 0;
			var wordStartIndex = 0;
			var lineStartIndex = 0;
			var numWordsThisLine = 0;
			var numCharsThisLine = 0;
			var numBreaksThisLine = 0;
			var splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;
			var maxLineWidth = this._element.calculatedWidth;

			if (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {
				maxLineWidth = Number.POSITIVE_INFINITY;
			}

			var fontMinY = 0;
			var fontMaxY = 0;
			var char, data, quad, nextchar;

			function breakLine(symbols, lineBreakIndex, lineBreakX) {
				self._lineWidths.push(Math.abs(lineBreakX));

				var sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;
				var sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;
				var chars = symbols.slice(sliceStart, sliceEnd);

				if (numBreaksThisLine) {
					var i = chars.length;

					while (i-- && numBreaksThisLine > 0) {
						if (LINE_BREAK_CHAR.test(chars[i])) {
							chars.splice(i, 1);
							numBreaksThisLine--;
						}
					}
				}

				self._lineContents.push(chars.join(''));

				_x = 0;
				_y -= self._scaledLineHeight;
				lines++;
				numWordsThisLine = 0;
				numCharsThisLine = 0;
				numBreaksThisLine = 0;
				wordStartX = 0;
				lineStartIndex = lineBreakIndex;
			}

			var retryUpdateMeshes = true;

			while (retryUpdateMeshes) {
				retryUpdateMeshes = false;

				if (autoFit) {
					this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);
				} else {
					this._scaledLineHeight = this._lineHeight;
				}

				this.width = 0;
				this.height = 0;
				this._lineWidths = [];
				this._lineContents = [];
				_x = 0;
				_y = 0;
				_z = 0;
				_xMinusTrailingWhitespace = 0;
				lines = 1;
				wordStartX = 0;
				wordStartIndex = 0;
				lineStartIndex = 0;
				numWordsThisLine = 0;
				numCharsThisLine = 0;
				numBreaksThisLine = 0;
				var scale = this._fontSize / MAGIC;
				fontMinY = this._fontMinY * scale;
				fontMaxY = this._fontMaxY * scale;

				for (var i = 0; i < this._meshInfo.length; i++) {
					this._meshInfo[i].quad = 0;
					this._meshInfo[i].lines = {};
				}

				var color_r = 255;
				var color_g = 255;
				var color_b = 255;

				for (var _i2 = 0; _i2 < l; _i2++) {
					char = this._symbols[_i2];
					nextchar = _i2 + 1 >= l ? null : this._symbols[_i2 + 1];
					var isLineBreak = LINE_BREAK_CHAR.test(char);

					if (isLineBreak) {
						numBreaksThisLine++;

						if (!this._wrapLines || this._maxLines < 0 || lines < this._maxLines) {
							breakLine(this._symbols, _i2, _xMinusTrailingWhitespace);
							wordStartIndex = _i2 + 1;
							lineStartIndex = _i2 + 1;
						}

						continue;
					}

					var x = 0;
					var y = 0;
					var advance = 0;
					var quadsize = 1;
					var dataScale = void 0,
							size = void 0;
					data = json.chars[char];

					if (!data) {
						if (CONTROL_CHARS.indexOf(char) !== -1) {
							data = CONTROL_GLYPH_DATA;
						} else {
							if (json.chars[' ']) {
								data = json.chars[' '];
							} else {
								for (var key in json.chars) {
									data = json.chars[key];
									break;
								}
							}

							if (!json.missingChars) {
								json.missingChars = new Set();
							}

							if (!json.missingChars.has(char)) {
								console.warn("Character '" + char + "' is missing from the font " + json.info.face);
								json.missingChars.add(char);
							}
						}
					}

					if (data) {
						var kerning = 0;

						if (numCharsThisLine > 0) {
							var kernTable = this._font.data.kerning;

							if (kernTable) {
								var kernLeft = kernTable[string.getCodePoint(this._symbols[_i2 - 1]) || 0];

								if (kernLeft) {
									kerning = kernLeft[string.getCodePoint(this._symbols[_i2]) || 0] || 0;
								}
							}
						}

						dataScale = data.scale || 1;
						size = (data.width + data.height) / 2;
						quadsize = scale * size / dataScale;
						advance = (data.xadvance + kerning) * scale;
						x = (data.xoffset - kerning) * scale;
						y = data.yoffset * scale;
					} else {
						console.error("Couldn't substitute missing character: '" + char + "'");
					}

					var isWhitespace = WHITESPACE_CHAR.test(char);
					var meshInfo = this._meshInfo[data && data.map || 0];
					var candidateLineWidth = _x + this._spacing * advance;

					if (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {
						if (this._maxLines < 0 || lines < this._maxLines) {
							if (numWordsThisLine === 0) {
								wordStartIndex = _i2;
								breakLine(this._symbols, _i2, _xMinusTrailingWhitespace);
							} else {
								var backtrack = Math.max(_i2 - wordStartIndex, 0);

								if (this._meshInfo.length <= 1) {
									meshInfo.lines[lines - 1] -= backtrack;
									meshInfo.quad -= backtrack;
								} else {
									var backtrackStart = wordStartIndex;
									var backtrackEnd = _i2;

									for (var j = backtrackStart; j < backtrackEnd; j++) {
										var backChar = this._symbols[j];
										var backCharData = json.chars[backChar];
										var backMeshInfo = this._meshInfo[backCharData && backCharData.map || 0];
										backMeshInfo.lines[lines - 1] -= 1;
										backMeshInfo.quad -= 1;
									}
								}

								_i2 -= backtrack + 1;
								breakLine(this._symbols, wordStartIndex, wordStartX);
								continue;
							}
						}
					}

					quad = meshInfo.quad;
					meshInfo.lines[lines - 1] = quad;
					var left = _x - x;
					var right = left + quadsize;
					var bottom = _y - y;
					var top = bottom + quadsize;

					if (this._rtl) {
						var shift = quadsize - x - this._spacing * advance - x;
						left -= shift;
						right -= shift;
					}

					meshInfo.positions[quad * 4 * 3 + 0] = left;
					meshInfo.positions[quad * 4 * 3 + 1] = bottom;
					meshInfo.positions[quad * 4 * 3 + 2] = _z;
					meshInfo.positions[quad * 4 * 3 + 3] = right;
					meshInfo.positions[quad * 4 * 3 + 4] = bottom;
					meshInfo.positions[quad * 4 * 3 + 5] = _z;
					meshInfo.positions[quad * 4 * 3 + 6] = right;
					meshInfo.positions[quad * 4 * 3 + 7] = top;
					meshInfo.positions[quad * 4 * 3 + 8] = _z;
					meshInfo.positions[quad * 4 * 3 + 9] = left;
					meshInfo.positions[quad * 4 * 3 + 10] = top;
					meshInfo.positions[quad * 4 * 3 + 11] = _z;
					this.width = Math.max(this.width, candidateLineWidth);
					var fontSize = void 0;

					if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {
						fontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));
						fontSize = math.clamp(fontSize, minFont, maxFont);

						if (fontSize !== this._element.fontSize) {
							this._fontSize = fontSize;
							retryUpdateMeshes = true;
							break;
						}
					}

					this.height = Math.max(this.height, fontMaxY - (_y + fontMinY));

					if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {
						fontSize = math.clamp(this._fontSize - 1, minFont, maxFont);

						if (fontSize !== this._element.fontSize) {
							this._fontSize = fontSize;
							retryUpdateMeshes = true;
							break;
						}
					}

					_x += this._spacing * advance;

					if (!isWhitespace) {
						_xMinusTrailingWhitespace = _x;
					}

					if (this._isWordBoundary(char) || this._isValidNextChar(nextchar) && (this._isNextCJKBoundary(char, nextchar) || this._isNextCJKWholeWord(nextchar))) {
						numWordsThisLine++;
						wordStartX = _xMinusTrailingWhitespace;
						wordStartIndex = _i2 + 1;
					}

					numCharsThisLine++;

					var uv = this._getUv(char);

					meshInfo.uvs[quad * 4 * 2 + 0] = uv[0];
					meshInfo.uvs[quad * 4 * 2 + 1] = 1.0 - uv[1];
					meshInfo.uvs[quad * 4 * 2 + 2] = uv[2];
					meshInfo.uvs[quad * 4 * 2 + 3] = 1.0 - uv[1];
					meshInfo.uvs[quad * 4 * 2 + 4] = uv[2];
					meshInfo.uvs[quad * 4 * 2 + 5] = 1.0 - uv[3];
					meshInfo.uvs[quad * 4 * 2 + 6] = uv[0];
					meshInfo.uvs[quad * 4 * 2 + 7] = 1.0 - uv[3];

					if (this._symbolColors) {
						var colorIdx = this._symbolColors[_i2] * 3;
						color_r = this._colorPalette[colorIdx];
						color_g = this._colorPalette[colorIdx + 1];
						color_b = this._colorPalette[colorIdx + 2];
					}

					meshInfo.colors[quad * 4 * 4 + 0] = color_r;
					meshInfo.colors[quad * 4 * 4 + 1] = color_g;
					meshInfo.colors[quad * 4 * 4 + 2] = color_b;
					meshInfo.colors[quad * 4 * 4 + 3] = 255;
					meshInfo.colors[quad * 4 * 4 + 4] = color_r;
					meshInfo.colors[quad * 4 * 4 + 5] = color_g;
					meshInfo.colors[quad * 4 * 4 + 6] = color_b;
					meshInfo.colors[quad * 4 * 4 + 7] = 255;
					meshInfo.colors[quad * 4 * 4 + 8] = color_r;
					meshInfo.colors[quad * 4 * 4 + 9] = color_g;
					meshInfo.colors[quad * 4 * 4 + 10] = color_b;
					meshInfo.colors[quad * 4 * 4 + 11] = 255;
					meshInfo.colors[quad * 4 * 4 + 12] = color_r;
					meshInfo.colors[quad * 4 * 4 + 13] = color_g;
					meshInfo.colors[quad * 4 * 4 + 14] = color_b;
					meshInfo.colors[quad * 4 * 4 + 15] = 255;
					meshInfo.quad++;
				}

				if (retryUpdateMeshes) {
					continue;
				}

				if (lineStartIndex < l) {
					breakLine(this._symbols, l, _x);
				}
			}

			this._noResize = true;
			this.autoWidth = this._autoWidth;
			this.autoHeight = this._autoHeight;
			this._noResize = false;
			var hp = this._element.pivot.x;
			var vp = this._element.pivot.y;
			var ha = this._alignment.x;
			var va = this._alignment.y;

			for (var _i3 = 0; _i3 < this._meshInfo.length; _i3++) {
				if (this._meshInfo[_i3].count === 0) continue;
				var prevQuad = 0;

				for (var line in this._meshInfo[_i3].lines) {
					var index = this._meshInfo[_i3].lines[line];

					var lw = this._lineWidths[parseInt(line, 10)];

					var hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);
					var voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);

					for (var _quad = prevQuad; _quad <= index; _quad++) {
						this._meshInfo[_i3].positions[_quad * 4 * 3] += hoffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 3] += hoffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 6] += hoffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 9] += hoffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 1] += voffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 4] += voffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 7] += voffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 10] += voffset;
					}

					if (this._rtl) {
						for (var _quad2 = prevQuad; _quad2 <= index; _quad2++) {
							var idx = _quad2 * 4 * 3;

							for (var vert = 0; vert < 4; ++vert) {
								this._meshInfo[_i3].positions[idx + vert * 3] = this._element.calculatedWidth - this._meshInfo[_i3].positions[idx + vert * 3] + hoffset * 2;
							}

							var tmp0 = this._meshInfo[_i3].positions[idx + 3];
							var tmp1 = this._meshInfo[_i3].positions[idx + 6];
							this._meshInfo[_i3].positions[idx + 3] = this._meshInfo[_i3].positions[idx + 0];
							this._meshInfo[_i3].positions[idx + 6] = this._meshInfo[_i3].positions[idx + 9];
							this._meshInfo[_i3].positions[idx + 0] = tmp0;
							this._meshInfo[_i3].positions[idx + 9] = tmp1;
						}
					}

					prevQuad = index + 1;
				}

				var numVertices = this._meshInfo[_i3].count * 4;
				var vertMax = this._meshInfo[_i3].quad * 4;
				var it = new VertexIterator(this._meshInfo[_i3].meshInstance.mesh.vertexBuffer);

				for (var v = 0; v < numVertices; v++) {
					if (v >= vertMax) {
						it.element[SEMANTIC_POSITION].set(0, 0, 0);
						it.element[SEMANTIC_TEXCOORD0].set(0, 0);
						it.element[SEMANTIC_COLOR].set(0, 0, 0, 0);
					} else {
						it.element[SEMANTIC_POSITION].set(this._meshInfo[_i3].positions[v * 3 + 0], this._meshInfo[_i3].positions[v * 3 + 1], this._meshInfo[_i3].positions[v * 3 + 2]);
						it.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[_i3].uvs[v * 2 + 0], this._meshInfo[_i3].uvs[v * 2 + 1]);
						it.element[SEMANTIC_COLOR].set(this._meshInfo[_i3].colors[v * 4 + 0], this._meshInfo[_i3].colors[v * 4 + 1], this._meshInfo[_i3].colors[v * 4 + 2], this._meshInfo[_i3].colors[v * 4 + 3]);
					}

					it.next();
				}

				it.end();

				this._meshInfo[_i3].meshInstance.mesh.aabb.compute(this._meshInfo[_i3].positions);

				this._meshInfo[_i3].meshInstance._aabbVer = -1;
			}

			this._aabbDirty = true;
		};

		_proto._onFontRender = function _onFontRender() {
			this.font = this._font;
		};

		_proto._onFontLoad = function _onFontLoad(asset) {
			if (this.font !== asset.resource) {
				this.font = asset.resource;
			}
		};

		_proto._onFontChange = function _onFontChange(asset, name, _new, _old) {
			if (name === 'data') {
				this._font.data = _new;
				var maps = this._font.data.info.maps.length;

				for (var i = 0; i < maps; i++) {
					if (!this._meshInfo[i]) continue;
					var mi = this._meshInfo[i].meshInstance;

					if (mi) {
						mi.setParameter("font_sdfIntensity", this._font.intensity);
						mi.setParameter("font_pxrange", this._getPxRange(this._font));
						mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
					}
				}
			}
		};

		_proto._onFontRemove = function _onFontRemove(asset) {};

		_proto._setTextureParams = function _setTextureParams(mi, texture) {
			if (this._font) {
				if (this._font.type === FONT_MSDF) {
					mi.deleteParameter("texture_emissiveMap");
					mi.deleteParameter("texture_opacityMap");
					mi.setParameter("texture_msdfMap", texture);
				} else if (this._font.type === FONT_BITMAP) {
					mi.deleteParameter("texture_msdfMap");
					mi.setParameter("texture_emissiveMap", texture);
					mi.setParameter("texture_opacityMap", texture);
				}
			}
		};

		_proto._getPxRange = function _getPxRange(font) {
			var keys = Object.keys(this._font.data.chars);

			for (var i = 0; i < keys.length; i++) {
				var char = this._font.data.chars[keys[i]];

				if (char.range) {
					return (char.scale || 1) * char.range;
				}
			}

			return 2;
		};

		_proto._getUv = function _getUv(char) {
			var data = this._font.data;

			if (!data.chars[char]) {
				var space = ' ';

				if (data.chars[space]) {
					return this._getUv(space);
				}

				return [0, 0, 0, 0];
			}

			var map = data.chars[char].map;
			var width = data.info.maps[map].width;
			var height = data.info.maps[map].height;
			var x = data.chars[char].x;
			var y = data.chars[char].y;
			var x1 = x;
			var y1 = y;
			var x2 = x + data.chars[char].width;
			var y2 = y - data.chars[char].height;
			var edge = 1 - data.chars[char].height / height;
			return [x1 / width, edge - y1 / height, x2 / width, edge - y2 / height];
		};

		_proto.onEnable = function onEnable() {
			this._fontAsset.autoLoad = true;

			if (this._model) {
				this._element.addModelToLayers(this._model);
			}
		};

		_proto.onDisable = function onDisable() {
			this._fontAsset.autoLoad = false;

			if (this._model) {
				this._element.removeModelFromLayers(this._model);
			}
		};

		_proto._setStencil = function _setStencil(stencilParams) {
			if (this._model) {
				var instances = this._model.meshInstances;

				for (var i = 0; i < instances.length; i++) {
					instances[i].stencilFront = stencilParams;
					instances[i].stencilBack = stencilParams;
				}
			}
		};

		_proto._shouldAutoFitWidth = function _shouldAutoFitWidth() {
			return this._autoFitWidth && !this._autoWidth;
		};

		_proto._shouldAutoFitHeight = function _shouldAutoFitHeight() {
			return this._autoFitHeight && !this._autoHeight;
		};

		_proto._shouldAutoFit = function _shouldAutoFit() {
			return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;
		};

		_proto._calculateCharsPerTexture = function _calculateCharsPerTexture(symbolIndex) {
			var charactersPerTexture = {};

			if (symbolIndex === undefined) {
				symbolIndex = this._symbols.length;
			}

			for (var i = 0, len = symbolIndex; i < len; i++) {
				var char = this._symbols[i];
				var info = this._font.data.chars[char];

				if (!info) {
					info = this._font.data.chars[' '];

					if (!info) {
						info = this._font.data.chars[Object.keys(this._font.data.chars)[0]];
					}
				}

				var map = info.map;

				if (!charactersPerTexture[map]) {
					charactersPerTexture[map] = 1;
				} else {
					charactersPerTexture[map]++;
				}
			}

			return charactersPerTexture;
		};

		_proto._updateRenderRange = function _updateRenderRange() {
			var startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);
			var endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);

			for (var i = 0, len = this._meshInfo.length; i < len; i++) {
				var start = startChars[i] || 0;
				var end = endChars[i] || 0;
				var instance = this._meshInfo[i].meshInstance;

				if (instance) {
					var mesh = instance.mesh;

					if (mesh) {
						mesh.primitive[0].base = start * 3 * 2;
						mesh.primitive[0].count = (end - start) * 3 * 2;
					}
				}
			}
		};

		_createClass(TextElement, [{
			key: "text",
			get: function get() {
				return this._text;
			},
			set: function set(value) {
				this._i18nKey = null;
				var str = value != null && value.toString() || "";

				this._setText(str);
			}
		}, {
			key: "key",
			get: function get() {
				return this._i18nKey;
			},
			set: function set(value) {
				var str = value !== null ? value.toString() : null;

				if (this._i18nKey === str) {
					return;
				}

				this._i18nKey = str;

				if (str) {
					this._fontAsset.disableLocalization = false;

					this._resetLocalizedText();
				} else {
					this._fontAsset.disableLocalization = true;
				}
			}
		}, {
			key: "color",
			get: function get() {
				return this._color;
			},
			set: function set(value) {
				var r = value.r;
				var g = value.g;
				var b = value.b;

				if (this._color === value) {
					console.warn("Setting element.color to itself will have no effect");
				}

				if (this._color.r !== r || this._color.g !== g || this._color.b !== b) {
					this._color.r = r;
					this._color.g = g;
					this._color.b = b;

					if (this._symbolColors) {
						if (this._font) {
							this._updateText();
						}
					} else {
						this._colorUniform[0] = this._color.r;
						this._colorUniform[1] = this._color.g;
						this._colorUniform[2] = this._color.b;

						for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
							var mi = this._model.meshInstances[i];
							mi.setParameter('material_emissive', this._colorUniform);
						}
					}
				}

				if (this._element) {
					this._element.fire('set:color', this._color);
				}
			}
		}, {
			key: "opacity",
			get: function get() {
				return this._color.a;
			},
			set: function set(value) {
				if (this._color.a !== value) {
					this._color.a = value;

					if (this._model) {
						for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
							var mi = this._model.meshInstances[i];
							mi.setParameter('material_opacity', value);
						}
					}
				}

				if (this._element) {
					this._element.fire('set:opacity', value);
				}
			}
		}, {
			key: "lineHeight",
			get: function get() {
				return this._lineHeight;
			},
			set: function set(value) {
				var _prev = this._lineHeight;
				this._lineHeight = value;
				this._scaledLineHeight = value;

				if (_prev !== value && this._font) {
					this._updateText();
				}
			}
		}, {
			key: "wrapLines",
			get: function get() {
				return this._wrapLines;
			},
			set: function set(value) {
				var _prev = this._wrapLines;
				this._wrapLines = value;

				if (_prev !== value && this._font) {
					this._updateText();
				}
			}
		}, {
			key: "lines",
			get: function get() {
				return this._lineContents;
			}
		}, {
			key: "spacing",
			get: function get() {
				return this._spacing;
			},
			set: function set(value) {
				var _prev = this._spacing;
				this._spacing = value;

				if (_prev !== value && this._font) {
					this._updateText();
				}
			}
		}, {
			key: "fontSize",
			get: function get() {
				return this._fontSize;
			},
			set: function set(value) {
				var _prev = this._fontSize;
				this._fontSize = value;
				this._originalFontSize = value;

				if (_prev !== value && this._font) {
					this._updateText();
				}
			}
		}, {
			key: "fontAsset",
			get: function get() {
				return this._fontAsset.localizedAsset;
			},
			set: function set(value) {
				this._fontAsset.defaultAsset = value;
			}
		}, {
			key: "font",
			get: function get() {
				return this._font;
			},
			set: function set(value) {
				var previousFontType;

				if (this._font) {
					previousFontType = this._font.type;
					if (this._font.off) this._font.off('render', this._onFontRender, this);
				}

				this._font = value;
				this._fontMinY = 0;
				this._fontMaxY = 0;
				if (!value) return;
				var json = this._font.data;

				for (var charId in json.chars) {
					var data = json.chars[charId];

					if (data.bounds) {
						this._fontMinY = Math.min(this._fontMinY, data.bounds[1]);
						this._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);
					}
				}

				if (this._font.on) this._font.on('render', this._onFontRender, this);

				if (this._fontAsset.localizedAsset) {
					var asset = this._system.app.assets.get(this._fontAsset.localizedAsset);

					if (asset.resource !== this._font) {
						this._fontAsset.defaultAsset = null;
					}
				}

				if (value.type !== previousFontType) {
					var screenSpace = this._element._isScreenSpace();

					this._updateMaterial(screenSpace);
				}

				for (var i = 0, len = this._font.textures.length; i < len; i++) {
					if (!this._meshInfo[i]) {
						this._meshInfo[i] = new MeshInfo();
					} else {
						var mi = this._meshInfo[i].meshInstance;

						if (mi) {
							mi.setParameter("font_sdfIntensity", this._font.intensity);
							mi.setParameter("font_pxrange", this._getPxRange(this._font));
							mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);

							this._setTextureParams(mi, this._font.textures[i]);
						}
					}
				}

				var removedModel = false;

				for (var _i4 = this._font.textures.length; _i4 < this._meshInfo.length; _i4++) {
					if (this._meshInfo[_i4].meshInstance) {
						if (!removedModel) {
							this._element.removeModelFromLayers(this._model);

							removedModel = true;
						}

						this._removeMeshInstance(this._meshInfo[_i4].meshInstance);
					}
				}

				if (this._meshInfo.length > this._font.textures.length) this._meshInfo.length = this._font.textures.length;

				this._updateText();
			}
		}, {
			key: "alignment",
			get: function get() {
				return this._alignment;
			},
			set: function set(value) {
				if (value instanceof Vec2) {
					this._alignment.set(value.x, value.y);
				} else {
					this._alignment.set(value[0], value[1]);
				}

				if (this._font) this._updateText();
			}
		}, {
			key: "autoWidth",
			get: function get() {
				return this._autoWidth;
			},
			set: function set(value) {
				var old = this._autoWidth;
				this._autoWidth = value;

				if (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {
					this._element.width = this.width;
				}

				if (old !== value) {
					var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

					if (newFontSize !== this._fontSize) {
						this._fontSize = newFontSize;

						if (this._font) {
							this._updateText();
						}
					}
				}
			}
		}, {
			key: "autoHeight",
			get: function get() {
				return this._autoHeight;
			},
			set: function set(value) {
				var old = this._autoHeight;
				this._autoHeight = value;

				if (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {
					this._element.height = this.height;
				}

				if (old !== value) {
					var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

					if (newFontSize !== this._fontSize) {
						this._fontSize = newFontSize;

						if (this._font) {
							this._updateText();
						}
					}
				}
			}
		}, {
			key: "rtlReorder",
			get: function get() {
				return this._rtlReorder;
			},
			set: function set(value) {
				if (this._rtlReorder !== value) {
					this._rtlReorder = value;

					if (this._font) {
						this._updateText();
					}
				}
			}
		}, {
			key: "unicodeConverter",
			get: function get() {
				return this._unicodeConverter;
			},
			set: function set(value) {
				if (this._unicodeConverter !== value) {
					this._unicodeConverter = value;

					this._setText(this._text);
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				if (this._aabbDirty) {
					var initialized = false;

					for (var i = 0; i < this._meshInfo.length; i++) {
						if (!this._meshInfo[i].meshInstance) continue;

						if (!initialized) {
							this._aabb.copy(this._meshInfo[i].meshInstance.aabb);

							initialized = true;
						} else {
							this._aabb.add(this._meshInfo[i].meshInstance.aabb);
						}
					}

					this._aabbDirty = false;
				}

				return this._aabb;
			}
		}, {
			key: "outlineColor",
			get: function get() {
				return this._outlineColor;
			},
			set: function set(value) {
				var r = value instanceof Color ? value.r : value[0];
				var g = value instanceof Color ? value.g : value[1];
				var b = value instanceof Color ? value.b : value[2];
				var a = value instanceof Color ? value.a : value[3];

				if (this._outlineColor === value) {
					console.warn("Setting element.outlineColor to itself will have no effect");
				}

				if (this._outlineColor.r === r && this._outlineColor.g === g && this._outlineColor.b === b && this._outlineColor.a === a) {
					return;
				}

				this._outlineColor.r = r;
				this._outlineColor.g = g;
				this._outlineColor.b = b;
				this._outlineColor.a = a;

				if (this._model) {
					this._outlineColorUniform[0] = this._outlineColor.r;
					this._outlineColorUniform[1] = this._outlineColor.g;
					this._outlineColorUniform[2] = this._outlineColor.b;
					this._outlineColorUniform[3] = this._outlineColor.a;

					for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
						var mi = this._model.meshInstances[i];
						mi.setParameter("outline_color", this._outlineColorUniform);
					}
				}
			}
		}, {
			key: "outlineThickness",
			get: function get() {
				return this._outlineThickness;
			},
			set: function set(value) {
				var _prev = this._outlineThickness;
				this._outlineThickness = value;

				if (_prev !== value && this._font) {
					if (this._model) {
						for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
							var mi = this._model.meshInstances[i];
							mi.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
						}
					}
				}
			}
		}, {
			key: "shadowColor",
			get: function get() {
				return this._shadowColor;
			},
			set: function set(value) {
				var r = value instanceof Color ? value.r : value[0];
				var g = value instanceof Color ? value.g : value[1];
				var b = value instanceof Color ? value.b : value[2];
				var a = value instanceof Color ? value.a : value[3];

				if (this._shadowColor === value) {
					Debug.warn("Setting element.shadowColor to itself will have no effect");
				}

				if (this._shadowColor.r === r && this._shadowColor.g === g && this._shadowColor.b === b && this._shadowColor.a === a) {
					return;
				}

				this._shadowColor.r = r;
				this._shadowColor.g = g;
				this._shadowColor.b = b;
				this._shadowColor.a = a;

				if (this._model) {
					this._shadowColorUniform[0] = this._shadowColor.r;
					this._shadowColorUniform[1] = this._shadowColor.g;
					this._shadowColorUniform[2] = this._shadowColor.b;
					this._shadowColorUniform[3] = this._shadowColor.a;

					for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
						var mi = this._model.meshInstances[i];
						mi.setParameter("shadow_color", this._shadowColorUniform);
					}
				}
			}
		}, {
			key: "shadowOffset",
			get: function get() {
				return this._shadowOffset;
			},
			set: function set(value) {
				var x = value instanceof Vec2 ? value.x : value[0],
						y = value instanceof Vec2 ? value.y : value[1];

				if (this._shadowOffset.x === x && this._shadowOffset.y === y) {
					return;
				}

				this._shadowOffset.set(x, y);

				if (this._font && this._model) {
					for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
						var ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
						this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
						this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
						var mi = this._model.meshInstances[i];
						mi.setParameter("shadow_offset", this._shadowOffsetUniform);
					}
				}
			}
		}, {
			key: "minFontSize",
			get: function get() {
				return this._minFontSize;
			},
			set: function set(value) {
				if (this._minFontSize === value) return;
				this._minFontSize = value;

				if (this.font && this._shouldAutoFit()) {
					this._updateText();
				}
			}
		}, {
			key: "maxFontSize",
			get: function get() {
				return this._maxFontSize;
			},
			set: function set(value) {
				if (this._maxFontSize === value) return;
				this._maxFontSize = value;

				if (this.font && this._shouldAutoFit()) {
					this._updateText();
				}
			}
		}, {
			key: "autoFitWidth",
			get: function get() {
				return this._autoFitWidth;
			},
			set: function set(value) {
				if (this._autoFitWidth === value) return;
				this._autoFitWidth = value;
				this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

				if (this.font) {
					this._updateText();
				}
			}
		}, {
			key: "autoFitHeight",
			get: function get() {
				return this._autoFitHeight;
			},
			set: function set(value) {
				if (this._autoFitHeight === value) return;
				this._autoFitHeight = value;
				this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

				if (this.font) {
					this._updateText();
				}
			}
		}, {
			key: "maxLines",
			get: function get() {
				return this._maxLines;
			},
			set: function set(value) {
				if (this._maxLines === value) return;
				if (value === null && this._maxLines === -1) return;
				this._maxLines = value === null ? -1 : value;

				if (this.font && this._wrapLines) {
					this._updateText();
				}
			}
		}, {
			key: "enableMarkup",
			get: function get() {
				return this._enableMarkup;
			},
			set: function set(value) {
				value = !!value;
				if (this._enableMarkup === value) return;
				this._enableMarkup = value;

				if (this.font) {
					this._updateText();
				}
			}
		}, {
			key: "symbols",
			get: function get() {
				return this._symbols;
			}
		}, {
			key: "symbolColors",
			get: function get() {
				if (this._symbolColors === null) {
					return null;
				}

				return this._symbolColors.map(function (c) {
					return this._colorPalette.slice(c * 3, c * 3 + 3);
				}, this);
			}
		}, {
			key: "rtl",
			get: function get() {
				return this._rtl;
			}
		}, {
			key: "rangeStart",
			get: function get() {
				return this._rangeStart;
			},
			set: function set(rangeStart) {
				rangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));

				if (rangeStart !== this._rangeStart) {
					this._rangeStart = rangeStart;

					this._updateRenderRange();
				}
			}
		}, {
			key: "rangeEnd",
			get: function get() {
				return this._rangeEnd;
			},
			set: function set(rangeEnd) {
				rangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));

				if (rangeEnd !== this._rangeEnd) {
					this._rangeEnd = rangeEnd;

					this._updateRenderRange();
				}
			}
		}]);

		return TextElement;
	}();

	var position = new Vec3();
	var invParentWtm = new Mat4();
	var vecA$1 = new Vec3();
	var vecB$1 = new Vec3();
	var matA = new Mat4();
	var matB = new Mat4();
	var matC = new Mat4();
	var matD = new Mat4();

	var ElementComponent = function (_Component) {
		_inheritsLoose(ElementComponent, _Component);

		function ElementComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._beingInitialized = false;
			_this._anchor = new Vec4();
			_this._localAnchor = new Vec4();
			_this._pivot = new Vec2();
			_this._width = _this._calculatedWidth = 32;
			_this._height = _this._calculatedHeight = 32;
			_this._margin = new Vec4(0, 0, -32, -32);
			_this._modelTransform = new Mat4();
			_this._screenToWorld = new Mat4();
			_this._anchorTransform = new Mat4();
			_this._anchorDirty = true;
			_this._parentWorldTransform = new Mat4();
			_this._screenTransform = new Mat4();
			_this._screenCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
			_this._canvasCorners = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
			_this._worldCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
			_this._cornersDirty = true;
			_this._canvasCornersDirty = true;
			_this._worldCornersDirty = true;

			_this.entity.on('insert', _this._onInsert, _assertThisInitialized(_this));

			_this._patch();

			_this.screen = null;
			_this._type = ELEMENTTYPE_GROUP;
			_this._image = null;
			_this._text = null;
			_this._group = null;
			_this._drawOrder = 0;
			_this._useInput = false;
			_this._layers = [LAYERID_UI];
			_this._addedModels = [];
			_this._batchGroupId = -1;
			_this._batchGroup = null;
			_this._offsetReadAt = 0;
			_this._maskOffset = 0.5;
			_this._maskedBy = null;
			return _this;
		}

		var _proto = ElementComponent.prototype;

		_proto._patch = function _patch() {
			this.entity._sync = this._sync;
			this.entity.setPosition = this._setPosition;
			this.entity.setLocalPosition = this._setLocalPosition;
		};

		_proto._unpatch = function _unpatch() {
			this.entity._sync = Entity.prototype._sync;
			this.entity.setPosition = Entity.prototype.setPosition;
			this.entity.setLocalPosition = Entity.prototype.setLocalPosition;
		};

		_proto._setPosition = function _setPosition(x, y, z) {
			if (!this.element.screen) return Entity.prototype.setPosition.call(this, x, y, z);

			if (x instanceof Vec3) {
				position.copy(x);
			} else {
				position.set(x, y, z);
			}

			this.getWorldTransform();
			invParentWtm.copy(this.element._screenToWorld).invert();
			invParentWtm.transformPoint(position, this.localPosition);
			if (!this._dirtyLocal) this._dirtifyLocal();
		};

		_proto._setLocalPosition = function _setLocalPosition(x, y, z) {
			if (x instanceof Vec3) {
				this.localPosition.copy(x);
			} else {
				this.localPosition.set(x, y, z);
			}

			var element = this.element;
			var p = this.localPosition;
			var pvt = element._pivot;
			element._margin.x = p.x - element._calculatedWidth * pvt.x;
			element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
			element._margin.y = p.y - element._calculatedHeight * pvt.y;
			element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
			if (!this._dirtyLocal) this._dirtifyLocal();
		};

		_proto._sync = function _sync() {
			var element = this.element;
			var screen = element.screen;

			if (screen) {
				if (element._anchorDirty) {
					var resx = 0;
					var resy = 0;
					var px = 0;
					var py = 1;

					if (this._parent && this._parent.element) {
						resx = this._parent.element.calculatedWidth;
						resy = this._parent.element.calculatedHeight;
						px = this._parent.element.pivot.x;
						py = this._parent.element.pivot.y;
					} else {
						var resolution = screen.screen.resolution;
						resx = resolution.x / screen.screen.scale;
						resy = resolution.y / screen.screen.scale;
					}

					element._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);

					element._anchorDirty = false;

					element._calculateLocalAnchors();
				}

				if (element._sizeDirty) {
					element._calculateSize(false, false);
				}
			}

			if (this._dirtyLocal) {
				this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
				var p = this.localPosition;
				var pvt = element._pivot;
				element._margin.x = p.x - element._calculatedWidth * pvt.x;
				element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
				element._margin.y = p.y - element._calculatedHeight * pvt.y;
				element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
				this._dirtyLocal = false;
			}

			if (!screen) {
				if (this._dirtyWorld) {
					element._cornersDirty = true;
					element._canvasCornersDirty = true;
					element._worldCornersDirty = true;
				}

				return Entity.prototype._sync.call(this);
			}

			if (this._dirtyWorld) {
				if (this._parent === null) {
					this.worldTransform.copy(this.localTransform);
				} else {
					if (this._parent.element) {
						element._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);
					} else {
						element._screenToWorld.copy(element._anchorTransform);
					}

					element._modelTransform.mul2(element._screenToWorld, this.localTransform);

					if (screen) {
						element._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);

						if (!screen.screen.screenSpace) {
							element._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);
						}

						this.worldTransform.mul2(element._screenToWorld, this.localTransform);
						var parentWorldTransform = element._parentWorldTransform;
						parentWorldTransform.setIdentity();
						var parent = this._parent;

						if (parent && parent.element && parent !== screen) {
							matA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());
							parentWorldTransform.mul2(parent.element._parentWorldTransform, matA);
						}

						var depthOffset = vecA$1;
						depthOffset.set(0, 0, this.localPosition.z);
						var pivotOffset = vecB$1;
						pivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);
						matA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);
						matB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());
						matC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);

						element._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);

						element._cornersDirty = true;
						element._canvasCornersDirty = true;
						element._worldCornersDirty = true;
					} else {
						this.worldTransform.copy(element._modelTransform);
					}
				}

				this._dirtyWorld = false;
			}
		};

		_proto._onInsert = function _onInsert(parent) {
			var result = this._parseUpToScreen();

			this.entity._dirtifyWorld();

			this._updateScreen(result.screen);

			this._dirtifyMask();
		};

		_proto._dirtifyMask = function _dirtifyMask() {
			var current = this.entity;

			while (current) {
				var next = current.parent;

				if ((next === null || next.screen) && current.element) {
					if (!this.system._prerender || !this.system._prerender.length) {
						this.system._prerender = [];
						this.system.app.once('prerender', this._onPrerender, this);
					}

					var i = this.system._prerender.indexOf(this.entity);

					if (i >= 0) {
						this.system._prerender.splice(i, 1);
					}

					var j = this.system._prerender.indexOf(current);

					if (j < 0) {
						this.system._prerender.push(current);
					}
				}

				current = next;
			}
		};

		_proto._onPrerender = function _onPrerender() {
			for (var i = 0; i < this.system._prerender.length; i++) {
				var mask = this.system._prerender[i];

				if (mask.element) {
					var depth = 1;
					mask.element.syncMask(depth);
				}
			}

			this.system._prerender.length = 0;
		};

		_proto._bindScreen = function _bindScreen(screen) {
			screen._bindElement(this);
		};

		_proto._unbindScreen = function _unbindScreen(screen) {
			screen._unbindElement(this);
		};

		_proto._updateScreen = function _updateScreen(screen) {
			if (this.screen && this.screen !== screen) {
				this._unbindScreen(this.screen.screen);
			}

			var previousScreen = this.screen;
			this.screen = screen;

			if (this.screen) {
				this._bindScreen(this.screen.screen);
			}

			this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);

			this.fire('set:screen', this.screen, previousScreen);
			this._anchorDirty = true;
			var children = this.entity.children;

			for (var i = 0, l = children.length; i < l; i++) {
				if (children[i].element) children[i].element._updateScreen(screen);
			}

			if (this.screen) this.screen.screen.syncDrawOrder();
		};

		_proto.syncMask = function syncMask(depth) {
			var result = this._parseUpToScreen();

			this._updateMask(result.mask, depth);
		};

		_proto._setMaskedBy = function _setMaskedBy(mask) {
			var renderableElement = this._image || this._text;

			if (mask) {
				var ref = mask.element._image._maskRef;
				var sp = new StencilParameters({
					ref: ref,
					func: FUNC_EQUAL
				});

				if (renderableElement && renderableElement._setStencil) {
					renderableElement._setStencil(sp);
				}

				this._maskedBy = mask;
			} else {

				if (renderableElement && renderableElement._setStencil) {
					renderableElement._setStencil(null);
				}

				this._maskedBy = null;
			}
		};

		_proto._updateMask = function _updateMask(currentMask, depth) {
			if (currentMask) {
				this._setMaskedBy(currentMask);

				if (this.mask) {
					var ref = currentMask.element._image._maskRef;
					var sp = new StencilParameters({
						ref: ref,
						func: FUNC_EQUAL,
						zpass: STENCILOP_INCREMENT
					});

					this._image._setStencil(sp);

					this._image._maskRef = depth;
					depth++;

					currentMask = this.entity;
				}

				var children = this.entity.children;

				for (var i = 0, l = children.length; i < l; i++) {
					if (children[i].element) {
						children[i].element._updateMask(currentMask, depth);
					}
				}

				if (this.mask) depth--;
			} else {
				this._setMaskedBy(null);

				if (this.mask) {
					var _sp = new StencilParameters({
						ref: depth,
						func: FUNC_ALWAYS,
						zpass: STENCILOP_REPLACE
					});

					this._image._setStencil(_sp);

					this._image._maskRef = depth;
					depth++;

					currentMask = this.entity;
				}

				var _children = this.entity.children;

				for (var _i = 0, _l = _children.length; _i < _l; _i++) {
					if (_children[_i].element) {
						_children[_i].element._updateMask(currentMask, depth);
					}
				}

				if (this.mask) depth--;
			}
		};

		_proto._parseUpToScreen = function _parseUpToScreen() {
			var result = {
				screen: null,
				mask: null
			};
			var parent = this.entity._parent;

			while (parent && !parent.screen) {
				if (parent.element && parent.element.mask) {
					if (!result.mask) result.mask = parent;
				}

				parent = parent.parent;
			}

			if (parent && parent.screen) result.screen = parent;
			return result;
		};

		_proto._onScreenResize = function _onScreenResize(res) {
			this._anchorDirty = true;
			this._cornersDirty = true;
			this._worldCornersDirty = true;

			this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);

			this.fire('screen:set:resolution', res);
		};

		_proto._onScreenSpaceChange = function _onScreenSpaceChange() {
			this.fire('screen:set:screenspace', this.screen.screen.screenSpace);
		};

		_proto._onScreenRemove = function _onScreenRemove() {
			if (this.screen) {
				if (this.screen._destroying) {
					this.screen = null;
				} else {
					this._updateScreen(null);
				}
			}
		};

		_proto._calculateLocalAnchors = function _calculateLocalAnchors() {
			var resx = 1000;
			var resy = 1000;
			var parent = this.entity._parent;

			if (parent && parent.element) {
				resx = parent.element.calculatedWidth;
				resy = parent.element.calculatedHeight;
			} else if (this.screen) {
				var res = this.screen.screen.resolution;
				var scale = this.screen.screen.scale;
				resx = res.x / scale;
				resy = res.y / scale;
			}

			this._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);
		};

		_proto.getOffsetPosition = function getOffsetPosition(x, y) {
			var p = this.entity.getLocalPosition().clone();
			p.x += x;
			p.y += y;

			this._screenToWorld.transformPoint(p, p);

			return p;
		};

		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addModelToLayers(this._image ? this._image._renderable.model : this._text._model);
			oldComp.off("add", this.onLayerAdded, this);
			oldComp.off("remove", this.onLayerRemoved, this);
			newComp.on("add", this.onLayerAdded, this);
			newComp.on("remove", this.onLayerRemoved, this);
		};

		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;

			if (this._image) {
				layer.addMeshInstances(this._image._renderable.model.meshInstances);
			} else if (this._text) {
				layer.addMeshInstances(this._text._model.meshInstances);
			}
		};

		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;

			if (this._image) {
				layer.removeMeshInstances(this._image._renderable.model.meshInstances);
			} else if (this._text) {
				layer.removeMeshInstances(this._text._model.meshInstances);
			}
		};

		_proto.onEnable = function onEnable() {
			if (this._image) this._image.onEnable();
			if (this._text) this._text.onEnable();
			if (this._group) this._group.onEnable();

			if (this.useInput && this.system.app.elementInput) {
				this.system.app.elementInput.addElement(this);
			}

			this.system.app.scene.on("set:layers", this.onLayersChanged, this);

			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.on("add", this.onLayerAdded, this);
				this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
			}

			if (this._batchGroupId >= 0) {
				this.system.app.batcher.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
			}

			this.fire("enableelement");
		};

		_proto.onDisable = function onDisable() {
			this.system.app.scene.off("set:layers", this.onLayersChanged, this);

			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.off("add", this.onLayerAdded, this);
				this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
			}

			if (this._image) this._image.onDisable();
			if (this._text) this._text.onDisable();
			if (this._group) this._group.onDisable();

			if (this.system.app.elementInput && this.useInput) {
				this.system.app.elementInput.removeElement(this);
			}

			if (this._batchGroupId >= 0) {
				this.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
			}

			this.fire("disableelement");
		};

		_proto.onRemove = function onRemove() {
			this.entity.off('insert', this._onInsert, this);

			this._unpatch();

			if (this._image) this._image.destroy();
			if (this._text) this._text.destroy();

			if (this.system.app.elementInput && this.useInput) {
				this.system.app.elementInput.removeElement(this);
			}

			if (this.screen && this.screen.screen) {
				this._unbindScreen(this.screen.screen);

				this.screen.screen.syncDrawOrder();
			}

			this.off();
		};

		_proto._calculateSize = function _calculateSize(propagateCalculatedWidth, propagateCalculatedHeight) {
			if (!this.entity._parent && !this.screen) return;

			this._calculateLocalAnchors();

			var newWidth = this._absRight - this._absLeft;
			var newHeight = this._absTop - this._absBottom;

			if (propagateCalculatedWidth) {
				this._setWidth(newWidth);
			} else {
				this._setCalculatedWidth(newWidth, false);
			}

			if (propagateCalculatedHeight) {
				this._setHeight(newHeight);
			} else {
				this._setCalculatedHeight(newHeight, false);
			}

			var p = this.entity.getLocalPosition();
			p.x = this._margin.x + this._calculatedWidth * this._pivot.x;
			p.y = this._margin.y + this._calculatedHeight * this._pivot.y;
			this.entity.setLocalPosition(p);
			this._sizeDirty = false;
		};

		_proto._setWidth = function _setWidth(w) {
			this._width = w;

			this._setCalculatedWidth(w, false);

			this.fire('set:width', this._width);
		};

		_proto._setHeight = function _setHeight(h) {
			this._height = h;

			this._setCalculatedHeight(h, false);

			this.fire('set:height', this._height);
		};

		_proto._setCalculatedWidth = function _setCalculatedWidth(value, updateMargins) {
			if (Math.abs(value - this._calculatedWidth) <= 1e-4) return;
			this._calculatedWidth = value;

			this.entity._dirtifyLocal();

			if (updateMargins) {
				var p = this.entity.getLocalPosition();
				var pvt = this._pivot;
				this._margin.x = p.x - this._calculatedWidth * pvt.x;
				this._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;
			}

			this._flagChildrenAsDirty();

			this.fire('set:calculatedWidth', this._calculatedWidth);
			this.fire('resize', this._calculatedWidth, this._calculatedHeight);
		};

		_proto._setCalculatedHeight = function _setCalculatedHeight(value, updateMargins) {
			if (Math.abs(value - this._calculatedHeight) <= 1e-4) return;
			this._calculatedHeight = value;

			this.entity._dirtifyLocal();

			if (updateMargins) {
				var p = this.entity.getLocalPosition();
				var pvt = this._pivot;
				this._margin.y = p.y - this._calculatedHeight * pvt.y;
				this._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;
			}

			this._flagChildrenAsDirty();

			this.fire('set:calculatedHeight', this._calculatedHeight);
			this.fire('resize', this._calculatedWidth, this._calculatedHeight);
		};

		_proto._flagChildrenAsDirty = function _flagChildrenAsDirty() {
			var c = this.entity._children;

			for (var i = 0, l = c.length; i < l; i++) {
				if (c[i].element) {
					c[i].element._anchorDirty = true;
					c[i].element._sizeDirty = true;
				}
			}
		};

		_proto.addModelToLayers = function addModelToLayers(model) {
			this._addedModels.push(model);

			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.addMeshInstances(model.meshInstances);
			}
		};

		_proto.removeModelFromLayers = function removeModelFromLayers(model) {
			var idx = this._addedModels.indexOf(model);

			if (idx >= 0) {
				this._addedModels.splice(idx, 1);
			}

			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances(model.meshInstances);
			}
		};

		_proto.getMaskOffset = function getMaskOffset() {
			var frame = this.system.app.frame;

			if (this._offsetReadAt !== frame) {
				this._maskOffset = 0.5;
				this._offsetReadAt = frame;
			}

			var mo = this._maskOffset;
			this._maskOffset -= 0.001;
			return mo;
		};

		_proto.isVisibleForCamera = function isVisibleForCamera(camera) {
			var clipL, clipR, clipT, clipB;

			if (this.maskedBy) {
				var corners = this.maskedBy.element.screenCorners;
				clipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));
				clipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));
				clipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));
				clipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));
			} else {
				var sw = this.system.app.graphicsDevice.width;
				var sh = this.system.app.graphicsDevice.height;
				var cameraWidth = camera._rect.z * sw;
				var cameraHeight = camera._rect.w * sh;
				clipL = camera._rect.x * sw;
				clipR = clipL + cameraWidth;
				clipT = (1 - camera._rect.y) * sh;
				clipB = clipT - cameraHeight;
			}

			var hitCorners = this.screenCorners;
			var left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));
			var right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));
			var bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));
			var top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));

			if (right < clipL || left > clipR || bottom > clipT || top < clipB) {
				return false;
			}

			return true;
		};

		_proto._isScreenSpace = function _isScreenSpace() {
			if (this.screen && this.screen.screen) {
				return this.screen.screen.screenSpace;
			}

			return false;
		};

		_proto._isScreenCulled = function _isScreenCulled() {
			if (this.screen && this.screen.screen) {
				return this.screen.screen.cull;
			}

			return false;
		};

		_createClass(ElementComponent, [{
			key: "_absLeft",
			get: function get() {
				return this._localAnchor.x + this._margin.x;
			}
		}, {
			key: "_absRight",
			get: function get() {
				return this._localAnchor.z - this._margin.z;
			}
		}, {
			key: "_absTop",
			get: function get() {
				return this._localAnchor.w - this._margin.w;
			}
		}, {
			key: "_absBottom",
			get: function get() {
				return this._localAnchor.y + this._margin.y;
			}
		}, {
			key: "_hasSplitAnchorsX",
			get: function get() {
				return Math.abs(this._anchor.x - this._anchor.z) > 0.001;
			}
		}, {
			key: "_hasSplitAnchorsY",
			get: function get() {
				return Math.abs(this._anchor.y - this._anchor.w) > 0.001;
			}
		}, {
			key: "aabb",
			get: function get() {
				if (this._image) return this._image.aabb;
				if (this._text) return this._text.aabb;
				return null;
			}
		}, {
			key: "anchor",
			get: function get() {
				return this._anchor;
			},
			set: function set(value) {
				if (value instanceof Vec4) {
					this._anchor.set(value.x, value.y, value.z, value.w);
				} else {
					this._anchor.set(value[0], value[1], value[2], value[3]);
				}

				if (!this.entity._parent && !this.screen) {
					this._calculateLocalAnchors();
				} else {
					this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
				}

				this._anchorDirty = true;
				if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
				this.fire('set:anchor', this._anchor);
			}
		}, {
			key: "batchGroupId",
			get: function get() {
				return this._batchGroupId;
			},
			set: function set(value) {
				if (this._batchGroupId === value) return;

				if (this.entity.enabled && this._batchGroupId >= 0) {
					this.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
				}

				if (this.entity.enabled && value >= 0) {
					this.system.app.batcher.insert(BatchGroup.ELEMENT, value, this.entity);
				}

				if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
					if (this._image && this._image._renderable.model) {
						this.addModelToLayers(this._image._renderable.model);
					} else if (this._text && this._text._model) {
						this.addModelToLayers(this._text._model);
					}
				}

				this._batchGroupId = value;
			}
		}, {
			key: "bottom",
			get: function get() {
				return this._margin.y;
			},
			set: function set(value) {
				this._margin.y = value;
				var p = this.entity.getLocalPosition();
				var wt = this._absTop;
				var wb = this._localAnchor.y + value;

				this._setHeight(wt - wb);

				p.y = value + this._calculatedHeight * this._pivot.y;
				this.entity.setLocalPosition(p);
			}
		}, {
			key: "calculatedWidth",
			get: function get() {
				return this._calculatedWidth;
			},
			set: function set(value) {
				this._setCalculatedWidth(value, true);
			}
		}, {
			key: "calculatedHeight",
			get: function get() {
				return this._calculatedHeight;
			},
			set: function set(value) {
				this._setCalculatedHeight(value, true);
			}
		}, {
			key: "canvasCorners",
			get: function get() {
				if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) return this._canvasCorners;
				var device = this.system.app.graphicsDevice;
				var screenCorners = this.screenCorners;
				var sx = device.canvas.clientWidth / device.width;
				var sy = device.canvas.clientHeight / device.height;

				for (var i = 0; i < 4; i++) {
					this._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);
				}

				this._canvasCornersDirty = false;
				return this._canvasCorners;
			}
		}, {
			key: "drawOrder",
			get: function get() {
				return this._drawOrder;
			},
			set: function set(value) {
				var priority = 0;

				if (this.screen) {
					priority = this.screen.screen.priority;
				}

				if (value > 0xFFFFFF) {
					Debug.warn("Element.drawOrder larger than max size of: " + 0xFFFFFF);
					value = 0xFFFFFF;
				}

				this._drawOrder = (priority << 24) + value;
				this.fire('set:draworder', this._drawOrder);
			}
		}, {
			key: "height",
			get: function get() {
				return this._height;
			},
			set: function set(value) {
				this._height = value;

				if (!this._hasSplitAnchorsY) {
					this._setCalculatedHeight(value, true);
				}

				this.fire('set:height', this._height);
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(value) {
				if (this._addedModels.length) {
					for (var i = 0; i < this._layers.length; i++) {
						var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

						if (layer) {
							for (var j = 0; j < this._addedModels.length; j++) {
								layer.removeMeshInstances(this._addedModels[j].meshInstances);
							}
						}
					}
				}

				this._layers = value;
				if (!this.enabled || !this.entity.enabled || !this._addedModels.length) return;

				for (var _i2 = 0; _i2 < this._layers.length; _i2++) {
					var _layer = this.system.app.scene.layers.getLayerById(this._layers[_i2]);

					if (_layer) {
						for (var _j = 0; _j < this._addedModels.length; _j++) {
							_layer.addMeshInstances(this._addedModels[_j].meshInstances);
						}
					}
				}
			}
		}, {
			key: "left",
			get: function get() {
				return this._margin.x;
			},
			set: function set(value) {
				this._margin.x = value;
				var p = this.entity.getLocalPosition();
				var wr = this._absRight;
				var wl = this._localAnchor.x + value;

				this._setWidth(wr - wl);

				p.x = value + this._calculatedWidth * this._pivot.x;
				this.entity.setLocalPosition(p);
			}
		}, {
			key: "margin",
			get: function get() {
				return this._margin;
			},
			set: function set(value) {
				this._margin.copy(value);

				this._calculateSize(true, true);

				this.fire('set:margin', this._margin);
			}
		}, {
			key: "maskedBy",
			get: function get() {
				return this._maskedBy;
			}
		}, {
			key: "pivot",
			get: function get() {
				return this._pivot;
			},
			set: function set(value) {
				var prevX = this._pivot.x;
				var prevY = this._pivot.y;

				if (value instanceof Vec2) {
					this._pivot.set(value.x, value.y);
				} else {
					this._pivot.set(value[0], value[1]);
				}

				var mx = this._margin.x + this._margin.z;
				var dx = this._pivot.x - prevX;
				this._margin.x += mx * dx;
				this._margin.z -= mx * dx;
				var my = this._margin.y + this._margin.w;
				var dy = this._pivot.y - prevY;
				this._margin.y += my * dy;
				this._margin.w -= my * dy;
				this._anchorDirty = true;
				this._cornersDirty = true;
				this._worldCornersDirty = true;

				this._calculateSize(false, false);

				this._flagChildrenAsDirty();

				this.fire('set:pivot', this._pivot);
			}
		}, {
			key: "right",
			get: function get() {
				return this._margin.z;
			},
			set: function set(value) {
				this._margin.z = value;
				var p = this.entity.getLocalPosition();
				var wl = this._absLeft;
				var wr = this._localAnchor.z - value;

				this._setWidth(wr - wl);

				p.x = this._localAnchor.z - this._localAnchor.x - value - this._calculatedWidth * (1 - this._pivot.x);
				this.entity.setLocalPosition(p);
			}
		}, {
			key: "screenCorners",
			get: function get() {
				if (!this._cornersDirty || !this.screen) return this._screenCorners;
				var parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];

				this._screenCorners[0].set(this._absLeft, this._absBottom, 0);

				this._screenCorners[1].set(this._absRight, this._absBottom, 0);

				this._screenCorners[2].set(this._absRight, this._absTop, 0);

				this._screenCorners[3].set(this._absLeft, this._absTop, 0);

				var screenSpace = this.screen.screen.screenSpace;

				for (var i = 0; i < 4; i++) {
					this._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);

					if (screenSpace) this._screenCorners[i].mulScalar(this.screen.screen.scale);

					if (parentBottomLeft) {
						this._screenCorners[i].add(parentBottomLeft);
					}
				}

				this._cornersDirty = false;
				this._canvasCornersDirty = true;
				this._worldCornersDirty = true;
				return this._screenCorners;
			}
		}, {
			key: "textWidth",
			get: function get() {
				return this._text ? this._text.width : 0;
			}
		}, {
			key: "textHeight",
			get: function get() {
				return this._text ? this._text.height : 0;
			}
		}, {
			key: "top",
			get: function get() {
				return this._margin.w;
			},
			set: function set(value) {
				this._margin.w = value;
				var p = this.entity.getLocalPosition();
				var wb = this._absBottom;
				var wt = this._localAnchor.w - value;

				this._setHeight(wt - wb);

				p.y = this._localAnchor.w - this._localAnchor.y - value - this._calculatedHeight * (1 - this._pivot.y);
				this.entity.setLocalPosition(p);
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (value !== this._type) {
					this._type = value;

					if (this._image) {
						this._image.destroy();

						this._image = null;
					}

					if (this._text) {
						this._text.destroy();

						this._text = null;
					}

					if (value === ELEMENTTYPE_IMAGE) {
						this._image = new ImageElement(this);
					} else if (value === ELEMENTTYPE_TEXT) {
						this._text = new TextElement(this);
					}
				}
			}
		}, {
			key: "useInput",
			get: function get() {
				return this._useInput;
			},
			set: function set(value) {
				if (this._useInput === value) return;
				this._useInput = value;

				if (this.system.app.elementInput) {
					if (value) {
						if (this.enabled && this.entity.enabled) {
							this.system.app.elementInput.addElement(this);
						}
					} else {
						this.system.app.elementInput.removeElement(this);
					}
				} else {
					if (this._useInput === true) {
						console.warn("Elements will not get any input events because this.system.app.elementInput is not created");
					}
				}

				this.fire('set:useInput', value);
			}
		}, {
			key: "width",
			get: function get() {
				return this._width;
			},
			set: function set(value) {
				this._width = value;

				if (!this._hasSplitAnchorsX) {
					this._setCalculatedWidth(value, true);
				}

				this.fire('set:width', this._width);
			}
		}, {
			key: "worldCorners",
			get: function get() {
				if (!this._worldCornersDirty) {
					return this._worldCorners;
				}

				if (this.screen) {
					var screenCorners = this.screenCorners;

					if (!this.screen.screen.screenSpace) {
						matA.copy(this.screen.screen._screenMatrix);
						matA.data[13] = -matA.data[13];
						matA.mul2(this.screen.getWorldTransform(), matA);

						for (var i = 0; i < 4; i++) {
							matA.transformPoint(screenCorners[i], this._worldCorners[i]);
						}
					}
				} else {
					var localPos = this.entity.getLocalPosition();
					matA.setTranslate(-localPos.x, -localPos.y, -localPos.z);
					matB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());
					matC.setTranslate(localPos.x, localPos.y, localPos.z);
					var entity = this.entity.parent ? this.entity.parent : this.entity;
					matD.copy(entity.getWorldTransform());
					matD.mul(matC).mul(matB).mul(matA);
					vecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
					matD.transformPoint(vecA$1, this._worldCorners[0]);
					vecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
					matD.transformPoint(vecA$1, this._worldCorners[1]);
					vecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
					matD.transformPoint(vecA$1, this._worldCorners[2]);
					vecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
					matD.transformPoint(vecA$1, this._worldCorners[3]);
				}

				this._worldCornersDirty = false;
				return this._worldCorners;
			}
		}]);

		return ElementComponent;
	}(Component);

	function _define(name) {
		Object.defineProperty(ElementComponent.prototype, name, {
			get: function get() {
				if (this._text) {
					return this._text[name];
				} else if (this._image) {
					return this._image[name];
				}

				return null;
			},
			set: function set(value) {
				if (this._text) {
					this._text[name] = value;
				} else if (this._image) {
					this._image[name] = value;
				}
			}
		});
	}

	_define("fontSize");

	_define("minFontSize");

	_define("maxFontSize");

	_define("maxLines");

	_define("autoFitWidth");

	_define("autoFitHeight");

	_define("color");

	_define("font");

	_define("fontAsset");

	_define("spacing");

	_define("lineHeight");

	_define("wrapLines");

	_define("lines");

	_define("alignment");

	_define("autoWidth");

	_define("autoHeight");

	_define("rtlReorder");

	_define("unicodeConverter");

	_define("text");

	_define("key");

	_define("texture");

	_define("textureAsset");

	_define("material");

	_define("materialAsset");

	_define("sprite");

	_define("spriteAsset");

	_define("spriteFrame");

	_define("pixelsPerUnit");

	_define("opacity");

	_define("rect");

	_define("mask");

	_define("outlineColor");

	_define("outlineThickness");

	_define("shadowColor");

	_define("shadowOffset");

	_define("enableMarkup");

	_define("rangeStart");

	_define("rangeEnd");

	var ElementComponentData = function ElementComponentData() {
		this.enabled = true;
	};

	var _schema$e = ['enabled'];

	var ElementComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ElementComponentSystem, _ComponentSystem);

		function ElementComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'element';
			_this.ComponentType = ElementComponent;
			_this.DataType = ElementComponentData;
			_this.schema = _schema$e;
			_this._unicodeConverter = null;
			_this._rtlReorder = null;
			_this._defaultTexture = new Texture(app.graphicsDevice, {
				width: 1,
				height: 1,
				format: PIXELFORMAT_R8_G8_B8_A8
			});
			_this._defaultTexture.name = 'element-system';

			var pixels = _this._defaultTexture.lock();

			var pixelData = new Uint8Array(4);
			pixelData[0] = 255.0;
			pixelData[1] = 255.0;
			pixelData[2] = 255.0;
			pixelData[3] = 255.0;
			pixels.set(pixelData);

			_this._defaultTexture.unlock();

			_this.defaultImageMaterial = null;
			_this.defaultImage9SlicedMaterial = null;
			_this.defaultImage9TiledMaterial = null;
			_this.defaultImageMaskMaterial = null;
			_this.defaultImage9SlicedMaskMaterial = null;
			_this.defaultImage9TiledMaskMaterial = null;
			_this.defaultScreenSpaceImageMaterial = null;
			_this.defaultScreenSpaceImage9SlicedMaterial = null;
			_this.defaultScreenSpaceImage9TiledMaterial = null;
			_this.defaultScreenSpaceImageMask9SlicedMaterial = null;
			_this.defaultScreenSpaceImageMask9TiledMaterial = null;
			_this.defaultScreenSpaceImageMaskMaterial = null;
			_this.defaultTextMaterial = null;
			_this.defaultBitmapTextMaterial = null;
			_this.defaultScreenSpaceTextMaterial = null;
			_this.defaultScreenSpaceBitmapTextMaterial = null;
			_this.defaultImageMaterials = [];

			_this.on('beforeremove', _this.onRemoveComponent, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = ElementComponentSystem.prototype;

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this._defaultTexture.destroy();
		};

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			component._beingInitialized = true;

			if (data.anchor !== undefined) {
				if (data.anchor instanceof Vec4) {
					component.anchor.copy(data.anchor);
				} else {
					component.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);
				}
			}

			if (data.pivot !== undefined) {
				if (data.pivot instanceof Vec2) {
					component.pivot.copy(data.pivot);
				} else {
					component.pivot.set(data.pivot[0], data.pivot[1]);
				}
			}

			var splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;
			var splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;
			var _marginChange = false;
			var color;

			if (data.margin !== undefined) {
				if (data.margin instanceof Vec4) {
					component.margin.copy(data.margin);
				} else {
					component._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);
				}

				_marginChange = true;
			}

			if (data.left !== undefined) {
				component._margin.x = data.left;
				_marginChange = true;
			}

			if (data.bottom !== undefined) {
				component._margin.y = data.bottom;
				_marginChange = true;
			}

			if (data.right !== undefined) {
				component._margin.z = data.right;
				_marginChange = true;
			}

			if (data.top !== undefined) {
				component._margin.w = data.top;
				_marginChange = true;
			}

			if (_marginChange) {
				component.margin = component._margin;
			}

			var shouldForceSetAnchor = false;

			if (data.width !== undefined && !splitHorAnchors) {
				component.width = data.width;
			} else if (splitHorAnchors) {
				shouldForceSetAnchor = true;
			}

			if (data.height !== undefined && !splitVerAnchors) {
				component.height = data.height;
			} else if (splitVerAnchors) {
				shouldForceSetAnchor = true;
			}

			if (shouldForceSetAnchor) {
				component.anchor = component.anchor;
			}

			if (data.enabled !== undefined) {
				component.enabled = data.enabled;
			}

			if (data.useInput !== undefined) {
				component.useInput = data.useInput;
			}

			component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;

			if (data.layers && Array.isArray(data.layers)) {
				component.layers = data.layers.slice(0);
			}

			if (data.type !== undefined) {
				component.type = data.type;
			}

			if (component.type === ELEMENTTYPE_IMAGE) {
				if (data.rect !== undefined) {
					component.rect = data.rect;
				}

				if (data.color !== undefined) {
					color = data.color;

					if (!(color instanceof Color)) {
						color = new Color(data.color[0], data.color[1], data.color[2]);
					}

					component.color = color;
				}

				if (data.opacity !== undefined) component.opacity = data.opacity;
				if (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;
				if (data.texture) component.texture = data.texture;
				if (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;
				if (data.sprite) component.sprite = data.sprite;
				if (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;
				if (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;
				if (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;
				if (data.material) component.material = data.material;

				if (data.mask !== undefined) {
					component.mask = data.mask;
				}
			} else if (component.type === ELEMENTTYPE_TEXT) {
				if (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;
				if (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;
				if (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;
				if (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;

				if (data.text !== null && data.text !== undefined) {
					component.text = data.text;
				} else if (data.key !== null && data.key !== undefined) {
					component.key = data.key;
				}

				if (data.color !== undefined) {
					color = data.color;

					if (!(color instanceof Color)) {
						color = new Color(color[0], color[1], color[2]);
					}

					component.color = color;
				}

				if (data.opacity !== undefined) {
					component.opacity = data.opacity;
				}

				if (data.spacing !== undefined) component.spacing = data.spacing;

				if (data.fontSize !== undefined) {
					component.fontSize = data.fontSize;
					if (!data.lineHeight) component.lineHeight = data.fontSize;
				}

				if (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;
				if (data.maxLines !== undefined) component.maxLines = data.maxLines;
				if (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;
				if (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;
				if (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;
				if (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;
				if (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;
				if (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;
				if (data.font !== undefined) component.font = data.font;
				if (data.alignment !== undefined) component.alignment = data.alignment;
				if (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;
				if (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;
				if (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;
				if (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;
				if (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;
			}

			var result = component._parseUpToScreen();

			if (result.screen) {
				component._updateScreen(result.screen);
			}

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);

			component._beingInitialized = false;

			if (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {
				component._image._updateMesh(component._image.mesh);
			}
		};

		_proto.onRemoveComponent = function onRemoveComponent(entity, component) {
			component.onRemove();
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var source = entity.element;
			var data = {
				enabled: source.enabled,
				width: source.width,
				height: source.height,
				anchor: source.anchor.clone(),
				pivot: source.pivot.clone(),
				margin: source.margin.clone(),
				alignment: source.alignment && source.alignment.clone() || source.alignment,
				autoWidth: source.autoWidth,
				autoHeight: source.autoHeight,
				type: source.type,
				rect: source.rect && source.rect.clone() || source.rect,
				rtlReorder: source.rtlReorder,
				unicodeConverter: source.unicodeConverter,
				materialAsset: source.materialAsset,
				material: source.material,
				color: source.color && source.color.clone() || source.color,
				opacity: source.opacity,
				textureAsset: source.textureAsset,
				texture: source.texture,
				spriteAsset: source.spriteAsset,
				sprite: source.sprite,
				spriteFrame: source.spriteFrame,
				pixelsPerUnit: source.pixelsPerUnit,
				spacing: source.spacing,
				lineHeight: source.lineHeight,
				wrapLines: source.wrapLines,
				layers: source.layers,
				fontSize: source.fontSize,
				minFontSize: source.minFontSize,
				maxFontSize: source.maxFontSize,
				autoFitWidth: source.autoFitWidth,
				autoFitHeight: source.autoFitHeight,
				maxLines: source.maxLines,
				fontAsset: source.fontAsset,
				font: source.font,
				useInput: source.useInput,
				batchGroupId: source.batchGroupId,
				mask: source.mask,
				outlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,
				outlineThickness: source.outlineThickness,
				shadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,
				shadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,
				enableMarkup: source.enableMarkup
			};

			if (source.key !== undefined && source.key !== null) {
				data.key = source.key;
			} else {
				data.text = source.text;
			}

			return this.addComponent(clone, data);
		};

		_proto.getTextElementMaterial = function getTextElementMaterial(screenSpace, msdf) {
			if (screenSpace) {
				if (msdf) {
					if (!this.defaultScreenSpaceTextMaterial) {
						this.defaultScreenSpaceTextMaterial = new StandardMaterial();
						this.defaultScreenSpaceTextMaterial.name = "defaultScreenSpaceTextMaterial";
						this.defaultScreenSpaceTextMaterial.msdfMap = this._defaultTexture;
						this.defaultScreenSpaceTextMaterial.useLighting = false;
						this.defaultScreenSpaceTextMaterial.useGammaTonemap = false;
						this.defaultScreenSpaceTextMaterial.useFog = false;
						this.defaultScreenSpaceTextMaterial.useSkybox = false;
						this.defaultScreenSpaceTextMaterial.diffuse.set(0, 0, 0);
						this.defaultScreenSpaceTextMaterial.emissive.set(1, 1, 1);
						this.defaultScreenSpaceTextMaterial.opacity = 0.5;
						this.defaultScreenSpaceTextMaterial.blendType = BLEND_PREMULTIPLIED;
						this.defaultScreenSpaceTextMaterial.depthWrite = false;
						this.defaultScreenSpaceTextMaterial.depthTest = false;
						this.defaultScreenSpaceTextMaterial.emissiveVertexColor = true;
						this.defaultScreenSpaceTextMaterial.update();
					}

					return this.defaultScreenSpaceTextMaterial;
				}

				if (!this.defaultScreenSpaceBitmapTextMaterial) {
					this.defaultScreenSpaceBitmapTextMaterial = new StandardMaterial();
					this.defaultScreenSpaceBitmapTextMaterial.name = "defaultScreenSpaceBitmapTextMaterial";
					this.defaultScreenSpaceBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5);
					this.defaultScreenSpaceBitmapTextMaterial.emissiveMap = this._defaultTexture;
					this.defaultScreenSpaceBitmapTextMaterial.emissiveTint = true;
					this.defaultScreenSpaceBitmapTextMaterial.opacity = 0.5;
					this.defaultScreenSpaceBitmapTextMaterial.opacityMap = this._defaultTexture;
					this.defaultScreenSpaceBitmapTextMaterial.opacityMapChannel = 'a';
					this.defaultScreenSpaceBitmapTextMaterial.useLighting = false;
					this.defaultScreenSpaceBitmapTextMaterial.useGammaTonemap = false;
					this.defaultScreenSpaceBitmapTextMaterial.useFog = false;
					this.defaultScreenSpaceBitmapTextMaterial.useSkybox = false;
					this.defaultScreenSpaceBitmapTextMaterial.diffuse.set(0, 0, 0);
					this.defaultScreenSpaceBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;
					this.defaultScreenSpaceBitmapTextMaterial.depthWrite = false;
					this.defaultScreenSpaceBitmapTextMaterial.depthTest = false;
					this.defaultScreenSpaceBitmapTextMaterial.emissiveVertexColor = true;
					this.defaultScreenSpaceBitmapTextMaterial.update();
				}

				return this.defaultScreenSpaceBitmapTextMaterial;
			}

			if (msdf) {
				if (!this.defaultTextMaterial) {
					this.defaultTextMaterial = new StandardMaterial();
					this.defaultTextMaterial.name = "defaultTextMaterial";
					this.defaultTextMaterial.msdfMap = this._defaultTexture;
					this.defaultTextMaterial.useLighting = false;
					this.defaultTextMaterial.useGammaTonemap = false;
					this.defaultTextMaterial.useFog = false;
					this.defaultTextMaterial.useSkybox = false;
					this.defaultTextMaterial.diffuse.set(0, 0, 0);
					this.defaultTextMaterial.emissive.set(1, 1, 1);
					this.defaultTextMaterial.opacity = 0.5;
					this.defaultTextMaterial.blendType = BLEND_PREMULTIPLIED;
					this.defaultTextMaterial.depthWrite = false;
					this.defaultTextMaterial.emissiveVertexColor = true;
					this.defaultTextMaterial.update();
				}

				return this.defaultTextMaterial;
			}

			if (!this.defaultBitmapTextMaterial) {
				this.defaultBitmapTextMaterial = new StandardMaterial();
				this.defaultBitmapTextMaterial.name = "defaultBitmapTextMaterial";
				this.defaultBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5);
				this.defaultBitmapTextMaterial.emissiveTint = true;
				this.defaultBitmapTextMaterial.emissiveMap = this._defaultTexture;
				this.defaultBitmapTextMaterial.opacity = 0.5;
				this.defaultBitmapTextMaterial.opacityMap = this._defaultTexture;
				this.defaultBitmapTextMaterial.opacityMapChannel = 'a';
				this.defaultBitmapTextMaterial.useLighting = false;
				this.defaultBitmapTextMaterial.useGammaTonemap = false;
				this.defaultBitmapTextMaterial.useFog = false;
				this.defaultBitmapTextMaterial.useSkybox = false;
				this.defaultBitmapTextMaterial.diffuse.set(0, 0, 0);
				this.defaultBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;
				this.defaultBitmapTextMaterial.depthWrite = false;
				this.defaultBitmapTextMaterial.emissiveVertexColor = true;
				this.defaultBitmapTextMaterial.update();
			}

			return this.defaultBitmapTextMaterial;
		};

		_proto._createBaseImageMaterial = function _createBaseImageMaterial() {
			var material = new StandardMaterial();
			material.diffuse.set(0, 0, 0);
			material.emissive.set(0.5, 0.5, 0.5);
			material.emissiveMap = this._defaultTexture;
			material.emissiveTint = true;
			material.opacityMap = this._defaultTexture;
			material.opacityMapChannel = "a";
			material.opacityTint = true;
			material.opacity = 0;
			material.useLighting = false;
			material.useGammaTonemap = false;
			material.useFog = false;
			material.useSkybox = false;
			material.blendType = BLEND_PREMULTIPLIED;
			material.depthWrite = false;
			return material;
		};

		_proto.getImageElementMaterial = function getImageElementMaterial(screenSpace, mask, nineSliced, nineSliceTiled) {
			if (screenSpace) {
				if (mask) {
					if (nineSliced) {
						if (!this.defaultScreenSpaceImageMask9SlicedMaterial) {
							this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImageMask9SlicedMaterial.name = "defaultScreenSpaceImageMask9SlicedMaterial";
							this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;
							this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);
						}

						return this.defaultScreenSpaceImageMask9SlicedMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultScreenSpaceImageMask9TiledMaterial) {
							this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();
							this.defaultScreenSpaceImageMask9TiledMaterial.name = "defaultScreenSpaceImageMask9TiledMaterial";
							this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;
							this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);
						}

						return this.defaultScreenSpaceImageMask9TiledMaterial;
					} else {
						if (!this.defaultScreenSpaceImageMaskMaterial) {
							this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImageMaskMaterial.name = "defaultScreenSpaceImageMaskMaterial";
							this.defaultScreenSpaceImageMaskMaterial.depthTest = false;
							this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;
							this.defaultScreenSpaceImageMaskMaterial.redWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.greenWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.blueWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);
						}

						return this.defaultScreenSpaceImageMaskMaterial;
					}
				} else {
					if (nineSliced) {
						if (!this.defaultScreenSpaceImage9SlicedMaterial) {
							this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImage9SlicedMaterial.name = "defaultScreenSpaceImage9SlicedMaterial";
							this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;
							this.defaultScreenSpaceImage9SlicedMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);
						}

						return this.defaultScreenSpaceImage9SlicedMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultScreenSpaceImage9TiledMaterial) {
							this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImage9TiledMaterial.name = "defaultScreenSpaceImage9TiledMaterial";
							this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultScreenSpaceImage9TiledMaterial.depthTest = false;
							this.defaultScreenSpaceImage9TiledMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);
						}

						return this.defaultScreenSpaceImage9TiledMaterial;
					} else {
						if (!this.defaultScreenSpaceImageMaterial) {
							this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImageMaterial.name = "defaultScreenSpaceImageMaterial";
							this.defaultScreenSpaceImageMaterial.depthTest = false;
							this.defaultScreenSpaceImageMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);
						}

						return this.defaultScreenSpaceImageMaterial;
					}
				}
			} else {
				if (mask) {
					if (nineSliced) {
						if (!this.defaultImage9SlicedMaskMaterial) {
							this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();
							this.defaultImage9SlicedMaskMaterial.name = "defaultImage9SlicedMaskMaterial";
							this.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultImage9SlicedMaskMaterial.alphaTest = 1;
							this.defaultImage9SlicedMaskMaterial.redWrite = false;
							this.defaultImage9SlicedMaskMaterial.greenWrite = false;
							this.defaultImage9SlicedMaskMaterial.blueWrite = false;
							this.defaultImage9SlicedMaskMaterial.alphaWrite = false;
							this.defaultImage9SlicedMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);
						}

						return this.defaultImage9SlicedMaskMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultImage9TiledMaskMaterial) {
							this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();
							this.defaultImage9TiledMaskMaterial.name = "defaultImage9TiledMaskMaterial";
							this.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultImage9TiledMaskMaterial.alphaTest = 1;
							this.defaultImage9TiledMaskMaterial.redWrite = false;
							this.defaultImage9TiledMaskMaterial.greenWrite = false;
							this.defaultImage9TiledMaskMaterial.blueWrite = false;
							this.defaultImage9TiledMaskMaterial.alphaWrite = false;
							this.defaultImage9TiledMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);
						}

						return this.defaultImage9TiledMaskMaterial;
					} else {
						if (!this.defaultImageMaskMaterial) {
							this.defaultImageMaskMaterial = this._createBaseImageMaterial();
							this.defaultImageMaskMaterial.name = "defaultImageMaskMaterial";
							this.defaultImageMaskMaterial.alphaTest = 1;
							this.defaultImageMaskMaterial.redWrite = false;
							this.defaultImageMaskMaterial.greenWrite = false;
							this.defaultImageMaskMaterial.blueWrite = false;
							this.defaultImageMaskMaterial.alphaWrite = false;
							this.defaultImageMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultImageMaskMaterial);
						}

						return this.defaultImageMaskMaterial;
					}
				} else {
					if (nineSliced) {
						if (!this.defaultImage9SlicedMaterial) {
							this.defaultImage9SlicedMaterial = this._createBaseImageMaterial();
							this.defaultImage9SlicedMaterial.name = "defaultImage9SlicedMaterial";
							this.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultImage9SlicedMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);
						}

						return this.defaultImage9SlicedMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultImage9TiledMaterial) {
							this.defaultImage9TiledMaterial = this._createBaseImageMaterial();
							this.defaultImage9TiledMaterial.name = "defaultImage9TiledMaterial";
							this.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultImage9TiledMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9TiledMaterial);
						}

						return this.defaultImage9TiledMaterial;
					} else {
						if (!this.defaultImageMaterial) {
							this.defaultImageMaterial = this._createBaseImageMaterial();
							this.defaultImageMaterial.name = "defaultImageMaterial";
							this.defaultImageMaterial.update();
							this.defaultImageMaterials.push(this.defaultImageMaterial);
						}

						return this.defaultImageMaterial;
					}
				}
			}
		};

		_proto.registerUnicodeConverter = function registerUnicodeConverter(func) {
			this._unicodeConverter = func;
		};

		_proto.registerRtlReorder = function registerRtlReorder(func) {
			this._rtlReorder = func;
		};

		_proto.getUnicodeConverter = function getUnicodeConverter() {
			return this._unicodeConverter;
		};

		_proto.getRtlReorder = function getRtlReorder() {
			return this._rtlReorder;
		};

		return ElementComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ElementComponent.prototype, _schema$e);

	var MOTION_FREE = 'free';
	var MOTION_LIMITED = 'limited';
	var MOTION_LOCKED = 'locked';

	var properties = ['angularDampingX', 'angularDampingY', 'angularDampingZ', 'angularEquilibriumX', 'angularEquilibriumY', 'angularEquilibriumZ', 'angularLimitsX', 'angularLimitsY', 'angularLimitsZ', 'angularMotionX', 'angularMotionY', 'angularMotionZ', 'angularSpringX', 'angularSpringY', 'angularSpringZ', 'angularStiffnessX', 'angularStiffnessY', 'angularStiffnessZ', 'breakForce', 'enableCollision', 'enabled', 'entityA', 'entityB', 'linearDampingX', 'linearDampingY', 'linearDampingZ', 'linearEquilibriumX', 'linearEquilibriumY', 'linearEquilibriumZ', 'linearLimitsX', 'linearLimitsY', 'linearLimitsZ', 'linearMotionX', 'linearMotionY', 'linearMotionZ', 'linearSpringX', 'linearSpringY', 'linearSpringZ', 'linearStiffnessX', 'linearStiffnessY', 'linearStiffnessZ'];

	var JointComponent = function (_Component) {
		_inheritsLoose(JointComponent, _Component);

		function JointComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			Debug.assert(typeof Ammo !== 'undefined', 'ERROR: Attempting to create a pc.JointComponent but Ammo.js is not loaded');
			_this._constraint = null;
			_this._entityA = null;
			_this._entityB = null;
			_this._breakForce = 3.4e+38;
			_this._enableCollision = true;
			_this._linearMotionX = MOTION_LOCKED;
			_this._linearLimitsX = new Vec2(0, 0);
			_this._linearSpringX = false;
			_this._linearStiffnessX = 0;
			_this._linearDampingX = 1;
			_this._linearEquilibriumX = 0;
			_this._linearMotionY = MOTION_LOCKED;
			_this._linearLimitsY = new Vec2(0, 0);
			_this._linearSpringY = false;
			_this._linearStiffnessY = 0;
			_this._linearDampingY = 1;
			_this._linearEquilibriumY = 0;
			_this._linearMotionZ = MOTION_LOCKED;
			_this._linearLimitsZ = new Vec2(0, 0);
			_this._linearSpringZ = false;
			_this._linearStiffnessZ = 0;
			_this._linearDampingZ = 1;
			_this._linearEquilibriumZ = 0;
			_this._angularMotionX = MOTION_LOCKED;
			_this._angularLimitsX = new Vec2(0, 0);
			_this._angularSpringX = false;
			_this._angularStiffnessX = 0;
			_this._angularDampingX = 1;
			_this._angularEquilibriumX = 0;
			_this._angularMotionY = MOTION_LOCKED;
			_this._angularLimitsY = new Vec2(0, 0);
			_this._angularSpringY = false;
			_this._angularStiffnessY = 0;
			_this._angularDampingY = 1;
			_this._angularEquilibriumY = 0;
			_this._angularMotionZ = MOTION_LOCKED;
			_this._angularLimitsZ = new Vec2(0, 0);
			_this._angularSpringZ = false;
			_this._angularEquilibriumZ = 0;
			_this._angularDampingZ = 1;
			_this._angularStiffnessZ = 0;

			_this.on('set_enabled', _this._onSetEnabled, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = JointComponent.prototype;

		_proto._convertTransform = function _convertTransform(pcTransform, ammoTransform) {
			var pos = pcTransform.getTranslation();
			var rot = new Quat();
			rot.setFromMat4(pcTransform);
			var ammoVec = new Ammo.btVector3(pos.x, pos.y, pos.z);
			var ammoQuat = new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w);
			ammoTransform.setOrigin(ammoVec);
			ammoTransform.setRotation(ammoQuat);
			Ammo.destroy(ammoVec);
			Ammo.destroy(ammoQuat);
		};

		_proto._updateAngularLimits = function _updateAngularLimits() {
			var constraint = this._constraint;

			if (constraint) {
				var lx, ly, lz, ux, uy, uz;

				if (this._angularMotionX === MOTION_LIMITED) {
					lx = this._angularLimitsX.x * math.DEG_TO_RAD;
					ux = this._angularLimitsX.y * math.DEG_TO_RAD;
				} else if (this._angularMotionX === MOTION_FREE) {
					lx = 1;
					ux = 0;
				} else {
					lx = ux = 0;
				}

				if (this._angularMotionY === MOTION_LIMITED) {
					ly = this._angularLimitsY.x * math.DEG_TO_RAD;
					uy = this._angularLimitsY.y * math.DEG_TO_RAD;
				} else if (this._angularMotionY === MOTION_FREE) {
					ly = 1;
					uy = 0;
				} else {
					ly = uy = 0;
				}

				if (this._angularMotionZ === MOTION_LIMITED) {
					lz = this._angularLimitsZ.x * math.DEG_TO_RAD;
					uz = this._angularLimitsZ.y * math.DEG_TO_RAD;
				} else if (this._angularMotionZ === MOTION_FREE) {
					lz = 1;
					uz = 0;
				} else {
					lz = uz = 0;
				}

				var limits = new Ammo.btVector3(lx, ly, lz);
				constraint.setAngularLowerLimit(limits);
				limits.setValue(ux, uy, uz);
				constraint.setAngularUpperLimit(limits);
				Ammo.destroy(limits);
			}
		};

		_proto._updateLinearLimits = function _updateLinearLimits() {
			var constraint = this._constraint;

			if (constraint) {
				var lx, ly, lz, ux, uy, uz;

				if (this._linearMotionX === MOTION_LIMITED) {
					lx = this._linearLimitsX.x;
					ux = this._linearLimitsX.y;
				} else if (this._linearMotionX === MOTION_FREE) {
					lx = 1;
					ux = 0;
				} else {
					lx = ux = 0;
				}

				if (this._linearMotionY === MOTION_LIMITED) {
					ly = this._linearLimitsY.x;
					uy = this._linearLimitsY.y;
				} else if (this._linearMotionY === MOTION_FREE) {
					ly = 1;
					uy = 0;
				} else {
					ly = uy = 0;
				}

				if (this._linearMotionZ === MOTION_LIMITED) {
					lz = this._linearLimitsZ.x;
					uz = this._linearLimitsZ.y;
				} else if (this._linearMotionZ === MOTION_FREE) {
					lz = 1;
					uz = 0;
				} else {
					lz = uz = 0;
				}

				var limits = new Ammo.btVector3(lx, ly, lz);
				constraint.setLinearLowerLimit(limits);
				limits.setValue(ux, uy, uz);
				constraint.setLinearUpperLimit(limits);
				Ammo.destroy(limits);
			}
		};

		_proto._createConstraint = function _createConstraint() {
			if (this._entityA && this._entityA.rigidbody) {
				this._destroyConstraint();

				var mat = new Mat4();
				var bodyA = this._entityA.rigidbody.body;
				bodyA.activate();
				var jointWtm = this.entity.getWorldTransform();

				var entityAWtm = this._entityA.getWorldTransform();

				var invEntityAWtm = entityAWtm.clone().invert();
				mat.mul2(invEntityAWtm, jointWtm);
				var frameA = new Ammo.btTransform();

				this._convertTransform(mat, frameA);

				if (this._entityB && this._entityB.rigidbody) {
					var bodyB = this._entityB.rigidbody.body;
					bodyB.activate();

					var entityBWtm = this._entityB.getWorldTransform();

					var invEntityBWtm = entityBWtm.clone().invert();
					mat.mul2(invEntityBWtm, jointWtm);
					var frameB = new Ammo.btTransform();

					this._convertTransform(mat, frameB);

					this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, bodyB, frameA, frameB, !this._enableCollision);
					Ammo.destroy(frameB);
				} else {
					this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, frameA, !this._enableCollision);
				}

				Ammo.destroy(frameA);
				var axis = ['X', 'Y', 'Z', 'X', 'Y', 'Z'];

				for (var i = 0; i < 6; i++) {
					var type = i < 3 ? '_linear' : '_angular';

					this._constraint.enableSpring(i, this[type + 'Spring' + axis[i]]);

					this._constraint.setDamping(i, this[type + 'Damping' + axis[i]]);

					this._constraint.setEquilibriumPoint(i, this[type + 'Equilibrium' + axis[i]]);

					this._constraint.setStiffness(i, this[type + 'Stiffness' + axis[i]]);
				}

				this._constraint.setBreakingImpulseThreshold(this._breakForce);

				this._updateLinearLimits();

				this._updateAngularLimits();

				var app = this.system.app;
				var dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
				dynamicsWorld.addConstraint(this._constraint, !this._enableCollision);
			}
		};

		_proto._destroyConstraint = function _destroyConstraint() {
			if (this._constraint) {
				var app = this.system.app;
				var dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
				dynamicsWorld.removeConstraint(this._constraint);
				Ammo.destroy(this._constraint);
				this._constraint = null;
			}
		};

		_proto.initFromData = function initFromData(data) {
			for (var _iterator = _createForOfIteratorHelperLoose(properties), _step; !(_step = _iterator()).done;) {
				var prop = _step.value;

				if (data.hasOwnProperty(prop)) {
					if (data[prop] instanceof Vec2) {
						this['_' + prop].copy(data[prop]);
					} else {
						this['_' + prop] = data[prop];
					}
				}
			}

			this._createConstraint();
		};

		_proto.onEnable = function onEnable() {
			this._createConstraint();
		};

		_proto.onDisable = function onDisable() {
			this._destroyConstraint();
		};

		_proto._onSetEnabled = function _onSetEnabled(prop, old, value) {};

		_proto._onBeforeRemove = function _onBeforeRemove() {
			this.fire('remove');
		};

		_createClass(JointComponent, [{
			key: "entityA",
			get: function get() {
				return this._entityA;
			},
			set: function set(body) {
				this._destroyConstraint();

				this._entityA = body;

				this._createConstraint();
			}
		}, {
			key: "entityB",
			get: function get() {
				return this._entityB;
			},
			set: function set(body) {
				this._destroyConstraint();

				this._entityB = body;

				this._createConstraint();
			}
		}, {
			key: "breakForce",
			get: function get() {
				return this._breakForce;
			},
			set: function set(force) {
				if (this._constraint && this._breakForce !== force) {
					this._constraint.setBreakingImpulseThreshold(force);

					this._breakForce = force;
				}
			}
		}, {
			key: "enableCollision",
			get: function get() {
				return this._enableCollision;
			},
			set: function set(enableCollision) {
				this._destroyConstraint();

				this._enableCollision = enableCollision;

				this._createConstraint();
			}
		}, {
			key: "angularLimitsX",
			get: function get() {
				return this._angularLimitsX;
			},
			set: function set(limits) {
				if (!this._angularLimitsX.equals(limits)) {
					this._angularLimitsX.copy(limits);

					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularMotionX",
			get: function get() {
				return this._angularMotionX;
			},
			set: function set(value) {
				if (this._angularMotionX !== value) {
					this._angularMotionX = value;

					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularLimitsY",
			get: function get() {
				return this._angularLimitsY;
			},
			set: function set(limits) {
				if (!this._angularLimitsY.equals(limits)) {
					this._angularLimitsY.copy(limits);

					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularMotionY",
			get: function get() {
				return this._angularMotionY;
			},
			set: function set(value) {
				if (this._angularMotionY !== value) {
					this._angularMotionY = value;

					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularLimitsZ",
			get: function get() {
				return this._angularLimitsZ;
			},
			set: function set(limits) {
				if (!this._angularLimitsZ.equals(limits)) {
					this._angularLimitsZ.copy(limits);

					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularMotionZ",
			get: function get() {
				return this._angularMotionZ;
			},
			set: function set(value) {
				if (this._angularMotionZ !== value) {
					this._angularMotionZ = value;

					this._updateAngularLimits();
				}
			}
		}, {
			key: "linearLimitsX",
			get: function get() {
				return this._linearLimitsX;
			},
			set: function set(limits) {
				if (!this._linearLimitsX.equals(limits)) {
					this._linearLimitsX.copy(limits);

					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearMotionX",
			get: function get() {
				return this._linearMotionX;
			},
			set: function set(value) {
				if (this._linearMotionX !== value) {
					this._linearMotionX = value;

					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearLimitsY",
			get: function get() {
				return this._linearLimitsY;
			},
			set: function set(limits) {
				if (!this._linearLimitsY.equals(limits)) {
					this._linearLimitsY.copy(limits);

					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearMotionY",
			get: function get() {
				return this._linearMotionY;
			},
			set: function set(value) {
				if (this._linearMotionY !== value) {
					this._linearMotionY = value;

					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearLimitsZ",
			get: function get() {
				return this._linearLimitsZ;
			},
			set: function set(limits) {
				if (!this._linearLimitsZ.equals(limits)) {
					this._linearLimitsZ.copy(limits);

					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearMotionZ",
			get: function get() {
				return this._linearMotionZ;
			},
			set: function set(value) {
				if (this._linearMotionZ !== value) {
					this._linearMotionZ = value;

					this._updateLinearLimits();
				}
			}
		}]);

		return JointComponent;
	}(Component);

	var functionMap = {
		Damping: 'setDamping',
		Equilibrium: 'setEquilibriumPoint',
		Spring: 'enableSpring',
		Stiffness: 'setStiffness'
	};
	['linear', 'angular'].forEach(function (type) {
		['Damping', 'Equilibrium', 'Spring', 'Stiffness'].forEach(function (name) {
			['X', 'Y', 'Z'].forEach(function (axis) {
				var prop = type + name + axis;
				var propInternal = '_' + prop;
				var index = type === 'linear' ? 0 : 3;
				if (axis === 'Y') index += 1;
				if (axis === 'Z') index += 2;
				Object.defineProperty(JointComponent.prototype, prop, {
					get: function get() {
						return this[propInternal];
					},
					set: function set(value) {
						if (this[propInternal] !== value) {
							this[propInternal] = value;

							this._constraint[functionMap[name]](index, value);
						}
					}
				});
			});
		});
	});

	var JointComponentData = function JointComponentData() {
		this.enabled = true;
	};

	var _schema$d = ['enabled'];

	var JointComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(JointComponentSystem, _ComponentSystem);

		function JointComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'joint';
			_this.app = app;
			_this.ComponentType = JointComponent;
			_this.DataType = JointComponentData;
			_this.schema = _schema$d;
			return _this;
		}

		var _proto = JointComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			component.initFromData(data);
		};

		return JointComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(JointComponent.prototype, _schema$d);

	var LayoutChildComponent = function (_Component) {
		_inheritsLoose(LayoutChildComponent, _Component);

		function LayoutChildComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._minWidth = 0;
			_this._minHeight = 0;
			_this._maxWidth = null;
			_this._maxHeight = null;
			_this._fitWidthProportion = 0;
			_this._fitHeightProportion = 0;
			_this._excludeFromLayout = false;
			return _this;
		}

		_createClass(LayoutChildComponent, [{
			key: "minWidth",
			get: function get() {
				return this._minWidth;
			},
			set: function set(value) {
				if (value !== this._minWidth) {
					this._minWidth = value;
					this.fire('resize');
				}
			}
		}, {
			key: "minHeight",
			get: function get() {
				return this._minHeight;
			},
			set: function set(value) {
				if (value !== this._minHeight) {
					this._minHeight = value;
					this.fire('resize');
				}
			}
		}, {
			key: "maxWidth",
			get: function get() {
				return this._maxWidth;
			},
			set: function set(value) {
				if (value !== this._maxWidth) {
					this._maxWidth = value;
					this.fire('resize');
				}
			}
		}, {
			key: "maxHeight",
			get: function get() {
				return this._maxHeight;
			},
			set: function set(value) {
				if (value !== this._maxHeight) {
					this._maxHeight = value;
					this.fire('resize');
				}
			}
		}, {
			key: "fitWidthProportion",
			get: function get() {
				return this._fitWidthProportion;
			},
			set: function set(value) {
				if (value !== this._fitWidthProportion) {
					this._fitWidthProportion = value;
					this.fire('resize');
				}
			}
		}, {
			key: "fitHeightProportion",
			get: function get() {
				return this._fitHeightProportion;
			},
			set: function set(value) {
				if (value !== this._fitHeightProportion) {
					this._fitHeightProportion = value;
					this.fire('resize');
				}
			}
		}, {
			key: "excludeFromLayout",
			get: function get() {
				return this._excludeFromLayout;
			},
			set: function set(value) {
				if (value !== this._excludeFromLayout) {
					this._excludeFromLayout = value;
					this.fire('resize');
				}
			}
		}]);

		return LayoutChildComponent;
	}(Component);

	var LayoutChildComponentData = function LayoutChildComponentData() {
		this.enabled = true;
	};

	var _schema$c = ['enabled'];

	var LayoutChildComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(LayoutChildComponentSystem, _ComponentSystem);

		function LayoutChildComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'layoutchild';
			_this.ComponentType = LayoutChildComponent;
			_this.DataType = LayoutChildComponentData;
			_this.schema = _schema$c;
			return _this;
		}

		var _proto = LayoutChildComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.enabled !== undefined) component.enabled = data.enabled;
			if (data.minWidth !== undefined) component.minWidth = data.minWidth;
			if (data.minHeight !== undefined) component.minHeight = data.minHeight;
			if (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;
			if (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;
			if (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;
			if (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;
			if (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var layoutChild = entity.layoutchild;
			return this.addComponent(clone, {
				enabled: layoutChild.enabled,
				minWidth: layoutChild.minWidth,
				minHeight: layoutChild.minHeight,
				maxWidth: layoutChild.maxWidth,
				maxHeight: layoutChild.maxHeight,
				fitWidthProportion: layoutChild.fitWidthProportion,
				fitHeightProportion: layoutChild.fitHeightProportion,
				excludeFromLayout: layoutChild.excludeFromLayout
			});
		};

		return LayoutChildComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(LayoutChildComponent.prototype, _schema$c);

	var FITTING_NONE = 0;
	var FITTING_STRETCH = 1;
	var FITTING_SHRINK = 2;
	var FITTING_BOTH = 3;

	var AXIS_MAPPINGS = {};
	AXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {
		axis: 'x',
		size: 'width',
		calculatedSize: 'calculatedWidth',
		minSize: 'minWidth',
		maxSize: 'maxWidth',
		fitting: 'widthFitting',
		fittingProportion: 'fitWidthProportion'
	};
	AXIS_MAPPINGS[ORIENTATION_VERTICAL] = {
		axis: 'y',
		size: 'height',
		calculatedSize: 'calculatedHeight',
		minSize: 'minHeight',
		maxSize: 'maxHeight',
		fitting: 'heightFitting',
		fittingProportion: 'fitHeightProportion'
	};
	var OPPOSITE_ORIENTATION = {};
	OPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;
	OPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;
	var PROPERTY_DEFAULTS = {
		minWidth: 0,
		minHeight: 0,
		maxWidth: Number.POSITIVE_INFINITY,
		maxHeight: Number.POSITIVE_INFINITY,
		width: null,
		height: null,
		fitWidthProportion: 0,
		fitHeightProportion: 0
	};
	var FITTING_ACTION = {
		NONE: 'NONE',
		APPLY_STRETCHING: 'APPLY_STRETCHING',
		APPLY_SHRINKING: 'APPLY_SHRINKING'
	};
	var availableSpace = new Vec2();

	function createCalculator(orientation) {
		var options;
		var a = AXIS_MAPPINGS[orientation];
		var b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];

		function minExtentA(element, size) {
			return -size[a.size] * element.pivot[a.axis];
		}

		function minExtentB(element, size) {
			return -size[b.size] * element.pivot[b.axis];
		}

		function maxExtentA(element, size) {
			return size[a.size] * (1 - element.pivot[a.axis]);
		}

		function calculateAll(allElements, layoutOptions) {
			allElements = allElements.filter(shouldIncludeInLayout);
			options = layoutOptions;
			availableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;
			availableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;
			resetAnchors(allElements);
			var lines = reverseLinesIfRequired(splitLines(allElements));
			var sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));
			var positions = calculateBasePositions(lines, sizes);
			applyAlignmentAndPadding(lines, sizes, positions);
			applySizesAndPositions(lines, sizes, positions);
			return createLayoutInfo(lines);
		}

		function shouldIncludeInLayout(element) {
			var layoutChildComponent = element.entity.layoutchild;
			return !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;
		}

		function resetAnchors(allElements) {
			for (var i = 0; i < allElements.length; ++i) {
				var element = allElements[i];
				var anchor = element.anchor;

				if (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {
					element.anchor = Vec4.ZERO;
				}
			}
		}

		function splitLines(allElements) {
			if (!options.wrap) {
				return [allElements];
			}

			var lines = [[]];
			var sizes = getElementSizeProperties(allElements);
			var runningSize = 0;
			var allowOverrun = options[a.fitting] === FITTING_SHRINK;

			for (var i = 0; i < allElements.length; ++i) {
				if (lines[lines.length - 1].length > 0) {
					runningSize += options.spacing[a.axis];
				}

				var idealElementSize = sizes[i][a.size];
				runningSize += idealElementSize;

				if (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {
					runningSize = idealElementSize;
					lines.push([]);
				}

				lines[lines.length - 1].push(allElements[i]);

				if (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {
					runningSize = 0;
					lines.push([]);
				}
			}

			return lines;
		}

		function reverseLinesIfRequired(lines) {
			var reverseAxisA = options.orientation === ORIENTATION_HORIZONTAL && options.reverseX || options.orientation === ORIENTATION_VERTICAL && options.reverseY;
			var reverseAxisB = options.orientation === ORIENTATION_HORIZONTAL && options.reverseY || options.orientation === ORIENTATION_VERTICAL && options.reverseX;

			if (reverseAxisA) {
				for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
					if (reverseAxisA) {
						lines[lineIndex].reverse();
					}
				}
			}

			if (reverseAxisB) {
				lines.reverse();
			}

			return lines;
		}

		function calculateSizesOnAxisA(lines) {
			var sizesAllLines = [];

			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				var sizesThisLine = getElementSizeProperties(line);
				var idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);
				var fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);

				if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
					stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
				} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
					shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
				}

				sizesAllLines.push(sizesThisLine);
			}

			return sizesAllLines;
		}

		function calculateSizesOnAxisB(lines, sizesAllLines) {
			var largestElementsForEachLine = [];
			var largestSizesForEachLine = [];

			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				line.largestElement = null;
				line.largestSize = {
					width: Number.NEGATIVE_INFINITY,
					height: Number.NEGATIVE_INFINITY
				};

				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var sizesThisElement = sizesAllLines[lineIndex][elementIndex];

					if (sizesThisElement[b.size] > line.largestSize[b.size]) {
						line.largestElement = line[elementIndex];
						line.largestSize = sizesThisElement;
					}
				}

				largestElementsForEachLine.push(line.largestElement);
				largestSizesForEachLine.push(line.largestSize);
			}

			var idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);
			var fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);

			if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
				stretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
			} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
				shrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
			}

			for (var _lineIndex = 0; _lineIndex < lines.length; ++_lineIndex) {
				var _line = lines[_lineIndex];

				for (var _elementIndex = 0; _elementIndex < _line.length; ++_elementIndex) {
					var sizesForThisElement = sizesAllLines[_lineIndex][_elementIndex];
					var currentSize = sizesForThisElement[b.size];
					var availableSize = lines.length === 1 ? availableSpace[b.axis] : _line.largestSize[b.size];
					var elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);

					if (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {
						sizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);
					} else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {
						sizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);
					}
				}
			}

			return sizesAllLines;
		}

		function determineFittingAction(fittingMode, currentSize, availableSize) {
			switch (fittingMode) {
				case FITTING_NONE:
					return FITTING_ACTION.NONE;

				case FITTING_STRETCH:
					if (currentSize < availableSize) {
						return FITTING_ACTION.APPLY_STRETCHING;
					}

					return FITTING_ACTION.NONE;

				case FITTING_SHRINK:
					if (currentSize >= availableSize) {
						return FITTING_ACTION.APPLY_SHRINKING;
					}

					return FITTING_ACTION.NONE;

				case FITTING_BOTH:
					if (currentSize < availableSize) {
						return FITTING_ACTION.APPLY_STRETCHING;
					}

					return FITTING_ACTION.APPLY_SHRINKING;

				default:
					throw new Error("Unrecognized fitting mode: " + fittingMode);
			}
		}

		function calculateTotalSpace(sizes, axis) {
			var totalSizes = sumValues(sizes, axis.size);
			var totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];
			return totalSizes + totalSpacing;
		}

		function stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
			var ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);
			var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
			var fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);
			var remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;

			for (var i = 0; i < sizesThisLine.length; ++i) {
				var index = ascendingMaxSizeOrder[i];
				var targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);
				var targetSize = sizesThisLine[index][axis.size] + targetIncrease;
				var maxSize = sizesThisLine[index][axis.maxSize];
				var actualSize = Math.min(targetSize, maxSize);
				sizesThisLine[index][axis.size] = actualSize;
				var actualIncrease = Math.max(targetSize - actualSize, 0);
				var appliedIncrease = targetIncrease - actualIncrease;
				remainingUndershoot -= appliedIncrease;
			}
		}

		function shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
			var descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);
			var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
			var inverseFittingProportions = invertNormalizedValues(fittingProportions);
			var inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);
			var remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];

			for (var i = 0; i < sizesThisLine.length; ++i) {
				var index = descendingMinSizeOrder[i];
				var targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);
				var targetSize = sizesThisLine[index][axis.size] - targetReduction;
				var minSize = sizesThisLine[index][axis.minSize];
				var actualSize = Math.max(targetSize, minSize);
				sizesThisLine[index][axis.size] = actualSize;
				var actualReduction = Math.max(actualSize - targetSize, 0);
				var appliedReduction = targetReduction - actualReduction;
				remainingOvershoot -= appliedReduction;
			}
		}

		function calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {
			var proportion = fittingProportions[index];
			var sumOfRemainingProportions = fittingProportionSums[index];

			if (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {
				return remainingAdjustment;
			}

			return remainingAdjustment * proportion / sumOfRemainingProportions;
		}

		function calculateBasePositions(lines, sizes) {
			var cursor = {};
			cursor[a.axis] = 0;
			cursor[b.axis] = 0;
			lines[a.size] = Number.NEGATIVE_INFINITY;
			var positionsAllLines = [];

			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];

				if (line.length === 0) {
					positionsAllLines.push([]);
					continue;
				}

				var positionsThisLine = [];
				var sizesThisLine = sizes[lineIndex];

				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var element = line[elementIndex];
					var sizesThisElement = sizesThisLine[elementIndex];
					cursor[b.axis] -= minExtentB(element, sizesThisElement);
					cursor[a.axis] -= minExtentA(element, sizesThisElement);
					positionsThisLine[elementIndex] = {};
					positionsThisLine[elementIndex][a.axis] = cursor[a.axis];
					positionsThisLine[elementIndex][b.axis] = cursor[b.axis];
					cursor[b.axis] += minExtentB(element, sizesThisElement);
					cursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];
				}

				line[a.size] = cursor[a.axis] - options.spacing[a.axis];
				line[b.size] = line.largestSize[b.size];
				lines[a.size] = Math.max(lines[a.size], line[a.size]);
				cursor[a.axis] = 0;
				cursor[b.axis] += line[b.size] + options.spacing[b.axis];
				positionsAllLines.push(positionsThisLine);
			}

			lines[b.size] = cursor[b.axis] - options.spacing[b.axis];
			return positionsAllLines;
		}

		function applyAlignmentAndPadding(lines, sizes, positions) {
			var alignmentA = options.alignment[a.axis];
			var alignmentB = options.alignment[b.axis];
			var paddingA = options.padding[a.axis];
			var paddingB = options.padding[b.axis];

			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				var sizesThisLine = sizes[lineIndex];
				var positionsThisLine = positions[lineIndex];
				var axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;
				var axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;

				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];
					positionsThisLine[elementIndex][a.axis] += axisAOffset;
					positionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;
				}
			}
		}

		function applySizesAndPositions(lines, sizes, positions) {
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				var sizesThisLine = sizes[lineIndex];
				var positionsThisLine = positions[lineIndex];

				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var element = line[elementIndex];
					element[a.calculatedSize] = sizesThisLine[elementIndex][a.size];
					element[b.calculatedSize] = sizesThisLine[elementIndex][b.size];

					if (options.orientation === ORIENTATION_HORIZONTAL) {
						element.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);
					} else {
						element.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);
					}
				}
			}
		}

		function createLayoutInfo(lines) {
			var layoutWidth = lines.width;
			var layoutHeight = lines.height;
			var xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;
			var yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;
			return {
				bounds: new Vec4(xOffset, yOffset, layoutWidth, layoutHeight)
			};
		}

		function getElementSizeProperties(elements) {
			var sizeProperties = [];

			for (var i = 0; i < elements.length; ++i) {
				var element = elements[i];
				var minWidth = Math.max(getProperty(element, 'minWidth'), 0);
				var minHeight = Math.max(getProperty(element, 'minHeight'), 0);
				var maxWidth = Math.max(getProperty(element, 'maxWidth'), minWidth);
				var maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);
				var width = clamp(getProperty(element, 'width'), minWidth, maxWidth);
				var height = clamp(getProperty(element, 'height'), minHeight, maxHeight);
				var fitWidthProportion = getProperty(element, 'fitWidthProportion');
				var fitHeightProportion = getProperty(element, 'fitHeightProportion');
				sizeProperties.push({
					minWidth: minWidth,
					minHeight: minHeight,
					maxWidth: maxWidth,
					maxHeight: maxHeight,
					width: width,
					height: height,
					fitWidthProportion: fitWidthProportion,
					fitHeightProportion: fitHeightProportion
				});
			}

			return sizeProperties;
		}

		function getProperty(element, propertyName) {
			var layoutChildComponent = element.entity.layoutchild;

			if (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {
				return layoutChildComponent[propertyName];
			} else if (element[propertyName] !== undefined) {
				return element[propertyName];
			}

			return PROPERTY_DEFAULTS[propertyName];
		}

		function clamp(value, min, max) {
			return Math.min(Math.max(value, min), max);
		}

		function sumValues(items, propertyName) {
			return items.reduce(function (accumulator, current) {
				return accumulator + current[propertyName];
			}, 0);
		}

		function getNormalizedValues(items, propertyName) {
			var sum = sumValues(items, propertyName);
			var normalizedValues = [];
			var numItems = items.length;

			if (sum === 0) {
				for (var i = 0; i < numItems; ++i) {
					normalizedValues.push(1 / numItems);
				}
			} else {
				for (var _i = 0; _i < numItems; ++_i) {
					normalizedValues.push(items[_i][propertyName] / sum);
				}
			}

			return normalizedValues;
		}

		function invertNormalizedValues(values) {
			if (values.length === 1) {
				return [1];
			}

			var invertedValues = [];
			var numValues = values.length;

			for (var i = 0; i < numValues; ++i) {
				invertedValues.push((1 - values[i]) / (numValues - 1));
			}

			return invertedValues;
		}

		function getTraversalOrder(items, orderBy, descending) {
			items.forEach(assignIndex);
			return items.slice().sort(function (itemA, itemB) {
				return descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];
			}).map(getIndex);
		}

		function assignIndex(item, index) {
			item.index = index;
		}

		function getIndex(item) {
			return item.index;
		}

		function createSumArray(values, order) {
			var sumArray = [];
			sumArray[order[values.length - 1]] = values[order[values.length - 1]];

			for (var i = values.length - 2; i >= 0; --i) {
				sumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];
			}

			return sumArray;
		}

		return calculateAll;
	}

	var CALCULATE_FNS = {};
	CALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);
	CALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);

	var LayoutCalculator = function () {
		function LayoutCalculator() {}

		var _proto = LayoutCalculator.prototype;

		_proto.calculateLayout = function calculateLayout(elements, options) {
			var calculateFn = CALCULATE_FNS[options.orientation];

			if (!calculateFn) {
				throw new Error('Unrecognized orientation value: ' + options.orientation);
			} else {
				return calculateFn(elements, options);
			}
		};

		return LayoutCalculator;
	}();

	function getElement(entity) {
		return entity.element;
	}

	function isEnabledAndHasEnabledElement(entity) {
		return entity.enabled && entity.element && entity.element.enabled;
	}

	var LayoutGroupComponent = function (_Component) {
		_inheritsLoose(LayoutGroupComponent, _Component);

		function LayoutGroupComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._orientation = ORIENTATION_HORIZONTAL;
			_this._reverseX = false;
			_this._reverseY = true;
			_this._alignment = new Vec2(0, 1);
			_this._padding = new Vec4();
			_this._spacing = new Vec2();
			_this._widthFitting = FITTING_NONE;
			_this._heightFitting = FITTING_NONE;
			_this._wrap = false;
			_this._layoutCalculator = new LayoutCalculator();

			_this._listenForReflowEvents(_this.entity, 'on');

			_this.entity.children.forEach(function (child) {
				_this._listenForReflowEvents(child, 'on');
			});

			_this.entity.on('childinsert', _this._onChildInsert, _assertThisInitialized(_this));

			_this.entity.on('childremove', _this._onChildRemove, _assertThisInitialized(_this));

			system.app.systems.element.on('add', _this._onElementOrLayoutComponentAdd, _assertThisInitialized(_this));
			system.app.systems.element.on('beforeremove', _this._onElementOrLayoutComponentRemove, _assertThisInitialized(_this));
			system.app.systems.layoutchild.on('add', _this._onElementOrLayoutComponentAdd, _assertThisInitialized(_this));
			system.app.systems.layoutchild.on('beforeremove', _this._onElementOrLayoutComponentRemove, _assertThisInitialized(_this));
			return _this;
		}

		var _proto = LayoutGroupComponent.prototype;

		_proto._isSelfOrChild = function _isSelfOrChild(entity) {
			return entity === this.entity || this.entity.children.indexOf(entity) !== -1;
		};

		_proto._listenForReflowEvents = function _listenForReflowEvents(target, onOff) {
			if (target.element) {
				target.element[onOff]('enableelement', this._scheduleReflow, this);
				target.element[onOff]('disableelement', this._scheduleReflow, this);
				target.element[onOff]('resize', this._scheduleReflow, this);
				target.element[onOff]('set:pivot', this._scheduleReflow, this);
			}

			if (target.layoutchild) {
				target.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);
				target.layoutchild[onOff]('resize', this._scheduleReflow, this);
			}
		};

		_proto._onElementOrLayoutComponentAdd = function _onElementOrLayoutComponentAdd(entity) {
			if (this._isSelfOrChild(entity)) {
				this._listenForReflowEvents(entity, 'on');

				this._scheduleReflow();
			}
		};

		_proto._onElementOrLayoutComponentRemove = function _onElementOrLayoutComponentRemove(entity) {
			if (this._isSelfOrChild(entity)) {
				this._listenForReflowEvents(entity, 'off');

				this._scheduleReflow();
			}
		};

		_proto._onChildInsert = function _onChildInsert(child) {
			this._listenForReflowEvents(child, 'on');

			this._scheduleReflow();
		};

		_proto._onChildRemove = function _onChildRemove(child) {
			this._listenForReflowEvents(child, 'off');

			this._scheduleReflow();
		};

		_proto._scheduleReflow = function _scheduleReflow() {
			if (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {
				this.system.scheduleReflow(this);
			}
		};

		_proto.reflow = function reflow() {
			var container = getElement(this.entity);
			var elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);

			if (!container || elements.length === 0) {
				return;
			}

			var containerWidth = Math.max(container.calculatedWidth, 0);
			var containerHeight = Math.max(container.calculatedHeight, 0);
			var options = {
				orientation: this._orientation,
				reverseX: this._reverseX,
				reverseY: this._reverseY,
				alignment: this._alignment,
				padding: this._padding,
				spacing: this._spacing,
				widthFitting: this._widthFitting,
				heightFitting: this._heightFitting,
				wrap: this._wrap,
				containerSize: new Vec2(containerWidth, containerHeight)
			};
			this._isPerformingReflow = true;

			var layoutInfo = this._layoutCalculator.calculateLayout(elements, options);

			this._isPerformingReflow = false;
			this.fire('reflow', layoutInfo);
		};

		_proto.onEnable = function onEnable() {
			this._scheduleReflow();
		};

		_proto.onRemove = function onRemove() {
			var _this2 = this;

			this.entity.off('childinsert', this._onChildInsert, this);
			this.entity.off('childremove', this._onChildRemove, this);

			this._listenForReflowEvents(this.entity, 'off');

			this.entity.children.forEach(function (child) {
				_this2._listenForReflowEvents(child, 'off');
			});
			this.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);
			this.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
			this.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);
			this.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
		};

		_createClass(LayoutGroupComponent, [{
			key: "orientation",
			get: function get() {
				return this._orientation;
			},
			set: function set(value) {
				if (value !== this._orientation) {
					this._orientation = value;

					this._scheduleReflow();
				}
			}
		}, {
			key: "reverseX",
			get: function get() {
				return this._reverseX;
			},
			set: function set(value) {
				if (value !== this._reverseX) {
					this._reverseX = value;

					this._scheduleReflow();
				}
			}
		}, {
			key: "reverseY",
			get: function get() {
				return this._reverseY;
			},
			set: function set(value) {
				if (value !== this._reverseY) {
					this._reverseY = value;

					this._scheduleReflow();
				}
			}
		}, {
			key: "alignment",
			get: function get() {
				return this._alignment;
			},
			set: function set(value) {
				if (!value.equals(this._alignment)) {
					this._alignment.copy(value);

					this._scheduleReflow();
				}
			}
		}, {
			key: "padding",
			get: function get() {
				return this._padding;
			},
			set: function set(value) {
				if (!value.equals(this._padding)) {
					this._padding.copy(value);

					this._scheduleReflow();
				}
			}
		}, {
			key: "spacing",
			get: function get() {
				return this._spacing;
			},
			set: function set(value) {
				if (!value.equals(this._spacing)) {
					this._spacing.copy(value);

					this._scheduleReflow();
				}
			}
		}, {
			key: "widthFitting",
			get: function get() {
				return this._widthFitting;
			},
			set: function set(value) {
				if (value !== this._widthFitting) {
					this._widthFitting = value;

					this._scheduleReflow();
				}
			}
		}, {
			key: "heightFitting",
			get: function get() {
				return this._heightFitting;
			},
			set: function set(value) {
				if (value !== this._heightFitting) {
					this._heightFitting = value;

					this._scheduleReflow();
				}
			}
		}, {
			key: "wrap",
			get: function get() {
				return this._wrap;
			},
			set: function set(value) {
				if (value !== this._wrap) {
					this._wrap = value;

					this._scheduleReflow();
				}
			}
		}]);

		return LayoutGroupComponent;
	}(Component);

	var LayoutGroupComponentData = function LayoutGroupComponentData() {
		this.enabled = true;
	};

	var _schema$b = ['enabled'];
	var MAX_ITERATIONS = 100;

	var LayoutGroupComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(LayoutGroupComponentSystem, _ComponentSystem);

		function LayoutGroupComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'layoutgroup';
			_this.ComponentType = LayoutGroupComponent;
			_this.DataType = LayoutGroupComponentData;
			_this.schema = _schema$b;
			_this._reflowQueue = [];

			_this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));

			_this.app.systems.on('postUpdate', _this._onPostUpdate, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = LayoutGroupComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.enabled !== undefined) component.enabled = data.enabled;
			if (data.orientation !== undefined) component.orientation = data.orientation;
			if (data.reverseX !== undefined) component.reverseX = data.reverseX;
			if (data.reverseY !== undefined) component.reverseY = data.reverseY;

			if (data.alignment !== undefined) {
				component.alignment = Array.isArray(data.alignment) ? new Vec2(data.alignment) : data.alignment;
			}

			if (data.padding !== undefined) {
				component.padding = Array.isArray(data.padding) ? new Vec4(data.padding) : data.padding;
			}

			if (data.spacing !== undefined) {
				component.spacing = Array.isArray(data.spacing) ? new Vec2(data.spacing) : data.spacing;
			}

			if (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;
			if (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;
			if (data.wrap !== undefined) component.wrap = data.wrap;

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var layoutGroup = entity.layoutgroup;
			return this.addComponent(clone, {
				enabled: layoutGroup.enabled,
				orientation: layoutGroup.orientation,
				reverseX: layoutGroup.reverseX,
				reverseY: layoutGroup.reverseY,
				alignment: layoutGroup.alignment,
				padding: layoutGroup.padding,
				spacing: layoutGroup.spacing,
				widthFitting: layoutGroup.widthFitting,
				heightFitting: layoutGroup.heightFitting,
				wrap: layoutGroup.wrap
			});
		};

		_proto.scheduleReflow = function scheduleReflow(component) {
			if (this._reflowQueue.indexOf(component) === -1) {
				this._reflowQueue.push(component);
			}
		};

		_proto._onPostUpdate = function _onPostUpdate() {
			this._processReflowQueue();
		};

		_proto._processReflowQueue = function _processReflowQueue() {
			if (this._reflowQueue.length === 0) {
				return;
			}

			var iterationCount = 0;

			while (this._reflowQueue.length > 0) {
				var queue = this._reflowQueue.slice();

				this._reflowQueue.length = 0;
				queue.sort(function (componentA, componentB) {
					return componentA.entity.graphDepth - componentB.entity.graphDepth;
				});

				for (var i = 0; i < queue.length; ++i) {
					queue[i].reflow();
				}

				if (++iterationCount >= MAX_ITERATIONS) {
					console.warn('Max reflow iterations limit reached, bailing.');
					break;
				}
			}
		};

		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off('postUpdate', this._onPostUpdate, this);
		};

		return LayoutGroupComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(LayoutGroupComponent.prototype, _schema$b);

	var _lightProps = [];
	var _lightPropsDefault = [];

	var LightComponent = function (_Component) {
		_inheritsLoose(LightComponent, _Component);

		function LightComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._cookieAsset = null;
			_this._cookieAssetId = null;
			_this._cookieAssetAdd = false;
			_this._cookieMatrix = null;
			return _this;
		}

		var _proto = LightComponent.prototype;

		_proto.addLightToLayers = function addLightToLayers() {
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);

				if (layer) {
					layer.addLight(this);
				}
			}
		};

		_proto.removeLightFromLayers = function removeLightFromLayers() {
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);

				if (layer) {
					layer.removeLight(this);
				}
			}
		};

		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			if (this.enabled && this.entity.enabled) {
				this.addLightToLayers();
			}

			oldComp.off("add", this.onLayerAdded, this);
			oldComp.off("remove", this.onLayerRemoved, this);
			newComp.on("add", this.onLayerAdded, this);
			newComp.on("remove", this.onLayerRemoved, this);
		};

		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);

			if (index >= 0 && this.enabled && this.entity.enabled) {
				layer.addLight(this);
			}
		};

		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);

			if (index >= 0) {
				layer.removeLight(this);
			}
		};

		_proto.refreshProperties = function refreshProperties() {
			for (var i = 0; i < _lightProps.length; i++) {
				var name = _lightProps[i];
				this[name] = this[name];
			}

			if (this.enabled && this.entity.enabled) this.onEnable();
		};

		_proto.updateShadow = function updateShadow() {
			this.light.updateShadow();
		};

		_proto.onCookieAssetSet = function onCookieAssetSet() {
			var forceLoad = false;

			if (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {
				this._cookieAsset.loadFaces = true;
				forceLoad = true;
			}

			if (!this._cookieAsset.resource || forceLoad) this.system.app.assets.load(this._cookieAsset);
			if (this._cookieAsset.resource) this.onCookieAssetLoad();
		};

		_proto.onCookieAssetAdd = function onCookieAssetAdd(asset) {
			if (this._cookieAssetId !== asset.id) return;
			this._cookieAsset = asset;
			if (this.light.enabled) this.onCookieAssetSet();

			this._cookieAsset.on('load', this.onCookieAssetLoad, this);

			this._cookieAsset.on('remove', this.onCookieAssetRemove, this);
		};

		_proto.onCookieAssetLoad = function onCookieAssetLoad() {
			if (!this._cookieAsset || !this._cookieAsset.resource) return;
			this.cookie = this._cookieAsset.resource;
		};

		_proto.onCookieAssetRemove = function onCookieAssetRemove() {
			if (!this._cookieAssetId) return;

			if (this._cookieAssetAdd) {
				this.system.app.assets.off('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
				this._cookieAssetAdd = false;
			}

			if (this._cookieAsset) {
				this._cookieAsset.off('load', this.onCookieAssetLoad, this);

				this._cookieAsset.off('remove', this.onCookieAssetRemove, this);

				this._cookieAsset = null;
			}

			this.cookie = null;
		};

		_proto.onEnable = function onEnable() {
			this.light.enabled = true;
			this.system.app.scene.on("set:layers", this.onLayersChanged, this);

			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.on("add", this.onLayerAdded, this);
				this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
			}

			if (this.enabled && this.entity.enabled) {
				this.addLightToLayers();
			}

			if (this._cookieAsset && !this.cookie) this.onCookieAssetSet();
		};

		_proto.onDisable = function onDisable() {
			this.light.enabled = false;
			this.system.app.scene.off("set:layers", this.onLayersChanged, this);

			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.off("add", this.onLayerAdded, this);
				this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
			}

			this.removeLightFromLayers();
		};

		_proto.onRemove = function onRemove() {
			this.onDisable();
			this.light.destroy();
			this.cookieAsset = null;
		};

		return LightComponent;
	}(Component);

	function _defineProperty(name, defaultValue, setFunc, skipEqualsCheck) {
		var c = LightComponent.prototype;

		_lightProps.push(name);

		_lightPropsDefault.push(defaultValue);

		Object.defineProperty(c, name, {
			get: function get() {
				return this.data[name];
			},
			set: function set(value) {
				var data = this.data;
				var oldValue = data[name];
				if (!skipEqualsCheck && oldValue === value) return;
				data[name] = value;
				if (setFunc) setFunc.call(this, value, oldValue);
			},
			configurable: true
		});
	}

	function _defineProps() {
		_defineProperty("enabled", true, function (newValue, oldValue) {
			this.onSetEnabled(null, oldValue, newValue);
		});

		_defineProperty("light", null);

		_defineProperty("type", 'directional', function (newValue, oldValue) {
			this.system.changeType(this, oldValue, newValue);
			this.refreshProperties();
		});

		_defineProperty("color", new Color(1, 1, 1), function (newValue, oldValue) {
			this.light.setColor(newValue);
		}, true);

		_defineProperty("intensity", 1, function (newValue, oldValue) {
			this.light.intensity = newValue;
		});

		_defineProperty("shape", LIGHTSHAPE_PUNCTUAL, function (newValue, oldValue) {
			this.light.shape = newValue;
		});

		_defineProperty("castShadows", false, function (newValue, oldValue) {
			this.light.castShadows = newValue;
		});

		_defineProperty("shadowDistance", 40, function (newValue, oldValue) {
			this.light.shadowDistance = newValue;
		});

		_defineProperty("shadowResolution", 1024, function (newValue, oldValue) {
			this.light.shadowResolution = newValue;
		});

		_defineProperty("shadowBias", 0.05, function (newValue, oldValue) {
			this.light.shadowBias = -0.01 * math.clamp(newValue, 0, 1);
		});

		_defineProperty("numCascades", 1, function (newValue, oldValue) {
			this.light.numCascades = math.clamp(Math.floor(newValue), 1, 4);
		});

		_defineProperty("bakeNumSamples", 1, function (newValue, oldValue) {
			this.light.bakeNumSamples = math.clamp(Math.floor(newValue), 1, 255);
		});

		_defineProperty("bakeArea", 0, function (newValue, oldValue) {
			this.light.bakeArea = math.clamp(newValue, 0, 180);
		});

		_defineProperty("cascadeDistribution", 0.5, function (newValue, oldValue) {
			this.light.cascadeDistribution = math.clamp(newValue, 0, 1);
		});

		_defineProperty("normalOffsetBias", 0, function (newValue, oldValue) {
			this.light.normalOffsetBias = math.clamp(newValue, 0, 1);
		});

		_defineProperty("range", 10, function (newValue, oldValue) {
			this.light.attenuationEnd = newValue;
		});

		_defineProperty("innerConeAngle", 40, function (newValue, oldValue) {
			this.light.innerConeAngle = newValue;
		});

		_defineProperty("outerConeAngle", 45, function (newValue, oldValue) {
			this.light.outerConeAngle = newValue;
		});

		_defineProperty("falloffMode", LIGHTFALLOFF_LINEAR, function (newValue, oldValue) {
			this.light.falloffMode = newValue;
		});

		_defineProperty("shadowType", SHADOW_PCF3, function (newValue, oldValue) {
			this.light.shadowType = newValue;
		});

		_defineProperty("vsmBlurSize", 11, function (newValue, oldValue) {
			this.light.vsmBlurSize = newValue;
		});

		_defineProperty("vsmBlurMode", BLUR_GAUSSIAN, function (newValue, oldValue) {
			this.light.vsmBlurMode = newValue;
		});

		_defineProperty("vsmBias", 0.01 * 0.25, function (newValue, oldValue) {
			this.light.vsmBias = math.clamp(newValue, 0, 1);
		});

		_defineProperty("cookieAsset", null, function (newValue, oldValue) {
			if (this._cookieAssetId && (newValue instanceof Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) return;
			this.onCookieAssetRemove();
			this._cookieAssetId = null;

			if (newValue instanceof Asset) {
				this.data.cookieAsset = newValue.id;
				this._cookieAssetId = newValue.id;
				this.onCookieAssetAdd(newValue);
			} else if (typeof newValue === 'number') {
				this._cookieAssetId = newValue;
				var asset = this.system.app.assets.get(newValue);

				if (asset) {
					this.onCookieAssetAdd(asset);
				} else {
					this._cookieAssetAdd = true;
					this.system.app.assets.on('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
				}
			}
		});

		_defineProperty("cookie", null, function (newValue, oldValue) {
			this.light.cookie = newValue;
		});

		_defineProperty("cookieIntensity", 1, function (newValue, oldValue) {
			this.light.cookieIntensity = math.clamp(newValue, 0, 1);
		});

		_defineProperty("cookieFalloff", true, function (newValue, oldValue) {
			this.light.cookieFalloff = newValue;
		});

		_defineProperty("cookieChannel", "rgb", function (newValue, oldValue) {
			this.light.cookieChannel = newValue;
		});

		_defineProperty("cookieAngle", 0, function (newValue, oldValue) {
			if (newValue !== 0 || this.cookieScale !== null) {
				if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
				var scx = 1;
				var scy = 1;

				if (this.cookieScale) {
					scx = this.cookieScale.x;
					scy = this.cookieScale.y;
				}

				var c = Math.cos(newValue * math.DEG_TO_RAD);
				var s = Math.sin(newValue * math.DEG_TO_RAD);

				this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);

				this.light.cookieTransform = this._cookieMatrix;
			} else {
				this.light.cookieTransform = null;
			}
		});

		_defineProperty("cookieScale", null, function (newValue, oldValue) {
			if (newValue !== null || this.cookieAngle !== 0) {
				if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
				var scx = newValue.x;
				var scy = newValue.y;
				var c = Math.cos(this.cookieAngle * math.DEG_TO_RAD);
				var s = Math.sin(this.cookieAngle * math.DEG_TO_RAD);

				this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);

				this.light.cookieTransform = this._cookieMatrix;
			} else {
				this.light.cookieTransform = null;
			}
		}, true);

		_defineProperty("cookieOffset", null, function (newValue, oldValue) {
			this.light.cookieOffset = newValue;
		}, true);

		_defineProperty("shadowUpdateMode", SHADOWUPDATE_REALTIME, function (newValue, oldValue) {
			this.light.shadowUpdateMode = newValue;
		}, true);

		_defineProperty("mask", 1, function (newValue, oldValue) {
			this.light.mask = newValue;
		});

		_defineProperty("affectDynamic", true, function (newValue, oldValue) {
			if (newValue) {
				this.light.mask |= MASK_AFFECT_DYNAMIC;
			} else {
				this.light.mask &= ~MASK_AFFECT_DYNAMIC;
			}

			this.light.layersDirty();
		});

		_defineProperty("affectLightmapped", false, function (newValue, oldValue) {
			if (newValue) {
				this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
				if (this.bake) this.light.mask &= ~MASK_BAKE;
			} else {
				this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
				if (this.bake) this.light.mask |= MASK_BAKE;
			}
		});

		_defineProperty("bake", false, function (newValue, oldValue) {
			if (newValue) {
				this.light.mask |= MASK_BAKE;
				if (this.affectLightmapped) this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
			} else {
				this.light.mask &= ~MASK_BAKE;
				if (this.affectLightmapped) this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
			}

			this.light.layersDirty();
		});

		_defineProperty("bakeDir", true, function (newValue, oldValue) {
			this.light.bakeDir = newValue;
		});

		_defineProperty("isStatic", false, function (newValue, oldValue) {
			this.light.isStatic = newValue;
		});

		_defineProperty("layers", [LAYERID_WORLD], function (newValue, oldValue) {
			for (var i = 0; i < oldValue.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
				if (!layer) continue;
				layer.removeLight(this);
			}

			for (var _i = 0; _i < newValue.length; _i++) {
				var _layer = this.system.app.scene.layers.getLayerById(newValue[_i]);

				if (!_layer) continue;

				if (this.enabled && this.entity.enabled) {
					_layer.addLight(this);
				}
			}
		});
	}

	_defineProps();

	var LightComponentData = function LightComponentData() {
		var _props = _lightProps;
		var _propsDefault = _lightPropsDefault;

		for (var i = 0; i < _props.length; i++) {
			var value = _propsDefault[i];

			if (value && value.clone) {
				this[_props[i]] = value.clone();
			} else {
				this[_props[i]] = value;
			}
		}
	};

	var lightTypes = {
		'directional': LIGHTTYPE_DIRECTIONAL,
		'omni': LIGHTTYPE_OMNI,
		'point': LIGHTTYPE_OMNI,
		'spot': LIGHTTYPE_SPOT
	};

	var LightComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(LightComponentSystem, _ComponentSystem);

		function LightComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'light';
			_this.ComponentType = LightComponent;
			_this.DataType = LightComponentData;

			_this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = LightComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, _data) {
			var properties = _lightProps;
			var data = {};

			for (var i = 0, len = properties.length; i < len; i++) {
				var property = properties[i];
				data[property] = _data[property];
			}

			if (!data.type) data.type = component.data.type;
			component.data.type = data.type;

			if (data.layers && Array.isArray(data.layers)) {
				data.layers = data.layers.slice(0);
			}

			if (data.color && Array.isArray(data.color)) data.color = new Color(data.color[0], data.color[1], data.color[2]);
			if (data.cookieOffset && data.cookieOffset instanceof Array) data.cookieOffset = new Vec2(data.cookieOffset[0], data.cookieOffset[1]);
			if (data.cookieScale && data.cookieScale instanceof Array) data.cookieScale = new Vec2(data.cookieScale[0], data.cookieScale[1]);

			if (data.enable) {
				console.warn("WARNING: enable: Property is deprecated. Set enabled property instead.");
				data.enabled = data.enable;
			}

			if (!data.shape) {
				data.shape = LIGHTSHAPE_PUNCTUAL;
			}

			var light = new Light(this.app.graphicsDevice);
			light.type = lightTypes[data.type];
			light._node = component.entity;
			light._scene = this.app.scene;
			component.data.light = light;

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};

		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var light = entity.light;
			var data = [];
			var name;
			var _props = _lightProps;

			for (var i = 0; i < _props.length; i++) {
				name = _props[i];
				if (name === "light") continue;

				if (light[name] && light[name].clone) {
					data[name] = light[name].clone();
				} else {
					data[name] = light[name];
				}
			}

			return this.addComponent(clone, data);
		};

		_proto.changeType = function changeType(component, oldValue, newValue) {
			if (oldValue !== newValue) {
				component.light.type = lightTypes[newValue];
			}
		};

		return LightComponentSystem;
	}(ComponentSystem);

	var ModelComponent = function (_Component) {
		_inheritsLoose(ModelComponent, _Component);

		function ModelComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._type = 'asset';
			_this._asset = null;
			_this._model = null;
			_this._mapping = {};
			_this._castShadows = true;
			_this._receiveShadows = true;
			_this._materialAsset = null;
			_this._material = void 0;
			_this._castShadowsLightmap = true;
			_this._lightmapped = false;
			_this._lightmapSizeMultiplier = 1;
			_this._isStatic = false;
			_this._layers = [LAYERID_WORLD];
			_this._batchGroupId = -1;
			_this._customAabb = null;
			_this._area = null;
			_this._materialEvents = null;
			_this._clonedModel = false;
			_this._batchGroup = null;
			_this._material = system.defaultMaterial;
			entity.on('remove', _this.onRemoveChild, _assertThisInitialized(_this));
			entity.on('removehierarchy', _this.onRemoveChild, _assertThisInitialized(_this));
			entity.on('insert', _this.onInsertChild, _assertThisInitialized(_this));
			entity.on('inserthierarchy', _this.onInsertChild, _assertThisInitialized(_this));
			return _this;
		}

		var _proto = ModelComponent.prototype;

		_proto.addModelToLayers = function addModelToLayers() {
			var layers = this.system.app.scene.layers;

			for (var i = 0; i < this._layers.length; i++) {
				var layer = layers.getLayerById(this._layers[i]);

				if (layer) {
					layer.addMeshInstances(this.meshInstances);
				}
			}
		};

		_proto.removeModelFromLayers = function removeModelFromLayers() {
			var layers = this.system.app.scene.layers;

			for (var i = 0; i < this._layers.length; i++) {
				var layer = layers.getLayerById(this._layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances(this.meshInstances);
			}
		};

		_proto.onRemoveChild = function onRemoveChild() {
			if (this._model) this.removeModelFromLayers();
		};

		_proto.onInsertChild = function onInsertChild() {
			if (this._model && this.enabled && this.entity.enabled) this.addModelToLayers();
		};

		_proto.onRemove = function onRemove() {
			this.asset = null;
			this.model = null;
			this.materialAsset = null;

			this._unsetMaterialEvents();

			this.entity.off('remove', this.onRemoveChild, this);
			this.entity.off('insert', this.onInsertChild, this);
		};

		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addModelToLayers();
			oldComp.off("add", this.onLayerAdded, this);
			oldComp.off("remove", this.onLayerRemoved, this);
			newComp.on("add", this.onLayerAdded, this);
			newComp.on("remove", this.onLayerRemoved, this);
		};

		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addMeshInstances(this.meshInstances);
		};

		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances(this.meshInstances);
		};

		_proto._setMaterialEvent = function _setMaterialEvent(index, event, id, handler) {
			var evt = event + ':' + id;
			this.system.app.assets.on(evt, handler, this);
			if (!this._materialEvents) this._materialEvents = [];
			if (!this._materialEvents[index]) this._materialEvents[index] = {};
			this._materialEvents[index][evt] = {
				id: id,
				handler: handler
			};
		};

		_proto._unsetMaterialEvents = function _unsetMaterialEvents() {
			var assets = this.system.app.assets;
			var events = this._materialEvents;
			if (!events) return;

			for (var i = 0, len = events.length; i < len; i++) {
				if (!events[i]) continue;
				var evt = events[i];

				for (var key in evt) {
					assets.off(key, evt[key].handler, this);
				}
			}

			this._materialEvents = null;
		};

		_proto._getAssetByIdOrPath = function _getAssetByIdOrPath(idOrPath) {
			var asset = null;
			var isPath = isNaN(parseInt(idOrPath, 10));

			if (!isPath) {
				asset = this.system.app.assets.get(idOrPath);
			} else if (this.asset) {
				var url = this._getMaterialAssetUrl(idOrPath);

				if (url) asset = this.system.app.assets.getByUrl(url);
			}

			return asset;
		};

		_proto._getMaterialAssetUrl = function _getMaterialAssetUrl(path) {
			if (!this.asset) return null;
			var modelAsset = this.system.app.assets.get(this.asset);
			return modelAsset ? modelAsset.getAbsoluteUrl(path) : null;
		};

		_proto._loadAndSetMeshInstanceMaterial = function _loadAndSetMeshInstanceMaterial(materialAsset, meshInstance, index) {
			var assets = this.system.app.assets;
			if (!materialAsset) return;

			if (materialAsset.resource) {
				meshInstance.material = materialAsset.resource;

				this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
					meshInstance.material = this.system.defaultMaterial;
				});
			} else {
				this._setMaterialEvent(index, 'load', materialAsset.id, function (asset) {
					meshInstance.material = asset.resource;

					this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
						meshInstance.material = this.system.defaultMaterial;
					});
				});

				if (this.enabled && this.entity.enabled) assets.load(materialAsset);
			}
		};

		_proto.onEnable = function onEnable() {
			var app = this.system.app;
			var scene = app.scene;
			scene.on("set:layers", this.onLayersChanged, this);

			if (scene.layers) {
				scene.layers.on("add", this.onLayerAdded, this);
				scene.layers.on("remove", this.onLayerRemoved, this);
			}

			var isAsset = this._type === 'asset';
			var asset;

			if (this._model) {
				this.addModelToLayers();
			} else if (isAsset && this._asset) {
				asset = app.assets.get(this._asset);

				if (asset && asset.resource !== this._model) {
					this._bindModelAsset(asset);
				}
			}

			if (this._materialAsset) {
				asset = app.assets.get(this._materialAsset);

				if (asset && asset.resource !== this._material) {
					this._bindMaterialAsset(asset);
				}
			}

			if (isAsset) {
				if (this._mapping) {
					for (var index in this._mapping) {
						if (this._mapping[index]) {
							asset = this._getAssetByIdOrPath(this._mapping[index]);

							if (asset && !asset.resource) {
								app.assets.load(asset);
							}
						}
					}
				}
			}

			if (this._batchGroupId >= 0) {
				app.batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);
			}
		};

		_proto.onDisable = function onDisable() {
			var app = this.system.app;
			var scene = app.scene;
			scene.off("set:layers", this.onLayersChanged, this);

			if (scene.layers) {
				scene.layers.off("add", this.onLayerAdded, this);
				scene.layers.off("remove", this.onLayerRemoved, this);
			}

			if (this._batchGroupId >= 0) {
				app.batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
			}

			if (this._model) {
				this.removeModelFromLayers();
			}
		};

		_proto.hide = function hide() {
			if (this._model) {
				var instances = this._model.meshInstances;

				for (var i = 0, l = instances.length; i < l; i++) {
					instances[i].visible = false;
				}
			}
		};

		_proto.show = function show() {
			if (this._model) {
				var instances = this._model.meshInstances;

				for (var i = 0, l = instances.length; i < l; i++) {
					instances[i].visible = true;
				}
			}
		};

		_proto._bindMaterialAsset = function _bindMaterialAsset(asset) {
			asset.on('load', this._onMaterialAssetLoad, this);
			asset.on('unload', this._onMaterialAssetUnload, this);
			asset.on('remove', this._onMaterialAssetRemove, this);
			asset.on('change', this._onMaterialAssetChange, this);

			if (asset.resource) {
				this._onMaterialAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};

		_proto._unbindMaterialAsset = function _unbindMaterialAsset(asset) {
			asset.off('load', this._onMaterialAssetLoad, this);
			asset.off('unload', this._onMaterialAssetUnload, this);
			asset.off('remove', this._onMaterialAssetRemove, this);
			asset.off('change', this._onMaterialAssetChange, this);
		};

		_proto._onMaterialAssetAdd = function _onMaterialAssetAdd(asset) {
			this.system.app.assets.off('add:' + asset.id, this._onMaterialAssetAdd, this);

			if (this._materialAsset === asset.id) {
				this._bindMaterialAsset(asset);
			}
		};

		_proto._onMaterialAssetLoad = function _onMaterialAssetLoad(asset) {
			this._setMaterial(asset.resource);
		};

		_proto._onMaterialAssetUnload = function _onMaterialAssetUnload(asset) {
			this._setMaterial(this.system.defaultMaterial);
		};

		_proto._onMaterialAssetRemove = function _onMaterialAssetRemove(asset) {
			this._onMaterialAssetUnload(asset);
		};

		_proto._onMaterialAssetChange = function _onMaterialAssetChange(asset) {};

		_proto._bindModelAsset = function _bindModelAsset(asset) {
			this._unbindModelAsset(asset);

			asset.on('load', this._onModelAssetLoad, this);
			asset.on('unload', this._onModelAssetUnload, this);
			asset.on('change', this._onModelAssetChange, this);
			asset.on('remove', this._onModelAssetRemove, this);

			if (asset.resource) {
				this._onModelAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};

		_proto._unbindModelAsset = function _unbindModelAsset(asset) {
			asset.off('load', this._onModelAssetLoad, this);
			asset.off('unload', this._onModelAssetUnload, this);
			asset.off('change', this._onModelAssetChange, this);
			asset.off('remove', this._onModelAssetRemove, this);
		};

		_proto._onModelAssetAdded = function _onModelAssetAdded(asset) {
			this.system.app.assets.off('add:' + asset.id, this._onModelAssetAdded, this);

			if (asset.id === this._asset) {
				this._bindModelAsset(asset);
			}
		};

		_proto._onModelAssetLoad = function _onModelAssetLoad(asset) {
			this.model = asset.resource.clone();
			this._clonedModel = true;
		};

		_proto._onModelAssetUnload = function _onModelAssetUnload(asset) {
			this.model = null;
		};

		_proto._onModelAssetChange = function _onModelAssetChange(asset, attr, _new, _old) {
			if (attr === 'data') {
				this.mapping = this._mapping;
			}
		};

		_proto._onModelAssetRemove = function _onModelAssetRemove(asset) {
			this.model = null;
		};

		_proto._setMaterial = function _setMaterial(material) {
			if (this._material === material) return;
			this._material = material;
			var model = this._model;

			if (model && this._type !== 'asset') {
				var meshInstances = model.meshInstances;

				for (var i = 0, len = meshInstances.length; i < len; i++) {
					meshInstances[i].material = material;
				}
			}
		};

		_createClass(ModelComponent, [{
			key: "meshInstances",
			get: function get() {
				if (!this._model) return null;
				return this._model.meshInstances;
			},
			set: function set(value) {
				if (!this._model) return;
				this._model.meshInstances = value;
			}
		}, {
			key: "customAabb",
			get: function get() {
				return this._customAabb;
			},
			set: function set(value) {
				this._customAabb = value;

				if (this._model) {
					var mi = this._model.meshInstances;

					if (mi) {
						for (var i = 0; i < mi.length; i++) {
							mi[i].setCustomAabb(this._customAabb);
						}
					}
				}
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (this._type === value) return;
				this._area = null;
				this._type = value;

				if (value === 'asset') {
					if (this._asset !== null) {
						this._bindModelAsset(this._asset);
					} else {
						this.model = null;
					}
				} else {
					var primData = getShapePrimitive(this.system.app.graphicsDevice, value);
					this._area = primData.area;
					var mesh = primData.mesh;
					var node = new GraphNode();
					var model = new Model();
					model.graph = node;
					model.meshInstances = [new MeshInstance(mesh, this._material, node)];
					this.model = model;
					this._asset = null;
				}
			}
		}, {
			key: "asset",
			get: function get() {
				return this._asset;
			},
			set: function set(value) {
				var assets = this.system.app.assets;
				var _id = value;

				if (value instanceof Asset) {
					_id = value.id;
				}

				if (this._asset !== _id) {
					if (this._asset) {
						assets.off('add:' + this._asset, this._onModelAssetAdded, this);

						var _prev = assets.get(this._asset);

						if (_prev) {
							this._unbindModelAsset(_prev);
						}
					}

					this._asset = _id;

					if (this._asset) {
						var asset = assets.get(this._asset);

						if (!asset) {
							this.model = null;
							assets.on('add:' + this._asset, this._onModelAssetAdded, this);
						} else {
							this._bindModelAsset(asset);
						}
					} else {
						this.model = null;
					}
				}
			}
		}, {
			key: "model",
			get: function get() {
				return this._model;
			},
			set: function set(value) {
				if (this._model === value) return;

				if (value && value._immutable) {
					Debug.error('Invalid attempt to assign a model to multiple ModelComponents');
					return;
				}

				if (this._model) {
					this._model._immutable = false;
					this.removeModelFromLayers();
					this.entity.removeChild(this._model.getGraph());
					delete this._model._entity;

					if (this._clonedModel) {
						this._model.destroy();

						this._clonedModel = false;
					}
				}

				this._model = value;

				if (this._model) {
					this._model._immutable = true;
					var meshInstances = this._model.meshInstances;

					for (var i = 0; i < meshInstances.length; i++) {
						meshInstances[i].castShadow = this._castShadows;
						meshInstances[i].receiveShadow = this._receiveShadows;
						meshInstances[i].isStatic = this._isStatic;
						meshInstances[i].setCustomAabb(this._customAabb);
					}

					this.lightmapped = this._lightmapped;
					this.entity.addChild(this._model.graph);

					if (this.enabled && this.entity.enabled) {
						this.addModelToLayers();
					}

					this._model._entity = this.entity;
					if (this.entity.animation) this.entity.animation.setModel(this._model);

					if (this.entity.anim) {
						this.entity.anim.rebind();
					}

					if (this.type === 'asset') {
						this.mapping = this._mapping;
					} else {
						this._unsetMaterialEvents();
					}
				}
			}
		}, {
			key: "lightmapped",
			get: function get() {
				return this._lightmapped;
			},
			set: function set(value) {
				if (value !== this._lightmapped) {
					this._lightmapped = value;

					if (this._model) {
						var mi = this._model.meshInstances;

						for (var i = 0; i < mi.length; i++) {
							mi[i].setLightmapped(value);
						}
					}
				}
			}
		}, {
			key: "castShadows",
			get: function get() {
				return this._castShadows;
			},
			set: function set(value) {
				if (this._castShadows === value) return;
				var model = this._model;

				if (model) {
					var layers = this.layers;
					var scene = this.system.app.scene;

					if (this._castShadows && !value) {
						for (var i = 0; i < layers.length; i++) {
							var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
							if (!layer) continue;
							layer.removeShadowCasters(model.meshInstances);
						}
					}

					var meshInstances = model.meshInstances;

					for (var _i = 0; _i < meshInstances.length; _i++) {
						meshInstances[_i].castShadow = value;
					}

					if (!this._castShadows && value) {
						for (var _i2 = 0; _i2 < layers.length; _i2++) {
							var _layer = scene.layers.getLayerById(layers[_i2]);

							if (!_layer) continue;

							_layer.addShadowCasters(model.meshInstances);
						}
					}
				}

				this._castShadows = value;
			}
		}, {
			key: "receiveShadows",
			get: function get() {
				return this._receiveShadows;
			},
			set: function set(value) {
				if (this._receiveShadows === value) return;
				this._receiveShadows = value;

				if (this._model) {
					var meshInstances = this._model.meshInstances;

					for (var i = 0, len = meshInstances.length; i < len; i++) {
						meshInstances[i].receiveShadow = value;
					}
				}
			}
		}, {
			key: "castShadowsLightmap",
			get: function get() {
				return this._castShadowsLightmap;
			},
			set: function set(value) {
				this._castShadowsLightmap = value;
			}
		}, {
			key: "lightmapSizeMultiplier",
			get: function get() {
				return this._lightmapSizeMultiplier;
			},
			set: function set(value) {
				this._lightmapSizeMultiplier = value;
			}
		}, {
			key: "isStatic",
			get: function get() {
				return this._isStatic;
			},
			set: function set(value) {
				if (this._isStatic === value) return;
				this._isStatic = value;

				if (this._model) {
					var rcv = this._model.meshInstances;

					for (var i = 0; i < rcv.length; i++) {
						var m = rcv[i];
						m.isStatic = value;
					}
				}
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(value) {
				var layers = this.system.app.scene.layers;

				if (this.meshInstances) {
					for (var i = 0; i < this._layers.length; i++) {
						var layer = layers.getLayerById(this._layers[i]);
						if (!layer) continue;
						layer.removeMeshInstances(this.meshInstances);
					}
				}

				this._layers.length = 0;

				for (var _i3 = 0; _i3 < value.length; _i3++) {
					this._layers[_i3] = value[_i3];
				}

				if (!this.enabled || !this.entity.enabled || !this.meshInstances) return;

				for (var _i4 = 0; _i4 < this._layers.length; _i4++) {
					var _layer2 = layers.getLayerById(this._layers[_i4]);

					if (!_layer2) continue;

					_layer2.addMeshInstances(this.meshInstances);
				}
			}
		}, {
			key: "batchGroupId",
			get: function get() {
				return this._batchGroupId;
			},
			set: function set(value) {
				if (this._batchGroupId === value) return;
				var batcher = this.system.app.batcher;

				if (this.entity.enabled && this._batchGroupId >= 0) {
					batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
				}

				if (this.entity.enabled && value >= 0) {
					batcher.insert(BatchGroup.MODEL, value, this.entity);
				}

				if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
					this.addModelToLayers();
				}

				this._batchGroupId = value;
			}
		}, {
			key: "materialAsset",
			get: function get() {
				return this._materialAsset;
			},
			set: function set(value) {
				var _id = value;

				if (value instanceof Asset) {
					_id = value.id;
				}

				var assets = this.system.app.assets;

				if (_id !== this._materialAsset) {
					if (this._materialAsset) {
						assets.off('add:' + this._materialAsset, this._onMaterialAssetAdd, this);

						var _prev = assets.get(this._materialAsset);

						if (_prev) {
							this._unbindMaterialAsset(_prev);
						}
					}

					this._materialAsset = _id;

					if (this._materialAsset) {
						var asset = assets.get(this._materialAsset);

						if (!asset) {
							this._setMaterial(this.system.defaultMaterial);

							assets.on('add:' + this._materialAsset, this._onMaterialAssetAdd, this);
						} else {
							this._bindMaterialAsset(asset);
						}
					} else {
						this._setMaterial(this.system.defaultMaterial);
					}
				}
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(value) {
				if (this._material === value) return;
				this.materialAsset = null;

				this._setMaterial(value);
			}
		}, {
			key: "mapping",
			get: function get() {
				return this._mapping;
			},
			set: function set(value) {
				if (this._type !== 'asset') return;

				this._unsetMaterialEvents();

				if (!value) value = {};
				this._mapping = value;
				if (!this._model) return;
				var meshInstances = this._model.meshInstances;
				var modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;
				var assetMapping = modelAsset ? modelAsset.data.mapping : null;
				var asset = null;

				for (var i = 0, len = meshInstances.length; i < len; i++) {
					if (value[i] !== undefined) {
						if (value[i]) {
							asset = this.system.app.assets.get(value[i]);

							this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
						} else {
							meshInstances[i].material = this.system.defaultMaterial;
						}
					} else if (assetMapping) {
						if (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {
							if (assetMapping[i].material !== undefined) {
								asset = this.system.app.assets.get(assetMapping[i].material);
							} else if (assetMapping[i].path !== undefined) {
								var url = this._getMaterialAssetUrl(assetMapping[i].path);

								if (url) {
									asset = this.system.app.assets.getByUrl(url);
								}
							}

							this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
						} else {
							meshInstances[i].material = this.system.defaultMaterial;
						}
					}
				}
			}
		}]);

		return ModelComponent;
	}(Component);

	var ModelComponentData = function ModelComponentData() {
		this.enabled = true;
	};

	var _schema$a = ['enabled'];

	var ModelComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ModelComponentSystem, _ComponentSystem);

		function ModelComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'model';
			_this.ComponentType = ModelComponent;
			_this.DataType = ModelComponentData;
			_this.schema = _schema$a;
			_this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);

			_this.on('beforeremove', _this.onRemove, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = ModelComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, _data, properties) {
			properties = ['material', 'materialAsset', 'asset', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'type', 'mapping', 'layers', 'isStatic', 'batchGroupId'];

			if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
				_data.batchGroupId = -1;
			}

			if (_data.layers && _data.layers.length) {
				_data.layers = _data.layers.slice(0);
			}

			for (var i = 0; i < properties.length; i++) {
				if (_data.hasOwnProperty(properties[i])) {
					component[properties[i]] = _data[properties[i]];
				}
			}

			if (_data.aabbCenter && _data.aabbHalfExtents) {
				component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
			}

			_ComponentSystem.prototype.initializeComponentData.call(this, component, _data, ['enabled']);
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var data = {
				type: entity.model.type,
				asset: entity.model.asset,
				castShadows: entity.model.castShadows,
				receiveShadows: entity.model.receiveShadows,
				castShadowsLightmap: entity.model.castShadowsLightmap,
				lightmapped: entity.model.lightmapped,
				lightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,
				isStatic: entity.model.isStatic,
				enabled: entity.model.enabled,
				layers: entity.model.layers,
				batchGroupId: entity.model.batchGroupId,
				mapping: extend({}, entity.model.mapping)
			};
			var materialAsset = entity.model.materialAsset;

			if (!(materialAsset instanceof Asset) && materialAsset != null) {
				materialAsset = this.app.assets.get(materialAsset);
			}

			var material = entity.model.material;

			if (!material || material === this.defaultMaterial || !materialAsset || material === materialAsset.resource) {
				data.materialAsset = materialAsset;
			}

			var component = this.addComponent(clone, data);

			if (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {
				component.model = entity.model.model.clone();
				component._clonedModel = true;
			}

			if (!data.materialAsset) component.material = material;

			if (entity.model.model) {
				var meshInstances = entity.model.model.meshInstances;
				var meshInstancesClone = component.model.meshInstances;

				for (var i = 0; i < meshInstances.length; i++) {
					meshInstancesClone[i].mask = meshInstances[i].mask;
					meshInstancesClone[i].material = meshInstances[i].material;
					meshInstancesClone[i].layer = meshInstances[i].layer;
					meshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;
				}
			}

			if (entity.model.customAabb) {
				component.customAabb = entity.model.customAabb.clone();
			}

			return component;
		};

		_proto.onRemove = function onRemove(entity, component) {
			component.onRemove();
		};

		return ModelComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ModelComponent.prototype, _schema$a);

	var RenderComponent = function (_Component) {
		_inheritsLoose(RenderComponent, _Component);

		function RenderComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._type = 'asset';
			_this._castShadows = true;
			_this._receiveShadows = true;
			_this._castShadowsLightmap = true;
			_this._lightmapped = false;
			_this._lightmapSizeMultiplier = 1;
			_this._isStatic = false;
			_this._batchGroupId = -1;
			_this._layers = [LAYERID_WORLD];
			_this._renderStyle = RENDERSTYLE_SOLID;
			_this._meshInstances = [];
			_this._customAabb = null;
			_this._area = null;
			_this._assetReference = [];
			_this._materialReferences = [];
			_this._material = void 0;
			_this._rootBone = void 0;
			_this._rootBone = new EntityReference(_assertThisInitialized(_this), 'rootBone');

			_this._rootBone.on('set:entity', _this._onSetRootBone, _assertThisInitialized(_this));

			_this._assetReference = new AssetReference('asset', _assertThisInitialized(_this), system.app.assets, {
				add: _this._onRenderAssetAdded,
				load: _this._onRenderAssetLoad,
				remove: _this._onRenderAssetRemove,
				unload: _this._onRenderAssetUnload
			}, _assertThisInitialized(_this));
			_this._material = system.defaultMaterial;
			entity.on('remove', _this.onRemoveChild, _assertThisInitialized(_this));
			entity.on('removehierarchy', _this.onRemoveChild, _assertThisInitialized(_this));
			entity.on('insert', _this.onInsertChild, _assertThisInitialized(_this));
			entity.on('inserthierarchy', _this.onInsertChild, _assertThisInitialized(_this));
			return _this;
		}

		var _proto = RenderComponent.prototype;

		_proto.assignAsset = function assignAsset(asset) {
			var id = asset instanceof Asset ? asset.id : asset;
			this._assetReference.id = id;
		};

		_proto._onSetRootBone = function _onSetRootBone(entity) {
			if (entity) {
				this._onRootBoneChanged();
			}
		};

		_proto._onRootBoneChanged = function _onRootBoneChanged() {
			this._clearSkinInstances();

			if (this.enabled && this.entity.enabled) {
				this._cloneSkinInstances();
			}
		};

		_proto.destroyMeshInstances = function destroyMeshInstances() {
			var meshInstances = this._meshInstances;

			if (meshInstances) {
				this.removeFromLayers();

				this._clearSkinInstances();

				for (var i = 0; i < meshInstances.length; i++) {
					meshInstances[i].destroy();
				}

				this._meshInstances.length = 0;
			}
		};

		_proto.addToLayers = function addToLayers() {
			var layers = this.system.app.scene.layers;

			for (var i = 0; i < this._layers.length; i++) {
				var layer = layers.getLayerById(this._layers[i]);

				if (layer) {
					layer.addMeshInstances(this._meshInstances);
				}
			}
		};

		_proto.removeFromLayers = function removeFromLayers() {
			if (this._meshInstances && this._meshInstances.length) {
				var layers = this.system.app.scene.layers;

				for (var i = 0; i < this._layers.length; i++) {
					var layer = layers.getLayerById(this._layers[i]);

					if (layer) {
						layer.removeMeshInstances(this._meshInstances);
					}
				}
			}
		};

		_proto.onRemoveChild = function onRemoveChild() {
			this.removeFromLayers();
		};

		_proto.onInsertChild = function onInsertChild() {
			if (this._meshInstances && this.enabled && this.entity.enabled) {
				this.addToLayers();
			}
		};

		_proto.onRemove = function onRemove() {
			this.destroyMeshInstances();
			this.asset = null;
			this.materialAsset = null;
			this._assetReference.id = null;

			for (var i = 0; i < this._materialReferences.length; i++) {
				this._materialReferences[i].id = null;
			}

			this.entity.off('remove', this.onRemoveChild, this);
			this.entity.off('insert', this.onInsertChild, this);
		};

		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addToLayers();
			oldComp.off("add", this.onLayerAdded, this);
			oldComp.off("remove", this.onLayerRemoved, this);
			newComp.on("add", this.onLayerAdded, this);
			newComp.on("remove", this.onLayerRemoved, this);
		};

		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addMeshInstances(this._meshInstances);
		};

		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances(this._meshInstances);
		};

		_proto.onEnable = function onEnable() {
			var app = this.system.app;
			var scene = app.scene;

			this._rootBone.onParentComponentEnable();

			this._cloneSkinInstances();

			scene.on("set:layers", this.onLayersChanged, this);

			if (scene.layers) {
				scene.layers.on("add", this.onLayerAdded, this);
				scene.layers.on("remove", this.onLayerRemoved, this);
			}

			var isAsset = this._type === 'asset';

			if (this._meshInstances && this._meshInstances.length) {
				this.addToLayers();
			} else if (isAsset && this.asset) {
				this._onRenderAssetAdded();
			}

			for (var i = 0; i < this._materialReferences.length; i++) {
				if (this._materialReferences[i].asset) {
					this.system.app.assets.load(this._materialReferences[i].asset);
				}
			}

			if (this._batchGroupId >= 0) {
				app.batcher.insert(BatchGroup.RENDER, this.batchGroupId, this.entity);
			}
		};

		_proto.onDisable = function onDisable() {
			var app = this.system.app;
			var scene = app.scene;
			scene.off("set:layers", this.onLayersChanged, this);

			if (scene.layers) {
				scene.layers.off("add", this.onLayerAdded, this);
				scene.layers.off("remove", this.onLayerRemoved, this);
			}

			if (this._batchGroupId >= 0) {
				app.batcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
			}

			this.removeFromLayers();
		};

		_proto.hide = function hide() {
			if (this._meshInstances) {
				for (var i = 0; i < this._meshInstances.length; i++) {
					this._meshInstances[i].visible = false;
				}
			}
		};

		_proto.show = function show() {
			if (this._meshInstances) {
				for (var i = 0; i < this._meshInstances.length; i++) {
					this._meshInstances[i].visible = true;
				}
			}
		};

		_proto._onRenderAssetAdded = function _onRenderAssetAdded() {
			if (!this._assetReference.asset) return;

			if (this._assetReference.asset.resource) {
				this._onRenderAssetLoad();
			} else if (this.enabled && this.entity.enabled) {
				this.system.app.assets.load(this._assetReference.asset);
			}
		};

		_proto._onRenderAssetLoad = function _onRenderAssetLoad() {
			this.destroyMeshInstances();

			if (this._assetReference.asset) {
				var render = this._assetReference.asset.resource;
				render.off('set:meshes', this._onSetMeshes, this);
				render.on('set:meshes', this._onSetMeshes, this);

				if (render.meshes) {
					this._onSetMeshes(render.meshes);
				}
			}
		};

		_proto._onSetMeshes = function _onSetMeshes(meshes) {
			this._cloneMeshes(meshes);
		};

		_proto._clearSkinInstances = function _clearSkinInstances() {
			for (var i = 0; i < this._meshInstances.length; i++) {
				var meshInstance = this._meshInstances[i];
				SkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);
				meshInstance.skinInstance = null;
			}
		};

		_proto._cloneSkinInstances = function _cloneSkinInstances() {
			if (this._meshInstances.length && this._rootBone.entity instanceof GraphNode) {
				for (var i = 0; i < this._meshInstances.length; i++) {
					var meshInstance = this._meshInstances[i];
					var mesh = meshInstance.mesh;

					if (mesh.skin && !mesh.skinInstance) {
						meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(mesh.skin, this._rootBone.entity, this.entity);
					}
				}
			}
		};

		_proto._cloneMeshes = function _cloneMeshes(meshes) {
			if (meshes && meshes.length) {
				var meshInstances = [];

				for (var i = 0; i < meshes.length; i++) {
					var mesh = meshes[i];
					var material = this._materialReferences[i] && this._materialReferences[i].asset && this._materialReferences[i].asset.resource;
					var meshInst = new MeshInstance(mesh, material || this.system.defaultMaterial, this.entity);
					meshInstances.push(meshInst);

					if (mesh.morph) {
						meshInst.morphInstance = new MorphInstance(mesh.morph);
					}
				}

				this.meshInstances = meshInstances;

				this._cloneSkinInstances();
			}
		};

		_proto._onRenderAssetUnload = function _onRenderAssetUnload() {
			if (this._type === 'asset') {
				this.destroyMeshInstances();
			}
		};

		_proto._onRenderAssetRemove = function _onRenderAssetRemove() {
			if (this._assetReference.asset && this._assetReference.asset.resource) {
				this._assetReference.asset.resource.off('set:meshes', this._onSetMeshes, this);
			}

			this._onRenderAssetUnload();
		};

		_proto._onMaterialAdded = function _onMaterialAdded(index, component, asset) {
			if (asset.resource) {
				this._onMaterialLoad(index, component, asset);
			} else {
				if (this.enabled && this.entity.enabled) {
					this.system.app.assets.load(asset);
				}
			}
		};

		_proto._updateMainMaterial = function _updateMainMaterial(index, material) {
			if (index === 0) {
				this.material = material;
			}
		};

		_proto._onMaterialLoad = function _onMaterialLoad(index, component, asset) {
			if (this._meshInstances[index]) {
				this._meshInstances[index].material = asset.resource;
			}

			this._updateMainMaterial(index, asset.resource);
		};

		_proto._onMaterialRemove = function _onMaterialRemove(index, component, asset) {
			if (this._meshInstances[index]) {
				this._meshInstances[index].material = this.system.defaultMaterial;
			}

			this._updateMainMaterial(index, this.system.defaultMaterial);
		};

		_proto._onMaterialUnload = function _onMaterialUnload(index, component, asset) {
			if (this._meshInstances[index]) {
				this._meshInstances[index].material = this.system.defaultMaterial;
			}

			this._updateMainMaterial(index, this.system.defaultMaterial);
		};

		_proto.resolveDuplicatedEntityReferenceProperties = function resolveDuplicatedEntityReferenceProperties(oldRender, duplicatedIdsMap) {
			if (oldRender.rootBone && duplicatedIdsMap[oldRender.rootBone]) {
				this.rootBone = duplicatedIdsMap[oldRender.rootBone];
			}

			this._clearSkinInstances();
		};

		_createClass(RenderComponent, [{
			key: "renderStyle",
			get: function get() {
				return this._renderStyle;
			},
			set: function set(renderStyle) {
				if (this._renderStyle !== renderStyle) {
					this._renderStyle = renderStyle;

					MeshInstance._prepareRenderStyleForArray(this._meshInstances, renderStyle);
				}
			}
		}, {
			key: "customAabb",
			get: function get() {
				return this._customAabb;
			},
			set: function set(value) {
				this._customAabb = value;
				var mi = this._meshInstances;

				if (mi) {
					for (var i = 0; i < mi.length; i++) {
						mi[i].setCustomAabb(this._customAabb);
					}
				}
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (this._type !== value) {
					this._area = null;
					this._type = value;
					this.destroyMeshInstances();

					if (value !== 'asset') {
						var material = this._material;

						if (!material || material === this.system.defaultMaterial) {
							material = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource;
						}

						var primData = getShapePrimitive(this.system.app.graphicsDevice, value);
						this._area = primData.area;
						this.meshInstances = [new MeshInstance(primData.mesh, material || this.system.defaultMaterial, this.entity)];
					}
				}
			}
		}, {
			key: "meshInstances",
			get: function get() {
				return this._meshInstances;
			},
			set: function set(value) {
				this.destroyMeshInstances();
				this._meshInstances = value;

				if (this._meshInstances) {
					var mi = this._meshInstances;

					for (var i = 0; i < mi.length; i++) {
						if (!mi[i].node) {
							mi[i].node = this.entity;
						}

						mi[i].castShadow = this._castShadows;
						mi[i].receiveShadow = this._receiveShadows;
						mi[i].isStatic = this._isStatic;
						mi[i].renderStyle = this._renderStyle;
						mi[i].setLightmapped(this._lightmapped);
						mi[i].setCustomAabb(this._customAabb);
					}

					if (this.enabled && this.entity.enabled) {
						this.addToLayers();
					}
				}
			}
		}, {
			key: "lightmapped",
			get: function get() {
				return this._lightmapped;
			},
			set: function set(value) {
				if (value !== this._lightmapped) {
					this._lightmapped = value;
					var mi = this._meshInstances;

					if (mi) {
						for (var i = 0; i < mi.length; i++) {
							mi[i].setLightmapped(value);
						}
					}
				}
			}
		}, {
			key: "castShadows",
			get: function get() {
				return this._castShadows;
			},
			set: function set(value) {
				if (this._castShadows !== value) {
					var mi = this._meshInstances;

					if (mi) {
						var layers = this.layers;
						var scene = this.system.app.scene;

						if (this._castShadows && !value) {
							for (var i = 0; i < layers.length; i++) {
								var layer = scene.layers.getLayerById(this.layers[i]);

								if (layer) {
									layer.removeShadowCasters(mi);
								}
							}
						}

						for (var _i = 0; _i < mi.length; _i++) {
							mi[_i].castShadow = value;
						}

						if (!this._castShadows && value) {
							for (var _i2 = 0; _i2 < layers.length; _i2++) {
								var _layer = scene.layers.getLayerById(layers[_i2]);

								if (_layer) {
									_layer.addShadowCasters(mi);
								}
							}
						}
					}

					this._castShadows = value;
				}
			}
		}, {
			key: "receiveShadows",
			get: function get() {
				return this._receiveShadows;
			},
			set: function set(value) {
				if (this._receiveShadows !== value) {
					this._receiveShadows = value;
					var mi = this._meshInstances;

					if (mi) {
						for (var i = 0; i < mi.length; i++) {
							mi[i].receiveShadow = value;
						}
					}
				}
			}
		}, {
			key: "castShadowsLightmap",
			get: function get() {
				return this._castShadowsLightmap;
			},
			set: function set(value) {
				this._castShadowsLightmap = value;
			}
		}, {
			key: "lightmapSizeMultiplier",
			get: function get() {
				return this._lightmapSizeMultiplier;
			},
			set: function set(value) {
				this._lightmapSizeMultiplier = value;
			}
		}, {
			key: "isStatic",
			get: function get() {
				return this._isStatic;
			},
			set: function set(value) {
				if (this._isStatic !== value) {
					this._isStatic = value;
					var mi = this._meshInstances;

					if (mi) {
						for (var i = 0; i < mi.length; i++) {
							mi[i].isStatic = value;
						}
					}
				}
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(value) {
				var layers = this.system.app.scene.layers;
				var layer;

				if (this._meshInstances) {
					for (var i = 0; i < this._layers.length; i++) {
						layer = layers.getLayerById(this._layers[i]);

						if (layer) {
							layer.removeMeshInstances(this._meshInstances);
						}
					}
				}

				this._layers.length = 0;

				for (var _i3 = 0; _i3 < value.length; _i3++) {
					this._layers[_i3] = value[_i3];
				}

				if (!this.enabled || !this.entity.enabled || !this._meshInstances) return;

				for (var _i4 = 0; _i4 < this._layers.length; _i4++) {
					layer = layers.getLayerById(this._layers[_i4]);

					if (layer) {
						layer.addMeshInstances(this._meshInstances);
					}
				}
			}
		}, {
			key: "batchGroupId",
			get: function get() {
				return this._batchGroupId;
			},
			set: function set(value) {
				if (this._batchGroupId !== value) {
					var batcher = this.system.app.batcher;

					if (this.entity.enabled && this._batchGroupId >= 0) {
						batcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
					}

					if (this.entity.enabled && value >= 0) {
						batcher.insert(BatchGroup.RENDER, value, this.entity);
					}

					if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
						this.addToLayers();
					}

					this._batchGroupId = value;
				}
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(value) {
				if (this._material !== value) {
					this._material = value;

					if (this._meshInstances && this._type !== 'asset') {
						for (var i = 0; i < this._meshInstances.length; i++) {
							this._meshInstances[i].material = value;
						}
					}
				}
			}
		}, {
			key: "materialAssets",
			get: function get() {
				return this._materialReferences.map(function (ref) {
					return ref.id;
				});
			},
			set: function set(value) {
				if (value === void 0) {
					value = [];
				}

				if (this._materialReferences.length > value.length) {
					for (var i = value.length; i < this._materialReferences.length; i++) {
						this._materialReferences[i].id = null;
					}

					this._materialReferences.length = value.length;
				}

				for (var _i5 = 0; _i5 < value.length; _i5++) {
					if (!this._materialReferences[_i5]) {
						this._materialReferences.push(new AssetReference(_i5, this, this.system.app.assets, {
							add: this._onMaterialAdded,
							load: this._onMaterialLoad,
							remove: this._onMaterialRemove,
							unload: this._onMaterialUnload
						}, this));
					}

					if (value[_i5]) {
						var id = value[_i5] instanceof Asset ? value[_i5].id : value[_i5];

						if (this._materialReferences[_i5].id !== id) {
							this._materialReferences[_i5].id = id;
						}

						if (this._materialReferences[_i5].asset) {
							this._onMaterialAdded(_i5, this, this._materialReferences[_i5].asset);
						}
					} else {
						this._materialReferences[_i5].id = null;

						if (this._meshInstances[_i5]) {
							this._meshInstances[_i5].material = this.system.defaultMaterial;
						}
					}
				}
			}
		}, {
			key: "asset",
			get: function get() {
				return this._assetReference.id;
			},
			set: function set(value) {
				var id = value instanceof Asset ? value.id : value;
				if (this._assetReference.id === id) return;

				if (this._assetReference.asset && this._assetReference.asset.resource) {
					this._onRenderAssetRemove();
				}

				this._assetReference.id = id;

				if (this._assetReference.asset) {
					this._onRenderAssetAdded();
				}
			}
		}]);

		return RenderComponent;
	}(Component);

	var RenderComponentData = function RenderComponentData() {
		this.enabled = true;
		this.rootBone = null;
	};

	var _schema$9 = [{
		name: 'rootBone',
		type: 'entity'
	}, 'enabled'];
	var _properties = ['material', 'meshInstances', 'asset', 'materialAssets', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'renderStyle', 'type', 'layers', 'isStatic', 'batchGroupId'];

	var RenderComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(RenderComponentSystem, _ComponentSystem);

		function RenderComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'render';
			_this.ComponentType = RenderComponent;
			_this.DataType = RenderComponentData;
			_this.schema = _schema$9;
			_this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);

			_this.on('beforeremove', _this.onRemove, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = RenderComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, _data, properties) {
			if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
				_data.batchGroupId = -1;
			}

			if (_data.layers && _data.layers.length) {
				_data.layers = _data.layers.slice(0);
			}

			for (var i = 0; i < _properties.length; i++) {
				if (_data.hasOwnProperty(_properties[i])) {
					component[_properties[i]] = _data[_properties[i]];
				}
			}

			if (_data.aabbCenter && _data.aabbHalfExtents) {
				component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
			}

			_ComponentSystem.prototype.initializeComponentData.call(this, component, _data, _schema$9);
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var data = {};

			for (var i = 0; i < _properties.length; i++) {
				data[_properties[i]] = entity.render[_properties[i]];
			}

			data.enabled = entity.render.enabled;
			delete data.meshInstances;
			var component = this.addComponent(clone, data);
			var srcMeshInstances = entity.render.meshInstances;
			var meshes = srcMeshInstances.map(function (mi) {
				return mi.mesh;
			});

			component._onSetMeshes(meshes);

			for (var m = 0; m < srcMeshInstances.length; m++) {
				component.meshInstances[m].material = srcMeshInstances[m].material;
			}

			if (entity.render.customAabb) {
				component.customAabb = entity.render.customAabb.clone();
			}

			return component;
		};

		_proto.onRemove = function onRemove(entity, component) {
			component.onRemove();
		};

		return RenderComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(RenderComponent.prototype, _schema$9);

	var nonUniformScale;
	var uniformScale = 1;
	var particleTexChannels$1 = 4;
	var rotMat = new Mat4();
	var rotMatInv = new Mat4();
	var randomPosTformed = new Vec3();
	var randomPos = new Vec3();
	var rndFactor3Vec = new Vec3();
	var particlePosPrev = new Vec3();
	var velocityVec = new Vec3();
	var localVelocityVec = new Vec3();
	var velocityVec2 = new Vec3();
	var localVelocityVec2 = new Vec3();
	var radialVelocityVec = new Vec3();
	var particlePos = new Vec3();
	var particleFinalPos = new Vec3();
	var moveDirVec = new Vec3();
	var tmpVec3$1 = new Vec3();

	function frac(f) {
		return f - Math.floor(f);
	}

	function saturate$1(x) {
		return Math.max(Math.min(x, 1), 0);
	}

	function glMod(x, y) {
		return x - y * Math.floor(x / y);
	}

	function encodeFloatRGBA(v) {
		var encX = frac(v);
		var encY = frac(255.0 * v);
		var encZ = frac(65025.0 * v);
		var encW = frac(160581375.0 * v);
		encX -= encY / 255.0;
		encY -= encZ / 255.0;
		encZ -= encW / 255.0;
		encW -= encW / 255.0;
		return [encX, encY, encZ, encW];
	}

	function encodeFloatRG(v) {
		var encX = frac(v);
		var encY = frac(255.0 * v);
		encX -= encY / 255.0;
		encY -= encY / 255.0;
		return [encX, encY];
	}

	var ParticleCPUUpdater = function () {
		function ParticleCPUUpdater(emitter) {
			this._emitter = emitter;
		}

		var _proto = ParticleCPUUpdater.prototype;

		_proto.calcSpawnPosition = function calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {
			var emitter = this._emitter;
			var rX = Math.random();
			var rY = Math.random();
			var rZ = Math.random();
			var rW = Math.random();

			if (emitter.useCpu) {
				particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rX;
				particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rY;
				particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rZ;
			}

			randomPos.x = rX - 0.5;
			randomPos.y = rY - 0.5;
			randomPos.z = rZ - 0.5;

			if (emitter.emitterShape === EMITTERSHAPE_BOX) {
				var max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));
				var edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];
				var edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];
				var edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];
				randomPos.x = edgeX * (max === Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);
				randomPos.y = edgeY * (max === Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);
				randomPos.z = edgeZ * (max === Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);
				if (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));else randomPosTformed.copy(spawnMatrix.transformPoint(randomPos));
			} else {
				randomPos.normalize();
				var spawnBoundsSphereInnerRatio = emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;
				var r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
				if (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r * emitter.emitterRadius));else randomPosTformed.copy(randomPos.mulScalar(r * emitter.emitterRadius));
			}

			var particleRate = math.lerp(emitter.rate, emitter.rate2, rX);
			var startSpawnTime = -particleRate * i;

			if (emitter.pack8) {
				var packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;
				var packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;
				var packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;
				var packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
				packA = packA % (Math.PI * 2) / (Math.PI * 2);
				var rg0 = encodeFloatRG(packX);
				particleTex[i * particleTexChannels$1] = rg0[0];
				particleTex[i * particleTexChannels$1 + 1] = rg0[1];
				var ba0 = encodeFloatRG(packY);
				particleTex[i * particleTexChannels$1 + 2] = ba0[0];
				particleTex[i * particleTexChannels$1 + 3] = ba0[1];
				var rg1 = encodeFloatRG(packZ);
				particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1] = rg1[0];
				particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1] = rg1[1];
				var ba1 = encodeFloatRG(packA);
				particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1] = ba1[0];
				particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = ba1[1];
				var a2 = 1.0;
				particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 2] = a2;
				var maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * Math.max(emitter.rate, emitter.rate2));
				var maxPosLife = emitter.lifetime + 1.0;
				startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);
				var rgba3 = encodeFloatRGBA(startSpawnTime);
				particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[0];
				particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[1];
				particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[2];
				particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[3];
			} else {
				particleTex[i * particleTexChannels$1] = randomPosTformed.x;
				particleTex[i * particleTexChannels$1 + 1] = randomPosTformed.y;
				particleTex[i * particleTexChannels$1 + 2] = randomPosTformed.z;
				particleTex[i * particleTexChannels$1 + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
				particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = startSpawnTime;
			}
		};

		_proto.update = function update(data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {
			var a, b, c;
			var emitter = this._emitter;

			if (emitter.meshInstance.node) {
				var fullMat = emitter.meshInstance.node.worldTransform;

				for (var j = 0; j < 12; j++) {
					rotMat.data[j] = fullMat.data[j];
				}

				rotMatInv.copy(rotMat);
				rotMatInv.invert();
				nonUniformScale = emitter.meshInstance.node.localScale;
				uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);
			}

			emitterPos = emitter.meshInstance.node === null || emitter.localSpace ? Vec3.ZERO : emitter.meshInstance.node.getPosition();
			var posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;
			var vertSize = !emitter.useMesh ? 15 : 17;
			var cf, cc;
			var rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;
			var precision1 = emitter.precision - 1;

			for (var i = 0; i < emitter.numParticles; i++) {
				var id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);
				var rndFactor = particleTex[id * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1];
				rndFactor3Vec.x = rndFactor;
				rndFactor3Vec.y = particleTex[id * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1];
				rndFactor3Vec.z = particleTex[id * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1];
				var particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;
				var particleLifetime = emitter.lifetime;
				var life = particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] + delta;
				var nlife = saturate$1(life / particleLifetime);
				var scale = 0;
				var alphaDiv = 0;
				var angle = 0;
				var respawn = life - delta <= 0.0 || life >= particleLifetime;

				if (respawn) {
					this.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);
				}

				var particleEnabled = life > 0.0 && life < particleLifetime;

				if (particleEnabled) {
					c = nlife * precision1;
					cf = Math.floor(c);
					cc = Math.ceil(c);
					c %= 1;
					a = emitter.qRotSpeed[cf];
					b = emitter.qRotSpeed[cc];
					rotSpeed = a + (b - a) * c;
					a = emitter.qRotSpeed2[cf];
					b = emitter.qRotSpeed2[cc];
					rotSpeed2 = a + (b - a) * c;
					a = emitter.qScale[cf];
					b = emitter.qScale[cc];
					scale = a + (b - a) * c;
					a = emitter.qScale2[cf];
					b = emitter.qScale2[cc];
					scale2 = a + (b - a) * c;
					a = emitter.qAlpha[cf];
					b = emitter.qAlpha[cc];
					alpha = a + (b - a) * c;
					a = emitter.qAlpha2[cf];
					b = emitter.qAlpha2[cc];
					alpha2 = a + (b - a) * c;
					a = emitter.qRadialSpeed[cf];
					b = emitter.qRadialSpeed[cc];
					radialSpeed = a + (b - a) * c;
					a = emitter.qRadialSpeed2[cf];
					b = emitter.qRadialSpeed2[cc];
					radialSpeed2 = a + (b - a) * c;
					radialSpeed += (radialSpeed2 - radialSpeed) * (rndFactor * 100.0 % 1.0);
					particlePosPrev.x = particleTex[id * particleTexChannels$1];
					particlePosPrev.y = particleTex[id * particleTexChannels$1 + 1];
					particlePosPrev.z = particleTex[id * particleTexChannels$1 + 2];
					if (!emitter.localSpace) radialVelocityVec.copy(particlePosPrev).sub(emitterPos);else radialVelocityVec.copy(particlePosPrev);
					radialVelocityVec.normalize().mulScalar(radialSpeed);
					cf *= 3;
					cc *= 3;
					a = emitter.qLocalVelocity[cf];
					b = emitter.qLocalVelocity[cc];
					localVelocityVec.x = a + (b - a) * c;
					a = emitter.qLocalVelocity[cf + 1];
					b = emitter.qLocalVelocity[cc + 1];
					localVelocityVec.y = a + (b - a) * c;
					a = emitter.qLocalVelocity[cf + 2];
					b = emitter.qLocalVelocity[cc + 2];
					localVelocityVec.z = a + (b - a) * c;
					a = emitter.qLocalVelocity2[cf];
					b = emitter.qLocalVelocity2[cc];
					localVelocityVec2.x = a + (b - a) * c;
					a = emitter.qLocalVelocity2[cf + 1];
					b = emitter.qLocalVelocity2[cc + 1];
					localVelocityVec2.y = a + (b - a) * c;
					a = emitter.qLocalVelocity2[cf + 2];
					b = emitter.qLocalVelocity2[cc + 2];
					localVelocityVec2.z = a + (b - a) * c;
					a = emitter.qVelocity[cf];
					b = emitter.qVelocity[cc];
					velocityVec.x = a + (b - a) * c;
					a = emitter.qVelocity[cf + 1];
					b = emitter.qVelocity[cc + 1];
					velocityVec.y = a + (b - a) * c;
					a = emitter.qVelocity[cf + 2];
					b = emitter.qVelocity[cc + 2];
					velocityVec.z = a + (b - a) * c;
					a = emitter.qVelocity2[cf];
					b = emitter.qVelocity2[cc];
					velocityVec2.x = a + (b - a) * c;
					a = emitter.qVelocity2[cf + 1];
					b = emitter.qVelocity2[cc + 1];
					velocityVec2.y = a + (b - a) * c;
					a = emitter.qVelocity2[cf + 2];
					b = emitter.qVelocity2[cc + 2];
					velocityVec2.z = a + (b - a) * c;
					localVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;
					localVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;
					localVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;

					if (emitter.initialVelocity > 0) {
						if (emitter.emitterShape === EMITTERSHAPE_SPHERE) {
							randomPos.copy(rndFactor3Vec).mulScalar(2).sub(Vec3.ONE).normalize();
							localVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));
						} else {
							localVelocityVec.add(Vec3.FORWARD.mulScalar(emitter.initialVelocity));
						}
					}

					velocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;
					velocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;
					velocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;
					rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;
					scale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;
					alphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);

					if (emitter.meshInstance.node) {
						if (!emitter.localSpace) {
							rotMat.transformPoint(localVelocityVec, localVelocityVec);
						} else {
							localVelocityVec.x /= nonUniformScale.x;
							localVelocityVec.y /= nonUniformScale.y;
							localVelocityVec.z /= nonUniformScale.z;
						}
					}

					if (!emitter.localSpace) {
						localVelocityVec.add(velocityVec.mul(nonUniformScale));
						localVelocityVec.add(radialVelocityVec.mul(nonUniformScale));
					} else {
						rotMatInv.transformPoint(velocityVec, velocityVec);
						localVelocityVec.add(velocityVec).add(radialVelocityVec);
					}

					moveDirVec.copy(localVelocityVec);
					particlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));
					particleFinalPos.copy(particlePos);
					particleTex[id * particleTexChannels$1] = particleFinalPos.x;
					particleTex[id * particleTexChannels$1 + 1] = particleFinalPos.y;
					particleTex[id * particleTexChannels$1 + 2] = particleFinalPos.z;
					particleTex[id * particleTexChannels$1 + 3] += rotSpeed * delta;

					if (emitter.wrap && emitter.wrapBounds) {
						if (!emitter.localSpace) particleFinalPos.sub(emitterPos);
						particleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;
						particleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;
						particleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;
						if (!emitter.localSpace) particleFinalPos.add(emitterPos);
					}

					if (emitter.sort > 0) {
						if (emitter.sort === 1) {
							tmpVec3$1.copy(particleFinalPos).sub(posCam);
							emitter.particleDistance[id] = -(tmpVec3$1.x * tmpVec3$1.x + tmpVec3$1.y * tmpVec3$1.y + tmpVec3$1.z * tmpVec3$1.z);
						} else if (emitter.sort === 2) {
							emitter.particleDistance[id] = life;
						} else if (emitter.sort === 3) {
							emitter.particleDistance[id] = -life;
						}
					}
				}

				if (isOnStop) {
					if (life < 0) {
						particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = -1;
					}
				} else {
					if (life >= particleLifetime) {
						life -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);
						particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = emitter.loop ? 1 : -1;
					}

					if (life < 0 && emitter.loop) {
						particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = 1;
					}
				}

				if (particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] < 0) particleEnabled = false;
				particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = life;

				for (var v = 0; v < emitter.numParticleVerts; v++) {
					var vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);
					var quadX = emitter.vbCPU[vbOffset];
					var quadY = emitter.vbCPU[vbOffset + 1];
					var quadZ = emitter.vbCPU[vbOffset + 2];

					if (!particleEnabled) {
						quadX = quadY = quadZ = 0;
					}

					var w = i * emitter.numParticleVerts * vertSize + v * vertSize;
					data[w] = particleFinalPos.x;
					data[w + 1] = particleFinalPos.y;
					data[w + 2] = particleFinalPos.z;
					data[w + 3] = nlife;
					data[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels$1 + 3];
					data[w + 5] = scale;
					data[w + 6] = alphaDiv;
					data[w + 7] = moveDirVec.x;
					data[w + 8] = quadX;
					data[w + 9] = quadY;
					data[w + 10] = quadZ;
					data[w + 11] = moveDirVec.y;
					data[w + 12] = id;
					data[w + 13] = moveDirVec.z;
					data[w + 14] = emitter.vbCPU[vbOffset + 3];

					if (emitter.useMesh) {
						data[w + 15] = emitter.vbCPU[vbOffset + 4];
						data[w + 16] = emitter.vbCPU[vbOffset + 5];
					}
				}
			}

			if (emitter.sort > PARTICLESORT_NONE && emitter.camera) {
				var vbStride = emitter.useMesh ? 6 : 4;
				var particleDistance = emitter.particleDistance;

				for (var _i = 0; _i < emitter.numParticles; _i++) {
					vbToSort[_i][0] = _i;
					vbToSort[_i][1] = particleDistance[Math.floor(emitter.vbCPU[_i * emitter.numParticleVerts * vbStride + 3])];
				}

				emitter.vbOld.set(emitter.vbCPU);
				vbToSort.sort(function (p1, p2) {
					return p1[1] - p2[1];
				});

				for (var _i2 = 0; _i2 < emitter.numParticles; _i2++) {
					var src = vbToSort[_i2][0] * emitter.numParticleVerts * vbStride;
					var dest = _i2 * emitter.numParticleVerts * vbStride;

					for (var _j = 0; _j < emitter.numParticleVerts * vbStride; _j++) {
						emitter.vbCPU[dest + _j] = emitter.vbOld[src + _j];
					}
				}
			}
		};

		return ParticleCPUUpdater;
	}();

	var spawnMatrix3 = new Mat3();
	var emitterMatrix3 = new Mat3();
	var emitterMatrix3Inv = new Mat3();

	var ParticleGPUUpdater = function () {
		function ParticleGPUUpdater(emitter, gd) {
			this._emitter = emitter;
			this.frameRandomUniform = new Float32Array(3);
			this.emitterPosUniform = new Float32Array(3);
			this.emitterScaleUniform = new Float32Array([1, 1, 1]);
			this.worldBoundsMulUniform = new Float32Array(3);
			this.worldBoundsAddUniform = new Float32Array(3);
			this.inBoundsSizeUniform = new Float32Array(3);
			this.inBoundsCenterUniform = new Float32Array(3);
			this.constantParticleTexIN = gd.scope.resolve("particleTexIN");
			this.constantParticleTexOUT = gd.scope.resolve("particleTexOUT");
			this.constantEmitterPos = gd.scope.resolve("emitterPos");
			this.constantEmitterScale = gd.scope.resolve("emitterScale");
			this.constantSpawnBounds = gd.scope.resolve("spawnBounds");
			this.constantSpawnPosInnerRatio = gd.scope.resolve("spawnPosInnerRatio");
			this.constantSpawnBoundsSphere = gd.scope.resolve("spawnBoundsSphere");
			this.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve("spawnBoundsSphereInnerRatio");
			this.constantInitialVelocity = gd.scope.resolve("initialVelocity");
			this.constantFrameRandom = gd.scope.resolve("frameRandom");
			this.constantDelta = gd.scope.resolve("delta");
			this.constantRate = gd.scope.resolve("rate");
			this.constantRateDiv = gd.scope.resolve("rateDiv");
			this.constantLifetime = gd.scope.resolve("lifetime");
			this.constantGraphSampleSize = gd.scope.resolve("graphSampleSize");
			this.constantGraphNumSamples = gd.scope.resolve("graphNumSamples");
			this.constantInternalTex0 = gd.scope.resolve("internalTex0");
			this.constantInternalTex1 = gd.scope.resolve("internalTex1");
			this.constantInternalTex2 = gd.scope.resolve("internalTex2");
			this.constantInternalTex3 = gd.scope.resolve("internalTex3");
			this.constantEmitterMatrix = gd.scope.resolve("emitterMatrix");
			this.constantEmitterMatrixInv = gd.scope.resolve("emitterMatrixInv");
			this.constantNumParticles = gd.scope.resolve("numParticles");
			this.constantNumParticlesPot = gd.scope.resolve("numParticlesPot");
			this.constantLocalVelocityDivMult = gd.scope.resolve("localVelocityDivMult");
			this.constantVelocityDivMult = gd.scope.resolve("velocityDivMult");
			this.constantRotSpeedDivMult = gd.scope.resolve("rotSpeedDivMult");
			this.constantSeed = gd.scope.resolve("seed");
			this.constantStartAngle = gd.scope.resolve("startAngle");
			this.constantStartAngle2 = gd.scope.resolve("startAngle2");
			this.constantOutBoundsMul = gd.scope.resolve("outBoundsMul");
			this.constantOutBoundsAdd = gd.scope.resolve("outBoundsAdd");
			this.constantInBoundsSize = gd.scope.resolve("inBoundsSize");
			this.constantInBoundsCenter = gd.scope.resolve("inBoundsCenter");
			this.constantMaxVel = gd.scope.resolve("maxVel");
			this.constantFaceTangent = gd.scope.resolve("faceTangent");
			this.constantFaceBinorm = gd.scope.resolve("faceBinorm");
		}

		var _proto = ParticleGPUUpdater.prototype;

		_proto._setInputBounds = function _setInputBounds() {
			this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;
			this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;
			this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;
			this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
			this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;
			this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;
			this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;
			this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);
		};

		_proto.randomize = function randomize() {
			this.frameRandomUniform[0] = Math.random();
			this.frameRandomUniform[1] = Math.random();
			this.frameRandomUniform[2] = Math.random();
		};

		_proto.update = function update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {
			DebugGraphics.pushGpuMarker(device, "ParticleGPU");
			var emitter = this._emitter;
			device.setBlending(false);
			device.setColorWrite(true, true, true, true);
			device.setCullMode(CULLFACE_NONE);
			device.setDepthTest(false);
			device.setDepthWrite(false);
			this.randomize();
			this.constantGraphSampleSize.setValue(1.0 / emitter.precision);
			this.constantGraphNumSamples.setValue(emitter.precision);
			this.constantNumParticles.setValue(emitter.numParticles);
			this.constantNumParticlesPot.setValue(emitter.numParticlesPot);
			this.constantInternalTex0.setValue(emitter.internalTex0);
			this.constantInternalTex1.setValue(emitter.internalTex1);
			this.constantInternalTex2.setValue(emitter.internalTex2);
			this.constantInternalTex3.setValue(emitter.internalTex3);
			var node = emitter.meshInstance.node;
			var emitterScale = node === null ? Vec3.ONE : node.localScale;

			if (emitter.pack8) {
				this.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;
				this.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;
				this.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;
				this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
				this.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;
				this.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;
				this.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;
				this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);

				this._setInputBounds();

				var maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);
				maxVel = Math.max(maxVel, 1);
				this.constantMaxVel.setValue(maxVel);
			}

			var emitterPos = node === null || emitter.localSpace ? Vec3.ZERO : node.getPosition();
			var emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();

			if (emitter.emitterShape === EMITTERSHAPE_BOX) {
				spawnMatrix3.setFromMat4(spawnMatrix);
				this.constantSpawnBounds.setValue(spawnMatrix3.data);
				this.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);
			} else {
				this.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);
				this.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);
			}

			this.constantInitialVelocity.setValue(emitter.initialVelocity);
			emitterMatrix3.setFromMat4(emitterMatrix);
			emitterMatrix.invertTo3x3(emitterMatrix3Inv);
			this.emitterPosUniform[0] = emitterPos.x;
			this.emitterPosUniform[1] = emitterPos.y;
			this.emitterPosUniform[2] = emitterPos.z;
			this.constantEmitterPos.setValue(this.emitterPosUniform);
			this.constantFrameRandom.setValue(this.frameRandomUniform);
			this.constantDelta.setValue(delta);
			this.constantRate.setValue(emitter.rate);
			this.constantRateDiv.setValue(emitter.rate2 - emitter.rate);
			this.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);
			this.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);
			this.constantSeed.setValue(emitter.seed);
			this.constantLifetime.setValue(emitter.lifetime);
			this.emitterScaleUniform[0] = emitterScale.x;
			this.emitterScaleUniform[1] = emitterScale.y;
			this.emitterScaleUniform[2] = emitterScale.z;
			this.constantEmitterScale.setValue(this.emitterScaleUniform);
			this.constantEmitterMatrix.setValue(emitterMatrix3.data);
			this.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);
			this.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);
			this.constantVelocityDivMult.setValue(emitter.velocityUMax);
			this.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);
			var texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;
			texIN = emitter.beenReset ? emitter.particleTexStart : texIN;
			var texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;
			this.constantParticleTexIN.setValue(texIN);
			drawQuadWithShader(device, emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT, !isOnStop ? emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn : emitter.shaderParticleUpdateOnStop);
			emitter.material.setParameter("particleTexOUT", texIN);
			emitter.material.setParameter("particleTexIN", texOUT);
			emitter.beenReset = false;
			emitter.swapTex = !emitter.swapTex;
			device.setDepthTest(true);
			device.setDepthWrite(true);
			emitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);
			emitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);
			if (emitter.pack8) this._setInputBounds();
			DebugGraphics.popGpuMarker(device);
		};

		return ParticleGPUUpdater;
	}();

	var particleVerts = [[-1, -1], [1, -1], [1, 1], [-1, 1]];

	function _createTexture(device, width, height, pixelData, format, mult8Bit, filter) {
		if (format === void 0) {
			format = PIXELFORMAT_RGBA32F;
		}

		var mipFilter = FILTER_NEAREST;
		if (filter && format === PIXELFORMAT_R8_G8_B8_A8) mipFilter = FILTER_LINEAR;
		var texture = new Texture(device, {
			width: width,
			height: height,
			format: format,
			cubemap: false,
			mipmaps: false,
			minFilter: mipFilter,
			magFilter: mipFilter,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		texture.name = "PSTexture";
		var pixels = texture.lock();

		if (format === PIXELFORMAT_R8_G8_B8_A8) {
			var temp = new Uint8Array(pixelData.length);

			for (var i = 0; i < pixelData.length; i++) {
				temp[i] = pixelData[i] * mult8Bit * 255;
			}

			pixelData = temp;
		}

		pixels.set(pixelData);
		texture.unlock();
		return texture;
	}

	function saturate(x) {
		return Math.max(Math.min(x, 1), 0);
	}

	var default0Curve = new Curve([0, 0, 1, 0]);
	var default1Curve = new Curve([0, 1, 1, 1]);
	var default0Curve3 = new CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);
	var default1Curve3 = new CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);
	var particleTexHeight = 2;
	var particleTexChannels = 4;
	var extentsInnerRatioUniform = new Float32Array(3);
	var spawnMatrix = new Mat4();
	var tmpVec3 = new Vec3();
	var bMin = new Vec3();
	var bMax = new Vec3();
	var setPropertyTarget;
	var setPropertyOptions;

	function setProperty(pName, defaultVal) {
		if (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {
			setPropertyTarget[pName] = setPropertyOptions[pName];
		} else {
			setPropertyTarget[pName] = defaultVal;
		}
	}

	function pack3NFloats(a, b, c) {
		var packed = a * 255 << 16 | b * 255 << 8 | c * 255;
		return packed / (1 << 24);
	}

	function packTextureXYZ_NXYZ(qXYZ, qXYZ2) {
		var num = qXYZ.length / 3;
		var colors = new Array(num * 4);

		for (var i = 0; i < num; i++) {
			colors[i * 4] = qXYZ[i * 3];
			colors[i * 4 + 1] = qXYZ[i * 3 + 1];
			colors[i * 4 + 2] = qXYZ[i * 3 + 2];
			colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);
		}

		return colors;
	}

	function packTextureRGBA(qRGB, qA) {
		var colors = new Array(qA.length * 4);

		for (var i = 0; i < qA.length; i++) {
			colors[i * 4] = qRGB[i * 3];
			colors[i * 4 + 1] = qRGB[i * 3 + 1];
			colors[i * 4 + 2] = qRGB[i * 3 + 2];
			colors[i * 4 + 3] = qA[i];
		}

		return colors;
	}

	function packTexture5Floats(qA, qB, qC, qD, qE) {
		var colors = new Array(qA.length * 4);

		for (var i = 0; i < qA.length; i++) {
			colors[i * 4] = qA[i];
			colors[i * 4 + 1] = qB[i];
			colors[i * 4 + 2] = 0;
			colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);
		}

		return colors;
	}

	function packTexture2Floats(qA, qB) {
		var colors = new Array(qA.length * 4);

		for (var i = 0; i < qA.length; i++) {
			colors[i * 4] = qA[i];
			colors[i * 4 + 1] = qB[i];
			colors[i * 4 + 2] = 0;
			colors[i * 4 + 3] = 0;
		}

		return colors;
	}

	function calcEndTime(emitter) {
		var interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;
		return Date.now() + interval * 1000;
	}

	function subGraph(A, B) {
		var r = new Float32Array(A.length);

		for (var i = 0; i < A.length; i++) {
			r[i] = A[i] - B[i];
		}

		return r;
	}

	function maxUnsignedGraphValue(A, outUMax) {
		var chans = outUMax.length;
		var values = A.length / chans;

		for (var i = 0; i < values; i++) {
			for (var j = 0; j < chans; j++) {
				var a = Math.abs(A[i * chans + j]);
				outUMax[j] = Math.max(outUMax[j], a);
			}
		}
	}

	function normalizeGraph(A, uMax) {
		var chans = uMax.length;
		var values = A.length / chans;

		for (var i = 0; i < values; i++) {
			for (var j = 0; j < chans; j++) {
				A[i * chans + j] /= uMax[j] === 0 ? 1 : uMax[j];
				A[i * chans + j] *= 0.5;
				A[i * chans + j] += 0.5;
			}
		}
	}

	function divGraphFrom2Curves(curve1, curve2, outUMax) {
		var sub = subGraph(curve2, curve1);
		maxUnsignedGraphValue(sub, outUMax);
		normalizeGraph(sub, outUMax);
		return sub;
	}

	var particleEmitterDeviceCache = new DeviceCache();

	var ParticleEmitter = function () {
		function ParticleEmitter(graphicsDevice, options) {
			this.graphicsDevice = graphicsDevice;
			var gd = graphicsDevice;
			var precision = 32;
			this.precision = precision;
			this._addTimeTime = 0;
			setPropertyTarget = this;
			setPropertyOptions = options;
			setProperty("numParticles", 1);

			if (this.numParticles > graphicsDevice.maxTextureSize) {
				Debug.warn("WARNING: can't create more than " + graphicsDevice.maxTextureSize + " particles on this device.");
				this.numParticles = graphicsDevice.maxTextureSize;
			}

			setProperty("rate", 1);
			setProperty("rate2", this.rate);
			setProperty("lifetime", 50);
			setProperty("emitterExtents", new Vec3(0, 0, 0));
			setProperty("emitterExtentsInner", new Vec3(0, 0, 0));
			setProperty("emitterRadius", 0);
			setProperty("emitterRadiusInner", 0);
			setProperty("emitterShape", EMITTERSHAPE_BOX);
			setProperty("initialVelocity", 1);
			setProperty("wrap", false);
			setProperty("localSpace", false);
			setProperty("screenSpace", false);
			setProperty("wrapBounds", null);
			setProperty("colorMap", this.defaultParamTexture);
			setProperty("normalMap", null);
			setProperty("loop", true);
			setProperty("preWarm", false);
			setProperty("sort", PARTICLESORT_NONE);
			setProperty("mode", PARTICLEMODE_GPU);
			setProperty("scene", null);
			setProperty("lighting", false);
			setProperty("halfLambert", false);
			setProperty("intensity", 1.0);
			setProperty("stretch", 0.0);
			setProperty("alignToMotion", false);
			setProperty("depthSoftening", 0);
			setProperty("mesh", null);
			setProperty("particleNormal", new Vec3(0, 1, 0));
			setProperty("orientation", PARTICLEORIENTATION_SCREEN);
			setProperty("depthWrite", false);
			setProperty("noFog", false);
			setProperty("blendType", BLEND_NORMAL);
			setProperty("node", null);
			setProperty("startAngle", 0);
			setProperty("startAngle2", this.startAngle);
			setProperty("animTilesX", 1);
			setProperty("animTilesY", 1);
			setProperty("animStartFrame", 0);
			setProperty("animNumFrames", 1);
			setProperty("animNumAnimations", 1);
			setProperty("animIndex", 0);
			setProperty("randomizeAnimIndex", false);
			setProperty("animSpeed", 1);
			setProperty("animLoop", true);
			this._gpuUpdater = new ParticleGPUUpdater(this, gd);
			this._cpuUpdater = new ParticleCPUUpdater(this);
			this.constantLightCube = gd.scope.resolve("lightCube[0]");
			this.emitterPosUniform = new Float32Array(3);
			this.wrapBoundsUniform = new Float32Array(3);
			this.emitterScaleUniform = new Float32Array([1, 1, 1]);
			setProperty("colorGraph", default1Curve3);
			setProperty("colorGraph2", this.colorGraph);
			setProperty("scaleGraph", default1Curve);
			setProperty("scaleGraph2", this.scaleGraph);
			setProperty("alphaGraph", default1Curve);
			setProperty("alphaGraph2", this.alphaGraph);
			setProperty("localVelocityGraph", default0Curve3);
			setProperty("localVelocityGraph2", this.localVelocityGraph);
			setProperty("velocityGraph", default0Curve3);
			setProperty("velocityGraph2", this.velocityGraph);
			setProperty("rotationSpeedGraph", default0Curve);
			setProperty("rotationSpeedGraph2", this.rotationSpeedGraph);
			setProperty("radialSpeedGraph", default0Curve);
			setProperty("radialSpeedGraph2", this.radialSpeedGraph);
			this.lightCube = new Float32Array(6 * 3);
			this.lightCubeDir = new Array(6);
			this.lightCubeDir[0] = new Vec3(-1, 0, 0);
			this.lightCubeDir[1] = new Vec3(1, 0, 0);
			this.lightCubeDir[2] = new Vec3(0, -1, 0);
			this.lightCubeDir[3] = new Vec3(0, 1, 0);
			this.lightCubeDir[4] = new Vec3(0, 0, -1);
			this.lightCubeDir[5] = new Vec3(0, 0, 1);
			this.animTilesParams = new Float32Array(2);
			this.animParams = new Float32Array(4);
			this.animIndexParams = new Float32Array(2);
			this.internalTex0 = null;
			this.internalTex1 = null;
			this.internalTex2 = null;
			this.colorParam = null;
			this.vbToSort = null;
			this.vbOld = null;
			this.particleDistance = null;
			this.camera = null;
			this.swapTex = false;
			this.useMesh = true;
			this.useCpu = !graphicsDevice.supportsGpuParticles;
			this.pack8 = true;
			this.localBounds = new BoundingBox();
			this.worldBoundsNoTrail = new BoundingBox();
			this.worldBoundsTrail = [new BoundingBox(), new BoundingBox()];
			this.worldBounds = new BoundingBox();
			this.worldBoundsSize = new Vec3();
			this.prevWorldBoundsSize = new Vec3();
			this.prevWorldBoundsCenter = new Vec3();
			this.prevEmitterExtents = this.emitterExtents;
			this.prevEmitterRadius = this.emitterRadius;
			this.worldBoundsMul = new Vec3();
			this.worldBoundsAdd = new Vec3();
			this.timeToSwitchBounds = 0;
			this.shaderParticleUpdateRespawn = null;
			this.shaderParticleUpdateNoRespawn = null;
			this.shaderParticleUpdateOnStop = null;
			this.numParticleVerts = 0;
			this.numParticleIndices = 0;
			this.material = null;
			this.meshInstance = null;
			this.drawOrder = 0;
			this.seed = Math.random();
			this.fixedTimeStep = 1.0 / 60;
			this.maxSubSteps = 10;
			this.simTime = 0;
			this.simTimeTotal = 0;
			this.beenReset = false;
			this._layer = null;
			this.rebuild();
		}

		var _proto = ParticleEmitter.prototype;

		_proto.onChangeCamera = function onChangeCamera() {
			this.regenShader();
			this.resetMaterial();
		};

		_proto.calculateBoundsMad = function calculateBoundsMad() {
			this.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;
			this.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;
			this.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;
			this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);
			this.worldBoundsAdd.x += 0.5;
			this.worldBoundsAdd.y += 0.5;
			this.worldBoundsAdd.z += 0.5;
		};

		_proto.calculateWorldBounds = function calculateWorldBounds() {
			if (!this.node) return;
			this.prevWorldBoundsSize.copy(this.worldBoundsSize);
			this.prevWorldBoundsCenter.copy(this.worldBounds.center);

			if (!this.useCpu) {
				var recalculateLocalBounds = false;

				if (this.emitterShape === EMITTERSHAPE_BOX) {
					recalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);
				} else {
					recalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);
				}

				if (recalculateLocalBounds) {
					this.calculateLocalBounds();
				}
			}

			var nodeWT = this.node.getWorldTransform();

			if (this.localSpace) {
				this.worldBoundsNoTrail.copy(this.localBounds);
			} else {
				this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);
			}

			this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
			this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
			var now = this.simTimeTotal;

			if (now >= this.timeToSwitchBounds) {
				this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);
				this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
				this.timeToSwitchBounds = now + this.lifetime;
			}

			this.worldBounds.copy(this.worldBoundsTrail[0]);
			this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);

			if (this.localSpace) {
				this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
				this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
			} else {
				this.meshInstance.aabb.copy(this.worldBounds);
				this.meshInstance.mesh.aabb.copy(this.worldBounds);
			}

			this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
			if (this.pack8) this.calculateBoundsMad();
		};

		_proto.resetWorldBounds = function resetWorldBounds() {
			if (!this.node) return;
			this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
			this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);
			this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
			this.worldBounds.copy(this.worldBoundsTrail[0]);
			this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
			this.prevWorldBoundsSize.copy(this.worldBoundsSize);
			this.prevWorldBoundsCenter.copy(this.worldBounds.center);
			this.simTimeTotal = 0;
			this.timeToSwitchBounds = 0;
		};

		_proto.calculateLocalBounds = function calculateLocalBounds() {
			var minx = Number.MAX_VALUE;
			var miny = Number.MAX_VALUE;
			var minz = Number.MAX_VALUE;
			var maxx = -Number.MAX_VALUE;
			var maxy = -Number.MAX_VALUE;
			var maxz = -Number.MAX_VALUE;
			var maxR = 0;
			var maxScale = 0;
			var stepWeight = this.lifetime / this.precision;
			var wVels = [this.qVelocity, this.qVelocity2];
			var lVels = [this.qLocalVelocity, this.qLocalVelocity2];
			var accumX = [0, 0];
			var accumY = [0, 0];
			var accumZ = [0, 0];
			var accumR = [0, 0];
			var accumW = [0, 0];
			var x, y, z;

			for (var i = 0; i < this.precision + 1; i++) {
				var index = Math.min(i, this.precision - 1);

				for (var j = 0; j < 2; j++) {
					x = lVels[j][index * 3 + 0] * stepWeight + accumX[j];
					y = lVels[j][index * 3 + 1] * stepWeight + accumY[j];
					z = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];
					minx = Math.min(x, minx);
					miny = Math.min(y, miny);
					minz = Math.min(z, minz);
					maxx = Math.max(x, maxx);
					maxy = Math.max(y, maxy);
					maxz = Math.max(z, maxz);
					accumX[j] = x;
					accumY[j] = y;
					accumZ[j] = z;
				}

				for (var _j = 0; _j < 2; _j++) {
					accumW[_j] += stepWeight * Math.sqrt(wVels[_j][index * 3 + 0] * wVels[_j][index * 3 + 0] + wVels[_j][index * 3 + 1] * wVels[_j][index * 3 + 1] + wVels[_j][index * 3 + 2] * wVels[_j][index * 3 + 2]);
				}

				accumR[0] += this.qRadialSpeed[index] * stepWeight;
				accumR[1] += this.qRadialSpeed2[index] * stepWeight;
				maxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));
				maxScale = Math.max(maxScale, this.qScale[index]);
			}

			if (this.emitterShape === EMITTERSHAPE_BOX) {
				x = this.emitterExtents.x * 0.5;
				y = this.emitterExtents.y * 0.5;
				z = this.emitterExtents.z * 0.5;
			} else {
				x = this.emitterRadius;
				y = this.emitterRadius;
				z = this.emitterRadius;
			}

			var w = Math.max(accumW[0], accumW[1]);
			bMin.x = minx - maxScale - x - maxR - w;
			bMin.y = miny - maxScale - y - maxR - w;
			bMin.z = minz - maxScale - z - maxR - w;
			bMax.x = maxx + maxScale + x + maxR + w;
			bMax.y = maxy + maxScale + y + maxR + w;
			bMax.z = maxz + maxScale + z + maxR + w;
			this.localBounds.setMinMax(bMin, bMax);
		};

		_proto.rebuild = function rebuild() {
			var gd = this.graphicsDevice;
			if (this.colorMap === null) this.colorMap = this.defaultParamTexture;
			this.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;
			this.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles || !gd.extTextureFloat;

			this._destroyResources();

			this.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;
			particleTexHeight = this.useCpu || this.pack8 ? 4 : 2;
			this.useMesh = false;

			if (this.mesh) {
				var totalVertCount = this.numParticles * this.mesh.vertexBuffer.numVertices;

				if (totalVertCount > 65535) {
					Debug.warn("WARNING: particle system can't render mesh particles because numParticles * numVertices is more than 65k. Reverting to quad particles.");
				} else {
					this.useMesh = true;
				}
			}

			this.numParticlesPot = math.nextPowerOfTwo(this.numParticles);
			this.rebuildGraphs();
			this.calculateLocalBounds();
			this.resetWorldBounds();

			if (this.node) {
				this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
				this.worldBoundsTrail[0].copy(this.worldBounds);
				this.worldBoundsTrail[1].copy(this.worldBounds);
				this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
				this.prevWorldBoundsSize.copy(this.worldBoundsSize);
				this.prevWorldBoundsCenter.copy(this.worldBounds.center);
				if (this.pack8) this.calculateBoundsMad();
			}

			this.vbToSort = new Array(this.numParticles);

			for (var iSort = 0; iSort < this.numParticles; iSort++) {
				this.vbToSort[iSort] = [0, 0];
			}

			this.particleDistance = new Float32Array(this.numParticles);

			this._gpuUpdater.randomize();

			this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
			var emitterPos = this.node === null || this.localSpace ? Vec3.ZERO : this.node.getPosition();

			if (this.emitterShape === EMITTERSHAPE_BOX) {
				if (this.node === null || this.localSpace) {
					spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);
				} else {
					spawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));
				}

				extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
				extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
				extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
			}

			for (var i = 0; i < this.numParticles; i++) {
				this._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);

				if (this.useCpu) this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;
			}

			this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);

			for (var _i = 0; _i < this.particleTexStart.length; _i++) {
				this.particleTexStart[_i] = this.particleTex[_i];
			}

			if (!this.useCpu) {
				if (this.pack8) {
					this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);
					this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);
					this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_R8_G8_B8_A8, 1, false);
				} else {
					this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
					this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
					this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);
				}

				this.rtParticleTexIN = new RenderTarget({
					colorBuffer: this.particleTexIN,
					depth: false
				});
				this.rtParticleTexOUT = new RenderTarget({
					colorBuffer: this.particleTexOUT,
					depth: false
				});
				this.swapTex = false;
			}

			var shaderCodeStart = (this.localSpace ? '#define LOCAL_SPACE\n' : '') + shaderChunks.particleUpdaterInitPS + (this.pack8 ? shaderChunks.particleInputRgba8PS + shaderChunks.particleOutputRgba8PS : shaderChunks.particleInputFloatPS + shaderChunks.particleOutputFloatPS) + (this.emitterShape === EMITTERSHAPE_BOX ? shaderChunks.particleUpdaterAABBPS : shaderChunks.particleUpdaterSpherePS) + shaderChunks.particleUpdaterStartPS;
			var shaderCodeRespawn = shaderCodeStart + shaderChunks.particleUpdaterRespawnPS + shaderChunks.particleUpdaterEndPS;
			var shaderCodeNoRespawn = shaderCodeStart + shaderChunks.particleUpdaterNoRespawnPS + shaderChunks.particleUpdaterEndPS;
			var shaderCodeOnStop = shaderCodeStart + shaderChunks.particleUpdaterOnStopPS + shaderChunks.particleUpdaterEndPS;
			var params = this.emitterShape + "" + this.pack8 + "" + this.localSpace;
			this.shaderParticleUpdateRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeRespawn, "fsQuad0" + params);
			this.shaderParticleUpdateNoRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, "fsQuad1" + params);
			this.shaderParticleUpdateOnStop = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeOnStop, "fsQuad2" + params);
			this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
			this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;

			this._allocate(this.numParticles);

			var mesh = new Mesh(gd);
			mesh.vertexBuffer = this.vertexBuffer;
			mesh.indexBuffer[0] = this.indexBuffer;
			mesh.primitive[0].type = PRIMITIVE_TRIANGLES;
			mesh.primitive[0].base = 0;
			mesh.primitive[0].count = this.numParticles * this.numParticleIndices;
			mesh.primitive[0].indexed = true;
			this.material = new Material();
			this.material.name = this.node.name;
			this.material.cull = CULLFACE_NONE;
			this.material.alphaWrite = false;
			this.material.blend = true;
			this.material.blendType = this.blendType;
			this.material.depthWrite = this.depthWrite;
			this.material.emitter = this;
			this.regenShader();
			this.resetMaterial();
			var wasVisible = this.meshInstance ? this.meshInstance.visible : true;
			this.meshInstance = new MeshInstance(mesh, this.material, this.node);
			this.meshInstance.pick = false;
			this.meshInstance.updateKey();
			this.meshInstance.cull = true;
			this.meshInstance._noDepthDrawGl1 = true;

			if (this.localSpace) {
				this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());
			} else {
				this.meshInstance.aabb.copy(this.worldBounds);
			}

			this.meshInstance._updateAabb = false;
			this.meshInstance.visible = wasVisible;

			this._initializeTextures();

			this.resetTime();
			this.addTime(0, false);
			if (this.preWarm) this.prewarm(this.lifetime);
		};

		_proto._isAnimated = function _isAnimated() {
			return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== this.defaultParamTexture || this.normalMap);
		};

		_proto.rebuildGraphs = function rebuildGraphs() {
			var precision = this.precision;
			var gd = this.graphicsDevice;
			this.qLocalVelocity = this.localVelocityGraph.quantize(precision);
			this.qVelocity = this.velocityGraph.quantize(precision);
			this.qColor = this.colorGraph.quantizeClamped(precision, 0, 1);
			this.qRotSpeed = this.rotationSpeedGraph.quantize(precision);
			this.qScale = this.scaleGraph.quantize(precision);
			this.qAlpha = this.alphaGraph.quantize(precision);
			this.qRadialSpeed = this.radialSpeedGraph.quantize(precision);
			this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);
			this.qVelocity2 = this.velocityGraph2.quantize(precision);
			this.qColor2 = this.colorGraph2.quantizeClamped(precision, 0, 1);
			this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);
			this.qScale2 = this.scaleGraph2.quantize(precision);
			this.qAlpha2 = this.alphaGraph2.quantize(precision);
			this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(precision);

			for (var i = 0; i < precision; i++) {
				this.qRotSpeed[i] *= math.DEG_TO_RAD;
				this.qRotSpeed2[i] *= math.DEG_TO_RAD;
			}

			this.localVelocityUMax = new Float32Array(3);
			this.velocityUMax = new Float32Array(3);
			this.colorUMax = new Float32Array(3);
			this.rotSpeedUMax = [0];
			this.scaleUMax = [0];
			this.alphaUMax = [0];
			this.radialSpeedUMax = [0];
			this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
			this.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);
			this.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);
			this.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
			this.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);
			this.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);
			this.qRadialSpeedDiv = divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);

			if (this.pack8) {
				var umax = [0, 0, 0];
				maxUnsignedGraphValue(this.qVelocity, umax);
				var umax2 = [0, 0, 0];
				maxUnsignedGraphValue(this.qVelocity2, umax2);
				var lumax = [0, 0, 0];
				maxUnsignedGraphValue(this.qLocalVelocity, lumax);
				var lumax2 = [0, 0, 0];
				maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);
				var rumax = [0];
				maxUnsignedGraphValue(this.qRadialSpeed, rumax);
				var rumax2 = [0];
				maxUnsignedGraphValue(this.qRadialSpeed2, rumax2);
				var maxVel = Math.max(umax[0], umax2[0]);
				maxVel = Math.max(maxVel, umax[1]);
				maxVel = Math.max(maxVel, umax2[1]);
				maxVel = Math.max(maxVel, umax[2]);
				maxVel = Math.max(maxVel, umax2[2]);
				var lmaxVel = Math.max(lumax[0], lumax2[0]);
				lmaxVel = Math.max(lmaxVel, lumax[1]);
				lmaxVel = Math.max(lmaxVel, lumax2[1]);
				lmaxVel = Math.max(lmaxVel, lumax[2]);
				lmaxVel = Math.max(lmaxVel, lumax2[2]);
				var maxRad = Math.max(rumax[0], rumax2[0]);
				this.maxVel = maxVel + lmaxVel + maxRad;
			}

			if (!this.useCpu) {
				this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));
				this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));
				this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));
				this.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));
			}

			this.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_R8_G8_B8_A8, 1.0, true);
		};

		_proto._initializeTextures = function _initializeTextures() {
			if (this.colorMap) {
				this.material.setParameter('colorMap', this.colorMap);

				if (this.lighting && this.normalMap) {
					this.material.setParameter('normalMap', this.normalMap);
				}
			}
		};

		_proto.regenShader = function regenShader() {
			var programLib = this.graphicsDevice.getProgramLibrary();
			var hasNormal = this.normalMap !== null;
			this.normalOption = 0;

			if (this.lighting) {
				this.normalOption = hasNormal ? 2 : 1;
			}

			this.material.updateShader = function () {
				if (this.emitter.scene) {
					if (this.emitter.camera !== this.emitter.scene._activeCamera) {
						this.emitter.camera = this.emitter.scene._activeCamera;
						this.emitter.onChangeCamera();
					}
				}

				var inTools = this.emitter.inTools;
				var shader = programLib.getProgram("particle", {
					useCpu: this.emitter.useCpu,
					normal: this.emitter.normalOption,
					halflambert: this.emitter.halfLambert,
					stretch: this.emitter.stretch,
					alignToMotion: this.emitter.alignToMotion,
					soft: this.emitter.depthSoftening,
					mesh: this.emitter.useMesh,
					gamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,
					toneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,
					fog: this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : "none",
					wrap: this.emitter.wrap && this.emitter.wrapBounds,
					localSpace: this.emitter.localSpace,
					screenSpace: inTools ? false : this.emitter.screenSpace,
					blend: this.blendType,
					animTex: this.emitter._isAnimated(),
					animTexLoop: this.emitter.animLoop,
					pack8: this.emitter.pack8,
					customFace: this.emitter.orientation !== PARTICLEORIENTATION_SCREEN
				});
				this.shader = shader;
			};

			this.material.updateShader();
		};

		_proto.resetMaterial = function resetMaterial() {
			var material = this.material;
			material.setParameter('stretch', this.stretch);

			if (this._isAnimated()) {
				material.setParameter('animTexTilesParams', this.animTilesParams);
				material.setParameter('animTexParams', this.animParams);
				material.setParameter('animTexIndexParams', this.animIndexParams);
			}

			material.setParameter('colorMult', this.intensity);

			if (!this.useCpu) {
				material.setParameter('internalTex0', this.internalTex0);
				material.setParameter('internalTex1', this.internalTex1);
				material.setParameter('internalTex2', this.internalTex2);
				material.setParameter('internalTex3', this.internalTex3);
			}

			material.setParameter('colorParam', this.colorParam);
			material.setParameter('numParticles', this.numParticles);
			material.setParameter('numParticlesPot', this.numParticlesPot);
			material.setParameter('lifetime', this.lifetime);
			material.setParameter('rate', this.rate);
			material.setParameter('rateDiv', this.rate2 - this.rate);
			material.setParameter('seed', this.seed);
			material.setParameter('scaleDivMult', this.scaleUMax[0]);
			material.setParameter('alphaDivMult', this.alphaUMax[0]);
			material.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);
			material.setParameter("graphNumSamples", this.precision);
			material.setParameter("graphSampleSize", 1.0 / this.precision);
			material.setParameter("emitterScale", new Float32Array([1, 1, 1]));

			if (this.pack8) {
				this._gpuUpdater._setInputBounds();

				material.setParameter("inBoundsSize", this._gpuUpdater.inBoundsSizeUniform);
				material.setParameter("inBoundsCenter", this._gpuUpdater.inBoundsCenterUniform);
				material.setParameter("maxVel", this.maxVel);
			}

			if (this.wrap && this.wrapBounds) {
				this.wrapBoundsUniform[0] = this.wrapBounds.x;
				this.wrapBoundsUniform[1] = this.wrapBounds.y;
				this.wrapBoundsUniform[2] = this.wrapBounds.z;
				material.setParameter('wrapBounds', this.wrapBoundsUniform);
			}

			if (this.colorMap) {
				material.setParameter('colorMap', this.colorMap);
			}

			if (this.lighting) {
				if (this.normalMap) {
					material.setParameter('normalMap', this.normalMap);
				}
			}

			if (this.depthSoftening > 0) {
				material.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100));
			}

			if (this.stretch > 0.0) material.cull = CULLFACE_NONE;

			this._compParticleFaceParams();
		};

		_proto._compParticleFaceParams = function _compParticleFaceParams() {
			var tangent, binormal;

			if (this.orientation === PARTICLEORIENTATION_SCREEN) {
				tangent = new Float32Array([1, 0, 0]);
				binormal = new Float32Array([0, 0, 1]);
			} else {
				var n;

				if (this.orientation === PARTICLEORIENTATION_WORLD) {
					n = this.particleNormal.normalize();
				} else {
					var emitterMat = this.node === null ? Mat4.IDENTITY : this.node.getWorldTransform();
					n = emitterMat.transformVector(this.particleNormal).normalize();
				}

				var t = new Vec3(1, 0, 0);
				if (Math.abs(t.dot(n)) === 1) t.set(0, 0, 1);
				var b = new Vec3().cross(n, t).normalize();
				t.cross(b, n).normalize();
				tangent = new Float32Array([t.x, t.y, t.z]);
				binormal = new Float32Array([b.x, b.y, b.z]);
			}

			this.material.setParameter("faceTangent", tangent);
			this.material.setParameter("faceBinorm", binormal);
		};

		_proto._allocate = function _allocate(numParticles) {
			var psysVertCount = numParticles * this.numParticleVerts;
			var psysIndexCount = numParticles * this.numParticleIndices;

			if (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {
				if (!this.useCpu) {
					var elements = [{
						semantic: SEMANTIC_ATTR0,
						components: 4,
						type: TYPE_FLOAT32
					}];

					if (this.useMesh) {
						elements.push({
							semantic: SEMANTIC_ATTR1,
							components: 2,
							type: TYPE_FLOAT32
						});
					}

					var particleFormat = new VertexFormat(this.graphicsDevice, elements);
					this.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);
					this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
				} else {
					var _elements = [{
						semantic: SEMANTIC_ATTR0,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR1,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR2,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR3,
						components: 1,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR4,
						components: this.useMesh ? 4 : 2,
						type: TYPE_FLOAT32
					}];

					var _particleFormat = new VertexFormat(this.graphicsDevice, _elements);

					this.vertexBuffer = new VertexBuffer(this.graphicsDevice, _particleFormat, psysVertCount, BUFFER_DYNAMIC);
					this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
				}

				var data = new Float32Array(this.vertexBuffer.lock());
				var meshData, stride, texCoordOffset;

				if (this.useMesh) {
					meshData = new Float32Array(this.mesh.vertexBuffer.lock());
					stride = meshData.length / this.mesh.vertexBuffer.numVertices;

					for (var elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++) {
						if (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {
							texCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;
							break;
						}
					}
				}

				for (var i = 0; i < psysVertCount; i++) {
					var id = Math.floor(i / this.numParticleVerts);

					if (!this.useMesh) {
						var vertID = i % 4;
						data[i * 4] = particleVerts[vertID][0];
						data[i * 4 + 1] = particleVerts[vertID][1];
						data[i * 4 + 2] = 0;
						data[i * 4 + 3] = id;
					} else {
						var vert = i % this.numParticleVerts;
						data[i * 6] = meshData[vert * stride];
						data[i * 6 + 1] = meshData[vert * stride + 1];
						data[i * 6 + 2] = meshData[vert * stride + 2];
						data[i * 6 + 3] = id;
						data[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];
						data[i * 6 + 5] = 1.0 - meshData[vert * stride + texCoordOffset + 1];
					}
				}

				if (this.useCpu) {
					this.vbCPU = new Float32Array(data);
					this.vbOld = new Float32Array(this.vbCPU.length);
				}

				this.vertexBuffer.unlock();

				if (this.useMesh) {
					this.mesh.vertexBuffer.unlock();
				}

				var dst = 0;
				var indices = new Uint16Array(this.indexBuffer.lock());
				if (this.useMesh) meshData = new Uint16Array(this.mesh.indexBuffer[0].lock());

				for (var _i2 = 0; _i2 < numParticles; _i2++) {
					if (!this.useMesh) {
						var baseIndex = _i2 * 4;
						indices[dst++] = baseIndex;
						indices[dst++] = baseIndex + 1;
						indices[dst++] = baseIndex + 2;
						indices[dst++] = baseIndex;
						indices[dst++] = baseIndex + 2;
						indices[dst++] = baseIndex + 3;
					} else {
						for (var j = 0; j < this.numParticleIndices; j++) {
							indices[_i2 * this.numParticleIndices + j] = meshData[j] + _i2 * this.numParticleVerts;
						}
					}
				}

				this.indexBuffer.unlock();
				if (this.useMesh) this.mesh.indexBuffer[0].unlock();
			}
		};

		_proto.reset = function reset() {
			this.beenReset = true;
			this.seed = Math.random();
			this.material.setParameter('seed', this.seed);

			if (this.useCpu) {
				for (var i = 0; i < this.particleTexStart.length; i++) {
					this.particleTex[i] = this.particleTexStart[i];
				}
			} else {
				this._initializeTextures();
			}

			this.resetWorldBounds();
			this.resetTime();
			var origLoop = this.loop;
			this.loop = true;
			this.addTime(0, false);
			this.loop = origLoop;

			if (this.preWarm) {
				this.prewarm(this.lifetime);
			}
		};

		_proto.prewarm = function prewarm(time) {
			var lifetimeFraction = time / this.lifetime;
			var iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);
			var stepDelta = time / iterations;

			for (var i = 0; i < iterations; i++) {
				this.addTime(stepDelta, false);
			}
		};

		_proto.resetTime = function resetTime() {
			this.endTime = calcEndTime(this);
		};

		_proto.finishFrame = function finishFrame() {
			if (this.useCpu) this.vertexBuffer.unlock();
		};

		_proto.addTime = function addTime(delta, isOnStop) {
			var device = this.graphicsDevice;
			var startTime = now();
			this.simTimeTotal += delta;
			this.calculateWorldBounds();

			if (this._isAnimated()) {
				var tilesParams = this.animTilesParams;
				tilesParams[0] = 1.0 / this.animTilesX;
				tilesParams[1] = 1.0 / this.animTilesY;
				var params = this.animParams;
				params[0] = this.animStartFrame;
				params[1] = this.animNumFrames * this.animSpeed;
				params[2] = this.animNumFrames - 1;
				params[3] = this.animNumAnimations - 1;
				var animIndexParams = this.animIndexParams;
				animIndexParams[0] = this.animIndex;
				animIndexParams[1] = this.randomizeAnimIndex;
			}

			if (this.scene) {
				if (this.camera !== this.scene._activeCamera) {
					this.camera = this.scene._activeCamera;
					this.onChangeCamera();
				}
			}

			if (this.emitterShape === EMITTERSHAPE_BOX) {
				extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
				extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
				extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;

				if (this.meshInstance.node === null) {
					spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);
				} else {
					spawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));
				}
			}

			var emitterPos;
			var emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;
			this.emitterScaleUniform[0] = emitterScale.x;
			this.emitterScaleUniform[1] = emitterScale.y;
			this.emitterScaleUniform[2] = emitterScale.z;
			this.material.setParameter("emitterScale", this.emitterScaleUniform);

			if (this.localSpace && this.meshInstance.node) {
				emitterPos = this.meshInstance.node.getPosition();
				this.emitterPosUniform[0] = emitterPos.x;
				this.emitterPosUniform[1] = emitterPos.y;
				this.emitterPosUniform[2] = emitterPos.z;
				this.material.setParameter("emitterPos", this.emitterPosUniform);
			}

			this._compParticleFaceParams();

			if (!this.useCpu) {
				this._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);
			} else {
				var data = new Float32Array(this.vertexBuffer.lock());

				this._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);
			}

			if (!this.loop) {
				if (Date.now() > this.endTime) {
					if (this.onFinished) this.onFinished();
					this.meshInstance.visible = false;
				}
			}

			if (this.meshInstance) {
				this.meshInstance.drawOrder = this.drawOrder;
			}

			this._addTimeTime += now() - startTime;
		};

		_proto._destroyResources = function _destroyResources() {
			if (this.particleTexIN) {
				this.particleTexIN.destroy();
				this.particleTexIN = null;
			}

			if (this.particleTexOUT) {
				this.particleTexOUT.destroy();
				this.particleTexOUT = null;
			}

			if (this.particleTexStart && this.particleTexStart.destroy) {
				this.particleTexStart.destroy();
				this.particleTexStart = null;
			}

			if (this.rtParticleTexIN) {
				this.rtParticleTexIN.destroy();
				this.rtParticleTexIN = null;
			}

			if (this.rtParticleTexOUT) {
				this.rtParticleTexOUT.destroy();
				this.rtParticleTexOUT = null;
			}

			if (this.internalTex0) {
				this.internalTex0.destroy();
				this.internalTex0 = null;
			}

			if (this.internalTex1) {
				this.internalTex1.destroy();
				this.internalTex1 = null;
			}

			if (this.internalTex2) {
				this.internalTex2.destroy();
				this.internalTex2 = null;
			}

			if (this.internalTex3) {
				this.internalTex3.destroy();
				this.internalTex3 = null;
			}

			if (this.colorParam) {
				this.colorParam.destroy();
				this.colorParam = null;
			}

			if (this.vertexBuffer) {
				this.vertexBuffer.destroy();
				this.vertexBuffer = undefined;
			}

			if (this.indexBuffer) {
				this.indexBuffer.destroy();
				this.indexBuffer = undefined;
			}

			if (this.material) {
				this.material.destroy();
				this.material = null;
			}
		};

		_proto.destroy = function destroy() {
			this.camera = null;

			this._destroyResources();
		};

		_createClass(ParticleEmitter, [{
			key: "defaultParamTexture",
			get: function get() {
				var _this = this;

				Debug.assert(this.graphicsDevice);
				return particleEmitterDeviceCache.get(this.graphicsDevice, function () {
					var resolution = 16;
					var centerPoint = resolution * 0.5 + 0.5;
					var dtex = new Float32Array(resolution * resolution * 4);

					for (var y = 0; y < resolution; y++) {
						for (var x = 0; x < resolution; x++) {
							var xgrad = x + 1 - centerPoint;
							var ygrad = y + 1 - centerPoint;
							var c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);
							var p = y * resolution + x;
							dtex[p * 4] = 1;
							dtex[p * 4 + 1] = 1;
							dtex[p * 4 + 2] = 1;
							dtex[p * 4 + 3] = c;
						}
					}

					var texture = _createTexture(_this.graphicsDevice, resolution, resolution, dtex, PIXELFORMAT_R8_G8_B8_A8, 1.0, true);

					texture.minFilter = FILTER_LINEAR;
					texture.magFilter = FILTER_LINEAR;
					return texture;
				});
			}
		}]);

		return ParticleEmitter;
	}();

	var SIMPLE_PROPERTIES = ['emitterExtents', 'emitterRadius', 'emitterExtentsInner', 'emitterRadiusInner', 'loop', 'initialVelocity', 'animSpeed', 'normalMap', 'particleNormal'];
	var COMPLEX_PROPERTIES = ['numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'lighting', 'halfLambert', 'intensity', 'wrap', 'wrapBounds', 'depthWrite', 'noFog', 'sort', 'stretch', 'alignToMotion', 'preWarm', 'emitterShape', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animLoop', 'colorMap', 'localSpace', 'screenSpace', 'orientation'];
	var GRAPH_PROPERTIES = ['scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'velocityGraph', 'velocityGraph2', 'localVelocityGraph', 'localVelocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2'];
	var ASSET_PROPERTIES = ['colorMapAsset', 'normalMapAsset', 'meshAsset', 'renderAsset'];
	var depthLayer;

	var ParticleSystemComponent = function (_Component) {
		_inheritsLoose(ParticleSystemComponent, _Component);

		function ParticleSystemComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._requestedDepth = false;
			_this._drawOrder = 0;

			_this.on("set_colorMapAsset", _this.onSetColorMapAsset, _assertThisInitialized(_this));

			_this.on("set_normalMapAsset", _this.onSetNormalMapAsset, _assertThisInitialized(_this));

			_this.on("set_meshAsset", _this.onSetMeshAsset, _assertThisInitialized(_this));

			_this.on("set_mesh", _this.onSetMesh, _assertThisInitialized(_this));

			_this.on("set_renderAsset", _this.onSetRenderAsset, _assertThisInitialized(_this));

			_this.on("set_loop", _this.onSetLoop, _assertThisInitialized(_this));

			_this.on("set_blendType", _this.onSetBlendType, _assertThisInitialized(_this));

			_this.on("set_depthSoftening", _this.onSetDepthSoftening, _assertThisInitialized(_this));

			_this.on("set_layers", _this.onSetLayers, _assertThisInitialized(_this));

			SIMPLE_PROPERTIES.forEach(function (prop) {
				_this.on("set_" + prop, _this.onSetSimpleProperty, _assertThisInitialized(_this));
			});
			COMPLEX_PROPERTIES.forEach(function (prop) {
				_this.on("set_" + prop, _this.onSetComplexProperty, _assertThisInitialized(_this));
			});
			GRAPH_PROPERTIES.forEach(function (prop) {
				_this.on("set_" + prop, _this.onSetGraphProperty, _assertThisInitialized(_this));
			});
			return _this;
		}

		var _proto = ParticleSystemComponent.prototype;

		_proto.addMeshInstanceToLayers = function addMeshInstanceToLayers() {
			if (!this.emitter) return;

			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.addMeshInstances([this.emitter.meshInstance]);
				this.emitter._layer = layer;
			}
		};

		_proto.removeMeshInstanceFromLayers = function removeMeshInstanceFromLayers() {
			if (!this.emitter) return;

			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances([this.emitter.meshInstance]);
			}
		};

		_proto.onSetLayers = function onSetLayers(name, oldValue, newValue) {
			if (!this.emitter) return;

			for (var i = 0; i < oldValue.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
				if (!layer) continue;
				layer.removeMeshInstances([this.emitter.meshInstance]);
			}

			if (!this.enabled || !this.entity.enabled) return;

			for (var _i = 0; _i < newValue.length; _i++) {
				var _layer = this.system.app.scene.layers.getLayerById(newValue[_i]);

				if (!_layer) continue;

				_layer.addMeshInstances([this.emitter.meshInstance]);
			}
		};

		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addMeshInstanceToLayers();
			oldComp.off("add", this.onLayerAdded, this);
			oldComp.off("remove", this.onLayerRemoved, this);
			newComp.on("add", this.onLayerAdded, this);
			newComp.on("remove", this.onLayerRemoved, this);
		};

		_proto.onLayerAdded = function onLayerAdded(layer) {
			if (!this.emitter) return;
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addMeshInstances([this.emitter.meshInstance]);
		};

		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			if (!this.emitter) return;
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances([this.emitter.meshInstance]);
		};

		_proto._bindColorMapAsset = function _bindColorMapAsset(asset) {
			asset.on('load', this._onColorMapAssetLoad, this);
			asset.on('unload', this._onColorMapAssetUnload, this);
			asset.on('remove', this._onColorMapAssetRemove, this);
			asset.on('change', this._onColorMapAssetChange, this);

			if (asset.resource) {
				this._onColorMapAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};

		_proto._unbindColorMapAsset = function _unbindColorMapAsset(asset) {
			asset.off('load', this._onColorMapAssetLoad, this);
			asset.off('unload', this._onColorMapAssetUnload, this);
			asset.off('remove', this._onColorMapAssetRemove, this);
			asset.off('change', this._onColorMapAssetChange, this);
		};

		_proto._onColorMapAssetLoad = function _onColorMapAssetLoad(asset) {
			this.colorMap = asset.resource;
		};

		_proto._onColorMapAssetUnload = function _onColorMapAssetUnload(asset) {
			this.colorMap = null;
		};

		_proto._onColorMapAssetRemove = function _onColorMapAssetRemove(asset) {
			this._onColorMapAssetUnload(asset);
		};

		_proto._onColorMapAssetChange = function _onColorMapAssetChange(asset) {};

		_proto.onSetColorMapAsset = function onSetColorMapAsset(name, oldValue, newValue) {
			var _this2 = this;

			var assets = this.system.app.assets;

			if (oldValue) {
				var asset = assets.get(oldValue);

				if (asset) {
					this._unbindColorMapAsset(asset);
				}
			}

			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.colorMapAsset = newValue.id;
					newValue = newValue.id;
				}

				var _asset = assets.get(newValue);

				if (_asset) {
					this._bindColorMapAsset(_asset);
				} else {
					assets.once("add:" + newValue, function (asset) {
						_this2._bindColorMapAsset(asset);
					});
				}
			} else {
				this.colorMap = null;
			}
		};

		_proto._bindNormalMapAsset = function _bindNormalMapAsset(asset) {
			asset.on('load', this._onNormalMapAssetLoad, this);
			asset.on('unload', this._onNormalMapAssetUnload, this);
			asset.on('remove', this._onNormalMapAssetRemove, this);
			asset.on('change', this._onNormalMapAssetChange, this);

			if (asset.resource) {
				this._onNormalMapAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};

		_proto._unbindNormalMapAsset = function _unbindNormalMapAsset(asset) {
			asset.off('load', this._onNormalMapAssetLoad, this);
			asset.off('unload', this._onNormalMapAssetUnload, this);
			asset.off('remove', this._onNormalMapAssetRemove, this);
			asset.off('change', this._onNormalMapAssetChange, this);
		};

		_proto._onNormalMapAssetLoad = function _onNormalMapAssetLoad(asset) {
			this.normalMap = asset.resource;
		};

		_proto._onNormalMapAssetUnload = function _onNormalMapAssetUnload(asset) {
			this.normalMap = null;
		};

		_proto._onNormalMapAssetRemove = function _onNormalMapAssetRemove(asset) {
			this._onNormalMapAssetUnload(asset);
		};

		_proto._onNormalMapAssetChange = function _onNormalMapAssetChange(asset) {};

		_proto.onSetNormalMapAsset = function onSetNormalMapAsset(name, oldValue, newValue) {
			var _this3 = this;

			var assets = this.system.app.assets;

			if (oldValue) {
				var asset = assets.get(oldValue);

				if (asset) {
					this._unbindNormalMapAsset(asset);
				}
			}

			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.normalMapAsset = newValue.id;
					newValue = newValue.id;
				}

				var _asset2 = assets.get(newValue);

				if (_asset2) {
					this._bindNormalMapAsset(_asset2);
				} else {
					assets.once("add:" + newValue, function (asset) {
						_this3._bindNormalMapAsset(asset);
					});
				}
			} else {
				this.normalMap = null;
			}
		};

		_proto._bindMeshAsset = function _bindMeshAsset(asset) {
			asset.on('load', this._onMeshAssetLoad, this);
			asset.on('unload', this._onMeshAssetUnload, this);
			asset.on('remove', this._onMeshAssetRemove, this);
			asset.on('change', this._onMeshAssetChange, this);

			if (asset.resource) {
				this._onMeshAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};

		_proto._unbindMeshAsset = function _unbindMeshAsset(asset) {
			asset.off('load', this._onMeshAssetLoad, this);
			asset.off('unload', this._onMeshAssetUnload, this);
			asset.off('remove', this._onMeshAssetRemove, this);
			asset.off('change', this._onMeshAssetChange, this);
		};

		_proto._onMeshAssetLoad = function _onMeshAssetLoad(asset) {
			this._onMeshChanged(asset.resource);
		};

		_proto._onMeshAssetUnload = function _onMeshAssetUnload(asset) {
			this.mesh = null;
		};

		_proto._onMeshAssetRemove = function _onMeshAssetRemove(asset) {
			this._onMeshAssetUnload(asset);
		};

		_proto._onMeshAssetChange = function _onMeshAssetChange(asset) {};

		_proto.onSetMeshAsset = function onSetMeshAsset(name, oldValue, newValue) {
			var assets = this.system.app.assets;

			if (oldValue) {
				var asset = assets.get(oldValue);

				if (asset) {
					this._unbindMeshAsset(asset);
				}
			}

			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.meshAsset = newValue.id;
					newValue = newValue.id;
				}

				var _asset3 = assets.get(newValue);

				if (_asset3) {
					this._bindMeshAsset(_asset3);
				}
			} else {
				this._onMeshChanged(null);
			}
		};

		_proto.onSetMesh = function onSetMesh(name, oldValue, newValue) {
			if (!newValue || newValue instanceof Asset || typeof newValue === 'number') {
				this.meshAsset = newValue;
			} else {
				this._onMeshChanged(newValue);
			}
		};

		_proto._onMeshChanged = function _onMeshChanged(mesh) {
			if (mesh && !(mesh instanceof Mesh)) {
				if (mesh.meshInstances[0]) {
					mesh = mesh.meshInstances[0].mesh;
				} else {
					mesh = null;
				}
			}

			this.data.mesh = mesh;

			if (this.emitter) {
				this.emitter.mesh = mesh;
				this.emitter.resetMaterial();
				this.rebuild();
			}
		};

		_proto.onSetRenderAsset = function onSetRenderAsset(name, oldValue, newValue) {
			var assets = this.system.app.assets;

			if (oldValue) {
				var asset = assets.get(oldValue);

				if (asset) {
					this._unbindRenderAsset(asset);
				}
			}

			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.renderAsset = newValue.id;
					newValue = newValue.id;
				}

				var _asset4 = assets.get(newValue);

				if (_asset4) {
					this._bindRenderAsset(_asset4);
				}
			} else {
				this._onRenderChanged(null);
			}
		};

		_proto._bindRenderAsset = function _bindRenderAsset(asset) {
			asset.on('load', this._onRenderAssetLoad, this);
			asset.on('unload', this._onRenderAssetUnload, this);
			asset.on('remove', this._onRenderAssetRemove, this);

			if (asset.resource) {
				this._onRenderAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};

		_proto._unbindRenderAsset = function _unbindRenderAsset(asset) {
			asset.off('load', this._onRenderAssetLoad, this);
			asset.off('unload', this._onRenderAssetUnload, this);
			asset.off('remove', this._onRenderAssetRemove, this);

			if (asset.resource) {
				asset.resource.off('set:meshes', this._onRenderSetMeshes, this);
			}
		};

		_proto._onRenderAssetLoad = function _onRenderAssetLoad(asset) {
			this._onRenderChanged(asset.resource);
		};

		_proto._onRenderAssetUnload = function _onRenderAssetUnload(asset) {
			this._onRenderChanged(null);
		};

		_proto._onRenderAssetRemove = function _onRenderAssetRemove(asset) {
			this._onRenderAssetUnload(asset);
		};

		_proto._onRenderChanged = function _onRenderChanged(render) {
			if (!render) {
				this._onMeshChanged(null);

				return;
			}

			render.off('set:meshes', this._onRenderSetMeshes, this);
			render.on('set:meshes', this._onRenderSetMeshes, this);

			if (render.meshes) {
				this._onRenderSetMeshes(render.meshes);
			}
		};

		_proto._onRenderSetMeshes = function _onRenderSetMeshes(meshes) {
			this._onMeshChanged(meshes && meshes[0]);
		};

		_proto.onSetLoop = function onSetLoop(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.resetTime();
			}
		};

		_proto.onSetBlendType = function onSetBlendType(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.material.blendType = newValue;
				this.emitter.resetMaterial();
				this.rebuild();
			}
		};

		_proto._requestDepth = function _requestDepth() {
			if (this._requestedDepth) return;
			if (!depthLayer) depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);

			if (depthLayer) {
				depthLayer.incrementCounter();
				this._requestedDepth = true;
			}
		};

		_proto._releaseDepth = function _releaseDepth() {
			if (!this._requestedDepth) return;

			if (depthLayer) {
				depthLayer.decrementCounter();
				this._requestedDepth = false;
			}
		};

		_proto.onSetDepthSoftening = function onSetDepthSoftening(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (newValue) {
					if (this.enabled && this.entity.enabled) this._requestDepth();
					if (this.emitter) this.emitter[name] = newValue;
				} else {
					if (this.enabled && this.entity.enabled) this._releaseDepth();
					if (this.emitter) this.emitter[name] = newValue;
				}

				if (this.emitter) {
					this.reset();
					this.emitter.resetMaterial();
					this.rebuild();
				}
			}
		};

		_proto.onSetSimpleProperty = function onSetSimpleProperty(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.resetMaterial();
			}
		};

		_proto.onSetComplexProperty = function onSetComplexProperty(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.resetMaterial();
				this.rebuild();
				this.reset();
			}
		};

		_proto.onSetGraphProperty = function onSetGraphProperty(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.rebuildGraphs();
				this.emitter.resetMaterial();
			}
		};

		_proto.onEnable = function onEnable() {
			var data = this.data;

			for (var i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {
				var asset = data[ASSET_PROPERTIES[i]];

				if (asset) {
					if (!(asset instanceof Asset)) {
						var id = parseInt(asset, 10);

						if (id >= 0) {
							asset = this.system.app.assets.get(asset);
						} else {
							continue;
						}
					}

					if (asset && !asset.resource) {
						this.system.app.assets.load(asset);
					}
				}
			}

			if (!this.emitter) {
				var mesh = data.mesh;
				if (!(mesh instanceof Mesh)) mesh = null;
				this.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {
					numParticles: data.numParticles,
					emitterExtents: data.emitterExtents,
					emitterExtentsInner: data.emitterExtentsInner,
					emitterRadius: data.emitterRadius,
					emitterRadiusInner: data.emitterRadiusInner,
					emitterShape: data.emitterShape,
					initialVelocity: data.initialVelocity,
					wrap: data.wrap,
					localSpace: data.localSpace,
					screenSpace: data.screenSpace,
					wrapBounds: data.wrapBounds,
					lifetime: data.lifetime,
					rate: data.rate,
					rate2: data.rate2,
					orientation: data.orientation,
					particleNormal: data.particleNormal,
					animTilesX: data.animTilesX,
					animTilesY: data.animTilesY,
					animStartFrame: data.animStartFrame,
					animNumFrames: data.animNumFrames,
					animNumAnimations: data.animNumAnimations,
					animIndex: data.animIndex,
					randomizeAnimIndex: data.randomizeAnimIndex,
					animSpeed: data.animSpeed,
					animLoop: data.animLoop,
					startAngle: data.startAngle,
					startAngle2: data.startAngle2,
					scaleGraph: data.scaleGraph,
					scaleGraph2: data.scaleGraph2,
					colorGraph: data.colorGraph,
					colorGraph2: data.colorGraph2,
					alphaGraph: data.alphaGraph,
					alphaGraph2: data.alphaGraph2,
					localVelocityGraph: data.localVelocityGraph,
					localVelocityGraph2: data.localVelocityGraph2,
					velocityGraph: data.velocityGraph,
					velocityGraph2: data.velocityGraph2,
					rotationSpeedGraph: data.rotationSpeedGraph,
					rotationSpeedGraph2: data.rotationSpeedGraph2,
					radialSpeedGraph: data.radialSpeedGraph,
					radialSpeedGraph2: data.radialSpeedGraph2,
					colorMap: data.colorMap,
					normalMap: data.normalMap,
					loop: data.loop,
					preWarm: data.preWarm,
					sort: data.sort,
					stretch: data.stretch,
					alignToMotion: data.alignToMotion,
					lighting: data.lighting,
					halfLambert: data.halfLambert,
					intensity: data.intensity,
					depthSoftening: data.depthSoftening,
					scene: this.system.app.scene,
					mesh: mesh,
					depthWrite: data.depthWrite,
					noFog: data.noFog,
					node: this.entity,
					blendType: data.blendType
				});
				this.emitter.meshInstance.node = this.entity;
				this.emitter.drawOrder = this.drawOrder;

				if (!data.autoPlay) {
					this.pause();
					this.emitter.meshInstance.visible = false;
				}
			}

			if (this.emitter.colorMap) {
				this.addMeshInstanceToLayers();
			}

			this.system.app.scene.on("set:layers", this.onLayersChanged, this);

			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.on("add", this.onLayerAdded, this);
				this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
			}

			if (this.enabled && this.entity.enabled && data.depthSoftening) {
				this._requestDepth();
			}
		};

		_proto.onDisable = function onDisable() {
			this.system.app.scene.off("set:layers", this.onLayersChanged, this);

			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.off("add", this.onLayerAdded, this);
				this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
			}

			if (this.emitter) {
				this.removeMeshInstanceFromLayers();
				if (this.data.depthSoftening) this._releaseDepth();
				this.emitter.camera = null;
			}
		};

		_proto.onBeforeRemove = function onBeforeRemove() {
			if (this.enabled) {
				this.enabled = false;
			}

			if (this.emitter) {
				this.emitter.destroy();
				this.emitter = null;
			}

			for (var i = 0; i < ASSET_PROPERTIES.length; i++) {
				var prop = ASSET_PROPERTIES[i];

				if (this.data[prop]) {
					this[prop] = null;
				}
			}

			this.off();
		};

		_proto.reset = function reset() {
			if (this.emitter) {
				this.emitter.reset();
			}
		};

		_proto.stop = function stop() {
			if (this.emitter) {
				this.emitter.loop = false;
				this.emitter.resetTime();
				this.emitter.addTime(0, true);
			}
		};

		_proto.pause = function pause() {
			this.data.paused = true;
		};

		_proto.unpause = function unpause() {
			this.data.paused = false;
		};

		_proto.play = function play() {
			this.data.paused = false;

			if (this.emitter) {
				this.emitter.meshInstance.visible = true;
				this.emitter.loop = this.data.loop;
				this.emitter.resetTime();
			}
		};

		_proto.isPlaying = function isPlaying() {
			if (this.data.paused) {
				return false;
			}

			if (this.emitter && this.emitter.loop) {
				return true;
			}

			return Date.now() <= this.emitter.endTime;
		};

		_proto.rebuild = function rebuild() {
			var enabled = this.enabled;
			this.enabled = false;

			if (this.emitter) {
				this.emitter.rebuild();
				this.emitter.meshInstance.node = this.entity;
			}

			this.enabled = enabled;
		};

		_createClass(ParticleSystemComponent, [{
			key: "drawOrder",
			get: function get() {
				return this._drawOrder;
			},
			set: function set(drawOrder) {
				this._drawOrder = drawOrder;

				if (this.emitter) {
					this.emitter.drawOrder = drawOrder;
				}
			}
		}]);

		return ParticleSystemComponent;
	}(Component);

	var ParticleSystemComponentData = function ParticleSystemComponentData() {
		this.numParticles = 1;
		this.rate = 1;
		this.rate2 = null;
		this.startAngle = 0;
		this.startAngle2 = null;
		this.lifetime = 50;
		this.emitterExtents = new Vec3();
		this.emitterExtentsInner = new Vec3();
		this.emitterRadius = 0;
		this.emitterRadiusInner = 0;
		this.emitterShape = EMITTERSHAPE_BOX;
		this.initialVelocity = 0;
		this.wrapBounds = new Vec3();
		this.localSpace = false;
		this.screenSpace = false;
		this.colorMap = null;
		this.colorMapAsset = null;
		this.normalMap = null;
		this.normalMapAsset = null;
		this.loop = true;
		this.preWarm = false;
		this.sort = 0;
		this.mode = PARTICLEMODE_GPU;
		this.scene = null;
		this.lighting = false;
		this.halfLambert = false;
		this.intensity = 1;
		this.stretch = 0.0;
		this.alignToMotion = false;
		this.depthSoftening = 0;
		this.meshAsset = null;
		this.mesh = null;
		this.depthWrite = false;
		this.noFog = false;
		this.orientation = PARTICLEORIENTATION_SCREEN;
		this.particleNormal = new Vec3(0, 1, 0);
		this.animTilesX = 1;
		this.animTilesY = 1;
		this.animStartFrame = 0;
		this.animNumFrames = 1;
		this.animNumAnimations = 1;
		this.animIndex = 0;
		this.randomizeAnimIndex = false;
		this.animSpeed = 1;
		this.animLoop = true;
		this.scaleGraph = null;
		this.scaleGraph2 = null;
		this.colorGraph = null;
		this.colorGraph2 = null;
		this.alphaGraph = null;
		this.alphaGraph2 = null;
		this.localVelocityGraph = null;
		this.localVelocityGraph2 = null;
		this.velocityGraph = null;
		this.velocityGraph2 = null;
		this.rotationSpeedGraph = null;
		this.rotationSpeedGraph2 = null;
		this.radialSpeedGraph = null;
		this.radialSpeedGraph2 = null;
		this.blendType = BLEND_NORMAL;
		this.enabled = true;
		this.paused = false;
		this.autoPlay = true;
		this.layers = [LAYERID_WORLD];
	};

	var _schema$8 = ['enabled', 'autoPlay', 'numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'loop', 'preWarm', 'lighting', 'halfLambert', 'intensity', 'depthWrite', 'noFog', 'depthSoftening', 'sort', 'blendType', 'stretch', 'alignToMotion', 'emitterShape', 'emitterExtents', 'emitterExtentsInner', 'emitterRadius', 'emitterRadiusInner', 'initialVelocity', 'wrap', 'wrapBounds', 'localSpace', 'screenSpace', 'colorMapAsset', 'normalMapAsset', 'mesh', 'meshAsset', 'renderAsset', 'orientation', 'particleNormal', 'localVelocityGraph', 'localVelocityGraph2', 'velocityGraph', 'velocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2', 'scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'colorMap', 'normalMap', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animSpeed', 'animLoop', 'layers'];

	var ParticleSystemComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ParticleSystemComponentSystem, _ComponentSystem);

		function ParticleSystemComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'particlesystem';
			_this.ComponentType = ParticleSystemComponent;
			_this.DataType = ParticleSystemComponentData;
			_this.schema = _schema$8;
			_this.propertyTypes = {
				emitterExtents: 'vec3',
				emitterExtentsInner: 'vec3',
				particleNormal: 'vec3',
				wrapBounds: 'vec3',
				localVelocityGraph: 'curveset',
				localVelocityGraph2: 'curveset',
				velocityGraph: 'curveset',
				velocityGraph2: 'curveset',
				colorGraph: 'curveset',
				colorGraph2: 'curveset',
				alphaGraph: 'curve',
				alphaGraph2: 'curve',
				rotationSpeedGraph: 'curve',
				rotationSpeedGraph2: 'curve',
				radialSpeedGraph: 'curve',
				radialSpeedGraph2: 'curve',
				scaleGraph: 'curve',
				scaleGraph2: 'curve'
			};

			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = ParticleSystemComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, _data, properties) {
			var data = {};
			properties = [];
			var types = this.propertyTypes;

			if (_data.mesh instanceof Asset || typeof _data.mesh === 'number') {
				_data.meshAsset = _data.mesh;
				delete _data.mesh;
			}

			for (var prop in _data) {
				if (_data.hasOwnProperty(prop)) {
					properties.push(prop);
					data[prop] = _data[prop];
				}

				if (types[prop] === 'vec3') {
					if (Array.isArray(data[prop])) {
						data[prop] = new Vec3(data[prop][0], data[prop][1], data[prop][2]);
					}
				} else if (types[prop] === 'curve') {
					if (!(data[prop] instanceof Curve)) {
						var t = data[prop].type;
						data[prop] = new Curve(data[prop].keys);
						data[prop].type = t;
					}
				} else if (types[prop] === 'curveset') {
					if (!(data[prop] instanceof CurveSet)) {
						var _t = data[prop].type;
						data[prop] = new CurveSet(data[prop].keys);
						data[prop].type = _t;
					}
				}

				if (data.layers && Array.isArray(data.layers)) {
					data.layers = data.layers.slice(0);
				}
			}

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var source = entity.particlesystem.data;
			var schema = this.schema;
			var data = {};

			for (var i = 0, len = schema.length; i < len; i++) {
				var prop = schema[i];
				var sourceProp = source[prop];

				if (sourceProp instanceof Vec3 || sourceProp instanceof Curve || sourceProp instanceof CurveSet) {
					sourceProp = sourceProp.clone();
					data[prop] = sourceProp;
				} else if (prop === "layers") {
					data.layers = source.layers.slice(0);
				} else {
					if (sourceProp !== null && sourceProp !== undefined) {
						data[prop] = sourceProp;
					}
				}
			}

			return this.addComponent(clone, data);
		};

		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;
			var numSteps;
			var stats = this.app.stats.particles;

			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					var entity = component.entity;
					var data = component.data;

					if (data.enabled && entity.enabled) {
						var emitter = entity.particlesystem.emitter;
						if (!emitter.meshInstance.visible) continue;

						if (emitter.lighting) {
							var layers = data.layers;
							var lightCube = void 0;

							for (var i = 0; i < layers.length; i++) {
								var layer = this.app.scene.layers.getLayerById(layers[i]);
								if (!layer) continue;

								if (!layer._lightCube) {
									layer._lightCube = new Float32Array(6 * 3);
								}

								lightCube = layer._lightCube;

								for (var j = 0; j < 6; j++) {
									lightCube[j * 3] = this.app.scene.ambientLight.r;
									lightCube[j * 3 + 1] = this.app.scene.ambientLight.g;
									lightCube[j * 3 + 2] = this.app.scene.ambientLight.b;
								}

								var dirs = layer._splitLights[LIGHTTYPE_DIRECTIONAL];

								for (var _j = 0; _j < dirs.length; _j++) {
									for (var c = 0; c < 6; c++) {
										var weight = Math.max(emitter.lightCubeDir[c].dot(dirs[_j]._direction), 0) * dirs[_j]._intensity;

										lightCube[c * 3] += dirs[_j]._color.r * weight;
										lightCube[c * 3 + 1] += dirs[_j]._color.g * weight;
										lightCube[c * 3 + 2] += dirs[_j]._color.b * weight;
									}
								}
							}

							emitter.constantLightCube.setValue(lightCube);
						}

						if (!data.paused) {
							emitter.simTime += dt;

							if (emitter.simTime > emitter.fixedTimeStep) {
								numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);
								emitter.simTime -= numSteps * emitter.fixedTimeStep;
							}

							if (numSteps) {
								numSteps = Math.min(numSteps, emitter.maxSubSteps);

								for (var _i = 0; _i < numSteps; _i++) {
									emitter.addTime(emitter.fixedTimeStep, false);
								}

								stats._updatesPerFrame += numSteps;
								stats._frameTime += emitter._addTimeTime;
								emitter._addTimeTime = 0;
							}

							emitter.finishFrame();
						}
					}
				}
			}
		};

		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			component.onBeforeRemove();
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off('update', this.onUpdate, this);
		};

		return ParticleSystemComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ParticleSystemComponent.prototype, _schema$8);

	var ObjectPool = function () {
		function ObjectPool(constructorFunc, size) {
			this._constructor = constructorFunc;
			this._pool = [];
			this._count = 0;

			this._resize(size);
		}

		var _proto = ObjectPool.prototype;

		_proto._resize = function _resize(size) {
			if (size > this._pool.length) {
				for (var i = this._pool.length; i < size; i++) {
					this._pool[i] = new this._constructor();
				}
			}
		};

		_proto.allocate = function allocate() {
			if (this._count >= this._pool.length) {
				this._resize(this._pool.length * 2);
			}

			return this._pool[this._count++];
		};

		_proto.freeAll = function freeAll() {
			this._count = 0;
		};

		return ObjectPool;
	}();

	var ammoTransform;
	var ammoVec1, ammoVec2, ammoQuat, ammoOrigin;

	var RigidBodyComponent = function (_Component) {
		_inheritsLoose(RigidBodyComponent, _Component);

		function RigidBodyComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._angularDamping = 0;
			_this._angularFactor = new Vec3(1, 1, 1);
			_this._angularVelocity = new Vec3();
			_this._body = null;
			_this._friction = 0.5;
			_this._group = BODYGROUP_STATIC;
			_this._linearDamping = 0;
			_this._linearFactor = new Vec3(1, 1, 1);
			_this._linearVelocity = new Vec3();
			_this._mask = BODYMASK_NOT_STATIC;
			_this._mass = 1;
			_this._restitution = 0;
			_this._rollingFriction = 0;
			_this._simulationEnabled = false;
			_this._type = BODYTYPE_STATIC;
			return _this;
		}

		RigidBodyComponent.onLibraryLoaded = function onLibraryLoaded() {
			if (typeof Ammo !== 'undefined' && !ammoTransform) {
				ammoTransform = new Ammo.btTransform();
				ammoVec1 = new Ammo.btVector3();
				ammoVec2 = new Ammo.btVector3();
				ammoQuat = new Ammo.btQuaternion();
				ammoOrigin = new Ammo.btVector3(0, 0, 0);
			}
		};

		var _proto = RigidBodyComponent.prototype;

		_proto.createBody = function createBody() {
			var entity = this.entity;
			var shape;

			if (entity.collision) {
				shape = entity.collision.shape;

				if (entity.trigger) {
					entity.trigger.destroy();
					delete entity.trigger;
				}
			}

			if (shape) {
				if (this._body) this.system.onRemove(entity, this);
				var mass = this._type === BODYTYPE_DYNAMIC ? this._mass : 0;

				this._getEntityTransform(ammoTransform);

				var body = this.system.createBody(mass, shape, ammoTransform);
				body.setRestitution(this._restitution);
				body.setFriction(this._friction);
				body.setRollingFriction(this._rollingFriction);
				body.setDamping(this._linearDamping, this._angularDamping);

				if (this._type === BODYTYPE_DYNAMIC) {
					var linearFactor = this._linearFactor;
					ammoVec1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);
					body.setLinearFactor(ammoVec1);
					var angularFactor = this._angularFactor;
					ammoVec1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);
					body.setAngularFactor(ammoVec1);
				} else if (this._type === BODYTYPE_KINEMATIC) {
					body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);
					body.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);
				}

				body.entity = entity;
				this.body = body;

				if (this.enabled && entity.enabled) {
					this.enableSimulation();
				}
			}
		};

		_proto.isActive = function isActive() {
			return this._body ? this._body.isActive() : false;
		};

		_proto.activate = function activate() {
			if (this._body) {
				this._body.activate();
			}
		};

		_proto.enableSimulation = function enableSimulation() {
			var entity = this.entity;

			if (entity.collision && entity.collision.enabled && !this._simulationEnabled) {
				var body = this._body;

				if (body) {
					this.system.addBody(body, this._group, this._mask);

					switch (this._type) {
						case BODYTYPE_DYNAMIC:
							this.system._dynamic.push(this);

							body.forceActivationState(BODYSTATE_ACTIVE_TAG);
							this.syncEntityToBody();
							break;

						case BODYTYPE_KINEMATIC:
							this.system._kinematic.push(this);

							body.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);
							break;

						case BODYTYPE_STATIC:
							body.forceActivationState(BODYSTATE_ACTIVE_TAG);
							this.syncEntityToBody();
							break;
					}

					if (entity.collision.type === 'compound') {
						this.system._compounds.push(entity.collision);
					}

					body.activate();
					this._simulationEnabled = true;
				}
			}
		};

		_proto.disableSimulation = function disableSimulation() {
			var body = this._body;

			if (body && this._simulationEnabled) {
				var system = this.system;

				var idx = system._compounds.indexOf(this.entity.collision);

				if (idx > -1) {
					system._compounds.splice(idx, 1);
				}

				idx = system._dynamic.indexOf(this);

				if (idx > -1) {
					system._dynamic.splice(idx, 1);
				}

				idx = system._kinematic.indexOf(this);

				if (idx > -1) {
					system._kinematic.splice(idx, 1);
				}

				system.removeBody(body);
				body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
				this._simulationEnabled = false;
			}
		};

		_proto.applyForce = function applyForce() {
			var x, y, z;
			var px, py, pz;

			switch (arguments.length) {
				case 1:
					x = arguments[0].x;
					y = arguments[0].y;
					z = arguments[0].z;
					break;

				case 2:
					x = arguments[0].x;
					y = arguments[0].y;
					z = arguments[0].z;
					px = arguments[1].x;
					py = arguments[1].y;
					pz = arguments[1].z;
					break;

				case 3:
					x = arguments[0];
					y = arguments[1];
					z = arguments[2];
					break;

				case 6:
					x = arguments[0];
					y = arguments[1];
					z = arguments[2];
					px = arguments[3];
					py = arguments[4];
					pz = arguments[5];
					break;
			}

			var body = this._body;

			if (body) {
				body.activate();
				ammoVec1.setValue(x, y, z);

				if (px !== undefined) {
					ammoVec2.setValue(px, py, pz);
					body.applyForce(ammoVec1, ammoVec2);
				} else {
					body.applyForce(ammoVec1, ammoOrigin);
				}
			}
		};

		_proto.applyTorque = function applyTorque() {
			var x, y, z;

			switch (arguments.length) {
				case 1:
					x = arguments[0].x;
					y = arguments[0].y;
					z = arguments[0].z;
					break;

				case 3:
					x = arguments[0];
					y = arguments[1];
					z = arguments[2];
					break;

				default:
					Debug.error('ERROR: applyTorque: function takes 1 or 3 arguments');
					return;
			}

			var body = this._body;

			if (body) {
				body.activate();
				ammoVec1.setValue(x, y, z);
				body.applyTorque(ammoVec1);
			}
		};

		_proto.applyImpulse = function applyImpulse() {
			var x, y, z;
			var px, py, pz;

			switch (arguments.length) {
				case 1:
					x = arguments[0].x;
					y = arguments[0].y;
					z = arguments[0].z;
					break;

				case 2:
					x = arguments[0].x;
					y = arguments[0].y;
					z = arguments[0].z;
					px = arguments[1].x;
					py = arguments[1].y;
					pz = arguments[1].z;
					break;

				case 3:
					x = arguments[0];
					y = arguments[1];
					z = arguments[2];
					break;

				case 6:
					x = arguments[0];
					y = arguments[1];
					z = arguments[2];
					px = arguments[3];
					py = arguments[4];
					pz = arguments[5];
					break;

				default:
					Debug.error('ERROR: applyImpulse: function takes 1, 2, 3 or 6 arguments');
					return;
			}

			var body = this._body;

			if (body) {
				body.activate();
				ammoVec1.setValue(x, y, z);

				if (px !== undefined) {
					ammoVec2.setValue(px, py, pz);
					body.applyImpulse(ammoVec1, ammoVec2);
				} else {
					body.applyImpulse(ammoVec1, ammoOrigin);
				}
			}
		};

		_proto.applyTorqueImpulse = function applyTorqueImpulse() {
			var x, y, z;

			switch (arguments.length) {
				case 1:
					x = arguments[0].x;
					y = arguments[0].y;
					z = arguments[0].z;
					break;

				case 3:
					x = arguments[0];
					y = arguments[1];
					z = arguments[2];
					break;

				default:
					Debug.error('ERROR: applyTorqueImpulse: function takes 1 or 3 arguments');
					return;
			}

			var body = this._body;

			if (body) {
				body.activate();
				ammoVec1.setValue(x, y, z);
				body.applyTorqueImpulse(ammoVec1);
			}
		};

		_proto.isStatic = function isStatic() {
			return this._type === BODYTYPE_STATIC;
		};

		_proto.isStaticOrKinematic = function isStaticOrKinematic() {
			return this._type === BODYTYPE_STATIC || this._type === BODYTYPE_KINEMATIC;
		};

		_proto.isKinematic = function isKinematic() {
			return this._type === BODYTYPE_KINEMATIC;
		};

		_proto._getEntityTransform = function _getEntityTransform(transform) {
			var entity = this.entity;
			var pos = entity.getPosition();
			var rot = entity.getRotation();
			ammoVec1.setValue(pos.x, pos.y, pos.z);
			ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
			transform.setOrigin(ammoVec1);
			transform.setRotation(ammoQuat);
		};

		_proto.syncEntityToBody = function syncEntityToBody() {
			var body = this._body;

			if (body) {
				this._getEntityTransform(ammoTransform);

				body.setWorldTransform(ammoTransform);

				if (this._type === BODYTYPE_KINEMATIC) {
					var motionState = body.getMotionState();

					if (motionState) {
						motionState.setWorldTransform(ammoTransform);
					}
				}

				body.activate();
			}
		};

		_proto._updateDynamic = function _updateDynamic() {
			var body = this._body;

			if (body.isActive()) {
				var motionState = body.getMotionState();

				if (motionState) {
					motionState.getWorldTransform(ammoTransform);
					var p = ammoTransform.getOrigin();
					var q = ammoTransform.getRotation();
					this.entity.setPosition(p.x(), p.y(), p.z());
					this.entity.setRotation(q.x(), q.y(), q.z(), q.w());
				}
			}
		};

		_proto._updateKinematic = function _updateKinematic() {
			var motionState = this._body.getMotionState();

			if (motionState) {
				this._getEntityTransform(ammoTransform);

				motionState.setWorldTransform(ammoTransform);
			}
		};

		_proto.teleport = function teleport() {
			if (arguments.length < 3) {
				if (arguments[0]) {
					this.entity.setPosition(arguments[0]);
				}

				if (arguments[1]) {
					if (arguments[1] instanceof Quat) {
						this.entity.setRotation(arguments[1]);
					} else {
						this.entity.setEulerAngles(arguments[1]);
					}
				}
			} else {
				if (arguments.length === 6) {
					this.entity.setEulerAngles(arguments[3], arguments[4], arguments[5]);
				}

				this.entity.setPosition(arguments[0], arguments[1], arguments[2]);
			}

			this.syncEntityToBody();
		};

		_proto.onEnable = function onEnable() {
			if (!this._body) {
				this.createBody();
			}

			this.enableSimulation();
		};

		_proto.onDisable = function onDisable() {
			this.disableSimulation();
		};

		_createClass(RigidBodyComponent, [{
			key: "angularDamping",
			get: function get() {
				return this._angularDamping;
			},
			set: function set(damping) {
				if (this._angularDamping !== damping) {
					this._angularDamping = damping;

					if (this._body) {
						this._body.setDamping(this._linearDamping, damping);
					}
				}
			}
		}, {
			key: "angularFactor",
			get: function get() {
				return this._angularFactor;
			},
			set: function set(factor) {
				if (!this._angularFactor.equals(factor)) {
					this._angularFactor.copy(factor);

					if (this._body && this._type === BODYTYPE_DYNAMIC) {
						ammoVec1.setValue(factor.x, factor.y, factor.z);

						this._body.setAngularFactor(ammoVec1);
					}
				}
			}
		}, {
			key: "angularVelocity",
			get: function get() {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
					var velocity = this._body.getAngularVelocity();

					this._angularVelocity.set(velocity.x(), velocity.y(), velocity.z());
				}

				return this._angularVelocity;
			},
			set: function set(velocity) {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
					this._body.activate();

					ammoVec1.setValue(velocity.x, velocity.y, velocity.z);

					this._body.setAngularVelocity(ammoVec1);

					this._angularVelocity.copy(velocity);
				}
			}
		}, {
			key: "body",
			get: function get() {
				return this._body;
			},
			set: function set(body) {
				if (this._body !== body) {
					this._body = body;

					if (body && this._simulationEnabled) {
						body.activate();
					}
				}
			}
		}, {
			key: "friction",
			get: function get() {
				return this._friction;
			},
			set: function set(friction) {
				if (this._friction !== friction) {
					this._friction = friction;

					if (this._body) {
						this._body.setFriction(friction);
					}
				}
			}
		}, {
			key: "group",
			get: function get() {
				return this._group;
			},
			set: function set(group) {
				if (this._group !== group) {
					this._group = group;

					if (this.enabled && this.entity.enabled) {
						this.disableSimulation();
						this.enableSimulation();
					}
				}
			}
		}, {
			key: "linearDamping",
			get: function get() {
				return this._linearDamping;
			},
			set: function set(damping) {
				if (this._linearDamping !== damping) {
					this._linearDamping = damping;

					if (this._body) {
						this._body.setDamping(damping, this._angularDamping);
					}
				}
			}
		}, {
			key: "linearFactor",
			get: function get() {
				return this._linearFactor;
			},
			set: function set(factor) {
				if (!this._linearFactor.equals(factor)) {
					this._linearFactor.copy(factor);

					if (this._body && this._type === BODYTYPE_DYNAMIC) {
						ammoVec1.setValue(factor.x, factor.y, factor.z);

						this._body.setLinearFactor(ammoVec1);
					}
				}
			}
		}, {
			key: "linearVelocity",
			get: function get() {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
					var velocity = this._body.getLinearVelocity();

					this._linearVelocity.set(velocity.x(), velocity.y(), velocity.z());
				}

				return this._linearVelocity;
			},
			set: function set(velocity) {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
					this._body.activate();

					ammoVec1.setValue(velocity.x, velocity.y, velocity.z);

					this._body.setLinearVelocity(ammoVec1);

					this._linearVelocity.copy(velocity);
				}
			}
		}, {
			key: "mask",
			get: function get() {
				return this._mask;
			},
			set: function set(mask) {
				if (this._mask !== mask) {
					this._mask = mask;

					if (this.enabled && this.entity.enabled) {
						this.disableSimulation();
						this.enableSimulation();
					}
				}
			}
		}, {
			key: "mass",
			get: function get() {
				return this._mass;
			},
			set: function set(mass) {
				if (this._mass !== mass) {
					this._mass = mass;

					if (this._body && this._type === BODYTYPE_DYNAMIC) {
						var enabled = this.enabled && this.entity.enabled;

						if (enabled) {
							this.disableSimulation();
						}

						this._body.getCollisionShape().calculateLocalInertia(mass, ammoVec1);

						this._body.setMassProps(mass, ammoVec1);

						this._body.updateInertiaTensor();

						if (enabled) {
							this.enableSimulation();
						}
					}
				}
			}
		}, {
			key: "restitution",
			get: function get() {
				return this._restitution;
			},
			set: function set(restitution) {
				if (this._restitution !== restitution) {
					this._restitution = restitution;

					if (this._body) {
						this._body.setRestitution(restitution);
					}
				}
			}
		}, {
			key: "rollingFriction",
			get: function get() {
				return this._rollingFriction;
			},
			set: function set(friction) {
				if (this._rollingFriction !== friction) {
					this._rollingFriction = friction;

					if (this._body) {
						this._body.setRollingFriction(friction);
					}
				}
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(type) {
				if (this._type !== type) {
					this._type = type;
					this.disableSimulation();

					switch (type) {
						case BODYTYPE_DYNAMIC:
							this._group = BODYGROUP_DYNAMIC;
							this._mask = BODYMASK_ALL;
							break;

						case BODYTYPE_KINEMATIC:
							this._group = BODYGROUP_KINEMATIC;
							this._mask = BODYMASK_ALL;
							break;

						case BODYTYPE_STATIC:
						default:
							this._group = BODYGROUP_STATIC;
							this._mask = BODYMASK_NOT_STATIC;
							break;
					}

					this.createBody();
				}
			}
		}]);

		return RigidBodyComponent;
	}(Component);

	var RigidBodyComponentData = function RigidBodyComponentData() {
		this.enabled = true;
	};

	var ammoRayStart, ammoRayEnd;

	var RaycastResult = function RaycastResult(entity, point, normal) {
		this.entity = entity;
		this.point = point;
		this.normal = normal;
	};

	var SingleContactResult = function SingleContactResult(a, b, contactPoint) {
		if (arguments.length === 0) {
			this.a = null;
			this.b = null;
			this.impulse = 0;
			this.localPointA = new Vec3();
			this.localPointB = new Vec3();
			this.pointA = new Vec3();
			this.pointB = new Vec3();
			this.normal = new Vec3();
		} else {
			this.a = a;
			this.b = b;
			this.impulse = contactPoint.impulse;
			this.localPointA = contactPoint.localPoint;
			this.localPointB = contactPoint.localPointOther;
			this.pointA = contactPoint.point;
			this.pointB = contactPoint.pointOther;
			this.normal = contactPoint.normal;
		}
	};

	var ContactPoint = function ContactPoint(localPoint, localPointOther, point, pointOther, normal, impulse) {
		if (localPoint === void 0) {
			localPoint = new Vec3();
		}

		if (localPointOther === void 0) {
			localPointOther = new Vec3();
		}

		if (point === void 0) {
			point = new Vec3();
		}

		if (pointOther === void 0) {
			pointOther = new Vec3();
		}

		if (normal === void 0) {
			normal = new Vec3();
		}

		if (impulse === void 0) {
			impulse = 0;
		}

		this.localPoint = localPoint;
		this.localPointOther = localPointOther;
		this.point = point;
		this.pointOther = pointOther;
		this.normal = normal;
		this.impulse = impulse;
	};

	var ContactResult = function ContactResult(other, contacts) {
		this.other = other;
		this.contacts = contacts;
	};

	var _schema$7 = ['enabled'];

	var RigidBodyComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(RigidBodyComponentSystem, _ComponentSystem);

		function RigidBodyComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.maxSubSteps = 10;
			_this.fixedTimeStep = 1 / 60;
			_this.gravity = new Vec3(0, -9.81, 0);
			_this._dynamic = [];
			_this._kinematic = [];
			_this._triggers = [];
			_this._compounds = [];
			_this.id = 'rigidbody';
			_this._stats = app.stats.frame;
			_this.ComponentType = RigidBodyComponent;
			_this.DataType = RigidBodyComponentData;
			_this.contactPointPool = null;
			_this.contactResultPool = null;
			_this.singleContactResultPool = null;
			_this.schema = _schema$7;
			_this.collisions = {};
			_this.frameCollisions = {};

			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

			_this.on('remove', _this.onRemove, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = RigidBodyComponentSystem.prototype;

		_proto.onLibraryLoaded = function onLibraryLoaded() {
			if (typeof Ammo !== 'undefined') {
				this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
				this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
				this.overlappingPairCache = new Ammo.btDbvtBroadphase();
				this.solver = new Ammo.btSequentialImpulseConstraintSolver();
				this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);

				if (this.dynamicsWorld.setInternalTickCallback) {
					var checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');
					this.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);
				} else {
					Debug.warn("WARNING: This version of ammo.js can potentially fail to report contacts. Please update it to the latest version.");
				}

				ammoRayStart = new Ammo.btVector3();
				ammoRayEnd = new Ammo.btVector3();
				RigidBodyComponent.onLibraryLoaded();
				this.contactPointPool = new ObjectPool(ContactPoint, 1);
				this.contactResultPool = new ObjectPool(ContactResult, 1);
				this.singleContactResultPool = new ObjectPool(SingleContactResult, 1);
				this.app.systems.on('update', this.onUpdate, this);
			} else {
				this.app.systems.off('update', this.onUpdate, this);
			}
		};

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			var props = ['mass', 'linearDamping', 'angularDamping', 'linearFactor', 'angularFactor', 'friction', 'rollingFriction', 'restitution', 'type', 'group', 'mask'];

			for (var _i = 0, _props = props; _i < _props.length; _i++) {
				var property = _props[_i];

				if (data.hasOwnProperty(property)) {
					var value = data[property];

					if (Array.isArray(value)) {
						component[property] = new Vec3(value[0], value[1], value[2]);
					} else {
						component[property] = value;
					}
				}
			}

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var rigidbody = entity.rigidbody;
			var data = {
				enabled: rigidbody.enabled,
				mass: rigidbody.mass,
				linearDamping: rigidbody.linearDamping,
				angularDamping: rigidbody.angularDamping,
				linearFactor: [rigidbody.linearFactor.x, rigidbody.linearFactor.y, rigidbody.linearFactor.z],
				angularFactor: [rigidbody.angularFactor.x, rigidbody.angularFactor.y, rigidbody.angularFactor.z],
				friction: rigidbody.friction,
				rollingFriction: rigidbody.rollingFriction,
				restitution: rigidbody.restitution,
				type: rigidbody.type,
				group: rigidbody.group,
				mask: rigidbody.mask
			};
			return this.addComponent(clone, data);
		};

		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			if (component.enabled) {
				component.enabled = false;
			}
		};

		_proto.onRemove = function onRemove(entity, component) {
			var body = component.body;

			if (body) {
				this.removeBody(body);
				this.destroyBody(body);
				component.body = null;
			}
		};

		_proto.addBody = function addBody(body, group, mask) {
			if (group !== undefined && mask !== undefined) {
				this.dynamicsWorld.addRigidBody(body, group, mask);
			} else {
				this.dynamicsWorld.addRigidBody(body);
			}
		};

		_proto.removeBody = function removeBody(body) {
			this.dynamicsWorld.removeRigidBody(body);
		};

		_proto.createBody = function createBody(mass, shape, transform) {
			var localInertia = new Ammo.btVector3(0, 0, 0);

			if (mass !== 0) {
				shape.calculateLocalInertia(mass, localInertia);
			}

			var motionState = new Ammo.btDefaultMotionState(transform);
			var bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
			var body = new Ammo.btRigidBody(bodyInfo);
			Ammo.destroy(bodyInfo);
			Ammo.destroy(localInertia);
			return body;
		};

		_proto.destroyBody = function destroyBody(body) {
			var motionState = body.getMotionState();

			if (motionState) {
				Ammo.destroy(motionState);
			}

			Ammo.destroy(body);
		};

		_proto.raycastFirst = function raycastFirst(start, end) {
			var result = null;
			ammoRayStart.setValue(start.x, start.y, start.z);
			ammoRayEnd.setValue(end.x, end.y, end.z);
			var rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);
			this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);

			if (rayCallback.hasHit()) {
				var collisionObj = rayCallback.get_m_collisionObject();
				var body = Ammo.castObject(collisionObj, Ammo.btRigidBody);

				if (body) {
					var point = rayCallback.get_m_hitPointWorld();
					var normal = rayCallback.get_m_hitNormalWorld();
					result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()));

					if (arguments.length > 2) {
						Debug.deprecated('pc.RigidBodyComponentSystem#rayCastFirst no longer requires a callback. The result of the raycast is returned by the function instead.');
						var callback = arguments[2];
						callback(result);
					}
				}
			}

			Ammo.destroy(rayCallback);
			return result;
		};

		_proto.raycastAll = function raycastAll(start, end) {
			Debug.assert(Ammo.AllHitsRayResultCallback, "pc.RigidBodyComponentSystem#raycastAll: Your version of ammo.js does not expose Ammo.AllHitsRayResultCallback. Update it to latest.");
			var results = [];
			ammoRayStart.setValue(start.x, start.y, start.z);
			ammoRayEnd.setValue(end.x, end.y, end.z);
			var rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);
			this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);

			if (rayCallback.hasHit()) {
				var collisionObjs = rayCallback.get_m_collisionObjects();
				var points = rayCallback.get_m_hitPointWorld();
				var normals = rayCallback.get_m_hitNormalWorld();
				var numHits = collisionObjs.size();

				for (var i = 0; i < numHits; i++) {
					var body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);

					if (body) {
						var point = points.at(i);
						var normal = normals.at(i);
						var result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()));
						results.push(result);
					}
				}
			}

			Ammo.destroy(rayCallback);
			return results;
		};

		_proto._storeCollision = function _storeCollision(entity, other) {
			var isNewCollision = false;
			var guid = entity.getGuid();
			this.collisions[guid] = this.collisions[guid] || {
				others: [],
				entity: entity
			};

			if (this.collisions[guid].others.indexOf(other) < 0) {
				this.collisions[guid].others.push(other);
				isNewCollision = true;
			}

			this.frameCollisions[guid] = this.frameCollisions[guid] || {
				others: [],
				entity: entity
			};
			this.frameCollisions[guid].others.push(other);
			return isNewCollision;
		};

		_proto._createContactPointFromAmmo = function _createContactPointFromAmmo(contactPoint) {
			var localPointA = contactPoint.get_m_localPointA();
			var localPointB = contactPoint.get_m_localPointB();
			var positionWorldOnA = contactPoint.getPositionWorldOnA();
			var positionWorldOnB = contactPoint.getPositionWorldOnB();
			var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
			var contact = this.contactPointPool.allocate();
			contact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());
			contact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());
			contact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
			contact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
			contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
			contact.impulse = contactPoint.getAppliedImpulse();
			return contact;
		};

		_proto._createReverseContactPointFromAmmo = function _createReverseContactPointFromAmmo(contactPoint) {
			var localPointA = contactPoint.get_m_localPointA();
			var localPointB = contactPoint.get_m_localPointB();
			var positionWorldOnA = contactPoint.getPositionWorldOnA();
			var positionWorldOnB = contactPoint.getPositionWorldOnB();
			var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
			var contact = this.contactPointPool.allocate();
			contact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());
			contact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());
			contact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
			contact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
			contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
			contact.impulse = contactPoint.getAppliedImpulse();
			return contact;
		};

		_proto._createSingleContactResult = function _createSingleContactResult(a, b, contactPoint) {
			var result = this.singleContactResultPool.allocate();
			result.a = a;
			result.b = b;
			result.localPointA = contactPoint.localPoint;
			result.localPointB = contactPoint.localPointOther;
			result.pointA = contactPoint.point;
			result.pointB = contactPoint.pointOther;
			result.normal = contactPoint.normal;
			result.impulse = contactPoint.impulse;
			return result;
		};

		_proto._createContactResult = function _createContactResult(other, contacts) {
			var result = this.contactResultPool.allocate();
			result.other = other;
			result.contacts = contacts;
			return result;
		};

		_proto._cleanOldCollisions = function _cleanOldCollisions() {
			for (var guid in this.collisions) {
				if (this.collisions.hasOwnProperty(guid)) {
					var frameCollision = this.frameCollisions[guid];
					var collision = this.collisions[guid];
					var entity = collision.entity;
					var entityCollision = entity.collision;
					var entityRigidbody = entity.rigidbody;
					var others = collision.others;
					var length = others.length;
					var i = length;

					while (i--) {
						var other = others[i];

						if (!frameCollision || frameCollision.others.indexOf(other) < 0) {
							others.splice(i, 1);

							if (entity.trigger) {
								if (entityCollision) {
									entityCollision.fire("triggerleave", other);
								}

								if (other.rigidbody) {
									other.rigidbody.fire('triggerleave', entity);
								}
							} else if (!other.trigger) {
								if (entityRigidbody) {
									entityRigidbody.fire("collisionend", other);
								}

								if (entityCollision) {
									entityCollision.fire("collisionend", other);
								}
							}
						}
					}

					if (others.length === 0) {
						delete this.collisions[guid];
					}
				}
			}
		};

		_proto._hasContactEvent = function _hasContactEvent(entity) {
			var c = entity.collision;

			if (c && (c.hasEvent("collisionstart") || c.hasEvent("collisionend") || c.hasEvent("contact"))) {
				return true;
			}

			var r = entity.rigidbody;
			return r && (r.hasEvent("collisionstart") || r.hasEvent("collisionend") || r.hasEvent("contact"));
		};

		_proto._checkForCollisions = function _checkForCollisions(world, timeStep) {
			var dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);
			var dispatcher = dynamicsWorld.getDispatcher();
			var numManifolds = dispatcher.getNumManifolds();
			this.frameCollisions = {};

			for (var i = 0; i < numManifolds; i++) {
				var manifold = dispatcher.getManifoldByIndexInternal(i);
				var body0 = manifold.getBody0();
				var body1 = manifold.getBody1();
				var wb0 = Ammo.castObject(body0, Ammo.btRigidBody);
				var wb1 = Ammo.castObject(body1, Ammo.btRigidBody);
				var e0 = wb0.entity;
				var e1 = wb1.entity;

				if (!e0 || !e1) {
					continue;
				}

				var flags0 = wb0.getCollisionFlags();
				var flags1 = wb1.getCollisionFlags();
				var numContacts = manifold.getNumContacts();
				var forwardContacts = [];
				var reverseContacts = [];
				var newCollision = void 0;

				if (numContacts > 0) {
					if (flags0 & BODYFLAG_NORESPONSE_OBJECT || flags1 & BODYFLAG_NORESPONSE_OBJECT) {
						var e0Events = e0.collision && (e0.collision.hasEvent("triggerenter") || e0.collision.hasEvent("triggerleave"));
						var e1Events = e1.collision && (e1.collision.hasEvent("triggerenter") || e1.collision.hasEvent("triggerleave"));
						var e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent("triggerenter") || e0.rigidbody.hasEvent("triggerleave"));
						var e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent("triggerenter") || e1.rigidbody.hasEvent("triggerleave"));

						if (e0Events) {
							newCollision = this._storeCollision(e0, e1);

							if (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {
								e0.collision.fire("triggerenter", e1);
							}
						}

						if (e1Events) {
							newCollision = this._storeCollision(e1, e0);

							if (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {
								e1.collision.fire("triggerenter", e0);
							}
						}

						if (e0BodyEvents) {
							if (!newCollision) {
								newCollision = this._storeCollision(e1, e0);
							}

							if (newCollision) {
								e0.rigidbody.fire("triggerenter", e1);
							}
						}

						if (e1BodyEvents) {
							if (!newCollision) {
								newCollision = this._storeCollision(e0, e1);
							}

							if (newCollision) {
								e1.rigidbody.fire("triggerenter", e0);
							}
						}
					} else {
						var _e0Events = this._hasContactEvent(e0);

						var _e1Events = this._hasContactEvent(e1);

						var globalEvents = this.hasEvent("contact");

						if (globalEvents || _e0Events || _e1Events) {
							for (var j = 0; j < numContacts; j++) {
								var btContactPoint = manifold.getContactPoint(j);

								var contactPoint = this._createContactPointFromAmmo(btContactPoint);

								if (_e0Events || _e1Events) {
									forwardContacts.push(contactPoint);

									var reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);

									reverseContacts.push(reverseContactPoint);
								}

								if (globalEvents) {
									var result = this._createSingleContactResult(e0, e1, contactPoint);

									this.fire("contact", result);
								}
							}

							if (_e0Events) {
								var forwardResult = this._createContactResult(e1, forwardContacts);

								newCollision = this._storeCollision(e0, e1);

								if (e0.collision) {
									e0.collision.fire("contact", forwardResult);

									if (newCollision) {
										e0.collision.fire("collisionstart", forwardResult);
									}
								}

								if (e0.rigidbody) {
									e0.rigidbody.fire("contact", forwardResult);

									if (newCollision) {
										e0.rigidbody.fire("collisionstart", forwardResult);
									}
								}
							}

							if (_e1Events) {
								var reverseResult = this._createContactResult(e0, reverseContacts);

								newCollision = this._storeCollision(e1, e0);

								if (e1.collision) {
									e1.collision.fire("contact", reverseResult);

									if (newCollision) {
										e1.collision.fire("collisionstart", reverseResult);
									}
								}

								if (e1.rigidbody) {
									e1.rigidbody.fire("contact", reverseResult);

									if (newCollision) {
										e1.rigidbody.fire("collisionstart", reverseResult);
									}
								}
							}
						}
					}
				}
			}

			this._cleanOldCollisions();

			this.contactPointPool.freeAll();
			this.contactResultPool.freeAll();
			this.singleContactResultPool.freeAll();
		};

		_proto.onUpdate = function onUpdate(dt) {
			var i, len;
			this._stats.physicsStart = now();
			var gravity = this.dynamicsWorld.getGravity();

			if (gravity.x() !== this.gravity.x || gravity.y() !== this.gravity.y || gravity.z() !== this.gravity.z) {
				gravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);
				this.dynamicsWorld.setGravity(gravity);
			}

			var triggers = this._triggers;

			for (i = 0, len = triggers.length; i < len; i++) {
				triggers[i].updateTransform();
			}

			var compounds = this._compounds;

			for (i = 0, len = compounds.length; i < len; i++) {
				compounds[i]._updateCompound();
			}

			var kinematic = this._kinematic;

			for (i = 0, len = kinematic.length; i < len; i++) {
				kinematic[i]._updateKinematic();
			}

			this.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);
			var dynamic = this._dynamic;

			for (i = 0, len = dynamic.length; i < len; i++) {
				dynamic[i]._updateDynamic();
			}

			if (!this.dynamicsWorld.setInternalTickCallback) this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);
			this._stats.physicsTime = now() - this._stats.physicsStart;
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off('update', this.onUpdate, this);

			if (typeof Ammo !== 'undefined') {
				Ammo.destroy(this.dynamicsWorld);
				Ammo.destroy(this.solver);
				Ammo.destroy(this.overlappingPairCache);
				Ammo.destroy(this.dispatcher);
				Ammo.destroy(this.collisionConfiguration);
				this.dynamicsWorld = null;
				this.solver = null;
				this.overlappingPairCache = null;
				this.dispatcher = null;
				this.collisionConfiguration = null;
			}
		};

		return RigidBodyComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(RigidBodyComponent.prototype, _schema$7);

	var SCALEMODE_NONE = "none";
	var SCALEMODE_BLEND = "blend";

	var _transform = new Mat4();

	var ScreenComponent = function (_Component) {
		_inheritsLoose(ScreenComponent, _Component);

		function ScreenComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._resolution = new Vec2(640, 320);
			_this._referenceResolution = new Vec2(640, 320);
			_this._scaleMode = SCALEMODE_NONE;
			_this.scale = 1;
			_this._scaleBlend = 0.5;
			_this._priority = 0;
			_this._screenSpace = false;
			_this.cull = _this._screenSpace;
			_this._screenMatrix = new Mat4();
			_this._elements = new Set();
			system.app.graphicsDevice.on("resizecanvas", _this._onResize, _assertThisInitialized(_this));
			return _this;
		}

		var _proto = ScreenComponent.prototype;

		_proto.syncDrawOrder = function syncDrawOrder() {
			this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);
		};

		_proto._recurseDrawOrderSync = function _recurseDrawOrderSync(e, i) {
			if (!(e instanceof Entity)) {
				return i;
			}

			if (e.element) {
				var prevDrawOrder = e.element.drawOrder;
				e.element.drawOrder = i++;

				if (e.element._batchGroupId >= 0 && prevDrawOrder !== e.element.drawOrder) {
					this.system.app.batcher.markGroupDirty(e.element._batchGroupId);
				}
			}

			if (e.particlesystem) {
				e.particlesystem.drawOrder = i++;
			}

			var children = e.children;

			for (var j = 0; j < children.length; j++) {
				i = this._recurseDrawOrderSync(children[j], i);
			}

			return i;
		};

		_proto._processDrawOrderSync = function _processDrawOrderSync() {
			var i = 1;

			this._recurseDrawOrderSync(this.entity, i);

			this.fire('syncdraworder');
		};

		_proto._calcProjectionMatrix = function _calcProjectionMatrix() {
			var w = this._resolution.x / this.scale;
			var h = this._resolution.y / this.scale;
			var left = 0;
			var right = w;
			var bottom = -h;
			var top = 0;
			var near = 1;
			var far = -1;

			this._screenMatrix.setOrtho(left, right, bottom, top, near, far);

			if (!this._screenSpace) {
				_transform.setScale(0.5 * w, 0.5 * h, 1);

				this._screenMatrix.mul2(_transform, this._screenMatrix);
			}
		};

		_proto._updateScale = function _updateScale() {
			this.scale = this._calcScale(this._resolution, this.referenceResolution);
		};

		_proto._calcScale = function _calcScale(resolution, referenceResolution) {
			var lx = Math.log2(resolution.x / referenceResolution.x);
			var ly = Math.log2(resolution.y / referenceResolution.y);
			return Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);
		};

		_proto._onResize = function _onResize(width, height) {
			if (this._screenSpace) {
				this._resolution.set(width, height);

				this.resolution = this._resolution;
			}
		};

		_proto._bindElement = function _bindElement(element) {
			this._elements.add(element);
		};

		_proto._unbindElement = function _unbindElement(element) {
			this._elements.delete(element);
		};

		_proto.onRemove = function onRemove() {
			this.system.app.graphicsDevice.off("resizecanvas", this._onResize, this);
			this.fire('remove');

			this._elements.forEach(function (element) {
				return element._onScreenRemove();
			});

			this._elements.clear();

			this.off();
		};

		_createClass(ScreenComponent, [{
			key: "resolution",
			get: function get() {
				return this._resolution;
			},
			set: function set(value) {
				var _this2 = this;

				if (!this._screenSpace) {
					this._resolution.set(value.x, value.y);
				} else {
					this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
				}

				this._updateScale();

				this._calcProjectionMatrix();

				if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
				this.fire("set:resolution", this._resolution);

				this._elements.forEach(function (element) {
					return element._onScreenResize(_this2._resolution);
				});
			}
		}, {
			key: "referenceResolution",
			get: function get() {
				if (this._scaleMode === SCALEMODE_NONE) {
					return this._resolution;
				}

				return this._referenceResolution;
			},
			set: function set(value) {
				var _this3 = this;

				this._referenceResolution.set(value.x, value.y);

				this._updateScale();

				this._calcProjectionMatrix();

				if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
				this.fire("set:referenceresolution", this._resolution);

				this._elements.forEach(function (element) {
					return element._onScreenResize(_this3._resolution);
				});
			}
		}, {
			key: "screenSpace",
			get: function get() {
				return this._screenSpace;
			},
			set: function set(value) {
				this._screenSpace = value;

				if (this._screenSpace) {
					this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
				}

				this.resolution = this._resolution;
				if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
				this.fire('set:screenspace', this._screenSpace);

				this._elements.forEach(function (element) {
					return element._onScreenSpaceChange();
				});
			}
		}, {
			key: "scaleMode",
			get: function get() {
				return this._scaleMode;
			},
			set: function set(value) {
				if (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {
					value = SCALEMODE_NONE;
				}

				if (!this._screenSpace && value !== SCALEMODE_NONE) {
					value = SCALEMODE_NONE;
				}

				this._scaleMode = value;
				this.resolution = this._resolution;
				this.fire("set:scalemode", this._scaleMode);
			}
		}, {
			key: "scaleBlend",
			get: function get() {
				return this._scaleBlend;
			},
			set: function set(value) {
				var _this4 = this;

				this._scaleBlend = value;

				this._updateScale();

				this._calcProjectionMatrix();

				if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
				this.fire("set:scaleblend", this._scaleBlend);

				this._elements.forEach(function (element) {
					return element._onScreenResize(_this4._resolution);
				});
			}
		}, {
			key: "priority",
			get: function get() {
				return this._priority;
			},
			set: function set(value) {
				if (value > 0xFF) {
					Debug.warn("Clamping screen priority from " + value + " to 255");
					value = 0xFF;
				}

				this._priority = value;
			}
		}]);

		return ScreenComponent;
	}(Component);

	var ScreenComponentData = function ScreenComponentData() {
		this.enabled = true;
	};

	var _schema$6 = ['enabled'];

	var ScreenComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ScreenComponentSystem, _ComponentSystem);

		function ScreenComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'screen';
			_this.ComponentType = ScreenComponent;
			_this.DataType = ScreenComponentData;
			_this.schema = _schema$6;
			_this.windowResolution = new Vec2();
			_this._drawOrderSyncQueue = new IndexedList();

			_this.app.graphicsDevice.on("resizecanvas", _this._onResize, _assertThisInitialized(_this));

			_this.app.systems.on('update', _this._onUpdate, _assertThisInitialized(_this));

			_this.on('beforeremove', _this.onRemoveComponent, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = ScreenComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.priority !== undefined) component.priority = data.priority;
			if (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;
			component.cull = component.screenSpace;
			if (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;
			if (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;

			if (data.resolution !== undefined) {
				if (data.resolution instanceof Vec2) {
					component._resolution.copy(data.resolution);
				} else {
					component._resolution.set(data.resolution[0], data.resolution[1]);
				}

				component.resolution = component._resolution;
			}

			if (data.referenceResolution !== undefined) {
				if (data.referenceResolution instanceof Vec2) {
					component._referenceResolution.copy(data.referenceResolution);
				} else {
					component._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);
				}

				component.referenceResolution = component._referenceResolution;
			}

			component.syncDrawOrder();

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.graphicsDevice.off("resizecanvas", this._onResize, this);
			this.app.systems.off('update', this._onUpdate, this);
		};

		_proto._onUpdate = function _onUpdate(dt) {
			var components = this.store;

			for (var id in components) {
				if (components[id].entity.screen.update) components[id].entity.screen.update(dt);
			}
		};

		_proto._onResize = function _onResize(width, height) {
			this.windowResolution.x = width;
			this.windowResolution.y = height;
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var screen = entity.screen;
			return this.addComponent(clone, {
				enabled: screen.enabled,
				screenSpace: screen.screenSpace,
				scaleMode: screen.scaleMode,
				resolution: screen.resolution.clone(),
				referenceResolution: screen.referenceResolution.clone()
			});
		};

		_proto.onRemoveComponent = function onRemoveComponent(entity, component) {
			component.onRemove();
		};

		_proto.processDrawOrderSyncQueue = function processDrawOrderSyncQueue() {
			var list = this._drawOrderSyncQueue.list();

			for (var i = 0; i < list.length; i++) {
				var item = list[i];
				item.callback.call(item.scope);
			}

			this._drawOrderSyncQueue.clear();
		};

		_proto.queueDrawOrderSync = function queueDrawOrderSync(id, fn, scope) {
			if (!this._drawOrderSyncQueue.list().length) {
				this.app.once('prerender', this.processDrawOrderSyncQueue, this);
			}

			if (!this._drawOrderSyncQueue.has(id)) {
				this._drawOrderSyncQueue.push(id, {
					callback: fn,
					scope: scope
				});
			}
		};

		return ScreenComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ScreenComponent.prototype, _schema$6);

	var ScriptComponentData = function ScriptComponentData() {
		this.enabled = true;
	};

	var METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';
	var METHOD_INITIALIZE = '_onInitialize';
	var METHOD_POST_INITIALIZE = '_onPostInitialize';
	var METHOD_UPDATE = '_onUpdate';
	var METHOD_POST_UPDATE = '_onPostUpdate';
	var executionOrderCounter = 0;

	var ScriptComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ScriptComponentSystem, _ComponentSystem);

		function ScriptComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'script';
			_this.ComponentType = ScriptComponent;
			_this.DataType = ScriptComponentData;
			_this._components = new SortedLoopArray({
				sortBy: '_executionOrder'
			});
			_this._enabledComponents = new SortedLoopArray({
				sortBy: '_executionOrder'
			});
			_this.preloading = true;

			_this.on('beforeremove', _this._onBeforeRemove, _assertThisInitialized(_this));

			_this.app.systems.on('initialize', _this._onInitialize, _assertThisInitialized(_this));

			_this.app.systems.on('postInitialize', _this._onPostInitialize, _assertThisInitialized(_this));

			_this.app.systems.on('update', _this._onUpdate, _assertThisInitialized(_this));

			_this.app.systems.on('postUpdate', _this._onPostUpdate, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = ScriptComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data) {
			component._executionOrder = executionOrderCounter++;

			this._components.append(component);

			if (executionOrderCounter > Number.MAX_SAFE_INTEGER) {
				this._resetExecutionOrder();
			}

			component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;

			if (component.enabled && component.entity.enabled) {
				this._enabledComponents.append(component);
			}

			if (data.hasOwnProperty('order') && data.hasOwnProperty('scripts')) {
				component._scriptsData = data.scripts;

				for (var i = 0; i < data.order.length; i++) {
					component.create(data.order[i], {
						enabled: data.scripts[data.order[i]].enabled,
						attributes: data.scripts[data.order[i]].attributes,
						preloading: this.preloading
					});
				}
			}
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var order = [];
			var scripts = {};

			for (var i = 0; i < entity.script._scripts.length; i++) {
				var scriptInstance = entity.script._scripts[i];
				var scriptName = scriptInstance.__scriptType.__name;
				order.push(scriptName);
				var attributes = {};

				for (var key in scriptInstance.__attributes) {
					attributes[key] = scriptInstance.__attributes[key];
				}

				scripts[scriptName] = {
					enabled: scriptInstance._enabled,
					attributes: attributes
				};
			}

			for (var _key in entity.script._scriptsIndex) {
				if (_key.awaiting) {
					order.splice(_key.ind, 0, _key);
				}
			}

			var data = {
				enabled: entity.script.enabled,
				order: order,
				scripts: scripts
			};
			return this.addComponent(clone, data);
		};

		_proto._resetExecutionOrder = function _resetExecutionOrder() {
			executionOrderCounter = 0;

			for (var i = 0, len = this._components.length; i < len; i++) {
				this._components.items[i]._executionOrder = executionOrderCounter++;
			}
		};

		_proto._callComponentMethod = function _callComponentMethod(components, name, dt) {
			for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
				components.items[components.loopIndex][name](dt);
			}
		};

		_proto._onInitialize = function _onInitialize() {
			this.preloading = false;

			this._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);

			this._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);
		};

		_proto._onPostInitialize = function _onPostInitialize() {
			this._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);
		};

		_proto._onUpdate = function _onUpdate(dt) {
			this._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);
		};

		_proto._onPostUpdate = function _onPostUpdate(dt) {
			this._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);
		};

		_proto._addComponentToEnabled = function _addComponentToEnabled(component) {
			this._enabledComponents.insert(component);
		};

		_proto._removeComponentFromEnabled = function _removeComponentFromEnabled(component) {
			this._enabledComponents.remove(component);
		};

		_proto._onBeforeRemove = function _onBeforeRemove(entity, component) {
			var ind = this._components.items.indexOf(component);

			if (ind >= 0) {
				component._onBeforeRemove();
			}

			this._removeComponentFromEnabled(component);

			this._components.remove(component);
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off('initialize', this._onInitialize, this);
			this.app.systems.off('postInitialize', this._onPostInitialize, this);
			this.app.systems.off('update', this._onUpdate, this);
			this.app.systems.off('postUpdate', this._onPostUpdate, this);
		};

		return ScriptComponentSystem;
	}(ComponentSystem);

	var ScriptLegacyComponent = function (_Component) {
		_inheritsLoose(ScriptLegacyComponent, _Component);

		function ScriptLegacyComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;

			_this.on("set_scripts", _this.onSetScripts, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = ScriptLegacyComponent.prototype;

		_proto.send = function send(name, functionName) {
			Debug.deprecated("ScriptLegacyComponent.send() is deprecated and will be removed soon. Please use: http://developer.playcanvas.com/user-manual/scripting/communication/");
			var args = Array.prototype.slice.call(arguments, 2);
			var instances = this.entity.script.instances;
			var fn;

			if (instances && instances[name]) {
				fn = instances[name].instance[functionName];

				if (fn) {
					return fn.apply(instances[name].instance, args);
				}
			}
		};

		_proto.onEnable = function onEnable() {
			if (this.data.areScriptsLoaded && !this.system.preloading) {
				if (!this.data.initialized) {
					this.system._initializeScriptComponent(this);
				} else {
					this.system._enableScriptComponent(this);
				}

				if (!this.data.postInitialized) {
					this.system._postInitializeScriptComponent(this);
				}
			}
		};

		_proto.onDisable = function onDisable() {
			this.system._disableScriptComponent(this);
		};

		_proto.onSetScripts = function onSetScripts(name, oldValue, newValue) {
			if (!this.system._inTools || this.runInTools) {
				if (this._updateScriptAttributes(oldValue, newValue)) {
					return;
				}

				if (this.enabled) {
					this.system._disableScriptComponent(this);
				}

				this.system._destroyScriptComponent(this);

				this.data.areScriptsLoaded = false;
				var scripts = newValue;
				var urls = scripts.map(function (s) {
					return s.url;
				});

				if (this._loadFromCache(urls)) {
					return;
				}

				this._loadScripts(urls);
			}
		};

		_proto._updateScriptAttributes = function _updateScriptAttributes(oldValue, newValue) {
			var onlyUpdateAttributes = true;

			if (oldValue.length !== newValue.length) {
				onlyUpdateAttributes = false;
			} else {
				for (var i = 0, len = newValue.length; i < len; i++) {
					if (oldValue[i].url !== newValue[i].url) {
						onlyUpdateAttributes = false;
						break;
					}
				}
			}

			if (onlyUpdateAttributes) {
				for (var key in this.instances) {
					if (this.instances.hasOwnProperty(key)) {
						this.system._updateAccessors(this.entity, this.instances[key]);
					}
				}
			}

			return onlyUpdateAttributes;
		};

		_proto._loadFromCache = function _loadFromCache(urls) {
			var cached = [];
			var prefix = this.system.app._scriptPrefix || "";
			var regex = /^http(s)?:\/\//i;

			for (var i = 0, len = urls.length; i < len; i++) {
				var url = urls[i];

				if (!regex.test(url)) {
					url = path.join(prefix, url);
				}

				var type = this.system.app.loader.getFromCache(url, 'script');

				if (!type) {
					return false;
				}

				cached.push(type);
			}

			for (var _i = 0, _len = cached.length; _i < _len; _i++) {
				var ScriptType = cached[_i];

				if (ScriptType === true) {
					continue;
				}

				if (ScriptType && this.entity.script) {
					if (!this.entity.script.instances[ScriptType._pcScriptName]) {
						var instance = new ScriptType(this.entity);

						this.system._preRegisterInstance(this.entity, urls[_i], ScriptType._pcScriptName, instance);
					}
				}
			}

			if (this.data) {
				this.data.areScriptsLoaded = true;
			}

			if (!this.system.preloading) {
				this.system.onInitialize(this.entity);
				this.system.onPostInitialize(this.entity);
			}

			return true;
		};

		_proto._loadScripts = function _loadScripts(urls) {
			var _this2 = this;

			var count = urls.length;
			var prefix = this.system.app._scriptPrefix || "";
			urls.forEach(function (url) {
				var _url = null;
				var _unprefixed = null;

				if (url.toLowerCase().startsWith("http://") || url.toLowerCase().startsWith("https://")) {
					_unprefixed = url;
					_url = url;
				} else {
					_unprefixed = url;
					_url = path.join(prefix, url);
				}

				_this2.system.app.loader.load(_url, "script", function (err, ScriptType) {
					count--;

					if (!err) {
						if (ScriptType && _this2.entity.script) {
							if (!_this2.entity.script.instances[ScriptType._pcScriptName]) {
								var instance = new ScriptType(_this2.entity);

								_this2.system._preRegisterInstance(_this2.entity, _unprefixed, ScriptType._pcScriptName, instance);
							}
						}
					} else {
						console.error(err);
					}

					if (count === 0) {
						_this2.data.areScriptsLoaded = true;

						if (!_this2.system.preloading) {
							_this2.system.onInitialize(_this2.entity);

							_this2.system.onPostInitialize(_this2.entity);
						}
					}
				});
			});
		};

		return ScriptLegacyComponent;
	}(Component);

	var ScriptLegacyComponentData = function ScriptLegacyComponentData() {
		this.scripts = [];
		this.enabled = true;
		this.instances = {};
		this._instances = {};
		this.runInTools = false;
		this.attributes = {};
		this.initialized = false;
		this.postInitialized = false;
		this.areScriptsLoaded = false;
	};

	var _schema$5 = ['enabled', 'scripts', 'instances', 'runInTools'];
	var INITIALIZE = "initialize";
	var POST_INITIALIZE = "postInitialize";
	var UPDATE = "update";
	var POST_UPDATE = "postUpdate";
	var FIXED_UPDATE = "fixedUpdate";
	var TOOLS_UPDATE = "toolsUpdate";
	var ON_ENABLE = 'onEnable';
	var ON_DISABLE = 'onDisable';

	var ScriptLegacyComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ScriptLegacyComponentSystem, _ComponentSystem);

		function ScriptLegacyComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'script';
			_this.ComponentType = ScriptLegacyComponent;
			_this.DataType = ScriptLegacyComponentData;
			_this.schema = _schema$5;
			_this.preloading = false;
			_this.instancesWithUpdate = [];
			_this.instancesWithFixedUpdate = [];
			_this.instancesWithPostUpdate = [];
			_this.instancesWithToolsUpdate = [];

			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

			_this.app.systems.on(INITIALIZE, _this.onInitialize, _assertThisInitialized(_this));

			_this.app.systems.on(POST_INITIALIZE, _this.onPostInitialize, _assertThisInitialized(_this));

			_this.app.systems.on(UPDATE, _this.onUpdate, _assertThisInitialized(_this));

			_this.app.systems.on(FIXED_UPDATE, _this.onFixedUpdate, _assertThisInitialized(_this));

			_this.app.systems.on(POST_UPDATE, _this.onPostUpdate, _assertThisInitialized(_this));

			_this.app.systems.on(TOOLS_UPDATE, _this.onToolsUpdate, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = ScriptLegacyComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['runInTools', 'enabled', 'scripts'];

			if (data.scripts && data.scripts.length) {
				data.scripts.forEach(function (script) {
					if (script.attributes && Array.isArray(script.attributes)) {
						var dict = {};

						for (var i = 0; i < script.attributes.length; i++) {
							dict[script.attributes[i].name] = script.attributes[i];
						}

						script.attributes = dict;
					}
				});
			}

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var src = this.store[entity.getGuid()];
			var data = {
				runInTools: src.data.runInTools,
				scripts: [],
				enabled: src.data.enabled
			};
			var scripts = src.data.scripts;

			for (var i = 0, len = scripts.length; i < len; i++) {
				var attributes = scripts[i].attributes;

				if (attributes) {
					delete scripts[i].attributes;
				}

				data.scripts.push(extend({}, scripts[i]));

				if (attributes) {
					data.scripts[i].attributes = this._cloneAttributes(attributes);
					scripts[i].attributes = attributes;
				}
			}

			return this.addComponent(clone, data);
		};

		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			if (component.enabled) {
				this._disableScriptComponent(component);
			}

			this._destroyScriptComponent(component);
		};

		_proto.onInitialize = function onInitialize(root) {
			this._registerInstances(root);

			if (root.enabled) {
				if (root.script && root.script.enabled) {
					this._initializeScriptComponent(root.script);
				}

				var children = root._children;

				for (var i = 0, len = children.length; i < len; i++) {
					if (children[i] instanceof Entity) {
						this.onInitialize(children[i]);
					}
				}
			}
		};

		_proto.onPostInitialize = function onPostInitialize(root) {
			if (root.enabled) {
				if (root.script && root.script.enabled) {
					this._postInitializeScriptComponent(root.script);
				}

				var children = root._children;

				for (var i = 0, len = children.length; i < len; i++) {
					if (children[i] instanceof Entity) {
						this.onPostInitialize(children[i]);
					}
				}
			}
		};

		_proto._callInstancesMethod = function _callInstancesMethod(script, method) {
			var instances = script.data.instances;

			for (var name in instances) {
				if (instances.hasOwnProperty(name)) {
					var instance = instances[name].instance;

					if (instance[method]) {
						instance[method]();
					}
				}
			}
		};

		_proto._initializeScriptComponent = function _initializeScriptComponent(script) {
			this._callInstancesMethod(script, INITIALIZE);

			script.data.initialized = true;

			if (script.enabled && script.entity.enabled) {
				this._enableScriptComponent(script);
			}
		};

		_proto._enableScriptComponent = function _enableScriptComponent(script) {
			this._callInstancesMethod(script, ON_ENABLE);
		};

		_proto._disableScriptComponent = function _disableScriptComponent(script) {
			this._callInstancesMethod(script, ON_DISABLE);
		};

		_proto._destroyScriptComponent = function _destroyScriptComponent(script) {
			var instances = script.data.instances;

			for (var name in instances) {
				if (instances.hasOwnProperty(name)) {
					var instance = instances[name].instance;

					if (instance.destroy) {
						instance.destroy();
					}

					if (instance.update) {
						var index = this.instancesWithUpdate.indexOf(instance);

						if (index >= 0) {
							this.instancesWithUpdate.splice(index, 1);
						}
					}

					if (instance.fixedUpdate) {
						var _index = this.instancesWithFixedUpdate.indexOf(instance);

						if (_index >= 0) {
							this.instancesWithFixedUpdate.splice(_index, 1);
						}
					}

					if (instance.postUpdate) {
						var _index2 = this.instancesWithPostUpdate.indexOf(instance);

						if (_index2 >= 0) {
							this.instancesWithPostUpdate.splice(_index2, 1);
						}
					}

					if (instance.toolsUpdate) {
						var _index3 = this.instancesWithToolsUpdate.indexOf(instance);

						if (_index3 >= 0) {
							this.instancesWithToolsUpdate.splice(_index3, 1);
						}
					}

					if (script.instances[name].instance === script[name]) {
						delete script[name];
					}

					delete script.instances[name];
				}
			}
		};

		_proto._postInitializeScriptComponent = function _postInitializeScriptComponent(script) {
			this._callInstancesMethod(script, POST_INITIALIZE);

			script.data.postInitialized = true;
		};

		_proto._updateInstances = function _updateInstances(method, updateList, dt) {
			for (var i = 0, len = updateList.length; i < len; i++) {
				var item = updateList[i];

				if (item && item.entity && item.entity.enabled && item.entity.script.enabled) {
					item[method](dt);
				}
			}
		};

		_proto.onUpdate = function onUpdate(dt) {
			this._updateInstances(UPDATE, this.instancesWithUpdate, dt);
		};

		_proto.onFixedUpdate = function onFixedUpdate(dt) {
			this._updateInstances(FIXED_UPDATE, this.instancesWithFixedUpdate, dt);
		};

		_proto.onPostUpdate = function onPostUpdate(dt) {
			this._updateInstances(POST_UPDATE, this.instancesWithPostUpdate, dt);
		};

		_proto.onToolsUpdate = function onToolsUpdate(dt) {
			this._updateInstances(TOOLS_UPDATE, this.instancesWithToolsUpdate, dt);
		};

		_proto.broadcast = function broadcast(name, functionName) {
			Debug.deprecated("ScriptLegacyComponentSystem.broadcast() is deprecated and will be removed soon. Please use: http://developer.playcanvas.com/user-manual/scripting/communication/");
			var args = Array.prototype.slice.call(arguments, 2);
			var dataStore = this.store;

			for (var id in dataStore) {
				if (dataStore.hasOwnProperty(id)) {
					var data = dataStore[id].data;

					if (data.instances[name]) {
						var fn = data.instances[name].instance[functionName];

						if (fn) {
							fn.apply(data.instances[name].instance, args);
						}
					}
				}
			}
		};

		_proto._preRegisterInstance = function _preRegisterInstance(entity, url, name, instance) {
			if (entity.script) {
				entity.script.data._instances = entity.script.data._instances || {};

				if (entity.script.data._instances[name]) {
					throw Error("Script name collision '" + name + "'. Scripts from '" + url + "' and '" + entity.script.data._instances[name].url + "' {" + entity.getGuid() + "}");
				}

				entity.script.data._instances[name] = {
					url: url,
					name: name,
					instance: instance
				};
			}
		};

		_proto._registerInstances = function _registerInstances(entity) {
			if (entity.script) {
				if (entity.script.data._instances) {
					entity.script.instances = entity.script.data._instances;

					for (var instanceName in entity.script.instances) {
						var preRegistered = entity.script.instances[instanceName];
						var instance = preRegistered.instance;
						events.attach(instance);

						if (instance.update) {
							this.instancesWithUpdate.push(instance);
						}

						if (instance.fixedUpdate) {
							this.instancesWithFixedUpdate.push(instance);
						}

						if (instance.postUpdate) {
							this.instancesWithPostUpdate.push(instance);
						}

						if (instance.toolsUpdate) {
							this.instancesWithToolsUpdate.push(instance);
						}

						if (entity.script.scripts) {
							this._createAccessors(entity, preRegistered);
						}

						if (entity.script[instanceName]) {
							throw Error("Script with name '" + instanceName + "' is already attached to Script Component");
						} else {
							entity.script[instanceName] = instance;
						}
					}

					delete entity.script.data._instances;
				}
			}

			var children = entity._children;

			for (var i = 0, len = children.length; i < len; i++) {
				if (children[i] instanceof Entity) {
					this._registerInstances(children[i]);
				}
			}
		};

		_proto._cloneAttributes = function _cloneAttributes(attributes) {
			var result = {};

			for (var key in attributes) {
				if (!attributes.hasOwnProperty(key)) continue;

				if (attributes[key].type !== 'entity') {
					result[key] = extend({}, attributes[key]);
				} else {
					var val = attributes[key].value;
					delete attributes[key].value;
					result[key] = extend({}, attributes[key]);
					result[key].value = val;
					attributes[key].value = val;
				}
			}

			return result;
		};

		_proto._createAccessors = function _createAccessors(entity, instance) {
			var len = entity.script.scripts.length;
			var url = instance.url;

			for (var i = 0; i < len; i++) {
				var script = entity.script.scripts[i];

				if (script.url === url) {
					var attributes = script.attributes;

					if (script.name && attributes) {
						for (var key in attributes) {
							if (attributes.hasOwnProperty(key)) {
								this._createAccessor(attributes[key], instance);
							}
						}

						entity.script.data.attributes[script.name] = this._cloneAttributes(attributes);
					}

					break;
				}
			}
		};

		_proto._createAccessor = function _createAccessor(attribute, instance) {
			var self = this;
			attribute = {
				name: attribute.name,
				value: attribute.value,
				type: attribute.type
			};

			this._convertAttributeValue(attribute);

			Object.defineProperty(instance.instance, attribute.name, {
				get: function get() {
					return attribute.value;
				},
				set: function set(value) {
					var oldValue = attribute.value;
					attribute.value = value;

					self._convertAttributeValue(attribute);

					instance.instance.fire("set", attribute.name, oldValue, attribute.value);
				},
				configurable: true
			});
		};

		_proto._updateAccessors = function _updateAccessors(entity, instance) {
			var len = entity.script.scripts.length;
			var url = instance.url;

			for (var i = 0; i < len; i++) {
				var scriptComponent = entity.script;
				var script = scriptComponent.scripts[i];

				if (script.url === url) {
					var name = script.name;
					var attributes = script.attributes;

					if (name) {
						if (attributes) {
							for (var key in attributes) {
								if (attributes.hasOwnProperty(key)) {
									this._createAccessor(attributes[key], instance);
								}
							}
						}

						var previousAttributes = scriptComponent.data.attributes[name];

						if (previousAttributes) {
							for (var _key in previousAttributes) {
								var oldAttribute = previousAttributes[_key];

								if (!(_key in attributes)) {
									delete instance.instance[oldAttribute.name];
								} else {
									if (attributes[_key].value !== oldAttribute.value) {
										if (instance.instance.onAttributeChanged) {
											instance.instance.onAttributeChanged(oldAttribute.name, oldAttribute.value, attributes[_key].value);
										}
									}
								}
							}
						}

						if (attributes) {
							scriptComponent.data.attributes[name] = this._cloneAttributes(attributes);
						} else {
							delete scriptComponent.data.attributes[name];
						}
					}

					break;
				}
			}
		};

		_proto._convertAttributeValue = function _convertAttributeValue(attribute) {
			if (attribute.type === 'rgb' || attribute.type === 'rgba') {
				if (Array.isArray(attribute.value)) {
					attribute.value = attribute.value.length === 3 ? new Color(attribute.value[0], attribute.value[1], attribute.value[2]) : new Color(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
				}
			} else if (attribute.type === 'vec2') {
				if (Array.isArray(attribute.value)) attribute.value = new Vec2(attribute.value[0], attribute.value[1]);
			} else if (attribute.type === 'vec3' || attribute.type === 'vector') {
				if (Array.isArray(attribute.value)) attribute.value = new Vec3(attribute.value[0], attribute.value[1], attribute.value[2]);
			} else if (attribute.type === 'vec4') {
				if (Array.isArray(attribute.value)) attribute.value = new Vec4(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
			} else if (attribute.type === 'entity') {
				if (attribute.value !== null && typeof attribute.value === 'string') attribute.value = this.app.root.findByGuid(attribute.value);
			} else if (attribute.type === 'curve' || attribute.type === 'colorcurve') {
				var curveType = attribute.value.keys[0] instanceof Array ? CurveSet : Curve;
				attribute.value = new curveType(attribute.value.keys);
				attribute.value.type = attribute.value.type;
			}
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off(INITIALIZE, this.onInitialize, this);
			this.app.systems.off(POST_INITIALIZE, this.onPostInitialize, this);
			this.app.systems.off(UPDATE, this.onUpdate, this);
			this.app.systems.off(FIXED_UPDATE, this.onFixedUpdate, this);
			this.app.systems.off(POST_UPDATE, this.onPostUpdate, this);
			this.app.systems.off(TOOLS_UPDATE, this.onToolsUpdate, this);
		};

		return ScriptLegacyComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ScriptLegacyComponent.prototype, _schema$5);

	var _inputScreenPosition = new Vec2();

	var _inputWorldPosition = new Vec3();

	var _rayOrigin = new Vec3();

	var _rayDirection = new Vec3();

	var _planeOrigin = new Vec3();

	var _planeNormal = new Vec3();

	var _entityRotation = new Quat();

	var OPPOSITE_AXIS = {
		x: 'y',
		y: 'x'
	};

	var ElementDragHelper = function (_EventHandler) {
		_inheritsLoose(ElementDragHelper, _EventHandler);

		function ElementDragHelper(element, axis) {
			var _this;

			_this = _EventHandler.call(this) || this;

			if (!element || !(element instanceof ElementComponent)) {
				throw new Error('Element was null or not an ElementComponent');
			}

			if (axis && axis !== 'x' && axis !== 'y') {
				throw new Error('Unrecognized axis: ' + axis);
			}

			_this._element = element;
			_this._app = element.system.app;
			_this._axis = axis || null;
			_this._enabled = true;
			_this._dragScale = new Vec3();
			_this._dragStartMousePosition = new Vec3();
			_this._dragStartHandlePosition = new Vec3();
			_this._deltaMousePosition = new Vec3();
			_this._deltaHandlePosition = new Vec3();
			_this._isDragging = false;

			_this._toggleLifecycleListeners('on');

			return _this;
		}

		var _proto = ElementDragHelper.prototype;

		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff) {
			this._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);

			this._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);
		};

		_proto._toggleDragListeners = function _toggleDragListeners(onOrOff) {
			var isOn = onOrOff === 'on';
			var addOrRemoveEventListener = isOn ? 'addEventListener' : 'removeEventListener';

			if (this._hasDragListeners && isOn) {
				return;
			}

			if (!this._handleMouseUpOrTouchEnd) {
				this._handleMouseUpOrTouchEnd = this._onMouseUpOrTouchEnd.bind(this);
			}

			if (this._app.mouse) {
				this._app.mouse[onOrOff]('mousemove', this._onMove, this);

				window[addOrRemoveEventListener]('mouseup', this._handleMouseUpOrTouchEnd, false);
			}

			if (platform.touch) {
				this._app.touch[onOrOff]('touchmove', this._onMove, this);

				window[addOrRemoveEventListener]('touchend', this._handleMouseUpOrTouchEnd, false);
				window[addOrRemoveEventListener]('touchcancel', this._handleMouseUpOrTouchEnd, false);
			}

			this._hasDragListeners = isOn;
		};

		_proto._onMouseDownOrTouchStart = function _onMouseDownOrTouchStart(event) {
			if (this._element && !this._isDragging && this.enabled) {
				this._dragCamera = event.camera;

				this._calculateDragScale();

				var currentMousePosition = this._screenToLocal(event);

				if (currentMousePosition) {
					this._toggleDragListeners('on');

					this._isDragging = true;

					this._dragStartMousePosition.copy(currentMousePosition);

					this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());

					this.fire('drag:start');
				}
			}
		};

		_proto._onMouseUpOrTouchEnd = function _onMouseUpOrTouchEnd() {
			if (this._isDragging) {
				this._isDragging = false;

				this._toggleDragListeners('off');

				this.fire('drag:end');
			}
		};

		_proto._screenToLocal = function _screenToLocal(event) {
			this._determineInputPosition(event);

			this._chooseRayOriginAndDirection();

			_planeOrigin.copy(this._element.entity.getPosition());

			_planeNormal.copy(this._element.entity.forward).mulScalar(-1);

			var denominator = _planeNormal.dot(_rayDirection);

			if (Math.abs(denominator) > 0) {
				var rayOriginToPlaneOrigin = _planeOrigin.sub(_rayOrigin);

				var collisionDistance = rayOriginToPlaneOrigin.dot(_planeNormal) / denominator;

				var position = _rayOrigin.add(_rayDirection.mulScalar(collisionDistance));

				_entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(position, position);

				position.mul(this._dragScale);
				return position;
			}

			return null;
		};

		_proto._determineInputPosition = function _determineInputPosition(event) {
			var devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;

			if (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {
				_inputScreenPosition.x = event.x * devicePixelRatio;
				_inputScreenPosition.y = event.y * devicePixelRatio;
			} else if (event.changedTouches) {
				_inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;
				_inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;
			} else {
				console.warn('Could not determine position from input event');
			}
		};

		_proto._chooseRayOriginAndDirection = function _chooseRayOriginAndDirection() {
			if (this._element.screen && this._element.screen.screen.screenSpace) {
				_rayOrigin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);

				_rayDirection.set(0, 0, -1);
			} else {
				_inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));

				_rayOrigin.copy(this._dragCamera.entity.getPosition());

				_rayDirection.copy(_inputWorldPosition).sub(_rayOrigin).normalize();
			}
		};

		_proto._calculateDragScale = function _calculateDragScale() {
			var current = this._element.entity.parent;
			var screen = this._element.screen && this._element.screen.screen;
			var isWithin2DScreen = screen && screen.screenSpace;
			var screenScale = isWithin2DScreen ? screen.scale : 1;
			var dragScale = this._dragScale;
			dragScale.set(screenScale, screenScale, screenScale);

			while (current) {
				dragScale.mul(current.getLocalScale());
				current = current.parent;

				if (isWithin2DScreen && current.screen) {
					break;
				}
			}

			dragScale.x = 1 / dragScale.x;
			dragScale.y = 1 / dragScale.y;
			dragScale.z = 1 / dragScale.z;
		};

		_proto._onMove = function _onMove(event) {
			if (this._element && this._isDragging && this.enabled && this._element.enabled && this._element.entity.enabled) {
				var currentMousePosition = this._screenToLocal(event);

				if (this._dragStartMousePosition && currentMousePosition) {
					this._deltaMousePosition.copy(currentMousePosition).sub(this._dragStartMousePosition);

					this._deltaHandlePosition.copy(this._dragStartHandlePosition).add(this._deltaMousePosition);

					if (this._axis) {
						var currentPosition = this._element.entity.getLocalPosition();

						var constrainedAxis = OPPOSITE_AXIS[this._axis];
						this._deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];
					}

					this._element.entity.setLocalPosition(this._deltaHandlePosition);

					this.fire('drag:move', this._deltaHandlePosition);
				}
			}
		};

		_proto.destroy = function destroy() {
			this._toggleLifecycleListeners('off');

			this._toggleDragListeners('off');
		};

		_createClass(ElementDragHelper, [{
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				this._enabled = value;
			}
		}, {
			key: "isDragging",
			get: function get() {
				return this._isDragging;
			}
		}]);

		return ElementDragHelper;
	}(EventHandler);

	var SCROLL_MODE_CLAMP = 0;
	var SCROLL_MODE_BOUNCE = 1;
	var SCROLL_MODE_INFINITE = 2;
	var SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;
	var SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;

	var ACTION_MOUSE = 'mouse';
	var ACTION_KEYBOARD = 'keyboard';
	var ACTION_GAMEPAD = 'gamepad';
	var AXIS_MOUSE_X = 'mousex';
	var AXIS_MOUSE_Y = 'mousey';
	var AXIS_PAD_L_X = 'padlx';
	var AXIS_PAD_L_Y = 'padly';
	var AXIS_PAD_R_X = 'padrx';
	var AXIS_PAD_R_Y = 'padry';
	var AXIS_KEY = 'key';
	var EVENT_KEYDOWN = 'keydown';
	var EVENT_KEYUP = 'keyup';
	var EVENT_MOUSEDOWN = "mousedown";
	var EVENT_MOUSEMOVE = "mousemove";
	var EVENT_MOUSEUP = "mouseup";
	var EVENT_MOUSEWHEEL = "mousewheel";
	var EVENT_TOUCHSTART = 'touchstart';
	var EVENT_TOUCHEND = 'touchend';
	var EVENT_TOUCHMOVE = 'touchmove';
	var EVENT_TOUCHCANCEL = 'touchcancel';
	var EVENT_SELECT = 'select';
	var EVENT_SELECTSTART = 'selectstart';
	var EVENT_SELECTEND = 'selectend';
	var KEY_BACKSPACE = 8;
	var KEY_TAB = 9;
	var KEY_RETURN = 13;
	var KEY_ENTER = 13;
	var KEY_SHIFT = 16;
	var KEY_CONTROL = 17;
	var KEY_ALT = 18;
	var KEY_PAUSE = 19;
	var KEY_CAPS_LOCK = 20;
	var KEY_ESCAPE = 27;
	var KEY_SPACE = 32;
	var KEY_PAGE_UP = 33;
	var KEY_PAGE_DOWN = 34;
	var KEY_END = 35;
	var KEY_HOME = 36;
	var KEY_LEFT = 37;
	var KEY_UP = 38;
	var KEY_RIGHT = 39;
	var KEY_DOWN = 40;
	var KEY_PRINT_SCREEN = 44;
	var KEY_INSERT = 45;
	var KEY_DELETE = 46;
	var KEY_0 = 48;
	var KEY_1 = 49;
	var KEY_2 = 50;
	var KEY_3 = 51;
	var KEY_4 = 52;
	var KEY_5 = 53;
	var KEY_6 = 54;
	var KEY_7 = 55;
	var KEY_8 = 56;
	var KEY_9 = 57;
	var KEY_SEMICOLON = 59;
	var KEY_EQUAL = 61;
	var KEY_A = 65;
	var KEY_B = 66;
	var KEY_C = 67;
	var KEY_D = 68;
	var KEY_E = 69;
	var KEY_F = 70;
	var KEY_G = 71;
	var KEY_H = 72;
	var KEY_I = 73;
	var KEY_J = 74;
	var KEY_K = 75;
	var KEY_L = 76;
	var KEY_M = 77;
	var KEY_N = 78;
	var KEY_O = 79;
	var KEY_P = 80;
	var KEY_Q = 81;
	var KEY_R = 82;
	var KEY_S = 83;
	var KEY_T = 84;
	var KEY_U = 85;
	var KEY_V = 86;
	var KEY_W = 87;
	var KEY_X = 88;
	var KEY_Y = 89;
	var KEY_Z = 90;
	var KEY_WINDOWS = 91;
	var KEY_CONTEXT_MENU = 93;
	var KEY_NUMPAD_0 = 96;
	var KEY_NUMPAD_1 = 97;
	var KEY_NUMPAD_2 = 98;
	var KEY_NUMPAD_3 = 99;
	var KEY_NUMPAD_4 = 100;
	var KEY_NUMPAD_5 = 101;
	var KEY_NUMPAD_6 = 102;
	var KEY_NUMPAD_7 = 103;
	var KEY_NUMPAD_8 = 104;
	var KEY_NUMPAD_9 = 105;
	var KEY_MULTIPLY = 106;
	var KEY_ADD = 107;
	var KEY_SEPARATOR = 108;
	var KEY_SUBTRACT = 109;
	var KEY_DECIMAL = 110;
	var KEY_DIVIDE = 111;
	var KEY_F1 = 112;
	var KEY_F2 = 113;
	var KEY_F3 = 114;
	var KEY_F4 = 115;
	var KEY_F5 = 116;
	var KEY_F6 = 117;
	var KEY_F7 = 118;
	var KEY_F8 = 119;
	var KEY_F9 = 120;
	var KEY_F10 = 121;
	var KEY_F11 = 122;
	var KEY_F12 = 123;
	var KEY_COMMA = 188;
	var KEY_PERIOD = 190;
	var KEY_SLASH = 191;
	var KEY_OPEN_BRACKET = 219;
	var KEY_BACK_SLASH = 220;
	var KEY_CLOSE_BRACKET = 221;
	var KEY_META = 224;
	var MOUSEBUTTON_NONE = -1;
	var MOUSEBUTTON_LEFT = 0;
	var MOUSEBUTTON_MIDDLE = 1;
	var MOUSEBUTTON_RIGHT = 2;
	var PAD_1 = 0;
	var PAD_2 = 1;
	var PAD_3 = 2;
	var PAD_4 = 3;
	var PAD_FACE_1 = 0;
	var PAD_FACE_2 = 1;
	var PAD_FACE_3 = 2;
	var PAD_FACE_4 = 3;
	var PAD_L_SHOULDER_1 = 4;
	var PAD_R_SHOULDER_1 = 5;
	var PAD_L_SHOULDER_2 = 6;
	var PAD_R_SHOULDER_2 = 7;
	var PAD_SELECT = 8;
	var PAD_START = 9;
	var PAD_L_STICK_BUTTON = 10;
	var PAD_R_STICK_BUTTON = 11;
	var PAD_UP = 12;
	var PAD_DOWN = 13;
	var PAD_LEFT = 14;
	var PAD_RIGHT = 15;
	var PAD_VENDOR = 16;
	var PAD_L_STICK_X = 0;
	var PAD_L_STICK_Y = 1;
	var PAD_R_STICK_X = 2;
	var PAD_R_STICK_Y = 3;

	var _tempScrollValue = new Vec2();

	var ScrollViewComponent = function (_Component) {
		_inheritsLoose(ScrollViewComponent, _Component);

		function ScrollViewComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._viewportReference = new EntityReference(_assertThisInitialized(_this), 'viewportEntity', {
				'element#gain': _this._onViewportElementGain,
				'element#resize': _this._onSetContentOrViewportSize
			});
			_this._contentReference = new EntityReference(_assertThisInitialized(_this), 'contentEntity', {
				'element#gain': _this._onContentElementGain,
				'element#lose': _this._onContentElementLose,
				'element#resize': _this._onSetContentOrViewportSize
			});
			_this._scrollbarUpdateFlags = {};
			_this._scrollbarReferences = {};
			_this._scrollbarReferences[ORIENTATION_HORIZONTAL] = new EntityReference(_assertThisInitialized(_this), 'horizontalScrollbarEntity', {
				'scrollbar#set:value': _this._onSetHorizontalScrollbarValue,
				'scrollbar#gain': _this._onHorizontalScrollbarGain
			});
			_this._scrollbarReferences[ORIENTATION_VERTICAL] = new EntityReference(_assertThisInitialized(_this), 'verticalScrollbarEntity', {
				'scrollbar#set:value': _this._onSetVerticalScrollbarValue,
				'scrollbar#gain': _this._onVerticalScrollbarGain
			});
			_this._prevContentSizes = {};
			_this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
			_this._prevContentSizes[ORIENTATION_VERTICAL] = null;
			_this._scroll = new Vec2();
			_this._velocity = new Vec3();
			_this._dragStartPosition = new Vec3();
			_this._disabledContentInput = false;
			_this._disabledContentInputEntities = [];

			_this._toggleLifecycleListeners('on', system);

			_this._toggleElementListeners('on');

			return _this;
		}

		var _proto = ScrollViewComponent.prototype;

		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff, system) {
			this[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);
			this[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);
			system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
			system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
		};

		_proto._toggleElementListeners = function _toggleElementListeners(onOrOff) {
			if (this.entity.element) {
				if (onOrOff === 'on' && this._hasElementListeners) {
					return;
				}

				this.entity.element[onOrOff]('resize', this._onSetContentOrViewportSize, this);
				this.entity.element[onOrOff](EVENT_MOUSEWHEEL, this._onMouseWheel, this);
				this._hasElementListeners = onOrOff === 'on';
			}
		};

		_proto._onElementComponentAdd = function _onElementComponentAdd(entity) {
			if (this.entity === entity) {
				this._toggleElementListeners('on');
			}
		};

		_proto._onElementComponentRemove = function _onElementComponentRemove(entity) {
			if (this.entity === entity) {
				this._toggleElementListeners('off');
			}
		};

		_proto._onViewportElementGain = function _onViewportElementGain() {
			this._syncAll();
		};

		_proto._onContentElementGain = function _onContentElementGain() {
			this._destroyDragHelper();

			this._contentDragHelper = new ElementDragHelper(this._contentReference.entity.element);

			this._contentDragHelper.on('drag:start', this._onContentDragStart, this);

			this._contentDragHelper.on('drag:end', this._onContentDragEnd, this);

			this._contentDragHelper.on('drag:move', this._onContentDragMove, this);

			this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
			this._prevContentSizes[ORIENTATION_VERTICAL] = null;

			this._syncAll();
		};

		_proto._onContentElementLose = function _onContentElementLose() {
			this._destroyDragHelper();
		};

		_proto._onContentDragStart = function _onContentDragStart() {
			if (this._contentReference.entity && this.enabled && this.entity.enabled) {
				this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition());
			}
		};

		_proto._onContentDragEnd = function _onContentDragEnd() {
			this._prevContentDragPosition = null;

			this._enableContentInput();
		};

		_proto._onContentDragMove = function _onContentDragMove(position) {
			if (this._contentReference.entity && this.enabled && this.entity.enabled) {
				this._wasDragged = true;

				this._setScrollFromContentPosition(position);

				this._setVelocityFromContentPositionDelta(position);

				if (!this._disabledContentInput) {
					var dx = position.x - this._dragStartPosition.x;
					var dy = position.y - this._dragStartPosition.y;

					if (Math.abs(dx) > this.dragThreshold || Math.abs(dy) > this.dragThreshold) {
						this._disableContentInput();
					}
				}
			}
		};

		_proto._onSetContentOrViewportSize = function _onSetContentOrViewportSize() {
			this._syncAll();
		};

		_proto._onSetHorizontalScrollbarValue = function _onSetHorizontalScrollbarValue(scrollValueX) {
			if (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {
				this._onSetScroll(scrollValueX, null);
			}
		};

		_proto._onSetVerticalScrollbarValue = function _onSetVerticalScrollbarValue(scrollValueY) {
			if (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {
				this._onSetScroll(null, scrollValueY);
			}
		};

		_proto._onSetHorizontalScrollingEnabled = function _onSetHorizontalScrollingEnabled() {
			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
		};

		_proto._onSetVerticalScrollingEnabled = function _onSetVerticalScrollingEnabled() {
			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
		};

		_proto._onHorizontalScrollbarGain = function _onHorizontalScrollbarGain() {
			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);

			this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
		};

		_proto._onVerticalScrollbarGain = function _onVerticalScrollbarGain() {
			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);

			this._syncScrollbarPosition(ORIENTATION_VERTICAL);
		};

		_proto._onSetScroll = function _onSetScroll(x, y, resetVelocity) {
			if (resetVelocity !== false) {
				this._velocity.set(0, 0, 0);
			}

			var xChanged = this._updateAxis(x, 'x', ORIENTATION_HORIZONTAL);

			var yChanged = this._updateAxis(y, 'y', ORIENTATION_VERTICAL);

			if (xChanged || yChanged) {
				this.fire('set:scroll', this._scroll);
			}
		};

		_proto._updateAxis = function _updateAxis(scrollValue, axis, orientation) {
			var hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;

			if (hasChanged || this._isDragging() || scrollValue === 0) {
				this._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);

				this._syncContentPosition(orientation);

				this._syncScrollbarPosition(orientation);
			}

			return hasChanged;
		};

		_proto._determineNewScrollValue = function _determineNewScrollValue(scrollValue, axis, orientation) {
			if (!this._getScrollingEnabled(orientation)) {
				return this._scroll[axis];
			}

			switch (this.scrollMode) {
				case SCROLL_MODE_CLAMP:
					return math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));

				case SCROLL_MODE_BOUNCE:
					this._setVelocityFromOvershoot(scrollValue, axis, orientation);

					return scrollValue;

				case SCROLL_MODE_INFINITE:
					return scrollValue;

				default:
					console.warn('Unhandled scroll mode:' + this.scrollMode);
					return scrollValue;
			}
		};

		_proto._syncAll = function _syncAll() {
			this._syncContentPosition(ORIENTATION_HORIZONTAL);

			this._syncContentPosition(ORIENTATION_VERTICAL);

			this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);

			this._syncScrollbarPosition(ORIENTATION_VERTICAL);

			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);

			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
		};

		_proto._syncContentPosition = function _syncContentPosition(orientation) {
			var axis = this._getAxis(orientation);

			var sign = this._getSign(orientation);

			var contentEntity = this._contentReference.entity;

			if (contentEntity) {
				var prevContentSize = this._prevContentSizes[orientation];

				var currContentSize = this._getContentSize(orientation);

				if (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {
					var prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);

					var currMaxOffset = this._getMaxOffset(orientation, currContentSize);

					if (currMaxOffset === 0) {
						this._scroll[axis] = 1;
					} else {
						this._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);
					}
				}

				var offset = this._scroll[axis] * this._getMaxOffset(orientation);

				var contentPosition = contentEntity.getLocalPosition();
				contentPosition[axis] = offset * sign;
				contentEntity.setLocalPosition(contentPosition);
				this._prevContentSizes[orientation] = currContentSize;
			}
		};

		_proto._syncScrollbarPosition = function _syncScrollbarPosition(orientation) {
			var axis = this._getAxis(orientation);

			var scrollbarEntity = this._scrollbarReferences[orientation].entity;

			if (scrollbarEntity && scrollbarEntity.scrollbar) {
				this._scrollbarUpdateFlags[orientation] = true;
				scrollbarEntity.scrollbar.value = this._scroll[axis];
				scrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);
				this._scrollbarUpdateFlags[orientation] = false;
			}
		};

		_proto._syncScrollbarEnabledState = function _syncScrollbarEnabledState(orientation) {
			var entity = this._scrollbarReferences[orientation].entity;

			if (entity) {
				var isScrollingEnabled = this._getScrollingEnabled(orientation);

				var requestedVisibility = this._getScrollbarVisibility(orientation);

				switch (requestedVisibility) {
					case SCROLLBAR_VISIBILITY_SHOW_ALWAYS:
						entity.enabled = isScrollingEnabled;
						return;

					case SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:
						entity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);
						return;

					default:
						console.warn('Unhandled scrollbar visibility:' + requestedVisibility);
						entity.enabled = isScrollingEnabled;
				}
			}
		};

		_proto._contentIsLargerThanViewport = function _contentIsLargerThanViewport(orientation) {
			return this._getContentSize(orientation) > this._getViewportSize(orientation);
		};

		_proto._contentPositionToScrollValue = function _contentPositionToScrollValue(contentPosition) {
			var maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);

			var maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);

			if (maxOffsetH === 0) {
				_tempScrollValue.x = 0;
			} else {
				_tempScrollValue.x = contentPosition.x / maxOffsetH;
			}

			if (maxOffsetV === 0) {
				_tempScrollValue.y = 0;
			} else {
				_tempScrollValue.y = contentPosition.y / -maxOffsetV;
			}

			return _tempScrollValue;
		};

		_proto._getMaxOffset = function _getMaxOffset(orientation, contentSize) {
			contentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;

			var viewportSize = this._getViewportSize(orientation);

			if (contentSize < viewportSize) {
				return -this._getViewportSize(orientation);
			}

			return viewportSize - contentSize;
		};

		_proto._getMaxScrollValue = function _getMaxScrollValue(orientation) {
			return this._contentIsLargerThanViewport(orientation) ? 1 : 0;
		};

		_proto._getScrollbarHandleSize = function _getScrollbarHandleSize(axis, orientation) {
			var viewportSize = this._getViewportSize(orientation);

			var contentSize = this._getContentSize(orientation);

			if (Math.abs(contentSize) < 0.001) {
				return 1;
			}

			var handleSize = Math.min(viewportSize / contentSize, 1);

			var overshoot = this._toOvershoot(this._scroll[axis], orientation);

			if (overshoot === 0) {
				return handleSize;
			}

			return handleSize / (1 + Math.abs(overshoot));
		};

		_proto._getViewportSize = function _getViewportSize(orientation) {
			return this._getSize(orientation, this._viewportReference);
		};

		_proto._getContentSize = function _getContentSize(orientation) {
			return this._getSize(orientation, this._contentReference);
		};

		_proto._getSize = function _getSize(orientation, entityReference) {
			if (entityReference.entity && entityReference.entity.element) {
				return entityReference.entity.element[this._getCalculatedDimension(orientation)];
			}

			return 0;
		};

		_proto._getScrollingEnabled = function _getScrollingEnabled(orientation) {
			if (orientation === ORIENTATION_HORIZONTAL) {
				return this.horizontal;
			} else if (orientation === ORIENTATION_VERTICAL) {
				return this.vertical;
			}

			console.warn('Unrecognized orientation: ' + orientation);
		};

		_proto._getScrollbarVisibility = function _getScrollbarVisibility(orientation) {
			if (orientation === ORIENTATION_HORIZONTAL) {
				return this.horizontalScrollbarVisibility;
			} else if (orientation === ORIENTATION_VERTICAL) {
				return this.verticalScrollbarVisibility;
			}

			console.warn('Unrecognized orientation: ' + orientation);
		};

		_proto._getSign = function _getSign(orientation) {
			return orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
		};

		_proto._getAxis = function _getAxis(orientation) {
			return orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
		};

		_proto._getCalculatedDimension = function _getCalculatedDimension(orientation) {
			return orientation === ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';
		};

		_proto._destroyDragHelper = function _destroyDragHelper() {
			if (this._contentDragHelper) {
				this._contentDragHelper.destroy();
			}
		};

		_proto.onUpdate = function onUpdate() {
			if (this._contentReference.entity) {
				this._updateVelocity();

				this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);

				this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
			}
		};

		_proto._updateVelocity = function _updateVelocity() {
			if (!this._isDragging()) {
				if (this.scrollMode === SCROLL_MODE_BOUNCE) {
					if (this._hasOvershoot('x', ORIENTATION_HORIZONTAL)) {
						this._setVelocityFromOvershoot(this.scroll.x, 'x', ORIENTATION_HORIZONTAL);
					}

					if (this._hasOvershoot('y', ORIENTATION_VERTICAL)) {
						this._setVelocityFromOvershoot(this.scroll.y, 'y', ORIENTATION_VERTICAL);
					}
				}

				if (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
					var position = this._contentReference.entity.getLocalPosition();

					position.x += this._velocity.x;
					position.y += this._velocity.y;

					this._contentReference.entity.setLocalPosition(position);

					this._setScrollFromContentPosition(position);
				}

				this._velocity.x *= 1 - this.friction;
				this._velocity.y *= 1 - this.friction;
			}
		};

		_proto._hasOvershoot = function _hasOvershoot(axis, orientation) {
			return Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;
		};

		_proto._toOvershoot = function _toOvershoot(scrollValue, orientation) {
			var maxScrollValue = this._getMaxScrollValue(orientation);

			if (scrollValue < 0) {
				return scrollValue;
			} else if (scrollValue > maxScrollValue) {
				return scrollValue - maxScrollValue;
			}

			return 0;
		};

		_proto._setVelocityFromOvershoot = function _setVelocityFromOvershoot(scrollValue, axis, orientation) {
			var overshootValue = this._toOvershoot(scrollValue, orientation);

			var overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);

			if (Math.abs(overshootPixels) > 0) {
				this._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);
			}
		};

		_proto._setVelocityFromContentPositionDelta = function _setVelocityFromContentPositionDelta(position) {
			if (this._prevContentDragPosition) {
				this._velocity.sub2(position, this._prevContentDragPosition);

				this._prevContentDragPosition.copy(position);
			} else {
				this._velocity.set(0, 0, 0);

				this._prevContentDragPosition = position.clone();
			}
		};

		_proto._setScrollFromContentPosition = function _setScrollFromContentPosition(position) {
			var scrollValue = this._contentPositionToScrollValue(position);

			if (this._isDragging()) {
				scrollValue = this._applyScrollValueTension(scrollValue);
			}

			this._onSetScroll(scrollValue.x, scrollValue.y, false);
		};

		_proto._applyScrollValueTension = function _applyScrollValueTension(scrollValue) {
			var factor = 1;

			var max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);

			var overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);

			if (overshoot > 0) {
				scrollValue.x = max + factor * Math.log10(1 + overshoot);
			} else if (overshoot < 0) {
				scrollValue.x = -factor * Math.log10(1 - overshoot);
			}

			max = this._getMaxScrollValue(ORIENTATION_VERTICAL);
			overshoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);

			if (overshoot > 0) {
				scrollValue.y = max + factor * Math.log10(1 + overshoot);
			} else if (overshoot < 0) {
				scrollValue.y = -factor * Math.log10(1 - overshoot);
			}

			return scrollValue;
		};

		_proto._isDragging = function _isDragging() {
			return this._contentDragHelper && this._contentDragHelper.isDragging;
		};

		_proto._setScrollbarComponentsEnabled = function _setScrollbarComponentsEnabled(enabled) {
			if (this._scrollbarReferences[ORIENTATION_HORIZONTAL].hasComponent('scrollbar')) {
				this._scrollbarReferences[ORIENTATION_HORIZONTAL].entity.scrollbar.enabled = enabled;
			}

			if (this._scrollbarReferences[ORIENTATION_VERTICAL].hasComponent('scrollbar')) {
				this._scrollbarReferences[ORIENTATION_VERTICAL].entity.scrollbar.enabled = enabled;
			}
		};

		_proto._setContentDraggingEnabled = function _setContentDraggingEnabled(enabled) {
			if (this._contentDragHelper) {
				this._contentDragHelper.enabled = enabled;
			}
		};

		_proto._onMouseWheel = function _onMouseWheel(event) {
			if (this.useMouseWheel) {
				var wheelEvent = event.event;
				var normalizedDeltaX = wheelEvent.deltaX / this._contentReference.entity.element.calculatedWidth * this.mouseWheelSensitivity.x;
				var normalizedDeltaY = wheelEvent.deltaY / this._contentReference.entity.element.calculatedHeight * this.mouseWheelSensitivity.y;
				var scrollX = math.clamp(this._scroll.x + normalizedDeltaX, 0, this._getMaxScrollValue(ORIENTATION_HORIZONTAL));
				var scrollY = math.clamp(this._scroll.y + normalizedDeltaY, 0, this._getMaxScrollValue(ORIENTATION_VERTICAL));
				this.scroll = new Vec2(scrollX, scrollY);
			}
		};

		_proto._enableContentInput = function _enableContentInput() {
			while (this._disabledContentInputEntities.length) {
				var e = this._disabledContentInputEntities.pop();

				if (e.element) {
					e.element.useInput = true;
				}
			}

			this._disabledContentInput = false;
		};

		_proto._disableContentInput = function _disableContentInput() {
			var _this2 = this;

			var _disableInput = function _disableInput(e) {
				if (e.element && e.element.useInput) {
					_this2._disabledContentInputEntities.push(e);

					e.element.useInput = false;
				}

				var children = e.children;

				for (var i = 0, l = children.length; i < l; i++) {
					_disableInput(children[i]);
				}
			};

			var contentEntity = this._contentReference.entity;

			if (contentEntity) {
				var children = contentEntity.children;

				for (var i = 0, l = children.length; i < l; i++) {
					_disableInput(children[i]);
				}
			}

			this._disabledContentInput = true;
		};

		_proto.onEnable = function onEnable() {
			this._viewportReference.onParentComponentEnable();

			this._contentReference.onParentComponentEnable();

			this._scrollbarReferences[ORIENTATION_HORIZONTAL].onParentComponentEnable();

			this._scrollbarReferences[ORIENTATION_VERTICAL].onParentComponentEnable();

			this._setScrollbarComponentsEnabled(true);

			this._setContentDraggingEnabled(true);

			this._syncAll();
		};

		_proto.onDisable = function onDisable() {
			this._setScrollbarComponentsEnabled(false);

			this._setContentDraggingEnabled(false);
		};

		_proto.onRemove = function onRemove() {
			this._toggleLifecycleListeners('off', this.system);

			this._toggleElementListeners('off');

			this._destroyDragHelper();
		};

		_createClass(ScrollViewComponent, [{
			key: "scroll",
			get: function get() {
				return this._scroll;
			},
			set: function set(value) {
				this._onSetScroll(value.x, value.y);
			}
		}]);

		return ScrollViewComponent;
	}(Component);

	var ScrollViewComponentData = function ScrollViewComponentData() {
		this.enabled = true;
	};

	var _schema$4 = [{
		name: 'enabled',
		type: 'boolean'
	}, {
		name: 'horizontal',
		type: 'boolean'
	}, {
		name: 'vertical',
		type: 'boolean'
	}, {
		name: 'scrollMode',
		type: 'number'
	}, {
		name: 'bounceAmount',
		type: 'number'
	}, {
		name: 'friction',
		type: 'number'
	}, {
		name: 'dragThreshold',
		type: 'number'
	}, {
		name: 'useMouseWheel',
		type: 'boolean'
	}, {
		name: 'mouseWheelSensitivity',
		type: 'vec2'
	}, {
		name: 'horizontalScrollbarVisibility',
		type: 'number'
	}, {
		name: 'verticalScrollbarVisibility',
		type: 'number'
	}, {
		name: 'viewportEntity',
		type: 'entity'
	}, {
		name: 'contentEntity',
		type: 'entity'
	}, {
		name: 'horizontalScrollbarEntity',
		type: 'entity'
	}, {
		name: 'verticalScrollbarEntity',
		type: 'entity'
	}];
	var DEFAULT_DRAG_THRESHOLD = 10;

	var ScrollViewComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ScrollViewComponentSystem, _ComponentSystem);

		function ScrollViewComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'scrollview';
			_this.ComponentType = ScrollViewComponent;
			_this.DataType = ScrollViewComponentData;
			_this.schema = _schema$4;

			_this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));

			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = ScrollViewComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.dragThreshold === undefined) {
				data.dragThreshold = DEFAULT_DRAG_THRESHOLD;
			}

			if (data.useMouseWheel === undefined) {
				data.useMouseWheel = true;
			}

			if (data.mouseWheelSensitivity === undefined) {
				data.mouseWheelSensitivity = new Vec2(1, 1);
			}

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$4);
		};

		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;

			for (var id in components) {
				var entity = components[id].entity;
				var component = entity.scrollview;

				if (component.enabled && entity.enabled) {
					component.onUpdate();
				}
			}
		};

		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off('update', this.onUpdate, this);
		};

		return ScrollViewComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ScrollViewComponent.prototype, _schema$4);

	var ScrollbarComponent = function (_Component) {
		_inheritsLoose(ScrollbarComponent, _Component);

		function ScrollbarComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._handleReference = new EntityReference(_assertThisInitialized(_this), 'handleEntity', {
				'element#gain': _this._onHandleElementGain,
				'element#lose': _this._onHandleElementLose,
				'element#set:anchor': _this._onSetHandleAlignment,
				'element#set:margin': _this._onSetHandleAlignment,
				'element#set:pivot': _this._onSetHandleAlignment
			});

			_this._toggleLifecycleListeners('on');

			return _this;
		}

		var _proto = ScrollbarComponent.prototype;

		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff) {
			this[onOrOff]('set_value', this._onSetValue, this);
			this[onOrOff]('set_handleSize', this._onSetHandleSize, this);
			this[onOrOff]('set_orientation', this._onSetOrientation, this);
		};

		_proto._onHandleElementGain = function _onHandleElementGain() {
			this._destroyDragHelper();

			this._handleDragHelper = new ElementDragHelper(this._handleReference.entity.element, this._getAxis());

			this._handleDragHelper.on('drag:move', this._onHandleDrag, this);

			this._updateHandlePositionAndSize();
		};

		_proto._onHandleElementLose = function _onHandleElementLose() {
			this._destroyDragHelper();
		};

		_proto._onHandleDrag = function _onHandleDrag(position) {
			if (this._handleReference.entity && this.enabled && this.entity.enabled) {
				this.value = this._handlePositionToScrollValue(position[this._getAxis()]);
			}
		};

		_proto._onSetValue = function _onSetValue(name, oldValue, newValue) {
			if (Math.abs(newValue - oldValue) > 1e-5) {
				this.data.value = math.clamp(newValue, 0, 1);

				this._updateHandlePositionAndSize();

				this.fire('set:value', this.data.value);
			}
		};

		_proto._onSetHandleSize = function _onSetHandleSize(name, oldValue, newValue) {
			if (Math.abs(newValue - oldValue) > 1e-5) {
				this.data.handleSize = math.clamp(newValue, 0, 1);

				this._updateHandlePositionAndSize();
			}
		};

		_proto._onSetHandleAlignment = function _onSetHandleAlignment() {
			this._updateHandlePositionAndSize();
		};

		_proto._onSetOrientation = function _onSetOrientation(name, oldValue, newValue) {
			if (newValue !== oldValue && this._handleReference.hasComponent('element')) {
				this._handleReference.entity.element[this._getOppositeDimension()] = 0;
			}
		};

		_proto._updateHandlePositionAndSize = function _updateHandlePositionAndSize() {
			var handleEntity = this._handleReference.entity;
			var handleElement = handleEntity && handleEntity.element;

			if (handleEntity) {
				var position = handleEntity.getLocalPosition();
				position[this._getAxis()] = this._getHandlePosition();

				this._handleReference.entity.setLocalPosition(position);
			}

			if (handleElement) {
				handleElement[this._getDimension()] = this._getHandleLength();
			}
		};

		_proto._handlePositionToScrollValue = function _handlePositionToScrollValue(handlePosition) {
			return handlePosition * this._getSign() / this._getUsableTrackLength();
		};

		_proto._scrollValueToHandlePosition = function _scrollValueToHandlePosition(value) {
			return value * this._getSign() * this._getUsableTrackLength();
		};

		_proto._getUsableTrackLength = function _getUsableTrackLength() {
			return Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);
		};

		_proto._getTrackLength = function _getTrackLength() {
			if (this.entity.element) {
				return this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;
			}

			return 0;
		};

		_proto._getHandleLength = function _getHandleLength() {
			return this._getTrackLength() * this.handleSize;
		};

		_proto._getHandlePosition = function _getHandlePosition() {
			return this._scrollValueToHandlePosition(this.value);
		};

		_proto._getSign = function _getSign() {
			return this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
		};

		_proto._getAxis = function _getAxis() {
			return this.orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
		};

		_proto._getDimension = function _getDimension() {
			return this.orientation === ORIENTATION_HORIZONTAL ? 'width' : 'height';
		};

		_proto._getOppositeDimension = function _getOppositeDimension() {
			return this.orientation === ORIENTATION_HORIZONTAL ? 'height' : 'width';
		};

		_proto._destroyDragHelper = function _destroyDragHelper() {
			if (this._handleDragHelper) {
				this._handleDragHelper.destroy();
			}
		};

		_proto._setHandleDraggingEnabled = function _setHandleDraggingEnabled(enabled) {
			if (this._handleDragHelper) {
				this._handleDragHelper.enabled = enabled;
			}
		};

		_proto.onEnable = function onEnable() {
			this._handleReference.onParentComponentEnable();

			this._setHandleDraggingEnabled(true);
		};

		_proto.onDisable = function onDisable() {
			this._setHandleDraggingEnabled(false);
		};

		_proto.onRemove = function onRemove() {
			this._destroyDragHelper();

			this._toggleLifecycleListeners('off');
		};

		return ScrollbarComponent;
	}(Component);

	var ScrollbarComponentData = function ScrollbarComponentData() {
		this.enabled = true;
	};

	var _schema$3 = [{
		name: 'enabled',
		type: 'boolean'
	}, {
		name: 'orientation',
		type: 'number'
	}, {
		name: 'value',
		type: 'number'
	}, {
		name: 'handleSize',
		type: 'number'
	}, {
		name: 'handleEntity',
		type: 'entity'
	}];

	var ScrollbarComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ScrollbarComponentSystem, _ComponentSystem);

		function ScrollbarComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'scrollbar';
			_this.ComponentType = ScrollbarComponent;
			_this.DataType = ScrollbarComponentData;
			_this.schema = _schema$3;

			_this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = ScrollbarComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$3);
		};

		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};

		return ScrollbarComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ScrollbarComponent.prototype, _schema$3);

	var STATE_PLAYING = 0;
	var STATE_PAUSED = 1;
	var STATE_STOPPED = 2;

	function capTime(time, duration) {
		return time % duration || 0;
	}

	var SoundInstance = function (_EventHandler) {
		_inheritsLoose(SoundInstance, _EventHandler);

		function SoundInstance(manager, sound, options) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this.source = null;
			_this._manager = manager;
			_this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
			_this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
			_this._loop = !!(options.loop !== undefined ? options.loop : false);
			_this._sound = sound;
			_this._state = STATE_STOPPED;
			_this._suspended = false;
			_this._suspendEndEvent = false;
			_this._suspendInstanceEvents = false;
			_this._playWhenLoaded = true;
			_this._startTime = Math.max(0, Number(options.startTime) || 0);
			_this._duration = Math.max(0, Number(options.duration) || 0);
			_this._startOffset = null;
			_this._onPlayCallback = options.onPlay;
			_this._onPauseCallback = options.onPause;
			_this._onResumeCallback = options.onResume;
			_this._onStopCallback = options.onStop;
			_this._onEndCallback = options.onEnd;

			if (hasAudioContext()) {
				_this._startedAt = 0;
				_this._currentTime = 0;
				_this._currentOffset = 0;
				_this._inputNode = null;
				_this._connectorNode = null;
				_this._firstNode = null;
				_this._lastNode = null;

				_this._initializeNodes();

				_this._endedHandler = _this._onEnded.bind(_assertThisInitialized(_this));
			} else {
				_this._isReady = false;
				_this._loadedMetadataHandler = _this._onLoadedMetadata.bind(_assertThisInitialized(_this));
				_this._timeUpdateHandler = _this._onTimeUpdate.bind(_assertThisInitialized(_this));
				_this._endedHandler = _this._onEnded.bind(_assertThisInitialized(_this));

				_this._createSource();
			}

			return _this;
		}

		var _proto = SoundInstance.prototype;

		_proto._onPlay = function _onPlay() {
			this.fire('play');
			if (this._onPlayCallback) this._onPlayCallback(this);
		};

		_proto._onPause = function _onPause() {
			this.fire('pause');
			if (this._onPauseCallback) this._onPauseCallback(this);
		};

		_proto._onResume = function _onResume() {
			this.fire('resume');
			if (this._onResumeCallback) this._onResumeCallback(this);
		};

		_proto._onStop = function _onStop() {
			this.fire('stop');
			if (this._onStopCallback) this._onStopCallback(this);
		};

		_proto._onEnded = function _onEnded() {
			if (this._suspendEndEvent) {
				this._suspendEndEvent = false;
				return;
			}

			this.fire('end');
			if (this._onEndCallback) this._onEndCallback(this);
			this.stop();
		};

		_proto._onManagerVolumeChange = function _onManagerVolumeChange() {
			this.volume = this._volume;
		};

		_proto._onManagerSuspend = function _onManagerSuspend() {
			if (this._state === STATE_PLAYING && !this._suspended) {
				this._suspended = true;
				this.pause();
			}
		};

		_proto._onManagerResume = function _onManagerResume() {
			if (this._suspended) {
				this._suspended = false;
				this.resume();
			}
		};

		_proto._initializeNodes = function _initializeNodes() {
			this.gain = this._manager.context.createGain();
			this._inputNode = this.gain;
			this._connectorNode = this.gain;

			this._connectorNode.connect(this._manager.context.destination);
		};

		_proto.play = function play() {
			if (this._state !== STATE_STOPPED) {
				this.stop();
			}

			if (!this.source) {
				this._createSource();
			}

			var offset = capTime(this._startOffset, this.duration);
			offset = capTime(this._startTime + offset, this._sound.duration);
			this._startOffset = null;

			if (this._duration) {
				this.source.start(0, offset, this._duration);
			} else {
				this.source.start(0, offset);
			}

			this._startedAt = this._manager.context.currentTime;
			this._currentTime = 0;
			this._currentOffset = offset;
			this._state = STATE_PLAYING;
			this._playWhenLoaded = false;
			this.volume = this._volume;
			this.loop = this._loop;
			this.pitch = this._pitch;

			this._manager.on('volumechange', this._onManagerVolumeChange, this);

			this._manager.on('suspend', this._onManagerSuspend, this);

			this._manager.on('resume', this._onManagerResume, this);

			this._manager.on('destroy', this._onManagerDestroy, this);

			if (this._manager.suspended) {
				this._onManagerSuspend();
			}

			if (!this._suspendInstanceEvents) this._onPlay();
			return true;
		};

		_proto.pause = function pause() {
			this._playWhenLoaded = false;
			if (this._state !== STATE_PLAYING || !this.source) return false;

			this._updateCurrentTime();

			this._state = STATE_PAUSED;
			this._suspendEndEvent = true;
			this.source.stop(0);
			this.source = null;
			this._startOffset = null;
			if (!this._suspendInstanceEvents) this._onPause();
			return true;
		};

		_proto.resume = function resume() {
			if (this._state !== STATE_PAUSED) {
				return false;
			}

			if (!this.source) {
				this._createSource();
			}

			var offset = this.currentTime;

			if (this._startOffset !== null) {
				offset = capTime(this._startOffset, this.duration);
				offset = capTime(this._startTime + offset, this._sound.duration);
				this._startOffset = null;
			}

			if (this._duration) {
				this.source.start(0, offset, this._duration);
			} else {
				this.source.start(0, offset);
			}

			this._state = STATE_PLAYING;
			this._startedAt = this._manager.context.currentTime;
			this._currentOffset = offset;
			this.volume = this._volume;
			this.loop = this._loop;
			this.pitch = this._pitch;
			this._playWhenLoaded = false;
			if (!this._suspendInstanceEvents) this._onResume();
			return true;
		};

		_proto.stop = function stop() {
			this._playWhenLoaded = false;
			if (this._state === STATE_STOPPED || !this.source) return false;

			this._manager.off('volumechange', this._onManagerVolumeChange, this);

			this._manager.off('suspend', this._onManagerSuspend, this);

			this._manager.off('resume', this._onManagerResume, this);

			this._manager.off('destroy', this._onManagerDestroy, this);

			this._startedAt = 0;
			this._currentTime = 0;
			this._currentOffset = 0;
			this._startOffset = null;
			this._suspendEndEvent = true;

			if (this._state === STATE_PLAYING) {
				this.source.stop(0);
			}

			this.source = null;
			this._state = STATE_STOPPED;
			if (!this._suspendInstanceEvents) this._onStop();
			return true;
		};

		_proto.setExternalNodes = function setExternalNodes(firstNode, lastNode) {
			if (!firstNode) {
				console.error('The firstNode must be a valid Audio Node');
				return;
			}

			if (!lastNode) {
				lastNode = firstNode;
			}

			var speakers = this._manager.context.destination;

			if (this._firstNode !== firstNode) {
				if (this._firstNode) {
					this._connectorNode.disconnect(this._firstNode);
				} else {
					this._connectorNode.disconnect(speakers);
				}

				this._firstNode = firstNode;

				this._connectorNode.connect(firstNode);
			}

			if (this._lastNode !== lastNode) {
				if (this._lastNode) {
					this._lastNode.disconnect(speakers);
				}

				this._lastNode = lastNode;

				this._lastNode.connect(speakers);
			}
		};

		_proto.clearExternalNodes = function clearExternalNodes() {
			var speakers = this._manager.context.destination;

			if (this._firstNode) {
				this._connectorNode.disconnect(this._firstNode);

				this._firstNode = null;
			}

			if (this._lastNode) {
				this._lastNode.disconnect(speakers);

				this._lastNode = null;
			}

			this._connectorNode.connect(speakers);
		};

		_proto.getExternalNodes = function getExternalNodes() {
			return [this._firstNode, this._lastNode];
		};

		_proto._createSource = function _createSource() {
			if (!this._sound) {
				return null;
			}

			var context = this._manager.context;

			if (this._sound.buffer) {
				this.source = context.createBufferSource();
				this.source.buffer = this._sound.buffer;
				this.source.connect(this._inputNode);
				this.source.onended = this._endedHandler;
				this.source.loopStart = capTime(this._startTime, this.source.buffer.duration);

				if (this._duration) {
					this.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));
				}
			}

			return this.source;
		};

		_proto._updateCurrentTime = function _updateCurrentTime() {
			this._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);
		};

		_proto._onManagerDestroy = function _onManagerDestroy() {
			if (this.source && this._state === STATE_PLAYING) {
				this.source.stop(0);
				this.source = null;
			}
		};

		_createClass(SoundInstance, [{
			key: "currentTime",
			get: function get() {
				if (this._startOffset !== null) {
					return this._startOffset;
				}

				if (this._state === STATE_PAUSED) {
					return this._currentTime;
				}

				if (this._state === STATE_STOPPED || !this.source) {
					return 0;
				}

				this._updateCurrentTime();

				return this._currentTime;
			},
			set: function set(value) {
				if (value < 0) return;

				if (this._state === STATE_PLAYING) {
					var suspend = this._suspendInstanceEvents;
					this._suspendInstanceEvents = true;
					this.stop();
					this._startOffset = value;
					this.play();
					this._suspendInstanceEvents = suspend;
				} else {
					this._startOffset = value;
					this._currentTime = value;
				}
			}
		}, {
			key: "duration",
			get: function get() {
				if (!this._sound) {
					return 0;
				}

				if (this._duration) {
					return capTime(this._duration, this._sound.duration);
				}

				return this._sound.duration;
			},
			set: function set(value) {
				this._duration = Math.max(0, Number(value) || 0);
				var isPlaying = this._state === STATE_PLAYING;
				this.stop();

				if (isPlaying) {
					this.play();
				}
			}
		}, {
			key: "isPaused",
			get: function get() {
				return this._state === STATE_PAUSED;
			}
		}, {
			key: "isPlaying",
			get: function get() {
				return this._state === STATE_PLAYING;
			}
		}, {
			key: "isStopped",
			get: function get() {
				return this._state === STATE_STOPPED;
			}
		}, {
			key: "isSuspended",
			get: function get() {
				return this._suspended;
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(value) {
				this._loop = !!value;

				if (this.source) {
					this.source.loop = this._loop;
				}
			}
		}, {
			key: "pitch",
			get: function get() {
				return this._pitch;
			},
			set: function set(pitch) {
				this._currentOffset = this.currentTime;
				this._startedAt = this._manager.context.currentTime;
				this._pitch = Math.max(Number(pitch) || 0, 0.01);

				if (this.source) {
					this.source.playbackRate.value = this._pitch;
				}
			}
		}, {
			key: "sound",
			get: function get() {
				return this._sound;
			},
			set: function set(value) {
				this._sound = value;

				if (this._state !== STATE_STOPPED) {
					this.stop();
				} else {
					this._createSource();
				}
			}
		}, {
			key: "startTime",
			get: function get() {
				return this._startTime;
			},
			set: function set(value) {
				this._startTime = Math.max(0, Number(value) || 0);
				var isPlaying = this._state === STATE_PLAYING;
				this.stop();

				if (isPlaying) {
					this.play();
				}
			}
		}, {
			key: "volume",
			get: function get() {
				return this._volume;
			},
			set: function set(volume) {
				volume = math.clamp(volume, 0, 1);
				this._volume = volume;

				if (this.gain) {
					this.gain.gain.value = volume * this._manager.volume;
				}
			}
		}]);

		return SoundInstance;
	}(EventHandler);

	if (!hasAudioContext()) {
		Object.assign(SoundInstance.prototype, {
			play: function play() {
				if (this._state !== STATE_STOPPED) {
					this.stop();
				}

				if (!this.source) {
					if (!this._createSource()) {
						return false;
					}
				}

				this.volume = this._volume;
				this.pitch = this._pitch;
				this.loop = this._loop;
				this.source.play();
				this._state = STATE_PLAYING;
				this._playWhenLoaded = false;

				this._manager.on('volumechange', this._onManagerVolumeChange, this);

				this._manager.on('suspend', this._onManagerSuspend, this);

				this._manager.on('resume', this._onManagerResume, this);

				this._manager.on('destroy', this._onManagerDestroy, this);

				if (this._manager.suspended) this._onManagerSuspend();
				if (!this._suspendInstanceEvents) this._onPlay();
				return true;
			},
			pause: function pause() {
				if (!this.source || this._state !== STATE_PLAYING) return false;
				this._suspendEndEvent = true;
				this.source.pause();
				this._playWhenLoaded = false;
				this._state = STATE_PAUSED;
				this._startOffset = null;
				if (!this._suspendInstanceEvents) this._onPause();
				return true;
			},
			resume: function resume() {
				if (!this.source || this._state !== STATE_PAUSED) return false;
				this._state = STATE_PLAYING;
				this._playWhenLoaded = false;

				if (this.source.paused) {
					this.source.play();
					if (!this._suspendInstanceEvents) this._onResume();
				}

				return true;
			},
			stop: function stop() {
				if (!this.source || this._state === STATE_STOPPED) return false;

				this._manager.off('volumechange', this._onManagerVolumeChange, this);

				this._manager.off('suspend', this._onManagerSuspend, this);

				this._manager.off('resume', this._onManagerResume, this);

				this._manager.off('destroy', this._onManagerDestroy, this);

				this._suspendEndEvent = true;
				this.source.pause();
				this._playWhenLoaded = false;
				this._state = STATE_STOPPED;
				this._startOffset = null;
				if (!this._suspendInstanceEvents) this._onStop();
				return true;
			},
			setExternalNodes: function setExternalNodes() {},
			clearExternalNodes: function clearExternalNodes() {},
			getExternalNodes: function getExternalNodes() {
				return [null, null];
			},
			_onLoadedMetadata: function _onLoadedMetadata() {
				this.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);
				this._isReady = true;
				var offset = capTime(this._startOffset, this.duration);
				offset = capTime(this._startTime + offset, this._sound.duration);
				this._startOffset = null;
				this.source.currentTime = offset;
			},
			_createSource: function _createSource() {
				if (this._sound && this._sound.audio) {
					this._isReady = false;
					this.source = this._sound.audio.cloneNode(true);
					this.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);
					this.source.addEventListener('timeupdate', this._timeUpdateHandler);
					this.source.onended = this._endedHandler;
				}

				return this.source;
			},
			_onTimeUpdate: function _onTimeUpdate() {
				if (!this._duration) return;

				if (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {
					if (this.loop) {
						this.source.currentTime = capTime(this._startTime, this.source.duration);
					} else {
						this.source.removeEventListener('timeupdate', this._timeUpdateHandler);
						this.source.pause();

						this._onEnded();
					}
				}
			},
			_onManagerDestroy: function _onManagerDestroy() {
				if (this.source) {
					this.source.pause();
				}
			}
		});
		Object.defineProperty(SoundInstance.prototype, 'volume', {
			get: function get() {
				return this._volume;
			},
			set: function set(volume) {
				volume = math.clamp(volume, 0, 1);
				this._volume = volume;

				if (this.source) {
					this.source.volume = volume * this._manager.volume;
				}
			}
		});
		Object.defineProperty(SoundInstance.prototype, 'pitch', {
			get: function get() {
				return this._pitch;
			},
			set: function set(pitch) {
				this._pitch = Math.max(Number(pitch) || 0, 0.01);

				if (this.source) {
					this.source.playbackRate = this._pitch;
				}
			}
		});
		Object.defineProperty(SoundInstance.prototype, 'sound', {
			get: function get() {
				return this._sound;
			},
			set: function set(value) {
				this.stop();
				this._sound = value;
			}
		});
		Object.defineProperty(SoundInstance.prototype, 'currentTime', {
			get: function get() {
				if (this._startOffset !== null) {
					return this._startOffset;
				}

				if (this._state === STATE_STOPPED || !this.source) {
					return 0;
				}

				return this.source.currentTime - this._startTime;
			},
			set: function set(value) {
				if (value < 0) return;
				this._startOffset = value;

				if (this.source && this._isReady) {
					this.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);
					this._startOffset = null;
				}
			}
		});
	}

	var MAX_DISTANCE = 10000;

	var SoundInstance3d = function (_SoundInstance) {
		_inheritsLoose(SoundInstance3d, _SoundInstance);

		function SoundInstance3d(manager, sound, options) {
			var _this;

			if (options === void 0) {
				options = {};
			}

			_this = _SoundInstance.call(this, manager, sound, options) || this;
			_this._position = new Vec3();
			_this._velocity = new Vec3();
			if (options.position) _this.position = options.position;
			_this.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;
			_this.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
			_this.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
			_this.distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;
			return _this;
		}

		var _proto = SoundInstance3d.prototype;

		_proto._initializeNodes = function _initializeNodes() {
			this.gain = this._manager.context.createGain();
			this.panner = this._manager.context.createPanner();
			this.panner.connect(this.gain);
			this._inputNode = this.panner;
			this._connectorNode = this.gain;

			this._connectorNode.connect(this._manager.context.destination);
		};

		_createClass(SoundInstance3d, [{
			key: "position",
			get: function get() {
				return this._position;
			},
			set: function set(value) {
				this._position.copy(value);

				var panner = this.panner;

				if ('positionX' in panner) {
					panner.positionX.value = value.x;
					panner.positionY.value = value.y;
					panner.positionZ.value = value.z;
				} else if (panner.setPosition) {
					panner.setPosition(value.x, value.y, value.z);
				}
			}
		}, {
			key: "velocity",
			get: function get() {
				Debug.warn('SoundInstance3d#velocity is not implemented.');
				return this._velocity;
			},
			set: function set(velocity) {
				Debug.warn('SoundInstance3d#velocity is not implemented.');

				this._velocity.copy(velocity);
			}
		}, {
			key: "maxDistance",
			get: function get() {
				return this.panner.maxDistance;
			},
			set: function set(value) {
				this.panner.maxDistance = value;
			}
		}, {
			key: "refDistance",
			get: function get() {
				return this.panner.refDistance;
			},
			set: function set(value) {
				this.panner.refDistance = value;
			}
		}, {
			key: "rollOffFactor",
			get: function get() {
				return this.panner.rolloffFactor;
			},
			set: function set(value) {
				this.panner.rolloffFactor = value;
			}
		}, {
			key: "distanceModel",
			get: function get() {
				return this.panner.distanceModel;
			},
			set: function set(value) {
				this.panner.distanceModel = value;
			}
		}]);

		return SoundInstance3d;
	}(SoundInstance);

	if (!hasAudioContext()) {
		var offset = new Vec3();

		var fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {
			offset = offset.sub2(posOne, posTwo);
			var distance = offset.length();

			if (distance < refDistance) {
				return 1;
			} else if (distance > maxDistance) {
				return 0;
			}

			var result = 0;

			if (distanceModel === DISTANCE_LINEAR) {
				result = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);
			} else if (distanceModel === DISTANCE_INVERSE) {
				result = refDistance / (refDistance + rollOffFactor * (distance - refDistance));
			} else if (distanceModel === DISTANCE_EXPONENTIAL) {
				result = Math.pow(distance / refDistance, -rollOffFactor);
			}

			return math.clamp(result, 0, 1);
		};

		Object.defineProperty(SoundInstance3d.prototype, 'position', {
			get: function get() {
				return this._position;
			},
			set: function set(position) {
				this._position.copy(position);

				if (this.source) {
					var listener = this._manager.listener;
					var lpos = listener.getPosition();
					var factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
					var v = this.volume;
					this.source.volume = v * factor * this._manager.volume;
				}
			}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'maxDistance', {
			get: function get() {
				return this._maxDistance;
			},
			set: function set(value) {
				this._maxDistance = value;
			}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'refDistance', {
			get: function get() {
				return this._refDistance;
			},
			set: function set(value) {
				this._refDistance = value;
			}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {
			get: function get() {
				return this._rollOffFactor;
			},
			set: function set(value) {
				this._rollOffFactor = value;
			}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'distanceModel', {
			get: function get() {
				return this._distanceModel;
			},
			set: function set(value) {
				this._distanceModel = value;
			}
		});
	}

	var instanceOptions = {
		volume: 0,
		pitch: 0,
		loop: false,
		startTime: 0,
		duration: 0,
		position: new Vec3(),
		maxDistance: 0,
		refDistance: 0,
		rollOffFactor: 0,
		distanceModel: 0,
		onPlay: null,
		onPause: null,
		onResume: null,
		onStop: null,
		onEnd: null
	};

	var SoundSlot = function (_EventHandler) {
		_inheritsLoose(SoundSlot, _EventHandler);

		function SoundSlot(component, name, options) {
			var _this;

			if (name === void 0) {
				name = 'Untitled';
			}

			if (options === void 0) {
				options = {};
			}

			_this = _EventHandler.call(this) || this;
			_this.name = void 0;
			_this.instances = [];
			_this._component = component;
			_this._assets = component.system.app.assets;
			_this._manager = component.system.manager;
			_this.name = name;
			_this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
			_this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
			_this._loop = !!(options.loop !== undefined ? options.loop : false);
			_this._duration = options.duration > 0 ? options.duration : null;
			_this._startTime = Math.max(0, Number(options.startTime) || 0);
			_this._overlap = !!options.overlap;
			_this._autoPlay = !!options.autoPlay;
			_this._firstNode = null;
			_this._lastNode = null;
			_this._asset = options.asset;

			if (_this._asset instanceof Asset) {
				_this._asset = _this._asset.id;
			}

			_this._onInstancePlayHandler = _this._onInstancePlay.bind(_assertThisInitialized(_this));
			_this._onInstancePauseHandler = _this._onInstancePause.bind(_assertThisInitialized(_this));
			_this._onInstanceResumeHandler = _this._onInstanceResume.bind(_assertThisInitialized(_this));
			_this._onInstanceStopHandler = _this._onInstanceStop.bind(_assertThisInitialized(_this));
			_this._onInstanceEndHandler = _this._onInstanceEnd.bind(_assertThisInitialized(_this));
			return _this;
		}

		var _proto = SoundSlot.prototype;

		_proto.play = function play() {
			if (!this.overlap) {
				this.stop();
			}

			if (!this.isLoaded && !this._hasAsset()) {
				Debug.warn("Trying to play SoundSlot " + this.name + " but it is not loaded and doesn't have an asset.");
				return;
			}

			var instance = this._createInstance();

			this.instances.push(instance);

			if (!this.isLoaded) {
				var onLoad = function onLoad(sound) {
					var playWhenLoaded = instance._playWhenLoaded;
					instance.sound = sound;

					if (playWhenLoaded) {
						instance.play();
					}
				};

				this.off('load', onLoad);
				this.once('load', onLoad);
				this.load();
			} else {
				instance.play();
			}

			return instance;
		};

		_proto.pause = function pause() {
			var paused = false;
			var instances = this.instances;

			for (var i = 0, len = instances.length; i < len; i++) {
				if (instances[i].pause()) {
					paused = true;
				}
			}

			return paused;
		};

		_proto.resume = function resume() {
			var resumed = false;
			var instances = this.instances;

			for (var i = 0, len = instances.length; i < len; i++) {
				if (instances[i].resume()) resumed = true;
			}

			return resumed;
		};

		_proto.stop = function stop() {
			var stopped = false;
			var instances = this.instances;
			var i = instances.length;

			while (i--) {
				instances[i].stop();
				stopped = true;
			}

			instances.length = 0;
			return stopped;
		};

		_proto.load = function load() {
			if (!this._hasAsset()) return;

			var asset = this._assets.get(this._asset);

			if (!asset) {
				this._assets.off('add:' + this._asset, this._onAssetAdd, this);

				this._assets.once('add:' + this._asset, this._onAssetAdd, this);

				return;
			}

			asset.off('remove', this._onAssetRemoved, this);
			asset.on('remove', this._onAssetRemoved, this);

			if (!asset.resource) {
				asset.off('load', this._onAssetLoad, this);
				asset.once('load', this._onAssetLoad, this);

				this._assets.load(asset);

				return;
			}

			this.fire('load', asset.resource);
		};

		_proto.setExternalNodes = function setExternalNodes(firstNode, lastNode) {
			if (!firstNode) {
				console.error('The firstNode must have a valid AudioNode');
				return;
			}

			if (!lastNode) {
				lastNode = firstNode;
			}

			this._firstNode = firstNode;
			this._lastNode = lastNode;

			if (!this._overlap) {
				var instances = this.instances;

				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].setExternalNodes(firstNode, lastNode);
				}
			}
		};

		_proto.clearExternalNodes = function clearExternalNodes() {
			this._firstNode = null;
			this._lastNode = null;

			if (!this._overlap) {
				var instances = this.instances;

				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].clearExternalNodes();
				}
			}
		};

		_proto.getExternalNodes = function getExternalNodes() {
			return [this._firstNode, this._lastNode];
		};

		_proto._hasAsset = function _hasAsset() {
			return this._asset != null;
		};

		_proto._createInstance = function _createInstance() {
			var instance = null;
			var component = this._component;
			var sound = null;

			if (this._hasAsset()) {
				var asset = this._assets.get(this._asset);

				if (asset) {
					sound = asset.resource;
				}
			}

			var data = instanceOptions;
			data.volume = this._volume * component.volume;
			data.pitch = this._pitch * component.pitch;
			data.loop = this._loop;
			data.startTime = this._startTime;
			data.duration = this._duration;
			data.onPlay = this._onInstancePlayHandler;
			data.onPause = this._onInstancePauseHandler;
			data.onResume = this._onInstanceResumeHandler;
			data.onStop = this._onInstanceStopHandler;
			data.onEnd = this._onInstanceEndHandler;

			if (component.positional) {
				data.position.copy(component.entity.getPosition());
				data.maxDistance = component.maxDistance;
				data.refDistance = component.refDistance;
				data.rollOffFactor = component.rollOffFactor;
				data.distanceModel = component.distanceModel;
				instance = new SoundInstance3d(this._manager, sound, data);
			} else {
				instance = new SoundInstance(this._manager, sound, data);
			}

			if (this._firstNode) {
				instance.setExternalNodes(this._firstNode, this._lastNode);
			}

			return instance;
		};

		_proto._onInstancePlay = function _onInstancePlay(instance) {
			this.fire('play', instance);

			this._component.fire('play', this, instance);
		};

		_proto._onInstancePause = function _onInstancePause(instance) {
			this.fire('pause', instance);

			this._component.fire('pause', this, instance);
		};

		_proto._onInstanceResume = function _onInstanceResume(instance) {
			this.fire('resume', instance);

			this._component.fire('resume', this, instance);
		};

		_proto._onInstanceStop = function _onInstanceStop(instance) {
			var idx = this.instances.indexOf(instance);

			if (idx !== -1) {
				this.instances.splice(idx, 1);
			}

			this.fire('stop', instance);

			this._component.fire('stop', this, instance);
		};

		_proto._onInstanceEnd = function _onInstanceEnd(instance) {
			var idx = this.instances.indexOf(instance);

			if (idx !== -1) {
				this.instances.splice(idx, 1);
			}

			this.fire('end', instance);

			this._component.fire('end', this, instance);
		};

		_proto._onAssetAdd = function _onAssetAdd(asset) {
			this.load();
		};

		_proto._onAssetLoad = function _onAssetLoad(asset) {
			this.load();
		};

		_proto._onAssetRemoved = function _onAssetRemoved(asset) {
			asset.off('remove', this._onAssetRemoved, this);

			this._assets.off('add:' + asset.id, this._onAssetAdd, this);

			this.stop();
		};

		_proto.updatePosition = function updatePosition(position) {
			var instances = this.instances;

			for (var i = 0, len = instances.length; i < len; i++) {
				instances[i].position = position;
			}
		};

		_createClass(SoundSlot, [{
			key: "asset",
			get: function get() {
				return this._asset;
			},
			set: function set(value) {
				var old = this._asset;

				if (old) {
					this._assets.off('add:' + old, this._onAssetAdd, this);

					var oldAsset = this._assets.get(old);

					if (oldAsset) {
						oldAsset.off('remove', this._onAssetRemoved, this);
					}
				}

				this._asset = value;

				if (this._asset instanceof Asset) {
					this._asset = this._asset.id;
				}

				if (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {
					this.load();
				}
			}
		}, {
			key: "autoPlay",
			get: function get() {
				return this._autoPlay;
			},
			set: function set(value) {
				this._autoPlay = !!value;
			}
		}, {
			key: "duration",
			get: function get() {
				var assetDuration = 0;

				if (this._hasAsset()) {
					var asset = this._assets.get(this._asset);

					assetDuration = asset != null && asset.resource ? asset.resource.duration : 0;
				}

				if (this._duration != null) {
					return this._duration % (assetDuration || 1);
				}

				return assetDuration;
			},
			set: function set(value) {
				this._duration = Math.max(0, Number(value) || 0) || null;

				if (!this._overlap) {
					var instances = this.instances;

					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i].duration = this._duration;
					}
				}
			}
		}, {
			key: "isLoaded",
			get: function get() {
				if (this._hasAsset()) {
					var asset = this._assets.get(this._asset);

					if (asset) {
						return !!asset.resource;
					}
				}

				return false;
			}
		}, {
			key: "isPaused",
			get: function get() {
				var instances = this.instances;
				var len = instances.length;
				if (len === 0) return false;

				for (var i = 0; i < len; i++) {
					if (!instances[i].isPaused) return false;
				}

				return true;
			}
		}, {
			key: "isPlaying",
			get: function get() {
				var instances = this.instances;

				for (var i = 0, len = instances.length; i < len; i++) {
					if (instances[i].isPlaying) return true;
				}

				return false;
			}
		}, {
			key: "isStopped",
			get: function get() {
				var instances = this.instances;

				for (var i = 0, len = instances.length; i < len; i++) {
					if (!instances[i].isStopped) return false;
				}

				return true;
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(value) {
				this._loop = !!value;
				var instances = this.instances;

				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].loop = this._loop;
				}
			}
		}, {
			key: "overlap",
			get: function get() {
				return this._overlap;
			},
			set: function set(value) {
				this._overlap = !!value;
			}
		}, {
			key: "pitch",
			get: function get() {
				return this._pitch;
			},
			set: function set(value) {
				this._pitch = Math.max(Number(value) || 0, 0.01);

				if (!this._overlap) {
					var instances = this.instances;

					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i].pitch = this.pitch * this._component.pitch;
					}
				}
			}
		}, {
			key: "startTime",
			get: function get() {
				return this._startTime;
			},
			set: function set(value) {
				this._startTime = Math.max(0, Number(value) || 0);

				if (!this._overlap) {
					var instances = this.instances;

					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i].startTime = this._startTime;
					}
				}
			}
		}, {
			key: "volume",
			get: function get() {
				return this._volume;
			},
			set: function set(value) {
				this._volume = math.clamp(Number(value) || 0, 0, 1);

				if (!this._overlap) {
					var instances = this.instances;

					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i].volume = this._volume * this._component.volume;
					}
				}
			}
		}]);

		return SoundSlot;
	}(EventHandler);

	var SoundComponent = function (_Component) {
		_inheritsLoose(SoundComponent, _Component);

		function SoundComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._volume = 1;
			_this._pitch = 1;
			_this._positional = true;
			_this._refDistance = 1;
			_this._maxDistance = 10000;
			_this._rollOffFactor = 1;
			_this._distanceModel = DISTANCE_LINEAR;
			_this._slots = {};
			_this._playingBeforeDisable = {};
			return _this;
		}

		var _proto = SoundComponent.prototype;

		_proto._updateSoundInstances = function _updateSoundInstances(property, value, isFactor) {
			var slots = this._slots;

			for (var key in slots) {
				var slot = slots[key];

				if (!slot.overlap) {
					var instances = slot.instances;

					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i][property] = isFactor ? slot[property] * value : value;
					}
				}
			}
		};

		_proto.onEnable = function onEnable() {
			if (this.system._inTools) {
				return;
			}

			var slots = this._slots;
			var playingBeforeDisable = this._playingBeforeDisable;

			for (var key in slots) {
				var slot = slots[key];

				if (slot.autoPlay && slot.isStopped) {
					slot.play();
				} else if (playingBeforeDisable[key]) {
					slot.resume();
				} else if (!slot.isLoaded) {
					slot.load();
				}
			}
		};

		_proto.onDisable = function onDisable() {
			var slots = this._slots;
			var playingBeforeDisable = {};

			for (var key in slots) {
				if (!slots[key].overlap) {
					if (slots[key].isPlaying) {
						slots[key].pause();
						playingBeforeDisable[key] = true;
					}
				}
			}

			this._playingBeforeDisable = playingBeforeDisable;
		};

		_proto.onRemove = function onRemove() {
			this.off();
		};

		_proto.addSlot = function addSlot(name, options) {
			var slots = this._slots;

			if (slots[name]) {
				Debug.warn("A sound slot with name " + name + " already exists on Entity " + this.entity.path);
				return null;
			}

			var slot = new SoundSlot(this, name, options);
			slots[name] = slot;

			if (slot.autoPlay && this.enabled && this.entity.enabled) {
				slot.play();
			}

			return slot;
		};

		_proto.removeSlot = function removeSlot(name) {
			var slots = this._slots;

			if (slots[name]) {
				slots[name].stop();
				delete slots[name];
			}
		};

		_proto.slot = function slot(name) {
			return this._slots[name];
		};

		_proto.play = function play(name) {
			if (!this.enabled || !this.entity.enabled) {
				return null;
			}

			var slot = this._slots[name];

			if (!slot) {
				Debug.warn("Trying to play sound slot with name " + name + " which does not exist");
				return null;
			}

			return slot.play();
		};

		_proto.pause = function pause(name) {
			var slots = this._slots;

			if (name) {
				var slot = slots[name];

				if (!slot) {
					Debug.warn("Trying to pause sound slot with name " + name + " which does not exist");
					return;
				}

				slot.pause();
			} else {
				for (var key in slots) {
					slots[key].pause();
				}
			}
		};

		_proto.resume = function resume(name) {
			var slots = this._slots;

			if (name) {
				var slot = slots[name];

				if (!slot) {
					Debug.warn("Trying to resume sound slot with name " + name + " which does not exist");
					return;
				}

				if (slot.isPaused) {
					slot.resume();
				}
			} else {
				for (var key in slots) {
					slots[key].resume();
				}
			}
		};

		_proto.stop = function stop(name) {
			var slots = this._slots;

			if (name) {
				var slot = slots[name];

				if (!slot) {
					Debug.warn("Trying to stop sound slot with name " + name + " which does not exist");
					return;
				}

				slot.stop();
			} else {
				for (var key in slots) {
					slots[key].stop();
				}
			}
		};

		_createClass(SoundComponent, [{
			key: "distanceModel",
			get: function get() {
				return this._distanceModel;
			},
			set: function set(value) {
				this._distanceModel = value;

				this._updateSoundInstances('distanceModel', value, false);
			}
		}, {
			key: "maxDistance",
			get: function get() {
				return this._maxDistance;
			},
			set: function set(value) {
				this._maxDistance = value;

				this._updateSoundInstances('maxDistance', value, false);
			}
		}, {
			key: "refDistance",
			get: function get() {
				return this._refDistance;
			},
			set: function set(value) {
				this._refDistance = value;

				this._updateSoundInstances('refDistance', value, false);
			}
		}, {
			key: "rollOffFactor",
			get: function get() {
				return this._rollOffFactor;
			},
			set: function set(value) {
				this._rollOffFactor = value;

				this._updateSoundInstances('rollOffFactor', value, false);
			}
		}, {
			key: "pitch",
			get: function get() {
				return this._pitch;
			},
			set: function set(value) {
				this._pitch = value;

				this._updateSoundInstances('pitch', value, true);
			}
		}, {
			key: "volume",
			get: function get() {
				return this._volume;
			},
			set: function set(value) {
				this._volume = value;

				this._updateSoundInstances('volume', value, true);
			}
		}, {
			key: "positional",
			get: function get() {
				return this._positional;
			},
			set: function set(newValue) {
				this._positional = newValue;
				var slots = this._slots;

				for (var key in slots) {
					var slot = slots[key];

					if (!slot.overlap) {
						var instances = slot.instances;
						var oldLength = instances.length;

						for (var i = oldLength - 1; i >= 0; i--) {
							var isPlaying = instances[i].isPlaying || instances[i].isSuspended;
							var currentTime = instances[i].currentTime;
							if (isPlaying) instances[i].stop();

							var instance = slot._createInstance();

							if (isPlaying) {
								instance.play();
								instance.currentTime = currentTime;
							}

							instances.push(instance);
						}
					}
				}
			}
		}, {
			key: "slots",
			get: function get() {
				return this._slots;
			},
			set: function set(newValue) {
				var oldValue = this._slots;

				if (oldValue) {
					for (var key in oldValue) {
						oldValue[key].stop();
					}
				}

				var slots = {};

				for (var _key in newValue) {
					if (!(newValue[_key] instanceof SoundSlot)) {
						if (newValue[_key].name) {
							slots[newValue[_key].name] = new SoundSlot(this, newValue[_key].name, newValue[_key]);
						}
					} else {
						slots[newValue[_key].name] = newValue[_key];
					}
				}

				this._slots = slots;
				if (this.enabled && this.entity.enabled) this.onEnable();
			}
		}]);

		return SoundComponent;
	}(Component);

	var SoundComponentData = function SoundComponentData() {
		this.enabled = true;
	};

	var _schema$2 = ['enabled'];

	var SoundComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(SoundComponentSystem, _ComponentSystem);

		function SoundComponentSystem(app, manager) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = "sound";
			_this.ComponentType = SoundComponent;
			_this.DataType = SoundComponentData;
			_this.schema = _schema$2;
			_this.manager = manager;

			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = SoundComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['volume', 'pitch', 'positional', 'refDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'slots'];

			for (var i = 0; i < properties.length; i++) {
				if (data.hasOwnProperty(properties[i])) {
					component[properties[i]] = data[properties[i]];
				}
			}

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var srcComponent = entity.sound;
			var srcSlots = srcComponent.slots;
			var slots = {};

			for (var key in srcSlots) {
				var srcSlot = srcSlots[key];
				slots[key] = {
					name: srcSlot.name,
					volume: srcSlot.volume,
					pitch: srcSlot.pitch,
					loop: srcSlot.loop,
					duration: srcSlot.duration,
					startTime: srcSlot.startTime,
					overlap: srcSlot.overlap,
					autoPlay: srcSlot.autoPlay,
					asset: srcSlot.asset
				};
			}

			var cloneData = {
				distanceModel: srcComponent.distanceModel,
				enabled: srcComponent.enabled,
				maxDistance: srcComponent.maxDistance,
				pitch: srcComponent.pitch,
				positional: srcComponent.positional,
				refDistance: srcComponent.refDistance,
				rollOffFactor: srcComponent.rollOffFactor,
				slots: slots,
				volume: srcComponent.volume
			};
			return this.addComponent(clone, cloneData);
		};

		_proto.onUpdate = function onUpdate(dt) {
			var store = this.store;

			for (var id in store) {
				if (store.hasOwnProperty(id)) {
					var item = store[id];
					var entity = item.entity;

					if (entity.enabled) {
						var component = entity.sound;

						if (component.enabled && component.positional) {
							var position = entity.getPosition();
							var slots = component.slots;

							for (var key in slots) {
								slots[key].updatePosition(position);
							}
						}
					}
				}
			}
		};

		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			var slots = component.slots;

			for (var key in slots) {
				if (!slots[key].overlap) {
					slots[key].stop();
				}
			}

			component.onRemove();
		};

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off('update', this.onUpdate, this);
		};

		_createClass(SoundComponentSystem, [{
			key: "volume",
			get: function get() {
				return this.manager.volume;
			},
			set: function set(volume) {
				this.manager.volume = volume;
			}
		}, {
			key: "context",
			get: function get() {
				if (!hasAudioContext()) {
					Debug.warn('WARNING: Audio context is not supported on this browser');
					return null;
				}

				return this.manager.context;
			}
		}]);

		return SoundComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(SoundComponent.prototype, _schema$2);

	var SPRITETYPE_SIMPLE = 'simple';
	var SPRITETYPE_ANIMATED = 'animated';

	var SpriteAnimationClip = function (_EventHandler) {
		_inheritsLoose(SpriteAnimationClip, _EventHandler);

		function SpriteAnimationClip(component, data) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._component = component;
			_this._frame = 0;
			_this._sprite = null;
			_this._spriteAsset = null;
			_this.spriteAsset = data.spriteAsset;
			_this.name = data.name;
			_this.fps = data.fps || 0;
			_this.loop = data.loop || false;
			_this._playing = false;
			_this._paused = false;
			_this._time = 0;
			return _this;
		}

		var _proto = SpriteAnimationClip.prototype;

		_proto._onSpriteAssetAdded = function _onSpriteAssetAdded(asset) {
			this._component.system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);

			if (this._spriteAsset === asset.id) {
				this._bindSpriteAsset(asset);
			}
		};

		_proto._bindSpriteAsset = function _bindSpriteAsset(asset) {
			asset.on("load", this._onSpriteAssetLoad, this);
			asset.on("remove", this._onSpriteAssetRemove, this);

			if (asset.resource) {
				this._onSpriteAssetLoad(asset);
			} else {
				this._component.system.app.assets.load(asset);
			}
		};

		_proto._unbindSpriteAsset = function _unbindSpriteAsset(asset) {
			asset.off("load", this._onSpriteAssetLoad, this);
			asset.off("remove", this._onSpriteAssetRemove, this);

			if (asset.resource && asset.resource.atlas) {
				this._component.system.app.assets.off('load:' + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
			}
		};

		_proto._onSpriteAssetLoad = function _onSpriteAssetLoad(asset) {
			if (!asset.resource) {
				this.sprite = null;
			} else {
				if (!asset.resource.atlas) {
					var atlasAssetId = asset.data.textureAtlasAsset;
					var assets = this._component.system.app.assets;
					assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
					assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
				} else {
					this.sprite = asset.resource;
				}
			}
		};

		_proto._onTextureAtlasLoad = function _onTextureAtlasLoad(atlasAsset) {
			var spriteAsset = this._spriteAsset;

			if (spriteAsset instanceof Asset) {
				this._onSpriteAssetLoad(spriteAsset);
			} else {
				this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));
			}
		};

		_proto._onSpriteAssetRemove = function _onSpriteAssetRemove(asset) {
			this.sprite = null;
		};

		_proto._onSpriteMeshesChange = function _onSpriteMeshesChange() {
			if (this._component.currentClip === this) {
				this._component._showFrame(this.frame);
			}
		};

		_proto._onSpritePpuChanged = function _onSpritePpuChanged() {
			if (this._component.currentClip === this) {
				if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {
					this._component._showFrame(this.frame);
				}
			}
		};

		_proto._update = function _update(dt) {
			if (this.fps === 0) return;
			if (!this._playing || this._paused || !this._sprite) return;
			var dir = this.fps < 0 ? -1 : 1;
			var time = this._time + dt * this._component.speed * dir;
			var duration = this.duration;
			var end = time > duration || time < 0;

			this._setTime(time);

			var frame = this.frame;

			if (this._sprite) {
				frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);
			} else {
				frame = 0;
			}

			if (frame !== this._frame) {
				this._setFrame(frame);
			}

			if (end) {
				if (this.loop) {
					this.fire('loop');

					this._component.fire('loop', this);
				} else {
					this._playing = false;
					this._paused = false;
					this.fire('end');

					this._component.fire('end', this);
				}
			}
		};

		_proto._setTime = function _setTime(value) {
			this._time = value;
			var duration = this.duration;

			if (this._time < 0) {
				if (this.loop) {
					this._time = this._time % duration + duration;
				} else {
					this._time = 0;
				}
			} else if (this._time > duration) {
				if (this.loop) {
					this._time %= duration;
				} else {
					this._time = duration;
				}
			}
		};

		_proto._setFrame = function _setFrame(value) {
			if (this._sprite) {
				this._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
			} else {
				this._frame = value;
			}

			if (this._component.currentClip === this) {
				this._component._showFrame(this._frame);
			}
		};

		_proto._destroy = function _destroy() {
			if (this._sprite) {
				this.sprite = null;
			}

			if (this._spriteAsset) {
				this.spriteAsset = null;
			}
		};

		_proto.play = function play() {
			if (this._playing) return;
			this._playing = true;
			this._paused = false;
			this.frame = 0;
			this.fire('play');

			this._component.fire('play', this);
		};

		_proto.pause = function pause() {
			if (!this._playing || this._paused) return;
			this._paused = true;
			this.fire('pause');

			this._component.fire('pause', this);
		};

		_proto.resume = function resume() {
			if (!this._paused) return;
			this._paused = false;
			this.fire('resume');

			this._component.fire('resume', this);
		};

		_proto.stop = function stop() {
			if (!this._playing) return;
			this._playing = false;
			this._paused = false;
			this._time = 0;
			this.frame = 0;
			this.fire('stop');

			this._component.fire('stop', this);
		};

		_createClass(SpriteAnimationClip, [{
			key: "duration",
			get: function get() {
				if (this._sprite) {
					var fps = this.fps || Number.MIN_VALUE;
					return this._sprite.frameKeys.length / Math.abs(fps);
				}

				return 0;
			}
		}, {
			key: "frame",
			get: function get() {
				return this._frame;
			},
			set: function set(value) {
				this._setFrame(value);

				var fps = this.fps || Number.MIN_VALUE;

				this._setTime(this._frame / fps);
			}
		}, {
			key: "isPaused",
			get: function get() {
				return this._paused;
			}
		}, {
			key: "isPlaying",
			get: function get() {
				return this._playing;
			}
		}, {
			key: "sprite",
			get: function get() {
				return this._sprite;
			},
			set: function set(value) {
				if (this._sprite) {
					this._sprite.off('set:meshes', this._onSpriteMeshesChange, this);

					this._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);

					this._sprite.off('set:atlas', this._onSpriteMeshesChange, this);

					if (this._sprite.atlas) {
						this._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);
					}
				}

				this._sprite = value;

				if (this._sprite) {
					this._sprite.on('set:meshes', this._onSpriteMeshesChange, this);

					this._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);

					this._sprite.on('set:atlas', this._onSpriteMeshesChange, this);

					if (this._sprite.atlas) {
						this._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);
					}
				}

				if (this._component.currentClip === this) {
					var mi;

					if (!value || !value.atlas) {
						mi = this._component._meshInstance;

						if (mi) {
							mi.deleteParameter('texture_emissiveMap');
							mi.deleteParameter('texture_opacityMap');
						}

						this._component._hideModel();
					} else {
						if (value.atlas.texture) {
							mi = this._component._meshInstance;

							if (mi) {
								mi.setParameter('texture_emissiveMap', value.atlas.texture);
								mi.setParameter('texture_opacityMap', value.atlas.texture);
							}

							if (this._component.enabled && this._component.entity.enabled) {
								this._component._showModel();
							}
						}

						if (this.time && this.fps) {
							this.time = this.time;
						} else {
							this.frame = this.frame;
						}
					}
				}
			}
		}, {
			key: "spriteAsset",
			get: function get() {
				return this._spriteAsset;
			},
			set: function set(value) {
				var assets = this._component.system.app.assets;
				var id = value;

				if (value instanceof Asset) {
					id = value.id;
				}

				if (this._spriteAsset !== id) {
					if (this._spriteAsset) {
						var prev = assets.get(this._spriteAsset);

						if (prev) {
							this._unbindSpriteAsset(prev);
						}
					}

					this._spriteAsset = id;

					if (this._spriteAsset) {
						var asset = assets.get(this._spriteAsset);

						if (!asset) {
							this.sprite = null;
							assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
						} else {
							this._bindSpriteAsset(asset);
						}
					} else {
						this.sprite = null;
					}
				}
			}
		}, {
			key: "time",
			get: function get() {
				return this._time;
			},
			set: function set(value) {
				this._setTime(value);

				if (this._sprite) {
					this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));
				} else {
					this.frame = 0;
				}
			}
		}]);

		return SpriteAnimationClip;
	}(EventHandler);

	var PARAM_EMISSIVE_MAP = 'texture_emissiveMap';
	var PARAM_OPACITY_MAP = 'texture_opacityMap';
	var PARAM_EMISSIVE = 'material_emissive';
	var PARAM_OPACITY = 'material_opacity';
	var PARAM_INNER_OFFSET = 'innerOffset';
	var PARAM_OUTER_SCALE = 'outerScale';
	var PARAM_ATLAS_RECT = 'atlasRect';

	var SpriteComponent = function (_Component) {
		_inheritsLoose(SpriteComponent, _Component);

		function SpriteComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._type = SPRITETYPE_SIMPLE;
			_this._material = system.defaultMaterial;
			_this._color = new Color(1, 1, 1, 1);
			_this._colorUniform = new Float32Array(3);
			_this._speed = 1;
			_this._flipX = false;
			_this._flipY = false;
			_this._width = 1;
			_this._height = 1;
			_this._drawOrder = 0;
			_this._layers = [LAYERID_WORLD];
			_this._outerScale = new Vec2(1, 1);
			_this._outerScaleUniform = new Float32Array(2);
			_this._innerOffset = new Vec4();
			_this._innerOffsetUniform = new Float32Array(4);
			_this._atlasRect = new Vec4();
			_this._atlasRectUniform = new Float32Array(4);
			_this._batchGroupId = -1;
			_this._batchGroup = null;
			_this._node = new GraphNode();
			_this._model = new Model();
			_this._model.graph = _this._node;
			_this._meshInstance = null;
			entity.addChild(_this._model.graph);
			_this._model._entity = entity;
			_this._updateAabbFunc = _this._updateAabb.bind(_assertThisInitialized(_this));
			_this._addedModel = false;
			_this._autoPlayClip = null;
			_this._clips = {};
			_this._defaultClip = new SpriteAnimationClip(_assertThisInitialized(_this), {
				name: _this.entity.name,
				fps: 0,
				loop: false,
				spriteAsset: null
			});
			_this._currentClip = _this._defaultClip;
			return _this;
		}

		var _proto = SpriteComponent.prototype;

		_proto.onEnable = function onEnable() {
			var app = this.system.app;
			var scene = app.scene;
			scene.on("set:layers", this._onLayersChanged, this);

			if (scene.layers) {
				scene.layers.on("add", this._onLayerAdded, this);
				scene.layers.on("remove", this._onLayerRemoved, this);
			}

			this._showModel();

			if (this._autoPlayClip) this._tryAutoPlay();

			if (this._batchGroupId >= 0) {
				app.batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);
			}
		};

		_proto.onDisable = function onDisable() {
			var app = this.system.app;
			var scene = app.scene;
			scene.off("set:layers", this._onLayersChanged, this);

			if (scene.layers) {
				scene.layers.off("add", this._onLayerAdded, this);
				scene.layers.off("remove", this._onLayerRemoved, this);
			}

			this.stop();

			this._hideModel();

			if (this._batchGroupId >= 0) {
				app.batcher.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);
			}
		};

		_proto.onDestroy = function onDestroy() {
			this._currentClip = null;

			if (this._defaultClip) {
				this._defaultClip._destroy();

				this._defaultClip = null;
			}

			for (var key in this._clips) {
				this._clips[key]._destroy();
			}

			this._clips = null;

			this._hideModel();

			this._model = null;

			if (this._node) {
				if (this._node.parent) this._node.parent.removeChild(this._node);
				this._node = null;
			}

			if (this._meshInstance) {
				this._meshInstance.material = null;
				this._meshInstance.mesh = null;
				this._meshInstance = null;
			}
		};

		_proto._showModel = function _showModel() {
			if (this._addedModel) return;
			if (!this._meshInstance) return;
			var meshInstances = [this._meshInstance];

			for (var i = 0, len = this._layers.length; i < len; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

				if (layer) {
					layer.addMeshInstances(meshInstances);
				}
			}

			this._addedModel = true;
		};

		_proto._hideModel = function _hideModel() {
			if (!this._addedModel || !this._meshInstance) return;
			var meshInstances = [this._meshInstance];

			for (var i = 0, len = this._layers.length; i < len; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

				if (layer) {
					layer.removeMeshInstances(meshInstances);
				}
			}

			this._addedModel = false;
		};

		_proto._showFrame = function _showFrame(frame) {
			if (!this.sprite) return;
			var mesh = this.sprite.meshes[frame];

			if (!mesh) {
				if (this._meshInstance) {
					this._meshInstance.mesh = null;
					this._meshInstance.visible = false;
				}

				return;
			}

			var material;

			if (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {
				material = this.system.default9SlicedMaterialSlicedMode;
			} else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {
				material = this.system.default9SlicedMaterialTiledMode;
			} else {
				material = this.system.defaultMaterial;
			}

			if (!this._meshInstance) {
				this._meshInstance = new MeshInstance(mesh, this._material, this._node);
				this._meshInstance.castShadow = false;
				this._meshInstance.receiveShadow = false;
				this._meshInstance.drawOrder = this._drawOrder;

				this._model.meshInstances.push(this._meshInstance);

				this._colorUniform[0] = this._color.r;
				this._colorUniform[1] = this._color.g;
				this._colorUniform[2] = this._color.b;

				this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);

				this._meshInstance.setParameter(PARAM_OPACITY, this._color.a);

				if (this.enabled && this.entity.enabled) {
					this._showModel();
				}
			}

			if (this._meshInstance.material !== material) {
				this._meshInstance.material = material;
			}

			if (this._meshInstance.mesh !== mesh) {
				this._meshInstance.mesh = mesh;
				this._meshInstance.visible = true;
				this._meshInstance._aabbVer = -1;
			}

			if (this.sprite.atlas && this.sprite.atlas.texture) {
				this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);

				this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);
			} else {
				this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);

				this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);
			}

			if (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
				this._meshInstance._updateAabbFunc = this._updateAabbFunc;
				var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];

				if (frameData) {
					var borderWidthScale = 2 / frameData.rect.z;
					var borderHeightScale = 2 / frameData.rect.w;

					this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);

					var tex = this.sprite.atlas.texture;

					this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
				} else {
					this._innerOffset.set(0, 0, 0, 0);
				}

				this._innerOffsetUniform[0] = this._innerOffset.x;
				this._innerOffsetUniform[1] = this._innerOffset.y;
				this._innerOffsetUniform[2] = this._innerOffset.z;
				this._innerOffsetUniform[3] = this._innerOffset.w;

				this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);

				this._atlasRectUniform[0] = this._atlasRect.x;
				this._atlasRectUniform[1] = this._atlasRect.y;
				this._atlasRectUniform[2] = this._atlasRect.z;
				this._atlasRectUniform[3] = this._atlasRect.w;

				this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);
			} else {
				this._meshInstance._updateAabbFunc = null;
			}

			this._updateTransform();
		};

		_proto._updateTransform = function _updateTransform() {
			var scaleX = this.flipX ? -1 : 1;
			var scaleY = this.flipY ? -1 : 1;
			var posX = 0;
			var posY = 0;

			if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
				var w = 1;
				var h = 1;

				if (this.sprite.atlas) {
					var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];

					if (frameData) {
						w = frameData.rect.z;
						h = frameData.rect.w;
						posX = (0.5 - frameData.pivot.x) * this._width;
						posY = (0.5 - frameData.pivot.y) * this._height;
					}
				}

				var scaleMulX = w / this.sprite.pixelsPerUnit;
				var scaleMulY = h / this.sprite.pixelsPerUnit;

				this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));

				scaleX *= scaleMulX;
				scaleY *= scaleMulY;
				this._outerScale.x /= scaleMulX;
				this._outerScale.y /= scaleMulY;
				scaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);
				scaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);

				if (this._meshInstance) {
					this._outerScaleUniform[0] = this._outerScale.x;
					this._outerScaleUniform[1] = this._outerScale.y;

					this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform);
				}
			}

			this._node.setLocalScale(scaleX, scaleY, 1);

			this._node.setLocalPosition(posX, posY, 0);
		};

		_proto._updateAabb = function _updateAabb(aabb) {
			aabb.center.set(0, 0, 0);
			aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
			aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());
			return aabb;
		};

		_proto._tryAutoPlay = function _tryAutoPlay() {
			if (!this._autoPlayClip) return;
			if (this.type !== SPRITETYPE_ANIMATED) return;
			var clip = this._clips[this._autoPlayClip];

			if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {
				if (this.enabled && this.entity.enabled) {
					this.play(clip.name);
				}
			}
		};

		_proto._onLayersChanged = function _onLayersChanged(oldComp, newComp) {
			oldComp.off("add", this.onLayerAdded, this);
			oldComp.off("remove", this.onLayerRemoved, this);
			newComp.on("add", this.onLayerAdded, this);
			newComp.on("remove", this.onLayerRemoved, this);

			if (this.enabled && this.entity.enabled) {
				this._showModel();
			}
		};

		_proto._onLayerAdded = function _onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;

			if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {
				layer.addMeshInstances([this._meshInstance]);
			}
		};

		_proto._onLayerRemoved = function _onLayerRemoved(layer) {
			if (!this._meshInstance) return;
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances([this._meshInstance]);
		};

		_proto.removeModelFromLayers = function removeModelFromLayers() {
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances([this._meshInstance]);
			}
		};

		_proto.addClip = function addClip(data) {
			var clip = new SpriteAnimationClip(this, {
				name: data.name,
				fps: data.fps,
				loop: data.loop,
				spriteAsset: data.spriteAsset
			});
			this._clips[data.name] = clip;
			if (clip.name && clip.name === this._autoPlayClip) this._tryAutoPlay();
			return clip;
		};

		_proto.removeClip = function removeClip(name) {
			delete this._clips[name];
		};

		_proto.clip = function clip(name) {
			return this._clips[name];
		};

		_proto.play = function play(name) {
			var clip = this._clips[name];
			var current = this._currentClip;

			if (current && current !== clip) {
				current._playing = false;
			}

			this._currentClip = clip;

			if (this._currentClip) {
				this._currentClip = clip;

				this._currentClip.play();
			} else {
				Debug.warn("Trying to play sprite animation " + name + " which does not exist.");
			}

			return clip;
		};

		_proto.pause = function pause() {
			if (this._currentClip === this._defaultClip) return;

			if (this._currentClip.isPlaying) {
				this._currentClip.pause();
			}
		};

		_proto.resume = function resume() {
			if (this._currentClip === this._defaultClip) return;

			if (this._currentClip.isPaused) {
				this._currentClip.resume();
			}
		};

		_proto.stop = function stop() {
			if (this._currentClip === this._defaultClip) return;

			this._currentClip.stop();
		};

		_createClass(SpriteComponent, [{
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (this._type === value) return;
				this._type = value;

				if (this._type === SPRITETYPE_SIMPLE) {
					this.stop();
					this._currentClip = this._defaultClip;

					if (this.enabled && this.entity.enabled) {
						this._currentClip.frame = this.frame;

						if (this._currentClip.sprite) {
							this._showModel();
						} else {
							this._hideModel();
						}
					}
				} else if (this._type === SPRITETYPE_ANIMATED) {
					this.stop();

					if (this._autoPlayClip) {
						this._tryAutoPlay();
					}

					if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {
						this._showModel();
					} else {
						this._hideModel();
					}
				}
			}
		}, {
			key: "frame",
			get: function get() {
				return this._currentClip.frame;
			},
			set: function set(value) {
				this._currentClip.frame = value;
			}
		}, {
			key: "spriteAsset",
			get: function get() {
				return this._defaultClip._spriteAsset;
			},
			set: function set(value) {
				this._defaultClip.spriteAsset = value;
			}
		}, {
			key: "sprite",
			get: function get() {
				return this._currentClip.sprite;
			},
			set: function set(value) {
				this._currentClip.sprite = value;
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(value) {
				this._material = value;

				if (this._meshInstance) {
					this._meshInstance.material = value;
				}
			}
		}, {
			key: "color",
			get: function get() {
				return this._color;
			},
			set: function set(value) {
				this._color.r = value.r;
				this._color.g = value.g;
				this._color.b = value.b;

				if (this._meshInstance) {
					this._colorUniform[0] = this._color.r;
					this._colorUniform[1] = this._color.g;
					this._colorUniform[2] = this._color.b;

					this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
				}
			}
		}, {
			key: "opacity",
			get: function get() {
				return this._color.a;
			},
			set: function set(value) {
				this._color.a = value;

				if (this._meshInstance) {
					this._meshInstance.setParameter(PARAM_OPACITY, value);
				}
			}
		}, {
			key: "clips",
			get: function get() {
				return this._clips;
			},
			set: function set(value) {
				if (!value) {
					for (var name in this._clips) {
						this.removeClip(name);
					}

					return;
				}

				for (var _name in this._clips) {
					var found = false;

					for (var key in value) {
						if (value[key].name === _name) {
							found = true;
							this._clips[_name].fps = value[key].fps;
							this._clips[_name].loop = value[key].loop;

							if (value[key].hasOwnProperty('sprite')) {
								this._clips[_name].sprite = value[key].sprite;
							} else if (value[key].hasOwnProperty('spriteAsset')) {
								this._clips[_name].spriteAsset = value[key].spriteAsset;
							}

							break;
						}
					}

					if (!found) {
						this.removeClip(_name);
					}
				}

				for (var _key in value) {
					if (this._clips[value[_key].name]) continue;
					this.addClip(value[_key]);
				}

				if (this._autoPlayClip) {
					this._tryAutoPlay();
				}

				if (!this._currentClip || !this._currentClip.sprite) {
					this._hideModel();
				}
			}
		}, {
			key: "currentClip",
			get: function get() {
				return this._currentClip;
			}
		}, {
			key: "speed",
			get: function get() {
				return this._speed;
			},
			set: function set(value) {
				this._speed = value;
			}
		}, {
			key: "flipX",
			get: function get() {
				return this._flipX;
			},
			set: function set(value) {
				if (this._flipX === value) return;
				this._flipX = value;

				this._updateTransform();
			}
		}, {
			key: "flipY",
			get: function get() {
				return this._flipY;
			},
			set: function set(value) {
				if (this._flipY === value) return;
				this._flipY = value;

				this._updateTransform();
			}
		}, {
			key: "width",
			get: function get() {
				return this._width;
			},
			set: function set(value) {
				if (value === this._width) return;
				this._width = value;
				this._outerScale.x = this._width;

				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
					this._updateTransform();
				}
			}
		}, {
			key: "height",
			get: function get() {
				return this._height;
			},
			set: function set(value) {
				if (value === this._height) return;
				this._height = value;
				this._outerScale.y = this.height;

				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
					this._updateTransform();
				}
			}
		}, {
			key: "batchGroupId",
			get: function get() {
				return this._batchGroupId;
			},
			set: function set(value) {
				if (this._batchGroupId === value) return;
				var prev = this._batchGroupId;
				this._batchGroupId = value;

				if (this.entity.enabled && prev >= 0) {
					this.system.app.batcher.remove(BatchGroup.SPRITE, prev, this.entity);
				}

				if (this.entity.enabled && value >= 0) {
					this.system.app.batcher.insert(BatchGroup.SPRITE, value, this.entity);
				} else {
					if (prev >= 0) {
						if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {
							this._showModel();
						}
					}
				}
			}
		}, {
			key: "autoPlayClip",
			get: function get() {
				return this._autoPlayClip;
			},
			set: function set(value) {
				this._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;

				this._tryAutoPlay();
			}
		}, {
			key: "drawOrder",
			get: function get() {
				return this._drawOrder;
			},
			set: function set(value) {
				this._drawOrder = value;

				if (this._meshInstance) {
					this._meshInstance.drawOrder = value;
				}
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(value) {
				if (this._addedModel) {
					this._hideModel();
				}

				this._layers = value;

				if (!this._meshInstance) {
					return;
				}

				if (this.enabled && this.entity.enabled) {
					this._showModel();
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				if (this._meshInstance) {
					return this._meshInstance.aabb;
				}

				return null;
			}
		}]);

		return SpriteComponent;
	}(Component);

	var SpriteComponentData = function SpriteComponentData() {
		this.enabled = true;
	};

	var _schema$1 = ['enabled'];

	var SpriteComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(SpriteComponentSystem, _ComponentSystem);

		function SpriteComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'sprite';
			_this.ComponentType = SpriteComponent;
			_this.DataType = SpriteComponentData;
			_this.schema = _schema$1;
			_this._defaultTexture = null;
			_this._defaultMaterial = null;
			_this._default9SlicedMaterialSlicedMode = null;
			_this._default9SlicedMaterialTiledMode = null;

			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = SpriteComponentSystem.prototype;

		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);

			this.app.systems.off('update', this.onUpdate, this);

			if (this._defaultTexture) {
				this._defaultTexture.destroy();

				this._defaultTexture = null;
			}
		};

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.enabled !== undefined) {
				component.enabled = data.enabled;
			}

			component.type = data.type;

			if (data.layers && Array.isArray(data.layers)) {
				component.layers = data.layers.slice(0);
			}

			if (data.drawOrder !== undefined) {
				component.drawOrder = data.drawOrder;
			}

			if (data.color !== undefined) {
				if (data.color instanceof Color) {
					component.color.set(data.color.r, data.color.g, data.color.b, data.opacity !== undefined ? data.opacity : 1);
				} else {
					component.color.set(data.color[0], data.color[1], data.color[2], data.opacity !== undefined ? data.opacity : 1);
				}

				component.color = component.color;
			}

			if (data.opacity !== undefined) {
				component.opacity = data.opacity;
			}

			if (data.flipX !== undefined) {
				component.flipX = data.flipX;
			}

			if (data.flipY !== undefined) {
				component.flipY = data.flipY;
			}

			if (data.width !== undefined) {
				component.width = data.width;
			}

			if (data.height !== undefined) {
				component.height = data.height;
			}

			if (data.spriteAsset !== undefined) {
				component.spriteAsset = data.spriteAsset;
			}

			if (data.sprite) {
				component.sprite = data.sprite;
			}

			if (data.frame !== undefined) {
				component.frame = data.frame;
			}

			if (data.clips) {
				for (var name in data.clips) {
					component.addClip(data.clips[name]);
				}
			}

			if (data.speed !== undefined) {
				component.speed = data.speed;
			}

			if (data.autoPlayClip) {
				component.autoPlayClip = data.autoPlayClip;
			}

			component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;

			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var source = entity.sprite;
			return this.addComponent(clone, {
				enabled: source.enabled,
				type: source.type,
				spriteAsset: source.spriteAsset,
				sprite: source.sprite,
				frame: source.frame,
				color: source.color.clone(),
				opacity: source.opacity,
				flipX: source.flipX,
				flipY: source.flipY,
				speed: source.speed,
				clips: source.clips,
				autoPlayClip: source.autoPlayClip,
				batchGroupId: source.batchGroupId,
				drawOrder: source.drawOrder,
				layers: source.layers.slice(0)
			});
		};

		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;

			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];

					if (component.data.enabled && component.entity.enabled) {
						var sprite = component.entity.sprite;

						if (sprite._currentClip) {
							sprite._currentClip._update(dt);
						}
					}
				}
			}
		};

		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			component.onDestroy();
		};

		_createClass(SpriteComponentSystem, [{
			key: "defaultMaterial",
			get: function get() {
				if (!this._defaultMaterial) {
					var texture = new Texture(this.app.graphicsDevice, {
						width: 1,
						height: 1,
						format: PIXELFORMAT_R8_G8_B8_A8
					});
					var pixels = new Uint8Array(texture.lock());
					pixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;
					texture.name = 'sprite';
					texture.unlock();
					var material = new StandardMaterial();
					material.diffuse.set(0, 0, 0);
					material.emissive.set(0.5, 0.5, 0.5);
					material.emissiveMap = texture;
					material.emissiveMapTint = true;
					material.opacityMap = texture;
					material.opacityMapChannel = "a";
					material.opacityTint = true;
					material.opacity = 0;
					material.useLighting = false;
					material.useGammaTonemap = false;
					material.useFog = false;
					material.useSkybox = false;
					material.blendType = BLEND_PREMULTIPLIED;
					material.depthWrite = false;
					material.pixelSnap = false;
					material.cull = CULLFACE_NONE;
					material.update();
					this._defaultTexture = texture;
					this._defaultMaterial = material;
				}

				return this._defaultMaterial;
			},
			set: function set(material) {
				this._defaultMaterial = material;
			}
		}, {
			key: "default9SlicedMaterialSlicedMode",
			get: function get() {
				if (!this._default9SlicedMaterialSlicedMode) {
					var material = this.defaultMaterial.clone();
					material.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
					material.update();
					this._default9SlicedMaterialSlicedMode = material;
				}

				return this._default9SlicedMaterialSlicedMode;
			},
			set: function set(material) {
				this._default9SlicedMaterialSlicedMode = material;
			}
		}, {
			key: "default9SlicedMaterialTiledMode",
			get: function get() {
				if (!this._default9SlicedMaterialTiledMode) {
					var material = this.defaultMaterial.clone();
					material.nineSlicedMode = SPRITE_RENDERMODE_TILED;
					material.update();
					this._default9SlicedMaterialTiledMode = material;
				}

				return this._default9SlicedMaterialTiledMode;
			},
			set: function set(material) {
				this._default9SlicedMaterialTiledMode = material;
			}
		}]);

		return SpriteComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(SpriteComponent.prototype, _schema$1);

	var ZoneComponent = function (_Component) {
		_inheritsLoose(ZoneComponent, _Component);

		function ZoneComponent(system, entity) {
			var _this;

			_this = _Component.call(this, system, entity) || this;
			_this._oldState = true;
			_this._size = new Vec3();

			_this.on('set_enabled', _this._onSetEnabled, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = ZoneComponent.prototype;

		_proto.onEnable = function onEnable() {
			this._checkState();
		};

		_proto.onDisable = function onDisable() {
			this._checkState();
		};

		_proto._onSetEnabled = function _onSetEnabled(prop, old, value) {
			this._checkState();
		};

		_proto._checkState = function _checkState() {
			var state = this.enabled && this.entity.enabled;
			if (state === this._oldState) return;
			this._oldState = state;
			this.fire('enable');
			this.fire('state', this.enabled);
		};

		_proto._onBeforeRemove = function _onBeforeRemove() {
			this.fire('remove');
		};

		_createClass(ZoneComponent, [{
			key: "size",
			get: function get() {
				return this._size;
			},
			set: function set(data) {
				if (data instanceof Vec3) {
					this._size.copy(data);
				} else if (data instanceof Array && data.length >= 3) {
					this.size.set(data[0], data[1], data[2]);
				}
			}
		}]);

		return ZoneComponent;
	}(Component);

	var ZoneComponentData = function ZoneComponentData() {
		this.enabled = true;
	};

	var _schema = ['enabled'];

	var ZoneComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ZoneComponentSystem, _ComponentSystem);

		function ZoneComponentSystem(app) {
			var _this;

			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'zone';
			_this.ComponentType = ZoneComponent;
			_this.DataType = ZoneComponentData;
			_this.schema = _schema;

			_this.on('beforeremove', _this._onBeforeRemove, _assertThisInitialized(_this));

			return _this;
		}

		var _proto = ZoneComponentSystem.prototype;

		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;

			if (data.size) {
				if (data.size instanceof Vec3) {
					component.size.copy(data.size);
				} else if (data.size instanceof Array && data.size.length >= 3) {
					component.size.set(data.size[0], data.size[1], data.size[2]);
				}
			}
		};

		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var data = {
				size: entity.zone.size
			};
			return this.addComponent(clone, data);
		};

		_proto._onBeforeRemove = function _onBeforeRemove(entity, component) {
			component._onBeforeRemove();
		};

		return ZoneComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ZoneComponent.prototype, _schema);

	var ApplicationStats = function () {
		function ApplicationStats(device) {
			this.frame = {
				fps: 0,
				ms: 0,
				dt: 0,
				updateStart: 0,
				updateTime: 0,
				renderStart: 0,
				renderTime: 0,
				physicsStart: 0,
				physicsTime: 0,
				cullTime: 0,
				sortTime: 0,
				skinTime: 0,
				morphTime: 0,
				instancingTime: 0,
				triangles: 0,
				otherPrimitives: 0,
				shaders: 0,
				materials: 0,
				cameras: 0,
				shadowMapUpdates: 0,
				shadowMapTime: 0,
				depthMapTime: 0,
				forwardTime: 0,
				lightClustersTime: 0,
				lightClusters: 0,
				_timeToCountFrames: 0,
				_fpsAccum: 0
			};
			this.drawCalls = {
				forward: 0,
				depth: 0,
				shadow: 0,
				immediate: 0,
				misc: 0,
				total: 0,
				skinned: 0,
				instanced: 0,
				removedByInstancing: 0
			};
			this.misc = {
				renderTargetCreationTime: 0
			};
			this.particles = {
				updatesPerFrame: 0,
				_updatesPerFrame: 0,
				frameTime: 0,
				_frameTime: 0
			};
			this.shaders = device._shaderStats;
			this.vram = device._vram;
			Object.defineProperty(this.vram, 'totalUsed', {
				get: function get() {
					return this.tex + this.vb + this.ib;
				}
			});
			Object.defineProperty(this.vram, 'geom', {
				get: function get() {
					return this.vb + this.ib;
				}
			});
		}

		_createClass(ApplicationStats, [{
			key: "scene",
			get: function get() {
				return getApplication().scene._stats;
			}
		}, {
			key: "lightmapper",
			get: function get() {
				return getApplication().lightmapper.stats;
			}
		}, {
			key: "batcher",
			get: function get() {
				return getApplication().batcher._stats;
			}
		}]);

		return ApplicationStats;
	}();

	var SceneRegistryItem = function () {
		function SceneRegistryItem(name, url) {
			this.name = name;
			this.url = url;
			this.data = null;
			this._loading = false;
			this._onLoadedCallbacks = [];
		}

		_createClass(SceneRegistryItem, [{
			key: "loaded",
			get: function get() {
				return !!this.data;
			}
		}, {
			key: "loading",
			get: function get() {
				return this._loading;
			}
		}]);

		return SceneRegistryItem;
	}();

	var SceneRegistry = function () {
		function SceneRegistry(app) {
			this._app = app;
			this._list = [];
			this._index = {};
			this._urlIndex = {};
		}

		var _proto = SceneRegistry.prototype;

		_proto.destroy = function destroy() {
			this._app = null;
		};

		_proto.list = function list() {
			return this._list;
		};

		_proto.add = function add(name, url) {
			if (this._index.hasOwnProperty(name)) {
				Debug.warn('pc.SceneRegistry: trying to add more than one scene called: ' + name);
				return false;
			}

			var item = new SceneRegistryItem(name, url);

			var i = this._list.push(item);

			this._index[item.name] = i - 1;
			this._urlIndex[item.url] = i - 1;
			return true;
		};

		_proto.find = function find(name) {
			if (this._index.hasOwnProperty(name)) {
				return this._list[this._index[name]];
			}

			return null;
		};

		_proto.findByUrl = function findByUrl(url) {
			if (this._urlIndex.hasOwnProperty(url)) {
				return this._list[this._urlIndex[url]];
			}

			return null;
		};

		_proto.remove = function remove(name) {
			if (this._index.hasOwnProperty(name)) {
				var idx = this._index[name];
				var item = this._list[idx];
				delete this._urlIndex[item.url];
				delete this._index[name];

				this._list.splice(idx, 1);

				for (var i = 0; i < this._list.length; i++) {
					item = this._list[i];
					this._index[item.name] = i;
					this._urlIndex[item.url] = i;
				}
			}
		};

		_proto._loadSceneData = function _loadSceneData(sceneItem, storeInCache, callback) {
			var url = sceneItem;

			if (sceneItem instanceof SceneRegistryItem) {
				url = sceneItem.url;
			} else {
				sceneItem = this.findByUrl(url);

				if (!sceneItem) {
					sceneItem = new SceneRegistryItem('Untitled', url);
				}
			}

			if (!sceneItem.url) {
				callback("URL or SceneRegistryItem is null when loading a scene");
				return;
			}

			if (sceneItem.loaded) {
				callback(null, sceneItem);
				return;
			}

			var handler = this._app.loader.getHandler("hierarchy");

			if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
				url = path.join(this._app.assets.prefix, url);
			}

			sceneItem._onLoadedCallbacks.push(callback);

			if (!sceneItem._loading) {
				handler.load(url, function (err, data) {
					sceneItem.data = data;
					sceneItem._loading = false;

					for (var i = 0; i < sceneItem._onLoadedCallbacks.length; i++) {
						sceneItem._onLoadedCallbacks[i](err, sceneItem);
					}

					if (!storeInCache) {
						sceneItem.data = null;
					}

					sceneItem._onLoadedCallbacks.length = 0;
				});
			}

			sceneItem._loading = true;
		};

		_proto.loadSceneData = function loadSceneData(sceneItem, callback) {
			this._loadSceneData(sceneItem, true, callback);
		};

		_proto.unloadSceneData = function unloadSceneData(sceneItem) {
			if (typeof sceneItem === 'string') {
				sceneItem = this.findByUrl(sceneItem);
			}

			if (sceneItem) {
				sceneItem.data = null;
			}
		};

		_proto.loadSceneHierarchy = function loadSceneHierarchy(sceneItem, callback) {
			var self = this;

			var handler = this._app.loader.getHandler("hierarchy");

			this._loadSceneData(sceneItem, false, function (err, sceneItem) {
				if (err) {
					if (callback) callback(err);
					return;
				}

				var url = sceneItem.url;
				var data = sceneItem.data;

				var _loaded = function _loaded() {
					self._app.systems.script.preloading = true;
					var entity = handler.open(url, data);
					self._app.systems.script.preloading = false;

					self._app.loader.clearCache(url, "hierarchy");

					self._app.root.addChild(entity);

					self._app.systems.fire('initialize', entity);

					self._app.systems.fire('postInitialize', entity);

					self._app.systems.fire('postPostInitialize', entity);

					if (callback) callback(err, entity);
				};

				self._app._preloadScripts(data, _loaded);
			});
		};

		_proto.loadSceneSettings = function loadSceneSettings(sceneItem, callback) {
			var self = this;

			this._loadSceneData(sceneItem, false, function (err, sceneItem) {
				if (!err) {
					self._app.applySceneSettings(sceneItem.data.settings);

					if (callback) {
						callback(null);
					}
				} else {
					if (callback) {
						callback(err);
					}
				}
			});
		};

		_proto.loadScene = function loadScene(url, callback) {
			var self = this;

			var handler = this._app.loader.getHandler("scene");

			if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
				url = path.join(this._app.assets.prefix, url);
			}

			handler.load(url, function (err, data) {
				if (!err) {
					var _loaded = function _loaded() {
						self._app.systems.script.preloading = true;
						var scene = handler.open(url, data);
						var sceneItem = self.findByUrl(url);

						if (sceneItem && !sceneItem.loaded) {
							sceneItem.data = data;
						}

						self._app.systems.script.preloading = false;

						self._app.loader.clearCache(url, "scene");

						self._app.loader.patch({
							resource: scene,
							type: "scene"
						}, self._app.assets);

						self._app.root.addChild(scene.root);

						if (self._app.systems.rigidbody && typeof Ammo !== 'undefined') {
							self._app.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);
						}

						if (callback) {
							callback(null, scene);
						}
					};

					self._app._preloadScripts(data, _loaded);
				} else {
					if (callback) {
						callback(err);
					}
				}
			});
		};

		return SceneRegistry;
	}();

	var SceneDepth = function () {
		function SceneDepth(application) {
			this.application = application;
			this.device = application.graphicsDevice;
			this.clearOptions = null;
			this.layer = null;
			this.init();
		}

		var _proto = SceneDepth.prototype;

		_proto.allocateTexture = function allocateTexture(device, name, format) {
			var texture = new Texture(device, {
				format: format,
				width: device.width,
				height: device.height,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			texture.name = name;
			device.scope.resolve("uDepthMap").setValue(texture);
			return texture;
		};

		_proto.allocateRenderTarget = function allocateRenderTarget(renderTarget, device, name, format, isDepth) {
			var buffer = this.allocateTexture(device, name, format);

			if (renderTarget) {
				renderTarget.destroyFrameBuffers();

				if (isDepth) {
					renderTarget._depthBuffer = buffer;
				} else {
					renderTarget._colorBuffer = buffer;
				}
			} else {
				renderTarget = new RenderTarget({
					colorBuffer: isDepth ? null : buffer,
					depthBuffer: isDepth ? buffer : null,
					depth: !isDepth,
					stencil: device.supportsStencil,
					autoResolve: false
				});
			}

			return renderTarget;
		};

		_proto.releaseRenderTarget = function releaseRenderTarget(rt) {
			if (rt) {
				rt.destroyTextureBuffers();
				rt.destroy();
			}
		};

		_proto.initWebGl2 = function initWebGl2() {
			var app = this.application;
			var self = this;
			this.clearOptions = {
				flags: 0
			};
			this.layer = new Layer({
				enabled: false,
				name: "Depth",
				id: LAYERID_DEPTH,
				onEnable: function onEnable() {
					self.releaseRenderTarget(this.renderTarget);
					this.renderTarget = self.allocateRenderTarget(this.renderTarget, app.graphicsDevice, "rt-depth2", PIXELFORMAT_DEPTHSTENCIL, true);
				},
				onDisable: function onDisable() {
					self.releaseRenderTarget(this.renderTarget);
					this.renderTarget = null;
				},
				onPreRenderOpaque: function onPreRenderOpaque(cameraPass) {
					var gl = app.graphicsDevice.gl;
					this.srcFbo = gl.getParameter(gl.FRAMEBUFFER_BINDING);

					if (this.renderTarget.width !== app.graphicsDevice.width || this.renderTarget.height !== app.graphicsDevice.height) {
						this.onEnable();
					}

					this.oldClear = this.cameras[cameraPass].camera._clearOptions;
					this.cameras[cameraPass].camera._clearOptions = self.clearOptions;
				},
				onPostRenderOpaque: function onPostRenderOpaque(cameraPass) {
					if (this.renderTarget) {
						this.cameras[cameraPass].camera._clearOptions = this.oldClear;
						app.graphicsDevice.setRenderTarget(this.renderTarget);
						app.graphicsDevice.updateBegin();
						var gl = app.graphicsDevice.gl;
						gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.srcFbo);
						gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.renderTarget.impl._glFrameBuffer);
						gl.blitFramebuffer(0, 0, this.renderTarget.width, this.renderTarget.height, 0, 0, this.renderTarget.width, this.renderTarget.height, gl.DEPTH_BUFFER_BIT, gl.NEAREST);
					}
				}
			});
		};

		_proto.initWebGl1 = function initWebGl1() {
			var app = this.application;
			var self = this;
			this.clearOptions = {
				color: [254.0 / 255, 254.0 / 255, 254.0 / 255, 254.0 / 255],
				depth: 1.0,
				flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
			};
			this.layer = new Layer({
				enabled: false,
				name: "Depth",
				id: LAYERID_DEPTH,
				shaderPass: SHADER_DEPTH,
				onEnable: function onEnable() {
					self.releaseRenderTarget(this.renderTarget);
					this.renderTarget = self.allocateRenderTarget(this.renderTarget, app.graphicsDevice, "rt-depth1", PIXELFORMAT_R8_G8_B8_A8, false);
				},
				onDisable: function onDisable() {
					self.releaseRenderTarget(this.renderTarget);
					this.renderTarget = null;
				},
				onPostCull: function onPostCull(cameraPass) {
					var visibleObjects = this.instances.visibleOpaque[cameraPass];
					var visibleList = visibleObjects.list;
					var layerComposition = app.scene.layers;
					var subLayerEnabled = layerComposition.subLayerEnabled;
					var isTransparent = layerComposition.subLayerList;
					var rt = app.scene.layers.getLayerById(LAYERID_WORLD).renderTarget;
					var cam = this.cameras[cameraPass];
					var visibleLength = 0;
					var layers = layerComposition.layerList;

					for (var i = 0; i < layers.length; i++) {
						var layer = layers[i];
						if (layer === this) break;
						if (layer.renderTarget !== rt || !layer.enabled || !subLayerEnabled[i]) continue;
						var layerCamId = layer.cameras.indexOf(cam);
						if (layerCamId < 0) continue;
						var transparent = isTransparent[i];
						var layerVisibleList = transparent ? layer.instances.visibleTransparent[layerCamId] : layer.instances.visibleOpaque[layerCamId];
						var layerVisibleListLength = layerVisibleList.length;
						layerVisibleList = layerVisibleList.list;

						for (var j = 0; j < layerVisibleListLength; j++) {
							var drawCall = layerVisibleList[j];

							if (drawCall.material && drawCall.material.depthWrite && !drawCall._noDepthDrawGl1) {
								visibleList[visibleLength] = drawCall;
								visibleLength++;
							}
						}
					}

					visibleObjects.length = visibleLength;
				},
				onPreRenderOpaque: function onPreRenderOpaque(cameraPass) {
					if (this.renderTarget.width !== app.graphicsDevice.width || this.renderTarget.height !== app.graphicsDevice.height) {
						this.onEnable();
					}

					this.oldClear = this.cameras[cameraPass].camera._clearOptions;
					this.cameras[cameraPass].camera._clearOptions = self.clearOptions;
				},
				onDrawCall: function onDrawCall() {
					app.graphicsDevice.setColorWrite(true, true, true, true);
				},
				onPostRenderOpaque: function onPostRenderOpaque(cameraPass) {
					if (!this.renderTarget) return;
					this.cameras[cameraPass].camera._clearOptions = this.oldClear;
				}
			});
		};

		_proto.init = function init() {
			if (this.device.webgl2) {
				this.initWebGl2();
			} else {
				this.initWebGl1();
			}
		};

		_proto.patch = function patch(layer) {
			layer.onEnable = this.layer.onEnable;
			layer.onDisable = this.layer.onDisable;
			layer.onPreRenderOpaque = this.layer.onPreRenderOpaque;
			layer.onPostRenderOpaque = this.layer.onPostRenderOpaque;
			layer.shaderPass = this.layer.shaderPass;
			layer.onPostCull = this.layer.onPostCull;
			layer.onDrawCall = this.layer.onDrawCall;
		};

		return SceneDepth;
	}();

	var Progress = function () {
		function Progress(length) {
			this.length = length;
			this.count = 0;
		}

		var _proto = Progress.prototype;

		_proto.inc = function inc() {
			this.count++;
		};

		_proto.done = function done() {
			return this.count === this.length;
		};

		return Progress;
	}();

	exports.app = null;

	var Application = function (_EventHandler) {
		_inheritsLoose(Application, _EventHandler);

		function Application(canvas, options) {
			var _this;

			if (options === void 0) {
				options = {};
			}

			_this = _EventHandler.call(this) || this;
			console.log("Powered by PlayCanvas " + version + " " + revision);
			Application._applications[canvas.id] = _assertThisInitialized(_this);
			setApplication(_assertThisInitialized(_this));
			exports.app = _assertThisInitialized(_this);
			_this._destroyRequested = false;
			_this._inFrameUpdate = false;
			_this._time = 0;
			_this.timeScale = 1;
			_this.maxDeltaTime = 0.1;
			_this.frame = 0;
			_this.autoRender = true;
			_this.renderNextFrame = false;
			_this.useLegacyScriptAttributeCloning = script.legacy;
			_this._librariesLoaded = false;
			_this._fillMode = FILLMODE_KEEP_ASPECT;
			_this._resolutionMode = RESOLUTION_FIXED;
			_this._allowResize = true;
			_this.context = _assertThisInitialized(_this);
			if (!options.graphicsDeviceOptions) options.graphicsDeviceOptions = {};

			if (platform.browser && !!navigator.xr) {
				options.graphicsDeviceOptions.xrCompatible = true;
			}

			options.graphicsDeviceOptions.alpha = options.graphicsDeviceOptions.alpha || false;
			_this.graphicsDevice = new WebglGraphicsDevice(canvas, options.graphicsDeviceOptions);

			_this._initDefaultMaterial();

			_this.stats = new ApplicationStats(_this.graphicsDevice);
			_this._soundManager = new SoundManager(options);
			_this.loader = new ResourceLoader(_assertThisInitialized(_this));
			LightsBuffer.init(_this.graphicsDevice);
			_this._entityIndex = {};
			_this.scene = new Scene(_this.graphicsDevice);

			_this._registerSceneImmediate(_this.scene);

			_this.root = new Entity();
			_this.root._enabledInHierarchy = true;
			_this.assets = new AssetRegistry(_this.loader);
			if (options.assetPrefix) _this.assets.prefix = options.assetPrefix;
			_this.bundles = new BundleRegistry(_this.assets);
			_this.enableBundles = typeof TextDecoder !== 'undefined';
			_this.scriptsOrder = options.scriptsOrder || [];
			_this.scripts = new ScriptRegistry(_assertThisInitialized(_this));
			_this.i18n = new I18n(_assertThisInitialized(_this));
			_this.scenes = new SceneRegistry(_assertThisInitialized(_this));

			var self = _assertThisInitialized(_this);

			_this.defaultLayerWorld = new Layer({
				name: "World",
				id: LAYERID_WORLD
			});
			_this.sceneDepth = new SceneDepth(_assertThisInitialized(_this));
			_this.defaultLayerDepth = _this.sceneDepth.layer;
			_this.defaultLayerSkybox = new Layer({
				enabled: true,
				name: "Skybox",
				id: LAYERID_SKYBOX,
				opaqueSortMode: SORTMODE_NONE
			});
			_this.defaultLayerUi = new Layer({
				enabled: true,
				name: "UI",
				id: LAYERID_UI,
				transparentSortMode: SORTMODE_MANUAL,
				passThrough: false
			});
			_this.defaultLayerImmediate = new Layer({
				enabled: true,
				name: "Immediate",
				id: LAYERID_IMMEDIATE,
				opaqueSortMode: SORTMODE_NONE,
				passThrough: true
			});
			var defaultLayerComposition = new LayerComposition("default");
			defaultLayerComposition.pushOpaque(_this.defaultLayerWorld);
			defaultLayerComposition.pushOpaque(_this.defaultLayerDepth);
			defaultLayerComposition.pushOpaque(_this.defaultLayerSkybox);
			defaultLayerComposition.pushTransparent(_this.defaultLayerWorld);
			defaultLayerComposition.pushOpaque(_this.defaultLayerImmediate);
			defaultLayerComposition.pushTransparent(_this.defaultLayerImmediate);
			defaultLayerComposition.pushTransparent(_this.defaultLayerUi);
			_this.scene.layers = defaultLayerComposition;

			_this.scene.on('set:layers', function (oldComp, newComp) {
				var list = newComp.layerList;
				var layer;

				for (var i = 0; i < list.length; i++) {
					layer = list[i];

					switch (layer.id) {
						case LAYERID_DEPTH:
							self.sceneDepth.patch(layer);
							break;

						case LAYERID_UI:
							layer.passThrough = self.defaultLayerUi.passThrough;
							break;

						case LAYERID_IMMEDIATE:
							layer.passThrough = self.defaultLayerImmediate.passThrough;
							break;
					}
				}
			});

			AreaLightLuts.createPlaceholder(_this.graphicsDevice);
			_this.renderer = new ForwardRenderer(_this.graphicsDevice);
			_this.renderer.scene = _this.scene;
			_this.lightmapper = new Lightmapper(_this.graphicsDevice, _this.root, _this.scene, _this.renderer, _this.assets);

			_this.once('prerender', _this._firstBake, _assertThisInitialized(_this));

			_this.batcher = new BatchManager(_this.graphicsDevice, _this.root, _this.scene);

			_this.once('prerender', _this._firstBatch, _assertThisInitialized(_this));

			_this.keyboard = options.keyboard || null;
			_this.mouse = options.mouse || null;
			_this.touch = options.touch || null;
			_this.gamepads = options.gamepads || null;
			_this.elementInput = options.elementInput || null;
			if (_this.elementInput) _this.elementInput.app = _assertThisInitialized(_this);
			_this.vr = null;
			_this.xr = new XrManager(_assertThisInitialized(_this));
			if (_this.elementInput) _this.elementInput.attachSelectEvents();
			_this._inTools = false;
			_this._skyboxAsset = null;
			_this._scriptPrefix = options.scriptPrefix || '';

			if (_this.enableBundles) {
				_this.loader.addHandler("bundle", new BundleHandler(_this.assets));
			}

			_this.loader.addHandler("animation", new AnimationHandler());

			_this.loader.addHandler("animclip", new AnimClipHandler());

			_this.loader.addHandler("animstategraph", new AnimStateGraphHandler());

			_this.loader.addHandler("model", new ModelHandler(_this.graphicsDevice));

			_this.loader.addHandler("render", new RenderHandler(_this.assets));

			_this.loader.addHandler("material", new MaterialHandler(_assertThisInitialized(_this)));

			_this.loader.addHandler("texture", new TextureHandler(_this.graphicsDevice, _this.assets, _this.loader));

			_this.loader.addHandler("text", new TextHandler());

			_this.loader.addHandler("json", new JsonHandler());

			_this.loader.addHandler("audio", new AudioHandler(_this._soundManager));

			_this.loader.addHandler("script", new ScriptHandler(_assertThisInitialized(_this)));

			_this.loader.addHandler("scene", new SceneHandler(_assertThisInitialized(_this)));

			_this.loader.addHandler("cubemap", new CubemapHandler(_this.graphicsDevice, _this.assets, _this.loader));

			_this.loader.addHandler("html", new HtmlHandler());

			_this.loader.addHandler("css", new CssHandler());

			_this.loader.addHandler("shader", new ShaderHandler());

			_this.loader.addHandler("hierarchy", new HierarchyHandler(_assertThisInitialized(_this)));

			_this.loader.addHandler("folder", new FolderHandler());

			_this.loader.addHandler("font", new FontHandler(_this.loader));

			_this.loader.addHandler("binary", new BinaryHandler());

			_this.loader.addHandler("textureatlas", new TextureAtlasHandler(_this.loader));

			_this.loader.addHandler("sprite", new SpriteHandler(_this.assets, _this.graphicsDevice));

			_this.loader.addHandler("template", new TemplateHandler(_assertThisInitialized(_this)));

			_this.loader.addHandler("container", new ContainerHandler(_this.graphicsDevice, _this.assets));

			_this.systems = new ComponentSystemRegistry();

			_this.systems.add(new RigidBodyComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new CollisionComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new JointComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new AnimationComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new AnimComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new ModelComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new RenderComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new CameraComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new LightComponentSystem(_assertThisInitialized(_this)));

			if (script.legacy) {
				_this.systems.add(new ScriptLegacyComponentSystem(_assertThisInitialized(_this)));
			} else {
				_this.systems.add(new ScriptComponentSystem(_assertThisInitialized(_this)));
			}

			_this.systems.add(new AudioSourceComponentSystem(_assertThisInitialized(_this), _this._soundManager));

			_this.systems.add(new SoundComponentSystem(_assertThisInitialized(_this), _this._soundManager));

			_this.systems.add(new AudioListenerComponentSystem(_assertThisInitialized(_this), _this._soundManager));

			_this.systems.add(new ParticleSystemComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new ScreenComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new ElementComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new ButtonComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new ScrollViewComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new ScrollbarComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new SpriteComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new LayoutGroupComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new LayoutChildComponentSystem(_assertThisInitialized(_this)));

			_this.systems.add(new ZoneComponentSystem(_assertThisInitialized(_this)));

			_this._visibilityChangeHandler = _this.onVisibilityChange.bind(_assertThisInitialized(_this));

			if (typeof document !== 'undefined') {
				if (document.hidden !== undefined) {
					_this._hiddenAttr = 'hidden';
					document.addEventListener('visibilitychange', _this._visibilityChangeHandler, false);
				} else if (document.mozHidden !== undefined) {
					_this._hiddenAttr = 'mozHidden';
					document.addEventListener('mozvisibilitychange', _this._visibilityChangeHandler, false);
				} else if (document.msHidden !== undefined) {
					_this._hiddenAttr = 'msHidden';
					document.addEventListener('msvisibilitychange', _this._visibilityChangeHandler, false);
				} else if (document.webkitHidden !== undefined) {
					_this._hiddenAttr = 'webkitHidden';
					document.addEventListener('webkitvisibilitychange', _this._visibilityChangeHandler, false);
				}
			}

			_this.tick = makeTick(_assertThisInitialized(_this));
			return _this;
		}

		Application.getApplication = function getApplication$1(id) {
			return id ? Application._applications[id] : getApplication();
		};

		var _proto2 = Application.prototype;

		_proto2._initDefaultMaterial = function _initDefaultMaterial() {
			var material = new StandardMaterial();
			material.name = "Default Material";
			material.shadingModel = SPECULAR_BLINN;
			setDefaultMaterial(this.graphicsDevice, material);
		};

		_proto2.configure = function configure(url, callback) {
			var _this2 = this;

			http.get(url, function (err, response) {
				if (err) {
					callback(err);
					return;
				}

				var props = response.application_properties;
				var scenes = response.scenes;
				var assets = response.assets;

				_this2._parseApplicationProperties(props, function (err) {
					_this2._parseScenes(scenes);

					_this2._parseAssets(assets);

					if (!err) {
						callback(null);
					} else {
						callback(err);
					}
				});
			});
		};

		_proto2.preload = function preload(callback) {
			var _this3 = this;

			this.fire("preload:start");
			var assets = this.assets.list({
				preload: true
			});
			var progress = new Progress(assets.length);
			var _done = false;

			var done = function done() {
				if (!_this3.graphicsDevice) {
					return;
				}

				if (!_done && progress.done()) {
					_done = true;

					_this3.fire("preload:end");

					callback();
				}
			};

			var total = assets.length;

			if (progress.length) {
				var onAssetLoad = function onAssetLoad(asset) {
					progress.inc();

					_this3.fire('preload:progress', progress.count / total);

					if (progress.done()) done();
				};

				var onAssetError = function onAssetError(err, asset) {
					progress.inc();

					_this3.fire('preload:progress', progress.count / total);

					if (progress.done()) done();
				};

				for (var i = 0; i < assets.length; i++) {
					if (!assets[i].loaded) {
						assets[i].once('load', onAssetLoad);
						assets[i].once('error', onAssetError);
						this.assets.load(assets[i]);
					} else {
						progress.inc();
						this.fire("preload:progress", progress.count / total);
						if (progress.done()) done();
					}
				}
			} else {
				done();
			}
		};

		_proto2._preloadScripts = function _preloadScripts(sceneData, callback) {
			var _this4 = this;

			if (!script.legacy) {
				callback();
				return;
			}

			this.systems.script.preloading = true;

			var scripts = this._getScriptReferences(sceneData);

			var l = scripts.length;
			var progress = new Progress(l);
			var regex = /^http(s)?:\/\//;

			if (l) {
				var onLoad = function onLoad(err, ScriptType) {
					if (err) console.error(err);
					progress.inc();

					if (progress.done()) {
						_this4.systems.script.preloading = false;
						callback();
					}
				};

				for (var i = 0; i < l; i++) {
					var scriptUrl = scripts[i];
					if (!regex.test(scriptUrl.toLowerCase()) && this._scriptPrefix) scriptUrl = path.join(self._scriptPrefix, scripts[i]);
					this.loader.load(scriptUrl, 'script', onLoad);
				}
			} else {
				this.systems.script.preloading = false;
				callback();
			}
		};

		_proto2._handleAreaLightDataProperty = function _handleAreaLightDataProperty(prop) {
			var asset = this.assets.get(prop);

			if (asset) {
				this.setAreaLightLuts(asset);
			} else {
				this.assets.once('add:' + prop, this.setAreaLightLuts, this);
			}
		};

		_proto2._parseApplicationProperties = function _parseApplicationProperties(props, callback) {
			if (typeof props.maxAssetRetries === 'number' && props.maxAssetRetries > 0) {
				this.loader.enableRetry(props.maxAssetRetries);
			}

			if (!props.useDevicePixelRatio) props.useDevicePixelRatio = props.use_device_pixel_ratio;
			if (!props.resolutionMode) props.resolutionMode = props.resolution_mode;
			if (!props.fillMode) props.fillMode = props.fill_mode;
			this._width = props.width;
			this._height = props.height;

			if (props.useDevicePixelRatio) {
				this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
			}

			this.setCanvasResolution(props.resolutionMode, this._width, this._height);
			this.setCanvasFillMode(props.fillMode, this._width, this._height);

			if (props.layers && props.layerOrder) {
				var composition = new LayerComposition("application");
				var layers = {};

				for (var key in props.layers) {
					var data = props.layers[key];
					data.id = parseInt(key, 10);
					data.enabled = data.id !== LAYERID_DEPTH;
					layers[key] = new Layer(data);
				}

				for (var i = 0, len = props.layerOrder.length; i < len; i++) {
					var sublayer = props.layerOrder[i];
					var layer = layers[sublayer.layer];
					if (!layer) continue;

					if (sublayer.transparent) {
						composition.pushTransparent(layer);
					} else {
						composition.pushOpaque(layer);
					}

					composition.subLayerEnabled[i] = sublayer.enabled;
				}

				this.scene.layers = composition;
			}

			if (props.batchGroups) {
				for (var _i = 0, _len = props.batchGroups.length; _i < _len; _i++) {
					var grp = props.batchGroups[_i];
					this.batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);
				}
			}

			if (props.i18nAssets) {
				this.i18n.assets = props.i18nAssets;
			}

			if (props.areaLightDataAsset) {
				this._handleAreaLightDataProperty(props.areaLightDataAsset);
			}

			this._loadLibraries(props.libraries, callback);
		};

		_proto2._loadLibraries = function _loadLibraries(urls, callback) {
			var _this5 = this;

			var len = urls.length;
			var count = len;
			var regex = /^http(s)?:\/\//;

			if (len) {
				var onLoad = function onLoad(err, script) {
					count--;

					if (err) {
						callback(err);
					} else if (count === 0) {
						_this5.onLibrariesLoaded();

						callback(null);
					}
				};

				for (var i = 0; i < len; ++i) {
					var url = urls[i];
					if (!regex.test(url.toLowerCase()) && this._scriptPrefix) url = path.join(this._scriptPrefix, url);
					this.loader.load(url, 'script', onLoad);
				}
			} else {
				this.onLibrariesLoaded();
				callback(null);
			}
		};

		_proto2._parseScenes = function _parseScenes(scenes) {
			if (!scenes) return;

			for (var i = 0; i < scenes.length; i++) {
				this.scenes.add(scenes[i].name, scenes[i].url);
			}
		};

		_proto2._parseAssets = function _parseAssets(assets) {
			var list = [];
			var scriptsIndex = {};
			var bundlesIndex = {};

			if (!script.legacy) {
				for (var i = 0; i < this.scriptsOrder.length; i++) {
					var id = this.scriptsOrder[i];
					if (!assets[id]) continue;
					scriptsIndex[id] = true;
					list.push(assets[id]);
				}

				if (this.enableBundles) {
					for (var _id in assets) {
						if (assets[_id].type === 'bundle') {
							bundlesIndex[_id] = true;
							list.push(assets[_id]);
						}
					}
				}

				for (var _id2 in assets) {
					if (scriptsIndex[_id2] || bundlesIndex[_id2]) continue;
					list.push(assets[_id2]);
				}
			} else {
				if (this.enableBundles) {
					for (var _id3 in assets) {
						if (assets[_id3].type === 'bundle') {
							bundlesIndex[_id3] = true;
							list.push(assets[_id3]);
						}
					}
				}

				for (var _id4 in assets) {
					if (bundlesIndex[_id4]) continue;
					list.push(assets[_id4]);
				}
			}

			for (var _i2 = 0; _i2 < list.length; _i2++) {
				var data = list[_i2];
				var asset = new Asset(data.name, data.type, data.file, data.data);
				asset.id = parseInt(data.id, 10);
				asset.preload = data.preload ? data.preload : false;
				asset.loaded = data.type === 'script' && data.data && data.data.loadingType > 0;
				asset.tags.add(data.tags);

				if (data.i18n) {
					for (var locale in data.i18n) {
						asset.addLocalizedAssetId(locale, data.i18n[locale]);
					}
				}

				this.assets.add(asset);
			}
		};

		_proto2._getScriptReferences = function _getScriptReferences(scene) {
			var priorityScripts = [];

			if (scene.settings.priority_scripts) {
				priorityScripts = scene.settings.priority_scripts;
			}

			var _scripts = [];
			var _index = {};

			for (var i = 0; i < priorityScripts.length; i++) {
				_scripts.push(priorityScripts[i]);

				_index[priorityScripts[i]] = true;
			}

			var entities = scene.entities;

			for (var key in entities) {
				if (!entities[key].components.script) {
					continue;
				}

				var scripts = entities[key].components.script.scripts;

				for (var _i3 = 0; _i3 < scripts.length; _i3++) {
					if (_index[scripts[_i3].url]) continue;

					_scripts.push(scripts[_i3].url);

					_index[scripts[_i3].url] = true;
				}
			}

			return _scripts;
		};

		_proto2.start = function start() {
			this.frame = 0;
			this.fire("start", {
				timestamp: now(),
				target: this
			});

			if (!this._librariesLoaded) {
				this.onLibrariesLoaded();
			}

			this.systems.fire('initialize', this.root);
			this.fire('initialize');
			this.systems.fire('postInitialize', this.root);
			this.systems.fire('postPostInitialize', this.root);
			this.fire('postinitialize');
			this.tick();
		};

		_proto2.inputUpdate = function inputUpdate(dt) {
			if (this.controller) {
				this.controller.update(dt);
			}

			if (this.mouse) {
				this.mouse.update();
			}

			if (this.keyboard) {
				this.keyboard.update();
			}

			if (this.gamepads) {
				this.gamepads.update();
			}
		};

		_proto2.update = function update(dt) {
			this.frame++;
			this.graphicsDevice.updateClientRect();
			if (this.vr) this.vr.poll();
			this.stats.frame.updateStart = now();
			if (script.legacy) this.systems.fire('fixedUpdate', 1.0 / 60.0);
			this.systems.fire(this._inTools ? 'toolsUpdate' : 'update', dt);
			this.systems.fire('animationUpdate', dt);
			this.systems.fire('postUpdate', dt);
			this.fire("update", dt);
			this.inputUpdate(dt);
			this.stats.frame.updateTime = now() - this.stats.frame.updateStart;
		};

		_proto2.render = function render() {
			this.stats.frame.renderStart = now();
			this.fire('prerender');
			this.root.syncHierarchy();
			this.batcher.updateAll();
			ForwardRenderer._skipRenderCounter = 0;
			this.renderer.renderComposition(this.scene.layers);
			this.fire('postrender');
			this.stats.frame.renderTime = now() - this.stats.frame.renderStart;
		};

		_proto2._fillFrameStatsBasic = function _fillFrameStatsBasic(now, dt, ms) {
			var stats = this.stats.frame;
			stats.dt = dt;
			stats.ms = ms;

			if (now > stats._timeToCountFrames) {
				stats.fps = stats._fpsAccum;
				stats._fpsAccum = 0;
				stats._timeToCountFrames = now + 1000;
			} else {
				stats._fpsAccum++;
			}

			this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;
			this.graphicsDevice._drawCallsPerFrame = 0;
		};

		_proto2._fillFrameStats = function _fillFrameStats() {
			var stats = this.stats.frame;
			stats.cameras = this.renderer._camerasRendered;
			stats.materials = this.renderer._materialSwitches;
			stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
			stats.shadowMapUpdates = this.renderer._shadowMapUpdates;
			stats.shadowMapTime = this.renderer._shadowMapTime;
			stats.depthMapTime = this.renderer._depthMapTime;
			stats.forwardTime = this.renderer._forwardTime;
			var prims = this.graphicsDevice._primsPerFrame;
			stats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);
			stats.cullTime = this.renderer._cullTime;
			stats.sortTime = this.renderer._sortTime;
			stats.skinTime = this.renderer._skinTime;
			stats.morphTime = this.renderer._morphTime;
			stats.lightClusters = this.renderer._lightClusters;
			stats.lightClustersTime = this.renderer._lightClustersTime;
			stats.otherPrimitives = 0;

			for (var i = 0; i < prims.length; i++) {
				if (i < PRIMITIVE_TRIANGLES) {
					stats.otherPrimitives += prims[i];
				}

				prims[i] = 0;
			}

			this.renderer._camerasRendered = 0;
			this.renderer._materialSwitches = 0;
			this.renderer._shadowMapUpdates = 0;
			this.graphicsDevice._shaderSwitchesPerFrame = 0;
			this.renderer._cullTime = 0;
			this.renderer._layerCompositionUpdateTime = 0;
			this.renderer._lightClustersTime = 0;
			this.renderer._sortTime = 0;
			this.renderer._skinTime = 0;
			this.renderer._morphTime = 0;
			this.renderer._shadowMapTime = 0;
			this.renderer._depthMapTime = 0;
			this.renderer._forwardTime = 0;
			stats = this.stats.drawCalls;
			stats.forward = this.renderer._forwardDrawCalls;
			stats.culled = this.renderer._numDrawCallsCulled;
			stats.depth = 0;
			stats.shadow = this.renderer._shadowDrawCalls;
			stats.skinned = this.renderer._skinDrawCalls;
			stats.immediate = 0;
			stats.instanced = 0;
			stats.removedByInstancing = 0;
			stats.misc = stats.total - (stats.forward + stats.shadow);
			this.renderer._depthDrawCalls = 0;
			this.renderer._shadowDrawCalls = 0;
			this.renderer._forwardDrawCalls = 0;
			this.renderer._numDrawCallsCulled = 0;
			this.renderer._skinDrawCalls = 0;
			this.renderer._immediateRendered = 0;
			this.renderer._instancedDrawCalls = 0;
			this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
			stats = this.stats.particles;
			stats.updatesPerFrame = stats._updatesPerFrame;
			stats.frameTime = stats._frameTime;
			stats._updatesPerFrame = 0;
			stats._frameTime = 0;
		};

		_proto2.setCanvasFillMode = function setCanvasFillMode(mode, width, height) {
			this._fillMode = mode;
			this.resizeCanvas(width, height);
		};

		_proto2.setCanvasResolution = function setCanvasResolution(mode, width, height) {
			this._resolutionMode = mode;

			if (mode === RESOLUTION_AUTO && width === undefined) {
				width = this.graphicsDevice.canvas.clientWidth;
				height = this.graphicsDevice.canvas.clientHeight;
			}

			this.graphicsDevice.resizeCanvas(width, height);
		};

		_proto2.isHidden = function isHidden() {
			return document[this._hiddenAttr];
		};

		_proto2.onVisibilityChange = function onVisibilityChange() {
			if (this.isHidden()) {
				this._soundManager.suspend();
			} else {
				this._soundManager.resume();
			}
		};

		_proto2.resizeCanvas = function resizeCanvas(width, height) {
			if (!this._allowResize) return;
			if (this.xr && this.xr.session) return;
			var windowWidth = window.innerWidth;
			var windowHeight = window.innerHeight;

			if (this._fillMode === FILLMODE_KEEP_ASPECT) {
				var r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
				var winR = windowWidth / windowHeight;

				if (r > winR) {
					width = windowWidth;
					height = width / r;
				} else {
					height = windowHeight;
					width = height * r;
				}
			} else if (this._fillMode === FILLMODE_FILL_WINDOW) {
				width = windowWidth;
				height = windowHeight;
			}

			this.graphicsDevice.canvas.style.width = width + 'px';
			this.graphicsDevice.canvas.style.height = height + 'px';
			this.updateCanvasSize();
			return {
				width: width,
				height: height
			};
		};

		_proto2.updateCanvasSize = function updateCanvasSize() {
			if (!this._allowResize || this.xr.active) {
				return;
			}

			if (this._resolutionMode === RESOLUTION_AUTO) {
				var canvas = this.graphicsDevice.canvas;
				this.graphicsDevice.resizeCanvas(canvas.clientWidth, canvas.clientHeight);
			}
		};

		_proto2.onLibrariesLoaded = function onLibrariesLoaded() {
			this._librariesLoaded = true;
			this.systems.rigidbody.onLibraryLoaded();
		};

		_proto2.applySceneSettings = function applySceneSettings(settings) {
			var asset;

			if (this.systems.rigidbody && typeof Ammo !== 'undefined') {
				var gravity = settings.physics.gravity;
				this.systems.rigidbody.gravity.set(gravity[0], gravity[1], gravity[2]);
			}

			this.scene.applySettings(settings);

			if (settings.render.hasOwnProperty('skybox')) {
				if (settings.render.skybox) {
					asset = this.assets.get(settings.render.skybox);

					if (asset) {
						this.setSkybox(asset);
					} else {
						this.assets.once('add:' + settings.render.skybox, this.setSkybox, this);
					}
				} else {
					this.setSkybox(null);
				}
			}
		};

		_proto2.setAreaLightLuts = function setAreaLightLuts(asset) {
			if (asset) {
				var device = this.graphicsDevice;
				asset.ready(function (asset) {
					AreaLightLuts.set(device, asset.resource);
				});
				this.assets.load(asset);
			} else {
				Debug.warn("setAreaLightLuts: asset is not valid");
			}
		};

		_proto2.setSkybox = function setSkybox(asset) {
			var _this6 = this;

			if (asset !== this._skyboxAsset) {
				var onSkyboxRemoved = function onSkyboxRemoved() {
					_this6.setSkybox(null);
				};

				var onSkyboxChanged = function onSkyboxChanged() {
					_this6.scene.setSkybox(_this6._skyboxAsset ? _this6._skyboxAsset.resources : null);
				};

				if (this._skyboxAsset) {
					this.assets.off('load:' + this._skyboxAsset.id, onSkyboxChanged, this);
					this.assets.off('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);

					this._skyboxAsset.off('change', onSkyboxChanged, this);
				}

				this._skyboxAsset = asset;

				if (this._skyboxAsset) {
					this.assets.on('load:' + this._skyboxAsset.id, onSkyboxChanged, this);
					this.assets.once('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);

					this._skyboxAsset.on('change', onSkyboxChanged, this);

					if (this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces) {
						this._skyboxAsset.loadFaces = true;
					}

					this.assets.load(this._skyboxAsset);
				}

				onSkyboxChanged();
			}
		};

		_proto2.enableVr = function enableVr() {
			if (!this.vr) {
				this.vr = new VrManager(this);
			}
		};

		_proto2.disableVr = function disableVr() {
			if (this.vr) {
				this.vr.destroy();
				this.vr = null;
			}
		};

		_proto2._firstBake = function _firstBake() {
			this.lightmapper.bake(null, this.scene.lightmapMode);
		};

		_proto2._firstBatch = function _firstBatch() {
			this.batcher.generate();
		};

		_proto2._processTimestamp = function _processTimestamp(timestamp) {
			return timestamp;
		};

		_proto2.drawLine = function drawLine(start, end, color, depthTest, layer) {
			this.scene.drawLine(start, end, color, depthTest, layer);
		};

		_proto2.drawLines = function drawLines(positions, colors, depthTest, layer) {
			if (depthTest === void 0) {
				depthTest = true;
			}

			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}

			this.scene.drawLines(positions, colors, depthTest, layer);
		};

		_proto2.drawLineArrays = function drawLineArrays(positions, colors, depthTest, layer) {
			if (depthTest === void 0) {
				depthTest = true;
			}

			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}

			this.scene.drawLineArrays(positions, colors, depthTest, layer);
		};

		_proto2.drawWireSphere = function drawWireSphere(center, radius, color, segments, depthTest, layer) {
			if (color === void 0) {
				color = Color.WHITE;
			}

			if (segments === void 0) {
				segments = 20;
			}

			if (depthTest === void 0) {
				depthTest = true;
			}

			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}

			this.scene.immediate.drawWireSphere(center, radius, color, segments, depthTest, layer);
		};

		_proto2.drawWireAlignedBox = function drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer) {
			if (color === void 0) {
				color = Color.WHITE;
			}

			if (depthTest === void 0) {
				depthTest = true;
			}

			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}

			this.scene.immediate.drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer);
		};

		_proto2.drawMeshInstance = function drawMeshInstance(meshInstance, layer) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}

			this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
		};

		_proto2.drawMesh = function drawMesh(mesh, material, matrix, layer) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}

			this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);
		};

		_proto2.drawQuad = function drawQuad(matrix, material, layer) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}

			this.scene.immediate.drawMesh(material, matrix, this.scene.immediate.getQuadMesh(), null, layer);
		};

		_proto2.drawTexture = function drawTexture(x, y, width, height, texture, material, layer) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}

			var matrix = new Mat4();
			matrix.setTRS(new Vec3(x, y, 0.0), Quat.IDENTITY, new Vec3(width, height, 0.0));

			if (!material) {
				material = new Material();
				material.setParameter("colorMap", texture);
				material.shader = this.scene.immediate.getTextureShader();
				material.update();
			}

			this.drawQuad(matrix, material, layer);
		};

		_proto2.drawDepthTexture = function drawDepthTexture(x, y, width, height, layer) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}

			var material = new Material();
			material.shader = this.scene.immediate.getDepthTextureShader();
			material.update();
			this.drawTexture(x, y, width, height, null, material, layer);
		};

		_proto2.destroy = function destroy() {
			if (this._inFrameUpdate) {
				this._destroyRequested = true;
				return;
			}

			var canvasId = this.graphicsDevice.canvas.id;
			this.off('librariesloaded');

			if (typeof document !== 'undefined') {
				document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
				document.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
				document.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
				document.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
			}

			this._visibilityChangeHandler = null;
			this.root.destroy();
			this.root = null;

			if (this.mouse) {
				this.mouse.off();
				this.mouse.detach();
				this.mouse = null;
			}

			if (this.keyboard) {
				this.keyboard.off();
				this.keyboard.detach();
				this.keyboard = null;
			}

			if (this.touch) {
				this.touch.off();
				this.touch.detach();
				this.touch = null;
			}

			if (this.elementInput) {
				this.elementInput.detach();
				this.elementInput = null;
			}

			if (this.controller) {
				this.controller = null;
			}

			this.systems.destroy();

			if (this.scene.layers) {
				this.scene.layers.destroy();
			}

			var assets = this.assets.list();

			for (var i = 0; i < assets.length; i++) {
				assets[i].unload();
				assets[i].off();
			}

			this.assets.off();
			this.bundles.destroy();
			this.bundles = null;
			this.i18n.destroy();
			this.i18n = null;

			for (var key in this.loader.getHandler('script')._cache) {
				var element = this.loader.getHandler('script')._cache[key];

				var parent = element.parentNode;
				if (parent) parent.removeChild(element);
			}

			this.loader.getHandler('script')._cache = {};
			this.loader.destroy();
			this.loader = null;
			this.scene.destroy();
			this.scene = null;
			this.systems = null;
			this.context = null;
			this.scripts.destroy();
			this.scripts = null;
			this.scenes.destroy();
			this.scenes = null;
			this.lightmapper.destroy();
			this.lightmapper = null;
			this.batcher.destroy();
			this.batcher = null;
			this._entityIndex = {};
			this.defaultLayerDepth.onPreRenderOpaque = null;
			this.defaultLayerDepth.onPostRenderOpaque = null;
			this.defaultLayerDepth.onDisable = null;
			this.defaultLayerDepth.onEnable = null;
			this.defaultLayerDepth = null;
			this.defaultLayerWorld = null;

			if (this.vr) {
				this.vr.destroy();
				this.vr = null;
			}

			this.xr.end();
			this.renderer.destroy();
			this.renderer = null;
			this.graphicsDevice.destroy();
			this.graphicsDevice = null;
			this.tick = null;
			this.off();

			if (this._soundManager) {
				this._soundManager.destroy();

				this._soundManager = null;
			}

			script.app = null;
			Application._applications[canvasId] = null;

			if (getApplication() === this) {
				setApplication(null);
			}
		};

		_proto2.getEntityFromIndex = function getEntityFromIndex(guid) {
			return this._entityIndex[guid];
		};

		_proto2._registerSceneImmediate = function _registerSceneImmediate(scene) {
			this.on('postrender', scene.immediate.onPostRender, scene.immediate);
		};

		_createClass(Application, [{
			key: "fillMode",
			get: function get() {
				return this._fillMode;
			}
		}, {
			key: "resolutionMode",
			get: function get() {
				return this._resolutionMode;
			}
		}]);

		return Application;
	}(EventHandler);

	Application._applications = {};
	var _frameEndData = {};

	var makeTick = function makeTick(_app) {
		var application = _app;
		var frameRequest;
		return function (timestamp, frame) {
			if (!application.graphicsDevice) return;
			setApplication(application);

			if (frameRequest) {
				window.cancelAnimationFrame(frameRequest);
				frameRequest = null;
			}

			exports.app = application;
			var currentTime = application._processTimestamp(timestamp) || now();
			var ms = currentTime - (application._time || currentTime);
			var dt = ms / 1000.0;
			dt = math.clamp(dt, 0, application.maxDeltaTime);
			dt *= application.timeScale;
			application._time = currentTime;

			if (application.vr && application.vr.display) {
				frameRequest = application.vr.display.requestAnimationFrame(application.tick);
			} else if (application.xr.session) {
				frameRequest = application.xr.session.requestAnimationFrame(application.tick);
			} else {
				frameRequest = platform.browser ? window.requestAnimationFrame(application.tick) : null;
			}

			if (application.graphicsDevice.contextLost) return;

			application._fillFrameStatsBasic(currentTime, dt, ms);

			application._fillFrameStats();

			application._inFrameUpdate = true;
			application.fire("frameupdate", ms);

			if (frame) {
				application.xr.update(frame);
				application.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;
			} else {
				application.graphicsDevice.defaultFramebuffer = null;
			}

			application.update(dt);
			application.fire("framerender");

			if (application.autoRender || application.renderNextFrame) {
				application.updateCanvasSize();
				application.render();
				application.renderNextFrame = false;
			}

			_frameEndData.timestamp = now();
			_frameEndData.target = application;
			application.fire("frameend", _frameEndData);
			application.fire("frameEnd", _frameEndData);

			if (application.vr && application.vr.display && application.vr.display.presenting) {
				application.vr.display.submitFrame();
			}

			application._inFrameUpdate = false;

			if (application._destroyRequested) {
				application.destroy();
			}
		};
	};

	var _enableList = [];

	var Entity = function (_GraphNode) {
		_inheritsLoose(Entity, _GraphNode);

		function Entity(name, app) {
			var _this;

			_this = _GraphNode.call(this, name) || this;
			_this.anim = void 0;
			_this.animation = void 0;
			_this.audiolistener = void 0;
			_this.button = void 0;
			_this.camera = void 0;
			_this.collision = void 0;
			_this.element = void 0;
			_this.layoutchild = void 0;
			_this.layoutgroup = void 0;
			_this.light = void 0;
			_this.model = void 0;
			_this.particlesystem = void 0;
			_this.render = void 0;
			_this.rigidbody = void 0;
			_this.screen = void 0;
			_this.script = void 0;
			_this.scrollbar = void 0;
			_this.scrollview = void 0;
			_this.sound = void 0;
			_this.sprite = void 0;
			_this.c = {};
			_this._app = void 0;
			_this._destroying = false;
			_this._guid = null;
			_this._template = false;
			if (name instanceof Application) app = name;

			if (!app) {
				app = Application.getApplication();

				if (!app) {
					throw new Error("Couldn't find current application");
				}
			}

			_this._app = app;
			return _this;
		}

		var _proto = Entity.prototype;

		_proto.addComponent = function addComponent(type, data) {
			var system = this._app.systems[type];

			if (!system) {
				Debug.error("addComponent: System " + type + " doesn't exist");
				return null;
			}

			if (this.c[type]) {
				Debug.warn("addComponent: Entity already has " + type + " component");
				return null;
			}

			return system.addComponent(this, data);
		};

		_proto.removeComponent = function removeComponent(type) {
			var system = this._app.systems[type];

			if (!system) {
				Debug.error("addComponent: System " + type + " doesn't exist");
				return;
			}

			if (!this.c[type]) {
				Debug.warn("removeComponent: Entity doesn't have " + type + " component");
				return;
			}

			system.removeComponent(this);
		};

		_proto.findComponent = function findComponent(type) {
			var entity = this.findOne(function (node) {
				return node.c && node.c[type];
			});
			return entity && entity.c[type];
		};

		_proto.findComponents = function findComponents(type) {
			var entities = this.find(function (node) {
				return node.c && node.c[type];
			});
			return entities.map(function (entity) {
				return entity.c[type];
			});
		};

		_proto.getGuid = function getGuid() {
			if (!this._guid) {
				this.setGuid(guid.create());
			}

			return this._guid;
		};

		_proto.setGuid = function setGuid(guid) {
			var index = this._app._entityIndex;

			if (this._guid) {
				delete index[this._guid];
			}

			this._guid = guid;
			index[this._guid] = this;
		};

		_proto._notifyHierarchyStateChanged = function _notifyHierarchyStateChanged(node, enabled) {
			var enableFirst = false;
			if (node === this && _enableList.length === 0) enableFirst = true;
			node._beingEnabled = true;

			node._onHierarchyStateChanged(enabled);

			if (node._onHierarchyStatePostChanged) _enableList.push(node);
			var c = node._children;

			for (var i = 0, len = c.length; i < len; i++) {
				if (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);
			}

			node._beingEnabled = false;

			if (enableFirst) {
				for (var _i = 0; _i < _enableList.length; _i++) {
					_enableList[_i]._onHierarchyStatePostChanged();
				}

				_enableList.length = 0;
			}
		};

		_proto._onHierarchyStateChanged = function _onHierarchyStateChanged(enabled) {
			_GraphNode.prototype._onHierarchyStateChanged.call(this, enabled);

			var components = this.c;

			for (var type in components) {
				if (components.hasOwnProperty(type)) {
					var component = components[type];

					if (component.enabled) {
						if (enabled) {
							component.onEnable();
						} else {
							component.onDisable();
						}
					}
				}
			}
		};

		_proto._onHierarchyStatePostChanged = function _onHierarchyStatePostChanged() {
			var components = this.c;

			for (var type in components) {
				if (components.hasOwnProperty(type)) components[type].onPostStateChange();
			}
		};

		_proto.findByGuid = function findByGuid(guid) {
			if (this._guid === guid) return this;
			var e = this._app._entityIndex[guid];

			if (e && (e === this || e.isDescendantOf(this))) {
				return e;
			}

			return null;
		};

		_proto.destroy = function destroy() {
			this._destroying = true;

			for (var name in this.c) {
				this.c[name].enabled = false;
			}

			for (var _name in this.c) {
				this.c[_name].system.removeComponent(this);
			}

			if (this._parent) this._parent.removeChild(this);
			var children = this._children;
			var child = children.shift();

			while (child) {
				if (child instanceof Entity) {
					child.destroy();
				}

				child._parent = null;
				child = children.shift();
			}

			this.fire('destroy', this);
			this.off();

			if (this._guid) {
				delete this._app._entityIndex[this._guid];
			}

			this._destroying = false;
		};

		_proto.clone = function clone() {
			var duplicatedIdsMap = {};

			var clone = this._cloneRecursively(duplicatedIdsMap);

			duplicatedIdsMap[this.getGuid()] = clone;
			resolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);
			return clone;
		};

		_proto._cloneRecursively = function _cloneRecursively(duplicatedIdsMap) {
			var clone = new Entity(this._app);

			_GraphNode.prototype._cloneInternal.call(this, clone);

			for (var type in this.c) {
				var component = this.c[type];
				component.system.cloneComponent(this, clone);
			}

			for (var i = 0; i < this._children.length; i++) {
				var oldChild = this._children[i];

				if (oldChild instanceof Entity) {
					var newChild = oldChild._cloneRecursively(duplicatedIdsMap);

					clone.addChild(newChild);
					duplicatedIdsMap[oldChild.getGuid()] = newChild;
				}
			}

			return clone;
		};

		return Entity;
	}(GraphNode);

	function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {
		if (oldEntity instanceof Entity) {
			var components = oldEntity.c;

			for (var componentName in components) {
				var component = components[componentName];
				var entityProperties = component.system.getPropertiesOfType('entity');

				for (var i = 0, len = entityProperties.length; i < len; i++) {
					var propertyDescriptor = entityProperties[i];
					var propertyName = propertyDescriptor.name;
					var oldEntityReferenceId = component[propertyName];
					var entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);

					if (entityIsWithinOldSubtree) {
						var newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();

						if (newEntityReferenceId) {
							newEntity.c[componentName][propertyName] = newEntityReferenceId;
						} else {
							Debug.warn('Could not find corresponding entity id when resolving duplicated entity references');
						}
					}
				}
			}

			if (components.script && !newEntity._app.useLegacyScriptAttributeCloning) {
				newEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);
			}

			if (components.render) {
				newEntity.render.resolveDuplicatedEntityReferenceProperties(components.render, duplicatedIdsMap);
			}

			if (components.anim) {
				newEntity.anim.resolveDuplicatedEntityReferenceProperties(components.anim, duplicatedIdsMap);
			}

			var _old = oldEntity.children.filter(function (e) {
				return e instanceof Entity;
			});

			var _new = newEntity.children.filter(function (e) {
				return e instanceof Entity;
			});

			for (var _i2 = 0, _len = _old.length; _i2 < _len; _i2++) {
				resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[_i2], _new[_i2], duplicatedIdsMap);
			}
		}
	}

	var _tempPoint = new Vec3();

	var BakeLightAmbient = function (_BakeLight) {
		_inheritsLoose(BakeLightAmbient, _BakeLight);

		function BakeLightAmbient(scene) {
			var lightEntity = new Entity("AmbientLight");
			lightEntity.addComponent("light", {
				type: "directional",
				affectDynamic: true,
				affectLightmapped: false,
				bake: true,
				bakeNumSamples: scene.ambientBakeNumSamples,
				castShadows: true,
				normalOffsetBias: 0.05,
				shadowBias: 0.2,
				shadowDistance: 1,
				shadowResolution: 2048,
				shadowType: SHADOW_PCF3,
				color: Color.WHITE,
				intensity: 1,
				bakeDir: false
			});
			return _BakeLight.call(this, scene, lightEntity.light.light) || this;
		}

		var _proto = BakeLightAmbient.prototype;

		_proto.prepareVirtualLight = function prepareVirtualLight(index, numVirtualLights) {
			random.spherePointDeterministic(_tempPoint, index, numVirtualLights, 0, this.scene.ambientBakeSpherePart);

			this.light._node.lookAt(_tempPoint.mulScalar(-1));

			this.light._node.rotateLocal(90, 0, 0);

			var gamma = this.scene.gammaCorrection ? 2.2 : 1;
			var fullIntensity = 2 * Math.PI * this.scene.ambientBakeSpherePart;
			var linearIntensity = Math.pow(fullIntensity, gamma);
			this.light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
		};

		_createClass(BakeLightAmbient, [{
			key: "numVirtualLights",
			get: function get() {
				return this.light.bakeNumSamples;
			}
		}]);

		return BakeLightAmbient;
	}(BakeLight);

	var BakeMeshNode = function () {
		function BakeMeshNode(node, meshInstances) {
			if (meshInstances === void 0) {
				meshInstances = null;
			}

			this.node = node;
			this.component = node.render || node.model;
			meshInstances = meshInstances || this.component.meshInstances;
			this.store();
			this.meshInstances = meshInstances;
			this.bounds = null;
			this.renderTargets = [];
		}

		var _proto = BakeMeshNode.prototype;

		_proto.store = function store() {
			this.castShadows = this.component.castShadows;
		};

		_proto.restore = function restore() {
			this.component.castShadows = this.castShadows;
		};

		return BakeMeshNode;
	}();

	var DENOISE_FILTER_SIZE = 15;

	var LightmapFilters = function () {
		function LightmapFilters(device) {
			this.device = device;
			this.shaderDilate = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.dilatePS, "lmDilate");
			this.constantTexSource = device.scope.resolve("source");
			this.constantPixelOffset = device.scope.resolve("pixelOffset");
			this.pixelOffset = new Float32Array(2);
			this.shaderDenoise = null;
			this.sigmas = null;
			this.constantSigmas = null;
			this.kernel = null;
		}

		var _proto = LightmapFilters.prototype;

		_proto.setSourceTexture = function setSourceTexture(texture) {
			this.constantTexSource.setValue(texture);
		};

		_proto.prepare = function prepare(textureWidth, textureHeight) {
			this.pixelOffset[0] = 1 / textureWidth;
			this.pixelOffset[1] = 1 / textureHeight;
			this.constantPixelOffset.setValue(this.pixelOffset);
		};

		_proto.prepareDenoise = function prepareDenoise(filterRange, filterSmoothness) {
			if (!this.shaderDenoise) {
				this.shaderDenoise = createShaderFromCode(this.device, shaderChunks.fullscreenQuadVS, shaderChunks.bilateralDeNoisePS, "lmBilateralDeNoise");
				this.sigmas = new Float32Array(2);
				this.constantSigmas = this.device.scope.resolve("sigmas");
				this.constantKernel = this.device.scope.resolve("kernel[0]");
				this.bZnorm = this.device.scope.resolve("bZnorm");
			}

			this.sigmas[0] = filterRange;
			this.sigmas[1] = filterSmoothness;
			this.constantSigmas.setValue(this.sigmas);
			this.evaluateDenoiseUniforms(filterRange, filterSmoothness);
		};

		_proto.evaluateDenoiseUniforms = function evaluateDenoiseUniforms(filterRange, filterSmoothness) {
			function normpdf(x, sigma) {
				return 0.39894 * Math.exp(-0.5 * x * x / (sigma * sigma)) / sigma;
			}

			this.kernel = this.kernel || new Float32Array(DENOISE_FILTER_SIZE);
			var kernel = this.kernel;
			var kSize = Math.floor((DENOISE_FILTER_SIZE - 1) / 2);

			for (var j = 0; j <= kSize; ++j) {
				var value = normpdf(j, filterRange);
				kernel[kSize + j] = value;
				kernel[kSize - j] = value;
			}

			this.constantKernel.setValue(this.kernel);
			var bZnorm = 1 / normpdf(0.0, filterSmoothness);
			this.bZnorm.setValue(bZnorm);
		};

		return LightmapFilters;
	}();

	var MAX_LIGHTMAP_SIZE = 2048;
	var PASS_COLOR = 0;
	var PASS_DIR = 1;
	var tempVec = new Vec3();

	var Lightmapper = function () {
		function Lightmapper(device, root, scene, renderer, assets) {
			this.device = device;
			this.root = root;
			this.scene = scene;
			this.renderer = renderer;
			this.assets = assets;
			this.shadowMapCache = renderer._shadowRenderer.shadowMapCache;
			this._tempSet = new Set();
			this._initCalled = false;
			this.passMaterials = [];
			this.ambientAOMaterial = null;
			this.fog = "";
			this.ambientLight = new Color();
			this.renderTargets = new Map();
			this.stats = {
				renderPasses: 0,
				lightmapCount: 0,
				totalRenderTime: 0,
				forwardTime: 0,
				fboTime: 0,
				shadowMapTime: 0,
				compileTime: 0,
				shadersLinked: 0
			};
		}

		var _proto = Lightmapper.prototype;

		_proto.destroy = function destroy() {
			LightmapCache.decRef(this.blackTex);
			this.blackTex = null;
			LightmapCache.destroy();
			this.device = null;
			this.root = null;
			this.scene = null;
			this.renderer = null;
			this.assets = null;
		};

		_proto.initBake = function initBake(device) {
			if (!this._initCalled) {
				this._initCalled = true;
				this.lightmapFilters = new LightmapFilters(device);
				this.constantBakeDir = device.scope.resolve("bakeDir");
				this.materials = [];
				this.blackTex = new Texture(this.device, {
					width: 4,
					height: 4,
					format: PIXELFORMAT_R8_G8_B8_A8,
					type: TEXTURETYPE_RGBM
				});
				this.blackTex.name = 'lightmapBlack';
				LightmapCache.incRef(this.blackTex);
				var camera = new Camera();
				camera.clearColor.set(0, 0, 0, 0);
				camera.clearColorBuffer = true;
				camera.clearDepthBuffer = false;
				camera.clearStencilBuffer = false;
				camera.frustumCulling = false;
				camera.projection = PROJECTION_ORTHOGRAPHIC;
				camera.aspectRatio = 1;
				camera.node = new GraphNode();
				this.camera = camera;
			}

			if (this.scene.clusteredLightingEnabled) {
				var lightingParams = new LightingParams(device.supportsAreaLights, device.maxTextureSize, function () {});
				this.lightingParams = lightingParams;
				var srcParams = this.scene.lighting;
				lightingParams.shadowsEnabled = srcParams.shadowsEnabled;
				lightingParams.shadowAtlasResolution = srcParams.shadowAtlasResolution;
				lightingParams.cookiesEnabled = srcParams.cookiesEnabled;
				lightingParams.cookieAtlasResolution = srcParams.cookieAtlasResolution;
				lightingParams.areaLightsEnabled = srcParams.areaLightsEnabled;
				lightingParams.cells = new Vec3(3, 3, 3);
				lightingParams.maxLightsPerCell = 4;
				this.worldClusters = new WorldClusters(device);
				this.worldClusters.name = "ClusterLightmapper";
			}
		};

		_proto.finishBake = function finishBake(bakeNodes) {
			this.materials = [];

			function destroyRT(rt) {
				LightmapCache.decRef(rt.colorBuffer);
				rt.destroy();
			}

			this.renderTargets.forEach(function (rt) {
				destroyRT(rt);
			});
			this.renderTargets.clear();
			bakeNodes.forEach(function (node) {
				node.renderTargets.forEach(function (rt) {
					destroyRT(rt);
				});
				node.renderTargets.length = 0;
			});
			this.ambientAOMaterial = null;

			if (this.worldClusters) {
				this.worldClusters.destroy();
				this.worldClusters = null;
			}
		};

		_proto.createMaterialForPass = function createMaterialForPass(device, scene, pass, addAmbient) {
			var material = new StandardMaterial();
			material.name = "lmMaterial-pass:" + pass + "-ambient:" + addAmbient;
			material.chunks.transformVS = "#define UV1LAYOUT\n" + shaderChunks.transformVS;

			if (pass === PASS_COLOR) {
				var bakeLmEndChunk = shaderChunks.bakeLmEndPS;

				if (addAmbient) {
					bakeLmEndChunk = "\n										dDiffuseLight = ((dDiffuseLight - 0.5) * max(" + scene.ambientBakeOcclusionContrast.toFixed(1) + " + 1.0, 0.0)) + 0.5;\n										dDiffuseLight += vec3(" + scene.ambientBakeOcclusionBrightness.toFixed(1) + ");\n										dDiffuseLight = saturate(dDiffuseLight);\n										dDiffuseLight *= dAmbientLight;\n								" + bakeLmEndChunk;
				} else {
					material.ambient = new Color(0, 0, 0);
					material.ambientTint = true;
				}

				material.chunks.endPS = bakeLmEndChunk;
				material.lightMap = this.blackTex;
			} else {
				material.chunks.basePS = shaderChunks.basePS + "\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n";
				material.chunks.endPS = shaderChunks.bakeDirLmEndPS;
			}

			material.chunks.outputAlphaPS = "\n";
			material.chunks.outputAlphaOpaquePS = "\n";
			material.chunks.outputAlphaPremulPS = "\n";
			material.cull = CULLFACE_NONE;
			material.forceUv1 = true;
			material.update();
			material.updateShader(device, scene);
			return material;
		};

		_proto.createMaterials = function createMaterials(device, scene, passCount) {
			for (var pass = 0; pass < passCount; pass++) {
				if (!this.passMaterials[pass]) {
					this.passMaterials[pass] = this.createMaterialForPass(device, scene, pass, false);
				}
			}

			if (!this.ambientAOMaterial) {
				this.ambientAOMaterial = this.createMaterialForPass(device, scene, 0, true);

				this.ambientAOMaterial.onUpdateShader = function (options) {
					options.lightMapWithoutAmbient = true;
					options.separateAmbient = true;
					return options;
				};
			}
		};

		_proto.createTexture = function createTexture(size, type, name) {
			var tex = new Texture(this.device, {
				profilerHint: TEXHINT_LIGHTMAP,
				width: size,
				height: size,
				format: PIXELFORMAT_R8_G8_B8_A8,
				mipmaps: false,
				type: type,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			tex.name = name;
			return tex;
		};

		_proto.collectModels = function collectModels(node, bakeNodes, allNodes) {
			var _node$model, _node$model2, _node$render;

			if (!node.enabled) return;
			var meshInstances;

			if ((_node$model = node.model) != null && _node$model.model && (_node$model2 = node.model) != null && _node$model2.enabled) {
				if (allNodes) allNodes.push(new BakeMeshNode(node));

				if (node.model.lightmapped) {
					if (bakeNodes) {
						meshInstances = node.model.model.meshInstances;
					}
				}
			}

			if ((_node$render = node.render) != null && _node$render.enabled) {
				if (allNodes) allNodes.push(new BakeMeshNode(node));

				if (node.render.lightmapped) {
					if (bakeNodes) {
						meshInstances = node.render.meshInstances;
					}
				}
			}

			if (meshInstances) {
				var hasUv1 = true;

				for (var i = 0; i < meshInstances.length; i++) {
					if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {
						Debug.log("Lightmapper - node [" + node.name + "] contains meshes without required uv1, excluding it from baking.");
						hasUv1 = false;
						break;
					}
				}

				if (hasUv1) {
					var notInstancedMeshInstances = [];

					for (var _i = 0; _i < meshInstances.length; _i++) {
						var mesh = meshInstances[_i].mesh;

						if (this._tempSet.has(mesh)) {
							bakeNodes.push(new BakeMeshNode(node, [meshInstances[_i]]));
						} else {
							notInstancedMeshInstances.push(meshInstances[_i]);
						}

						this._tempSet.add(mesh);
					}

					this._tempSet.clear();

					if (notInstancedMeshInstances.length > 0) {
						bakeNodes.push(new BakeMeshNode(node, notInstancedMeshInstances));
					}
				}
			}

			for (var _i2 = 0; _i2 < node._children.length; _i2++) {
				this.collectModels(node._children[_i2], bakeNodes, allNodes);
			}
		};

		_proto.prepareShadowCasters = function prepareShadowCasters(nodes) {
			var casters = [];

			for (var n = 0; n < nodes.length; n++) {
				var component = nodes[n].component;
				component.castShadows = component.castShadowsLightmap;

				if (component.castShadowsLightmap) {
					var meshes = nodes[n].meshInstances;

					for (var i = 0; i < meshes.length; i++) {
						meshes[i].visibleThisFrame = true;
						casters.push(meshes[i]);
					}
				}
			}

			return casters;
		};

		_proto.updateTransforms = function updateTransforms(nodes) {
			for (var i = 0; i < nodes.length; i++) {
				var meshInstances = nodes[i].meshInstances;

				for (var j = 0; j < meshInstances.length; j++) {
					meshInstances[j].node.getWorldTransform();
				}
			}
		};

		_proto.calculateLightmapSize = function calculateLightmapSize(node) {
			var data;
			var sizeMult = this.scene.lightmapSizeMultiplier || 16;
			var scale = tempVec;
			var srcArea, lightmapSizeMultiplier;

			if (node.model) {
				lightmapSizeMultiplier = node.model.lightmapSizeMultiplier;

				if (node.model.asset) {
					data = this.assets.get(node.model.asset).data;

					if (data.area) {
						srcArea = data.area;
					}
				} else if (node.model._area) {
					data = node.model;

					if (data._area) {
						srcArea = data._area;
					}
				}
			} else if (node.render) {
				lightmapSizeMultiplier = node.render.lightmapSizeMultiplier;

				if (node.render.type !== 'asset') {
					if (node.render._area) {
						data = node.render;

						if (data._area) {
							srcArea = data._area;
						}
					}
				}
			}

			var area = {
				x: 1,
				y: 1,
				z: 1,
				uv: 1
			};

			if (srcArea) {
				area.x = srcArea.x;
				area.y = srcArea.y;
				area.z = srcArea.z;
				area.uv = srcArea.uv;
			}

			var areaMult = lightmapSizeMultiplier || 1;
			area.x *= areaMult;
			area.y *= areaMult;
			area.z *= areaMult;
			var component = node.render || node.model;
			var bounds = this.computeNodeBounds(component.meshInstances);
			scale.copy(bounds.halfExtents);
			var totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;
			totalArea /= area.uv;
			totalArea = Math.sqrt(totalArea);
			var lightmapSize = Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || MAX_LIGHTMAP_SIZE);
			return lightmapSize;
		};

		_proto.setLightmapping = function setLightmapping(nodes, value, passCount, shaderDefs) {
			for (var i = 0; i < nodes.length; i++) {
				var node = nodes[i];
				var meshInstances = node.meshInstances;

				for (var j = 0; j < meshInstances.length; j++) {
					var meshInstance = meshInstances[j];
					meshInstance.setLightmapped(value);

					if (value) {
						if (shaderDefs) {
							meshInstance._shaderDefs |= shaderDefs;
						}

						meshInstance.mask = MASK_AFFECT_LIGHTMAPPED;

						for (var pass = 0; pass < passCount; pass++) {
							var tex = node.renderTargets[pass].colorBuffer;
							tex.minFilter = FILTER_LINEAR;
							tex.magFilter = FILTER_LINEAR;
							meshInstance.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tex);
						}
					}
				}
			}
		};

		_proto.bake = function bake(nodes, mode) {
			if (mode === void 0) {
				mode = BAKE_COLORDIR;
			}

			var device = this.device;
			var startTime = now();

			this.scene._updateSkybox(device);

			device.fire('lightmapper:start', {
				timestamp: startTime,
				target: this
			});
			this.stats.renderPasses = 0;
			this.stats.shadowMapTime = 0;
			this.stats.forwardTime = 0;
			var startShaders = device._shaderStats.linked;
			var startFboTime = device._renderTargetCreationTime;
			var startCompileTime = device._shaderStats.compileTime;
			var bakeNodes = [];
			var allNodes = [];

			if (nodes) {
				for (var i = 0; i < nodes.length; i++) {
					this.collectModels(nodes[i], bakeNodes, null);
				}

				this.collectModels(this.root, null, allNodes);
			} else {
				this.collectModels(this.root, bakeNodes, allNodes);
			}

			DebugGraphics.pushGpuMarker(this.device, "LMBake");

			if (bakeNodes.length > 0) {
				var passCount = mode === BAKE_COLORDIR ? 2 : 1;
				this.setLightmapping(bakeNodes, false, passCount);
				this.initBake(device);
				this.bakeInternal(passCount, bakeNodes, allNodes);
				var shaderDefs = SHADERDEF_LM;

				if (mode === BAKE_COLORDIR) {
					shaderDefs |= SHADERDEF_DIRLM;
				}

				if (this.scene.ambientBake) {
					shaderDefs |= SHADERDEF_LMAMBIENT;
				}

				this.setLightmapping(bakeNodes, true, passCount, shaderDefs);
				this.finishBake(bakeNodes);
			}

			DebugGraphics.popGpuMarker(this.device);
			var nowTime = now();
			this.stats.totalRenderTime = nowTime - startTime;
			this.stats.shadersLinked = device._shaderStats.linked - startShaders;
			this.stats.compileTime = device._shaderStats.compileTime - startCompileTime;
			this.stats.fboTime = device._renderTargetCreationTime - startFboTime;
			this.stats.lightmapCount = bakeNodes.length;
			device.fire('lightmapper:end', {
				timestamp: nowTime,
				target: this
			});
		};

		_proto.allocateTextures = function allocateTextures(bakeNodes, passCount) {
			for (var i = 0; i < bakeNodes.length; i++) {
				var bakeNode = bakeNodes[i];
				var size = this.calculateLightmapSize(bakeNode.node);

				for (var pass = 0; pass < passCount; pass++) {
					var tex = this.createTexture(size, TEXTURETYPE_DEFAULT, "lightmapper_lightmap_" + i);
					LightmapCache.incRef(tex);
					bakeNode.renderTargets[pass] = new RenderTarget({
						colorBuffer: tex,
						depth: false
					});
				}

				if (!this.renderTargets.has(size)) {
					var _tex = this.createTexture(size, TEXTURETYPE_DEFAULT, "lightmapper_temp_lightmap_" + size);

					LightmapCache.incRef(_tex);
					this.renderTargets.set(size, new RenderTarget({
						colorBuffer: _tex,
						depth: false
					}));
				}
			}
		};

		_proto.prepareLightsToBake = function prepareLightsToBake(layerComposition, allLights, bakeLights) {
			if (this.scene.ambientBake) {
				var ambientLight = new BakeLightAmbient(this.scene);
				bakeLights.push(ambientLight);
			}

			var sceneLights = layerComposition._lights;

			for (var i = 0; i < sceneLights.length; i++) {
				var light = sceneLights[i];
				var bakeLight = new BakeLightSimple(this.scene, light);
				allLights.push(bakeLight);

				if (light.enabled && (light.mask & MASK_BAKE) !== 0) {
					light.isStatic = false;
					light.mask = 0xFFFFFFFF;
					light.shadowUpdateMode = light.type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;
					bakeLights.push(bakeLight);
				}
			}

			bakeLights.sort();
		};

		_proto.restoreLights = function restoreLights(allLights) {
			for (var i = 0; i < allLights.length; i++) {
				allLights[i].restore();
			}
		};

		_proto.setupScene = function setupScene() {
			this.revertStatic = false;

			if (this.scene._needsStaticPrepare) {
				this.scene._needsStaticPrepare = false;
				this.revertStatic = true;
			}

			this.fog = this.scene.fog;
			this.ambientLight.copy(this.scene.ambientLight);
			this.scene.fog = FOG_NONE;

			if (!this.scene.ambientBake) {
				this.scene.ambientLight.set(0, 0, 0);
			}

			this.renderer.setSceneConstants();
		};

		_proto.restoreScene = function restoreScene() {
			this.scene.fog = this.fog;
			this.scene.ambientLight.copy(this.ambientLight);

			if (this.revertStatic) {
				this.scene._needsStaticPrepare = true;
			}
		};

		_proto.computeNodeBounds = function computeNodeBounds(meshInstances) {
			var bounds = new BoundingBox();

			if (meshInstances.length > 0) {
				bounds.copy(meshInstances[0].aabb);

				for (var m = 1; m < meshInstances.length; m++) {
					bounds.add(meshInstances[m].aabb);
				}
			}

			return bounds;
		};

		_proto.computeNodesBounds = function computeNodesBounds(nodes) {
			for (var i = 0; i < nodes.length; i++) {
				var meshInstances = nodes[i].meshInstances;
				nodes[i].bounds = this.computeNodeBounds(meshInstances);
			}
		};

		_proto.computeBounds = function computeBounds(meshInstances) {
			var bounds = new BoundingBox();

			for (var i = 0; i < meshInstances.length; i++) {
				bounds.copy(meshInstances[0].aabb);

				for (var m = 1; m < meshInstances.length; m++) {
					bounds.add(meshInstances[m].aabb);
				}
			}

			return bounds;
		};

		_proto.backupMaterials = function backupMaterials(meshInstances) {
			for (var i = 0; i < meshInstances.length; i++) {
				this.materials[i] = meshInstances[i].material;
			}
		};

		_proto.restoreMaterials = function restoreMaterials(meshInstances) {
			for (var i = 0; i < meshInstances.length; i++) {
				meshInstances[i].material = this.materials[i];
			}
		};

		_proto.lightCameraPrepare = function lightCameraPrepare(device, bakeLight) {
			var light = bakeLight.light;
			var shadowCam;

			if (light.type === LIGHTTYPE_SPOT) {
				var lightRenderData = light.getRenderData(null, 0);
				shadowCam = lightRenderData.shadowCamera;

				shadowCam._node.setPosition(light._node.getPosition());

				shadowCam._node.setRotation(light._node.getRotation());

				shadowCam._node.rotateLocal(-90, 0, 0);

				shadowCam.projection = PROJECTION_PERSPECTIVE;
				shadowCam.nearClip = light.attenuationEnd / 1000;
				shadowCam.farClip = light.attenuationEnd;
				shadowCam.aspectRatio = 1;
				shadowCam.fov = light._outerConeAngle * 2;
				this.renderer.updateCameraFrustum(shadowCam);
			}

			return shadowCam;
		};

		_proto.lightCameraPrepareAndCull = function lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds) {
			var light = bakeLight.light;
			var lightAffectsNode = true;

			if (light.type === LIGHTTYPE_DIRECTIONAL) {
				tempVec.copy(casterBounds.center);
				tempVec.y += casterBounds.halfExtents.y;
				this.camera.node.setPosition(tempVec);
				this.camera.node.setEulerAngles(-90, 0, 0);
				this.camera.nearClip = 0;
				this.camera.farClip = casterBounds.halfExtents.y * 2;
				var frustumSize = Math.max(casterBounds.halfExtents.x, casterBounds.halfExtents.z);
				this.camera.orthoHeight = frustumSize;
			} else {
				if (!bakeLight.lightBounds.intersects(bakeNode.bounds)) {
					lightAffectsNode = false;
				}
			}

			if (light.type === LIGHTTYPE_SPOT) {
				var nodeVisible = false;
				var meshInstances = bakeNode.meshInstances;

				for (var i = 0; i < meshInstances.length; i++) {
					if (meshInstances[i]._isVisible(shadowCam)) {
						nodeVisible = true;
						break;
					}
				}

				if (!nodeVisible) {
					lightAffectsNode = false;
				}
			}

			return lightAffectsNode;
		};

		_proto.setupLightArray = function setupLightArray(lightArray, light) {
			lightArray[LIGHTTYPE_DIRECTIONAL].length = 0;
			lightArray[LIGHTTYPE_OMNI].length = 0;
			lightArray[LIGHTTYPE_SPOT].length = 0;
			lightArray[light.type][0] = light;
			light.visibleThisFrame = true;
		};

		_proto.renderShadowMap = function renderShadowMap(shadowMapRendered, casters, lightArray, bakeLight) {
			var light = bakeLight.light;

			if (!shadowMapRendered && light.castShadows) {
				if (!light.shadowMap && !this.scene.clusteredLightingEnabled) {
					light.shadowMap = this.shadowMapCache.get(this.device, light);
				}

				if (light.type === LIGHTTYPE_DIRECTIONAL) {
					this.renderer._shadowRenderer.cullDirectional(light, casters, this.camera);
				} else {
					this.renderer._shadowRenderer.cullLocal(light, casters);
				}

				this.renderer.renderShadows(lightArray[light.type], this.camera);
			}

			return true;
		};

		_proto.postprocessTextures = function postprocessTextures(device, bakeNodes, passCount) {
			var numDilates2x = 1;
			var dilateShader = this.lightmapFilters.shaderDilate;
			var filterLightmap = this.scene.lightmapFilterEnabled;

			if (filterLightmap) {
				this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness);
			}

			for (var node = 0; node < bakeNodes.length; node++) {
				var bakeNode = bakeNodes[node];
				DebugGraphics.pushGpuMarker(this.device, "LMPost:" + node);

				for (var pass = 0; pass < passCount; pass++) {
					var nodeRT = bakeNode.renderTargets[pass];
					var lightmap = nodeRT.colorBuffer;
					var tempRT = this.renderTargets.get(lightmap.width);
					var tempTex = tempRT.colorBuffer;
					this.lightmapFilters.prepare(lightmap.width, lightmap.height);

					for (var i = 0; i < numDilates2x; i++) {
						this.lightmapFilters.setSourceTexture(lightmap);
						var bilateralFilterEnabled = filterLightmap && pass === 0 && i === 0;
						drawQuadWithShader(device, tempRT, bilateralFilterEnabled ? this.lightmapFilters.shaderDenoise : dilateShader);
						this.lightmapFilters.setSourceTexture(tempTex);
						drawQuadWithShader(device, nodeRT, dilateShader);
					}
				}

				DebugGraphics.popGpuMarker(this.device);
			}
		};

		_proto.bakeInternal = function bakeInternal(passCount, bakeNodes, allNodes) {
			var scene = this.scene;
			var device = this.device;
			var clusteredLightingEnabled = scene.clusteredLightingEnabled;
			this.createMaterials(device, scene, passCount);
			this.setupScene();

			scene.layers._update();

			this.computeNodesBounds(bakeNodes);
			this.allocateTextures(bakeNodes, passCount);
			var allLights = [],
					bakeLights = [];
			this.prepareLightsToBake(scene.layers, allLights, bakeLights);
			this.updateTransforms(allNodes);
			var casters = this.prepareShadowCasters(allNodes);
			this.renderer.updateCpuSkinMatrices(casters);
			this.renderer.gpuUpdate(casters);
			var casterBounds = this.computeBounds(casters);
			var i, j, rcv, m;

			for (i = 0; i < bakeNodes.length; i++) {
				var bakeNode = bakeNodes[i];
				rcv = bakeNode.meshInstances;

				for (j = 0; j < rcv.length; j++) {
					m = rcv[j];
					m.setLightmapped(false);
					m.mask = MASK_BAKE;
					m.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], m.material.lightMap ? m.material.lightMap : this.blackTex);
					m.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], this.blackTex);
				}
			}

			for (j = 0; j < bakeLights.length; j++) {
				bakeLights[j].light.enabled = false;
			}

			var lightArray = [[], [], []];
			var pass, node;
			var shadersUpdatedOn1stPass = false;

			for (i = 0; i < bakeLights.length; i++) {
				var bakeLight = bakeLights[i];
				var isAmbientLight = bakeLight instanceof BakeLightAmbient;
				var numVirtualLights = bakeLight.numVirtualLights;

				if (passCount > 1 && numVirtualLights > 1 && bakeLight.light.bakeDir) {
					numVirtualLights = 1;
					Debug.warn("Lightmapper's BAKE_COLORDIR mode is not compatible with Light's bakeNumSamples larger than one. Forcing it to one.");
				}

				for (var virtualLightIndex = 0; virtualLightIndex < numVirtualLights; virtualLightIndex++) {
					DebugGraphics.pushGpuMarker(device, "Light:" + bakeLight.light._node.name + ":" + virtualLightIndex);

					if (numVirtualLights > 1) {
						bakeLight.prepareVirtualLight(virtualLightIndex, numVirtualLights);
					}

					bakeLight.startBake();
					var shadowMapRendered = false;
					var shadowCam = this.lightCameraPrepare(device, bakeLight);

					for (node = 0; node < bakeNodes.length; node++) {
						var _bakeNode = bakeNodes[node];
						rcv = _bakeNode.meshInstances;
						var lightAffectsNode = this.lightCameraPrepareAndCull(bakeLight, _bakeNode, shadowCam, casterBounds);

						if (!lightAffectsNode) {
							continue;
						}

						this.setupLightArray(lightArray, bakeLight.light);

						if (clusteredLightingEnabled) {
							this.renderer.lightTextureAtlas.update(lightArray[LIGHTTYPE_SPOT], lightArray[LIGHTTYPE_OMNI], this.lightingParams);
						}

						shadowMapRendered = this.renderShadowMap(shadowMapRendered, casters, lightArray, bakeLight);

						if (clusteredLightingEnabled) {
							var clusterLights = lightArray[LIGHTTYPE_SPOT].concat(lightArray[LIGHTTYPE_OMNI]);
							this.worldClusters.update(clusterLights, this.scene.gammaCorrection, this.lightingParams);
						}

						this.backupMaterials(rcv);

						for (pass = 0; pass < passCount; pass++) {
							if (pass > 0 && virtualLightIndex > 0) {
								break;
							}

							if (isAmbientLight && pass > 0) {
								break;
							}

							DebugGraphics.pushGpuMarker(device, "LMPass:" + pass);
							var nodeRT = _bakeNode.renderTargets[pass];
							var lightmapSize = _bakeNode.renderTargets[pass].colorBuffer.width;
							var tempRT = this.renderTargets.get(lightmapSize);
							var tempTex = tempRT.colorBuffer;

							if (pass === 0) {
								shadersUpdatedOn1stPass = scene.updateShaders;
							} else if (shadersUpdatedOn1stPass) {
								scene.updateShaders = true;
							}

							var passMaterial = this.passMaterials[pass];

							if (isAmbientLight) {
								var lastVirtualLightForPass = virtualLightIndex + 1 === numVirtualLights;

								if (lastVirtualLightForPass && pass === 0) {
									passMaterial = this.ambientAOMaterial;
								}
							}

							for (j = 0; j < rcv.length; j++) {
								rcv[j].material = passMaterial;
							}

							this.renderer.updateShaders(rcv);
							this.renderer.setCamera(this.camera, tempRT, true);

							if (pass === PASS_DIR) {
								this.constantBakeDir.setValue(bakeLight.light.bakeDir ? 1 : 0);
							}

							if (clusteredLightingEnabled) {
								this.worldClusters.activate(this.renderer.lightTextureAtlas);
							}

							this.renderer._forwardTime = 0;
							this.renderer._shadowMapTime = 0;
							this.renderer.renderForward(this.camera, rcv, rcv.length, lightArray, SHADER_FORWARDHDR);
							this.stats.shadowMapTime += this.renderer._shadowMapTime;
							this.stats.forwardTime += this.renderer._forwardTime;
							this.stats.renderPasses++;
							_bakeNode.renderTargets[pass] = tempRT;
							this.renderTargets.set(lightmapSize, nodeRT);

							for (j = 0; j < rcv.length; j++) {
								m = rcv[j];
								m.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tempTex);
								m._shaderDefs |= SHADERDEF_LM;
							}

							DebugGraphics.popGpuMarker(device);
						}

						this.restoreMaterials(rcv);
					}

					bakeLight.endBake(this.shadowMapCache);
					DebugGraphics.popGpuMarker(device);
				}
			}

			this.postprocessTextures(device, bakeNodes, passCount);

			for (node = 0; node < allNodes.length; node++) {
				allNodes[node].restore();
			}

			this.restoreLights(allLights);
			this.restoreScene();

			if (!clusteredLightingEnabled) {
				this.shadowMapCache.clear();
			}
		};

		return Lightmapper;
	}();

	var tempSet = new Set();
	var clearDepthOptions = {
		depth: 1.0,
		flags: CLEARFLAG_DEPTH
	};

	var Picker = function () {
		function Picker(app, width, height) {
			if (app instanceof GraphicsDevice) {
				app = getApplication();
				Debug.deprecated("pc.Picker now takes pc.Application as first argument. Passing pc.GraphicsDevice is deprecated.");
			}

			this.app = app;
			this.device = app.graphicsDevice;
			this.pickColor = new Float32Array(4);
			this.pickColor[3] = 1;
			this.mapping = [];
			this.cameraEntity = null;
			this.layer = null;
			this.layerComp = null;
			this.initLayerComposition();
			this._renderTarget = null;
			var device = this.device;
			this.clearDepthCommand = new Command(0, 0, function () {
				device.clear(clearDepthOptions);
			});
			this.width = 0;
			this.height = 0;
			this.resize(width, height);
		}

		var _proto = Picker.prototype;

		_proto.getSelection = function getSelection(x, y, width, height) {
			var device = this.device;

			if (typeof x === 'object') {
				Debug.deprecated("Picker.getSelection:param 'rect' is deprecated, use 'x, y, width, height' instead.");
				var rect = x;
				x = rect.x;
				y = rect.y;
				width = rect.width;
				height = rect.height;
			} else {
				y = this.renderTarget.height - (y + (height || 1));
			}

			x = Math.floor(x);
			y = Math.floor(y);
			width = Math.floor(Math.max(width || 1, 1));
			height = Math.floor(Math.max(height || 1, 1));
			var origRenderTarget = device.renderTarget;
			device.setRenderTarget(this.renderTarget);
			device.updateBegin();
			var pixels = new Uint8Array(4 * width * height);
			device.readPixels(x, y, width, height, pixels);
			device.updateEnd();
			device.setRenderTarget(origRenderTarget);
			var mapping = this.mapping;

			for (var i = 0; i < width * height; i++) {
				var r = pixels[4 * i + 0];
				var g = pixels[4 * i + 1];
				var b = pixels[4 * i + 2];
				var index = r << 16 | g << 8 | b;

				if (index !== 0xffffff) {
					tempSet.add(mapping[index]);
				}
			}

			var selection = [];
			tempSet.forEach(function (meshInstance) {
				return selection.push(meshInstance);
			});
			tempSet.clear();
			return selection;
		};

		_proto.allocateRenderTarget = function allocateRenderTarget() {
			var colorBuffer = new Texture(this.device, {
				format: PIXELFORMAT_R8_G8_B8_A8,
				width: this.width,
				height: this.height,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			colorBuffer.name = 'pick';
			this.renderTarget = new RenderTarget({
				colorBuffer: colorBuffer,
				depth: true
			});
		};

		_proto.releaseRenderTarget = function releaseRenderTarget() {
			this.cameraEntity.camera.renderTarget = null;

			if (this._renderTarget) {
				this._renderTarget._colorBuffer.destroy();

				this._renderTarget.destroy();

				this._renderTarget = null;
			}
		};

		_proto.initLayerComposition = function initLayerComposition() {
			var device = this.device;
			var self = this;
			var pickColorId = device.scope.resolve('uColor');
			this.cameraEntity = new Entity();
			this.cameraEntity.addComponent("camera");
			this.layer = new Layer({
				name: "Picker",
				shaderPass: SHADER_PICK,
				opaqueSortMode: SORTMODE_NONE,
				onDrawCall: function onDrawCall(meshInstance, index) {
					self.pickColor[0] = (index >> 16 & 0xff) / 255;
					self.pickColor[1] = (index >> 8 & 0xff) / 255;
					self.pickColor[2] = (index & 0xff) / 255;
					pickColorId.setValue(self.pickColor);
					device.setBlending(false);
					self.mapping[index] = meshInstance;
				}
			});
			this.layer.addCamera(this.cameraEntity.camera);
			this.layerComp = new LayerComposition("picker");
			this.layerComp.pushOpaque(this.layer);
		};

		_proto.prepare = function prepare(camera, scene, layers) {
			if (camera instanceof Camera) {
				Debug.deprecated("pc.Picker#prepare now takes pc.CameraComponent as first argument. Passing pc.Camera is deprecated.");
				camera = camera.node.camera;
			}

			if (layers instanceof Layer) {
				layers = [layers];
			}

			this.layer.clearMeshInstances();
			var destMeshInstances = this.layer.opaqueMeshInstances;
			var srcLayers = scene.layers.layerList;
			var subLayerEnabled = scene.layers.subLayerEnabled;
			var isTransparent = scene.layers.subLayerList;

			for (var i = 0; i < srcLayers.length; i++) {
				var srcLayer = srcLayers[i];

				if (layers && layers.indexOf(srcLayer) < 0) {
					continue;
				}

				if (srcLayer.enabled && subLayerEnabled[i]) {
					var layerCamId = srcLayer.cameras.indexOf(camera);

					if (layerCamId >= 0) {
						if (srcLayer._clearDepthBuffer) {
							destMeshInstances.push(this.clearDepthCommand);
						}

						var meshInstances = isTransparent[i] ? srcLayer.instances.transparentMeshInstances : srcLayer.instances.opaqueMeshInstances;

						for (var j = 0; j < meshInstances.length; j++) {
							var meshInstance = meshInstances[j];

							if (meshInstance.pick) {
								destMeshInstances.push(meshInstance);
							}
						}
					}
				}
			}

			if (!this.renderTarget || this.width !== this.renderTarget.width || this.height !== this.renderTarget.height) {
				this.releaseRenderTarget();
				this.allocateRenderTarget();
			}

			this.updateCamera(camera);
			this.mapping.length = 0;
			this.app.renderer.renderComposition(this.layerComp);
		};

		_proto.updateCamera = function updateCamera(srcCamera) {
			this.cameraEntity.copy(srcCamera.entity);
			this.cameraEntity.name = "PickerCamera";
			var destCamera = this.cameraEntity.camera;
			destCamera.copy(srcCamera);
			destCamera.clearColorBuffer = true;
			destCamera.clearDepthBuffer = true;
			destCamera.clearStencilBuffer = true;
			destCamera.clearColor = Color.WHITE;
			destCamera.renderTarget = this.renderTarget;
			this.layer.clearCameras();
			this.layer.addCamera(destCamera);
			destCamera.layers = [this.layer.id];
		};

		_proto.resize = function resize(width, height) {
			this.width = Math.floor(width);
			this.height = Math.floor(height);
		};

		return Picker;
	}();

	var MAX_TEXTURE_SIZE = 4096;
	var DEFAULT_TEXTURE_SIZE = 512;

	var CanvasFont = function (_EventHandler) {
		_inheritsLoose(CanvasFont, _EventHandler);

		function CanvasFont(app, options) {
			var _this;

			if (options === void 0) {
				options = {};
			}

			_this = _EventHandler.call(this) || this;
			_this.type = "bitmap";
			_this.app = app;
			_this.intensity = 0;
			_this.fontWeight = options.fontWeight || 'normal';
			_this.fontSize = parseInt(options.fontSize, 10);
			_this.glyphSize = _this.fontSize;
			_this.fontName = options.fontName || 'Arial';
			_this.color = options.color || new Color(1, 1, 1);
			_this.padding = options.padding || 0;
			var w = options.width > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : options.width || DEFAULT_TEXTURE_SIZE;
			var h = options.height > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : options.height || DEFAULT_TEXTURE_SIZE;
			var canvas = document.createElement('canvas');
			canvas.height = h;
			canvas.width = w;
			var texture = new Texture(_this.app.graphicsDevice, {
				name: 'font',
				format: PIXELFORMAT_R8_G8_B8_A8,
				minFilter: FILTER_LINEAR_MIPMAP_LINEAR,
				magFilter: FILTER_LINEAR,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				mipmaps: true
			});
			texture.setSource(canvas);
			_this.textures = [texture];
			_this.chars = "";
			_this.data = {};
			return _this;
		}

		var _proto = CanvasFont.prototype;

		_proto.createTextures = function createTextures(text) {
			var _chars = this._normalizeCharsSet(text);

			if (_chars.length !== this.chars.length) {
				this._renderAtlas(_chars);

				return;
			}

			for (var i = 0; i < _chars.length; i++) {
				if (_chars[i] !== this.chars[i]) {
					this._renderAtlas(_chars);

					return;
				}
			}
		};

		_proto.updateTextures = function updateTextures(text) {
			var _chars = this._normalizeCharsSet(text);

			var newCharsSet = [];

			for (var i = 0; i < _chars.length; i++) {
				var char = _chars[i];

				if (!this.data.chars[char]) {
					newCharsSet.push(char);
				}
			}

			if (newCharsSet.length > 0) {
				this._renderAtlas(this.chars.concat(newCharsSet));
			}
		};

		_proto.destroy = function destroy() {
			for (var i = 0; i < this.textures.length; i++) {
				this.textures[i].destroy();
			}

			this.chars = null;
			this.color = null;
			this.data = null;
			this.fontName = null;
			this.fontSize = null;
			this.glyphSize = null;
			this.intensity = null;
			this.textures = null;
			this.type = null;
			this.fontWeight = null;
		};

		_proto._getAndClearContext = function _getAndClearContext(canvas, clearColor) {
			var w = canvas.width;
			var h = canvas.height;
			var ctx = canvas.getContext('2d', {
				alpha: true
			});
			ctx.clearRect(0, 0, w, h);
			ctx.fillStyle = clearColor;
			ctx.fillRect(0, 0, w, h);
			return ctx;
		};

		_proto._colorToRgbString = function _colorToRgbString(color, alpha) {
			var str;
			var r = Math.round(255 * color.r);
			var g = Math.round(255 * color.g);
			var b = Math.round(255 * color.b);

			if (alpha) {
				str = "rgba(" + r + ", " + g + ", " + b + ", " + color.a + ")";
			} else {
				str = "rgb(" + r + ", " + g + ", " + b + ")";
			}

			return str;
		};

		_proto.renderCharacter = function renderCharacter(context, char, x, y, color) {
			context.fillStyle = color;
			context.fillText(char, x, y);
		};

		_proto._renderAtlas = function _renderAtlas(charsArray) {
			this.chars = charsArray;
			var numTextures = 1;
			var canvas = this.textures[numTextures - 1].getSource();
			var w = canvas.width;
			var h = canvas.height;

			var color = this._colorToRgbString(this.color, false);

			var a = this.color.a;
			this.color.a = 1 / 255;

			var transparent = this._colorToRgbString(this.color, true);

			this.color.a = a;
			var TEXT_ALIGN = 'center';
			var TEXT_BASELINE = 'alphabetic';

			var ctx = this._getAndClearContext(canvas, transparent);

			ctx.font = this.fontWeight + ' ' + this.fontSize.toString() + 'px ' + this.fontName;
			ctx.textAlign = TEXT_ALIGN;
			ctx.textBaseline = TEXT_BASELINE;
			this.data = this._createJson(this.chars, this.fontName, w, h);
			var symbols = string.getSymbols(this.chars.join(''));
			var prevNumTextures = this.textures.length;
			var maxHeight = 0;
			var maxDescent = 0;
			var metrics = {};

			for (var i = 0; i < symbols.length; i++) {
				var ch = symbols[i];
				metrics[ch] = this._getTextMetrics(ch);
				maxHeight = Math.max(maxHeight, metrics[ch].height);
				maxDescent = Math.max(maxDescent, metrics[ch].descent);
			}

			this.glyphSize = Math.max(this.glyphSize, maxHeight);
			var sx = this.glyphSize + this.padding * 2;
			var sy = this.glyphSize + this.padding * 2;

			var _xOffset = this.glyphSize / 2 + this.padding;

			var _yOffset = sy - maxDescent - this.padding;

			var _x = 0;
			var _y = 0;

			for (var _i = 0; _i < symbols.length; _i++) {
				var _ch = symbols[_i];
				var code = string.getCodePoint(symbols[_i]);
				var fs = this.fontSize;
				ctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;
				ctx.textAlign = TEXT_ALIGN;
				ctx.textBaseline = TEXT_BASELINE;
				var width = ctx.measureText(_ch).width;

				if (width > fs) {
					fs = this.fontSize * this.fontSize / width;
					ctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;
					width = this.fontSize;
				}

				this.renderCharacter(ctx, _ch, _x + _xOffset, _y + _yOffset, color);
				var xoffset = this.padding + (this.glyphSize - width) / 2;
				var yoffset = -this.padding + metrics[_ch].descent - maxDescent;
				var xadvance = width;

				this._addChar(this.data, _ch, code, _x, _y, sx, sy, xoffset, yoffset, xadvance, numTextures - 1, w, h);

				_x += sx;

				if (_x + sx > w) {
					_x = 0;
					_y += sy;

					if (_y + sy > h) {
						this.textures[numTextures - 1].upload();
						numTextures++;
						_y = 0;

						if (numTextures > prevNumTextures) {
							canvas = document.createElement('canvas');
							canvas.height = h;
							canvas.width = w;
							ctx = this._getAndClearContext(canvas, transparent);
							var texture = new Texture(this.app.graphicsDevice, {
								format: PIXELFORMAT_R8_G8_B8_A8,
								mipmaps: true
							});
							texture.name = 'font-atlas';
							texture.setSource(canvas);
							texture.minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
							texture.magFilter = FILTER_LINEAR;
							texture.addressU = ADDRESS_CLAMP_TO_EDGE;
							texture.addressV = ADDRESS_CLAMP_TO_EDGE;
							this.textures.push(texture);
						} else {
							canvas = this.textures[numTextures - 1].getSource();
							ctx = this._getAndClearContext(canvas, transparent);
						}
					}
				}
			}

			this.textures[numTextures - 1].upload();

			if (numTextures < prevNumTextures) {
				for (var _i2 = numTextures; _i2 < prevNumTextures; _i2++) {
					this.textures[_i2].destroy();
				}

				this.textures.splice(numTextures);
			}

			this.fire("render");
		};

		_proto._createJson = function _createJson(chars, fontName, width, height) {
			var base = {
				"version": 3,
				"intensity": this.intensity,
				"info": {
					"face": fontName,
					"width": width,
					"height": height,
					"maps": [{
						"width": width,
						"height": height
					}]
				},
				"chars": {}
			};
			return base;
		};

		_proto._addChar = function _addChar(json, char, charCode, x, y, w, h, xoffset, yoffset, xadvance, mapNum, mapW, mapH) {
			if (json.info.maps.length < mapNum + 1) {
				json.info.maps.push({
					"width": mapW,
					"height": mapH
				});
			}

			var scale = this.fontSize / 32;
			json.chars[char] = {
				"id": charCode,
				"letter": char,
				"x": x,
				"y": y,
				"width": w,
				"height": h,
				"xadvance": xadvance / scale,
				"xoffset": xoffset / scale,
				"yoffset": (yoffset + this.padding) / scale,
				"scale": scale,
				"range": 1,
				"map": mapNum,
				"bounds": [0, 0, w / scale, h / scale]
			};
		};

		_proto._normalizeCharsSet = function _normalizeCharsSet(text) {
			var unicodeConverterFunc = this.app.systems.element.getUnicodeConverter();

			if (unicodeConverterFunc) {
				text = unicodeConverterFunc(text);
			}

			var set = {};
			var symbols = string.getSymbols(text);

			for (var i = 0; i < symbols.length; i++) {
				var ch = symbols[i];
				if (set[ch]) continue;
				set[ch] = ch;
			}

			var chars = Object.keys(set);
			return chars.sort();
		};

		_proto._getTextMetrics = function _getTextMetrics(text) {
			var textSpan = document.createElement('span');
			textSpan.id = 'content-span';
			textSpan.innerHTML = text;
			var block = document.createElement("div");
			block.id = 'content-block';
			block.style.display = 'inline-block';
			block.style.width = '1px';
			block.style.height = '0px';
			var div = document.createElement('div');
			div.appendChild(textSpan);
			div.appendChild(block);
			div.style.font = this.fontSize + 'px ' + this.fontName;
			var body = document.body;
			body.appendChild(div);
			var ascent = -1;
			var descent = -1;
			var height = -1;

			try {
				block.style['vertical-align'] = 'baseline';
				ascent = block.offsetTop - textSpan.offsetTop;
				block.style['vertical-align'] = 'bottom';
				height = block.offsetTop - textSpan.offsetTop;
				descent = height - ascent;
			} finally {
				document.body.removeChild(div);
			}

			return {
				ascent: ascent,
				descent: descent,
				height: height
			};
		};

		return CanvasFont;
	}(EventHandler);

	var ResourceHandler = function () {
		function ResourceHandler() {}

		var _proto = ResourceHandler.prototype;

		_proto.load = function load(url, callback, asset) {
			throw new Error('not implemented');
		};

		_proto.open = function open(url, data, asset) {
			throw new Error('not implemented');
		};

		_proto.patch = function patch(asset, assets) {};

		return ResourceHandler;
	}();

	var SceneSettingsHandler = function () {
		function SceneSettingsHandler(app) {
			this._app = app;
			this.maxRetries = 0;
		}

		var _proto = SceneSettingsHandler.prototype;

		_proto.load = function load(url, callback) {
			SceneUtils.load(url, this.maxRetries, callback);
		};

		_proto.open = function open(url, data) {
			return data.settings;
		};

		return SceneSettingsHandler;
	}();

	var reservedScriptNames = new Set(['system', 'entity', 'create', 'destroy', 'swap', 'move', 'scripts', '_scripts', '_scriptsIndex', '_scriptsData', 'enabled', '_oldState', 'onEnable', 'onDisable', 'onPostStateChange', '_onSetEnabled', '_checkState', '_onBeforeRemove', '_onInitializeAttributes', '_onInitialize', '_onPostInitialize', '_onUpdate', '_onPostUpdate', '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);

	function createScript(name, app) {
		if (script.legacy) {
			Debug.error("This project is using the legacy script system. You cannot call pc.createScript().");
			return null;
		}

		if (reservedScriptNames.has(name)) throw new Error("script name: '" + name + "' is reserved, please change script name");

		var scriptType = function scriptType(args) {
			EventHandler.prototype.initEventHandler.call(this);
			ScriptType.prototype.initScriptType.call(this, args);
		};

		scriptType.prototype = Object.create(ScriptType.prototype);
		scriptType.prototype.constructor = scriptType;
		scriptType.extend = ScriptType.extend;
		scriptType.attributes = new ScriptAttributes(scriptType);
		registerScript(scriptType, name, app);
		return scriptType;
	}

	var reservedAttributes = {};
	ScriptAttributes.reservedNames.forEach(function (value, value2, set) {
		reservedAttributes[value] = 1;
	});
	createScript.reservedAttributes = reservedAttributes;

	function registerScript(script, name, app) {
		if (script.legacy) {
			Debug.error("This project is using the legacy script system. You cannot call pc.registerScript().");
			return;
		}

		if (typeof script !== 'function') throw new Error("script class: '" + script + "' must be a constructor function (i.e. class).");
		if (!(script.prototype instanceof ScriptType)) throw new Error("script class: '" + ScriptType.__getScriptName(script) + "' does not extend pc.ScriptType.");
		name = name || script.__name || ScriptType.__getScriptName(script);
		if (reservedScriptNames.has(name)) throw new Error("script name: '" + name + "' is reserved, please change script name");
		script.__name = name;
		var registry = app ? app.scripts : Application.getApplication().scripts;
		registry.add(script);

		ScriptHandler._push(script);
	}

	var KeyboardEvent = function KeyboardEvent(keyboard, event) {
		if (event) {
			this.key = event.keyCode;
			this.element = event.target;
			this.event = event;
		} else {
			this.key = null;
			this.element = null;
			this.event = null;
		}
	};

	var _keyboardEvent = new KeyboardEvent();

	function makeKeyboardEvent(event) {
		_keyboardEvent.key = event.keyCode;
		_keyboardEvent.element = event.target;
		_keyboardEvent.event = event;
		return _keyboardEvent;
	}

	function toKeyCode(s) {
		if (typeof s === "string") {
			return s.toUpperCase().charCodeAt(0);
		}

		return s;
	}

	var _keyCodeToKeyIdentifier = {
		'9': 'Tab',
		'13': 'Enter',
		'16': 'Shift',
		'17': 'Control',
		'18': 'Alt',
		'27': 'Escape',
		'37': 'Left',
		'38': 'Up',
		'39': 'Right',
		'40': 'Down',
		'46': 'Delete',
		'91': 'Win'
	};

	var Keyboard = function (_EventHandler) {
		_inheritsLoose(Keyboard, _EventHandler);

		function Keyboard(element, options) {
			var _this;

			if (options === void 0) {
				options = {};
			}

			_this = _EventHandler.call(this) || this;
			_this._element = null;
			_this._keyDownHandler = _this._handleKeyDown.bind(_assertThisInitialized(_this));
			_this._keyUpHandler = _this._handleKeyUp.bind(_assertThisInitialized(_this));
			_this._keyPressHandler = _this._handleKeyPress.bind(_assertThisInitialized(_this));
			_this._visibilityChangeHandler = _this._handleVisibilityChange.bind(_assertThisInitialized(_this));
			_this._windowBlurHandler = _this._handleWindowBlur.bind(_assertThisInitialized(_this));
			_this._keymap = {};
			_this._lastmap = {};

			if (element) {
				_this.attach(element);
			}

			_this.preventDefault = options.preventDefault || false;
			_this.stopPropagation = options.stopPropagation || false;
			return _this;
		}

		var _proto = Keyboard.prototype;

		_proto.attach = function attach(element) {
			if (this._element) {
				this.detach();
			}

			this._element = element;

			this._element.addEventListener("keydown", this._keyDownHandler, false);

			this._element.addEventListener("keypress", this._keyPressHandler, false);

			this._element.addEventListener("keyup", this._keyUpHandler, false);

			document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
			window.addEventListener('blur', this._windowBlurHandler, false);
		};

		_proto.detach = function detach() {
			if (!this._element) {
				Debug.warn('Unable to detach keyboard. It is not attached to an element.');
				return;
			}

			this._element.removeEventListener("keydown", this._keyDownHandler);

			this._element.removeEventListener("keypress", this._keyPressHandler);

			this._element.removeEventListener("keyup", this._keyUpHandler);

			this._element = null;
			document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
			window.removeEventListener('blur', this._windowBlurHandler, false);
		};

		_proto.toKeyIdentifier = function toKeyIdentifier(keyCode) {
			keyCode = toKeyCode(keyCode);

			var id = _keyCodeToKeyIdentifier[keyCode.toString()];

			if (id) {
				return id;
			}

			var hex = keyCode.toString(16).toUpperCase();
			var length = hex.length;

			for (var count = 0; count < 4 - length; count++) {
				hex = '0' + hex;
			}

			return 'U+' + hex;
		};

		_proto._handleKeyDown = function _handleKeyDown(event) {
			var code = event.keyCode || event.charCode;
			if (code === undefined) return;
			var id = this.toKeyIdentifier(code);
			this._keymap[id] = true;
			this.fire("keydown", makeKeyboardEvent(event));

			if (this.preventDefault) {
				event.preventDefault();
			}

			if (this.stopPropagation) {
				event.stopPropagation();
			}
		};

		_proto._handleKeyUp = function _handleKeyUp(event) {
			var code = event.keyCode || event.charCode;
			if (code === undefined) return;
			var id = this.toKeyIdentifier(code);
			delete this._keymap[id];
			this.fire("keyup", makeKeyboardEvent(event));

			if (this.preventDefault) {
				event.preventDefault();
			}

			if (this.stopPropagation) {
				event.stopPropagation();
			}
		};

		_proto._handleKeyPress = function _handleKeyPress(event) {
			this.fire("keypress", makeKeyboardEvent(event));

			if (this.preventDefault) {
				event.preventDefault();
			}

			if (this.stopPropagation) {
				event.stopPropagation();
			}
		};

		_proto._handleVisibilityChange = function _handleVisibilityChange() {
			if (document.visibilityState === 'hidden') {
				this._handleWindowBlur();
			}
		};

		_proto._handleWindowBlur = function _handleWindowBlur() {
			this._keymap = {};
			this._lastmap = {};
		};

		_proto.update = function update() {
			for (var prop in this._lastmap) {
				delete this._lastmap[prop];
			}

			for (var _prop in this._keymap) {
				if (this._keymap.hasOwnProperty(_prop)) {
					this._lastmap[_prop] = this._keymap[_prop];
				}
			}
		};

		_proto.isPressed = function isPressed(key) {
			var keyCode = toKeyCode(key);
			var id = this.toKeyIdentifier(keyCode);
			return !!this._keymap[id];
		};

		_proto.wasPressed = function wasPressed(key) {
			var keyCode = toKeyCode(key);
			var id = this.toKeyIdentifier(keyCode);
			return !!this._keymap[id] && !!!this._lastmap[id];
		};

		_proto.wasReleased = function wasReleased(key) {
			var keyCode = toKeyCode(key);
			var id = this.toKeyIdentifier(keyCode);
			return !!!this._keymap[id] && !!this._lastmap[id];
		};

		return Keyboard;
	}(EventHandler);

	function isMousePointerLocked() {
		return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
	}

	var MouseEvent = function MouseEvent(mouse, event) {
		var coords = {
			x: 0,
			y: 0
		};

		if (event) {
			if (event instanceof MouseEvent) {
				throw Error("Expected MouseEvent");
			}

			coords = mouse._getTargetCoords(event);
		} else {
			event = {};
		}

		if (coords) {
			this.x = coords.x;
			this.y = coords.y;
		} else if (isMousePointerLocked()) {
			this.x = 0;
			this.y = 0;
		} else {
			return;
		}

		this.wheelDelta = 0;

		if (event.type === 'wheel') {
			if (event.deltaY > 0) {
				this.wheelDelta = 1;
			} else if (event.deltaY < 0) {
				this.wheelDelta = -1;
			}
		}

		if (isMousePointerLocked()) {
			this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
			this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
		} else {
			this.dx = this.x - mouse._lastX;
			this.dy = this.y - mouse._lastY;
		}

		if (event.type === 'mousedown' || event.type === 'mouseup') {
			this.button = event.button;
		} else {
			this.button = MOUSEBUTTON_NONE;
		}

		this.buttons = mouse._buttons.slice(0);
		this.element = event.target;
		this.ctrlKey = event.ctrlKey || false;
		this.altKey = event.altKey || false;
		this.shiftKey = event.shiftKey || false;
		this.metaKey = event.metaKey || false;
		this.event = event;
	};

	var Mouse = function (_EventHandler) {
		_inheritsLoose(Mouse, _EventHandler);

		function Mouse(element) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._lastX = 0;
			_this._lastY = 0;
			_this._buttons = [false, false, false];
			_this._lastbuttons = [false, false, false];
			_this._upHandler = _this._handleUp.bind(_assertThisInitialized(_this));
			_this._downHandler = _this._handleDown.bind(_assertThisInitialized(_this));
			_this._moveHandler = _this._handleMove.bind(_assertThisInitialized(_this));
			_this._wheelHandler = _this._handleWheel.bind(_assertThisInitialized(_this));

			_this._contextMenuHandler = function (event) {
				event.preventDefault();
			};

			_this._target = null;
			_this._attached = false;

			_this.attach(element);

			return _this;
		}

		Mouse.isPointerLocked = function isPointerLocked() {
			return isMousePointerLocked();
		};

		var _proto = Mouse.prototype;

		_proto.attach = function attach(element) {
			this._target = element;
			if (this._attached) return;
			this._attached = true;
			var opts = platform.passiveEvents ? {
				passive: false
			} : false;
			window.addEventListener("mouseup", this._upHandler, opts);
			window.addEventListener("mousedown", this._downHandler, opts);
			window.addEventListener("mousemove", this._moveHandler, opts);
			window.addEventListener("wheel", this._wheelHandler, opts);
		};

		_proto.detach = function detach() {
			if (!this._attached) return;
			this._attached = false;
			this._target = null;
			var opts = platform.passiveEvents ? {
				passive: false
			} : false;
			window.removeEventListener("mouseup", this._upHandler, opts);
			window.removeEventListener("mousedown", this._downHandler, opts);
			window.removeEventListener("mousemove", this._moveHandler, opts);
			window.removeEventListener("wheel", this._wheelHandler, opts);
		};

		_proto.disableContextMenu = function disableContextMenu() {
			if (!this._target) return;

			this._target.addEventListener("contextmenu", this._contextMenuHandler);
		};

		_proto.enableContextMenu = function enableContextMenu() {
			if (!this._target) return;

			this._target.removeEventListener("contextmenu", this._contextMenuHandler);
		};

		_proto.enablePointerLock = function enablePointerLock(success, error) {
			if (!document.body.requestPointerLock) {
				if (error) error();
				return;
			}

			var s = function s() {
				success();
				document.removeEventListener('pointerlockchange', s);
			};

			var e = function e() {
				error();
				document.removeEventListener('pointerlockerror', e);
			};

			if (success) {
				document.addEventListener('pointerlockchange', s, false);
			}

			if (error) {
				document.addEventListener('pointerlockerror', e, false);
			}

			document.body.requestPointerLock();
		};

		_proto.disablePointerLock = function disablePointerLock(success) {
			if (!document.exitPointerLock) {
				return;
			}

			var s = function s() {
				success();
				document.removeEventListener('pointerlockchange', s);
			};

			if (success) {
				document.addEventListener('pointerlockchange', s, false);
			}

			document.exitPointerLock();
		};

		_proto.update = function update() {
			this._lastbuttons[0] = this._buttons[0];
			this._lastbuttons[1] = this._buttons[1];
			this._lastbuttons[2] = this._buttons[2];
		};

		_proto.isPressed = function isPressed(button) {
			return this._buttons[button];
		};

		_proto.wasPressed = function wasPressed(button) {
			return this._buttons[button] && !this._lastbuttons[button];
		};

		_proto.wasReleased = function wasReleased(button) {
			return !this._buttons[button] && this._lastbuttons[button];
		};

		_proto._handleUp = function _handleUp(event) {
			this._buttons[event.button] = false;
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEUP, e);
		};

		_proto._handleDown = function _handleDown(event) {
			this._buttons[event.button] = true;
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEDOWN, e);
		};

		_proto._handleMove = function _handleMove(event) {
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEMOVE, e);
			this._lastX = e.x;
			this._lastY = e.y;
		};

		_proto._handleWheel = function _handleWheel(event) {
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEWHEEL, e);
		};

		_proto._getTargetCoords = function _getTargetCoords(event) {
			var rect = this._target.getBoundingClientRect();

			var left = Math.floor(rect.left);
			var top = Math.floor(rect.top);

			if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
				return null;
			}

			return {
				x: event.clientX - left,
				y: event.clientY - top
			};
		};

		return Mouse;
	}(EventHandler);

	var Controller = function () {
		function Controller(element, options) {
			if (options === void 0) {
				options = {};
			}

			this._keyboard = options.keyboard || null;
			this._mouse = options.mouse || null;
			this._gamepads = options.gamepads || null;
			this._element = null;
			this._actions = {};
			this._axes = {};
			this._axesValues = {};

			if (element) {
				this.attach(element);
			}
		}

		var _proto = Controller.prototype;

		_proto.attach = function attach(element) {
			this._element = element;

			if (this._keyboard) {
				this._keyboard.attach(element);
			}

			if (this._mouse) {
				this._mouse.attach(element);
			}
		};

		_proto.detach = function detach() {
			if (this._keyboard) {
				this._keyboard.detach();
			}

			if (this._mouse) {
				this._mouse.detach();
			}

			this._element = null;
		};

		_proto.disableContextMenu = function disableContextMenu() {
			if (!this._mouse) {
				this._enableMouse();
			}

			this._mouse.disableContextMenu();
		};

		_proto.enableContextMenu = function enableContextMenu() {
			if (!this._mouse) {
				this._enableMouse();
			}

			this._mouse.enableContextMenu();
		};

		_proto.update = function update(dt) {
			if (this._keyboard) {
				this._keyboard.update();
			}

			if (this._mouse) {
				this._mouse.update();
			}

			if (this._gamepads) {
				this._gamepads.update();
			}

			this._axesValues = {};

			for (var key in this._axes) {
				this._axesValues[key] = [];
			}
		};

		_proto.registerKeys = function registerKeys(action, keys) {
			if (!this._keyboard) {
				this._enableKeyboard();
			}

			if (this._actions[action]) {
				throw new Error("Action: " + action + " already registered");
			}

			if (keys === undefined) {
				throw new Error("Invalid button");
			}

			if (!keys.length) {
				keys = [keys];
			}

			if (this._actions[action]) {
				this._actions[action].push({
					type: ACTION_KEYBOARD,
					keys: keys
				});
			} else {
				this._actions[action] = [{
					type: ACTION_KEYBOARD,
					keys: keys
				}];
			}
		};

		_proto.registerMouse = function registerMouse(action, button) {
			if (!this._mouse) {
				this._enableMouse();
			}

			if (button === undefined) {
				throw new Error('Invalid button');
			}

			if (this._actions[action]) {
				this._actions[action].push({
					type: ACTION_MOUSE,
					button: button
				});
			} else {
				this._actions[action] = [{
					type: ACTION_MOUSE,
					button: -button
				}];
			}
		};

		_proto.registerPadButton = function registerPadButton(action, pad, button) {
			if (button === undefined) {
				throw new Error('Invalid button');
			}

			if (this._actions[action]) {
				this._actions[action].push({
					type: ACTION_GAMEPAD,
					button: button,
					pad: pad
				});
			} else {
				this._actions[action] = [{
					type: ACTION_GAMEPAD,
					button: button,
					pad: pad
				}];
			}
		};

		_proto.registerAxis = function registerAxis(options) {
			var name = options.name;

			if (!this._axes[name]) {
				this._axes[name] = [];
			}

			var i = this._axes[name].push(name);

			options = options || {};
			options.pad = options.pad || PAD_1;

			var bind = function bind(controller, source, value, key) {
				switch (source) {
					case 'mousex':
						controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
							controller._axesValues[name][i] = e.dx / 10;
						});

						break;

					case 'mousey':
						controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
							controller._axesValues[name][i] = e.dy / 10;
						});

						break;

					case 'key':
						controller._axes[name].push(function () {
							return controller._keyboard.isPressed(key) ? value : 0;
						});

						break;

					case 'padrx':
						controller._axes[name].push(function () {
							return controller._gamepads.getAxis(options.pad, PAD_R_STICK_X);
						});

						break;

					case 'padry':
						controller._axes[name].push(function () {
							return controller._gamepads.getAxis(options.pad, PAD_R_STICK_Y);
						});

						break;

					case 'padlx':
						controller._axes[name].push(function () {
							return controller._gamepads.getAxis(options.pad, PAD_L_STICK_X);
						});

						break;

					case 'padly':
						controller._axes[name].push(function () {
							return controller._gamepads.getAxis(options.pad, PAD_L_STICK_Y);
						});

						break;

					default:
						throw new Error('Unknown axis');
				}
			};

			bind(this, options.positive, 1, options.positiveKey);

			if (options.negativeKey || options.negative !== options.positive) {
				bind(this, options.negative, -1, options.negativeKey);
			}
		};

		_proto.isPressed = function isPressed(actionName) {
			if (!this._actions[actionName]) {
				return false;
			}

			var length = this._actions[actionName].length;

			for (var index = 0; index < length; ++index) {
				var action = this._actions[actionName][index];

				switch (action.type) {
					case ACTION_KEYBOARD:
						if (this._keyboard) {
							var len = action.keys.length;

							for (var i = 0; i < len; i++) {
								if (this._keyboard.isPressed(action.keys[i])) {
									return true;
								}
							}
						}

						break;

					case ACTION_MOUSE:
						if (this._mouse && this._mouse.isPressed(action.button)) {
							return true;
						}

						break;

					case ACTION_GAMEPAD:
						if (this._gamepads && this._gamepads.isPressed(action.pad, action.button)) {
							return true;
						}

						break;
				}
			}

			return false;
		};

		_proto.wasPressed = function wasPressed(actionName) {
			if (!this._actions[actionName]) {
				return false;
			}

			var length = this._actions[actionName].length;

			for (var index = 0; index < length; ++index) {
				var action = this._actions[actionName][index];

				switch (action.type) {
					case ACTION_KEYBOARD:
						if (this._keyboard) {
							var len = action.keys.length;

							for (var i = 0; i < len; i++) {
								if (this._keyboard.wasPressed(action.keys[i])) {
									return true;
								}
							}
						}

						break;

					case ACTION_MOUSE:
						if (this._mouse && this._mouse.wasPressed(action.button)) {
							return true;
						}

						break;

					case ACTION_GAMEPAD:
						if (this._gamepads && this._gamepads.wasPressed(action.pad, action.button)) {
							return true;
						}

						break;
				}
			}

			return false;
		};

		_proto.getAxis = function getAxis(name) {
			var value = 0;

			if (this._axes[name]) {
				var len = this._axes[name].length;

				for (var i = 0; i < len; i++) {
					if (type$1(this._axes[name][i]) === 'function') {
						var v = this._axes[name][i]();

						if (Math.abs(v) > Math.abs(value)) {
							value = v;
						}
					} else if (this._axesValues[name]) {
						if (Math.abs(this._axesValues[name][i]) > Math.abs(value)) {
							value = this._axesValues[name][i];
						}
					}
				}
			}

			return value;
		};

		_proto._enableMouse = function _enableMouse() {
			this._mouse = new Mouse();

			if (!this._element) {
				throw new Error("Controller must be attached to an Element");
			}

			this._mouse.attach(this._element);
		};

		_proto._enableKeyboard = function _enableKeyboard() {
			this._keyboard = new Keyboard();

			if (!this._element) {
				throw new Error("Controller must be attached to an Element");
			}

			this._keyboard.attach(this._element);
		};

		return Controller;
	}();

	var targetX, targetY;
	var vecA = new Vec3();
	var vecB = new Vec3();
	var rayA = new Ray();
	var rayB = new Ray();
	var rayC = new Ray();
	rayA.end = new Vec3();
	rayB.end = new Vec3();
	rayC.end = new Vec3();

	var _pq = new Vec3();

	var _pa = new Vec3();

	var _pb = new Vec3();

	var _pc = new Vec3();

	var _pd = new Vec3();

	var _m = new Vec3();

	var _au = new Vec3();

	var _bv = new Vec3();

	var _cw = new Vec3();

	var _ir = new Vec3();

	var _sct = new Vec3();

	var _accumulatedScale = new Vec3();

	var _paddingTop = new Vec3();

	var _paddingBottom = new Vec3();

	var _paddingLeft = new Vec3();

	var _paddingRight = new Vec3();

	var _cornerBottomLeft = new Vec3();

	var _cornerBottomRight = new Vec3();

	var _cornerTopRight = new Vec3();

	var _cornerTopLeft = new Vec3();

	var ZERO_VEC4 = new Vec4();

	function scalarTriple(p1, p2, p3) {
		return _sct.cross(p1, p2).dot(p3);
	}

	function intersectLineQuad(p, q, corners) {
		_pq.sub2(q, p);

		_pa.sub2(corners[0], p);

		_pb.sub2(corners[1], p);

		_pc.sub2(corners[2], p);

		_m.cross(_pc, _pq);

		var v = _pa.dot(_m);

		var u;
		var w;

		if (v >= 0) {
			u = -_pb.dot(_m);
			if (u < 0) return -1;
			w = scalarTriple(_pq, _pb, _pa);
			if (w < 0) return -1;
			var denom = 1.0 / (u + v + w);

			_au.copy(corners[0]).mulScalar(u * denom);

			_bv.copy(corners[1]).mulScalar(v * denom);

			_cw.copy(corners[2]).mulScalar(w * denom);

			_ir.copy(_au).add(_bv).add(_cw);
		} else {
			_pd.sub2(corners[3], p);

			u = _pd.dot(_m);
			if (u < 0) return -1;
			w = scalarTriple(_pq, _pa, _pd);
			if (w < 0) return -1;
			v = -v;

			var _denom = 1.0 / (u + v + w);

			_au.copy(corners[0]).mulScalar(u * _denom);

			_bv.copy(corners[3]).mulScalar(v * _denom);

			_cw.copy(corners[2]).mulScalar(w * _denom);

			_ir.copy(_au).add(_bv).add(_cw);
		}

		if (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) return -1;
		if (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) return -1;
		return _ir.sub(p).lengthSq();
	}

	var ElementInputEvent = function () {
		function ElementInputEvent(event, element, camera) {
			this.event = event;
			this.element = element;
			this.camera = camera;
			this._stopPropagation = false;
		}

		var _proto = ElementInputEvent.prototype;

		_proto.stopPropagation = function stopPropagation() {
			this._stopPropagation = true;

			if (this.event) {
				this.event.stopImmediatePropagation();
				this.event.stopPropagation();
			}
		};

		return ElementInputEvent;
	}();

	var ElementMouseEvent = function (_ElementInputEvent) {
		_inheritsLoose(ElementMouseEvent, _ElementInputEvent);

		function ElementMouseEvent(event, element, camera, x, y, lastX, lastY) {
			var _this;

			_this = _ElementInputEvent.call(this, event, element, camera) || this;
			_this.x = x;
			_this.y = y;
			_this.ctrlKey = event.ctrlKey || false;
			_this.altKey = event.altKey || false;
			_this.shiftKey = event.shiftKey || false;
			_this.metaKey = event.metaKey || false;
			_this.button = event.button;

			if (Mouse.isPointerLocked()) {
				_this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
				_this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
			} else {
				_this.dx = x - lastX;
				_this.dy = y - lastY;
			}

			_this.wheelDelta = 0;

			if (event.type === 'wheel') {
				if (event.deltaY > 0) {
					_this.wheelDelta = 1;
				} else if (event.deltaY < 0) {
					_this.wheelDelta = -1;
				}
			}

			return _this;
		}

		return ElementMouseEvent;
	}(ElementInputEvent);

	var ElementTouchEvent = function (_ElementInputEvent2) {
		_inheritsLoose(ElementTouchEvent, _ElementInputEvent2);

		function ElementTouchEvent(event, element, camera, x, y, touch) {
			var _this2;

			_this2 = _ElementInputEvent2.call(this, event, element, camera) || this;
			_this2.touches = event.touches;
			_this2.changedTouches = event.changedTouches;
			_this2.x = x;
			_this2.y = y;
			_this2.touch = touch;
			return _this2;
		}

		return ElementTouchEvent;
	}(ElementInputEvent);

	var ElementSelectEvent = function (_ElementInputEvent3) {
		_inheritsLoose(ElementSelectEvent, _ElementInputEvent3);

		function ElementSelectEvent(event, element, camera, inputSource) {
			var _this3;

			_this3 = _ElementInputEvent3.call(this, event, element, camera) || this;
			_this3.inputSource = inputSource;
			return _this3;
		}

		return ElementSelectEvent;
	}(ElementInputEvent);

	var ElementInput = function () {
		function ElementInput(domElement, options) {
			this._app = null;
			this._attached = false;
			this._target = null;
			this._enabled = true;
			this._lastX = 0;
			this._lastY = 0;
			this._upHandler = this._handleUp.bind(this);
			this._downHandler = this._handleDown.bind(this);
			this._moveHandler = this._handleMove.bind(this);
			this._wheelHandler = this._handleWheel.bind(this);
			this._touchstartHandler = this._handleTouchStart.bind(this);
			this._touchendHandler = this._handleTouchEnd.bind(this);
			this._touchcancelHandler = this._touchendHandler;
			this._touchmoveHandler = this._handleTouchMove.bind(this);
			this._sortHandler = this._sortElements.bind(this);
			this._elements = [];
			this._hoveredElement = null;
			this._pressedElement = null;
			this._touchedElements = {};
			this._touchesForWhichTouchLeaveHasFired = {};
			this._selectedElements = {};
			this._selectedPressedElements = {};
			this._useMouse = !options || options.useMouse !== false;
			this._useTouch = !options || options.useTouch !== false;
			this._useXr = !options || options.useXr !== false;
			this._selectEventsAttached = false;
			if (platform.touch) this._clickedEntities = {};
			this.attach(domElement);
		}

		var _proto2 = ElementInput.prototype;

		_proto2.attach = function attach(domElement) {
			if (this._attached) {
				this._attached = false;
				this.detach();
			}

			this._target = domElement;
			this._attached = true;
			var opts = platform.passiveEvents ? {
				passive: true
			} : false;

			if (this._useMouse) {
				window.addEventListener('mouseup', this._upHandler, opts);
				window.addEventListener('mousedown', this._downHandler, opts);
				window.addEventListener('mousemove', this._moveHandler, opts);
				window.addEventListener('wheel', this._wheelHandler, opts);
			}

			if (this._useTouch && platform.touch) {
				this._target.addEventListener('touchstart', this._touchstartHandler, opts);

				this._target.addEventListener('touchend', this._touchendHandler, false);

				this._target.addEventListener('touchmove', this._touchmoveHandler, false);

				this._target.addEventListener('touchcancel', this._touchcancelHandler, false);
			}

			this.attachSelectEvents();
		};

		_proto2.attachSelectEvents = function attachSelectEvents() {
			if (!this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported) {
				if (!this._clickedEntities) this._clickedEntities = {};
				this._selectEventsAttached = true;
				this.app.xr.on('start', this._onXrStart, this);
			}
		};

		_proto2.detach = function detach() {
			if (!this._attached) return;
			this._attached = false;
			var opts = platform.passiveEvents ? {
				passive: true
			} : false;

			if (this._useMouse) {
				window.removeEventListener('mouseup', this._upHandler, opts);
				window.removeEventListener('mousedown', this._downHandler, opts);
				window.removeEventListener('mousemove', this._moveHandler, opts);
				window.removeEventListener('wheel', this._wheelHandler, opts);
			}

			if (this._useTouch) {
				this._target.removeEventListener('touchstart', this._touchstartHandler, opts);

				this._target.removeEventListener('touchend', this._touchendHandler, false);

				this._target.removeEventListener('touchmove', this._touchmoveHandler, false);

				this._target.removeEventListener('touchcancel', this._touchcancelHandler, false);
			}

			if (this._selectEventsAttached) {
				this._selectEventsAttached = false;
				this.app.xr.off('start', this._onXrStart, this);
				this.app.xr.off('end', this._onXrEnd, this);
				this.app.xr.off('update', this._onXrUpdate, this);
				this.app.xr.input.off('selectstart', this._onSelectStart, this);
				this.app.xr.input.off('selectend', this._onSelectEnd, this);
				this.app.xr.input.off('remove', this._onXrInputRemove, this);
			}

			this._target = null;
		};

		_proto2.addElement = function addElement(element) {
			if (this._elements.indexOf(element) === -1) this._elements.push(element);
		};

		_proto2.removeElement = function removeElement(element) {
			var idx = this._elements.indexOf(element);

			if (idx !== -1) this._elements.splice(idx, 1);
		};

		_proto2._handleUp = function _handleUp(event) {
			if (!this._enabled) return;
			if (Mouse.isPointerLocked()) return;

			this._calcMouseCoords(event);

			if (targetX === null) return;

			this._onElementMouseEvent('mouseup', event);
		};

		_proto2._handleDown = function _handleDown(event) {
			if (!this._enabled) return;
			if (Mouse.isPointerLocked()) return;

			this._calcMouseCoords(event);

			if (targetX === null) return;

			this._onElementMouseEvent('mousedown', event);
		};

		_proto2._handleMove = function _handleMove(event) {
			if (!this._enabled) return;

			this._calcMouseCoords(event);

			if (targetX === null) return;

			this._onElementMouseEvent('mousemove', event);

			this._lastX = targetX;
			this._lastY = targetY;
		};

		_proto2._handleWheel = function _handleWheel(event) {
			if (!this._enabled) return;

			this._calcMouseCoords(event);

			if (targetX === null) return;

			this._onElementMouseEvent('mousewheel', event);
		};

		_proto2._determineTouchedElements = function _determineTouchedElements(event) {
			var touchedElements = {};
			var cameras = this.app.systems.camera.cameras;

			for (var i = cameras.length - 1; i >= 0; i--) {
				var camera = cameras[i];
				var done = 0;
				var len = event.changedTouches.length;

				for (var j = 0; j < len; j++) {
					if (touchedElements[event.changedTouches[j].identifier]) {
						done++;
						continue;
					}

					var coords = this._calcTouchCoords(event.changedTouches[j]);

					var element = this._getTargetElement(camera, coords.x, coords.y);

					if (element) {
						done++;
						touchedElements[event.changedTouches[j].identifier] = {
							element: element,
							camera: camera,
							x: coords.x,
							y: coords.y
						};
					}
				}

				if (done === len) {
					break;
				}
			}

			return touchedElements;
		};

		_proto2._handleTouchStart = function _handleTouchStart(event) {
			if (!this._enabled) return;

			var newTouchedElements = this._determineTouchedElements(event);

			for (var i = 0, len = event.changedTouches.length; i < len; i++) {
				var touch = event.changedTouches[i];
				var newTouchInfo = newTouchedElements[touch.identifier];
				var oldTouchInfo = this._touchedElements[touch.identifier];

				if (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {
					this._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, touch));

					this._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;
				}
			}

			for (var touchId in newTouchedElements) {
				this._touchedElements[touchId] = newTouchedElements[touchId];
			}
		};

		_proto2._handleTouchEnd = function _handleTouchEnd(event) {
			if (!this._enabled) return;
			var cameras = this.app.systems.camera.cameras;

			for (var key in this._clickedEntities) {
				delete this._clickedEntities[key];
			}

			for (var i = 0, len = event.changedTouches.length; i < len; i++) {
				var touch = event.changedTouches[i];
				var touchInfo = this._touchedElements[touch.identifier];
				if (!touchInfo) continue;
				var element = touchInfo.element;
				var camera = touchInfo.camera;
				var x = touchInfo.x;
				var y = touchInfo.y;
				delete this._touchedElements[touch.identifier];
				delete this._touchesForWhichTouchLeaveHasFired[touch.identifier];

				this._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, touch));

				if (event.touches.length === 0) {
					var coords = this._calcTouchCoords(touch);

					for (var c = cameras.length - 1; c >= 0; c--) {
						var hovered = this._getTargetElement(cameras[c], coords.x, coords.y);

						if (hovered === element) {
							if (!this._clickedEntities[element.entity.getGuid()]) {
								this._fireEvent('click', new ElementTouchEvent(event, element, camera, x, y, touch));

								this._clickedEntities[element.entity.getGuid()] = true;
							}
						}
					}
				}
			}
		};

		_proto2._handleTouchMove = function _handleTouchMove(event) {
			event.preventDefault();
			if (!this._enabled) return;

			var newTouchedElements = this._determineTouchedElements(event);

			for (var i = 0, len = event.changedTouches.length; i < len; i++) {
				var touch = event.changedTouches[i];
				var newTouchInfo = newTouchedElements[touch.identifier];
				var oldTouchInfo = this._touchedElements[touch.identifier];

				if (oldTouchInfo) {
					var coords = this._calcTouchCoords(touch);

					if ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {
						this._fireEvent('touchleave', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));

						this._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;
					}

					this._fireEvent('touchmove', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));
				}
			}
		};

		_proto2._onElementMouseEvent = function _onElementMouseEvent(eventType, event) {
			var element;
			var hovered = this._hoveredElement;
			this._hoveredElement = null;
			var cameras = this.app.systems.camera.cameras;
			var camera;

			for (var i = cameras.length - 1; i >= 0; i--) {
				camera = cameras[i];
				element = this._getTargetElement(camera, targetX, targetY);
				if (element) break;
			}

			if (element) {
				this._fireEvent(eventType, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));

				this._hoveredElement = element;

				if (eventType === 'mousedown') {
					this._pressedElement = element;
				}
			}

			if (hovered !== this._hoveredElement) {
				if (hovered) {
					this._fireEvent('mouseleave', new ElementMouseEvent(event, hovered, camera, targetX, targetY, this._lastX, this._lastY));
				}

				if (this._hoveredElement) {
					this._fireEvent('mouseenter', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
				}
			}

			if (eventType === 'mouseup' && this._pressedElement) {
				if (this._pressedElement === this._hoveredElement) {
					this._pressedElement = null;

					if (!this._clickedEntities || !this._clickedEntities[this._hoveredElement.entity.getGuid()]) {
						this._fireEvent('click', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
					}
				} else {
					this._pressedElement = null;
				}
			}
		};

		_proto2._onXrStart = function _onXrStart() {
			this.app.xr.on('end', this._onXrEnd, this);
			this.app.xr.on('update', this._onXrUpdate, this);
			this.app.xr.input.on('selectstart', this._onSelectStart, this);
			this.app.xr.input.on('selectend', this._onSelectEnd, this);
			this.app.xr.input.on('remove', this._onXrInputRemove, this);
		};

		_proto2._onXrEnd = function _onXrEnd() {
			this.app.xr.off('update', this._onXrUpdate, this);
			this.app.xr.input.off('selectstart', this._onSelectStart, this);
			this.app.xr.input.off('selectend', this._onSelectEnd, this);
			this.app.xr.input.off('remove', this._onXrInputRemove, this);
		};

		_proto2._onXrUpdate = function _onXrUpdate() {
			if (!this._enabled) return;
			var inputSources = this.app.xr.input.inputSources;

			for (var i = 0; i < inputSources.length; i++) {
				this._onElementSelectEvent('selectmove', inputSources[i], null);
			}
		};

		_proto2._onXrInputRemove = function _onXrInputRemove(inputSource) {
			var hovered = this._selectedElements[inputSource.id];

			if (hovered) {
				inputSource._elementEntity = null;

				this._fireEvent('selectleave', new ElementSelectEvent(null, hovered, null, inputSource));
			}

			delete this._selectedElements[inputSource.id];
			delete this._selectedPressedElements[inputSource.id];
		};

		_proto2._onSelectStart = function _onSelectStart(inputSource, event) {
			if (!this._enabled) return;

			this._onElementSelectEvent('selectstart', inputSource, event);
		};

		_proto2._onSelectEnd = function _onSelectEnd(inputSource, event) {
			if (!this._enabled) return;

			this._onElementSelectEvent('selectend', inputSource, event);
		};

		_proto2._onElementSelectEvent = function _onElementSelectEvent(eventType, inputSource, event) {
			var element;
			var hoveredBefore = this._selectedElements[inputSource.id];
			var hoveredNow;
			var cameras = this.app.systems.camera.cameras;
			var camera;

			if (inputSource.elementInput) {
				rayC.set(inputSource.getOrigin(), inputSource.getDirection());

				for (var i = cameras.length - 1; i >= 0; i--) {
					camera = cameras[i];
					element = this._getTargetElementByRay(rayC, camera);
					if (element) break;
				}
			}

			inputSource._elementEntity = element || null;

			if (element) {
				this._selectedElements[inputSource.id] = element;
				hoveredNow = element;
			} else {
				delete this._selectedElements[inputSource.id];
			}

			if (hoveredBefore !== hoveredNow) {
				if (hoveredBefore) this._fireEvent('selectleave', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
				if (hoveredNow) this._fireEvent('selectenter', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
			}

			if (eventType === 'selectstart') {
				this._selectedPressedElements[inputSource.id] = hoveredNow;
				if (hoveredNow) this._fireEvent('selectstart', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
			}

			var pressed = this._selectedPressedElements[inputSource.id];

			if (!inputSource.elementInput && pressed) {
				delete this._selectedPressedElements[inputSource.id];
				if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
			}

			if (eventType === 'selectend' && inputSource.elementInput) {
				delete this._selectedPressedElements[inputSource.id];
				if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));

				if (pressed && pressed === hoveredBefore) {
					this._fireEvent('click', new ElementSelectEvent(event, pressed, camera, inputSource));
				}
			}
		};

		_proto2._fireEvent = function _fireEvent(name, evt) {
			var element = evt.element;

			while (true) {
				element.fire(name, evt);
				if (evt._stopPropagation) break;
				if (!element.entity.parent) break;
				element = element.entity.parent.element;
				if (!element) break;
			}
		};

		_proto2._calcMouseCoords = function _calcMouseCoords(event) {
			var rect = this._target.getBoundingClientRect();

			var left = Math.floor(rect.left);
			var top = Math.floor(rect.top);

			if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
				targetX = null;
				targetY = null;
			} else {
				targetX = event.clientX - left;
				targetY = event.clientY - top;
			}
		};

		_proto2._calcTouchCoords = function _calcTouchCoords(touch) {
			var totalOffsetX = 0;
			var totalOffsetY = 0;
			var target = touch.target;

			while (!(target instanceof HTMLElement)) {
				target = target.parentNode;
			}

			var currentElement = target;

			do {
				totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
				totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
				currentElement = currentElement.offsetParent;
			} while (currentElement);

			return {
				x: touch.pageX - totalOffsetX,
				y: touch.pageY - totalOffsetY
			};
		};

		_proto2._sortElements = function _sortElements(a, b) {
			var layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);
			if (layerOrder !== 0) return layerOrder;
			if (a.screen && !b.screen) return -1;
			if (!a.screen && b.screen) return 1;
			if (!a.screen && !b.screen) return 0;
			if (a.screen.screen.screenSpace && !b.screen.screen.screenSpace) return -1;
			if (b.screen.screen.screenSpace && !a.screen.screen.screenSpace) return 1;
			return b.drawOrder - a.drawOrder;
		};

		_proto2._getTargetElement = function _getTargetElement(camera, x, y) {
			var result = null;
			var closestDistance3d = Infinity;

			this._elements.sort(this._sortHandler);

			var rayScreen, ray3d;

			for (var i = 0, len = this._elements.length; i < len; i++) {
				var element = this._elements[i];

				if (element.screen && element.screen.screen.screenSpace) {
					if (rayScreen === undefined) {
						rayScreen = this._calculateRayScreen(x, y, camera, rayA) ? rayA : null;
					}

					if (!rayScreen) continue;

					var currentDistance = this._checkElement(rayScreen, element, true);

					if (currentDistance >= 0) {
						result = element;
						break;
					}
				} else {
					if (ray3d === undefined) {
						ray3d = this._calculateRay3d(x, y, camera, rayB) ? rayB : null;
					}

					if (!ray3d) continue;

					var _currentDistance = this._checkElement(ray3d, element, false);

					if (_currentDistance >= 0) {
						if (_currentDistance < closestDistance3d) {
							result = element;
							closestDistance3d = _currentDistance;
						}

						if (element.screen) {
							result = element;
							break;
						}
					}
				}
			}

			return result;
		};

		_proto2._getTargetElementByRay = function _getTargetElementByRay(ray, camera) {
			var result = null;
			rayA.origin.copy(ray.origin);
			rayA.direction.copy(ray.direction);
			rayA.end.copy(rayA.direction).mulScalar(camera.farClip * 2).add(rayA.origin);

			this._elements.sort(this._sortHandler);

			for (var i = 0, len = this._elements.length; i < len; i++) {
				var element = this._elements[i];

				if (!element.screen || !element.screen.screen.screenSpace) {
					if (this._checkElement(rayA, element, false) >= 0) {
						result = element;
						break;
					}
				}
			}

			return result;
		};

		_proto2._buildHitCorners = function _buildHitCorners(element, screenOrWorldCorners, scaleX, scaleY, scaleZ) {
			var hitCorners = screenOrWorldCorners;
			var button = element.entity && element.entity.button;

			if (button) {
				var hitPadding = element.entity.button.hitPadding || ZERO_VEC4;

				_paddingTop.copy(element.entity.up);

				_paddingBottom.copy(_paddingTop).mulScalar(-1);

				_paddingRight.copy(element.entity.right);

				_paddingLeft.copy(_paddingRight).mulScalar(-1);

				_paddingTop.mulScalar(hitPadding.w * scaleY);

				_paddingBottom.mulScalar(hitPadding.y * scaleY);

				_paddingRight.mulScalar(hitPadding.z * scaleX);

				_paddingLeft.mulScalar(hitPadding.x * scaleX);

				_cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);

				_cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);

				_cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);

				_cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);

				hitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];
			}

			if (scaleX < 0) {
				var left = hitCorners[2].x;
				var right = hitCorners[0].x;
				hitCorners[0].x = left;
				hitCorners[1].x = right;
				hitCorners[2].x = right;
				hitCorners[3].x = left;
			}

			if (scaleY < 0) {
				var bottom = hitCorners[2].y;
				var top = hitCorners[0].y;
				hitCorners[0].y = bottom;
				hitCorners[1].y = bottom;
				hitCorners[2].y = top;
				hitCorners[3].y = top;
			}

			if (scaleZ < 0) {
				var x = hitCorners[2].x;
				var y = hitCorners[2].y;
				var z = hitCorners[2].z;
				hitCorners[2].x = hitCorners[0].x;
				hitCorners[2].y = hitCorners[0].y;
				hitCorners[2].z = hitCorners[0].z;
				hitCorners[0].x = x;
				hitCorners[0].y = y;
				hitCorners[0].z = z;
			}

			return hitCorners;
		};

		_proto2._calculateScaleToScreen = function _calculateScaleToScreen(element) {
			var current = element.entity;
			var screenScale = element.screen.screen.scale;

			_accumulatedScale.set(screenScale, screenScale, screenScale);

			while (current && !current.screen) {
				_accumulatedScale.mul(current.getLocalScale());

				current = current.parent;
			}

			return _accumulatedScale;
		};

		_proto2._calculateScaleToWorld = function _calculateScaleToWorld(element) {
			var current = element.entity;

			_accumulatedScale.set(1, 1, 1);

			while (current) {
				_accumulatedScale.mul(current.getLocalScale());

				current = current.parent;
			}

			return _accumulatedScale;
		};

		_proto2._calculateRayScreen = function _calculateRayScreen(x, y, camera, ray) {
			var sw = this.app.graphicsDevice.width;
			var sh = this.app.graphicsDevice.height;
			var cameraWidth = camera.rect.z * sw;
			var cameraHeight = camera.rect.w * sh;
			var cameraLeft = camera.rect.x * sw;
			var cameraRight = cameraLeft + cameraWidth;
			var cameraBottom = (1 - camera.rect.y) * sh;
			var cameraTop = cameraBottom - cameraHeight;

			var _x = x * sw / this._target.clientWidth;

			var _y = y * sh / this._target.clientHeight;

			if (_x >= cameraLeft && _x <= cameraRight && _y <= cameraBottom && _y >= cameraTop) {
				_x = sw * (_x - cameraLeft) / cameraWidth;
				_y = sh * (_y - cameraTop) / cameraHeight;
				_y = sh - _y;
				ray.origin.set(_x, _y, 1);
				ray.direction.set(0, 0, -1);
				ray.end.copy(ray.direction).mulScalar(2).add(ray.origin);
				return true;
			}

			return false;
		};

		_proto2._calculateRay3d = function _calculateRay3d(x, y, camera, ray) {
			var sw = this._target.clientWidth;
			var sh = this._target.clientHeight;
			var cameraWidth = camera.rect.z * sw;
			var cameraHeight = camera.rect.w * sh;
			var cameraLeft = camera.rect.x * sw;
			var cameraRight = cameraLeft + cameraWidth;
			var cameraBottom = (1 - camera.rect.y) * sh;
			var cameraTop = cameraBottom - cameraHeight;
			var _x = x;
			var _y = y;

			if (x >= cameraLeft && x <= cameraRight && y <= cameraBottom && _y >= cameraTop) {
				_x = sw * (_x - cameraLeft) / cameraWidth;
				_y = sh * (_y - cameraTop) / cameraHeight;
				camera.screenToWorld(_x, _y, camera.nearClip, vecA);
				camera.screenToWorld(_x, _y, camera.farClip, vecB);
				ray.origin.copy(vecA);
				ray.direction.set(0, 0, -1);
				ray.end.copy(vecB);
				return true;
			}

			return false;
		};

		_proto2._checkElement = function _checkElement(ray, element, screen) {
			if (element.maskedBy) {
				if (this._checkElement(ray, element.maskedBy.element, screen) < 0) {
					return -1;
				}
			}

			var scale;

			if (screen) {
				scale = this._calculateScaleToScreen(element);
			} else {
				scale = this._calculateScaleToWorld(element);
			}

			var corners = this._buildHitCorners(element, screen ? element.screenCorners : element.worldCorners, scale.x, scale.y, scale.z);

			return intersectLineQuad(ray.origin, ray.end, corners);
		};

		_createClass(ElementInput, [{
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				this._enabled = value;
			}
		}, {
			key: "app",
			get: function get() {
				return this._app || getApplication();
			},
			set: function set(value) {
				this._app = value;
			}
		}]);

		return ElementInput;
	}();

	var MAPS = {
		DEFAULT: {
			buttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_3', 'PAD_FACE_4', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],
			axes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y']
		},
		PS3: {
			buttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_4', 'PAD_FACE_3', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],
			axes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y']
		}
	};
	var PRODUCT_CODES = {
		'Product: 0268': 'PS3'
	};

	var GamePads = function () {
		function GamePads() {
			this.gamepadsSupported = !!navigator.getGamepads || !!navigator.webkitGetGamepads;
			this.current = [];
			this.previous = [];
			this.deadZone = 0.25;
		}

		var _proto = GamePads.prototype;

		_proto.update = function update() {
			for (var i = 0, l = this.current.length; i < l; i++) {
				var buttons = this.current[i].pad.buttons;
				var buttonsLen = buttons.length;

				for (var j = 0; j < buttonsLen; j++) {
					if (this.previous[i] === undefined) {
						this.previous[i] = [];
					}

					this.previous[i][j] = buttons[j].pressed;
				}
			}

			this.poll(this.current);
		};

		_proto.poll = function poll(pads) {
			if (pads === void 0) {
				pads = [];
			}

			if (pads.length > 0) {
				pads.length = 0;
			}

			if (this.gamepadsSupported) {
				var padDevices = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads();

				for (var i = 0, len = padDevices.length; i < len; i++) {
					if (padDevices[i]) {
						pads.push({
							map: this.getMap(padDevices[i]),
							pad: padDevices[i]
						});
					}
				}
			}

			return pads;
		};

		_proto.getMap = function getMap(pad) {
			for (var code in PRODUCT_CODES) {
				if (pad.id.indexOf(code) >= 0) {
					return MAPS[PRODUCT_CODES[code]];
				}
			}

			return MAPS.DEFAULT;
		};

		_proto.isPressed = function isPressed(index, button) {
			if (!this.current[index]) {
				return false;
			}

			var key = this.current[index].map.buttons[button];
			return this.current[index].pad.buttons[pc[key]].pressed;
		};

		_proto.wasPressed = function wasPressed(index, button) {
			if (!this.current[index]) {
				return false;
			}

			var key = this.current[index].map.buttons[button];
			var i = pc[key];
			return this.current[index].pad.buttons[i].pressed && !(this.previous[index] && this.previous[index][i]);
		};

		_proto.wasReleased = function wasReleased(index, button) {
			if (!this.current[index]) {
				return false;
			}

			var key = this.current[index].map.buttons[button];
			var i = pc[key];
			return !this.current[index].pad.buttons[i].pressed && this.previous[index] && this.previous[index][i];
		};

		_proto.getAxis = function getAxis(index, axes) {
			if (!this.current[index]) {
				return 0;
			}

			var key = this.current[index].map.axes[axes];
			var value = this.current[index].pad.axes[pc[key]];

			if (Math.abs(value) < this.deadZone) {
				value = 0;
			}

			return value;
		};

		return GamePads;
	}();

	function getTouchTargetCoords(touch) {
		var totalOffsetX = 0;
		var totalOffsetY = 0;
		var target = touch.target;

		while (!(target instanceof HTMLElement)) {
			target = target.parentNode;
		}

		var currentElement = target;

		do {
			totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
			totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
			currentElement = currentElement.offsetParent;
		} while (currentElement);

		return {
			x: touch.pageX - totalOffsetX,
			y: touch.pageY - totalOffsetY
		};
	}

	var Touch = function Touch(touch) {
		var coords = getTouchTargetCoords(touch);
		this.id = touch.identifier;
		this.x = coords.x;
		this.y = coords.y;
		this.target = touch.target;
		this.touch = touch;
	};

	var TouchEvent = function () {
		function TouchEvent(device, event) {
			this.element = event.target;
			this.event = event;
			this.touches = [];
			this.changedTouches = [];

			if (event) {
				for (var i = 0, l = event.touches.length; i < l; i++) {
					this.touches.push(new Touch(event.touches[i]));
				}

				for (var _i = 0, _l = event.changedTouches.length; _i < _l; _i++) {
					this.changedTouches.push(new Touch(event.changedTouches[_i]));
				}
			}
		}

		var _proto = TouchEvent.prototype;

		_proto.getTouchById = function getTouchById(id, list) {
			for (var i = 0, l = list.length; i < l; i++) {
				if (list[i].id === id) {
					return list[i];
				}
			}

			return null;
		};

		return TouchEvent;
	}();

	var TouchDevice = function (_EventHandler) {
		_inheritsLoose(TouchDevice, _EventHandler);

		function TouchDevice(element) {
			var _this;

			_this = _EventHandler.call(this) || this;
			_this._element = null;
			_this._startHandler = _this._handleTouchStart.bind(_assertThisInitialized(_this));
			_this._endHandler = _this._handleTouchEnd.bind(_assertThisInitialized(_this));
			_this._moveHandler = _this._handleTouchMove.bind(_assertThisInitialized(_this));
			_this._cancelHandler = _this._handleTouchCancel.bind(_assertThisInitialized(_this));

			_this.attach(element);

			return _this;
		}

		var _proto = TouchDevice.prototype;

		_proto.attach = function attach(element) {
			if (this._element) {
				this.detach();
			}

			this._element = element;

			this._element.addEventListener('touchstart', this._startHandler, false);

			this._element.addEventListener('touchend', this._endHandler, false);

			this._element.addEventListener('touchmove', this._moveHandler, false);

			this._element.addEventListener('touchcancel', this._cancelHandler, false);
		};

		_proto.detach = function detach() {
			if (this._element) {
				this._element.removeEventListener('touchstart', this._startHandler, false);

				this._element.removeEventListener('touchend', this._endHandler, false);

				this._element.removeEventListener('touchmove', this._moveHandler, false);

				this._element.removeEventListener('touchcancel', this._cancelHandler, false);
			}

			this._element = null;
		};

		_proto._handleTouchStart = function _handleTouchStart(e) {
			this.fire('touchstart', new TouchEvent(this, e));
		};

		_proto._handleTouchEnd = function _handleTouchEnd(e) {
			this.fire('touchend', new TouchEvent(this, e));
		};

		_proto._handleTouchMove = function _handleTouchMove(e) {
			e.preventDefault();
			this.fire('touchmove', new TouchEvent(this, e));
		};

		_proto._handleTouchCancel = function _handleTouchCancel(e) {
			this.fire('touchcancel', new TouchEvent(this, e));
		};

		return TouchDevice;
	}(EventHandler);

	var log = {
		write: function write(text) {
			Debug.deprecated("pc.log.write is deprecated. Use console.log instead.");
			console.log(text);
		},
		open: function open() {
			Debug.deprecated("pc.log.open is deprecated. Use console.log instead.");
			log.write("Powered by PlayCanvas " + version + " " + revision);
		},
		info: function info(text) {
			Debug.deprecated("pc.log.info is deprecated. Use console.info instead.");
			console.info("INFO:		" + text);
		},
		debug: function debug(text) {
			Debug.deprecated("pc.log.debug is deprecated. Use console.debug instead.");
			console.debug("DEBUG:	 " + text);
		},
		error: function error(text) {
			Debug.deprecated("pc.log.error is deprecated. Use console.error instead.");
			console.error("ERROR:	 " + text);
		},
		warning: function warning(text) {
			Debug.deprecated("pc.log.warning is deprecated. Use console.warn instead.");
			console.warn("WARNING: " + text);
		},
		alert: function (_alert) {
			function alert(_x) {
				return _alert.apply(this, arguments);
			}

			alert.toString = function () {
				return _alert.toString();
			};

			return alert;
		}(function (text) {
			Debug.deprecated("pc.log.alert is deprecated. Use alert instead.");
			log.write("ALERT:	 " + text);
			alert(text);
		}),
		assert: function assert(condition, text) {
			Debug.deprecated("pc.log.assert is deprecated. Use a conditional plus console.log instead.");

			if (condition === false) {
				log.write("ASSERT:	" + text);
			}
		}
	};

	string.endsWith = function (s, subs) {
		Debug.deprecated("pc.string.endsWith is deprecated. Use String#endsWith instead.");
		return s.endsWith(subs);
	};

	string.startsWith = function (s, subs) {
		Debug.deprecated("pc.string.startsWith is deprecated. Use String#startsWith instead.");
		return s.startsWith(subs);
	};

	var time = {
		now: now,
		Timer: Timer
	};
	Object.defineProperty(Color.prototype, "data", {
		get: function get() {
			Debug.deprecated('pc.Color#data is not public API and should not be used. Access color components via their individual properties.');

			if (!this._data) {
				this._data = new Float32Array(4);
			}

			this._data[0] = this.r;
			this._data[1] = this.g;
			this._data[2] = this.b;
			this._data[3] = this.a;
			return this._data;
		}
	});
	Object.defineProperty(Color.prototype, "data3", {
		get: function get() {
			Debug.deprecated('pc.Color#data3 is not public API and should not be used. Access color components via their individual properties.');

			if (!this._data3) {
				this._data3 = new Float32Array(3);
			}

			this._data3[0] = this.r;
			this._data3[1] = this.g;
			this._data3[2] = this.b;
			return this._data3;
		}
	});
	function inherits(Self, Super) {
		var Temp = function Temp() {};

		var Func = function Func(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
			Super.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
			Self.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
		};

		Func._super = Super.prototype;
		Temp.prototype = Super.prototype;
		Func.prototype = new Temp();
		return Func;
	}
	function makeArray(arr) {
		Debug.deprecated('pc.makeArray is not public API and should not be used. Use Array.prototype.slice.call instead.');
		return Array.prototype.slice.call(arr);
	}
	math.INV_LOG2 = Math.LOG2E;
	math.intToBytes = math.intToBytes32;
	math.bytesToInt = math.bytesToInt32;
	Object.defineProperty(Vec2.prototype, "data", {
		get: function get() {
			Debug.deprecated('pc.Vec2#data is not public API and should not be used. Access vector components via their individual properties.');

			if (!this._data) {
				this._data = new Float32Array(2);
			}

			this._data[0] = this.x;
			this._data[1] = this.y;
			return this._data;
		}
	});
	Vec2.prototype.scale = Vec2.prototype.mulScalar;
	Object.defineProperty(Vec3.prototype, "data", {
		get: function get() {
			Debug.deprecated('pc.Vec3#data is not public API and should not be used. Access vector components via their individual properties.');

			if (!this._data) {
				this._data = new Float32Array(3);
			}

			this._data[0] = this.x;
			this._data[1] = this.y;
			this._data[2] = this.z;
			return this._data;
		}
	});
	Vec3.prototype.scale = Vec3.prototype.mulScalar;
	Object.defineProperty(Vec4.prototype, "data", {
		get: function get() {
			Debug.deprecated('pc.Vec4#data is not public API and should not be used. Access vector components via their individual properties.');

			if (!this._data) {
				this._data = new Float32Array(4);
			}

			this._data[0] = this.x;
			this._data[1] = this.y;
			this._data[2] = this.z;
			this._data[3] = this.w;
			return this._data;
		}
	});
	Vec4.prototype.scale = Vec4.prototype.mulScalar;
	var shape = {
		Aabb: BoundingBox,
		Sphere: BoundingSphere,
		Plane: Plane
	};
	BoundingSphere.prototype.intersectRay = BoundingSphere.prototype.intersectsRay;

	Frustum.prototype.update = function (projectionMatrix, viewMatrix) {
		Debug.deprecated('pc.Frustum#update is deprecated. Use pc.Frustum#setFromMat4 instead.');
		var viewProj = new Mat4();
		viewProj.mul2(projectionMatrix, viewMatrix);
		this.setFromMat4(viewProj);
	};

	var ELEMENTTYPE_INT8 = TYPE_INT8;
	var ELEMENTTYPE_UINT8 = TYPE_UINT8;
	var ELEMENTTYPE_INT16 = TYPE_INT16;
	var ELEMENTTYPE_UINT16 = TYPE_UINT16;
	var ELEMENTTYPE_INT32 = TYPE_INT32;
	var ELEMENTTYPE_UINT32 = TYPE_UINT32;
	var ELEMENTTYPE_FLOAT32 = TYPE_FLOAT32;
	function UnsupportedBrowserError(message) {
		this.name = "UnsupportedBrowserError";
		this.message = message || "";
	}
	UnsupportedBrowserError.prototype = Error.prototype;
	function ContextCreationError(message) {
		this.name = "ContextCreationError";
		this.message = message || "";
	}
	ContextCreationError.prototype = Error.prototype;
	var gfx = {
		ADDRESS_CLAMP_TO_EDGE: ADDRESS_CLAMP_TO_EDGE,
		ADDRESS_MIRRORED_REPEAT: ADDRESS_MIRRORED_REPEAT,
		ADDRESS_REPEAT: ADDRESS_REPEAT,
		BLENDMODE_ZERO: BLENDMODE_ZERO,
		BLENDMODE_ONE: BLENDMODE_ONE,
		BLENDMODE_SRC_COLOR: BLENDMODE_SRC_COLOR,
		BLENDMODE_ONE_MINUS_SRC_COLOR: BLENDMODE_ONE_MINUS_SRC_COLOR,
		BLENDMODE_DST_COLOR: BLENDMODE_DST_COLOR,
		BLENDMODE_ONE_MINUS_DST_COLOR: BLENDMODE_ONE_MINUS_DST_COLOR,
		BLENDMODE_SRC_ALPHA: BLENDMODE_SRC_ALPHA,
		BLENDMODE_SRC_ALPHA_SATURATE: BLENDMODE_SRC_ALPHA_SATURATE,
		BLENDMODE_ONE_MINUS_SRC_ALPHA: BLENDMODE_ONE_MINUS_SRC_ALPHA,
		BLENDMODE_DST_ALPHA: BLENDMODE_DST_ALPHA,
		BLENDMODE_ONE_MINUS_DST_ALPHA: BLENDMODE_ONE_MINUS_DST_ALPHA,
		BUFFER_STATIC: BUFFER_STATIC,
		BUFFER_DYNAMIC: BUFFER_DYNAMIC,
		BUFFER_STREAM: BUFFER_STREAM,
		CULLFACE_NONE: CULLFACE_NONE,
		CULLFACE_BACK: CULLFACE_BACK,
		CULLFACE_FRONT: CULLFACE_FRONT,
		CULLFACE_FRONTANDBACK: CULLFACE_FRONTANDBACK,
		ELEMENTTYPE_INT8: TYPE_INT8,
		ELEMENTTYPE_UINT8: TYPE_UINT8,
		ELEMENTTYPE_INT16: TYPE_INT16,
		ELEMENTTYPE_UINT16: TYPE_UINT16,
		ELEMENTTYPE_INT32: TYPE_INT32,
		ELEMENTTYPE_UINT32: TYPE_UINT32,
		ELEMENTTYPE_FLOAT32: TYPE_FLOAT32,
		FILTER_NEAREST: FILTER_NEAREST,
		FILTER_LINEAR: FILTER_LINEAR,
		FILTER_NEAREST_MIPMAP_NEAREST: FILTER_NEAREST_MIPMAP_NEAREST,
		FILTER_NEAREST_MIPMAP_LINEAR: FILTER_NEAREST_MIPMAP_LINEAR,
		FILTER_LINEAR_MIPMAP_NEAREST: FILTER_LINEAR_MIPMAP_NEAREST,
		FILTER_LINEAR_MIPMAP_LINEAR: FILTER_LINEAR_MIPMAP_LINEAR,
		INDEXFORMAT_UINT8: INDEXFORMAT_UINT8,
		INDEXFORMAT_UINT16: INDEXFORMAT_UINT16,
		INDEXFORMAT_UINT32: INDEXFORMAT_UINT32,
		PIXELFORMAT_R5_G6_B5: PIXELFORMAT_R5_G6_B5,
		PIXELFORMAT_R8_G8_B8: PIXELFORMAT_R8_G8_B8,
		PIXELFORMAT_R8_G8_B8_A8: PIXELFORMAT_R8_G8_B8_A8,
		PRIMITIVE_POINTS: PRIMITIVE_POINTS,
		PRIMITIVE_LINES: PRIMITIVE_LINES,
		PRIMITIVE_LINELOOP: PRIMITIVE_LINELOOP,
		PRIMITIVE_LINESTRIP: PRIMITIVE_LINESTRIP,
		PRIMITIVE_TRIANGLES: PRIMITIVE_TRIANGLES,
		PRIMITIVE_TRISTRIP: PRIMITIVE_TRISTRIP,
		PRIMITIVE_TRIFAN: PRIMITIVE_TRIFAN,
		SEMANTIC_POSITION: SEMANTIC_POSITION,
		SEMANTIC_NORMAL: SEMANTIC_NORMAL,
		SEMANTIC_COLOR: SEMANTIC_COLOR,
		SEMANTIC_TEXCOORD: SEMANTIC_TEXCOORD,
		SEMANTIC_TEXCOORD0: SEMANTIC_TEXCOORD0,
		SEMANTIC_TEXCOORD1: SEMANTIC_TEXCOORD1,
		SEMANTIC_ATTR0: SEMANTIC_ATTR0,
		SEMANTIC_ATTR1: SEMANTIC_ATTR1,
		SEMANTIC_ATTR2: SEMANTIC_ATTR2,
		SEMANTIC_ATTR3: SEMANTIC_ATTR3,
		TEXTURELOCK_READ: TEXTURELOCK_READ,
		TEXTURELOCK_WRITE: TEXTURELOCK_WRITE,
		drawQuadWithShader: drawQuadWithShader,
		programlib: programlib,
		shaderChunks: shaderChunks,
		ContextCreationError: ContextCreationError,
		Device: GraphicsDevice,
		IndexBuffer: IndexBuffer,
		ProgramLibrary: ProgramLibrary,
		RenderTarget: RenderTarget,
		ScopeId: ScopeId,
		Shader: Shader,
		ShaderInput: ShaderInput,
		Texture: Texture,
		UnsupportedBrowserError: UnsupportedBrowserError,
		VertexBuffer: VertexBuffer,
		VertexFormat: VertexFormat,
		VertexIterator: VertexIterator
	};
	var posteffect = {
		createFullscreenQuad: createFullscreenQuad,
		drawFullscreenQuad: drawFullscreenQuad,
		PostEffect: PostEffect$1,
		PostEffectQueue: PostEffectQueue
	};
	Object.defineProperty(shaderChunks, "transformSkinnedVS", {
		get: function get() {
			return "#define SKIN\n" + shaderChunks.transformVS;
		}
	});
	var deprecatedChunks = {
		'ambientPrefilteredCube.frag': 'ambientEnv.frag',
		'ambientPrefilteredCubeLod.frag': 'ambientEnv.frag',
		'dpAtlasQuad.frag': null,
		'genParaboloid.frag': null,
		'prefilterCubemap.frag': null,
		'reflectionDpAtlas.frag': 'reflectionEnv.frag',
		'reflectionPrefilteredCube.frag': 'reflectionEnv.frag',
		'reflectionPrefilteredCubeLod.frag': 'reflectionEnv.frag'
	};
	Object.keys(deprecatedChunks).forEach(function (chunkName) {
		var replacement = deprecatedChunks[chunkName];
		var useInstead = replacement ? " Use pc.shaderChunks['" + replacement + "'] instead." : "";
		var msg = "pc.shaderChunks['" + chunkName + "'] is deprecated." + useInstead + "}";
		Object.defineProperty(shaderChunks, chunkName, {
			get: function get() {
				Debug.error(msg);
				return null;
			},
			set: function set() {
				Debug.error(msg);
			}
		});
	});
	Object.defineProperties(RenderTarget.prototype, {
		_glFrameBuffer: {
			get: function get() {
				Debug.deprecated("pc.RenderTarget#_glFrameBuffer is deprecated. Use pc.RenderTarget.impl#_glFrameBuffer instead.");
				return this.impl._glFrameBuffer;
			},
			set: function set(rgbm) {
				Debug.deprecated("pc.RenderTarget#_glFrameBuffer is deprecated. Use pc.RenderTarget.impl#_glFrameBuffer instead.");
			}
		}
	});

	VertexFormat.prototype.update = function () {
		Debug.deprecated('pc.VertexFormat.update is deprecated, and VertexFormat cannot be changed after it has been created.');
	};

	Object.defineProperties(Texture.prototype, {
		rgbm: {
			get: function get() {
				Debug.deprecated("pc.Texture#rgbm is deprecated. Use pc.Texture#type instead.");
				return this.type === TEXTURETYPE_RGBM;
			},
			set: function set(rgbm) {
				Debug.deprecated("pc.Texture#rgbm is deprecated. Use pc.Texture#type instead.");
				this.type = rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
			}
		},
		swizzleGGGR: {
			get: function get() {
				Debug.deprecated("pc.Texture#swizzleGGGR is deprecated. Use pc.Texture#type instead.");
				return this.type === TEXTURETYPE_SWIZZLEGGGR;
			},
			set: function set(swizzleGGGR) {
				Debug.deprecated("pc.Texture#swizzleGGGR is deprecated. Use pc.Texture#type instead.");
				this.type = swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
			}
		},
		_glTexture: {
			get: function get() {
				Debug.deprecated("pc.Texture#_glTexture is no longer available, use Use pc.Texture.impl._glTexture instead.");
				return this.impl._glTexture;
			}
		}
	});
	var PhongMaterial = StandardMaterial;
	var scene = {
		partitionSkin: partitionSkin,
		procedural: {
			calculateTangents: calculateTangents,
			createMesh: createMesh$1,
			createTorus: createTorus,
			createCylinder: createCylinder,
			createCapsule: createCapsule,
			createCone: createCone,
			createSphere: createSphere,
			createPlane: createPlane,
			createBox: createBox
		},
		BasicMaterial: BasicMaterial,
		Command: Command,
		ForwardRenderer: ForwardRenderer,
		GraphNode: GraphNode,
		Material: Material,
		Mesh: Mesh,
		MeshInstance: MeshInstance,
		Model: Model,
		ParticleEmitter: ParticleEmitter,
		PhongMaterial: StandardMaterial,
		Picker: Picker,
		Projection: {
			ORTHOGRAPHIC: PROJECTION_ORTHOGRAPHIC,
			PERSPECTIVE: PROJECTION_PERSPECTIVE
		},
		Scene: Scene,
		Skin: Skin,
		SkinInstance: SkinInstance
	};
	Object.defineProperty(Scene.prototype, 'defaultMaterial', {
		get: function get() {
			Debug.deprecated('pc.Scene#defaultMaterial is deprecated.');
			return getDefaultMaterial(getApplication().graphicsDevice);
		}
	});
	['128', '64', '32', '16', '8', '4'].forEach(function (size, index) {
		Object.defineProperty(Scene.prototype, "skyboxPrefiltered" + size, {
			get: function get() {
				Debug.deprecated("pc.Scene#skyboxPrefiltered" + size + " is deprecated. Use pc.Scene#prefilteredCubemaps instead.");
				return this._prefilteredCubemaps[index];
			},
			set: function set(value) {
				Debug.deprecated("pc.Scene#skyboxPrefiltered" + size + " is deprecated. Use pc.Scene#prefilteredCubemaps instead.");
				this._prefilteredCubemaps[index] = value;
				this.updateShaders = true;
			}
		});
	});
	Object.defineProperty(Batch.prototype, 'model', {
		get: function get() {
			Debug.deprecated('pc.Batch#model is deprecated. Use pc.Batch#meshInstance to access batched mesh instead.');
			return null;
		}
	});

	MeshInstance.prototype.syncAabb = function () {
		Debug.deprecated('pc.MeshInstance#syncAabb is deprecated.');
	};

	Morph.prototype.getTarget = function (index) {
		Debug.deprecated('pc.Morph#getTarget is deprecated. Use pc.Morph#targets instead.');
		return this.targets[index];
	};

	GraphNode.prototype._dirtify = function (local) {
		Debug.deprecated('pc.GraphNode#_dirtify is deprecated. Use pc.GraphNode#_dirtifyLocal or _dirtifyWorld respectively instead.');
		if (local) this._dirtifyLocal();else this._dirtifyWorld();
	};

	GraphNode.prototype.addLabel = function (label) {
		Debug.deprecated('pc.GraphNode#addLabel is deprecated. Use pc.GraphNode#tags instead.');
		this._labels[label] = true;
	};

	GraphNode.prototype.getLabels = function () {
		Debug.deprecated('pc.GraphNode#getLabels is deprecated. Use pc.GraphNode#tags instead.');
		return Object.keys(this._labels);
	};

	GraphNode.prototype.hasLabel = function (label) {
		Debug.deprecated('pc.GraphNode#hasLabel is deprecated. Use pc.GraphNode#tags instead.');
		return !!this._labels[label];
	};

	GraphNode.prototype.removeLabel = function (label) {
		Debug.deprecated('pc.GraphNode#removeLabel is deprecated. Use pc.GraphNode#tags instead.');
		delete this._labels[label];
	};

	GraphNode.prototype.findByLabel = function (label, results) {
		if (results === void 0) {
			results = [];
		}

		Debug.deprecated('pc.GraphNode#findByLabel is deprecated. Use pc.GraphNode#tags instead.');

		if (this.hasLabel(label)) {
			results.push(this);
		}

		for (var i = 0; i < this._children.length; ++i) {
			results = this._children[i].findByLabel(label, results);
		}

		return results;
	};

	GraphNode.prototype.getChildren = function () {
		Debug.deprecated('pc.GraphNode#getChildren is deprecated. Use pc.GraphNode#children instead.');
		return this.children;
	};

	GraphNode.prototype.getName = function () {
		Debug.deprecated('pc.GraphNode#getName is deprecated. Use pc.GraphNode#name instead.');
		return this.name;
	};

	GraphNode.prototype.getPath = function () {
		Debug.deprecated('pc.GraphNode#getPath is deprecated. Use pc.GraphNode#path instead.');
		return this.path;
	};

	GraphNode.prototype.getRoot = function () {
		Debug.deprecated('pc.GraphNode#getRoot is deprecated. Use pc.GraphNode#root instead.');
		return this.root;
	};

	GraphNode.prototype.getParent = function () {
		Debug.deprecated('pc.GraphNode#getParent is deprecated. Use pc.GraphNode#parent instead.');
		return this.parent;
	};

	GraphNode.prototype.setName = function (name) {
		Debug.deprecated('pc.GraphNode#setName is deprecated. Use pc.GraphNode#name instead.');
		this.name = name;
	};

	Material.prototype.getName = function () {
		Debug.deprecated('pc.Material#getName is deprecated. Use pc.Material#name instead.');
		return this.name;
	};

	Material.prototype.setName = function (name) {
		Debug.deprecated('pc.Material#setName is deprecated. Use pc.Material#name instead.');
		this.name = name;
	};

	Material.prototype.getShader = function () {
		Debug.deprecated('pc.Material#getShader is deprecated. Use pc.Material#shader instead.');
		return this.shader;
	};

	Material.prototype.setShader = function (shader) {
		Debug.deprecated('pc.Material#setShader is deprecated. Use pc.Material#shader instead.');
		this.shader = shader;
	};

	function _defineAlias(newName, oldName) {
		Object.defineProperty(StandardMaterial.prototype, oldName, {
			get: function get() {
				Debug.deprecated("pc.StandardMaterial#" + oldName + " is deprecated. Use pc.StandardMaterial#" + newName + " instead.");
				return this[newName];
			},
			set: function set(value) {
				Debug.deprecated("pc.StandardMaterial#" + oldName + " is deprecated. Use pc.StandardMaterial#" + newName + " instead.");
				this[newName] = value;
			}
		});
	}

	_defineAlias("diffuseTint", "diffuseMapTint");

	_defineAlias("specularTint", "specularMapTint");

	_defineAlias("emissiveTint", "emissiveMapTint");

	_defineAlias("aoVertexColor", "aoMapVertexColor");

	_defineAlias("diffuseVertexColor", "diffuseMapVertexColor");

	_defineAlias("specularVertexColor", "specularMapVertexColor");

	_defineAlias("emissiveVertexColor", "emissiveMapVertexColor");

	_defineAlias("metalnessVertexColor", "metalnessMapVertexColor");

	_defineAlias("glossVertexColor", "glossMapVertexColor");

	_defineAlias("opacityVertexColor", "opacityMapVertexColor");

	_defineAlias("lightVertexColor", "lightMapVertexColor");

	var anim = {
		Animation: Animation,
		Key: Key,
		Node: Node,
		Skeleton: Skeleton
	};

	Animation.prototype.getDuration = function () {
		Debug.deprecated('pc.Animation#getDuration is deprecated. Use pc.Animation#duration instead.');
		return this.duration;
	};

	Animation.prototype.getName = function () {
		Debug.deprecated('pc.Animation#getName is deprecated. Use pc.Animation#name instead.');
		return this.name;
	};

	Animation.prototype.getNodes = function () {
		Debug.deprecated('pc.Animation#getNodes is deprecated. Use pc.Animation#nodes instead.');
		return this.nodes;
	};

	Animation.prototype.setDuration = function (duration) {
		Debug.deprecated('pc.Animation#setDuration is deprecated. Use pc.Animation#duration instead.');
		this.duration = duration;
	};

	Animation.prototype.setName = function (name) {
		Debug.deprecated('pc.Animation#setName is deprecated. Use pc.Animation#name instead.');
		this.name = name;
	};

	Skeleton.prototype.getAnimation = function () {
		Debug.deprecated('pc.Skeleton#getAnimation is deprecated. Use pc.Skeleton#animation instead.');
		return this.animation;
	};

	Skeleton.prototype.getCurrentTime = function () {
		Debug.deprecated('pc.Skeleton#getCurrentTime is deprecated. Use pc.Skeleton#currentTime instead.');
		return this.currentTime;
	};

	Skeleton.prototype.getLooping = function () {
		Debug.deprecated('pc.Skeleton#getLooping is deprecated. Use pc.Skeleton#looping instead.');
		return this.looping;
	};

	Skeleton.prototype.getNumNodes = function () {
		Debug.deprecated('pc.Skeleton#getNumNodes is deprecated. Use pc.Skeleton#numNodes instead.');
		return this.numNodes;
	};

	Skeleton.prototype.setAnimation = function (animation) {
		Debug.deprecated('pc.Skeleton#setAnimation is deprecated. Use pc.Skeleton#animation instead.');
		this.animation = animation;
	};

	Skeleton.prototype.setCurrentTime = function (time) {
		Debug.deprecated('pc.Skeleton#setCurrentTime is deprecated. Use pc.Skeleton#currentTime instead.');
		this.currentTime = time;
	};

	Skeleton.prototype.setLooping = function (looping) {
		Debug.deprecated('pc.Skeleton#setLooping is deprecated. Use pc.Skeleton#looping instead.');
		this.looping = looping;
	};

	var audio = {
		AudioManager: SoundManager,
		Channel: Channel,
		Channel3d: Channel3d,
		Listener: Listener,
		Sound: Sound
	};

	SoundManager.prototype.getListener = function () {
		Debug.deprecated('pc.SoundManager#getListener is deprecated. Use pc.SoundManager#listener instead.');
		return this.listener;
	};

	SoundManager.prototype.getVolume = function () {
		Debug.deprecated('pc.SoundManager#getVolume is deprecated. Use pc.SoundManager#volume instead.');
		return this.volume;
	};

	SoundManager.prototype.setVolume = function (volume) {
		Debug.deprecated('pc.SoundManager#setVolume is deprecated. Use pc.SoundManager#volume instead.');
		this.volume = volume;
	};

	var asset = {
		ASSET_ANIMATION: 'animation',
		ASSET_AUDIO: 'audio',
		ASSET_IMAGE: 'image',
		ASSET_JSON: 'json',
		ASSET_MODEL: 'model',
		ASSET_MATERIAL: 'material',
		ASSET_TEXT: 'text',
		ASSET_TEXTURE: 'texture',
		ASSET_CUBEMAP: 'cubemap',
		ASSET_SCRIPT: 'script'
	};

	AssetRegistry.prototype.getAssetById = function (id) {
		Debug.deprecated("pc.AssetRegistry#getAssetById is deprecated. Use pc.AssetRegistry#get instead.");
		return this.get(id);
	};

	Object.defineProperty(XrInputSource.prototype, 'ray', {
		get: function get() {
			Debug.deprecated('pc.XrInputSource#ray is deprecated. Use pc.XrInputSource#getOrigin and pc.XrInputSource#getDirection instead.');
			return this._rayLocal;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'position', {
		get: function get() {
			Debug.deprecated('pc.XrInputSource#position is deprecated. Use pc.XrInputSource#getLocalPosition instead.');
			return this._localPosition;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'rotation', {
		get: function get() {
			Debug.deprecated('pc.XrInputSource#rotation is deprecated. Use pc.XrInputSource#getLocalRotation instead.');
			return this._localRotation;
		}
	});
	var input = {
		getTouchTargetCoords: getTouchTargetCoords,
		Controller: Controller,
		GamePads: GamePads,
		Keyboard: Keyboard,
		KeyboardEvent: KeyboardEvent,
		Mouse: Mouse,
		MouseEvent: MouseEvent,
		Touch: Touch,
		TouchDevice: TouchDevice,
		TouchEvent: TouchEvent
	};
	Object.defineProperty(ElementInput.prototype, 'wheel', {
		get: function get() {
			return this.wheelDelta * -2;
		}
	});
	Object.defineProperty(MouseEvent.prototype, 'wheel', {
		get: function get() {
			return this.wheelDelta * -2;
		}
	});
	var RIGIDBODY_TYPE_STATIC = BODYTYPE_STATIC;
	var RIGIDBODY_TYPE_DYNAMIC = BODYTYPE_DYNAMIC;
	var RIGIDBODY_TYPE_KINEMATIC = BODYTYPE_KINEMATIC;
	var RIGIDBODY_CF_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
	var RIGIDBODY_CF_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
	var RIGIDBODY_CF_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
	var RIGIDBODY_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
	var RIGIDBODY_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
	var RIGIDBODY_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
	var RIGIDBODY_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
	var RIGIDBODY_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
	var fw = {
		Application: Application,
		Component: Component,
		ComponentSystem: ComponentSystem,
		Entity: Entity,
		FillMode: {
			NONE: FILLMODE_NONE,
			FILL_WINDOW: FILLMODE_FILL_WINDOW,
			KEEP_ASPECT: FILLMODE_KEEP_ASPECT
		},
		ResolutionMode: {
			AUTO: RESOLUTION_AUTO,
			FIXED: RESOLUTION_FIXED
		}
	};

	Application.prototype.isFullscreen = function () {
		Debug.deprecated('pc.Application#isFullscreen is deprecated. Use the Fullscreen API directly.');
		return !!document.fullscreenElement;
	};

	Application.prototype.enableFullscreen = function (element, success, error) {
		Debug.deprecated('pc.Application#enableFullscreen is deprecated. Use the Fullscreen API directly.');
		element = element || this.graphicsDevice.canvas;

		var s = function s() {
			success();
			document.removeEventListener('fullscreenchange', s);
		};

		var e = function e() {
			error();
			document.removeEventListener('fullscreenerror', e);
		};

		if (success) {
			document.addEventListener('fullscreenchange', s, false);
		}

		if (error) {
			document.addEventListener('fullscreenerror', e, false);
		}

		if (element.requestFullscreen) {
			element.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
		} else {
			error();
		}
	};

	Application.prototype.disableFullscreen = function (success) {
		Debug.deprecated('pc.Application#disableFullscreen is deprecated. Use the Fullscreen API directly.');

		var s = function s() {
			success();
			document.removeEventListener('fullscreenchange', s);
		};

		if (success) {
			document.addEventListener('fullscreenchange', s, false);
		}

		document.exitFullscreen();
	};

	Application.prototype.getSceneUrl = function (name) {
		Debug.deprecated("pc.Application#getSceneUrl is deprecated. Use pc.Application#scenes and pc.SceneRegistry#find instead.");
		var entry = this.scenes.find(name);

		if (entry) {
			return entry.url;
		}

		return null;
	};

	Application.prototype.loadScene = function (url, callback) {
		Debug.deprecated("pc.Application#loadScene is deprecated. Use pc.Application#scenes and pc.SceneRegistry#loadScene instead.");
		this.scenes.loadScene(url, callback);
	};

	Application.prototype.loadSceneHierarchy = function (url, callback) {
		Debug.deprecated("pc.Application#loadSceneHierarchy is deprecated. Use pc.Application#scenes and pc.SceneRegistry#loadSceneHierarchy instead.");
		this.scenes.loadSceneHierarchy(url, callback);
	};

	Application.prototype.loadSceneSettings = function (url, callback) {
		Debug.deprecated("pc.Application#loadSceneSettings is deprecated. Use pc.Application#scenes and pc.SceneRegistry#loadSceneSettings instead.");
		this.scenes.loadSceneSettings(url, callback);
	};

	Application.prototype.renderMeshInstance = function (meshInstance, options) {
		Debug.deprecated("pc.Application.renderMeshInstance is deprecated. Use pc.Application.drawMeshInstance.");
		var layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;
		this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
	};

	Application.prototype.renderMesh = function (mesh, material, matrix, options) {
		Debug.deprecated("pc.Application.renderMesh is deprecated. Use pc.Application.drawMesh.");
		var layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;
		this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);
	};

	Application.prototype._addLines = function (positions, colors, options) {
		var layer = options && options.layer ? options.layer : this.scene.layers.getLayerById(LAYERID_IMMEDIATE);
		var depthTest = options && options.depthTest !== undefined ? options.depthTest : true;
		var batch = this.scene.immediate.getBatch(layer, depthTest);
		batch.addLines(positions, colors);
	};

	Application.prototype.renderLine = function (start, end, color) {
		Debug.deprecated("pc.Application.renderLine is deprecated. Use pc.Application.drawLine.");
		var endColor = color;
		var options;
		var arg3 = arguments[3];
		var arg4 = arguments[4];

		if (arg3 instanceof Color) {
			endColor = arg3;

			if (typeof arg4 === 'number') {
				if (arg4 === LINEBATCH_OVERLAY) {
					options = {
						layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
						depthTest: false
					};
				} else {
					options = {
						layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
						depthTest: true
					};
				}
			} else {
				options = arg4;
			}
		} else if (typeof arg3 === 'number') {
			endColor = color;

			if (arg3 === LINEBATCH_OVERLAY) {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
					depthTest: false
				};
			} else {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
					depthTest: true
				};
			}
		} else if (arg3) {
			options = arg3;
		}

		this._addLines([start, end], [color, endColor], options);
	};

	Application.prototype.renderLines = function (position, color, options) {
		Debug.deprecated("pc.Application.renderLines is deprecated. Use pc.Application.drawLines.");

		if (!options) {
			options = {
				layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
				depthTest: true
			};
		} else if (typeof options === 'number') {
			if (options === LINEBATCH_OVERLAY) {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
					depthTest: false
				};
			} else {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
					depthTest: true
				};
			}
		}

		var multiColor = !!color.length;

		if (multiColor) {
			if (position.length !== color.length) {
				console.error("renderLines: position/color arrays have different lengths");
				return;
			}
		}

		if (position.length % 2 !== 0) {
			console.error("renderLines: array length is not divisible by 2");
			return;
		}

		this._addLines(position, color, options);
	};

	Object.defineProperty(CameraComponent.prototype, "node", {
		get: function get() {
			Debug.deprecated("pc.CameraComponent#node is deprecated. Use pc.CameraComponent#entity instead.");
			return this.entity;
		}
	});
	Object.defineProperty(LightComponent.prototype, "enable", {
		get: function get() {
			Debug.deprecated("pc.LightComponent#enable is deprecated. Use pc.LightComponent#enabled instead.");
			return this.enabled;
		},
		set: function set(value) {
			Debug.deprecated("pc.LightComponent#enable is deprecated. Use pc.LightComponent#enabled instead.");
			this.enabled = value;
		}
	});

	ModelComponent.prototype.setVisible = function (visible) {
		Debug.deprecated("pc.ModelComponent#setVisible is deprecated. Use pc.ModelComponent#enabled instead.");
		this.enabled = visible;
	};

	Object.defineProperty(ModelComponent.prototype, "aabb", {
		get: function get() {
			Debug.deprecated('pc.ModelComponent#aabb is deprecated. Use pc.ModelComponent#customAabb instead - which expects local space AABB instead of a world space AABB.');
			return null;
		},
		set: function set(type) {
			Debug.deprecated('pc.ModelComponent#aabb is deprecated. Use pc.ModelComponent#customAabb instead - which expects local space AABB instead of a world space AABB.');
		}
	});
	Object.defineProperty(RenderComponent.prototype, "aabb", {
		get: function get() {
			Debug.deprecated('pc.RenderComponent#aabb is deprecated. Use pc.RenderComponent#customAabb instead - which expects local space AABB instead of a world space AABB.');
			return null;
		},
		set: function set(type) {
			Debug.deprecated('pc.RenderComponent#aabb is deprecated. Use pc.RenderComponent#customAabb instead - which expects local space AABB instead of a world space AABB.');
		}
	});
	Object.defineProperty(RigidBodyComponent.prototype, "bodyType", {
		get: function get() {
			Debug.deprecated('pc.RigidBodyComponent#bodyType is deprecated. Use pc.RigidBodyComponent#type instead.');
			return this.type;
		},
		set: function set(type) {
			Debug.deprecated('pc.RigidBodyComponent#bodyType is deprecated. Use pc.RigidBodyComponent#type instead.');
			this.type = type;
		}
	});

	RigidBodyComponent.prototype.syncBodyToEntity = function () {
		Debug.deprecated('pc.RigidBodyComponent#syncBodyToEntity is not public API and should not be used.');

		this._updateDynamic();
	};

	RigidBodyComponentSystem.prototype.setGravity = function () {
		Debug.deprecated('pc.RigidBodyComponentSystem#setGravity is deprecated. Use pc.RigidBodyComponentSystem#gravity instead.');

		if (arguments.length === 1) {
			this.gravity.copy(arguments[0]);
		} else {
			this.gravity.set(arguments[0], arguments[1], arguments[2]);
		}
	};

	function basisSetDownloadConfig(glueUrl, wasmUrl, fallbackUrl) {
		Debug.deprecated('pc.basisSetDownloadConfig is deprecated. Use pc.basisInitialize instead.');
		basisInitialize({
			glueUrl: glueUrl,
			wasmUrl: wasmUrl,
			fallbackUrl: fallbackUrl,
			lazyInit: true
		});
	}
	function prefilterCubemap(options) {
		Debug.deprecated('pc.prefilterCubemap is deprecated. Use pc.envLighting instead.');
	}
	var AssetListLoader = function (_EventHandler) {
		_inheritsLoose(AssetListLoader, _EventHandler);

		function AssetListLoader(assetList, assetRegistry) {
			var _this;

			Debug.deprecated('pc.AssetListLoader is deprecated.');
			_this = _EventHandler.call(this) || this;
			_this._assets = [];
			_this._registry = assetRegistry;
			_this._loaded = false;
			_this._count = 0;
			_this._total = 0;
			_this._failed = [];
			_this._waitingAssets = [];

			if (assetList.length && assetList[0] instanceof Asset) {
				_this._assets = assetList;
			} else {
				for (var i = 0; i < assetList.length; i++) {
					var _asset = assetRegistry.get(assetList[i]);

					if (_asset) {
						_this._assets.push(_asset);
					} else {
						_this._waitForAsset(assetList[i]);

						_this._total++;
					}
				}
			}

			return _this;
		}

		var _proto = AssetListLoader.prototype;

		_proto.destroy = function destroy() {
			var _this2 = this;

			Debug.deprecated('pc.AssetListLoader is deprecated.');

			this._registry.off("load", this._onLoad);

			this._registry.off("error", this._onError);

			this._waitingAssets.forEach(function (id) {
				_this2._registry.off("add:" + id, _this2._onAddAsset);
			});

			this.off("progress");
			this.off("load");
		};

		_proto.load = function load(done, scope) {
			Debug.deprecated('pc.AssetListLoader is deprecated.');
			this._count = 0;
			this._failed = [];
			this._callback = done;
			this._scope = scope;

			this._registry.on("load", this._onLoad, this);

			this._registry.on("error", this._onError, this);

			for (var i = 0, l = this._assets.length; i < l; i++) {
				var _asset2 = this._assets[i];

				if (!_asset2.loading && !_asset2.loaded) {
					this._registry.load(_asset2);

					this._total++;
				}
			}
		};

		_proto.ready = function ready(done, scope) {
			Debug.deprecated('pc.AssetListLoader is deprecated.');
			scope = scope || this;

			if (this._loaded) {
				done.call(scope, this._assets);
			} else {
				this.once("load", function (assets) {
					done.call(scope, assets);
				});
			}
		};

		_proto._loadingComplete = function _loadingComplete() {
			this._loaded = true;

			this._registry.off("load", this._onLoad, this);

			this._registry.off("error", this._onError, this);

			if (this._failed && this._failed.length) {
				if (this._callback) {
					this._callback.call(this._scope, "Failed to load some assets", this._failed);
				}

				this.fire("error", this._failed);
			} else {
				if (this._callback) {
					this._callback.call(this._scope);
				}

				this.fire("load", this._assets);
			}
		};

		_proto._onLoad = function _onLoad(asset) {
			var _this3 = this;

			if (this._assets.indexOf(asset) >= 0) {
				this._count++;
				this.fire("progress", asset);
			}

			if (this._count === this._total) {
				setTimeout(function () {
					_this3._loadingComplete(_this3._failed);
				}, 0);
			}
		};

		_proto._onError = function _onError(err, asset) {
			var _this4 = this;

			if (this._assets.indexOf(asset) >= 0) {
				this._count++;

				this._failed.push(asset);
			}

			if (this._count === this._total) {
				setTimeout(function () {
					_this4._loadingComplete(_this4._failed);
				}, 0);
			}
		};

		_proto._onAddAsset = function _onAddAsset(asset) {
			var index = this._waitingAssets.indexOf(asset);

			if (index >= 0) {
				this._waitingAssets.splice(index, 1);
			}

			this._assets.push(asset);

			for (var i = 0, l = this._assets.length; i < l; i++) {
				asset = this._assets[i];

				if (!asset.loading && !asset.loaded) {
					this._registry.load(asset);
				}
			}
		};

		_proto._waitForAsset = function _waitForAsset(assetId) {
			this._waitingAssets.push(assetId);

			this._registry.once('add:' + assetId, this._onAddAsset, this);
		};

		return AssetListLoader;
	}(EventHandler);

	exports.ABSOLUTE_URL = ABSOLUTE_URL;
	exports.ACTION_GAMEPAD = ACTION_GAMEPAD;
	exports.ACTION_KEYBOARD = ACTION_KEYBOARD;
	exports.ACTION_MOUSE = ACTION_MOUSE;
	exports.ADDRESS_CLAMP_TO_EDGE = ADDRESS_CLAMP_TO_EDGE;
	exports.ADDRESS_MIRRORED_REPEAT = ADDRESS_MIRRORED_REPEAT;
	exports.ADDRESS_REPEAT = ADDRESS_REPEAT;
	exports.ANIM_BLEND_1D = ANIM_BLEND_1D;
	exports.ANIM_BLEND_2D_CARTESIAN = ANIM_BLEND_2D_CARTESIAN;
	exports.ANIM_BLEND_2D_DIRECTIONAL = ANIM_BLEND_2D_DIRECTIONAL;
	exports.ANIM_BLEND_DIRECT = ANIM_BLEND_DIRECT;
	exports.ANIM_CONTROL_STATES = ANIM_CONTROL_STATES;
	exports.ANIM_EQUAL_TO = ANIM_EQUAL_TO;
	exports.ANIM_GREATER_THAN = ANIM_GREATER_THAN;
	exports.ANIM_GREATER_THAN_EQUAL_TO = ANIM_GREATER_THAN_EQUAL_TO;
	exports.ANIM_INTERRUPTION_NEXT = ANIM_INTERRUPTION_NEXT;
	exports.ANIM_INTERRUPTION_NEXT_PREV = ANIM_INTERRUPTION_NEXT_PREV;
	exports.ANIM_INTERRUPTION_NONE = ANIM_INTERRUPTION_NONE;
	exports.ANIM_INTERRUPTION_PREV = ANIM_INTERRUPTION_PREV;
	exports.ANIM_INTERRUPTION_PREV_NEXT = ANIM_INTERRUPTION_PREV_NEXT;
	exports.ANIM_LAYER_ADDITIVE = ANIM_LAYER_ADDITIVE;
	exports.ANIM_LAYER_OVERWRITE = ANIM_LAYER_OVERWRITE;
	exports.ANIM_LESS_THAN = ANIM_LESS_THAN;
	exports.ANIM_LESS_THAN_EQUAL_TO = ANIM_LESS_THAN_EQUAL_TO;
	exports.ANIM_NOT_EQUAL_TO = ANIM_NOT_EQUAL_TO;
	exports.ANIM_PARAMETER_BOOLEAN = ANIM_PARAMETER_BOOLEAN;
	exports.ANIM_PARAMETER_FLOAT = ANIM_PARAMETER_FLOAT;
	exports.ANIM_PARAMETER_INTEGER = ANIM_PARAMETER_INTEGER;
	exports.ANIM_PARAMETER_TRIGGER = ANIM_PARAMETER_TRIGGER;
	exports.ANIM_STATE_ANY = ANIM_STATE_ANY;
	exports.ANIM_STATE_END = ANIM_STATE_END;
	exports.ANIM_STATE_START = ANIM_STATE_START;
	exports.ASPECT_AUTO = ASPECT_AUTO;
	exports.ASPECT_MANUAL = ASPECT_MANUAL;
	exports.ASSET_ANIMATION = ASSET_ANIMATION;
	exports.ASSET_AUDIO = ASSET_AUDIO;
	exports.ASSET_CONTAINER = ASSET_CONTAINER;
	exports.ASSET_CSS = ASSET_CSS;
	exports.ASSET_CUBEMAP = ASSET_CUBEMAP;
	exports.ASSET_HTML = ASSET_HTML;
	exports.ASSET_IMAGE = ASSET_IMAGE;
	exports.ASSET_JSON = ASSET_JSON;
	exports.ASSET_MATERIAL = ASSET_MATERIAL;
	exports.ASSET_MODEL = ASSET_MODEL;
	exports.ASSET_SCRIPT = ASSET_SCRIPT;
	exports.ASSET_SHADER = ASSET_SHADER;
	exports.ASSET_TEXT = ASSET_TEXT;
	exports.ASSET_TEXTURE = ASSET_TEXTURE;
	exports.AXIS_KEY = AXIS_KEY;
	exports.AXIS_MOUSE_X = AXIS_MOUSE_X;
	exports.AXIS_MOUSE_Y = AXIS_MOUSE_Y;
	exports.AXIS_PAD_L_X = AXIS_PAD_L_X;
	exports.AXIS_PAD_L_Y = AXIS_PAD_L_Y;
	exports.AXIS_PAD_R_X = AXIS_PAD_R_X;
	exports.AXIS_PAD_R_Y = AXIS_PAD_R_Y;
	exports.AnimBinder = AnimBinder;
	exports.AnimClip = AnimClip;
	exports.AnimClipHandler = AnimClipHandler;
	exports.AnimComponent = AnimComponent;
	exports.AnimComponentLayer = AnimComponentLayer;
	exports.AnimComponentSystem = AnimComponentSystem;
	exports.AnimController = AnimController;
	exports.AnimCurve = AnimCurve;
	exports.AnimData = AnimData;
	exports.AnimEvaluator = AnimEvaluator;
	exports.AnimEvents = AnimEvents;
	exports.AnimSnapshot = AnimSnapshot;
	exports.AnimStateGraph = AnimStateGraph;
	exports.AnimStateGraphHandler = AnimStateGraphHandler;
	exports.AnimTarget = AnimTarget;
	exports.AnimTrack = AnimTrack;
	exports.Animation = Animation;
	exports.AnimationComponent = AnimationComponent;
	exports.AnimationComponentSystem = AnimationComponentSystem;
	exports.AnimationHandler = AnimationHandler;
	exports.Application = Application;
	exports.Asset = Asset;
	exports.AssetListLoader = AssetListLoader;
	exports.AssetReference = AssetReference;
	exports.AssetRegistry = AssetRegistry;
	exports.AudioHandler = AudioHandler;
	exports.AudioListenerComponent = AudioListenerComponent;
	exports.AudioListenerComponentSystem = AudioListenerComponentSystem;
	exports.AudioSourceComponent = AudioSourceComponent;
	exports.AudioSourceComponentSystem = AudioSourceComponentSystem;
	exports.BAKE_COLOR = BAKE_COLOR;
	exports.BAKE_COLORDIR = BAKE_COLORDIR;
	exports.BLENDEQUATION_ADD = BLENDEQUATION_ADD;
	exports.BLENDEQUATION_MAX = BLENDEQUATION_MAX;
	exports.BLENDEQUATION_MIN = BLENDEQUATION_MIN;
	exports.BLENDEQUATION_REVERSE_SUBTRACT = BLENDEQUATION_REVERSE_SUBTRACT;
	exports.BLENDEQUATION_SUBTRACT = BLENDEQUATION_SUBTRACT;
	exports.BLENDMODE_CONSTANT_ALPHA = BLENDMODE_CONSTANT_ALPHA;
	exports.BLENDMODE_CONSTANT_COLOR = BLENDMODE_CONSTANT_COLOR;
	exports.BLENDMODE_DST_ALPHA = BLENDMODE_DST_ALPHA;
	exports.BLENDMODE_DST_COLOR = BLENDMODE_DST_COLOR;
	exports.BLENDMODE_ONE = BLENDMODE_ONE;
	exports.BLENDMODE_ONE_MINUS_CONSTANT_ALPHA = BLENDMODE_ONE_MINUS_CONSTANT_ALPHA;
	exports.BLENDMODE_ONE_MINUS_CONSTANT_COLOR = BLENDMODE_ONE_MINUS_CONSTANT_COLOR;
	exports.BLENDMODE_ONE_MINUS_DST_ALPHA = BLENDMODE_ONE_MINUS_DST_ALPHA;
	exports.BLENDMODE_ONE_MINUS_DST_COLOR = BLENDMODE_ONE_MINUS_DST_COLOR;
	exports.BLENDMODE_ONE_MINUS_SRC_ALPHA = BLENDMODE_ONE_MINUS_SRC_ALPHA;
	exports.BLENDMODE_ONE_MINUS_SRC_COLOR = BLENDMODE_ONE_MINUS_SRC_COLOR;
	exports.BLENDMODE_SRC_ALPHA = BLENDMODE_SRC_ALPHA;
	exports.BLENDMODE_SRC_ALPHA_SATURATE = BLENDMODE_SRC_ALPHA_SATURATE;
	exports.BLENDMODE_SRC_COLOR = BLENDMODE_SRC_COLOR;
	exports.BLENDMODE_ZERO = BLENDMODE_ZERO;
	exports.BLEND_ADDITIVE = BLEND_ADDITIVE;
	exports.BLEND_ADDITIVEALPHA = BLEND_ADDITIVEALPHA;
	exports.BLEND_MAX = BLEND_MAX;
	exports.BLEND_MIN = BLEND_MIN;
	exports.BLEND_MULTIPLICATIVE = BLEND_MULTIPLICATIVE;
	exports.BLEND_MULTIPLICATIVE2X = BLEND_MULTIPLICATIVE2X;
	exports.BLEND_NONE = BLEND_NONE;
	exports.BLEND_NORMAL = BLEND_NORMAL;
	exports.BLEND_PREMULTIPLIED = BLEND_PREMULTIPLIED;
	exports.BLEND_SCREEN = BLEND_SCREEN;
	exports.BLEND_SUBTRACTIVE = BLEND_SUBTRACTIVE;
	exports.BLUR_BOX = BLUR_BOX;
	exports.BLUR_GAUSSIAN = BLUR_GAUSSIAN;
	exports.BODYFLAG_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
	exports.BODYFLAG_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
	exports.BODYFLAG_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
	exports.BODYGROUP_DEFAULT = BODYGROUP_DEFAULT;
	exports.BODYGROUP_DYNAMIC = BODYGROUP_DYNAMIC;
	exports.BODYGROUP_ENGINE_1 = BODYGROUP_ENGINE_1;
	exports.BODYGROUP_ENGINE_2 = BODYGROUP_ENGINE_2;
	exports.BODYGROUP_ENGINE_3 = BODYGROUP_ENGINE_3;
	exports.BODYGROUP_KINEMATIC = BODYGROUP_KINEMATIC;
	exports.BODYGROUP_NONE = BODYGROUP_NONE;
	exports.BODYGROUP_STATIC = BODYGROUP_STATIC;
	exports.BODYGROUP_TRIGGER = BODYGROUP_TRIGGER;
	exports.BODYGROUP_USER_1 = BODYGROUP_USER_1;
	exports.BODYGROUP_USER_2 = BODYGROUP_USER_2;
	exports.BODYGROUP_USER_3 = BODYGROUP_USER_3;
	exports.BODYGROUP_USER_4 = BODYGROUP_USER_4;
	exports.BODYGROUP_USER_5 = BODYGROUP_USER_5;
	exports.BODYGROUP_USER_6 = BODYGROUP_USER_6;
	exports.BODYGROUP_USER_7 = BODYGROUP_USER_7;
	exports.BODYGROUP_USER_8 = BODYGROUP_USER_8;
	exports.BODYMASK_ALL = BODYMASK_ALL;
	exports.BODYMASK_NONE = BODYMASK_NONE;
	exports.BODYMASK_NOT_STATIC = BODYMASK_NOT_STATIC;
	exports.BODYMASK_NOT_STATIC_KINEMATIC = BODYMASK_NOT_STATIC_KINEMATIC;
	exports.BODYMASK_STATIC = BODYMASK_STATIC;
	exports.BODYSTATE_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
	exports.BODYSTATE_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
	exports.BODYSTATE_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
	exports.BODYSTATE_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
	exports.BODYSTATE_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
	exports.BODYTYPE_DYNAMIC = BODYTYPE_DYNAMIC;
	exports.BODYTYPE_KINEMATIC = BODYTYPE_KINEMATIC;
	exports.BODYTYPE_STATIC = BODYTYPE_STATIC;
	exports.BUFFER_DYNAMIC = BUFFER_DYNAMIC;
	exports.BUFFER_GPUDYNAMIC = BUFFER_GPUDYNAMIC;
	exports.BUFFER_STATIC = BUFFER_STATIC;
	exports.BUFFER_STREAM = BUFFER_STREAM;
	exports.BUTTON_TRANSITION_MODE_SPRITE_CHANGE = BUTTON_TRANSITION_MODE_SPRITE_CHANGE;
	exports.BUTTON_TRANSITION_MODE_TINT = BUTTON_TRANSITION_MODE_TINT;
	exports.BasicMaterial = BasicMaterial;
	exports.Batch = Batch;
	exports.BatchGroup = BatchGroup;
	exports.BatchManager = BatchManager;
	exports.BinaryHandler = BinaryHandler;
	exports.BoundingBox = BoundingBox;
	exports.BoundingSphere = BoundingSphere;
	exports.Bundle = Bundle;
	exports.BundleHandler = BundleHandler;
	exports.BundleRegistry = BundleRegistry;
	exports.ButtonComponent = ButtonComponent;
	exports.ButtonComponentSystem = ButtonComponentSystem;
	exports.CLEARFLAG_COLOR = CLEARFLAG_COLOR;
	exports.CLEARFLAG_DEPTH = CLEARFLAG_DEPTH;
	exports.CLEARFLAG_STENCIL = CLEARFLAG_STENCIL;
	exports.COMPUPDATED_BLEND = COMPUPDATED_BLEND;
	exports.COMPUPDATED_CAMERAS = COMPUPDATED_CAMERAS;
	exports.COMPUPDATED_INSTANCES = COMPUPDATED_INSTANCES;
	exports.COMPUPDATED_LIGHTS = COMPUPDATED_LIGHTS;
	exports.CUBEFACE_NEGX = CUBEFACE_NEGX;
	exports.CUBEFACE_NEGY = CUBEFACE_NEGY;
	exports.CUBEFACE_NEGZ = CUBEFACE_NEGZ;
	exports.CUBEFACE_POSX = CUBEFACE_POSX;
	exports.CUBEFACE_POSY = CUBEFACE_POSY;
	exports.CUBEFACE_POSZ = CUBEFACE_POSZ;
	exports.CUBEPROJ_BOX = CUBEPROJ_BOX;
	exports.CUBEPROJ_NONE = CUBEPROJ_NONE;
	exports.CULLFACE_BACK = CULLFACE_BACK;
	exports.CULLFACE_FRONT = CULLFACE_FRONT;
	exports.CULLFACE_FRONTANDBACK = CULLFACE_FRONTANDBACK;
	exports.CULLFACE_NONE = CULLFACE_NONE;
	exports.CURVE_CARDINAL = CURVE_CARDINAL;
	exports.CURVE_CATMULL = CURVE_CATMULL;
	exports.CURVE_LINEAR = CURVE_LINEAR;
	exports.CURVE_SMOOTHSTEP = CURVE_SMOOTHSTEP;
	exports.CURVE_SPLINE = CURVE_SPLINE;
	exports.CURVE_STEP = CURVE_STEP;
	exports.Camera = Camera;
	exports.CameraComponent = CameraComponent;
	exports.CameraComponentSystem = CameraComponentSystem;
	exports.CanvasFont = CanvasFont;
	exports.CollisionComponent = CollisionComponent;
	exports.CollisionComponentSystem = CollisionComponentSystem;
	exports.Color = Color;
	exports.Command = Command;
	exports.Component = Component;
	exports.ComponentSystem = ComponentSystem;
	exports.ComponentSystemRegistry = ComponentSystemRegistry;
	exports.ContactPoint = ContactPoint;
	exports.ContactResult = ContactResult;
	exports.ContainerHandler = ContainerHandler;
	exports.ContainerResource = ContainerResource;
	exports.ContextCreationError = ContextCreationError;
	exports.Controller = Controller;
	exports.CssHandler = CssHandler;
	exports.CubemapHandler = CubemapHandler;
	exports.Curve = Curve;
	exports.CurveSet = CurveSet;
	exports.DETAILMODE_ADD = DETAILMODE_ADD;
	exports.DETAILMODE_MAX = DETAILMODE_MAX;
	exports.DETAILMODE_MIN = DETAILMODE_MIN;
	exports.DETAILMODE_MUL = DETAILMODE_MUL;
	exports.DETAILMODE_OVERLAY = DETAILMODE_OVERLAY;
	exports.DETAILMODE_SCREEN = DETAILMODE_SCREEN;
	exports.DISTANCE_EXPONENTIAL = DISTANCE_EXPONENTIAL;
	exports.DISTANCE_INVERSE = DISTANCE_INVERSE;
	exports.DISTANCE_LINEAR = DISTANCE_LINEAR;
	exports.DefaultAnimBinder = DefaultAnimBinder;
	exports.ELEMENTTYPE_FLOAT32 = ELEMENTTYPE_FLOAT32;
	exports.ELEMENTTYPE_GROUP = ELEMENTTYPE_GROUP;
	exports.ELEMENTTYPE_IMAGE = ELEMENTTYPE_IMAGE;
	exports.ELEMENTTYPE_INT16 = ELEMENTTYPE_INT16;
	exports.ELEMENTTYPE_INT32 = ELEMENTTYPE_INT32;
	exports.ELEMENTTYPE_INT8 = ELEMENTTYPE_INT8;
	exports.ELEMENTTYPE_TEXT = ELEMENTTYPE_TEXT;
	exports.ELEMENTTYPE_UINT16 = ELEMENTTYPE_UINT16;
	exports.ELEMENTTYPE_UINT32 = ELEMENTTYPE_UINT32;
	exports.ELEMENTTYPE_UINT8 = ELEMENTTYPE_UINT8;
	exports.EMITTERSHAPE_BOX = EMITTERSHAPE_BOX;
	exports.EMITTERSHAPE_SPHERE = EMITTERSHAPE_SPHERE;
	exports.EVENT_KEYDOWN = EVENT_KEYDOWN;
	exports.EVENT_KEYUP = EVENT_KEYUP;
	exports.EVENT_MOUSEDOWN = EVENT_MOUSEDOWN;
	exports.EVENT_MOUSEMOVE = EVENT_MOUSEMOVE;
	exports.EVENT_MOUSEUP = EVENT_MOUSEUP;
	exports.EVENT_MOUSEWHEEL = EVENT_MOUSEWHEEL;
	exports.EVENT_SELECT = EVENT_SELECT;
	exports.EVENT_SELECTEND = EVENT_SELECTEND;
	exports.EVENT_SELECTSTART = EVENT_SELECTSTART;
	exports.EVENT_TOUCHCANCEL = EVENT_TOUCHCANCEL;
	exports.EVENT_TOUCHEND = EVENT_TOUCHEND;
	exports.EVENT_TOUCHMOVE = EVENT_TOUCHMOVE;
	exports.EVENT_TOUCHSTART = EVENT_TOUCHSTART;
	exports.ElementComponent = ElementComponent;
	exports.ElementComponentSystem = ElementComponentSystem;
	exports.ElementDragHelper = ElementDragHelper;
	exports.ElementInput = ElementInput;
	exports.ElementInputEvent = ElementInputEvent;
	exports.ElementMouseEvent = ElementMouseEvent;
	exports.ElementSelectEvent = ElementSelectEvent;
	exports.ElementTouchEvent = ElementTouchEvent;
	exports.Entity = Entity;
	exports.EntityReference = EntityReference;
	exports.EnvLighting = EnvLighting;
	exports.EventHandler = EventHandler;
	exports.FILLMODE_FILL_WINDOW = FILLMODE_FILL_WINDOW;
	exports.FILLMODE_KEEP_ASPECT = FILLMODE_KEEP_ASPECT;
	exports.FILLMODE_NONE = FILLMODE_NONE;
	exports.FILTER_LINEAR = FILTER_LINEAR;
	exports.FILTER_LINEAR_MIPMAP_LINEAR = FILTER_LINEAR_MIPMAP_LINEAR;
	exports.FILTER_LINEAR_MIPMAP_NEAREST = FILTER_LINEAR_MIPMAP_NEAREST;
	exports.FILTER_NEAREST = FILTER_NEAREST;
	exports.FILTER_NEAREST_MIPMAP_LINEAR = FILTER_NEAREST_MIPMAP_LINEAR;
	exports.FILTER_NEAREST_MIPMAP_NEAREST = FILTER_NEAREST_MIPMAP_NEAREST;
	exports.FITTING_BOTH = FITTING_BOTH;
	exports.FITTING_NONE = FITTING_NONE;
	exports.FITTING_SHRINK = FITTING_SHRINK;
	exports.FITTING_STRETCH = FITTING_STRETCH;
	exports.FOG_EXP = FOG_EXP;
	exports.FOG_EXP2 = FOG_EXP2;
	exports.FOG_LINEAR = FOG_LINEAR;
	exports.FOG_NONE = FOG_NONE;
	exports.FONT_BITMAP = FONT_BITMAP;
	exports.FONT_MSDF = FONT_MSDF;
	exports.FRESNEL_NONE = FRESNEL_NONE;
	exports.FRESNEL_SCHLICK = FRESNEL_SCHLICK;
	exports.FUNC_ALWAYS = FUNC_ALWAYS;
	exports.FUNC_EQUAL = FUNC_EQUAL;
	exports.FUNC_GREATER = FUNC_GREATER;
	exports.FUNC_GREATEREQUAL = FUNC_GREATEREQUAL;
	exports.FUNC_LESS = FUNC_LESS;
	exports.FUNC_LESSEQUAL = FUNC_LESSEQUAL;
	exports.FUNC_NEVER = FUNC_NEVER;
	exports.FUNC_NOTEQUAL = FUNC_NOTEQUAL;
	exports.FolderHandler = FolderHandler;
	exports.Font = Font;
	exports.FontHandler = FontHandler;
	exports.ForwardRenderer = ForwardRenderer;
	exports.Frustum = Frustum;
	exports.GAMMA_NONE = GAMMA_NONE;
	exports.GAMMA_SRGB = GAMMA_SRGB;
	exports.GAMMA_SRGBFAST = GAMMA_SRGBFAST;
	exports.GAMMA_SRGBHDR = GAMMA_SRGBHDR;
	exports.GamePads = GamePads;
	exports.GraphNode = GraphNode;
	exports.GraphicsDevice = GraphicsDevice;
	exports.HierarchyHandler = HierarchyHandler;
	exports.HtmlHandler = HtmlHandler;
	exports.Http = Http;
	exports.I18n = I18n;
	exports.INDEXFORMAT_UINT16 = INDEXFORMAT_UINT16;
	exports.INDEXFORMAT_UINT32 = INDEXFORMAT_UINT32;
	exports.INDEXFORMAT_UINT8 = INDEXFORMAT_UINT8;
	exports.INTERPOLATION_CUBIC = INTERPOLATION_CUBIC;
	exports.INTERPOLATION_LINEAR = INTERPOLATION_LINEAR;
	exports.INTERPOLATION_STEP = INTERPOLATION_STEP;
	exports.ImageElement = ImageElement;
	exports.IndexBuffer = IndexBuffer;
	exports.IndexedList = IndexedList;
	exports.JointComponent = JointComponent;
	exports.JointComponentSystem = JointComponentSystem;
	exports.JsonHandler = JsonHandler;
	exports.JsonStandardMaterialParser = JsonStandardMaterialParser;
	exports.KEY_0 = KEY_0;
	exports.KEY_1 = KEY_1;
	exports.KEY_2 = KEY_2;
	exports.KEY_3 = KEY_3;
	exports.KEY_4 = KEY_4;
	exports.KEY_5 = KEY_5;
	exports.KEY_6 = KEY_6;
	exports.KEY_7 = KEY_7;
	exports.KEY_8 = KEY_8;
	exports.KEY_9 = KEY_9;
	exports.KEY_A = KEY_A;
	exports.KEY_ADD = KEY_ADD;
	exports.KEY_ALT = KEY_ALT;
	exports.KEY_B = KEY_B;
	exports.KEY_BACKSPACE = KEY_BACKSPACE;
	exports.KEY_BACK_SLASH = KEY_BACK_SLASH;
	exports.KEY_C = KEY_C;
	exports.KEY_CAPS_LOCK = KEY_CAPS_LOCK;
	exports.KEY_CLOSE_BRACKET = KEY_CLOSE_BRACKET;
	exports.KEY_COMMA = KEY_COMMA;
	exports.KEY_CONTEXT_MENU = KEY_CONTEXT_MENU;
	exports.KEY_CONTROL = KEY_CONTROL;
	exports.KEY_D = KEY_D;
	exports.KEY_DECIMAL = KEY_DECIMAL;
	exports.KEY_DELETE = KEY_DELETE;
	exports.KEY_DIVIDE = KEY_DIVIDE;
	exports.KEY_DOWN = KEY_DOWN;
	exports.KEY_E = KEY_E;
	exports.KEY_END = KEY_END;
	exports.KEY_ENTER = KEY_ENTER;
	exports.KEY_EQUAL = KEY_EQUAL;
	exports.KEY_ESCAPE = KEY_ESCAPE;
	exports.KEY_F = KEY_F;
	exports.KEY_F1 = KEY_F1;
	exports.KEY_F10 = KEY_F10;
	exports.KEY_F11 = KEY_F11;
	exports.KEY_F12 = KEY_F12;
	exports.KEY_F2 = KEY_F2;
	exports.KEY_F3 = KEY_F3;
	exports.KEY_F4 = KEY_F4;
	exports.KEY_F5 = KEY_F5;
	exports.KEY_F6 = KEY_F6;
	exports.KEY_F7 = KEY_F7;
	exports.KEY_F8 = KEY_F8;
	exports.KEY_F9 = KEY_F9;
	exports.KEY_G = KEY_G;
	exports.KEY_H = KEY_H;
	exports.KEY_HOME = KEY_HOME;
	exports.KEY_I = KEY_I;
	exports.KEY_INSERT = KEY_INSERT;
	exports.KEY_J = KEY_J;
	exports.KEY_K = KEY_K;
	exports.KEY_L = KEY_L;
	exports.KEY_LEFT = KEY_LEFT;
	exports.KEY_M = KEY_M;
	exports.KEY_META = KEY_META;
	exports.KEY_MULTIPLY = KEY_MULTIPLY;
	exports.KEY_N = KEY_N;
	exports.KEY_NUMPAD_0 = KEY_NUMPAD_0;
	exports.KEY_NUMPAD_1 = KEY_NUMPAD_1;
	exports.KEY_NUMPAD_2 = KEY_NUMPAD_2;
	exports.KEY_NUMPAD_3 = KEY_NUMPAD_3;
	exports.KEY_NUMPAD_4 = KEY_NUMPAD_4;
	exports.KEY_NUMPAD_5 = KEY_NUMPAD_5;
	exports.KEY_NUMPAD_6 = KEY_NUMPAD_6;
	exports.KEY_NUMPAD_7 = KEY_NUMPAD_7;
	exports.KEY_NUMPAD_8 = KEY_NUMPAD_8;
	exports.KEY_NUMPAD_9 = KEY_NUMPAD_9;
	exports.KEY_O = KEY_O;
	exports.KEY_OPEN_BRACKET = KEY_OPEN_BRACKET;
	exports.KEY_P = KEY_P;
	exports.KEY_PAGE_DOWN = KEY_PAGE_DOWN;
	exports.KEY_PAGE_UP = KEY_PAGE_UP;
	exports.KEY_PAUSE = KEY_PAUSE;
	exports.KEY_PERIOD = KEY_PERIOD;
	exports.KEY_PRINT_SCREEN = KEY_PRINT_SCREEN;
	exports.KEY_Q = KEY_Q;
	exports.KEY_R = KEY_R;
	exports.KEY_RETURN = KEY_RETURN;
	exports.KEY_RIGHT = KEY_RIGHT;
	exports.KEY_S = KEY_S;
	exports.KEY_SEMICOLON = KEY_SEMICOLON;
	exports.KEY_SEPARATOR = KEY_SEPARATOR;
	exports.KEY_SHIFT = KEY_SHIFT;
	exports.KEY_SLASH = KEY_SLASH;
	exports.KEY_SPACE = KEY_SPACE;
	exports.KEY_SUBTRACT = KEY_SUBTRACT;
	exports.KEY_T = KEY_T;
	exports.KEY_TAB = KEY_TAB;
	exports.KEY_U = KEY_U;
	exports.KEY_UP = KEY_UP;
	exports.KEY_V = KEY_V;
	exports.KEY_W = KEY_W;
	exports.KEY_WINDOWS = KEY_WINDOWS;
	exports.KEY_X = KEY_X;
	exports.KEY_Y = KEY_Y;
	exports.KEY_Z = KEY_Z;
	exports.Key = Key;
	exports.Keyboard = Keyboard;
	exports.KeyboardEvent = KeyboardEvent;
	exports.LAYERID_DEPTH = LAYERID_DEPTH;
	exports.LAYERID_IMMEDIATE = LAYERID_IMMEDIATE;
	exports.LAYERID_SKYBOX = LAYERID_SKYBOX;
	exports.LAYERID_UI = LAYERID_UI;
	exports.LAYERID_WORLD = LAYERID_WORLD;
	exports.LAYER_FX = LAYER_FX;
	exports.LAYER_GIZMO = LAYER_GIZMO;
	exports.LAYER_HUD = LAYER_HUD;
	exports.LAYER_WORLD = LAYER_WORLD;
	exports.LIGHTFALLOFF_INVERSESQUARED = LIGHTFALLOFF_INVERSESQUARED;
	exports.LIGHTFALLOFF_LINEAR = LIGHTFALLOFF_LINEAR;
	exports.LIGHTSHAPE_DISK = LIGHTSHAPE_DISK;
	exports.LIGHTSHAPE_PUNCTUAL = LIGHTSHAPE_PUNCTUAL;
	exports.LIGHTSHAPE_RECT = LIGHTSHAPE_RECT;
	exports.LIGHTSHAPE_SPHERE = LIGHTSHAPE_SPHERE;
	exports.LIGHTTYPE_DIRECTIONAL = LIGHTTYPE_DIRECTIONAL;
	exports.LIGHTTYPE_OMNI = LIGHTTYPE_OMNI;
	exports.LIGHTTYPE_POINT = LIGHTTYPE_POINT;
	exports.LIGHTTYPE_SPOT = LIGHTTYPE_SPOT;
	exports.LINEBATCH_GIZMO = LINEBATCH_GIZMO;
	exports.LINEBATCH_OVERLAY = LINEBATCH_OVERLAY;
	exports.LINEBATCH_WORLD = LINEBATCH_WORLD;
	exports.Layer = Layer;
	exports.LayerComposition = LayerComposition;
	exports.LayoutCalculator = LayoutCalculator;
	exports.LayoutChildComponent = LayoutChildComponent;
	exports.LayoutChildComponentSystem = LayoutChildComponentSystem;
	exports.LayoutGroupComponent = LayoutGroupComponent;
	exports.LayoutGroupComponentSystem = LayoutGroupComponentSystem;
	exports.Light = Light;
	exports.LightComponent = LightComponent;
	exports.LightComponentSystem = LightComponentSystem;
	exports.LightingParams = LightingParams;
	exports.Lightmapper = Lightmapper;
	exports.LocalizedAsset = LocalizedAsset;
	exports.MASK_AFFECT_DYNAMIC = MASK_AFFECT_DYNAMIC;
	exports.MASK_AFFECT_LIGHTMAPPED = MASK_AFFECT_LIGHTMAPPED;
	exports.MASK_BAKE = MASK_BAKE;
	exports.MOTION_FREE = MOTION_FREE;
	exports.MOTION_LIMITED = MOTION_LIMITED;
	exports.MOTION_LOCKED = MOTION_LOCKED;
	exports.MOUSEBUTTON_LEFT = MOUSEBUTTON_LEFT;
	exports.MOUSEBUTTON_MIDDLE = MOUSEBUTTON_MIDDLE;
	exports.MOUSEBUTTON_NONE = MOUSEBUTTON_NONE;
	exports.MOUSEBUTTON_RIGHT = MOUSEBUTTON_RIGHT;
	exports.Mat3 = Mat3;
	exports.Mat4 = Mat4;
	exports.Material = Material;
	exports.MaterialHandler = MaterialHandler;
	exports.Mesh = Mesh;
	exports.MeshInstance = MeshInstance;
	exports.Model = Model;
	exports.ModelComponent = ModelComponent;
	exports.ModelComponentSystem = ModelComponentSystem;
	exports.ModelHandler = ModelHandler;
	exports.Morph = Morph;
	exports.MorphInstance = MorphInstance;
	exports.MorphTarget = MorphTarget;
	exports.Mouse = Mouse;
	exports.MouseEvent = MouseEvent;
	exports.Node = Node;
	exports.ORIENTATION_HORIZONTAL = ORIENTATION_HORIZONTAL;
	exports.ORIENTATION_VERTICAL = ORIENTATION_VERTICAL;
	exports.OrientedBox = OrientedBox;
	exports.PAD_1 = PAD_1;
	exports.PAD_2 = PAD_2;
	exports.PAD_3 = PAD_3;
	exports.PAD_4 = PAD_4;
	exports.PAD_DOWN = PAD_DOWN;
	exports.PAD_FACE_1 = PAD_FACE_1;
	exports.PAD_FACE_2 = PAD_FACE_2;
	exports.PAD_FACE_3 = PAD_FACE_3;
	exports.PAD_FACE_4 = PAD_FACE_4;
	exports.PAD_LEFT = PAD_LEFT;
	exports.PAD_L_SHOULDER_1 = PAD_L_SHOULDER_1;
	exports.PAD_L_SHOULDER_2 = PAD_L_SHOULDER_2;
	exports.PAD_L_STICK_BUTTON = PAD_L_STICK_BUTTON;
	exports.PAD_L_STICK_X = PAD_L_STICK_X;
	exports.PAD_L_STICK_Y = PAD_L_STICK_Y;
	exports.PAD_RIGHT = PAD_RIGHT;
	exports.PAD_R_SHOULDER_1 = PAD_R_SHOULDER_1;
	exports.PAD_R_SHOULDER_2 = PAD_R_SHOULDER_2;
	exports.PAD_R_STICK_BUTTON = PAD_R_STICK_BUTTON;
	exports.PAD_R_STICK_X = PAD_R_STICK_X;
	exports.PAD_R_STICK_Y = PAD_R_STICK_Y;
	exports.PAD_SELECT = PAD_SELECT;
	exports.PAD_START = PAD_START;
	exports.PAD_UP = PAD_UP;
	exports.PAD_VENDOR = PAD_VENDOR;
	exports.PARTICLEMODE_CPU = PARTICLEMODE_CPU;
	exports.PARTICLEMODE_GPU = PARTICLEMODE_GPU;
	exports.PARTICLEORIENTATION_EMITTER = PARTICLEORIENTATION_EMITTER;
	exports.PARTICLEORIENTATION_SCREEN = PARTICLEORIENTATION_SCREEN;
	exports.PARTICLEORIENTATION_WORLD = PARTICLEORIENTATION_WORLD;
	exports.PARTICLESORT_DISTANCE = PARTICLESORT_DISTANCE;
	exports.PARTICLESORT_NEWER_FIRST = PARTICLESORT_NEWER_FIRST;
	exports.PARTICLESORT_NONE = PARTICLESORT_NONE;
	exports.PARTICLESORT_OLDER_FIRST = PARTICLESORT_OLDER_FIRST;
	exports.PIXELFORMAT_111110F = PIXELFORMAT_111110F;
	exports.PIXELFORMAT_A8 = PIXELFORMAT_A8;
	exports.PIXELFORMAT_ASTC_4x4 = PIXELFORMAT_ASTC_4x4;
	exports.PIXELFORMAT_ATC_RGB = PIXELFORMAT_ATC_RGB;
	exports.PIXELFORMAT_ATC_RGBA = PIXELFORMAT_ATC_RGBA;
	exports.PIXELFORMAT_DEPTH = PIXELFORMAT_DEPTH;
	exports.PIXELFORMAT_DEPTHSTENCIL = PIXELFORMAT_DEPTHSTENCIL;
	exports.PIXELFORMAT_DXT1 = PIXELFORMAT_DXT1;
	exports.PIXELFORMAT_DXT3 = PIXELFORMAT_DXT3;
	exports.PIXELFORMAT_DXT5 = PIXELFORMAT_DXT5;
	exports.PIXELFORMAT_ETC1 = PIXELFORMAT_ETC1;
	exports.PIXELFORMAT_ETC2_RGB = PIXELFORMAT_ETC2_RGB;
	exports.PIXELFORMAT_ETC2_RGBA = PIXELFORMAT_ETC2_RGBA;
	exports.PIXELFORMAT_L8 = PIXELFORMAT_L8;
	exports.PIXELFORMAT_L8_A8 = PIXELFORMAT_L8_A8;
	exports.PIXELFORMAT_PVRTC_2BPP_RGBA_1 = PIXELFORMAT_PVRTC_2BPP_RGBA_1;
	exports.PIXELFORMAT_PVRTC_2BPP_RGB_1 = PIXELFORMAT_PVRTC_2BPP_RGB_1;
	exports.PIXELFORMAT_PVRTC_4BPP_RGBA_1 = PIXELFORMAT_PVRTC_4BPP_RGBA_1;
	exports.PIXELFORMAT_PVRTC_4BPP_RGB_1 = PIXELFORMAT_PVRTC_4BPP_RGB_1;
	exports.PIXELFORMAT_R32F = PIXELFORMAT_R32F;
	exports.PIXELFORMAT_R4_G4_B4_A4 = PIXELFORMAT_R4_G4_B4_A4;
	exports.PIXELFORMAT_R5_G5_B5_A1 = PIXELFORMAT_R5_G5_B5_A1;
	exports.PIXELFORMAT_R5_G6_B5 = PIXELFORMAT_R5_G6_B5;
	exports.PIXELFORMAT_R8_G8_B8 = PIXELFORMAT_R8_G8_B8;
	exports.PIXELFORMAT_R8_G8_B8_A8 = PIXELFORMAT_R8_G8_B8_A8;
	exports.PIXELFORMAT_RGB16F = PIXELFORMAT_RGB16F;
	exports.PIXELFORMAT_RGB32F = PIXELFORMAT_RGB32F;
	exports.PIXELFORMAT_RGBA16F = PIXELFORMAT_RGBA16F;
	exports.PIXELFORMAT_RGBA32F = PIXELFORMAT_RGBA32F;
	exports.PIXELFORMAT_SRGB = PIXELFORMAT_SRGB;
	exports.PIXELFORMAT_SRGBA = PIXELFORMAT_SRGBA;
	exports.PRIMITIVE_LINELOOP = PRIMITIVE_LINELOOP;
	exports.PRIMITIVE_LINES = PRIMITIVE_LINES;
	exports.PRIMITIVE_LINESTRIP = PRIMITIVE_LINESTRIP;
	exports.PRIMITIVE_POINTS = PRIMITIVE_POINTS;
	exports.PRIMITIVE_TRIANGLES = PRIMITIVE_TRIANGLES;
	exports.PRIMITIVE_TRIFAN = PRIMITIVE_TRIFAN;
	exports.PRIMITIVE_TRISTRIP = PRIMITIVE_TRISTRIP;
	exports.PROJECTION_ORTHOGRAPHIC = PROJECTION_ORTHOGRAPHIC;
	exports.PROJECTION_PERSPECTIVE = PROJECTION_PERSPECTIVE;
	exports.ParticleEmitter = ParticleEmitter;
	exports.ParticleSystemComponent = ParticleSystemComponent;
	exports.ParticleSystemComponentSystem = ParticleSystemComponentSystem;
	exports.PhongMaterial = PhongMaterial;
	exports.Picker = Picker;
	exports.Plane = Plane;
	exports.PostEffect = PostEffect$1;
	exports.PostEffectQueue = PostEffectQueue;
	exports.ProgramLibrary = ProgramLibrary;
	exports.Quat = Quat;
	exports.RENDERSTYLE_POINTS = RENDERSTYLE_POINTS;
	exports.RENDERSTYLE_SOLID = RENDERSTYLE_SOLID;
	exports.RENDERSTYLE_WIREFRAME = RENDERSTYLE_WIREFRAME;
	exports.RESOLUTION_AUTO = RESOLUTION_AUTO;
	exports.RESOLUTION_FIXED = RESOLUTION_FIXED;
	exports.RIGIDBODY_ACTIVE_TAG = RIGIDBODY_ACTIVE_TAG;
	exports.RIGIDBODY_CF_KINEMATIC_OBJECT = RIGIDBODY_CF_KINEMATIC_OBJECT;
	exports.RIGIDBODY_CF_NORESPONSE_OBJECT = RIGIDBODY_CF_NORESPONSE_OBJECT;
	exports.RIGIDBODY_CF_STATIC_OBJECT = RIGIDBODY_CF_STATIC_OBJECT;
	exports.RIGIDBODY_DISABLE_DEACTIVATION = RIGIDBODY_DISABLE_DEACTIVATION;
	exports.RIGIDBODY_DISABLE_SIMULATION = RIGIDBODY_DISABLE_SIMULATION;
	exports.RIGIDBODY_ISLAND_SLEEPING = RIGIDBODY_ISLAND_SLEEPING;
	exports.RIGIDBODY_TYPE_DYNAMIC = RIGIDBODY_TYPE_DYNAMIC;
	exports.RIGIDBODY_TYPE_KINEMATIC = RIGIDBODY_TYPE_KINEMATIC;
	exports.RIGIDBODY_TYPE_STATIC = RIGIDBODY_TYPE_STATIC;
	exports.RIGIDBODY_WANTS_DEACTIVATION = RIGIDBODY_WANTS_DEACTIVATION;
	exports.Ray = Ray;
	exports.RaycastResult = RaycastResult;
	exports.ReadStream = ReadStream;
	exports.RenderComponent = RenderComponent;
	exports.RenderComponentSystem = RenderComponentSystem;
	exports.RenderHandler = RenderHandler;
	exports.RenderTarget = RenderTarget;
	exports.ResourceHandler = ResourceHandler;
	exports.ResourceLoader = ResourceLoader;
	exports.RigidBodyComponent = RigidBodyComponent;
	exports.RigidBodyComponentSystem = RigidBodyComponentSystem;
	exports.SCALEMODE_BLEND = SCALEMODE_BLEND;
	exports.SCALEMODE_NONE = SCALEMODE_NONE;
	exports.SCROLLBAR_VISIBILITY_SHOW_ALWAYS = SCROLLBAR_VISIBILITY_SHOW_ALWAYS;
	exports.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED;
	exports.SCROLL_MODE_BOUNCE = SCROLL_MODE_BOUNCE;
	exports.SCROLL_MODE_CLAMP = SCROLL_MODE_CLAMP;
	exports.SCROLL_MODE_INFINITE = SCROLL_MODE_INFINITE;
	exports.SEMANTIC_ATTR = SEMANTIC_ATTR;
	exports.SEMANTIC_ATTR0 = SEMANTIC_ATTR0;
	exports.SEMANTIC_ATTR1 = SEMANTIC_ATTR1;
	exports.SEMANTIC_ATTR10 = SEMANTIC_ATTR10;
	exports.SEMANTIC_ATTR11 = SEMANTIC_ATTR11;
	exports.SEMANTIC_ATTR12 = SEMANTIC_ATTR12;
	exports.SEMANTIC_ATTR13 = SEMANTIC_ATTR13;
	exports.SEMANTIC_ATTR14 = SEMANTIC_ATTR14;
	exports.SEMANTIC_ATTR15 = SEMANTIC_ATTR15;
	exports.SEMANTIC_ATTR2 = SEMANTIC_ATTR2;
	exports.SEMANTIC_ATTR3 = SEMANTIC_ATTR3;
	exports.SEMANTIC_ATTR4 = SEMANTIC_ATTR4;
	exports.SEMANTIC_ATTR5 = SEMANTIC_ATTR5;
	exports.SEMANTIC_ATTR6 = SEMANTIC_ATTR6;
	exports.SEMANTIC_ATTR7 = SEMANTIC_ATTR7;
	exports.SEMANTIC_ATTR8 = SEMANTIC_ATTR8;
	exports.SEMANTIC_ATTR9 = SEMANTIC_ATTR9;
	exports.SEMANTIC_BLENDINDICES = SEMANTIC_BLENDINDICES;
	exports.SEMANTIC_BLENDWEIGHT = SEMANTIC_BLENDWEIGHT;
	exports.SEMANTIC_COLOR = SEMANTIC_COLOR;
	exports.SEMANTIC_NORMAL = SEMANTIC_NORMAL;
	exports.SEMANTIC_POSITION = SEMANTIC_POSITION;
	exports.SEMANTIC_TANGENT = SEMANTIC_TANGENT;
	exports.SEMANTIC_TEXCOORD = SEMANTIC_TEXCOORD;
	exports.SEMANTIC_TEXCOORD0 = SEMANTIC_TEXCOORD0;
	exports.SEMANTIC_TEXCOORD1 = SEMANTIC_TEXCOORD1;
	exports.SEMANTIC_TEXCOORD2 = SEMANTIC_TEXCOORD2;
	exports.SEMANTIC_TEXCOORD3 = SEMANTIC_TEXCOORD3;
	exports.SEMANTIC_TEXCOORD4 = SEMANTIC_TEXCOORD4;
	exports.SEMANTIC_TEXCOORD5 = SEMANTIC_TEXCOORD5;
	exports.SEMANTIC_TEXCOORD6 = SEMANTIC_TEXCOORD6;
	exports.SEMANTIC_TEXCOORD7 = SEMANTIC_TEXCOORD7;
	exports.SHADERDEF_DIRLM = SHADERDEF_DIRLM;
	exports.SHADERDEF_INSTANCING = SHADERDEF_INSTANCING;
	exports.SHADERDEF_LM = SHADERDEF_LM;
	exports.SHADERDEF_LMAMBIENT = SHADERDEF_LMAMBIENT;
	exports.SHADERDEF_MORPH_NORMAL = SHADERDEF_MORPH_NORMAL;
	exports.SHADERDEF_MORPH_POSITION = SHADERDEF_MORPH_POSITION;
	exports.SHADERDEF_MORPH_TEXTURE_BASED = SHADERDEF_MORPH_TEXTURE_BASED;
	exports.SHADERDEF_NOSHADOW = SHADERDEF_NOSHADOW;
	exports.SHADERDEF_SCREENSPACE = SHADERDEF_SCREENSPACE;
	exports.SHADERDEF_SKIN = SHADERDEF_SKIN;
	exports.SHADERDEF_TANGENTS = SHADERDEF_TANGENTS;
	exports.SHADERDEF_UV0 = SHADERDEF_UV0;
	exports.SHADERDEF_UV1 = SHADERDEF_UV1;
	exports.SHADERDEF_VCOLOR = SHADERDEF_VCOLOR;
	exports.SHADERTAG_MATERIAL = SHADERTAG_MATERIAL;
	exports.SHADER_DEPTH = SHADER_DEPTH;
	exports.SHADER_FORWARD = SHADER_FORWARD;
	exports.SHADER_FORWARDHDR = SHADER_FORWARDHDR;
	exports.SHADER_PICK = SHADER_PICK;
	exports.SHADER_SHADOW = SHADER_SHADOW;
	exports.SHADOWUPDATE_NONE = SHADOWUPDATE_NONE;
	exports.SHADOWUPDATE_REALTIME = SHADOWUPDATE_REALTIME;
	exports.SHADOWUPDATE_THISFRAME = SHADOWUPDATE_THISFRAME;
	exports.SHADOW_COUNT = SHADOW_COUNT;
	exports.SHADOW_DEPTH = SHADOW_DEPTH;
	exports.SHADOW_PCF1 = SHADOW_PCF1;
	exports.SHADOW_PCF3 = SHADOW_PCF3;
	exports.SHADOW_PCF5 = SHADOW_PCF5;
	exports.SHADOW_VSM16 = SHADOW_VSM16;
	exports.SHADOW_VSM32 = SHADOW_VSM32;
	exports.SHADOW_VSM8 = SHADOW_VSM8;
	exports.SORTKEY_DEPTH = SORTKEY_DEPTH;
	exports.SORTKEY_FORWARD = SORTKEY_FORWARD;
	exports.SORTMODE_BACK2FRONT = SORTMODE_BACK2FRONT;
	exports.SORTMODE_CUSTOM = SORTMODE_CUSTOM;
	exports.SORTMODE_FRONT2BACK = SORTMODE_FRONT2BACK;
	exports.SORTMODE_MANUAL = SORTMODE_MANUAL;
	exports.SORTMODE_MATERIALMESH = SORTMODE_MATERIALMESH;
	exports.SORTMODE_NONE = SORTMODE_NONE;
	exports.SPECOCC_AO = SPECOCC_AO;
	exports.SPECOCC_GLOSSDEPENDENT = SPECOCC_GLOSSDEPENDENT;
	exports.SPECOCC_NONE = SPECOCC_NONE;
	exports.SPECULAR_BLINN = SPECULAR_BLINN;
	exports.SPECULAR_PHONG = SPECULAR_PHONG;
	exports.SPRITETYPE_ANIMATED = SPRITETYPE_ANIMATED;
	exports.SPRITETYPE_SIMPLE = SPRITETYPE_SIMPLE;
	exports.SPRITE_RENDERMODE_SIMPLE = SPRITE_RENDERMODE_SIMPLE;
	exports.SPRITE_RENDERMODE_SLICED = SPRITE_RENDERMODE_SLICED;
	exports.SPRITE_RENDERMODE_TILED = SPRITE_RENDERMODE_TILED;
	exports.STENCILOP_DECREMENT = STENCILOP_DECREMENT;
	exports.STENCILOP_DECREMENTWRAP = STENCILOP_DECREMENTWRAP;
	exports.STENCILOP_INCREMENT = STENCILOP_INCREMENT;
	exports.STENCILOP_INCREMENTWRAP = STENCILOP_INCREMENTWRAP;
	exports.STENCILOP_INVERT = STENCILOP_INVERT;
	exports.STENCILOP_KEEP = STENCILOP_KEEP;
	exports.STENCILOP_REPLACE = STENCILOP_REPLACE;
	exports.STENCILOP_ZERO = STENCILOP_ZERO;
	exports.Scene = Scene;
	exports.SceneHandler = SceneHandler;
	exports.SceneRegistry = SceneRegistry;
	exports.SceneRegistryItem = SceneRegistryItem;
	exports.SceneSettingsHandler = SceneSettingsHandler;
	exports.ScopeId = ScopeId;
	exports.ScopeSpace = ScopeSpace;
	exports.ScreenComponent = ScreenComponent;
	exports.ScreenComponentSystem = ScreenComponentSystem;
	exports.ScriptAttributes = ScriptAttributes;
	exports.ScriptComponent = ScriptComponent;
	exports.ScriptComponentSystem = ScriptComponentSystem;
	exports.ScriptHandler = ScriptHandler;
	exports.ScriptLegacyComponent = ScriptLegacyComponent;
	exports.ScriptLegacyComponentSystem = ScriptLegacyComponentSystem;
	exports.ScriptRegistry = ScriptRegistry;
	exports.ScriptType = ScriptType;
	exports.ScrollViewComponent = ScrollViewComponent;
	exports.ScrollViewComponentSystem = ScrollViewComponentSystem;
	exports.ScrollbarComponent = ScrollbarComponent;
	exports.ScrollbarComponentSystem = ScrollbarComponentSystem;
	exports.Shader = Shader;
	exports.ShaderHandler = ShaderHandler;
	exports.SingleContactResult = SingleContactResult;
	exports.Skeleton = Skeleton;
	exports.Skin = Skin;
	exports.SkinBatchInstance = SkinBatchInstance;
	exports.SkinInstance = SkinInstance;
	exports.SortedLoopArray = SortedLoopArray;
	exports.Sound = Sound;
	exports.SoundComponent = SoundComponent;
	exports.SoundComponentSystem = SoundComponentSystem;
	exports.SoundInstance = SoundInstance;
	exports.SoundInstance3d = SoundInstance3d;
	exports.SoundManager = SoundManager;
	exports.SoundSlot = SoundSlot;
	exports.Sprite = Sprite;
	exports.SpriteAnimationClip = SpriteAnimationClip;
	exports.SpriteComponent = SpriteComponent;
	exports.SpriteComponentSystem = SpriteComponentSystem;
	exports.SpriteHandler = SpriteHandler;
	exports.StandardMaterial = StandardMaterial;
	exports.StencilParameters = StencilParameters;
	exports.TEXHINT_ASSET = TEXHINT_ASSET;
	exports.TEXHINT_LIGHTMAP = TEXHINT_LIGHTMAP;
	exports.TEXHINT_NONE = TEXHINT_NONE;
	exports.TEXHINT_SHADOWMAP = TEXHINT_SHADOWMAP;
	exports.TEXTURELOCK_READ = TEXTURELOCK_READ;
	exports.TEXTURELOCK_WRITE = TEXTURELOCK_WRITE;
	exports.TEXTUREPROJECTION_CUBE = TEXTUREPROJECTION_CUBE;
	exports.TEXTUREPROJECTION_EQUIRECT = TEXTUREPROJECTION_EQUIRECT;
	exports.TEXTUREPROJECTION_NONE = TEXTUREPROJECTION_NONE;
	exports.TEXTUREPROJECTION_OCTAHEDRAL = TEXTUREPROJECTION_OCTAHEDRAL;
	exports.TEXTURETYPE_DEFAULT = TEXTURETYPE_DEFAULT;
	exports.TEXTURETYPE_RGBE = TEXTURETYPE_RGBE;
	exports.TEXTURETYPE_RGBM = TEXTURETYPE_RGBM;
	exports.TEXTURETYPE_SWIZZLEGGGR = TEXTURETYPE_SWIZZLEGGGR;
	exports.TONEMAP_ACES = TONEMAP_ACES;
	exports.TONEMAP_ACES2 = TONEMAP_ACES2;
	exports.TONEMAP_FILMIC = TONEMAP_FILMIC;
	exports.TONEMAP_HEJL = TONEMAP_HEJL;
	exports.TONEMAP_LINEAR = TONEMAP_LINEAR;
	exports.TYPE_FLOAT32 = TYPE_FLOAT32;
	exports.TYPE_INT16 = TYPE_INT16;
	exports.TYPE_INT32 = TYPE_INT32;
	exports.TYPE_INT8 = TYPE_INT8;
	exports.TYPE_UINT16 = TYPE_UINT16;
	exports.TYPE_UINT32 = TYPE_UINT32;
	exports.TYPE_UINT8 = TYPE_UINT8;
	exports.Tags = Tags;
	exports.Template = Template;
	exports.TemplateHandler = TemplateHandler;
	exports.TextElement = TextElement;
	exports.TextHandler = TextHandler;
	exports.Texture = Texture;
	exports.TextureAtlas = TextureAtlas;
	exports.TextureAtlasHandler = TextureAtlasHandler;
	exports.TextureHandler = TextureHandler;
	exports.TextureParser = TextureParser;
	exports.Timer = Timer;
	exports.Touch = Touch;
	exports.TouchDevice = TouchDevice;
	exports.TouchEvent = TouchEvent;
	exports.TransformFeedback = TransformFeedback;
	exports.UNIFORMTYPE_BOOL = UNIFORMTYPE_BOOL;
	exports.UNIFORMTYPE_BVEC2 = UNIFORMTYPE_BVEC2;
	exports.UNIFORMTYPE_BVEC3 = UNIFORMTYPE_BVEC3;
	exports.UNIFORMTYPE_BVEC4 = UNIFORMTYPE_BVEC4;
	exports.UNIFORMTYPE_FLOAT = UNIFORMTYPE_FLOAT;
	exports.UNIFORMTYPE_FLOATARRAY = UNIFORMTYPE_FLOATARRAY;
	exports.UNIFORMTYPE_INT = UNIFORMTYPE_INT;
	exports.UNIFORMTYPE_IVEC2 = UNIFORMTYPE_IVEC2;
	exports.UNIFORMTYPE_IVEC3 = UNIFORMTYPE_IVEC3;
	exports.UNIFORMTYPE_IVEC4 = UNIFORMTYPE_IVEC4;
	exports.UNIFORMTYPE_MAT2 = UNIFORMTYPE_MAT2;
	exports.UNIFORMTYPE_MAT3 = UNIFORMTYPE_MAT3;
	exports.UNIFORMTYPE_MAT4 = UNIFORMTYPE_MAT4;
	exports.UNIFORMTYPE_TEXTURE2D = UNIFORMTYPE_TEXTURE2D;
	exports.UNIFORMTYPE_TEXTURE2D_SHADOW = UNIFORMTYPE_TEXTURE2D_SHADOW;
	exports.UNIFORMTYPE_TEXTURE3D = UNIFORMTYPE_TEXTURE3D;
	exports.UNIFORMTYPE_TEXTURECUBE = UNIFORMTYPE_TEXTURECUBE;
	exports.UNIFORMTYPE_TEXTURECUBE_SHADOW = UNIFORMTYPE_TEXTURECUBE_SHADOW;
	exports.UNIFORMTYPE_VEC2 = UNIFORMTYPE_VEC2;
	exports.UNIFORMTYPE_VEC2ARRAY = UNIFORMTYPE_VEC2ARRAY;
	exports.UNIFORMTYPE_VEC3 = UNIFORMTYPE_VEC3;
	exports.UNIFORMTYPE_VEC3ARRAY = UNIFORMTYPE_VEC3ARRAY;
	exports.UNIFORMTYPE_VEC4 = UNIFORMTYPE_VEC4;
	exports.UNIFORMTYPE_VEC4ARRAY = UNIFORMTYPE_VEC4ARRAY;
	exports.URI = URI;
	exports.UnsupportedBrowserError = UnsupportedBrowserError;
	exports.VIEW_CENTER = VIEW_CENTER;
	exports.VIEW_LEFT = VIEW_LEFT;
	exports.VIEW_RIGHT = VIEW_RIGHT;
	exports.Vec2 = Vec2;
	exports.Vec3 = Vec3;
	exports.Vec4 = Vec4;
	exports.VertexBuffer = VertexBuffer;
	exports.VertexFormat = VertexFormat;
	exports.VertexIterator = VertexIterator;
	exports.VrDisplay = VrDisplay;
	exports.VrManager = VrManager;
	exports.WebglGraphicsDevice = WebglGraphicsDevice;
	exports.WorldClusters = WorldClusters;
	exports.XRDEPTHSENSINGFORMAT_F32 = XRDEPTHSENSINGFORMAT_F32;
	exports.XRDEPTHSENSINGFORMAT_L8A8 = XRDEPTHSENSINGFORMAT_L8A8;
	exports.XRDEPTHSENSINGUSAGE_CPU = XRDEPTHSENSINGUSAGE_CPU;
	exports.XRDEPTHSENSINGUSAGE_GPU = XRDEPTHSENSINGUSAGE_GPU;
	exports.XRHAND_LEFT = XRHAND_LEFT;
	exports.XRHAND_NONE = XRHAND_NONE;
	exports.XRHAND_RIGHT = XRHAND_RIGHT;
	exports.XRSPACE_BOUNDEDFLOOR = XRSPACE_BOUNDEDFLOOR;
	exports.XRSPACE_LOCAL = XRSPACE_LOCAL;
	exports.XRSPACE_LOCALFLOOR = XRSPACE_LOCALFLOOR;
	exports.XRSPACE_UNBOUNDED = XRSPACE_UNBOUNDED;
	exports.XRSPACE_VIEWER = XRSPACE_VIEWER;
	exports.XRTARGETRAY_GAZE = XRTARGETRAY_GAZE;
	exports.XRTARGETRAY_POINTER = XRTARGETRAY_POINTER;
	exports.XRTARGETRAY_SCREEN = XRTARGETRAY_SCREEN;
	exports.XRTRACKABLE_MESH = XRTRACKABLE_MESH;
	exports.XRTRACKABLE_PLANE = XRTRACKABLE_PLANE;
	exports.XRTRACKABLE_POINT = XRTRACKABLE_POINT;
	exports.XRTYPE_AR = XRTYPE_AR;
	exports.XRTYPE_INLINE = XRTYPE_INLINE;
	exports.XRTYPE_VR = XRTYPE_VR;
	exports.XrDepthSensing = XrDepthSensing;
	exports.XrDomOverlay = XrDomOverlay;
	exports.XrHitTest = XrHitTest;
	exports.XrHitTestSource = XrHitTestSource;
	exports.XrImageTracking = XrImageTracking;
	exports.XrInput = XrInput;
	exports.XrInputSource = XrInputSource;
	exports.XrLightEstimation = XrLightEstimation;
	exports.XrManager = XrManager;
	exports.XrPlane = XrPlane;
	exports.XrPlaneDetection = XrPlaneDetection;
	exports.XrTrackedImage = XrTrackedImage;
	exports.ZoneComponent = ZoneComponent;
	exports.ZoneComponentSystem = ZoneComponentSystem;
	exports.anim = anim;
	exports.apps = apps;
	exports.asset = asset;
	exports.audio = audio;
	exports.basisInitialize = basisInitialize;
	exports.basisSetDownloadConfig = basisSetDownloadConfig;
	exports.basisTranscode = basisTranscode;
	exports.calculateNormals = calculateNormals;
	exports.calculateTangents = calculateTangents;
	exports.common = common;
	exports.config = config;
	exports.createBox = createBox;
	exports.createCapsule = createCapsule;
	exports.createCone = createCone;
	exports.createCylinder = createCylinder;
	exports.createMesh = createMesh$1;
	exports.createPlane = createPlane;
	exports.createScript = createScript;
	exports.createSphere = createSphere;
	exports.createStyle = createStyle;
	exports.createTorus = createTorus;
	exports.createURI = createURI;
	exports.data = data;
	exports.drawFullscreenQuad = drawFullscreenQuad;
	exports.drawQuadWithShader = drawQuadWithShader;
	exports.drawTexture = drawTexture;
	exports.events = events;
	exports.extend = extend;
	exports.fw = fw;
	exports.getTouchTargetCoords = getTouchTargetCoords;
	exports.gfx = gfx;
	exports.guid = guid;
	exports.http = http;
	exports.inherits = inherits;
	exports.input = input;
	exports.isDefined = isDefined;
	exports.log = log;
	exports.makeArray = makeArray;
	exports.math = math;
	exports.now = now;
	exports.path = path;
	exports.platform = platform;
	exports.posteffect = posteffect;
	exports.prefilterCubemap = prefilterCubemap;
	exports.programlib = programlib;
	exports.registerScript = registerScript;
	exports.reprojectTexture = reprojectTexture;
	exports.revision = revision;
	exports.scene = scene;
	exports.script = script;
	exports.semanticToLocation = semanticToLocation;
	exports.shFromCubemap = shFromCubemap;
	exports.shaderChunks = shaderChunks;
	exports.shadowTypeToString = shadowTypeToString;
	exports.shape = shape;
	exports.string = string;
	exports.time = time;
	exports.type = type$1;
	exports.typedArrayIndexFormats = typedArrayIndexFormats;
	exports.typedArrayIndexFormatsByteSize = typedArrayIndexFormatsByteSize;
	exports.typedArrayToType = typedArrayToType;
	exports.typedArrayTypes = typedArrayTypes;
	exports.typedArrayTypesByteSize = typedArrayTypesByteSize;
	exports.version = version;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
