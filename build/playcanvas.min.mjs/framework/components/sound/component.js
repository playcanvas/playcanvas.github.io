import"../../../core/tracing.js";import{DISTANCE_LINEAR as t}from"../../../audio/constants.js";import{Component as s}from"../component.js";import{SoundSlot as e}from"./slot.js";class n extends s{constructor(s,e){super(s,e),this._volume=1,this._pitch=1,this._positional=!0,this._refDistance=1,this._maxDistance=1e4,this._rollOffFactor=1,this._distanceModel=t,this._slots={},this._playingBeforeDisable={}}_updateSoundInstances(t,s,e){const n=this._slots;for(const o in n){const i=n[o];if(!i.overlap){const n=i.instances;for(let o=0,a=n.length;o<a;o++)n[o][t]=e?i[t]*s:s}}}set distanceModel(t){this._distanceModel=t,this._updateSoundInstances("distanceModel",t,!1)}get distanceModel(){return this._distanceModel}set maxDistance(t){this._maxDistance=t,this._updateSoundInstances("maxDistance",t,!1)}get maxDistance(){return this._maxDistance}set refDistance(t){this._refDistance=t,this._updateSoundInstances("refDistance",t,!1)}get refDistance(){return this._refDistance}set rollOffFactor(t){this._rollOffFactor=t,this._updateSoundInstances("rollOffFactor",t,!1)}get rollOffFactor(){return this._rollOffFactor}set pitch(t){this._pitch=t,this._updateSoundInstances("pitch",t,!0)}get pitch(){return this._pitch}set volume(t){this._volume=t,this._updateSoundInstances("volume",t,!0)}get volume(){return this._volume}set positional(t){this._positional=t;const s=this._slots;for(const t in s){const e=s[t];if(!e.overlap){const t=e.instances;for(let s=t.length-1;s>=0;s--){const n=t[s].isPlaying||t[s].isSuspended,o=t[s].currentTime;n&&t[s].stop();const i=e._createInstance();n&&(i.play(),i.currentTime=o),t.push(i)}}}}get positional(){return this._positional}set slots(t){const s=this._slots;if(s)for(const t in s)s[t].stop();const n={};for(const s in t)t[s]instanceof e?n[t[s].name]=t[s]:t[s].name&&(n[t[s].name]=new e(this,t[s].name,t[s]));this._slots=n,this.enabled&&this.entity.enabled&&this.onEnable()}get slots(){return this._slots}onEnable(){if(this.system._inTools)return;const t=this._slots,s=this._playingBeforeDisable;for(const e in t){const n=t[e];n.autoPlay&&n.isStopped?n.play():s[e]?n.resume():n.isLoaded||n.load()}}onDisable(){const t=this._slots,s={};for(const e in t)t[e].overlap||t[e].isPlaying&&(t[e].pause(),s[e]=!0);this._playingBeforeDisable=s}onRemove(){this.off()}addSlot(t,s){const n=this._slots;if(n[t])return null;const o=new e(this,t,s);return n[t]=o,o.autoPlay&&this.enabled&&this.entity.enabled&&o.play(),o}removeSlot(t){const s=this._slots;s[t]&&(s[t].stop(),delete s[t])}slot(t){return this._slots[t]}play(t){if(!this.enabled||!this.entity.enabled)return null;const s=this._slots[t];return s?s.play():null}pause(t){const s=this._slots;if(t){const e=s[t];if(!e)return;e.pause()}else for(const t in s)s[t].pause()}resume(t){const s=this._slots;if(t){const e=s[t];if(!e)return;e.isPaused&&e.resume()}else for(const t in s)s[t].resume()}stop(t){const s=this._slots;if(t){const e=s[t];if(!e)return;e.stop()}else for(const t in s)s[t].stop()}}export{n as SoundComponent};
